<html>
<head>
<title>Cointegration for Time Series Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列分析的协整</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cointegration-for-time-series-analysis-1d0a758a20f1?source=collection_archive---------1-----------------------#2020-02-10">https://medium.com/analytics-vidhya/cointegration-for-time-series-analysis-1d0a758a20f1?source=collection_archive---------1-----------------------#2020-02-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a617" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇帖子最初出现在<a class="ae jd" href="https://medium.com/ro-data-team-blog" rel="noopener"> Ro的数据团队博客</a>。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="6d4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">平稳性是时间序列建模的一个重要属性。问题是，在实践中，很少有现象实际上是静止不变的。诀窍是采用正确的技术将时间序列重新组织成一种稳定的形式。其中一种技术利用了一种叫做<em class="jl">协整</em>的统计特性。协整从两个或多个非平稳序列的线性组合中形成一个合成平稳序列。</p><p id="0557" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用模拟数据来展示R中协整背后的主要观点。Tsay [2005]，普法夫等人[2008]，以及普法夫和陶努斯[2007]的资料来源被用来放在一起进行以下演示，以及以下三个R包。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="067d" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">require</strong>(urca) <br/><strong class="jr hj">require</strong>(vars) <br/><strong class="jr hj">require</strong>(ggplot2)</span></pre><h1 id="e591" class="kb jw hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">背景</h1><p id="f59e" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">假设你有一组时间序列都遵循随机游走。你可以把协整看作是找出哪些序列倾向于“随机地走在一起”,以及哪些序列的分布(两个序列在每个时间步的差异)是稳定的。协整告诉你，虽然两个序列独立运动，但它们之间的平均距离保持相对恒定。</p><p id="56d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更正式的说法是，如果两个序列都是单位根非平稳的(1阶积分:<em class="jl"> I(1) </em>)，但存在一个单位根平稳的线性组合(0阶积分:<em class="jl"> I(0) </em>)。如果任何单个序列已经是平稳的，那么协整就是多余的，因为线性组合会着重强调平稳序列。</p><h2 id="dca2" class="jv jw hi bd kc ld le lf kg lg lh li kk iq lj lk ko iu ll lm ks iy ln lo kw lp bi translated">协整与相关性</h2><p id="29f6" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">虽然相关系数和协整都描述了变量之间的一些潜在关系，但这两个属性不是同义词。两个时间序列很有可能具有弱/强相关性，但具有强/弱协整性。</p><blockquote class="lq lr ls"><p id="791a" class="if ig jl ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated">强相关，无协整</p></blockquote><p id="6ffc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个系列明显相关，但它们之间的差异随时间而变化。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="d007" class="jv jw hi jr b fi jx jy l jz ka"># Strong correlation and no cointegration<br/>set.seed(1)<br/>y1 = cumsum(rnorm(150,0.5))<br/>y2 = cumsum(rnorm(150,1))<br/>Y &lt;- data.frame(cbind(y1,y2))</span><span id="2538" class="jv jw hi jr b fi lw jy l jz ka">ggplot(Y, aes(x=1:nrow(Y))) +<br/>  geom_line(aes(y= y1),colour = "red") +<br/>  geom_line(aes(y= y2),colour = "green") +<br/>  labs(title = "Correlation vs Cointegration") +<br/>  xlab(expression("Time")) +<br/>  ylab(expression("Y")) +<br/>  theme(plot.title = element_text(hjust = 0.5))<br/>cor(Y)</span></pre><figure class="jm jn jo jp fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es lx"><img src="../Images/5ecb19b22c63867e4225f6f552c5fca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YeeAZOQvhO-fUzwOezLD6Q.png"/></div></div></figure><blockquote class="lq lr ls"><p id="a3c3" class="if ig jl ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated">强相关，无协整</p></blockquote><p id="200a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个序列是完美的相关和协整的，因为两者之间的差异不会随着时间而改变。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="dbb9" class="jv jw hi jr b fi jx jy l jz ka"># Strong correlation and no cointegration<br/>y1 = sin(seq(1,100,1))<br/>y2 = 1.5+sin(seq(1,100,1))<br/>Y &lt;- data.frame(cbind(y1,y2))</span><span id="03ec" class="jv jw hi jr b fi lw jy l jz ka">ggplot(Y, aes(x=1:nrow(Y))) +<br/>  geom_line(aes(y= y1),colour = "red") +<br/>  geom_line(aes(y= y2),colour = "green") +<br/>  labs(title = "Correlation vs Cointegration") +<br/>  xlab(expression("Time")) +<br/>  ylab(expression("Y")) +<br/>  theme(plot.title = element_text(hjust = 0.5))<br/>cor(Y)</span></pre><figure class="jm jn jo jp fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mf"><img src="../Images/48696923f594594aef4ca5e9c826aa74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J2dQqHaMAf1iojgxdraa2Q.png"/></div></div></figure><blockquote class="lq lr ls"><p id="e038" class="if ig jl ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated">无相关性和强协整性</p></blockquote><p id="d43a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的基础上增加一个微小的相移可以消除所有的相关性，但仍然保持协整性。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="eb94" class="jv jw hi jr b fi jx jy l jz ka"># No correlation and strong cointegration<br/>y1 = sin(seq(1,100,1))<br/>y2 = 1.5+sin(seq(pi/2+1,pi/2+100,1))<br/>Y &lt;- data.frame(cbind(y1,y2))</span><span id="3ba9" class="jv jw hi jr b fi lw jy l jz ka">ggplot(Y, aes(x=1:nrow(Y))) +<br/>  geom_line(aes(y= y1),colour = "red") +<br/>  geom_line(aes(y= y2),colour = "green") +<br/>  labs(title = "Correlation vs Cointegration") +<br/>  xlab(expression("Time")) +<br/>  ylab(expression("Y")) +<br/>  theme(plot.title = element_text(hjust = 0.5))<br/>cor(Y) # correlation = -0.002733781</span></pre><figure class="jm jn jo jp fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mg"><img src="../Images/5cf26b1fb0a32afe3cc78ce4c0d62b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3hJAs2SDVZ2kT19Fa2kog.png"/></div></div></figure><h2 id="c1fb" class="jv jw hi bd kc ld le lf kg lg lh li kk iq lj lk ko iu ll lm ks iy ln lo kw lp bi translated">模拟数据的协整</h2><p id="5d17" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">下面的代码片段模拟了三个时间序列，它们共享相同的基本随机行走过程。该图显示，尽管是单独的随机行走，但这三个系列似乎共享一个共同的基本过程。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="b820" class="jv jw hi jr b fi jx jy l jz ka">iterations &lt;- 1000<br/>Y &lt;- setNames(as.data.frame(matrix(0, iterations, 4)), c("y", "y1", "y2", "y3"))<br/>set.seed(1)<br/>for (ii in 2:iterations) {<br/>  Y$y[ii] &lt;- y[ii-1] + rnorm(1)<br/>  Y$y1[ii] &lt;- Y$y1[ii-1] + (0.01*(Y$y[ii-1] - Y$y1[ii-1])) + rnorm(1)<br/>  Y$y2[ii] &lt;- Y$y2[ii-1] + (0.05*(Y$y[ii-1] - Y$y2[ii-1])) + rnorm(1)<br/>  Y$y3[ii] &lt;- Y$y3[ii-1] + (0.1*(Y$y[ii-1] - Y$y3[ii-1])) + rnorm(1)<br/>}<br/>cor(Y)<br/>#            y        y1        y2        y3<br/># y  1.0000000 0.4926226 0.9121291 0.9673797<br/># y1 0.4926226 1.0000000 0.5843223 0.5284070<br/># y2 0.9121291 0.5843223 1.0000000 0.9339683<br/># y3 0.9673797 0.5284070 0.9339683 1.0000000</span></pre><p id="09f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相关矩阵显示，具有较大协整系数(0.01、0.05和0.1)的序列与原始序列的相关性更强。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="2ad2" class="jv jw hi jr b fi jx jy l jz ka">ggplot(Y, aes(x=1:iterations)) +<br/>  geom_line(aes(y= y),colour = "black") +<br/>  geom_line(aes(y= y1),colour = "red") +<br/>  geom_line(aes(y= y2),colour = "green") +<br/>  geom_line(aes(y= y3),colour = "blue") +<br/>  labs(title = "Simulated Series with Shared Underlying Random Walk") + <br/>  xlab(expression("Time")) +<br/>  ylab(expression("Y")) +<br/>  theme(plot.title = element_text(hjust = 0.5), plot.legend = TRUE)</span></pre><figure class="jm jn jo jp fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mh"><img src="../Images/b1e7844688a0e968386e0cb809dd6404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wym8cZfm29kJek1tplsK6A.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">起始随机游走(黑色)，第一个协整序列(红色)，第二个协整序列(绿色)，第三个协整序列(蓝色)</figcaption></figure><p id="d1e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">方程中具有较高协整系数的时间序列更接近原始序列。尽管第一个系列(红色)的相关性较低，但似乎确实有某种潜在的力量将这两个系列保持在一定范围内。这种行为在绿色和蓝色系列中更加明显。</p><p id="6a1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将回顾检验协整的实际技术，而不仅仅是目测。</p><h1 id="498f" class="kb jw hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">协整检验</h1><h2 id="f20e" class="jv jw hi bd kc ld le lf kg lg lh li kk iq lj lk ko iu ll lm ks iy ln lo kw lp bi translated">恩格尔-格兰杰程序</h2><p id="0ffb" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">这是罗伯特·恩格尔和克莱夫·格兰杰在他们的开创性论文恩格尔和格兰杰[1987]中提出的检验协整的原始程序。这两个步骤很容易遵循，并且很好地描绘了协整背后的一般思想。其想法是首先验证单个序列确实是按照<em class="jl"> I(1) </em>(非平稳)顺序整合的。然后，我们使用标准OLS一个接一个地回归，并检查残差序列是否按照<em class="jl"> I(0) </em>(表明平稳性)的顺序进行积分。如果残差是平稳的，那么我们可以从OLS模型中提取系数，并使用它们来形成两个时间序列的平稳线性组合。</p><p id="34c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在前两个协整系列中运行这个。首先让我们使用流行的ADF测试来测试每个序列，以确认它们确实是非平稳的(存在单位根)。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="ba0f" class="jv jw hi jr b fi jx jy l jz ka">y1Adf &lt;- ur.df(Y$y1) <em class="jl">#ADF test: H0 of having a unit-root (nonstationary) <br/></em>y1Adf@cval<br/><strong class="jr hj">#       1pct  5pct 10pct<br/># tau1 -2.58 -1.95 -1.62</strong></span><span id="a65e" class="jv jw hi jr b fi lw jy l jz ka">y1Adf<strong class="jr hj">@</strong>teststat <em class="jl"># fail to reject null of unit-root<br/></em><strong class="jr hj">#                tau1<br/># statistic -1.609493</strong></span><span id="8aba" class="jv jw hi jr b fi lw jy l jz ka">y2Adf &lt;- ur.df(Y$y2) <br/>y2Adf@teststat <em class="jl"># fail to reject null of unit-root<br/></em><strong class="jr hj">#                 tau1<br/># statistic -0.3265977</strong></span></pre><p id="984b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述ADF检验证实该序列是非平稳的。接下来，我们使用OLS拟合线性模型，并检查残差的平稳性</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="f500" class="jv jw hi jr b fi jx jy l jz ka">m1 &lt;- lm(Y$y1 ~ Y$y2) <br/>m1<strong class="jr hj">$</strong>coefficients<br/><strong class="jr hj"># (Intercept)        Y$y2 <br/>#  -4.0986059   0.3059797</strong></span><span id="2c57" class="jv jw hi jr b fi lw jy l jz ka">wt &lt;- m1<strong class="jr hj">$</strong>residuals <br/>spreadAdf &lt;- ur.df(wt) <br/>spreadAdf<strong class="jr hj">@</strong>cval<br/><strong class="jr hj">#       1pct  5pct 10pct<br/># tau1 -2.58 -1.95 -1.62</strong></span><span id="7bd5" class="jv jw hi jr b fi lw jy l jz ka">spreadAdf<strong class="jr hj">@</strong>teststat <em class="jl"># reject H0 of unit-root (conclude it is stationary)<br/></em><strong class="jr hj"># tau1<br/># statistic -2.982549</strong></span></pre><p id="9ed0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分布(wₜ)的检验统计量小于所有三个置信水平的检验统计量。我们很乐意假设我们现在有一个平稳的序列来处理。因为我们无法拒绝平稳性的零假设，Engle-Granger检验表明存在协整关系。协整方程由下式给出:</p><figure class="jm jn jo jp fd ly er es paragraph-image"><div class="er es mm"><img src="../Images/e09c2d1759cb1d7c5a71e8e5a73f9279.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*IdPybsQztXqYopL6sEktww.png"/></div></figure><figure class="jm jn jo jp fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mn"><img src="../Images/2c3bfe8f93a3bcf13778ef1c5269b514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjX48lxUbwSqpETKDfh4Rg.png"/></div></div></figure><h2 id="e30c" class="jv jw hi bd kc ld le lf kg lg lh li kk iq lj lk ko iu ll lm ks iy ln lo kw lp bi translated">约翰森试验</h2><p id="f975" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">恩格尔-格兰杰程序有几个缺点。第一个是它不能同时测试多个系列之间的协整关系。此外，在y1上回归y2而不是在y2上回归y1(如我们上面所做的)将产生不同的协整向量。因此，选择哪一个序列回归另一个序列在某种程度上是任意的。另一个缺点是，它忽略了潜在的误差校正模型对传播序列的影响。</p><p id="63ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">方便的是，所有上述缺点都可以通过Johansen手术来解决。此程序估计VECM(向量误差修正模型)形式的协整VARMA( <em class="jl"> p </em>，<em class="jl"> q </em>)，用于xₜ.<em class="jl">k</em>不同序列之间的<em class="jl"> m </em>协整关系</p><figure class="jm jn jo jp fd ly er es paragraph-image"><div class="er es mo"><img src="../Images/605029b5f2de433d4c8fea4b0def1266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*NWiYIbZ9UF6yUrVo9wNzJg.png"/></div></figure><p id="52cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上图中，α <strong class="ih hj"> </strong>和β <strong class="ih hj"> </strong>都是<em class="jl"> k x m </em>矩阵，∆xₜ将一阶差分表示为∆xₜ=xₜxₜ₋₁，φI<strong class="ih hj"/>是AR系数，θj<strong class="ih hj"/>是MA系数。协整方程由β′x { t1 }定义，其中β包含<em class="jl"> m </em>协整向量的系数。</p><p id="1142" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">VECM表示法的另一个好处是，它能够在考虑协整关系的情况下生成预测。创建这些预测超出了本文的范围，但可能会在以后的文章中涉及。</p><p id="631e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Johansen检验对π<strong class="ih hj"/>矩阵进行特征值分解，并依次检验其秩<em class="jl"> r </em>以确定存在多少协整关系。r = 0的零假设意味着，如果我们不拒绝它，就不存在这样的关系。然后继续测试r ≤ j ∀j &lt; k，其中k是被测试的级数(我们不能有k个有效的协整关系)。如果我们只测试两个数列，那么这两个测试是r = 0和r = 1。</p><p id="f764" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特征值分解产生特征向量，其中对应于最大特征向量的分量用于协整系数β。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="fd48" class="jv jw hi jr b fi jx jy l jz ka">cot=ca.jo(Y[,c(2:4)],ecdet="const", type='trace', K=2, spec='transitory')</span><span id="43a1" class="jv jw hi jr b fi lw jy l jz ka">summary(cot)<br/># ###################### <br/># # Johansen-Procedure # <br/># ###################### <br/># <br/># Test type: trace statistic , without linear trend and constant in cointegration <br/># <br/># Eigenvalues (lambda):<br/># [1] 3.947760e-02 2.063349e-02 8.268313e-04 4.336809e-19<br/># <br/># Values of teststatistic and critical values of test:<br/># <br/>#           test 10pct  5pct  1pct<br/># r &lt;= 2 |  0.83  7.52  9.24 12.97<br/># r &lt;= 1 | 21.63 17.85 19.96 24.60<br/># r = 0  | 61.83 32.00 34.91 41.07<br/># <br/># Eigenvectors, normalised to first column:<br/># (These are the cointegration relations)<br/># <br/>#              y1.l1      y2.l1       y3.l1   constant<br/># y1.l1     1.000000  1.0000000   1.0000000  1.0000000<br/># y2.l1     2.918063 -1.0330340   0.1625347  0.2206172<br/># y3.l1    -3.830987  0.5674745   0.8981619  0.1276251<br/># constant -1.536007  2.8054993 -10.6323941 15.9087882<br/># <br/># Weights W:<br/># (This is the loading matrix)<br/># <br/>#              y1.l1        y2.l1         y3.l1     constant<br/># y1.d -0.0016638564 -0.020254936  0.0002125480 5.487152e-18<br/># y2.d -0.0111657363  0.003239633 -0.0001845491 1.099864e-18<br/># y3.d  0.0007776353 -0.005012261 -0.0010935382 3.262192e-18</span></pre><p id="1d64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看测试统计和临界值，我们看到我们没有拒绝r &lt;= 2 test but we can reject the r &lt;= 1 case at the 0.05 level of significance. Therefore, we can accept the alternate hypothesis that the rank of the matrix is r=2. This means that we can form a stationary series from a linear combination of just two out of the three series tested.</p><p id="1bff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">The eigenvectors corresponding to the largest eigenvalue (3.947760e-02) are [1, 2.918063, -3.830987, -1.536007], which can be found under column y1.l1 in the Eigenvector section . This leads to our cointegrating equation</p><figure class="jm jn jo jp fd ly er es paragraph-image"><div class="er es mp"><img src="../Images/39f63e48631b0a6a2c02d8dc0d426668.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*74z9X-0tk1uh8vnNYsRq5w.png"/></div></figure><p id="600f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">The ADF test also supports our resulting series being stationary.</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="512a" class="jv jw hi jr b fi jx jy l jz ka">xMat &lt;- t(data.matrix(cbind(Y[c(2:4)],ones)))<br/>beta &lt;- data.matrix(cot@V[,1])<br/>wt &lt;- t(beta) %*% (xMat) <br/># wt = Y$y1 + 2.918063*Y$y2 - 3.830987*Y$y3 - 1.536007</span><span id="ed2b" class="jv jw hi jr b fi lw jy l jz ka">plot(t(wt), type="l", main="Stationary Spread Series",<br/>     xlab="Time", ylab="Spread")</span><span id="6d9b" class="jv jw hi jr b fi lw jy l jz ka">wtAdf &lt;- ur.df(t(wt))<br/>wtAdf@cval<br/>#      1pct  5pct 10pct<br/># tau1 -2.58 -1.95 -1.62<br/>wtAdf@teststat # fail to reject null of unit-root<br/>#                tau1<br/># statistic -4.037032</span></pre><figure class="jm jn jo jp fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mq"><img src="../Images/972888bba37a98cba800c47a74bc57a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HLG_VTuzUfMopC4UHQHJ0w.png"/></div></div></figure><h1 id="944c" class="kb jw hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">References</h1><p id="8895" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">Robert F Engle and Clive WJ Granger. Co-integration and error correction: representation, estimation, and testing. <em class="jl">计量经济学:计量经济学学会杂志</em>，251–276页，1987。</p><p id="4756" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">伯恩哈德·普法夫和克朗伯格·伊姆·陶努斯。使用vars包。<em class="jl">克朗伯格:im Taunus </em>，2007年第2007页。伯恩哈德·普法夫等人的var、svar和svec模型:在r包Var中的实现。<em class="jl">统计学杂志</em></p><p id="e6b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jl">软件</em>，27(4):1–32，2008。蔡瑞诗。<em class="jl">金融时间序列分析</em>，第543卷。约翰·威利的儿子们，2005年。</p></div></div>    
</body>
</html>