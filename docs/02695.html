<html>
<head>
<title>Short Introduction to MQTT with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的MQTT简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/short-introduction-to-mqtt-with-python-e625c337c8f5?source=collection_archive---------5-----------------------#2019-12-29">https://medium.com/analytics-vidhya/short-introduction-to-mqtt-with-python-e625c337c8f5?source=collection_archive---------5-----------------------#2019-12-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="c492" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">物联网</h2><div class=""/><div class=""><h2 id="5c97" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">Python中的MQTT入门</h2></div><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="jl jm l"/></div></figure><p id="8d48" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">本月早些时候(2019年12月)，我有机会在ComparetheMarket.com主办的Python伦敦会议上发言。在考虑话题的时候，我决定谈论一些我作为业余爱好做的事情，而不是谈论一些与工作相关的事情。将我的家变成智能家居。</p><p id="c6ab" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你们中的许多人可能听说过与物联网相关的术语MQTT。MQTT是一个发布/订阅协议，适用于没有大量计算和网络连接的小型设备。MQTT代表MQ遥测传输，以IBM MQ服务命名。这已经成为机器对机器通信的标准。我不会深入讨论该协议的细节，但会向您展示一些如何在Python中使用它的例子。</p><h1 id="09f8" class="kj kk hi bd kl km kn ko kp kq kr ks kt ix ku iy kv ja kw jb kx jd ky je kz la bi translated">MQTT概述</h1><p id="e500" class="pw-post-body-paragraph jn jo hi jp b jq lb is js jt lc iv jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">正如所料，MQTT需要两种类型的组件:代理和客户机。代理负责消息的排队和分发；而客户端发布和使用消息。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/97e3a259e871f7d78668154207f82253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zjMaBIjkjFMpV0Ak"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">图片来自<a class="ae lr" href="https://randomnerdtutorials.com/what-is-mqtt-and-how-it-works/" rel="noopener ugc nofollow" target="_blank">https://randomnerdtutorials . com/what-is-mqtt-and-how-it-works/</a></figcaption></figure><p id="fcb8" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">尽管与其他著名的发布-订阅系统有一些不同。首先，MQTT是一个非常轻量级的协议。最小的消息是2字节，包括协议头。当设备之间的网络带宽较低时，这一点非常重要。其次，该协议可以通过任何网络系统使用。不一定要通过TCP/IP。您可以使用UDP或任何其他自定义传输层。MQTT定义了标准和协议，而不是实现。</p><p id="e2a6" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">还有两个特性或功能符合轻量级设备的需求:支持主题层次结构和短暂主题。这些将在稍后的演示中探讨。</p><h1 id="9663" class="kj kk hi bd kl km kn ko kp kq kr ks kt ix ku iy kv ja kw jb kx jd ky je kz la bi translated">入门:设置代理</h1><p id="72f2" class="pw-post-body-paragraph jn jo hi jp b jq lb is js jt lc iv jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">Linux上最流行的MQTT代理之一是<a class="ae lr" href="https://mosquitto.org/" rel="noopener ugc nofollow" target="_blank"> Mosquitto </a>。可以用MacOS上的<code class="du ls lt lu lv b">brew</code>或者Ubuntu上的<code class="du ls lt lu lv b">apt-get</code>。默认情况下，它监听<code class="du ls lt lu lv b">localhost</code>上的1883端口。一旦运行它，您将看到:</p><pre class="jg jh ji jj fd lw lv lx ly aw lz bi"><span id="5d27" class="ma kk hi lv b fi mb mc l md me">Config loaded from /etc/mosquitto/mosquitto.conf.                                                                          Opening ipv4 listen socket on port 1883.                                                                                   Opening ipv6 listen socket on port 1883.</span></pre><p id="24d1" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">由于MQTT和Mosquitto代理非常轻量级，所以我在我的树莓Pi 1B模型上运行它，没有出现任何性能问题。</p><h1 id="3471" class="kj kk hi bd kl km kn ko kp kq kr ks kt ix ku iy kv ja kw jb kx jd ky je kz la bi translated">设置Python</h1><p id="8b1d" class="pw-post-body-paragraph jn jo hi jp b jq lb is js jt lc iv jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated"><code class="du ls lt lu lv b"><a class="ae lr" href="https://pypi.org/project/paho-mqtt/" rel="noopener ugc nofollow" target="_blank">paho-mqtt</a></code>是一个简单易用且功能完善的Python库，用于使用MQTT协议进行通信。在3或4行Python代码中，您可以设置一个基本的发布者。</p><pre class="jg jh ji jj fd lw lv lx ly aw lz bi"><span id="e0f5" class="ma kk hi lv b fi mb mc l md me">import paho.mqtt.client as mqtt</span><span id="d914" class="ma kk hi lv b fi mf mc l md me">client = mqtt.Client()<br/>client.connect("localhost", 1883, 60)<br/>topic = 'my_topic'<br/>client.publish(topic, payload='on')</span></pre><p id="a69c" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">仅仅推送消息是不够的，让我们看看订阅者。</p><pre class="jg jh ji jj fd lw lv lx ly aw lz bi"><span id="daab" class="ma kk hi lv b fi mb mc l md me">import paho.mqtt.client as mqtt</span><span id="adac" class="ma kk hi lv b fi mf mc l md me"># The callback for when the client receives a CONNACK response from the server.<br/>def on_connect(client, userdata, flags, rc):<br/>    print(f"Connected with result code {str(rc)}")</span><span id="edfa" class="ma kk hi lv b fi mf mc l md me"># The callback for when a PUBLISH message is received from the server.<br/>def on_message(client, userdata, msg):<br/>    print(f"{msg.topic} {str(msg.payload)}")</span><span id="84d8" class="ma kk hi lv b fi mf mc l md me">if __name__ == '__main__':<br/>    client = mqtt.Client()<br/>    client.on_connect = on_connect<br/>    client.on_message = on_message</span><span id="3d10" class="ma kk hi lv b fi mf mc l md me">    client.connect("localhost", 1883, 60)</span><span id="e4ff" class="ma kk hi lv b fi mf mc l md me">    topic = 'my_topic'<br/>    client.subscribe(topic)</span><span id="12a5" class="ma kk hi lv b fi mf mc l md me">    client.loop_forever()</span></pre><p id="d01c" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有两个基本功能。当客户端成功连接到代理时，调用<code class="du ls lt lu lv b">on_connect</code>。<code class="du ls lt lu lv b">on_message</code>在代理向客户端推送消息时被调用。客户端将这些注册为回调方法，然后连接到代理。一旦连接上，我们就订阅感兴趣的话题，开始一个等待消息的无限循环。这个客户机目前只是打印主题名和收到的消息。任何进一步的处理都可以添加到<code class="du ls lt lu lv b">on_message</code>方法中。</p><p id="a895" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要对此进行测试，请确保Mosquitto broker正在运行。首先启动订阅服务器，然后运行发布服务器。一旦发布者运行，它将向主题推送一条消息，订阅者将打印该消息。你可以在你的电脑或类似Raspberry Pi的设备上运行。</p><h1 id="25db" class="kj kk hi bd kl km kn ko kp kq kr ks kt ix ku iy kv ja kw jb kx jd ky je kz la bi translated">短暂的话题</h1><p id="d9b9" class="pw-post-body-paragraph jn jo hi jp b jq lb is js jt lc iv jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">MQTT broker规范提到，只有当至少有一个订阅者在监听时，消息才会被持久化。如果在消息被发送到代理时没有订阅者在监听，那么代理将丢弃这个消息。我们可以使用上面的代码看到这一点，但是我们需要改变执行的顺序。</p><p id="2668" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">代理运行时，确保发布者和订阅者都已停止。首先运行发布服务器，然后启动订阅服务器。希望您不会看到订户打印的任何输出消息。但是，如果您在订阅者侦听时再次运行发布者，您将再次看到您的消息。这表明如果没有订阅者在侦听，MQTT broker会丢弃消息。您也可以对多个订户进行尝试。运行订阅者的一个实例，然后发布一条消息，然后启动订阅者的第二个实例。第一个订户将打印消息，但第二个订户不会。</p><p id="48db" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这实际上非常有用，因为传感器等设备可以随着时间的推移发送大量消息。如果没有用户，那么没有必要存储<em class="mg">所有的</em>消息，然后在连接时让用户过载。在这些情况下，很可能需要忽略旧的消息，因为新的测量更准确和完整。</p><h1 id="5208" class="kj kk hi bd kl km kn ko kp kq kr ks kt ix ku iy kv ja kw jb kx jd ky je kz la bi translated">保留消息</h1><p id="7d7b" class="pw-post-body-paragraph jn jo hi jp b jq lb is js jt lc iv jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">考虑到设备和代理之间的低连接性或高连接丢失率的用例，一个很好的功能是能够调用最新的传感器值(或最后一条消息)，以便我们可以恢复任何所需的状态。为此，代理允许保留最后一条消息供任何新订户使用。为了保留消息，我们需要向<code class="du ls lt lu lv b">publish</code>调用添加一个标志。</p><pre class="jg jh ji jj fd lw lv lx ly aw lz bi"><span id="1e41" class="ma kk hi lv b fi mb mc l md me">client.publish(topic, payload='on', retain=True)</span></pre><p id="aac7" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要尝试这样做，请停止所有发布者和订阅者，并保持代理运行。将<code class="du ls lt lu lv b">retain</code>标志设置为<code class="du ls lt lu lv b">True</code>，运行发布程序一次。启动订阅服务器；这应该会打印出您的消息，与我们之前的演示步骤不同。您甚至可以停止订阅者并重新运行它(不运行发布者)，这将再次打印出相同的消息。</p><p id="4032" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">更进一步，在订户运行时发送多条消息。然后启动订阅者的第二个实例，注意它只使用和打印最后发送的消息。</p><h1 id="b9cb" class="kj kk hi bd kl km kn ko kp kq kr ks kt ix ku iy kv ja kw jb kx jd ky je kz la bi translated">主题层次结构</h1><p id="6a20" class="pw-post-body-paragraph jn jo hi jp b jq lb is js jt lc iv jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">大多数可用的消息传递系统都支持单一级别的主题。例如，Apache Kafka的主题都在同一个顶级。它没有副主题的概念。即使用户像<code class="du ls lt lu lv b">level1-level2-level3</code>一样命名他们的主题，这也是一个Kafka无法解释为层次的主题的单一名称。MQTT在协议级别支持这样的级别。每个级别由一个正斜杠<code class="du ls lt lu lv b">/</code>分隔。</p><p id="e7a3" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">用智能家居设备用例来说明这一点可能是最好的。修改上面的发布者和订阅者以使用名为<code class="du ls lt lu lv b">home/living_room/light</code>的主题。然后像以前一样启动你的订阅者并发布一条关于这个主题的消息。现在让您的订阅者保持运行，并发布一条消息到一个新主题<code class="du ls lt lu lv b">home/living_room/tv</code>。不出所料，订阅者打印了一条关于<code class="du ls lt lu lv b">home/living_room/light</code>主题的消息，但没有打印出<code class="du ls lt lu lv b">home/living_room/tv</code>主题的消息。</p><p id="9a81" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以它的行为和卡夫卡或其他任何信息系统一样。但是让我们来看一个有趣的例子。</p><p id="1ef6" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">启动订阅者，听<code class="du ls lt lu lv b">home/living_room/+</code>话题。对，就是名字末尾的一个<code class="du ls lt lu lv b">+</code>。然后就以下话题发消息(不分先后):<code class="du ls lt lu lv b">home/living_room/light</code>和<code class="du ls lt lu lv b">home/living_room/tv</code>。订户将打印出两个主题的消息。<strong class="jp hs"/><code class="du ls lt lu lv b"><strong class="jp hs">+</strong></code><strong class="jp hs">是MQTT </strong>中单个级别的通配符。</p><p id="3cf2" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">同样可以订阅<code class="du ls lt lu lv b">home/+/light</code>，发布消息到主题:<code class="du ls lt lu lv b">home/living_room/light</code>和<code class="du ls lt lu lv b">home/bedroom/light</code>。但是，该用户不会从<code class="du ls lt lu lv b">home/living_room/tv</code>开始消费。</p><p id="09e1" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，我们可以通过房间或所有房间的设备类型来收听来自设备的消息。如果你想听来自<strong class="jp hs">所有</strong>主题的消息，而不考虑层级，该怎么办？</p><p id="cc40" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">只需订阅<code class="du ls lt lu lv b">#</code>话题。这将消耗来自所有主题的消息。这对于发现新设备或调试和故障排除非常有用。这方面的一个例子是<a class="ae lr" href="https://www.home-assistant.io/docs/mqtt/discovery/" rel="noopener ugc nofollow" target="_blank">家庭助理MQTT发现特性</a>，它通过模板主题名称<code class="du ls lt lu lv b">&lt;discovery_prefix&gt;/&lt;component&gt;/[&lt;node_id&gt;/]&lt;object_id&gt;/config</code>识别和配置设备。您可以看到这些级别如何定义一个层次结构，该层次结构可以轻松地允许用户监听特定的组件类型或特定的节点和对象。</p><p id="f332" class="pw-post-body-paragraph jn jo hi jp b jq jr is js jt ju iv jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我希望这是一个有用的介绍，您可以在下面的Github库中找到代码:</p><div class="mh mi ez fb mj mk"><a href="https://github.com/atharvai/mqtt_demo_python" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab dw"><div class="mm ab mn cl cj mo"><h2 class="bd hs fi z dy mp ea eb mq ed ef hr bi translated">atharvai/mqtt_demo_python</h2><div class="mr l"><h3 class="bd b fi z dy mp ea eb mq ed ef dx translated">通过在GitHub上创建一个帐户，为atharvai/mqtt_demo_python开发做贡献。</h3></div><div class="ms l"><p class="bd b fp z dy mp ea eb mq ed ef dx translated">github.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my ll mk"/></div></div></a></div></div></div>    
</body>
</html>