<html>
<head>
<title>Custom Rate Limiting in GoLang using Redis with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在GoLang中使用Redis和Docker进行自定义速率限制</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/custom-rate-limiting-in-golang-using-redis-with-docker-e4a7be96f7dc?source=collection_archive---------7-----------------------#2020-08-29">https://medium.com/analytics-vidhya/custom-rate-limiting-in-golang-using-redis-with-docker-e4a7be96f7dc?source=collection_archive---------7-----------------------#2020-08-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/75fd26fd1de46e241eff31a3bad5ad8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VCo0evGB6OGkfZCz41Od3Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">《让魔法开始》</strong></figcaption></figure><h1 id="a7c9" class="iv iw hi bd iu ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="bcb8" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">世界正朝着面向微服务的系统发展。防止web服务受到DOS(拒绝服务)等攻击非常重要。速率限制通常是作为服务的防御措施而设置的。保护服务免受有意或无意的过度使用。它还有助于以公平的方式确保服务对所有客户端的可用性。</p><p id="9b4d" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">而这种能力可以很容易地使用反向代理服务器与应用程序集成。通常，反向代理服务器会根据客户端访问服务的次数进行速率限制。但是，在某些情况下，您可能希望基于其他属性启用速率限制。例如，您可能希望根据客户机从数据库中请求的记录数量来限制客户机的速率。因此，了解如何在应用程序中扩展这种能力始终是一项附加任务。</p><p id="ade7" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">让我们试着创建一个速率限制的自定义实现。</p><h1 id="cfba" class="iv iw hi bd iu ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">先决条件</h1><p id="25fc" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">对…有相当的了解:</p><ul class=""><li id="1a40" class="kv kw hi ju b jv kq jz kr kd kx kh ky kl kz kp la lb lc ld bi translated">戈朗</li><li id="c656" class="kv kw hi ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated"><a class="ae lj" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="8e1e" class="kv kw hi ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">Redis —用于缓存IP到count的映射</li></ul><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/0feeff6ee24520487c5c33c9234e4927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gv-tmyg2fra-M-J_XBcKjw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">知识只能是自愿的，不能是强制的。—戴夫·斯诺登</figcaption></figure><h1 id="7cf0" class="iv iw hi bd iu ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">概念</h1><p id="fa2e" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">我们将使用Redis进行记录的内存缓存。这个想法是为带有定制请求过滤器的服务构建一个中间件。我们将拦截每个请求，并维护一个缓存，记录客户端点击服务的次数。该缓存将按分钟维护。如果客户端在一分钟内访问服务的次数超过了允许的限制，我们将拒绝该请求。</p><h2 id="3614" class="lp iw hi bd iu lq lr ls ja lt lu lv je kd lw lx ji kh ly lz jm kl ma mb jq mc bi translated">中间件</h2><p id="e89a" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">中间件(通常)是一些小代码，它们接受一个请求，对它做一些事情，然后将它传递给另一个中间件或最终的处理程序。中间件的一些常见用例是请求日志、头操作或<code class="du md me mf mg b">ResponseWriter</code>劫持。</p><h1 id="3455" class="iv iw hi bd iu ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">设置</h1><p id="1dcc" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">我们将在本地加速Redis容器以进行内存缓存。假设您已经建立了一个docker客户端。让我们把集装箱拿上来。在终端或等效工具中运行以下命令。</p><pre class="ll lm ln lo fd mh mg mi mj aw mk bi"><span id="67ae" class="lp iw hi mg b fi ml mm l mn mo">docker run -d — name redis-test -p 6379:6379 redis</span></pre><p id="a481" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">使用Golang中的<code class="du md me mf mg b">mux</code>库创建端点。</p><pre class="ll lm ln lo fd mh mg mi mj aw mk bi"><span id="0a65" class="lp iw hi mg b fi ml mm l mn mo">go get -v github.com/gorilla/mux</span></pre><p id="5d51" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">获取Redis交互的<code class="du md me mf mg b">redigo</code>库。</p><pre class="ll lm ln lo fd mh mg mi mj aw mk bi"><span id="c2b0" class="lp iw hi mg b fi ml mm l mn mo">go get -v github.com/gomodule/redigo/redis</span></pre><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/6b42157e45148f989405615665188aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25WCk4mNQLLebdnb58e_5A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">“顺应自然的步伐。她的秘诀是耐心。”—拉尔夫·瓦尔多·爱默生</strong></figcaption></figure><h1 id="d92f" class="iv iw hi bd iu ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">履行</h1><h2 id="0af0" class="lp iw hi bd iu lq lr ls ja lt lu lv je kd lw lx ji kh ly lz jm kl ma mb jq mc bi translated">为Redis连接池创建单一客户端</h2><p id="38d2" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">我们需要创建一个单独的客户端，它将从Redis连接池中返回一个连接。连接池有助于降低过度使用资源的风险。这些参数可以根据系统能力进行配置。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="4fe4" class="lp iw hi bd iu lq lr ls ja lt lu lv je kd lw lx ji kh ly lz jm kl ma mb jq mc bi translated">限制请求速率的中间件</h2><p id="2cfd" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">我们将创建一个预请求过滤器，在请求到达最终处理程序之前拦截它。为了便于使用，我们将实现一个IP来限制计数率。</p><p id="89aa" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">第一步是从请求中提取IP地址。我们需要对每个请求分时段。背后的想法是，我们希望根据键是否属于特定的时间段来增加键的计数器。</p><p id="a0f8" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我们将每分钟维护一次铲斗。这也有助于我们轻松删除密钥。参考<code class="du md me mf mg b">GetKey</code>方法理解实现。</p><p id="0f14" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">Redis不会自行删除密钥，这意味着没有与密钥相关联的默认TTL。一旦密钥被创建，它们将永远存在。我们需要为密钥显式设置一个TTL。</p><p id="2ad3" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">因此，本质上，一旦我们得到一个新的请求，我们将检查缓存中是否存在该关键字，如果是，我们将递增该关键字的计数器，否则我们将把该关键字添加到缓存中。此外，我们验证计数器是否与阈值匹配，如果匹配，将使请求失败。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/cfaef23c0c319763a9b44fc863854bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ExDjB-V9jd36jAyPpvc7g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">“我们用照片作为返程票，回到那个已经逝去的时刻。”</strong></figcaption></figure><h2 id="7a83" class="lp iw hi bd iu lq lr ls ja lt lu lv je kd lw lx ji kh ly lz jm kl ma mb jq mc bi translated">为端点创建路由</h2><p id="babe" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">最后一件事是创建一个服务端点，并为路由器配置中间件。我们将有一个简单的测试端点，我们将其命名为<code class="du md me mf mg b">ping</code>。我们需要配置<code class="du md me mf mg b">router</code>来使用中间件。本质上，存在两种中间件变体，即预请求和预响应过滤器。相同性质的中间件按照它们被配置的顺序执行。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h1 id="64e2" class="iv iw hi bd iu ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">最终代码</h1><p id="8e0c" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">这是完整的代码。一定要试一试。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/48fde847465edc09441847b3f3eaaf64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ahe1hEswKhdblpMl-wHXDw.jpeg"/></div></div></figure><h1 id="896e" class="iv iw hi bd iu ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">非常感谢您的阅读</h1><p id="2214" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">我希望这篇文章对你有所帮助。<br/>快乐编码！！！</p></div></div>    
</body>
</html>