<html>
<head>
<title>Geometric Intuition OF Logistic Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归的几何直观</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/geometric-intuition-of-logistic-regression-2e2b57781743?source=collection_archive---------0-----------------------#2019-06-07">https://medium.com/analytics-vidhya/geometric-intuition-of-logistic-regression-2e2b57781743?source=collection_archive---------0-----------------------#2019-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d377" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是逻辑回归:</strong></p><p id="a5cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是机器学习中使用的多类分类技术，用于预测类标签，即Yi，s，其中Yi属于某个类，但不是真实值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/b4fefaf46c51ff0f192b795c8d08f5b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*l4vdZRsfT6w2n1ej"/></div></figure><p id="5531" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们几何理解:</strong></p><p id="056a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">假设</strong>:求解之前最大的假设是我们的数据是线性可分或者几乎线性可分的。现在我们有两类点，即正点和负点。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jl"><img src="../Images/763ebcc45abb5e1d6a94b6e3e5ed2bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/0*ScIom1FMC4yMLRts"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jm"><img src="../Images/4bb7d5a31307720b6b249e8823aa1d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrKiD_F58dk_JEdcKzKRWg.png"/></div></div></figure><p id="be59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，我们有:<strong class="ih hj"> W </strong>垂直于平面，Pi(𝜋)平面</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jr"><img src="../Images/8f502bdb1564b5d85eb95b82a2541f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QAZN59L1IZyf7Gb-pn3yg.png"/></div></div></figure><p id="d887" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以平面的方程将是:<strong class="ih hj"> W(转置)X+b=0 </strong>其中<strong class="ih hj"> b </strong>是标量</p><p id="b82f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而<strong class="ih hj"> </strong>如果我们让平面通过原点:<strong class="ih hj"> W(转置)X=0 </strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es js"><img src="../Images/1454e61b6be8d73a96b4385083eef362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmumN1XbpLPsWVLVmxx1LQ.png"/></div></div></figure><p id="57a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么现在让我们给定数据集(<strong class="ih hj"> Dn) </strong>有正负点。</p><p id="d55a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">逻辑回归中的任务是:</strong>找出<strong class="ih hj"> W </strong>和<strong class="ih hj"> b </strong>找出一个平面，使得它分离正负点，即我们必须找到(𝜋).</p><p id="b4b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，在上面的图像_1中，我们可以找出从任意点到Pi(𝜋).平面的距离我们还假设W是一个单位向量，垂直于平面。</p><p id="d8e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在通过下图看到有趣的部分，即如果我们计算:</p><p id="7684" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1正点到平面<strong class="ih hj"> ( </strong> 𝜋 <strong class="ih hj"> ) </strong>的距离为正，即<strong class="ih hj"> di=W(转置)&gt; 0 </strong>因为(<strong class="ih hj"> W </strong>和X <strong class="ih hj"> i </strong>在同一侧)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jt"><img src="../Images/50e47e543c2eea1a0750c2cf07fa01ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*2Y9c-MqAgcEISXsDmx-ndw.png"/></div></figure><p id="e034" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在逻辑部分来了:</strong>所以我们的分类器说！</p><p id="7f97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<strong class="ih hj"> W(转置)Xi &gt; 0 </strong>，那么<strong class="ih hj"> Yi=+1 </strong>和</p><p id="4cc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<strong class="ih hj"> W(转置)&lt; 0 </strong>则<strong class="ih hj"> Yi=-1 </strong></p><p id="2847" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们来看不同的案例:</p><p id="070f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况1:对于阳性点:</strong></p><p id="4e71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">l</strong>et<strong class="ih hj">pi(</strong>𝜋<strong class="ih hj">)</strong>通过原点。</p><p id="5e2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在如果<strong class="ih hj">易</strong>为正即(+1)而<strong class="ih hj"> W(转置)&gt; 0 →(那么</strong>我们的量词说！)<strong class="ih hj">现在</strong>如果</p><p id="f896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(<strong class="ih hj">易* </strong> <strong class="ih hj"> W(转置)&gt; 0 </strong>和<strong class="ih hj">易</strong>为正则<strong class="ih hj"> W </strong>为正确分类正点。</p><p id="322b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况2:针对负积分:</strong></p><p id="b716" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让<strong class="ih hj">圆周率(</strong> 𝜋 <strong class="ih hj"> ) </strong>通过原点</p><p id="6adb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<strong class="ih hj">易</strong>是否定的，即(-1)<strong class="ih hj">W(转置)&lt; 0 ( </strong>我们的量词说！)</p><p id="3224" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在</strong>如果:(<strong class="ih hj">伊*W(转置)&gt; 0 </strong>和<strong class="ih hj">伊</strong>为负</p><p id="0180" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为(-)*(-)=(+)那么<strong class="ih hj"> W </strong>就是对负分的正确分类。</p><p id="6344" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">观察</strong>:从上面的逻辑部分来看是:正反两面分！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ju"><img src="../Images/80866cc1126d4528adae0ecd659680e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnBWJzsTCA93fDcyXbE6kQ.png"/></div></div></figure><p id="3021" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果(<strong class="ih hj"> Yi* </strong> <strong class="ih hj"> W(转置)&gt; 0那么L.R </strong>模型是正确分类了点Xi，s <strong class="ih hj"> …… </strong></p><p id="7533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在以同样的方式对负点进行如下处理:</p><p id="18d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况3: </strong>如果Yi是正的，即(+1)<strong class="ih hj">W(转置)】&lt; 0 </strong>那么<strong class="ih hj"> L.R </strong>就是说它是负类:</p><p id="ef34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后(<strong class="ih hj">易* </strong> <strong class="ih hj"> W(转置)&lt; 0即错过归类点。</strong></p><p id="3044" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况4: </strong>如果Yi为负，即(-1)<strong class="ih hj">W(转置)】&gt; 0 </strong>那么<strong class="ih hj"> L.R </strong>表示它是正类:</p><p id="38fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后(<strong class="ih hj">易* </strong> <strong class="ih hj"> W(转置)&lt; 0即错过归类点。</strong></p><p id="26a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">观察</strong>:从上面逻辑部分是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jv"><img src="../Images/5b7481246d6551b5d5babb5f465f4702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBqFGMbL7R03yB9kvHV4kA.png"/></div></div></figure><p id="c6f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于正负两点:</p><p id="2c80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果(<strong class="ih hj">易* </strong> <strong class="ih hj"> W(转置)&lt; 0)那么L.R模型是不正确地分类了点，s. </strong></p><p id="538f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一天结束时，我们希望我们的分类器V.good，即最小化错误分类的数量或最大化正确分类的点的数量。也就是说，我们希望尽可能多的点:</p><p id="25a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(【易*】<strong class="ih hj">)W(转置)&gt; 0 </strong></p><p id="1ee1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">即:W*=arg max(w)(i=1到n):(易* W(转置)……..</strong>(优化问题)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jw"><img src="../Images/d26cfda8feda83996bb4cdf0ac4b13cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f4BZ_DQn7zBPpWQhZXiTBw.png"/></div></div></figure><p id="aa90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里在上面的方程中<strong class="ih hj"/>和<strong class="ih hj">易</strong>是固定的来自<strong class="ih hj">(Dtrain)</strong>现在我们必须在这里计算<strong class="ih hj"> W </strong>变量，所以我们这里的优化问题是找到W*(最优W)最大化:</p><p id="a172" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在通过理解函数我们得到(<strong class="ih hj">易* </strong> <strong class="ih hj"> W(转置))</strong>是有符号距离。现在，让我们假设看下图:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jx"><img src="../Images/0b127c26164e07c7e9079c4e7716a377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ez1_d5cgljtF-mJdFSCjmg.png"/></div></div></figure><p id="01be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上图观察:</p><p id="58c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设10个点与Pi-one(𝜋1平面的距离相等，与Pi-one(𝜋1):平面的距离为X 100个单位</p><p id="bba6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">情况1:现在如果我们选择W1和Pi-one(𝜋1)作为我们的分隔符</p><p id="3e8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后<strong class="ih hj"> (i=1到n):(Yi* W1(转置)=</strong>5+5–100 =-90<strong class="ih hj">，</strong>这里我们试图最大化符号距离。</p><p id="d6b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">情况2:现在如果我们选择W2和Pi-two(^2)作为我们的分隔符</p><p id="2929" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后<strong class="ih hj"> (i=1到n): </strong> ( <strong class="ih hj">易* </strong> <strong class="ih hj"> W2(转置)=</strong>1+2+3+4+5-1-2-3-4–5+1 = 1</p><p id="0ec9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在根据我们的目标，我们将选择<strong class="ih hj"> Pi-two( </strong> 𝜋 <strong class="ih hj"> 2) </strong>作为我们的分类器。但是如果我们直觉地认为<strong class="ih hj">π-2(</strong>𝜋<strong class="ih hj">2)</strong>是可怕的分类器，即只有一个点被正确分类。</p><p id="ce37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在Pi-one(𝜋1)=(10/11)=0.909的准确度</strong></p><p id="5f98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">和Pi-two(𝜋2)=(6/11的精度)=0.545 </strong></p><p id="4b71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，作为分类器，对符号距离的最大和的精度<strong class="ih hj">π-2(</strong>𝜋<strong class="ih hj">2)</strong>比<strong class="ih hj">π-1(</strong>𝜋<strong class="ih hj">1)</strong>。</p><p id="44e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为在<strong class="ih hj"> W1、</strong>方向上距离<strong class="ih hj">pi-one(</strong>𝜋<strong class="ih hj">1)</strong>100个单位距离的极值点，即单个极值/异常点正在改变我们的模型。因此，符号距离的最大和会受到异常值的影响。</p><p id="4c32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们要通过被称为<strong class="ih hj"> Squshing的<strong class="ih hj"> </strong>技巧来修改<strong class="ih hj"> W*=(arg max(w)(i=1到n):(Yi* W(转置))</strong>。</strong></p><h1 id="110f" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><em class="kw">挤压→ </em></h1><p id="2660" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">因此，我们不使用简单的符号距离，而是使用:如果符号距离很小:按原样使用。如果有符号的距离很大:使它成为一个小值。所以我们想要一个函数:当它的值很小时:线性增加。当它的值变大时:轻敲它。现在，我们有一个这样的函数是<strong class="ih hj"> SIGMOID函数</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lc"><img src="../Images/eeeecd7675cfd5de529f1bdabf631031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHWL_71qml0kP_Imyx4zBg.png"/></div></div></figure><p id="6bed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们对W*应用Sigmoid函数，我们将得到:</p><p id="1771" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">W*= <strong class="ih hj"> (arg max(w)(i=1到n):1/1+(exp(-(易* W(转置)))。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ld"><img src="../Images/92405021101946d8f4c73da21a243976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8HXTVZQHMhLJnpGcu1_bg.png"/></div></div></figure><p id="dba6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，上述函数将较少受到异常值的影响。</p><p id="7d51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们知道了<strong class="ih hj">单调函数</strong>的性质:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es le"><img src="../Images/399e5d2c7d1f0a9f3cf0516cd46ad164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-Kpj0jrEOXxApmnniyw-Q.png"/></div></div></figure><p id="5279" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果x增加，则G(x)增加，并且<strong class="ih hj">如果x1 &gt; x2，则G(x1) &gt; G(x2) </strong></p><p id="4e90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果G(x)是单调的，那么…..</p><p id="9649" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">1&gt;arg min F(x)= arg min G(F(x))………</strong></p><p id="b987" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">2&gt;arg maxf(x)= arg max G(F(x))……</strong></p><p id="1896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在— -&gt;我们知道log是单调函数，log(1/x)=-log(x)，现在如果我们暗示log在W*上，那么W*将是:</p><p id="c370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">W*=(arg max(w)(i=1到n):log(1/1+(exp(-(易* W(转置)Xi))))</p><p id="5236" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">W*=(arg max(w)(i=1到n): -log(1+(exp(-(易* W(转置)Xi))))</p><p id="4b5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> W*=(arg min(w)(i=1到n): log(1+(exp(-(易* W(转置))))……(等式1) </strong></p><p id="eb12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果上面的等式中没有1，那么:</p><p id="267d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">W*=(arg min(w)(i=1到n): log((exp(-(易* W(转置)Xi))))</p><p id="4c37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">W*=(arg min(w)(i=1到n): -(易* W(转置))</p><p id="4c25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> W*=(arg max(w)(i=1到n): (Yi* W(转置)……(等式2)即有符号距离的和</strong></p><p id="dfa6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在使用exp和log的具有小变化的逻辑回归的优化问题中，我们具有带符号距离的和，其具有巨大的异常值问题，因此，这就是为什么我们将不使用<strong class="ih hj"> …(等式2) </strong>来优化问题。</p><p id="d954" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用概率方法的W*的其他公式如下，我们在这里直接写出来只是为了关联:</p><p id="43af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> W*=arg min(w)(i=1到n):-{ Yi * log(P(I))+(1-Yi)* log(1-P(I))}</strong></p><p id="f945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将这个等式与<strong class="ih hj"> ……(等式1)</strong>相关联</p><p id="d336" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">然后P(I)</strong><strong class="ih hj">s形(W(转置)Xi)。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lf"><img src="../Images/89160b2b4d2629408551c9e67ccaa7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DRcOhcrNwvaJrKuCdz21yg.png"/></div></div></figure><p id="9754" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在从<strong class="ih hj"> ……(等式1) </strong>我们得到<strong class="ih hj"> W*最优，W </strong>也被称为<strong class="ih hj">权重向量</strong></p><p id="5d60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">即</strong> W属于Rd = &lt; w1，w2，w3……..wd &gt;，d =特征/尺寸的数量。</p><p id="1255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在L.R中，我们将权重与每个特征相关联:</p><p id="fbe3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果Wi为正，则Xqi为高Wi*Xqi将为高(i:1至d (Wi*Xqi))然后sigmoid(W(转置)Xi)也为高，即P(Yq =正)将为高。</p><p id="def7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">以类似的方式:</strong></p><p id="c207" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果Wi为负，则Xqi为高Wi*Xqi将为低(i:1至d (Wi*Xqi))然后sigmoid(W(转置)Xi)也将为低，即P(Yq =正)将为低P(Yq =负)将为高。</p><h2 id="2cf1" class="lg jz hi bd ka lh li lj ke lk ll lm ki iq ln lo km iu lp lq kq iy lr ls ku lt bi translated">L2正则化过度拟合和欠拟合；</h2><p id="8a58" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">所以我们的优化问题是:从等式……..一</p><p id="8ac6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> W*=(arg min(w)(i=1到n): log(1+(exp(-(易* W(转置)))))</strong></p><p id="e719" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设<strong class="ih hj">(易* W(转置))=子</strong></p><p id="6d5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后<strong class="ih hj"> W*=(arg min(w)(i=1到n): log(1+(exp(-Zi)))，现在</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lu"><img src="../Images/c496b4fa4bae7410a361180a2e759262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oiLqPuRCDgVZTfncnhrp7w.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lv"><img src="../Images/e536bd1930a15f55512c2a72c82a2148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wNzJ6fgx-QDQ4TkUZp3kfA.png"/></div></div></figure><p id="630c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们选择W，使得所有训练点被正确分类，并且所有Zi →(负无穷大),那么这样的W是最佳W，但是对于最佳W，如果一些点是不正确的或异常的，即<strong class="ih hj">过拟合的情况，我们会有问题。</strong></p><p id="a40b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，上述问题的解决方案是在这里添加正则化子，即L2:现在整个优化方程将是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lw"><img src="../Images/b43bc2592e0d1290de423296ceda0b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Bag2RiMapHaglx3fTSNDA.png"/></div></div></figure><p id="6bde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们看到的是<strong class="ih hj">Wj→无穷大</strong>，那么<strong class="ih hj">平方(Wj) </strong> → <strong class="ih hj">无穷大</strong>，我们的系统不会让它发生，因为我们的优化系统正试图最小化W*。所以通过加上[ <strong class="ih hj"> W(转置)W </strong>，避免了Wj到— - &gt;无穷大。现在我们最终的<strong class="ih hj">优化方程将是:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lx"><img src="../Images/07e10928bf7307ac1c4ebd683ee77500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xLCWsTgbZ7AU1w3y-JKV7g.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ly"><img src="../Images/6339bf0a17bb64caa312d2acab0021af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_JRylYxvjUlNBsw2oUn1w.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">一些缩写</figcaption></figure><p id="d5b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>