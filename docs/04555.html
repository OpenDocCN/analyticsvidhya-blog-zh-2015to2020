<html>
<head>
<title>Java Threads and Chaos in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java线程和Spring Boot的混乱</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/multi-threaded-chaos-69216bb2c45a?source=collection_archive---------7-----------------------#2020-03-24">https://medium.com/analytics-vidhya/multi-threaded-chaos-69216bb2c45a?source=collection_archive---------7-----------------------#2020-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/95ce31095178662c6385bfcf05824665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pogFFpufwUc3a7j2"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">肖恩·林在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f54f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你是一个API开发者或者业余程序员，你一定知道我们称之为<strong class="ix hj">“线程”</strong>的东西。毕竟线程是伟大的…它们允许你写代码，可以同时执行多个任务。它们还允许我们利用CPU的全部能力，将我们从UI冻结的可怕情况中解救出来。</p><p id="e43e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，线程也可能以意外的行为结束。我已经编码超过10年，我喜欢和线程一起工作。<strong class="ix hj">并发</strong>和<strong class="ix hj">并发作业</strong>的概念总是让我兴奋不已。是的，这是真的；但是当然，直到两个月前我陷入了怪异的境地！</p><h1 id="4f33" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">这是怎么回事？</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/39cef2659edec575326d8449fdd2fa34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e022CfXzv_lqNYc3YHJlFA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">以上是代码在上下文中的图示</figcaption></figure><blockquote class="kw kx ky"><p id="6cf0" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">考虑一个系统，我们需要处理100个作业(假设这个数字)。此外，在每个作业的处理过程中，我们需要调用一个外部服务来处理我们的请求并返回一些信息。为了进行类比，让我们说<em class="hi">是</em>或<em class="hi">现在是</em>。实现看起来非常简单，直到一段代码被证明是一场灾难！</p></blockquote><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/fb571ce23a3ca82e8500e2560b073737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Ap66ePXBO2BkjqzFDKUBg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在每个线程中，我们调用外部web服务并等待响应</figcaption></figure><p id="5fbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的系统看起来很容易实现。然而，当我们在生产，事情实际上是混乱的，执行是我们从来没有想过的事情！</p><blockquote class="kw kx ky"><p id="40ba" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">我们从外部服务获得的数据显示，不同的数据片段已经与其他具有不规则模式的数据混合在一起。例如，对象1的一个字段变成了对象2的同一字段的数据。然而，当我们检查代码时，我们分配正确！下面是混合物的可视化。</p></blockquote><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es le"><img src="../Images/e524fe82e567da147ea68b40afb38eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*16AQeYNPj0fqPcNlWdBG2w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">Web服务端点的数据混合</figcaption></figure><h1 id="73f0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">代码片段</h1><p id="49d8" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">我们使用的是Java 8 SDK中的CompletableFuture。Web应用程序基于<strong class="ix hj"> Spring框架</strong>。API很棒，因为它提供了开箱即用的线程实现以及<strong class="ix hj">执行器</strong>。<strong class="ix hj"> CompletableFuture </strong>的一个特性是执行一些执行，然后得到执行的响应。这正是我们所需要的。我们可以在一个线程上发送网络调用，然后接收响应。</p><p id="6dab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是我们的数据示例:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/7001e992cae6860b13cbc5571bfc58ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*WNQuc3nWdRz2TSV5sepdQA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">数据示例</figcaption></figure><p id="3a62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以对收到的响应执行进一步的业务逻辑。由于代码是专有的，我附加了一个简单的实现:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/34f38225853feecdbb84c14fc76f6475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhJl8qYuWlel7WTMw56b0A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">错误实现<strong class="bd jv"> CompletableFuture </strong>导致应用程序混乱</figcaption></figure><p id="2e5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很明显，当执行转移到实现<strong class="ix hj"> SupplierAsync </strong>的内部类时，作为参数传递的数据项会发生变化，导致两个实例的字段混淆。在正常情况下，我们从来没有遇到过这种情况，但当它来到网络调用，这种意外的行为被观察到。</p><h1 id="07b9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">解决办法</h1><p id="88e7" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">为了解决这个问题，我们必须重写和重构整个代码。我们必须创建一个新的类来实现<strong class="ix hj">供应商</strong>和<strong class="ix hj">消费者</strong>接口。现在我们可以初始化这个类，并在构造函数中传递所需的数据。这消除了堆栈状态被更改的任何可能性。现在，我们可以将这个新实例化的对象传递给<strong class="ix hj"> Worker </strong>，这样就可以得到想要的结果。下面是实施的快照:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/6ecbafcb3956ad0869d12567e1a5cf4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tpKeNtatXh-016baarttMA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">工人阶级</figcaption></figure><p id="2aec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们创建一个名为<strong class="ix hj"> Worker </strong> class的新类。这个类代表任何需要创建和启动的线程。这个线程通过构造函数接收所有需要的数据。因为在创建类的任何新实例时，都会分配一个单独的内存块，这消除了混淆状态的可能性。新创建的实例被传递给<strong class="ix hj"> CompletableFuture </strong>实例，如下所示:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/78c0cfcfb022a223b20918683433c010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*eQC6PfzgEmbdIG3RbxJcug.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">正确的</figcaption></figure><blockquote class="kw kx ky"><p id="e20a" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">简而言之，CompletableFuture(文档<a class="ae iu" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" rel="noopener ugc nofollow" target="_blank">此处为</a>)是一个很棒的API，它简化了并发代码的编写，并且自己处理了很多场景。它装载了适应多线程代码不同情况所需的所有助手方法。但是应该非常小心地使用这个API，以便获得期望的性能，而不会遇到上面提到的意外情况。</p></blockquote><p id="782c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个实现的完整代码可以在我的Github库<a class="ae iu" href="https://github.com/umairk83/Multi-Threaded-Chaos" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="23d8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="349d" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">这篇文章是为了让读者在编写多线程应用程序时要非常小心，以免意外的结果影响生产！</p><p id="56bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你喜欢读这篇文章，请跟我来看更多与开发相关的文章。</p></div></div>    
</body>
</html>