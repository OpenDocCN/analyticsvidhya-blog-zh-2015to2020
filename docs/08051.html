<html>
<head>
<title>Python’s Float Type is Flexible but Nasty too!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的浮动类型很灵活，但也很糟糕！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pythons-float-type-is-flexible-but-nasty-too-9bd3de80a1f0?source=collection_archive---------33-----------------------#2020-07-15">https://medium.com/analytics-vidhya/pythons-float-type-is-flexible-but-nasty-too-9bd3de80a1f0?source=collection_archive---------33-----------------------#2020-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b3fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python的float类型实现给了我们比你可能已经知道的更多的准确性。尽管如此，它也有典型的黑暗面，这是一个值得任何程序员关注的问题。</p><p id="b8b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题的出现是因为我们使用的十进制记数法的数字范围是0-9，而计算机理解的是基于数字开关的0-1组合。</p><p id="5259" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，十进制的15应作为1111输入CPU，而76应作为1001100。虽然它似乎对整数工作得很好(我们很快就会看到为什么)，但高精度浮点在表示分数和无理数时会遇到问题。</p><p id="c538" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下代码将更好地说明这一点:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/b235c7a73b04a71de00cf2d2ceee0f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*NevF9oVGSofl_mylkGNyBw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">Python是不是没有能力只把两个数相加？</figcaption></figure><p id="c7e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">刚刚发生了什么？在while循环中，我给c加了0.1，直到它达到1，但是Python给了我们一个错误的结果。这是个bug吗？</p><p id="89a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，没必要害怕。这正是我所说的编程障碍。<strong class="ih hj">将十进制转换成二进制与用sig*2^exp </strong>表示sig*10^x是一样的(sig =有效数字，exp =指数数字)。</p><p id="847e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于分数，通常的二进制存储形式是(sig，-exp)。所以，<strong class="ih hj"> <em class="jp"> 0.25 </em> </strong>馈为<strong class="ih hj"> <em class="jp"> (1，-10) </em> </strong>也就是<strong class="ih hj"><em class="jp"/></strong>。</p><p id="ad78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">甚至我们在代码中使用的数字0.1也不能被唯一地定义。如果你只用4个二进制数，你能得出的最接近的是<strong class="ih hj"> <em class="jp"> (0011，-101) </em> </strong>。这相当于3/32，即0.09375。</p><p id="6b2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，用五个有效二进制数，我们可以把0.1表示为<strong class="ih hj"> <em class="jp"> (11001，-1000) </em> </strong>，相当于25/256，即0.09765625。</p><p id="bbbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python的float数据类型给你的是<strong class="ih hj"><em class="jp"/></strong>53位的精度，所以0.1存储为<strong class="ih hj"><strong class="ih hj">11001100110011001100110011001100110011001100110011001100110011001</strong>。十进制的话这就是<strong class="ih hj">T31】0.100000000000005551151231257827021181583404541015625。 </strong></strong></p><p id="5c6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是啊！太近但又太远:(</p><p id="6907" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能看起来很可怕，真的！但是如果一个人制作了Python，那么他也做了一些技巧来逃避这样的场景:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/0090e5fe91db07083fbfbf2d858c754f.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*WiQF7YHdyiOxqWIiQGCKcQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">正确的做法！</figcaption></figure><p id="2f4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇哦。这次我们做对了。但是这里发生了什么？</p><p id="1192" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不可否认的是，我们得到了1.0，尽管重复地增加了0.1，但这是有代价的。我们已经定义了一个“ε”作为精度度量:如果c和1之间的差小于这个ε，那么我们给c赋值1。</p><p id="9fac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以根据自己的要求将ε变小或变大。但是让我们再看一个例子。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jr"><img src="../Images/90cff26180f764e894b9109f38b5f479.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*dawvqQi-rT9TmYK5Xq0i5A.png"/></div></figure><p id="bdcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是Python在0.5的情况下工作正常(如预期)。而且应该，因为0.5可以准确地用二进制表示为(1，-1)。</p><p id="a3d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仔细观察，你现在可以直观地理解为什么二进制对整数如此有效:<strong class="ih hj"> <em class="jp">任何整数都是0.5的倍数，因此可以写成sig*2^(exp).</em>T3】</strong></p><p id="7255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再来一个来自上面的直觉:<strong class="ih hj"> <em class="jp">分母为2的幂的每一个分数，比如1/16，5/64，19/1024等等。可以在双星系统</em> </strong>中精确确定。但是，对于其他人，我们必须更加努力！</p><p id="8b73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是大多数处理浮点数的Python方法的内置特性。我们已经明确定义了这个度量来说明Python如何处理这样的计算限制。</p><p id="9e2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，所有的小数点都不能用2的幂来唯一定义，除非你用无限多的二进制数字来表示。</p><p id="42ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用浮点数据类型时，建议使用精度范围<strong class="ih hj"><em class="jp">ε</em></strong>，而不是使用<strong class="ih hj"> "==" </strong>检查，以避免我们在第一个代码中得到的不幸答案。</p><p id="3742" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我写了这篇文章，因为我觉得在一个更关注快速算法和优化的世界里，我们错过了一些基本的计算属性。我希望这个博客对你的计算机科学之旅有所帮助，并让你对预期的事情有最好的理解。</p></div></div>    
</body>
</html>