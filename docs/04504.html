<html>
<head>
<title>Eclat Association Rule is very easy ! You know?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Eclat关联规则非常简单！你知道吗？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/eclat-association-rule-is-very-easy-you-know-71c8a992b36b?source=collection_archive---------9-----------------------#2020-03-22">https://medium.com/analytics-vidhya/eclat-association-rule-is-very-easy-you-know-71c8a992b36b?source=collection_archive---------9-----------------------#2020-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a82bfc20abdb447a31ddb8c193bf0650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIEw8nH49CuY4I--ZYX_Sg.png"/></div></div></figure><p id="f684" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Eclat </strong>算法代表<strong class="is hj"> E </strong>等值<strong class="is hj">CL</strong>as<strong class="is hj">T</strong>变压器。它是一种推荐或关联算法。和<a class="ae jo" rel="noopener" href="/analytics-vidhya/get-a-prior-knowledge-of-apriori-algorithm-before-using-it-4cf72bdaf7dd?source=friends_link&amp;sk=e03c4e7cbcce1e1a7dd2e02b3c9028b7"> <strong class="is hj"> Apriori算法</strong> </a>相比就非常好理解了。Apriori算法遵循<strong class="is hj">广度优先搜索</strong>算法，而Eclat算法遵循<strong class="is hj">深度优先搜索</strong>。下表显示了Apriori和Eclat关联模型之间的比较。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/0813b56f93720453dc138767ba185868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*ut0KNzKNpw7G1vkL2ycBng.png"/></div></figure><p id="66ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上表我们可以看出，Eclat算法在同时使用两种算法时比Apriori算法更有效。我们可以在下面的图片中看到最好的比较，它说明了这两种算法如何从第一个节点(<strong class="is hj"> a </strong>)到达目标节点(<strong class="is hj"> e </strong>)。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/9665d83cd90c73e9fec6cdcff6d80118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itulJzlY_1ceWL7RnvG4lQ.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">Aprior(BFS)对Eclat(外勤部)</figcaption></figure><h2 id="1e3a" class="jz ka hi bd kb kc kd ke kf kg kh ki kj jb kk kl km jf kn ko kp jj kq kr ks kt bi translated">Eclat算法的工作→</h2><p id="6333" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">因此，首先我们将决定我们要处理的数据集。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/5bfc53862bef6c7e0fe2813489bff704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*6Hq7u2tp4DFnkyVzYec1sw.png"/></div></figure><p id="a64d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将决定数据集的最小支持，它将等于<strong class="is hj"> 50% </strong>和<strong class="is hj"> </strong>。事务的最小支持的数值将= ( <strong class="is hj">给定的%值</strong>/<strong class="is hj">100</strong>)<strong class="is hj">*</strong>(<strong class="is hj">事务数</strong> ) = (50/100)*4 = <strong class="is hj"> 2。</strong></p><p id="a3b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将从长度大于或等于2的数据集<strong class="is hj">中找出每一个唯一的可能组合及其频率。</strong></p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es la"><img src="../Images/d4303e1205c0e0ca29896004c30f7680.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*sYsVeP9UYcpVerNdWbi1yQ.png"/></div></figure><p id="11f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从该表中，我们可以得出以下组合…..</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/00428d4b18729452b187560f35deb9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*CXt9MYo2PTbXn1rfdEFMOQ.png"/></div></figure><p id="e2ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">长度大于或等于2，是Eclat算法的输出。</strong></p><p id="f9df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的读者们，我希望这是理解Eclat算法的简短易懂的教程。如果您对此有任何问题、意见或担忧，请在回复中自由提出。我会尽快回答他们。在那之前，享受学习吧！……</p></div></div>    
</body>
</html>