<html>
<head>
<title>Big O &amp; Algorithm analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大 O &amp;算法分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/big-o-algorithm-analysis-2b92174c17e7?source=collection_archive---------27-----------------------#2020-12-29">https://medium.com/analytics-vidhya/big-o-algorithm-analysis-2b92174c17e7?source=collection_archive---------27-----------------------#2020-12-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d41e726d02f45c6a54dd1e1920deee63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xdz6gKWXrm1MkaKh_PX_Tw.jpeg"/></div></div></figure><p id="b079" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们都知道如何编码。我们可能知道如何编写“干净的代码”，或者至少我们知道是什么让代码变得干净(<a class="ae jn" href="https://www.amazon.com/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073" rel="noopener ugc nofollow" target="_blank">Bob 叔叔</a>肯定知道)。但是性能呢？如何预测算法是否快速且内存高效？我们如何分析算法并相互比较？原来，大 O 符号就是为此而存在的！</p><blockquote class="jo jp jq"><p id="99fe" class="ip iq jr ir b is it iu iv iw ix iy iz js jb jc jd jt jf jg jh ju jj jk jl jm ha bi translated"><em class="hh">简而言之，算法的效率就是你的代码执行一项任务的步骤数。</em></p></blockquote><p id="fb04" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，如果我们要创建一个显示其输入的函数，对于一个字符串，我们将做一个动作，对于一个 100 的数组，我们将做 100 次打印，对于<em class="jr"> n </em>我们将做<em class="jr"> n </em>。我们可以注意到 O( <em class="jr"> n </em>)或者“大 O 的<em class="jr"> n </em>”。</p><p id="f45d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，如果我们采取的动作的数量不依赖于输入，例如访问数组的<em class="jr"> n </em> ᵗʰ <em class="jr"> </em>项(无论数组的大小如何，它总是只有一个动作)，那么你的算法将在常数时间内运行，因此可以写成 O(1)。</p><p id="b7af" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们不一定对给定输入的实际精度和实际步骤数感兴趣，也不一定对运行代码所需的实际时间感兴趣，而是对输入的大小感兴趣。我们实际上是在比较 O(log₂ <em class="jr"> n </em>比 O( <em class="jr"> n </em>)更好还是更差。</p><p id="2dbd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们真的要看看<code class="du jv jw jx jy b">print</code>函数的实际复杂度，我们假设它在 O(1)中工作，我们就大错特错了。<code class="du jv jw jx jy b">print</code>函数将一个字符串作为参数记录在控制台中。<code class="du jv jw jx jy b">print</code>函数最有可能使用 POSIX <code class="du jv jw jx jy b">write</code>函数，这是一个系统调用，将一定量的数据转储到文件描述符(表示文件或终端等)...).在我们的例子中，数据是一个<code class="du jv jw jx jy b">string</code>，它基本上是一个 char 数组。知道字符串的长度意味着从字符串的开头到 O(n)的<code class="du jv jw jx jy b">null</code>字符(即<code class="du jv jw jx jy b">\0</code>)。从一个字符到另一个字符意味着增加一个变量(这有计算成本<em class="jr"> t </em> ₐ),我们只需要做一次。我们还需要检查计算成本为<em class="jr">t</em>ₜₛₜ<em class="jr">t13】的当前 char 的值，以及计算成本为<em class="jr"> tⱼₘₚ </em>的 jump(循环)的值。从一个字符串的第一个字符开始移动的实际计算代价其实是 o(<em class="jr">n</em>(<em class="jr">t</em>ₐ+<em class="jr">t</em>ₜₛₜ+<em class="jr">tⱼₘₚ</em>))。这只是没有我们调用并返回一个值的函数:<code class="du jv jw jx jy b">while(str[i++]);</code>。</em></p><p id="3fcd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">给出算法效率洞察的是<em class="jr"> n </em>，而不是常数。从长远来看，100 个<em class="jr"> n 个</em>总会比<em class="jr"> n 个</em> /2 好。在这方面，我们总是可以丢弃非确定性因素，用 O( <em class="jr"> n </em>)代替 O(100 <em class="jr"> n </em>)，用 O( <em class="jr"> n </em>)代替 O( <em class="jr"> n </em> /2)。</p></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><h1 id="047e" class="kg kh hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">练习:鸡蛋掉落问题</h1><p id="9d8b" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">我们有两个鸡蛋和一座 100 层的大楼。鸡蛋会在几层打破？</p><p id="e9de" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">两者完全相同。一个人可以把鸡蛋扔出窗户无限次，如果第一次没有打破，它就不会打破了。永远不会。在这一层和那些风箱上。永远不会。进行这项测试并了解其结果是有科学意义的。我们有一台传送机，可以让我们立即进入每一层。</p><h1 id="21ba" class="kg kh hh bd ki kj lj kl km kn lk kp kq kr ll kt ku kv lm kx ky kz ln lb lc ld bi translated">只有一个鸡蛋…</h1><p id="bfb5" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">用两个鸡蛋解决问题并不容易。先从一个开始解吧。凭直觉，我们会从地面开始，尝试每一层，直到它打破。这意味着:</p><ul class=""><li id="175c" class="lo lp hh ir b is it iw ix ja lq je lr ji ls jm lt lu lv lw bi translated">最好的情况是:我们在一楼扔一次</li><li id="d65a" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">最坏的情况是:鸡蛋在第 100 层打破…</li></ul><p id="2844" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用这个程序，如果我们有一个 1000 层的建筑，我们至少要做 1000 次投掷。又用一座<em class="jr"> n </em>层高的建筑，<em class="jr"> n </em>扔过来。</p><p id="e8c2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种方法是在 O( <em class="jr"> n </em>)中进行的</p><h1 id="689f" class="kg kh hh bd ki kj lj kl km kn lk kp kq kr ll kt ku kv lm kx ky kz ln lb lc ld bi translated">有无限的蛋…</h1><p id="6acd" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">这是最直观的方法，也是大多数人使用的方法。</p><p id="0d62" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你从 50 楼开始。如果鸡蛋破了，你就去 25 楼。如果它没有破裂，到 38 楼(取决于你如何回合)，等等…也就是说，你把建筑一分为二，并尝试在中间。对于每一次迭代，如果鸡蛋没有打破，你就把剩下的上半部分分成两半，如果鸡蛋打破了，你就把剩下的下半部分分成两半。</p><p id="2de2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们有一栋 32 层的建筑，我们将测试 16 层、8 层、4 层、2 层以及最后一层:</p><ul class=""><li id="d580" class="lo lp hh ir b is it iw ix ja lq je lr ji ls jm lt lu lv lw bi">16 = 32/2¹</li><li id="ae92" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi">8 = 32/2²</li><li id="f202" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi">4 = 32/2³</li><li id="1f8f" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi">2 = 32/2⁴</li><li id="926e" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">最后 1 = 32/2⁵.</li></ul><p id="1929" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此:</p><p id="3031" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么复杂度将是 O(log <em class="jr"> n </em>)。</p><ul class=""><li id="e673" class="lo lp hh ir b is it iw ix ja lq je lr ji ls jm lt lu lv lw bi translated">对于一个 100 层的建筑，我们有 7 次投掷，</li><li id="6026" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">对于一个 1000 层的建筑，我们有大约 10 次投掷</li></ul><p id="df66" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这比我们以前的尝试好多了。然而，我们没有无限数量的蛋，而是两个。</p><h1 id="aa31" class="kg kh hh bd ki kj lj kl km kn lk kp kq kr ll kt ku kv lm kx ky kz ln lb lc ld bi translated">回到两个鸡蛋…</h1><p id="ac7e" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">我们需要一种两者兼而有之的方法。</p><p id="6e39" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们把建筑分成相等的几块，试着每一块的顶部，我们会知道如果鸡蛋打破了，我们必须试着那块的每一层，这将对两个鸡蛋起作用。10 块似乎是一个有吸引力的数字，但在使用之前，让我们确保它是正确的。</p><p id="c144" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们希望在我们尝试的楼层数和组块数之间取得平衡，也就是说，组块数必须等于该组块中的楼层数:</p><figure class="md me mf mg fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/0e7099649ab07b91d27d08aee8cecdfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/0*0KKKTSjcHJnF8YkT"/></div></figure><p id="6e79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的例子中是 10，幸运。现在，我们最糟糕的情况是 99 层，因为我们必须测试 10、20、…、80、90、100 层，然后是 91、92、…、98、99 层。那是 19 次测试。</p><p id="f71c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种复杂性并不令人惊讶:</p><figure class="md me mf mg fd ii er es paragraph-image"><div class="er es mh"><img src="../Images/d1d1a60afe014d1fe95a0f344ea3c7da.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/0*keoY5Y29sI4Usumv"/></div></figure><h1 id="1370" class="kg kh hh bd ki kj lj kl km kn lk kp kq kr ll kt ku kv lm kx ky kz ln lb lc ld bi translated">有更好的吗？</h1><p id="5798" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">正如我们刚刚看到的，在最坏的情况下，我们将进行 19 次测试。但是如果楼层是 13，我们会做 6 个测试:10，20，11，12，13，14。也许我们可以重新分配楼层，这样，不管是哪一层，我们都可以保证做同样多的测试。</p><p id="373d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">换句话说，对于每个已经通过的块，我们少测试一层。例如，如果第一个块是 10，下一个将是 9，下一个是 8，依此类推。这样，如果它在 9 点突破，我们将测试 10，1，2，3，…，8，9 (10 次测试)，如果它在 18 点突破，我们将测试 10，19，11，12，…，17，18 (10 次测试)等等。</p><p id="b8c0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，基本上我们需要解决<em class="jr"> k </em> + … + 3 + 2 + 1 =建筑和数字<em class="jr"> k </em>出来。这就是 building = n(n+1) / 2，对于一栋 100 层的建筑，我们最差也要扔 14 次才能找到正确的楼层:</p><figure class="md me mf mg fd ii er es paragraph-image"><div class="er es mi"><img src="../Images/5128e1965ae3f152718fcf7f29250c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/0*mS1G9P5iofyZrRfx"/></div></figure><p id="7b6a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">复杂之处在于:</p><figure class="md me mf mg fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/f5bc363d773204c4a72832e54e34f159.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/0*Ug9zmKETLh-6h_ev"/></div></figure><p id="1f42" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这和我们之前找到的算法是一样的。我们来比较一下这四个:</p><figure class="md me mf mg fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/4459736e638577e05075d3e4a9c2ac59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RvbmvGcz1lB0hN8tHDGUA.png"/></div></div></figure><ul class=""><li id="dec0" class="lo lp hh ir b is it iw ix ja lq je lr ji ls jm lt lu lv lw bi translated">红色:带 1 个鸡蛋:O( <em class="jr"> n </em>)</li><li id="d28b" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">绿色:有无限个蛋:O(log <em class="jr"> n </em>)</li><li id="c478" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">橙色:我们的第二个鸡蛋解决方案:O(2 sqrt( <em class="jr"> n </em>)</li><li id="f785" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">蓝色:我们的第二个 2 蛋解:O(sqrt(1/4+2 <em class="jr"> n </em> ) - 1/2)</li></ul><p id="4bb3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以清楚地看到 O( <em class="jr"> n </em>)、O(sqrt <em class="jr"> n </em>)和 O(log <em class="jr"> n </em>)之间的区别，而不考虑我们丢弃的常数。当然，当比较两个整体复杂度相同的算法时，常数是有意义的(对于 1600 层，在第一个两个鸡蛋的解决方案和第二个之间有 30 次尝试偏移)。</p></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><h1 id="a6b6" class="kg kh hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">更进一步…</h1><p id="fcc9" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">到目前为止，我们已经计算了步数。我们称之为“时间复杂度”,因为它给出了算法运行需要多长时间的感觉。</p><p id="6654" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同样的逻辑也适用于算法占用的内存量:“空间复杂度”。在这种情况下，您只需要计算需要创建多少个变量。例如，如果您想计算数组中唯一条目的数量，您的第一个选择可能是使用<code class="du jv jw jx jy b">Set</code>。对于每个新条目，如果条目存在，您将检查<code class="du jv jw jx jy b">Set</code>,否则创建它。该算法将在 O( <em class="jr"> n </em>)时间(因为您必须遍历每个条目)和 O( <em class="jr"> n </em>)空间中运行，因为在最坏的情况下，数组充满了唯一的条目，因此您在<code class="du jv jw jx jy b">Set</code>中创建了<em class="jr"> n </em>新条目(bloom filter 可能是 O( <em class="jr"> n </em>)空间和 O(1)空间中的一个有趣的替代方案，但这会带来一些误报——我们现在不讨论这个)。</p><p id="92cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是…还有更多。</p><p id="8a8e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们不必像在本文中那样只谈论“最坏的情况”。最糟糕的情况实际上是一个算法函数的“渐近紧上限”，这意味着如果一切都出错了，这将是多么的错误。</p><p id="72e2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">比如你说“我 20 分钟到，堵车的话 1 小时”，1 小时就是你的上限。那基本上就是<strong class="ir hi">大 O </strong>了。然而 20mn 是“紧下限”，或<strong class="ir hi">大ω</strong>:ω(<em class="jr">n</em>)</p><p id="f978" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以只说“我会在一天结束前到达工作地点”，这将是一个“宽松的上限”，或<strong class="ir hi"> little o </strong> o( <em class="jr"> n </em>)。但是如果你说“我马上就来”会是一个“松散的下界”或者<strong class="ir hi">小ω</strong>ω(<em class="jr">n</em>)。</p><p id="604e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你知道你将在 40mn 内到达，那将是“预期的平均情况”或<strong class="ir hi">大θ</strong>θ(<em class="jr">n</em>)。它实际上是函数的上界和下界。</p><figure class="md me mf mg fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/3f536e74adad864264ebde58373c8b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KgK4EpkcBFsqC-4D.png"/></div></div></figure><p id="0518" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们看图，我们的算法<em class="jr"> f </em> ( <em class="jr"> n </em>)运行在θ(<em class="jr">n</em>)中，有界在 O( <em class="jr"> n </em>)和ω(<em class="jr">n</em>)之间。从长远来看，我们知道它不会比 o( <em class="jr"> n </em>)差，也不会比ω(log <em class="jr"> n </em>)好</p><h1 id="21ae" class="kg kh hh bd ki kj lj kl km kn lk kp kq kr ll kt ku kv lm kx ky kz ln lb lc ld bi translated">常见复杂性</h1><ul class=""><li id="2c22" class="lo lp hh ir b is le iw lf ja mm je mn ji mo jm lt lu lv lw bi translated">O(1):直接访问(例如，在数组或散列表/集合中)</li><li id="5bca" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">O( <em class="jr"> n </em>):循环输入一段固定的时间(例如，索引查找、计数)</li><li id="02e7" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">O( <em class="jr"> n </em>):对于每个输入，每隔一个输入查看一次(例如冒泡排序)</li><li id="65bb" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">O(log <em class="jr"> n </em> )$:划分问题(例如二叉树查找)</li><li id="d2e6" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">O( <em class="jr"> n </em>日志<em class="jr"> n </em>):排序</li><li id="f059" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">o(！组合学</li></ul></div></div>    
</body>
</html>