<html>
<head>
<title>Go: A Beautiful Mess</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go:漂亮的一塌糊涂</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/go-a-beautiful-mess-e7fdf267b050?source=collection_archive---------4-----------------------#2020-11-30">https://medium.com/analytics-vidhya/go-a-beautiful-mess-e7fdf267b050?source=collection_archive---------4-----------------------#2020-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="aa81" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">围棋所立足的世界，我们都从围棋中得到快乐和痛苦。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/29128f8e956fd79c6be6707e2536434b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZS0KyMa9G9sA-xqU"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由<a class="ae jn" href="https://unsplash.com/@mikepetrucci?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·彼得鲁奇</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4350" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi kk translated">像我这样的老派人喜欢静态类型语言，甚至我也尝到了动态类型语言在处理 JSON 等复杂结构数据或用 SQL/NoSQL 操作数据时的便利。静态类型语言避免了许多不明确的问题，让我们在单元测试报告错误之前找出错误。</p><p id="bc2f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以我在很多方面都很喜欢<em class="kt"> Go </em>，它利用了来自<em class="kt"> </em>其他语言的许多概念，具有易于理解的结构类型，用于生产的强大工具集…等等，最重要的是，它易于编写，性能不会让你失望，但我有时也会感到困惑，并在 Go 中发现许多模糊的部分。</p><p id="73f9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">刚开始用 Go 的时候，惊喜地发现 Go 几乎把我的所有东西都收藏了。在大多数情况下，我需要做的就是关注代码本身。但是在我用 Go 写项目一段时间后，我开始觉得他们在 Go 中的一些设计太<em class="kt">简单</em>了，在处理更大的项目时缺乏灵活性。</p><p id="73a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<a class="ae jn" href="https://commandcenter.blogspot.fr/2012/06/less-is-exponentially-more.html" rel="noopener ugc nofollow" target="_blank">Less is exponentially more</a>中，Rob Pike 解释了许多设计原则和许多 Go 变成这样的原因，我可以想象一些守旧派工程师坐在一起谈论 C++的场景，分享他们关于 C++的恼人经历，并决定制作一种简单的语言，创造许多便利的工具，帮助他们生活在快乐的编码世界中。有趣的是，这可能也是我认为围棋既漂亮又混乱的原因。</p><blockquote class="ku kv kw"><p id="6248" class="jo jp kt jq b jr js ij jt ju jv im jw kx jy jz ka ky kc kd ke kz kg kh ki kj hb bi translated">美丽的混乱——围棋站立的世界</p></blockquote><p id="9b52" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kt">在撰写本文时，Go 的最新发布版本是 v1.15。因此，下面的一些观点可能会在未来发生变化。</em></p><h1 id="b335" class="la lb hi bd lc ld le lf lg lh li lj lk io ll ip lm ir ln is lo iu lp iv lq lr bi translated">围棋之美</h1><h2 id="fa4c" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">简单学习曲线</h2><p id="1481" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">这可能不是编程语言最重要的核心特性，但令我惊讶的是，我只花了两天时间学习基本知识，花了一天时间习惯键入声明(比如写<code class="du ml mm mn mo b">num int</code>而不是<code class="du ml mm mn mo b">int num</code>)，花了大约三天时间了解 Go 模块、goroutine、上下文、通道等。</p><p id="7a9a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于一个有 C/C++/Java 等经验的程序员来说，花一些时间完成<a class="ae jn" href="https://tour.golang.org/" rel="noopener ugc nofollow" target="_blank">中的所有课程，一次围棋之旅</a>将足以开始编写一个实用的围棋程序，剩下的时间将花在阅读库文档、学习惯用的方法和遇到围棋中的陷阱上。</p><p id="3b88" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Go 还提供了丰富的工具来帮助新手编写程序，而不需要学习很多关于编译、闪烁、打包和部署等方面的知识</p><p id="9151" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从很多方面来说，Go 确实是一种简单易学的语言，它更像是一个生态系统，让人们不需要在环境设置上花费太多时间。</p><p id="0e91" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们只需要编写代码并键入<code class="du ml mm mn mo b">go run ...</code></p><h2 id="fb17" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">没有预处理器指令</h2><p id="adb5" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">在传统的静态类型语言如 C/C++中，我们经常使用预处理器指令来定义 marcos 或在编译时进行条件测试，如下所示:</p><pre class="iy iz ja jb fd mp mo mq mr aw ms bi"><span id="0ccc" class="ls lb hi mo b fi mt mu l mv mw">#define MIN(a,b) (((a)&lt;(b))?(a):(b))<br/>#define MAX(a,b) (((a)&gt;(b))?(a):(b))<!-- --> <br/>#ifdef <!-- -->__x86_64__<br/>...<br/>#else<br/>...<br/>#endif</span></pre><p id="4181" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们出于多种目的定义 marcos(通常是因为他们可以做任何事情，即使我们知道这是邪恶的)，但是这样做的代价是缺乏类型安全性，有时会使代码不可读并且难以调试。</p><p id="5435" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Go 不提供像<code class="du ml mm mn mo b">#define</code>、<code class="du ml mm mn mo b">#if</code>…等预处理指令。，在我看来，这是进步的象征，尤其是对现代语言来说。</p><p id="7a06" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从技术上来说，Go <em class="kt">提供了一些特殊的预处理器指令</em>，不是让人去定义 marcos，只是让人给编译器或者构建工具提供提示。</p><p id="ec05" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，Go 提供了一些类似<code class="du ml mm mn mo b">go:noescape</code>、<code class="du ml mm mn mo b">go:noinline</code>…等的编译指令，为编译器提供提示。Go 还提供了<a class="ae jn" href="https://golang.org/cmd/go/#hdr-Build_constraints" rel="noopener ugc nofollow" target="_blank"> build tags </a>指令来约束哪些文件将被包含在包中，这不是一个完美的解决方案，也不像其他构建系统如 CMake、Gnu-make 那样有效..等等。，但无论如何，它让事情变得简单。</p><p id="cb63" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kt">延伸阅读</em> </strong></p><div class="mx my ez fb mz na"><a href="https://dave.cheney.net/2018/01/08/gos-hidden-pragmas" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">Go 的隐藏#pragmas</h2><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">dave.cheney.net</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jh na"/></div></div></a></div><div class="mx my ez fb mz na"><a href="https://golang.org/cmd/go/#hdr-Build_constraints" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">Go-Go 编程语言</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">构建约束部分。</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">golang.org</p></div></div><div class="ni l"><div class="np l nk nl nm ni nn jh na"/></div></div></a></div><h2 id="8d0b" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">易于定义新类型</h2><p id="b4ee" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">这是让我感觉舒服的部分，在 Go 中，从现有类型定义一个新类型是非常容易的。</p><p id="24ca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用于不同目的的不同类型将使代码更具可读性，它还有助于防止将错误的参数顺序传递给函数，并提供了为每种类型编写检查方法的可能性。</p><p id="a1e8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从<em class="kt">字符串</em>创建一个新类型并为新类型提供一些方法是非常容易的，如下例所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nq nr l"/></div></figure><p id="4a61" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个例子展示了一种从字符串定义两个新类型的简单方法:<code class="du ml mm mn mo b">UserID</code>和<code class="du ml mm mn mo b">UserName</code>，并为这些类型添加了验证函数，这种独特的类型还防止我们传递错误的参数顺序。</p><h2 id="e7e4" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">并发编程从未如此简单</h2><p id="54cb" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">我一直认为围棋最大的特点是 goroutine，而<em class="kt">频道</em>的概念可能有点混乱，但也很棒。</p><p id="995c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">除了<em class="kt"> goroutine </em>的优点，比如轻量级和有一个很好的上下文控制机制，我认为<em class="kt"> goroutine </em>最大的优点是我们可以用同步模型在<em class="kt"> goroutine </em>中编写代码，并受益于异步模型的性能。</p><p id="94c9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一方面，一个 goroutine 的内存开销只有 2 ~ 4k 字节左右，线程的开销有几兆，这说明<em class="kt"> goroutine </em>相比<em class="kt">线程</em>确实是一个轻量级的解决方案。</p><p id="358f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">根据我的经验，Go scheduler 可以很好地处理成千上万的 goroutines 和频繁的垃圾收集。</p><p id="896a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kt">延伸阅读</em> </strong></p><div class="mx my ez fb mz na"><a rel="noopener follow" target="_blank" href="/rungo/anatomy-of-goroutines-in-go-concurrency-in-go-a4cb9272ff88"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">Go 中 Go routines/Go 中并发性的剖析</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">goroutine 是在后台运行的轻量级执行线程。goroutine 是实现并发性的关键因素…</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">medium.com</p></div></div><div class="ni l"><div class="ns l nk nl nm ni nn jh na"/></div></div></a></div><h2 id="fb3d" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">Go 中的上下文包非常棒，非常优雅</h2><p id="e514" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">在处理网络编程时，Go standard library 提供了一个<code class="du ml mm mn mo b">context</code>包，通过一个优雅的传播机制来管理任务，如果我们想取消任务或为任务设置超时，这就变得容易多了，而不需要编写复杂的代码。同步和通知机制。</p><p id="f483" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们编写一个大的服务程序时，网络操作可能发生在很深的代码堆栈中，我们需要非常小心地处理每个函数的超时或网络故障问题，否则会阻塞整个服务或导致连锁崩溃。</p><p id="0937" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">幸运的是，Go 中大多数与请求相关的函数使用<code class="du ml mm mn mo b">context</code>作为其第一个参数，并在必要时创建一个派生上下文，因此我们可以从上层函数取消或设置这些函数的超时，并以令人愉快的方式控制这些任务。</p><p id="1017" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kt">延伸阅读</em> </strong></p><div class="mx my ez fb mz na"><a rel="noopener follow" target="_blank" href="/a-journey-with-go/go-context-and-cancellation-by-propagation-7a808bbc889c"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">Go:通过传播的上下文和取消</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">在 1.7 中引入的上下文包为我们提供了一种在应用程序中处理上下文的方法。这些环境可以…</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">medium.com</p></div></div><div class="ni l"><div class="nt l nk nl nm ni nn jh na"/></div></div></a></div><h2 id="f5f4" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated"><strong class="ak">使用迭代范围作为默认样式，不使用迭代器接口</strong></h2><p id="539a" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">嗯，有些人可能不同意这一部分，我知道有些程序员真的很喜欢迭代器风格，但在我看来，我更喜欢基于范围的循环，例如。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nq nr l"/></div></figure><p id="9218" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Go 对字符串、数组、切片、地图和通道使用基于范围的循环，这是一种迭代项目的干净方式，现代 C++也支持基于范围的循环、自动类型化变量和其他好的特性(这使我喜欢用 C++编程)。</p><p id="c623" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Go 中基于范围的循环看起来很好看很干净，可惜 Go 没有提供 Java 和 C++那样的标准迭代器接口，所以范围操作只支持内置类型。</p><p id="44e8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">比如我们要迭代<code class="du ml mm mn mo b">sync.Map</code>中的条目时，不能直接对其进行 range，而需要传递一个回调函数给<code class="du ml mm mn mo b">Map.Range(),</code>Go 中容器的不良支持对我来说毫无意义。</p><h2 id="3955" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">标准工具链令人震撼</h2><p id="72a1" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">Go 提供的标准工具的有用性和便利性可能是我喜欢用 Go 编码的前 5 个部分。</p><p id="73a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于格式化代码，go 提供了<code class="du ml mm mn mo b">gofmt</code>，简单快捷，不管你喜不喜欢，它为代码提供了一个<em class="kt">官方</em>规范格式，我发现很多项目都在用，我猜是因为 vscode 是 Go 开发中最受欢迎的编辑器，vscode 的 Go 扩展真的很好看，真的。</p><p id="b0e2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于林挺来说，围棋提供了<code class="du ml mm mn mo b">golint</code>，不强大但简单，但有<a class="ae jn" href="https://golangci-lint.run/" rel="noopener ugc nofollow" target="_blank"> golintci-lint </a>和<a class="ae jn" href="https://revive.run/" rel="noopener ugc nofollow" target="_blank"> revive </a>，又好又快。</p><p id="9e67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于构造检查，它有<code class="du ml mm mn mo b">go vec</code>，对于文档化 Go 代码，Go 定义了 godoc 格式，让我们可以编写内联文档，并且有一个官方的<a class="ae jn" href="https://pkg.go.dev/" rel="noopener ugc nofollow" target="_blank"> https://pkg.go.dev </a>包文档门户。</p><p id="fa17" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最好的部分是关于测试、代码覆盖报告、基准测试和性能分析，尤其是性能分析，内置的 CPU 和内存性能分析功能非常强大，它减少了性能优化的大量时间。</p><h2 id="c6bd" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">快速构建，快速测试，快速死亡</h2><p id="f28c" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">这部分是我个人的偏好，我对长时间的编译没有耐心，但是如果你生活在 C++世界，你唯一能做的就是深呼吸，接受它。</p><p id="cf02" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我开始使用 Go 时，令我惊讶的是编译时间非常快，即使是一个大项目也只需要几秒钟。快速的编译时间带来更敏捷的调试效率，换句话说，如果你做错了什么，代码会死得更快。</p><h2 id="2768" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">便于部署</h2><p id="0a1c" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">这是个人偏好的另一部分，默认的 go 编译器和链接器(不是 gccgo)可以将对象编译链接成一个静态的可执行文件，这意味着我们的程序不依赖于其他共享库。</p><p id="67cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">库依赖问题在部署阶段可能会变得非常棘手，在现代部署环境中，人们越来越多地使用容器技术。像 Docker 一样，单个静态可执行文件不依赖于任何东西，所以不需要将库安装到容器中，结果是我们有了一个占用空间小的容器，DevOps 喜欢这个。</p><h1 id="94e1" class="la lb hi bd lc ld le lf lg lh li lj lk io ll ip lm ir ln is lo iu lp iv lq lr bi translated">围棋的混乱</h1><h2 id="a7e7" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">围棋的错误处理还停留在恐龙时代</h2><p id="f670" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">人们抱怨 Go 的错误处理，我也是。</p><p id="ab06" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Go 的错误处理让我感觉回到了写 C 代码的 90 年代。</p><p id="dccc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Golang 的开发团队说他们不想支持异常，所以最终，我们代码中的错误处理都是这样的:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nq nr l"/></div></figure><p id="e7e7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于 Go 中的接口不支持方法的默认实现，<em class="kt">错误</em>是带有<code class="du ml mm mn mo b">Error()</code>方法的接口类型，没有定义任何其他方法来支持堆栈跟踪。</p><p id="be33" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">即使它定义了它，要求每个自定义错误实现方法进行堆栈跟踪是不实际的，它应该让一个默认实现在<em class="kt">错误</em>接口中处理堆栈跟踪。</p><p id="dda7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不幸的是，Go 接口的角色需要简单而纯粹，所以接口唯一需要做的就是定义方法的名称和签名。</p><p id="1488" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以事情变得很有趣，错误类型看起来只是一个字符串值。当一个错误发生时，我们唯一知道的是“等等…等等”出错了。我们不确定错误发生的位置，因为这个错误可能会在更深层次的函数中报告，而不是在我们调用的函数中报告，如果我们不使用类似<a class="ae jn" href="https://pkg.go.dev/github.com/pkg/errors" rel="noopener ugc nofollow" target="_blank"> errors </a>的堆栈可跟踪包，我们需要花费大量时间来找出错误发生的实际位置。</p><h2 id="02fc" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">恐慌，恢复，推迟，使人痛苦</h2><p id="6331" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">我说 Go 不支持异常，但是等等…它支持！</p><p id="27cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Go 有一个函数<code class="du ml mm mn mo b">panic()</code>是像 c 中的<code class="du ml mm mn mo b">assert()</code>一样被设计用来终止程序的，而出于某种原因，也许是关于宇宙中的黑暗力量，几年后 Go v1.0 又增加了一个函数<code class="du ml mm mn mo b">recover()</code>，相关讨论在这里是<a class="ae jn" href="https://groups.google.com/g/golang-nuts/c/HOXNBQu5c-Q" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="aec9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当<code class="du ml mm mn mo b">recover()</code>在 Go 中加入后，panic 和 recover 成为伙伴，其行为类似于 try-catch 异常处理，panic-recover 看起来像是<em class="kt"> try-catch </em>的怪异版本，只是 Go 称其为 panic 和 recover。</p><p id="f80a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">嗯，使用<code class="du ml mm mn mo b">recover()</code>来捕捉来自<code class="du ml mm mn mo b">panic()</code>的错误对我来说是一种可以接受的方式，即使我们需要在延迟函数中调用<code class="du ml mm mn mo b">recover()</code>。</p><blockquote class="ku kv kw"><p id="f127" class="jo jp kt jq b jr js ij jt ju jv im jw kx jy jz ka ky kc kd ke kz kg kh ki kj hb bi translated">但是如果我们想从恐慌中捕捉错误，然后返回错误或一些有意义的结果呢？</p></blockquote><p id="3d11" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">解决方案是我们需要使用<a class="ae jn" href="https://golang.org/ref/spec#Defer_statements" rel="noopener ugc nofollow" target="_blank">命名的 result_parameters </a>，aka。命名返回值。这是因为<em class="kt">延迟</em>函数中的返回值在函数完成时被丢弃，而<em class="kt">延迟</em>函数可以在返回值被返回之前访问和修改已命名的返回值。如果我们想在一个<em class="kt">定义的</em>函数中返回一些东西，我们需要将数据设置为一个指定的返回值。</p><p id="6340" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了完成如此简单的任务，我们需要编写一些奇怪的代码，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nq nr l"/></div></figure><p id="4e11" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">panic 是由<code class="du ml mm mn mo b">throwPanic()</code>抛出的，然后<code class="du ml mm mn mo b">catchPanic()</code>在一个延迟函数中通过<code class="du ml mm mn mo b">recover()</code>捕捉到它，<code class="du ml mm mn mo b">recover()</code>的返回值是一个类型为<code class="du ml mm mn mo b">interface{}</code>的值，所以我们需要检查 panic 抛出的值是否是错误的，然后我们可以将它赋给<code class="du ml mm mn mo b">err</code>。</p><p id="538a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好吧，我需要承认，这不像 Java 里的 try-catch 机制，像是 try…finally 机制！</p><p id="2450" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kt">延迟</em>函数<code class="du ml mm mn mo b">recover()</code>类似于<em class="kt">最终</em>的一个块，它不确定是否有异常抛出，所以它需要检查<code class="du ml mm mn mo b">recover()</code>返回值，看看是否有<code class="du ml mm mn mo b">panic()</code>抛出的值。</p><p id="5993" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">无论如何，我不能理解为什么 Go 团队提供这种奇怪的解决方案，如果他们认为捕捉恐慌是一个必要的功能，而不是提供一个更可读的机制。</p><p id="1996" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kt">延伸阅读</em> </strong></p><div class="mx my ez fb mz na"><a href="https://yourbasic.org/golang/recover-from-panic/" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">死机、堆栈跟踪以及如何恢复[最佳实践]</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">Panics 类似于 C++和 Java 异常，但只适用于运行时错误，比如跟在 nil…</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">yourbasic.org</p></div></div><div class="ni l"><div class="nu l nk nl nm ni nn jh na"/></div></div></a></div><h2 id="686b" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">界面很简单，但是太简单了</h2><p id="fe9f" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">接口是 Go 中类型系统的基础，接口的功能和其他语言类似:定义行为。</p><p id="d889" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Go 不是面向对象的语言，但它借用了现代语言中的一些概念。Go 接口是一个提供多态性的简单解决方案，提到术语<em class="kt">多态性</em>，我想引用 BASIC 语言发明者的一句话。</p><blockquote class="ku kv kw"><p id="d740" class="jo jp kt jq b jr js ij jt ju jv im jw kx jy jz ka ky kc kd ke kz kg kh ki kj hb bi translated">多态性意味着你写了一个特定的程序，它的行为取决于它所操作的数据托马斯·e·库尔茨</p></blockquote><p id="63b2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接口的概念对我来说很好，但是当我在标准和其他社区包中处理接口时，我发现了一些有趣的现象。</p><ul class=""><li id="877e" class="nv nw hi jq b jr js ju jv jx nx kb ny kf nz kj oa ob oc od bi translated"><em class="kt">空的</em>接口被过度使用，<code class="du ml mm mn mo b">inteface{}</code>到处出现，因为地鼠用它作为<em class="kt"> Any/void * </em>值来接收/传递具体的数据。</li><li id="563f" class="nv nw hi jq b jr oe ju of jx og kb oh kf oi kj oa ob oc od bi translated">人们喜欢将接口视为基类，但事实并非如此。</li><li id="f22a" class="nv nw hi jq b jr oe ju of jx og kb oh kf oi kj oa ob oc od bi translated">当情况变得更糟时，人们使用 reflect package 通过一堆条件语句来解决运行时的问题。</li><li id="10c7" class="nv nw hi jq b jr oe ju of jx og kb oh kf oi kj oa ob oc od bi translated">人们花费大量时间来弄清楚哪个结构实现了哪个接口，因为 Go 声称它不想提供关键字<em class="kt">“implements”</em>。</li></ul><p id="1007" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">除了最后一个，所有这些现象都与泛型有关，但 Go 的类型系统至少在 Go 的 v1 中不能为泛型编程提供优雅的方式。</p><p id="4c48" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是泛型在某些场景下非常有用，以至于让人无法放弃，所以人们努力尝试通过定义方法、使用类型断言、反射等方式将代码写成泛型。</p><p id="5336" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">先说我提到的最后一个，一个接口需要一个具体的类型来实现，不管这个类型叫 class，struct，还是别的名字。所以，当我们在静态类型语言中定义一个类型来实现一个接口时，我们要让编译器知道，然后编译器可以在编译时检查接口的操作是否有效。</p><p id="1b2b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这给编译器带来了复杂性，也给编译时间带来了成本，Go 让类型检查操作从编译时到运行时，然后告诉程序员你的职责是在运行时检查类型，程序员说:“哦，好的”，然后就出现了一些笨拙的代码。</p><p id="2c83" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Go 最终会有泛型，关于泛型的提议是<a class="ae jn" href="https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md" rel="noopener ugc nofollow" target="_blank">这里</a>，希望在不久的将来会发生。</p><p id="91a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kt">延伸阅读</em> </strong></p><div class="mx my ez fb mz na"><a href="https://www.ardanlabs.com/blog/2018/03/interface-values-are-valueless.html" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">接口值没有价值</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">我最近在 Slack 上看到很多关于界面的问题。大多数情况下，答案是…</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">www.ardanlabs.com</p></div></div><div class="ni l"><div class="oj l nk nl nm ni nn jh na"/></div></div></a></div><div class="mx my ez fb mz na"><a rel="noopener follow" target="_blank" href="/hackernoon/why-go-doesnt-have-generics-b40ef9e69833"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">为什么 Go 没有泛型</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">首先，我只想说，是的，我知道 Go 最终会有泛型，而且已经有一个很大的…</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">medium.com</p></div></div><div class="ni l"><div class="ok l nk nl nm ni nn jh na"/></div></div></a></div><div class="mx my ez fb mz na"><a href="https://golang.org/doc/effective_go.html#interfaces_and_types" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">有效围棋</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">围棋是一门新的语言。虽然它借鉴了现有语言的思想，但它有一些不寻常的属性，使它变得有效…</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">golang.org</p></div></div><div class="ni l"><div class="ol l nk nl nm ni nn jh na"/></div></div></a></div><h2 id="e828" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">该接口不支持方法的默认实现</h2><p id="fac7" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">由于<a class="ae jn" href="#686b" rel="noopener ugc nofollow">部分接口简单，但是</a>提到的太简单，Go 接口太简单了，除了定义方法签名之外，它不支持任何其他特性。因此它不能定义方法的默认实现，这使得在不破坏已经实现该接口的现有类型的兼容性的情况下，很难在接口中添加新方法。</p><p id="fe8c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果接口没有被导出到包之外，这可能没什么大不了的，因为我们可以自己更新包中的所有类型。但是，如果我们为包中的其他人提供导出的接口，比如我们写一个开源的包放在 GitHub 上，试图给这个接口添加一个新的方法会破解使用我们包的人的代码。</p><p id="987c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以我们唯一能做的就是升级软件包的主要版本，并将其设置为不兼容，因为我们不能为新方法提供默认实现。有一个著名的例子:</p><p id="840b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当 Go v1.13 发布时，它通过向<a class="ae jn" href="https://pkg.go.dev/errors" rel="noopener ugc nofollow" target="_blank"> errors </a>包添加新的<a class="ae jn" href="https://pkg.go.dev/errors#Unwrap" rel="noopener ugc nofollow" target="_blank"> Unwrap </a>方法，引入了错误链接机制。</p><p id="926a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为什么不把这个方法添加到错误接口，而是添加到<a class="ae jn" href="https://pkg.go.dev/errors" rel="noopener ugc nofollow" target="_blank">错误</a>包？这可能是我上面提到的原因:他们不能，因为这将破坏所有现有的代码。</p><p id="d0b3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kt">延伸阅读</em> </strong></p><div class="mx my ez fb mz na"><a href="https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/#interface-methods-dont-support-default-implementations" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">Go:好的，坏的，丑的</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">这是“围棋不好”系列的附加帖子。Go 确实有一些不错的特性，因此有“好”的部分…</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">bluxte.net</p></div></div></div></a></div><h2 id="1981" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">Go 中的常量只支持标量类型</h2><p id="7596" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">Go 有常量，但不是我想的<em class="kt">那个</em>常量。</p><p id="4266" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Go 中常量的定义遵循一个简单的原则，使得标量值不可改变，标量值的类型有:bool、全数字类型、string。因此，没有常量结构、常量指针和常量数组。</p><p id="1d7d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是如果我们看 Go 提供的标准包，你会发现有一堆<em class="kt">非常量</em>导出的变量，而这些变量不是常量的原因是:Go 不支持它们是常量。</p><p id="dd43" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看看<a class="ae jn" href="https://pkg.go.dev/net" rel="noopener ugc nofollow" target="_blank"> net </a>包，这个包输出<code class="du ml mm mn mo b">IPv4bcast</code>、<code class="du ml mm mn mo b">IPv4allsys</code>、<code class="du ml mm mn mo b">IPv4allrouter</code>和<code class="du ml mm mn mo b">IPv4zero</code>变量。所以很容易做一些邪恶的事情:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nq nr l"/></div></figure><p id="ea0d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">严格地说，这个问题是一个实现问题，有许多方法可以不在包中使用导出的变量，但是在现实世界中，有时我们需要导出一些变量来提供预定义的信息。</p><p id="4a0f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这种情况下，如果可以的话，我们会想把这些变量设为常量。</p><h2 id="4995" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">基于范围的循环只能迭代内置类型</h2><p id="3540" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">我们再次回到接口问题上，Go 为内置容器类型提供了一级成员徽章:数组、切片、映射、通道<em class="kt">(嗯，你为什么在这里，就因为你的行为像队列？但是你父亲叫你通道。)</em></p><p id="648a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">只有这些一级成员可以享受坐在基于范围的循环中，其他容器类型是经济舱的成员，需要找到自己的方式来提供迭代。</p><p id="c1d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<a class="ae jn" href="https://pkg.go.dev/container/list#List" rel="noopener ugc nofollow" target="_blank">列表中。列出</a>包，需要用<code class="du ml mm mn mo b">for e := l.Front(); e != nil; e = e.Next() {…}</code>迭代项，和<a class="ae jn" href="https://pkg.go.dev/sync#Map" rel="noopener ugc nofollow" target="_blank">同步。Map </a>需要使用<a class="ae jn" href="https://pkg.go.dev/sync#Map.Range" rel="noopener ugc nofollow" target="_blank"> Range() </a>方法和传递回调函数。</p><p id="d441" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，这些一级成员的行为与其他成员不同，当它们作为参数传递时，它们的行为就像是通过值传递的，实际上，它们是通过指针传递的，所以它们看起来像是通过引用传递的。</p><p id="6c4b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">顺便说一下，字符串类型是一种特殊的类型，它是不可变的，它是通过值传递的，但它只复制字符串的长度和字符串的指针。如果我们修改它，它只会创建一个新的内存空间来存储新的内容。</p><h2 id="844c" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">可见性的命名约定</h2><p id="a6ca" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">Go 中可见性的命名约定还不错，除了有点烦人。</p><p id="9e55" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Go 迫使我们在导出变量、结构和方法的第一个字符中使用大写字母，如果我们一直生活在 Go 世界中，这不是问题。</p><p id="c62f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是当我们要通过 JSON/Protocol Buffers 等在网络上交换数据的时候，在 struct 字段中添加 struct 标签就有点烦人了。</p><p id="ce10" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">struct 标签的元格式有点…嗯..太简单了！？，而且很容易一不小心出错。关于 struct 标签的另一件事是，我们需要使用<em class="kt"> reflect </em>包来获取它并自己解析它。</p><h2 id="4051" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">是否导出，结构字段没有私有属性</h2><p id="0be7" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">在包范围内，一切都像老大哥<em class="kt"> C </em>一样彼此可见，但与 C 不同的是，Go 还提供了一个简单的可见性规则:<em class="kt">使其在当前包外可见或不可见</em>。</p><p id="b61e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同样的情况又发生了，它适合小的包，但是如果有一个针对大的包的细粒度可见性控制就更好了，所以:</p><blockquote class="ku kv kw"><p id="e2ae" class="jo jp kt jq b jr js ij jt ju jv im jw kx jy jz ka ky kc kd ke kz kg kh ki kj hb bi translated">给结构字段提供私有属性，让结构字段只在结构中可见，怎么样？</p></blockquote><p id="85d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">私有成员数据，或者我们可以称之为私有结构字段，是一个常见的概念，它确实有助于防止有人篡改数据。</p><h2 id="61eb" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">Slice 建了个陷阱等着你</h2><p id="855f" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">Slice 在 Go 中的应用非常广泛，当我们把它简单地作为底层数组的只读视图使用时，它不会遇到问题。但是当我们将一个切片传入另一个函数，并试图用<code class="du ml mm mn mo b">append()</code>或<code class="du ml mm mn mo b">copy()</code>来修改切片时，就会遇到一些令人困惑和不直观的问题。</p><p id="5aec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">需要花一些时间去了解切片的内部工作原理和结构。在我看来，许多问题和陷阱与切片本身无关，但人们习惯于将切片视为值或引用/指针值，因为它看起来像值！但是切片的本质是底层数组的视图。</p><p id="5209" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一个问题是关于<code class="du ml mm mn mo b">append()</code>函数，<code class="du ml mm mn mo b">append()</code>会在目的地容量足够的情况下尽量不为底层数组分配新内存，在必要时分配新内存以避免运行时死机，然后总是返回一个可能指向相同地址也可能不指向相同地址的新片。</p><p id="393a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">切片的结构是这样的:</p><pre class="iy iz ja jb fd mp mo mq mr aw ms bi"><span id="fb7b" class="ls lb hi mo b fi mt mu l mv mw">type slice struct {<br/> array unsafe.Pointer<br/> len   int<br/> cap   int<br/>}</span></pre><p id="6dfc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一个切片值不是一个<code class="du ml mm mn mo b">slice</code>实例或者一个<code class="du ml mm mn mo b">slice</code>的指针，它更像是一个指向<code class="du ml mm mn mo b">slice.array</code>的值，你可以把一个切片值想象成<code class="du ml mm mn mo b">unsafe.Pointer((*slice)(unsafe.Pointer(&amp;A).array)</code>。</p><p id="c31c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看一个例子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nq nr l"/></div></figure><p id="fb33" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当创建长度和容量为 4 的' A '时，想要向' A '中追加一个字节，<code class="du ml mm mn mo b">append()</code>检测到' A '的容量不够，因此它为底层数组分配新的内存。</p><p id="9cdf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">' A '和' B '的底层数组的地址是不同的，而' A '和' B '的地址总是不同的，因为它们是不同的值。</p><p id="eb47" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有趣的部分是关于' C '和' D '，' C '是用零长度和 4 字节容量创建的，所以当向' C '追加一个字节时，<code class="du ml mm mn mo b">append() </code>不是分配新的内存，而是返回一个具有相同底层数组和更新长度值的新值。</p><p id="cf7c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们观察' C '和' D '，我们发现这两个值的内存地址是相同的，当我们把 slice 看成指针时，会误导我们认为' C '和' D '都指向同一个结构，所以' C '的长度应该从 0 更新为 1，但它没有。</p><p id="a452" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如我上面提到的，切片是底层数组的<strong class="jq hj">视图，它是指向底层数组的指针，而不是指向内部结构本身的指针。</strong></p><p id="b35c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从技术上来说，slice 和<code class="du ml mm mn mo b">append()</code>函数没有问题，但是提供一个类似<code class="du ml mm mn mo b">A.append(B)</code>的 slice 方法，并在这个方法中更新长度、容量和数据地址可能会更好。</p><p id="2a16" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kt">延伸阅读</em> </strong></p><div class="mx my ez fb mz na"><a rel="noopener follow" target="_blank" href="/@irbekrm/go-slices-functions-append-and-copy-e4afa7646ec4"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">执行切片、函数、追加和复制</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">我正在浏览 Go 复习一些基础知识，遇到了一个练习，你必须写一个简单的结构…</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">medium.com</p></div></div><div class="ni l"><div class="om l nk nl nm ni nn jh na"/></div></div></a></div><div class="mx my ez fb mz na"><a href="https://blog.golang.org/slices-intro" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">Go 博客</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">Andrew Gerrand 2011 年 1 月 5 日简介 Go 的切片类型提供了一种方便有效的工作方式…</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">blog.golang.org</p></div></div><div class="ni l"><div class="on l nk nl nm ni nn jh na"/></div></div></a></div><h1 id="f070" class="la lb hi bd lc ld le lf lg lh li lj lk io ll ip lm ir ln is lo iu lp iv lq lr bi translated">美丽而混乱</h1><h2 id="68c6" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">godoc 很简单，但是也太简单了</h2><p id="566b" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">刚开始学围棋的时候，看 API 文档的时候觉得头晕。我记得我当时的想法:</p><ul class=""><li id="d47e" class="nv nw hi jq b jr js ju jv jx nx kb ny kf nz kj oa ob oc od bi translated">关于输入参数的描述在哪里？</li><li id="be76" class="nv nw hi jq b jr oe ju of jx og kb oh kf oi kj oa ob oc od bi translated">哪一段是关于返回值的？</li><li id="7fdc" class="nv nw hi jq b jr oe ju of jx og kb oh kf oi kj oa ob oc od bi translated">为什么他们不标记参数，而是让它看起来像普通的单词？</li><li id="b6da" class="nv nw hi jq b jr oe ju of jx og kb oh kf oi kj oa ob oc od bi translated">为什么这么多方法的返回值都是错误的，但我却很少看到相关的描述？</li></ul><p id="2bdf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我开始阅读 godoc 文档之后，我终于解决了我的困惑，哦…它是一个纯文本格式，除了 godoc 解析器可以解析 url 之外，没有其他任何东西。</p><blockquote class="ku kv kw"><p id="7d28" class="jo jp kt jq b jr js ij jt ju jv im jw kx jy jz ka ky kc kd ke kz kg kh ki kj hb bi translated">甚至 UNIX 手册页也像爷爷一样把事情描述得更清楚</p></blockquote><p id="8296" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">纯文本格式很容易编写，Go 提供官方工具来支持文档化确实是一件好事，但是编写无标记的格式需要编写更多内容来更好地描述参数和返回值，人们需要充当词法分析器来搜索关于参数和返回值的关键字，有时由于 Go 中的速记命名约定而有点累。</p><p id="fc3b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我看来，如果有一个官方的方法来标记参数和返回值，比如<a class="ae jn" href="https://en.wikipedia.org/wiki/Javadoc" rel="noopener ugc nofollow" target="_blank"> javadoc </a>，那就太好了。</p><h2 id="f625" class="ls lb hi bd lc lt lu lv lg lw lx ly lk jx lz ma lm kb mb mc lo kf md me lq mf bi translated">Go 模块不错，可以进一步改进</h2><p id="3210" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">Go 模块大概是 Go v1.11 引入时最激动人心的。</p><p id="e299" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它省去了依赖性管理的麻烦，我喜欢使用 URL 作为模块名称空间的惯用方式，看起来很清楚，避免了命名冲突问题。</p><p id="d766" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不幸的是，因为人们使用 GOPATH 多年，所以 Go 模块需要尽可能兼容，为了向后兼容，当我们即将发布新的主要版本时，事情变得有点尴尬。</p><blockquote class="ku kv kw"><p id="3efb" class="jo jp kt jq b jr js ij jt ju jv im jw kx jy jz ka ky kc kd ke kz kg kh ki kj hb bi translated">推荐的策略是在以主要版本后缀命名的目录中开发<code class="du ml mm mn mo b">v2+</code>模块。— <a class="ae jn" href="https://blog.golang.org/v2-go-modules" rel="noopener ugc nofollow" target="_blank"> Go 模块:v2 及以上</a></p></blockquote><p id="6be1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<a class="ae jn" href="https://blog.golang.org/v2-go-modules" rel="noopener ugc nofollow" target="_blank"> Go Modules: v2 and Beyond </a>中，解释了为什么这是推荐的方式，而不是为主要版本创建 v+分支的常见方式。</p><p id="a7ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我希望 Go 模块可以更好地处理这个问题。</p><p id="b548" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">提供一种从私有库获取模块的简单方法</strong></p><p id="d73b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">流行的包管理器<a class="ae jn" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>很好的处理了这个话题。它支持多种方式访问 git 库，支持通过 ssh、git 和 https 访问，有或没有访问令牌，它支持从库直接获取包，从 gzipped tarball，从本地目录，从注册表…等等。</p><p id="5bf1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">简而言之，npm 提供了一种更灵活的方式来获取包，然后进入模块。</p><p id="955c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于托管在启用了身份验证的私有存储库中的 Go 模块，我们需要首先设置一些东西:</p><ul class=""><li id="8268" class="nv nw hi jq b jr js ju jv jx nx kb ny kf nz kj oa ob oc od bi translated">设置 GOPRIVATE 环境变量以绕过官方代理</li><li id="ed61" class="nv nw hi jq b jr oe ju of jx og kb oh kf oi kj oa ob oc od bi translated">在 git 配置中做一些小技巧。</li><li id="f0c6" class="nv nw hi jq b jr oe ju of jx og kb oh kf oi kj oa ob oc od bi translated">如有必要，设置 GONOSUMDB 环境变量。</li></ul><p id="2b59" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一般来说，对于不同的模块源，Go 模块和模块代理可能需要更灵活的符号。</p><p id="4ea6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kt">延伸阅读</em> </strong></p><div class="mx my ez fb mz na"><a href="https://blog.golang.org/v2-go-modules" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">Go 博客</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">Jean de Klerk 和 Tyler Bui-Palsulich 2019 年 11 月 7 日引言本文是系列文章的第 4 部分。作为一个成功的…</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">blog.golang.org</p></div></div><div class="ni l"><div class="oo l nk nl nm ni nn jh na"/></div></div></a></div><div class="mx my ez fb mz na"><a href="https://blog.golang.org/v2-go-modules" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">Go 博客</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">Jean de Klerk 和 Tyler Bui-Palsulich 2019 年 11 月 7 日引言本文是系列文章的第 4 部分。作为一个成功的…</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">blog.golang.org</p></div></div><div class="ni l"><div class="oo l nk nl nm ni nn jh na"/></div></div></a></div><div class="mx my ez fb mz na"><a rel="noopener follow" target="_blank" href="/cloud-native-the-gathering/go-modules-with-private-git-repositories-dfe795068db4"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">带有私有 Git 库的 Go 模块</h2><div class="no l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">如何配置 Go 模块来使用私有 Git 库，包括本地开发和 Docker 的例子。</h3></div><div class="nh l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">medium.com</p></div></div><div class="ni l"><div class="op l nk nl nm ni nn jh na"/></div></div></a></div><h1 id="4a4f" class="la lb hi bd lc ld le lf lg lh li lj lk io ll ip lm ir ln is lo iu lp iv lq lr bi translated">结论</h1><p id="d0e8" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">现实世界，美与乱共存不是矛盾，而是一种常态，每个人对美或乱都有不同的看法。</p><p id="ef29" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我开始写这篇文章的时候，它原本期望是一篇表达我个人观点的 3 ~ 4 页的文章，尽量做到中立公正。但是正如你所看到的，一个观点会带来其他观点，就像积极的一面总是有另一面。</p><p id="a0ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我对围棋的感觉很复杂，我个人对围棋或其他语言的偏好更明确。比如我喜欢 C++，即使它超级复杂，语法看起来也不好看；我不喜欢 Java，即使我尊重它的许多好的语言设计理念；我喜欢 Javascript(现代版)即使它这么乱；我不喜欢 Python，因为它很慢。</p><p id="123d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Go 就像一个友善的大叔，幽默风趣，精力充沛，但也偏执固执，有时喜欢穿时髦的行头，但有时又坚持旧毛衣是最好的。</p><p id="88c3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">围棋的独特魅力和特点让你很快喜欢上了它，并开始对它抱有期望，然后你可能会开始觉得它有点顽固，最后你学会习惯它。</p><p id="0f36" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">简单是美好的，少即是多，我看到围棋团队为了保持简单付出了很多努力。事实上，围棋很容易学习，也很容易在生产环境中使用。但是如果我们总是谈论简单，那么专注于简单会带来困惑，然后事情会变得复杂。</p><p id="94b8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">编程语言流行总是有原因的。比如:当<a class="ae jn" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> node.js </a>遇到<a class="ae jn" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> express </a>框架，当<a class="ae jn" href="https://www.ruby-lang.org/" rel="noopener ugc nofollow" target="_blank"> Ruby </a>遇到<a class="ae jn" href="https://rubyonrails.org/" rel="noopener ugc nofollow" target="_blank"> Rails </a>的时候，PHP……嗯，让我们跳过。性能、并发和云友好的特性使人们开始从其他语言转向 Go。</p><p id="154a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同样的事实也适用于我，在我的常规使用场景中，Go 可以节省大量时间来实现高性能、低延迟和实时的 web 服务。我喜欢使用 node.js 在前端提供 RESTful API，让 node.js 做数据验证和其他 I/O 密集型工作，然后将写入的任务调度到后端并发执行计算任务。</p><p id="e9c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我希望这篇文章能给你一些提示，提供一些你以前可能没有意识到的观点。如果你能在阅读后避免陷入一些陷阱，那将是我的荣幸。</p></div></div>    
</body>
</html>