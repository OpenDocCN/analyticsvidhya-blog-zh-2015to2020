<html>
<head>
<title>Data preprocessing techniques with scikit-learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">scikit-learn 的数据预处理技术</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-preprocessing-techniques-with-scikit-learn-f403e72d532?source=collection_archive---------19-----------------------#2020-08-29">https://medium.com/analytics-vidhya/data-preprocessing-techniques-with-scikit-learn-f403e72d532?source=collection_archive---------19-----------------------#2020-08-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2c42e4b4c30345941a224842a390a625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjDV85QYa0quGsjRJtqN1g.jpeg"/></div></div></figure><p id="e783" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">scikit-learn 库包括用于数据预处理和数据挖掘的工具。它是通过语句<code class="du jo jp jq jr b">import sklearn</code>导入 Python 的。</p><h1 id="0010" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">1.使标准化</h1><p id="6eca" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">数据可以包含各种不同的值。当数据取任何范围的值时，都很难解释。因此，我们应该将数据转换成标准格式，以便于理解。数据的标准格式是指 0 均值和单位方差。这是一个简单的过程。对于每个数据值，<em class="kv"> x </em>，我们减去数据的总体平均值μ，然后除以总体标准偏差σ。</p><p id="03cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">scikit-learn 数据预处理模块被称为<code class="du jo jp jq jr b">sklearn.preprocessing</code>。这个模块中的函数之一，<code class="du jo jp jq jr b"><a class="ae kw" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html#sklearn.preprocessing.scale" rel="noopener ugc nofollow" target="_blank">scale</a></code>，将数据标准化应用到一个 NumPy 数组的给定轴上。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="74b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果出于某种原因，我们需要跨行而不是列标准化数据，我们可以将<code class="du jo jp jq jr b">scale</code>函数中的<code class="du jo jp jq jr b">axis</code>关键字参数设置为 1。在分析观测数据而非要素数据时，可能会出现这种情况。</p><h1 id="22c7" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">2.数据范围</h1><p id="ed65" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">在本节中，我们将学习如何将数据值压缩到指定的范围。</p><h2 id="62cc" class="ld jt hi bd ju le lf lg jy lh li lj kc jb lk ll kg jf lm ln kk jj lo lp ko lq bi translated">范围缩放</h2><p id="72d7" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">我们可以通过将数据压缩到一个固定的范围来扩展数据，而不是将其标准化。其中一个常见的用例是将数据压缩到[0，1]范围内。</p><p id="65b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个分两步走的过程。</p><ul class=""><li id="767f" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">对于给定的数据值，我们首先计算该值相对于数据的最小值和最大值的比例</li><li id="35b2" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">然后，我们使用该值的比例缩放到指定的范围。</li></ul><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/bc9ff00c3dd7fc164f543ccd7dbab498.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*CGWt3RE0hgm9eojtlf2UdQ.png"/></div></figure><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/7606e90a9662da5ac5d4086407c54b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*_DbwovM_0daewSqI0wqqrQ.png"/></div></div></figure><h2 id="70ac" class="ld jt hi bd ju le lf lg jy lh li lj kc jb lk ll kg jf lm ln kk jj lo lp ko lq bi translated">scikit 中的范围压缩-学习</h2><p id="d6ea" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">在前一章中，我们使用了一个函数<code class="du jo jp jq jr b">scale</code>来执行数据标准化，剩下的章节将集中讨论如何使用其他的 transformer 模块。</p><p id="d585" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b"><a class="ae kw" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler" rel="noopener ugc nofollow" target="_blank">MinMaxScaler</a></code>转换器使用之前的公式执行范围压缩。默认范围是[0，1]。</p><p id="e2c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">MinMaxScaler</code>包含一个名为<code class="du jo jp jq jr b">fit_transform</code>的函数，允许它接收输入数据数组，然后输出缩放后的数据。该函数是对象的<code class="du jo jp jq jr b">fit</code>和<code class="du jo jp jq jr b">transform</code>函数的组合，前者接受一个输入数据数组，后者根据来自<code class="du jo jp jq jr b">fit</code>函数输入的数据转换一个(可能不同的)数组。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h1 id="ff59" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">3.稳健缩放</h1><p id="f859" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">离群值是指距离其他数据点非常远的数据点。</p><p id="603a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前两章的数据缩放方法都受到异常值的影响。数据标准化使用每个要素的平均值和标准差，而范围缩放使用最大值和最小值，这意味着它们都容易受到异常值的影响。</p><p id="9d53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过使用数据的中位数和<a class="ae kw" href="https://en.wikipedia.org/wiki/Interquartile_range" rel="noopener ugc nofollow" target="_blank">四分位间距(IQR) </a>，稳健地扩展数据，即避免受异常值的影响。它们不受离群值的影响。对于缩放方法，我们只需从每个数据值中减去中值，然后缩放到 IQR。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h1 id="c302" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">4.数据插补</h1><p id="5eb7" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">现实生活中的数据集通常包含缺失值。如果数据集缺少太多的值，我们就不使用它。但是，如果只有几个值缺失，我们可以进行数据插补，用其他值替代缺失的数据。</p><p id="cbb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">-* *数据插补有几种方法。在 scikit-learn 中，<code class="du jo jp jq jr b"><a class="ae kw" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html#sklearn.impute.SimpleImputer" rel="noopener ugc nofollow" target="_blank">SimpleImputer</a></code>转换器执行四种不同的数据插补方法。</p><ul class=""><li id="3107" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">使用平均值</li><li id="6b53" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">使用中间值</li><li id="bcc8" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">使用最频繁的值</li><li id="a2d4" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">使用常数值</li></ul><p id="68b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过在初始化<code class="du jo jp jq jr b">SimpleImputer</code>对象时使用<code class="du jo jp jq jr b">strategy</code>关键字参数，我们可以指定不同的插补方法。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="a3bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据插补不限于这四种方法。</p><p id="d541" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有更高级的插补方法，如<a class="ae kw" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank">k-最近邻</a>(根据 kNN 算法的相似性分数填充缺失值)和<a class="ae kw" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3074241/" rel="noopener ugc nofollow" target="_blank"> MICE </a>(应用多重链式插补，假设缺失值随机分布在观察值中)。</p><h1 id="433c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">5.主成分分析</h1><p id="4b3a" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">当数据集包含这些类型的相关数字特征时，我们可以执行<a class="ae kw" href="https://en.wikipedia.org/wiki/Principal_component_analysis" rel="noopener ugc nofollow" target="_blank">主成分分析(PCA) </a>进行降维(即减少数据阵列中的列数)。它可以提取数据集的主成分，这些主成分是不相关的潜在变量集，包含原始数据集中的大部分信息。</p><p id="4171" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以在 scikit-learn 中用一个转换器将 PCA 应用于数据集，在本例中是 PCA 模块。在初始化<code class="du jo jp jq jr b">PCA</code>模块时，我们可以使用<code class="du jo jp jq jr b">n_components</code>关键字来指定主成分的个数。默认设置是提取<em class="kv"> m - 1 </em>个主成分，其中<em class="kv"> m </em>是数据集中特征的数量。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure></div></div>    
</body>
</html>