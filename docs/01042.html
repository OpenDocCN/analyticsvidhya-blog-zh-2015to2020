<html>
<head>
<title>Machine Learning: Models to Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习:从模型到生产</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-models-to-production-part-1-build-your-own-sklearn-pipeline-e7aa7c06152a?source=collection_archive---------3-----------------------#2019-09-27">https://medium.com/analytics-vidhya/machine-learning-models-to-production-part-1-build-your-own-sklearn-pipeline-e7aa7c06152a?source=collection_archive---------3-----------------------#2019-09-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5045" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第1部分—构建您自己的Sklearn管道</h2></div><p id="d5f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是关于如何使用Sklearn管道构建机器学习模型、将它们转换为包并在生产环境中部署模型的多部分系列的第一部分。有许多方法可以做到这一点，这里介绍的方法只是其中之一。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/ea8b9914b6f1bc1f028070ea124df0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9R-o-lCbWIqyWk0txJHOjA.jpeg"/></div></div></figure><p id="5694" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">什么是Scikit-learn管道</strong></p><p id="864f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">管道是实现过程化编程的方法之一。在过程编程范例中，过程(函数或子例程)是作为一系列计算步骤来执行的。</p><p id="85d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">建立机器学习模型有很多步骤。数据几乎从来都不是干净的，你需要做一些预处理(如标准化、转换、特征工程等)来确保你的模型的速度和精度达到标准。要实现过程化编程，一种方法是为所有单个进程编写单个函数，并按顺序调用它们来分别训练和测试数据集。另一种方法是利用Scikit-learn pipeline的强大功能，使这一过程更加简单、可重复、易于理解、易于调试和可执行(以确保不遗漏任何步骤)。此外，通过这种方式，模型更容易部署到生产环境中。</p><h1 id="d4fe" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">sci kit-学习管道</h1><p id="79c5" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">python中的Scikit-learn库是机器学习中功能强大且使用最多的库之一。它提供了一系列算法的有效实现，从数据转换、预处理到整套机器学习模型。它被写成一种形式，使得它的大多数算法遵循相同的功能。这意味着，如果您知道实现逻辑回归的代码，您可以运行SVM或决策树分类器，但只需更改分类器的名称和一些参数(或多或少)，代码就会运行良好。Scikit-learn已经非常成熟，其他库中的新包(如Keras)在设计时都考虑到了scikit-learn的功能。</p><p id="1784" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">代码示例概述:</strong></p><p id="f80c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码示例的A部分和B部分只是展示了如何为一个简单的模型实现这一点，代码不会自己运行。您需要下载数据集并导入必要的库，代码片段仅作为指导。代码的C部分分为两部分——使用函数构建预测模型，以及使用带有自定义类的Sklearn管道构建预测模型</p><p id="4b7d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一部分:用于特征工程和预测的非常基本的管道实现</p><p id="3389" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二部分:使用预建管道实现多种算法，以快速构建模型</p><p id="a13d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">C部分:</p><ul class=""><li id="6b68" class="lc ld hi iz b ja jb jd je jg le jk lf jo lg js lh li lj lk bi translated">使用函数实现预测算法</li><li id="f5ae" class="lc ld hi iz b ja ll jd lm jg ln jk lo jo lp js lh li lj lk bi translated">将函数转换成遵循OOP范式的类，并构建定制的管道</li></ul><h2 id="af22" class="lq kg hi bd kh lr ls lt kl lu lv lw kp jg lx ly kr jk lz ma kt jo mb mc kv md bi translated">A部分:基本管道代码</h2><p id="e680" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">这只是为了展示使用管道的预测模型是什么样子。网上有更详细的解释。</p><p id="119a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据:声纳矿岩石数据集【来源<a class="ae me" href="http://archive.ics.uci.edu/ml/datasets/connectionist+bench+(sonar,+mines+vs.+rocks)" rel="noopener ugc nofollow" target="_blank"> UCI ML Repo(原始)</a>和<a class="ae me" href="https://www.kaggle.com/adx891/sonar-data-set" rel="noopener ugc nofollow" target="_blank">ka ggle(CSV)】</a></p><p id="97d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不会深入数据的细节，这是一个非常简单的分类数据，没有任何缺失值或不同的数据类型，您可以通过几行代码对这些数据运行一个粗略的模型。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="40ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个例子:将fit和predict方法链接在一起(来源:StackOverFlow)</p><p id="d553" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">词向量上的分类器:没有管道</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="7584" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面相同的代码，使用管道</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h2 id="1a10" class="lq kg hi bd kh lr ls lt kl lu lv lw kp jg lx ly kr jk lz ma kt jo mb mc kv md bi translated">B部分:连接多个管道</h2><p id="98b3" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">这是上述代码的扩展，来源于杰森·布朗利的博客(<a class="ae me" href="https://machinelearningmastery.com/automate-machine-learning-workflows-pipelines-python-scikit-learn/" rel="noopener ugc nofollow" target="_blank">machinelingmastery</a>)。你应该看看他的博客。这是一种将具有不同模型的多个管道链接在一起的方式，以便一次性快速评估多个算法。</p><p id="bc4f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意—在对任何数据集运行此操作之前，导入必要的库。假设X_train、X_test、Y_train和Y_test来自A部分的somarminesrocks数据集</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="ae3c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">减少代码并确保训练和测试遵循相同程序的好方法！</p><p id="67d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种方法有一个问题——这些是预构建的函数和模块，尽管它们在定义参数方面提供了一定程度的灵活性，但它不允许您修改这些函数的运行方式，或者如果您想以不同的方式做事。</p><p id="f86d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数时候，在几乎99%的数据科学工作中，您必须编写某些自定义函数，然后才能将数据集提供给这些管道。这些过程包括输入缺失值、分类变量的标签编码、正确处理日期变量(将日期转换为月份，或者计算不同列中两个日期之间的天数差)、非高斯的某些要素的对数变换(或任何其他变换)、删除某些要素，或者在调用任何模型之前需要运行的任何其他预处理步骤。创建自定义管道是有效实现这一点的关键。</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="2396" class="kf kg hi bd kh ki mo kk kl km mp ko kp io mq ip kr ir mr is kt iu ms iv kv kw bi translated">定制的Scikit-learn管道</h1><p id="97dd" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated"><strong class="iz hj">优点</strong>:</p><ul class=""><li id="d8ac" class="lc ld hi iz b ja jb jd je jg le jk lf jo lg js lh li lj lk bi translated">以您想要的方式定义预处理—因为每个数据都是不同的，所以应该以这种方式完成</li><li id="2837" class="lc ld hi iz b ja ll jd lm jg ln jk lo jo lp js lh li lj lk bi translated">以健壮的面向对象的方式实现，所以这种方法是非常结构化的</li><li id="db76" class="lc ld hi iz b ja ll jd lm jg ln jk lo jo lp js lh li lj lk bi translated">处理数据中出现的异常，并采取必要的措施</li><li id="6f22" class="lc ld hi iz b ja ll jd lm jg ln jk lo jo lp js lh li lj lk bi translated">非常适合生产级代码，以及将模型转换成包</li></ul><p id="d1ab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过将整个代码分成不同的模块，可以获得一个关键的优势——一个文件用于配置变量，一个代码用于为每个预处理步骤构建管道，一个代码用于数据导入/导出&amp;保存/加载模型，一个主代码用于调用和运行管道来训练和保存模型，一个代码用于对任何数据运行预测。这种模块化的方法将整个代码分成块，使得维护和调试变得容易。此外，如果你想添加一个新的特性转换器，或者修改其他东西，你可以只修改模块的一部分，而不需要遍历整个代码。</p><h2 id="fa36" class="lq kg hi bd kh lr ls lt kl lu lv lw kp jg lx ly kr jk lz ma kt jo mb mc kv md bi translated">Scikit-learn对象的组件:</h2><p id="ed33" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated"><strong class="iz hj"> Transformers </strong>:具有用于转换数据的fit和transform方法的类</p><ul class=""><li id="8237" class="lc ld hi iz b ja jb jd je jg le jk lf jo lg js lh li lj lk bi translated">示例:缩放器、特征选择器或onehot编码器</li></ul><p id="21ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">预测器</strong>:具有拟合和预测方法的类——用于预测</p><ul class=""><li id="21df" class="lc ld hi iz b ja jb jd je jg le jk lf jo lg js lh li lj lk bi translated">示例— ML算法，如LogisticRegression、Lasso、SVC等</li></ul><p id="44bc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">管道</strong>:按顺序运行转换器和预测器的类</p><ul class=""><li id="2dcb" class="lc ld hi iz b ja jb jd je jg le jk lf jo lg js lh li lj lk bi translated">除了最后一步，所有步骤都应该是变形金刚</li><li id="b272" class="lc ld hi iz b ja ll jd lm jg ln jk lo jo lp js lh li lj lk bi translated">最后一步应该是预测器</li></ul><h2 id="d8c9" class="lq kg hi bd kh lr ls lt kl lu lv lw kp jg lx ly kr jk lz ma kt jo mb mc kv md bi translated"><strong class="ak">C部分——代码示例:将函数转换为Sklearn类</strong></h2><p id="684b" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">数据:<a class="ae me" href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data" rel="noopener ugc nofollow" target="_blank">【ka ggle】:房价预测</a>。访问Kaggle页面获取数据描述和其他详细信息</p><p id="0155" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">目标</strong>:给定一组数字、分类和时间特征，预测房屋的销售价格。</p><p id="5195" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">挑战</strong>:数据有很多缺失变量，也有不同的数据类型(数值和分类)。此外，一些功能是歪斜的，所以需要转换。分类变量需要编码。可以应用更多的预处理，这只是代码的演示版本。</p><p id="2cfb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">例1: </strong></p><p id="04fb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的函数将一个数据帧(' X ')和一个分类特征列表(' features ')作为输入，并返回缺失值替换为' missing '的数据帧。可以对任何数据帧调用此函数来替换分类变量中缺失的值</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="1318" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Scikit-learn类，用于将分类数据中的缺失值转换为“缺失”</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="cf60" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">BaseEstimator和TransformerMixin:从启用管道功能的sklearn.base模块继承的类</p><p id="2ca3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">例2: </strong></p><p id="67e7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码分类变量——标准标签编码器，按照目标变量在每个类别中出现的频率顺序分配标签</p><p id="174d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">功能:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="23d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Sklearn类:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="9a1d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">完整代码:</strong></p><p id="bcb3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.配置变量—用于定义变量列表。这可以在首先运行模型、理解数据和识别特征之后获得。通常，这保存在一个单独的文件(config.py)中</p><p id="2894" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.实现函数-使用函数进行数据处理和预测</p><p id="8d2e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.实现管道-使用管道进行数据处理和预测</p><p id="6369" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">配置变量:功能代码和管道代码通用</strong></p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="aed8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">实现用于预测的功能代码(以有点粗糙的形式编写，以确保所有步骤都是可见的。这里可以使用方法链接来链接多个函数，或者使用单独的函数来调用它们，下面的例子只是步骤的分解)</strong></p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="0e97" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">管道代码:将每个函数转换成一个sklearn类，并将它们放入管道</strong></p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="2ccf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦定义了类，下一步就是构建<strong class="iz hj">管道</strong></p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf mg l"/></div></figure></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><p id="c7af" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Github代码可以在<a class="ae me" href="https://github.com/ashukumar27/Python_ML_Package/tree/master/01_model_training" rel="noopener ugc nofollow" target="_blank">这里</a>访问。</p><h1 id="c810" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">第2部分:<a class="ae me" rel="noopener" href="/analytics-vidhya/machine-learning-models-to-production-72280c3cb479">从您的ML模型构建Python包</a></h1></div></div>    
</body>
</html>