<html>
<head>
<title>Introduction to Anomaly Detection using Machine Learning with a Case Study</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习的异常检测简介及案例研究</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/introduction-to-anomaly-detection-using-machine-learning-with-a-case-study-part-two-f78243f74d2f?source=collection_archive---------1-----------------------#2020-04-01">https://medium.com/analytics-vidhya/introduction-to-anomaly-detection-using-machine-learning-with-a-case-study-part-two-f78243f74d2f?source=collection_archive---------1-----------------------#2020-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="53fd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第二部分:使用PyOD工具包识别欺诈性信用卡交易。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6f9dddb0660a9797478dd7da4f768dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZNCcDaIUt5OnVsR1QuUbDA.jpeg"/></div></div></figure><p id="68fc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是我的系列的第二部分，也是最后一部分，重点是使用机器学习进行异常检测。如果这是你第一次，我推荐你阅读我的第一篇文章<a class="ae kf" rel="noopener" href="/@Davis_David/introduction-to-anomaly-detection-using-machine-learning-with-a-case-study-part-one-3fa2ae08f413">这里</a>，它将向你介绍异常检测及其在商业世界中的应用。</p><p id="5e89" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我将带您了解一个关于<strong class="jl hj">信用卡欺诈检测</strong>的案例研究。信用卡公司能够识别欺诈性的信用卡交易是很重要的，这样客户就不会为他们没有购买的商品付费。所以主要任务是通过使用机器学习来识别欺诈性的信用卡交易。我们将使用一个名为<strong class="jl hj"> PyOD </strong>的Python库，它是专门为异常检测而开发的。</p><h1 id="9afe" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">什么是PYOD库</h1><p id="0ce5" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">PyOD是一个全面且可扩展的<strong class="jl hj"> Python工具包</strong>，用于<strong class="jl hj">检测多元数据中的无关对象</strong>。它有大约20个异常检测算法(监督和非监督)。PyOD开发了一个全面的API来支持多种技术，你可以在这里看看PyOD <a class="ae kf" href="https://pyod.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">的官方文档。</a></p><p id="b77a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你是一个异常检测专家，或者你想学习更多关于异常检测的知识，那么我建议你尝试使用PYOD工具包。</p><h1 id="658a" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">PyOD的特征</h1><p id="a7cf" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">PyOD的特色是:</p><ul class=""><li id="06d7" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">跨各种算法的统一API、详细文档和交互式示例。</li><li id="d620" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">高级模型，包括神经网络/深度学习和离群值集成。</li><li id="effc" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">使用<a class="ae kf" href="https://github.com/numba/numba" rel="noopener ugc nofollow" target="_blank"> numba </a>和<a class="ae kf" href="https://github.com/joblib/joblib" rel="noopener ugc nofollow" target="_blank"> joblib </a>，尽可能通过JIT和并行化优化性能。</li><li id="2c68" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">兼容Python 2和3。(对python 2的支持截止到2020年1月)。</li></ul><h2 id="b775" class="lr kh hi bd ki ls lt lu km lv lw lx kq js ly lz ks jw ma mb ku ka mc md kw me bi translated">在Python中安装PyOD</h2><p id="7a76" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">让我们首先在我们的机器上安装PyOD。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="10de" class="lr kh hi mg b fi mk ml l mm mn">pip install pyod            <em class="mo"># normal install</em><br/>pip install --pre pyod      <em class="mo"># pre-release version for new features</em></span></pre><p id="dd60" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">或者，您可以克隆并运行setup.py文件。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="aea6" class="lr kh hi mg b fi mk ml l mm mn">git clone https://github.com/yzhao062/pyod.git<br/>cd pyod<br/>pip install .</span></pre><p id="9038" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="mo">如果您计划在Pyod中使用基于神经网络的模型，您必须在您的机器中手动安装Keras和其他库。</em></p><h1 id="d44b" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated"><strong class="ak">信用卡欺诈检测案例研究</strong></h1><p id="4bad" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">我们将使用的数据集包含2013年9月欧洲持卡人的信用卡交易。该数据集是在Worldline和ULB(布鲁塞尔自由大学)的<a class="ae kf" href="http://mlg.ulb.ac.be" rel="noopener ugc nofollow" target="_blank">机器学习小组</a>就大数据挖掘和欺诈检测进行研究合作期间收集和分析的。</p><p id="1ea4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们看看如何在这个案例研究中使用PYOD库。我们将从导入熊猫、numpy、sklearn、pyod等重要包开始。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="29dc" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># Import important packages</em><br/><strong class="mg hj">import</strong> <strong class="mg hj">pandas</strong> <strong class="mg hj">as</strong> <strong class="mg hj">pd</strong><br/><strong class="mg hj">import</strong> <strong class="mg hj">numpy</strong> <strong class="mg hj">as</strong> <strong class="mg hj">np</strong><br/><strong class="mg hj">import</strong> <strong class="mg hj">scipy</strong><br/><strong class="mg hj">import</strong> <strong class="mg hj">sklearn</strong><br/><strong class="mg hj">import</strong> <strong class="mg hj">matplotlib.pyplot</strong> <strong class="mg hj">as</strong> <strong class="mg hj">plt</strong> <br/><strong class="mg hj">import</strong> <strong class="mg hj">seaborn</strong> <strong class="mg hj">as</strong> <strong class="mg hj">sns</strong> <br/><strong class="mg hj">from</strong> <strong class="mg hj">sklearn.model_selection</strong> <strong class="mg hj">import</strong> train_test_split <br/><strong class="mg hj">from</strong> <strong class="mg hj">sklearn.metrics</strong> <strong class="mg hj">import</strong> classification_report, accuracy_score,confusion_matrix<br/><strong class="mg hj">from</strong> <strong class="mg hj">sklearn.ensemble</strong> <strong class="mg hj">import</strong> IsolationForest <br/><strong class="mg hj">from</strong> <strong class="mg hj">sklearn.neighbors</strong> <strong class="mg hj">import</strong> LocalOutlierFactor <br/><em class="mo"># Importing KNN module from PyOD</em><br/><strong class="mg hj">from</strong> <strong class="mg hj">pyod.models.knn</strong> <strong class="mg hj">import</strong> KNN <br/><strong class="mg hj">from</strong> <strong class="mg hj">pyod.models.ocsvm</strong> <strong class="mg hj">import</strong> OCSVM <br/><em class="mo"># Import the utility function for model evaluation</em><br/><strong class="mg hj">from</strong> <strong class="mg hj">pyod.utils.data</strong> <strong class="mg hj">import</strong> evaluate_print<br/><strong class="mg hj">from</strong> <strong class="mg hj">pyod.utils.example</strong> <strong class="mg hj">import</strong> visualize<br/><strong class="mg hj">from</strong> <strong class="mg hj">sklearn.preprocessing</strong> <strong class="mg hj">import</strong> StandardScaler<br/><strong class="mg hj">from</strong> <strong class="mg hj">cf_matrix</strong> <strong class="mg hj">import</strong> make_confusion_matrix <br/>%matplotlib inline <br/><strong class="mg hj">import</strong> <strong class="mg hj">warnings</strong> <br/>warnings.filterwarnings('ignore')<br/><br/><em class="mo"># set seed</em><br/>np.random.seed(123)<br/></span></pre><p id="a066" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">本案例研究的数据集可在<a class="ae kf" href="https://www.kaggle.com/mlg-ulb/creditcardfraud" rel="noopener ugc nofollow" target="_blank">此处</a>下载。</p><p id="e999" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们加载数据集</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="4750" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># Load the dataset from csv file by using pandas</em><br/>data = pd.read_csv("creditcard.csv")<br/></span></pre><p id="adb6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">检查数据集中的列。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="b053" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># show columns </em>data.columns</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mp"><img src="../Images/ec64a9a4aac476b0d99e8e6d159059e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*J5d1KyhAj1WAKl5Ls-JZfw.png"/></div></figure><p id="ba18" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">数据集包含31列，只有3列有意义，它们是时间、金额和类别(欺诈或非欺诈)。其余28列使用PCA降维进行转换，以保护用户身份。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="781c" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># print the shape of the data</em><br/>data.shape</span><span id="1a9b" class="lr kh hi mg b fi mq ml l mm mn">(284807, 31)</span></pre><p id="c4f7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如前所述，数据集包含284807行和31列。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="d530" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># show the first five rows <br/></em>data.head()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/a4f084ae840a5f5263e66680ab25810e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMzO3JWq2HWAPEZBOKImTA.png"/></div></div></figure><p id="e83b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可以看到所有转换后的列都被命名为从V1到V28。</p><p id="8b31" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们检查一下数据集中是否有缺失的值。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="2dbf" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo">#check missing data <br/></em>data.isnull().sum()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ms"><img src="../Images/4cb1bf2f8b45459d9db465e10eb15186.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*wTCkXVxS845btXj4Ur7EEw.png"/></div></figure><p id="aef2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的数据集中没有任何缺失值。</p><p id="e09b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的目标列是包含两个类的类，一个是标记为<strong class="jl hj"> 1 </strong>的欺诈类，另一个是标记为<strong class="jl hj"> 0的非欺诈类。</strong></p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="ebb4" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># determine number of fraud cases in our  file</em><br/>data.Class.value_counts(normalize=<strong class="mg hj">True</strong>)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/1e9b6e34d4ad3d437bc8059241ead63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*U2ovJguHpoRBbtqa3vVs3g.png"/></div></div></figure><p id="bed3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这个数据集中，只有0.173%(共492笔)的欺诈交易和99.82%(共284315笔)的有效交易。</p><p id="6884" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以通过使用seaborn库中实现的热图来观察数据集中的变量是否相互关联。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="408f" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo">#find the correlation betweeen the variables </em><br/><br/>corr = data.corr() <br/><br/>fig = plt.figure(figsize=(30,20))<br/><br/>sns.heatmap(corr, vmax=.8, square=<strong class="mg hj">True</strong>,annot=<strong class="mg hj">True</strong>)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/8dad5476f6a40b76d726f7d88b2394fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-C88iPGJqR-uMFW8fcPXeg.png"/></div></div></figure><p id="e1a4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上图显示<strong class="jl hj"> V11变量</strong>与<strong class="jl hj">类变量</strong>强正相关，而<strong class="jl hj"> V17变量</strong>与<strong class="jl hj">类变量强负相关。</strong></p><p id="2659" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为我们有许多有效交易，所以我们将使用所有10，000个有效案例和492个欺诈案例来创建我们的模型。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="ea80" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># use sample of the dataset </em><br/><br/>positive = data[data["Class"]== 1]<br/>negative = data[data["Class"]== 0]<br/><br/><br/>print("positive:<strong class="mg hj">{}</strong>".format(len(positive)))<br/>print("negative:<strong class="mg hj">{}</strong>".format(len(negative)))<br/><br/>new_data = pd.concat([positive,negative[:10000]])<br/><br/><em class="mo">#shuffling our dataset </em><br/>new_data = new_data.sample(frac=1,random_state=42)<br/><br/><br/>new_data.shape</span></pre><p id="b452" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正:492 <br/>负:284315</p><p id="04d3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi">(10492,31)</p><p id="ed68" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们总共有10492行。</p><p id="fc10" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将通过使用sklearn的<a class="ae kf" href="https://onlinecoursetutorials.com/machine-learning/sklearn-preprocessing-standardscaler-function-with-example-in-python/" rel="noopener ugc nofollow" target="_blank"> standardScaler </a>方法来标准化数量变量。StandardSclaer将数据转换为平均值为0、标准差为1的数据，这意味着将数据标准化为正态分布。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="57e9" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo">#Normalising the amount column.</em><br/>new_data['Amount'] = StandardScaler().fit_transform(new_data['Amount'].values.reshape(-1,1))</span></pre><p id="ebaa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将数据集分成自变量和目标变量(类变量)。</p><p id="6eb6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="mo"> NB。在本文中，我们不打算使用时间变量。</em></p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="24eb" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># split into independent variables and target variable<br/></em>X = new_data.drop(['Time','Class'], axis=1) <br/>y = new_data['Class']  <br/><em class="mo"># show the shape of x and y </em> <br/>print("X shape: <strong class="mg hj">{}</strong>".format(X.shape)) <br/>print("y shape: <strong class="mg hj">{}</strong>".format(y.shape))</span><span id="2247" class="lr kh hi mg b fi mq ml l mm mn">X shape: (10492, 29)<br/>y shape: (10492,)</span></pre><p id="858c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将数据集分为训练集和测试集。我们将只使用数据集的20%作为测试集，其余的将作为训练集。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="e4d3" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo">#split the data into train and test <br/></em>X_train, X_test, y_train,y_test = train_test_split(X,y, test_size = 0.2, stratify=y, random_state=42 )</span></pre><h2 id="8c66" class="lr kh hi bd ki ls lt lu km lv lw lx kq js ly lz ks jw ma mb ku ka mc md kw me bi translated"><strong class="ak">创建模型</strong></h2><p id="7234" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">我们将从PyOD库中创建两个离群点检测器，它们是K近邻检测器和一类SVM检测器。</p><h2 id="f9a2" class="lr kh hi bd ki ls lt lu km lv lw lx kq js ly lz ks jw ma mb ku ka mc md kw me bi translated"><strong class="ak"> 1。k-最近邻检测器</strong></h2><p id="974b" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">在用于任何观察的KNN检测器中，其到其第k个最近邻居的距离可以被视为外围分数。</p><p id="ff89" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">PyOD支持三个<a class="ae kf" href="https://www.analyticsvidhya.com/blog/2018/03/introduction-k-neighbours-algorithm-clustering/" rel="noopener ugc nofollow" target="_blank"> kNN </a>探测器:</p><ul class=""><li id="de1f" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj">最大:</strong>使用第k个邻居的距离作为异常值。</li><li id="4348" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><strong class="jl hj"> Mean: </strong>使用所有k个邻居的平均值作为异常值分数。</li><li id="c4fa" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><strong class="jl hj">中值:</strong>使用到k个邻居的距离的中值作为异常值分数。</li></ul><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="2975" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># create the KNN model</em><br/>clf_knn = KNN(contamination=0.172, n_neighbors = 5,n_jobs=-1)<br/><br/>clf_knn.fit(X_train)</span></pre><p id="d82a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们传递给KNN()的两个参数是</p><ul class=""><li id="4050" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj">污染:T </strong>数据中的异常量，对于我们的情况= 0.0172</li><li id="bafa" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><strong class="jl hj"> n_neighbors: </strong>测量邻近度时要考虑的邻居数量。</li></ul><p id="2136" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在训练我们的KNN检测器模型之后，我们可以获得训练数据上的预测标签，然后获得训练数据的异常值分数。分数越高越不正常。这表明数据中的总体异常。这些特性使得<strong class="jl hj"> PyOD </strong>成为异常检测任务的重要工具。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="0140" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># Get the prediction labels of the training data</em> <br/>y_train_pred = clf_knn.labels_ <em class="mo"># binary labels (0: inliers, 1: outliers)</em> </span><span id="4934" class="lr kh hi mg b fi mq ml l mm mn"><em class="mo"># Outlier scores</em> <br/>y_train_scores = clf_knn.decision_scores_ </span></pre><p id="eb73" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以根据训练数据来评估<strong class="jl hj"> KNN() </strong>。<strong class="jl hj"> PyOD </strong>为这个任务提供了一个方便的函数，叫做<strong class="jl hj"> evaluate_print()。</strong>默认指标包括<a class="ae kf" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" rel="noopener ugc nofollow" target="_blank"> ROC </a>和Precision @ n。我们将传递类名、y_train值和y_train_scores(拟合模型返回的异常值)。)</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="d62d" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># Evaluate on the training data</em> e<br/>valuate_print(‘KNN’, y_train, y_train_scores)</span></pre><p id="38c4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">KNN ROC: 0.9566，精度@排名n:0 0.5482。</p><p id="6282" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们看到<strong class="jl hj"> KNN() </strong>模型在训练数据上有很好的表现。让我们为训练集绘制混淆矩阵。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="622d" class="lr kh hi mg b fi mk ml l mm mn"><strong class="mg hj">import</strong> <strong class="mg hj">scikitplot</strong> <strong class="mg hj">as</strong> <strong class="mg hj">skplt</strong> </span><span id="356c" class="lr kh hi mg b fi mq ml l mm mn"><em class="mo"># plot the comfusion matrix in the train set </em></span><span id="df8b" class="lr kh hi mg b fi mq ml l mm mn">skplt.metrics.plot_confusion_matrix(y_train,y_train_pred, normalize=<strong class="mg hj">False</strong>,title=”Consfusion Matrix on Train Set”)</span><span id="02ba" class="lr kh hi mg b fi mq ml l mm mn"> plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mu"><img src="../Images/5cfb55923bc9f0981bf24f8e4faadcef.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*m7qEuTTHXnG7W-SSL5PnVg.png"/></div></figure><p id="45c0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在训练集中，372个欺诈案例被正确预测，只有22个案例被错误预测为有效案例。</p><p id="b8c5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将使用decision_function来预测使用拟合检测器(KNN检测器)的测试集的异常分数，并评估结果。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="46fd" class="lr kh hi mg b fi mk ml l mm mn">y_test_scores = clf_knn.decision_function(X_test)  <em class="mo"># outlier scores</em><br/><br/><em class="mo"># Evaluate on the training data</em><br/>evaluate_print('KNN', y_test,y_test_scores)</span></pre><p id="8fd6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">KNN ROC:0.9393，精度@排名n:0.5408</p><p id="bc28" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的<strong class="jl hj"> KNN() </strong>模型在测试集上继续表现良好。让我们为测试集绘制混淆矩阵。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="9422" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># plot the comfusion matrix  in the test set</em><br/>y_preds = clf_knn.predict(X_test)<br/><br/>skplt.metrics.plot_confusion_matrix(y_test,y_preds, normalize=<strong class="mg hj">False</strong>,<br/>                                    title="Consfusion Matrix on Test Set")<br/>plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mv"><img src="../Images/eb799d68fe85df2f790425366ba74c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*7nQUiEd5RoamgZs_qFHnYQ.png"/></div></figure><p id="bc88" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在测试集中，87个欺诈案例被正确预测，只有11个案例被错误预测为有效案例。</p><h2 id="48c7" class="lr kh hi bd ki ls lt lu km lv lw lx kq js ly lz ks jw ma mb ku ka mc md kw me bi translated">2.一类SVM检测器</h2><p id="39c1" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">这是一个无监督的离群点检测算法，是scikit-learn单类SVM类的包装器，具有更多功能。</p><p id="9296" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们创造一流的SVM模式。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="8792" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># create the OCSVM model</em><br/>clf_ocsvm = OCSVM(contamination= 0.172)<br/><br/>clf_ocsvm.fit(X_train)</span></pre><p id="5ad9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在训练我们的OCSVM检测器模型之后，我们可以获得训练数据上的预测标签，然后获得训练数据的离群值分数。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="3fdf" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># Get the prediction labels of the training data</em><br/>y_train_pred = clf_ocsvm.labels_  <em class="mo"># binary labels (0: inliers, 1: outliers)</em><br/><br/>clf_name ='OCSVM'<br/><br/><em class="mo"># Outlier scores</em><br/>y_train_scores = clf_ocsvm.decision_scores_ <br/><em class="mo"># Evaluate on the training data</em><br/>evaluate_print(clf_name, y_train, y_train_scores)</span></pre><p id="b947" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">OCSVM ROC:0.9651，精度@ rant n:0.7132</p><p id="7c8d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在训练集上，OCSVM模型的性能优于KNN模型。让我们为训练集绘制混淆矩阵。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="3cd5" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># plot the comfusion matrix  in the train set </em><br/><br/>skplt.metrics.plot_confusion_matrix(y_train,y_train_pred, <br/>                                    normalize=<strong class="mg hj">False</strong>,<br/>                                    title="Consfusion Matrix on                 <br/>                                    Train Set")<br/>plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mw"><img src="../Images/a777cc429357c04d820de883ddfd1d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*egnEqvGAONwXzEb-FtBebg.png"/></div></figure><p id="8760" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在训练集中，373个欺诈案例被正确预测，只有21个案例被错误预测为有效案例。</p><p id="eb6c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将使用decision_function来预测使用拟合检测器(OCSVM检测器)的测试集的异常分数，并评估结果。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="9e3c" class="lr kh hi mg b fi mk ml l mm mn">y_test_scores = clf_ocsvm.decision_function(X_test)  <em class="mo"># outlier scores</em><br/><br/><em class="mo"># Evaluate on the training data</em><br/>evaluate_print(clf_name, y_test,y_test_scores)</span></pre><p id="f130" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">OCSVM ROC: 0.9571，精度@秩n:0.6633</p><p id="f23e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的OCSVM模型在测试集上继续表现良好。让我们为测试集绘制混淆矩阵。</p><pre class="iy iz ja jb fd mf mg mh mi aw mj bi"><span id="d408" class="lr kh hi mg b fi mk ml l mm mn"><em class="mo"># plot the comfusion matrix in the test set</em> <br/>y_preds = clf_ocsvm.predict(X_test) </span><span id="e3f5" class="lr kh hi mg b fi mq ml l mm mn">skplt.metrics.plot_confusion_matrix(y_test,y_preds, normalize=<strong class="mg hj">False</strong>, title=”Consfusion Matrix on Test Set”, ) plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mx"><img src="../Images/df72f8a95ff5790e466616b61a93fd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*ZUULVoDl_wl0wkWV5cLGQQ.png"/></div></figure><p id="39f6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在测试集中，92个欺诈案例被正确预测，只有6个案例被错误预测为有效案例。</p><p id="d87d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">总的来说，当您比较这两个模型时，我们观察到OCSVM模型比KNN模型表现得更好。要提高检测欺诈交易的最佳模型(OCSVM)的性能，还有很多工作要做。您也可以尝试使用在<a class="ae kf" href="https://pyod.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> PyOD文档</a>中找到的其他检测器算法。</p><h1 id="0ef5" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated"><strong class="ak">结论</strong></h1><p id="33aa" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">信用卡公司能够识别欺诈性的信用卡交易是很重要的，这样客户就不会为他们没有购买的商品付费。作为企业主，您可以通过识别支付环境中潜在的信用卡欺诈来避免严重的问题和不必要的宣传。</p><p id="011c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">本文的源代码可以在Github上找到。</p><div class="my mz ez fb na nb"><a href="https://github.com/Davisy/Credit-Card-Fraud-Detection-using-PYOD-Library" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">davisy/信用卡欺诈检测使用PYOD库</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">使用异常检测技术识别欺诈性信用卡交易。…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">github.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np jh nb"/></div></div></a></div><p id="3b6c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你学到了新的东西或者喜欢阅读这篇文章，请分享给其他人看。也可以随意发表评论。我也期待听到你使用PyOD库的经验。也可以通过推特<a class="ae kf" href="https://twitter.com/Davis_McDavid" rel="noopener ugc nofollow" target="_blank"> @Davis_McDavid </a>联系到我</p><p id="a9f0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="mo">最后一件事:</em> </strong> <em class="mo">在下面的链接里多看看类似这样的文章。</em></p><div class="my mz ez fb na nb"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/feature-selection-by-using-voting-approach-e0d1c7182a21"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">使用投票方法的特征选择</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">如何应用多种技术来选择Xverse包的特性？</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">medium.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np jh nb"/></div></div></a></div><div class="my mz ez fb na nb"><a href="https://towardsdatascience.com/the-six-key-things-you-need-to-know-about-scikit-plot-119cbd869adb" rel="noopener follow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">关于Scikit-plot你需要知道的六件关键事情</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">向scikit-learn对象添加绘图功能的直观库。</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">towardsdatascience.com</p></div></div><div class="nk l"><div class="nr l nm nn no nk np jh nb"/></div></div></a></div><div class="my mz ez fb na nb"><a href="https://towardsdatascience.com/how-to-practice-logging-in-python-with-logzero-82e4f9842a5c" rel="noopener follow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">如何用Logzero练习Python中的日志记录</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">为您的Python项目提供强大而有效的日志记录。</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">towardsdatascience.com</p></div></div><div class="nk l"><div class="ns l nm nn no nk np jh nb"/></div></div></a></div></div></div>    
</body>
</html>