<html>
<head>
<title>Math behind GBM and XGBoost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GBM和XGBoost背后的数学</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/math-behind-gbm-and-xgboost-d00e8536b7de?source=collection_archive---------0-----------------------#2019-04-13">https://medium.com/analytics-vidhya/math-behind-gbm-and-xgboost-d00e8536b7de?source=collection_archive---------0-----------------------#2019-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="29c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GBM和XGBoost都是基于梯度推进的算法。但是在两种算法中构建新树的方式有很大的不同。今天，我将写下这两种算法背后的数学。</p><p id="e297" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我开始之前，让我们了解一下什么是升压。机器学习中的Boosting属于集成模型家族，其焦点主要是减少偏差。它意味着首先建立一个模型，找到它的残差，然后在残差上建立另一个模型。根据需要多次重复此过程。数学上可以表示如下。</p><p id="c79b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设f(x)是你的模型，y是实际值，gamma是预测值，L是损失函数。第一个模型f0(x)在{xi，易}上建造如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/29e0b2b9d054c3cde4bfd6c2c9054ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzyKtSvAfy_A018ED7EYyQ.jpeg"/></div></div></figure><p id="3318" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，计算残差(ri = (y-gamma))并在{xi，ri}上建立第二个模型h1(x)。将h1(x)加到f0(x)上，得到新的改进模型f1(x)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jp"><img src="../Images/e63c5726598c37c7be1bf8099af44d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIdSgGHS4sHL13xDMeElSQ.jpeg"/></div></div></figure><p id="201a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">反复重复以上过程。因此，在迭代m时方程的一般形式将是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jq"><img src="../Images/a7ea4ebcd97d48de42fc6d00a6435806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUMu4V59D3w6nDLJ0J7dYQ.jpeg"/></div></div></figure><p id="dc31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述等式是升压算法的通用等式。有几种方法可以决定在fm-1(x)中加入多少比例的hm(x)。等式将会是这样的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jr"><img src="../Images/9f328439bafa020c340d8a9819e92e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y06qdkrldjIGM968do2xgw.jpeg"/></div></div></figure><p id="2eab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有几种方法可以计算阿尔法像平均，加权平均，adaboost或使用梯度推进。今天，我写的是梯度推进。</p><p id="dc4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，问题来了什么是梯度推进？梯度增强中的术语梯度来自梯度下降合并到增强中。使用基于梯度下降的方法来决定α或步长。为了计算α，在比方说迭代m时，计算第一伪残差(rim)并且在{xi，rim}上建立新的模型hm(x)。伪残差的计算公式如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es js"><img src="../Images/9b6e4226ce86e13d0fc4f5615c70ae87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6JE6YbalSAbJzGtSYd1Vw.jpeg"/></div></div></figure><p id="7da8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，计算α，使损失函数最小。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/0dc69c440083d389afbbf87e21a7056b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fYxjVAbjjK6zL9TzyUpPQ.jpeg"/></div></div></figure><p id="be3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在代入α和hm(x)值得到fm(x)。</p><p id="5a95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GBM中，算法与梯度增强中的算法相同。该模型是基于决策树的，即f(x)和h(x)是车树。对于有T片叶子的树，模型hm(x)可以写成:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/9612f67803d06f47a0791778220673c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XAnuK17eNNAXJTB_gHSOIQ.jpeg"/></div></div></figure><p id="e74c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">bjm是预测值(平均值、中值、最大投票等。)在区域Rjm(叶j)中。如果将树的hm(x)代入梯度推进方程，将会有alpha和bjm。在GBM中，结合alpha和bjm来获得每个叶子的步进率。所以，在一棵有T片叶子的树上会有Tα(步率)。GBM的方程式变为:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/35d05bebd1f3cba2e2559ee246b46579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lSFZaEavpM--Vs73tONDlw.jpeg"/></div></div></figure><p id="1a1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，我们看到了GBM是如何构建的。你一定注意到了，GBM中的步进率计算需要两步1)计算伪残差2)计算alpha。此外，在GBM中也有过拟合的机会，这可以通过添加正则化来减少。XGBoost将计算步进率的两个步骤合并为一个步骤，并在损失函数中添加正则项以对抗过拟合。在XGBoost中，每次迭代时构建的树使得每次分裂时增益最大。等等，什么？一步一步来看。</p><p id="addc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先了解XGBoost中的损失函数有一个额外的调节项omega。该损失函数用于计算最大增益，该最大增益可以在分裂每个节点时直接用于树构建过程。这就是GBM中的两步过程如何通过正则化简化为一步。</p><p id="7255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看在XGBoost树构建中Gain是如何计算的。从需要最小化的损失函数开始。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jv"><img src="../Images/fc1b062082e23c8e5c362f9b6dcbc4b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eq9VZZxDwiwHQVPDVN3vjA.jpeg"/></div></div></figure><p id="e928" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以有几种类型的损失函数(等式中的L ),如用于回归的MSE或用于分类的交叉熵。为了形成与损失函数无关的通用方程，L函数的泰勒级数展开如下。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jw"><img src="../Images/4619f7b1b129789af82545840e716507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAAg21PzT8uSiJBtIrCZDg.jpeg"/></div></div></figure><p id="cbbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">损失函数展开类似泰勒级数。所生成的常数项被删除，因为在拆分树中的一个节点时，它们对计算增益没有贡献。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jx"><img src="../Images/6e2c6e9c078bafcee6deeb68d9f402f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCUTth4VxFzRTUafFolTrw.jpeg"/></div></div></figure><p id="3758" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">树的正则项ω可以写成:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jy"><img src="../Images/394c6d408e98946bc39cb1769f031c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mdP_wzOV7l6dAIxmp_jVg.jpeg"/></div></div></figure><p id="29e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将hm(x)的值替换为树方程，并去掉整洁度的m(迭代次数),损失函数变为:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jz"><img src="../Images/d1b566ded49203dad8b6926bbaed7e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*463pn-lwjUCecWD_DXjcSw.jpeg"/></div></div></figure><p id="53db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进一步简化方程，</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ka"><img src="../Images/9c9477316a2b515f4a9a2789b4b9311f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDJtry6Kny2slWDPm4V3ng.jpeg"/></div></div></figure><p id="ac27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的目标是最小化这个损失函数。如果你注意到第一项，求和项，是一个抛物线方程。可以看作是ax + bx。抛物线的最小值将出现在x = -a/2b处。在我们的例子中，bj = -Gj/(Hj+lamba)。将bj代入损失函数，最佳损失函数变为:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kb"><img src="../Images/debdb41ca75c1b1e53d6e936761d9a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9b_MooE-WgilDiZit_n6g.jpeg"/></div></div></figure><p id="9cd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一片叶子分成两片叶子(左L和右R)时，增益变为:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kc"><img src="../Images/b95f8215613556f8ea42140c06c528fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drNQ3AfYghomxpqJEGrlCg.jpeg"/></div></div></figure><p id="bd21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这个增益，XGBoost构建了树结构。</p><p id="02be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你喜欢这个，如果你喜欢，请鼓掌:)</p></div></div>    
</body>
</html>