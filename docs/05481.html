<html>
<head>
<title>Introduction to Algorithm Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法分析导论</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/introduction-to-algorithm-analysis-4c1228744d12?source=collection_archive---------26-----------------------#2020-04-22">https://medium.com/analytics-vidhya/introduction-to-algorithm-analysis-4c1228744d12?source=collection_archive---------26-----------------------#2020-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e2f831870b60caf7ca12b3b5da6813c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XpNqTrxnBLvMPrfGFU5pKg.jpeg"/></div></div></figure><p id="88bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">著名数学家阿基米德被要求确定国王委托的一顶金冠是否真的是纯金的，而不是像一个告密者所说的是部分银的。阿基米德发现了一种在洗澡时进行分析的方法。他注意到从浴缸里溢出的水与他进去的水成比例。意识到这一事实的含义后，他立刻从浴缸里出来，光着身子在城市里跑着，喊着:“找到了，找到了！”因为他发现了一种分析工具(位移)，当与一个简单的秤结合时，可以确定国王的新王冠是好是坏。也就是说，阿基米德可以将皇冠和同等重量的黄金浸入一碗水中，看看它们是否移动了相同的量。然而，这一发现对金匠来说是不幸的，因为当阿基米德进行分析时，皇冠比同等重量的纯金块排开更多的水，这表明皇冠实际上不是纯金的。</p><p id="4efe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">阿基米德发现了一种分析王冠是否由纯金制成的方法。在计算机科学中，一个问题可以用很多方法来解决，如下所示的例子，将一个数从1加到给定的“n”值(即n个值的和)</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/6246f2953ad035ce75a386bf431132f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKvNp-uPncBJSzzsFVr9gQ.png"/></div></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/4943f4abc05328e4cc71e19836e336f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJdsi77fllc55JcInnVzLw.png"/></div></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/57a22c3c93ca7f89f4a036649f26cae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*5f8_uaTnc7ejDz3ktNAGug.png"/></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">两个函数具有相同的结果</figcaption></figure><p id="3c95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是完全不同的算法。您会注意到，第一个函数迭代地将数字相加，而第二个函数利用了2</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/f31d23080190e1802ec0496446405081.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*sJ1NBaagggJojju-C__VcA.png"/></div></figure><p id="b8c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么如何才能客观的比较算法呢？我们可以比较它们在内存中占用的空间，或者我们也可以比较每个函数运行需要多少时间。我们可以使用jupyter中内置的<strong class="is hj"> %timeit </strong>魔法函数来比较函数的时间。Jupyter笔记本里的<a class="ae ka" href="https://ipython.org/ipython-doc/3/interactive/magics.html#magic-timeit" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> %timeit </strong> </a>魔法会重复循环迭代一定次数，取最佳结果。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/f556c34e6a7466824b2210041a3adc48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jeshQxHK_55OyMqkxnOj0Q.png"/></div></div></figure><p id="c234" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，您可以看到函数1花费了<strong class="is hj"> 6.83微秒</strong>，而函数2花费了<strong class="is hj"> 416纳秒</strong>比较两个数量级<strong class="is hj">微秒与纳秒</strong>对于较小的数据值，这不会产生太大的差异，但是如果我们考虑10，000数量级的较高值的相同函数，我们可以观察到较大的差异，如下所示</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/8f045976a96478ef68dd1cb1b51719af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Trx6OzdUTTohZlq3Nq5lVw.png"/></div></div></figure><p id="e760" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到第二个函数的效率要高得多！比第一次跑得快多了。然而，我们不能使用“运行时间”作为客观的衡量标准，因为这将取决于计算机本身的<strong class="is hj">速度和硬件能力</strong>。所以我们将需要使用另一种方法，<strong class="is hj"> Big-O </strong>！</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="8982" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你有任何反馈或批评，请随时与我分享。如果本演练对您有所帮助，请喜欢👏文章。干杯！🍻</p></div></div>    
</body>
</html>