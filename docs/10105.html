<html>
<head>
<title>Black Friday — A Detailed Analysis &amp; Prediction using Visualization and XGBoost.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">黑色星期五——使用可视化和XGBoost的详细分析和预测。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/black-friday-a-detailed-analysis-prediction-using-visualization-and-xgboost-6f5fe4eb7622?source=collection_archive---------7-----------------------#2020-10-05">https://medium.com/analytics-vidhya/black-friday-a-detailed-analysis-prediction-using-visualization-and-xgboost-6f5fe4eb7622?source=collection_archive---------7-----------------------#2020-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f8841d8ac57e8b833306d33c964460be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l7WRX6M-yaODwdAS"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">🇨🇭·克劳迪奥·施瓦茨| @purzlbaum 在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="be70" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated"><span class="l ju jv jw bm jx jy jz ka kb di"> O </span>机器学习和数据科学最有趣的用途之一可以在商业领域找到，人们可能需要分析给定的数据来解决问题，例如确定公司可以预期的客户数量，公司需要关注的客户类型以实现利润最大化等。<br/>通过这一特定的黑色星期五销售分析，我们更感兴趣的是根据客户的特定属性(如年龄组、城市类别等)计算出他们的消费金额。(稍后将详细讨论)。</p><blockquote class="kc kd ke"><p id="db56" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated"><em class="hi">这个项目是正在进行的黑客马拉松</em> <a class="ae iu" href="https://datahack.analyticsvidhya.com/contest/all/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">分析Vidhya </em> </a> <em class="hi">的一部分，被称为</em> <a class="ae iu" href="https://datahack.analyticsvidhya.com/contest/black-friday/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">黑色星期五销售预测</em> </a></p><p id="9c5d" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">注意:完整的Python代码可以在这里访问<a class="ae iu" href="https://github.com/starnlm/Black-Friday-Hackathon" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="51e4" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">还有，看看这个<strong class="ix hj"> </strong> <a class="ae iu" href="https://public.tableau.com/views/BlackFriday_16010249401550/BlackFriday?:language=en-GB&amp;:display_count=y&amp;publish=yes&amp;:toolbar=n&amp;:origin=viz_share_link" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">黑色星期五可视化</strong> </a>我在Tableau上创作的。</p></blockquote><h2 id="d971" class="kj kk hi bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">介绍</h2><p id="792a" class="pw-post-body-paragraph iv iw hi ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">零售公司“ABC Private Limited”希望<strong class="ix hj">了解顾客对不同类别的各种产品的购买行为(具体来说，购买金额)。他们分享了上个月不同客户对选定的大量产品的购买摘要。</strong></p><p id="ae1d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">他们希望建立一个模型来预测客户对各种产品的购买量，这将有助于他们针对不同的产品为客户创建个性化的报价。</p><h2 id="1ec0" class="kj kk hi bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">步骤0:理解问题</h2><p id="d683" class="pw-post-body-paragraph iv iw hi ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">在我们开始处理数据之前，我们必须了解问题对我们的要求。在这种情况下，我们需要预测'<em class="kf">购买量'</em>，这是一个连续变量。既然我们知道我们将预测一个连续变量，我们可以肯定地说，这是一个<strong class="ix hj">回归</strong> <strong class="ix hj">问题</strong>，我们可以使用各种回归算法，如线性回归、岭回归、决策树回归、集成技术、神经网络或任何其他首选的回归技术。</p><h2 id="92f4" class="kj kk hi bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">步骤1:导入库和数据集</h2><p id="f255" class="pw-post-body-paragraph iv iw hi ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">Python拥有大量的机器学习库，这使得它成为数据科学的最佳编程语言之一。最重要的是熊猫，Numpy，Scikit Learn，MatplotLib和Seaborn。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="6959" class="kj kk hi lo b fi ls lt l lu lv">#Import Libraries</span><span id="85e1" class="kj kk hi lo b fi lw lt l lu lv">import pandas as pd<br/>import numpy as np<br/>from sklearn.preprocessing import OneHotEncoder<br/>from sklearn.metrics import mean_squared_error<br/>from math import sqrt<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.linear_model import LinearRegression<br/>from sklearn.ensemble import RandomForestRegressor<br/>import xgboost as xgb<br/>from sklearn.preprocessing import StandardScaler</span><span id="dbea" class="kj kk hi lo b fi lw lt l lu lv">#Get the Data<br/>train = pd.read_csv("train.csv")<br/>test = pd.read_csv("test.csv")</span><span id="0cd6" class="kj kk hi lo b fi lw lt l lu lv">train.head()</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/34872bc38eb99e1ab0820c81b0522a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1MCAD-MlxaZrK_u3GsuAw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">数据</figcaption></figure><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="27dc" class="kj kk hi lo b fi ls lt l lu lv">train.info()</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/3b42a440de566d2fc9055521e63a2ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*T11JPangdlCjbimTDZGGdw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">dataFrame.info()给出了关于实体数量和各列数据类型的信息</figcaption></figure><p id="7d0e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以看出，我们的数据中有550，068行，除了<em class="kf">‘Purchase _ Category _ 2’</em>和<em class="kf">‘Purchase _ Category _ 3’之外，大多数数据列都是非空的。我们需要处理这些列中缺失的数据。但是在此之前，我们将看看这些列是如何影响目标的，然后对其进行相应的处理。</em></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="c4a9" class="kj kk hi lo b fi ls lt l lu lv">train.describe()</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/94ff0e22844d2fe495b4c6efc1e9bb1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Kf_bt6RGMev3o_qa.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">dataFrame.describe()给出了数据的统计洞察</figcaption></figure><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="149c" class="kj kk hi lo b fi ls lt l lu lv">#Checking for unique values</span><span id="e05d" class="kj kk hi lo b fi lw lt l lu lv">print('The number of unique Users are:',train['User_ID'].nunique())<br/>print('The number of unique Products are:',train['Product_ID'].nunique())<br/>-------------------------------------</span><span id="b47c" class="kj kk hi lo b fi lw lt l lu lv"><strong class="lo hj">OUTPUT<br/></strong>The number of unique Users are: 5891<br/>The number of unique Products are: 3631</span></pre><p id="d39c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到，在550，068个数据点中，只有5，891个唯一用户和3，631种不同的产品可用。</p><h2 id="28a2" class="kj kk hi bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">第二步:仔细观察特征</h2><ol class=""><li id="90fc" class="ma mb hi ix b iy le jc lf jg mc jk md jo me js mf mg mh mi bi translated"><strong class="ix hj"> User_ID: </strong>给客户一个独特的ID，以唯一地标识他们。</li><li id="3030" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">产品标识:</strong>产品被赋予一个独特的标识，以唯一地标识它们。</li><li id="7003" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">性别:</strong> M或F可作为二元变量。</li><li id="1f28" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">年龄:</strong>年龄分为6类。</li><li id="a234" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">职业:</strong>用户从事的职业类型，已经被屏蔽。</li><li id="ae63" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">City _ Category:</strong>A、B、c中城市的类别应作为分类变量。</li><li id="ff98" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">Stay _ In _ Current _ City _ Years:</strong>有5个值:0，1，2，3，4+，可以作为分类变量使用。</li><li id="4cd1" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">婚姻状况:</strong> 0:未婚，1:已婚。预计婚姻状况确实会影响购买价值。</li><li id="5fff" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">产品_类别_1: </strong>产品所属的主要类别。这可能是一个有用的功能，因为某些类别的产品比其他产品销售得更频繁。</li><li id="52c9" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">产品_类别_2: </strong>产品的二级类别。如果没有次级类别，这将是空的。</li><li id="bc70" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">产品_类别_3: </strong>产品的第三个类别。只有当类别1和类别2被占用时，它才会被占用。此外，如果产品没有第三类别，它将为<em class="kf"> Null。</em></li><li id="d9ce" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">购买:</strong>这是目标变量。</li></ol><p id="e3b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经理解了我们的数据，我们可以开始可视化，并获得更多的见解。</p><blockquote class="kc kd ke"><p id="e471" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi">注:</em> </strong> <em class="hi">我将使用Tableau进行数据可视化。</em></p></blockquote></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h2 id="1661" class="kj kk hi bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">步骤3:使用可视化的EDA</h2><p id="dbd9" class="pw-post-body-paragraph iv iw hi ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">当使用可视化来分析数据时，有大量的可能性。我们将首先了解不同的特征如何影响目标，然后了解这些特征的组合如何影响目标。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/2a5a8fa7e02dcad2b180e12abd29037a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*pud8SsdN8gm5ZXBpYDE-4w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.1.1</figcaption></figure><h2 id="7694" class="kj kk hi bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">3.1年龄</h2><p id="c23c" class="pw-post-body-paragraph iv iw hi ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">我们可以在<em class="kf">图3.1.1 </em>中看到，我们数据中各个年龄组的分布情况。26-35岁的顾客数量最多，约占总顾客的40%，而0-17岁的顾客数量最少，仅占2.75%。</p><p id="5859" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们可以推断，26-35岁年龄段的人购物最多，其次是36-25岁，18-25岁，51-55岁，55岁以上，然后是0-17岁。</p><p id="0ecc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很容易推测这个数据。由于0-17岁的人通常依赖老年人，他们作为顾客的数量最少。此外，26-35岁年龄组的人通常是独立的，有收入来源，他们是我们数据中最大的人群。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/0320f3504a0feaa76695dae9da38d2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*lay00dt-IlIsnHUPHFqB2Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.1.2</figcaption></figure><p id="26e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管不同年龄组的顾客数量存在差异，但我们可以从<em class="kf">图3.1.2 </em>中看到，不同年龄组的平均购买金额(平均值)与该年龄组中平均每人的购买金额(中值)几乎相同。此外，重要的是要注意，26-35岁的年龄组确实在很大程度上构成了我们的数据，但最大的平均支出金额是51-55岁年龄组的人。一个普遍的原因可能是，他们不再需要储蓄，可以自由地花费他们想要的任何金额。</p><blockquote class="kc kd ke"><p id="4164" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">此数据列不应用作序数变量，因为图表显示它们在比较时不符合任何特定的顺序。我将使用该列作为分类变量，并执行一个热编码以用于建模。</p></blockquote><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/d8b354a9d9c03515beea813fb7b896cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*DMNJ9J23w3AP0NwSFlnXhg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.2.1</figcaption></figure><p id="6f3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3.2性别<br/>这可能是一个非常重要的特征，因为不同性别的购物行为之间可能存在一些重大差异。在<em class="kf">图3.2.1 </em>中我们可以看到数据中男性(M)和女性(F)的分布。男性占购物的75%，而女性仅占25%。这是一个非常奇怪的观察结果，因为人们不会想到性别之间会有如此大的差异，公司必须找出存在这种差异的原因，以及如何吸引女性购物者。</strong></p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es my"><img src="../Images/a638563b9c04a82b423263527bb640be.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*CNRDvpj74dmCq5Dm7TfoAg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.2.2</figcaption></figure><p id="25ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">男性不仅购物更多，而且平均花费也比女性多。此外，一个普通男性的花费比一个普通女性多，尽管不是很多。</p><blockquote class="kc kd ke"><p id="f724" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">因为这个类别只有两个变量M和F，所以它可以很容易地被认为是一个二元变量。</p></blockquote><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/e7c47a2db217e190f6a175e548137106.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*3llT5LUG452vpjojHOncrQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.3.1</figcaption></figure><p id="5eef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3.3婚姻状况<br/> </strong>从<em class="kf">图3.3.1，</em>我们可以看到大约60%的客户未婚，40%已婚。已婚人士喜欢购买的商品可能没有吸引人的报价，也许公司可以在下次销售中解决这个问题。也有可能夫妇选择不在销售中浪费他们的收入，而更多地关注他们自己和他们的家庭。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es na"><img src="../Images/d65164fc83002bce46d2eecbb68351ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*mo5z_mIF9ZpIugGHqNEhGQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.3.2</figcaption></figure><p id="3e29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管未婚者购物更多，但未婚者和已婚者的平均花费几乎相同。</p><blockquote class="kc kd ke"><p id="b46b" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">看起来这个特性并不会对目标产生太大的影响，但是我们将进行更详细的双变量分析，并确定是否要使用这个特性。</p></blockquote><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/712b7fdfbe61ccab449edd0ac04f56c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*OWNybXK1RSCUwrMjFxnwTQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.4.1</figcaption></figure><p id="5907" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3.4城市类别<br/> </strong> <em class="kf">图3.4.1 </em>显示了我们的客户在各个城市的分布情况。大多数购物者来自B城市(43%)，最少来自A城市(27%)。现在我们还不确定这些类别是什么意思，这些类别是在什么基础上制定的。不过，我们可以得到一些想法后，更详细的分析。例如，如果我们假设城市是根据人们的收入范围划分的，那么高收入的人可能对销售不太感兴趣，因此属于城市A，同样，低收入的人会感兴趣，但由于他们的报酬低，他们的手被束缚，因此可以被归类为城市c。工资不太高也不太低的人可以自由地参与这次销售，主要购物者也是如此，因此属于城市b类。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/87aa114962984d0a77c48a181792ea09.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*8yNaLkoGb-9GuYxvQufYiw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.4.2</figcaption></figure><p id="474d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从<em class="kf">图3.4.2 </em>中可以明显看出，C城市的人均消费金额最多，A城市的人均消费金额最少。此外，C城市的购买中值(平均每人花费的金额)最多，A城市最少。现在，这不符合我们的假设，即A类城市的人收入最高，因为我们可以预计他们将花费最多，但实际上，他们花费最少。因此，这不是划分这些类别的标准。</p><p id="7356" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3.5职业</strong></p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/d06175b559c8a60fc383ea04272832a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51QihjqIEDxgrNN5bSUvOg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.5.1</figcaption></figure><p id="fd2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有21种不同的职业，这些价值观已经被掩盖了。从<em class="kf">图3.5.1 </em>我们可以看到，大部分购物者都涉及职业代码4，占13.15%，其次是职业代码0，占12.66%。<br/>从事职业8的人占购物者的比例最低。也许公司应该关注这一职业的购物者。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/aaf6f73fa01c1141173cb4c0779be813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJUaDr6NaZ5EsDeOS5sRbw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.5.2</figcaption></figure><p id="2fd2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从<em class="kf">图3.5.2，</em>很明显，在占用-购买图中有一些趋势。职业17的顾客花费最多，职业9的顾客花费最少。</p><blockquote class="kc kd ke"><p id="5812" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">尽管occupation字段中的值是数字，但是最好将该列作为分类变量处理，并使用一个热编码进行编码。</p></blockquote><p id="ed83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3.6在当前城市停留年数</strong></p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/5f6f5321f9162143733b070e08ffc6e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*dg42z0Pr4KvlheYUm7XkLw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.6.1</figcaption></figure><p id="b46c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从<em class="kf">图3.6.1 </em>我们可以看到，我们的大部分客户是那些在过去1年内一直住在同一城市的人(35.24%)。而最少的是刚搬进来的(13.53 %)。这种现象可能有一些显而易见的原因。已经在一个城市呆了一年的人现在可能会呆得更久，所以他们会自由地参加黑色星期五的销售活动，可能会为房子买些东西，而那些刚刚搬进来的人需要更多的时间来适应。此外，有可能那些已经在这个城市呆了4年以上的人要么计划搬出去，要么厌倦了这个城市的销售，所以选择不去购物。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/04e4a3259b634b068d712756d90f673b.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*rcWyGJ1jFLr_MvdzyWXYUA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.6.2</figcaption></figure><p id="e329" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">停留时间不同的人平均花费的金额非常相似。然而，相比之下，逗留不到一年的人花费最低。因此，我们可以肯定地说，如果一个人还没有完成在一个城市的第一年，他会花更少的钱。</p><blockquote class="kc kd ke"><p id="8580" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">这个特性在购买量的预测中起着至关重要的作用。我们将把它视为一个分类变量。</p></blockquote><p id="18f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3.7产品类别<br/> </strong>产品类别有三列，其中两列为空值。我们将不得不处理空值。但在此之前，让我们了解这些类别告诉我们什么。<br/>一个产品可以属于一个类别(主要类别)，也可以有两个类别(主要+次要类别)或最多三个类别(主要+次要+第三类别)。<strong class="ix hj">属于多个品类会影响产品的购买金额吗？</strong>让我们来了解一下。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/c96446c19fa99fbd1859ef53623129db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9gDqOvODFHyAv2jk0ZIgMQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.7.1</figcaption></figure><p id="f888" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<em class="kf">图3.7.1中，</em>我们可以看到，主要类别为10的产品平均购买量高达19，676，其次是类别为7的产品，平均购买量为16，366，以此类推。属于类别19的产品的平均购买金额为37。</p><p id="3132" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们假设有一个产品，它有一个主要类别10，还有一个次要类别。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es ni"><img src="../Images/d725e82f2eb425e4ae0f03f539ece6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*j1lE5AgbWOpnYespfo0K0A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.7.2</figcaption></figure><p id="d861" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图<em class="kf"> 3.7.2 </em>显示了当主要类别为10时，不同的次要产品类别和平均采购金额。因此，如果一个产品有一个类别10，这意味着它可能不属于任何其他类别(空)，或者它可以属于以下任何类别:14，16，13，15或11。我们可以看到，如果该产品不属于任何其他类别，它具有最大的平均购买价值:20，295。如果该产品属于类别10和类别11，其平均购买量显著下降至19，206，这是不可忽略的。因此，我们可以说，产品类别2与产品类别1相结合，肯定会影响购买价值。<br/>现在让我们假设我们有一个类别为10和13的产品。<strong class="ix hj">拥有第三个类别会影响产品的购买量吗？</strong></p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es nj"><img src="../Images/9de0128231eb06beb9bdacae5c8040da.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*W47y1I7HZ6_seDm-hrYgkQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.7.3</figcaption></figure><p id="9ce8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kf">图3.7.3 </em>描述了在我们给定的数据中，如果产品有类别10和13，它可能没有第三个类别(空)或者可能属于类别16。我们可以看到平均成绩的巨大差异。没有第三类的产品和有第三类的产品的购买量(16)。</p><blockquote class="kc kd ke"><p id="a12e" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">因此，删除空值或不考虑三个产品类别列中的任何一个都是不明智的。无论如何，我们将在稍后创建模型时处理这些列。</p></blockquote><p id="43f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经完成了数据的单变量分析。但是有一个可变的“婚姻状况”,我们不知道它如何影响我们的目标。因此，我们将进行双变量分析，并获得更深入的见解。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es nk"><img src="../Images/86416baedcdb3e15c5d8be536b9c384c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*IUnYxXRrC582B6T6ZfwePw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.8.1</figcaption></figure><p id="13fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<em class="kf">图</em> <em class="kf"> 3.8.1 </em>中我们看到婚姻状况和性别w.r.t平均购买量的对比。我们看到，对于一个未婚的人来说，如果他们是女性，他们比男性花费少得多。已婚人士也有同样的趋势，只是略有不同。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es nl"><img src="../Images/50421ebfb19fe74b657ea2954c150ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*MUtRhs8elDkKOcqOTcAxYw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.8.2</figcaption></figure><p id="9b99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<em class="kf">图</em>图<em class="kf"> 3.8.2 </em>中我们看到了婚姻状况和停留在当前城市年(SCCY) w.r.t平均购房的对比。对于SCCY 0，平均值。购买也差不多。对于SCCY 1，平均值。已婚和未婚之间只有细微的差别。对于SCCY 2号来说，已婚和未婚之间也只有细微的差别。然而，对于SCCY 3，已婚(9 170.6英镑)和未婚(9 362.9英镑)之间的差距稍大一些。对于SCCY 4+来说，已婚和未婚之间只有微小的区别。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es nm"><img src="../Images/e7d86d33eec9797c7c6a73ad22a82ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*a5vf3DmHy4G4TXWXtiQbXg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.8.3</figcaption></figure><p id="c42f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<em class="kf">图</em> <em class="kf"> 3.8.2 </em>中我们看到婚姻状况和城市类别w.r.t平均购买量的对比。生活在城市不同类别的已婚和未婚人群之间没有显著差异。</p><blockquote class="kc kd ke"><p id="54c6" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">根据上述双变量分析和图3.8.1、3.8.2和3.8.3，我们可以得出结论，婚姻状况对目标影响不大，可以不再使用。</p></blockquote><p id="d49f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经完成了数据分析，我们将开始构建预测模型。</p><h2 id="3882" class="kj kk hi bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">步骤4:数据预处理</h2><ol class=""><li id="d6da" class="ma mb hi ix b iy le jc lf jg mc jk md jo me js mf mg mh mi bi translated">我们要做的第一件事是删除婚姻状况列。</li></ol><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="2a32" class="kj kk hi lo b fi ls lt l lu lv">df = train.copy() #Create a copy of Train Data to work on.<br/>df = df.drop(columns = ['Marital_Status'])</span></pre><p id="ba6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.现在我们将对性别列进行编码。因为它是一个二进制变量，我们将使用一个<em class="kf"> replace( ) </em>函数来实现这个目的<em class="kf">。</em></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="60fd" class="kj kk hi lo b fi ls lt l lu lv">df = df.replace({'Gender': {'M': 1, 'F':0}})</span></pre><p id="56ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.现在我们需要对<em class="kf"> Product_Category_2 </em>和<em class="kf"> Product_Category_3 </em>中缺失的值进行处理，同时不丢弃缺失的值。因此，我们首先将这两列中的NaN值替换为0，然后对<em class="kf"> Product_Category_1进行一次热编码。</em>接下来，如果我们在数据<em class="kf">、</em>的任何一行中的<em class="kf"> Product_Category_2 </em>和<em class="kf"> Product_Category_3 </em>列中遇到任何非零值，我们将用1 <em class="kf">替换一个热编码<em class="kf"> Product_Category_1 </em>的相应列中的值。</em>这将把三个产品类别列的所有信息聚合到一个用于<em class="kf"> Product_Category_1的热编码中。</em>为了有更清楚的了解，让我们举一个例子。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/0dd18e0ef88c022c9998f01381298b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*41aoNI6GQE60LVQ8Bm9PNA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图:4.1</figcaption></figure><p id="c8e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">图4.1 </strong>:考虑总共只有4个类别1、2、3、4的虚拟数据。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es no"><img src="../Images/8f42cfcb31953977cd470f85038af943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*jFNmh67_QPw4fv_obaHYUA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4.2</figcaption></figure><p id="9e00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">图4.2 </strong>:将所有NaN值替换为0。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es np"><img src="../Images/6c6d61baf8492f1a90d363df4ba3cbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*6mkcasmfSja0n0RCH2Kn9w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4.3</figcaption></figure><p id="f96c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">图4.3: </strong>使用一键编码和前缀= 'P '对产品类别1进行编码</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es nq"><img src="../Images/58d277ea2a6738907d811b2d43736d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*2FGsJw31OdJ0xpPDyshO_A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4.4</figcaption></figure><p id="93f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">图4.4: </strong>对于在产品类别2或产品类别3中有非零单元格的每一行(假设第2行突出显示)，我们取非零值<strong class="ix hj">‘I’</strong>，并用1替换该行中的<strong class="ix hj">‘ith’</strong>列。我们对所有数据都这样做。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/7438f5a955efb2958e4a309ddf6b52a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*n7XLawtYQT-FiI7Cd5_Wug.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4.5</figcaption></figure><p id="0f5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">图4.5: </strong>我们对第3行(突出显示)执行上述步骤，这是我们的数据看起来的样子。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es ns"><img src="../Images/d9268625deebd0370708a63334fad69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*10wJRR94s_zItMLCRhTV2w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4.6</figcaption></figure><p id="b3d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">图4.6: </strong>这是我们完成所有数据点后的最终数据。<br/> <strong class="ix hj">现在我们将为实际数据集编写上述步骤的代码。</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="2b33" class="kj kk hi lo b fi ls lt l lu lv"><strong class="lo hj"># First do One Hot encoding for Product Category 1</strong><br/>df_oneHot = pd.get_dummies(df, columns = ['Product_Category_1'], prefix = ['P'])</span><span id="f0a7" class="kj kk hi lo b fi lw lt l lu lv"><strong class="lo hj">#Fill NaN values with Zeros<br/></strong>df_oneHot = df_oneHot.fillna(0)</span><span id="7388" class="kj kk hi lo b fi lw lt l lu lv">for i in range(1, 15):<br/>    df_oneHot.loc[df_oneHot.Product_Category_2 == i,'P_'+ str(i)]= 1<br/>    df_oneHot.loc[df_oneHot.Product_Category_3 == i,'P_'+ str(i)]= 1</span></pre><p id="e0cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看看数据中的列。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="fe7e" class="kj kk hi lo b fi ls lt l lu lv">df_oneHot.columns<br/>--------------------------------------------------------------------</span><span id="6aba" class="kj kk hi lo b fi lw lt l lu lv"><strong class="lo hj">OUTPUT<br/></strong>Index(['User_ID', 'Product_ID', 'Gender', 'Age', 'Occupation', 'City_Category', 'Stay_In_Current_City_Years', 'Product_Category_2','Product_Category_3', 'Purchase', 'P_1', 'P_2', 'P_3', 'P_4',  'P_5', 'P_6', 'P_7', 'P_8', 'P_9', 'P_10', 'P_11', 'P_12', 'P_13', 'P_14','P_15', 'P_16', 'P_17', 'P_18', 'P_19', 'P_20'],<br/>dtype='object')</span></pre><p id="dea3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在删除<em class="kf">‘产品_类别_ 2’</em>和<em class="kf">‘产品_类别_ 3’</em>列。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="7bbb" class="kj kk hi lo b fi ls lt l lu lv">df_oneHot = df_oneHot.drop(columns = ['Product_Category_2', 'Product_Category_3'])</span></pre><p id="20fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们对其余的分类变量进行一次热编码。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="7d88" class="kj kk hi lo b fi ls lt l lu lv">data_df_onehot = pd.get_dummies(df_oneHot, columns=['Age',"Occupation", 'City_Category', 'Stay_In_Current_City_Years'], prefix = ['Age',"Occupation", 'City','Stay'])</span></pre><p id="17e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还想使用产品ID列，但由于它属于“P00…”类型，因此无法按原样使用。因此，我们将首先从列中删除“P00 ”,然后使用它。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9181" class="kj kk hi lo b fi ls lt l lu lv">data_df_onehot['Product_ID'] = data_df_onehot['Product_ID'].str.replace('P00', '')</span></pre><p id="74e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了有效地建立模型，我们可以使用<strong class="ix hj">特征缩放</strong>来标准化数据集。这可以用sklearn预处理库中的<em class="kf"> StandardScaler() </em>来完成。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9df6" class="kj kk hi lo b fi ls lt l lu lv">scaler = StandardScaler()<br/>data_df_onehot['Product_ID'] = scaler.fit_transform(data_df_onehot['Product_ID'].values.reshape(-1, 1))<br/>data_df_onehot['User_ID'] = scaler.transform(data_df_onehot['User_ID'].values.reshape(-1, 1))</span></pre><p id="15fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们将目标变量从数据集中分离出来，然后使用<em class="kf"> train_test_split() </em>命令将数据集分成比例为80:20的训练数据和测试数据。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="85d9" class="kj kk hi lo b fi ls lt l lu lv">target = data_df_onehot.Purchase<br/>data_df_onehot = data_df_onehot.drop(columns = ['Purchase'])</span><span id="13cb" class="kj kk hi lo b fi lw lt l lu lv">train_data, test_data, train_labels, test_labels = train_test_split(data_df_onehot, target, test_size=0.2, random_state=42)</span></pre><h2 id="825f" class="kj kk hi bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">步骤5:数据建模</h2><blockquote class="kc kd ke"><p id="1c84" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">在这个故事中，我不会深入解释极端梯度推进(XGBoost)算法。为了更好地解释超参数调整<a class="ae iu" href="https://blog.cambridgespark.com/hyperparameter-tuning-in-xgboost-4ff9100a3b2f" rel="noopener ugc nofollow" target="_blank">请点击此链接</a>，为了理解算法如何工作，<a class="ae iu" href="https://www.youtube.com/watch?v=OtD8wVaFm6E" rel="noopener ugc nofollow" target="_blank">请点击此链接</a>。</p></blockquote><p id="30d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们导入xgboost，然后将数据转换成XGBoost使用的DMatrix格式。然而，该算法也可以在不转换成数据矩阵的情况下使用。无论如何我都会做的。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="af71" class="kj kk hi lo b fi ls lt l lu lv">import xgboost as xgb</span><span id="ffcc" class="kj kk hi lo b fi lw lt l lu lv">dtrain = xgb.DMatrix(train_data, label=train_labels)<br/>dtest = xgb.DMatrix(test_data, label=test_labels)</span></pre><p id="656f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们将考虑我们将要调优的XGBoost的一些参数。这些参数是<strong class="ix hj"> <em class="kf">最大深度、最小子权重、学习率、子样本、</em> </strong>和<strong class="ix hj"> <em class="kf">列采样</em> </strong>。我们还采用了评估指标。我们将使用<strong class="ix hj"> <em class="kf">均方根误差(RMSE) </em> </strong>，因为这是竞赛中使用的。此外，我们将把<strong class="ix hj"> N <em class="kf">助推轮数</em> </strong>设置为999(这显然是允许的最大值)。<strong class="ix hj"> N <em class="kf">助推轮数</em> </strong>是模型遍历完整数据的次数。为了避免花费大量时间进行999轮，我们可以设置一个早期停止变量，一旦模型在一定数量的轮次后没有改善，该变量将停止训练。我们做所有这些，然后开始训练我们的模型。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="c1eb" class="kj kk hi lo b fi ls lt l lu lv">params = {<br/>    # Parameters that we are going to tune.<br/>    'max_depth':6,<br/>    'min_child_weight': 1,<br/>    'eta':.3,<br/>    'subsample': 1,<br/>    'colsample_bytree': 1,<br/>    # Other parameters<br/>    'objective':'reg:squarederror',<br/>}</span><span id="5999" class="kj kk hi lo b fi lw lt l lu lv">params['eval_metric'] = "rmse"<br/>num_boost_round = 999</span><span id="4e7a" class="kj kk hi lo b fi lw lt l lu lv">model = xgb.train(<br/>    params,<br/>    dtrain,<br/>    num_boost_round=num_boost_round,<br/>    evals=[(dtest, "Test")],<br/>    early_stopping_rounds=10<br/>    <br/>)</span><span id="da0d" class="kj kk hi lo b fi lw lt l lu lv"><strong class="lo hj">--------------------------------------------------------------</strong></span><span id="09c1" class="kj kk hi lo b fi lw lt l lu lv"><strong class="lo hj">OUTPUT<br/></strong>[0]	Test-rmse:7753.65625<br/>Will train until Test-rmse hasn't improved in 10 rounds.<br/>[1]	Test-rmse:5930.35205<br/>[2]	Test-rmse:4769.00244<br/>[3]	Test-rmse:4027.15063<br/>[4]	Test-rmse:3586.85400<br/>[5]	Test-rmse:3348.09839<br/>...<br/>[814]	Test-rmse:2511.04102<br/>[815]	Test-rmse:2511.13452<br/>[816]	Test-rmse:2511.16455<br/>[817]	Test-rmse:2511.13867<br/>[818]	Test-rmse:2511.05640<br/>[819]	Test-rmse:2511.06519<br/>Stopping. Best iteration:<br/>[809]	Test-rmse:2510.89258</span></pre><p id="0bf4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于数据点很多，训练模型需要一些时间。我们的模型遍历了819次完整数据，并在第809轮找到了最好的分数。Test-rmse是2510，没有超参数调优，相当不错。</p><h2 id="64c3" class="kj kk hi bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">步骤6:超参数调整</h2><p id="0842" class="pw-post-body-paragraph iv iw hi ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">现在我们将调整我们的模型。为此，我们将使用交叉验证。XGBoost自带了一个内置的交叉验证特性，我们将会用到它。</p><blockquote class="kc kd ke"><p id="f137" class="iv iw kf ix b iy iz ja jb jc jd je jf kg jh ji jj kh jl jm jn ki jp jq jr js hb bi translated">我只做了一个粗略的参数调整，因为使用交叉验证调整模型花费了很多时间。与下面的调整相比，我觉得可以对模型进行更好的调整，但目的是展示我是如何进行调整的。</p></blockquote><p id="7b80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 6.1最大深度和最小儿童体重。<br/> </strong> <code class="du nt nu nv lo b">max_depth</code>是一棵树从根到最远的叶子所允许的最大节点数。更深的树可以通过添加更多的节点来模拟更复杂的关系，但随着我们深入，分裂变得不那么相关，有时只是因为噪音，导致模型过度拟合。<br/> <code class="du nt nu nv lo b">min_child_weight</code>是在树中创建新节点所需的最小权重(或样本数，如果所有样本的权重都为1)。更小的<code class="du nt nu nv lo b">min_child_weight</code>允许算法创建对应于更少样本的子代，从而允许更复杂的树，但同样，更有可能过度拟合。</p><p id="6c85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们一起调整这些参数，以确保模型偏差和方差之间的良好平衡。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="e7e0" class="kj kk hi lo b fi ls lt l lu lv"><strong class="lo hj">#Select a range of values for different parameters</strong><br/>gridsearch_params = [<br/>    (max_depth, min_child_weight)<br/>    for max_depth in range(9,12)<br/>    for min_child_weight in range(5,8) <strong class="lo hj">#TRY GREATER VALUES &gt; 60</strong><br/>]</span><span id="c0b0" class="kj kk hi lo b fi lw lt l lu lv"><strong class="lo hj">#Initialize minimum rmse and the best parameters</strong></span><span id="7d25" class="kj kk hi lo b fi lw lt l lu lv">min_rmse  = float("Inf")<br/>best_params = None</span><span id="445a" class="kj kk hi lo b fi lw lt l lu lv">for max_depth, min_child_weight in gridsearch_params:<br/>    print("CV with max_depth={}, min_child_weight={}".format(<br/>                             max_depth,<br/>                             min_child_weight))<br/>    <strong class="lo hj"># Update our parameters</strong><br/>    params['max_depth'] = max_depth<br/>    params['min_child_weight'] = min_child_weight<br/>   <strong class="lo hj"> # Run CV</strong><br/>    cv_results = xgb.cv(<br/>        params,<br/>        dtrain,<br/>        num_boost_round=num_boost_round,<br/>        seed=42,<br/>        nfold=5,<br/>        metrics={'rmse'},<br/>        early_stopping_rounds=5,<br/>        verbose_eval = True<br/>    )<br/>   <strong class="lo hj"> # Update best RMSE</strong><br/>    mean_rmse = cv_results['test-rmse-mean'].min()<br/>    boost_rounds = cv_results['test-rmse-mean'].argmin()<br/>    print("\tRMSE {} for {} rounds".format(mean_rmse, boost_rounds))<br/>    if mean_rmse &lt; min_rmse:<br/>        min_rmse = mean_rmse<br/>        best_params = (max_depth,min_child_weight)<br/>print("Best params: {}, {}".format(best_params[0], best_params[1])</span><span id="c9e8" class="kj kk hi lo b fi lw lt l lu lv">-----------------------------------------------------------------<strong class="lo hj"><br/>OUTPUT<br/></strong>Best params: 9, 7</span></pre><p id="4d8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们用9的<code class="du nt nu nv lo b">max_depth</code>和7的<code class="du nt nu nv lo b">min_child_weight</code>得到最好的分数，所以让我们更新我们的参数</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9b1b" class="kj kk hi lo b fi ls lt l lu lv">params['max_depth'] = 9<br/>params['min_child_weight'] = 7</span></pre><p id="1146" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 6.2子采样和逐树列采样<br/> </strong>这些参数控制在每个增强回合中进行的数据集采样。<br/>我们不需要每次都使用整个训练集，而是可以在每个步骤中基于稍微不同的数据构建一个树，这样就不太可能过度适应单个样本或特征。</p><ul class=""><li id="7bef" class="ma mb hi ix b iy iz jc jd jg nw jk nx jo ny js nz mg mh mi bi translated"><code class="du nt nu nv lo b">subsample</code>对应于每一步要进行二次抽样的观察值(行)的分数。默认情况下，它被设置为1，意味着我们使用所有行。</li><li id="29cd" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js nz mg mh mi bi translated"><code class="du nt nu nv lo b">colsample_bytree</code>对应于要使用的特征(列)的分数。默认情况下，它被设置为1，意味着我们将使用所有功能。</li></ul><p id="5572" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看是否可以通过一起调整这些参数来获得更好的结果。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="4386" class="kj kk hi lo b fi ls lt l lu lv"><strong class="lo hj">#Select a range of values for different parameters<br/></strong>gridsearch_params = [(subsample, colsample)<br/>    for subsample in [i/10. for i in range(7,11)]<br/>    for colsample in [i/10. for i in range(7,11)]<br/>]<br/><strong class="lo hj">#Initialize minimum rmse and the best parameters</strong></span><span id="3f3a" class="kj kk hi lo b fi lw lt l lu lv">min_rmse = float("Inf")<br/>best_params = None<br/><strong class="lo hj"># We start by the largest values and go down to the smallest</strong><br/>for subsample, colsample in reversed(gridsearch_params):<br/>    print("CV with subsample={}, colsample={}".format(<br/>                             subsample,<br/>                             colsample))<br/>    <strong class="lo hj"># We update our parameters</strong><br/>    params['subsample'] = subsample<br/>    params['colsample_bytree'] = colsample<br/>    # Run CV<br/>    cv_results = xgb.cv(<br/>        params,<br/>        dtrain,<br/>        num_boost_round=num_boost_round,<br/>        seed=42,<br/>        nfold=5,<br/>        metrics={'rmse'},<br/>        early_stopping_rounds=10<br/>    )<br/>    <strong class="lo hj"># Update best score</strong><br/>    mean_rmse = cv_results['test-rmse-mean'].min()<br/>    boost_rounds = cv_results['test-rmse-mean'].argmin()<br/>    print("\tRMSE {} for {} rounds".format(mean_rmse, boost_rounds))<br/>    if mean_rmse &lt; min_rmse:<br/>        min_rmse = mean_rmse<br/>        best_params = (subsample,colsample)<br/>print("Best params: {}, {}".format(best_params[0], best_params[1)<br/>--------------------------------------------------------------------<br/><strong class="lo hj">OUTPUT</strong></span><span id="7532" class="kj kk hi lo b fi lw lt l lu lv">Best params: 1, 0.7</span></pre><p id="fb99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再次，我们更新我们的<code class="du nt nu nv lo b">params</code>字典。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="59bb" class="kj kk hi lo b fi ls lt l lu lv">params['subsample'] = 1<br/>params['colsample_bytree'] = 0.7</span></pre><p id="a0fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 6.3 ETA(学习率)<br/></strong><code class="du nt nu nv lo b">ETA</code>参数控制学习率。它对应于每一轮后与特征相关联的权重的收缩，换句话说，它定义了我们在每一步进行的“校正”的量。</p><p id="7b22" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在实践中，较低的<code class="du nt nu nv lo b">eta</code>使我们的模型对过拟合更加鲁棒，因此，通常学习率越低越好。但是随着更低的<code class="du nt nu nv lo b">eta</code>，我们需要更多的助推轮，这需要更多的时间来训练，有时只是边际改善。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="778a" class="kj kk hi lo b fi ls lt l lu lv">min_rmse = float("Inf")<br/>best_params = None<br/>for eta in [.3, .2, .1, .05, .01, .005]:<br/>    print("CV with eta={}".format(eta))<br/>    <strong class="lo hj"># We update our parameters</strong><br/>    params['eta'] = eta<br/>    <strong class="lo hj"># Run and time CV</strong><br/>    cv_results = xgb.cv(<br/>            params,<br/>            dtrain,<br/>            num_boost_round=num_boost_round,<br/>            seed=42,<br/>            nfold=5,<br/>            metrics=['rmse'],<br/>            early_stopping_rounds=10<br/>          )<br/>    <strong class="lo hj"># Update best score</strong><br/>    mean_rmse = cv_results['test-rmse-mean'].min()<br/>    boost_rounds = cv_results['test-rmse-mean'].argmin()<br/>    print("\tRMSE {} for {} rounds\n".format(mean_rmse, boost_rounds))<br/>    if mean_rmse &lt; min_rmse:<br/>        min_rmse = mean_rmse<br/>        best_params = eta<br/>print("Best params: {}".format(best_params))<br/>--------------------------------------------------------------------<br/><strong class="lo hj">OUTPUT</strong></span><span id="c79b" class="kj kk hi lo b fi lw lt l lu lv">Best Params: 0.2</span></pre><h2 id="73c9" class="kj kk hi bd kl km kn ko kp kq kr ks kt jg ku kv kw jk kx ky kz jo la lb lc ld bi translated">步骤7:模型的评估</h2><p id="310b" class="pw-post-body-paragraph iv iw hi ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">下面是我们最终的参数字典的样子:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="7917" class="kj kk hi lo b fi ls lt l lu lv">params = {'colsample_bytree': 0.7,<br/> 'eta': 0.2,<br/> 'eval_metric': 'rmse',<br/> 'max_depth': 9,<br/> 'min_child_weight': 7,<br/> 'objective': 'reg:squarederror',<br/> 'subsample': 1}</span></pre><p id="2f50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用它来训练一个模型，看看它在我们的测试集上表现如何！</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="e643" class="kj kk hi lo b fi ls lt l lu lv">model = xgb.train(<br/>    params,<br/>    dtrain,<br/>    num_boost_round=num_boost_round,<br/>    evals=[(dtest, "Test")],<br/>    early_stopping_rounds=10<br/>)</span><span id="08de" class="kj kk hi lo b fi lw lt l lu lv">-------------------------------------------------------------------</span><span id="6992" class="kj kk hi lo b fi lw lt l lu lv"><strong class="lo hj">OUTPUT</strong><br/>[0]	Test-rmse:7753.65625<br/>Will train until Test-rmse hasn't improved in 10 rounds.<br/>[1]	Test-rmse:8655.89258<br/>[2]	Test-rmse:7285.25684<br/>[3]	Test-rmse:5282.01660<br/>[4]	Test-rmse:4646.53125<br/>[5]	Test-rmse:3779.51074<br/>...<br/>[604]   Test-rmse:2497.35059<br/>[605]   Test-rmse:2497.48877<br/>[606]   Test-rmse:2497.36914<br/>[607]   Test-rmse:2497.48291<br/>Stopping. Best iteration:<br/>[597]   Test-rmse:2497.25513</span></pre><p id="309f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧，好吧，这难道不是一个进步。不仅迭代次数从819减少到607，而且测试RMSE也从2510.89减少到2497.255。现在，我们可以使用这个模型来拟合测试数据，然后提交它进行检查。<br/> <strong class="ix hj">这使我们处于第355位，是所有参与者中排名前14%的人。</strong></p><h1 id="b2c7" class="oa kk hi bd kl ob oc od kp oe of og kt oh oi oj kw ok ol om kz on oo op lc oq bi translated">结论</h1><p id="efec" class="pw-post-body-paragraph iv iw hi ix b iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">即使我们用上面的模型得到了一个不错的结果，还是有354名参与者比我们做得更好。也许，我们可以更专注于提取有趣的特征或使用不同的集成模型。还可以使用深度神经网络进行回归，这可能产生比集合模型更好的结果。<br/>完整的Python代码可以在这里<a class="ae iu" href="https://github.com/starnlm/Black-Friday-Hackathon" rel="noopener ugc nofollow" target="_blank">访问。如果你对这篇文章或使用Tableau的可视化有任何疑问，请在评论中提出来，如果你喜欢我的作品，请为它鼓掌！T9】</a></p></div></div>    
</body>
</html>