<html>
<head>
<title>Event Emitters in Node.JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点中的事件发射器。射流研究…</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/event-emitters-in-node-js-d93084441974?source=collection_archive---------7-----------------------#2020-04-18">https://medium.com/analytics-vidhya/event-emitters-in-node-js-d93084441974?source=collection_archive---------7-----------------------#2020-04-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/9f4bf76dd790698251a2a6d18622cc4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*DY7TZYQtJRzSv6bpjUYdYg.png"/></div><figcaption class="hn ho et er es hp hq bd b be z dx translated">NodeJS徽标。来源:维基百科</figcaption></figure><div class=""/><p id="1bce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您曾经在浏览器上使用过JavaScript，您会意识到用户的交互有多少是通过事件完成的——鼠标点击、键盘按压等等。</p><blockquote class="jo jp jq"><p id="b679" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">节点'<strong class="is hu">中的许多对象发出</strong>事件来引起'<strong class="is hu">观察者'</strong>或<strong class="is hu">' T5 '<strong class="is hu">监听器</strong>对象的注意，以便执行某个功能。这里，该函数被称为“<strong class="is hu">事件处理程序</strong></strong></p></blockquote><p id="53cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个例子是:每当用户点击按钮时，程序员想要执行一个函数(一段代码)。在本例中，发出了一个单击事件。</p><p id="6d73" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个架构可以通过位于<em class="jr">事件</em>模块中的<em class="jr">事件发射器</em>类来实现。</p><h1 id="6602" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">代码</h1><p id="0772" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">这里，我们将发出一个‘scream’事件，然后为它编写一个侦听器。</p><p id="70da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，你必须<em class="jr"> require() </em>这个<em class="jr"> events </em>模块，然后像这样使用它:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="2d96" class="lh jw ht ld b fi li lj l lk ll">const events  = require('events')<br/>const eventEmitter = new events.EventEmitter()</span></pre><p id="a248" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们创建一个每当事件被发出时都会被执行的函数。换句话说，让我们编写一个事件处理程序</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="f50a" class="lh jw ht ld b fi li lj l lk ll">const myEventHandler = function() {<br/>console.log("I sense a scream")<br/>}</span></pre><p id="d5d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将<strong class="is hu">将</strong>这个处理程序连接到我们的<strong class="is hu">事件发射器</strong></p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="86d0" class="lh jw ht ld b fi li lj l lk ll">eventHandler.on('scream' , myEventHandler)</span></pre><p id="52bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面写的代码说<strong class="is hu">在</strong>a’<strong class="is hu">scream</strong>事件上，函数<em class="jr"> myEventHandler </em>将被执行。</p><p id="7a1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们发出<strong class="is hu">尖叫</strong>事件</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="5b2d" class="lh jw ht ld b fi li lj l lk ll">eventHandler.emit(‘scream’)</span></pre><p id="d73c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行你的代码，你会在屏幕上看到“我感觉到一声尖叫”的字样。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="25c6" class="jv jw ht bd jx jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks bi translated">步伐</h1><figure class="ky kz la lb fd hk er es paragraph-image"><div class="er es ly"><img src="../Images/d7f963a26a74434a95b28a9e376c81ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/0*MZBKSqPPADMlwDeY"/></div><figcaption class="hn ho et er es hp hq bd b be z dx translated">来源:微软dev 283 x‘NodeJS入门’课程。章节:介绍事件发射器</figcaption></figure><ol class=""><li id="24b9" class="lz ma ht is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated"><em class="jr">要求事件</em>模块</li><li id="d3ec" class="lz ma ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh bi translated">创建<em class="jr">事件发射器</em>的实例</li><li id="0b43" class="lz ma ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh bi translated">用<em class="jr">创建一个观察器(事件监听器)。on(eventName，eventHandler) </em></li><li id="4810" class="lz ma ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh bi translated">用<em class="jr"> emit() </em>发出一个事件，并执行观察器中的事件处理程序。</li></ol></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="7853" class="jv jw ht bd jx jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks bi translated">自定义事件发射器</h1><p id="dc50" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">我们可以通过创建一个从<em class="jr"> EventEmitter </em>类继承的类来编写定制的事件发射器。</p><p id="90dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，让我们编写一个事件发射器，每当事件被激发/发射时给出时间</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="0376" class="lh jw ht ld b fi li lj l lk ll">const EventEmitter = require('events')<br/>class Job extends EventEmitter{}</span><span id="52ee" class="lh jw ht ld b fi mn lj l lk ll">job  = new Job()</span><span id="ac16" class="lh jw ht ld b fi mn lj l lk ll">job.on('done' , function(timeDone) {<br/>console.log('Job was done at ' + timeDone)<br/>})</span><span id="dfab" class="lh jw ht ld b fi mn lj l lk ll">job.emit('done', new Date()</span><span id="7baf" class="lh jw ht ld b fi mn lj l lk ll">job.removeAllListeners() //remove all observers</span></pre></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="0e9e" class="jv jw ht bd jx jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks bi translated">多个事件触发器</h1><p id="e9c4" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">事件也可以被多次触发。为此，多次运行'<em class="jr"> emit()' </em>。</p><p id="8dc7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们重用第一个例子中的代码</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="e01e" class="lh jw ht ld b fi li lj l lk ll">const events  = require('events')<br/>const eventEmitter = new events.EventEmitter()</span><span id="85be" class="lh jw ht ld b fi mn lj l lk ll">const myEventHandler = function() {<br/>console.log("I sense a scream")<br/>}</span><span id="640f" class="lh jw ht ld b fi mn lj l lk ll">eventHandler.on('scream' , myEventHandler)<br/>eventHandler.emit(‘scream’)<br/>eventHandler.emit('scream')</span></pre><p id="373a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行代码，你会看到“我感觉到一声尖叫”打印了两次</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="e273" class="jv jw ht bd jx jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks bi translated">仅执行一次观察者代码</h1><p id="08e3" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">在某些情况下，无论事件发出多少次，您都希望事件处理程序只运行一次</p><p id="1609" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，可使用功能<em class="jr"> emitter.once. </em>它与<em class="jr"> emitter.on具有相同的参数。</em></p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="f5c0" class="lh jw ht ld b fi li lj l lk ll">const events = require('events')<br/>const EventEmitter = new events.EventEmitter()</span><span id="ff75" class="lh jw ht ld b fi mn lj l lk ll">EventEmitter.once('scream' , function() {<br/>console.log(" I sense a scream ")<br/>})</span><span id="e809" class="lh jw ht ld b fi mn lj l lk ll">EventEmitter.emit('scream')<br/>EventEmitter.emit('scream')</span></pre><p id="e3d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，“我感觉到一声尖叫”将只印一次。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="c701" class="jv jw ht bd jx jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks bi translated">模块化事件</h1><p id="de68" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">在真实世界的项目中，事件发射器类文件和事件发射文件被分离到它们自己的模块中</p><p id="5e67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，这允许我们在不改变模块代码本身的情况下改变模块行为</p><p id="e5be" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr"> job.js </em></p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="2f5c" class="lh jw ht ld b fi li lj l lk ll">const EventEmitter = require('events')</span><span id="402b" class="lh jw ht ld b fi mn lj l lk ll">class Job extends EventEmitter {<br/> constructor() {<br/> super()<br/> this.on('start', ()=&gt; {<br/>  <br/>  this.process()<br/> })<br/> }<br/> <br/>  process() {<br/> this.emit('done' , ()=&gt; {<br/> console.log('completed!')<br/> })<br/> }<br/>}</span><span id="9a09" class="lh jw ht ld b fi mn lj l lk ll">module.exports = Job</span></pre><p id="c3d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果创建了<em class="jr">作业</em>的实例，那么已经创建了一个观察者(<em class="jr"> this.on(..))</em>如果发出“开始”事件，它将执行一个名为<em class="jr"> process() </em>的功能</p><p id="4990" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们创建另一个模块，<em class="jr"> executed.js </em></p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="03a7" class="lh jw ht ld b fi li lj l lk ll">var Job = require("./job")<br/>var job = new Job() </span><span id="71e8" class="lh jw ht ld b fi mn lj l lk ll">job.on('done', ()=&gt; {<br/>console.log('completed on ' + new Date())<br/>})</span><span id="8631" class="lh jw ht ld b fi mn lj l lk ll">job.emit('start');</span></pre><p id="3f40" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们实现了一个观察者，并为“完成”事件编写了一个事件处理程序。接下来，我们发出'<em class="jr"> start </em>'事件。根据<em class="jr"> job.js </em>发出“开始”事件执行一个名为“<em class="jr"> process() </em>的函数，该函数发出一个“完成”事件。“done”的观察者代码现在执行其事件处理程序。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="81cc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你需要花一些时间来理解事件发射器的概念，但是读一两遍就能正确理解了。</p><p id="5e13" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天到此为止。谢谢你留下来！</p><p id="efde" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">呆在家里拯救世界</p></div></div>    
</body>
</html>