<html>
<head>
<title>The compilation process of a c source file</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个c源文件的编译过程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-compilation-process-of-a-c-source-file-bd94f11a0f34?source=collection_archive---------16-----------------------#2020-11-18">https://medium.com/analytics-vidhya/the-compilation-process-of-a-c-source-file-bd94f11a0f34?source=collection_archive---------16-----------------------#2020-11-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e71e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将一个<code class="du jd je jf jg b">C</code>源文件编译成一个可执行程序，需要多个步骤。它们如下:</p><h1 id="56b4" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">源文件的准备</h1><p id="a8fa" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">编译<code class="du jd je jf jg b">C</code>源文件的第一步是预处理源文件的准备。</p><p id="01b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准备步骤的第一步是物理源文件，字符，被<strong class="ih hj"> <em class="kk">映射</em> </strong>到<a class="ae kl" href="https://twiserandom.com/c/c-source-execution-basic-and-extended-character-sets/" rel="noopener ugc nofollow" target="_blank">源字符集</a>，因此多字节编码或其他编码被映射到源字符集。</p><p id="358f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，<strong class="ih hj"> <em class="kk">三个字母被它们所代表的字符代替</em> </strong>。<a class="ae kl" href="https://difyel.com/c/lexical/what-is-a-trigraph-in-c/" rel="noopener ugc nofollow" target="_blank">三字符</a>由两个询问标记和一个字符组成，用于替换某些字符。例如<code class="du jd je jf jg b">??(</code>可以作为<code class="du jd je jf jg b">[</code>的替代品。</p><p id="4563" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，任何<strong class="ih hj"> <em class="kk">反斜杠后跟一个新行</em> </strong>，都被删除。一个反斜杠后跟一个新行，可以用来在多行上写一个预处理指令，比如<code class="du jd je jf jg b">#define</code>。</p><h1 id="7878" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">预处理</h1><p id="a9d4" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">源文件现在由字符序列和空格组成。这些字符序列中，有些被<strong class="ih hj"> <em class="kk">认为是</em> </strong> <em class="kk"> </em>预处理标记，有些是注释，三分之一与预处理无关。</p><p id="eaba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来发生的是，每个注释<strong class="ih hj"><em class="kk"/></strong>，都被一个空格所代替。</p><p id="9984" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，<em class="kk">预处理器令牌被解释为</em>。执行指令如<code class="du jd je jf jg b">#ifdef</code>，扩展宏如<code class="du jd je jf jg b">#define x 1</code>。最后，执行<code class="du jd je jf jg b">#include</code>指令，使引用的头文件或源文件首先像第一步一样为预处理做准备，然后像第二步一样进行预处理。</p><p id="0d02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦预处理完成，<strong class="ih hj"> <em class="kk">预处理工件</em> </strong>被删除。</p><p id="8e3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预处理步骤，可以单独执行，通过发出<strong class="ih hj"> <em class="kk">命令</em> </strong>:</p><pre class="km kn ko kp fd kq jg kr ks aw kt bi"><span id="ab30" class="ku ji hi jg b fi kv kw l kx ky">$ gcc -E source.c &gt; name_of_preprocessed_file.i <br/># If using the gcc compiler . </span><span id="7fe8" class="ku ji hi jg b fi kz kw l kx ky">$ cc -E source.c &gt; name_of_preprocessed_file.i <br/># If using the cc compiler . </span><span id="2833" class="ku ji hi jg b fi kz kw l kx ky">$ cpp -E source.c &gt; name_of_preprocessed_file.i <br/># If using the c preprocessor .</span></pre><p id="b89a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，这是一个<code class="du jd je jf jg b">C</code>源文件:</p><pre class="km kn ko kp fd kq jg kr ks aw kt bi"><span id="1799" class="ku ji hi jg b fi kv kw l kx ky">/* This is a comment */<br/>#define x 0<br/>int y = 1,/* Comments are replaced by a single space*/y;</span><span id="341b" class="ku ji hi jg b fi kz kw l kx ky">int z = x</span></pre><p id="6f5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是预处理这个文件的输出:</p><pre class="km kn ko kp fd kq jg kr ks aw kt bi"><span id="154e" class="ku ji hi jg b fi kv kw l kx ky">$ gcc -E source.c<br/>int y = 1, y;</span><span id="8837" class="ku ji hi jg b fi kz kw l kx ky">int z = 0</span></pre><p id="4295" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">$ gcc -E source.c</code>，预处理<code class="du jd je jf jg b">source.c</code>文件，并输出其内容。注释被替换为一个空格，并且执行预处理器指令。不执行<code class="du jd je jf jg b">C</code>语法检查。</p><h1 id="74a4" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">为执行环境做准备</h1><p id="1a11" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">第三步，为执行环境做好准备。字符常量和字符串文字，从源字符集<strong class="ih hj"> <em class="kk">翻译</em> </strong>，到<a class="ae kl" href="https://twiserandom.com/c/c-source-execution-basic-and-extended-character-sets/" rel="noopener ugc nofollow" target="_blank">执行字符集</a>，包括任何转义序列，如<code class="du jd je jf jg b">\n</code>。</p><p id="58a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相邻的字符串文字，比如<code class="du jd je jf jg b">"a" "b"</code>被<em class="kk">连接</em>成一个。</p><p id="9f1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个步骤产生的文件称为<em class="kk">翻译单元</em>。</p><h1 id="9a71" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">转化为装配</h1><p id="1dab" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">前三个步骤产生的文件称为翻译单元，由标记和空白组成。</p><p id="2154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据C标准，对标记进行语法和语义分析。高层次的C语言，被翻译成低层次的<strong class="ih hj"><em class="kk"/></strong>汇编语言。</p><p id="2c0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个cpu架构都可以有自己的汇编语言，例如<code class="du jd je jf jg b">x64</code>汇编或<code class="du jd je jf jg b">arm</code>汇编。</p><p id="eb2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在编译时，可以指定目标架构环境。</p><p id="b6f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编译到一个架构，不同于编译器运行的架构，叫做<strong class="ih hj"> <em class="kk">交叉编译</em> </strong>。</p><p id="733c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以通过发出以下命令来执行向汇编步骤的转换:</p><pre class="km kn ko kp fd kq jg kr ks aw kt bi"><span id="3a21" class="ku ji hi jg b fi kv kw l kx ky">$ gcc -S source.c -o name_of_preprocessed_file.s<br/># If using the gcc compiler .</span><span id="1b74" class="ku ji hi jg b fi kz kw l kx ky">$ cc -S source.c -o name_of_preprocessed_file.s<br/># If using the cc compiler .</span></pre><p id="ccb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，下面的源文件:</p><pre class="km kn ko kp fd kq jg kr ks aw kt bi"><span id="7d63" class="ku ji hi jg b fi kv kw l kx ky">int main(void){ <br/>        int x =0; <br/>}</span></pre><p id="e36d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">被转换为程序集:</p><pre class="km kn ko kp fd kq jg kr ks aw kt bi"><span id="790e" class="ku ji hi jg b fi kv kw l kx ky">$ cc -S source.c<br/># Translate source.c into source.s</span><span id="24fb" class="ku ji hi jg b fi kz kw l kx ky">$ cat source.s<br/># output the content of source.s</span><span id="f6bc" class="ku ji hi jg b fi kz kw l kx ky">.section        __TEXT,__text,regular,pure_instructions<br/>        .macosx_version_min 10, 12<br/>        .globl  _main<br/>        .p2align        4, 0x90<br/>_main:                                  ## <a class="ae kl" href="http://twitter.com/main" rel="noopener ugc nofollow" target="_blank">@main</a><br/>        .cfi_startproc<br/>## BB#0:<br/>        pushq   %rbp<br/>Lcfi0:<br/>        .cfi_def_cfa_offset 16<br/>Lcfi1:<br/>        .cfi_offset %rbp, -16<br/>        movq    %rsp, %rbp<br/>Lcfi2:<br/>        .cfi_def_cfa_register %rbp<br/>        xorl    %eax, %eax<br/>        movl    $0, -4(%rbp)<br/>        popq    %rbp<br/>        retq<br/>        .cfi_endproc</span><span id="b7d2" class="ku ji hi jg b fi kz kw l kx ky">.subsections_via_symbols</span></pre><h1 id="067a" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">装配</h1><p id="4d5c" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">在这一步中，生成的汇编语言，被<strong class="ih hj"> <em class="kk">映射为</em> </strong>。机器语言仅由<code class="du jd je jf jg b">0</code>和<code class="du jd je jf jg b">1</code>组成，因此源文件现在被翻译成<code class="du jd je jf jg b">0</code>和<code class="du jd je jf jg b">1</code>。</p><p id="1a18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个步骤产生的文件称为<strong class="ih hj"> <em class="kk">目标代码</em> </strong>。目标代码还不可执行。</p><p id="60d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">装配步骤<strong class="ih hj"> <em class="kk">可通过发出以下命令</em> </strong>来执行:</p><pre class="km kn ko kp fd kq jg kr ks aw kt bi"><span id="ca7e" class="ku ji hi jg b fi kv kw l kx ky">$ as -c source.s -o source.o<br/># If using as , assemble an <br/># assembly file into an <br/># object file .</span><span id="d466" class="ku ji hi jg b fi kz kw l kx ky">$ gcc -c source.c -o source.o<br/># If using gcc  , translate <br/># a source.c file into <br/># object code .</span><span id="8e24" class="ku ji hi jg b fi kz kw l kx ky">$ cc -c source.c -o source.o<br/># If using cc , translate a <br/># source.c file into<br/># object code .</span></pre><h1 id="507d" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">连接</h1><p id="2376" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">在该步骤中，从目标代码文件创建一个<strong class="ih hj"> <em class="kk">可执行文件</em> </strong>。组合多个目标代码文件，合并部分静态库，并解析外部引用。每个操作系统都有自己的可执行目标代码格式。</p><p id="c7ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以通过使用<code class="du jd je jf jg b">ld</code>命令，或者通过为<code class="du jd je jf jg b">gcc</code>或<code class="du jd je jf jg b">cc</code>提供选项来执行链接。例如，下面的源文件:</p><pre class="km kn ko kp fd kq jg kr ks aw kt bi"><span id="6021" class="ku ji hi jg b fi kv kw l kx ky">/*source.c file */<br/>#include&lt;math.h&gt;<br/>int main(void){<br/>  double number = sqrt(2.9);<br/>}</span></pre><p id="806f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用以下方法转换为目标代码:</p><pre class="km kn ko kp fd kq jg kr ks aw kt bi"><span id="3bd8" class="ku ji hi jg b fi kv kw l kx ky">$ gcc -c source.c</span></pre><p id="d28e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目标代码可以静态链接到<code class="du jd je jf jg b">C</code>数学库，并通过发出命令变成可执行文件:</p><pre class="km kn ko kp fd kq jg kr ks aw kt bi"><span id="8709" class="ku ji hi jg b fi kv kw l kx ky">$ gcc source.o -lm -o executable_file_name</span></pre><h1 id="1a5e" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">最终注释</h1><p id="f0a0" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">编译器可以一次完成所有这些步骤。例如发出<code class="du jd je jf jg b">gcc source.c</code>或<code class="du jd je jf jg b">cc source.c</code>，源文件被翻译成可执行文件。多个源文件，可以传递给<code class="du jd je jf jg b">gcc</code>或<code class="du jd je jf jg b">cc</code>。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="b2c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kk">原载于2020年11月18日https://twiserandom.com</em><em class="kk">的</em> <a class="ae kl" href="https://twiserandom.com/c/the-compilation-process-of-a-c-source-file/" rel="noopener ugc nofollow" target="_blank"> <em class="kk">。</em></a></p></div></div>    
</body>
</html>