<html>
<head>
<title>Machine Learning and Data Analysis with Python, Titanic Dataset: Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python进行机器学习和数据分析，Titanic数据集:第4部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-and-data-analysis-with-python-titanic-dataset-part-4-92a985d7ad52?source=collection_archive---------15-----------------------#2020-03-03">https://medium.com/analytics-vidhya/machine-learning-and-data-analysis-with-python-titanic-dataset-part-4-92a985d7ad52?source=collection_archive---------15-----------------------#2020-03-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5ecd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">进行改进并重新提交</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e23ee4c6d389f56e45802c993fdeac65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVqOtCOc7ViXMbyhxOu5nQ.png"/></div></div></figure><p id="bcaa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们已经在第三部中向Kaggle提交了我们的第一次提交。在这个系列的最后一部分，我们将尝试对我们的预测进行改进，并重新提交以查看我们的结果。链接到本教程的视频版本将在底部。</p><p id="0ef8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们开始吧！</p><p id="66fa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当谈到改进我们的预测时，我们通常要考虑两件事:</p><ul class=""><li id="2cc1" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">进一步的特征工程</li><li id="1788" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">模型调整</li></ul><p id="5f00" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是在我们继续之前，让我们回顾一下使用基线模型的提交分数:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ku"><img src="../Images/d1683951c58af34ccb64cd06584ef2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Zlb8zxgPNxZhgI6VUDNnQ.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">基线模型分数</figcaption></figure><p id="889a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你可能已经注意到了这里的一些差异。为什么我们80-20分割的测试集获得了82.68%的准确率，而Kaggle测试集的预测只有76%的准确率？</p><p id="59fd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">原因之一是这些模型预测的方式存在一定的随机性。与Kaggle提供的测试集相比，我们训练的80%的数据可能恰好看起来更类似于我们作为模拟测试集留下的20%的数据。结果，从这80%的数据训练的模型将在20%的模拟测试集上表现得更好。特别是当我们的训练集很小的时候，很有可能在一个随机选择的测试集上的预测比另一个稍微好一点。</p><p id="63fa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我向您展示我在20%测试集的不同随机选择上运行一些测试的意思。</p><p id="2d8c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们在训练测试分割函数中使用了随机状态42:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kz"><img src="../Images/8f5dae7eff391836e71b8c5f25f6db4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0uiIIRFxAWio_TS1m6zemA.png"/></div></div></figure><p id="ae6e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个数字实质上决定了选取哪20%的数据，所以每次我们运行这条线时，它都会使用相同的分割。这被称为随机种子，它在某种意义上是有用的，我们可以控制随机性，以便在不同的试验之间进行公平的比较。</p><p id="c8c1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看当我们把这个随机状态改为0时会发生什么:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es la"><img src="../Images/2c416e25c03cd35a8e57d94059d20bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kAYYYGBorcyzFNxSFKvagg.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">train_test_split随机状态为0的结果</figcaption></figure><p id="9770" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将此与随机状态为42时的结果进行比较:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lb"><img src="../Images/77e057083ae65657e12d624ae2ed2572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2d7_33v5DqZVlvMy_Ptm2Q.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">在train_test_split时随机状态为42的结果</figcaption></figure><p id="bb08" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们准确率下降了2%以上。</p><p id="04be" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，在我们尝试创建更多要素或改进模型之前，为了比较任何两个模型之间的精度，我们可能需要取某种平均值来最小化这种随机性的影响。</p><p id="a348" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要获得平均分:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kz"><img src="../Images/2d779ea8a44de04731077b5407eee2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3MIIuHeketNz5T_jR3ymA.png"/></div></div></figure><p id="66de" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">导入numpy库并使用。创建一个50个数字的列表作为我们的随机状态。使用这50个数字中的每一个作为随机状态，并取各自准确度分数的平均值。这平均有78.8%的准确率。</p><p id="11ef" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们可以回到数据帧，看看我们可以使用哪些附加功能来提高性能。在基线模型中，我们删除了列<em class="lc">姓名</em>、<em class="lc">机票</em>和<em class="lc">舱位</em>，因此也许我们可以从这3列中提取一些有用的信息，并将它们合并回模型中。</p><p id="09b8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们知道在<em class="lc">舱</em>列中有很多缺失值，所以像我们在<em class="lc">年龄</em>列中所做的那样尝试填充它们可能不值得。然而，在某个乘客错过他/她的<em class="lc">舱</em>入口的背后可能有原因，并且这个原因可能与他/她是否幸存相关。我们可以通过打印出缺少<em class="lc">舱室</em>条目的人和没有这些条目的人的存活率来检查这种可能性:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ld"><img src="../Images/e4e186d149cefe317f2f3464632a0cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGDIHfDvY5oIWcUjBVOinw.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">客舱失联与非失联乘客的存活率比较</figcaption></figure><p id="1fb8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">存活率确实差别很大，所以看起来这是我们想要的特性。要使用此功能:</p><pre class="iy iz ja jb fd le lf lg lh aw li bi"><span id="2d6d" class="lj lk hi lf b fi ll lm l ln lo">df["is missing cabin"] = df["Cabin"].isna()</span></pre><p id="2f99" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">请注意，布尔特征也被接受为我们的模型输入。</p><p id="c7f3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后再次运行循环。这一次，我们的平均得分是78.7%，这表明添加这个特性对模型没有任何改进。</p><p id="e35e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们试着添加一些别的东西。</p><p id="d1a3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在Kaggle讨论区，经常有人分享对改进他们的模型有用的代码。您可以从这些讨论中找到灵感，并为您自己模型添加特性。例如，我在这里找到了一段处理name列的代码:</p><div class="lp lq ez fb lr ls"><a href="https://github.com/minsuk-heo/kaggle-titanic/blob/master/titanic-solution.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">闵素赫/卡格尔-泰坦尼克号</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">permalink dissolve GitHub是4000多万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">github.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg jh ls"/></div></div></a></div><p id="8d8d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">实际上，在“姓名”列中，每个乘客的姓名后面都有一个头衔。一些常见的称呼是先生、夫人、小姐。，而这些标题后面总是跟着一个“.”性格。要提取标题:</p><pre class="iy iz ja jb fd le lf lg lh aw li bi"><span id="d13a" class="lj lk hi lf b fi ll lm l ln lo">df['Title'] = df['Name'].str.extract(' ([A-Za-z]+)\.', expand=False)</span></pre><p id="e8af" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">而我们的<em class="lc">标题</em>列将会是这样的:</p><div class="iy iz ja jb fd ab cb"><figure class="mh jc mi mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/ab71da38d05c115af87dd6cf614f715c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*A3AAZGgHf4E-TTijeCKzuA.png"/></div></figure><figure class="mh jc mn mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/38ce265edc2767d34b59285274e205cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*GkOGT0q3rU9MHnM-mVz7_A.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx mo di mp mq translated">标题列及其分布</figcaption></figure></div><p id="4311" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以看到有一些常见的称呼如先生，小姐。、夫人，还有一些不常见的头衔如少校。先生。这些不太常见的头衔类似于高基数特征，在某种意义上，用它们进行训练不会提供可概括的信息。这就是为什么在讨论核心中，作者将所有不常见的标题映射到一个唯一的值，并将常见的标题映射到它们自己的唯一值:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/134d0928fd6bdbdef10632de59c0c94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQT2lG_rEGbD20wxZ5kXpw.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">将标题映射到整数</figcaption></figure><p id="fad9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我们使用<em class="lc"> Title </em>特性再次运行循环，我们将获得79.16%的准确率，这比我们的基线模型稍好。</p><p id="22b5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们现在已经试验了两个额外的特性。其中一个根本没有提高我们的分数，另一个只提高了不到0.5%。在这里不要气馁。这有时表明模型设置不适合这个问题，这就把我们带到了提高性能的第二种方法:对模型进行调整。我们一直使用ExtraTreesClassifier的默认hyper参数，其中一个名为max_depth的参数被设置为None。此参数限制了森林中的树可以生长到的最大深度，默认设置“无”允许每棵树尽可能深地生长，这可能会使模型过拟合。</p><p id="9c94" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们尝试给定最大深度限制为10:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/d1272be46c94c24c795459017bf49529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_SHxj_5lff0LG8m3XoCWQ.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">设置max_depth = 10</figcaption></figure><p id="a370" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如预期的那样，平均准确度得分有了更显著的提高。</p><p id="0df0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">了解了限制max_depth的影响后，让我们回到基线模型，看看基线要素和max_depth =10时我们的平均精度得分是多少。如果您使用新的模型设置再次运行我们的基线设置，您应该会得到81.7%的平均分，甚至更高。</p><p id="9724" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">不幸的是，在这一点上的结论是，我们的基线特征与参数{n_estimators=100，max_depth=10}配对给出了最好的性能。这是否意味着我们探索的2个额外特性完全没有用？添加这两个特性可能没有帮助，但在实践中，我们通常会在得出特性没有用的结论之前做更多的优化(这需要另一篇文章来解释)。只有当模型的超参数也适合这些特征时，一组特征才处于它们的最佳性能。我们已经看到了一个这样的例子:当我们将max_depth设置为10而不是缺省的None时，基线特性给出了更高的平均准确度分数。我将写一篇文章，介绍我使用过的超参数调优的常用方法，以及每种方法的优点和注意事项。有兴趣的敬请关注！</p><p id="54b6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为我们没有使用额外的特性，所以我们不需要对Kaggle测试集做任何预处理。只需使用新模型(max_depth=10)进行预测，并将我们的预测保存在submission.csv中，然后重新提交。你应该看到你的排名上升，通过添加这一个变化！</p><p id="75cb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">几分钟前承诺的视频…</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">本文视频教程</figcaption></figure></div></div>    
</body>
</html>