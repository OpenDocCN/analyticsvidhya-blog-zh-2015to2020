<html>
<head>
<title>Automated data pipeline using Ceph notifications and KNative Serving</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Ceph通知和被动服务的自动化数据管道</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/automated-data-pipeline-using-ceph-notifications-and-kserving-5e1e9b996661?source=collection_archive---------6-----------------------#2020-01-09">https://medium.com/analytics-vidhya/automated-data-pipeline-using-ceph-notifications-and-kserving-5e1e9b996661?source=collection_archive---------6-----------------------#2020-01-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f4cf" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">实施解决方案和创建演示的完整指南！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/80e362bf4be21d8fe0f65e4e7e7293f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*Js6C0Y4kP36NG0FL1EY4RQ.png"/></div></figure><p id="ef34" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我最近分享了一个视频，演示了如何利用Ceph的新通知功能以及Kafka和KNative事件和服务来创建全自动的数据管道。如果你还没有做的话，最好快点检查一下，因为这会帮助你理解这篇文章的其余部分！</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="80b6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果您没有时间，下面是我们将实施的场景的摘要:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kd"><img src="../Images/1ca375ca3756b1f14add806fa78b7b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfbLCUhYDQoURO7JsE7bPw.png"/></div></div></figure><p id="47a0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">既然我们都在同一页面上，让我们看看如何在您舒适的(家|隔间|机场休息室|蝙蝠洞)中重现此演示…</p><p id="5e68" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">注</strong>:这里使用的所有代码都可以在https://github.com/guimou/dataprep-code<a class="ae ki" href="https://github.com/guimou/dataprep-code/tree/master/examples/xray" rel="noopener ugc nofollow" target="_blank">获得</a></p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="1b8a" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">准备数据</h1><p id="a350" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">这些步骤并不完全必要，因为我所分享的代码已经包含了一个经过训练的模型和一些演示图片，您可以使用。但如果你想知道整个事情是如何运作的，或者你想从头开始重现一切，那就试一试吧！</p><h2 id="9e75" class="ln kr hi bd ks lo lp lq kw lr ls lt la jo lu lv lc js lw lx le jw ly lz lg ma bi translated">数据集</h2><p id="6283" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">该演示基于以下数据集，可从Kaggle获得:<a class="ae ki" href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/paultimothymooney/chest-x ray-pneumonia</a>。这是一组胸部x光图像，分别来自有肺炎症状的患者(约1300张图像)和健康人(约3900张图像)。当然，它们已经被分类，并分成不同的批次进行训练、验证和测试。所以第一步当然是下载并解压到某个地方(~1.2GB)。这就给出了下面的结构(demo_base来自后面的操作):</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="77cf" class="ln kr hi mc b fi mg mh l mi mj">.<br/>└── data<br/>    └── chest_xray<br/>        ├── demo_base<br/>        │   ├── NORMAL<br/>        │   └── PNEUMONIA<br/>        ├── test<br/>        │   ├── NORMAL<br/>        │   └── PNEUMONIA<br/>        ├── train<br/>        │   ├── NORMAL<br/>        │   └── PNEUMONIA<br/>        └── val<br/>            ├── NORMAL<br/>            └── PNEUMONIA</span></pre><h2 id="17cf" class="ln kr hi bd ks lo lp lq kw lr ls lt la jo lu lv lc js lw lx le jw ly lz lg ma bi translated">训练模型</h2><p id="08b6" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">我用来训练模型的笔记本“x-ray-predict-pneumonia-keras-training . ipynb”可以在repo中的examples/xray/utils下获得。如果您有上面的目录结构，您可以从项目的根目录使用它。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mk kc l"/></div></figure><p id="4e08" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这只是一个运行笔记本电脑的问题，耐心点，在GTX1070Ti的帮助下，对我来说大约2000万(是的，我不仅做演示和发布，虽然我肯定会得到一个RTX…😁).如果一切顺利，您应该获得用于预测的“pneumonia_model.h5”文件。</p><h2 id="1314" class="ln kr hi bd ks lo lp lq kw lr ls lt la jo lu lv lc js lw lx le jw ly lz lg ma bi translated">创建演示图像</h2><p id="5df8" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">当然，我们从原始数据集中获得的图像是完全匿名的。但是对于匿名化演示，我们想上传包含个人信息的图像…好吧，让我们创建它们吧！这是在“make_demo_images.ipynb”笔记本的帮助下完成的，位置与上一个笔记本相同。这里没有火箭科学:我们只是从原始数据集(在val/PNEUMONIA文件夹中)获取图像，并生成一些随机的个人信息，然后粘贴到图像上。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mk kc l"/></div></figure><p id="64d0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这就是数据部分，我们现在有一个模型，和一些我们可以在演示中使用的图像！</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="5e3b" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">主菜前的一些开胃菜(听起来比先决条件要好)</h1><h2 id="8667" class="ln kr hi bd ks lo lp lq kw lr ls lt la jo lu lv lc js lw lx le jw ly lz lg ma bi translated">Ceph</h2><p id="a940" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">对于这个演示，您当然需要一个Ceph集群，但是对于完整的安装过程，那是另外一个故事了……不过，快速提示:为了执行演示的其余部分，您还需要OpenShift或另一种类型的Kubernetes集群(虽然没有经过测试！)，您可以使用<a class="ae ki" href="https://rook.io/docs/rook/v1.2/ceph-quickstart.html" rel="noopener ugc nofollow" target="_blank"> Rook-Ceph </a>来部署您的Ceph实例(这就是我在这里使用的)。到目前为止，我正在使用的Kafka通知只在Ceph的master分支上可用(但是HTTP和AMQ通知已经在最新版本中了)。因此，如果您使用rook-ceph，请确保您的集群yaml文件在某个时间点读取:</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="a094" class="ln kr hi mc b fi mg mh l mi mj">cephVersion:<br/> image: ceph/daemon-base:latest-master-devel<br/> allowUnsupported: true</span></pre><p id="1509" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><em class="ml">(当该功能在标准版本中可用时，我会更新帖子)。</em></p><h2 id="8f14" class="ln kr hi bd ks lo lp lq kw lr ls lt la jo lu lv lc js lw lx le jw ly lz lg ma bi translated">卡夫卡</h2><p id="0ffa" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">这里就不多说了，因为部署卡夫卡和创造话题本身也是另一回事。因此，我假设您已经准备好Kafka集群，所有必要的端点信息，并且您已经创建了一个主题，在我们的示例中称为“存储”。不过还有一个小提示:您可以使用<a class="ae ki" href="https://strimzi.io/" rel="noopener ugc nofollow" target="_blank"> Strimzi </a>操作符在OpenShift上快速轻松地部署Kafka。</p><h2 id="22a0" class="ln kr hi bd ks lo lp lq kw lr ls lt la jo lu lv lc js lw lx le jw ly lz lg ma bi translated">KNative / OpenShift无服务器</h2><p id="deec" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">最后，KNative必须安装在集群上。同样，本文的目的不是详述这种操作，已经有很多关于这方面的文档了。</p><p id="8b70" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">但是要小心！为了让这个演示运行，您必须安装KafkaSource资源。这是KNative eventing的一个“附加组件”，你可以按照这里的说明安装:<a class="ae ki" href="https://github.com/knative/eventing-contrib/tree/v0.12.4/kafka/source" rel="noopener ugc nofollow" target="_blank">https://github . com/KNative/eventing-contrib/tree/v 0 . 12 . 4/Kafka/source</a></p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="cc4d" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">创建管道</h1><p id="d5a9" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">如果您还记得视频中的内容(或者如果您没有看过，就不记得了)，这是我们将要建立的管道:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kd"><img src="../Images/5b25e6c1d97017b4669dd1633188dad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilAc2PQdEHUDo1cGUHr1IQ.png"/></div></div></figure><p id="e46a" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">您可以从创建我们将在本演示中使用的3个存储桶开始:x射线数据输入、x射线数据处理和x射线数据匿名。</p><h2 id="624b" class="ln kr hi bd ks lo lp lq kw lr ls lt la jo lu lv lc js lw lx le jw ly lz lg ma bi translated">设置Kafka的存储桶通知</h2><p id="fb1a" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">现在到桶通知！为了帮助您完成这些步骤，您将在utils文件夹中找到所有请求的Postman集合“Ceph notifications pipeline . Postman _ collection . JSON”。无论您是否使用它，<strong class="jh hj">不要忘记设置您的凭证</strong>(用户访问密钥和秘密密钥)以便能够与网关交互。在Postman中，您必须编辑集合参数(授权选项卡)，或者您可以逐个请求地设置它们。</p><p id="cf43" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">涉及两个不同的步骤:</p><ul class=""><li id="b479" class="mm mn hi jh b ji jj jl jm jo mo js mp jw mq ka mr ms mt mu bi translated">创建一个Kafka主题:这是一个简单的对网关的POST请求，传递所需的参数:</li></ul><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="7be0" class="ln kr hi mc b fi mg mh l mi mj">POST <a class="ae ki" href="http://your.ceph.rgw.url/?Action=CreateTopic&amp;Name=storage&amp;push-endpoint=kafka://my-cluster-kafka-bootstrap.kafka:9092&amp;kafka-ack-level=broker" rel="noopener ugc nofollow" target="_blank">http://your.ceph.rgw.url/?Action=CreateTopic&amp;Name=storage&amp;push-endpoint=kafka://my-cluster-kafka-bootstrap.kafka:9092&amp;kafka-ack-level=broker</a></span></pre><p id="7bc4" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">它会以<strong class="jh hj">arn:AWS:SNS:my-store::storage</strong>的形式返回主题信息</p><ul class=""><li id="0545" class="mm mn hi jh b ji jj jl jm jo mo js mp jw mq ka mr ms mt mu bi translated">创建通知:这是对您希望启用通知的bucket上的网关的PUT请求。在我们的示例中，它是x射线数据输入:</li></ul><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="ad6c" class="ln kr hi mc b fi mg mh l mi mj">PUT <a class="ae ki" href="http://your.ceph.rgw.url/data-bckt?notification" rel="noopener ugc nofollow" target="_blank">http://your.ceph.rgw.url/</a>xray-data-in<a class="ae ki" href="http://your.ceph.rgw.url/data-bckt?notification" rel="noopener ugc nofollow" target="_blank">?notification</a></span></pre><p id="d20c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在请求体中以XML形式传递参数(包括您刚刚创建的主题):</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="ef70" class="ln kr hi mc b fi mg mh l mi mj">&lt;NotificationConfiguration xmlns=”<a class="ae ki" href="http://s3.amazonaws.com/doc/2006-03-01/" rel="noopener ugc nofollow" target="_blank">http://s3.amazonaws.com/doc/2006-03-01/</a>"&gt;<br/> &lt;TopicConfiguration&gt;<br/> &lt;Id&gt;storage&lt;/Id&gt;<br/> &lt;Topic&gt;arn:aws:sns:my-store::storage&lt;/Topic&gt;<br/> &lt;/TopicConfiguration&gt;<br/>&lt;/NotificationConfiguration&gt;</span></pre><p id="d1ad" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">就这么简单！</p><h2 id="75a4" class="ln kr hi bd ks lo lp lq kw lr ls lt la jo lu lv lc js lw lx le jw ly lz lg ma bi translated">部署KNative服务容器</h2><p id="3d9b" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">容器将进行图像分析，并最终实现匿名化。源代码位于repo的examples/Xray/Xray-event-container文件夹中。以下是Python代码本身:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mk kc l"/></div></figure><p id="b1bc" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这几乎是不言自明的和评论，但如果你有任何问题，请留下评论。你可以自己建造它，或者使用quay.io/guimou/xray:master的图像</p><p id="0fc2" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在创建了项目/名称空间“xray”之后，我们将创建一个秘密，其中包含访问容器将与之交互的不同存储桶所需的凭证(不要忘记创建它们！对于本演示，您应该有x射线数据输入、x射线数据处理和x射线数据匿名。下面是“secret.yaml”文件(您必须输入实际的密钥/秘密值):</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="3e6b" class="ln kr hi mc b fi mg mh l mi mj">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/> name: s3-secret<br/> namespace: xray<br/>stringData:<br/> AWS_ACCESS_KEY_ID: replace_me <br/> AWS_SECRET_ACCESS_KEY: replace_me</span></pre><p id="5c7e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们部署的:</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="3f0b" class="ln kr hi mc b fi mg mh l mi mj">oc create -f secret.yaml</span></pre><p id="4c75" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然后我们用“service-xray.yaml”定义我们的服务(您必须输入正确的service_point URL):</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="ce48" class="ln kr hi mc b fi mg mh l mi mj">apiVersion: serving.knative.dev/v1alpha1 <br/>kind: Service<br/>metadata:<br/> name: xray<br/> namespace: xray<br/>spec:<br/> template:<br/>   spec:<br/>     containers:<br/>     — image: quay.io/guimou/xray:master<br/>       env:<br/>       — name: AWS_ACCESS_KEY_ID<br/>         valueFrom:<br/>           secretKeyRef:<br/>             name: s3-secret<br/>             key: AWS_ACCESS_KEY_ID <br/>       — name: AWS_SECRET_ACCESS_KEY<br/>         valueFrom:<br/>           secretKeyRef:<br/>             name: s3-secret<br/>             key: AWS_SECRET_ACCESS_KEY <br/>       — name: service_point<br/>         value: http://your.gateway.url</span></pre><p id="fdc7" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们部署的:</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="aaa1" class="ln kr hi mc b fi mg mh l mi mj">oc create -f service-xray.yaml</span></pre><h2 id="9d11" class="ln kr hi bd ks lo lp lq kw lr ls lt la jo lu lv lc js lw lx le jw ly lz lg ma bi translated">部署已知事件源</h2><p id="4a7b" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">该组件将使用我们的Kafka主题，并将消息传递给我们刚刚创建的服务。</p><p id="5ce8" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">它由“kafkasource.yaml”定义:</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="ff91" class="ln kr hi mc b fi mg mh l mi mj">apiVersion: sources.eventing.knative.dev/v1alpha1<br/>kind: KafkaSource<br/>metadata:<br/> name: kafka-source<br/> namespace: xray<br/>spec:<br/> consumerGroup: xray<br/> bootstrapServers: my-cluster-kafka-bootstrap.kafka:9092<br/> topics: storage<br/> sink:<br/>   apiVersion: serving.knative.dev/v1alpha1<br/>   kind: Service<br/>   name: xray</span></pre><p id="978c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">并且再次部署有:</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="f71f" class="ln kr hi mc b fi mg mh l mi mj">oc create -f kafkasource.yaml</span></pre><p id="0c00" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一切都准备好了，应该可以工作了！</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="7da5" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">审查整个管道</h1><p id="07ab" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">为了更好地理解正在发生的事情，或者如果您需要做一些调试，这里是这个管道中正在发生的事情的一步一步。</p><ul class=""><li id="93f6" class="mm mn hi jh b ji jj jl jm jo mo js mp jw mq ka mr ms mt mu bi translated">当图像被推送到x射线数据输入桶时，Ceph将向Kafka发送通知。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es mv"><img src="../Images/fb16744a274406b90abb708b0fda3191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAGvOleS-870NB1m-s4_Eg.png"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx translated">原象</figcaption></figure><ul class=""><li id="d182" class="mm mn hi jh b ji jj jl jm jo mo js mp jw mq ka mr ms mt mu bi translated">该通知将是这样一条消息:</li></ul><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="bd3a" class="ln kr hi mc b fi mg mh l mi mj">{“Records”: [{“eventVersion”: “2.2”, “eventSource”: “ceph:s3”, “awsRegion”: “”, “eventTime”: “2019–12–12T02:42:43.692977Z”, “eventName”: “s3:ObjectCreated:Put”, “userIdentity”: {“principalId”: “ceph-user-bp3UfKOG”}, “requestParameters”: {“sourceIPAddress”: “”}, “responseElements”: {“x-amz-request-id”: “645c86a7–8062–43b1–972b-f6c6ccd4bc6f.134312.15301”, “x-amz-id-2”: “20ca8-my-store-my-store”}, “s3”: {“s3SchemaVersion”: “1.0”, “configurationId”: “storage”, “bucket”: {“name”: “xray-data-in”, “ownerIdentity”: {“principalId”: “ceph-user-bp3UfKOG”}, “arn”: “arn:aws:s3:::xray-data-in”, “id”: “645c86a7–8062–43b1–972b-f6c6ccd4bc6f.29026.2”}, “object”: {“key”: “data/chest_xray/demo/PNEUMONIA/demo_Anna Mcgehee_3677_1941–11–26_2015–02–10.jpeg”, “size”: 253130, “etag”: “a7d65d30ba7a639a017aa7d2c6fdc28a”, “versionId”: “”, “sequencer”: “23A9F15D4FBC632A”, “metadata”: [{“key”: “x-amz-content-sha256”, “val”: “95fe6dd24fc010ee526e40457ff34ef057d257c71b22ac9fd312094d4d7b2a37”}, {“key”: “x-amz-date”, “val”: “20191212T024243Z”}]}}, “eventId”: “1576118563.711179.a7d65d30ba7a639a017aa7d2c6fdc28a”}]}</span></pre><ul class=""><li id="da4e" class="mm mn hi jh b ji jj jl jm jo mo js mp jw mq ka mr ms mt mu bi translated">Kafka将通过“存储”主题处理此消息，因为我们在那里发布了它。</li><li id="5627" class="mm mn hi jh b ji na jl nb jo nc js nd jw ne ka mr ms mt mu bi translated">我们定义的KNative事件组件是“存储”主题的消费者。它将获取消息，并传递给它的“接收器”，即我们的服务服务。</li><li id="d50f" class="mm mn hi jh b ji na jl nb jo nc js nd jw ne ka mr ms mt mu bi translated">该服务将启动一个图像处理容器(如果尚未运行的话)，或者最终根据工作负载对其进行缩放，并向其传递消息内容。</li><li id="d288" class="mm mn hi jh b ji na jl nb jo nc js nd jw ne ka mr ms mt mu bi translated">图像处理容器将解析消息，检索图像，施展魔法(评估肺炎风险并将其打印在图像上)，然后保存它。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es nf"><img src="../Images/e193c6a9695e31c3ee82a3fab8b2a35a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Spu9EzJzkPo-D8X2CLGOdg.png"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx translated">风险评估图像，PII还在</figcaption></figure><ul class=""><li id="d0a0" class="mm mn hi jh b ji jj jl jm jo mo js mp jw mq ka mr ms mt mu bi translated">最终(取决于风险)，我们的KNative服务将对图像进行匿名化，并按照我们的场景将其保存到另一个桶中。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es nf"><img src="../Images/1718264814a3e3df873e9d3b8e0f98aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5kTb19ZfC6IyFFB6ffgVQ.png"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx translated">匿名图像</figcaption></figure><ul class=""><li id="f22a" class="mm mn hi jh b ji jj jl jm jo mo js mp jw mq ka mr ms mt mu bi translated">当该过程完成时，图像处理容器简单地终止。</li></ul><h1 id="eee2" class="kq kr hi bd ks kt ng kv kw kx nh kz la io ni ip lc ir nj is le iu nk iv lg lh bi translated">最终注释</h1><h2 id="4f05" class="ln kr hi bd ks lo lp lq kw lr ls lt la jo lu lv lc js lw lx le jw ly lz lg ma bi translated">值得一提的问题</h2><p id="5c75" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">在创建这个演示的过程中，棘手的部分是弄清楚如何监听KNative事件消息。从理论上讲，这是有据可查的，但是我真的没有找到任何简单的Python实现(至少简单到我能理解，因为我不是真正的开发人员😁).直到我找到了<a class="ae ki" href="https://blog.elegantmonkeys.com/python-serverless-event-driven-with-knative-728e96e9b35" rel="noopener ugc nofollow" target="_blank">这个帖子</a>和这个<a class="ae ki" href="https://github.com/elegantmonkeys/python-kncloudevents" rel="noopener ugc nofollow" target="_blank">项目</a>。这是一个非常好的简单的包，如果你想玩KNative和Python，它会让你很快上手。</p><p id="5990" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">但是如果你读完了所有的代码，你会问“那你为什么不使用它呢？”。这就是为什么我想在这里提到它，这个包使用ThreadedHTTPServer来监听事件。但是当从线程内部启动预测时，Keras似乎有一些问题(我必须再次承认，我并不完全理解这个问题)，预测功能将会失败。这就是为什么我用ForkedHTTPServer从包中重新实现了整个CloudeventsServer类，而不只是调用它。</p><h2 id="88c9" class="ln kr hi bd ks lo lp lq kw lr ls lt la jo lu lv lc js lw lx le jw ly lz lg ma bi translated">观点</h2><p id="f745" class="pw-post-body-paragraph jf jg hi jh b ji li ij jk jl lj im jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">这个简单的演示表明，现在比以往任何时候都更容易构建自动化数据管道，而不需要一些orchestrator或其他工具。我们可以只使用存储层和容器/应用层的本地函数，并以我们能想到的任何方式将它们绑定在一起。请继续关注其他实现！如果您有您认为可以利用这种交互的用例，请随时联系我们。</p></div></div>    
</body>
</html>