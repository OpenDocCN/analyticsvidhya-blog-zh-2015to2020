<html>
<head>
<title>Code Walkthrough in An anonymous Machine Learning Hiring Hackathon — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">匿名机器学习招聘黑客马拉松中的代码演练—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/code-walkthrough-in-an-anonymous-machine-learning-hiring-hackathon-part-2-17f5df32ba43?source=collection_archive---------19-----------------------#2020-11-19">https://medium.com/analytics-vidhya/code-walkthrough-in-an-anonymous-machine-learning-hiring-hackathon-part-2-17f5df32ba43?source=collection_archive---------19-----------------------#2020-11-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/c522a54777639cb9ee12aa52307341d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*qLK2rD9VNfWMIfTeSBNEMA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">所有模型的比较结果</figcaption></figure><p id="c62e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文的第1部分中，我们介绍了如何导入数据和库，预处理数据，使用CatBoost分类器模型和网格搜索来查找最佳参数，并通过最大化灵敏度和特异性之和以及最大化Roc_Auc分数来调整分类器截止值。</p><p id="d34e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一部分中，我们将重点讨论特征工程、特征选择和自动机器学习(AutoML)。</p><h2 id="53ac" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">特征工程</h2><p id="9d78" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">特征工程是ML管道中的重要步骤，因为机器学习模型只能和它的数据一样好。特征工程是通过经验、领域知识和一些尝试来学习的。我们将使用将生成列的组合或一些数学变换的技术来生成新的特征，因为它们可以在任何ML竞赛中使用，而不需要对特征进行太多的头脑风暴。</p><p id="ffd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它在数据预处理之后，但在分割数据用于模型训练之前进行。当我们从组合数据中恢复了训练和测试数据后，我们将从上一篇文章中分支出来。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ko"><img src="../Images/96665331ee9b9a57ace610c7f1024728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avcKVOyWDAGoqvSnmBW_LQ.png"/></div></div></figure><h2 id="8446" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">列的组合</h2><p id="58c6" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">大多数列是“分类”或“对象”类型，因此创建了由两列组成的要素。</p><p id="8b99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑这样一种情况，其中一列是“Office_PIN”和“Manager_Num_Products ”,那么这两列的组合将被称为“Office _ PIN _ and _ Manager _ Num _ Products ”,并且所有的值将使用“_”连接，因此将创建许多新的类别。</p><div class="kp kq kr ks fd ab cb"><figure class="kx ij ky kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/efef9a3c13077fbfbf7f4abbebb257d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*URNulx4QnSGAbHlLtWgV1Q.png"/></div></figure><figure class="kx ij ld kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/e352818559e3fb87a54c8f083d504b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*JQrAoSpbivfmqnmkTevtlQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx le di lf lg translated">列的组合</figcaption></figure></div><p id="2f06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">赔率日志</strong></p><p id="e872" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是分类问题中使用的一种技术，将分类变量转换为数字变量。数值变量可进一步用于特征工程。</p><div class="kp kq kr ks fd ab cb"><figure class="kx ij lh kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/34fcb5595becd5493e1cecd8438b39a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*4qBt4mhUu52Ugnx1w0mPBA.png"/></div></figure><figure class="kx ij li kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/bd8a475925e1239aa8d58dc7a6042ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*GuT_fDUsrCf77HCXoqx0kg.png"/></div></figure></div><p id="f086" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“column_defaultratio_cut”函数采用数据帧、要对其执行比值对数转换的列名以及目标变量，并返回字典。</p><p id="c3e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">平方、平方根和对数变换</strong></p><p id="1d58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为在执行了对数概率转换后，所有列都是数字，所以我们可以执行平方、平方根和对数转换，因为有时这些转换后的变量具有更好的预测能力。</p><div class="kp kq kr ks fd ab cb"><figure class="kx ij lj kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/df7e8b8a10d2418f4e9fa6a35ba66163.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*mqG2-1dq0lDsIrRShSyklg.png"/></div></figure><figure class="kx ij lk kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/7e600c9ed72811ef1e2acc3a65b3a6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1582/format:webp/1*2vgbCch3NGU6sOLAXduegQ.png"/></div></figure></div><p id="a25d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为有一列的最小值为负，所以平方根和对数转换可能会显示一些错误，所以建议添加一个常数值以避免错误。</p><div class="kp kq kr ks fd ab cb"><figure class="kx ij ll kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/11cb3a39bdc168b823b96993f5305cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*h-qiQSSL7nIEHS0Q-ETmJw.png"/></div></figure><figure class="kx ij lm kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/01598eb0f68674b4e9cadcfe9c7c7417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*uMgYzmus7EK_X0NTX-8REA.png"/></div></figure></div><p id="d95c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有转换都经过计算并与原始数据帧合并，并检查在此过程中创建的任何空值。</p><p id="3e0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经过这些转换后，我们的数据帧中有1768列，因此我们需要执行特征选择来选择一些最具预测能力的特征。</p><p id="c545" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">功能选择</strong></p><p id="9369" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以有许多技术来选择最佳特征。尽管如此，我还是使用了一个CatBoost分类器，并根据特性的重要性对这些特性进行了排序，并选择了这些特性，直到它们的累积和达到98%左右。这个过程重复多次，以减少变量的数量。其他技术，如使用VIF或相关，也可以用于特征选择。</p><div class="kp kq kr ks fd ab cb"><figure class="kx ij ln kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/ebad88a33785e66d62b7c2bd42347105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*irrTiGyNbdvMhTBq4JvTAg.png"/></div></figure><figure class="kx ij lo kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/6a73013c4c29e4f427b64371d3b7ab87.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*R2897QJD1I6nRAf5YA3vFQ.png"/></div></figure></div><p id="d236" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个非常耗时的过程，所以用一个循环来自动化这个过程将会非常有益。重复这个过程5-6次后，我选择了175个特征。</p><div class="kp kq kr ks fd ab cb"><figure class="kx ij lp kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/8fe1edfa2d3c65bb30b0a259ed1e02ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*lRS2ZSGXiSb8ggnudT9u7A.png"/></div></figure><figure class="kx ij lq kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/3907205d365c7d3d667c9381e6c6cb9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*kyLytOFtSLcIq2OW2cDWuA.png"/></div><figcaption class="im in et er es io ip bd b be z dx lr di ls lg translated">特征工程前后ROC_AUC的差异。</figcaption></figure></div><p id="2361" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最初，当我们没有进行临界值调整时，我们的测试ROC_AUC得分是0.51，现在已经增加到0.61。然而，在使用AutoML技术、找到最佳参数和截止调谐之后，它仍然可以增加。</p><p id="962e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">随机搜索最佳参数</strong></p><div class="kp kq kr ks fd ab cb"><figure class="kx ij lt kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/e747a24ce2f22e82e2f86f9ee8d1290d.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*pOsObMtcXBqMFHOl-JnxaA.png"/></div></figure><figure class="kx ij lu kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/f91ffc9485d1faf6a2b7207ba5d88741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*_2B9d4NZ3mg7ce491lNdLg.png"/></div></figure></div><p id="b5d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它类似于网格搜索，因为两者都使用参数范围。尽管如此，在网格搜索中，我们用整数来定义参数的范围，并且尝试所有的组合。相反，在随机搜索中，尝试由“niter”参数定义的有限数量的组合。网格搜索有效但速度慢；随机搜索速度很快，但并不总是有效。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es lv"><img src="../Images/906d4bcede4d7dfd99b319a24b90fabd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_UaXPbUzdVNb30mb3GNDw.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">随机搜索后的ROC_AUC得分</figcaption></figure><p id="b7f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">通过最大化ROC_AUC得分</strong>进行临界值调整，使用“predict_proba”函数预测训练和验证集的概率，然后尝试不同的临界值，以找到ROC_AUC最大的临界值。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es lw"><img src="../Images/b1babbc8124e22cf33d7e800e3908540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCz7Q1Gpk0szlMssQQu2Gg.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">训练和测试ROC_AUC分数</figcaption></figure><p id="5123" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用调整的截止值0.65，我们得到训练和测试ROC_AUC分数为0.74和0.66。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es lx"><img src="../Images/f94db4184c97c6bef75936f671381b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWbLTBHdCE-3pXpA8Lrupw.png"/></div></div></figure><p id="febc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，我们已经看到我们的测试ROC_AUC分数有了相当大的改进，但是我们仍然有一些东西，那就是AutoML。一些人认为AutoML会吞噬掉工作岗位，另一些人则认为它还有很长的路要走。让我们把它看作一种工具，如果它能产生好的结果，就使用它。AutoML有很多种，比如Google、AWS、Azure、H2O、AutoKeras、Auto Sklearn、TPot和Pycaret，有些是付费的，有些是开源的，但我在黑客马拉松中不使用付费工具。我发现<a class="ae ly" href="https://mljar.com/" rel="noopener ugc nofollow" target="_blank">的MLJAR </a>非常有用并且易于使用。他们有开源代码和付费网络服务。我会推荐在Google Colab上或者在虚拟环境中使用MLJAR。</p><p id="8d85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，保存我们的数据集用于Colab。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es lz"><img src="../Images/9f655a97e0aa55911537e05749e8265e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PbONdYN9bYuJMSv4ybq7sA.png"/></div></div></figure><h2 id="e8df" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak"> MLJAR </strong></h2><p id="a3a1" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我们需要的大多数库都是预装在Google Colab上的，但是我们必须安装MLJAR。使用下面的命令非常简单，安装完成后，会提示重启运行时来完成我们的安装。</p><pre class="kp kq kr ks fd ma mb mc md aw me bi"><span id="6bc7" class="jo jp hi mb b fi mf mg l mh mi">!pip install mljar-supervised</span></pre><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mj"><img src="../Images/6fbf72051c80eb7bbc83d93451e26d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJn-Hd944VqrRx7Hv5xJbQ.png"/></div></div></figure><p id="30d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将不得不导入一些库来开始。</p><pre class="kp kq kr ks fd ma mb mc md aw me bi"><span id="5a17" class="jo jp hi mb b fi mf mg l mh mi">from google.colab import drive</span><span id="0c7e" class="jo jp hi mb b fi mk mg l mh mi">drive.mount('/content/drive')</span></pre><p id="2308" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以在Colab和Google drive上上传我们的数据集，我已经使用了后者，然后我们可以使用上面的命令导入我们的驱动器。</p><p id="eb96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">成功导入驱动器后，我们可以读取数据文件。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ml"><img src="../Images/f5939381839c3f2f534bc6612f92e8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*scdly1TNiYO2jZmS8YHVLw.png"/></div></div></figure><p id="e1ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">MLJAR有许多模式，因为我们将它用于黑客马拉松/竞赛，我们将使用“竞争”模式。关于不同模式的信息可以在他们的Github库中找到。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mm"><img src="../Images/2011e9c9fb18b7d73d55d0506bd6bc41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XBzofugYLSYDjN5K2A3xyA.png"/></div></div></figure><p id="c77f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将需要一些时间，具体取决于数据集的大小。测试ROC_AUC分数有显著改善，我们将检查调整截止值是否能显示更多改善。</p><div class="kp kq kr ks fd ab cb"><figure class="kx ij mn kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/18b581a173ca8792a2246e56344e052c.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*c7ZuYLG9rTtAI3B4vswPyg.png"/></div></figure><figure class="kx ij mo kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/afbfc226dd1a11991913ad14b62673de.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*5ztADmrs3MkNIivaGDOOfg.png"/></div></figure><figure class="kx ij mp kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/63507ca05f05b057f6352c0e8cc96f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*cKiKbB6tjaV5x4OungrzTg.png"/></div></figure></div><h2 id="6e56" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">AutoML模型上的微调截止值</h2><p id="c371" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">之前用于调节临界值的两种方法都在Jupyter笔记本中执行过，结果相似，都将测试ROC_AUC分数提高了一点，达到0.693。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mq"><img src="../Images/4746a5739d0a353bac3609281b9973b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5vTOZ9ihyj73By4S1E3DQ.png"/></div></div></figure><p id="af31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结果</strong></p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es if"><img src="../Images/c522a54777639cb9ee12aa52307341d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*qLK2rD9VNfWMIfTeSBNEMA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">所有模型的比较结果</figcaption></figure><p id="dd67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这两篇文章中，我们已经从第一个模型开始构建了许多模型，在第一个模型中，我们使用了带有Catboost的网格搜索来自动进行截止微调。这次旅程向我们展示了大约30%的测试分数提高，从0.53提高到0.69。</p><h2 id="d761" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">遗言</h2><p id="cd06" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">虽然我参加了这次黑客马拉松，但还是没能取得这个好成绩。我类似地做了所有的步骤，除了特性工程，在编译这篇文章时我增加了一个步骤，这确实有所不同。所有的数据文件和Jupyter笔记本都是到Github的资源库。欢迎评论和建议。</p><div class="mr ms ez fb mt mu"><a href="https://www.linkedin.com/in/raghuvansh-tahlan/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">raghuvansh tah LAN-Guru Gobind Singh Indraprastha大学-新德里，德里，印度| LinkedIn</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">查看Raghuvansh Tahlan在世界上最大的职业社区LinkedIn上的个人资料。Raghuvansh列出了2项工作…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">www.linkedin.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ik mu"/></div></div></a></div><div class="mr ms ez fb mt mu"><a href="https://github.com/rvt123/Medium_Articles/tree/main/Code%20Walkthrough%20in%20An%20anonymous%20Machine%20Learning%20Hiring%20Hackathon" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">rvt123/Medium_Articles</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">github.com</p></div></div><div class="nd l"><div class="nj l nf ng nh nd ni ik mu"/></div></div></a></div></div></div>    
</body>
</html>