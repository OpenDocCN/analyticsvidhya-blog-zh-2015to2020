# 调查快速排序分区

> 原文：<https://medium.com/analytics-vidhya/investigating-quick-sort-partitioning-c70b4240cf4b?source=collection_archive---------8----------------------->

过去有几次，我与我的朋友和同事讨论解决问题和准备面试的问题。他们中的许多人认为标准算法和问题是他们学过的东西，过一段时间就会忘记。这在某种程度上是对的，但不完全对。这通常发生在概念没有被正确地内化到我们的系统中的时候。一旦我们学会了一种算法，它就应该成为我们作为软件工程师必备工具的一部分。它应该成为我们思考过程的一部分。这篇文章只是试图创造这种心态。

![](img/3ee07d13318515e88f35e148af73feb3.png)

穆里洛·维维亚尼在 Unsplash 上拍摄的照片

通常，当大多数人开始为面试做准备时，他们开始寻找各种排序算法，并试图记住这些步骤。这篇文章的目的是在你的脑海中建立一个快速排序的印象，这样这个算法就成为解决相关问题的一种方式，而不仅仅是一个面试问题。我们将关注快速排序所采用的方法，以及如何利用它来解决其他问题。

那么，quicksort 背后的核心思想是什么？如果给我一个 5 个元素的数组[3，1，4，5，2]，quicksort 将选择 1 个 *pivot* 元素，并将所有小于它的元素放在一边，所有大于它的元素放在另一边。在这种情况下，如果我们选择 2 作为*支点*。

第一步是，[1， **2** ，4，5，3]。这里，所有大于 2 的元素都在右侧，小于 2 的元素在左侧。这个过程叫做**分区**。

quicksort 有两个关键思想: **Pivot** 和 **Partitioning** 。

## **分区**

分区指的是这样一个步骤，我们在逻辑上将一个线性数据结构分成两个部分，这样一个部分的所有元素都少于中枢，而另一个部分的所有元素都多于中枢。

我们现在剩下的问题是，*我们如何划分？*我们将采用一个简单的选择支点的逻辑。*现在，选择最后一个元素*。就像现实世界中的分区一样，我们的分区也会创建一个边界。现在，我们需要找到在数组中创建逻辑边界的方法。为了比较一个元素是否小于所选的支点，我们需要遍历数组。所以我们知道***数组的比较和迭代是划分逻辑的两个关键步骤。***

假设我们有一个数组[1，2，3，4，5]，为了在数组中建立边界，我们需要有一个变量 *bound* ，它将跟踪小于轴心的元素的索引。这样我们可以将 pivot 放在它的旁边，所有其他元素都可以跟随。

> *结果结构应该是[e1，e2，e3，(绑定/透视)，e4，e5，e6…..]其中，e1，e2，e3 <枢轴< e4，e5，e6。*

*我们通过比较和扩展边界来不断迭代*

**1 < 5 是真的吗？**绑定++，索引++；**2<5 是真的吗？**绑定++，索引++； **3 < 5 是真的吗？** bound++，index++，我们会到达终点。边界是正确的。5 是最大的元素，小于它的所有元素都在左边。没什么可做的。但是当数组是这样的*【1，2，3，7，4，5】*会怎么样呢。让我们试着重复同样的过程。

**1 < 5 是真的吗？**绑定++，索引++；**2<5 是真的吗？**绑定++，索引++； **3 < 5 是真的吗？**绑定++，索引++；

**7 < 5 是真的吗？** *不！*！我们不能增加界限，因为界限表示小于轴心的元素的结尾。那我们现在怎么办？就像现实生活中一样，我们将继续迭代，现在跳过增加界限，这样，如果我们在将来找到比 pivot 小的其他元素，我们将把 *7* 与该元素交换，并将*增加界限 1* 。所以较小的元素来到这里，较大的元素被扔掉。

> 关键是每当我们看到一个比支点大的元素时，我们就冻结在那里，等待一个比支点小的元素，当我们遇到它时，我们就进行交换。如果我们没有遇到任何更小的元素，那么我们也可以安全地将其与 pivot 交换，因为它大于 pivot。

那么，再问一次， **7 < 5 是真的吗？**不，所以 index++的界限保持不变。**4<5**T32 是真的吗？ *是*，所以*交换 7 和 4* 的位置，bounds++，index++。

一旦迭代完成，我们将拥有指向分区的边界。然后，我们将 T38 交换支点和数组[bound]的位置。所以 pivot 将在它正确的位置结束，数组将被分区。

```
public int partition(int[] array) {
    int pivot = array[array.length-1];
    int bound = 0; // tracks the boundary
    for(int index = 0 ; index<array.length-1 ; index++) {
        if(array[index] < pivot) {
            swap(array,bound,index); // If bound == index, we can skips swaps also. Not doing it for simplicity.
            bound++;
        }
    }
    swap(array,bound,array.length-1);
    return bound;
}
```

上面的代码片段以 partition an *array[ 0，length -1]* 的最后一个元素作为支点。在快速排序中，从逻辑上将整个数组分成多个小的子数组，并重复这种划分。每次分区完成后，pivot 都会回到正确的位置。 ***那我们怎么分阵呢？*** *我们通过标记给定数组的高低索引来实现。* [( *1，2，3)* ，( *4，5)*——我们可以通过让 *lowIndex = 0，highIndex = 2 :: lowIndex = 3，highIndex = 4，把这个分成 2 个数组。*

我们必须修改上面的代码片段来接受 low 和 high，而不是使用 0 和 len-1 作为界限。这样我们就可以传递高低值，这些值代表逻辑需要运行的数组中的一个片或子数组。

[1，2，3，4，5] —我们可以通过让 *lowIndex = 0，highIndex = 2 :: lowIndex = 3，highIndex = 4，将它分成 2 个数组。我们必须修改上面的代码片段以接受 low 和 high，而不是使用 0 和 len-1 作为界限。*

```
// Modified partitioning logic
public int partition(int[] array,int low, int high) {
    int pivot = array[high];
    int i = low;  // Keeps track of index at which we add an element less        than pivot.
    for(int j = low ; j<high ; j++) {
        if(array[j] < pivot) {
            swap(array,i,j);
            i++;
        }
    }
    swap(array,i,high);
    return i; // returns the index at which partition happened or correct pivot position.

}
```

分区是这类工作中的重中之重。实际的排序只是重复的划分。

## 结论:

> 根据 wiki 的说法，“一个**就地**算法是一种使用具有少量、恒定额外存储空间的数据结构来转换输入的算法。”

我们用索引来划分整个数组，对同一个数组进行操作，不使用任何辅助空间来进行排序，所以快速排序是一种 ***原地*** 排序。就地排序不使用任何额外的数据结构来完成排序。

> 如果具有相同键的两个对象在**排序的**输出中出现的顺序与它们在输入数组中出现的顺序相同，则称**排序**算法是**稳定的**。

交换不包括交换前元素的相对位置。这对于保持相等元素的初始顺序很重要。这对原语来说并不重要，因为它们没有自己的身份。例如，[1，1，1，1]，如果我们以任何顺序排列 1，它们都是相同的，但是[ Integer(1)，Integer(1)，Integer(1) ]，它们都是独立的标识，保持这些元素在后排序结构中的顺序很重要。所以，快速排序是**不稳定的。**

快速排序是 ***高速缓存高效*** *t* 因为数据是在一个数组中线性访问的，如果数组适合高速缓存，那么它将需要在主内存行上较少的等待。在计算机方面，它被称为 ***引用局部性*** ，合并排序也将具有不错的引用局部性，但其代价是为辅助数组增加额外的内存并对其进行访问。

> **快速概念**:与高速缓存(经济上很贵，但是非常快)相比，从主存储器中读取是很昂贵的(耗时但是经济上很便宜)。主存储器被分成块，这些块作为一个整体由数据总线读取。它们读取该块中的所有内容，并将其放入缓存。现在，当您的阵列被连续读取时，整个阵列都有可能被放入缓存中，因此避免了从主 m/m 读取。

我们看到 quicksort 对 m/m 的需求较少，但是我们仍然会发现，现实生活中的大多数排序都是使用合并排序或合并排序的一些修改版本来完成的，为什么呢？

1.  对于病理输入，O(N log N)的平均性能退化为 O(N ) 。但是合并排序的最坏情况是 O(NlogN)。
2.  *快速分拣不稳定*。在现实生活中，我们并不总是对原始整数进行操作。例如，我有一个电子邮件页面，需要得到排序 wrt 到日期，在日期排序列表中，我必须按字母顺序显示电子邮件排序 wrt 到发件人的邮件 id。在这里使用快速排序可能不会保留在排序工作日期后创建的原始顺序。即使在 JDK，我们如果看到源代码，Arrays.sort()对原语使用快速排序，对对象使用修改的合并排序。
3.  通过考虑对象的身份可以使快速排序变得稳定，但是它需要 O(n)额外的空间以及递归调用堆栈内存。在这种情况下，可以使用合并排序，因为它在默认情况下是稳定的，并且比稳定的快速排序更简单。

> 但是，如果我们在面试中解决一个基于 int 数组的问题，quicksort 比 merge sort 更好。

*划分逻辑可以帮助我们以一种高效的方式解决很多问题，例如:给我们一组正数和负数，我们必须将所有负数放在一边，而将正数放在另一边。我们可以以 0 为中心进行分区，我们将在线性时间解决方案中完成。或者与将某组数字移到数组的开头或结尾有关的问题，等等。*

## 对时间和空间复杂性的简单化分析；

当我们进行分区时，这是一个线性操作，因为我们必须迭代到数组片段的末尾，所以顺序是 O(n)简单。但是我们要做多少次呢？答案是我们把数组分成两半的次数，大概是 log2n 的数量级。所以，简单来说，在 avg 的情况下，顺序是 O(N log N)。

我们将在另一篇文章中讨论 ***中枢以及它如何影响运行时性能*** 。如果你喜欢你所读到的，请鼓掌！50 是极限。

![](img/a403071de72f5016c09579dd05ae2de9.png)

干杯！