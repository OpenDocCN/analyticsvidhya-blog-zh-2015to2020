<html>
<head>
<title>Recursion vs explicit stacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归与显式堆栈</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/recursion-vs-explicit-stacks-44d9bd14cb0a?source=collection_archive---------3-----------------------#2020-03-08">https://medium.com/analytics-vidhya/recursion-vs-explicit-stacks-44d9bd14cb0a?source=collection_archive---------3-----------------------#2020-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9837" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前几天，我试图解决一个与树数据结构相关的问题。通常，大多数与树/图相关的问题的解决方案本质上都是递归的。</p><p id="c127" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">递归涉及到隐式堆栈的使用。这是由用来编译代码的编译器在后台实现的。</p><p id="8046" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个由编译器创建的后台栈被称为一个'<a class="ae jd" href="https://en.wikipedia.org/wiki/Call_stack" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">调用栈</strong> </a> <strong class="ih hj">'。</strong>维基百科将调用栈定义为<a class="ae jd" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">栈</a> <a class="ae jd" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>，它存储关于<a class="ae jd" href="https://en.wikipedia.org/wiki/Computer_program" rel="noopener ugc nofollow" target="_blank">计算机程序</a>的活动<a class="ae jd" href="https://en.wikipedia.org/wiki/Subroutine" rel="noopener ugc nofollow" target="_blank">子例程</a>的信息。它还有其他名称，如运行时堆栈，但这是最常见的名称。</p><p id="7cce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个函数/子程序调用都使用调用堆栈内的一个框架，称为<strong class="ih hj">堆栈框架</strong>。当一个函数返回值时，它的堆栈框架被弹出调用堆栈。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/94973d124b6e0d9c18e32f63a4d12f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aPCs0hP0Q-s4fkCJ.jpg"/></div></div></figure><p id="fa4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这让我想到，如果我实现自己的显式堆栈来解决问题，而不是使用递归来完成任务，会怎么样？有哪些权衡？</p><h1 id="baad" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">堆栈溢出</h1><p id="a5c7" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这两个堆栈的根本区别在于，编译器为程序调用堆栈分配的空间是固定的。这意味着，如果你不确定递归函数调用的最大次数，就会出现堆栈溢出，而且在给定的时间点，调用的次数远远超过分配给堆栈的空间所能处理的。</p><p id="96d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，如果你定义了一个显式堆栈，它是在运行时编译器分配给程序的<strong class="ih hj">堆</strong>空间上实现的。您猜怎么着，堆大小不是固定的，可以在运行时根据需要动态增加。您实际上不必担心显式堆栈溢出。这对于可伸缩性和管理存在深度递归调用的不可避免的极端情况是有益的。</p><h1 id="9311" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">空间和时间</h1><p id="c8f5" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">对于给定的情况，哪一个会更快？</p><p id="acde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在不支持递归相关优化(如针对尾部递归的尾部调用优化)的语言中，在显式堆栈上迭代可能比递归更快。</p><p id="c2b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是全部递归？</p><p id="f8c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尾递归是递归的一种特殊情况，其中递归函数在递归函数调用后不再进行任何计算，即函数的最后一步是对递归函数的调用。</p><p id="3546" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是<strong class="ih hj">尾音优化(TCO) </strong>？</p><p id="eecb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尾调用优化是您能够避免为函数分配新的堆栈帧的地方，因为调用函数将简单地返回它从被调用函数获得的值。</p><p id="8821" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，支持尾部调用优化的编译器/语言在调用栈中只使用一个<strong class="ih hj">栈帧</strong>来实现对递归函数的调用。如果你的编译器/语言不支持这一点，那么使用显式堆栈将会节省你大量的空间和时间。</p><p id="453b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python不支持尾部调用优化。这样做的主要原因是为了有一个完整而清晰的堆栈跟踪，从而实现高效的调试。</p><p id="49f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几乎所有的C/C++编译器都支持尾部调用优化。</p><h1 id="bbbe" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">直觉</h1><p id="25bc" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">对于一些人来说，很难理解递归解决方案。它只是不符合认知。当使用多个参数时，有时显式控制堆栈有助于简化事情。</p><p id="c653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，递归解决方案使源代码的大小变得更小，更易于维护。</p><h1 id="671c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="89d8" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">最后，没有固定的答案。对于特定的场景，需要考虑许多因素，例如可伸缩性、代码可维护性、使用的语言/编译器等。</p><p id="d65d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最好的方法是使用这两种方法实现解决方案，在将它部署到生产环境之前，对输入集上的两个解决方案进行计时，并分析峰值空间利用率。</p></div></div>    
</body>
</html>