<html>
<head>
<title>Using custom libraries in Azure ML — Python (Two Methods)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Azure ML-Python中使用定制库(两种方法)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/using-custom-libraries-in-azure-ml-python-28e784c41035?source=collection_archive---------5-----------------------#2020-04-28">https://medium.com/analytics-vidhya/using-custom-libraries-in-azure-ml-python-28e784c41035?source=collection_archive---------5-----------------------#2020-04-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0b87e24befe29e0076ad1a1b2821419c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ik0DWXEihnQ195CyZ2twSA.png"/></div></div></figure><div class=""/><p id="511e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Azure ML是一个非常棒的服务，可以快速有效地训练、测试和部署ML模型。您可以从一系列可用模型中进行选择，并对您的数据进行特征工程，以充分利用ML管道。</p><p id="6b1b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有时，您可能希望使用自定义python脚本来处理数据。我使用自定义脚本进行预处理和后处理。弄清楚如何上传ML studio上没有的自定义库是一件痛苦的事情，所以我写了这篇指南来帮助你。</p><blockquote class="jo jp jq"><p id="c354" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">“你应该包括azure ml可能很好，但他们在文档方面很糟糕”</p><p id="4f6a" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">—同事看完这个。</p></blockquote></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="7b24" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">1)(方法一)下载python。whl套件</h1><p id="b5ed" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">如果你像我一样是个新手，whl文件基本上是一个zip文件，其中包含当你用python正常安装时pip会自动下载并安装的库文件。</p><p id="0081" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步是获取。您想要的库或包的whl pkg。这可以通过这个简单的命令来完成。注意我们想要的lirary是fuzzywuzzy 0.17，它用于NLP中的模糊字符串匹配。在bash的新文件夹中运行命令:</p><blockquote class="jo jp jq"><p id="76e9" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="ht"> pip下载-d . fuzzywuzzy==0.17 </em></p></blockquote><ul class=""><li id="f382" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated">pip = Python包安装程序</li><li id="4179" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">-d =保存到此目录</li><li id="77d3" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">版本=您可以指定您想要的版本。</li></ul><p id="2570" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经下载了whl，它看起来像这样:</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es lt"><img src="../Images/31decf7d3a72517d8b5669224698399f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*Xz_V0iX5jWtdApcDx6Jzww.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">已下载。来自pip的whl包</figcaption></figure><p id="2a13" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还需要这个文件的依赖关系。为了检查依赖性，我在pip上找到了一个名为<em class="jr"> pkginfo的定制库。</em></p><blockquote class="jo jp jq"><p id="e7c2" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">pip安装pkginfo</p></blockquote><p id="0efc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们可以在python shell中运行以下命令:</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="b7d7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如图所示，我们需要另一个名为“python-levenshtein (≥0.12)”的依赖项，所以让我们将它下载到同一个文件夹中:</p><blockquote class="jo jp jq"><p id="c86b" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="ht"> pip下载-d . python-levenshtein==0.12 </em></p></blockquote><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es me"><img src="../Images/d63e8d3f52785cbfb79c051a6fd46717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*CspkMt70jRK-lPzBR7WBhg.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">原始库的依赖项</figcaption></figure><p id="10ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以看到我们还获得了setuptools库。让我们看看这个whl是否有必要。</p><h1 id="9e0a" class="kc kd ht bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">2)提取必要的文件和侦探工作</h1><p id="483a" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们实际上并不需要包含在。whl文件。如果我们使用winzip或7zip提取whl，我们会看到一些包包含额外的dist-info文件夹或我们不需要的文件。</p><p id="f8a1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们只需要包含基本文件的文件夹:</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es mk"><img src="../Images/791948ae3a031389c8f3cb80dae571eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*CR3ZycsoW_sLIN4r9M4FlQ.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">我们不需要额外的dist-info文件夹</figcaption></figure><p id="0725" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">FuzzyWuzzy附带了一个同名的文件夹，其中包含了我们想要的功能，还有一个*dist-info文件夹，这个文件夹并没有被使用。</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es ml"><img src="../Images/6e089bb4663715010c7579be5bb091b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*lumNdW0akcWwtxIhTn2RMA.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">模糊文件夹</figcaption></figure><p id="ed46" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了确定我们实际需要的依赖项，让我们研究一下每个fuzzywuzzy文件的文件导入。</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="mc md l"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">fuzzy __init__。巴拉圭</figcaption></figure><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="mc md l"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">fuzzy fuzz.py</figcaption></figure><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="mc md l"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">模糊字符串匹配器. py</figcaption></figure><p id="ab1b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们找到了依赖！我们可以看到，在StringMatcher.py中，我们需要Levenshtein导入，因此让我们再次使用winzip提取它。</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es mm"><img src="../Images/d7a6b3268d188efb7b881157c61b548e.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*w8CQNeP0vO26X5tv_RXshQ.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">python Levenshtein依赖性提取</figcaption></figure><p id="40c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以在这里看到提取的Levenshtein文件夹，还有一个setup.py文件。setup.py使用setuptools，这就是为什么。我们运行pip下载时包括了whl。如果我们检查莱文斯坦的文件夹并调查。我们可以看到它们不依赖于任何其他文件。</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="13fd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以现在我们可以走了！让我们创建一个<strong class="is hu">新文件夹</strong>，其中只有我们需要的“<em class="jr">基本</em>文件。这些文件夹仅与以下名称的文件夹相同:</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es mn"><img src="../Images/4e82c56da4d57b8948b3d165e3f8ba93.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*z7aLlWmiVLPUAz60UbVYIA.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">最需要的文件夹</figcaption></figure><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es mo"><img src="../Images/2cc49647b81a545c68e79aecbe3fcb38.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*jrh197OkYSwoYXuyLnAupA.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">树内容(cmd中的树/ f)</figcaption></figure><h1 id="0ee6" class="kc kd ht bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">3)压缩文件夹并发送到Azure ML</h1><p id="3fab" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">让我们压缩文件夹并上传到数据集下的Azure ML。这使得我们可以在管道中使用它。确保打开后的压缩文件中包含这两个文件夹。不需要父文件夹。</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mp"><img src="../Images/7f32389bf3d0f9618703cf4fb3ad711e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FH5DbIDP0ZjdBi331ADMhA.png"/></div></div></figure><p id="4bf2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意数据集是如何连接的。这是执行Python脚本选项的第三次导入。</p><p id="b96b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在执行Python脚本中，确保导入了所需的函数。这将自动搜索zip中的依赖项。</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="mc md l"/></div></figure><h1 id="475b" class="kc kd ht bd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz bi translated">4)检查日志输出以验证其工作</h1><p id="2cc0" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">导入的库现在可以工作了，你可以在ML studio中使用它的功能了！</p><p id="d414" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我这样做是因为我认为在文档中找不到任何有意义的帮助，我用这个<a class="ae mq" href="https://stackoverflow.com/questions/44371692/install-python-packages-in-azure-ml" rel="noopener ugc nofollow" target="_blank">堆栈溢出帖子</a>来指导。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="4ad3" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">1)(方法二)使用虚拟环境进行更新</h1><p id="5baa" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">写完这个指南后我学到的一个新方法就是简单地创建一个新的空的虚拟环境。Python虚拟环境是一个小空间，它使用自己的python解释器，并保持其库与实际系统分离。这用于为不同的项目保持特定版本的库分离。</p><p id="de27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虚拟环境的结构将已安装的包保存在env/Lib/site-packages文件夹中。这是从pip(使用虚拟环境python)安装的库被保存的地方。我们可以将该文件夹中的内容压缩并发送到Azure ML。</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es mr"><img src="../Images/feeb96812bf94f4f34cad832333111c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*m6sj15jL_Yn0ep8L7KottQ.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">环境/库/站点包的内容</figcaption></figure><p id="5b23" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只需在该级别上压缩并发送到Azure ML！这一次我们可以包含文件夹中的所有内容。只要记住基本的包，比如pandas或numpy，已经在Azure ML上了，所以没有必要在venv中再次安装它们。</p><p id="dad0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">按如下方式导入库:</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="243f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>