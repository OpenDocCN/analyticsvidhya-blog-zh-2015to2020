<html>
<head>
<title>Simulation Optimization — Operational Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模拟优化—操作方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-list-of-operational-methods-in-simulation-optimization-324ca5016f9c?source=collection_archive---------21-----------------------#2020-04-02">https://medium.com/analytics-vidhya/a-list-of-operational-methods-in-simulation-optimization-324ca5016f9c?source=collection_archive---------21-----------------------#2020-04-02</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><figure class="hi hj fa fc hk hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et hh"><img src="../Images/e00393772685b84da8d47092fea2d86e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7BDLPM0o9kKL694XddMzIw.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="ff91" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji dy translated">在<strong class="ak"> C++ </strong>和<strong class="ak"> Python中包含了一系列科学代码，用于性能优化和代码演示</strong></h2></div><h1 id="91e0" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated"><strong class="ak">简介</strong></h1><p id="3e0a" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">本文包含从各种来源收集的代码样本，如使用数值和随机优化方法的英特尔MKL和SceneNet深度学习框架。这里介绍的C++代码库使用了示例代码，这些代码可以使用OpenMP (OMP)或OpenMPI (MPI)进行性能增强。</p><h2 id="cd07" class="kx jk hu bd jl ky kz la jp lb lc ld jt kk le lf jv ko lg lh jx ks li lj jz lk bi translated"><strong class="ak">使用OMP运行代码的说明:</strong></h2><p id="f86e" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">该存储库是为在OMP执行而构建的，以利用并行化和矢量化技术。</p><pre class="ll lm ln lo fe lp lq lr ls aw lt bi"><span id="42b9" class="kx jk hu lq b fj lu lv l lw lx"><strong class="lq hv">cmake .. &amp;&amp; make all </strong></span><span id="4758" class="kx jk hu lq b fj ly lv l lw lx"><strong class="lq hv">./app --intervals 4 --iterations 8 --condition_factor 2 --multiplier 1000000</strong></span></pre><p id="55d6" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">首先，您需要通过以下方式在Linux中安装cmake:</p><pre class="ll lm ln lo fe lp lq lr ls aw lt bi"><span id="d670" class="kx jk hu lq b fj lu lv l lw lx"><strong class="lq hv">sudo apt-get install cmake</strong></span></pre><p id="0416" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">或者获取docker存储库:</p><pre class="ll lm ln lo fe lp lq lr ls aw lt bi"><span id="7ceb" class="kx jk hu lq b fj lu lv l lw lx"><strong class="lq hv"><em class="me">git clone </em></strong><a class="ae mf" href="https://github.com/aswinvk28/cpp-performance-math-problems" rel="noopener ugc nofollow" target="_blank"><strong class="lq hv"><em class="me">https://github.com/aswinvk28/cpp-performance-math-problems </em></strong></a><strong class="lq hv"><em class="me">cpp_math_problems</em></strong></span><span id="227f" class="kx jk hu lq b fj ly lv l lw lx"><strong class="lq hv"><em class="me">git checkout </em>navier-stokes-autodiff</strong></span></pre><h2 id="6b77" class="kx jk hu bd jl ky kz la jp lb lc ld jt kk le lf jv ko lg lh jx ks li lj jz lk bi translated">使用MPI运行代码的说明:</h2><p id="d49c" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">请修改存储库中的代码，以MPI编程方法执行代码。然后使用mpiexec执行命令行应用程序。为了执行命令行应用程序，您需要执行存储库中给出的shell脚本。</p><blockquote class="mg"><p id="c650" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated"><code class="dv mq mr ms lq b">./run_project.sh</code></p></blockquote><pre class="mt mu mv mw mx lp lq lr ls aw lt bi"><span id="1477" class="kx jk hu lq b fj lu lv l lw lx"><strong class="lq hv">mpiexec -n 4 ./app --intervals 4 --iterations 8 --condition_factor 2 --multiplier 1000000</strong></span></pre><ol class=""><li id="8885" class="my mz hu kd b ke lz kh ma kk na ko nb ks nc kw nd ne nf ng bi translated"><em class="me">你需要创建一个实现函数</em></li></ol><pre class="ll lm ln lo fe lp lq lr ls aw lt bi"><span id="2686" class="kx jk hu lq b fj lu lv l lw lx"><strong class="lq hv">double * navier_stokes(double * u2, double u0, const double dt, const double dx, const double p, const double alpha, int length, double * model)</strong></span></pre><p id="3531" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated"><em class="me"> 2。对照参考实现功能</em></p><pre class="ll lm ln lo fe lp lq lr ls aw lt bi"><span id="2c41" class="kx jk hu lq b fj lu lv l lw lx"><strong class="lq hv">double * navier_stokes_ref(double * u1, double u0, const double dt, const double dx, const double p, const double alpha, int length, double * model)</strong></span></pre><p id="cba4" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">实现函数在给定向量值的每个间隔执行，类似于参考实现。参考实现与手写模型进行了比较。</p><p id="18af" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di">我</span> <strong class="kd hv">初始假设:</strong></p><blockquote class="nq nr ns"><p id="3277" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated"><em class="hu">线性估计模型的组合方程为:</em></p></blockquote><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et nw"><img src="../Images/bbb62b91bc870e0ab53a46eb3ae4ece6.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*L1J4tc-p3PfQUyUOQQnfRA.png"/></div></figure><p id="8404" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">线性阻尼因子被应用于满足我们的估计模型的每个单元向量的原始单元。这意味着我们的假设，即估计模型观察到的每细胞单位满足。</p><p id="0471" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di">P</span>T21】初步分析:</p><p id="c09b" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">在初步分析中，我们采用了一种宏观方法，这种方法使我们得到了每个单元的最佳曲线。我们需要根据一个幂级数公式来表示该函数，该公式由下面的问题表示:</p><p id="8899" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">在幂级数方程中，精度得分是多项式回归中的均方误差，使用从原始数据点到预测曲线的误差向量来测量。在支持向量机(SVM)中，它们要么是功能边界，要么是几何边界。因为我们假设色散关系中的每个点都将质量传递给另一个点，所以流函数和解析复变量将解决我们的问题。我们可以在幂级数方程中选择相位，表示为:</p><blockquote class="nq nr ns"><p id="f76f" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated"><strong class="kd hv"><em class="hu">a</em>₀+<em class="hu">a</em>₁cos(<em class="hu">θ</em>)+<em class="hu">a</em>₂cos(2<em class="hu">θ</em>)+<em class="hu">a</em>₃cos(3<em class="hu">θ</em>)+<em class="hu">a</em>₄cos(4<em class="hu">θ【t18)+<em class="hu">a</em>₅cos(5<em class="hu">θ</em>)+……</em></strong></p></blockquote><p id="8313" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated"><strong class="kd hv"> <em class="me">衍生:——</em></strong></p><blockquote class="nq nr ns"><p id="e6c2" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated"><strong class="kd hv"> <em class="hu"> A </em> ₀ + - <em class="hu"> A </em> ₁辛(<em class="hu"> θ </em> ) + -2 * <em class="hu"> A </em> ₂辛(2 <em class="hu"> θ </em> ) + -3 * <em class="hu"> A </em> ₃辛(3 <em class="hu"> θ </em> ) + -4 * <em class="hu"> A </em> ₄辛(4 <em class="hu"> θ </em> ) + -5 * <em class="hu"/></strong></p></blockquote><p id="1743" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">这将使我们的函数在每个方向上进行分析，并创建一个像SVM这样的分类器可以预测的流函数。存在另一组幂级数系数，其代表具有相移的幂级数系数。</p><blockquote class="nq nr ns"><p id="2416" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated"><strong class="kd hv"> B₀ + B₁辛(<em class="hu"> θ </em> ) + B₂辛(2 <em class="hu"> θ </em> ) + B₃辛(3 <em class="hu"> θ </em> ) + B₄辛(4 <em class="hu"> θ </em> ) + B₅辛(5 <em class="hu"> θ </em> ) + … </strong></p></blockquote><p id="c19e" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated"><strong class="kd hv"> <em class="me">衍生:——</em></strong></p><blockquote class="nq nr ns"><p id="24fe" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated"><strong class="kd hv">b₀+b₁cos(<em class="hu">θ</em>)+2 *b₂cos(2<em class="hu">θ</em>)+3 *b₃cos(3<em class="hu">θ</em>)+4 *b₄cos(4<em class="hu">θ</em>)+5 *b₅cos(5<em class="hu">θ</em>)+…</strong></p></blockquote><p id="31d0" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">让我们将我们的<em class="me">流程模型</em>表示为:</p><blockquote class="mg"><p id="2472" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated">f(x，t) : <strong class="ak">状态空间模型</strong></p></blockquote><p id="b04d" class="pw-post-body-paragraph kb kc hu kd b ke nx iv kg kh ny iy kj kk nz km kn ko oa kq kr ks ob ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> C </span> <strong class="kd hv"> ost功能:</strong></p><figure class="ll lm ln lo fe hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et oc"><img src="../Images/58c291cf8dfb4255614d122bf6a9bb45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqudqyJ8YBOfx2Bfg5F0fA.png"/></div></div></figure><p id="2849" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">当您对“<em class="me">参考执行功能”</em>执行梯度下降时，分析上下文被设置为离散。间隔的大小各不相同，这产生了模型一致性检查</p><blockquote class="nq nr ns"><p id="df7d" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated"><strong class="kd hv">因此，我们得到的系数将是一个傅立叶变换，事实上，它是一个时域的逆STFT(逆短时傅立叶变换)。</strong></p></blockquote><p id="1bbc" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">可以执行STFT的流行python包有:</p><ul class=""><li id="f375" class="my mz hu kd b ke lz kh ma kk na ko nb ks nc kw od ne nf ng bi translated">numpy</li><li id="5029" class="my mz hu kd b ke oe kh of kk og ko oh ks oi kw od ne nf ng bi translated">利布罗萨</li><li id="a59b" class="my mz hu kd b ke oe kh of kk og ko oh ks oi kw od ne nf ng bi translated">scipy</li><li id="55ce" class="my mz hu kd b ke oe kh of kk og ko oh ks oi kw od ne nf ng bi translated">张量流</li></ul><p id="caec" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">其他可以执行STFT的软件包有:</p><div class="hi hj fa fc hk oj"><a href="https://uk.mathworks.com/help/signal/ref/stft.html" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dx"><div class="ol ab om cl cj on"><h2 class="bd hv fj z dz oo eb ec op ee eg ht bi translated">stft</h2><div class="oq l"><h3 class="bd b fj z dz oo eb ec op ee eg dy translated">短时傅立叶变换崩溃都产生两秒钟的压控振荡器输出，由…</h3></div><div class="or l"><p class="bd b fq z dz oo eb ec op ee eg dy translated">uk.mathworks.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox hq oj"/></div></div></a></div></div><div class="ab cl oy oz gq pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="hc hd he hf hg"><p id="f5cb" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">这篇来自英特尔的文章解释了使用C++编译器 的浮点运算的<a class="ae mf" href="https://software.intel.com/en-us/articles/consistency-of-floating-point-results-using-the-intel-compiler" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hv">一致性。所有GPU和操作系统的浮点精度必须一致。为了保持一致性，加法和乘法的属性必须遵循关联原则，并且浮点数可以被序列化以在各种线程和向量单元(VU)下执行。这里演示的问题展示了OMP (OpenMP)和OpenMPI在计算模型评估中的应用。练习中选用的计算模型是C++和Python语言。出现的问题有:</strong></a></p><blockquote class="mg"><p id="f88e" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated">-蒙特卡罗扩散作为色散关系，</p><p id="97a6" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated">-格子波尔兹曼方法，</p><p id="3da7" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated">-实验设计和</p><p id="c107" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated">-复杂分析。</p></blockquote></div><div class="ab cl oy oz gq pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="hc hd he hf hg"><h1 id="5563" class="jj jk hu bd jl jm pf jo jp jq pg js jt ja ph jb jv jd pi je jx jg pj jh jz ka bi translated"><strong class="ak"> <em class="pk">给定参数执行代码得到的结果:</em> </strong></h1><p id="24cf" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">模式1:当量化因子被设置为默认分数时</p><pre class="ll lm ln lo fe lp lq lr ls aw lt bi"><span id="31ff" class="kx jk hu lq b fj lu lv l lw lx"><strong class="lq hv">qf = ( MAX. ESTIMATED VALUE ) * 2 / 3</strong></span></pre><p id="bde3" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> Y </span> <strong class="kd hv"> <em class="me">您可以调整Max。作为力项的模型估计值，并根据最大值的选定分数评估异常值。估计值。</em>T13】</strong></p><pre class="ll lm ln lo fe lp lq lr ls aw lt bi"><span id="6a64" class="kx jk hu lq b fj lu lv l lw lx"><strong class="lq hv"><em class="me">./app \<br/>--intervals 4 \<br/>--iterations 8 \<br/>--condition_factor 2 \<br/>--multiplier 1</em></strong></span></pre><figure class="ll lm ln lo fe hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et pl"><img src="../Images/d1730a009862a14df87fc0f406942048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9vnBp1JC2m-RyuUEFwkB6Q.png"/></div></div><figcaption class="pm pn eu es et po pp bd b be z dy translated"><strong class="bd jl">一致性、可靠性、残差、精度</strong></figcaption></figure><h2 id="9b4a" class="kx jk hu bd jl ky kz la jp lb lc ld jt kk le lf jv ko lg lh jx ks li lj jz lk bi translated">代码示例</h2><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="pq pr l"/></div></figure></div><div class="ab cl oy oz gq pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="hc hd he hf hg"><pre class="ll lm ln lo fe lp lq lr ls aw lt bi"><span id="4183" class="kx jk hu lq b fj lu lv l lw lx"><strong class="lq hv"><em class="me">./app \<br/>--intervals 3 \<br/>--iterations 7 \<br/>--condition_factor 2 \<br/>--multiplier 1 \<br/>--quantisation_factor 2e-2</em></strong></span></pre><figure class="ll lm ln lo fe hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et ps"><img src="../Images/94326b04d89df0297cb3d0d0dcc63eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ub2j9IHcHks8WRm8_tmooA.png"/></div></div><figcaption class="pm pn eu es et po pp bd b be z dy translated"><strong class="bd jl">一致性、可靠性、残差、精度</strong></figcaption></figure><p id="ff5c" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated">区间长度的变化确实改变了精确度、可靠性和一致性。在内插我们为校准的假设的每细胞单位参数时</p><blockquote class="mg"><p id="d868" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated">长度= 100</p></blockquote><p id="cf24" class="pw-post-body-paragraph kb kc hu kd b ke nx iv kg kh ny iy kj kk nz km kn ko oa kq kr ks ob ku kv kw hc bi translated"><em class="me">使用样条插值，带有控制点</em></p><blockquote class="mg"><p id="26bf" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated"><em class="pk"> α </em>和<em class="pk"> 1 - α </em></p></blockquote></div><div class="ab cl oy oz gq pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="hc hd he hf hg"><h1 id="f94d" class="jj jk hu bd jl jm pf jo jp jq pg js jt ja ph jb jv jd pi je jx jg pj jh jz ka bi translated"><em class="pk">设定目标</em></h1><p id="7ec5" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> P </span> <strong class="kd hv"> <em class="me">精度</em> </strong></p><p id="da53" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">如您所见，两种模型的精度不同，这是因为:</p><pre class="ll lm ln lo fe lp lq lr ls aw lt bi"><span id="4f1c" class="kx jk hu lq b fj lu lv l lw lx"><strong class="lq hv">--intervals 4 --iterations 8       being used in model1<br/>--intervals 3 --iterations 7       being used in model2</strong></span></pre><p id="6878" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">当进行即兴表演时，每个音程(长度分别为2⁴和2)被用作我们的计算模型。我们在每个间隔取MAE(平均绝对误差)来最终确定我们的结果。</p><p id="06b7" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di">R</span>T38<em class="me">可靠性</em>T41】</p><p id="1891" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">两种模型中的可靠性值不同，这是因为区间确实随着精度的变化而变化。可靠性被定义为N次实验失败的概率。</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et pt"><img src="../Images/64bf6e6b2a3d3f08b0dadc8738de453b.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*__29nOpKdrns8QdLEmY9Tg.png"/></div></figure><p id="fbcc" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di">R</span><strong class="kd hv"><em class="me">ESI dual</em></strong></p><p id="c0fa" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">在一段时间内，模型值会因微小的偏差而变化。用平方表示的偏差或由模型值归一化的偏差给出了该区间内模型的残差属性。</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et pu"><img src="../Images/c7fbd181f139bbfef8032ba76b77c0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:196/format:webp/1*bQC0Nfdh4jOoXcZSF59eKw.png"/></div></figure><p id="0a55" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">同样，表示为条件数，它在分子处取N范数，并乘以矩阵的逆矩阵。对于大的区间，它是一个相关的统计量，因为它提供了泰勒级数展开。</p><p id="7c55" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di">C</span><strong class="kd hv">T3】on cordT5】</strong></p><p id="084a" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">用模型的定义，力项表示:<em class="me"> ρ ( δu / δt ) </em>和力项的导数，<em class="me">V</em>(<em class="me">τ【T11)=(1<em class="me">/ρ)</em><em class="me">(δF/δx)，</em>表示区间。</em></p><p id="3e80" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">这里的一致性统计考虑了一个数值和一个复杂的参数。数值对应<strong class="kd hv"> <em class="me"> ( δx / x ) </em> </strong> <em class="me">复数arg对应</em><strong class="kd hv"><em class="me">z</em>₂<em class="me">/z</em>₁</strong>其中复数是流函数的轮廓积分和复数导数的乘积。这里取的流函数是力项。</p><p id="f99a" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> I </span> <strong class="kd hv"> <em class="me">来自统计分析的影响</em> </strong></p><p id="4365" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">区间分析是我们理解模型参数的关键，如精度、残差、条件数、可靠性模型和模型的一致性。</p><p id="5d92" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">如上面在<strong class="kd hv">“初步分析”中所讨论的，</strong>幂级数参数，<strong class="kd hv"> <em class="me"> θ，</em> </strong> <em class="me">在从‘a’到‘b’的区间上，区间长度L = ( b - a)，表示为:</em></p><blockquote class="mg"><p id="e8e4" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated"><em class="pk">θ</em>= 2<em class="pk">π</em>T46】nT48】x/L</p></blockquote><p id="9f85" class="pw-post-body-paragraph kb kc hu kd b ke nx iv kg kh ny iy kj kk nz km kn ko oa kq kr ks ob ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di">在</span> <em class="me">泰勒级数展开中，kᵗʰ导数将包含归一化参数nᵏ，因为在每个导数的间隔处具有控制点α和1 - α的样条插值将具有相同的形式:</em></p><blockquote class="mg"><p id="54ae" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated"><em class="pk">f</em>(<em class="pk">k</em>)=<em class="pk">α</em><em class="pk">f</em>ᶦ+(1<em class="pk">α</em>)<em class="pk">f</em>ᶦ⁺</p></blockquote><p id="1ab3" class="pw-post-body-paragraph kb kc hu kd b ke nx iv kg kh ny iy kj kk nz km kn ko oa kq kr ks ob ku kv kw hc bi translated">这里使用泰勒级数展开偏差，我们得到了Ramanujan的生日函数。递归的生日问题是一个人在包含N天的一年中找到另一个生日相同的人之前可以尝试的次数的解决方案。生日问题在这里给出<a class="ae mf" href="https://en.wikipedia.org/wiki/Birthday_problem" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Birthday_problem</a></p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et pv"><img src="../Images/38664d415939d023ad20f14bd8dc4992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*OztRVBFl9MePbZ8mEtLNHg.png"/></div><figcaption class="pm pn eu es et po pp bd b be z dy translated"><strong class="bd jl">用区间长度归一化的生日问题</strong></figcaption></figure><p id="c20a" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">生日问题与一组Ramanujan分布的推导相关，例如</p><ul class=""><li id="e6ce" class="my mz hu kd b ke lz kh ma kk na ko nb ks nc kw od ne nf ng bi translated"><strong class="kd hv"> Ramanujan Q分布</strong>，以及</li><li id="72e4" class="my mz hu kd b ke oe kh of kk og ko oh ks oi kw od ne nf ng bi translated"><strong class="kd hv"> Ramanujan R分布</strong></li></ul><p id="31d6" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">其实我可以说Ramanujan R分布在哪里有用。在我们的宏观问题的情况下，我们迭代区间，并发现我们的生日问题实际上可以创建记录的观察偏差的母函数，Ramanujan R-分布是置换矩阵的概率问题。</p><p id="b4c3" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">如果我们在这里利用我们的问题，其中我们假设将基于光流相位的方法应用于我们的流函数的每一个导数，则产生的数据争论阶段有两个选项:</p><p id="5d1a" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> F </span></p><p id="db0b" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">让我们在这里讨论一些强化学习，如果你有一个数据集，你需要根据可能的<a class="ae mf" href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search" rel="noopener ugc nofollow" target="_blank">蒙特卡罗树搜索</a> ( <strong class="kd hv"> MCTS </strong>)算法对数据集的发现进行评分，你可以搜索整个数据集，并根据你选择的算法或模型对数据集进行分层聚类。这样，迭代的状态空间将是巨大的。下面使用的置换矩阵将模型的输入映射到从第一因子图到第二因子图的输出。如下所述:</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et pw"><img src="../Images/9b6da8ffa25e8e62c84b0fda1d04ec5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ycUw7jNUfaQY1hYRdizQ6w.png"/></div></figure><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et px"><img src="../Images/26b0466d30ff45cb09c8c0b872c9a496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*UfZo4H9D-QWdRP8EqDUsUg.png"/></div></figure><p id="f30a" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">一旦它们被映射，可能的N×5×5的状态空间，正如我们在这里可以看到的5个因子，被减少到2×5×5。</p><p id="ed9d" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> S </span> <strong class="kd hv"> <em class="me">其次</em> </strong> <em class="me">，将系数Aₙ视为时间序列连续体的一部分，执行随机化以选择复值状态空间</em> <strong class="kd hv"> <em class="me">由</em> </strong> <em class="me">匹配k </em> <strong class="kd hv"> <em class="me">世界痕迹</em> </strong> <em class="me">成对拍摄。在这种情况下，</em> jᵗʰ <em class="me">衍生工具可以与</em> iᵗʰ衍生工具进行匹配。</p><p id="9fc1" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">在这里，<a class="ae mf" href="https://arxiv.org/pdf/1506.02335.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1506.02335.pdf,</a>的论文描述了在秩(N+k)的状态空间中匹配随机排列的多匹配算法运行，将k个元素匹配到特定的k个元素。</p><h1 id="8d87" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated">“Ramanujan R分布在这里显示了在没有两列系数重复其结构的情况下进行匹配的概率，以便通过独立考虑流函数导数来解决问题，例如置换矩阵问题。”</h1><h1 id="1685" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated">"二项式分布表示为Ramanujan Q分布和Ramanujan R分布的乘积. "</h1><blockquote class="mg"><p id="a6ba" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated">区间长度的重要性很高，因为无论是动量守恒模型、<em class="pk"> k </em> ᵗʰ导数、能量还是哈密顿力学，它都是用于这个宏观问题的相同样条插值。</p></blockquote><blockquote class="nq nr ns"><p id="b4c6" class="kb kc me kd b ke nx iv kg kh ny iy kj nt nz km kn nu oa kq kr nv ob ku kv kw hc bi translated">autodiff软件包帮助我推导导数，并且擅长向前和向后微分</p><p id="3d45" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated">@礼貌:<a class="ae mf" href="https://autodiff.github.io/" rel="noopener ugc nofollow" target="_blank">T3】https://autodiff.github.io/T5】</a></p></blockquote></div><div class="ab cl oy oz gq pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="hc hd he hf hg"><p id="01c0" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">如论文<a class="ae mf" href="https://arxiv.org/pdf/1801.06397.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1801.06397.pdf</a>中所述，使用光流方法分析数据集所获得的结果可归纳为两个方面:</p><blockquote class="mg"><p id="dc85" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated">(1) <strong class="ak">多样性</strong>，以及</p><p id="b87f" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated">②<strong class="ak">现实主义</strong>。</p></blockquote><h1 id="12e0" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja py jb jv jd pz je jx jg qa jh jz ka bi translated">正如本文所述，与基于多样化数据训练的网络相比，基于专门化数据训练的网络对其他数据集的泛化能力更差。它还指出，大多数学习任务可以通过简单的数据和数据扩充来完成。</h1><p id="71a1" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">我想在这里讨论三种作战模拟优化方法，它们展示了如何达到最优解的各种技术。</p><p id="ec2c" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di">一个</span> <em class="me">计算模型列表:</em></p><h1 id="1d4f" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated"><strong class="ak">作为弥散关系的蒙特卡罗(MC)扩散</strong></h1><p id="2c91" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">在蒙特卡罗扩散中，扩散的概率可以写成空气流入和空气流出选定点的概率之和</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qb"><img src="../Images/c9f1f8409eb98b4aca4958d9486e9b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/1*oVnUtQjNzJeMaWUN-gqfqg.png"/></div></figure><p id="2624" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> P </span> <strong class="kd hv">问题</strong> : <em class="me">给定问题是一个小时间间隔、小位移的计算模型，在一段时间内，当有一个输入速度的空气供应时</em></p><p id="7018" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">供应输入空气时，质量流量可写为:</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qc"><img src="../Images/dee38d97fee2f8d7c65165351e76a1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*2JOm33ErZHyp2exGotHi2g.png"/></div></figure><p id="6aec" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">利用这个线性方程，如果用空气动力学的动能(K.E .)向前计算，得到空间和时间之间的关系:</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qd"><img src="../Images/ce3cea6fe8d6530dd8a50edfdf3ffa3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*a4m5vYmY0R6PkHoe7zDyYQ.png"/></div><figcaption class="pm pn eu es et po pp bd b be z dy translated"><strong class="bd jl">各向同性外部压力下动量守恒的纳维尔-斯托克斯关系，无任何剪切力穿过输入速度时间序列的壁面</strong></figcaption></figure><p id="0ff7" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">我们的模型变量是:</p><ul class=""><li id="2a07" class="my mz hu kd b ke lz kh ma kk na ko nb ks nc kw od ne nf ng bi translated">每个单元格的单位数</li><li id="71f3" class="my mz hu kd b ke oe kh of kk og ko oh ks oi kw od ne nf ng bi translated">运动概率</li><li id="aa4d" class="my mz hu kd b ke oe kh of kk og ko oh ks oi kw od ne nf ng bi translated">空气密度率的无量纲常数</li><li id="08e7" class="my mz hu kd b ke oe kh of kk og ko oh ks oi kw od ne nf ng bi translated">流体速度的输入时间序列</li></ul><p id="f80c" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">在推导纳维尔-斯托克斯模型时，使用的方程有:<strong class="kd hv">菲克扩散通量</strong>和<strong class="kd hv">吉布自由能。</strong>空气密度率的无量纲参数在计算过程中假设为常数。该方程假设在每单元参数的单位和空气密度速率的无量纲常数之间存在同步性。该模型的主要缺点是，它从1到0呈线性分布，并且从不考虑单元段内分析的墙壁上的反弹或剪切应力。</p><blockquote class="nq nr ns"><p id="a217" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated">由于大的输入信号，存在粒子的分散。</p></blockquote><p id="2467" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> S </span> <em class="me">模拟优化模型:</em></p><h1 id="7a75" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated"><strong class="ak">随机优化</strong></h1><p id="080a" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">通过使用张量流库的随机梯度下降，在单位段长度内确定计算模型的参数。对于纳维尔-斯托克斯关系，这里使用了一个输入速度时间序列<strong class="kd hv"> t ^ 5 </strong>。</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et qe"><img src="../Images/be948382955e30a90d898befb03aa335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hn7cM0mFYvOm3cLoCBrPdg.png"/></div></div></figure><blockquote class="nq nr ns"><p id="d417" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated"><strong class="kd hv">如本库中所述:</strong></p></blockquote><div class="hi hj fa fc hk oj"><a href="https://github.com/aswinvk28/cpp-performance-math-problems-benchmark" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dx"><div class="ol ab om cl cj on"><h2 class="bd hv fj z dz oo eb ec op ee eg ht bi translated">aswinvk 28/CPP-性能-数学-问题-基准</h2><div class="oq l"><h3 class="bd b fj z dz oo eb ec op ee eg dy translated">这个练习的目的是用C++开发一个性能优化模型，使用基本的GNU编译器特性，例如…</h3></div><div class="or l"><p class="bd b fq z dz oo eb ec op ee eg dy translated">github.com</p></div></div><div class="os l"><div class="qf l ou ov ow os ox hq oj"/></div></div></a></div><p id="add5" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated"><strong class="kd hv">速度</strong>的计算基于:</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qg"><img src="../Images/9fb8ed3d10af7e9b51bf02f0bc1fb171.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*N4Bv-jxynO7NqrkDOsekpg.png"/></div></figure><p id="3190" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">这意味着速度从大约为的值<strong class="kd hv"> 0.2线性降低到大约为</strong>的值<strong class="kd hv"> 0.1。总有效点的长度取为100。等式中的其他参数描述如下:</strong></p><ol class=""><li id="5a8c" class="my mz hu kd b ke lz kh ma kk na ko nb ks nc kw nd ne nf ng bi translated"><em class="me">显著速度观察点</em>绘制成散点图；</li></ol><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qh"><img src="../Images/9b20d021c062e4c9197a6da6c5ad9575.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*5HI8N6Jjwkie0CBTWgchlw.png"/></div></figure><p id="1b73" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">2.初始速度是</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qi"><img src="../Images/fd73689bef6dc082f241d9428228fde1.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*Fj9MVz5myw1TFWTYC7qhFA.png"/></div></figure><p id="2f04" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">3.概率是</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qj"><img src="../Images/1864fdc0b34c917a41591ca86c3775cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*buGuYcmbbyRGdddSbkjFJw.png"/></div></figure><p id="2518" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">4.alpha值为</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qk"><img src="../Images/85fc5fc2d29bbab0e0d0e100d1991068.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/1*1UyJAh00pIJUbnEIKbzxVg.png"/></div></figure><p id="0642" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">计算模型的位移和时间参数为:</p><blockquote class="mg"><p id="6a7e" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated"><em class="pk"> dt = 1e-3 </em></p><p id="4fa9" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated"><em class="pk"> dx = 1e-6 </em></p></blockquote><blockquote class="nq nr ns"><p id="db77" class="kb kc me kd b ke nx iv kg kh ny iy kj nt nz km kn nu oa kq kr nv ob ku kv kw hc bi translated">通过校准蒙特卡罗扩散的结果，我们总是得到每个单元的体积关系的相同模式</p></blockquote><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et ql"><img src="../Images/b8cacc868d9fae85b4562375ee459e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*C6Dihkm0tVQgUAgL4qNkDw.png"/></div></figure><p id="4bd2" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> G </span> <strong class="kd hv"> <em class="me">高斯峭度解释</em> </strong></p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qm"><img src="../Images/483e3cc630d612e54954b10dd100a442.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*-LT749jldLrlILENgo_C7g.png"/></div></figure><blockquote class="nq nr ns"><p id="c0a3" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated">这是完全可以预料的，因为我们的原始模型显示了动量守恒模型的这一结果，因为原始纳维尔-斯托克斯关系的<strong class="kd hv">峰度</strong>高于计算模型的每个单元的体积关系</p></blockquote><figure class="ll lm ln lo fe hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et qn"><img src="../Images/a07e5d8d3eb67fc5beda77a5f59ca6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eabchpHbSSx4VFPGBUjKSQ.png"/></div></div></figure><blockquote class="mg"><p id="6508" class="mh mi hu bd mj mk qo qp qq qr qs kw dy translated">为了在同一时刻观察我们的有界环境中的整个空气立方体，必须确定这种模式重复自身的间隔。可以看出，由于尺寸问题，这样的间隔必然存在。我相信在指定空间的每个长方体内标定的声速为343 m/s时，显示出这样的<strong class="ak">峰度</strong>区间是可能的。</p></blockquote><p id="bfb5" class="pw-post-body-paragraph kb kc hu kd b ke nx iv kg kh ny iy kj kk nz km kn ko oa kq kr ks ob ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di">一个</span> <em class="me">计算模型列表:</em></p><h1 id="1c7d" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated"><strong class="ak">格子玻尔兹曼方法(LBM) </strong></h1><p id="ab43" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">在格子Boltzmann方法中，我们将流体在某一时刻离散为8个速度矢量和1个静止速度。使用格子玻尔兹曼方法，声速由下式确定:</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qt"><img src="../Images/a00182cc4f6f62bc3409f23df6c63cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/format:webp/1*q7_hG1eHgX14P9mOJEWWBw.png"/></div></figure><blockquote class="nq nr ns"><p id="59dc" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated">玻尔兹曼晶格模型的能量取决于密度、速度和速度矢量，声速是附加参数。这是格子玻尔兹曼方法应用于障碍物的演示。</p></blockquote><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qu"><img src="../Images/9253093217564b9e770364d37bf708b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/1*wspnTkb31a1rHQ4ISJFQhw.gif"/></div><figcaption class="pm pn eu es et po pp bd b be z dy translated"><strong class="bd jl">请花时间观察LBM的变化</strong></figcaption></figure><h2 id="c990" class="kx jk hu bd jl ky kz la jp lb lc ld jt kk le lf jv ko lg lh jx ks li lj jz lk bi translated">代码示例</h2><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="pq pr l"/></div></figure><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qv"><img src="../Images/2ae0a274766e26621250ede98162c148.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*KU1j4OiJmgrfeltwwc-tyQ.png"/></div></figure><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qw"><img src="../Images/95a792ee87e3ca78f6a64a4a648c888c.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*tCEbi6OV60iHmDa_d6zVtA.png"/></div></figure><p id="7521" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">晶格玻尔兹曼模型的能量取决于作用于粒子的输入/输出方向、密度或速度，以及来自每个方向的速度矢量。</p><p id="3019" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> S </span> <em class="me">模拟优化模型:</em></p><h1 id="8b50" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated"><strong class="ak">进化策略</strong></h1><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qj"><img src="../Images/40e9b61eac7a8e309313c0b5cd861fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*fTNDoLun62mdO6afuhkmGw.png"/></div></figure><p id="d2f3" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">如前所述，基于输入时间序列的模型以如下所述的组合方式发展:</p><blockquote class="nq nr ns"><p id="876d" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated"><strong class="kd hv">下面提供了LBM的代码示例:</strong></p></blockquote><div class="hi hj fa fc hk oj"><a href="https://github.com/aswinvk28/doe-response-surface/blob/master/lattice-boltzmann.py" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dx"><div class="ol ab om cl cj on"><h2 class="bd hv fj z dz oo eb ec op ee eg ht bi translated">aswinvk 28/doe-response-surface/lattice-Boltzmann . py</h2><div class="oq l"><h3 class="bd b fj z dz oo eb ec op ee eg dy translated">晶格玻尔兹曼方法as winvk 28/doe-响应面</h3></div><div class="or l"><p class="bd b fq z dz oo eb ec op ee eg dy translated">github.com</p></div></div><div class="os l"><div class="qx l ou ov ow os ox hq oj"/></div></div></a></div><p id="d14c" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">一小部分<strong class="kd hv"> 1 / 9 </strong>被分配给正交方向，一小部分<strong class="kd hv"> 1 / 36 </strong>被分配给对角方向，一小部分<strong class="kd hv"> 4 / 9 </strong>被分配给剩余速度。</p><p id="b453" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di">一个</span> <em class="me">计算模型列表:</em></p><h1 id="8517" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated"><strong class="ak">实验设计</strong></h1><p id="c139" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">可以安装的实验设计使用:</p><blockquote class="mg"><p id="45da" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated">pip安装—用户pyDOE2</p></blockquote><p id="e067" class="pw-post-body-paragraph kb kc hu kd b ke nx iv kg kh ny iy kj kk nz km kn ko oa kq kr ks ob ku kv kw hc bi translated">是一系列被构造来模拟给定世界轨迹的技术。它可以创建的实验有:析因设计、响应面设计和随机设计。</p><p id="706b" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated"><a class="ae mf" href="https://pythonhosted.org/pyDOE/factorial.html#factorial" rel="noopener ugc nofollow" target="_blank"> <em class="me">析因设计</em> </a></p><ol class=""><li id="837c" class="my mz hu kd b ke lz kh ma kk na ko nb ks nc kw nd ne nf ng bi translated"><a class="ae mf" href="https://pythonhosted.org/pyDOE/factorial.html#general-full-factorial" rel="noopener ugc nofollow" target="_blank"> <em class="me">一般全因子</em> </a> <em class="me"> (fullfact) </em></li><li id="a922" class="my mz hu kd b ke oe kh of kk og ko oh ks oi kw nd ne nf ng bi translated"><a class="ae mf" href="https://pythonhosted.org/pyDOE/factorial.html#level-full-factorial" rel="noopener ugc nofollow" target="_blank"><em class="me"/></a><em class="me">【ff2n】</em></li><li id="581b" class="my mz hu kd b ke oe kh of kk og ko oh ks oi kw nd ne nf ng bi translated"><a class="ae mf" href="https://pythonhosted.org/pyDOE/factorial.html#fractional-factorial" rel="noopener ugc nofollow" target="_blank"><em class="me"/></a><em class="me">【frac fact】</em></li><li id="cc22" class="my mz hu kd b ke oe kh of kk og ko oh ks oi kw nd ne nf ng bi translated"><a class="ae mf" href="https://pythonhosted.org/pyDOE/factorial.html#plackett-burman" rel="noopener ugc nofollow" target="_blank"><em class="me">【Plackett-Burman】</em></a><em class="me">(Pb design)</em></li></ol><p id="c5a1" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated"><a class="ae mf" href="https://pythonhosted.org/pyDOE/rsm.html#response-surface" rel="noopener ugc nofollow" target="_blank"> <em class="me">响应面设计</em> </a></p><ol class=""><li id="5160" class="my mz hu kd b ke lz kh ma kk na ko nb ks nc kw nd ne nf ng bi translated"><a class="ae mf" href="https://pythonhosted.org/pyDOE/rsm.html#box-behnken" rel="noopener ugc nofollow" target="_blank"> <em class="me">框-贝肯</em> </a> <em class="me"> (bbdesign) </em></li><li id="accb" class="my mz hu kd b ke oe kh of kk og ko oh ks oi kw nd ne nf ng bi translated"><a class="ae mf" href="https://pythonhosted.org/pyDOE/rsm.html#central-composite" rel="noopener ugc nofollow" target="_blank"><em class="me"/></a><em class="me">【cc design】</em></li></ol><p id="04f4" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated"><a class="ae mf" href="https://pythonhosted.org/pyDOE/randomized.html#randomized" rel="noopener ugc nofollow" target="_blank"> <em class="me">随机设计</em> </a></p><ol class=""><li id="f779" class="my mz hu kd b ke lz kh ma kk na ko nb ks nc kw nd ne nf ng bi translated"><a class="ae mf" href="https://pythonhosted.org/pyDOE/randomized.html#latin-hypercube" rel="noopener ugc nofollow" target="_blank"> <em class="me">拉丁超立方体</em> </a> <em class="me"> (lhs) </em></li></ol><h2 id="5210" class="kx jk hu bd jl ky kz la jp lb lc ld jt kk le lf jv ko lg lh jx ks li lj jz lk bi translated">代码示例</h2><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="pq pr l"/></div></figure><p id="f1a8" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di">S</span>T28】模拟优化模型:</p><h1 id="c934" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated"><strong class="ak">响应面方法</strong></h1><p id="2098" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">使用响应面方法，一系列回归模型拟合提供的输入参数。使用计算模型<strong class="kd hv">实验设计</strong>，可以运行一组实验，这些实验基于期望的一组特性(例如L2范数和用于建模状态空间的流动特性)来内插数据。</p><p id="9388" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">在这种情况下，<strong class="kd hv"> MNIST </strong>数字和<strong class="kd hv"> EMNIST </strong>字符通过随机设计方法(拉丁超立方)使用两个极端区间(即MNIST数字7和5)从地面真实数据中模拟出来。这里使用的插值特征是实验矩阵与实验值和地面真实值之间的差的乘积，差的次数为1。</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qy"><img src="../Images/303c65d5a661d413a956e96f142cf22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:240/1*T_r3Tcw6ryzESloWXSr9fw.gif"/></div><figcaption class="pm pn eu es et po pp bd b be z dy translated"><strong class="bd jl"> MNIST位数从7转换为5 </strong></figcaption></figure><blockquote class="nq nr ns"><p id="ca81" class="kb kc me kd b ke lz iv kg kh ma iy kj nt mb km kn nu mc kq kr nv md ku kv kw hc bi translated">实验设计的代码库如下所示:</p></blockquote><div class="hi hj fa fc hk oj"><a href="https://github.com/aswinvk28/doe-response-surface" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dx"><div class="ol ab om cl cj on"><h2 class="bd hv fj z dz oo eb ec op ee eg ht bi translated">aswinvk 28/doe-响应面</h2><div class="oq l"><h3 class="bd b fj z dz oo eb ec op ee eg dy translated">使用实验设计的响应面方法</h3></div><div class="or l"><p class="bd b fq z dz oo eb ec op ee eg dy translated">github.com</p></div></div><div class="os l"><div class="qz l ou ov ow os ox hq oj"/></div></div></a></div><p id="8f66" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"/><em class="me">计算模型列表:</em></p><h1 id="3782" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated"><strong class="ak">复分析中的循环和通量</strong></h1><p id="ea31" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">在复分析中，解析复变量表示如下:</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et ra"><img src="../Images/00292d6fa63f87a533a135ba86ac7759.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*Cl3-YvG0fl4uwozCl8JL6Q.png"/></div></figure><p id="7de7" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">如果复函数是调和函数，它们表示为:</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et rb"><img src="../Images/797ec08a3b155c063ec8fa84caabad0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*luKuTpfT_LKbT-I-iYYXxw.png"/></div></figure><p id="30a1" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">假设有一个流量函数，定义如下:</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et qb"><img src="../Images/1176d36f68973f81d24bcef7f66ffc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/1*WM27YVszMCuN4K7EsMoQ8Q.png"/></div></figure><p id="c15f" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">沿着指定等高线的环流和通量定义为:</p><figure class="ll lm ln lo fe hl es et paragraph-image"><div class="es et rc"><img src="../Images/a1f6ed99d1d65c94ae40c788aac9b2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*2vcsdyWlK_jHo5OULv2fPQ.png"/></div></figure><p id="9381" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> S </span> <em class="me">模拟优化模型:</em></p><h1 id="3dd4" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated"><strong class="ak">使用基于相位方法的光流分析</strong></h1><p id="4764" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">使用基于相位的方法，提取图像的空间和时间属性。光流分析是一组可以进行图像分割、确定视频中的约束等的方法。这是一个库，它使用光流技术来预测图像中的微分关系。使用SceneNet框架进行光流导数的查找。该脚本将图像转换为定义的大小，并对图像应用水平视野和垂直视野。图像的输入就是1e-3归一化的深度图。</p><p id="ce83" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">可以进行光流的封装:</p><div class="hi hj fa fc hk oj"><a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_video/py_lucas_kanade/py_lucas_kanade.html" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dx"><div class="ol ab om cl cj on"><h2 class="bd hv fj z dz oo eb ec op ee eg ht bi translated">光流- OpenCV-Python教程1文档</h2><div class="oq l"><h3 class="bd b fj z dz oo eb ec op ee eg dy translated">在这一章中，我们将理解光流的概念及其使用Lucas-Kanade方法的估计。我们会…</h3></div><div class="or l"><p class="bd b fq z dz oo eb ec op ee eg dy translated">opencv-python-tutro als . readthedocs . io</p></div></div><div class="os l"><div class="rd l ou ov ow os ox hq oj"/></div></div></a></div><div class="hi hj fa fc hk oj"><a href="https://robotvault.bitbucket.io/scenenet-rgbd.html" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dx"><div class="ol ab om cl cj on"><h2 class="bd hv fj z dz oo eb ec op ee eg ht bi translated">SceneNet RGB-D:具有完美地面真实性的5M图像的照片级真实感渲染</h2><div class="oq l"><h3 class="bd b fj z dz oo eb ec op ee eg dy translated">scene net RGB-D:500万张合成室内轨迹的照片级逼真图像。</h3></div><div class="or l"><p class="bd b fq z dz oo eb ec op ee eg dy translated">robotvault.bitbucket.io</p></div></div><div class="os l"><div class="re l ou ov ow os ox hq oj"/></div></div></a></div><div class="hi hj fa fc hk oj"><a href="https://github.com/scivision/pyoptflow" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dx"><div class="ol ab om cl cj on"><h2 class="bd hv fj z dz oo eb ec op ee eg ht bi translated">scivision/pyoptflow</h2><div class="oq l"><h3 class="bd b fj z dz oo eb ec op ee eg dy translated">仅使用Scipy栈的光流估计的Python实现也是可能的</h3></div><div class="or l"><p class="bd b fq z dz oo eb ec op ee eg dy translated">github.com</p></div></div><div class="os l"><div class="rf l ou ov ow os ox hq oj"/></div></div></a></div><div class="ll lm ln lo fe ab cb"><figure class="rg hl rh ri rj rk rl paragraph-image"><img src="../Images/0471d45102e78c10776c5625ad8d9132.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*6tWAL9ysMlNx2LkQeem2sg.gif"/></figure><figure class="rg hl rh ri rj rk rl paragraph-image"><img src="../Images/32d15f82face77106b718601ebe46916.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*8auQcOXHBEDI2gZwXKAmhA.gif"/><figcaption class="pm pn eu es et po pp bd b be z dy rm di rn ro translated"><strong class="bd jl">左边是振幅变化，右边是几个轨迹上的光流图像变化</strong></figcaption></figure></div><div class="ab cb"><figure class="rg hl rp ri rj rk rl paragraph-image"><img src="../Images/de741ed1dd2c60dcef205ad93c605395.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*m1jYnMvDhod45_BJWmj9tQ.gif"/></figure><figure class="rg hl rq ri rj rk rl paragraph-image"><img src="../Images/fb9c82c7abb9dc4cb9021d63f04fa235.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*k0ENsQ0_gUldCNSKkHBplg.jpeg"/><figcaption class="pm pn eu es et po pp bd b be z dy rr di rs ro translated"><strong class="bd jl">左边是太阳穴的变化，右边是原始图像</strong></figcaption></figure></div><p id="ba4c" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi nh translated"><span class="l ni nj nk bm nl nm nn no np di"> H </span> <strong class="kd hv">这是怎么生成的！！！</strong></p><blockquote class="mg"><p id="bc96" class="mh mi hu bd mj mk ml mm mn mo mp kw dy translated">只需将2通道2D带通信号<a class="ae mf" href="https://www.electronics-tutorials.ws/filter/filter_4.html" rel="noopener ugc nofollow" target="_blank">和光流导数的复共轭乘积作为一个复数，即可得到实部、虚部和反正切分量。为了将光流导数表示为空间分量，考虑使用移动图像，然后将它们分解成<strong class="ak"> X </strong>和<strong class="ak"> Y </strong>轴。</a></p></blockquote><blockquote class="nq nr ns"><p id="3b1a" class="kb kc me kd b ke nx iv kg kh ny iy kj nt nz km kn nu oa kq kr nv ob ku kv kw hc bi translated"><strong class="kd hv">光流分析的代码库如下:</strong></p></blockquote><div class="hi hj fa fc hk oj"><a href="https://github.com/aswinvk28/optical-flow-analysis" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dx"><div class="ol ab om cl cj on"><h2 class="bd hv fj z dz oo eb ec op ee eg ht bi translated">aswinvk 28/光流分析</h2><div class="oq l"><h3 class="bd b fj z dz oo eb ec op ee eg dy translated">使用Python和scene net-aswinvk 28/optical-Flow-Analysis对图像数据进行光流分析</h3></div><div class="or l"><p class="bd b fq z dz oo eb ec op ee eg dy translated">github.com</p></div></div><div class="os l"><div class="rt l ou ov ow os ox hq oj"/></div></div></a></div><h1 id="8a6a" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka bi translated">结论</h1><p id="56d8" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hc bi translated">总之，组合学分析算法，然后根据状态空间的大小和模型复杂性概括问题，并解决状态空间的表示问题。通过复杂分析，可以确定数据的时间和空间成分或复杂性。实验设计的方法利用社会图表，能够以标准化的方法模拟数据。蒙特卡罗方法是抽样技术，在许多用例中使用。蒙特卡罗方法是与其他问题解决技术相结合的强大技术，例如哈密尔顿力学(带哈密尔顿的MCMC)。</p><p id="c364" class="pw-post-body-paragraph kb kc hu kd b ke lz iv kg kh ma iy kj kk mb km kn ko mc kq kr ks md ku kv kw hc bi translated">这是一篇关于深度学习网络梯度<a class="ae mf" href="https://arxiv.org/pdf/1812.00308.pdf" rel="noopener ugc nofollow" target="_blank">变化的论文，读起来很有趣，因为它们解释了神经网络内几个节点的激活模式。他们还讨论了深层神经网络中最大的变化发生在节点较少的层改变其激活模式时。观察到深度学习问题中的深度神经网络(DNN)同时实现其<strong class="kd hv">复杂性</strong>和<strong class="kd hv">不变性</strong>。</a></p></div></div>    
</body>
</html>