<html>
<head>
<title>Question Answering System with BERT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于BERT的问答系统</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/question-answering-system-with-bert-ebe1130f8def?source=collection_archive---------0-----------------------#2020-07-27">https://medium.com/analytics-vidhya/question-answering-system-with-bert-ebe1130f8def?source=collection_archive---------0-----------------------#2020-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="07bc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">本文解释了什么是BERT，BERT的优点，以及如何使用微调的BERT创建QA系统。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/84d9e313975a4aab7de8deed68366fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*takFFgf0eejdq4pzWxuxdA.jpeg"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">谷歌伯特</figcaption></figure><h1 id="7fe1" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">伯特是什么？</h1><p id="c0c1" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi kx translated"><span class="l ky kz la bm lb lc ld le lf di"> B </span></p><p id="aada" class="pw-post-body-paragraph kb kc hi kd b ke lg ij kg kh lh im kj kk li km kn ko lj kq kr ks lk ku kv kw hb bi translated">它旨在通过联合调节左右上下文来预训练来自未标记文本的深度双向表示。因此，预训练的BERT模型可以通过一个额外的输出层进行微调，从而为各种NLP任务创建最先进的模型。</p><h1 id="3d59" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">为什么是伯特？</h1><p id="2759" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj"> BERT </strong>可以更好地理解长期查询，从而呈现更合适的结果。<strong class="kd hj"> BERT </strong>模型适用于有机搜索结果和特色片段。虽然您可以针对这些查询进行优化，但是您不能“针对BERT进行优化”</p><blockquote class="ll lm ln"><p id="1b56" class="kb kc lo kd b ke lg ij kg kh lh im kj lp li km kn lq lj kq kr lr lk ku kv kw hb bi translated"><strong class="kd hj">简而言之:</strong> BERT帮助搜索引擎理解所用关键词中“To”和“for”等转换词的意义。</p></blockquote><h1 id="6ad1" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">使用BERT的问答系统</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ls"><img src="../Images/5adc734422560a9c9ce88d1830a16d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*cXDOP0gsE7Zp8-sgZqYfTA.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">用BERT构建问答系统</figcaption></figure><p id="4eaf" class="pw-post-body-paragraph kb kc hi kd b ke lg ij kg kh lh im kj kk li km kn ko lj kq kr ks lk ku kv kw hb bi translated">对于问答系统，BERT将两个参数，输入问题和段落作为一个打包序列。输入嵌入是记号嵌入和片段嵌入的总和。</p><ol class=""><li id="2630" class="lt lu hi kd b ke lg kh lh kk lv ko lw ks lx kw ly lz ma mb bi translated"><strong class="kd hj">记号嵌入:</strong>在问题的开头将【CLS】记号添加到输入单词记号，并且在问题和段落的结尾都插入【SEP】记号。</li><li id="b564" class="lt lu hi kd b ke mc kh md kk me ko mf ks mg kw ly lz ma mb bi translated"><strong class="kd hj">片段嵌入:</strong>向每个标记添加指示句子A或句子B的标记。这使得模型能够区分句子。在下面的例子中，所有标记为A的单词都属于问题，标记为B的单词属于段落。</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mh"><img src="../Images/780dde6b0ab55fcadc600acb157aa975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6tR3aYl2HNuociJFKGflQ.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">这两段文本由特殊的<code class="du mm mn mo mp b">[SEP]</code>标记分隔。</figcaption></figure><p id="777d" class="pw-post-body-paragraph kb kc hi kd b ke lg ij kg kh lh im kj kk li km kn ko lj kq kr ks lk ku kv kw hb bi translated">BERT使用“片段嵌入”来区分问题和参考文本。这只是BERT学习的两个嵌入(对于段“A”和“B”)，并且在将它们馈送到输入层之前，将它们添加到令牌嵌入中。</p><h1 id="83a4" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">开始和结束标记分类器</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mq"><img src="../Images/68de85d6b2a825732e25e6e582045449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmymbFhSoCrnpQaSxk-t6Q.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">寻找起始字和结束字的层的变换器结构</figcaption></figure><p id="5e7e" class="pw-post-body-paragraph kb kc hi kd b ke lg ij kg kh lh im kj kk li km kn ko lj kq kr ks lk ku kv kw hb bi translated">对于文本中的每个标记，我们将其最终嵌入到起始标记分类器中。开始标记分类器只有一组应用于每个单词的权重。</p><p id="c1f1" class="pw-post-body-paragraph kb kc hi kd b ke lg ij kg kh lh im kj kk li km kn ko lj kq kr ks lk ku kv kw hb bi translated">在获得输出嵌入和“开始”权重之间的点积之后，我们应用softmax激活来产生所有单词的概率分布。我们选择最有可能成为起始标记的单词。</p><h1 id="e2fc" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">让我们开始编码吧！</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mr"><img src="../Images/80b0724b7a5b6560b33e3903aab08ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*b3uHFSNbZea0Ux0CA_2bVQ.gif"/></div></figure><p id="4ec1" class="pw-post-body-paragraph kb kc hi kd b ke lg ij kg kh lh im kj kk li km kn ko lj kq kr ks lk ku kv kw hb bi translated">安装变压器库，</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="1893" class="pw-post-body-paragraph kb kc hi kd b ke lg ij kg kh lh im kj kk li km kn ko lj kq kr ks lk ku kv kw hb bi translated">加载<strong class="kd hj"> BertForQuestionAnswering </strong>模型和<strong class="kd hj">分词器</strong>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="9691" class="pw-post-body-paragraph kb kc hi kd b ke lg ij kg kh lh im kj kk li km kn ko lj kq kr ks lk ku kv kw hb bi translated">创建一个QA示例，并使用函数encode_plus()对该示例进行编码。encode_plus()函数返回一个包含input _ id、token _ type _ id和注意屏蔽的字典，但是我们只需要input _ id和token _ type _ id来完成QA任务。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="d662" class="pw-post-body-paragraph kb kc hi kd b ke lg ij kg kh lh im kj kk li km kn ko lj kq kr ks lk ku kv kw hb bi translated">通过加载的模型运行QA示例。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="a3a5" class="pw-post-body-paragraph kb kc hi kd b ke lg ij kg kh lh im kj kk li km kn ko lj kq kr ks lk ku kv kw hb bi translated">我们可以获得开始索引和结束索引，并使用这两个索引进行跨度预测。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="fc38" class="pw-post-body-paragraph kb kc hi kd b ke lg ij kg kh lh im kj kk li km kn ko lj kq kr ks lk ku kv kw hb bi translated">我们可以恢复任何被分解成子词的单词，只需要多做一点工作。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="3eec" class="mu jk hi bd jl mv mw mx jp my mz na jt kk nb nc jv ko nd ne jx ks nf ng jz nh bi translated">输出:</h2><pre class="iy iz ja jb fd ni mp nj nk aw nl bi"><span id="86a5" class="mu jk hi mp b fi nm nn l no np">The answer is : the scientific study of algorithms and statistical models</span></pre><h1 id="137a" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">结论</h1><p id="53d0" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我希望你现在已经理解了如何用微调过的BERT创建一个问答系统。感谢阅读！</p></div></div>    
</body>
</html>