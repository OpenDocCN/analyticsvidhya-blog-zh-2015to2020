<html>
<head>
<title>K-Means Clustering With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K-Means使用Python进行聚类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/k-means-clustering-with-python-77b20c2d538d?source=collection_archive---------7-----------------------#2020-04-28">https://medium.com/analytics-vidhya/k-means-clustering-with-python-77b20c2d538d?source=collection_archive---------7-----------------------#2020-04-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="aae8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用python在5分钟内读取聚类</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0dd9e9e93221b5367c83024c5e214d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7P9Vmb6Xbd6ZDb9GFn89Aw.png"/></div></div></figure><p id="1790" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在机器学习中，有一部分是我们处理未标记的数据集，称为“无监督学习”。有时，我们只是想知道我们的数据是如何组织的，以了解这种聚类进入我们了解数据是如何组织的画面。聚类意味着对一组对象进行分组。</p><p id="ebc7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">K-means聚类是无监督学习的一部分，在这种情况下，我们获得了未标记的数据集，该算法会自动将数据分组为连贯的聚类。这是最流行和最广泛使用的聚类算法。它被用于各种应用中，例如市场分割、图像分割等。</p><p id="ed38" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">该算法将接受两个输入:</strong></p><p id="9301" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">a) K(这是您想要的聚类数)</p><p id="5ddf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">b)训练数据集</p><p id="121f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">我们将在几个步骤中看到k-means算法与python的结合:</strong></p><p id="4870" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">1.K-均值的表示</p><p id="a501" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">2.集群分配步骤</p><p id="a568" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">3.移动质心步长</p><p id="7a2b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">4 .局部最优</p><p id="d4b7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">5 .选择集群数量</p><p id="9539" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">6.使用python实现</p><p id="a078" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">表象:</strong></p><p id="bbd9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">K =集群的数量</p><p id="8c86" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">c(称为簇质心)=随机初始化K个簇质心</p><p id="76b6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">m =训练样本的数量</p><p id="b7f4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">【注意:你应该总是有K的值&lt;m】</em></p><p id="ffe4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">idx C(i) =示例X(i)被分配到的聚类的聚类质心</p><p id="e45a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里给出了一个例子，这样你就能理解这个符号了</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kg"><img src="../Images/5922f8dd2f71878ff5803dce2bdc9b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*echDfBe1sDun52SJ-Ro96Q.png"/></div></figure><p id="4992" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">集群分配步骤:</strong></p><p id="5d16" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这一步中，我们将根据离数据集最近的聚类质心为数据集指定一个聚类质心，并对指定的数据集进行着色。这通过计算欧几里德距离来完成</p><p id="9187" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们以更好的方式来看:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kh"><img src="../Images/7c2d664bee6b4a5e0c35845e1a4dd79e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DtgInf0NQs8v8my-s-L_Pw.png"/></div></div></figure><p id="5b35" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在随机定义聚类质心和聚类分配步骤后，它看起来将如下图所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ki"><img src="../Images/20bd00579cc6aefe406f1a9b99eaff4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSb4X5MG4EXWcGs1TG0hmw.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx translated">随机初始化K</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kn"><img src="../Images/4e2c353327c7da1350812cf6e4cd2e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gnt6e5tM9MwuhKPqAwejfw.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx translated">在集群分配步骤之后</figcaption></figure><p id="618d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">移动质心的步骤:</strong></p><p id="4a9b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，我们要做的是，我们要取两个群集质心，即红色十字和蓝色十字，我们要将它们移动到相同颜色的点的平均值。我们要做的是查看所有的红点并计算平均值，实际上平均值是所有红点的位置，我们要将红色聚类的质心移动到那里。蓝十字也是如此。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ko"><img src="../Images/d0eeec90a90fd4450164a04b09c725b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sbS0WLxYAUdgB-NgN2Fatg.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx translated">计算移动质心后，我们可以从上面的图像中看到质心的位置发生了变化</figcaption></figure><p id="21a0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">K均值的优化目标:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kp"><img src="../Images/59f840d64c05f0e081be26de2814e08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*I2xJOFm_c1_oJHv_kXNdWw.png"/></div></figure><p id="a83d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是所谓的失真函数</p><p id="421c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">局部最优:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kq"><img src="../Images/530827e45a31572753d4f1bbcd1f3ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hwbKu84cSBx4qdxcSo0y-g.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx translated">图片01</figcaption></figure><p id="d5b0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我们运行K-means，如果它以一个好的局部最优结束，也称为全局最优，那么你可能会得到上面图像01中带有全局最优标题的簇环。不幸的是，通过进行随机初始化，K-means算法也可以停留在不同的局部最优，在左边的图像01中，看起来蓝色集群捕获了大量的点，而红色、绿色在相对少量的点上添加了字幕。这相当于坏的局部最优，因为它将两个聚类合并成一个，并将第二个聚类分成两个子聚类。</p><p id="121b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了获得最佳的全局最优解，如图01所示，我们将尝试多次随机初始化聚类质心，并运行K-means算法很多次，从中，我们将获得最佳的解决方案，因为良好的局部最优解或全局最优解是可能的。</p><p id="da24" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">选择聚类数:</strong></p><p id="0bf5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们通常知道K的值，我们用这个值，否则我们用肘法。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kr"><img src="../Images/624f42b8c313d3b96e292967f5d64435.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*2ufSnPpyn5oob8FM5oeDwA.png"/></div></figure><p id="79ec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们针对不同的K值(比如K = 10比1)运行该算法，并绘制K值与失真的关系图。并为肘点选择K值，如图所示。</p><p id="7c33" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">使用python实现:</strong></p><p id="55a0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf">导入库</em> </strong></p><pre class="iy iz ja jb fd ks kt ku kv aw kw bi"><span id="9078" class="kx ky hi kt b fi kz la l lb lc">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span></pre><p id="e291" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf">导入数据集</em> </strong></p><pre class="iy iz ja jb fd ks kt ku kv aw kw bi"><span id="7faa" class="kx ky hi kt b fi kz la l lb lc">X = pd.read_csv("data1.csv")</span></pre><p id="caf0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf">绘制一个数据集</em> </strong></p><pre class="iy iz ja jb fd ks kt ku kv aw kw bi"><span id="f9e7" class="kx ky hi kt b fi kz la l lb lc">a = X['0'].values<br/>b = X['1'].values<br/>X = np.array(list(zip(a, b)))<br/>plt.scatter(a, b , c='black', s=7)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ld"><img src="../Images/befdf262f07d318496e356ef4aa5bcdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*an-qZB868Qhf5AxuCnRWsg.png"/></div></figure><p id="fcfc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf">定义K的值并随机初始化点</em> </strong></p><pre class="iy iz ja jb fd ks kt ku kv aw kw bi"><span id="78e3" class="kx ky hi kt b fi kz la l lb lc">K = 3<br/>c_x = np.random.randint(0 , np.max(X) , size = K)<br/>c_y = np.random.randint(0 , np.max(X) , size = K)<br/>c = np.array(list(zip(c_x,c_y)),dtype = np.float32)<br/></span></pre><p id="e49e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的聚类中心在这些随机选择的点上</p><p id="c3f2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">[[6.1.】<br/>【4。5.】<br/>【5。4.]]</p><p id="13af" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf">用簇形心绘制图形</em> </strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ld"><img src="../Images/008307e8ef60af3696f7685ee2d5249c.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*O_sl29rl6vsxhCCOBijzOQ.png"/></div></figure><p id="dbd2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf">聚类赋值</em> </strong></p><p id="3f1c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将每个输入值分配给最近的中心</p><pre class="iy iz ja jb fd ks kt ku kv aw kw bi"><span id="1fd1" class="kx ky hi kt b fi kz la l lb lc">m = X.shape[0]<br/>idx = np.zeros(m)</span><span id="b651" class="kx ky hi kt b fi le la l lb lc">for i in range(m):<br/>    temp = np.zeros(K)<br/>    for j in range(K):<br/>        temp[j] = np.sum((X[i,:] - c[j,:]) ** 2) <br/>        idx[i] = np.argmin(temp)</span></pre><p id="adf2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf">计算质心</em> </strong></p><p id="b6aa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们通过取分配给该聚类的所有点的平均值来找到新的质心。</p><pre class="iy iz ja jb fd ks kt ku kv aw kw bi"><span id="1fa8" class="kx ky hi kt b fi kz la l lb lc">for i in range(K):<br/>    points = [X[j] for j in range(len(X)) if idx[j] == i]<br/>    c[i] = np.mean(points, axis=0)</span></pre><p id="ecef" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf">标图</em> </strong></p><pre class="iy iz ja jb fd ks kt ku kv aw kw bi"><span id="758e" class="kx ky hi kt b fi kz la l lb lc">colors = ['r', 'g', 'b']<br/>fig, ax = plt.subplots()<br/>for i in range(K):<br/>     points = np.array([X[j] for j in range(len(X)) if idx[j] == i])<br/>        ax.scatter(points[:, 0], points[:, 1], c=colors[i])<br/>ax.scatter(c[:, 0], c[:, 1], marker='*', s=200, c='#050505')</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ld"><img src="../Images/a7bbde1bc46dd7d274e2c05cbc4189ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*oX9f8fqG5Kmmc-Dx-wA3rw.png"/></div></figure><p id="6f0d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你可以在我的GitHub库上看到添加了GUI的整个项目</p><p id="a907" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae lf" href="https://github.com/Zeel2864/Synapse_ML" rel="noopener ugc nofollow" target="_blank">https://github.com/Zeel2864/Synapse_ML</a></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lg"><img src="../Images/85ae82bdc75ebc485b7c5b5c324ab448.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*ljq7N2V7iyStK6rqsXy0HQ.jpeg"/></div></figure></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="0f1b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你觉得这篇文章有帮助，请鼓掌👏拍手可以让更多的人看到一个帖子。</p></div></div>    
</body>
</html>