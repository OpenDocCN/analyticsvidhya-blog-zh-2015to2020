<html>
<head>
<title>Denoising Autoencoder on Colored Images Using Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于张量流的彩色图像自动编码器去噪</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/denoising-autoencoder-on-colored-images-using-tensorflow-17bf63e19dad?source=collection_archive---------6-----------------------#2019-12-09">https://medium.com/analytics-vidhya/denoising-autoencoder-on-colored-images-using-tensorflow-17bf63e19dad?source=collection_archive---------6-----------------------#2019-12-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/8f362f8e6e1b40c0751beb3c87fdeb59.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*VLVLUR7sXlgoM8-4WBtKfA.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">使用去噪自动编码器前后的图像</figcaption></figure><p id="d02d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将构建一个自动编码器来消除彩色图像中的噪声。大多数文章使用灰度而不是RGB，我想做一些不同的东西。</p><p id="0431" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要对此进行编程，我们需要了解自动编码器是如何工作的。自动编码器是一种神经网络，旨在以无监督的方式复制原始输入。它由两部分组成:编码器和解码器。编码器接收输入，并将其压缩成潜在空间表示。另一方面，解码器试图从潜在空间重建原始输入。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jp"><img src="../Images/2622df127285761ca7091a2f9a40c2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nv8vBsFe7lqidtkXaZhKlA@2x.jpeg"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">自动编码器的结构。来源:<a class="ae jy" href="https://i-systems.github.io/HSE545/machine%20learning%20all/KIMM/image_files/AE_arch2.png" rel="noopener ugc nofollow" target="_blank">https://I-systems . github . io/HSE 545/machine % 20 learning % 20 all/KIMM/image _ files/AE _ arch 2 . png</a></figcaption></figure></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="d348" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">内森·胡本斯写了一篇关于自动编码器的很棒的文章:<a class="ae jy" href="https://towardsdatascience.com/deep-inside-autoencoders-7e41f319999f" rel="noopener" target="_blank">https://towards data science . com/deep-inside-auto encoders-7e 41 f 319999 f</a></p><p id="9f34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它帮助我更好地理解这个概念。内森，谢谢你的贡献。</p><p id="a39d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么我们为什么要复制原始数据呢？</p><p id="efe2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">众所周知，自动编码器用于降维应用。然而，在这种情况下，我们希望使用一种称为降噪自动编码器的自动编码器。</p><p id="d7ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以将噪声添加到训练数据中，并根据我们的原始图像对它们进行训练。因此，自动编码器将学习对输入数据进行降噪的必要步骤。</p><p id="2fb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个项目，我使用的是微软的猫狗数据集。你可以在这里找到<a class="ae jy" href="https://www.microsoft.com/en-us/download/details.aspx?id=54765" rel="noopener ugc nofollow" target="_blank">。因为这不是一个分类算法，所以我在这个例子中使用了狗的图片。你可以使用任何你想要的数据集。</a></p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="46d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要将图像调整到相同的大小。这可以通过OpenCV中的<a class="ae jy" href="https://www.tutorialkart.com/opencv/python/opencv-python-resize-image/" rel="noopener ugc nofollow" target="_blank"> cv2.resize() </a>来实现。我正在将它们的尺寸调整为300 x 300。当然，您也可以使用其他图像处理库来完成这项工作。</p><p id="ab20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">确保您还使用了reshape data to(# of pictures，width，height，3)来获得适当的形状，否则自动编码器将无法工作。你可以使用一个叫做<a class="ae jy" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html" rel="noopener ugc nofollow" target="_blank">NP . shape</a>的方法来做这件事。</p><p id="1c7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们来讨论一下在数据中加入噪声的问题。有几种方法可以实现这一点。然而，我在这个例子中使用的是高斯噪声算法。还记得统计学上的正态分布吗？我们需要它来制造噪音。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kg"><img src="../Images/209735eba016acabb15abbcd674987e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrUV9kwhufPgBC1dfCm0Bg.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">来源:<a class="ae jy" href="https://machinelearningmastery.com/a-gentle-introduction-to-calculating-normal-summary-statistics/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/a-gentle-简介-计算-普通-汇总-统计/ </a></figcaption></figure><p id="f8e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像宇宙中的大多数事物一样，噪音也遵循正态分布，其特征是标志性的钟形曲线。本质上，我们是基于高斯函数值来产生噪声的。这可以通过以下代码实现:</p><pre class="jq jr js jt fd kh ki kj kk aw kl bi"><span id="395e" class="km kn hi ki b fi ko kp l kq kr"># adds the Gaussian noise based on the mean and the standard deviation<br/>def add_gaussian_noise(data):<br/>    mean = (10, 10, 10)<br/>    std = (50, 50, 50)<br/>    row, col, channel = data.shape<br/>    noise = np.random.normal(mean, std, (row, col,     channel)).astype('uint8')<br/>    eturn data + noise</span><span id="6018" class="km kn hi ki b fi ks kp l kq kr">def add_gaussian_to_dataset(data):<br/>    count = 0<br/>    end = len(data)<br/>    output_data = []<br/>    while count &lt; end:<br/>        output_data.append(add_gaussian_noise(data[count]))<br/>        count+=1<br/>    return np.array(output_data)</span></pre><p id="0e0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个函数用于向单个图像添加高斯噪声。第二个函数用于使用第一个函数将高斯噪声添加到给定的数据集。</p><p id="4333" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们来谈谈房间里的大象，去噪自动编码器。正如我们所见，神经网络由一个编码器和一个解码器组成。我正在使用3000张带有高斯噪声的狗的图像和3000张没有高斯噪声的狗的图像来训练我的神经网络。代码如下:</p><pre class="jq jr js jt fd kh ki kj kk aw kl bi"><span id="c40f" class="km kn hi ki b fi ko kp l kq kr">def create_model():<br/>  x = Input(shape=(300, 300, 3))</span><span id="19d6" class="km kn hi ki b fi ks kp l kq kr"># Encoder<br/>  e_conv1 = Conv2D(64, (3, 3), activation='relu', padding='same')(x)<br/>  pool1 = MaxPooling2D((2, 2), padding='same')(e_conv1)<br/>  batchnorm_1 = BatchNormalization()(pool1)<br/>  e_conv2 = Conv2D(32, (3, 3), activation='relu', padding='same')(batchnorm_1)<br/>  pool2 = MaxPooling2D((2, 2), padding='same')(e_conv2)<br/>  batchnorm_2 = BatchNormalization()(pool2)<br/>  e_conv3 = Conv2D(16, (3, 3), activation='relu', padding='same')(batchnorm_2)<br/>  h = MaxPooling2D((2, 2), padding='same')(e_conv3)</span><span id="8634" class="km kn hi ki b fi ks kp l kq kr"># Decoder<br/>  d_conv1 = Conv2D(64, (3, 3), activation='relu', padding='same')(h)<br/>  up1 = UpSampling2D((2, 2))(d_conv1)<br/>  d_conv2 = Conv2D(32, (3, 3), activation='relu', padding='same')(up1)<br/>  up2 = UpSampling2D((2, 2))(d_conv2)<br/>  d_conv3 = Conv2D(16, (3, 3), activation='relu')(up2)<br/>  up3 = UpSampling2D((2, 2))(d_conv3)<br/>  r = Conv2D(3, (3, 3), activation='sigmoid', padding='same')(up3)</span><span id="a57a" class="km kn hi ki b fi ks kp l kq kr">  model = Model(x, r)<br/>  model.compile(optimizer='adam', loss='mse')<br/>  return model</span><span id="6e15" class="km kn hi ki b fi ks kp l kq kr">gaussian_auto_encoder = create_model()<br/>gaussian_early_stop = EarlyStopping(monitor='loss', patience=3)<br/>gaussian_history = gaussian_auto_encoder.fit(gaussian_train_data, train_data, epochs=50, batch_size=32, callbacks=[gaussian_early_stop])</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/2ffb6f82f60e4f1d1bffb2f3e9bcbf2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*8OQ0hSGrop6n6uikd7MMPg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">我们在训练中得到的图表</figcaption></figure><p id="e5ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种autoencoder布局使用函数式API，类似于代数中的函数工作方式(函数组合)。这使得我们的模型比传统的顺序格式更加灵活。</p><p id="b6f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与使用复杂的神经网络类似，您也可以为自动编码器使用卷积和池层。我使用提前停止回调来确保我没有对我的模型进行不必要的训练。</p><p id="88c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果如下:</p><p id="c9c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我正在对来自测试数据的图片使用训练好的模型。我的测试数据包括1000张带有高斯噪声的狗的图片和1000张没有高斯噪声的狗的图片。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es if"><img src="../Images/6dbc9c46942105fd2586d2db55548aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*mPr07uXWDEmkv3um_OhNrQ.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">使用自动编码器前后</figcaption></figure><p id="da5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们所看到的，autoencoder很好地消除了测试图像中的高斯噪声。尽管图像清晰度有了巨大的提高(图像损失更少)，但这并没有提高图像分辨率。这是卷积神经网络的完全不同的实现。</p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="24ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，仍有很大的改进空间。更大的数据集可能是有利的，因为它提供了更多的变化。此外，我们可能希望使训练数据多样化，以包括除狗以外的图像。因此，该模型可能会更好地概括。</p><p id="0856" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章的代码可以在<a class="ae jy" href="https://github.com/therealcyberlord/tensorflow_keras_color_images_denoiser" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><p id="f1b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这有帮助。请随时向我提供反馈。</p></div></div>    
</body>
</html>