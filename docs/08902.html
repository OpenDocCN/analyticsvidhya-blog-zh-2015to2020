<html>
<head>
<title>Lightgbm for regression with categorical data.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于分类数据回归的 Lightgbm。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/lightgbm-for-regression-with-categorical-data-b08eaff501d1?source=collection_archive---------1-----------------------#2020-08-18">https://medium.com/analytics-vidhya/lightgbm-for-regression-with-categorical-data-b08eaff501d1?source=collection_archive---------1-----------------------#2020-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4f4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这方面，我们将</p><ul class=""><li id="0ba3" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">了解 LGBM</li><li id="a4a8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在 kaggle 数据集上实现</li><li id="e9d2" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">利弊</li></ul><h1 id="8b37" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">了解 LGBM</h1><p id="d4ff" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们都知道，梯度推进技术是用数据进行实验所必须的，它们也能给出很好的结果。他们如此受欢迎，我们不能忽视他们。但是梯度增强树在准确性和效率之间进行了权衡。因为它们需要扫描整个数据来计算所有可能分裂点的信息增益。因此计算时间随着特征数量的增加而增加。所以用这种方法处理大数据非常困难。一种方法是丢弃低梯度变化的特征，但我们会冒准确性的风险，因此在 LGBM 中，我们进行<strong class="ih hj">基于梯度的单侧采样(GOSS)。</strong></p><p id="c7c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基于梯度的单侧采样(GOSS) </strong></p><p id="bd2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们将保留具有大梯度特征，并将随机选择具有小梯度变化的特征。</p><p id="1504" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">寻找最佳分割点(基于直方图)</strong>。</p><p id="bdc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">提升树中的另一个非常耗时的部分是找到最佳分裂以减少这种情况，基于直方图的算法将连续的特征值存储到离散的箱中，并在训练期间使用这些箱来构建特征直方图，而不是在排序的特征值上找到分裂点。这在内存和速度上都是有效的。</p><p id="9536" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些使得 LGBM 速度很快，因此被命名为 LightGBM，因为它可以在大数据上操作，并且效率高。</p><p id="1e3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">垂直生长</strong></p><p id="552e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它垂直生长，因为它会检测到具有较高数据丢失的叶子，然后在其上生长，而不是以其他方式水平生长，即在每片叶子上生长。更多信息请访问<a class="ae ku" rel="noopener" href="/@pushkarmandot/https-medium-com-pushkarmandot-what-is-lightgbm-how-to-implement-it-how-to-fine-tune-the-parameters-60347819b7fc">这里</a>。垂直生长也使它变得很快。</p><h1 id="3756" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">在 kaggle 数据集上实现</h1><p id="1d44" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们已经从 kaggle 下载了数据，并在本教程的<a class="ae ku" rel="noopener" href="/@rajanlagah/data-cleaning-for-machine-learning-algorithms-to-eat-328858114fbc">中清理了数据。就这样，直到删除空值。我会告诉你 LGBM 有多酷，它如何处理分类特征。</a></p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="350b" class="le js hi la b fi lf lg l lh li">import pandas as pd <br/>import numpy as np<br/>import lightgbm as lgb</span></pre><p id="b6d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您没有安装 lightgbm</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="8015" class="le js hi la b fi lf lg l lh li">pip install lightgbm</span></pre><p id="504a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经保存了该教程中的数据，并将测试和培训结合在一起</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="49c5" class="le js hi la b fi lf lg l lh li">data = pd.read_csv('./train_test_nullFill_break_1460.csv')</span></pre><p id="fcea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看所有不连续的特征</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="8db1" class="le js hi la b fi lf lg l lh li">obj_feat = list(data.loc[:, data.dtypes == 'object'].columns.values)<br/>obj_feat</span></pre><p id="7714" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它将输出</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9005" class="le js hi la b fi lf lg l lh li">['MSZoning','Street',....]</span></pre><p id="9d7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是花了我一天时间解决的恼人的部分是 lgbm 不接受对象格式或字符串格式的分类数据，你必须将它们转换成<strong class="ih hj">分类</strong>类型。因此</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3e9c" class="le js hi la b fi lf lg l lh li">for feature in obj_feat:<br/>    data[feature] = pd.Series(data[feature], dtype="category")</span></pre><p id="a01d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="2f94" class="le js hi la b fi lf lg l lh li">train_df = pd.read_csv('./train.csv') # just forgot to save y values<br/>X_train = data[:1260]<br/>y_train = train_df['SalePrice'][:1260]<br/>X_valid = data[1260:1460]<br/>y_valid = train_df['SalePrice'][1260:]<br/>test_df = data[1460:]</span></pre><p id="d453" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在开始建模</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="a0b6" class="le js hi la b fi lf lg l lh li">hyper_params = {<br/>    'task': 'train',<br/>    'boosting_type': 'gbdt',<br/>    'objective': 'regression',<br/>    'metric': ['l2', 'auc'],<br/>    'learning_rate': 0.005,<br/>    "num_leaves": 128,  <br/>    "max_bin": 512,<br/>}</span><span id="aa8a" class="le js hi la b fi lj lg l lh li">lgb_train = lgb.Dataset(X_train, y_train)<br/>gbm = lgb.train(hyper_params, lgb_train, num_boost_round=10, verbose_eval=False)</span></pre><p id="c1b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是使用它是多么简单。不需要处理分类变量。现在让我们保存预测并提交给 kaggle</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="b3e4" class="le js hi la b fi lf lg l lh li">preds_3 = gbm0.predict(test_df)<br/>pred = pd.DataFrame(preds_3)<br/>sub_df=pd.read_csv('sample_submission.csv')</span><span id="7b91" class="le js hi la b fi lj lg l lh li">datasets = pd.concat([sub_df['Id'],pred],axis=1)<br/>datasets.columns = ["Id",'SalePrice']</span><span id="75d2" class="le js hi la b fi lj lg l lh li">datasets.to_csv('lgbm_v1.csv',index=False)</span></pre><p id="c862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们会把它提交给卡格尔。你可以调整得更精确，我刚刚改变了我使用的参数，你必须继续努力。</p><h1 id="9b5f" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">利弊</h1><p id="81b2" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated"><strong class="ih hj">优点</strong></p><ul class=""><li id="03a9" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">快的</li><li id="cddf" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">你不需要担心分类变量(如果你愿意，你可以)</li><li id="f2c8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">它给出了很好结果</li></ul><p id="0aed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">缺点</strong></p><ul class=""><li id="8387" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">它不适合小数据集，因为它会过拟合</li><li id="e1a0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">它有很多可以玩的参数</li></ul><p id="4457" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你读到这里，我希望你能得到一些好的东西。如果您有任何建议，我们将乐于在 rajanlagah@gmail.com<strong class="ih hj">的邮件中听到</strong></p></div></div>    
</body>
</html>