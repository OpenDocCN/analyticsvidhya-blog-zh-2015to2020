<html>
<head>
<title>A Curious Case of Tail Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">尾部递归的一个奇怪例子</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-curious-case-of-tail-recursion-9a3251eabf57?source=collection_archive---------22-----------------------#2020-10-17">https://medium.com/analytics-vidhya/a-curious-case-of-tail-recursion-9a3251eabf57?source=collection_archive---------22-----------------------#2020-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/444732592f76144625be818c03f1d0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c3oOyjIs6OxLBGrP.jpeg"/></div></div></figure><p id="f58a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">递归对于程序员来说并不是一个新术语。我们已经多次使用它来解决各种问题，如阶乘、GCD、树遍历、汉诺塔等，并且可以扩展相同的方法来解决图片拼图、数独，甚至魔方。</p><p id="69ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们都知道递归的利与弊，但这不是你开始阅读这篇文章的原因，所以让我跳到尾部递归的典型例子。</p><p id="a0b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在计算机科学中，<strong class="is hj">尾调用</strong>是作为过程的最终动作执行的子程序调用。如果一个尾部的目标是同一个子程序，这个子程序被称为<strong class="is hj">尾递归</strong>，这是直接递归的一个特例。<strong class="is hj">尾部递归</strong>(或<strong class="is hj">尾部递归</strong>)特别有用，并且在实现中通常容易处理。</p><p id="e168" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无需向调用堆栈添加新的堆栈框架就可以实现尾部调用。当前过程的大部分帧不再需要，并且可以被适当修改的尾部调用的帧所替代。</p><p id="f3be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后程序可以跳转到被调用的子程序。产生这样的代码而不是标准的调用序列被称为<strong class="is hj">尾部调用消除</strong>或<strong class="is hj">尾部调用优化</strong>。尾部调用消除允许尾部位置的过程调用像 goto 语句一样高效地实现，从而允许高效的结构化编程。</p><p id="20e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一个例子</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="1084" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该函数不是尾递归的，因为递归函数调用不是该函数的最后一次调用。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="4336" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们分析一下计算第 n 个斐波那契数的不同技术对 CPU 和内存使用的影响。我们使用的是 Golang 编程语言。</p><p id="6396" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们在分析中考虑的用于计算第 n 个斐波那契数的 4 个候选者。</p><ol class=""><li id="861d" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated"><em class="kd">迭代法。</em></li><li id="981a" class="ju jv hi is b it ke ix kf jb kg jf kh jj ki jn jz ka kb kc bi translated"><em class="kd">不使用记忆化的递归方法。</em></li><li id="953b" class="ju jv hi is b it ke ix kf jb kg jf kh jj ki jn jz ka kb kc bi translated"><em class="kd">使用记忆化进行优化的递归方法。</em></li><li id="b0df" class="ju jv hi is b it ke ix kf jb kg jf kh jj ki jn jz ka kb kc bi translated"><em class="kd">尾部递归。</em></li></ol><p id="8637" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我已经捆绑了 GitHub 仓库中使用的代码，可以在 https://github.com/rahulbaghel159/tail_recursion_exp 访问</p><p id="9c2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是基准测试结果:-</p><p id="2b9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">无记忆递归</strong></p><pre class="jo jp jq jr fd kk kl km kn aw ko bi"><span id="f698" class="kp kq hi kl b fi kr ks l kt ku">goos: darwin<br/>goarch: amd64<br/>pkg: github.com/baghelrahul159/tail_recursion_exp/benchmark/non-tail-recursion<br/>BenchmarkFibWithRecursion1-4    	443103949	         2.60 ns/op<br/>BenchmarkFibWithRecursion2-4    	165883412	         7.25 ns/op<br/>BenchmarkFibWithRecursion5-4    	30739672	        41.1 ns/op<br/>BenchmarkFibWithRecursion10-4   	 2572047	       455 ns/op<br/>BenchmarkFibWithRecursion20-4   	   18165	     80904 ns/op<br/>PASS</span></pre><p id="0e2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很明显，在没有记忆的递归中，即使第 20 个斐波那契数也需要 80904 ns/op。因此，我们将在以后的讨论中忽略它。</p><p id="7501" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">带记忆的递归</strong></p><pre class="jo jp jq jr fd kk kl km kn aw ko bi"><span id="d624" class="kp kq hi kl b fi kr ks l kt ku">goos: darwin<br/>goarch: amd64<br/>pkg: github.com/baghelrahul159/tail_recursion_exp/benchmark/recursion_with_memoization<br/>BenchmarkFibWithRecursionMemoization1-4      	415333540	         3.00 ns/op<br/>BenchmarkFibWithRecursionMemoization2-4      	149585394	         8.03 ns/op<br/>BenchmarkFibWithRecursionMemoization5-4      	100000000	        10.8 ns/op<br/>BenchmarkFibWithRecursionMemoization10-4     	49885395	        25.9 ns/op<br/>BenchmarkFibWithRecursionMemoization20-4     	66632116	        20.2 ns/op<br/>BenchmarkFibWithRecursionMemoization50-4     	45081136	        27.7 ns/op<br/>BenchmarkFibWithRecursionMemoization100-4    	41284546	        33.4 ns/op<br/>BenchmarkFibWithRecursionMemoization300-4    	45022812	        28.7 ns/op<br/>BenchmarkFibWithRecursionMemoization500-4    	75619054	        19.7 ns/op<br/>BenchmarkFibWithRecursionMemoization700-4    	69009540	        21.3 ns/op<br/>BenchmarkFibWithRecursionMemoization1000-4   	80567641	        16.3 ns/op<br/>PASS</span></pre><p id="b944" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">尾部递归</strong></p><pre class="jo jp jq jr fd kk kl km kn aw ko bi"><span id="7a0a" class="kp kq hi kl b fi kr ks l kt ku">goos: darwin<br/>goarch: amd64<br/>pkg: github.com/baghelrahul159/tail_recursion_exp/benchmark/tail_recursion<br/>BenchmarkTailFib1-4      	373255960	         4.33 ns/op<br/>BenchmarkTailFib2-4      	157686687	         7.42 ns/op<br/>BenchmarkTailFib5-4      	73597358	        24.2 ns/op<br/>BenchmarkTailFib10-4     	16147897	        69.8 ns/op<br/>BenchmarkTailFib20-4     	13154060	       126 ns/op<br/>BenchmarkTailFib50-4     	 5215443	       270 ns/op<br/>BenchmarkTailFib100-4    	 2578944	       477 ns/op<br/>BenchmarkTailFib300-4    	  965191	      1368 ns/op<br/>BenchmarkTailFib500-4    	  438627	      3005 ns/op<br/>BenchmarkTailFib700-4    	  339271	      4191 ns/op<br/>BenchmarkTailFib1000-4   	  263703	      5076 ns/op<br/>PASS</span></pre><p id="f7e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">迭代</strong></p><pre class="jo jp jq jr fd kk kl km kn aw ko bi"><span id="1097" class="kp kq hi kl b fi kr ks l kt ku">goos: darwin<br/>goarch: amd64<br/>pkg: github.com/baghelrahul159/tail_recursion_exp/benchmark/without_recursion<br/>BenchmarkFib1-4      	441498200	         2.52 ns/op<br/>BenchmarkFib2-4      	460432479	         2.40 ns/op<br/>BenchmarkFib5-4      	231182103	         6.86 ns/op<br/>BenchmarkFib10-4     	118818930	        12.0 ns/op<br/>BenchmarkFib20-4     	58351034	        20.1 ns/op<br/>BenchmarkFib50-4     	23743794	        59.4 ns/op<br/>BenchmarkFib100-4    	17107134	        68.1 ns/op<br/>BenchmarkFib300-4    	 6996146	       194 ns/op<br/>BenchmarkFib500-4    	 4176632	       359 ns/op<br/>BenchmarkFib700-4    	 2957839	       398 ns/op<br/>BenchmarkFib1000-4   	 2071720	      1038 ns/op<br/>BenchmarkFib2000-4   	 1000000	      1153 ns/op<br/>BenchmarkFib3000-4   	  611624	      3048 ns/op<br/>PASS</span></pre><p id="e3d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用 python 中的 matplotlib 库绘制上述值。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es kv"><img src="../Images/6499eb4d5efb3d8c78bc4424c1076c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*XKwJKqp1lhtkZj_4UcJjkQ.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">这说明了这样一个事实:记忆化以更多的内存为代价极大地提高了速度。然而，有趣的是，尾部递归和迭代方法非常接近。</figcaption></figure><h1 id="716a" class="la kq hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">堆轮廓的火焰图</h1><p id="8687" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated"><strong class="is hj">无记忆递归</strong></p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/8096c7f941d28ae1b525abf437ca6bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*qTgJnIZjG7fka6S8Hk3_Lw.png"/></div></figure><p id="0149" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">带记忆的递归</strong></p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es md"><img src="../Images/6abccc599efcc1dd547ea706e99fc214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*muFZgLjWNkWlfHMItDISeg.png"/></div></figure><p id="ea58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">尾递归</strong></p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es me"><img src="../Images/01a0dd51711d81e986aeb61308a3c165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*HEyJW81d-Oc9o6LoakR47g.png"/></div></figure><p id="b48c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">迭代</strong></p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/1dd41f665fe3a259f16c667c24ecb7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*kNwKBYej3-2NXSoyCm2Kqg.png"/></div></figure><p id="bd40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了存储技术使用了近 30 MB，其余所有方法都使用了几 KB</p><h1 id="2af0" class="la kq hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">CPU 配置文件的火焰图</h1><p id="5364" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated"><strong class="is hj">无记忆递归</strong></p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/2b497014da6c910820ee3afde56b8846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*qNOT_O1-Y3e4EQaVJ92pxw.png"/></div></figure><p id="c02f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">带记忆的递归</strong></p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/3ae8246c9ba4a1655cbd8fc151bc6eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*7P8Gs0YKQv8b7PJgOy9_dg.png"/></div></figure><p id="93c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">尾部递归</strong></p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/88c198bf4106fa59c049d4f801ee95ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*jt37fzJiAULSW_ToxaUfzQ.png"/></div></figure><p id="3dde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">迭代</strong></p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/1e2636d232454d414095b3be937932c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*PqN4fa8Zhq27ZXw0GyLDoQ.png"/></div></figure><p id="10a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在没有记忆化的情况下，递归需要大约 18s，而在有记忆化的情况下减少到 160ms，尾递归和迭代函数需要几乎相同的 CPU 时间。</p><blockquote class="mk ml mm"><p id="f707" class="iq ir kd is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">参考文献:</em> </strong></p><p id="73a6" class="iq ir kd is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated"><a class="ae kj" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Recursion _(计算机科学)</a></p><p id="fe53" class="iq ir kd is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated"><a class="ae kj" href="https://en.wikipedia.org/wiki/Tail_call" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Tail_call</a></p><p id="7b17" class="iq ir kd is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated"><a class="ae kj" rel="noopener" href="/@openmohan/profiling-in-golang-3e51c68eb6a8">https://medium . com/@ open Mohan/profiling-in-golang-3 e 51 c 68 EB 6 a 8</a></p></blockquote></div></div>    
</body>
</html>