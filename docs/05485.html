<html>
<head>
<title>Machine Learning using C++: A Beginner’s Guide to Linear and Logistic Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C++的机器学习:线性和逻辑回归初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-using-c-a-beginners-guide-to-linear-and-logistic-regression-b67f13dc45e4?source=collection_archive---------30-----------------------#2020-04-22">https://medium.com/analytics-vidhya/machine-learning-using-c-a-beginners-guide-to-linear-and-logistic-regression-b67f13dc45e4?source=collection_archive---------30-----------------------#2020-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="6af7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">为什么用C++做机器学习？</h1><p id="cea9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">机器学习的应用超越了边界和行业，所以我们为什么要让工具和语言阻碍我们呢？是的，Python是目前业界的首选语言，但是我们中的很多人都没有学习过Python！</p><p id="b907" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">大学里的计算机科学教师仍然在教授C++编程——所以这是我们大多数人最终首先学习的东西。我理解你为什么应该学习Python——它是这个行业的主要语言，它有你开始机器学习所需的所有库。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/c89cb62303836764adcea5b8f6670c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-TTCHV9M5u_B7zJb.png"/></div></div></figure><p id="d44b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">但是如果你的大学不教呢？嗯——这启发了我更深入地挖掘，并使用C++来构建机器学习算法。因此，如果你是一名大学生，该行业的新生，或者只是对学习不同的机器学习语言感到好奇的人，这篇教程就是为你准备的！</p><p id="98be" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在我关于使用C++进行机器学习系列的第一篇文章中，我们将从基础开始。我们将了解如何使用C++实现线性回归和逻辑回归！</p><p id="6869" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们开始吧！</p><p id="2d67" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="ks">注:如果你是机器学习初学者，我推荐你参加综合</em> <a class="ae kt" href="https://courses.analyticsvidhya.com/courses/applied-machine-learning-beginner-to-professional?utm_source=blog&amp;utm_medium=machine-learning-using-c-linear-logistic-regression" rel="noopener ugc nofollow" target="_blank"> <em class="ks">应用机器学习课程</em> </a> <em class="ks">。</em></p><h1 id="d155" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">使用C++进行线性回归</h1><p id="505f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在使用C++实现线性回归之前，让我们先简单了解一下什么是线性回归以及它是如何工作的。</p><p id="5918" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">线性回归模型用于根据一个因素的值预测另一个因素的值。被预测的值称为因变量，用于预测因变量的值称为自变量。线性回归的数学方程是:</p><blockquote class="ku kv kw"><p id="232e" class="jd je ks jf b jg kb ji jj jk kc jm jn kx kd jq jr ky ke ju jv kz kf jy jz ka hb bi translated">Y=B0+B1 X</p></blockquote><p id="2f76" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里，</p><ul class=""><li id="1dd7" class="la lb hi jf b jg kb jk kc jo lc js ld jw le ka lf lg lh li bi translated">x:独立变量</li><li id="150b" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">y:因变量</li><li id="1209" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">B0:表示X=0时Y的值</li><li id="eed6" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">B1:回归系数(这代表因变量基于自变量单位变化的变化)</li></ul><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lo"><img src="../Images/9cd3300eb9e03b5fd4b0c6426f7d4d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/0*r9nrRdyRS6DppBaf.png"/></div></figure><p id="098e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">例如，我们可以使用线性回归来了解是否可以根据吸烟持续时间来预测香烟消费量。在这里，你的因变量是“香烟消费量”，以每天消费的香烟数量来衡量，你的自变量是“吸烟持续时间”，以天数来衡量。</p><h1 id="e7b7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">损失函数</h1><p id="c94b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">损失是我们预测值B0和B1的误差。我们的目标是最小化这一误差，以获得B0和B1的最精确值，从而获得未来预测的最佳拟合线。</p><p id="35e5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为简单起见，我们将使用以下损失函数:</p><blockquote class="ku kv kw"><p id="9b57" class="jd je ks jf b jg kb ji jj jk kc jm jn kx kd jq jr ky ke ju jv kz kf jy jz ka hb bi translated">e(i) = p(i) - y(i)</p></blockquote><p id="d1ab" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里，</p><ul class=""><li id="780d" class="la lb hi jf b jg kb jk kc jo lc js ld jw le ka lf lg lh li bi translated">e(I)<em class="ks">与</em>训练示例的误差</li><li id="dcd2" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">p(i):第个训练样本的<em class="ks">的预测值</em></li><li id="d955" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">y(i):第个训练示例的<em class="ks">的实际值</em></li></ul><h1 id="4c36" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">梯度下降算法概述</h1><p id="a7b9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">梯度下降是一种寻找函数最小值的迭代优化算法。在我们的例子中，这个函数就是我们的损失函数<strong class="jf hj">。</strong></p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lp"><img src="../Images/7d2c5bfff2c8cd04d8dc9e6e98ded4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*UrqDGaA6VqU4PN0g.jpeg"/></div></figure><p id="bcb9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里，我们的目标是找到损失函数的最小值(在我们的例子中非常接近于零)。梯度下降是实现这一点的有效算法。我们从系数B0和B1的随机初始值开始，基于每个实例的误差，我们将更新它们的值。</p><p id="e750" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它是这样工作的:</p><ol class=""><li id="7bc6" class="la lb hi jf b jg kb jk kc jo lc js ld jw le ka lq lg lh li bi translated">最初，让B1 = 0，B0 = 0。设L为我们的学习率。这控制了<strong class="jf hj"> B1 </strong>的值随着每一步变化的程度。l可以是一个小值，如0.01，以获得良好的精度</li><li id="2b13" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lq lg lh li bi translated">我们计算第一点的误差:e(1)= p(1)- y(1)</li><li id="fc0d" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lq lg lh li bi translated">我们将根据以下等式更新B0和B1:</li></ol><blockquote class="ku kv kw"><p id="127b" class="jd je ks jf b jg kb ji jj jk kc jm jn kx kd jq jr ky ke ju jv kz kf jy jz ka hb bi translated">b0(t+1) = b0(t) - L *误差<br/> b1(t+1) = b1(t) - L *误差</p></blockquote><p id="65b4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们将对训练集的每个实例都这样做。这完成了一个时代。我们将对更多的时期重复这一过程，以获得更准确的预测。</p><p id="3c81" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您可以参考这些综合指南，以更深入地了解线性回归和梯度下降:</p><ul class=""><li id="ed98" class="la lb hi jf b jg kb jk kc jo lc js ld jw le ka lf lg lh li bi translated"><a class="ae kt" href="https://www.analyticsvidhya.com/blog/2017/06/a-comprehensive-guide-for-linear-ridge-and-lasso-regression/?utm_source=blog&amp;utm_medium=machine-learning-using-c-linear-logistic-regression" rel="noopener ugc nofollow" target="_blank">线性、脊形和套索回归综合初学者指南</a></li><li id="249f" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated"><a class="ae kt" href="https://www.analyticsvidhya.com/blog/2017/03/introduction-to-gradient-descent-algorithm-along-its-variants/?utm_source=blog&amp;utm_medium=machine-learning-using-c-linear-logistic-regression" rel="noopener ugc nofollow" target="_blank">机器学习中的梯度下降介绍</a></li></ul><h1 id="2aae" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">在C++中实现线性回归</h1><h2 id="8c9b" class="lr ig hi bd ih ls lt lu il lv lw lx ip jo ly lz it js ma mb ix jw mc md jb me bi translated">初始化阶段:</h2><p id="51bf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将从定义数据集开始。在本教程中，我们将使用这个数据集:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mf"><img src="../Images/8cbb761351e230df85c68e41f38168b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/0*o31oMSqxNjI7Oaqr.png"/></div></figure><p id="4e73" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们将针对前5个值训练数据集，并针对最后一个值进行测试:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="5845" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">接下来，我们将定义变量:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h2 id="8913" class="lr ig hi bd ih ls lt lu il lv lw lx ip jo ly lz it js ma mb ix jw mc md jb me bi translated">培训阶段</h2><p id="ad8d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们的下一步是梯度下降算法:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="87fa" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因为有5个值，我们运行整个算法4个时期，因此我们的迭代函数工作20次。变量<em class="ks"> p </em>计算每个实例的预测值。变量<em class="ks"> err </em>用于计算每个实例的误差。然后，我们更新b0和b1的值，如上文梯度下降部分所述。我们最后把误差推进误差向量。</p><p id="3b44" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你会注意到，B0没有任何输入。这个系数通常被称为<strong class="jf hj">偏差</strong>或<strong class="jf hj">截距</strong>，我们可以假设它的输入值总是1.0。当使用向量或数组实现算法时，这种假设会有所帮助。</p><p id="e6e6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">最后，我们将对误差向量进行排序，以获得误差的最小值以及b0和b1的相应值。最后，我们将打印这些值:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h2 id="d5b1" class="lr ig hi bd ih ls lt lu il lv lw lx ip jo ly lz it js ma mb ix jw mc md jb me bi translated">测试阶段:</h2><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="5261" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们将输入测试值6。我们得到的答案是4.9753，非常接近5。恭喜你！我们刚刚用C++建立了一个线性回归模型，而且参数也很好。</p><h2 id="605d" class="lr ig hi bd ih ls lt lu il lv lw lx ip jo ly lz it js ma mb ix jw mc md jb me bi translated">最终实现的完整代码:</h2><p id="c028" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最终实现的完整代码可以在这里找到:<a class="ae kt" href="https://github.com/Alakhator/Machine-Learning-With-C-/blob/master/linear_regession_full.cpp" rel="noopener ugc nofollow" target="_blank">https://github . com/Alakhator/Machine-Learning-With-C-/blob/master/linear _ regession _ full . CPP</a></p><h1 id="76e8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">用C++实现逻辑回归</h1><p id="b233" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">逻辑回归是用于二分类的最著名的机器学习算法之一。这是因为它是一个简单的算法，在广泛的问题上表现非常好。</p><p id="2ea2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这个算法的名字叫逻辑回归，因为我们在这个算法中使用了逻辑函数。该物流功能定义为:</p><blockquote class="ku kv kw"><p id="daaa" class="jd je ks jf b jg kb ji jj jk kc jm jn kx kd jq jr ky ke ju jv kz kf jy jz ka hb bi translated">预测值= 1 / (1 + e^-x)</p></blockquote><p id="38b3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">逻辑回归模型采用实值输入，并预测输入属于默认类(类0)的概率。如果概率&gt; 0.5，我们可以将输出作为默认类(类0)的预测，否则，该预测是针对另一个类(类1)的。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mi"><img src="../Images/d053c172bf4885bea668c96d6aa5d120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3XArhHzORX-JgzZv.png"/></div></figure><h1 id="fb72" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">逻辑回归的梯度下降</h1><p id="7e85" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以将随机梯度下降应用于寻找逻辑回归模型系数的问题，如下所示:</p><p id="b17f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们假设对于示例数据集，逻辑回归与线性回归一样具有三个系数:</p><blockquote class="ku kv kw"><p id="a2eb" class="jd je ks jf b jg kb ji jj jk kc jm jn kx kd jq jr ky ke ju jv kz kf jy jz ka hb bi translated">输出= b0 + b1*x1 + b2*x2</p></blockquote><p id="3417" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">学习算法的工作将是基于训练数据发现系数(b0、b1和b2)的最佳值。</p><p id="7668" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">给定每个训练实例:</p><ol class=""><li id="497e" class="la lb hi jf b jg kb jk kc jo lc js ld jw le ka lq lg lh li bi translated">使用系数的当前值计算预测。</li></ol><blockquote class="ku kv kw"><p id="2b60" class="jd je ks jf b jg kb ji jj jk kc jm jn kx kd jq jr ky ke ju jv kz kf jy jz ka hb bi translated">预测= 1 / (1 + e^(-(b0 + b1*x1 + b2*x2))。</p></blockquote><p id="7307" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">2.基于预测中的误差计算新的系数值。这些值根据以下等式进行更新:</p><blockquote class="ku kv kw"><p id="eb4c" class="jd je ks jf b jg kb ji jj jk kc jm jn kx kd jq jr ky ke ju jv kz kf jy jz ka hb bi translated">b = b+alpha *(y-预测)*预测*(1-预测)* x</p></blockquote><p id="713e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">其中b是我们正在更新的系数，预测是使用模型进行预测的输出。Alpha是您必须在训练开始时指定的参数。这是学习率，控制着每次更新时系数(以及模型)的变化或学习程度。</p><p id="cc9d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">就像我们之前讨论线性回归时看到的，B0没有任何输入。这个系数称为偏差或截距，我们可以假设它的输入值总是1.0。所以在更新的时候，我们会乘以1.0。</p><p id="f166" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">重复该过程，直到模型足够精确(例如，误差下降到某个期望的水平)或者重复固定次数。</p><p id="f283" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于逻辑回归的初学者指南，看看这个— <a class="ae kt" href="https://www.analyticsvidhya.com/blog/2015/11/beginners-guide-on-logistic-regression-in-r/" rel="noopener ugc nofollow" target="_blank">逻辑回归简单指南</a>。</p><h1 id="a08e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">在C++中实现逻辑回归</h1><h2 id="e817" class="lr ig hi bd ih ls lt lu il lv lw lx ip jo ly lz it js ma mb ix jw mc md jb me bi translated">初始阶段</h2><p id="8603" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将从定义数据集开始:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mj"><img src="../Images/a4c3eaf08100dd7b5879c2522983402e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/0*Mo3Sa3MnDeyiz23q.png"/></div></figure><p id="9d3f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们将训练前10个值，并测试最后一个值:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="ad10" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">接下来，我们将初始化变量:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h2 id="c6ba" class="lr ig hi bd ih ls lt lu il lv lw lx ip jo ly lz it js ma mb ix jw mc md jb me bi translated">培训阶段</h2><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="965d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">由于有10个值，我们将运行一个包含10个步骤的纪元。我们将根据上面梯度下降部分描述的等式计算预测值:</p><blockquote class="ku kv kw"><p id="398b" class="jd je ks jf b jg kb ji jj jk kc jm jn kx kd jq jr ky ke ju jv kz kf jy jz ka hb bi translated">预测= 1 / (1 + e^(-(b0 + b1*x1 + b2*x2)))</p></blockquote><p id="94f0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">接下来，我们将根据上面描述的类似等式更新变量:</p><blockquote class="ku kv kw"><p id="a314" class="jd je ks jf b jg kb ji jj jk kc jm jn kx kd jq jr ky ke ju jv kz kf jy jz ka hb bi translated">b = b + alpha * (y预测)*预测* (1预测)* x</p></blockquote><p id="50ba" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">最后，我们将对误差向量进行排序，以获得误差的最小值以及b0、b1和b2的相应值。最后，我们将打印这些值:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h2 id="92ee" class="lr ig hi bd ih ls lt lu il lv lw lx ip jo ly lz it js ma mb ix jw mc md jb me bi translated">测试阶段:</h2><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="9dfd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当我们输入x1=7.673756466，x2= 3.508563011时，得到pred = 0.59985。所以最后我们将打印这个类:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="9c4d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以模型打印出来的类是1。是啊！我们的预测是正确的！</p><h2 id="894e" class="lr ig hi bd ih ls lt lu il lv lw lx ip jo ly lz it js ma mb ix jw mc md jb me bi translated">全面实施的最终代码</h2><p id="7b72" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">完整实现的最终代码可以在这里找到:<a class="ae kt" href="https://github.com/Alakhator/Machine-Learning-With-C-/blob/master/logistic_regression_full.cpp" rel="noopener ugc nofollow" target="_blank">https://github . com/Alakhator/Machine-Learning-With-C-/blob/master/logistic _ regression _ full . CPP</a></p><h1 id="591d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结束注释</h1><p id="fc7a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了学习机器学习，更重要的一步是从零开始实现算法。简单的事实是，如果我们不熟悉算法的基础，我们就不能在C++中实现它。</p><p id="fa2f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这是我用C++在机器学习这个领域开始的冒险之一。我正在研究更先进的机器学习算法，请密切关注！</p><h1 id="c48d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">你也可以在分析Vidhya的Android应用上阅读这篇文章</h1><p id="7709" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">【https://www.analyticsvidhya.com】原载于2020年4月22日<a class="ae kt" href="https://www.analyticsvidhya.com/blog/2020/04/machine-learning-using-c-linear-logistic-regression/" rel="noopener ugc nofollow" target="_blank"><em class="ks"/></a><em class="ks">。</em></p></div></div>    
</body>
</html>