<html>
<head>
<title>Exploring Trending with FitBit Heart Health Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索FitBit心脏健康数据的趋势</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/exploring-trending-with-fitbit-heart-health-data-5765768110a9?source=collection_archive---------17-----------------------#2020-01-19">https://medium.com/analytics-vidhya/exploring-trending-with-fitbit-heart-health-data-5765768110a9?source=collection_archive---------17-----------------------#2020-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="560f" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这是在Jupyter Notebook 中用Python、Pandas和Seaborn探索您的<a class="ae jh" rel="noopener" href="/analytics-vidhya/exploring-your-fitbit-sleep-data-with-python-pandas-and-seaborn-in-jupyter-notebook-a997f17c3a42"> FitBit睡眠数据的继续，该书介绍了FitBit数据存档的整体情况以及将其放入绘图的基本知识。如果你想从头开始，就从那里开始。我还会指出我在那篇文章中讨论过的地方。</a></p></blockquote><h1 id="d069" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">介绍</h1><p id="9b76" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ki kj iw ix kk kl ja jb km kn je jf jg hb bi translated">对于这篇文章，我们的目标是拟合FitBit所谓的“心脏健康”数据。FitBit所谓的“心脏健康”实际上是FitBit对<a class="ae jh" href="https://en.wikipedia.org/wiki/VO2_max" rel="noopener ugc nofollow" target="_blank"> VO2 max </a>的最佳猜测——一种对身体吸收氧气能力的测量。我认为这个数字真的很酷，因为它基本上是一个在任何给定时间我的健身制度有多有效的代理测量。</p><p id="6724" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">FitBit应用程序静态显示这个数字，没有任何历史或趋势。我想看看这个数字是如何随着时间的推移而变化的，以及它是呈上升趋势还是下降趋势。这可以给我预警，告诉我什么时候该离开沙发，或者只是提供一些额外的动力来保持活跃。不管是哪种方式，看看它们之间的关系，并与其他健康指标进行比较，都是很酷的事情。</p><h1 id="bb5a" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">加载并处理数据帧</h1><p id="c047" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ki kj iw ix kk kl ja jb km kn je jf jg hb bi translated">第一步是确定正确的数据，并将其放入数据框架中。我们感兴趣的数据存在于归档导出的两种文件中:</p><ul class=""><li id="abd3" class="ko kp hi il b im in iq ir ki kq kk kr km ks jg kt ku kv kw bi translated">人口统计_vo2_max-yyyy-mm-dd.json</li><li id="3f4c" class="ko kp hi il b im kx iq ky ki kz kk la km lb jg kt ku kv kw bi translated">run_vo2_max-yyyy-mm-dd.json</li></ul><p id="ff5b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">run_vo2_max比demographic_vo2_max更准确，但它只在你用FitBit记录跑步时才会被记录下来——我不常这样做。demographic_vo2_max不太准确，但它是在您每天佩戴FitBit时计算的，与您的活动无关。我将使用demographic_v2_max获得更可靠的数据集。如果你定期记录跑步，无论如何，使用run_vo2_max。</p><p id="1f6a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">首先，将这些文件放到它们自己的文件夹中，这样我们就可以很容易地将它们连接成一个数据帧。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b54c" class="ll jj hi lh b fi lm ln l lo lp">!mkdir vo2_max_data<br/>!cp LoganHennessy/user-site-export/demographic_vo2_max* vo2_max_data/</span></pre><p id="ecc0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">和前面的分析一样，一旦数据进入它自己的文件夹，我们可以使用简单的for-loop和Pandas <code class="du lq lr ls lh b">concat()</code>函数加载数据。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="28a6" class="ll jj hi lh b fi lm ln l lo lp">import os<br/>import pandas as pd</span><span id="fa0e" class="ll jj hi lh b fi lt ln l lo lp">dfs = []<br/>for file in os.listdir("vo2_max_data"):<br/>    dfs.append(pd.read_json(f"vo2_max_data/{file}"))<br/>df = pd.concat(dfs)</span></pre><p id="0d21" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">我们感兴趣的数据又一次被加载为JSON对象，这使得我们很难访问我们想要的字段。</p><p id="9e9b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">首先看一下第一个值，理解JSON对象是如何构造的。我们感兴趣的数据存储在一个统称为<code class="du lq lr ls lh b">value</code>的列中。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="29f8" class="ll jj hi lh b fi lm ln l lo lp">In [2]: df.iloc[0].value<br/>Out[2]: {'demographicVO2Max': 47.60661,<br/>         'demographicVO2MaxError': 3.0,<br/>         'filteredDemographicVO2Max': 47.08661000000001,<br/>         'filteredDemographicVO2MaxError': 0.36310000000000003}</span></pre><p id="5794" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">只有四个字段，让我们将它们解析到各自的列中。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="234d" class="ll jj hi lh b fi lm ln l lo lp">df["demographicVO2Max"] = df.value.apply(lambda val: val["demographicVO2Max"])<br/>df["demographicVO2MaxError"] = df.value.apply(lambda val: val["demographicVO2MaxError"])<br/>df["filteredDemographicVO2Max"] = df.value.apply(lambda val: val["filteredDemographicVO2Max"])<br/>df["filteredDemographicVO2MaxError"] = df.value.apply(lambda val: val["filteredDemographicVO2MaxError"])</span></pre><p id="34d6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">放弃现在无用的<code class="du lq lr ls lh b">value</code>专栏。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="612c" class="ll jj hi lh b fi lm ln l lo lp">df.drop(columns=["value"], inplace=True)</span></pre><p id="e9e9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">标准的日期索引操作。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8fc0" class="ll jj hi lh b fi lm ln l lo lp">df.dateTime = pd.to_datetime(df.dateTime)<br/>df.set_index("dateTime", drop=True, inplace=True)<br/>df.sort_index(inplace=True)</span></pre><p id="e8cc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">看看你的数据框，我们已经对它做了一些手术。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="729b" class="ll jj hi lh b fi lm ln l lo lp">df.head()</span></pre><p id="56fb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">此时，我们已经有了一个日期时间索引，其中的数据从最早的到最新的排序，所有感兴趣的数据都在它自己的专用列中。现在是时候想象了。</p><h1 id="5948" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">绘图和可视化</h1><p id="05a3" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ki kj iw ix kk kl ja jb km kn je jf jg hb bi translated">最简单的绘图方法之一是将整个数据帧传递给Seaborn的“lineplot”方法。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="f6c0" class="ll jj hi lh b fi lm ln l lo lp">import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from pandas.plotting import register_matplotlib_converters</span><span id="327b" class="ll jj hi lh b fi lt ln l lo lp">%matplotlib inline</span><span id="3b5d" class="ll jj hi lh b fi lt ln l lo lp">register_matplotlib_converters()<br/>sns.set()</span><span id="1967" class="ll jj hi lh b fi lt ln l lo lp">fig, ax = plt.subplots(figsize=(18,10))<br/>sns.lineplot(ax=ax, data=df)</span></pre><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lu"><img src="../Images/624bf7b82e5ef21c7d94a77236451255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wiUY1wTU9GKXpiV8NzbdAw.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">使用sns.lineplot()的简单绘图</figcaption></figure><p id="8165" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">这对于在图表上快速获取我们的数据非常有用。我们可以看到<code class="du lq lr ls lh b">demographicVO2Max</code>和<code class="du lq lr ls lh b">filteredDemographicVO2Max</code>都在45–50的范围内徘徊，而<code class="du lq lr ls lh b">demographicVO2MaxError</code>和<code class="du lq lr ls lh b">filteredDemographicVO2MaxError</code>列或多或少都是小于5的常量值。</p><p id="7291" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">但这并不是非常有用，因为我们实际上想对我们的数据做些什么，比如说，趋势分析。</p><p id="e0f4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">要做到这一点，我们需要放大一点，更好地理解这些值是如何随时间变化的。</p><p id="dcf2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">由于错误列基本上是常量，我不确定“过滤”值是什么意思，让我们放大<code class="du lq lr ls lh b">demographicVO2Max</code>数据，看看我们会发现什么。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7363" class="ll jj hi lh b fi lm ln l lo lp">sns.lineplot(df.index, df.demographicVO2Max)</span></pre><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mg"><img src="../Images/fee999d0010f2ffc16343ad14d600cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gxcBZUoAJ52u39Q3e7RyEg.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">SNS . line plot()on just demographicvo 2 max</figcaption></figure><p id="9e68" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">好吧，这看起来更有趣了。在这一水平上，我们能够对大约2.5年期间的数据变化有所了解。</p><p id="ef71" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">我们使用了一个<code class="du lq lr ls lh b">lineplot</code>来绘制这个图表，但实际上这并不多，事实上，它在某种程度上隐藏了大量蓝色“墨水”背后的潜在数据——如果你愿意的话。</p><p id="853c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">Seaborn的<code class="du lq lr ls lh b">scatterplot</code>去掉了这些线条。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="25dd" class="ll jj hi lh b fi lm ln l lo lp">sns.scatterplot(df.index, df.demographicVO2Max)</span></pre><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mh"><img src="../Images/ca4adab4ca687445fd688deef2565af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KP3Ie2cN9V0eeOa1mmmAfg.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">demographicVO2Max的sns.scatterplot()</figcaption></figure><p id="88c3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">哇哦。那里发生了什么事？为什么我们所有的数据都挤在图表的右边？</p><p id="64f2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">这里的技巧与matplotlib的<code class="du lq lr ls lh b">scatter</code>方法有关。在幕后，Seaborn调用这个方法来绘制传递给<code class="du lq lr ls lh b">scatterplot</code>的数据。默认情况下，该方法不能很好地处理日期。你可以在这里阅读更多关于这个<a class="ae jh" href="https://github.com/mwaskom/seaborn/issues/1641" rel="noopener ugc nofollow" target="_blank">的内容</a>。</p><p id="b843" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">总之，我们需要从Seaborn转到matplotlib的<code class="du lq lr ls lh b">plot_date</code>方法来适当地处理这个问题。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="56ac" class="ll jj hi lh b fi lm ln l lo lp">fig, ax = plt.subplots(figsize=(18,10))<br/>ax.plot_date(df.index, df.demographicVO2Max)</span></pre><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mi"><img src="../Images/bb86d3ffefb85ddca2420bf1cf511262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOXr0z9zSyPwXxSv6XgTpQ.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">matplotlib在demographicVO2Max上的plot_date()方法</figcaption></figure><p id="6a47" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">看起来好多了。现在我们可以开始看看这些数据告诉我们什么。下一步:趋势！</p><h1 id="6d42" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">趋势</h1><p id="513f" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ki kj iw ix kk kl ja jb km kn je jf jg hb bi translated">趋势是一个巨大的话题。我的时间有限，你们的注意力也有限，所以在这篇文章中，我将只关注一种趋势数据的方法。</p><p id="32ea" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">一般来说，对数据集进行“趋势分析”是将数据集拟合为直线或曲线的过程，目的是为了进行预测或获得数据的一般意义。我们的目标是后者。</p><h2 id="3bdf" class="ll jj hi bd jk mj mk ml jo mm mn mo js ki mp mq jw kk mr ms ka km mt mu ke mv bi translated">线性回归</h2><p id="7206" class="pw-post-body-paragraph ii ij hi il b im kg io ip iq kh is it ki kj iw ix kk kl ja jb km kn je jf jg hb bi translated">本质上，线性回归是将数据集缩减(回归)到一条简单直线的过程。</p><blockquote class="if ig ih"><p id="f3e7" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">附注:线性回归可能不是该数据集的最佳模型，因为序列点是自相关的。然而，因为我们不打算用它来预测，所以它仍然是一种有效的方法来得到一条线来绘制我们的数据。</p></blockquote><p id="9cb9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">从代数上回忆一下，一条线可以表示为:<em class="ik">y</em>=<em class="ik">MX</em>+<em class="ik">b .</em>其中<em class="ik"> m </em>为斜率，<em class="ik"> b </em>为<em class="ik">y</em>-截距<em class="ik">。</em>一旦确定了<em class="ik"> m </em>和<em class="ik"> b </em>，我们就可以得到一个<em class="ik"> y </em>给我们传入<em class="ik">的任意一个<em class="ik"> x </em>。</em></p><p id="5b33" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">用于线性回归的最流行的Python库是<code class="du lq lr ls lh b">sklearn</code>。要在我们的心脏健康数据上生成<em class="ik"> m </em>和<em class="ik"> b </em>，运行:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="629c" class="ll jj hi lh b fi lm ln l lo lp">import numpy as np<br/>from sklearn import linear_model</span><span id="5029" class="ll jj hi lh b fi lt ln l lo lp">reg = linear_model.LinearRegression()<br/>X = np.array(list(range(len(df.index.values)))).reshape(-1,1)<br/>y = df.demographicVO2Max.values.reshape(-1,1)<br/>reg.fit(X, y)</span></pre><p id="7abf" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">运行<code class="du lq lr ls lh b">reg.fit(X, y)</code>后。<code class="du lq lr ls lh b">reg</code>对象包含了我们要寻找的<em class="ik"> m </em>和<em class="ik"> b </em>值。<em class="ik"> m </em>简称<code class="du lq lr ls lh b">coef</code>，因为是<em class="ik"> y- </em>截距，所以在<em class="ik"> x的系数中，b </em>简称<code class="du lq lr ls lh b">intercept</code>。这些变量都有尾随下划线，如下所示:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="16ff" class="ll jj hi lh b fi lm ln l lo lp">print(reg.coef_)<br/>print(reg.intercept_)</span><span id="5f82" class="ll jj hi lh b fi lt ln l lo lp">[[0.00139158]]<br/>[46.58244957]</span></pre><p id="bf70" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">为了了解这条线的样子，我们可以使用下面的函数创建一条简单的线来绘制。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="e69d" class="ll jj hi lh b fi lm ln l lo lp">def make_line(slope, intercept, start_x, end_x):<br/>    x_vals = np.array((start_x, end_x))<br/>    y_vals = intercept + slope * x_vals<br/>    return x_vals, y_vals</span><span id="cfb6" class="ll jj hi lh b fi lt ln l lo lp">line = make_line(reg.coef_[0][0], reg.intercept_[0], 0, 834)</span></pre><p id="01de" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">“线”只是两组数组，我们现在可以将它们传递给matplotlib进行绘制。为什么是834？这就是我的心脏健康数据中有多少个数据点，0偏移减1。你可以看到你的有多少。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="665b" class="ll jj hi lh b fi lm ln l lo lp">df.shape</span></pre><p id="a002" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">对我来说，这给出了<code class="du lq lr ls lh b">(835, 4)</code>，因为我的数据帧中有835行和4列。不是这样，虽然我们的原始数据集有835行，但是我们传递给<code class="du lq lr ls lh b">plt.plot</code>的数组只有两个元素，分别代表行的左下和右上。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b14f" class="ll jj hi lh b fi lm ln l lo lp">plt.plot(*line)</span></pre><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mw"><img src="../Images/4e5979e4df69c53e47b0ae283e5df61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C0WpQw93lQX5MGlj-N8fIw.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">我们的趋势线</figcaption></figure><p id="e8b6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">回想一下，我们的数据分散在~44和~50之间，并且似乎有略微上升的趋势。这个情节反映了这一点。我们的数据已经“回归”到一条简单的直线上。</p><p id="900a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">最后，让我们在分散的数据旁边画一条线。我们已经知道如何让我们分散的数据显示出来，我们可以单独绘制我们的线。</p><p id="038a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">为了沿着分散的数据绘图，我们需要获得一个与分散的数据具有相同形状和类型的序列。在这种情况下，这意味着我们需要一个形状为<code class="du lq lr ls lh b">835,1</code>的时间戳X轴和一个形状相同的Y轴值。为了获得Y轴的值，我们将直线公式应用于我们之前为线性回归创建的X系列中的每个点。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="ca2d" class="ll jj hi lh b fi lm ln l lo lp">Y_vals = reg.intercept_[0] + (reg.coef_[0][0] * np.array(X))</span></pre><p id="0542" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">为了绘图，我们使用和以前一样的<code class="du lq lr ls lh b">plot_date</code>，但是增加了一个额外的<code class="du lq lr ls lh b">ax.plot</code>，传入了<code class="du lq lr ls lh b">df.index</code>和<code class="du lq lr ls lh b">Y_vals</code>。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5f20" class="ll jj hi lh b fi lm ln l lo lp">fig, ax = plt.subplots(figsize=(18,10))<br/>ax.plot_date(df.index, df.demographicVO2Max)<br/>ax.plot(df.index, Y_vals)</span></pre><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mx"><img src="../Images/ba1d742de5dcc3cd20514c7cf76cbd5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2oC_rHd28eW7bc7ijBwHqg.png"/></div></div></figure><p id="d81e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">现在平坦的区域发生了什么？最引人注目的是2018年8-10月左右的现货。当然，我也有不戴FitBit的时候。我的数据是从2017年4月1日到2019年9月28日。要找出数据跨度有多少天，可以使用这个简单的公式。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="30d0" class="ll jj hi lh b fi lm ln l lo lp">(df.index[-1] - df.index[0]).days</span></pre><p id="ba9b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">对我来说，这就是910。回想一下，我的数据帧有835个数据点。所以我的数据集中有75天不见了。绘制时，这些间隙用一条简单的线连接在一起。对于较大的间隙，这导致一条平坦的线。</p><p id="8acf" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ki iv iw ix kk iz ja jb km jd je jf jg hb bi translated">暂时就这样吧！</p></div></div>    
</body>
</html>