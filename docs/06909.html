<html>
<head>
<title>ML Pipelines using scikit-learn and GridSearchCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用scikit-learn和GridSearchCV的ML管道</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/ml-pipelines-using-scikit-learn-and-gridsearchcv-fe605a7f9e05?source=collection_archive---------3-----------------------#2020-06-07">https://medium.com/analytics-vidhya/ml-pipelines-using-scikit-learn-and-gridsearchcv-fe605a7f9e05?source=collection_archive---------3-----------------------#2020-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="4f8f" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">sci kit-学习管道和交叉验证</h2><div class=""/><div class=""><h2 id="85a7" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">使用管道管理ML工作流并使用GridSearch交叉验证技术进行参数调整</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/aa1bd42a158b8ca4243fccc3d7c1529e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fu3k2qVlZHxGwY4dH9xJgA.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">图片来自U<a class="ae jw" href="http://www.unsplash.com" rel="noopener ugc nofollow" target="_blank">n flash</a></figcaption></figure><blockquote class="jx jy jz"><p id="6778" class="ka kb kc kd b ke kf is kg kh ki iv kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">ML计算和算法通常处理大量信息。管道是一种按照需要以有组织的方式链接那些信息处理企业的方法。不仅如此，它同样有助于制作令人难以置信的工作流程和可复制的代码。</p></blockquote><h1 id="cc3b" class="kx ky hi bd kz la lb lc ld le lf lg lh ix li iy lj ja lk jb ll jd lm je ln lo bi translated">什么是ML管道？</h1><p id="5dc3" class="pw-post-body-paragraph ka kb hi kd b ke lp is kg kh lq iv kj lr ls km kn lt lu kq kr lv lw ku kv kw hb bi translated">管道是信息更改的一系列步骤。它源于“管道和过滤器”计划设计。通过这种方式，您可以为每个过滤器创建一个类，然后创建另一个类来将这些方法连接到管道中，形成一个完整的最终管道。</p><h1 id="0857" class="kx ky hi bd kz la lb lc ld le lf lg lh ix li iy lj ja lk jb ll jd lm je ln lo bi translated">Scikit-Learn管道的方法</h1><p id="c09b" class="pw-post-body-paragraph ka kb hi kd b ke lp is kg kh lq iv kj lr ls km kn lt lu kq kr lv lw ku kv kw hb bi translated">管道<strong class="kd hs">必须有那两种方法</strong>:</p><ul class=""><li id="3752" class="lx ly hi kd b ke kf kh ki lr lz lt ma lv mb kw mc md me mf bi translated">“适合”一词是指对数据进行学习并获取其状态</li><li id="d254" class="lx ly hi kd b ke mg kh mh lr mi lt mj lv mk kw mc md me mf bi translated">单词“transform”(或“predict”)实际处理数据并生成预测。</li></ul><p id="8536" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">也可以调用这个方法或者将两者都链接起来:</p><ul class=""><li id="f5e9" class="lx ly hi kd b ke kf kh ki lr lz lt ma lv mb kw mc md me mf bi translated">单词“fit_transform”是拟合然后转换数据，但这一切都是一步完成的，当这两种方法必须同时进行时，这允许很好的代码优化。</li></ul><p id="e3fc" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">首先，我们将定义模型管道，然后我们进行网格搜索交叉验证技术，为我们的问题陈述找到最佳模型。</p><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="4678" class="mq ky hi mm b fi mr ms l mt mu">import pandas as pd<br/>import numpy as np<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>from sklearn.feature_extraction.text import CountVectorizer<br/>from sklearn import feature_extraction, linear_model, model_selection, preprocessing<br/>from sklearn.metrics import accuracy_score<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.linear_model import LogisticRegression<br/></span></pre><p id="670a" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">在这里，我使用来自kaggle的bbc新闻数据集来建造管道。</p><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="9152" class="mq ky hi mm b fi mr ms l mt mu">news=pd.read_csv(‘bbc-text.csv’)<br/>news.head()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mv"><img src="../Images/c112c17df74aba8684c54913af102088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*hpQNw6mSGOcWKqRcI1YWBw.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">抽样资料</figcaption></figure><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="ca1c" class="mq ky hi mm b fi mr ms l mt mu">news[‘category’].value_counts()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mw"><img src="../Images/e9c780aa1cfdffe1bdcc04acebfca7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*N5wSByoEzhtVdc_hSvJNXQ.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">每个类别的值计数</figcaption></figure><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="4a30" class="mq ky hi mm b fi mr ms l mt mu">sns.countplot(x=”category”, data=news)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mx"><img src="../Images/b95c974b220dbe9068962f1b1efc12c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*gUOjH03fjb9VBBXHO-MFCw.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">每个类别的绘图</figcaption></figure><h1 id="aa42" class="kx ky hi bd kz la lb lc ld le lf lg lh ix li iy lj ja lk jb ll jd lm je ln lo bi translated">逻辑回归分类器</h1><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="ae5c" class="mq ky hi mm b fi mr ms l mt mu">x_train,x_test,y_train,y_test = train_test_split(news[‘text’], news.category, test_size=0.2, random_state=2020)</span><span id="5b1f" class="mq ky hi mm b fi my ms l mt mu">pipe_lr = Pipeline([(‘vect’, CountVectorizer()),<br/> (‘tfidf’, TfidfTransformer()),<br/> (‘model’, LogisticRegression())])</span><span id="75f5" class="mq ky hi mm b fi my ms l mt mu">model = pipe_lr.fit(x_train, y_train)<br/>prediction = model.predict(x_test)<br/>print(“\naccuracy: {}%”.format(round(accuracy_score(y_test, prediction)*100,2)))</span><span id="d373" class="mq ky hi mm b fi my ms l mt mu">print('\n',confusion_matrix(y_test, prediction))</span><span id="8ab3" class="mq ky hi mm b fi my ms l mt mu">print('\n',classification_report(y_test, prediction))</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mz"><img src="../Images/352409040b49261bb9fe2ff1a0ec44f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*bSsV6CxPUlghdBMA1z_73g.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">模型的完整报告</figcaption></figure><p id="b87d" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">我们从scikit-learn库导入了管道。在流水线中，我们可以定义必须按顺序执行的功能。在这里，我们首先将我们的数据分成train，使用train_test_split进行测试。</p><p id="79b9" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">然后，我们在管道中按顺序定义了计数矢量器、Tf-Idf、逻辑回归。这种方式减少了代码量，并且将模型流水线化有助于将它与不同的模型进行比较，并获得我们选择的最佳模型。</p><p id="4ff5" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">同样，让我们用相同的数据作为输入，为不同的模型创建管道，并从所有模型中选择最佳模型。</p><p id="d182" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated"><strong class="kd hs">创建不同的管道:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="49bb" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">在上面的代码中，我为四个不同的模型构建了四个管道。</p><ol class=""><li id="c1b5" class="lx ly hi kd b ke kf kh ki lr lz lt ma lv mb kw nc md me mf bi translated">逻辑回归</li><li id="329a" class="lx ly hi kd b ke mg kh mh lr mi lt mj lv mk kw nc md me mf bi translated">决策图表</li><li id="cd6e" class="lx ly hi kd b ke mg kh mh lr mi lt mj lv mk kw nc md me mf bi translated">随机森林</li><li id="9a33" class="lx ly hi kd b ke mg kh mh lr mi lt mj lv mk kw nc md me mf bi translated">支持向量机</li></ol><p id="b29d" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">您完全可以改变单一管道的架构。例如，在逻辑回归中，如果您觉得目标值需要缩放，您可以使用标准缩放器，或者您完全可以使用一些预处理技术。</p><p id="8420" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">让我们假设一种需要预处理的情况，以及如何处理这种情况。</p><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="0814" class="mq ky hi mm b fi mr ms l mt mu">from sklearn.pipeline import Pipeline<br/>from sklearn.impute import SimpleImputer<br/>from sklearn.preprocessing import StandardScaler, OneHotEncoder</span><span id="2585" class="mq ky hi mm b fi my ms l mt mu">num_transformer = Pipeline([('imputer',SimpleImputer(strategy='mean')),<br/>    ('scaler', StandardScaler())])</span><span id="e7df" class="mq ky hi mm b fi my ms l mt mu">cat_transformer = Pipeline([<br/>    ('imputer', SimpleImputer(strategy='constant', fill_value='missing')),('onehot',OneHotEncoder(handle_unknown='ignore'))])</span></pre><p id="5ced" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">因此，我创建了两个单独的管道来处理不同类型的数据，即num_transformer使用简单的估算器处理缺失的数字，而标准缩放器将转换您的数据，使其分布的平均值为0，标准差为1。</p><p id="787f" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">在cat_transformer中，我使用了简单的输入器和一个热编码器来对类别进行编码。</p><p id="bbec" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">现在让我们采用数字特征以及分类特征的列，并应用上述预处理步骤的流水线。为此，我采用train_data并选择特定的列，如下所示。</p><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="ec54" class="mq ky hi mm b fi mr ms l mt mu">num_features = train_data.select_dtypes(include=[‘int64’).columns<br/>cat_features = train_data.select_dtypes(include=[‘object’]).columns</span></pre><p id="bd52" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">一旦我们准备好了，我们现在可以把所有的东西都推到我们的列转换器中，它可以从sklearn.compose导入</p><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="f3cb" class="mq ky hi mm b fi mr ms l mt mu"><br/>from sklearn.compose import ColumnTransformer</span><span id="5876" class="mq ky hi mm b fi my ms l mt mu">preprocessor = ColumnTransformer([<br/>        ('num', num_transformer, num_features),<br/>        ('cat', cat_transformer, cat_features)])</span></pre><p id="480a" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">与上面不同的是，我在一个步骤中完成了所有的预处理，可以用于多个模型。</p><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="5add" class="mq ky hi mm b fi mr ms l mt mu">pipe_rf = Pipeline([(‘preprocess’,preprocessor),<br/> (‘clf’, RandomForestClassifier(random_state=42))])</span></pre><p id="db4b" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">现在让我们使用GridSearchCV来拟合模型，GridSearchCV通过为每个管道传递许多不同的参数来帮助我们进行模型选择，并获得最佳模型以及模型拟合使用的最佳参数。因此，让我们从定义网格搜索的一些参数开始。</p><p id="b6f4" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">线性回归默认采用l2罚分，所以我想用l1罚分进行实验。类似地，对于选择标准中的随机森林，我可能想对“基尼”和“熵”进行实验。所以我将这两个值都传递给了clf_criterion</p><p id="721b" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">您还可以针对特定的问题陈述和用例，在您选择的不同内核上进行实验。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="2936" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">输出:</p><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="0d96" class="mq ky hi mm b fi mr ms l mt mu">Performing model optimizations...<br/><br/>Estimator: Logistic Regression<br/>Best params: {'clf__C': 1.0, 'clf__penalty': 'l2', 'clf__solver': 'liblinear'}<br/>Best training accuracy: 0.969<br/>Test set accuracy score for best params: 0.966 <br/><br/>Estimator: Random Forest<br/>Best params: {'clf__criterion': 'gini', 'clf__max_depth': 10, 'clf__min_samples_split': 10}<br/>Best training accuracy: 0.844<br/>Test set accuracy score for best params: 0.836 <br/><br/>Estimator: Support Vector Machine<br/>Best params: {'clf__C': 9, 'clf__kernel': 'linear'}<br/>Best training accuracy: 0.978<br/>Test set accuracy score for best params: 0.971 <br/><br/>Classifier with best test set accuracy: Support Vector Machine<br/><br/>Saved Support Vector Machine grid search pipeline to file: best_grid_search_pipeline.pkl</span></pre><p id="f3b0" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">现在，我比较了逻辑回归、随机森林和SVM，我可以肯定地看到，SVM是最好的模型，精确度为0.978。我们还通过网格搜索交叉验证获得了最佳参数。</p><p id="f2e2" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">所以我把准确率作为一个评分参数。完全基于问题陈述。您可以将评分参数作为完全来自混淆矩阵的回忆或f1分数或精确度</p><p id="b9c7" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">最后，网格搜索为指定的每个超参数组合建立一个模型，并评估每个模型。另一种有效的超参数调整技术是随机搜索，其中超参数的随机组合用于找到最佳解决方案。</p><p id="a039" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">混淆矩阵和评分参数可以从下图中理解。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nd"><img src="../Images/7a4ba161ff86fbb66fa8da4438ff051a.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*BTB9weIUfSsSRy5kvh_-uA.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">困惑矩阵(图片由作者提供)</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ne"><img src="../Images/0f218fab8b945b69cc41020f287c6021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*eqWZ6rOCUl0ntHokbUrUTQ.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">评分参数(图片由作者提供)</figcaption></figure><p id="b110" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">您可以定义自己的自定义转换器，其中应该明确包含fit和transform方法。</p><p id="c5d3" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">瞧，给你。现在，您可以尝试构建自己的机器学习管道，并且不要忘记尝试定制转换器。还要更改网格搜索中的参数并运行实验。学习任何东西的最好方法是通过实验。</p><p id="632c" class="pw-post-body-paragraph ka kb hi kd b ke kf is kg kh ki iv kj lr kl km kn lt kp kq kr lv kt ku kv kw hb bi translated">我希望这篇文章能增强你的知识。继续支持，快乐学习。</p><div class="nf ng ez fb nh ni"><a href="https://www.linkedin.com/in/nikhil-pentapalli-5744bb18b/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="bd hs fi z dy nn ea eb no ed ef hr bi translated">Nikhil Pentapalli -数据科学家||机器学习工程师- Jio平台有限公司| LinkedIn</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">真实世界人工智能产品制造经验。-&gt;在将实际问题转化为需求和解决方案方面经验丰富…</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">www.linkedin.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jq ni"/></div></div></a></div></div></div>    
</body>
</html>