<html>
<head>
<title>Google Quest Challenge Q/A Labelling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Quest挑战问答标签</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/google-quest-challenge-q-a-labelling-9df4aff317d5?source=collection_archive---------28-----------------------#2020-07-15">https://medium.com/analytics-vidhya/google-quest-challenge-q-a-labelling-9df4aff317d5?source=collection_archive---------28-----------------------#2020-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="93e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">业务问题:</strong></p><p id="52fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算机非常擅长用单一的、可验证的答案来回答问题。但是，人类通常更善于回答关于观点、建议或个人经历的问题。</p><p id="7513" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">人类更擅长解决需要对背景有更深层次、多维度理解的主观问题——这是计算机还没有训练好的……目前为止..问题可以有多种形式——有些是多句子的阐述，有些可能是简单的好奇或者是一个完全成熟的问题。他们可以有多种意图，或者寻求建议和意见。有些可能是有帮助的，有些可能是有趣的。有些是简单的对错。</p><p id="c025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题陈述概述:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/346e74f0a091e6fd6ea5d74a08d8f730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjy-2wYtuaIX8RsvueHyLQ.png"/></div></div></figure><ol class=""><li id="0340" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">当谈到问题和答案时，人类有不同的理解和回答问题的方式。在本案例研究中，我们将借助顶级网站的(问答)数据集来理解相同的内容。</li><li id="9d53" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">人类有独特的方式来回答任何问题。我们首先理解问题，问题背后的直觉，问题的意义等等。机器就不同了。</li><li id="4533" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在这个问题中，我们将借助来自不同网站的问答数据集来帮助机器理解问题的这些方面。</li><li id="bb4b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在我们的数据集中，我们有30个不同方面的问答，如“问题_对话”、“问题_正文_关键”、“回答_有用”等。</li><li id="4411" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我们的目标是在训练数据集的帮助下找到这些方面的分数。在我们的训练数据集中，我们在[0，1]的范围内具有与这些标签中的每一个相关联的分数。我们将让我们的模型学习这些方面，并尝试对我们的测试数据集进行同样的评估。</li></ol><p id="07d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据来源:</strong></p><p id="97b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此竞赛的数据包括来自各种StackExchange属性的问题和答案。我们的任务是为每个问答配对预测30个标签的目标值。</p><p id="0893" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">30个目标标签的列表与sample_submission.csv文件中的列名相同。前缀为question_的目标标注与数据中的question_title和/或question_body要素相关。前缀为answer_relate的目标标注与答案要素相关。</p><p id="fd90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每一行包含一个问题和该问题的一个答案，以及附加功能。训练数据包含带有一些重复问题(但答案不同)的行。测试数据不包含任何重复的问题。</p><p id="ac25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是二元预测挑战。目标标签由多名评核人汇总而成，可以具有范围[0，1]内的连续值。因此，预测也必须在该范围内。</p><p id="fc0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以从这里下载数据集:<a class="ae kd" href="https://www.kaggle.com/c/google-quest-challenge/data" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">https://www.kaggle.com/c/google-quest-challenge/data</strong></a></p><p id="e0ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现有解决方案&amp;思路:</strong></p><p id="1939" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个挑战中，我们必须找出30个不同目标变量的值。这是一个回归问题，我们的预测值介于0和1之间。由于我们有文本数据和几个类别作为输入，最好的方法之一是使用预单词嵌入，然后找到标签。</p><p id="dc49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为这是一个难题，所以很少有内核使用最先进的模型，如通用语句编码器、Al-BERT、Ro-bert、BERT等。</p><ol class=""><li id="23db" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><strong class="ih hj">基于BERT的方法:</strong></li></ol><div class="ke kf ez fb kg kh"><a href="https://www.kaggle.com/akensert/quest-bert-base-tf2-0" rel="noopener  ugc nofollow" target="_blank"><div class="ki ab dw"><div class="kj ab kk cl cj kl"><h2 class="bd hj fi z dy km ea eb kn ed ef hh bi translated">[任务]伯特基础TF2.0</h2><div class="ko l"><h3 class="bd b fi z dy km ea eb kn ed ef dx translated">使用Kaggle笔记本探索和运行机器学习代码|使用来自多个数据源的数据</h3></div><div class="kp l"><p class="bd b fp z dy km ea eb kn ed ef dx translated">www.kaggle.com</p></div></div><div class="kq l"><div class="kr l ks kt ku kq kv jn kh"/></div></div></a></div><p id="5a52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该解决方案使用基于BERT的方法，给出了良好的结果，得到的相关分数为:0.382</p><p id="fda1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">通用语句编码器Keras </strong>:</p><div class="ke kf ez fb kg kh"><a href="https://www.kaggle.com/abazdyrev/use-features-oof" rel="noopener  ugc nofollow" target="_blank"><div class="ki ab dw"><div class="kj ab kk cl cj kl"><h2 class="bd hj fi z dy km ea eb kn ed ef hh bi translated">使用+功能+ OOF</h2><div class="ko l"><h3 class="bd b fi z dy km ea eb kn ed ef dx translated">使用Kaggle笔记本探索和运行机器学习代码|使用来自多个数据源的数据</h3></div><div class="kp l"><p class="bd b fp z dy km ea eb kn ed ef dx translated">www.kaggle.com</p></div></div><div class="kq l"><div class="kw l ks kt ku kq kv jn kh"/></div></div></a></div><p id="c5b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个模型中，作者使用了使用模型中的单词嵌入，得到了大约0.32的spearman相关结果</p><p id="429d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.罗伯塔:</p><div class="ke kf ez fb kg kh"><a href="https://www.kaggle.com/melissarajaram/roberta-fastai-huggingface-transformers" rel="noopener  ugc nofollow" target="_blank"><div class="ki ab dw"><div class="kj ab kk cl cj kl"><h2 class="bd hj fi z dy km ea eb kn ed ef hh bi translated">罗伯塔[法斯泰，拥抱脸🤗变形金刚]</h2><div class="ko l"><h3 class="bd b fi z dy km ea eb kn ed ef dx translated">使用Kaggle笔记本探索和运行机器学习代码|使用来自多个数据源的数据</h3></div><div class="kp l"><p class="bd b fp z dy km ea eb kn ed ef dx translated">www.kaggle.com</p></div></div><div class="kq l"><div class="kx l ks kt ku kq kv jn kh"/></div></div></a></div><p id="907b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里作者使用Ro-BERTa并得到0.352左右的相关分数。</p><p id="107b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的三个解决方案中，我们得到一个想法，我们可能必须使用预训练的模型来获得单词嵌入。在这里，我们正在寻找问题和答案背后的关系和直觉。因此，决定哪个模型表现最好或者应该使用哪个模型的只是需求和模型构建部分的问题。</p><p id="b33e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，更重要的是理解为什么选择特定的模型并进行误差分析。我们将使用一个预先训练的模型来解决这个问题，并进行误差分析，看看我们是否可以识别任何类型的模式，并进一步尝试改善结果。</p><p id="2863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们现有解决方案的方法:</strong></p><p id="5eaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与其直接跳到预先训练好的模型，不如让我们先试着确定，我们是否真的需要它们，以及我们为什么需要它们。因此，我们将首先从使用LSTM层的基线模型开始，看看我们的模型表现如何。</p><p id="2b01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将激励我们使用预先训练好的模型之一:</p><p id="4801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从数据集的探索性数据分析开始，并尝试理解数据集。</p><p id="7a47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">训练数据集:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ky"><img src="../Images/cb0cd11bebcdf912c73b216f9359916e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtnmBngm2a2yKK8HL2FdOA.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">训练数据集</figcaption></figure><p id="accf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">训练数据集中的所有列:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ld"><img src="../Images/b90cb3f8723c3cfe794ddee38e096732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*2BDXNGoTjsstwRnWbprB1Q.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">我们的训练数据中有41列</figcaption></figure><p id="20ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">测试数据集:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es le"><img src="../Images/ce82d367ab9d0cb96878614f9b12f309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZIxBw7VF7YhGTJq4MWvgaQ.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">测试数据集的头</figcaption></figure><p id="da55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">测试数据集中的所有列:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lf"><img src="../Images/fbad1043607d3b377167ae291389ce61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*MX61bA-g_udpLgW4odtB4w.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">测试数据集中有11列</figcaption></figure><p id="012e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们必须预测训练数据中的30个目标标签。我们的数据集中有三个文本字段，即“<strong class="ih hj"> <em class="lg">问题_正文</em> </strong>”、“<strong class="ih hj"> <em class="lg">问题_标题</em> </strong>”和“<strong class="ih hj"> <em class="lg">答案</em> </strong>”。除此之外，我们的数据集中还有分类特征。在所有可用的分类特征中，让我们看看“<strong class="ih hj"> <em class="lg">宿主</em> </strong>”和“<strong class="ih hj"> <em class="lg">类别</em> </strong>”是否有某种模式。</p><p id="c1cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">类别分布:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lh"><img src="../Images/bdf801c2043f9198c6262058b3bc16e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*vNDMNcAQyulOZoFytn6KIw.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">列车数据中类别的分布</figcaption></figure><p id="708f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，我们的大部分数据来自技术领域。</p><p id="7a75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">宿主分布:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es li"><img src="../Images/59c40045d2d704ff8415aad9d63261ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpUVBWzKJ2WED--T02n7NA.png"/></div></div></figure><p id="5b03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们的大多数数据点，stackoverflow.com是主机。这很有意义，因为这里通常人们会问与新技术相关的问题，而我们的大部分数据都是关于技术的。</p><p id="44d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">目标变量关系:</strong></p><p id="dbe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们必须预测大约30个目标变量的值。因此，让我们看看这些目标之间是否存在任何关系。这将帮助我们更好地理解我们的模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/d13346f08a0fd66ade5b19d4ea2462f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXXnQ4uiGtFuiGmOkllmUA.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">代码片段</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/0e0761087d4b5018e042ac5234710897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tAhgHkzh7OuX_5Z-z_DKg.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">目标变量配对图</figcaption></figure><p id="5898" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与上面的输出一样，我们将得到所有30个目标变量的输出。这些目标变量之间没有太大的关系。因此，我们必须单独预测它们，因为没有办法从另一个中推断出一个的值。</p><p id="207d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有关更详细的解释和完整的代码访问，请参考下面的链接。</p><div class="ke kf ez fb kg kh"><a href="https://github.com/mansi2596/Kaggle-Google-Quest-Challege/upload/master" rel="noopener  ugc nofollow" target="_blank"><div class="ki ab dw"><div class="kj ab kk cl cj kl"><h2 class="bd hj fi z dy km ea eb kn ed ef hh bi translated">mansi 2596/ka ggle-Google-Quest-Challege</h2><div class="ko l"><h3 class="bd b fi z dy km ea eb kn ed ef dx translated">计算机非常擅长用单一的、可验证的答案来回答问题。但是，人类通常更擅长…</h3></div><div class="kp l"><p class="bd b fp z dy km ea eb kn ed ef dx translated">github.com</p></div></div><div class="kq l"><div class="ll l ks kt ku kq kv jn kh"/></div></div></a></div><p id="065b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">字云:</strong></p><p id="9717" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们来看看所有三种文本特征的单词在我们的训练数据集中的分布，并看看是否有一种模式:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/ba211c014031cdfb1e342ec3f1e42482.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*HhWmohOUn1Jed-Mi8htnCQ.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ln"><img src="../Images/bc88cbc599eb74fc4881159d3cd9f9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*E08uIY4XKnLiwxYgOdprCQ.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lo"><img src="../Images/10925486baa887a6f1e6f8aa5d127039.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*4206dm8IYfbBQDICW4mYcQ.png"/></div></figure><p id="584a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">相关黑白目标变量:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lp"><img src="../Images/fd50f16964496402698a9d06d3a1cf61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*Xy1OeTHe5OdjVjS65aze4Q.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">目标变量相关性</figcaption></figure><p id="0a21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经完成了EDA部分，让我们来训练第一个基线模型。在给出输入之前，我们对文本特征做了一些过滤。这包括将<strong class="ih hj"> <em class="lg">不能</em> </strong>改为<strong class="ih hj"> <em class="lg">不能</em> </strong>，<strong class="ih hj"> <em class="lg">不会</em> </strong>改为<strong class="ih hj"> <em class="lg">不会</em> </strong>等等。你可以在上面提到的github链接上查看相同的内容。</p><p id="bf27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">训练我们的基线模型:</strong></p><p id="ef8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们在LSTM层的帮助下创建了一个简单的神经网络。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/cff132081341cfef3841b535e885ba64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHeO-7M0a6bJWytXw7ubfw.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">基线模型的张量流代码</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lr"><img src="../Images/10362c5cb1d7b4757ca50756ff076f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*6EWbMuZMWMI0wpTcmaEymg.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">模型摘要</figcaption></figure><p id="c177" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们训练和运行这个模型时，在几个时期之后，我们的模型停止学习，因为分数没有提高:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ls"><img src="../Images/151b6dfa41923cd6153efe6da53f163f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*2e2Lb8PpwZf2yhxhhoz_3w.png"/></div></figure><p id="f7b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这表明我们的模型表现不好，因此，我们切换到预先训练的模型。现在，我们训练的任何模型都应该比这个模型表现得更好。这个基线模型给了我们一个必须得到的分数的想法。</p><p id="a34c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用通用语句编码器:</strong></p><p id="830b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们使用USE来训练我们的模型。这是一个预先训练好的模型。这将为我们所有的数据点提供单词嵌入。然后这些嵌入我们将在一个简单的网络中得到结果。让我们看看这个模型是如何为我们工作的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lt"><img src="../Images/1cf1de247b78cf56b8bf22f67ed23cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSKm8vtNIgRycBChXJG3Gw.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">模型架构的代码截取</figcaption></figure><p id="f65b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们有三种不同的输入，分别为<strong class="ih hj"> <em class="lg">问题_标题</em> </strong>，<strong class="ih hj"> <em class="lg">问题_正文</em> </strong>和<strong class="ih hj"> <em class="lg">答案</em> </strong>。这些输入中的每一个都在USE的帮助下被转换成512维向量。然后我们将其输入一个简单的神经网络。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/cad45f5bcb8cf5c2dd288dc06eb8c0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UXkF9mzCbGswMLeWC5L5tg.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">模型架构</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lv"><img src="../Images/1cac05a9d7ff972dfd92c6322226443c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*ABXGYuz-md9h5eCjKfhk5A.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">模型架构</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lw"><img src="../Images/056734c90715c3123ab580b2aa995ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*Z0LXIxe_WiFSbhH22CPN5w.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">模型训练</figcaption></figure><p id="ff03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们使用这个模型训练时，我们的分数会提高。这肯定比以前好，但它仍然不显得很高，虽然损失相当低。让我们深入研究一下，找出这背后的原因。</p><p id="6f7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">错误分析:</strong></p><p id="d47f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦经过训练，我们必须能够知道，我们的模型何时表现良好，何时表现不佳。误差分析将帮助我们识别模型中的松散部分。让我们看一下做同样事情的基本步骤:</p><p id="b4aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤1: </strong>分别计算每个数据点的损失。确定具有高损失值的数据点，并对其进行分析，寻找可能导致高损失值的模式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lx"><img src="../Images/2c8d7e72225c2b0f2232b9dcd3efa1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*ceWnG7uIX0zJK51Xu4YTZA.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">计算每个数据点的平均绝对误差</figcaption></figure><p id="4a18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步:绘制目标变量的损失图。这里我们有30个目标，因此我们必须为每个目标绘制损失图。这可以使用给定的代码片段来完成:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ly"><img src="../Images/ea6008a53ebfdcdfc76c7dc6df381ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WEVKSSsZmGk6p48GgjUkmg.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">代码片段</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/c5cf40e4f609f340708fb4bbdf0ac5d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*Ka-KYjSZ4Mp5V_G9ed_aGg.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ma"><img src="../Images/996e92e4a083357e16e18523a1d02eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*m5Qd-Qt-PwGT1t7hOPWMOA.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mb"><img src="../Images/668b6577a447134a14efa79daa6400e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*eSHqqm5Q_ExZhzJ3lCqtgg.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/4f0488155428698ac47b234df1bb6827.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*fVH2jdDXit_5Br4d6kVMSA.png"/></div></figure><p id="d052" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的图中，我们注意到，在大多数情况下，我们的损失范围大多在0.0到0.2之间，其中大多数点也仅位于0.0和0.1之间。因此，现在我们将分析这些具有较高损失值的数据点，看看我们能否在其中找到一个模式。</p><p id="d863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来自我们数据集的另一个重要观察结果是，对于目标<strong class="ih hj"> <em class="lg">问题_非_真_问题</em> </strong>来说，损失值非常低，但是相关分数也非常低，大约为0.042。因此，这意味着对于这个特定的目标，我们的模型不能预测正确的值。<strong class="ih hj"><em class="lg">question _ type _ spelling</em></strong>和<strong class="ih hj"><em class="lg">question _ type _ result</em></strong>也是如此。我们可能需要研究它们的分布，以确定为什么会发生这种情况。</p><p id="57b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第三步</strong>:分析行为异常的目标。如上所示，让我们看看损失分数低但相关性很小的值的分布。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es md"><img src="../Images/a210e79550977dbeef35653753df34e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*QQiiUyfZRh7-7BsSlwETcg.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">损失值较少的目标分布</figcaption></figure><p id="47fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，对于这些值，我们所有要预测的标签都是0。因此，即使我们的模型预测正确，两者之间也没有关联。这就是为什么我们会得到如图所示的结果。</p><p id="de8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">观察:</strong></p><p id="f13b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的最终得分中，我们取所有目标变量得分的平均值。这就是为什么我们得到同样的低值，尽管对于许多目标标签，预测值是高的。</p><p id="ecd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，通过很少的误差分析，我们能够发现我们的度量在评估我们的模型时是否有效，以及在什么情况下它失败了。</p><p id="54bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">其他错误分析方法:</strong></p><p id="dbc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了上面提到的，你还可以尝试其他的方法来进一步了解你的模型的表现。</p><ol class=""><li id="9763" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">查看具有高损失值的点的分类分布，并查看是否存在得分较高的类别。对于给定的数据集，您可以对<strong class="ih hj"> <em class="lg">主机</em> </strong>和<strong class="ih hj"> <em class="lg">类别</em> </strong>进行此分析。</li><li id="52e5" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">使用词性标注从我们的数据中导出其他特征，如句子的长度、单词的数量、名词和动词的数量。很多时候<strong class="ih hj"> <em class="lg">命名实体</em> </strong>并没有给模型足够的信息来学习特定的数据点。因此，如果您发现具有高丢失值的数据点具有高频率的命名实体，那么您可以从您的数据集中移除命名实体。</li><li id="066e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">你也可以进行相似性测试。找出数据的文本特征之间的相似性，并查看丢失率较高的数据点的相似性得分是否不同。您可以使用余弦相似性或模糊逻辑来尝试相同的方法。</li></ol><p id="899d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.您还可以检查Tfidf得分，并查看得分值是否出现偏差。</p><p id="73d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面提到的错误分析部分都已经完成了，你可以在github链接中找到。但是在直接跳到代码之前，先自己尝试一下，我打赌你会喜欢的。</p><p id="2a6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">未来工作:</strong></p><ol class=""><li id="0a2e" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">这里我们只使用基于使用的模型。我们可以尝试不同的预训练模型，看看我们的模型在这些模型上表现如何。</li></ol><p id="8fa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献:</strong></p><ol class=""><li id="4ea6" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><a class="ae kd" href="https://www.kaggle.com/abazdyrev/use-features-oof" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/abazdyrev/use-features-oof</a></li><li id="9b4c" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><a class="ae kd" href="https://tfhub.dev/google/universal-sentence-encoder/2" rel="noopener ugc nofollow" target="_blank">https://tfhub.dev/google/universal-sentence-encoder/2</a></li><li id="e0f2" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><a class="ae kd" href="https://arxiv.org/abs/1803.11175" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1803.11175</a></li><li id="4fcc" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><a class="ae kd" href="https://www.appliedaicourse.com/course/11/Applied-Machine-learning-course" rel="noopener ugc nofollow" target="_blank">https://Applied ai course . com/course/11/Applied-Machine-learning-course</a></li></ol></div></div>    
</body>
</html>