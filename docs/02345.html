<html>
<head>
<title>Speed up Bulk inserts to SQL db using Pandas and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pandas和Python加速SQL db的批量插入</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/speed-up-bulk-inserts-to-sql-db-using-pandas-and-python-61707ae41990?source=collection_archive---------0-----------------------#2019-12-12">https://medium.com/analytics-vidhya/speed-up-bulk-inserts-to-sql-db-using-pandas-and-python-61707ae41990?source=collection_archive---------0-----------------------#2019-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8820af1d64043ea7e37f5a3b9fc0894b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qU7CHfWniakb16Ak"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">米卡·鲍梅斯特在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="301f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文详细介绍了:</p><ol class=""><li id="75d8" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">使用pandas和pyodbc将数据帧写入数据库的不同方式</li><li id="3056" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">如何使用python加速对sql数据库的插入</li><li id="f725" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">每个方法写入数据库所花费的时间</li><li id="e80c" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">比较使用不同方法写入数据库所需的时间</li></ol><h2 id="afa9" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">方法1:</h2><p id="54ee" class="pw-post-body-paragraph iv iw hi ix b iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">这里的方法是:</p><ol class=""><li id="9aa3" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">数据帧中的每一行都被转换成元组</li><li id="52aa" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">然后使用pyodbc将每条记录插入到表中</li></ol><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="ec3d" class="kh ki hi lm b fi lq lr l ls lt"><br/>p<em class="lu">arams = 'DRIVER='+driver + ';SERVER='+server + ';PORT=1433;DATABASE=' + database + ';UID=' + username + ';PWD=' + password</em></span><span id="abd7" class="kh ki hi lm b fi lv lr l ls lt"><em class="lu">#df_op is the dataframe that needs to be written to database and test is the table name in database and col_name1, col_name2,... are the respective column names</em></span><span id="a830" class="kh ki hi lm b fi lv lr l ls lt"><em class="lu">cnxn = pyodbc.connect(params)<br/>cursor = cnxn.cursor()<br/>for row_count in range(0, df_op.shape[0]):<br/>      chunk = df_op.iloc[row_count:row_count + 1,:].values.tolist()<br/>      tuple_of_tuples = tuple(tuple(x) for x in chunk)<br/>      cursor.executemany("insert into test" + " ([col_name1],   col_name2],[col_name3],[col_name4],[col_name5],[col_name6],[col_name7],[col_name8],[col_name9],[col_name10]) values   (?,?,?,?,?,?,?,?,?,?)",tuple_of_tuples)</em></span></pre><p id="d2e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请使用此方法，<br/> <em class="lu">找到一个数据帧各自的行数和写入数据库所用的时间，rows_count=['50 '，' 1000 '，' 5000 '，' 0.01米'，' 0.05米'，' 0.1米'，' 0.2米'] <br/> time(sec)= [0.005，0.098，0.440，0.903，4.290，8.802，17.776，26.982]</em></p><h2 id="a21f" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">方法2</h2><p id="e87c" class="pw-post-body-paragraph iv iw hi ix b iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">现在让我们将cursor.fast_executemany = True添加到方法1中已经使用的函数中。突出显示了方法1和方法2之间的差异</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="6765" class="kh ki hi lm b fi lq lr l ls lt"><em class="lu">#df_op is the dataframe that needs to be written to database and test is the table name in database and col_name1, col_name2,... are the respective column names</em></span><span id="6784" class="kh ki hi lm b fi lv lr l ls lt"><em class="lu">cnxn = pyodbc.connect(params)<br/>cursor = cnxn.cursor()<br/></em><strong class="lm hj"><em class="lu">cursor.fast_executemany = True</em></strong><em class="lu"><br/>for row_count in range(0, df_op.shape[0]):<br/>   chunk = df_op.iloc[row_count:row_count + 1,:].values.tolist()<br/>   tuple_of_tuples = tuple(tuple(x) for x in chunk)<br/>   cursor.executemany("insert into test" + " ([col_name1],   col_name2],[col_name3],[col_name4],[col_name5],[col_name6],[col_name7],[col_name8],[col_name9],[col_name10]) values   (?,?,?,?,?,?,?,?,?,?)",tuple_of_tuples)</em></span></pre><p id="ed01" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请使用此方法找到一个数据帧中的行数和写入数据库所用的时间，<br/> <em class="lu"> rows_count =['50 '，' 1000 '，' 5000 '，' 0.01M '，' 0.05M '，' 0.1M '，' 0.2M ']<br/>time(sec)=[0.009，0.179，0.574，1.35，6.718，14.949，28.422，42</em></p><h2 id="40c1" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">方法3:</h2><p id="56fa" class="pw-post-body-paragraph iv iw hi ix b iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">使用pandas 'to_sql '函数、sql alchemy和python将数据帧df写入sql</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="649e" class="kh ki hi lm b fi lq lr l ls lt"><em class="lu">db_params = urllib.parse.quote_plus(params)<br/>engine = sqlalchemy.create_engine("mssql+pyodbc:///?odbc_connect={}".format(db_params))</em></span><span id="9e7b" class="kh ki hi lm b fi lv lr l ls lt"><em class="lu">#df is the dataframe; test is table name in which this dataframe is #inserted<br/>df.to_sql(test,engine,index=False,if_exists="append",schema="dbo")</em></span></pre><p id="9b93" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请使用此方法找到一个数据帧中的行数和写入数据库所用的时间，<br/> <em class="lu"> rows_count=['50 '，' 1000 '，' 5000 '，' 0.01M '，' 0.05M '，' 0.1M '，' 0.2M ']<br/>time(sec)=[0.0230，0.081，0.289，0.589，3.105，5.74，11.769，20</em></p><h2 id="5058" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated"><strong class="ak">方法4: </strong></h2><p id="c2c3" class="pw-post-body-paragraph iv iw hi ix b iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">现在让我们使用事件设置<strong class="ix hj"><em class="lu">cursor . fast _ execute many = True</em></strong>并使用to_sql函数写入数据库。(突出显示了方法3和方法4之间的差异)</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="9e2d" class="kh ki hi lm b fi lq lr l ls lt"><strong class="lm hj"><em class="lu">from sqlalchemy import event</em></strong></span><span id="936a" class="kh ki hi lm b fi lv lr l ls lt"><strong class="lm hj"><em class="lu">@event.listens_for(engine, "before_cursor_execute")<br/>def receive_before_cursor_execute(<br/>       conn, cursor, statement, params, context, executemany<br/>        ):<br/>            if executemany:<br/>                cursor.fast_executemany = True</em></strong><em class="lu"><br/><br/>df.to_sql(tbl, engine, index=False, if_exists="append", schema="dbo")</em></span></pre><p id="cc11" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请使用此方法找出数据帧中的行数和写入数据库所用的时间，<br/> <em class="lu"> rows_count =['50 '，' 1000 '，' 5000 '，' 0.01M '，' 0.05M '，' 0.1M '，' 0.2M ']<br/>time(sec)=[0.017，0.015，0.031，0.063，0.146，0.344，0.611，0.831</em></p><p id="fb18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们比较不同方法写入数据库以插入不同大小(从5000万到30万条记录)的数据帧所用的时间。“行数”表示写入数据帧的行数，“时间”表示不同方法将相应行数插入数据库所用的时间</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/34c099ba04effe71c70f1dc712d63633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*vLkf4pJuNeBBqEk7u_1nwQ.png"/></div></figure><p id="56f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，与其他方法相比，方法4花费的时间更少。使用方法4，插入速度至少会快15倍。</p><p id="ba50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">参考文献</strong></p><p id="c136" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://github.com/mkleehammer/pyodbc/issues/547" rel="noopener ugc nofollow" target="_blank">https://github.com/mkleehammer/pyodbc/issues/547</a></p></div></div>    
</body>
</html>