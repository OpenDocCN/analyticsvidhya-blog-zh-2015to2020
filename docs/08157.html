<html>
<head>
<title>Sliding Window Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">滑动窗口算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sliding-window-algorithms-c1cdf2638487?source=collection_archive---------25-----------------------#2020-07-19">https://medium.com/analytics-vidhya/sliding-window-algorithms-c1cdf2638487?source=collection_archive---------25-----------------------#2020-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/6fc1d1ab90057805e1b3f06a1330a930.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/1*wytgFSuRwFp82yQ9kxD_-A.gif"/></div><figcaption class="im in et er es io ip bd b be z dx translated">滑动窗口</figcaption></figure><p id="9847" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有一类问题，在编程面试中很常见，可以通过使用所谓的<em class="jo">滑动窗口</em>技术，以<em class="jo">优化</em>的方式来解决。通常这些问题有这些特征:</p><ul class=""><li id="adfe" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">在算法中的任何时候，基于输入的子集做出决定</li><li id="3cf3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">将会有更简单的方法来解决这个计算量很大的问题</li></ul><p id="6d4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用一些代码的例子来看看我的意思。假设给你一个输入字符串和一个变位词字符串，要求你从输入字符串中找出所有变位词子字符串的起始索引，你会怎么做呢？一个简单的算法可能包括以下步骤:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="5b46" class="km kn hi ki b fi ko kp l kq kr">For each index in the input string:<br/>   For the substring input[index, index + length of anagram]:<br/>      Check if the substring is an anagram, if yes add it to results</span></pre><p id="f116" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个相同的图示</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ks"><img src="../Images/cf5f70bee5fb7b417bfb15d4b0ab0287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNKIbdludGTueBPAYbeuLQ.jpeg"/></div></div></figure><p id="85cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是它的代码:</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="8c2d" class="km kn hi ki b fi ko kp l kq kr"><strong class="ki hj">def </strong>findAnagrams(s: str, p: str) -&gt; List[int]:<br/>    s_len, p_len = len(s), len(p)<br/>    p_chars_freq = {c: 0 <strong class="ki hj">for </strong>c <strong class="ki hj">in </strong>p}<br/>    <strong class="ki hj">for </strong>c <strong class="ki hj">in </strong>p:<br/>        p_chars_freq[c] += 1<br/>    result = []<br/>    <strong class="ki hj">for </strong>i <strong class="ki hj">in </strong>range(s_len - p_len + 1):<br/>        substr_start, substr_end = i, i + p_len<br/>        remaining_chars_for_anagram = p_len<br/>        p_chars_check_freq = {c: p_chars_freq[c] <strong class="ki hj">for </strong>c <strong class="ki hj">in </strong>p_chars_freq}<br/>        <strong class="ki hj">for </strong>c <strong class="ki hj">in </strong>range(substr_start, substr_end):<br/>            <strong class="ki hj">if </strong>s[c] <strong class="ki hj">in </strong>p_chars_check_freq <strong class="ki hj">and </strong>p_chars_check_freq[s[c]] &gt; 0:<br/>                remaining_chars_for_anagram -= 1<br/>                p_chars_check_freq[s[c]] -= 1<br/>        <strong class="ki hj">if </strong>remaining_chars_for_anagram == 0:<br/>            result.append(i)<br/>    <strong class="ki hj">return </strong>result</span></pre><p id="ecf9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，问题本身并不难解决，上述解决方案的时间复杂度为O(n)。所以很自然，要问的问题是，我们能做得更好吗？</p><p id="db2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，我们可以，让我们看看怎么做。</p><p id="1862" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图的两次迭代之间，真正改变的是什么？<br/> 1。我们省略了左边的字符，包括了右边的字符<br/> 2。因此，我们不必为中间的所有东西重新计算频率</p><p id="b817" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们更详细地解释一下，我们需要什么来省略左边的字符:<br/>如果它是变位词的一部分，那么增加频率计数并增加剩下的字符数，以成为变位词</p><p id="0217" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">b)包括右边的字符:<br/>减少频率计数</p><p id="0924" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看这在代码中是如何工作的</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="1dbd" class="km kn hi ki b fi ko kp l kq kr"><strong class="ki hj">def </strong>findAnagrams(s: str, p: str) -&gt; List[int]:<br/>    """<br/>    <em class="jo">s:</em> is the input string<br/>    <em class="jo">p:</em> is the anagram<br/>    """<br/>    start_indices = []<br/>    s_len, p_len = len(s), len(p)<br/>    chars_left_to_be_anagram = p_len<br/>    <strong class="ki hj">if </strong>s_len &lt; p_len:<br/>        <strong class="ki hj">return </strong>start_indices<br/>    <em class="jo"># Keep a map of the frequency of characters in the anagram<br/>    </em>p_char_freq = {}<br/><em class="jo">    </em><strong class="ki hj">for </strong>c <strong class="ki hj">in </strong>p:<br/>        p_char_freq[c] = p_char_freq.get(c,0) + 1<br/>    window_start_index = 0<br/>    <strong class="ki hj">for </strong>window_end_index, current_char <strong class="ki hj">in </strong>enumerate(s):  <em class="jo"><br/>        </em><strong class="ki hj">if </strong>p_char_freq.get(current_char, 0) &gt; 0:<br/>            chars_left_to_be_anagram -= 1<br/>        p_char_freq[current_char] = p_char_freq.get(current_char, 0) - 1<br/>        <strong class="ki hj">if </strong>window_end_index + 1 - window_start_index == p_len:<br/>            <strong class="ki hj">if </strong>chars_left_to_be_anagram == 0:<br/>                start_indices.append(window_start_index)<br/>            # If it was part of anagram then increase the no of chars left to form an anagram<br/>            <strong class="ki hj">if </strong>p_char_freq.get(s[window_start_index], 0) &gt;= 0:<br/>                chars_left_to_be_anagram += 1<br/>            p_char_freq[s[window_start_index]] = p_char_freq.get(s[window_start_index], 0) + 1<br/>            window_start_index += 1<br/>    <strong class="ki hj">return </strong>start_indices</span></pre><p id="2c5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，大概就是这样。我们现在能够在线性时间内解决这个问题。在下一个帖子里，让我们来看看滑动窗口的其他问题。</p><p id="178f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考:<br/><a class="ae kx" href="https://leetcode.com/problems/find-all-anagrams-in-a-string/submissions/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/find-all-anagrams-in-a-string/submissions/</a></p></div></div>    
</body>
</html>