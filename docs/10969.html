<html>
<head>
<title>A* Path Finding Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">*路径查找代码</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-path-finding-code-in-python-30a767353195?source=collection_archive---------2-----------------------#2020-11-11">https://medium.com/analytics-vidhya/a-path-finding-code-in-python-30a767353195?source=collection_archive---------2-----------------------#2020-11-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="e6cd" class="io ip hi ik b fi iq ir l is it">import pygame<br/>import math<br/>from queue import PriorityQueue<br/><br/>WIDTH = 800<br/>WIN = pygame.display.set_mode((WIDTH, WIDTH))<br/>pygame.display.set_caption("A* Pathfinding")<br/><br/>RED = (255,0,0)<br/>GREEN = (0,255,0)<br/>YELLOW = (255,255,0)<br/>WHITE = (255, 255, 255)<br/>BLACK = (0, 0, 0)<br/>PURPLE = (128, 0, 128)<br/>ORANGE = (255, 165, 0)<br/>GREY = (128, 128, 128)<br/>TURQUOISE = (64, 224, 208)<br/><br/>class Spot:<br/>    def __init__(self, row, col, width, total_rows):<br/>        self.row = row<br/>        self.col = col<br/>        self.x = row *width<br/>        self.y = col * width<br/>        self.colour =  WHITE<br/>        self.neighbours = []<br/>        self.width = width<br/>        self.total_rows = total_rows<br/><br/>    def get_pos(self):<br/>        return self.row, self.col<br/><br/>    def is_closed(self):<br/>        return self.colour == RED<br/><br/>    def is_open(self):<br/>        return self.colour ==GREEN<br/><br/>    def is_barrier(self):<br/>        return self.colour == BLACK<br/><br/>    def is_start(self):<br/>        return self.colour == ORANGE<br/><br/>    def is_end(self):<br/>        return self.colour == TURQUOISE<br/><br/>    def reset(self):<br/>        self.colour = WHITE<br/><br/>    def make_closed(self):<br/>        self.colour = RED<br/><br/>    def make_open(self):<br/>        self.colour = GREEN<br/><br/>    def make_barrier(self):<br/>        self.colour = BLACK<br/><br/>    def make_end(self):<br/>        self.colour = TURQUOISE<br/><br/>    def make_path(self):<br/>        self.colour = PURPLE<br/><br/>    def draw(self, win):<br/>        pygame.draw.rect(win, self.colour, (self.x, self.y, self.width, self.width))<br/><br/>    def update_neighbours(self, grid):<br/>        self.neighbours = []<br/>        if self.row &lt; self.total_rows - 1 and not grid[self.row +1][self.col].is_barrier():  #DOWN<br/>            self.neighbours.append(grid[self.row +1][self.col])<br/><br/>        if self.row &gt; 0 and not grid[self.row - 1][self.col].is_barrier():   # UP<br/>            self.neighbours.append(grid[self.row -1][self.col])<br/><br/>        if self.col &lt; self.total_rows - 1 and not grid[self.row][self.col+ 1].is_barrier():  #RIGHT<br/>            self.neighbours.append(grid[self.row ][self.col+1])<br/><br/>        if self.col &gt; 0 and not grid[self.row][self.col - 1].is_barrier():  #RIGHT<br/>            self.neighbours.append(grid[self.row][self.col - 1])<br/><br/>    def __lt__(self,other):<br/>        return False<br/><br/>    def make_start(self):<br/>        self.colour = ORANGE<br/>def reconstruct_path(came_from, current, draw):<br/>    while current in came_from:<br/>        current = came_from[current]<br/>        current.make_path()<br/>        draw()<br/>def h(p1, p2):<br/>    x1, y1 = p1<br/>    x2, y2 = p2<br/>    return abs(x1-x2) + abs(y1-y2)<br/><br/>def algorithm(draw, grid, start, end):<br/>    count = 0<br/>    open_set = PriorityQueue()   # returns the smallest value in the list<br/>    open_set.put((0, count, start))<br/>    came_from = {}<br/>    g_score = {spot: float("inf") for row in grid for spot in row}<br/>    g_score[start] = 0<br/>    f_score = {spot: float("inf") for row in grid for spot in row}<br/>    f_score[start] = h(start.get_pos(), end.get_pos())<br/><br/>    open_set_hash = {start}<br/>    while not open_set.empty():<br/>        for event in pygame.event.get():<br/>            if event.type ==pygame.QUIT:<br/>                pygame.quit()<br/>        current = open_set.get()[2]      # returns the best value<br/>        open_set_hash.remove(current)<br/>        if current == end:<br/>            reconstruct_path(came_from, end, draw)<br/>            end.make_end()<br/>            start.make_start()<br/>            return True<br/><br/>        for neighbour in current.neighbours:<br/>            temp_g_score = g_score[current]+1<br/><br/>            if temp_g_score &lt; g_score[neighbour]:<br/>                came_from[neighbour] = current<br/>                g_score[neighbour] = temp_g_score<br/>                f_score[neighbour] = temp_g_score + h(neighbour.get_pos(), end.get_pos())<br/>                if neighbour not in open_set_hash:<br/>                    count += 1<br/>                    open_set.put((f_score[neighbour], count, neighbour))<br/>                    open_set_hash.add(neighbour)<br/>                    neighbour.make_open()<br/>        draw()<br/>        if current != start:<br/>            current.make_closed()<br/><br/>    return False<br/><br/><br/><br/>def make_grid(rows, width):<br/>    grid = []<br/>    gap = width // rows<br/>    for i in range(rows):<br/>        grid.append([])<br/>        for j in range(rows):<br/>            spot = Spot(i, j, gap, rows)<br/>            grid[i].append(spot)<br/><br/>    return grid<br/><br/>def draw_grid(win, rows, width):<br/>    gap = width //rows<br/>    for i in range(rows):<br/>        pygame.draw.line(win, GREY, (0, i*gap),(width, i*gap))<br/>        for j in range(rows):<br/>            pygame.draw.line(win, GREY, (j* gap, 0), (j* gap,width))<br/><br/>def draw(win, grid, rows, width):<br/>    win.fill(WHITE)<br/>    for row in grid:<br/>        for spot in row:<br/>            spot.draw(win)<br/><br/>    draw_grid(win, rows, width)<br/>    pygame.display.update()<br/><br/>def get_clicked_pos(pos, rows, width):<br/>    gap = width //rows<br/>    y,x = pos<br/><br/>    row = y//gap<br/>    col = x//gap<br/>    return row, col<br/><br/>def main(win, width):<br/>    ROWS = 50<br/>    grid = make_grid(ROWS, width)<br/>    start = None<br/>    end = None<br/>    run = True<br/>    started = False<br/>    while run:<br/>        draw(win, grid, ROWS, width)<br/>        for event in pygame.event.get():<br/>            if event.type ==pygame.QUIT:<br/>                run = False<br/>            if started:<br/>                continue<br/>            if pygame.mouse.get_pressed()[0]:  # left mouse button<br/>                pos = pygame.mouse.get_pos()<br/>                row, col = get_clicked_pos(pos, ROWS, width)<br/>                spot = grid[row][col]<br/>                if not start and  spot != end:<br/>                    start = spot<br/>                    start.make_start()<br/><br/>                elif not end and spot != start:<br/>                    end = spot<br/>                    end.make_end()<br/>                elif spot != end and spot != start:<br/>                    spot.make_barrier()<br/><br/>            elif pygame.mouse.get_pressed()[2]:<br/>                pos = pygame.mouse.get_pos()<br/>                row, col = get_clicked_pos(pos, ROWS, width)<br/>                spot = grid[row][col]<br/>                spot.reset()<br/>                if spot ==start:<br/>                    start = None<br/>                elif spot == end:<br/>                    end = None<br/><br/>            if event.type == pygame.KEYDOWN:<br/>                if event.key == pygame.K_SPACE and not started:<br/>                    for row in grid:<br/>                        for spot in row:<br/>                            spot.update_neighbours(grid)<br/>                    algorithm(lambda: draw(win, grid, ROWS, width), grid, start, end)   #having lambda lets you run the function inside the function<br/><br/>                if event.key == pygame.K_c:<br/>                    start = None<br/>                    end = None<br/>                    grid = make_grid(ROWS, width)<br/><br/><br/>    pygame.quit()<br/><br/><br/>main(WIN, WIDTH)</span></pre><p id="22b7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我解释这段代码之前，我承认这不是我的代码。这是从youtube上的一个视频中截取的，我跟着这个视频去理解寻路的概念和使时间有效的逻辑。我将在这里链接youtube视频:<a class="ae js" href="https://www.youtube.com/watch?v=JtiK0DOeI4A" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=JtiK0DOeI4A</a>如果你不明白我的任何解释，我强烈建议你查看视频，因为他对代码做了非常好的解释。</p><p id="7c4f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">启发式函数:</strong></p><p id="3047" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个程序的工作方式是通过使用一个叫做启发式函数的函数。简而言之，启发式函数:h(n)= f(n)+g(n)，其中f(n)是路线所用的时间，h(n)是到终点的最近距离。每当我们在节点(你和最终目的地之间的点)之间有任何移动时，你将检查它的每个邻居的启发式函数，以检查哪个将具有最低的值，因此将是最快的选择。最低启发式函数是合乎逻辑的，因为它将最接近最终目的地的效率与时间效率相结合。</p><figure class="if ig ih ii fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jt"><img src="../Images/5513b7b8051b57cea8b408dd96a51387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l78GtGzYv_ODYEkC.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">这是一个到同一个节点的2条路径的例子，如果我们作为一个算法来做，我们将在2条路径(红色和绿色)的每一条上有2个以上的节点，我们将计算启发式函数来决定哪条路径将是最快的</figcaption></figure><figure class="if ig ih ii fd ju er es paragraph-image"><div class="er es kf"><img src="../Images/9d626c1f0f08c0439207d16cdb25062b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*dVj23giTLoMQv7To.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">这是一个类似于我们的例子，每个方块代表一个节点，每个方块都是根据启发式函数来考虑的，但是正如你所看到的，这里的路径具有最低的启发式函数。</figcaption></figure><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="f04a" class="io ip hi ik b fi iq ir l is it">import pygame<br/>import math<br/>from queue import PriorityQueue<br/><br/>WIDTH = 800<br/>WIN = pygame.display.set_mode((WIDTH, WIDTH))<br/>pygame.display.set_caption("A* Pathfinding")<br/><br/>RED = (255,0,0)<br/>GREEN = (0,255,0)<br/>YELLOW = (255,255,0)<br/>WHITE = (255, 255, 255)<br/>BLACK = (0, 0, 0)<br/>PURPLE = (128, 0, 128)<br/>ORANGE = (255, 165, 0)<br/>GREY = (128, 128, 128)<br/>TURQUOISE = (64, 224, 208)</span></pre><p id="8276" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">程序的开始将是建立网格。我们导入pygame，因为这是显示程序可视化的地方。优先级队列是一个自动排序列表，当我们决定要移动到哪个节点时，这个列表非常重要。宽度决定了屏幕上的像素数量，WIN创建了我们玩游戏的窗口。我们用两倍的宽度做一个正方形面板。我们将尺寸作为参数(width，width)传递，这意味着我们需要两对括号。设置标题功能将命名你创建的窗口(运行程序时看窗口的左上方)。</p><p id="5158" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来的几行使用RGB颜色系统来创建程序中我们想要的颜色。它的格式为(R，G，B)。</p><figure class="if ig ih ii fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kg"><img src="../Images/5f31298709b10cc1fa726ca66f25af37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a274LaV7HRZH-WlC.jpg"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">一个简单的谷歌搜索会给你一个调色板选择，如果你输入颜色，它会返回它的RGB值在你的程序中使用</figcaption></figure><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="7d39" class="io ip hi ik b fi iq ir l is it">class Spot:<br/>    def __init__(self, row, col, width, total_rows):<br/>        self.row = row<br/>        self.col = col<br/>        self.x = row *width<br/>        self.y = col * width<br/>        self.colour =  WHITE<br/>        self.neighbours = []<br/>        self.width = width<br/>        self.total_rows = total_rows<br/><br/>    def get_pos(self):<br/>        return self.row, self.col<br/><br/>    def is_closed(self):<br/>        return self.colour == RED<br/><br/>    def is_open(self):<br/>        return self.colour ==GREEN<br/><br/>    def is_barrier(self):<br/>        return self.colour == BLACK<br/><br/>    def is_start(self):<br/>        return self.colour == ORANGE<br/><br/>    def is_end(self):<br/>        return self.colour == TURQUOISE<br/><br/>    def reset(self):<br/>        self.colour = WHITE<br/><br/>    def make_closed(self):<br/>        self.colour = RED<br/><br/>    def make_open(self):<br/>        self.colour = GREEN<br/><br/>    def make_barrier(self):<br/>        self.colour = BLACK<br/><br/>    def make_end(self):<br/>        self.colour = TURQUOISE<br/><br/>    def make_path(self):<br/>        self.colour = PURPLE</span></pre><p id="4bdc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下一个代码块利用了面向对象的编程，你可能已经从Java或类似的编码语言中学到了。最初，我们正在设置我称之为点的节点的主要属性。这些很重要，因为我们要实例化这些点来制作一个网格。实例化意味着在程序中创建它的一个实体。之后的所有方法都用来帮助我们识别它们是什么类型的节点(它们可以是开始块、结束块， 障碍或要移动到的自由点)并且当我们让算法创建路径时，拥有这些是很重要的，这样我们就可以理解我们当前所在的节点周围的对象(这样我们就不会移动到当然不允许的障碍上)之后只有一个“=”的方法用于改变节点的类型(这允许我们在运行代码之前定制过程。 例如，如果我们在一个节点上运行make_open()，它会将该节点变成绿色。同样的概念适用于所有带有一个“=”的方法。当你使用' == '时，它变成了一个比较语句，所以它将比较两个输入，如果相同则返回True，否则返回False。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="fbdb" class="io ip hi ik b fi iq ir l is it">def draw(self, win):<br/>        pygame.draw.rect(win, self.colour, (self.x, self.y, self.width, self.width))<br/><br/>    def update_neighbours(self, grid):<br/>        self.neighbours = []<br/>        if self.row &lt; self.total_rows - 1 and not grid[self.row +1][self.col].is_barrier():  #DOWN<br/>            self.neighbours.append(grid[self.row +1][self.col])<br/><br/>        if self.row &gt; 0 and not grid[self.row - 1][self.col].is_barrier():   # UP<br/>            self.neighbours.append(grid[self.row -1][self.col])<br/><br/>        if self.col &lt; self.total_rows - 1 and not grid[self.row][self.col+ 1].is_barrier():  #RIGHT<br/>            self.neighbours.append(grid[self.row ][self.col+1])<br/><br/>        if self.col &gt; 0 and not grid[self.row][self.col - 1].is_barrier():  #RIGHT<br/>            self.neighbours.append(grid[self.row][self.col - 1])<br/><br/>    def __lt__(self,other):<br/>        return False<br/><br/>    def make_start(self):<br/>        self.colour = ORANGE<br/>def reconstruct_path(came_from, current, draw):<br/>    while current in came_from:<br/>        current = came_from[current]<br/>        current.make_path()<br/>        draw()</span></pre><p id="96b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些方法有点复杂，涉及到绘图背后的逻辑。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="c9ea" class="io ip hi ik b fi iq ir l is it">def draw(self, win):<br/>        pygame.draw.rect(win, self.colour, (self.x, self.y, self.width, self.width))</span></pre><p id="8a86" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这一行只是告诉pygame在我们指定的点绘制一个矩形。如果我们把最后的路径画回到起点，这是很有用的。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="fe59" class="io ip hi ik b fi iq ir l is it">def update_neighbours(self, grid):<br/>        self.neighbours = []<br/>        if self.row &lt; self.total_rows - 1 and not grid[self.row +1][self.col].is_barrier():  #DOWN<br/>            self.neighbours.append(grid[self.row +1][self.col])<br/><br/>        if self.row &gt; 0 and not grid[self.row - 1][self.col].is_barrier():   # UP<br/>            self.neighbours.append(grid[self.row -1][self.col])<br/><br/>        if self.col &lt; self.total_rows - 1 and not grid[self.row][self.col+ 1].is_barrier():  #RIGHT<br/>            self.neighbours.append(grid[self.row ][self.col+1])<br/><br/>        if self.col &gt; 0 and not grid[self.row][self.col - 1].is_barrier():  #RIGHT<br/>            self.neighbours.append(grid[self.row][self.col - 1])</span></pre><p id="1c0d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个代码简单地用于检查节点可以移动到的四个方向中的每一个方向，方法是检查节点两侧是否有障碍物。如果空间是空闲的，那么它会将相邻节点添加到一个列表中，然后我们可以计算节点的启发式函数，以找出哪一个是最好的。我们还执行第一个if语句，以确保我们正在检查的节点确实在我们指定的范围内(如果我们正在检查的节点在屏幕的边缘，我们不希望程序检查不存在的节点)。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="bcf8" class="io ip hi ik b fi iq ir l is it">def __lt__(self,other):<br/>        return False</span></pre><p id="1eb8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过比较我们传入的值，它的作用与</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="1de6" class="io ip hi ik b fi iq ir l is it">def reconstruct_path(came_from, current, draw):<br/>    while current in came_from:<br/>        current = came_from[current]<br/>        current.make_path()<br/>        draw()</span></pre><p id="65cd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦我们找到了最快的路径并重新构建了路径，就可以使用这种方法。当我们决定包的时候，我们将会在一个列表中得到节点的顺序，我们将会把它传递到这个列表中。而current将直接遍历列表，并将每个节点实体赋给一个名为current的变量。由于我们处理的是前面创建的类中的一个实例，我们可以使用其中的方法，所以我们在spot的方法中运行make_path()函数，它会将节点变成紫色。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="5b78" class="io ip hi ik b fi iq ir l is it">def h(p1, p2):<br/>    x1, y1 = p1<br/>    x2, y2 = p2<br/>    return abs(x1-x2) + abs(y1-y2)<br/><br/>def algorithm(draw, grid, start, end):<br/>    count = 0<br/>    open_set = PriorityQueue()   # returns the smallest value in the list<br/>    open_set.put((0, count, start))<br/>    came_from = {}<br/>    g_score = {spot: float("inf") for row in grid for spot in row}<br/>    g_score[start] = 0<br/>    f_score = {spot: float("inf") for row in grid for spot in row}<br/>    f_score[start] = h(start.get_pos(), end.get_pos())<br/><br/>    open_set_hash = {start}<br/>    while not open_set.empty():<br/>        for event in pygame.event.get():<br/>            if event.type ==pygame.QUIT:<br/>                pygame.quit()<br/>        current = open_set.get()[2]      # returns the best value<br/>        open_set_hash.remove(current)<br/>        if current == end:<br/>            reconstruct_path(came_from, end, draw)<br/>            end.make_end()<br/>            start.make_start()<br/>            return True<br/><br/>        for neighbour in current.neighbours:<br/>            temp_g_score = g_score[current]+1<br/><br/>            if temp_g_score &lt; g_score[neighbour]:<br/>                came_from[neighbour] = current<br/>                g_score[neighbour] = temp_g_score<br/>                f_score[neighbour] = temp_g_score + h(neighbour.get_pos(), end.get_pos())<br/>                if neighbour not in open_set_hash:<br/>                    count += 1<br/>                    open_set.put((f_score[neighbour], count, neighbour))<br/>                    open_set_hash.add(neighbour)<br/>                    neighbour.make_open()<br/>        draw()<br/>        if current != start:<br/>            current.make_closed()<br/><br/>    return False</span></pre><p id="00b4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来的两个函数构成了算法中的理论，所以你要做好准备。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="5d2f" class="io ip hi ik b fi iq ir l is it">def h(p1, p2):<br/>    x1, y1 = p1<br/>    x2, y2 = p2<br/>    return abs(x1-x2) + abs(y1-y2)</span></pre><p id="a7f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此函数将获取网格中两个节点的坐标，一个是结束节点，另一个是您所在图块的相邻节点的坐标。这个h函数将执行我之前提到的启发式函数的g()部分，因此它将决定邻居和端节点之间的距离，以计算出哪个邻居会将我们带到端节点。我们使用这些值的坐标差来计算。abs()将使函数中的负值变为正值。</p><figure class="if ig ih ii fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jt"><img src="../Images/673563361d432ca75b456f1df6386b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OMfb-Y3D7BLllb2V.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">绝对值的例子。它只是把任何负值变成正值。</figcaption></figure><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="2df3" class="io ip hi ik b fi iq ir l is it">def algorithm(draw, grid, start, end):<br/>    count = 0<br/>    open_set = PriorityQueue()   # returns the smallest value in the list<br/>    open_set.put((0, count, start))<br/>    came_from = {}<br/>    g_score = {spot: float("inf") for row in grid for spot in row}<br/>    g_score[start] = 0<br/>    f_score = {spot: float("inf") for row in grid for spot in row}<br/>    f_score[start] = h(start.get_pos(), end.get_pos())</span></pre><p id="01aa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是完成大部分工作的算法。首先，我们设置一个计数来显示我们在路径中的哪个节点上，如果路径很复杂，万一我们需要在程序中回溯。我们在这里也创建了一个优先级队列，这样我们就可以决定哪个邻居最有可能到达正确的路径。我们首先将值0表示第一个节点，count表示第一个节点(它是起始节点)，然后将起始节点本身放入我们将在程序中稍后分配的函数中。你不能跳出优先级队列，所以你需要创建另一个字典，我调用了这个字典来记录我们来的地方。然后我们需要计算之前的f和g函数。我们首先通过实例化存储这些值的列表开始，我们确实购买了一个字典，它将创建一个字典记录，并最初给它赋一个无穷大的值(这意味着gscore方法的返回值不可能大于它之前的值。当然，我们随后在g_score字典中将开始节点的值设置为0，因为这是我们开始的地方。我们使用曼哈顿距离来计算起始节点的f函数，如上所示。</p><figure class="if ig ih ii fd ju er es paragraph-image"><div class="er es kh"><img src="../Images/d63584880841cf050ebe731e69f7ec64.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/0*SLp0NqrJHVsGtEcg"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">既然我们用的是对角线，就不能用欧几里得几何</figcaption></figure><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="8a8c" class="io ip hi ik b fi iq ir l is it">open_set_hash = {start}<br/>    while not open_set.empty():<br/>        for event in pygame.event.get():<br/>            if event.type ==pygame.QUIT:<br/>                pygame.quit()<br/>        current = open_set.get()[2]      # returns the best value<br/>        open_set_hash.remove(current)<br/>        if current == end:<br/>            reconstruct_path(came_from, end, draw)<br/>            end.make_end()<br/>            start.make_start()<br/>            return True<br/><br/>        for neighbour in current.neighbours:<br/>            temp_g_score = g_score[current]+1<br/><br/>            if temp_g_score &lt; g_score[neighbour]:<br/>                came_from[neighbour] = current<br/>                g_score[neighbour] = temp_g_score<br/>                f_score[neighbour] = temp_g_score + h(neighbour.get_pos(), end.get_pos())<br/>                if neighbour not in open_set_hash:<br/>                    count += 1<br/>                    open_set.put((f_score[neighbour], count, neighbour))<br/>                    open_set_hash.add(neighbour)<br/>                    neighbour.make_open()<br/>        draw()<br/>        if current != start:<br/>            current.make_closed()<br/><br/>    return False</span></pre><p id="24da" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">open_set_hash将一个值放入优先级队列。我们这样做是为了在下一行运行while循环，并且我们可以使用这个优先级队列回溯我们已经走过的地方。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="43b2" class="io ip hi ik b fi iq ir l is it">for event in pygame.event.get():<br/>            if event.type ==pygame.QUIT:<br/>                pygame.quit()<br/>        current = open_set.get()[2]      # returns the best value<br/>        open_set_hash.remove(current)<br/>        if current == end:<br/>            reconstruct_path(came_from, end, draw)<br/>            end.make_end()<br/>            start.make_start()<br/>            return True<br/>        for neighbour in current.neighbours:<br/>            temp_g_score = g_score[current]+1<br/><br/>            if temp_g_score &lt; g_score[neighbour]:<br/>                came_from[neighbour] = current<br/>                g_score[neighbour] = temp_g_score<br/>                f_score[neighbour] = temp_g_score + h(neighbour.get_pos(), end.get_pos())<br/>                if neighbour not in open_set_hash:<br/>                    count += 1<br/>                    open_set.put((f_score[neighbour], count, neighbour))<br/>                    open_set_hash.add(neighbour)<br/>                    neighbour.make_open()<br/>        draw()<br/>        if current != start:<br/>            current.make_closed()<br/><br/>    return False</span></pre><p id="bca5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">前两行告诉pygame如果你试图关闭窗口该怎么做，这是所有pygame例子中使用的标准代码。我们使用current取出优先级队列中的最大值，然后将其从列表中删除，因为我们要用新节点替换它，首先我们需要检查它是否在目的节点中，我们可以通过检查它是否与结束节点是同一个节点来轻松完成此操作。如果为true，它将通过设置输出True来退出循环。如果节点不是最后一个节点，我们需要检查我们当前所在节点的邻居，首先我们要跟踪我们所在的节点，我们通过增加之前所在节点的g值来实现这一点。当我们在current . neighbors:命令中使用for neighbour时，我们检查每个邻居，该命令将运行current . neighbors方法将返回的列表(该列表包含我们可以移动到的所有可能的节点)。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="68e4" class="io ip hi ik b fi iq ir l is it">if temp_g_score &lt; g_score[neighbour]:<br/>                came_from[neighbour] = current<br/>                g_score[neighbour] = temp_g_score<br/>                f_score[neighbour] = temp_g_score + h(neighbour.get_pos(), end.get_pos())<br/>                if neighbour not in open_set_hash:<br/>                    count += 1<br/>                    open_set.put((f_score[neighbour], count, neighbour))<br/>                    open_set_hash.add(neighbour)<br/>                    neighbour.make_open()<br/>        draw()<br/>        if current != start:<br/>            current.make_closed()<br/><br/>    return False</span></pre><p id="8a45" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个if语句将检查新的gscore是否更好，如果是的话，我们将把它作为下一个使用的节点。这一点很重要，因为我们不想后退，因为后退会增加gscore。然后，我们将这个值添加到我们用来监控我们所采用的路径的字典中，并添加这个值的te gscroe和fscore。如果该值不在开放集中，这意味着它是一个新的节点，这意味着我们需要增加计数器，这样我们就可以计算一个准确的g值。我们最后将这个值放入优先级队列，这样我们就可以在循环的下一次迭代中使用这个值。然后，我们将邻居设为绿色，这意味着它们将在下一次迭代中被检查。最后，我们将所有已经检查的值的边界设置为红色，我们有if语句，因为我们仍然希望保持起始节点的颜色不同。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="22da" class="io ip hi ik b fi iq ir l is it">def make_grid(rows, width):<br/>    grid = []<br/>    gap = width // rows<br/>    for i in range(rows):<br/>        grid.append([])<br/>        for j in range(rows):<br/>            spot = Spot(i, j, gap, rows)<br/>            grid[i].append(spot)<br/><br/>    return grid</span></pre><p id="ecbb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个函数在spot类之外，负责对spot进行排列，以便生成一个网格。首先，我们制作一个数组来存储所有这些点，这样我们就可以在程序中使用它们，然后使用输入，我们可以通过对宽度和行进行绝对分割来计算网格的尺寸。计算应该是直观的。然后，我们使用循环中的循环来创建每一行和每一列，当到达网格时，I循环负责y轴，而j循环负责x轴。每次它都会实例化到网格中，然后将其值追加到网格列表中。我们在spot = spot(…)行中传递Spot的属性，然后将我们创建的这个实例添加到网格中。一旦我们创建了网格，我们最终会返回网格，这样程序的其他部分就可以使用它。稍后将在draw函数中确定节点的位置。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="22d8" class="io ip hi ik b fi iq ir l is it">def draw_grid(win, rows, width):<br/>    gap = width //rows<br/>    for i in range(rows):<br/>        pygame.draw.line(win, GREY, (0, i*gap),(width, i*gap))<br/>        for j in range(rows):<br/>            pygame.draw.line(win, GREY, (j* gap, 0), (j* gap,width))</span></pre><p id="d363" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们希望节点对用户来说是容易区分的，因为现在它将作为一个白色的画布开始，所以为了使它更像一个网格，我们使用这个函数。我们再次计算间隙，然后以类似于创建节点网格的方式使用循环，我们将在画布上创建网格线。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="bac9" class="io ip hi ik b fi iq ir l is it">def draw(win, grid, rows, width):<br/>    win.fill(WHITE)<br/>    for row in grid:<br/>        for spot in row:<br/>            spot.draw(win)<br/><br/>    draw_grid(win, rows, width)<br/>    pygame.display.update()</span></pre><p id="ba1e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个draw函数在每次屏幕更新的时候都会被调用(和你电脑的帧率是一样的)，它也会负责白色画布，然后把每个点放到网格上正确的位置。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="3795" class="io ip hi ik b fi iq ir l is it">def get_clicked_pos(pos, rows, width):<br/>    gap = width //rows<br/>    y,x = pos<br/><br/>    row = y//gap<br/>    col = x//gap<br/>    return row, col</span></pre><p id="c093" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我们点击一个节点时(当我们在代码的开始处改变节点的类型时)，这个函数将获取鼠标的位置，然后转换像素形式的输入，然后通过使用绝对值并除以节点的维度将其转换成节点。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="c4af" class="io ip hi ik b fi iq ir l is it">def main(win, width):<br/>    ROWS = 50<br/>    grid = make_grid(ROWS, width)<br/>    start = None<br/>    end = None<br/>    run = True<br/>    started = False<br/>    while run:<br/>        draw(win, grid, ROWS, width)<br/>        for event in pygame.event.get():<br/>            if event.type ==pygame.QUIT:<br/>                run = False<br/>            if started:<br/>                continue<br/>            if pygame.mouse.get_pressed()[0]:  # left mouse button<br/>                pos = pygame.mouse.get_pos()<br/>                row, col = get_clicked_pos(pos, ROWS, width)<br/>                spot = grid[row][col]<br/>                if not start and  spot != end:<br/>                    start = spot<br/>                    start.make_start()<br/><br/>                elif not end and spot != start:<br/>                    end = spot<br/>                    end.make_end()<br/>                elif spot != end and spot != start:<br/>                    spot.make_barrier()<br/><br/>            elif pygame.mouse.get_pressed()[2]:<br/>                pos = pygame.mouse.get_pos()<br/>                row, col = get_clicked_pos(pos, ROWS, width)<br/>                spot = grid[row][col]<br/>                spot.reset()<br/>                if spot ==start:<br/>                    start = None<br/>                elif spot == end:<br/>                    end = None<br/><br/>            if event.type == pygame.KEYDOWN:<br/>                if event.key == pygame.K_SPACE and not started:<br/>                    for row in grid:<br/>                        for spot in row:<br/>                            spot.update_neighbours(grid)<br/>                    algorithm(lambda: draw(win, grid, ROWS, width), grid, start, end)   #having lambda lets you run the function inside the function<br/><br/>                if event.key == pygame.K_c:<br/>                    start = None<br/>                    end = None<br/>                    grid = make_grid(ROWS, width)<br/><br/><br/>    pygame.quit()<br/><br/><br/>main(WIN, WIDTH)</span></pre><p id="8126" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个函数是整个程序的控制中枢，让我们以正确的顺序运行所有的东西。我们在这里决定行数，所以如果您想要更多或更少的行，只需更改rows变量的值。我们首先要创建网格，因此我们为它运行函数并传入行，这将相应地改变节点和网格的大小，以便所有内容都适合800x800像素的窗口。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="3891" class="io ip hi ik b fi iq ir l is it">start = None<br/>end = None<br/>run = True<br/>started = False</span></pre><p id="1d45" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些行只是布尔值和变量，以确保程序不会启动，直到有一个开始和结束节点。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="50a3" class="io ip hi ik b fi iq ir l is it">while run:<br/>        draw(win, grid, ROWS, width)<br/>        for event in pygame.event.get():<br/>            if event.type ==pygame.QUIT:<br/>                run = False<br/>            if started:<br/>                continue<br/>            if pygame.mouse.get_pressed()[0]:  # left mouse button<br/>                pos = pygame.mouse.get_pos()<br/>                row, col = get_clicked_pos(pos, ROWS, width)<br/>                spot = grid[row][col]<br/>                if not start and  spot != end:<br/>                    start = spot<br/>                    start.make_start()<br/><br/>                elif not end and spot != start:<br/>                    end = spot<br/>                    end.make_end()<br/>                elif spot != end and spot != start:<br/>                    spot.make_barrier()<br/><br/>            elif pygame.mouse.get_pressed()[2]:<br/>                pos = pygame.mouse.get_pos()<br/>                row, col = get_clicked_pos(pos, ROWS, width)<br/>                spot = grid[row][col]<br/>                spot.reset()<br/>                if spot ==start:<br/>                    start = None<br/>                elif spot == end:<br/>                    end = None</span></pre><p id="17f5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们实际运行程序的寻路部分之前，这些行都负责创建程序的路线部分。我们画出网格，然后重写相同的退出函数，这样我们就可以在程序运行的时候退出窗口，因为我们现在陷入了while循环，这意味着我们不能使用另一个退出命令。然后我们说，如果我们左键单击，程序将确定我们所在的节点，然后检查我们是否选择了开始和结束节点，如果没有，那么我们将设置该节点，如果有开始和结束节点，那么我们将放置一个障碍。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="c64d" class="io ip hi ik b fi iq ir l is it">elif pygame.mouse.get_pressed()[2]:<br/>                pos = pygame.mouse.get_pos()<br/>                row, col = get_clicked_pos(pos, ROWS, width)<br/>                spot = grid[row][col]<br/>                spot.reset()<br/>                if spot ==start:<br/>                    start = None<br/>                elif spot == end:<br/>                    end = None</span></pre><p id="e0eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们右键单击pygame.mouse.get_pressed()[2]就会发生这种情况，等同于说右键单击。我们必须再次找到我们点击的节点，我们可以很容易地使用网格数组，然后对我们从列表中拉出的实体使用reset()方法。我们必须确保，如果我们重置起点或终点，我们重置相关变量，否则新的起点将不起作用。</p><pre class="if ig ih ii fd ij ik il im aw in bi"><span id="485e" class="io ip hi ik b fi iq ir l is it">if event.type == pygame.KEYDOWN:<br/>                if event.key == pygame.K_SPACE and not started:<br/>                    for row in grid:<br/>                        for spot in row:<br/>                            spot.update_neighbours(grid)<br/>                    algorithm(lambda: draw(win, grid, ROWS, width), grid, start, end)   #having lambda lets you run the function inside the function<br/><br/>                if event.key == pygame.K_c:<br/>                    start = None<br/>                    end = None<br/>                    grid = make_grid(ROWS, width)<br/><br/><br/>    pygame.quit()</span></pre><p id="938e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，当代码的寻路部分运行时，这最后一部分代码就发生了，这是在按下空格键之后。每次运行该行时，我们都会更新屏幕，然后运行算法函数，并传入一个lambda函数。通过传递一个lambda函数，我们可以在算法函数中运行这个函数，这是很常见的。</p><p id="43c4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，如果用户在他们的障碍中犯了一个错误，只是想重新开始，我们已经编写了一个将清除整个屏幕的语句，如果event.key == pygame。K_c表示如果按下字母c，然后我们重置开始和结束变量，然后在现有的网格上重新画一个新的网格。</p><p id="2516" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是最终完成的代码！</p></div></div>    
</body>
</html>