<html>
<head>
<title>Underscore phenomena in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python 中的下划线现象</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/underscore-phenomena-in-python-fdebcfdd45f0?source=collection_archive---------10-----------------------#2020-11-23">https://medium.com/analytics-vidhya/underscore-phenomena-in-python-fdebcfdd45f0?source=collection_archive---------10-----------------------#2020-11-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/60837add69647cc959e399ea9ec37931.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*ieViMYpHAxp5J9ouVjT-Ng.jpeg"/></div></div></figure><p id="2d63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我第一次接触下划线是在我高中开始学习 c++(T1)的时候。我的第一堂课是变量的命名惯例，有趣的是下划线是唯一可以在变量名中使用的非字母数字字符。后来在大学里，当我转向 Python 时，我发现下划线是如何以如此多的不同方式实现不同目标的，这非常有趣。<br/>这篇文章将有以下主题:</p><ul class=""><li id="27b5" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">单前导下划线</li><li id="4556" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">单个尾随下划线</li><li id="53f3" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">单个独立下划线</li><li id="9967" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">双前导下划线</li><li id="1597" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">双前导和尾随下划线</li></ul><p id="a089" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">_ single _ leading _ 下划线:</strong></p><p id="6693" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">许多在线资源将前导下划线定义为 python 中受保护的访问修饰符。但事实并非如此。Python 没有类似于 Java 或 C++等其他面向对象语言的访问修饰符。<br/>让我们看一个例子:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="c3b2" class="kl km hi kh b fi kn ko l kp kq">#file1.py<br/>class Example:</span><span id="fb07" class="kl km hi kh b fi kr ko l kp kq">def __init__(self):<br/>  self.foo = 1<br/>  self._bar = 2</span><span id="09fe" class="kl km hi kh b fi kr ko l kp kq">&gt;&gt;&gt; from file1 import Example<br/>&gt;&gt;&gt; example = Example()<br/>&gt;&gt;&gt; print(example.foo, example._bar)<br/>1 2</span></pre><p id="a868" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有趣的是，在方法名中有一个前导下划线确实会以某种方式改变它的行为。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="90ef" class="kl km hi kh b fi kn ko l kp kq"># file1.py<br/>def first_method():<br/>    print("output --- First Method")</span><span id="4fa6" class="kl km hi kh b fi kr ko l kp kq">def _second_method():<br/>    print("output --- second method")</span></pre><p id="f139" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们将这些函数导入到另一个文件中。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="3d11" class="kl km hi kh b fi kn ko l kp kq">from file1 import *</span><span id="60e6" class="kl km hi kh b fi kr ko l kp kq">first_method()<br/>_second_method()</span></pre><p id="934a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="2d25" class="kl km hi kh b fi kn ko l kp kq">output --- First Method<br/>Traceback (most recent call last):<br/>  File "file2.py", line 4, in &lt;module&gt;<br/>    _second_method()<br/>NameError: name '_second_method' is not defined</span></pre><p id="b2dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">产生上述输出的原因是，如果我们使用通配符导入从模块中导入所有名称，Python 将不会导入带有前导下划线的名称。PS:使用通配符导入从来都不是一个好主意。</p><p id="1507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">单 _ 尾 _ 下划线 _: </strong></p><p id="d66d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尾随下划线的任何特殊用法都完全是约定俗成的，而不是规则。有时最合适的变量名已经被 Python 语言中的一个<br/>关键字所采用。在这种情况下，您可以附加一个下划线来消除命名冲突:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="8409" class="kl km hi kh b fi kn ko l kp kq"><br/>&gt;&gt;&gt; def make_object(name, class):<br/>SyntaxError: “invalid syntax”<br/>&gt;&gt;&gt; def make_object(name, class_):<br/>        pass</span></pre><p id="ea5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> _: </strong></p><p id="9a07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单个下划线通常用作占位符变量。但这完全是惯例。例如，在下面的循环中，我们不需要访问运行索引，我们可以使用“_”来表示它只是一个临时值:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="b58f" class="kl km hi kh b fi kn ko l kp kq">for _ in range(32):<br/>    print('Hello, World.')</span></pre><p id="212e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者在下面这段代码中，我们只需要打印列表中每个元组的第一个和第三个属性，这样我们就可以<strong class="is hj"> <em class="ks">忽略</em> </strong>第二个。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="abed" class="kl km hi kh b fi kn ko l kp kq">list_ = [('red', 'suzuki', '2016'), ('Blue', 'suzuki', '2017'), ('Green', 'Sedan', '2017') ]</span><span id="6db7" class="kl km hi kh b fi kr ko l kp kq">for color, _, make in list_:<br/>    print(color, make)</span></pre><p id="52bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="c513" class="kl km hi kh b fi kn ko l kp kq">red 2016<br/>Blue 2017<br/>Green 2017</span></pre><p id="ce07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">_ _ 双前导下划线:</strong></p><p id="204f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上述三种命名模式中，我们到目前为止所涉及的一切都是约定俗成的。但是现在事情要改变了。</p><p id="ac71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“双下划线前缀导致 Python 解释器重写属性名<br/>，以避免子类中的命名冲突。”</p><p id="55e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们做一些实验:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="59df" class="kl km hi kh b fi kn ko l kp kq">class Test:</span><span id="d251" class="kl km hi kh b fi kr ko l kp kq">def __init__(self):<br/>  self.foo = 10<br/>  self._bar = 20<br/>  self.__baz = 30</span><span id="f1af" class="kl km hi kh b fi kr ko l kp kq">test = Test()<br/>print(test.foo, test._bar, test.__baz)</span></pre><p id="152c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="342f" class="kl km hi kh b fi kn ko l kp kq">Traceback (most recent call last):<br/>  File "file1.py", line 10, in &lt;module&gt;<br/>    print(test.foo, test._bar, test.__baz) <br/>AttributeError: 'Test' object has no attribute '__baz'</span></pre><p id="ae8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python 解释器无法识别测试类中的任何属性 __baz。让我们试着深入了解一下。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="f7fe" class="kl km hi kh b fi kn ko l kp kq">&gt;&gt;&gt; t = Test()<br/>&gt;&gt;&gt; dir(t)<br/>['_Test__baz', '__class__', '__delattr__', '__dict__',<br/>'__dir__', '__doc__', '__eq__', '__format__', '__ge__',<br/>'__getattribute__', '__gt__', '__hash__', '__init__',<br/>'__le__', '__lt__', '__module__', '__ne__', '__new__',<br/>'__reduce__', '__reduce_ex__', '__repr__',<br/>'__setattr__', '__sizeof__', '__str__',<br/>'__subclasshook__', '__weakref__', '_bar', 'foo']</span></pre><p id="8f20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">dir()给出了一个对象的属性列表。让我们看一下名单。自我。foo 和自我。_bar 变量在属性列表中显示为未修改。然而，与自我。_ _ 巴兹的东西看起来有点奇怪。没有属性 __baz。但是到底发生了什么呢？<br/>如果你仔细观察，你会发现这个对象上有一个名为 _Test__baz <br/>的属性。这是 Python 解释器<br/>应用的<em class="ks">名 mangling </em>。这样做是为了防止变量在<br/>子类中被覆盖。</p><p id="5d1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">_ _ double _ leading _ trailing _ 下划线 __: </strong></p><p id="40ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">令人惊讶的是，如果一个名字以<br/>开头并以双下划线结尾，那么就不会出现名称混淆。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="4e11" class="kl km hi kh b fi kn ko l kp kq">class PrefixPostfixTest:<br/>def __init__(self):<br/>    self.__bam__ = 42<br/>&gt;&gt;&gt; PrefixPostfixTest().__bam__<br/>42</span></pre><p id="2d8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，具有前导和尾随双 under- <br/>分数的名称在语言中被保留用于特殊用途。这条规则涵盖了像对象构造函数的 __init__ 或 __call__ 这样的事情，以使 o B-<br/>对象可调用。因此，为了避免任何麻烦，最好不要使用这样的名称，以避免与任何未来的 python 版本发生命名冲突。</p></div></div>    
</body>
</html>