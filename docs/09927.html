<html>
<head>
<title>Django: how to pass the user object into form classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django:如何将用户对象传递给表单类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/django-how-to-pass-the-user-object-into-form-classes-ee322f02948c?source=collection_archive---------2-----------------------#2020-09-27">https://medium.com/analytics-vidhya/django-how-to-pass-the-user-object-into-form-classes-ee322f02948c?source=collection_archive---------2-----------------------#2020-09-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/864c45be79ba685986e40555d7dc766c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3AA4b8l5SG41HL0SG4EOOQ.jpeg"/></div></div></figure><p id="50bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">更新(2022 年 6 月):我现在发布 Django 教程到</em> <a class="ae jp" href="https://ctrlzblog.com/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">我自己的网站</em> </a> <em class="jo">。如果你对这篇文章感兴趣(或者迷失在这篇文章中)，那么你可能会发现我的</em> <a class="ae jp" href="https://ctrlzblog.com/how-to-use-the-many-to-many-field-in-your-django-models/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">指南对许多领域</em> </a> <em class="jo">有用。</em></p><p id="71e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">昨天，我发表了一篇关于如何构建多字段表单的教程。后端工作几乎已经完成，除了一个我们将在本文中修复的错误。</p><h2 id="28d9" class="jq jr hi bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">一些背景:</h2><p id="60cc" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">我目前正在构建一个膳食规划应用程序。当用户创建新的一餐，我希望他们有复选框来选择哪些家庭成员将加入这一餐。每个用户的家庭成员列表都是唯一的。</p><p id="bb64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上一篇文章中，我使用 ModelMultipleChoiceField 类实现了表单功能，并用复选框替换了默认的小部件。你可以在这里了解更多。</p><div class="kq kr ez fb ks kt"><a rel="noopener follow" target="_blank" href="/@alicecampkin/django-forms-for-many-to-many-fields-d977dec4b024"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hj fi z dy ky ea eb kz ed ef hh bi translated">多对多字段的 Django 表单</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">如果您的字段是像文本字段这样的简单输入，那么用 Django 构建表单很简单，但是如果您的表单…</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">medium.com</p></div></div><div class="lc l"><div class="ld l le lf lg lc lh io kt"/></div></div></a></div><h2 id="e290" class="jq jr hi bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">问题是</h2><p id="0d96" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">ModelMultipleChoiceField 是一个 Django 表单类，设计用于多项选择输入，其中的选择来自另一个模型。</p><p id="3eac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该类采用一个名为 Queryset 的强制参数。Queryset 允许开发人员从其他模型中筛选选择。在这种情况下，我只希望与当前用户相关联的成员显示为选项。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="f6cb" class="jq jr hi ln b fi lr ls l lt lu"><strong class="ln hj"><em class="jo"><br/>forms.py</em></strong></span><span id="4393" class="jq jr hi ln b fi lv ls l lt lu">class CreateMealForm(forms.ModelForm):    <br/>    class Meta:<br/>        model = Meal<br/>        fields = [‘name’, ‘date’, ‘members’] <br/>   <br/>    name = forms.CharField()<br/>    date = forms.DateInput()    </span><span id="ebb3" class="jq jr hi ln b fi lv ls l lt lu">    members = forms.ModelMultipleChoiceField(<br/>        <strong class="ln hj">queryset=Member.objects.all(),</strong><br/>        widget=forms.CheckboxSelectMultiple<br/>    )</span></pre><p id="2d96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">未能从成员模型中过滤出对象给了我这样的结果:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/02e95626648b4cf07126fd7e38192454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2iJ2cTaTdMPRRgXRHrYt-Q.jpeg"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">queryset=member.objects.all()不起作用，因为我们可以看到所有用户的成员</figcaption></figure><p id="f913" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这不起作用，因为我可以看到另一个用户的家庭成员的名字。当前登录的用户有三个家庭成员:Anna、Adelaide 和 Axel。我的用户也不想看到杰克、杰斯、简和吉姆。</p><h1 id="adce" class="mb jr hi bd js mc md me jw mf mg mh ka mi mj mk kd ml mm mn kg mo mp mq kj mr bi translated">我们需要从表单类内部访问用户对象</h1><p id="ce90" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">我一定能做到吗？</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="0c51" class="jq jr hi ln b fi lr ls l lt lu">queryset=Member.objects.filter(user=self.request.user),</span></pre><p id="6589" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可惜没有。</p><p id="f966" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尝试这样做时，Django 提出了无法识别<em class="jo">‘self’</em>对象的错误。</p><p id="edf2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个问题是请求不是表单类的默认属性。</p><h2 id="6dd0" class="jq jr hi bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">我们需要做什么？</h2><ol class=""><li id="440e" class="ms mt hi is b it kl ix km jb mu jf mv jj mw jn mx my mz na bi translated">将请求对象从视图传递到表单实例。</li><li id="47af" class="ms mt hi is b it nb ix nc jb nd jf ne jj nf jn mx my mz na bi translated">定义为用户筛选的查询集。</li></ol><h2 id="855e" class="jq jr hi bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">解决办法</h2><p id="0fb5" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">首先，在您的<strong class="is hj">视图</strong>(我使用的是基于类的)中，添加一个名为‘get _ form _ kwargs(self)’的方法。</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="8c4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们覆盖了 get_form_kwargs 方法，这样我们可以添加额外的关键字参数传递给表单实例。</p><p id="849e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，在您的表单类中，我们覆盖 __init__ 函数来从 kwargs 中解包请求对象。</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="ng nh l"/></div></figure><h2 id="4ba1" class="jq jr hi bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">这是怎么回事？</h2><p id="d811" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">在 views.py 中，我们通过覆盖 get_form_kwargs 方法将请求对象添加到关键字参数(kwargs)列表中。</p><p id="8769" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过将<em class="jo">‘request’</em>添加到<em class="jo"> kwargs </em>，forms.py 现在可以访问它了。</p><p id="2542" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们仍然不能直接从 Queryset 调用'<em class="jo">请求'</em>。<em class="jo"> Request' </em>附加在' self '上，' self '是指类的单个实例。Queryset 是更广泛的类定义的一部分(就像一个蓝图)，所以放在那里的任何东西都将应用于所有实例(表单)，这对于每个用户来说都是不同的。</p><p id="bd20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相反，我们可以在 __init__ 函数中设置 Queryset。这是类构造函数，类被实例化时调用的方法。__init__ 内部运行的代码是特定于一个实例(和一个用户)的，所以我们可以使用<em class="jo">‘self’</em>对象。</p><p id="8362" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在 __init__ 函数中指定我们的 Queryset:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="16f5" class="jq jr hi ln b fi lr ls l lt lu">self.fields[‘members’].queryset = Member.objects.filter( user=self.request.user)</span></pre><p id="5a06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的 CustomModelMultipleChoiceField 仍然需要一个 Queryset 参数，但是我们可以只说'<em class="jo"> None' </em>。<em class="jo">“无”</em>将被 __init__ 中的查询集覆盖。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/adf6c6eb613bb81056e9d0455d335871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DsqjK6QSFTI5t70d6_f05w.jpeg"/></div></div></figure><p id="fced" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们只看到单个用户的成员。</p><p id="0341" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读。</p></div></div>    
</body>
</html>