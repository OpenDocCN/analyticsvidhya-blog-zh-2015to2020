<html>
<head>
<title>Slipstream — Saving and Loading Trained ML Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">滑流-保存和加载已训练的ML模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/slipstream-saving-and-loading-trained-ml-models-99ab6efe0584?source=collection_archive---------30-----------------------#2020-01-14">https://medium.com/analytics-vidhya/slipstream-saving-and-loading-trained-ml-models-99ab6efe0584?source=collection_archive---------30-----------------------#2020-01-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/75083214c50b217724c7606b26b288fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*Iy6Y3gZ4doT5R3lqbBcbWA.jpeg"/></div></figure><p id="f8b4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">“Slipstream”是一系列帖子，我希望读者在其中找到关于应用于投资的机器学习主题的指导，如数据预处理、EDA、ML模型、策略回溯测试和其他ML相关领域。我的例子和代码片段将会尽可能的简洁明了，以传达关键思想，而不是提供可读性差的冗长代码，这会损害帖子的目的。</p><p id="73c1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">机器学习模型训练可能是一项单调乏味的任务。除非我们有实时的需求来训练我们的模型——我..e .高频交易或短期投资范围策略—<strong class="io hj">提高效率的最佳方式是训练模型一次，保存并在最需要的时候上传</strong>,例如与其他模型进行比较，或使用最新发布的预测数据(如收益数据)预测新结果。</p><p id="8ef9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此外，我们可以考虑在另一个项目/策略中使用相同的模型结果。因此，保存一个训练好的模型并在我们方便的时候上传它将会在我们的生产流程中节省大量的时间。这些<strong class="io hj">“保存”和“加载”过程也被称为</strong> <a class="ae jl" href="https://en.wikipedia.org/wiki/Serialization" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj">序列化和反序列化</strong> </a></p><p id="85ad" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好消息是Python允许多种方法来执行我们的ML模型的序列化和反序列化:<strong class="io hj"> pickle模块、joblib模块和专有开发。</strong>下表提供了一个快速比较概述，当将pickle和joblib与一个更内部/专有的开发方法进行比较时，在灵活性和复杂性之间有明显的权衡。</p><figure class="jn jo jp jq fd ij er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jm"><img src="../Images/cdfafab633351e5e21e52c2cfca232f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jN5S9PEe-k8TuMPv1h3lIA.png"/></div></div></figure><p id="326d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">出于说明的目的，在不考虑超参数优化、交叉验证或数据预处理的情况下，创建了一个简单的ML模型。<strong class="io hj">这篇文章的目标是理解如何保存一个模型——无论它是复杂还是简单— </strong>因此接下来的几行脚本就足够了。理想情况下，我们应该做一些超参数优化和交叉验证，但我们会把数据留给其他旨在优化算法的帖子。</p><p id="22f0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">数据收集是第一阶段。假设我们的目标是开发一个模型来预测可口可乐(股票代码:KO)的每日走势，那么我们使用pandas_datareader模块来下载安全价格信息。此外，我们将根据简单的移动平均线和收益滞后为我们的模型创建几个预测器。下一步是在“训练”和“验证”之间拆分数据，并使用训练指数来定义我们的训练样本。最后但同样重要的是，<strong class="io hj">我们运行一个简单的logit模型，以便有一个ML模型可以使用。</strong></p><pre class="jn jo jp jq fd jv jw jx jy aw jz bi"><span id="fa52" class="ka kb hi jw b fi kc kd l ke kf"># Modules<br/>import time<br/>import pandas_datareader.data as web<br/>import numpy as np<br/>import pandas as pd<br/>import json<br/>from sklearn.model_selection import TimeSeriesSplit<br/>from sklearn.linear_model import LogisticRegression</span><span id="8185" class="ka kb hi jw b fi kg kd l ke kf"># data download:<br/>t_list = [‘KO’]<br/>s= ‘1999–12–31’<br/>e= ‘2018–12–31’ # Training Period 2000–2018<br/>df = web.get_data_yahoo(t_list, s,e) <br/>df = df[‘Adj Close’].copy() # Only Price</span><span id="d273" class="ka kb hi jw b fi kg kd l ke kf"># feature engineering: creating predictors<br/>t=df.columns # ticker<br/># SMA Rule Signals: <br/>SMA_L=200<br/>SMA_M=50<br/>SMA_S=10<br/>df[‘SMA_L’] = df[t].rolling(SMA_L).mean() <br/>df[‘SMA_M’] = df[t].rolling(SMA_M).mean() <br/>df[‘SMA_S’] = df[t].rolling(SMA_S).mean() <br/>df[‘X_ML_r’]= np.where(df[‘SMA_M’] &gt; df[‘SMA_L’], 1, -1) <br/>df[‘X_SM_r’]= np.where(df[‘SMA_S’] &gt; df[‘SMA_M’], 1, -1) <br/>df[‘X_SL_r’]= np.where(df[‘SMA_S’] &gt; df[‘SMA_L’], 1, -1)</span><span id="127e" class="ka kb hi jw b fi kg kd l ke kf"># Lag returns binary signals:<br/>lags=6 # number of predictors<br/>df[t+’_1d_r’]= np.log(df[t] / df[t].shift(1))<br/>for lag in range(1, lags + 1):<br/> df[t+’_’+str(lag)+’d_r’] =df[t+’_1d_r’].shift(lag)</span><span id="ad54" class="ka kb hi jw b fi kg kd l ke kf"># Define Model X and y<br/>df[t+’_y’] = np.sign(np.log(df[t].shift(-1)/df[t])) # dependent variable = 1 day future return on a binary basis<br/>df.dropna(inplace=True)<br/>X=df.filter(regex=’_r’).copy()<br/>y=df[t+’_y’]<br/>y.head(5)</span><span id="6caf" class="ka kb hi jw b fi kg kd l ke kf"># train/validation split:<br/>tscv = TimeSeriesSplit(n_splits=2) # generate train/cv indices =&gt; this generate 2 sets of train/cv indices<br/>train_idx = list(tscv.split(df))[1][0] # take the second set of train indices<br/>X=X.iloc[train_idx]<br/>y=y.iloc[train_idx]</span><span id="70e2" class="ka kb hi jw b fi kg kd l ke kf"># Model Training: Train simple Logit Model<br/>model= LogisticRegression()<br/>model.fit(X,y)<br/>model.score(X,y)</span><span id="9f51" class="ka kb hi jw b fi kg kd l ke kf">0.5158456228427989</span></pre><p id="4bc2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">既然我们的模型已经训练好了，那么让我们来讨论一下我们的三种方法，以便在将来有空的时候保存和加载它。</p><p id="f87c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">方法1: pickle模块</strong><br/><a class="ae jl" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank">Pickle模块</a>实现了一种基于二进制协议的算法，用于将Python对象结构Pickle(序列化)成字节流，并将字节流解Pickle(反序列化)回对象层次结构。Pickle很容易实现，但是它也存在一些缺陷，比如处理大数据的困难、对导入其他库的依赖、缺乏压缩选项以及无法存储数据(例如结果等)。</p><figure class="jn jo jp jq fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/a6ed09a810cb8726ef44caf0d4da0c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*GEHLAQ4cHcnZ22CZLzC5Ew.png"/></div></figure><p id="725e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我们导入pickle库，并定义一个变量来存储一个字符串，该字符串带有模型将要被序列化的pkl文件的名称。pickle.dump()允许我们将模型保存在所需的位置:</p><pre class="jn jo jp jq fd jv jw jx jy aw jz bi"><span id="85c5" class="ka kb hi jw b fi kc kd l ke kf"># import library<br/>import pickle</span><span id="f1f6" class="ka kb hi jw b fi kg kd l ke kf">pkl_file = “LOG_model.pkl”</span><span id="a468" class="ka kb hi jw b fi kg kd l ke kf"># Save model in current folder<br/>with open(pkl_file, ‘wb’) as file: <br/> pickle.dump(model, file)</span></pre><p id="ac82" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">其次，我们将加载回我们的模型，并确认logit模型已被成功反序列化:</p><pre class="jn jo jp jq fd jv jw jx jy aw jz bi"><span id="8d31" class="ka kb hi jw b fi kc kd l ke kf"># Load Model<br/>with open(pkl_file, ‘rb’) as file: <br/> load_model = pickle.load(file)<br/># check model:<br/>load_model.score(X,y)</span><span id="0cf9" class="ka kb hi jw b fi kg kd l ke kf">0.5158456228427989</span></pre><p id="f324" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">显然，模型加载正在工作，因为我们获得了完全相同的结果。我们本来可以执行额外的测试，但是为了本文的简洁起见，前面的测试已经足够了。<br/> <br/> <strong class="io hj">方法2: Joblib模块</strong><br/><a class="ae jl" href="https://scikit-learn.org/stable/modules/model_persistence.html" rel="noopener ugc nofollow" target="_blank">Joblib模块</a>是<a class="ae jl" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn模块</a>中的内置方法，可以更好地处理大数据。Joblib也以pickle格式保存模型，但是代码可读性显著提高，因为不需要导入其他库，而且它还允许存储数据。此外，Joblib可以处理文件对象和字符串文件名，而Pickle需要一个文件对象作为参数。最后但同样重要的是，在选择压缩格式(gzip、zlib、bz2’)和压缩程度时，Joblib提供了更广泛的选项。</p><p id="ce36" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面几行代码提供了joblib的一个简单实现，用于最初保存我们的模型:</p><pre class="jn jo jp jq fd jv jw jx jy aw jz bi"><span id="21a1" class="ka kb hi jw b fi kc kd l ke kf"># import library<br/>from sklearn.externals import joblib<br/># Save model in current folder:<br/>jl_file = “jl_LOG_model.pkl” <br/>joblib.dump(model, jl_file)</span></pre><p id="63de" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将再次通过加载以下内容来检查反序列化是否有效:</p><pre class="jn jo jp jq fd jv jw jx jy aw jz bi"><span id="2928" class="ka kb hi jw b fi kc kd l ke kf"># Load Model<br/>jl_load_model = joblib.load(jl_file)<br/># Check Model<br/>jl_load_model.score(X,y)</span><span id="8cd5" class="ka kb hi jw b fi kg kd l ke kf">0.5158456228427989</span></pre><p id="29d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的加载模型提供了相同的结果，所以这里也没有问题。正如上面的截图所示，与Pickle的纯对象语法相比，joblib允许以字符串格式传递文件对象和名称；这在使用joblib时提高了代码的可读性。</p><p id="b7dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">方法3:专有</strong> <br/>构建一个ML模型综合类来序列化和反序列化JSON格式的模型的可能性，允许完全控制哪些数据需要存储以及如何存储，此外还可以用任何文本编辑器打开JSON文件进行可视化检查。需要注意的一点是代码的可读性，因为随着需要更多的灵活性，语法的复杂性也会增加。另一个缺点是使用JSON格式而不是字节流，这对我们的基础设施的安全性有负面影响。最后但同样重要的是，如果ML研究者增加了任何新的变量/预测因子，这种方法需要持续修正；此外，有时Python中的sklearn ML模型对象可能有不同的结构，因此迫使管理员进一步调整下面的代码。</p><p id="016d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面的脚本展示了如何构建一个类来实现这个目的。首先，观察我们的类“my_model”是作为子类构建的，继承了父类(即“model”对象)的方法和属性。一旦新的子类“my_model”被创建，用户可以调用三个方法:</p><ul class=""><li id="46ff" class="ki kj hi io b ip iq it iu ix kk jb kl jf km jj kn ko kp kq bi translated"><strong class="io hj"> Mimic: </strong>通过复制一个已经创建的模型对象的实例来创建模型，该模型对象将作为新参数传递到函数(model_inst)中。</li><li id="29d8" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated"><strong class="io hj">保存:</strong>将模型信息以json格式保存在所需的目的地/名称(路径)中。</li><li id="a2f0" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated"><strong class="io hj">加载:</strong>从指定的目的地/名称(路径)加载json格式的模型信息。</li></ul><pre class="jn jo jp jq fd jv jw jx jy aw jz bi"><span id="d646" class="ka kb hi jw b fi kc kd l ke kf">## Import libraries<br/>import json</span><span id="186e" class="ka kb hi jw b fi kg kd l ke kf"># Reboot model object (Parent Class):<br/>model= LogisticRegression()</span><span id="bbce" class="ka kb hi jw b fi kg kd l ke kf"># Create Synthetic ML Model Class:<br/># build model class based on our model instance class e.g. LogisticRegression, SVM, etc<br/># Note; <br/>class my_model(model.__class__): <br/>    def __init__(self):<br/>        model.__class__.__init__(self) # 1</span><span id="fa1b" class="ka kb hi jw b fi kg kd l ke kf">def mimic(self, model_inst):<br/> ‘’’<br/> Create model based on copying an instance of an already created model <br/> Parameter<br/> — — — — -<br/> model_inst = enter model object instance with trained/fitted model<br/> ‘’’<br/>    list_ = list(filter(lambda x: x.endswith(‘_’)!=0 and      x.startswith(‘_’)==0 ,dir(model_inst))) # instance attributes (ending “_”)<br/>    for i in list_: # 2<br/>        setattr(self,i,eval(‘model_inst.’+eval(‘i’)))<br/> <br/> def save(self,path):<br/> ‘’’<br/> Save model information using json format.<br/> Params<br/> — — — <br/> path = file name using “name.json” format including path address where it will be stored in a different \<br/> directory than the current folder.<br/> <br/> ‘’’<br/>     dict_={‘path’:path}<br/>     array_param=[]<br/>     for i in self.__dict__.keys():<br/>         dict_[i]= eval(‘self.’+eval(‘i’))<br/>         if type(dict_[i]).__name__== ‘ndarray’: # 3<br/>             array_param.append(i)<br/>             dict_[i]=dict_[i].tolist() # 4 <br/>     dict_[‘array_param’]=array_param # 5<br/>     json_ = json.dumps(dict_, indent=4)<br/>     with open(path, ‘w’) as file:<br/>         file.write(json_)<br/> <br/> def load(self,path):<br/> ‘’’<br/> Load model information using json format.<br/> Params<br/> — — — <br/> path = file name using “name.json” format where the model info will loaded \<br/> including path address if the json file is in a folder different than the \<br/> current working directory<br/> ‘’’<br/>     with open(path, ‘r’) as file:<br/>         dict_load = json.load(file)<br/>         for p in dict_load[‘array_param’]:<br/>             dict_load[p] = np.array(dict_load[p]) # 6<br/> <br/>     for i in dict_load.keys():<br/>         setattr(self,i,dict_load[i])</span></pre><p id="2fb3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了阐明脚本中列举的代码行，下面几行提供了一些解释:</p><ol class=""><li id="873c" class="ki kj hi io b ip iq it iu ix kk jb kl jf km jj kw ko kp kq bi translated">初始化该类以加载父类的默认参数。</li><li id="b770" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kw ko kp kq bi translated">Mimic创建一个已训练模型对象(model_inst)的基本属性列表，允许在未来的会话中加载模型，而无需进一步训练。指出<a class="ae jl" href="https://docs.python.org/3/library/functions.html#setattr" rel="noopener ugc nofollow" target="_blank"> setattr </a>是一个非常有用的内置方法，可以在类中使用循环来分配新属性。</li><li id="639b" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kw ko kp kq bi translated">这一行测试元素是否是数组对象。</li><li id="a89b" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kw ko kp kq bi translated">这一行将数组元素转换成列表，因为json格式不支持数组对象。</li><li id="b97d" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kw ko kp kq bi translated">存储数组元素的名称对于将来加载模型时将它们转换回数组对象是很重要的。</li><li id="d103" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kw ko kp kq bi translated">将先前标识为数组格式的元素转换为数组格式，这些元素先前存储在save()方法中名为“array_param”的属性中。</li></ol><p id="5ee9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><br/>在进入下一部分之前，我们可以测试我们的类是否如预期的那样运行:</p><pre class="jn jo jp jq fd jv jw jx jy aw jz bi"><span id="ad4f" class="ka kb hi jw b fi kc kd l ke kf"># Create new model instance:<br/>test=my_model()<br/># Create a synthetic replica of our trained ML model object instance:<br/>test.mimic(model)<br/># Save our new synthetic model configuration:<br/>test.save(‘test.json’)</span><span id="6870" class="ka kb hi jw b fi kg kd l ke kf"># Restart your kernel/session<br/># Load your X,y data again<br/># Load ML Model:<br/>load_model = my_model()<br/>load_model.load(‘js.json’)<br/>load_model.__dict__ # check trained ML model info (coefficients, etc) is loaded</span></pre><p id="5d7f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出如下所示:</p><pre class="jn jo jp jq fd jv jw jx jy aw jz bi"><span id="608e" class="ka kb hi jw b fi kc kd l ke kf">{‘penalty’: ‘l2’,<br/> ‘dual’: False,<br/> ‘tol’: 0.0001,<br/> ‘C’: 1.0,<br/> ‘fit_intercept’: True,<br/> ‘intercept_scaling’: 1,<br/> ‘class_weight’: None,<br/> ‘random_state’: None,<br/> ‘solver’: ‘liblinear’,<br/> ‘max_iter’: 100,<br/> ‘multi_class’: ‘ovr’,<br/> ‘verbose’: 0,<br/> ‘warm_start’: False,<br/> ‘n_jobs’: 1,<br/> ‘path’: ‘js.json’,<br/> ‘classes_’: array([-1., 0., 1.]),<br/> ‘coef_’: array([[-0.01761617, 0.03940818, -0.04529708, -0.22983772, 0.54803269,<br/> -0.19148281, 0.13275605, 0.32121991, 0.21970841],<br/> [-0.08148684, 0.20891583, -0.22773737, -0.07924449, -0.0869601 ,<br/> 0.02197722, 0.07910192, 0.12206928, -0.03592072],<br/> [ 0.0194266 , -0.04965671, 0.05607809, 0.30001922, -0.47147896,<br/> 0.1708758 , -0.20327823, -0.4302993 , -0.18861738]]),<br/> ‘intercept_’: array([-0.08293168, -4.40521989, 0.0394294 ]),<br/> ‘n_iter_’: array([7]),<br/> ‘array_param’: [‘classes_’, ‘coef_’, ‘intercept_’, ‘n_iter_’]}</span></pre><p id="e307" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们最后的acid测试用训练数据检查分数:</p><pre class="jn jo jp jq fd jv jw jx jy aw jz bi"><span id="e167" class="ka kb hi jw b fi kc kd l ke kf">load_model.score(X,y)</span><span id="2cb2" class="ka kb hi jw b fi kg kd l ke kf">0.5158456228427989</span></pre><p id="4a31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">其他方法:超越本地地平线</strong> <br/>这篇文章旨在帮助读者更轻松地保存和加载本地机器学习实验的模型。然而，<strong class="io hj">这些方法在处理为企业目的插入生产中的巨大模型或大数据模型时存在不足</strong>。幸运的是，有其他方法可以使用远程数据库或云计算工具非本地地管理/存储模型，这使我们能够更有效地保存和加载ML模型，下面给出了一些例子:</p><ul class=""><li id="73a3" class="ki kj hi io b ip iq it iu ix kk jb kl jf km jj kn ko kp kq bi translated">将模型保存为文件，并将它们推送到一个<a class="ae jl" href="https://git-lfs.github.com/" rel="noopener ugc nofollow" target="_blank"> GIT LFS(大型文件存储)存储库中。</a></li><li id="9166" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated">将模型保存在SQL数据库或非SQL数据库中(例如<a class="ae jl" href="https://www.mongodb.com/cloud/atlas/lp/general/try?utm_source=google&amp;utm_campaign=gs_emea_united%20kingdom_search_brand_atlas_desktop&amp;utm_term=mongodb&amp;utm_medium=cpc_paid_search&amp;utm_ad=e&amp;gclid=CjwKCAiA6vXwBRBKEiwAYE7iS7KNt9Ufo00bSj3Wq_HtMh7D40Xctalv8r4d0Lm2tpTwrOTrKYkxJBoC42sQAvD_BwE" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>)</li><li id="431b" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated">一些ML库比如<a class="ae jl" href="https://www.tensorflow.org/tfx/guide/serving" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>有内置的保存/加载方法。</li><li id="4c17" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated">像<a class="ae jl" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> AWS的S3 </a>这样的云产品允许将我们的模型保存为对象而不是文档，因此这对于大型项目来说是非常好的，但是需要进行一些成本分析以确保我们不会超出预算，此外当存储对象而不是文件时，ML模型管理会更加混乱。</li><li id="6fc0" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated">其他库/开源解决方案也是:；</li><li id="c660" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated"><a class="ae jl" href="https://databricks.com/blog/2018/06/05/introducing-mlflow-an-open-source-machine-learning-platform.html" rel="noopener ugc nofollow" target="_blank">数据块</a></li><li id="f059" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated"><a class="ae jl" href="https://github.com/datmo/datmo" rel="noopener ugc nofollow" target="_blank"> Datmo </a></li><li id="aff7" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated"><a class="ae jl" href="https://github.com/vespa-engine/vespa" rel="noopener ugc nofollow" target="_blank"> Vespa发动机</a></li><li id="26eb" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated"><a class="ae jl" href="https://nexpy.github.io/nexpy/" rel="noopener ugc nofollow" target="_blank">联系</a></li><li id="52d5" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated"><a class="ae jl" href="https://dvc.org/" rel="noopener ugc nofollow" target="_blank"> DvC </a></li><li id="9d71" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated"><a class="ae jl" href="https://www.h2o.ai/products/h2o-driverless-ai/" rel="noopener ugc nofollow" target="_blank"> H20 </a></li></ul><p id="98a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">前一种方法在管理ML模型管道方面更现实，但是它们超出了本文的范围。“滑流”系列的后续文章将深入探讨与ML管理相关的更复杂的问题。</p><p id="8ce7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">推荐资源:</strong></p><ul class=""><li id="40b2" class="ki kj hi io b ip iq it iu ix kk jb kl jf km jj kn ko kp kq bi translated"><strong class="io hj">教程:</strong> <a class="ae jl" href="https://www.w3schools.com/python/python_classes.asp" rel="noopener ugc nofollow" target="_blank"> Python类</a></li><li id="72b1" class="ki kj hi io b ip kr it ks ix kt jb ku jf kv jj kn ko kp kq bi translated"><strong class="io hj">Github:</strong>T6】脚本</li></ul></div></div>    
</body>
</html>