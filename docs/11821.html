<html>
<head>
<title>Feature-matching using BRISK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 BRISK 进行特征匹配</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/feature-matching-using-brisk-277c47539e8?source=collection_archive---------5-----------------------#2020-12-20">https://medium.com/analytics-vidhya/feature-matching-using-brisk-277c47539e8?source=collection_archive---------5-----------------------#2020-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="661a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SIFT 的开源替代品</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d574bf5fd766384acceedf627adf628e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLIMuhr_hhYP18TGGjpMoA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">左图像边框在右图像中的位置上的投影</figcaption></figure><p id="d236" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想要一个应用程序，可以拍摄两张图像，并在第二张图像中检测第一张图像的位置，我也不想使用人工智能。</p><p id="50c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我需要做的可以总结为三步:<br/> 1。在第一幅图像上找到好的关键点(或特征)2。在第二张图片<br/> 3 上做同样的操作。将第一幅图像的关键点与第二幅图像的关键点进行匹配</p><p id="1e0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很简单，你说呢？！让我们看看我们的选择</p><p id="3c48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这么简单的任务，我不想使用人工智能，我刚刚开始学习人工智能，我是一个完全的新手，下一个最好的东西是一种叫做 SIFT 的算法！</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="6d08" class="ka kb hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated"><strong class="ak">筛</strong></h2><p id="1fbf" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">尺度不变特征变换(<strong class="ih hj"> SIFT </strong>)是计算机视觉中检测和描述图像局部特征的一种特征检测算法，由 David Lowe 于 1999 年开发，该算法及其开发者在 CV 领域都非常著名，<strong class="ih hj">但是，</strong>它已经申请了专利！</p><h2 id="24ea" class="ka kb hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated"><strong class="ak">轻快</strong></h2><p id="7a4f" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">BRISK 是一种具有尺度不变性和旋转不变性的特征点检测和描述算法，于 2011 年开发，作为 SIFT 的免费替代，并在 OpenCV 等著名的 CV 库中易于实现</p><h2 id="9442" class="ka kb hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated">第一步:寻找特征</h2><p id="28a5" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">为了说明这一点，我将使用下面两张图片:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/7d1b5337fd71441c925582c6b1ef3cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*k02cVMqiaUJBVkmrUF58VQ.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图片 1</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lb"><img src="../Images/b5d1b1a7d092eb9475664f3d2d6b45c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*SaRtd0-7M8jmKsyY0GcpzQ.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图片 2</figcaption></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lc ld l"/></div></figure><h2 id="aec3" class="ka kb hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated">说明</h2><p id="938f" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">我们需要计算两幅图像上的特征点，这些是算法感兴趣的点。</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="e85b" class="ka kb hi lf b fi lj lk l ll lm">detector = cv.BRISK_create()</span><span id="8d2c" class="ka kb hi lf b fi ln lk l ll lm">kp1, desc1 = detector.detectAndCompute(img1, None)</span></pre><p id="65f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们初始化一个检测器对象，并用它来计算每个点的特征和描述符，描述符将帮助我们匹配图像之间的点，下面是第一步的结果</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/b530978bc404c6b6ba9af9af5e999e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*q8NyLmPimfa0a6FOaTNQ8Q.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图像 1 的特征点</figcaption></figure><p id="a88d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像 2 也是如此</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lb"><img src="../Images/1e4756ef88044fd08c9b6e08e2184f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*S9oooywQ3WA1PLxTvKJpOg.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图像二的特征点</figcaption></figure><p id="165e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lo">请注意，如果您使用的是大图像，这可能需要更多时间，因此请考虑调整图像大小。</em></p><p id="2c23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在到了有趣的部分，我们把两张图片匹配起来，</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="3240" class="ka kb hi lf b fi lj lk l ll lm">FLANN_INDEX_LSH    = 6</span><span id="4bae" class="ka kb hi lf b fi ln lk l ll lm">flann_params= dict(algorithm = FLANN_INDEX_LSH,</span><span id="d0ad" class="ka kb hi lf b fi ln lk l ll lm">table_number = 6, <em class="lo"># 12</em></span><span id="bff2" class="ka kb hi lf b fi ln lk l ll lm">key_size = 12,     <em class="lo"># 20</em></span><span id="7477" class="ka kb hi lf b fi ln lk l ll lm">multi_probe_level = 1) <em class="lo">#2</em></span><span id="5c70" class="ka kb hi lf b fi ln lk l ll lm">matcher = cv.FlannBasedMatcher(flann_params, {})</span><span id="b7fd" class="ka kb hi lf b fi ln lk l ll lm">raw_matches = matcher.knnMatch(desc1, trainDescriptors = desc2, k = 2)</span></pre><p id="81f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">FLANN 是一个 matcher 对象，它会给我们可能包含一些不准确的匹配，为了消除不准确的点，我们使用 Low 的比率测试，这里我为它做了一个函数</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="ec50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还想围绕检测到的对象绘制一个边界框，我将使用单应来完成，简单地说，我将把第一个图像的边界投影到第二个图像的新位置上，这就是看起来的样子</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d574bf5fd766384acceedf627adf628e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLIMuhr_hhYP18TGGjpMoA.jpeg"/></div></div></figure><p id="b0c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我做了一个函数来做单应，下面是它的样子:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="5835" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里找到完整的代码<a class="ae lp" href="https://github.com/Hasan-Alsulaiman/BRISK-matching" rel="noopener ugc nofollow" target="_blank"/>，其中大部分是不言自明的，但是如果你有问题，请随时问我。</p></div></div>    
</body>
</html>