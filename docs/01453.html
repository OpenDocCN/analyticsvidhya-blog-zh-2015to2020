<html>
<head>
<title>Object Segmentation using Fuzzy Divergence in python: A case study over peripheral blood smears (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python中使用模糊散度的对象分割:外周血涂片的案例研究(上)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/object-segmentation-using-fuzzy-divergence-in-python-a-case-study-over-peripheral-blood-smears-de61ce5dc8d1?source=collection_archive---------12-----------------------#2019-10-23">https://medium.com/analytics-vidhya/object-segmentation-using-fuzzy-divergence-in-python-a-case-study-over-peripheral-blood-smears-de61ce5dc8d1?source=collection_archive---------12-----------------------#2019-10-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b2b0dcf5b0f0b59fde402e7dfb20290b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*E2mXwBhLQ5jFyZs5lmj98Q.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><a class="ae iq" href="https://www.google.com/url?sa=i&amp;source=images&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjOkPmNm7LlAhWt7HMBHSzwA5gQjhx6BAgBEAI&amp;url=https%3A%2F%2Fmmegias.webs.uvigo.es%2F02-english%2Fguiada_a_sanguineo.php&amp;psig=AOvVaw1j3ZLp0CEumLy2ubsLxnVj&amp;ust=1571914238260401" rel="noopener ugc nofollow" target="_blank">https://www.google.com/url?sa=i&amp;source = images&amp;CD =&amp;CAD = rja&amp;uact = 8&amp;ved = 2 ahukewjokpmnm 7 llahwt 7 hmbhszwa 5 gqjhx 6 bagbeai&amp;URL = https % 3A % 2F % 2fm megias . webs . uvigo . es % 2f 02-English % 2 fguiada _ a _ sanguineo . PHP&amp;psig = aovvaw 1j 3 zlp 0 ceum 2 UBS lxnvj【1</a></figcaption></figure><p id="eee2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">外周血涂片检查是一个便宜但不可避免的步骤，有助于诊断一些关键疾病，如白血病、溶血性贫血和血小板减少症。传统上，训练有素的实验室人员或医疗从业人员使用显微镜手工检查血涂片。最近，已经开发了自动化系统和过程来帮助在阶段、规格和规模的背景下更有效和广泛地分析血涂片。整个过程具有以下步骤:感兴趣区域(ROI)的分割、疾病/非疾病状况的ROI参数的识别和表征、阶段、规格和尺度的解释。因此，ROI分割是从外周血涂片中检测疾病状态的主要步骤之一。它是从图像中存在的一组不同区域中分离出特定区域的过程。在这个博客中，已经讨论了一种特定的方法，其中在阈值选择的模糊散度测量的帮助下，以自动的方式分割血液参数之一。</p><ul class=""><li id="3c4e" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated"><strong class="it hj">什么是血液参数，为什么需要它们来识别疾病？</strong></li></ul><p id="bc92" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">血液包含三种细胞:红细胞、白细胞和血小板。正常的血液涂片由两个因素描述，即足够数量的细胞和具有正常外观的细胞。但是当血液中细胞的大小、形状、颜色或数量异常时，就要考虑异常血涂片。异常结果可能因受影响的血细胞类型而异。血液相关疾病包括三种类型的疾病。</p><ul class=""><li id="cdf6" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated">红细胞疾病:缺铁性贫血、镰状细胞性贫血、溶血性尿毒症综合征、真性红细胞增多症</li><li id="0dff" class="jp jq hi it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx bi translated">白细胞疾病:急性或慢性白血病、艾滋病毒、丙型肝炎病毒感染、寄生虫感染、真菌感染(念珠菌病)、其他淋巴增生性疾病(骨髓瘤)</li><li id="cbe8" class="jp jq hi it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx bi translated">血小板血细胞疾病:骨髓增生性疾病、血小板减少症</li></ul><p id="0102" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">关于形状、大小、颜色、质地和对这些血液参数的计数的临床研究有助于勾勒出患病/非患病状况。</p><p id="d5f7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">案例研究:从血液涂片(显微图像)中分割白细胞(ROI)</strong></p><p id="d24a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">多年来，模糊技术被用作从背景中提取目标的主要技术方法之一。模糊散度是一种基于图像灰度直方图来处理目标和背景先验概率分布的技术。在这种情况下，从灰度直方图中对象-背景类的先验概率分布的信息内容的最大化中选择阈值。</p><h1 id="f636" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">要遵循的步骤:</h1><p id="c566" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated"><strong class="it hj">第一步:</strong> <strong class="it hj">将一幅灰度图像表现为一幅模糊图像</strong></p><p id="3a5a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">模糊图像是灰度值及其相应隶属度值的组合。假设一个大小为M×N的模糊图像被定义为灰度级和它的像素的隶属值的组合。特定像素的隶属值必须在区间[0，1]内。特定灰度级<em class="lg"> </em>的频率由该特定图像中出现的次数来定义。首先，基于(0，255)中的特定阈值，计算背景和目标区域的平均灰度级。第二，为了计算隶属度值(伽马隶属度)，已经考虑了像素所属区域的平均值和该像素的灰度级之间的距离的绝对值。</p><p id="1369" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">第二步:</strong> <strong class="it hj">区分模糊图像内的物体和背景</strong></p><p id="77d4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">基于隶属值计算背景和对象的区分度。考虑图像对象和背景作为独立的图像，因此我们可以计算它们之间的区别。图像中特定点(<em class="lg"> i，j </em>)处的对象和背景的信息量被描述为，</p><p id="1f7c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">exp(memOb[i，j]-member[I，j])</p><p id="e501" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">*memOb =对象的成员资格，memB =后台的成员资格</p><p id="60e8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">步骤3 </strong> : <strong class="it hj">使用香农指数熵计算两幅模糊图像之间的模糊散度</strong></p><p id="4824" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">基于香农的指数熵，我们可以用公式表示物体和背景之间的散度，</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lh"><img src="../Images/75020a4058fbfe769005914fcb67bf7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4GVEQqozSHHWKFC-r8xcg.png"/></div></div></figure><p id="e884" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">第四步</strong>:求产生最小散度值的阈值。</p><p id="8900" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">步骤5 </strong>:使用阈值从背景中分割出物体。</p><p id="f6eb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">步骤6 </strong>:对图像的分割部分进行图像重建。</p><h1 id="9f12" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结果:</h1><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/db1e8542d070871d6793d7641172644f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*XVUBc7Ckx5xkv1Pi"/></div><figcaption class="im in et er es io ip bd b be z dx translated">输入:原始图像</figcaption></figure><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/6875b3490eb0ebefbf9e4f3867572c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/0*2PQEZ49QlQvc4l60"/></div><figcaption class="im in et er es io ip bd b be z dx translated">发散图</figcaption></figure><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/5c712e3063d3b0ff64bb2b3c625bcc7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*DrTIJB2zgR_Pylks"/></div><figcaption class="im in et er es io ip bd b be z dx translated">分段血液颗粒</figcaption></figure><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/9b6897b965f46b2f35ae6f9c35f79f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*wptQO2ewAHWfFfWl"/></div><figcaption class="im in et er es io ip bd b be z dx translated">分节白细胞</figcaption></figure><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/09e5def3f2a68cf9cb4763bbfebbba0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*dM1SLp-Jod6UKmD7"/></div><figcaption class="im in et er es io ip bd b be z dx translated">输出:分段重建的白细胞</figcaption></figure><p id="4c2e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">python中的代码(jupyter笔记本):</p><pre class="li lj lk ll fd ls lt lu lv aw lw bi"><span id="1cb4" class="lx ke hi lt b fi ly lz l ma mb"># import all libraries <br/>import numpy as np<br/>from scipy import signal<br/>import cv2<br/>import pip<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/>import math<br/>from math import e<br/>from scipy.signal import find_peaks</span><span id="df3c" class="lx ke hi lt b fi mc lz l ma mb"># this function helps to find out the mean value for onject and background regions separately</span><span id="adb5" class="lx ke hi lt b fi mc lz l ma mb"># this function helps to find out the mean value for onject and background regions separately</span><span id="fff1" class="lx ke hi lt b fi mc lz l ma mb">def mean_obj_back(img, threshold):<br/>    <br/>    Y = img.shape[0]*img.shape[1]<br/>    # setting the max and min of histogram peaks within which <br/>      threshold point to be found<br/>    fmax = 250<br/>    fmin = 180<br/>    const = 1/(fmax-fmin)<br/>    # calculate the histogram    <br/>    hist,bins = np.histogram(img.ravel(),256,[0,256])<br/>    # set an arbitrary threshold point<br/>    th = threshold<br/>    # initialize the parameters<br/>    s0 = 0<br/>    s1 = 0<br/>    s00 = 0<br/>    s11 = 0<br/>    s = 0<br/>    s2 = 0<br/>    <br/>    for f in range(0,th):<br/>        s = bins[f]*hist[f]<br/>        num = s0 + s<br/>        den = s1 + hist[f] <br/>        s0 = num<br/>        s1 = den<br/>    # mue of object<br/>    mueOb = round(num/den)<br/>    <br/>    for f in range(th,256):<br/>        s2 = bins[f]*hist[f]<br/>        numb = s00 + s2<br/>        s00 = numb<br/>        denb = s11 + hist[f]<br/>        s11 = denb<br/>   # mue of background<br/>    mueB = round(numb/denb)<br/>   <br/>    return mueOb, mueB,const<br/># make a gray image to a fuzzy image <br/>def fuzzyImage(img,th,mueOb,mueB,const):<br/>    <br/>    for i in range(0, img.shape[0]):<br/>        for j in range(0, img.shape[1]):<br/>            if (img[i,j]&lt;th):<br/>                f = (-const) * abs(img[i,j] - mueOb)<br/>                mem[i,j] = np.exp(f)<br/>            else:<br/>                f1 = (-const) * abs(img[i,j] - mueB)<br/>                mem[i,j] = np.exp(f1)<br/>    return mem</span><span id="b74c" class="lx ke hi lt b fi mc lz l ma mb"># calculation of fuzzy divergence measure<br/>def fuzzydivergence(mem):<br/>    u1 = 0<br/>    for i in range(0, mem.shape[0]):<br/>        for j in range(0, mem.shape[1]):<br/>            p1 = (np.exp(mem[i,j]-1))<br/>            p2 = (np.exp(1-mem[i,j]))<br/>            h = (2 -((mem[i,j]+1)*p1)-(1-1+mem[i,j])*p2) + u1<br/>            u1 = h<br/>    return h<br/># calculate the divergence measurement between image object and image background<br/>def divergence(img):<br/>    div_vec = []<br/>    threshold =[]<br/>    fmax = 250<br/>    fmin = 180<br/>    for th in range(fmin,fmax):<br/>        const = 1/(fmax-fmin)<br/>        mueOb = mean_obj_back(img, th)[0]<br/>        mueB = mean_obj_back(img, th)[1]<br/>        mem = np.zeros((img.shape[0], img.shape[1]))<br/>        p = th<br/>        mem = fuzzyImage(img,p,mueOb,mueB,const)<br/>        h = fuzzydivergence(mem)<br/>        Y = img.shape[0] * img.shape[1]<br/>        div = h/Y<br/>        div_vec.append(div)<br/>        threshold.append(th)<br/>    <br/>    <br/>    return div_vec,threshold<br/># area based filter that will helps to filter out ROI from rest of the image<br/>def area_based_filter(binary):<br/>    #make binary image as integer type<br/>    binary = np.array(binary, dtype=np.uint8)<br/>    #find all your connected components (white blobs in your image)<br/>    nb_components, output, stats, centroids = cv2.connectedComponentsWithStats(binary, connectivity=8)<br/>    #connectedComponentswithStats yields every seperated component with information on each of them, such as size<br/>    #the following part is just taking out the background which is also considered a component, but most of the time we don't want that.<br/>    sizes = stats[1:, -1]; <br/>    nb_components = nb_components - 1<br/>    min_size = max(sizes)<br/>    # minimum size of particles we want to keep (number of pixels)<br/>    #here, it's a fixed value, but you can set it as you want, eg the mean of the sizes or whatever<br/>    #your answer image<br/>    result = np.zeros((output.shape))<br/>    #for every component in the image, you keep it only if it's above min_size<br/>    for i in range(0, nb_components):<br/>        if sizes[i] &gt;= min_size:<br/>            result[output == i + 1] = 255<br/>    return result</span><span id="992f" class="lx ke hi lt b fi mc lz l ma mb"># make binary of image<br/>def binarize_image(img,threshold_value):<br/>    binary = np.zeros((img.shape[0], img.shape[1]))</span><span id="1b8d" class="lx ke hi lt b fi mc lz l ma mb">    for i in range(0, img.shape[0]):<br/>            for j in range(0, img.shape[1]):<br/>                if (img[i,j] &lt; threshold_value):<br/>                    binary[i,j] = 255<br/>                else:<br/>                    binary[i,j] = 0<br/>    return binary</span><span id="ff44" class="lx ke hi lt b fi mc lz l ma mb"># fill the segmented region holes<br/>def img_fill(im_in):  # n = binary image threshold<br/>    #th, im_th = cv2.threshold(im_in, n, 255, cv2.THRESH_BINARY);<br/>    im_th = im_in.astype('uint8')<br/>    <br/>    # Copy the thresholded image.<br/>    im_floodfill = im_th.copy()</span><span id="8eb1" class="lx ke hi lt b fi mc lz l ma mb">    # Mask used to flood filling.<br/>    # Notice the size needs to be 2 pixels than the image.<br/>    h, w = im_th.shape[:2]<br/>    mask = np.zeros((h + 2, w + 2), np.uint8)</span><span id="a997" class="lx ke hi lt b fi mc lz l ma mb">    # Floodfill from point (0, 0)<br/>    cv2.floodFill(im_floodfill, mask, (0, 0), 255);</span><span id="57b0" class="lx ke hi lt b fi mc lz l ma mb">    # Invert floodfilled image<br/>    im_floodfill_inv = cv2.bitwise_not(im_floodfill)</span><span id="a77b" class="lx ke hi lt b fi mc lz l ma mb">    # Combine the two images to get the foreground.<br/>    fill_image = im_th | im_floodfill_inv</span><span id="739b" class="lx ke hi lt b fi mc lz l ma mb">    return fill_image</span><span id="023e" class="lx ke hi lt b fi mc lz l ma mb">Path_to_image  = '.../Original_Image.jpg'</span><span id="a80e" class="lx ke hi lt b fi mc lz l ma mb"># read image from directory path<br/>img = cv2.imread(path_to_image) <br/># make it gray<br/>img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)<br/># get the histogram<br/>hist,bins = np.histogram(img.ravel(),256,[0,256])<br/># define a membership mask for processing<br/>mem = np.zeros((img.shape[0], img.shape[1]))<br/># find out the divergence measure for segmentation <br/>diver,thr = divergence(img)<br/># find out the minimum divergence value<br/>min_diver = min(diver)<br/>index = [i for i,x in enumerate(diver) if x == min_diver]<br/>val = index.pop()<br/># find out the threshold value for which divergence value is minimum<br/>threshold_value  = thr[val]<br/># binarize the image using the threshold value<br/>binary = binarize_image(img, threshold_value)<br/># set an area based filter to get region of interest (ROI)<br/>area_filtered_image = area_based_filter(binary)<br/># fill up segmented area for reconstruction of original ROI<br/>fill_img = img_fill(area_filtered_image)<br/># remap segmented ROI with original gray image ROI<br/>out = fill_img.copy()<br/>out[fill_img == 255] = img[fill_img == 255]</span><span id="38e0" class="lx ke hi lt b fi mc lz l ma mb">## Plot the results<br/>fig, axes = plt.subplots(ncols= 2, figsize=(10, 5))<br/>ax = axes.ravel()</span><span id="fff8" class="lx ke hi lt b fi mc lz l ma mb">ax[0].imshow(img, cmap=plt.cm.gray)<br/>ax[0].set_title('Original Image')<br/>ax[0].axis('off')<br/>ax[1].plot(diver)<br/>ax[1].set_title('Divergence Plot')<br/>ax[1].axis('on')</span><span id="d4f3" class="lx ke hi lt b fi mc lz l ma mb">plt.show()</span><span id="4d45" class="lx ke hi lt b fi mc lz l ma mb">fig, axes = plt.subplots(ncols= 3, figsize=(15, 8))<br/>ax = axes.ravel()</span><span id="ce49" class="lx ke hi lt b fi mc lz l ma mb">ax[0].imshow(binary, cmap=plt.cm.gray)<br/>ax[0].set_title('Thresholded')<br/>ax[1].imshow(fill_img, cmap=plt.cm.gray)<br/>ax[1].set_title('Segmented_Leukocyte')<br/>ax[2].imshow(out, cmap=plt.cm.gray)<br/>ax[2].set_title('Reconstructed_Leukocyte ')<br/>for a in ax:<br/>    a.axis('off')<br/>plt.show()</span></pre><p id="74aa" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">请参考我关于美光、爱思唯尔的论文</p><p id="217d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><a class="ae iq" href="https://www.sciencedirect.com/science/article/pii/S0968432810001071" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj"> <em class="lg"> Madhumala Ghosh，Dev Kumar Das，Chandan Chakraborty，Ajoy K Ray，使用模糊散度的自动白细胞识别，Micron Vol-41，Issue -7，2010年10月，第840-846页。</em> </strong> </a></p><p id="f340" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">结论</strong></p><p id="25c8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">通过检查不同的血液参数，从血液中测量健康状况。每当血液参数测量值异常或不一致时，都会反映在您的健康危害中。这就是为什么了解可能导致基本健康问题的常见血液疾病非常重要。常见的血液疾病有<a class="ae iq" href="https://www.hematology.org/Patients/Anemia/" rel="noopener ugc nofollow" target="_blank">贫血</a>、<a class="ae iq" href="https://www.hematology.org/Patients/Bleeding.aspx" rel="noopener ugc nofollow" target="_blank">出血性疾病</a>如<a class="ae iq" href="https://www.hematology.org/Patients/Bleeding.aspx#a2" rel="noopener ugc nofollow" target="_blank">血友病</a>、<a class="ae iq" href="https://www.hematology.org/Patients/Clots/" rel="noopener ugc nofollow" target="_blank">血块</a>和<a class="ae iq" href="https://www.hematology.org/Patients/Cancers/" rel="noopener ugc nofollow" target="_blank">血癌</a>如<a class="ae iq" href="https://www.hematology.org/Patients/Cancers/Leukemia.aspx" rel="noopener ugc nofollow" target="_blank">白血病</a>、<a class="ae iq" href="https://www.hematology.org/Patients/Cancers/Lymphoma.aspx" rel="noopener ugc nofollow" target="_blank">淋巴瘤</a>和<a class="ae iq" href="https://www.hematology.org/Patients/Cancers/Myeloma.aspx" rel="noopener ugc nofollow" target="_blank">骨髓瘤</a>。甚至像疟疾这样的寄生虫感染也可以从血液参数中识别出来。血液涂片的自动化表征取代了人工判读，有助于优化人工误差，减少人工工作量，并最大限度地减少昂贵的资源利用和化学品。从今以后，在未来的连续博客中，我将详细解释血液参数将如何导致检测具有与疾病状况相关的有意义特征的血液相关疾病。回头见。</p></div></div>    
</body>
</html>