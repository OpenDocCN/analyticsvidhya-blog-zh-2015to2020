<html>
<head>
<title>Clustering Taxi Geolocation Data To Predict Location of Taxi Service Stations (Pt 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚类出租车地理位置数据以预测出租车服务站的位置(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/clustering-taxi-geolocation-data-to-predict-location-of-taxi-service-stations-pt-2-the-end-is-de13da87f3ff?source=collection_archive---------10-----------------------#2020-09-06">https://medium.com/analytics-vidhya/clustering-taxi-geolocation-data-to-predict-location-of-taxi-service-stations-pt-2-the-end-is-de13da87f3ff?source=collection_archive---------10-----------------------#2020-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a4d615365e3e8db18664697b8eb4b6c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E88uXKulc7R5bYLe.png"/></div></div></figure><p id="b37c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你好，欢迎回来！</p><p id="3998" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先谢谢你这么有耐心。我们差不多完成了。</p><p id="be2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文是<strong class="is hj"> <em class="jo">【聚类出租车地理位置数据预测出租车服务站位置】</em> </strong> <em class="jo">分步指南的<em class="jo">后续</em>。</em></p><p id="bfb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个很大的话题，所以我决定分成两部分，本文是第2部分。</p><p id="f120" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我以前的文章中——“<a class="ae jp" rel="noopener" href="/analytics-vidhya/clustering-taxi-geolocation-data-to-predict-location-of-taxi-service-stations-pt-1-2471303e0965">聚类出租车地理位置数据以预测出租车服务站的位置(Pt 1) </a>”和“<a class="ae jp" rel="noopener" href="/analytics-vidhya/clustering-taxi-geolocation-data-to-predict-location-of-taxi-service-stations-answering-important-82535ed9bf57">聚类出租车地理位置数据以预测出租车服务站的位置——回答重要问题</a>”我们讨论了如何使用K-Means聚类来分析出租车等级的地理位置数据以预测在哪里建立出租车服务站。尽管听起来感觉不错，但结果并不令人满意。我觉得我们可以做得更好，所以在这篇文章中，我将告诉你我们如何通过使用DBSCAN(基于密度的带噪声应用空间聚类)、HDBSCAN(分层DBSCAN)来改进我们现有的模型，然后通过使用KNN(K-最近邻)来解决异常值来画龙点睛。</p><p id="05a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么我们需要改进我们当前的模型？-我们已经在前面的文章中详细讨论过了。</p><p id="d2c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们为什么使用DBSCAN和HDBSCAN？K-means在聚类大小和密度不同的数据时有困难。由于人口密度在我们的问题陈述中起着主要作用，DBSCAN和hdb在这里可以占上风。</p><p id="3297" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以事不宜迟，让我们开始工作吧。</p><h1 id="8755" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">先决条件:</strong></h1><ol class=""><li id="41f0" class="ko kp hi is b it kq ix kr jb ks jf kt jj ku jn kv kw kx ky bi translated"><a class="ae jp" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html" rel="noopener ugc nofollow" target="_blank"> DBSCAN(带噪声的应用程序的基于密度的空间聚类)</a></li><li id="6172" class="ko kp hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated"><a class="ae jp" href="https://hdbscan.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> HDBSCAN(分级数据库扫描)</a></li><li id="e21d" class="ko kp hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated"><a class="ae jp" href="https://towardsdatascience.com/machine-learning-basics-with-the-k-nearest-neighbors-algorithm-6a6e71d01761" rel="noopener" target="_blank"> KNN (K近邻)</a></li></ol><h1 id="feaf" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">1.带噪声应用的基于密度的空间聚类</h1><p id="ce52" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">基于密度的噪声应用空间聚类。从名称中，我们可以假设DBSCAN查看区域的密度，并根据数据集中某个样本区域的密度来分配聚类。这可能对我们的事业有所帮助，因为我们知道市中心的出租车数量非常多，越往郊区越少。因此，这将有助于我们的重叠集群不同的集群。</p><p id="4a23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在第一段代码中有一个虚拟数组，我们假设这些都是簇，-1，-1，-1是噪声值，而不是实际的簇。假设我们希望将这些噪声值中的每一个作为一个集群来唯一地寻址。我想把第一个-1指定为-2，其他的指定为-3，-4。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/d8a11defb5066603963c1d96ca334c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJgydszOt-q9uDIEoLARyQ.png"/></div></div></figure><p id="7351" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当我们观察剪影分数时，这对我们很重要。我们想要表明，当我们有一个有噪声的数据(<strong class="is hj">有噪声的数据</strong>是其中有大量额外的无意义信息的数据，称为噪声。这包括数据<strong class="is hj"> </strong>损坏，该术语通常用作损坏数据的同义词。它还包括用户系统不能正确理解和解释的任何数据)我们并没有完全忽略它。我们想观察如果它被选为<strong class="is hj">单例集群</strong>会对我们的数据集产生什么影响。单个簇是指只有一个点的簇。</p><p id="7ff3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行之后，我们可以开始训练我们的第一个DBSCAN模型。它有助于定义一个半径，在该半径内标记并考虑潜在的聚类。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/ee5a78ccb881f0b347c2f97fda8a499a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ygoG-YdQxWCeX6Dw5z16A.png"/></div></div></figure><p id="91d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还需要找出以下参数——聚类数、原始侧影得分、离群值数、忽略离群值的侧影得分(其中类预测不等于-1)。我们将每个异常值视为一个单独的聚类。这是我们的输出结果--</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/d13edaae110d07361a454704bb95f85b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-iBaM4EPakNlXJvTaxPdw.png"/></div></div></figure><p id="a965" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">高轮廓分数(忽略异常值)表示那些被聚类的点被很好地聚类。但是当我们把异常值当作单值时，分数就很小了。我们需要努力解决这个问题。</p><p id="622d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们现在的地图。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/20f09435705fb3662e15466db1982c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ia2PzOC7-PnQvgnOYJMEg.png"/></div></div></figure><p id="5d93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看起来不错，但是，你需要看看这个-</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/2ccf8d4ae9fa60c0f0d028e318af6c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QabjlpP1UFuGbrSm9-pzLg.png"/></div></div></figure><p id="b50e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你看到了吗？</p><p id="0eb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">DBSCAN的局限性:如果有两个人口密集的区域；一个比另一个稍大，它用相同的密度参数处理它们。这也需要修理。</p><p id="e765" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就引出了我们的下一部分——使用HDBSCAN改进我们当前的模型。</p><h1 id="c16e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">2.HDBSCAN(带噪声的应用程序的基于层次密度的空间聚类)</h1><p id="4c78" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">分级DBSCAN。训练这个类似于DBSCAN。HDBSCAN会挑出异常值。这不是一个缺点，但鉴于我们的数据集，我们希望所有的点都以相同的方式聚集。</p><p id="d473" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以跳回到以前的代码，找到一种方法，让我们给离群值一个单独的颜色。</p><p id="936a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个简单的if语句。这意味着，如果我们正在寻找的当前聚类是-1，那么它在我们的算法中被分类为异常值，并被设置为特定的颜色..说黑。我们在这里给出了颜色的十六进制代码。</p><p id="138d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其他一切都与我们在DBSCAN中所做的一样。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/3f968f63c06869bba81a9e87d2673aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvYSgFe6ysgZ2v2ZrTeUbw.png"/></div></div></figure><p id="39de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们的输出，我们将观察我们的参数值来检查模型的性能。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/cf26aa6c636ea27409d06a582a6f6151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*rwXzZlngv5Yrr5y0VrN9fA.png"/></div></figure><p id="059c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们将此与我们在DBSCAN模型中获得的输出进行比较，我们可以看到这里有更多的聚类和更少的离群值。密度的变化很有帮助，因为我们发现了更多的集群和更少的异常值。这意味着当我们使用HDBSCAN时，那些被聚类的点被更好地聚类。此外，我们的侧影得分(忽略异常值和使用异常值作为单值，分别)比上次有更小的差异，并且肯定有所改善。</p><p id="d062" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，我相信我们已经解决了目前面临的所有问题。这是一个好迹象。这是我们现在的地图。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/c77abc9920e42666d4ca5a38a10a3ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5kp1R5YYu4LvaPfasGDrg.png"/></div></div></figure><p id="3050" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你怎么想呢?看起来比上次干净多了。异常值不仅仅是第一眼就能看出来，如果我们点击这些点也会看出来。标记的值是-1，这意味着这些点没有被聚类。</p><p id="f09d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，看一下-</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/a25c45ea188de50de23bed8ba16643b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ew_-WE0rPkyTnGoK"/></div></div></figure><h1 id="bcc6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">3.处理异常值</h1><p id="b961" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">这里我们将定义一种方法来处理这些异常值。我们可以尝试使这些离群值成为其他现有集群的一部分。我们可以通过使用<strong class="is hj"> K最近邻(KNN </strong>)方法来做到这一点。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="22b5" class="jq jr hi bd js jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn bi translated">KNN算法是如何工作的？</h1><p id="07db" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">我们举一个简单的案例来理解这个算法。以下是红色圆圈(RC)和绿色方块(GS)的分布:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/26f47cd66e975b1c0faf862a20de968c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rMV6UiSIPbSOVNuE.png"/></div></div></figure><p id="7c85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们打算找出蓝星的等级(BS)。BS可以是RC，也可以是GS，不能是别的。“K”是KNN算法，是我们希望进行投票的最近邻。假设K = 3。因此，我们现在将画一个以BS为中心的圆，这个圆的大小正好能在平面上包含三个数据点。有关更多详细信息，请参考下图:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/fc3816ef54a217f765a8ac1c00d130ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-SX3-lkmD5R5wzX8.png"/></div></div></figure><p id="1bb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">离BS最近的三个点都是RC。因此，在良好的置信度下，我们可以说BS应该属于RC类。这里，选择变得非常明显，因为来自最近邻居的所有三张选票都投给了RC。</p><p id="b3e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该算法中，参数K的选择非常关键。接下来，我们将了解得出最佳k需要考虑哪些因素。</p><h1 id="3027" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">我们如何选择因子K？</h1><p id="89c0" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">首先让我们试着理解K在算法中到底影响了什么。如果我们看到最后一个例子，假设所有的6个训练观察值保持不变，用给定的K值我们可以做出每个类的边界。这些界限将RC从GS中分离出来。同样，让我们来看看值“K”对类边界的影响。以下是分隔具有不同k值的两个类别的不同边界。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/a5decc252803e0b09f4aaf0faa184045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6DcKM6GqcH9NIG99.png"/></div></div></figure><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/d2007bc2e5af6603ef0034ba146366f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qP-IDhr2p_s6acho.png"/></div></div></figure><p id="1e2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果仔细观察，您会发现随着K值的增加，边界变得更加平滑。随着K值增加到无穷大，它最终会变成全蓝色或全红色，这取决于总多数。训练错误率和验证错误率是我们需要访问不同K值的两个参数。下面是具有不同K值的训练错误率的曲线:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/55cb989e1a10bf57ea2e53274583d2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w7uyDp3WBMmqaWk5.png"/></div></div></figure><p id="6fc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，对于训练样本，K=1时的错误率始终为零。这是因为最接近任何训练数据点的点是它本身。因此，当K=1时，预测总是准确的。如果验证误差曲线相似，我们选择的K应该是1。以下是不同K值的验证误差曲线:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/634295de6ecfa11c252b54d44190bf70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B9ZYXMAeXyh0T4qh.png"/></div></div></figure><p id="da8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这让故事更加清晰。在K=1时，我们对边界进行了<strong class="is hj">过度拟合</strong>(过度拟合是一种建模错误，当一个函数过于接近有限的数据点集合时就会出现这种错误)。因此，错误率最初降低并达到最小值。在最小值点之后，它随K的增加而增加。为了获得K的最佳值，可以将训练和验证与初始数据集分开。现在绘制验证误差曲线，以获得最佳K值。该K值应用于所有预测。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="31a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回到我们的讨论。现在我们必须在这里设置n _ neighbour参数。本质上，它所做的是找到离最近的分类样本最近的未分类样本，并将其设置为另一个聚类所属的任何点。我们在这里将其设置为1，但我们可以将其设置为3，这样它将挑选3个最近的邻居，并将其放入与这三个最相似的聚类中。</p><p id="5f0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们要做的是将现有数据分成训练和测试数据集。我们必须将聚类的点作为我们的训练数据，然后从没有聚类的点推断数据。一种简单的方法是创建两个新的数据框。一个是HDBSCAN不为-1的数据，另一个是为-1的数据。最后我们要做的就是预测和绘制地图。完美的教科书程序。你看了就明白了。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/e65a31ab0b0761dde3adf8448b3e0c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*AUGJ7fme8ZtJkmCboafmyA.png"/></div></div></figure><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/c3787f2e96ba3fa368fc12e6ecc7c0fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hJKo4j4FcI2Se64N77SAQ.png"/></div></div></figure><p id="5af6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">x预测是以前被标记为异常值的值。所以预测给了我们很多非-1的数字。</p><p id="06a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，理想情况下，我们想要做的是在数据集中创建一个新列，包括这个新的聚类算法，称为混合模型。我们创造了它。然后我们设定我们的预测。</p><p id="b6e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，这个新的集群将为我们提供混合预测，现在我们只需像之前一样绘制它。我们使用原始数据框创建地图，并包含新的混合列。</p><p id="05e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">混合地图看起来像这样:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/9f4476d374bde1e8da6ecdbb220e0f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wiXptxNTNFd3PsKoynow2g.png"/></div></div></figure><p id="c854" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到异常值在左侧是橙色的，这意味着它们已经与最近的组聚集在一起，因此我们已经消除了异常值的问题。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/74acb51af4ef5b44c36010c2f584ca54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lst-WmYPxZOYXMao33iL3g.png"/></div></div></figure><p id="13e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然剪影的分数比我们在K均值中的分数低，但是如果我们放大的话，聚类的效果会更好。</p><p id="1cf9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种聚类更好，因为它是基于密度的，我们希望在人口密集的地区建立服务站，而K-Means没有考虑到这一点。</p><p id="b04a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以做的是通过直方图来比较K-Means和基于密度的方法。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/9910816e18151ca7570919a536d59a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWXWzJcxjQ-OeSp7d5ARbA.png"/></div></div></figure><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/c02a18370ad44171aefdc6f7de839d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pI3rXN4BiXKlPnRcgQo7_Q.png"/></div></div></figure><p id="488c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结论:混合方法有更多的聚类，给我们提供了一个更好的方法来建立服务站。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="2b21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这样了，伙计们。我很高兴地告诉你，我们的项目已经成功完成。</p><p id="1367" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你是一个伟大的观众。谢谢你这么有耐心，这是一个很棒的项目，一开始有点吓人，但非常令人兴奋，你说呢？</p><p id="1958" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在这个项目上度过了一段美好的时光，在写作上更是如此。</p><p id="c9a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下次我会带着更好的内容回来。</p><p id="2fcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在那之前，再见！还有快乐编码！！</p></div></div>    
</body>
</html>