<html>
<head>
<title>Jenks Natural Breaks — The Best Range Finder algorithm.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jenks自然间断——最佳测距算法。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/jenks-natural-breaks-best-range-finder-algorithm-8d1907192051?source=collection_archive---------0-----------------------#2019-04-04">https://medium.com/analytics-vidhya/jenks-natural-breaks-best-range-finder-algorithm-8d1907192051?source=collection_archive---------0-----------------------#2019-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/8002798a57451bb1ec8f79bb3bd9adf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*PfECAtgWc7T4oGiq.png"/></div></figure><p id="d8ed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这篇文章试图给这个晦涩的便捷工具一个清晰的描述。</p><p id="dc23" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> Jenks优化方法</strong>，也称为<strong class="io hj"> Jenks自然间断分类方法</strong>，是<a class="ae jk" href="https://towardsdatascience.com/the-5-clustering-algorithms-data-scientists-need-to-know-a36d136ef68" rel="noopener" target="_blank">数据聚类方法</a>中的一种，旨在确定不同类中值的最佳排列。但是在继续之前，让我们看看“自然休息”是什么意思。</p><p id="9781" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jl">自然间断:“T8】 </em></strong>自然间断”是分割范围的最佳方式。最佳范围意味着相似区域被组合在一起的范围。这种方法最大限度地减少了每个范围内的变化，因此每个范围内的区域在值上尽可能接近。</p><p id="b316" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jl">直觉</em></strong>:Jenks natural breaks算法，就像K-means一样，将数据分配给K个组中的一个，使得组内距离最小化。就像K-means一样，我们必须在运行算法之前选择K。</p><p id="6be2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jl">为什么手动设置不是一个好主意:</em> </strong>通常<strong class="io hj">不切实际</strong>因为会有大量不同的方式来设置范围<strong class="io hj">不准确</strong>因为它破坏了数据的客观显示<strong class="io hj">。在用户可以测试的几个图案中，几乎肯定会选择“最漂亮”的图案，但这与数据的正确显示无关。</strong></p><h2 id="9f86" class="jm jn hi bd jo jp jq jr js jt ju jv jw ix jx jy jz jb ka kb kc jf kd ke kf kg bi translated"><strong class="ak"> <em class="kh">遮光罩下的算法:</em> </strong></h2><p id="74fa" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">让我们看一个例子来理解算法是如何工作的。假设我们的值列表是[4，5，9，10]，我们需要从中找出最佳范围。</p><p id="94a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jl">第一步:</em> </strong> <em class="jl">计算“数组均值的方差之和”(SDAM)。</em></p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3a50" class="jm jn hi ks b fi kw kx l ky kz">list = [4, 5, 9, 10]<br/>mean = 7  #(4 + 5 + 9 + 10) / 4<br/>SDAM = (4-7)^2 + (5-7)^2 + (9-7)^2 + (10-7)^2 = 9 + 4 + 4 + 9 = 26</span></pre><p id="bb85" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jl">第二步:</em> </strong> <em class="jl">对于每一个范围组合，计算“类均值的离差平方和”(SDCM _全部)，找出最小的一个。SDCM所有类似于SDAM，但使用阶级手段和偏差。</em></p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="cb81" class="jm jn hi ks b fi kw kx l ky kz">"""<br/>For [4][5,9,10]<br/>SDCM_ALL = (4-4)^2+(5-8)^2+(9-8)^2+(10-8)^2 = 0 + 9 + 1 + 4 = 14</span><span id="706c" class="jm jn hi ks b fi la kx l ky kz">For [4,5][9,10]<br/>SDCM_ALL = (4-4.5)^2+(5-4.5)^2+(9-9.5)^2+(10-9.5)^2 = 0.25 + 0.25 + 0.25 + 0.25 = 1.</span><span id="d24a" class="jm jn hi ks b fi la kx l ky kz">For [4,5,9][10]<br/>SDCM_ALL = (4-6)^2+(5-6)^2+(9-6)^2+(10-10)^2 = 4 + 1 + 9 + 0 = 14.<br/>"""</span></pre><p id="2681" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意中间的一个具有最低的<em class="jl"> SDCM，意味着方差最小。</em></p><p id="c5db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jl">第三步:</em> </strong> <em class="jl">作为最终的汇总度量，计算一个“方差拟合优度”(GVF)，定义为(SDAM — SCDM) / SDAM。GVF的范围从1(非常适合)到0(非常适合)。</em></p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="961d" class="jm jn hi ks b fi kw kx l ky kz">"""<br/>GVF for [4,5][9,10] is (26 - 1) / 26 = 25 / 26 = 0.96 <br/>GVF for the other 2 ranges is (26 - 14) / 26 = 12 / 26 = 0.46<br/>"""</span></pre><p id="469e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">[4，5][9，10]的GVF是最高的，表明该组合是列表[4，5，9，10]的最佳范围，这在直觉上是有意义的。</p><p id="a75d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jl">要知道的事情</em> </strong>:是数据密集型算法。以将254个项目分成6个范围为例。有8，301，429，675种可能的范围组合。测试如此多的组合可能要花一点时间。因此，从较小的范围开始通常是更好的做法，只有在需要时才增加到较大的范围。</p><p id="32e2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jl">代码中的用法</em> </strong>:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3f11" class="jm jn hi ks b fi kw kx l ky kz">pip install <!-- -->jenks</span></pre><p id="913f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是一个函数，用于在给定要分类的值数组和所选类数的情况下计算方差拟合优度:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="7ce4" class="jm jn hi ks b fi kw kx l ky kz">from jenks import jenks<br/>import numpy as np<br/>def goodness_of_variance_fit(array, classes):<br/>    # get the break points<br/>    classes = jenks(array, classes)<br/><br/>    # do the actual classification<br/>    classified = np.array([classify(i, classes) for i in array])<br/><br/>    # max value of zones<br/>    maxz = max(classified)<br/><br/>    # nested list of zone indices<br/>    zone_indices = [[idx for idx, val in enumerate(classified) if zone + 1 == val] for zone in range(maxz)]<br/><br/>    # sum of squared deviations from array mean<br/>    sdam = np.sum((array - array.mean()) ** 2)<br/><br/>    # sorted polygon stats<br/>    array_sort = [np.array([array[index] for index in zone]) for zone in zone_indices]<br/><br/>    # sum of squared deviations of class means<br/>    sdcm = sum([np.sum((classified - classified.mean()) ** 2) for classified in array_sort])<br/><br/>    # goodness of variance fit<br/>    gvf = (sdam - sdcm) / sdam<br/><br/>    return gvf<br/><br/>def classify(value, breaks):<br/>    for i in range(1, len(breaks)):<br/>        if value &lt; breaks[i]:<br/>            return i<br/>    return len(breaks) - 1</span></pre><p id="8e91" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，假设您决定GVF至少应为0.8，那么您可以增加类的数量，直到GVF满意为止:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="b3f7" class="jm jn hi ks b fi kw kx l ky kz">gvf = 0.0<br/>nclasses = 2<br/>while gvf &lt; .8:<br/>    gvf = goodness_of_variance_fit(array, nclasses)<br/>    nclasses += 1</span></pre></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="496d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就把我们带到了文章的结尾。Jenks Natural Breaks 可能是您的工具集中一种方便的静态技术，旨在优化一组值到“自然”类的排列。</p><blockquote class="li lj lk"><p id="bedb" class="im in jl io b ip iq ir is it iu iv iw ll iy iz ja lm jc jd je ln jg jh ji jj hb bi translated">关于我</p></blockquote><p id="5f4d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我是<a class="ae jk" href="https://wavelabs.ai/" rel="noopener ugc nofollow" target="_blank"> Wavelabs.ai </a>的资深机器学习专家。我们Wavelabs帮助您利用人工智能(AI)来彻底改变用户体验并降低成本。我们使用人工智能独特地增强您的产品，以达到您的全部市场潜力。我们试图将尖端研究引入您的应用中。</p><p id="1ae8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">欢迎访问<a class="ae jk" href="https://wavelabs.ai/" rel="noopener ugc nofollow" target="_blank"> Wavelabs.ai </a>了解更多信息。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="a46b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">嗯，这些都在这个博客里。感谢阅读:)</p><p id="96e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">保持好奇！</p><p id="af87" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以通过<a class="ae jk" href="https://www.linkedin.com/in/rehan-a-18675296" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div></div>    
</body>
</html>