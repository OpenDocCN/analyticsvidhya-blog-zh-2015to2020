<html>
<head>
<title>Async iterators in JavaScript — database iteration in NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的异步迭代器NodeJS中的数据库迭代</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/async-iterators-in-js-database-iteration-in-nodejs-31a813cf7ec3?source=collection_archive---------17-----------------------#2020-03-21">https://medium.com/analytics-vidhya/async-iterators-in-js-database-iteration-in-nodejs-31a813cf7ec3?source=collection_archive---------17-----------------------#2020-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/661af93c369b12f52ee34f18f0832a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-esubczgDBH_BDNzoU92Q.jpeg"/></div></div></figure><p id="68d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将给出一个简单的例子，说明如何使用现代JavaScript工具处理整个数据库(比如MongoDB、Elasticsearch或PostgreSQL之类的RDBS)。我们将把async/await、迭代器和函数生成器结合成一个简单而强大的模式，可以在很多情况下使用。</p><p id="dbba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参见</strong> <a class="ae jo" href="https://runkit.com/kmoskwiak/5e07544f761b77001b44c45f" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Runkit </strong> </a> <strong class="is hj">上的工作示例。</strong></p><h1 id="6094" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">问题是</h1><p id="f164" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们的例子是逐个条目地处理整个数据库(RDB的表，Mongo的集合)。最简单的方法是选择所有文档，将它们放入运行时内存并执行所有操作。然而，这不是答案，尤其是当数据集很大而我们的内存有限的时候。</p><h2 id="6721" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">经典方法:极限和偏移</h2><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/73603dd2384f7c71d4fe154e9a944eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dSdroJM18o9FoXobzVNodA.gif"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">在SQL中使用限制和偏移</figcaption></figure><p id="8d64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在SQL中有一个选项可以将<code class="du lp lq lr ls b">limit</code>与<code class="du lp lq lr ls b">offset</code>结合使用:</p><pre class="lh li lj lk fd lt ls lu lv aw lw bi"><span id="8a12" class="ks jq hi ls b fi lx ly l lz ma">SELECT * FROM my_table LIMIT 50 OFFSET 100;</span></pre><p id="8870" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Mongo中应该是这样的:</p><pre class="lh li lj lk fd lt ls lu lv aw lw bi"><span id="adac" class="ks jq hi ls b fi lx ly l lz ma">db.my_collection.find({}).skip(100).limit(50)</span></pre><p id="2463" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，在大多数数据库中，这种技术的性能根据偏移值而变化。偏移量越大，查询就越慢。这是因为在大多数情况下，数据库会在返回我们感兴趣的条目之前处理所有跳过的条目。由于这一障碍，一些数据库指定了偏移量的最大值，因此如果不对数据库设置进行一些额外的调整，可能无法处理整个数据库。</p><h2 id="f50e" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">有状态游标</h2><p id="96c9" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们可以使用<code class="du lp lq lr ls b">cursors</code>来利用有状态技术。游标是由数据库创建并保存在内存中的对象。它会记住查询的上下文，例如分页的当前状态。通常我们必须创建游标，然后在进一步的查询中使用对它的引用。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/1aa2dab714acd16853fc1762f48d84de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*sdBJdQ3_JR0Wq1_EF1IotQ.gif"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">用光标迭代数据库</figcaption></figure><p id="8a0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，在某些数据库中，游标有其生存期。例如，在Elasticsearch中，我们可以在<code class="du lp lq lr ls b">scroll </code>参数中指定搜索上下文的到期时间。</p><p id="a18f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能还会遇到同时打开的游标的最大数量限制。</p><h2 id="e90b" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">另一种方法:范围查询</h2><p id="fed9" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">下一项技术——范围查询——有几个有趣的特性。</p><ul class=""><li id="ef8e" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated">是<strong class="is hj">无状态</strong>。这意味着您不必关心网络中所有数据库节点之间的状态过期或状态同步。</li><li id="ed76" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">它具有<strong class="is hj">恒定且可控的内存使用量</strong>。这意味着它可以在低内存机器上成功使用，并且其性能不会因数据集大小或分页进度而变化。</li><li id="8b07" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">它<strong class="is hj">不是数据库特有的</strong>。毕竟，这只是一种如何构造查询以便在大多数数据库中使用的方法。</li></ul><p id="7a9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">范围查询非常类似于限制和偏移的组合。然而，我们没有提供要跳过的文档数量，而是指定了边界条件，排除了已经处理的文档。<br/>在示例数据集(如下图所示)中，文档按id升序排列。条件<code class="du lp lq lr ls b">id &gt; 16</code>跳过6个id为<strong class="is hj"> 1 </strong>，<strong class="is hj"> 2 </strong>，<strong class="is hj"> 11 </strong>，<strong class="is hj"> 13 </strong>，<strong class="is hj"> 14 </strong>，<strong class="is hj"> 16 </strong>的文档。结果等同于提供等于6的偏移。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/4ba349e19ec08db269b77aa4a5d6f8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*b94QQg9WJn-dlIymiPkEtQ.gif"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">SQL中的范围查询</figcaption></figure><p id="84b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在批量大小为6的数据集上迭代归结为3个步骤:</p><ol class=""><li id="1e2b" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn mp mh mi mj bi translated">请求前6个文件并记住最后一个文件的id(<strong class="is hj">16</strong>)，</li><li id="63ac" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mp mh mi mj bi translated">请求条件id &gt; <strong class="is hj"> 16 </strong>的下6个文档，记住最后一个id ( <strong class="is hj"> 35 </strong>)，</li><li id="1e9a" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mp mh mi mj bi translated">请求条件id &gt; <strong class="is hj"> 35 </strong>的下6个文档。注意，这次只返回了3个文档，这意味着它是我们数据集的结尾。</li></ol><p id="6f66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要记住的事情:</p><ul class=""><li id="0248" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated">数据集必须按我们的条件所应用的关键字进行排序，</li><li id="1180" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">为实现最佳性能并保持恒定的内存使用量，条件中使用的字段应由<strong class="is hj">索引</strong>，</li><li id="82f2" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">该字段下的值也必须是唯一的<strong class="is hj"/>。如果不是范围查询可能会“丢失”一些文档。</li></ul><p id="11f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在示例中使用范围查询。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h1 id="6ab5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">JavaScript中的异步迭代</h1><p id="5ad0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将使用<code class="du lp lq lr ls b">async-await</code>结合<code class="du lp lq lr ls b">functions generator</code>和自定义<code class="du lp lq lr ls b">iterator</code>。这个组合叫做<code class="du lp lq lr ls b">async iteration</code>，它的提议可以在<a class="ae jo" href="https://github.com/tc39/proposal-async-iteration" rel="noopener ugc nofollow" target="_blank">这里</a>找到。然而，从版本10 开始，NodeJS中的单个部分可以在循环<a class="ae jo" href="https://node.green/#ES2018-features-Asynchronous-Iterators" rel="noopener ugc nofollow" target="_blank">中使用。</a></p><p id="b35e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">最终我们希望能够使用for-loop来同步迭代数据库。</strong></p><p id="9caa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文的代码片段中，我假设我们在方法<code class="du lp lq lr ls b">select</code>的作用域中有<code class="du lp lq lr ls b">Database</code>对象，该方法返回<code class="du lp lq lr ls b">Promise</code>解析到文档数组。它接受具有两个属性的参数对象:<code class="du lp lq lr ls b">idGreaterThan</code> —确定数据库中的条件，以及<code class="du lp lq lr ls b">limit</code> —返回文档的数量，例如<code class="du lp lq lr ls b">db.select({idGreaterThan: 6, limit: 2})</code>相当于SQL查询<code class="du lp lq lr ls b">SELECT * FROM exoplanets WHERE id &gt; 6 ORDER BY id ASC LIMIT 2</code>。在本文中，我省略了<code class="du lp lq lr ls b">Database</code>类的实现，但是简单的模拟可以在这个<a class="ae jo" href="https://runkit.com/kmoskwiak/5e07544f761b77001b44c45f" rel="noopener ugc nofollow" target="_blank"> RunKit笔记本</a>中找到。这个笔记本还包含了我们将要编写的代码的工作示例。</p><h2 id="1c71" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">readDocuments函数生成器</h2><blockquote class="ms"><p id="9f66" class="mt mu hi bd mv mw mx my mz na nb jn dx translated">生成器是可以退出并在以后重新进入的功能。它们的上下文(变量绑定)将在重入时被保存。<br/>(来源:<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank">函数* — JavaScript | MDN </a>)</p></blockquote><p id="2df5" class="pw-post-body-paragraph iq ir hi is b it nc iv iw ix nd iz ja jb ne jd je jf nf jh ji jj ng jl jm jn hb bi translated">MDN Web Docs对Javascript中的<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank">函数生成器</a>和<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank">迭代器</a>给出了很好的解释。对于本文，我们必须知道的是，生成器在被调用后会返回一个迭代器。迭代器是一个可以用于for的对象..循环的。</p><p id="37fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们写我们的生成器<code class="du lp lq lr ls b">readDocuments</code>。</p><pre class="lh li lj lk fd lt ls lu lv aw lw bi"><span id="3cc9" class="ks jq hi ls b fi lx ly l lz ma">/**<br/>* Iterate over database<br/>* <a class="ae jo" href="http://twitter.com/generator" rel="noopener ugc nofollow" target="_blank">@generator</a><br/>* <a class="ae jo" href="http://twitter.com/function" rel="noopener ugc nofollow" target="_blank">@function</a> readDocuments<br/>* <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {number} limit maximum number of documents<br/>* <a class="ae jo" href="http://twitter.com/yields" rel="noopener ugc nofollow" target="_blank">@yields</a> {array} list of planets<br/>*/<br/>async function* readDocuments(limit) {<br/> const db = new Database();<br/> let lastId = 0; // initialize with min value<br/> let done = false; // indicates end of iteration</span><span id="0edf" class="ks jq hi ls b fi nh ly l lz ma"> while(!done) {<br/>   // select batch of documents and wait for database response<br/>   // TODO: error handling<br/>   const result = await db.select({<br/>     idGreaterThan: lastId,<br/>     limit: limit<br/>   });</span><span id="93d6" class="ks jq hi ls b fi nh ly l lz ma">   // get id of last document<br/>   lastId = result[result.length — 1].id;</span><span id="76e4" class="ks jq hi ls b fi nh ly l lz ma">   // end iteration if there are less documents than limit<br/>   if(result.length &lt; limit) {<br/>     done = true;<br/>   }</span><span id="46b2" class="ks jq hi ls b fi nh ly l lz ma">   // yield result<br/>   yield result<br/> }<br/>};</span></pre><p id="7a82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意上面代码中的两件重要事情:<code class="du lp lq lr ls b">readDocuments</code>是用<code class="du lp lq lr ls b">async</code>关键字和<code class="du lp lq lr ls b">function*</code>表达式声明的。这个函数是异步函数和函数生成器的混合体，具有两者的功能。我们从两个角度来分析一下。</p><p id="1b5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一个异步函数，它允许我们等待异步数据库操作。这意味着while循环将同步运行。每个select from database只有在前一个完成后才会执行。</p><p id="156f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们没有返回它，而是返回了它。这是函数生成器的一部分。正如我上面提到的，生成器返回一个可以在for循环中使用的迭代器。每当生成器产生一些东西时，程序就从函数中分离出来，进入循环体。</p><p id="71bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这给我们带来了众所周知的..的循环，但在异步变化。</p><pre class="lh li lj lk fd lt ls lu lv aw lw bi"><span id="ed7d" class="ks jq hi ls b fi lx ly l lz ma">async function run() {<br/> // We need to place our loop inside another async function <br/> // so we can use await keyword</span><span id="c7bd" class="ks jq hi ls b fi nh ly l lz ma"> for await (let documents of readDocuments(4)) { <br/>   // This for loop behaves synchronously. <br/>   // Next iteration will begin after execution of this loop<br/>   await doSomethingWithDocuments(documents);<br/> }</span><span id="e598" class="ks jq hi ls b fi nh ly l lz ma">}<br/>run();</span></pre><p id="4093" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！在<a class="ae jo" href="https://runkit.com/kmoskwiak/5e07544f761b77001b44c45f" rel="noopener ugc nofollow" target="_blank"> Runkit </a>的例子中，我只是记录行星来安慰每次迭代。您应该会看到类似下面的输出。</p><pre class="lh li lj lk fd lt ls lu lv aw lw bi"><span id="164d" class="ks jq hi ls b fi lx ly l lz ma">DATABASE: SELECT * FROM exoplanets ORDER BY id ASC LIMIT 4<br/>APP: Got 4 items from database: Proxima Centauri b, Gliese 667 Cc, Kepler-442b, Kepler-452b. Done: false</span><span id="9a8b" class="ks jq hi ls b fi nh ly l lz ma">DATABASE: SELECT * FROM exoplanets WHERE id &gt; 7 ORDER BY id ASC LIMIT 4<br/>APP: Got 4 items from database: Wolf 1061c, Kepler-1229b, Kapteyn b, Kepler-62f. Done: false</span><span id="1194" class="ks jq hi ls b fi nh ly l lz ma">DATABASE: SELECT * FROM exoplanets WHERE id &gt; 14 ORDER BY id ASC LIMIT 4<br/>APP: Got 4 items from database: Kepler-186f, Luyten b, TRAPPIST-1d, TRAPPIST-1e. Done: false</span><span id="4edc" class="ks jq hi ls b fi nh ly l lz ma">DATABASE: SELECT * FROM exoplanets WHERE id &gt; 18 ORDER BY id ASC LIMIT 4<br/>APP: Got 4 items from database: TRAPPIST-1f, TRAPPIST-1g, LHS 1140 b, Kepler-1638b. Done: false</span><span id="9849" class="ks jq hi ls b fi nh ly l lz ma">DATABASE: SELECT * FROM exoplanets WHERE id &gt; 24 ORDER BY id ASC LIMIT 4<br/>APP: Got 1 items from database: Teegarden c*. Done: true</span></pre><p id="9f5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你喜欢这篇文章。在本系列的下一篇文章中，我将展示如何在内存有限的情况下使用这个工具读取大文件。敬请期待！</p></div><div class="ab cl ni nj gp nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="hb hc hd he hf"><h2 id="d43e" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">ack🦄</h2><ul class=""><li id="ef87" class="mb mc hi is b it kn ix ko jb np jf nq jj nr jn mg mh mi mj bi translated">照片由<a class="ae jo" href="https://unsplash.com/@cazault?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·梅尼德雷</a>在<a class="ae jo" href="https://unsplash.com/s/photos/planet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</li><li id="0092" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">取自<a class="ae jo" href="https://en.wikipedia.org/wiki/List_of_potentially_habitable_exoplanets" rel="noopener ugc nofollow" target="_blank">维基百科</a>的例子中的系外行星</li></ul></div></div>    
</body>
</html>