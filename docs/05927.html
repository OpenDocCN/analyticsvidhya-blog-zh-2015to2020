<html>
<head>
<title>Convolutional Neuronal Network with Keras-Tuner on CIFAR 10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CIFAR 10上带有Keras-Tuner的卷积神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/convolutional-neuronal-network-with-keras-tuner-on-cifar-10-b4271ca4643d?source=collection_archive---------5-----------------------#2020-05-06">https://medium.com/analytics-vidhya/convolutional-neuronal-network-with-keras-tuner-on-cifar-10-b4271ca4643d?source=collection_archive---------5-----------------------#2020-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6819" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">应用Keras-Tuner寻找最佳CNN结构</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/1261227547f316a3fbe5adbcc640b5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*eeoLjM-QM0WvN5kPPhN6kA.png"/></div></figure><p id="a715" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卷积神经网络是一种用于图像数据分析和分类的监督算法。当我开始这个项目时，我知道CNN的基本知识和结构，但我不知道我应该放多少。</p></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><h1 id="0067" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">卷积神经网络的结构</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kr"><img src="../Images/f6cdfb6fa84a92e43d5ed1e8191a4a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wDoZyhXhGvkfqpO0k0y6g.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">https://www.mdpi.com/1424-8220/19/22/4933/htm<a class="ae la" href="https://www.mdpi.com/1424-8220/19/22/4933/htm" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="335e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">图片摘自</em> <strong class="ih hj"> <em class="jd">《一种用于复杂复合材料结构冲击检测与表征的卷积神经网络》</em> </strong> <em class="jd">作者</em> <a class="ae la" href="https://sciprofiles.com/profile/876720" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">尤莲娜·塔比安</strong> </a>、<a class="ae la" href="https://sciprofiles.com/profile/379880" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">海陵·傅</strong> </a>、<a class="ae la" href="https://sciprofiles.com/profile/198359" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">扎赫拉·沙里夫·科达耶</strong> </a> <strong class="ih hj">。</strong></p><p id="9a32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卷积神经网络包括:</p><h2 id="9955" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">2D·conv:</h2><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lp"><img src="../Images/150a600ffbbb7b6f3f76d0b8b7755966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*O06nY1U7zoP4vE5AZEnxKA.gif"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated"><a class="ae la" href="https://www.pyimagesearch.com/2018/12/31/keras-conv2d-and-convolutional-layers/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2018/12/31/keras-conv2d-and-卷积-层/ </a></figcaption></figure><p id="9043" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2d接受一个三维输入，并将其传递给一个<strong class="ih hj">卷积核，</strong>这个<strong class="ih hj"> </strong>是一个矩阵，它与输入相乘，通过这种方法我们可以从输入中得到一些隐含的特征。</p><p id="b586" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Conv2D的一个优点同时也是一个缺点是，我们可以选择输出的维数，即卷积中应用的滤波器数量，大多数情况下我们选择通道32或64，甚至2的幂，但这取决于程序员。</p><p id="3d4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点发生在选择通道数量时，<br/>因为原则上我们不知道最精确模型的合适通道数量，并且为每个通道运行代码不是最佳的，并且会持续很长时间。</p><h2 id="b0cf" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated"><strong class="ak">池化(最大值):</strong></h2><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lq"><img src="../Images/45f76d1d100c5e53786bec6196a6687a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6u3QK9M9ZJws58P4SAr2AQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated"><a class="ae la" href="https://www.geeksforgeeks.org/cnn-introduction-to-pooling-layer/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/CNN-introduction-to-pooling-layer/</a></figcaption></figure><p id="4abb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">池图层会将每个要素地图的大小缩小1/2，从而将每个要素地图中的像素或值的数量减少到1/4。</p><p id="4fa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">池操作是指定的，而不是学习的。汇集操作中使用的两个常见函数是:</p><ul class=""><li id="dbd1" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated"><strong class="ih hj">平均汇集</strong>:计算特征图上每个面片的平均值。</li><li id="2905" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated"><strong class="ih hj">最大池(或最大池)</strong>:计算特征图每个面片的最大值。</li></ul><p id="3e40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用最多的池层是Max，在这种情况下，我们将把它用于Cifar。</p></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><h2 id="db64" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">通常在进行展平之前进行至少两到三个连续的卷积和汇集步骤。</h2><p id="71e4" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">这里又出现了另一个问题，原则上我们不知道为了得到最精确的模型应该进行多少次卷积和合并。</p></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><h1 id="63b4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">变平</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es mk"><img src="../Images/f6020617a353b1b3a6d0a3bf7465e18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Cb1dzBhciwRi9y1-J6qjQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated"><a class="ae la" href="https://www.superdatascience.com/blogs/convolutional-neural-networks-cnn-step-3-flattening" rel="noopener ugc nofollow" target="_blank">https://www . superdata science . com/blogs/convolutionary-neural-networks-CNN-step-3-flatting</a></figcaption></figure><p id="8a59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能是最容易的一步。</p><p id="aadc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上我们要把所有的特征图展平成一列作为图像。</p><h1 id="6d35" class="jt ju hi bd jv jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq bi translated">全连接层</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es mk"><img src="../Images/b6ea032c4938e554307f2fcdabc795fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*db3TLi3gl2LzCqRxhs1vZg.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated"><a class="ae la" href="https://www.superdatascience.com/blogs/convolutional-neural-networks-cnn-step-4-full-connection" rel="noopener ugc nofollow" target="_blank">https://www . superdata science . com/blogs/convolutionary-neural-networks-CNN-step-4-full-connection</a></figcaption></figure><p id="562a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CNN的最后一步是获取前一层的输出，“展平”并将它们转换成一个向量，这个向量可以是一个概率或一个类的输出。</p><p id="1d34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步我们可以选择两件事:</p><p id="9a07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">有多少个节点？</strong>我们的前一层，在一个大小为n的列上组织特征，但是我们可以选择在整个层上连接多少个节点，然后返回向量，通常是2的幂。但是没有一个最精确模型的幻数。</p><p id="1232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这一步我们做了多少次？为了获得最佳精度，我们可以建立尽可能多的连接。</strong></p></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><p id="afef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们在选择上有一定的疑虑:</p><ul class=""><li id="f299" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated">卷积核的通道数</li><li id="0919" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">我们应该应用Conv和统筹的时代</li><li id="f839" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">全连接层的节点数</li><li id="671b" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">我们制作完全连接层的次数</li></ul></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><h1 id="5658" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建我们的卷积神经网络</h1><p id="42a6" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">在制作我们的CNN之前，我们必须安装相应的包，<br/>在Anaconda <em class="jd">提示符下，e </em>在命令提示符下或在google colab中执行这个命令:</p><pre class="jf jg jh ji fd mq mr ms mt aw mu bi"><span id="55cf" class="lb ju hi mr b fi mv mw l mx my">pip install tensorflow<br/>______________________<br/>pip install keras<br/>______________________<br/>pip install keras-tuner</span></pre></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><h1 id="5bc8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">常规CNN</h1><h2 id="073c" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">导入包</h2><p id="1be6" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">因为我们所有的代码都需要下一个包</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><h2 id="2a7c" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">标准化数据</h2><p id="d702" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">在加载数据之前，为了更好地读取数据，我们将定义一个归一化函数</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><h2 id="a0a0" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">加载和预处理数据</h2><p id="3b30" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">对于这个项目，我们从keras获得了keras.datasets中的数据</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><h2 id="c792" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">带Keras的正则CNN模型</h2><p id="a06e" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">最初，我们将使用Keras执行常规的CNN模型。这将有两个卷积，都有32个通道，以及他各自的池化，展平，和1024个节点的完全连接层。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="82d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们用训练数据拟合CNN，并与测试数据进行比较</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="1192" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据我们的电脑，几分钟或几分钟后，我们将得到以下结果:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es nb"><img src="../Images/b42187555387573b36df3e084f239ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*pPR1OVfck667hmE_WCLnbA.png"/></div></figure><p id="ad61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些结果并不坏，它有67%的准确性，但在我的情况下，最初我有很多疑问，如果我能通过改变上面显示的参数来提高它的准确性。但是这是一个非常长且没有成效的等待时间，而且在某些情况下，我们的准确度不是在提高，而是在变化。</p><h1 id="ce5f" class="jt ju hi bd jv jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq bi translated">克拉斯-图纳模型</h1><p id="2588" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">现在，我们将根据keras-tuner，<br/>制作最佳模型，并且只会对我们的常规代码进行某些更改。</p><p id="5e7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的加载和预处理代码将与常规代码相同</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><h2 id="b1f7" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">带Keras调谐器的型号</h2><p id="fd94" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">这里我们的代码与之前的代码有所不同。这将会是</p><ul class=""><li id="5647" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated">卷积上的输入单元数</li></ul><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="23d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们让CNN在32到256之间随机选择input_channel参数，步长为32。</p><ul class=""><li id="a192" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated">卷积和池的数量</li></ul><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="958d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用此参数将得到一个具有2–5个卷积的convnet</p><ul class=""><li id="e9a0" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated">全连通层上的节点数和连通层数</li></ul><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="393c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以最终我们的CNN模型将会是</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><h2 id="bcf3" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">随机搜索</h2><p id="ca02" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">在模型构建中，我们定义了将要随机选择的参数，但是我们现在需要一些其他的代码来使用这个函数。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="ec02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的目标显然是获得最好的准确性</p><h2 id="acfe" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">拟合并保存模型</h2><p id="7259" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">最后，我们符合我们的模型</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><h1 id="3556" class="jt ju hi bd jv jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq bi translated">这样完整的代码就是</h1><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mz na l"/></div></figure><h2 id="2bc3" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">结果</h2><p id="8692" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">编译并运行我们的代码后，我们将会得到下面的输出</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es nc"><img src="../Images/37b0c88a651dc04581301d5a9bc50827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*beAwDqoyDBC5NOpq45VUBA.png"/></div></div></figure><p id="7df0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们的调谐器选择的具有最佳精度的模型结构。最后的结果会是</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es nd"><img src="../Images/d665d00bd106182b5b82334261dcfc40.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*iJq6DT_ifk7tFgJTJUi_UA.png"/></div></figure><h1 id="5abe" class="jt ju hi bd jv jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq bi translated">结论</h1><p id="091f" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">也许这只是我的想法，但原则上我想找到实现最佳精度的最佳结构，通过Keras-Tuner，我不仅可以为卷积神经网络和Keras上的任何神经网络找到合适的结构。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ne"><img src="../Images/5ddff2b2b89e08289ba48486dd331ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*F7NhWS2zD0OEYZatcp6-Zw.gif"/></div></figure><h1 id="a52a" class="jt ju hi bd jv jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq bi translated">参考</h1><p id="3df5" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">[1] <a class="ae la" href="https://www.pyimagesearch.com/author/adrian/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">阿德里安·罗斯布鲁克</strong> </a> (2018)，《Keras Conv2D与卷积层》，<a class="ae la" href="https://www.pyimagesearch.com/2018/12/31/keras-conv2d-and-convolutional-layers/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2018/12/31/Keras-conv 2d-and-Convolutional-Layers/</a></p><p id="3699" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[2]<strong class="ih hj"/><a class="ae la" href="https://auth.geeksforgeeks.org/user/savyakhosla/articles" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">savyakhosla</strong></a>，“CNN |池层简介”，<a class="ae la" href="https://www.geeksforgeeks.org/cnn-introduction-to-pooling-layer/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/CNN-Introduction-to-Pooling-Layer/</a></p><p id="1194" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[3] <a class="ae la" href="https://www.superdatascience.com/profile/77Rsq4n6ESZFEb4b9" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> SuperDataScience团队</strong> </a> (2018)，“卷积神经网络(CNN):第三步——扁平化！”，<a class="ae la" href="https://www.superdatascience.com/blogs/convolutional-neural-networks-cnn-step-3-flattening" rel="noopener ugc nofollow" target="_blank">https://www . superdata science . com/blogs/convolatile-neural-networks-CNN-step-3-flatting</a></p><p id="b860" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[4] <a class="ae la" href="https://www.superdatascience.com/profile/77Rsq4n6ESZFEb4b9" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> SuperDataScience团队</strong> </a> (2018)，《卷积神经网络(CNN):第4步——全连接》，<a class="ae la" href="https://www.superdatascience.com/blogs/convolutional-neural-networks-cnn-step-4-full-connection" rel="noopener ugc nofollow" target="_blank">https://www . superdata science . com/blogs/convolutionary-Neural-Networks-CNN——第4步——全连接</a></p><p id="db7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[5]Sendtex(Harrison @ python programming . net)，用Keras-Tuner优化神经网络结构，<a class="ae la" href="https://pythonprogramming.net/keras-tuner-optimizing-neural-network-tutorial/" rel="noopener ugc nofollow" target="_blank">https://python programming . net/Keras-Tuner-Optimizing-Neural-Network-tutorial/</a></p></div></div>    
</body>
</html>