<html>
<head>
<title>Looking for the Best Excel Add-ins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找最好的Excel加载项</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/looking-for-the-best-excel-add-ins-d49d90a149b4?source=collection_archive---------29-----------------------#2020-09-27">https://medium.com/analytics-vidhya/looking-for-the-best-excel-add-ins-d49d90a149b4?source=collection_archive---------29-----------------------#2020-09-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/d62f4e8143155885addff06dbc39e57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*0UfmJNoFqxZi_WbDcoFYwA.png"/></div></figure><p id="7dd4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Excel为执行简单计算提供了方便的方法，包括易于使用的函数和直观的按钮和菜单。但是它很难独自完成复杂的计算和某些特殊的计算。因此，它提供了插件接口，通过该接口可以连接外部应用程序，以使用它们的语言或脚本来帮助Excel处理这些计算。</p><p id="a7b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我将研究一些常见的Excel插件，并评估它们的计算能力。</p><h1 id="66d1" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Excel DNA</h1><p id="f973" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">作为最早的Excel加载项之一，Excel DNA允许您使用C#、F#、VB.net等语言为Excel创建动态库函数。</p><p id="2c0a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，您需要编写一个用户定义的函数。下面是一个用C#写的例子，列在Excel DNA的官网上。MyFunction是用户定义函数的名称。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="db27" class="kw jl hi ks b fi kx ky l kz la">using System;<br/>using  System.Collections.Generic;<br/>using   System.Linq;<br/>using   System.Text;<br/>using  System.Threading.Tasks;<br/>using  ExcelDna.Integration;</span><span id="d567" class="kw jl hi ks b fi lb ky l kz la">namespace   MyLibrary<br/>{<br/>    public class Class1<br/>    {<br/>        ExcelFunction(Description="few  people use this way!")]<br/>        public static string  MyFunction(string name)<br/>        {<br/>        return "Bonjour" + name;<br/>       }<br/>    }<br/>}</span></pre><p id="fb54" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码需要编译成动态库才能在Excel中使用。</p><p id="047a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后配置用户定义函数和外接程序之间的关系。以下DnaSample.dna文件配置加载项的名称(“我的名称”)和相应的动态库Mylibrary.dll，其中包括多个用户定义的函数。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="c0e8" class="kw jl hi ks b fi kx ky l kz la">&lt;DnaLibrary   Name="My  name"   RuntimeVersion="v4.0"&gt;<br/>&lt;ExternalLibrary  Path="Mylibrary.dll" /&gt;<br/>&lt;/DnaLibary&gt;</span></pre><p id="f07f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，在Excel中配置新的插件，使其能够从单元格中调用MyFunction，如下所示:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/56a6a8c3476418891a738608f6926256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6SAQKAuncDk_PVcUDsTPg.png"/></div></div></figure><p id="2120" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于一个编译好的程序已经准备好执行，并且紧密地集成到Excel中，所以执行起来流畅而快速。所以Excel DNA最大的优势就是流动性高。</p><p id="6fb8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">顾名思义，该插件可以充分利用Windows DNA Architecture提供的功能，如开发语言和工具、与Excel的集成、交互式调试等。</p><p id="6185" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">理论上，像C#、F#和VB.net这样的语言是通用的、全能的。但是我注意到他们网站上的示例程序都是关于字符串输出的。这当然不是展示实力的好选择。为什么会这样呢？</p><p id="d028" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为他们的能力只存在于纸面上。</p><p id="72f5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那些语言缺乏用于结构化数据计算的类库。即使是最基本的计算也需要硬编码。极其迂回的代码不适合处理复杂的计算。</p><p id="2d6f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此外，C#、F#和VB.net是编译语言，而不是解释语言。这种类型的编程语言需要用户维护一个编译环境来编译算法，以防它被改变。但是配置Windows编译环境很复杂，也很难学。实际上这些语言有很高的技术门槛。这意味着Excel DNA更适合作为接口使用的专业程序员，而不是直接用于桌面分析的大部分数据分析师。</p><p id="4b26" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">其他插件，如基于Java的JINX，也缺乏用于结构化数据计算的类库。所以JINX也不适合数据计算。即使是电子表格工具的内置插件Excel VBA，在表达能力方面也没有更好(这意味着它不适合计算数据)。但是由于它不需要集成和编译，所以比Excel DNA和/JINX更有竞争力。</p><h1 id="6576" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Excel JavaScript</h1><p id="92a1" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">一个插件需要比VBA更方便，更容易使用才能得到普及。因此，微软在2013年发布了Excel JavaScript，这是一种旨在供插件使用的语言，比VBA更方便。</p><p id="50d4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Excel JavaScript与其他加载项语言有类似的用途。关键是它是一种解释型语言，因此支持随时修改程序，然后无需编译就立即执行。这是和Excel DNA很大的区别。一般来说，解释性语言的流动性很低。但是作为Excel内置的，Excel JavaScript可以和电子表格工具在同一个进程中执行。在实际操作中，执行是流畅而快速的，只比Excel DNA慢一点。</p><p id="337a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">n Excel内置的外接程序带来了很多好处。你不需要下载插件，不需要配置就可以开发程序。Excel JavaScript继承了Excel的跨平台能力。一个程序可以在单机版、网页版和Mac版之间无缝迁移。该外接程序还可以访问Excel对象，包括工作簿、工作表和单元格。这大大加快了开发进度。</p><p id="b976" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而这些优点正是VBA所拥有的。那么Excel JavaScript有什么独特之处呢？</p><p id="e7a3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它具有强大的界面管理能力。它可以使用更简单的语法访问Excel菜单栏、按钮和弹出对话框，并在JS文件中定义一个插件接口。那比VBA方便多了。</p><p id="9ca8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不幸的是，界面管理不是数据计算插件的关键方面。不值得关注。</p><p id="ee8d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的重点应该是计算能力。遗憾的是JavaScript仍然没有配备任何结构化的计算功能。它在处理复杂计算时没有任何优势。这只是另一种基于Excel的脚本语言。</p><h1 id="66cd" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">PyXLL</h1><p id="e2ff" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">一个标准的数据计算插件应该有用于结构化计算的类库，比如PyXLL。PyXLL是一个基于Pyhon的插件。Python Pandas拥有结构化计算类库。</p><p id="ca22" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">PyXLL在实现简单算法时不需要硬编码，比如在指定区域进行分组和聚合。这里有一个例子。从Excel工作表中选择一批员工记录，传递给用户自定义函数groupEmp，在PyXLL中执行分组聚合算法，返回结果。实现该过程的代码如下:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="0eb9" class="kw jl hi ks b fi kx ky l kz la">import pandas  as pd<br/>import numpy  as np<br/>from pyxll   import xl_func</span><span id="e774" class="kw jl hi ks b fi lb ky l kz la"><a class="ae lh" href="http://twitter.com/xl_func" rel="noopener ugc nofollow" target="_blank">@xl_func</a>("dataframe&lt;index=False,   columns=True&gt;")<br/>def   groupEmp(df):<br/>df=df.groupby("deptid")['salary'].agg([len,   np.sum,  np.mean])  # The core code: grouping &amp; aggregation<br/>return df</span></pre><p id="f6d9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">核心代码只占一行。其他的基本都是套路。这个程序很简洁。</p><p id="3689" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当然，执行复杂和特殊的计算需要多个功能的合作，而不是单一的基本功能。问题是在PyXLL中这样做不方便。</p><p id="b68a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里有一个标准化然后分组和聚合数据的例子。基于记录单元样式(列A-E)的Excel表，用户定义的函数将按样式和卧室对记录进行分组，并计算平方英尺列、浴室列和价格列的平均值。您需要从string样式PRICE列的每个值中删除$并将其转换为数值样式以便进行计算。</p><p id="b1c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">源数据:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es li"><img src="../Images/2b5ca81153bc1c99b6af1416b1411aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhD5WC8mq7LRyItteNH9cQ.png"/></div></div></figure><p id="47a0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">已处理的数据存储在新的工作表中:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/4ddca8b0f8f343175613831acd64d88a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbmYIrY2jTDd3L3Qvdl4sw.png"/></div></div></figure><p id="28ff" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">用于实现算法的用户定义函数如下(仅显示核心代码):</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="9ab7" class="kw jl hi ks b fi kx ky l kz la">for i in range(1,   len(b)):<br/>    b[i][4] = b[i][4].replace(“$”,‘ ‘)<br/>    b[i][4] = b[i][4].replace(“,”,‘ ‘)</span><span id="ff08" class="kw jl hi ks b fi lb ky l kz la">for i in range(1,   len(b)):<br/>    for j in [1, 2, 3, 4]:<br/>        b[i][j] = eval(b[i][j])</span><span id="2bec" class="kw jl hi ks b fi lb ky l kz la">data =   pandas.DataFrame(b[1:],columns=b[0])<br/>out =   data.groupby([‘STYLE’,‘BEDROOMS’]).mean()<br/>return out</span></pre><p id="5a76" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">只有一行用于分组，但有六行用于预处理。这有点复杂。</p><p id="eb9e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一个例子是将一行拆分成多行。列A存储id，列B存储相应的列表值。有些列表值有多个由空格分隔的成员。用户定义的函数需要用空格将它们分开，并将它们分别对应到ID。</p><p id="b0b1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">源代码:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lj"><img src="../Images/844dd2bcdf1979836d006a8c24cb4d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EVenkIxyfFNHCTNRkY1CA.png"/></div></div></figure><p id="207a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将处理后的数据存储在新的工作表中:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lk"><img src="../Images/ca8a34878d9d22e50ba23013bb7e102c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gK0Zt7yHqbdbNmnnunrHJg.png"/></div></div></figure><p id="8425" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">用于实现该算法的用户定义函数如下:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="2cac" class="kw jl hi ks b fi kx ky l kz la">split_dict = df.set_index('ID').T.to_dict('list')</span><span id="a6de" class="kw jl hi ks b fi lb ky l kz la">split_list = []<br/>for key,value in split_dict.items():<br/>    anomalies = value[0].split(' ')<br/>    key_array = np.tile(key,len(anomalies))<br/>    split_df =   pd.DataFrame(np.array([key_array,anomalies]).T,columns=['ID','ANOMALIES'])<br/>    split_list.append(split_df)</span><span id="0102" class="kw jl hi ks b fi lb ky l kz la">df = pd.concat(split_list,ignore_index=True)<br/>return df</span></pre><p id="ae65" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">核心代码很复杂。PyXLL不擅长处理复杂或特殊的计算。</p><p id="6491" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">PyXLL还有一个问题。Excel必须调用外部解释器来解析Python脚本。这导致了非常低的流动性和非常糟糕的用户体验。然而低流动性并不是PyXLL独有的问题。这在所有需要外部解释器的脚本插件中都很常见，比如XLwings、Bert和RExcel。XLwings是另一个基于Python的插件，因此与PyXLL有相同的优缺点。Bert和RExcel都是基于R的。R语言是为实现科学建模算法而设计的。它的结构化计算类库并不专业。所以两个插件的计算能力都比PyXLL弱，流畅性也比PyXLL低。</p><p id="2c94" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">解释语言最大的优点是支持无需编译就能立即执行，并且易于维护和修改。</p><h1 id="a25c" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">埃斯普罗克</h1><p id="4c8a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">esProc是专业的数据计算引擎，它提供了一个Excel加载项来使用其SPL语言编写脚本。与PyXLL类似，它拥有丰富的结构化计算功能，可以毫不费力地实现简单的算法。例如，要对指定区域中的记录进行分组和聚合，您只需要以下脚本(<em class="ll"> groupEmp.dfx </em>):</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lm"><img src="../Images/9eb829aee7f6cf9e9f7879be94045149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYR571apFDbooVjK_Uzlbg.png"/></div></div></figure><p id="921c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">核心代码是A2。很简洁。然后我们可以在Excel单元格中调用用户自定义函数。语法是=dfx("groupEmp "，A1:D20)。</p><p id="fd5c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">esProc以简单易行的方式处理其他基本算法(这里只显示核心代码):</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es ln"><img src="../Images/bd249d25cf7f0dc1eb65e38ac785142e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LEq0xoW_x6oWfS3ngcI7wg.png"/></div></div></figure><p id="6a3c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以看到，评估插件计算能力的标准是它在处理复杂或特殊计算方面的表现。</p><p id="7d81" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与PyXLL相比，esProc在这方面更有优势。</p><p id="fd75" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与PyXLL相比，在esProc中将数据转换为标准格式并对其进行分组要容易和简单得多:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lo"><img src="../Images/d1dbac6a3b1046d43acb93aeb43b6886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxyMtTYY385kliuHwbNmWw.png"/></div></div></figure><p id="3196" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在esProc中将一行拆分成多行非常简单:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lp"><img src="../Images/d6de3d7da2f1cc01b64eb43af8f40b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EymDvCIznKAUagZpGZc4rQ.png"/></div></div></figure><p id="a105" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">更复杂的例子是计算分期付款。Excel工作表记录贷款信息，包括贷款ID、金额、期限数(按月)和年利率:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lo"><img src="../Images/dba8eba51999e6c5beb9cd86ca8e5e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBjW2XdH4SdO6Zh3byg6iA.png"/></div></div></figure><p id="d485" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">用户自定义函数需要获取每期的详细数据，包括应付金额、利息、本金和本金余额。新工作表的预期结果如下:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lq"><img src="../Images/080b5cb3f9df45d0d410b9a7218bf255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6W3gJ0xkOqrHnoddOh2seQ.png"/></div></div></figure><p id="db1d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在esProc中完成这项工作相当方便:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lr"><img src="../Images/92a76ce6f9446934034ed45449922e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I53R8QWriziPCyt87N-h0w.png"/></div></div></figure><p id="563b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">尽管esProc具有强大的计算能力，但它也是一个插件，其执行依赖于外部解释器JVM。所以不流动性问题依然存在。</p><h1 id="7951" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">esProc通过剪贴板</h1><p id="c3a4" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">有没有一种方法既能保留计算能力，又能流畅地运行应用程序？</p><p id="1c2c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">esProc通过用剪贴板替换用户定义的函数成功地实现了这一点！</p><p id="07af" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，查找每门学科分数排名前三的学生。A列包含学生姓名，B-D列分别包含数学、英语和物理的分数。现在，我们希望找到符合条件的学生，将他们添加到大学的分数中。</p><p id="d294" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">源数据:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es ls"><img src="../Images/83aac96536e261f39306a8d3475ad3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GL1XToWbulzwPVW_pxYZKg.png"/></div></div></figure><p id="8baf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">选取有效的储存格，透过ctrl+C将它们复制到剪贴簿，然后执行下列esProc指令码:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lt"><img src="../Images/83546158f2c2baa421dd70fa1d22e9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vu8t5T3bOJB7q2dgzeY4ww.png"/></div></div></figure><p id="7be6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">执行上述脚本后，只需选择单元格B11并按ctrl+V，剪贴板中的数据就会复制到B11-D13中。这与用户定义的函数得到的结果相同，如下所示:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lq"><img src="../Images/8d0c08f4b6c65d1dbf148deb088035bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPuPljpOH0bGsFJpG-wdgQ.png"/></div></div></figure><p id="ca50" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有了esProc，您就可以永远使用剪贴簿，而不需要撰写使用者定义的函数，除非是某些情况，例如计算中涉及多个区域。</p><p id="f709" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过剪贴板，您可以拥有流畅的计算过程和强大的计算能力，而无需复杂的插件部署。对于数据分析师来说，这真的很方便。</p><p id="12ce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">理论上，所有插件包括PyXLL都可以通过剪贴板解决不流畅的问题，只要它们在未来的版本中能够提供相应的功能(从剪贴板获取数据并将其转换为Excel中的结构化数据)。</p><p id="f2a5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一言以蔽之，一个流体插件计算能力弱，一个计算能力强的就没那么流体了。然而，由于剪贴板方法可以弥补流动性的限制，esProc是数据分析师的合适插件。</p></div></div>    
</body>
</html>