<html>
<head>
<title>Metaclasses in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的元类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/metaclasses-in-python-35f7787c762e?source=collection_archive---------15-----------------------#2020-08-24">https://medium.com/analytics-vidhya/metaclasses-in-python-35f7787c762e?source=collection_archive---------15-----------------------#2020-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cf55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">元类简介</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/020f7f4420da6d89e2cf23f7da26c679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kz77FG4Q5qsjOUMvAS7IeA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">由<a class="ae jt" href="https://unsplash.com/@maxcodes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">麦克斯韦·纳尔逊</a>在<a class="ae jt" href="https://unsplash.com/s/photos/python-programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1a88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数编程语言中，类只是为对象定义规则的代码片段，但是在 Python 中，正如您所听到的，一切都是对象:事实证明，类本身也是如此。类实际上是一级对象，它们可以在运行时创建，作为参数传递，从函数返回，以及赋给变量。</p><p id="83a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看下面的例子-</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="bb71" class="jz ka hi jv b fi kb kc l kd ke">class Tutorial:<br/>    pass</span><span id="1015" class="jz ka hi jv b fi kf kc l kd ke">print(Tutorial())</span><span id="9d26" class="jz ka hi jv b fi kf kc l kd ke"># Output - <br/># &lt;__main__.Tutorial object at 0x7fd92c1500f0&gt;</span></pre><p id="cec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的,<code class="du kg kh ki jv b">Tutorial</code>类的实例告诉我们这是主教程对象的一个对象。在某个地方。</p><p id="af9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在只打印类本身-</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="666b" class="jz ka hi jv b fi kb kc l kd ke">print(Tutorial)</span><span id="6491" class="jz ka hi jv b fi kf kc l kd ke"># Output -<br/># &lt;class '__main__.Tutorial'&gt;</span></pre><p id="d103" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们能够这样做的原因是因为<code class="du kg kh ki jv b">Tutorial</code>类是一个对象，就像任何其他对象一样。当你使用<code class="du kg kh ki jv b">class</code>关键字时，Python 会自动创建这个对象。这是一个元类的实例- <code class="du kg kh ki jv b">type</code>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kj"><img src="../Images/7b620dc8ee9b95ec7cc7fe501429a8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sallVEC1DB9AnwPZ.jpg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">理解 Python 元类</figcaption></figure><blockquote class="kk kl km"><p id="eac1" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated"><em class="hi">元类是一个类的类；它定义了一个类的行为。</em></p></blockquote><p id="51c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在为了更简单，让我们深入一下，也许你在 Python 中遇到过<code class="du kg kh ki jv b">type</code>关键字？用来寻找物体的类型-</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="7973" class="jz ka hi jv b fi kb kc l kd ke">print(type(1))</span><span id="99b6" class="jz ka hi jv b fi kf kc l kd ke"># Output - <br/># &lt;class 'int'&gt;</span><span id="f2bb" class="jz ka hi jv b fi kf kc l kd ke">print(type('Hey'))</span><span id="fae5" class="jz ka hi jv b fi kf kc l kd ke"># Output - <br/># &lt;class 'str'&gt;</span></pre><p id="1c77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">果然<code class="du kg kh ki jv b">1</code>是<code class="du kg kh ki jv b">int</code>类的类型，<code class="du kg kh ki jv b">Hey</code>是<code class="du kg kh ki jv b">str</code>类的类型，让我们找出我们类的类型——</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="9dd7" class="jz ka hi jv b fi kb kc l kd ke">print(type(Tutorial))</span><span id="5aba" class="jz ka hi jv b fi kf kc l kd ke"># Output - <br/># &lt;class 'type'&gt;</span></pre><p id="00e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次，我们得到了一个打印输出，表明<code class="du kg kh ki jv b">Tutorial</code>是类<code class="du kg kh ki jv b">type</code>的类型。但是<code class="du kg kh ki jv b">type</code>本身呢？什么是类型的<code class="du kg kh ki jv b">type</code>？</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="0d66" class="jz ka hi jv b fi kb kc l kd ke">print(type(type))</span><span id="d1e3" class="jz ka hi jv b fi kf kc l kd ke"># Output -<br/># &lt;class 'type'&gt;</span></pre><p id="32bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kg kh ki jv b">type</code>的类型是类<code class="du kg kh ki jv b">type</code>，你可能会觉得这很奇怪。因此我们发现<code class="du kg kh ki jv b">type</code>也是它自己的元类！</p><h1 id="52da" class="kr ka hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">理解元类如何工作</h1><p id="418a" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated"><code class="du kg kh ki jv b">type</code>是 python 中内置的元类。它用于构造类，就像类用于构造对象一样。所以每当我们创建一个类时，默认的元类(<code class="du kg kh ki jv b">type</code>)就会被调用，并给我们一个选项来使用它作为一个对象。<br/>这意味着 python 中的每个类也是<code class="du kg kh ki jv b">type</code>的对象，因此我们可以直接使用<code class="du kg kh ki jv b">type</code>来生成一个类，而不需要任何类语法。type()函数可以通过使用以下三个参数来直接定义类</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="71e1" class="jz ka hi jv b fi kb kc l kd ke">type(&lt;name&gt;, &lt;bases&gt;, &lt;dct&gt;)</span></pre><ul class=""><li id="4fc7" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated"><strong class="ih hj">名称</strong> —这是类的内部表示。这是类的名称。</li><li id="1827" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">bases</strong>——这指定了我们从超类或父类继承的任何东西。这是父类的元组。</li><li id="9e4d" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj"> dct </strong> —这指定了包含类的方法和变量定义的名称空间字典。</li></ul><p id="0bc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更清楚地说-</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="9a84" class="jz ka hi jv b fi kb kc l kd ke">Test = type('Test', (), {})</span></pre><p id="0300" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以上面的代码完全等同于下面的代码-</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="7254" class="jz ka hi jv b fi kb kc l kd ke">class Test:<br/>    pass</span></pre><p id="5335" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">他们绝对没有什么不同。</p><p id="430d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们想要修改类的行为，我们将需要编写我们自己的自定义元类。</p><p id="c63e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建我们自己的定制元类，我们首先必须继承默认的元类<code class="du kg kh ki jv b">type</code>，并实现元类的<code class="du kg kh ki jv b">__new__</code>方法和/或<code class="du kg kh ki jv b">__init__</code>方法。</p><ul class=""><li id="56dc" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated"><code class="du kg kh ki jv b">__new__</code>:这个 dunder 方法通常被类型的<code class="du kg kh ki jv b">__new__</code>覆盖，在调用创建类的原始<code class="du kg kh ki jv b">__new__</code>之前，修改要创建的类的一些属性。</li><li id="c706" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><code class="du kg kh ki jv b">__init__</code>:创建实例/对象后，当您想要控制初始化时，调用此方法。</li></ul><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="cf12" class="jz ka hi jv b fi kb kc l kd ke">class MyMeta(type):<br/>    def __new__(self, name, bases, attr):<br/>        print(attr)<br/>        return type(name, bases, attr)</span></pre><p id="dca0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我定义了一个简单的元类<code class="du kg kh ki jv b">MyMeta</code>，我们将打印出属性，这样我们就可以看到它们的样子。之后，我定义了另一个类<code class="du kg kh ki jv b">Sample</code>，它有元类<code class="du kg kh ki jv b">MyMeta</code>，有<code class="du kg kh ki jv b">name</code>和<code class="du kg kh ki jv b">age</code>变量-</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="2e83" class="jz ka hi jv b fi kb kc l kd ke">class Sample(metaclass=MyMeta):<br/>    name = 'bob'<br/>    age = 24</span></pre><p id="ba42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在没有创建实例的情况下，它仍然会运行，您可以看到下面的输出</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="f01e" class="jz ka hi jv b fi kb kc l kd ke">{'__module__': '__main__', '__qualname__': 'Sample', 'name': 'bob', 'age': 24}</span></pre><p id="22bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么这个类<code class="du kg kh ki jv b">Sample</code>是如何被创建的</p><p id="7321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解释器看到了在<code class="du kg kh ki jv b">Sample</code>中定义的<code class="du kg kh ki jv b">metaclass=MyMeta</code>，所以现在解释器得到信息，默认元类<code class="du kg kh ki jv b">type</code>不能用于创建<code class="du kg kh ki jv b">Sample</code>类，而必须使用<code class="du kg kh ki jv b">MyMeta</code>来创建<code class="du kg kh ki jv b">Sample</code>类。</p><p id="1a4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，解释器调用<code class="du kg kh ki jv b">MyMeta</code>来创建类<code class="du kg kh ki jv b">Sample</code>，当<code class="du kg kh ki jv b">MyMeta</code>被调用时，<code class="du kg kh ki jv b">MyMeta</code>的<code class="du kg kh ki jv b">__new__</code>被调用，它打印出属性，并使用<code class="du kg kh ki jv b">type</code>构造<code class="du kg kh ki jv b">MyMeta</code>的实例，即<code class="du kg kh ki jv b">Sample</code>并将对象返回给我们。</p><p id="23e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个元类只覆盖对象创建。类和对象行为的所有其他方面仍然由类型处理。</p><p id="bacd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经介绍了足够多的理论来理解什么是元类以及如何编写自定义元类。现在让我们看一个简单的真实案例--</p><p id="a405" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个要求，你的类的所有属性都应该是大写的，有多种方法可以实现这个功能，但是这里我们将在模块级使用<code class="du kg kh ki jv b">metaclass</code>来实现，所以在名称空间字典(属性)中，如果一个键不是以双下划线开头，我们需要将其改为大写-</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="3ad6" class="jz ka hi jv b fi kb kc l kd ke">class MyMeta(type):</span><span id="3f38" class="jz ka hi jv b fi kf kc l kd ke">    def __new__(self, name, bases, atts):</span><span id="6315" class="jz ka hi jv b fi kf kc l kd ke">        print(f'current_attributes - {atts}\n')<br/>        new_atts = {}</span><span id="6d9a" class="jz ka hi jv b fi kf kc l kd ke">        for key, val in atts.items():<br/>            if key.startswith('__'):<br/>                new_atts[key] = val<br/>            else:<br/>                new_atts[key.upper()] = val</span><span id="d782" class="jz ka hi jv b fi kf kc l kd ke">        print(f'modified_attributes - {new_atts}')        <br/>        return type(name, bases, new_atts)<br/></span><span id="a092" class="jz ka hi jv b fi kf kc l kd ke">class Sample(metaclass=MyMeta):<br/>    x = 'bob'<br/>    y = 24</span><span id="e371" class="jz ka hi jv b fi kf kc l kd ke">    def say_hi(self):<br/>        print('hii')</span></pre><p id="40e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出-</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="c55e" class="jz ka hi jv b fi kb kc l kd ke">current_attributes - {'__module__': '__main__', '__qualname__': 'Sample', 'x': 'bob', 'y': 24, 'say_hi': &lt;function Sample.say_hi at 0x7fd92c10d048&gt;}</span><span id="d32c" class="jz ka hi jv b fi kf kc l kd ke">modified_attributes - {'__module__': '__main__', '__qualname__': 'Sample', 'X': 'bob', 'Y': 24, 'SAY_HI': &lt;function Sample.say_hi at 0x7fd92c10d048&gt;}</span></pre><p id="f57e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在上面看到的，我们已经打印了当前的属性，并创建了一个字典来表示我们修改过的属性。</p><p id="5951" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们只是检查键是否以双下划线开头，然后添加正确的值，否则我们将添加具有相应值的大写属性。</p><p id="9c7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了确保这是可行的，让我们来试试，我已经创建了一个<code class="du kg kh ki jv b">Sample</code>的实例，并且只打印一个旧的属性。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="8ef3" class="jz ka hi jv b fi kb kc l kd ke">s = Sample()<br/>s.x</span></pre><p id="dd6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出-</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="10c9" class="jz ka hi jv b fi kb kc l kd ke">AttributeError Traceback (most recent call last)<br/>&lt;ipython-input-18-87b2922593a9&gt; in &lt;module&gt;<br/>      1 s = Sample()<br/>----&gt; 2 s.x</span><span id="7eab" class="jz ka hi jv b fi kf kc l kd ke">AttributeError: 'Sample' object has no attribute 'x'</span></pre><p id="2804" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不出所料，我们得到了一个错误<code class="du kg kh ki jv b">AttributeError</code>，这完全没问题，因为我们刚刚修改了对象的构造，让我们尝试通过修改后的属性来访问</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="1fff" class="jz ka hi jv b fi kb kc l kd ke">print(s.X)</span><span id="f50a" class="jz ka hi jv b fi kf kc l kd ke">s.SAY_HI()</span></pre><p id="adb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出-</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="ba25" class="jz ka hi jv b fi kb kc l kd ke">bob<br/>hii</span></pre><p id="54ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是他们称之为魔术的原因，因为通过这种与类创建的挂钩，你真的可以对如何创建类施加相当多的约束</p><p id="0995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果你想让一个特定模块中的每一个类都不被允许使用某个特定的属性或者遵循某个特定的模式，你可以为这些特定的模块设置元类。</p><h1 id="3aef" class="kr ka hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h1><p id="cf52" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">元类的目的不是用元类/类代替类/对象的区别，而是以某种方式改变类定义(以及它们的实例)的行为。<br/>元类使用的合理模式是在定义一个类时做一次，而不是在实例化同一个类时重复做。当多个类共享相同的特殊行为时，重复<code class="du kg kh ki jv b">metaclass=X</code>显然比重复特定目的代码要好。</p><h1 id="20c3" class="kr ka hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">参考</h1><div class="mh mi ez fb mj mk"><a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab dw"><div class="mm ab mn cl cj mo"><h2 class="bd hj fi z dy mp ea eb mq ed ef hh bi translated">Python 中的元类是什么？</h2><div class="mr l"><h3 class="bd b fi z dy mp ea eb mq ed ef dx translated">在理解元类之前，您需要掌握 Python 中的类。Python 对什么有一个非常特殊的想法……</h3></div><div class="ms l"><p class="bd b fp z dy mp ea eb mq ed ef dx translated">stackoverflow.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my jn mk"/></div></div></a></div><p id="a7f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://stackoverflow.com/questions/392160/what-are-some-concrete-use-cases-for-metaclasses/393368" rel="noopener ugc nofollow" target="_blank">https://stackoverflow . com/questions/392160/元类的具体用例是什么/393368 </a></p></div></div>    
</body>
</html>