<html>
<head>
<title>Create Voronoi regions using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 创建 Voronoi 区域</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/create-voronoi-regions-with-python-28720b9c70d8?source=collection_archive---------8-----------------------#2020-10-11">https://medium.com/analytics-vidhya/create-voronoi-regions-with-python-28720b9c70d8?source=collection_archive---------8-----------------------#2020-10-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="d4b3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">概观</h1><p id="cc01" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最常见的空间问题之一是找到离我们当前位置最近的兴趣点(POI)。假设某人很快就要没油了，他/她需要在为时已晚之前找到最近的加油站，这个问题的最佳解决方案是什么？当然，司机可以查看地图以找到最近的加油站，但如果该地区有多个加油站，他/她需要快速决定哪个加油站是最近的，这就有问题了。最佳解决方案是用多边形内的点来表示每个 POI。所以在一个多边形内，最近的 POI 肯定是多边形内的点。这些多边形被称为 Voronoi 区域。</p><h1 id="4624" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">数据收集</h1><p id="2e23" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">对于这个项目，我根据 POI 数据在地图上创建 Voronoi 区域。所有 POI 数据都是随机选择的，而街道网络数据是借助 OSMnx 软件包从 OpenStreetMap 下载的。</p><h1 id="18e5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">创建 Voronoi 区域</h1><p id="31b6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">目前，使用 Python 构建 Voronoi 区域最简单的方法是使用 geovoronoi 包。Geovoronoi 是一个在地理区域内创建和绘制 voronoi 区域的软件包。至于地图可视化，我选择的是 leav 包。</p><p id="976a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，我开始在地图周围创建随机点。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d97f" class="kp ig hi kl b fi kq kr l ks kt">gdf = gpd.GeoDataFrame()<br/>gdf = gdf.append({'geometry': Point(106.644085,-6.305286)}, ignore_index=<strong class="kl hj">True</strong>)<br/>gdf = gdf.append({'geometry': Point(106.653261,-6.301309)}, ignore_index=<strong class="kl hj">True</strong>)<br/>gdf = gdf.append({'geometry': Point(106.637751,-6.284774)}, ignore_index=<strong class="kl hj">True</strong>)<br/>gdf = gdf.append({'geometry': Point(106.665062,-6.284598)}, ignore_index=<strong class="kl hj">True</strong>)<br/>gdf = gdf.append({'geometry': Point(106.627582,-6.283521)}, ignore_index=<strong class="kl hj">True</strong>)<br/>gdf = gdf.append({'geometry': Point(106.641365,-6.276593)}, ignore_index=<strong class="kl hj">True</strong>)<br/>gdf = gdf.append({'geometry': Point(106.625972,-6.303643)}, ignore_index=<strong class="kl hj">True</strong>)</span></pre><p id="c8bb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下一步是确定 Voronoi 区域的覆盖范围，并将其保存到地理数据框架中。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="56d0" class="kp ig hi kl b fi kq kr l ks kt">area_max_lon = 106.670929<br/>area_min_lon = 106.619602<br/>area_max_lat = -6.275227<br/>area_min_lat = -6.309795<br/><br/>lat_point_list = [area_min_lat, area_max_lat,area_max_lat,area_min_lat]<br/>lon_point_list = [area_min_lon, area_min_lon, area_max_lon, area_max_lon]<br/><br/>polygon_geom = Polygon(zip(lon_point_list, lat_point_list))</span><span id="9f89" class="kp ig hi kl b fi ku kr l ks kt">boundary = gpd.GeoDataFrame()<br/>boundary = boundary.append({'geometry': polygon_geom}, ignore_index=<strong class="kl hj">True</strong>)<br/></span></pre><p id="b497" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">不要忘记将 gdf 和边界数据帧转换为 Web 墨卡托投影。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="903a" class="kp ig hi kl b fi kq kr l ks kt">gdf.crs = {'init' :'epsg:3395'}<br/>boundary.crs = {'init' :'epsg:3395'}</span></pre><p id="9a0c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将边界几何数据帧转换为多边形的并集，将 POI 数据帧转换为坐标数组。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="0b05" class="kp ig hi kl b fi kq kr l ks kt">boundary_shape = cascaded_union(boundary.geometry)<br/>coords = points_to_coords(gdf.geometry)</span></pre><p id="fb67" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">计算 Voronoi 区域。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="9167" class="kp ig hi kl b fi kq kr l ks kt">poly_shapes, pts, poly_to_pt_assignments = voronoi_regions_from_coords(coords, boundary_shape)</span></pre><p id="98fd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">根据 OpenStreetMap 在覆盖区域的边界内创建一个图表。使用图表收集覆盖区域边界内的所有街道网络，并将其保存到 dataframe。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="f2d4" class="kp ig hi kl b fi kq kr l ks kt">G = ox.graph_from_polygon(boundary_shape, network_type='all_private')<br/>gdf_all_streets =  ox.graph_to_gdfs(G, nodes=<strong class="kl hj">False</strong>, edges=<strong class="kl hj">True</strong>,node_geometry=<strong class="kl hj">False</strong>, fill_edge_geometry=<strong class="kl hj">True</strong>)</span></pre><p id="4b5b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">创建新的数据框以收集每个 Voronoi 区域内的街道网络</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="0e88" class="kp ig hi kl b fi kq kr l ks kt">gdf_streets_by_region = gpd.GeoDataFrame()<br/><strong class="kl hj">for</strong> x <strong class="kl hj">in</strong> range(len(poly_shapes)):<br/>    gdf_streets = gpd.GeoDataFrame()<br/>    gdf_streets['geometry'] = gdf_all_streets.intersection(poly_shapes[x])<br/>    gdf_streets['voronoi_region'] = x<br/>    gdf_streets = gdf_streets[gdf_streets['geometry'].astype(str) != 'LINESTRING EMPTY']<br/>    gdf_streets_by_region = gdf_streets_by_region.append(gdf_streets)</span></pre><p id="43fc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面是地图上 Voronoi 区域的可视化。</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kv"><img src="../Images/a89fa2e0bee0f9463c90782d5b26d254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvIN07e6-UU6s3F7SplQ8Q.png"/></div></div></figure><h1 id="ac20" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="ea68" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">地图看起来很棒！不幸的是，它还没有准备好用于现实生活中的应用，问题是这些 Voronoi 区域是通过使用欧几里德距离而不是网络距离创建的。</p><p id="3258" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">希望你喜欢阅读这篇文章。关于代码的更多细节，你可以点击<a class="ae ld" href="https://nbviewer.jupyter.org/github/Dennypalinggi/voronoi_diagram_folium_map/blob/master/voronoi_diagram_project.ipynb" rel="noopener ugc nofollow" target="_blank">这个</a>链接。</p></div></div>    
</body>
</html>