<html>
<head>
<title>Hierarchical Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分层聚类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/hierarchical-clustering-d2d92835280c?source=collection_archive---------8-----------------------#2020-12-17">https://medium.com/analytics-vidhya/hierarchical-clustering-d2d92835280c?source=collection_archive---------8-----------------------#2020-12-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3cc2eb84ebfe8c4c5b125f9cfb170b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QZCzHubTJbZ0Hp8c"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@itfeelslikefilm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">🇸🇮·扬科·菲利</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d3b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">聚类是一种无监督的机器学习技术。在这篇博客文章中，我们将涉及以下主题</p><ol class=""><li id="5ad2" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">什么是集群？</li><li id="aae5" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">分层聚类。</li><li id="4ac8" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">分层聚类的实现。</li></ol><p id="5256" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 1。</strong> <strong class="ix hj">什么是聚类？</strong></p><p id="5a0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">聚类是基于相似性对数据点进行分组的过程，使得一个聚类中的数据点彼此相似，而与其他聚类中的数据点不相似。例如，图1.1中所示的数据点被分成三组。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/277b5cbde3a75f5d116e97a5a96bcc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*uOcBeC3zNRMk9BBKlvHUeA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd km">图1.1:聚类</strong></figcaption></figure><p id="1d54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来源:-<a class="ae iu" href="https://i.ytimg.com/vi/2QTeuO0C-fY/hqdefault.jpg" rel="noopener ugc nofollow" target="_blank">https://i.ytimg.com/vi/2QTeuO0C-fY/hqdefault.jpg</a></p><p id="e197" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有各种距离度量来计算数据点或聚类之间的相似性。其中一些列举如下</p><p id="64f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">欧几里得距离</p><p id="6de9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最大距离</p><p id="5d48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">曼哈顿距离</p><p id="267f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">堪培拉距离</p><p id="e2f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">二元距离</p><p id="f7c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">闵可夫斯基距离</p><p id="e46b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。</strong> <strong class="ix hj">层次聚类</strong></p><p id="d78f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">层次聚类</strong>是聚类的类型之一。它将数据点划分为一个聚类层次。它可以分为两种类型——凝聚聚类和分裂聚类。</p><p id="0c64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">i) <strong class="ix hj">凝聚聚类</strong></p><p id="f113" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">聚集聚类遵循自下而上的方法。在聚集聚类中，每个数据点被分配给一个单独的聚类。在每次迭代中，基于聚类的相似性将聚类合并在一起，并且重复该过程，直到形成一个聚类或K个聚类。</p><p id="9da8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">算法:- </strong></p><p id="f32f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.将每个数据点分配给单个聚类。</p><p id="1c25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.基于相似性合并聚类。</p><p id="462f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.重复步骤2，直到我们剩下k个集群或单个集群。</p><p id="04bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了理解聚集聚类的概念，让我们考虑五个数据点{a，b，c，d，e}。</p><p id="5077" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤0:- </strong>在步骤0中，所有的数据点都被分配到单个聚类中。因此有五个群集{a}、{b}、{c}、{d}、{e}最初对应于五个数据点。</p><p id="fd31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤1:- </strong>在步骤1中，聚类{a}和{b}被合并成单个聚类{a，b}，因为它们彼此相似，并且我们留下了4个聚类。</p><p id="9657" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤2:- </strong>在步骤2中，聚类{d}和{e}基于相似性被合并，并且我们有3个聚类。</p><p id="e008" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤3:- </strong>在步骤3中，聚类{c}和{d，e}被合并成单个聚类{c，d，e}，因为它们彼此相似，并且我们留下了两个聚类。</p><p id="c3a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤4:- </strong>在步骤4中，聚类{a，b}和{c，d，e}被合并成单个聚类{a，b，c，d，e}，因为它们彼此相似，现在最后，我们只剩下单个聚类，如图1.2所示。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kn"><img src="../Images/0b5994f2a2df64995a8d6ee332ae880f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*5sBT0bnWWlKrmIGGON8kMQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd km">图1.2:聚集和分裂聚类</strong></figcaption></figure><p id="e978" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来源:<a class="ae iu" href="https://i1.wp.com/r-posts.com/wp-content/uploads/2017/12/Agnes.png" rel="noopener ugc nofollow" target="_blank">https://i1 . WP . com/rposts . com/WP content/uploads/2017/12/Agnes . png</a></p><p id="d795" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> ii)分裂聚类</strong></p><p id="7f5c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分裂聚类遵循自上而下的方法。它与凝聚集群相反。在分裂聚类中，所有数据点都被分配到一个聚类中。在每一次迭代中，基于不相似性将聚类分成其他聚类，并且重复该过程，直到我们剩下n个聚类。</p><p id="68f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">算法:- </strong></p><p id="8ff8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.将所有数据点分配给单个聚类。</p><p id="cb3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.根据相异度将数据点划分为单独的聚类。</p><p id="60c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.重复步骤2，直到我们剩下n个集群。</p><p id="3f49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了理解分裂聚类的概念，让我们考虑五个数据点{a，b，c，d，e}。</p><p id="774e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤0:- </strong>在步骤0中，所有点{a，b，c，d，e}被分配到单个聚类。所以最初只存在一个集群。</p><p id="f7e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤1:- </strong>在步骤1中，聚类{a，b，c，d，e}根据相异度被分成两个聚类{a，b}和{c，d，e}。</p><p id="b1a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤2:- </strong>在步骤2中，聚类{c，d，e}被分成两个聚类{c}和{d，e}，因为它们不相似。</p><p id="027a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤3:- </strong>在步骤3中，聚类{d，e}基于相异度被分成两个聚类{d}和{e}。</p><p id="61f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤4:- </strong>在步骤4中，聚类{a，b}根据相异度被分成两个聚类{a}和{b}，现在，最终我们剩下五个聚类，即{a}、{b}、{c}、{d}、{e}，如图1.2所示。</p><p id="2d56" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">如何计算一个数据点或一个聚类到另一个聚类的距离</strong></p><p id="d2ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">一、单联动</strong></p><p id="0faa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在单链聚类中，从一个数据点或一个聚类到另一个聚类的距离是通过取一个聚类的任何成员到另一个聚类的任何成员的最小距离来计算的，如图1.3所示。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/614a203f5b859b775ddeee2fc2837bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*a4SH5yJkNXdwNVv8HUY3Ag.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1.3:单一连杆</figcaption></figure><p id="977d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来源:<a class="ae iu" href="https://www.saedsayad.com/images/Clustering_single.png" rel="noopener ugc nofollow" target="_blank">https://www.saedsayad.com/images/Clustering_single.png</a></p><p id="2545" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">二。完成联动</strong></p><p id="55e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在完全关联聚类中，从一个数据点或一个聚类到另一个聚类的距离是通过取一个聚类的任何成员到另一个聚类的任何成员的最大距离来计算的，如图1.4所示。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/e1ef11e8ba1addc5ebcbe5fdbae1d322.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*ju7AJ_Ufh9T2N6tkhmxvTw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1.4:-完整的连接</figcaption></figure><p id="cf61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来源:-<a class="ae iu" href="https://www.saedsayad.com/images/Clustering_complete.png" rel="noopener ugc nofollow" target="_blank">https://www.saedsayad.com/images/Clustering_complete.png</a></p><p id="3170" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">三世。平均联动</strong></p><p id="f10b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在平均关联聚类中，一个数据点或一个聚类到另一个聚类的距离是通过计算一个聚类的任何成员到另一个聚类的任何成员的平均距离来计算的，如图1.5所示。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/e65b21b51c49dbea53ed0fcc49a764a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*RIzFYexDLQYGRsDJmrAF9g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1.5:-平均链接</figcaption></figure><p id="1e83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来源:【https://www.saedsayad.com/images/Clustering_average.png】T4</p><p id="e564" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。实现层次聚类</strong></p><p id="cba8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi kr translated">为了进行实验，我从Kaggle下载了一个数据集(https://www.kaggle.com/deepakg/usarrests)。该数据集包含1973年美国50个州每100，000名居民中因攻击、谋杀和强奸而被捕的统计数据。它也给出了居住在城市地区的人口百分比。</p><ol class=""><li id="8b30" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><strong class="ix hj">加载数据集</strong></li></ol><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es la"><img src="../Images/19704f933cec24e0e1bcf19debed2007.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*m4cYaDb81XOSbVfM0fcx8g.png"/></div></figure><p id="0fc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行上述代码后，我们得到以下输出-</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/7d5913eff52a9182914c0c5f7ba70e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*dCDEe1AwjrV1-e7FfwNMAg.png"/></div></figure><p id="e77a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们已经加载了数据集，我们可以看到数据集的行。</p><p id="b4d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。缩放比例</strong></p><p id="591e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在应用层次聚类之前，需要对数据进行归一化，以便每个变量的尺度都相同。如果变量的比例不同，模型可能会偏向比例较高的变量。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/7fd9308246149afa489d7f8a6cbd7c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*DUFebpe26zUloXHnq6uZ2w.png"/></div></figure><p id="5ab7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行上述代码后，我们得到以下输出-</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/8815663a54dad0f09acfcba9b97ac566.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*5NYpAiVPG-KjlUudbITXcw.png"/></div></figure><p id="48df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们可以看到所有变量的规模几乎是相似的。</p><p id="8b8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.下一步是计算不同数据点之间的欧几里德距离，并将结果存储在变量d中。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/9906c32b08763f27fbcdae2dd585aa0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*qzpnoU3Ahlf3eKFogxk3Zw.png"/></div></figure><p id="9af7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行上述代码后，我们得到以下输出-</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es le"><img src="../Images/4cbdb6fe6f47f63e619a6fe6e6143512.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*7elJyHrTIeF2hUqxUbZoGQ.png"/></div></figure><p id="ac83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们可以看到不同数据点的距离的6*6矩阵。</p><p id="3cb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.使用分层平均链接方法进行聚类。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/a6f4208d5374ffbba77c661cf4d41ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*QsVnXlqsTsPPOrBmqdl-5g.png"/></div></figure><p id="5607" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了绘制树枝状图，我们在这里使用了plot命令，得到了下图。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/efee522aead5183fc3cd7b36f69ce5c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*RwQKDXeXuBm_L2yILTgr2Q.png"/></div></figure><p id="3ff3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.将树突分割成簇。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/b01470b5e4ee6c3400a9622054ef34e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*eovpSsG8EM0MdTLht37Epg.png"/></div></figure><p id="2b79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行上述代码后，我们得到以下输出-</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/d16fb893f9878a6639f84216bed95559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*lBHRliaBbwgL4x_FMf3UJw.png"/></div></figure><p id="05e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.将聚类数与数据集关联</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es li"><img src="../Images/136a91f2e6fd7533b32841fa9734107a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*pZ1pLvhHnobvZF2CCh0FoQ.png"/></div></figure><p id="7902" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行上述代码后，我们得到以下输出-</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/f1f6032f0bfd00b93521e82ac9b2a30d.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*vQVRtmerZYBwzxWMVa4a-w.png"/></div></figure><p id="f6d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们可以看到数据被分成了几个簇。</p></div></div>    
</body>
</html>