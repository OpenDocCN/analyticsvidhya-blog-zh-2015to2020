<html>
<head>
<title>Understanding Python scopes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Python范围</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-python-scopes-8a5e24b7d784?source=collection_archive---------18-----------------------#2019-12-10">https://medium.com/analytics-vidhya/understanding-python-scopes-8a5e24b7d784?source=collection_archive---------18-----------------------#2019-12-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ff0b029405131ce24a9a526695226f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AmTSUocOgq2cSAYL"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae iu" href="https://unsplash.com/@jpvalery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jp Valery </a></figcaption></figure><p id="3db7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一名深度学习工程师，你发现自己需要为不同的问题编写非常不同的代码。理解Python开发的本质细节会让你成为一个更有创造力和更强大的问题解决者。</p><p id="2a88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在编写代码时经常做的事情之一就是使用赋值(例如a = 5)。无论你是在调用一个函数，一个类还是进行一个简单的计算，你都可能在使用作用域。范围定义了在代码的不同部分对不同标签的访问权限。也就是说，如果从函数1或函数2中执行，计算+5可能有不同的意义。为了准确理解您正在处理的“a”是什么，并使它按预期运行，您需要理解范围。</p><h1 id="3466" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">内置和全局范围</h1><p id="851f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将讨论的第一个范围是内置范围。当你在模块本身中，而不是在任何函数或类中时，你可以这样写:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="dcf5" class="lf ju hi lb b fi lg lh l li lj">print('this is just a print')</span><span id="4d73" class="lf ju hi lb b fi lk lh l li lj">---&gt; this is just a print</span></pre><p id="f05c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python完全知道您的意思，它只是打印您请求的字符串。Python怎么知道什么是“打印”？假设这是我们的整个脚本，Python在模块中寻找打印的定义(也称为全局范围)，当它找不到任何定义时，它就转到<strong class="ix hj">内置的</strong>范围，在那里找到它需要的内容。Python开始查看它被执行的范围，并且每当它找不到它需要的东西时就沿着链向上。这意味着我可以很容易地覆盖“print ”,并使其行为不同。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="eb11" class="lf ju hi lb b fi lg lh l li lj">def print(*args):<br/>    return 3 + 4</span><span id="31d5" class="lf ju hi lb b fi lk lh l li lj">print('this is just a print')<br/>---&gt; 7</span></pre><p id="5bf8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在当我执行print函数时，我实际上只得到整数7。由于现在在<strong class="ix hj">全局</strong>作用域中有打印的定义，这就是正在使用的。这个<strong class="ix hj">全局</strong>打印范围定义，隐藏了<strong class="ix hj">内置</strong>范围定义，从而改变了它的行为。</p><h1 id="2972" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">全局和本地范围</h1><p id="5e1e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">上面提到的全局作用域是主模块作用域，这里没有定义任何特别的东西。然而，如果我们定义一个函数，函数内部的任何东西都是局部范围。这个<strong class="ix hj">局部</strong>范围是函数的上下文。让我们看看这是如何表现的:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8b00" class="lf ju hi lb b fi lg lh l li lj"># define x = 40 in the global scope.<br/>x = 'python'<br/>print(x)<br/>---&gt; 'python'</span><span id="768a" class="lf ju hi lb b fi lk lh l li lj"># get access to global scope from a function<br/>def print_global_x():<br/>    print(x)<br/>---&gt; 'python'</span><span id="0ab8" class="lf ju hi lb b fi lk lh l li lj"># define a function to change x <br/>def change_x():<br/>    x = 5<br/>    print('the local scope x =', x)</span><span id="9ca8" class="lf ju hi lb b fi lk lh l li lj">change_x()<br/>print('the global scope x =', x)</span><span id="ea6c" class="lf ju hi lb b fi lk lh l li lj">---&gt; the local scope x = 5<br/>---&gt; the global scope x = 'python'</span></pre><p id="b776" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们所看到的，我们有两个不同的x。一个是5，第二个是“python”。你可以想象，当我们想把x作为一个整数使用时，这会变得很混乱，但我们实际得到的是字符串‘python’。在这种情况下，x在change_x的上下文中是5，但在主模块的上下文中是“python”。</p><p id="fc40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在函数print_global_x中，我们可以再次看到寻找作用域函数的过程。它首先尝试执行的作用域，在这个例子中是函数本身，它没有找到x的任何赋值，所以它继续到下一个全局作用域，在那里找到并打印它。如果x没有在全局作用域中定义，Python将在内置作用域中寻找它，在那里它找不到它，因此返回一个“<strong class="ix hj"> NameError </strong>异常，说明x没有定义。</p><h1 id="023d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">控制范围</h1><p id="4de7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是否意味着我们只能在模块本身中定义全局范围？其实不是。我们甚至可以在函数内部改变全局范围，使用<strong class="ix hj">全局</strong> <strong class="ix hj">关键字</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7826" class="lf ju hi lb b fi lg lh l li lj">a = 20</span><span id="4bed" class="lf ju hi lb b fi lk lh l li lj">def change_a():<br/>    global a <br/>    a = 4</span><span id="25d3" class="lf ju hi lb b fi lk lh l li lj">print('a before change in global scope =', a)<br/>change_a()<br/>print('a after change in global scope =', a)</span><span id="6084" class="lf ju hi lb b fi lk lh l li lj">---&gt; a before change in global scope = 20<br/>---&gt; a after change in global scope = 4</span></pre><p id="6b4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在函数内部的全局作用域中改变了a引用的值(从而改变了我们调用a时得到的值)。当我们试图在全局上下文中访问一个，无论是从函数还是从模块，我们都会得到4。</p><p id="9f2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，假设我有几个嵌套的函数，我需要改变主函数的范围，所以它会影响到所有其他的函数。我们可以通过使用<strong class="ix hj">非本地</strong> <strong class="ix hj">关键字</strong>来实现这一点。这里我们定义了一个函数define_b，它定义了b，并将其打印为4。然后我们定义一个名为change_b的新函数，它将b的<strong class="ix hj">非局部</strong>上下文更改为10。当我们稍后调用新函数print_b时，我们看到b被修改了。</p><p id="c84e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们试图在全局范围内打印b，我们仍然会得到一个未定义的<strong class="ix hj"> NameError </strong>，因为b只存在于define_b函数的范围内。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3a59" class="lf ju hi lb b fi lg lh l li lj">def define_b():<br/>    b = 4<br/>    print('b before change =', b)</span><span id="f35e" class="lf ju hi lb b fi lk lh l li lj">    def change_b():<br/>        nonlocal b<br/>        b = 10<br/>    change_b()<br/>    <br/>    def print_b():<br/>        print('new b is ', b)<br/>    print('b after change =', b)<br/>    print_b()</span></pre><p id="ca18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">外地</strong>改什么范围？如果我们有更多的嵌套函数，我们会看到非局部函数在层次结构中上升到可以找到b的下一次赋值的位置，在我们的例子中，b的下一次赋值是在define_b函数中，因此它改变了这个范围。注意，非局部不会改变全局范围，为此我们仍然必须使用<strong class="ix hj">“全局b”。</strong></p><p id="7d66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望这能让使用作用域变得更容易理解，因为这是一个非常重要的话题。</p><p id="f160" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如有任何其他问题，请随时通过Bakugan@gmail.com或<a class="ae iu" href="https://www.linkedin.com/in/chen-margalit-4b1a67117/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>联系我</p></div></div>    
</body>
</html>