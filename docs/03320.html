<html>
<head>
<title>Optimization Modelling in Python: SciPy, PuLP, and Pyomo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的优化建模:SciPy、PuLP和Pyomo</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/optimization-modelling-in-python-scipy-pulp-and-pyomo-d392376109f4?source=collection_archive---------2-----------------------#2020-01-26">https://medium.com/analytics-vidhya/optimization-modelling-in-python-scipy-pulp-and-pyomo-d392376109f4?source=collection_archive---------2-----------------------#2020-01-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5a8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优化建模是寻找复杂决策问题的最优或近似最优解的最实用和最广泛使用的工具之一。优化建模，大多数时候被简单地称为“优化”，是更广泛的研究领域运筹学的一部分。</p><p id="8241" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将简要比较三个流行的开源优化库:SciPy、PuLP和Pyomo。我们将尝试解决单个用例，以突出提到的库的实现和语法差异。</p><p id="1861" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑简化的运输类型问题。我们有一组客户<strong class="ih hj"><em class="jd">I</em></strong>=【1，2，3，4，5】和一组工厂<strong class="ih hj"><em class="jd">J</em></strong>=【1，2，3】。每个客户都有一些固定的产品需求<strong class="ih hj"> <em class="jd"> d_i </em> </strong>每个工厂都有固定的生产能力<strong class="ih hj"> <em class="jd"> M_j </em> </strong>。从工厂<strong class="ih hj"> <em class="jd"> j </em> </strong>向客户<strong class="ih hj"> <em class="jd"> i </em> </strong>交付一单位货物也有固定的运输成本。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/e15e9492b6eed6204e80ae8be00be15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*fxKfoW6at3P1B5RQloMb1A.png"/></div></figure><p id="44a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在数学上，这个优化问题可以描述如下:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jm"><img src="../Images/9c87f8816a3bd89cffd06c705bbb5284.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*u1x12gxQ4Dxx4t0JZFdYCw.png"/></div></figure><p id="77c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的任务是以最低的总运输成本向每个客户交付必要数量的货物(满足客户需求和工厂生产能力)。为了将这种情况公式化为优化问题，我们必须将其分成3个主要部分:</p><ul class=""><li id="3b79" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">决策变量</strong> —从工厂<strong class="ih hj"> <em class="jd"> j </em> </strong>发送给客户<strong class="ih hj"> <em class="jd"> i </em> </strong>的货物数量(正实数)</li><li id="7da1" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj">约束</strong>——货物总量必须满足客户需求和工厂生产能力(等式/不等式在左侧有线性表达)</li><li id="83c0" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj">目标函数</strong>——找出总运输成本最低的决策变量的值(本例中为线性表达式)</li></ul><p id="4e74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最优化术语中，这种特殊情况是<strong class="ih hj">混合整数线性规划</strong>问题，因为决策变量不限于整数(整数规划)，并且根据业务逻辑，所有约束和目标函数都是线性的。仅存在一个业务目标使其成为单目标优化问题(多目标优化也是可能的)。</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="3869" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始用python实现解决方案。首先，我们准备好所有的数据结构:</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="868b" class="kn ko hi kj b fi kp kq l kr ks">import sys<br/>import numpy as np</span><span id="7319" class="kn ko hi kj b fi kt kq l kr ks">d = {1:80, 2:270, 3:250, 4:160, 5:180}  # customer demand<br/>M = {1:500, 2:500, 3:500}               # factory capacity</span><span id="96cc" class="kn ko hi kj b fi kt kq l kr ks">I = [1,2,3,4,5]                         # Customers<br/>J = [1,2,3]                             # Factories</span><span id="3b67" class="kn ko hi kj b fi kt kq l kr ks">cost = {(1,1):4,    (1,2):6,    (1,3):9,<br/>     (2,1):5,    (2,2):4,    (2,3):7,<br/>     (3,1):6,    (3,2):3,    (3,3):3,<br/>     (4,1):8,    (4,2):5,    (4,3):3,<br/>     (5,1):10,   (5,2):8,    (5,3):4<br/>   }                                    # transportation costs</span></pre><ul class=""><li id="822b" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> SciPy </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="1df8" class="kn ko hi kj b fi kp kq l kr ks"># to be used in <strong class="kj hj">SciPy</strong> we must transform <strong class="kj hj">cost</strong> dictionary into 2D aray<br/>cost2d = np.empty([len(I), len(J)])<br/>for i in range(len(I)):<br/>    for j in range(len(J)):<br/>        cost2d[i,j] = cost[i+1,j+1]</span></pre><ul class=""><li id="c66d" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> Pyomo </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="d6c9" class="kn ko hi kj b fi kp kq l kr ks">from pyomo import environ as pe</span><span id="b640" class="kn ko hi kj b fi kt kq l kr ks"># ConcreteModel is model where data values supplied at the time of the model definition. As opposite to AbstractModel where data values are supplied in data file<br/>model = pe.ConcreteModel()</span><span id="afab" class="kn ko hi kj b fi kt kq l kr ks"># all iterables are to be converted into Set objects<br/>model.d_cust_demand = pe.Set(initialize = d.keys())<br/>model.M_fact_capacity = pe.Set(initialize = M.keys())</span><span id="c298" class="kn ko hi kj b fi kt kq l kr ks"># Parameters<br/># Cartesian product of two sets creates list of tuples [((i1,j1),v1),((i2,j2),v2),...] !!!<br/>model.transport_cost = pe.Param(<br/>    model.d_cust_demand * model.M_fact_capacity,<br/>    initialize = cost,<br/>    within = pe.NonNegativeReals)</span><span id="2e72" class="kn ko hi kj b fi kt kq l kr ks">model.cust_demand = pe.Param(model.d_cust_demand, <br/>    initialize = d,<br/>    within = pe.NonNegativeReals)</span><span id="e8db" class="kn ko hi kj b fi kt kq l kr ks">model.fact_capacity = pe.Param(model.M_fact_capacity, <br/>    initialize = M,<br/>    within = pe.NonNegativeReals)</span></pre></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="d294" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们初始化决策变量。</p><ul class=""><li id="14d3" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> SciPy </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="a458" class="kn ko hi kj b fi kp kq l kr ks">x0 = np.ones(len(cost))*100<br/>bounds = list((0,max(d.values())) for _ in range(cost2d.size))</span></pre><ul class=""><li id="26a9" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">纸浆</strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="c760" class="kn ko hi kj b fi kp kq l kr ks">import pulp</span><span id="3cdd" class="kn ko hi kj b fi kt kq l kr ks">x = pulp.LpVariable.dicts("amount of goods", ((i, j) for i in I for j in J), lowBound = 0, cat = 'Continuous')</span></pre><ul class=""><li id="6757" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> Pyomo </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="03ba" class="kn ko hi kj b fi kp kq l kr ks">model.x = pe.Var(<br/>    model.d_cust_demand * model.M_fact_capacity,<br/>    domain = pe.NonNegativeReals,<br/>    bounds = (0, max(d.values())))</span></pre></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="eeba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们声明目标函数。</p><ul class=""><li id="06e2" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> SciPy </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="af29" class="kn ko hi kj b fi kp kq l kr ks">def objective(x):<br/>    obj_func = sum(x[idx]*cost2d[idx//len(J), idx%len(J)] for idx in range(cost2d.size))<br/>    return obj_func</span></pre><ul class=""><li id="e38e" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">纸浆</strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="e842" class="kn ko hi kj b fi kp kq l kr ks">objective = pulp.LpAffineExpression(e = [(x[i,j],cost[i,j]) for i,j in x], name = 'Objective function')<br/>model = pulp.LpProblem(name = "Transportation cost minimization", <br/>                        sense = pulp.LpMinimize)<br/>model += pulp.lpSum(objective)</span></pre><ul class=""><li id="f95e" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> Pyomo </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="9f1c" class="kn ko hi kj b fi kp kq l kr ks">model.objective = pe.Objective(<br/>    expr = pe.summation(model.transport_cost, model.x),<br/>    sense = pe.minimize)</span></pre></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="df69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们定义约束。</p><ul class=""><li id="c2fb" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> SciPy </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="b0fb" class="kn ko hi kj b fi kp kq l kr ks"># Constraints: sum of goods == customer demand<br/>def const1():<br/>    tmp = []<br/>    for idx in range(0, cost2d.size, len(J)):<br/>        tmp_constr = {<br/>            'type': 'eq',<br/>            'fun': lambda x, idx: d[idx//len(J) + 1] - np.sum(x[idx: idx + len(J)]),<br/>            'args': (idx,)<br/>            }<br/>        tmp.append(tmp_constr)<br/>    return tmp</span><span id="42fd" class="kn ko hi kj b fi kt kq l kr ks"># Constraints: sum of goods &lt;= factory capacity<br/>def const2():<br/>    tmp = []<br/>    for idx in range(0, cost2d.size, len(I)):<br/>        tmp_constr = {<br/>            'type': 'ineq',<br/>            'fun': lambda x, idx=idx: M[idx//len(I) + 1] - np.sum(x[idx: idx + len(I)])<br/>            }<br/>        tmp.append(tmp_constr)<br/>    return tmp</span><span id="3d8a" class="kn ko hi kj b fi kt kq l kr ks">list_of_lists = [const1(), const2()]<br/>constraints = [item for sublist in list_of_lists for item in sublist]</span></pre><ul class=""><li id="797c" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">纸浆</strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="39e4" class="kn ko hi kj b fi kp kq l kr ks"># Constraint: sum of goods == customer demand<br/>for i in I:<br/>    tmpExpression = pulp.LpAffineExpression(e = [(x[i,j], 1) for j in J if (i,j) in x])<br/>    tmpConstraint = pulp.LpConstraint(e = pulp.lpSum(tmpExpression),<br/>        sense = pulp.LpConstraintEQ,                                <br/>        rhs = d[i])<br/>    model.addConstraint(tmpConstraint)</span><span id="30c8" class="kn ko hi kj b fi kt kq l kr ks"># Constraint: sum of goods &lt;= factory capacityy<br/>for j in J:<br/>    tmpExpression = pulp.LpAffineExpression(e = [(x[i,j], 1) for j in J if (i,j) in x])<br/>    tmpConstraint = pulp.LpConstraint(e = pulp.lpSum(tmpExpression),<br/>        sense = pulp.LpConstraintLE,<br/>        rhs = M[j])<br/>    model.addConstraint(tmpConstraint)</span></pre><ul class=""><li id="f96f" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> Pyomo </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="a027" class="kn ko hi kj b fi kp kq l kr ks"># Constraints: sum of goods == customer demand<br/>def meet_demand(model, customer):<br/>    sum_of_goods_from_factories = sum(model.x[customer,factory] for factory in model.M_fact_capacity)<br/>    customer_demand = model.cust_demand[customer]<br/>    return sum_of_goods_from_factories == customer_demand<br/>model.Constraint1 = pe.Constraint(model.d_cust_demand, rule = meet_demand)</span><span id="50da" class="kn ko hi kj b fi kt kq l kr ks"># Constraints: sum of goods &lt;= factory capacity<br/>def meet_capacity(model, factory):<br/>    sum_of_goods_for_customers = sum(model.x[customer,factory] for customer in model.d_cust_demand)<br/>    factory_capacity = model.fact_capacity[factory]<br/>    return sum_of_goods_for_customers &lt;= factory_capacity<br/>model.Constraint2 = pe.Constraint(model.M_fact_capacity, rule = meet_demand)</span></pre></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="e7e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们实际解决优化问题。为此，读者需要在他/她的机器上安装GLPK求解器。SciPy模块将使用内置的解算器SLSQP。</p><p id="c6cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GLPK可以这样安装:</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="8524" class="kn ko hi kj b fi kp kq l kr ks">$sudo apt-get install glpk-utils</span></pre><ul class=""><li id="4862" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> SciPy </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="ee43" class="kn ko hi kj b fi kp kq l kr ks">from scipy.optimize import minimize</span><span id="1b96" class="kn ko hi kj b fi kt kq l kr ks">solution = minimize(fun = objective,<br/>                x0 = x0,<br/>                bounds = bounds,<br/>                method = 'SLSQP',<br/>                constraints = constraints,<br/>                tol = None,<br/>                callback = None,<br/>                options = {'full_output':False, 'disp':False, 'xtol': 1e-8}<br/>                )</span></pre><ul class=""><li id="3720" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">纸浆</strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="8726" class="kn ko hi kj b fi kp kq l kr ks">solver = pulp.solvers.GLPK_CMD(msg=0)<br/>results = model.solve(solver)</span></pre><ul class=""><li id="c722" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> Pyomo </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="a5ff" class="kn ko hi kj b fi kp kq l kr ks">solver = pe.SolverFactory("glpk")<br/>solution = solver.solve(model)</span></pre></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="d107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们检查结果</p><ul class=""><li id="565d" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> SciPy </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="3967" class="kn ko hi kj b fi kp kq l kr ks">if (solution.success) and (solution.status == 0):<br/>    print("Solution is feasible and optimal")<br/>    print("Objective function value = ", solution.fun)<br/>elif solution.status != 0:<br/>    print("Failed to find solution. Exit code", solution.status)<br/>else:<br/>    # something else is wrong<br/>    print(solution.message)</span><span id="35d2" class="kn ko hi kj b fi kt kq l kr ks">if solution.success:<br/>    EPS = 1.e-6<br/>    for i,_ in enumerate(solution.x):<br/>        if solution.x[i] &gt; EPS:<br/>            print("sending quantity %10s from factory %3s to customer %3s" % (round(solution.x[i]), i%len(J) + 1, i//len(J) + 1))</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ku"><img src="../Images/83d8538b5b99df844086bde29c0fd6e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*beMX6XWWIOi1GMamrAkDfg.png"/></div></figure><ul class=""><li id="6293" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">纸浆</strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="b643" class="kn ko hi kj b fi kp kq l kr ks">if model.status == 1:<br/>    print('Solution is optimal: %s' %pulp.LpStatus[model.status])<br/>else:<br/>    print('Failed to find solution: %s' %pulp.LpStatus[model.status])</span><span id="b322" class="kn ko hi kj b fi kt kq l kr ks">print('Objective function value =', pulp.value(model.objective))</span><span id="eaca" class="kn ko hi kj b fi kt kq l kr ks">EPS = 1.e-6<br/>for (i,j) in x:<br/>    if x[i,j].varValue &gt; EPS:<br/>        print("sending quantity %10s from factory %3s to customer %3s" % (x[i,j].varValue,j,i))</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kv"><img src="../Images/8acbd96d5682f4f4da2f7c6683d70795.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*HMAfdwVfzYqHea_8yixpXA.png"/></div></div></figure><ul class=""><li id="8737" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> Pyomo </strong></li></ul><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="5b93" class="kn ko hi kj b fi kp kq l kr ks">from pyomo.opt import SolverStatus, TerminationCondition</span><span id="c481" class="kn ko hi kj b fi kt kq l kr ks">if (solution.solver.status == SolverStatus.ok) and (solution.solver.termination_condition == TerminationCondition.optimal):<br/>    print("Solution is feasible and optimal")<br/>    print("Objective function value = ", model.objective())<br/>elif solution.solver.termination_condition == TerminationCondition.infeasible:<br/>    print ("Failed to find solution.")<br/>else:<br/>    # something else is wrong<br/>    print(str(solution.solver))</span><span id="c8c7" class="kn ko hi kj b fi kt kq l kr ks">assignments = model.x.get_values().items()<br/>EPS = 1.e-6<br/>for (customer,factory),x in sorted(assignments):<br/>    if x &gt; EPS:<br/>        print("sending quantity %10s from factory %3s to customer %3s" % (x, factory, customer))</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es la"><img src="../Images/a24604c82f03c4bafb43835d8f0ebd06.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*FKClSwrI_Sb_E0VU_Um2Vg.png"/></div></div></figure></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="5059" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们可以看到的，所有三个优化模块都找到了相同的目标函数值3350。然而，在SciPy中使用的SLSQP解算器实现了这一点，其决策变量的值与纸浆和Pyomo使用的GLPK解算器略有不同。</p><p id="74fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里分析的三个优化模块在语法和实现原理上都非常不同。SciPy可能是最受支持的，拥有最多的功能，并且使用简单的python语法。但是，据我所知它不支持二元优化问题。</p><p id="25ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">纸浆和Pyomo有一些相似的语法结构。我有意实现了这两个模块的解决方案，将每个可能的变量或函数完全包装到<strong class="ih hj">纸浆</strong>或<strong class="ih hj"> pyomo </strong>对象中。使用普通python可以实现相同的解决方案。</p><p id="b1a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">纸浆可以说是三个模块中比较容易学习的，但是它只能处理线性优化问题。Pyomo似乎比PuLP更受支持，支持非线性优化问题，最后一点，可以进行多目标优化。</p></div></div>    
</body>
</html>