<html>
<head>
<title>Hierarchical Indexing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分级索引</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/hierarchical-indexing-76dcc6a8dd86?source=collection_archive---------15-----------------------#2020-04-28">https://medium.com/analytics-vidhya/hierarchical-indexing-76dcc6a8dd86?source=collection_archive---------15-----------------------#2020-04-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/88eca14a069f8bf678f937f862b651ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPV4sq1SENezhUm016W0eA.jpeg"/></div></div></figure><p id="be4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上一个教程中，我们了解了高级索引。我们学习了如何使用默认索引将索引列重新分配给数据帧。我们还看到了如何通过用<code class="du jo jp jq jr b">List Comprehensions</code>改变整个索引列来改变或修改索引。你可以在这里刷新你的记忆，或者如果你还没有这样做的话，你可以阅读全部内容。</p><p id="f1ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">说完这些，我们将直接进入今天的主题:层次索引。</p><p id="e6a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们的数据帧有两个以上的维度时，就出现了多索引或层次索引。正如我们已经知道的，Series是一个一维的带标签的NumPy数组，DataFrame通常是一个列是Series的二维表。在某些情况下，为了执行一些复杂的数据分析和操作，我们的数据以更高维度呈现。</p><p id="d229" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多索引至少为数据增加了一个维度。顾名思义，分级索引是根据项目的排名对多个项目进行排序。</p><p id="a1d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用一些数据来看看它是如何工作的。</p><p id="49ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将创建一个数据框架，从Fifa19数据集的一些球员的球员评级。我们将通过比较这些参与者以及分级指数如何帮助我们的事业来阐述我们的观点。</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="dd60" class="kb kc hi jr b fi kd ke l kf kg">In [1]: import pandas as pd<br/>In [2]: data = {'Position': ['GK','GK','GK', 'DF','DF','DF',<br/>            'MF','MF','MF','CF','CF','CF'],   <br/>            'Name': ['De Gea', 'Coutois','Allison','Van Dijk',<br/>            'Ramos','Godin','Hazard','Kante','De Bruyne', 'Ronaldo'<br/>            'Messi','Neymar'],<br/>            'Overall': ['91','88','89','89','91','90','91',<br/>            '90','92','94','93','92'],<br/>            'Rank': ['1st','3rd','2nd','3rd','1st','2nd',<br/>            '2nd','3rd','1st','1st','2nd','3rd']}<br/>In [3]: fifa19 = pd.DataFrame(data, columns=['Position','Name',<br/>                'Overall','Rank'])<br/>In [4]: fifa19<br/>Out[4]: <br/>             Position     Name        Overall     Rank<br/>     0        GK         De Gea          91        1st<br/>     1        GK         Coutios         88        3rd<br/>     2        GK         Allison         89        2nd<br/>     3        DF         Van Dijk        89        3rd<br/>     4        DF         Ramos           91        1st<br/>     5        DF         Godin           90        2nd<br/>     6        MF         Hazard          91        2nd<br/>     7        MF         Kante           90        3rd<br/>     8        MF         De Bruyne       92        1st<br/>     9        CF         Ronaldo         94        1st<br/>     10       CF         Messi           93        2nd<br/>     11       CF         Neymar          92        3rd</span></pre><p id="b2c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从我们的数据框架中，我们注意到该索引是默认的Pandas索引；列“位置”和“等级”都有重复的值或对象。当我们想要分析数据时，这有时会给我们带来问题。我们想要做的是使用有意义的索引来惟一地标识每一行，并使我们更容易理解我们正在处理的数据。</p><p id="6027" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是多索引或层次索引的用武之地。我们将把我们的索引从默认索引重新分配到一个更细微的索引，以捕捉我们分析的本质。</p><p id="07f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们通过使用<code class="du jo jp jq jr b">set_index()</code>方法来做到这一点。对于层次索引，我们传递一个列表来表示我们希望如何惟一地标识行。</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="01b7" class="kb kc hi jr b fi kd ke l kf kg">In [5]: fif19.set_index(['Position','Rank'], drop=False)<br/>In [6]: fifa19<br/>Out[6]:            Position     Name        Overall     Rank<br/> Position  Rank<br/>    GK     1st        GK         De Gea          91        1st<br/>    GK     3rd        GK         Coutios         88        3rd<br/>    GK     2nd        GK         Allison         89        2nd<br/>    DF     3rd        DF         Van Dijk        89        3rd<br/>    DF     1st        DF         Ramos           91        1st<br/>    DF     2nd        DF         Godin           90        2nd<br/>    MF     2nd        MF         Hazard          91        2nd<br/>    MF     3rd        MF         Kante           90        3rd<br/>    MF     1st        MF         De Bruyne       92        1st<br/>    CF     1st        CF         Ronaldo         94        1st<br/>    CF     2nd        CF         Messi           93        2nd<br/>    CF     3rd        CF         Neymar          92        3rd</span></pre><p id="c731" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上面的代码中我们可以看到，我们已经将新的索引设置为“Position”和“Rank ”,但是这些列有一个副本。这是因为我们通过了<code class="du jo jp jq jr b">drop=False</code>，它将列保持在原来的位置。然而，默认的方法是<code class="du jo jp jq jr b">drop=True</code>，所以如果没有指定<code class="du jo jp jq jr b">drop=False</code>，这两列将被设置为索引，并且自动删除这两列。</p><p id="29a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="b959" class="kb kc hi jr b fi kd ke l kf kg">In [7]: fifa19.set_index(['Position','Rank'])<br/>Out[7]:              Name        Overall    <br/> Position  Rank<br/>    GK     1st       De Gea          91       <br/>    GK     3rd       Coutios         88        <br/>    GK     2nd       Allison         89       <br/>    DF     3rd       Van Dijk        89        <br/>    DF     1st       Ramos           91      <br/>    DF     2nd       Godin           90     <br/>    MF     2nd       Hazard          91     <br/>    MF     3rd       Kante           90      <br/>    MF     1st       De Bruyne       92       <br/>    CF     1st       Ronaldo         94      <br/>    CF     2nd       Messi           93    <br/>    CF     3rd       Neymar          92    </span></pre><p id="ff8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用带有列标签有序列表的<code class="du jo jp jq jr b">set_index()</code>来创建新的索引。</p><p id="5b41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了验证我们确实已经将数据帧设置为分层索引，我们调用了<code class="du jo jp jq jr b">.index</code>属性</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="1a83" class="kb kc hi jr b fi kd ke l kf kg">In [8]: fifa19=fifa19.set_index(['Position','Rank'])<br/>In [9]: fifa19.index<br/>Out[9]: MultiIndex(levels=[['CF', 'DF', 'GK', 'MF'],<br/>                          ['1st', '2nd',   '3rd']],<br/>                   codes= [[2, 2, 2, 1, 1, 1, 3, 3, 3, 0, 0, 0],<br/>                          [0, 2, 1, 2,0,1, 1, 2, 0, 0, 1, 2]],<br/>                   names= ['Position', 'Rank'])</span></pre><p id="5514" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多指数将位置作为第一级，这意味着我们的数据被分为中锋、后卫、守门员和中场。然后是排名。这意味着，对于每一个指定的位置，球员被排在第一，第二或第三。</p><p id="9299" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这看起来很容易，并且稍微减轻了分析的任务。以这种方式保存索引可以减少大量的工作，但是有一个小问题。排名不是以有序的方式进行的。更有价值的是，将球员从最好到最差排列在他们的位置上。</p><p id="4007" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以用<code class="du jo jp jq jr b">sort_index()</code>方法来解决这个问题。</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="c93d" class="kb kc hi jr b fi kd ke l kf kg">In [10]: fifa19.sort_index()<br/>Out[10]:              Name     Overall<br/>    Position  Rank  <br/>     CF       1st    Ronaldo     94<br/>              2nd    Messi       93<br/>              3rd    Neymar      92<br/>     DF       1st    Ramos       91<br/>              2nd    Godin       90<br/>              3rd    Van Dijk    89<br/>     GK       1st    De Gea      91<br/>              2nd    Coutois     89<br/>              3rd    Allison     88<br/>     MF       1st    De Bruyne   92<br/>              2nd    Hazard      91<br/>              3rd    Kante       90</span></pre><p id="cc7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这看起来很棒。我们以分层的方式对数据进行了分类。根据FIFA19的数据，我们可以知道c罗是最佳前锋，而拉莫斯、德基和德布鲁因等人占据了其他位置。当真正的分析开始时，让我们的数据框架保持这种格式可以让我们更容易着陆。</p><p id="5a79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你发现这个教程信息丰富。接下来，我们将看看如何从多索引数据帧中切片和提取数据。</p><p id="8a5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在那之前，编码快乐！</p></div></div>    
</body>
</html>