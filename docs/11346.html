<html>
<head>
<title>What is an unsigned integer ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是无符号整数？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/what-is-an-unsigned-integer-fc5e5c9247e5?source=collection_archive---------11-----------------------#2020-11-30">https://medium.com/analytics-vidhya/what-is-an-unsigned-integer-fc5e5c9247e5?source=collection_archive---------11-----------------------#2020-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="62f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数学中的整数，是属于集合<code class="du jd je jf jg b">Z</code>的任何数。集合<code class="du jd je jf jg b">Z</code>，包含正整数如:<code class="du jd je jf jg b">1</code>，负整数如:<code class="du jd je jf jg b">-1</code>，数字:<code class="du jd je jf jg b">0</code>。</p><p id="4307" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问什么是<code class="du jd je jf jg b">signed</code>或者<code class="du jd je jf jg b">unsigned</code>整数，实际上是问，在计算机中如何表示<code class="du jd je jf jg b">-1</code>、<code class="du jd je jf jg b">0</code>、<code class="du jd je jf jg b">1</code>等整数。</p><p id="07ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在计算机中表示数字是在有限数量的位上完成的，例如<code class="du jd je jf jg b">8</code>位或<code class="du jd je jf jg b">16</code>位。</p><p id="b2a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这第一部分，我们将描述什么是一个<code class="du jd je jf jg b">unsigned</code>整数，在第二部分，我们将描述什么是一个<code class="du jd je jf jg b">signed</code>整数。</p><h1 id="6f16" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">无符号整数</h1><p id="a4e0" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">也就是说，我们可以首先选择对非负数进行编码，比如正整数，如<code class="du jd je jf jg b">1</code>或<code class="du jd je jf jg b">2</code>等。，以及编号<code class="du jd je jf jg b"> 0</code>。</p><p id="59c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为计算机存储器是有限的，所以计算机中的编码可以仅使用有限数量的比特来执行。</p><p id="e99f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，一旦选择了编码非负整数值的位数，就只能表示有限的一组非负整数。这个有限的非负整数集合及其编码称为无符号整数集合。一个无符号整数，有一个非负的整数值，并且它有一个编码。</p><p id="9937" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算机中的编码包括使用仅由<code class="du jd je jf jg b">0</code>和<code class="du jd je jf jg b">1</code>组成的位串(如<code class="du jd je jf jg b">10101</code>)来表示数据，称为二进制表示。二进制如所用的数字，仅由两个值<code class="du jd je jf jg b">0</code>或<code class="du jd je jf jg b">1</code>组成。</p><p id="423e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在无符号编码中，非负整数使用二进制位置数字系统进行编码。在二进制位置数字系统中，例如，<code class="du jd je jf jg b">0101</code>在十进制位置数字系统中具有值<code class="du jd je jf jg b">5</code>。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/408e6cc74ccff5214e55a748cad4e740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5qaEIodz_VHtC2Wm.jpg"/></div></figure><p id="2ed7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在高级编程语言中，无符号整数使用某种数据类型来表示，例如在<code class="du jd je jf jg b">c</code>或<code class="du jd je jf jg b">c++</code>中，无符号整数使用以下数据类型来表示:</p><pre class="kl km kn ko fd ks jg kt ku aw kv bi"><span id="12f2" class="kw ji hi jg b fi kx ky l kz la">unsigned char <br/># typically 8 bits .<br/># at least 8 bits .</span><span id="4a05" class="kw ji hi jg b fi lb ky l kz la">unsigned short <br/># typically 16 bits .<br/># at least 16 bits .</span><span id="fd1b" class="kw ji hi jg b fi lb ky l kz la">unsigned int <br/># typically 32 bits .<br/># at least 16 bits .</span><span id="0231" class="kw ji hi jg b fi lb ky l kz la">unsigned long <br/># typically 64 bits<br/># at least 32 bits .</span><span id="3749" class="kw ji hi jg b fi lb ky l kz la">unsigned long long <br/># typically 64 bits<br/># at least 64 bits .</span></pre><p id="cb3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择了一些位，以及如何在计算机中对非负整数进行编码，我们最终得到一个无符号整数集，由有限数量的非负整数及其编码组成，因此要问的问题是，可以对这个集执行什么操作。</p><p id="7fd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于以下所有部分，假设编码仅使用<code class="du jd je jf jg b">2</code>位执行，因此无符号整数集为:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/3695425c2bcb92328b2d542d8fd6b88b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Jqcnbhhza8DMbWJD.jpeg"/></div></figure><h1 id="f1aa" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">无符号整数加法</h1><p id="5bd1" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">加法是使用二进制位置数字系统执行的，因此它的工作方式类似于常规加法，带有进位等等。</p><p id="5e96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当使用无符号整数执行加法时，面临的一个问题是，用于编码的位数有限。这可能会导致溢出，即结果太大而无法使用所选的编码来表示。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/a9e3fb0c97894d7b59d0e27ae469e5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*22NRaGPkPK97F0dp.jpeg"/></div></figure><p id="6af5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当无符号加法的结果太大而不能用所选位数表示时，多余的位被丢弃，因此得到的位数被截断以适合所选位数。这与以下内容相同:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es kk"><img src="../Images/2a5f83645643558f90eecde728f0e686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9nnJcUp_6f8eDMIy.jpeg"/></div></div></figure><p id="de55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，当选择用于编码的位数只有<code class="du jd je jf jg b">2</code>时，执行无符号整数加法的结果是:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/5baa6600daae519fcf8376d7ca4f23c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hgt2b57lhOd7myN5.jpeg"/></div></figure><p id="c686" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要检测无符号整数加法是否发生溢出，只需检查无符号加法的结果是否小于其两个操作数中的任何一个。</p><pre class="kl km kn ko fd ks jg kt ku aw kv bi"><span id="a29e" class="kw ji hi jg b fi kx ky l kz la">int unsignedAdditionOverflow( unsigned int x , unsigned int y ){<br/>  /* Check if unsigned int addition overflow ,<br/>    will occur , return 1 , if it does , 0 <br/>    otherwise .*/ <br/>  return ( x + y )  &lt; x;}// end unsignedAdditionOverflow</span></pre><h1 id="733c" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">无符号整数乘法</h1><p id="7d88" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">无符号整数乘法的工作方式类似于常规乘法，因为它是使用基数<code class="du jd je jf jg b">2</code>来执行的。</p><p id="46b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无符号乘法面临的问题是由使用的有限位数引起的，这导致溢出。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/2972d7fbda838113be316de15389a4b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MN8xS7qoDO_wme3u.jpeg"/></div></figure><p id="e88d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于无符号整数乘法，当溢出发生时，超出的位被丢弃，结果被截断为选定的位数。这与以下内容相同:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/1ed5af5486338a01eea67b6b788d916e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*73yy4gRJOh0JMGbq.jpeg"/></div></figure><p id="8989" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，当使用两位执行编码时，无符号乘法的表是:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/b57173a08ef9dfe1de43c5aeba067ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wD9H2vnn7P32wvOq.jpeg"/></div></figure><p id="b77a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要检测<code class="du jd je jf jg b">C</code>中的无符号乘法溢出，可以使用这个方法，或者它的一个派生方法。</p><pre class="kl km kn ko fd ks jg kt ku aw kv bi"><span id="8089" class="kw ji hi jg b fi kx ky l kz la">#include&lt;limits.h&gt;<br/>/* The limits.h header contains the<br/>   min and  max values , that integer<br/>   types in C , can have on a certain<br/>   machine . */</span><span id="76bf" class="kw ji hi jg b fi lb ky l kz la">int unsignedMultiplicationOverflow( unsigned char x , unsigned char y ){<br/>  //Check for unsigned char multiplication overflow <br/>  if( x == 0 || y == 0 )<br/>    return 0; //no unsigned char multiplication overflow<br/>  if( x == 1 || y == 1 )<br/>    return 0; // no unsigned char multiplication overflow<br/>  unsigned char z = UCHAR_MAX / x ;<br/>  /* Perform unsigned division ,<br/>     For example , x = 20 , UCHAR_MAX = 255<br/>       z = 12 .<br/>     z is the greatest number such that :<br/>       z * x &lt;= UCHAR_MAX */<br/>  if( y &gt; z )<br/>    return 1;//unsigned char multiplication overflow<br/>  else<br/>    return 0; /*no unsigned char multiplication overflow*/}//end unsignedMultiplicationOverflow</span></pre><h1 id="651d" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">无符号整数除法</h1><p id="8ab3" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">无符号整数除法的工作原理与常规整数除法相同，因为除法是使用基数<code class="du jd je jf jg b">2</code>来执行的。它只返回商，没有任何余数或小数部分。</p><p id="4a42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行无符号整数除法时不会发生溢出，被<code class="du jd je jf jg b">0</code>除的结果是未定义的。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/f5607f583b2c9dea24c180994152ac0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*243qTK58upbemgOQ.jpeg"/></div></figure><h1 id="06bc" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">无符号整数减法</h1><p id="e394" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">从较小的无符号值中减去较大的无符号值时，结果是正确的，但从较大的无符号值中减去较小的无符号值时，结果是负的。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/35c19fddd18869e7112dc7b58b2c069c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oNOf5u_Y-7wv5xcK.jpeg"/></div></figure><p id="94d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当两个无符号整数相减产生负值时，计算结果的公式如下:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/6bf9cd6fdf6e8df3013023d330f03930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4BzhEyR6q_LIPsu6.jpeg"/></div></figure><p id="eccd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，下表详细说明了使用2位的无符号减法:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kk"><img src="../Images/0312bc144e4a98e258cfbf104d711353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6SGfF7yrOTXgheUz.jpeg"/></div></figure><p id="a919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要检查两个无符号整数相减是否会产生取模结果，可以按如下方式进行:</p><pre class="kl km kn ko fd ks jg kt ku aw kv bi"><span id="2f54" class="kw ji hi jg b fi kx ky l kz la">int unsignedSubstractionModulo( unsigned char x , unsigned char y ){<br/>  // Check if y - x cause modulo result . <br/>  if( x &lt;= y )<br/>    return 0; // no unsigned char substraction modulo result<br/>  else<br/>    return 1;/* unsigned char substraction modulo result */}// end unsignedSubstractionModulo</span></pre><h1 id="c341" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">交换性、结合性和分配性</h1><pre class="kl km kn ko fd ks jg kt ku aw kv bi"><span id="6c53" class="kw ji hi jg b fi kx ky l kz la">unsigned addition <br/>    commutative : a + b = b + a <br/>    associative : a + ( b + c ) = ( a + b ) + c</span><span id="40d8" class="kw ji hi jg b fi lb ky l kz la">unsigned Multiplication<br/>    commutative : a * b = b * a <br/>    associative : a * ( b * c ) = ( a * b ) * c <br/>    distributive over addition and substraction <br/>                  a * ( b + c ) = ( a * b ) + ( a * c )<br/>                  a * ( b - c ) = ( a * b ) - ( a * c )</span><span id="7970" class="kw ji hi jg b fi lb ky l kz la">unsigned Division<br/>    not commutative  : ( 1 / 2 ) != ( 2 / 1 )<br/>    not associative  : ( 1 / 2 ) / 3 != 1 / ( 2 / 3 ) <br/>                  because     0      !=   undefined</span><span id="4d20" class="kw ji hi jg b fi lb ky l kz la">unsigned Subtraction<br/>    not commutative : 1 - 2 != 2 - 1  <br/>    not associative : ( 1 - 2 ) - 1 != 1 - ( 2 - 1 )</span></pre></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><p id="7320" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ln">原载于2020年11月30日</em><a class="ae lo" href="https://twiserandom.com/data-structure-and-algorithms/what-is-an-unsigned-integer/" rel="noopener ugc nofollow" target="_blank"><em class="ln">【https://twiserandom.com】</em></a><em class="ln">。</em></p></div></div>    
</body>
</html>