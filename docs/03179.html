<html>
<head>
<title>Persistent data structures thanks to recursive type aliases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">得益于递归类型别名的持久数据结构</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/persistent-data-structures-thanks-to-recursive-type-aliases-cf576643380f?source=collection_archive---------14-----------------------#2020-01-19">https://medium.com/analytics-vidhya/persistent-data-structures-thanks-to-recursive-type-aliases-cf576643380f?source=collection_archive---------14-----------------------#2020-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="de40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">也发表于</em><a class="ae je" href="https://www.aleksandra.codes/type-inference" rel="noopener ugc nofollow" target="_blank"><em class="jd"/></a>。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es jf"><img src="../Images/7c5cef09d29201f544d8e74538794152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*2cJLhWnLoMvBhkTd.jpg"/></div></figure><p id="64fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">众所周知，易变性是邪恶的，而且常常是麻烦的。但是，在某些情况下，可变数据结构实现起来更简单，性能也更好，这也是事实。有时候，你可以顺其自然，完全没问题，但其他时候不变性是必需的。现在让我们把重点放在数组上。如果你想以一种不可变的方式将一个项目追加或前置到列表中，你会怎么做？浅抄？深度复制(天理不容)？这些操作是昂贵的。它们有更大的渐近时间复杂度——O(n)，而我们想要的是O(1)。在本文中，我将展示一个简单的数据结构来实现这一点。</p><p id="53e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我现在引起你的注意了吗？所以，我们开始吧！</p><h1 id="8cbe" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">持久与不可变的数据结构🔎</h1><p id="f3f9" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">首先，我需要坦白。在相当长的一段时间里，我认为持久结构就是不可变的结构。相当蹩脚。然后我了解到，当数据结构被修改时，如果它保留了以前的版本，那么它就是持久的。好像它永远不会忘记自己是谁。事实上，它们实际上是不可变的，但是反过来就不行了。不可变的数据结构不一定是持久的。</p><p id="c4d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里阅读更多相关信息<a class="ae je" href="https://en.wikipedia.org/wiki/Persistent_data_structure" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="927d" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">满足缺点列表</h1><p id="432a" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">这就是了。演出的明星👏</p><p id="2487" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们关注一下<em class="jd">缺点</em>是什么意思。所以…这是一个函数。更重要的是，这是许多编程语言的基本功能。尤其是在Lisp方言中。它接受两个对象或指向对象x和y的指针，以及保存x和y的内存中的cons对象。你可能以前见过这个:</p><ul class=""><li id="078c" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated"><strong class="ih hj"> 1::[2] </strong> : ML，Scala，F#和Elm</li><li id="0753" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated"><strong class="ih hj"> 1:[2] </strong>:哈斯克尔</li><li id="c665" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated"><strong class="ih hj"> (cons 1 2) </strong> : Lisp及其方言</li></ul><p id="a979" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是列表数据结构的<strong class="ih hj"> cons </strong> tructors。<em class="jd">弊单</em>也叫<em class="jd">链表</em>，我猜这是一个更容易辨认的名字。</p><p id="8f0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用下面的方式将<em class="jd">缺点列表</em>可视化:</p><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="07a2" class="lj jo hi lf b fi lk ll l lm ln">┌────────────┐     ┌────────────┐     ┌────────────┐<br/>│  1  | tail │   ┌─│  2  | tail │   ┌─│  3  | null │<br/>└────────│───┘   │ └────────│───┘   │ └────────────┘<br/>         └───────┘          └───────┘<br/>a linked list of (1, 2, 3)</span></pre><h1 id="67d9" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">是如何坚持下来的？</h1><p id="00a8" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">有几个词是关于持久数据结构的，所以你可能想知道cons list是否是持久的。是的，它是！让我们看看怎么做。</p><p id="a8a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个cons列表— <strong class="ih hj"> xs </strong>，我们想在其中加入一个元素。它产生了一个全新的列表<strong class="ih hj"> ys </strong>，你可以注意到来自<strong class="ih hj"> xs </strong>的物品现在在<strong class="ih hj"> xs </strong>和<strong class="ih hj"> ys </strong>之间共享。因此列表<strong class="ih hj"> xs </strong>没有被修改，它是新列表<strong class="ih hj"> ys </strong>的一部分。</p><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="fd35" class="lj jo hi lf b fi lk ll l lm ln">xs                           ys<br/>┌──│──┐                      ┌──│──┐<br/>│  3  │                      │  4  │<br/>└──│──┘                      └──│──┘<br/>┌──│──┐                     xs  │<br/>│  2  │    cons 4 xs →       └─┌┘<br/>└──│──┘                     ┌──│──┐<br/>┌──│──┐                     │  3  │<br/>│  1  │                     └──│──┘<br/>└─────┘                     ┌──│──┐<br/>                            │  2  │<br/>                            └──│──┘<br/>                            ┌──│──┐<br/>                            │  1  │<br/>                            └─────┘</span></pre><h1 id="34e7" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">它在TypeScript 3.7中的样子</h1><p id="232b" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">我可以用下面的方式编写cons列表的类型，由于TypeScript 3.7中引入的递归类型别名，它可以完美地工作。</p><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="4fe0" class="lj jo hi lf b fi lk ll l lm ln">export type ConsList&lt;T&gt; = null | readonly [T, ConsList&lt;T&gt;];</span></pre><p id="bbaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在3.7之前，我会得到以下错误:</p><blockquote class="lo lp lq"><p id="f614" class="if ig jd ih b ii ij ik il im in io ip lr ir is it ls iv iw ix lt iz ja jb jc hb bi translated"><em class="hi">类型别名“ConsList”循环引用自身。ts(2456 </em></p></blockquote><p id="e7ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">长话短说，类型别名需要被急切地构建，所以你不能在右边有和左边一样的东西，因为编译器会试图用后者替换前者，然后用前者替换后者，等等…你可以在<a class="ae je" href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-7-rc/#more-recursive-type-aliases" rel="noopener ugc nofollow" target="_blank"> TypeScript 3.7公告</a>上读到更多关于它的内容。</p><h1 id="8800" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">在ConsList上操作的函数</h1><p id="8ef1" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">好了，我们已经对什么是<em class="jd">缺点列表</em>有了一些了解。现在是时候看看我们能用它做什么以及如何让它变得有用了。缺点列表可能会成为数组不可变的替代品。这意味着我们可以期待它的一些功能。再补充一些吧！</p><ul class=""><li id="bcaa" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">将元素添加到列表中</li></ul><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="aa77" class="lj jo hi lf b fi lk ll l lm ln">function cons&lt;T&gt;(h: T, t: ConsList&lt;T&gt;): ConsList&lt;T&gt; {<br/>  return [h, t];<br/>}</span></pre><ul class=""><li id="cd81" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">从列表中提取头尾</li></ul><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="1acd" class="lj jo hi lf b fi lk ll l lm ln">function head&lt;T&gt;(xs: ConsList&lt;T&gt;): T {<br/>  if (!xs) {<br/>    throw new Error("can't take head of empty ConsList");<br/>  }<br/>  return xs[0];<br/>}</span><span id="9ec5" class="lj jo hi lf b fi lu ll l lm ln">function tail&lt;T&gt;(xs: ConsList&lt;T&gt;): ConsList&lt;T&gt; {<br/>  if (!xs) {<br/>    throw new Error("can't take tail of empty ConsList");<br/>  }<br/>  return xs[1];<br/>}</span></pre><ul class=""><li id="aed7" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">在上面画地图。</li></ul><blockquote class="lo lp lq"><p id="b220" class="if ig jd ih b ii ij ik il im in io ip lr ir is it ls iv iw ix lt iz ja jb jc hb bi translated"><em class="hi">注:</em>弊单<em class="hi">带</em>图<em class="hi">不再持久。这是不可改变的。为了使它持久，我们需要记住以前的版本。我现在跳过它。</em></p></blockquote><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="ae55" class="lj jo hi lf b fi lk ll l lm ln">function map&lt;A, B&gt;(xs: ConsList&lt;A&gt;, f: (a: A) =&gt; B): ConsList&lt;B&gt; {<br/>  let res: ConsList&lt;B&gt; = null;<br/>  while (xs) {<br/>    const [head, tail] = xs;<br/>    res = [f(head), res];<br/>    xs = tail;<br/>  }<br/>  return reverse(res);<br/>}</span></pre><ul class=""><li id="5a3e" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">减少它</li></ul><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="a43c" class="lj jo hi lf b fi lk ll l lm ln">function reduce&lt;T, R = T&gt;(<br/>  xs: ConsList&lt;T&gt;,<br/>  reducer: (acc: R, val: T) =&gt; R,<br/>  initialValue: R<br/>): R {<br/>  while (xs) {<br/>    const [head, tail] = xs;<br/>    initialValue = reducer(initialValue, head);<br/>    xs = tail;<br/>  }<br/>  return initialValue;<br/>}</span></pre><ul class=""><li id="b832" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">从数组构造一个新的<em class="jd">缺点列表</em>，反之亦然</li></ul><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="53aa" class="lj jo hi lf b fi lk ll l lm ln">const of = &lt;T&gt;(...xs: T[]): ConsList&lt;T&gt; =&gt; {<br/>  let res: ConsList&lt;T&gt; = null;<br/>  for (let i = xs.length - 1; i &gt;= 0; --i) {<br/>    res = cons(xs[i], res);<br/>  }<br/>  return res;<br/>};</span><span id="a735" class="lj jo hi lf b fi lu ll l lm ln">function toArray&lt;T&gt;(xs: ConsList&lt;T&gt;) {<br/>  return reduce&lt;T, T[]&gt;(<br/>    xs,<br/>    (a, v) =&gt; {<br/>      a.push(v);<br/>      return a;<br/>    },<br/>    []<br/>  );<br/>}</span></pre><ul class=""><li id="586c" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">逆转它</li></ul><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="ba1e" class="lj jo hi lf b fi lk ll l lm ln">function reverse&lt;T&gt;(xs: ConsList&lt;T&gt;): ConsList&lt;T&gt; {<br/>  return reduce(xs, (acc, v) =&gt; cons(v, acc), null as ConsList&lt;T&gt;);<br/>}</span></pre><ul class=""><li id="6efd" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">串联两个<em class="jd">缺点列表</em></li></ul><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="e9ea" class="lj jo hi lf b fi lk ll l lm ln">function concat&lt;T&gt;(xs: ConsList&lt;T&gt;, ys: ConsList&lt;T&gt;): ConsList&lt;T&gt; {<br/>  return xs ? cons(head(xs), concat(tail(xs), ys)) : ys;<br/>}</span></pre><p id="f571" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，一切顺利。我现在停下来。它已经很强大了💪</p><h1 id="4588" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">🛠的真实使用案例</h1><p id="1f37" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">你可能已经注意到了，<em class="jd">缺点列表</em>让我们可以快速访问列表的第一个元素。这意味着我们可以预先考虑列表，并以极快的速度从列表中取出第一个元素。事实上，堆栈(或<em class="jd">后进先出队列</em>)就是基于这两种操作的数据结构。压入栈只是在做<em class="jd">弊列表</em>上的<em class="jd">弊</em>，pop是提取头。在常见的堆栈命名法中，应该是这样的:</p><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="9d58" class="lj jo hi lf b fi lk ll l lm ln">const push = cons;<br/>const pop = tail;<br/>const peek = head;</span></pre><p id="b6d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太好了！我们毫不费力地完成了堆叠。没有任何修改也没有任何新代码。这个很简单，现在是做更复杂的事情的时候了。先进先出队列。当我们从前面获取元素并推到最后时的结构。因此，我们需要快速访问列表的第一个和最后一个元素。突变和指针非常简单。我们只需要为第一项和最后一项维护两个指针。但是我们没有突变。取而代之的是我们的<em class="jd">缺点清单</em>！</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/9acc2f260a4e5b1c143852fedadf0743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iHLYGXfhsfdM9GwY.png"/></div></div></figure><p id="fbed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一个聪明的家伙叫Chris Okasaki，他想出了一个聪明的方法来实现一个有效的、不可变的FIFO quque，使用一对两个<em class="jd">缺点列表</em> <strong class="ih hj">(前，后)</strong>。他们分别代表队列的前面和后面。但是<strong class="ih hj">后面的</strong>是反过来的，所以这个链表的头是队列的最后一个元素。</p><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="4e39" class="lj jo hi lf b fi lk ll l lm ln">type Queue&lt;T&gt; = {<br/>  front: ConsList&lt;T&gt;;<br/>  back: ConsList&lt;T&gt;;<br/>};</span></pre><p id="796e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该结构的要点:</p><ul class=""><li id="e6bd" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">当我们想要将一个项目推入队列时，我们需要将它前置到<strong class="ih hj">后面</strong></li><li id="c38a" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">当我们想要弹出一个项目时，我们需要从<strong class="ih hj">前端</strong>提取头部</li></ul><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/7959bb05c335bcdea5f6bf0924664020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qCZBhPKc1CQLaHYP.png"/></div></div></figure><p id="5ba6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们不断地将元素放入队列时，它们都将进入后面的列表。假设我们从1到5按下了一个又一个数字。这意味着我们的结构看起来会像这样:</p><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="6b2f" class="lj jo hi lf b fi lk ll l lm ln">{ front: null, back: [5, [4, [3, [2, [1, null]]]]]}</span></pre><p id="53b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前面的列表是空的。那么，我们如何从中提取一个元素呢？那是最好的部分。我们轮流值班。这意味着我们将<strong class="ih hj">返回</strong>列表，反转它，将其附加为新的前端，并使<strong class="ih hj">返回</strong>为空。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/17107d3cd2c24a92de17cfad0d160cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jKN38A7KwdjdT-8N.png"/></div></div></figure><p id="d242" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是整个实现:</p><pre class="jg jh ji jj fd le lf lg lh aw li bi"><span id="9e0a" class="lj jo hi lf b fi lk ll l lm ln">const empty = &lt;T&gt;(): Queue&lt;T&gt; =&gt; ({<br/>  front: null,<br/>  back: null,<br/>});</span><span id="1de0" class="lj jo hi lf b fi lu ll l lm ln">const isEmpty = (queue: Queue&lt;unknown&gt;) =&gt; (queue.front || queue.back) === null;</span><span id="0b57" class="lj jo hi lf b fi lu ll l lm ln">const enqueue = &lt;T&gt;(x: T, { front, back }: Queue&lt;T&gt;) =&gt; ({<br/>  front,<br/>  back: ConsList.cons(x, back),<br/>});</span><span id="a91d" class="lj jo hi lf b fi lu ll l lm ln">const dequeue = &lt;T&gt;(queue: Queue&lt;T&gt;): [T | null, Queue&lt;T&gt;] =&gt; {<br/>  const { front, back } = queue;<br/>  if (front) {<br/>    const [value, newFront] = front;<br/>    return [value, { back, front: newFront }];<br/>  }</span><span id="8b06" class="lj jo hi lf b fi lu ll l lm ln">  if (back) {<br/>    return dequeue({<br/>      back: null,<br/>      front: ConsList.reverse(back),<br/>    });<br/>  }</span><span id="f321" class="lj jo hi lf b fi lu ll l lm ln">  return [null, queue];<br/>};</span></pre><h2 id="e1a7" class="lj jo hi bd jp ma mb mc jt md me mf jx iq mg mh kb iu mi mj kf iy mk ml kj mm bi translated">何时不使用缺点列表</h2><ul class=""><li id="8489" class="kq kr hi ih b ii kl im km iq mn iu mo iy mp jc kv kw kx ky bi translated">它不是Array的替代品。</li><li id="6bb5" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">它不是一个随机访问列表(因此我甚至没有实现它)，所以如果你想快速随机访问，那么最好使用数组。</li></ul><h1 id="c50d" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">⌛️基准</h1><p id="b1f2" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">你可能想知道使用<em class="jd">缺点列表</em>是否有所回报。事实上，确实如此！我做了一些基准测试来比较Array和<em class="jd"> cons list </em>上的操作，结果令人激动！下面是基准测试的要点。</p><p id="230b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基准测试非常简单，这里的数字来自于在固定大小的10000个数字的输入上运行它们。</p><h1 id="f862" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">可变操作与缺点</h1><p id="4326" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">a . un shift(50)<em class="jd">99953.939 ops/s</em></p><p id="d8c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a .推(50) <em class="jd"> 70675.276 ops/s </em></p><p id="76e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">cons(50，l) <em class="jd"> 5822999.798 ops/s </em></p><h1 id="fbeb" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">不可变操作与缺点</h1><p id="f19e" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">12680.588 ops/s </p><p id="392d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[…a，50] <em class="jd"> 38113.025 ops/s </em></p><p id="a209" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">cons(50，l) <em class="jd"> 5485947.933 ops/s </em></p><h1 id="e793" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Array.prototype.map vs map</h1><p id="fc50" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">array.map(x =&gt; x * 2) 4389.837操作/秒</p><p id="3f40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">map(列表，x =&gt; x * 2) 662.805操作/秒</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="e93c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望上述基准能够说明问题。</p><h1 id="7921" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">资源📚</h1><p id="c282" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated"><a class="ae je" href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-7-rc/#more-recursive-type-aliases" rel="noopener ugc nofollow" target="_blank">变更日志</a></p><p id="4ca6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://www.aleksandra.codes/(https://en.wikipedia.org/wiki/Persistent_data_structure)" rel="noopener ugc nofollow" target="_blank">持久数据结构</a></p><p id="c6f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://en.wikipedia.org/wiki/Cons" rel="noopener ugc nofollow" target="_blank">缺点</a></p></div></div>    
</body>
</html>