<html>
<head>
<title>#SuperNaive: K-medoids clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">#超级:K-medoids聚类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/supernaive-k-medoids-clustering-31db7bfc5075?source=collection_archive---------5-----------------------#2019-12-14">https://medium.com/analytics-vidhya/supernaive-k-medoids-clustering-31db7bfc5075?source=collection_archive---------5-----------------------#2019-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0b8d" class="pw-subtitle-paragraph ig hh hi bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dx translated">强力实现</h2></div><h1 id="1bc5" class="iy iz hi bd ja jb jc jd je jf jg jh ji ip jj iq jk is jl it jm iv jn iw jo jp bi translated">一、导言</h1><p id="adce" class="pw-post-body-paragraph jq jr hi js b jt ju ik jv jw jx in jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="js hj"> <em class="km">聚类</em> </strong>是<em class="km">数据科学</em>等AI/ML领域的核心关注点之一。许多<em class="km">聚类算法</em>是用不同的方法和目的发明出来的。在我看来<em class="km">，基于质心的聚类</em>是<em class="km">数据科学新手</em>最容易掌握的。</p><p id="09fe" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj"><em class="km">K-表示</em> </strong>是其中最受欢迎的。在谷歌上搜索这个词，不到一秒钟你就能找到超过10亿个结果。然而，<strong class="js hj"> <em class="km"> K-medoids </em> </strong>，一个让人联想到<strong class="js hj"> <em class="km">的K-means </em> </strong>，并没有与其“<em class="km">老大哥”</em>一样的吸引力。</p><p id="c1d4" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在本文中，我将谈谈我对该算法的理解，并展示一个用Python 3实现的<em class="km"># superniave</em>。</p><p id="d7ae" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">热烈欢迎每一个建议和批评。</p><h1 id="eded" class="iy iz hi bd ja jb jc jd je jf jg jh ji ip jj iq jk is jl it jm iv jn iw jo jp bi translated">II — K-MEDOIDS聚类</h1><p id="4d57" class="pw-post-body-paragraph jq jr hi js b jt ju ik jv jw jx in jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="js hj"> 1。什么是水母？</strong></p><p id="22b0" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">根据维基百科:</p><blockquote class="ks kt ku"><p id="200a" class="jq jr km js b jt kn ik jv jw ko in jy kv kp kb kc kw kq kf kg kx kr kj kk kl hb bi translated"><strong class="js hj"> Medoids </strong>是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Data_set" rel="noopener ugc nofollow" target="_blank">数据集</a>或一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Cluster_analysis" rel="noopener ugc nofollow" target="_blank">聚类</a>的代表对象，其数据集与该聚类中所有对象的平均相异度最小。</p></blockquote><p id="9a66" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">换句话说，成为medoid有两个条件:</p><p id="3e1b" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">(1)数据集的成员(数据点/对象)</p><p id="495f" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">(2)从它到数据集中所有其他数据点的距离总和(简称“平均相异度”)是最小的</p><p id="abc3" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">条件(1)标志着<em class="km"> K-means </em>和<em class="km"> K-medoids </em>之间的最大差异。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es kz"><img src="../Images/1667e96dd023c0b3a4fb1c53a45fbd92.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/1*UbuL98gJDMvB_u9JdZeQmQ.gif"/></div><figcaption class="lh li et er es lj lk bd b be z dx translated">从数据集计算平均值。从数据集中选择Medoid。</figcaption></figure><p id="a6ff" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj"> 2。选择medoids </strong></p><p id="a066" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">成本很高。</p><p id="23e7" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">因为水母是被选择的，而不是被计算的。从程序上讲，我们必须遍历数据集，在每个数据点停下来，计算“平均相异度”，然后将最小的一个作为medoid。在我的<em class="km">#超级</em>实现中，时间复杂度为O(n)。</p><p id="b9a5" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj"> 3。算法</strong></p><p id="25a8" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="km"> K-medoids </em>也被称为<strong class="js hj"><em class="km">PAM——围绕Medoids </em> </strong>分区</p><blockquote class="ks kt ku"><p id="805d" class="jq jr km js b jt kn ik jv jw ko in jy kv kp kb kc kw kq kf kg kx kr kj kk kl hb bi translated"><strong class="js hj">输入</strong>:一个数据集</p><p id="04fb" class="jq jr km js b jt kn ik jv jw ko in jy kv kp kb kc kw kq kf kg kx kr kj kk kl hb bi translated"><strong class="js hj">输出</strong> : k个簇用它们的medoids表示</p></blockquote><p id="95b6" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj">步骤0:初始化</strong></p><p id="c6ec" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">随机选择<strong class="js hj"> k </strong>个数据点作为初始点。</p><p id="550c" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj">第一步:关联(标记数据点)</strong></p><p id="cc82" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">遍历数据集，计算每个数据点<strong class="js hj"> <em class="km"> dp </em> </strong> <em class="km"> </em>到当前medoids的距离。将<strong class="js hj"> <em class="km"> dp </em> </strong>关联到最近的medoid <strong class="js hj"> <em class="km"> m. </em> </strong></p><p id="0fa3" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">每个<strong class="js hj"> <em class="km"> dp </em> </strong>现在已经被分配了一个标签，这是代表它所属的集群的medoid的序号。</p><p id="528a" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj">步骤2:更新medoids </strong></p><p id="f111" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在每个聚类中，假设每个<strong class="js hj"> <em class="km"> dp </em> </strong>都是潜在的新medoid。如果一个<strong class="js hj"> <em class="km"> dp </em> </strong>的“平均相异度”小于当前medoid的“平均相异度”，则将其作为新的medoid。</p><p id="3dd4" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj">第三步:收敛？</strong></p><p id="6136" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果我们的聚类是收敛的(medoids在更新后保持不变)，停止算法并返回结果。反之亦然，回到<strong class="js hj">步骤1 </strong>。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/b8b1ac7295386b1907bddb9567053d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TosiqnSF2kol5GouyAKdQQ.gif"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">(通过维基百科)PAM选择初始medoids，然后迭代收敛k=3个簇，用<a class="ae ky" href="https://en.wikipedia.org/wiki/ELKI" rel="noopener ugc nofollow" target="_blank"> ELKI </a>可视化。</figcaption></figure></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="0e5a" class="iy iz hi bd ja jb lx jd je jf ly jh ji ip lz iq jk is ma it jm iv mb iw jo jp bi translated">Python实现</h1><p id="f1d5" class="pw-post-body-paragraph jq jr hi js b jt ju ik jv jw jx in jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="js hj"> K-medoids类</strong></p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="1476" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj">初始化</strong></p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="b6d8" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj">关联</strong></p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="63f1" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj">更新Medoids </strong></p><p id="c07e" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了理解算法，我使用了一种蛮力方法来计算、比较和选择新的medoids。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="c954" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj">会集？</strong></p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="cc2e" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj">组装在一起</strong></p><p id="2d7f" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">完整的代码和测试用例可以在这里找到:<a class="ae ky" href="https://github.com/briverse17/supernaive-kmedoids" rel="noopener ugc nofollow" target="_blank">https://github.com/briverse17/supernaive-kmedoids</a></p><p id="4bbc" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="js hj">对，测试！</strong></p><p id="c997" class="pw-post-body-paragraph jq jr hi js b jt kn ik jv jw ko in jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们将围绕三个播种点(2，2)、(3，6)和(8，3)生成数据。期望是我们的模型能近似收敛到那个状态。</p><pre class="la lb lc ld fd me mf mg mh aw mi bi"><span id="fe1a" class="mj iz hi mf b fi mk ml l mm mn"><strong class="mf hj"><em class="km">#SuperNaive K-medoids</em></strong><br/>model=k_medoids(k=3)<br/>print('Centers found by your model:')<br/>print(model.fit(X))<br/>pred = model.predict(X)<br/>visualize(X,pred)</span><span id="ac5c" class="mj iz hi mf b fi mo ml l mm mn">Centers found by your model:<br/>[[1.98413249 2.04159709]<br/> [7.93224207 3.0213355 ]<br/> [2.98493437 5.97312308]]</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mp"><img src="../Images/8b7978d3bd40358448c2ccfde9528cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*IgTOYF4ILVj-jVP8driPzA.png"/></div></figure><pre class="la lb lc ld fd me mf mg mh aw mi bi"><span id="87ab" class="mj iz hi mf b fi mk ml l mm mn"><strong class="mf hj"><em class="km">sklearn_extra K-medoids<br/></em></strong>Centers found by scikit-learn extra:<br/>[[1.98413249 2.04159709]<br/> [7.93224207 3.0213355 ]<br/> [2.98493437 5.97312308]]</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mp"><img src="../Images/8b7978d3bd40358448c2ccfde9528cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*IgTOYF4ILVj-jVP8driPzA.png"/></div></figure></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="4188" class="iy iz hi bd ja jb lx jd je jf ly jh ji ip lz iq jk is ma it jm iv mb iw jo jp bi translated"><strong class="ak">参考文献</strong></h1><ol class=""><li id="1be1" class="mq mr hi js b jt ju jw jx jz ms kd mt kh mu kl mv mw mx my bi translated">维基百科关于K-medoids的文章:<a class="ae ky" href="https://en.wikipedia.org/wiki/K-medoids" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/K-medoids</a></li><li id="0689" class="mq mr hi js b jt mz jw na jz nb kd nc kh nd kl mv mw mx my bi translated">Tri Nguyen的K-medoids实现:<a class="ae ky" href="https://towardsdatascience.com/k-medoids-clustering-on-iris-data-set-1931bf781e05" rel="noopener" target="_blank">https://towards data science . com/k-me doids-clustering-on-iris-data-set-1931 BF 781 e 05</a></li><li id="45e4" class="mq mr hi js b jt mz jw na jz nb kd nc kh nd kl mv mw mx my bi translated">scikit learn extra的Github资源库:<a class="ae ky" href="https://github.com/scikit-learn-contrib/scikit-learn-extra/tree/master/sklearn_extra/cluster" rel="noopener ugc nofollow" target="_blank">https://github . com/scikit-learn-contrib/scikit-learn-extra/tree/master/sk learn _ extra/cluster</a></li></ol></div></div>    
</body>
</html>