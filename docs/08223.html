<html>
<head>
<title>Machine Learning and Trading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习和交易</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-and-trading-6f47a083a531?source=collection_archive---------19-----------------------#2020-07-21">https://medium.com/analytics-vidhya/machine-learning-and-trading-6f47a083a531?source=collection_archive---------19-----------------------#2020-07-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/39e0183a671999aa27bf4ba70fbfa2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvBPXrM6GuZ-9cre4Q21hw.png"/></div></div></figure><h1 id="7345" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">间隙播放</h1><p id="1f07" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi km translated">约翰·f·卡特在<em class="kv">的《掌握交易</em>一书中，将他最简单的系统描述为“<em class="kv">缺口游戏</em>”，他在股票开盘时创造的缺口进行交易，并在收盘时记录利润。我将尝试使用<strong class="jq hj">简单的分类和回归技术</strong>来重现这种差距。交易术语会被随意使用，但如果幸运的话，这不会影响这篇文章的本质。然而，如果你想随时跟上速度，<a class="ae kw" href="https://www.investopedia.com/articles/trading/05/playinggaps.asp" rel="noopener ugc nofollow" target="_blank">这个</a>是解释这里所有基本概念的兔子洞的良好开端。</p><h2 id="3690" class="kx ir hi bd is ky kz la iw lb lc ld ja jz le lf je kd lg lh ji kh li lj jm lk bi translated">设置</h2><p id="749e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">卡特的设置包括<em class="kv"/>缩小股票价格的差距。他每天都这样做，并使用特定股票的盘前总成交量，他称之为“当天的大盘股”，提供当天市场状态的概览。他的设置包括基于他根据经验对这些代表性股票的盘前交易量定义的启发式阈值。他以VIX美元指数的值为基础来计算临界量的值。</p><h2 id="c60d" class="kx ir hi bd is ky kz la iw lb lc ld ja jz le lf je kd lg lh ji kh li lj jm lk bi translated">设置(没有行话)</h2><p id="4c92" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">卡特的设置包括从一天内的股价差异中赚钱。例如，如果在今天开市时，一只股票的交易价格低于昨天收市时的交易价格，那么根据某些指标，卡特购买该股票的股票，并在今天开市时和昨天收市时的价格差距关闭时卖出。这些指标是什么？卡特使用他挑选的某一组股票在开市前的交易量数据，并根据这些交易量定义阈值，他根据这些阈值做出买卖决定。这些阈值是根据另一个称为VIX的指标确定的，该指标的值决定了这些阈值应该是多少。这不是(或者至少在我看来不是)火箭科学，这是一个根据经验精心制作的设置。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="468f" class="pw-post-body-paragraph jo jp hi jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl hb bi translated">我的目标是使用基本的机器学习技术重建这个设置。我将训练两种预测器:一个<strong class="jq hj">回归器来预测缺口将被填充的百分比</strong>和一个<strong class="jq hj">分类器来预测缺口是否会闭合</strong>。然而，在这篇文章中，我将只详述分类器的结果。</p><h1 id="f236" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">数据</h1><p id="effe" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于我的数据，我已经获得了从2019年1月1日到2020年7月17日所有<a class="ae kw" href="https://www1.nseindia.com/live_market/dynaContent/live_watch/equities_stock_watch.htm?cat=N" rel="noopener ugc nofollow" target="_blank">漂亮的</a>股票的15分钟内数据。这些数据以CSV文件的形式提供，我从更大的数据集中过滤出上市前的数据。这是通过在所有股票的数据中搜索09:00–09:15(NSE的盘前时段时间)的适当时间戳并将其收集到数据矩阵中来完成的。</p><p id="e02e" class="pw-post-body-paragraph jo jp hi jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl hb bi translated">该模型将提供对NIFTY缺口的预测(Carter使用S&amp;P、道琼斯指数)，因此对于真相标签(缺口是否闭合)，我使用NIFTY(以及$INDIAVIX)的每日数据，范围与之前相同。然后，我遍历数据，使用前一天和今天的OHLC，形成NIFTY中的缺口是否闭合所需的标签。</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="efcf" class="kx ir hi mc b fi mg mh l mi mj"># NIFTY OHLC data is in nifty_data</span><span id="bca5" class="kx ir hi mc b fi mk mh l mi mj"># truth labels<br/>binary_labels = []</span><span id="9ba7" class="kx ir hi mc b fi mk mh l mi mj">for i in range(nifty_data.shape[0]-1):<br/>    yday_close = nifty_data[i, CLOSE]<br/>    today_open = nifty_data[i+1, OPEN]<br/>    today_low = nifty_data[i+1, LOW]<br/>    today_high = nifty_data[i+1, HIGH]</span><span id="4247" class="kx ir hi mc b fi mk mh l mi mj"># gap at open, and gap at its smallest<br/>if today_open &gt; yday_close:<br/>    gap = today_open - yday_close<br/>    gap_close = today_low - yday_close</span><span id="e304" class="kx ir hi mc b fi mk mh l mi mj">elif today_open &lt; yday_close:<br/>    gap = yday_close - today_open<br/>    gap_close = yday_close - today_high</span><span id="ed76" class="kx ir hi mc b fi mk mh l mi mj"># did the gap close?<br/>if gap_close &lt;= 0:<br/>    binary_labels.append([i,1])<br/>else:<br/>    binary_labels.append([i,0])</span></pre><h1 id="6754" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">天真的基线</h1><p id="9f34" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们马上面临一个困境:<strong class="jq hj">没有足够的数据。</strong>我获取历史数据的来源仅提供了2019年1月1日的数据，这导致了<strong class="jq hj"> ≈ </strong> 350个数据点。由于我们缺乏数据，让我们使用一个简单的<strong class="jq hj">逻辑回归模型作为初始的原始基线。</strong></p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="1b40" class="kx ir hi mc b fi mg mh l mi mj">clf = LogisticRegression()</span></pre><p id="7303" class="pw-post-body-paragraph jo jp hi jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl hb bi translated">使用具有4个分割的K-fold交叉验证方法，给出了可怕的结果:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="6809" class="kx ir hi mc b fi mg mh l mi mj">Class   Metric     Score<br/>0       Recall     0.064<br/>1       Precision  0.67<br/>--------------------------<br/>Accuracy = 0.66</span></pre><p id="47db" class="pw-post-body-paragraph jo jp hi jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl hb bi translated"><strong class="jq hj">注:</strong>我们感兴趣的是缺口未平仓(0级)的召回分数，因为错误预测缺口将平仓(假阴性)的头寸后果严重。类似地，缺口闭合(类别1)的精度更重要，因为我们想要尽可能多的缺口闭合的正确预测(真阳性),并且如果预测是缺口开放(假阳性),我们就不会进入该位置。</p><p id="74cd" class="pw-post-body-paragraph jo jp hi jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl hb bi translated">如果我们对模型做一个小小的改变:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="a742" class="kx ir hi mc b fi mg mh l mi mj">clf = LogisticRegression(class_weight='balanced')</span></pre><p id="1567" class="pw-post-body-paragraph jo jp hi jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl hb bi translated">那么结果就更有希望了:</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="cee6" class="kx ir hi mc b fi mg mh l mi mj">Class   Metric     Score<br/>0       Recall     0.45<br/>1       Precision  0.70<br/>--------------------------<br/>Accuracy = 0.59</span></pre><p id="642a" class="pw-post-body-paragraph jo jp hi jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl hb bi translated">从表面上看，我们已经取得了45%的更好的召回分数，同时以整体准确性为代价略微提高了70%的精确度，整体准确性从66%降低到59%。然而，<strong class="jq hj">总体精度在这里并不重要。</strong>为了理解原因，下面是整个数据集的曲线图:</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/095500e18eedf4debc193a47c07b60ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IqawYhhgQGqN8x52Vy_nrQ.png"/></div></div></figure><p id="1ad5" class="pw-post-body-paragraph jo jp hi jq b jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh lw kj kk kl hb bi translated"><em class="kv">“间隙闭合”</em>点的数量明显多于<em class="kv">“间隙打开”</em>点，只有1/3的数据对应于<em class="kv">“间隙打开”</em>点。这意味着您可以<strong class="jq hj">通过预测差距将会缩小</strong>获得66%的准确度，这是第一个基线模型给出的准确度。<strong class="jq hj"><em class="kv">class _ weight = ' balanced '</em></strong><em class="kv"/>参数允许我们抵消数据中的这种不平衡，结果很清楚。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h2 id="1422" class="kx ir hi bd is ky kz la iw lb lc ld ja jz le lf je kd lg lh ji kh li lj jm lk bi translated">结论</h2><p id="eccb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">通过使用在一年半的数据上训练的逻辑回归分类器，一个完全不必要的相当于约翰·f·卡特的<em class="kv"> gap play </em>的数据科学是可能的。此外，有趣的是，人们可以通过简单地进入一个假设差距会缩小的位置来赚钱(也亏损了很多，但最终获得了利润)。</p></div></div>    
</body>
</html>