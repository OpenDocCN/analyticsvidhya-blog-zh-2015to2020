<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/vanilla-javascript-vs-rxjs-a1e6bd7978e6?source=collection_archive---------18-----------------------#2020-11-05">https://medium.com/analytics-vidhya/vanilla-javascript-vs-rxjs-a1e6bd7978e6?source=collection_archive---------18-----------------------#2020-11-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><p id="ab58" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">你可以继续在这里阅读或者<a class="ae if" href="https://odone.io/posts/2020-11-05-vanilla-javascript-vs-rxjs.html" rel="noopener ugc nofollow" target="_blank">跳转到我的博客</a>来获得完整的体验，包括美妙的粉红色，蓝色和白色的调色板。</p></div><div class="ab cl ig ih gp ii" role="separator"><span class="ij bw bk ik il im"/><span class="ij bw bk ik il im"/><span class="ij bw bk ik il"/></div><div class="hb hc hd he hf"><p id="29b1" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">这篇文章比较了普通JavaScript和RxJs。我的意图并不是要证明哪一个是最好的方法。一如既往，视情况而定。</p><p id="7e1c" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">但是我想强调从不同角度解决问题的重要性。在这种情况下，必须反对声明性，或者说“推”对“拉”</p><p id="58ad" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">此外，不同的心智模型提供了可以在解决方案中利用的洞察力，而不管选择了什么样的范式。在本文中，命令式方法有助于探索问题，声明式方法提炼解决方案:两者各有千秋。</p><h2 id="167a" class="io ip hi bd iq ir is it iu iv iw ix iy hs iz ja jb hw jc jd je ia jf jg jh ji bi translated">现在是星期一早上</h2><p id="65d2" class="pw-post-body-paragraph hg hh hi hj b hk jj hm hn ho jk hq hr hs jl hu hv hw jm hy hz ia jn ic id ie hb bi translated">当你等待浏览器加载待办事项的时候，你想知道你今天将要使用的功能。</p><p id="6097" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">也许你会在Elm-land工作，那里从来不会出现运行时异常，或者你会在Haskell中建模新的领域，那里不可能的状态不会被编译。</p><p id="77f5" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">不，是JavaScript。您需要添加一个输入字段，使用户能够获取数据。</p><p id="1b14" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><em class="jo">该死的</em>。</p><p id="73ed" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">你相信小步骤和短反馈循环，所以这是你的第一步:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9ae3" class="io ip hi ju b fi jy jz l ka kb">&lt;input type="text" id="query" /&gt;</span><span id="3b78" class="io ip hi ju b fi kc jz l ka kb">const callback = value =&gt; console.log(value)<br/><br/>const queryElement = document.getElementById("query")<br/>queryElement.addEventListener('input', event =&gt; callback(event.target.value))</span></pre><p id="ce14" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">浏览一下浏览器就可以确认在输入字段中输入的值会记录在控制台中。太好了！</p><p id="698b" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">获取时间:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="d92d" class="io ip hi ju b fi jy jz l ka kb">-const callback = value =&gt; console.log(value)<br/>+const callback = query =&gt;<br/>+  fetch(`https://httpbin.org/get?query=${encodeURIComponent(query)}`)<br/>+    .then(response =&gt; response.json())<br/>+    .then(response =&gt; console.log(response))</span></pre><p id="52a6" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">另一个快速的手动测试确认这些请求有效。</p><p id="976a" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">剩下的时间里，你把事情做得更漂亮，用合适的函数替换<code class="du kd ke kf ju b">console.log()</code>来填充DOM。然后，你满怀自豪地把票挪到done。</p><p id="285f" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">太棒了！</p><p id="6c64" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">不幸的是，第二天你收到了devops团队发来的邮件，主题如下:<strong class="hj in">紧急！1!</strong>。部署之后，服务器开始接收大量请求。</p><p id="47d4" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">你打开应用程序，输入“天哪！”在文本字段中。当您注意到它生成了10个网络请求时，您的心跳有些加快:</p><ul class=""><li id="f7e3" class="kg kh hi hj b hk hl ho hp hs ki hw kj ia kk ie kl km kn ko bi translated">" h "</li><li id="da76" class="kg kh hi hj b hk kp ho kq hs kr hw ks ia kt ie kl km kn ko bi translated">“嗬”</li><li id="91be" class="kg kh hi hj b hk kp ho kq hs kr hw ks ia kt ie kl km kn ko bi translated">“霍尔”</li><li id="8949" class="kg kh hi hj b hk kp ho kq hs kr hw ks ia kt ie kl km kn ko bi translated">“神圣”</li><li id="575a" class="kg kh hi hj b hk kp ho kq hs kr hw ks ia kt ie kl km kn ko bi translated">“神圣”</li><li id="97d0" class="kg kh hi hj b hk kp ho kq hs kr hw ks ia kt ie kl km kn ko bi translated">“神圣的m”</li><li id="dd6b" class="kg kh hi hj b hk kp ho kq hs kr hw ks ia kt ie kl km kn ko bi">…</li></ul><p id="4555" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><em class="jo">神圣的钼！的确，我忘记去抖了！</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="2f67" class="io ip hi ju b fi jy jz l ka kb">+const DEBOUNCE_MILLISECONDS = 300<br/>+let scheduled<br/>+<br/> const callback = query =&gt;<br/>   fetch(`https://httpbin.org/get?query=${encodeURIComponent(query)}`)<br/>     .then(response =&gt; response.json())<br/>     .then(response =&gt; console.log(response))<br/><br/>+const debounce = fnc =&gt; arg =&gt; {<br/>+  clearTimeout(scheduled)<br/>+  scheduled = setTimeout(() =&gt; fnc(arg), DEBOUNCE_MILLISECONDS)<br/>+}<br/>+<br/>+const debouncedCallback = debounce(callback)<br/>+<br/> const queryElement = document.getElementById("query")<br/>-queryElement.addEventListener('input', event =&gt; callback(event.target.value))<br/>+queryElement.addEventListener('input', event =&gt; debouncedCallback(event.target.value))</span></pre><p id="960b" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">为了确保不再激怒操作团队，您更深入地进行手动测试。去抖动是可行的，但是有些奇怪:有时，应用程序显示旧查询的数据。</p><p id="8944" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">啊哈，这些响应是乱序的。</p><p id="7fe8" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">为了使其更加明显，您在<code class="du kd ke kf ju b">fetch</code>中引入了随机延迟:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="e693" class="io ip hi ju b fi jy jz l ka kb">+const throttledFetch = (url, options) =&gt; {<br/>+  return new Promise((res, rej) =&gt; {<br/>+    const throttleBy = Math.random() * 10000<br/>+    console.log(`throttledBy ${throttleBy} milliseconds`)<br/>+    fetch(url)<br/>+      .then(x =&gt; setTimeout(() =&gt; res(x), throttleBy))<br/>+      .catch(x =&gt; setTimeout(() =&gt; rej(x), throttleBy))<br/>+  })<br/>+}<br/>+<br/> const callback = query =&gt;<br/>-  fetch(`https://httpbin.org/get?query=${encodeURIComponent(query)}`)<br/>+  throttledFetch(`https://httpbin.org/get?query=${encodeURIComponent(query)}`)<br/>     .then(response =&gt; response.json())<br/>     .then(response =&gt; console.log(response))</span></pre><p id="5d6f" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">幸运的是，您可以在执行下一个<code class="du kd ke kf ju b">fetch</code>之前中止上一个:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="40b2" class="io ip hi ju b fi jy jz l ka kb">+let controller = new AbortController()<br/><br/> const throttledFetch = (url, options) =&gt; {<br/>   return new Promise((res, rej) =&gt; {<br/>     const throttleBy = Math.random() * 10000<br/>     console.log(`throttleBy ${throttleBy} milliseconds`)<br/>-    fetch(url)<br/>+    controller.abort()<br/>+    controller = new AbortController()<br/>+    fetch(url, { signal: controller.signal })</span></pre><p id="01ad" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">快结束了，你盯着这段代码:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="1ac1" class="io ip hi ju b fi jy jz l ka kb">const DEBOUNCE_MILLISECONDS = 300<br/>let scheduled<br/>let controller = new AbortController()<br/><br/>const throttledFetch = (url, options) =&gt; {<br/>  return new Promise((res, rej) =&gt; {<br/>    const throttleBy = Math.random() * 10000<br/>    console.log(`throttleBy ${throttleBy} milliseconds`)<br/>    controller.abort()<br/>    controller = new AbortController()<br/>    fetch(url, { signal: controller.signal })<br/>      .then(x =&gt; setTimeout(() =&gt; res(x), throttleBy))<br/>      .catch(x =&gt; setTimeout(() =&gt; rej(x), throttleBy))<br/>  })<br/>}<br/><br/>const callback = query =&gt;<br/>  throttledFetch(`https://httpbin.org/get?query=${encodeURIComponent(query)}`)<br/>    .then(response =&gt; response.json())<br/>    .then(response =&gt; console.log(response))<br/>    .catch(error =&gt; console.log(error))<br/><br/>const debounce = fnc =&gt; arg =&gt; {<br/>  clearTimeout(scheduled)<br/>  scheduled = setTimeout(() =&gt; fnc(arg), DEBOUNCE_MILLISECONDS)<br/>}<br/><br/>const debouncedCallback = debounce(callback)<br/><br/>const queryElement = document.getElementById("query")<br/>queryElement.addEventListener("input", event =&gt; debouncedCallback(event.target.value))</span></pre><p id="9f3c" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">需要删除限制代码。尽管如此，你头脑中的软件工匠还是很痛苦。你不应该一行一行地告诉JavaScript该做什么。</p><p id="f094" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">你想“拉”信息并对其做出反应，而不是“推”信息。它应该像电子表格一样具有声明性。</p><p id="6553" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">现在想这些已经太晚了，你的手指已经在打字了:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="abd2" class="io ip hi ju b fi jy jz l ka kb">const queryElement = document.getElementById("query")<br/><br/>fromEvent(queryElement, 'input').pipe(<br/>  debounceTime(300),<br/>  map(event =&gt; event.target.value),<br/>  switchMap(query =&gt; fromFetch(`https://httpbin.org/get?query=${encodeURIComponent(query)}`)),<br/>  flatMap(response =&gt; response.json()),<br/>  catchError(error =&gt; console.log(error))<br/>)<br/>.subscribe(response =&gt; console.log(response))</span></pre><p id="8991" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">这不仅实现了相同的结果，而且它更短，更具声明性。还不算你从新的角度注意到的额外洞察力:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="f86e" class="io ip hi ju b fi jy jz l ka kb">const queryElement = document.getElementById("query")<br/><br/>fromEvent(queryElement, 'input').pipe(<br/>  debounceTime(300),<br/>  map(event =&gt; event.target.value),<br/>+ distinctUntilChanged(),<br/>  switchMap(query =&gt; fromFetch(`https://httpbin.org/get?query=${encodeURIComponent(query)}`)),<br/>  flatMap(response =&gt; response.json()),<br/>  catchError(error =&gt; console.log(error))<br/>)<br/>.subscribe(response =&gt; console.log(response))</span></pre><p id="b4e4" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">你确保没有其他人在看，你偷偷加入附加的依赖项，然后进行部署。</p><p id="ddeb" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">现在，一天结束了！</p></div><div class="ab cl ig ih gp ii" role="separator"><span class="ij bw bk ik il im"/><span class="ij bw bk ik il im"/><span class="ij bw bk ik il"/></div><div class="hb hc hd he hf"><p id="6eda" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">从我个人的电子邮件中获取最新内容。用你的想法回复。让我们互相学习。订阅我的<a class="ae if" href="https://odone.io#newsletter" rel="noopener ugc nofollow" target="_blank"> PinkLetter </a>！</p></div></div>    
</body>
</html>