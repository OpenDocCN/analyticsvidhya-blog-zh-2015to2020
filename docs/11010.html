<html>
<head>
<title>Simple Loan Prediction Project using Neural Network.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用神经网络的简单贷款预测项目。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/simple-loan-prediction-project-using-neural-network-bdac5e945fcc?source=collection_archive---------3-----------------------#2020-11-13">https://medium.com/analytics-vidhya/simple-loan-prediction-project-using-neural-network-bdac5e945fcc?source=collection_archive---------3-----------------------#2020-11-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9682056fb1193c7654429aeeaef5ae6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGTB7xvQa4qVIo4-OvlfYQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:互联网</figcaption></figure><p id="43b5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这个项目中，我们将解决贷款预测问题，我们必须<strong class="iw hj">根据客户详细信息预测贷款是否应该被批准</strong>。下面是数据的一瞥。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es js"><img src="../Images/3d26540bd951929af7b6c220c096bbf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTrOAXEMHSDz4cZPWDmkMQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:Vidhya分析</figcaption></figure><p id="3a1c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们有各种自变量，从<strong class="iw hj"> <em class="jx">教育、收入、贷款额、信用历史</em> </strong>等。和一个目标变量<strong class="iw hj"> <em class="jx">贷款状态</em> </strong>。因为在我们的目标变量中有两个值,“Y”代表贷款批准,“N”代表贷款未批准。</p><p id="2200" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们深入研究这个问题，一步一步地解决它。</p><blockquote class="jy jz ka"><p id="2979" class="iu iv jx iw b ix iy iz ja jb jc jd je kb jg jh ji kc jk jl jm kd jo jp jq jr hb bi translated"><strong class="iw hj">步骤1:数据预处理步骤:</strong>由于模型沉迷于数字，我们将在这个项目中关注的一些数据预处理步骤如下。</p></blockquote><ol class=""><li id="2de2" class="ke kf hi iw b ix iy jb jc jf kg jj kh jn ki jr kj kk kl km bi translated"><em class="jx">填充空值/缺失值</em>。</li><li id="1cd1" class="ke kf hi iw b ix kn jb ko jf kp jj kq jn kr jr kj kk kl km bi translated"><em class="jx">将分类值转换成数字</em>。</li><li id="253d" class="ke kf hi iw b ix kn jb ko jf kp jj kq jn kr jr kj kk kl km bi translated"><em class="jx">将所有变量置于(0到1)之间的相同范围内，这减少了计算时间，有助于神经网络更快地收敛</em>。</li></ol><p id="387c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">缺少值。</strong></p><ol class=""><li id="b25a" class="ke kf hi iw b ix iy jb jc jf kg jj kh jn ki jr kj kk kl km bi translated">分类值。</li></ol><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="e445" class="kx ky hi kt b fi kz la l lb lc"># Checking Null Values.</span><span id="8fa1" class="kx ky hi kt b fi ld la l lb lc">data.isnull().sum()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es le"><img src="../Images/cac1c6b7cb95c1bc3d1ed4a44c510453.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*2bxII5abMWS2bDj4aav2vA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:Vidhya分析</figcaption></figure><p id="87f0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的自变量列中存在多个空值。我们会一个一个处理。</p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="ef8f" class="kx ky hi kt b fi kz la l lb lc"># Handling Categorical Null Values </span><span id="8a4d" class="kx ky hi kt b fi ld la l lb lc">-&gt; Gender<br/>data['Gender'].fillna(data['Gender'].mode()[0],<br/>                      inplace = True)</span><span id="d083" class="kx ky hi kt b fi ld la l lb lc">-&gt; Married<br/>data['Married'].fillna(data['Married'].mode()[0],<br/>                       inplace = True)</span><span id="4b68" class="kx ky hi kt b fi ld la l lb lc">-&gt; Dependent<br/>data['Dependent'].fillna(data['Dependent'].mode()[0],<br/>                         inplace = True)</span><span id="7e1d" class="kx ky hi kt b fi ld la l lb lc">-&gt; Education<br/>data['Education'].fillna(data['Education'].mode()[0],<br/>                         inplace = True)</span><span id="8025" class="kx ky hi kt b fi ld la l lb lc">-&gt; Self_Employed<br/>data['Self_Employed'].fillna(data['Self_Employed'].mode()[0],<br/>                             inplace = True)</span></pre><p id="4ddb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2 .连续值。</p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="0849" class="kx ky hi kt b fi kz la l lb lc">plt.figure(figsize = (10,4))</span><span id="86c1" class="kx ky hi kt b fi ld la l lb lc">sns.boxplot(x = 'LoanAmount',<br/>            data = data,<br/>            orient = 'horizontal')</span><span id="7baa" class="kx ky hi kt b fi ld la l lb lc">plt.show()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/ab1642e2184c9889d5cc51060c5b799d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyPpCsMjQKWd2R0Xh3g3Gg.png"/></div></div></figure><p id="6b26" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于我们在LoanAmount列中有许多异常值，我们将使用中位数估算缺失值，因为中位数对异常值没有任何影响。</p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="e738" class="kx ky hi kt b fi kz la l lb lc">data['LoanAmount'].fillna(data['LoanAmount'].median(),<br/>                          inplace = True)</span></pre><p id="6c1f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">处理分类值。</strong></p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="2ecf" class="kx ky hi kt b fi kz la l lb lc"># Converting the categories into numbers using map function.</span><span id="db8f" class="kx ky hi kt b fi ld la l lb lc">data['Gender'] = data['Gender'].map({'Male': 0, 'Female': 1})</span><span id="4da2" class="kx ky hi kt b fi ld la l lb lc">data['Married'] = data['Married'].map({'No': 0, 'Yes': 1})</span><span id="85f1" class="kx ky hi kt b fi ld la l lb lc">data['Dependents'] = data['Dependents'].map({'0': 0, '1': 1, '2': 2, '3+': 3})</span><span id="5e05" class="kx ky hi kt b fi ld la l lb lc">data['Education'] = data['Education'].map({'Graduate': 1, 'Not Graduate': 0})</span><span id="cb11" class="kx ky hi kt b fi ld la l lb lc">data['Self_Employed'] = data['Self_Employed'].map({'No': 0, 'Yes': 1})</span><span id="66ad" class="kx ky hi kt b fi ld la l lb lc">data['Property_Area'] = data['Property_Area'].map({'Rural': 0, 'Semiurban': 1, 'Urban': 2})</span><span id="766c" class="kx ky hi kt b fi ld la l lb lc">data['Loan_Status'] = data['Loan_Status'].map({'N': 0, 'Y': 1})</span></pre><p id="1556" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">缩放数值-最小最大缩放器。</strong></p><p id="7054" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将使用最小-最大缩放器，它将所有列的值缩小到0到1之间。最小-最大缩放器的公式如下所示。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/75e710cb94c99f6df6c47bf083414f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*UyT3wNJvWE4G5AA0UXiJfw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:Vidhya分析</figcaption></figure><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="f652" class="kx ky hi kt b fi kz la l lb lc">for i in data.columns[1:]:<br/>    data[i] = (data[i] - data[i].min()) / (data[i].max() - data[i].min())</span></pre><blockquote class="jy jz ka"><p id="2e99" class="iu iv jx iw b ix iy iz ja jb jc jd je kb jg jh ji kc jk jl jm kd jo jp jq jr hb bi translated"><strong class="iw hj">第二步:构建神经网络的步骤。这里我们将讨论建立一个神经网络所需的步骤。</strong></p></blockquote><ol class=""><li id="32ff" class="ke kf hi iw b ix iy jb jc jf kg jj kh jn ki jr kj kk kl km bi translated"><em class="jx">加载数据</em>。</li><li id="9204" class="ke kf hi iw b ix kn jb ko jf kp jj kq jn kr jr kj kk kl km bi translated"><em class="jx">创建训练和验证数据</em>:我们将根据训练数据进行训练，根据验证数据进行验证。</li><li id="545e" class="ke kf hi iw b ix kn jb ko jf kp jj kq jn kr jr kj kk kl km bi translated"><em class="jx">定义我们模型的架构</em>:我们将定义输入神经元的数量，隐藏层和输出层神经元的数量。</li><li id="e92a" class="ke kf hi iw b ix kn jb ko jf kp jj kq jn kr jr kj kk kl km bi translated"><em class="jx">编译模型(损失函数/优化器)</em>:这里我们将定义我们的成本函数，它将在反向传播期间使用。</li><li id="6b8d" class="ke kf hi iw b ix kn jb ko jf kp jj kq jn kr jr kj kk kl km bi translated"><em class="jx">训练模型:</em>我们将训练我们的模型，并定义纪元的数量。</li><li id="aab6" class="ke kf hi iw b ix kn jb ko jf kp jj kq jn kr jr kj kk kl km bi translated"><em class="jx">评估模型在训练和验证数据上的表现</em>。</li></ol><p id="fba4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">训练&amp;验证:</strong>在这里，我们将使用我们的训练数据。在100%的训练数据中，我们将保留10%用于测试数据，并在此基础上评估模型的准确性。模型完全看不到这些测试数据。在剩余的90%的训练数据中，我们将使用20%来验证我们的模型，并对70%的数据进行训练。</p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="2194" class="kx ky hi kt b fi kz la l lb lc"># Testing Data - 10%<br/>from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.1, stratify=data['Loan_Status'], random_state = 42)</span><span id="0143" class="kx ky hi kt b fi ld la l lb lc"># Train &amp; Valid Data - 90%<br/>x_train, x_val, y_train, y_val = train_test_split(X_train, y_train, test_size = 0.2, stratify = y_train, random_state = 42)</span></pre><ul class=""><li id="4fae" class="ke kf hi iw b ix iy jb jc jf kg jj kh jn ki jr lh kk kl km bi translated"><em class="jx">分层</em>将确保训练和测试/验证集中类的分布是相似的。</li><li id="070b" class="ke kf hi iw b ix kn jb ko jf kp jj kq jn kr jr lh kk kl km bi translated"><em class="jx">随机状态</em>重新生成相同的训练和验证集。</li><li id="b6f0" class="ke kf hi iw b ix kn jb ko jf kp jj kq jn kr jr lh kk kl km bi translated"><em class="jx">测试大小</em> 0.2将在验证中保留20%的数据，在训练集中保留80%的数据。</li></ul><p id="cfbd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">定义模型架构:</strong>在定义模型架构时，我建议在使用优化器和激活函数之前，请让我们从以下关于优化器和各种激活函数的博客中了解一下。</p><div class="li lj ez fb lk ll"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/optimizer-loss-functions-in-neural-network-2520c244cc22"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">神经网络中的优化器和损失函数</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">深度学习中最常用的各种优化器和损失函数。</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">medium.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz io ll"/></div></div></a></div><div class="li lj ez fb lk ll"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/activation-functions-in-neural-network-55d1afb5397a"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">神经网络中的激活函数</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">在这个博客中，我们将了解深度学习中最广泛使用的激活函数。</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">medium.com</p></div></div><div class="lu l"><div class="ma l lw lx ly lu lz io ll"/></div></div></a></div><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/5c8da84178cf3e688453db8f2a223e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AvPUl_qWBJq4FCZMFJwrPA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:Vidhya分析</figcaption></figure><p id="fbf2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，我们将定义输入、隐藏和输出神经元的数量。</p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="89fd" class="kx ky hi kt b fi kz la l lb lc"># Creating a skeleton of model.<br/>from keras.models import Sequential</span><span id="0ba0" class="kx ky hi kt b fi ld la l lb lc"># Defining layers<br/>from keras.layers import Input, Dense</span></pre><p id="8bfc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">定义输入、隐藏、输出神经元和架构。现在，我选择了<strong class="iw hj"> <em class="jx"> relu </em> </strong>作为隐藏层的激活功能。还有，既然是二元分类问题，我在最后一层用了<strong class="iw hj"> <em class="jx"> sigmoid </em> </strong>激活函数。没有硬性规定我们必须只使用这些激活功能。我们也可以关闭其他激活功能。</p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="1dc6" class="kx ky hi kt b fi kz la l lb lc"># Input neurons<br/>input_neurons = X_train.shape[1]</span><span id="a47c" class="kx ky hi kt b fi ld la l lb lc"># Output neurons (Since it is binary classification)<br/>output_neurons = 1</span><span id="7c65" class="kx ky hi kt b fi ld la l lb lc"># Defining hidden layers &amp; neurons in each layersnumber_of_hidden_layers = 2<br/>neuron_hidden_layer_1         = 10<br/>neuron_hidden_layer_2         = 5</span><span id="74dc" class="kx ky hi kt b fi ld la l lb lc"># Defining the architecture of the model<br/>model = Sequential()<br/>model.add(InputLayer(input_shape=(input_neurons)))<br/>model.add(Dense(units=neuron_hidden_layer_1, activation='relu'))<br/>model.add(Dense(units=neuron_hidden_layer_2, activation='relu'))<br/>model.add(Dense(units=output_neurons, activation='sigmoid'))</span></pre><p id="ca1b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">编译模型(损失函数/优化器):</strong>在本部分中，我们定义了损失函数和优化器，这有助于验证我们的数据和反向传播。</p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="b9d2" class="kx ky hi kt b fi kz la l lb lc">model.compile(loss='binary_crossentropy',optimizer='Adam',metrics=['accuracy'])</span></pre><p id="3d3f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">训练模型:</strong>在这一部分，我们将通过传递自变量和因变量以及验证数据和时期数来训练我们的模型，时期数指定了我们的模型通过训练集的次数。</p><p id="c10f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于每个历元，训练集和验证集都会产生一个损失，而且我们会获得训练集和验证集的准确性，因为我们已经在编译阶段定义了它们，并且正在捕获它们</p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="3773" class="kx ky hi kt b fi kz la l lb lc">model_history = model.fit(X_train, y_train, validation_data = (X_test, y_test), epochs = 50)</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/c707489d33b0e984dbd70d7fd40acb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhaIT95b3rSzm8VRl_EmMw.png"/></div></div></figure><p id="f50f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">根据测试数据评估模型:</strong>这里，我们将预测数据的类别，并使用度量作为<em class="jx">准确性</em>来评估模型性能。</p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="5fcc" class="kx ky hi kt b fi kz la l lb lc"># Getting predictions for the test set<br/>prediction = model.predict_classes(X_test)</span><span id="f37e" class="kx ky hi kt b fi ld la l lb lc"># Getting accuracy score<br/>from sklearn.metrics import accuracy_score<br/>print("Accuracy_Score : {}".format(accuracy_score(prediction, y_test) * 100))</span></pre><p id="8f30" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在对测试和验证数据进行分类预测后，我们得到了80%的下降准确率。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/ba755d734df630dbfa62207c4caadde5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LOn7RBSnp26mKn-ERqVxNA.png"/></div></div></figure><p id="1e84" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">可视化结果(损失&amp;精度):</strong>在这里，我们将看到损失函数和精度在多个时期内的变化。</p><ol class=""><li id="2405" class="ke kf hi iw b ix iy jb jc jf kg jj kh jn ki jr kj kk kl km bi translated">损失函数</li></ol><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/69730292a342b89e207e18826eb1be8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFbTfapdZySHUxWlAlDnoA.png"/></div></div></figure><p id="a934" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从上图中我们可以看出，随着历元数的增加，损失会减少。经过一定数量的时期后，验证损失似乎没有改善。</p><p id="bb90" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.准确(性)</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/8e0ec404c2eac769c848002c325702bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-KG-jjp0ZuSRTbjCN_zJ8g.png"/></div></div></figure><p id="21b4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我们所看到的，5到10个时期的精度变化不大。之后，训练集和验证集的准确性开始提高，因此我们可以说模型开始学习。从公元20世纪到公元100世纪，这个模型有了轻微的改进，或者我们可以说它停止了学习。</p><p id="48d6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是我们如何在数据集上建立神经网络模型。我希望你喜欢它。</p><p id="7abc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi mg translated"><span class="l mh mi mj bm mk ml mm mn mo di">C</span>T2】结束语</p><p id="a303" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，在这篇博客中，我们已经学会了如何使用ANN解决一个简单的神经网络贷款预测问题。我们可以通过做各种超参数调整和观察随机数据的准确性来进一步改进模型的性能。</p><p id="a976" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请在LinkedIn上与我联系:【https://www.linkedin.com/in/gaurav-rajpal/ T4】</p><p id="01af" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="jx">敬请关注演示项目的进一步更新，我们将在卷积神经网络中处理图像数据集，并查看迁移学习。</em>T9】</strong></p><p id="a195" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你喜欢，请给50个掌声。T13】</p><p id="5390" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">问候，</p><p id="68e7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">高拉夫·拉杰帕尔·(gauravrajpal1994@gmail.com)</p></div></div>    
</body>
</html>