<html>
<head>
<title>Practical Time Series — from ARIMA to Deep Learning (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用时间序列——从ARIMA到深度学习(上)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/practical-time-series-from-arima-to-deep-learning-part-1-b292b07ec6c3?source=collection_archive---------16-----------------------#2020-01-07">https://medium.com/analytics-vidhya/practical-time-series-from-arima-to-deep-learning-part-1-b292b07ec6c3?source=collection_archive---------16-----------------------#2020-01-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="673c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天我们要讲的是时间序列和预测！预测是使用预测模型，根据以前观察到的值和时间序列数据的有意义特征来预测未来值。它可应用于各种行业和使用案例，例如金融、零售、营销，甚至是针对系统故障的异常检测。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/e846de4e2c4388a986fed87d8af5d03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*JmaM-hrxd_FwmBjFS9-bkw.png"/></div></figure><p id="d2f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一系列关于时间序列的帖子也将作为我的实用笔记，因为我可以在未来快速地将代码改造成任何特定的用例，我希望它也能以同样的方式帮助你。这篇文章中的代码也将在<a class="ae jl" href="https://github.com/wyseow/timeseries" rel="noopener ugc nofollow" target="_blank"> my Github </a>中提供。</p><h1 id="748a" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">1.导入库和数据集</h1><p id="f982" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们将在后面讨论单个的库，因为目前还不清楚它们有什么帮助。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="ffbb" class="ku jn hi kq b fi kv kw l kx ky">import pandas as pd <br/>import matplotlib.pyplot as plt <br/>import statsmodels.api as sm <br/>import itertools <br/>import numpy as np from pmdarima <br/>import auto_arima from pylab <br/>import rcParams from statsmodels.tsa.stattools <br/>import adfuller from random <br/>import seed, random from statsmodels.graphics <br/>import tsaplots plt.style.use('fivethirtyeight')</span></pre><p id="dd7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用一个小型数据集，即可以从<a class="ae jl" href="https://community.tableau.com/docs/DOC-1236" rel="noopener ugc nofollow" target="_blank">这里</a>下载的超市销售数据。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="7157" class="ku jn hi kq b fi kv kw l kx ky">df = pd.read_excel('Sample - Superstore.xls')</span></pre><p id="f9fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每一行代表一笔销售交易，其中包含非常丰富的信息，如客户人口统计数据和利润。如果我们采用机器学习方法，这些将有助于特征工程。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/7f804fdfbb95d7f4fec01c22f4eae89d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SAjWfzKlb5cmmLFI.png"/></div></div></figure><p id="866b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有大量不同类别的产品。现在，我们只看“家具”。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="b08f" class="ku jn hi kq b fi kv kw l kx ky">sales_df = df.loc[df['Category'] == 'Furniture'] sales_df['Order Date'].min(), sales_df['Order Date'].max()</span></pre><p id="c140" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(时间戳(' 2014–01–06 00:00:00 ')，时间戳(' 2017–12–30 00:00:00 ')</p><p id="fb2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快速浏览一下时间序列的可用时间段，就会发现我们有4年的数据可以使用！</p><h1 id="bfc0" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">2.数据预处理</h1><p id="19a7" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">让我们只使用我们最感兴趣的主要变量:销售，将数据转换为单变量时间序列数据。当我们对单变量时间序列进行建模时，我们是在对单个变量随时间的变化进行建模。</p><p id="0a9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">附带的好处是，我们不需要检查和清理所有特性的数据。所以让我们检查这个特定变量的空值。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="3786" class="ku jn hi kq b fi kv kw l kx ky">sales_df = sales_df[['Order Date','Sales']] sales_df = sales_df.sort_values('Order Date') sales_df.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es le"><img src="../Images/7cd3c39d3e8569d65e6665fba8393c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/0*An2SprsiAqR4jP6z.png"/></div></figure><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="1a6c" class="ku jn hi kq b fi kv kw l kx ky">sales_df.isnull().sum()</span><span id="e793" class="ku jn hi kq b fi lf kw l kx ky">Order Date 0 <br/>Sales 0 <br/>dtype: int64</span></pre><p id="4f87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们非常幸运，这是一个干净的数据集；没有空值😂</p><p id="adf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回想一下，数据集的每一行都是一笔销售交易，因此每一天都会有多笔销售。我们希望将数据汇总成“每日销售额”格式。我们用求和来总结，你也可以用其他的统计数据。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="a16a" class="ku jn hi kq b fi kv kw l kx ky">#the reset_index is here is to regenerate the index on the grouped panda series sales_df = sales_df.groupby('Order Date')['Sales'].sum().reset_index()</span></pre><h1 id="b7da" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">3.数据争论</h1><p id="7e74" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们将把订单日期作为索引，这样向前发展，数据操作会更容易。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="f0ce" class="ku jn hi kq b fi kv kw l kx ky">sales_df = sales_df.set_index('Order Date') sales_df.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lg"><img src="../Images/57d42a534eb04f52cd8964f55727afd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*Jlwt5JpB1Zypqm4P.png"/></div></figure><h1 id="44cd" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">3.1不均匀空间时间序列</h1><p id="0819" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">请注意，时间序列数据中的第8、第9和第12个值缺失。</p><p id="02ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经遇到了我们的第一个问题，臭名昭著的“不均匀空间时间序列”问题，这是一个在这个领域得到充分研究的问题。</p><p id="ecc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)如果您的最终输出允许您在月级别进行预测，那么您很幸运:您可以在更高的级别进行重新采样(将天数累计到月数并汇总值)。有一个简单的函数可以快速做到这一点:DataFrame.resample</p><p id="7495" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)插值数据</p><p id="f4b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">天真的方法:向下采样到月频率</strong> <br/>让我们采用第一种方法，因为我们要预测月销售额。我们后面会讲到时间序列的插值…</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="2cef" class="ku jn hi kq b fi kv kw l kx ky">monthly_sales_df = sales_df.resample('MS').mean() monthly_sales_df.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lh"><img src="../Images/11fbd870e85f2cf32f266c103d2f630a.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/0*MSTi26-5kLeqZKwV.png"/></div></figure><h1 id="11d2" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">4.可视化时间序列</h1><p id="abe8" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">就像我们通常的数据分析工作一样，我们首先在任何建模工作(如果有的话)之前绘制数据，试图识别一些可区分的模式。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="2899" class="ku jn hi kq b fi kv kw l kx ky">monthly_sales_df.plot(figsize=(13, 5)) plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/daf04601f5ea3ef3fb4ee26c6317da9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uYKO4XniOwDJ1UEe.png"/></div></div></figure><h1 id="d1cf" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">4.1描述模式—季节性</h1><p id="7e2e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们在图中观察到的第一个明显的模式是年度季节性(12个月=一个周期)。销售额在年初相对较低，在年底较高，这种模式每年都在重复。这些年来，销售额也有小幅下降的趋势。</p><p id="80b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">时间序列过程可以分解成几个部分:级别:序列中的平均值。趋势:系列中增加或减少的值。季节性:系列中重复的短期周期。噪声:序列中的随机变化。</p><p id="acd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用scipy的seasonal_decompose函数自动分解一个时间序列并绘制出来，以便更好地检查每个组件，而不是猜测组件。</p><p id="4139" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，这里有一个模型参数，这意味着时间序列是否是一个加法和乘法模型。区别在于成分是如何组合在一起的。</p><p id="4cab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加法模型= y(t) =水平+趋势+季节性+噪声</p><p id="519b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乘法模型= y(t) =水平<em class="li">趋势</em>季节性*噪声</p><p id="9df7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个简单的经验法则是:如果你观察到方差随着时间的推移而增加，它很可能是倍增的。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="df73" class="ku jn hi kq b fi kv kw l kx ky">rcParams['figure.figsize'] = 18, 8 # note that the freq defaults to freq of dataframe's decomposition = sm.tsa.seasonal_decompose(monthly_sales_df, model='additive') fig = decomposition.plot() <br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/b06954ace523c7255a84416f5aef35ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lRwnrTu8Lp3Wn4RF.png"/></div></div></figure><p id="50ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在季节性成分中更明显地看到年度季节性，趋势正在下降，就像我们观察到的那样。</p><h1 id="4fd5" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">4.2描述模式—静态</h1><p id="fdca" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们也可以将时间序列描述为平稳或非平稳过程。这是时间序列中的一个重要概念，植根于几个时间序列模型的假设中，所以让我们快速看一下。</p><p id="6ab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个定义可能有点吓人，平稳性有两种形式:弱形式和严格平稳性。</p><p id="99ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.2.1“弱形式”或“协方差”平稳性:</strong></p><p id="758e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)常数μ</p><p id="7ca5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)常数σ</p><p id="eecf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3) Cov(x_n，x_{n+k}) = Cov(x_m，x_{m+k})(相同长度的周期之间的协方差相同。)</p><p id="5a9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.2.2“严格的”平稳性:</strong></p><p id="fa37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">严格平稳性更具限制性，因为它要求相同长度的两个周期之间具有相同的分布。实际上，我们经常称弱形式平稳性为严格形式平稳性，因为严格形式平稳性很少被观察到。</p><p id="d33a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.2.3其他可观察到的静止性状:</strong></p><p id="4817" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)平稳时间序列中的观测值不依赖于时间。</p><p id="bbe3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)它们没有趋势或季节效应。</p><p id="3eec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.2.4静止的视觉示例</strong></p><p id="ae98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">平稳性的概念可能有点滑，有时候直观地看剧情是有帮助的。为了确定这一点，一个平稳的时间序列可能如下图所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lj"><img src="../Images/315ffc30b37698678a7ed5838889176a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j_T5xEVtxNgn4rid.png"/></div></div></figure><p id="3a82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，幅度和平均值不随时间变化。价值不会随着时间的推移而增加(趋势)，价值与时间无关，也没有像我们的商店销售那样的季节性模式。</p><p id="101e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.2.5我们为什么关心文具？</strong></p><p id="e94b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)稳定性；平稳时间序列在一段时间内具有稳定的统计特性。</p><p id="bd6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)统计建模方法，如ARIMA(我们将在后面谈到)假设或要求时间序列是平稳的才有效。</p><p id="ca1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3)我们感兴趣的是模拟时间步长之间的相对差异，而不是绝对值。例如:我们希望模型按照一种模式学习上涨或下跌的百分比，而不是在某个时间学习1，200的值。</p><p id="2927" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.2.6我们如何使我们的时间序列平稳？</strong></p><ol class=""><li id="5c4a" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">对数变换或平方根变换是两种流行的选择，特别是在方差随时间变化的情况下。</li><li id="5932" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">当我们有时间序列数据显示趋势时，最流行的选择是差分。我们可以用减法求差(积分)</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ly"><img src="../Images/182105bf0ec07950cfae7c86a28fe749.png" data-original-src="https://miro.medium.com/v2/resize:fit:42/format:webp/0*XBQSmrsJ26Z1Nk-L.png"/></div></figure><ol class=""><li id="0c63" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">从</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lz"><img src="../Images/14694ead876f834934db888c9be5aa16.png" data-original-src="https://miro.medium.com/v2/resize:fit:30/format:webp/0*N8cteWPb50Lq8cZp.png"/></div></figure><ol class=""><li id="f6cb" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">让它保持平稳。回忆一下上面的时间序列图:</li></ol><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="a1f5" class="ku jn hi kq b fi kv kw l kx ky">monthly_sales_df.plot(figsize=(10, 3)) plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/67158bd21bc0e02b26b64b9c95658685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x1gkMN9iwLUQqWsn.png"/></div></div></figure><p id="a51c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用Panda的diff()来快速执行差分。在[20]中:</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="2281" class="ku jn hi kq b fi kv kw l kx ky">diff_monthly_sales_df = monthly_sales_df.diff() diff_monthly_sales_df.plot(figsize=(10, 3)) plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/6cb9eeaf652cce8e1e535da0b1d3ef81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qqU96BUICFe89iQz.png"/></div></div></figure><p id="6a62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.2.7平稳性测试</strong></p><p id="7e20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检验平稳性，我们可以使用统计检验，即扩展的Dickey-Fuller(ADF)检验，其中检验的零假设是时间序列不是平稳的(具有一些依赖于时间的结构)。另一个假设是时间序列是平稳的。换句话说，如果你的时间序列确实是平稳的，你应该得到一个p值&lt;=0.05 (95% confidence interval, significance level(α) of 0.05) which suggets us to reject the null hypothesis.</p><p id="21a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Here’s an example using the statsmodels library.</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="8513" class="ku jn hi kq b fi kv kw l kx ky">adfuller(monthly_sales_df.Sales.values)</span><span id="7dd7" class="ku jn hi kq b fi lf kw l kx ky">(-5.19107018733927,<br/>9.168756655665654e-06,<br/>10,<br/>37,<br/>{'1%': -3.6209175221605827,<br/>'5%': -2.9435394610388332,<br/>'10%': -2.6104002410518627},<br/>521.9616303121272)</span></pre><p id="5221" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">The first line is the test statistic which we could use to compare against certain critical value in the Dicker-Fuller table to determine statistical significant.</p><p id="c3c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Conveniently, it also provide us the critical values of several common levels of significance(1, 5 and 10%), from the DF table.</p><p id="4b16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">In this case, we could see that the test statistic is smaller than not just 5% but also all levels of significant. Therefore, we can confidently reject the null hypothesis and <strong class="ih hj">假设这个时间序列是平稳的。</strong></p><p id="b57e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，我们可以在第二行简单地使用与检验统计量相关的p值。这非常方便，因为您可以快速与1%(0.01)、5%(0.05)或10%(0.10)的置信水平进行比较，以确定统计显著性。</p><p id="f71b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三行(10)指的是滞后的数量，我们可以说有一些自相关可以追溯到10个周期。</p><p id="2c32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，第四行(37)简单地表达了观察的数量。</p><h1 id="3596" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">4.3描述模式—白噪声</h1><p id="dd37" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">平稳性的一个相关主题是“白噪声”，这是一种数据不遵循某种模式的时间序列。如果我们不能利用过去的模式来推断未来的模式，那么它是不可预测的！因此，在我们考虑建模之前，最好先检查一下白噪声模式。</p><p id="b725" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何识别白噪音？<strong class="ih hj">这些是定义:</strong></p><p id="f7f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)常数μ为0</p><p id="1825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)常数σ</p><p id="15b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3)无(零)自相关(过去和现在的值之间没有关系)</p><p id="e019" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们很快会谈到自相关，但它基本上是时间序列和过去版本之间的相关量。</p><p id="4d52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.3.1白噪声的视觉示例</strong></p><p id="b98f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，为了确定这一点，白噪音在图中是这样的。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="6703" class="ku jn hi kq b fi kv kw l kx ky">rcParams['figure.figsize'] = 15, 5 random_white_noise = np.random.normal(loc=3, scale=2, size=1000) plt.plot(random_white_noise) plt.title('White noise time series') plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/d03da2658ca3fb2635fe20ee9b3ccefb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F13nTYPA74K6Y_zl.png"/></div></div></figure><p id="cc79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，这些值通常分布在平均值3附近(大多数值形成在3附近),并且震级大多保持在2个单位以内。</p><p id="af41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最重要的是，它表现得很零散；过去和未来的价值之间没有相关性，所以我们不可能用过去的模式来预测未来的价值。</p><p id="6381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.3.2我们为什么关心白噪声？</strong></p><p id="323e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)如果你的时间序列是白噪声，<strong class="ih hj">无法建模。</strong></p><p id="9107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)时间序列模型的残差应该是白噪声。这意味着时间序列中的所有信号都被模型利用来进行预测。剩下的只是无法建模的随机波动。</p><p id="749b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.3.3白噪声与静态噪声</strong></p><p id="64a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你认为白噪音听起来像刚刚通过的平稳，你是对的！请注意，虽然白噪声时间序列是平稳的，但并不是每个平稳的时间序列都是白噪声。</p><p id="a005" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.3.4建模白噪声</strong></p><p id="f05c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我开始学习这些概念时，令我困惑的一件事是平稳性是对特定时间序列建模的先决条件，但如果白噪声也是平稳的，为什么我们不能对白噪声建模？</p><p id="52a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准确地说，我在想:白噪声=平稳=可以建模？</p><p id="c8f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一种思考方式:记住，我们对原始时间序列进行差分，使其平稳。这种差异行为有效地消除/减少了趋势和季节性，试图稳定时间序列的平均值。我们可以多次(顺序)对其进行差分，直到所有的时间相关性都被移除。</p><p id="f13e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果没有信号留下，订单的数量实际上可以用于建模具有线性趋势和季节性的时间序列。</p><p id="0297" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有一些信号留下，它可能仍然基本上是稳定的，剩余的信号可能有一些自相关。然后我们可以继续对这个自相关信号进行建模。</p><p id="1567" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍后我们将通过一个端到端的例子看到一个更清晰的画面。</p><h1 id="f1f1" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">4.4描述模式—随机漫步</h1><p id="0988" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们要讨论的最后一个重要的时间序列模式是“随机游走”，这是一种特殊类型的时间序列，其中值往往会随着时间的推移而存在，周期之间的差异只是白噪声(随机)。换句话说，今天的价格等于昨天的价格和一些白噪声的残差</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ma"><img src="../Images/580a041f25cee559f0b5de01ba27cd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:208/format:webp/0*n9SNWVqcH4nPsZ-P.png"/></div></figure><p id="27ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在哪里</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mb"><img src="../Images/0dc9c42266ff7b595044ff11c924a82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:232/format:webp/0*RyxC7_oA9XkM-wi6.png"/></div></figure><p id="742e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.4.1随机行走的视觉示例</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/4b2535214e763dcc85487a0552c5ea40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5PX1lqrKkJQWSU3o.png"/></div></div></figure><p id="9025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，它与我们刚刚谈到的白噪声非常不同。事实上，它看起来像一系列的股票或指数价格，其中它展示了一些模式。这是因为序列本身不是随机的，尽管差异是随机的。</p><p id="392c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随机游走源于金融，基于金融理论，即股票市场价格是随机游走，无法预测。然而值得一提的是，这个<a class="ae jl" href="https://en.wikipedia.org/wiki/Random_walk_hypothesis" rel="noopener ugc nofollow" target="_blank">的说法是有争议的。</a></p><p id="0bd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到定义上来:我们肯定可以看到连续时间段之间的微小变化，或者换句话说，P_t值依赖于P_t-1</p><p id="b6e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免我在开始学习我们所学的概念时产生的一些困惑，这里有一些不同之处。</p><p id="2be4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.4.2随机行走vs静止</strong></p><p id="ebc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随机游走是一个非平稳过程，因为我们可以看到它极大地违反了平稳的假设。平稳时间序列的值不是时间的函数。另一方面，随机漫步中的观察依赖于时间。</p><p id="3143" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.4.3随机游走vs白噪声</strong></p><p id="3a86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不一样；白噪声就像一个随机数序列。虽然随机游走值可以表现为随机的，但是序列中的下一个值(P_t+1)总是前一个值(P_t)的修改。有一个潜在的过程，从一步到一步产生一些一致性，而不是吐出随机数。这就是为什么随机漫步也被称为“醉鬼漫步”。</p><p id="09fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4.4.4我们为什么关心随机漫步？</strong></p><p id="7060" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有一个随机游走的时间序列，<strong class="ih hj">那么它就不能被熟练地预测。</strong>这仅仅是因为下一个时间步长是前一个时间步长的函数，并且这种模型提供了简单的预测。我们把这样的模型称为“持久性模型”。</p><p id="5be5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们做一个小实验，生成一个随机行走的时间序列，并将数据集分成训练集和测试集。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/c43e96983326f6a3a2e8e087855cf472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uMvww8a7iE7PTBSV.png"/></div></div></figure><p id="13de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用持久性模型，使用滚动预测方法来预测结果，并计算从测试集中收集的所有预测的MSE。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="bd3c" class="ku jn hi kq b fi kv kw l kx ky">Persistence MSE: 1.000</span></pre><p id="df40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然，由于观测值是通过生成-1或+1的先前值构建的，因此计算“预测”的MSE也将是1。</p><p id="197c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果我们说我们知道过程的方差，然后我们可以在生成值时加入一点方差，会发生什么呢？</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="5882" class="ku jn hi kq b fi kv kw l kx ky">Persistence MSE: 1.976</span></pre><p id="2cfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果表现更差。如果你不相信的话，我们可以以后用更复杂的模型进行更多的实验。那么，它将走向何方？有两个要点:</p><p id="7519" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)随机行走的最佳模型/预测器至多是持久性模型。</p><p id="2da8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)在您使用复杂的时间序列建模技术之前，持久性模型可以是一个基线模型。如果你的最终模型的性能(技能)不能打败一个持久性模型，这也意味着我们最好只把以前的值作为预测。哎哟！</p><p id="1e25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何处理一个可疑的随机游走时间序列？</p><p id="7615" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设大部分时间序列都是随机游走的，我们可以<strong class="ih hj">尝试</strong>来模拟一阶差分，而不是原始值。还记得我们在开始建模之前，在平稳部分讨论差分时间序列使其平稳。然而，如果使其稳定仍然显示数据中没有明显的可学习的结构，那么它就不能被预测。</p><h1 id="00a9" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">5.建模— ARIMA模型</h1><p id="d8da" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">最后，随着一些重要的概念的方式，我们可以开始看看建模时间序列！</p><p id="717a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ARIMA及其变体(ARMA，ARMAX，SARIMA)是几乎所有时间序列文献的经典模型。ARIMA是一种传统的时间序列模型，用于模拟时间序列的自回归(AR)和移动平均(MA)特性。对于具有季节性的时间序列，就像我们上面讨论的，我们可以使用季节性ARIMA (SARIMA)来模拟这种过程。让我们看看最简单的ARMA模型的构建模块和假设。</p><h1 id="fe5d" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">5.1自回归(AR)</h1><p id="bee7" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">在时间序列中，过去的值和现在的值之间通常有关系。例如，我们可以根据昨天的销售额，或者7天前的销售额，对今天的销售额进行合理的猜测。因此，我们使用<strong class="ih hj">自相关</strong>，它是一个序列本身之间的相关性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/495e4d147958dedcda593ca149afa949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M6rUosMmNb5joHse.jpg"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/95a2c7e1439722adbbf289bcc2305a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1yG_zeZ_3Edvxrnq.jpg"/></div></div></figure><p id="a5b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，上图说明了当前系列与其滞后版本(t-1，滞后1)之间的相关性。滞后值的频率可以是几天、几周或几个月。</p><p id="de4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ARIMA利用了时间序列的这种AR性质并对其建模。我们可以将此描述为一个线性模型，它依赖于过去周期值的总和乘以一个常数(系数)来预测当前周期值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/d69348e9c0a7970bd2211b593216a3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oW-Je5esFOWAS5a4.png"/></div></div></figure><p id="02e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很可能我们在ARIMA模型中使用的滞后值越多，它就能模拟更复杂的关系和相互作用。因此，我们不仅经常使用滞后值1: AR(1)，而且还使用更进一步的滞后值:AR(2)，AR(3)，等等。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/0297f310ad4a99c3fc2d531d376cec13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aUR79dAc3UtD5Ym3.png"/></div></div></figure><p id="db14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，当我们包括更多的系数时，它们中的一些更有可能是不重要的(不同于零)，就像任何机器学习或神经网络模型一样，更多的参数可能会导致过度拟合。</p><p id="9038" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自相关函数</strong></p><p id="ec7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以想象，同时计算不同滞后的自相关非常有用:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/10f30dcadc9c74494eaf775d3a01a770.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/0*vwHOiee9wjGjiMXz.png"/></div></figure><p id="9086" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顶部实质上是原始数据和k单位滞后数据之间的协方差。底部是原始数据集偏差的平方和。</p><p id="cd27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是ACF背后的主要思想。我们可以手动计算，也可以简单地使用statsmodels库中的plot_acf()函数。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="875f" class="ku jn hi kq b fi kv kw l kx ky">rcParams['figure.figsize'] = 8, 3 tsaplots.plot_acf(monthly_sales_df.Sales.values, zero=True) plt.plot()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/26cce2a8948ea400558dd3b6dd3ce1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1zVWV1EF0jBIQnjT.png"/></div></div></figure><p id="8c13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然，我们可以看到时间序列与其滞后值0(滞后=0，基本上是其本身)具有最高的相关性。更有趣的是，我们可以在滞后12秒时看到显著的相关性。这很有道理，也很好地表明了季节性；这个月的销售额与12个月前高度相关。</p><p id="a11f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ACF和密切相关的PACF图是传统时间序列分析中根深蒂固的概念，它们可以在正式课堂上教授半天，所以我们现在跳过这个…</p><h1 id="2b41" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">5.2移动平均线(MA)</h1><p id="2f33" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">AR模型有一个问题:因为现值依赖于过去的值，所以无法可靠地预测价值的不可预测的突然增加(冲击)。一个想法是引入一个额外的分量(MA ),它考虑了过去的残差，以自动校正并对预测进行调整。数学上，它看起来像这样:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/62149eaeb6d75917f6b7f52760ddd140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tjm9z9F5owYd2eiV.png"/></div></div></figure><p id="1f68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样的一组成分(AR和MA)也可以应用于季节性，只是增加了一项。</p><h1 id="eeea" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">5.3整合(一)</h1><p id="c00c" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">这是指我们需要积分(差分)时间序列的次数，以确保ARIMA假设的平稳性。</p><p id="6094" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回想一下，如果您手头有一个非平稳的时间序列，我们可以通过差分将时间序列转换为平稳的过程，以便它符合假设。</p><p id="a1ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在金融学中，一种常见的方法是简单地使用回报率，即两个连续时期的价值之间的变化百分比，而不是价格。在pandas中，我们可以简单地使用“pct_change()”函数来完成。</p><p id="49e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">符号</strong></p><p id="6389" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们经常用p、d、q参数来表示ARIMA模型，这些参数分别指AR、I和MA的阶数。接下来，我们将使用这种符号。</p><p id="f8bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些概念听起来可能很抽象，但在我们开始将时间序列与ARIMA模型相适应后，这些概念就变得有意义了。在我们开始建模之前，我们必须触及的最后一件事是，我们应该如何着手评估模型。</p><h1 id="5590" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">6.模型选择和数据泄漏</h1><p id="9870" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">虽然模型选择策略类似于一般建模，即您将数据集分为训练和验证/测试，并在训练中拟合模型，同时根据其验证分割的性能选择模型，但时间序列则更为复杂。</p><p id="1357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为我们需要确保我们没有把未来的信息泄露给过去。这可能在普通的预处理技术(如指数平滑)中悄悄发生。在处理时间序列时，使用通常的方法(来自Scikit-Learn的train_test_split)将数据随机分成训练集和测试集是错误的。例如，这将导致利用2015年的数据对2014年进行预测。</p><p id="9735" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个简单的解决方案是将时间序列数据分成2个日期范围窗口。例如，我们可以使用2014年1月到2016年12月的时间序列进行训练，使用2017年的时间序列进行验证。</p><p id="4b41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您非常喜欢交叉验证(CV)方法，您可以向前滚动培训、验证和测试窗口，一次利用所有数据:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es md"><img src="../Images/2a172bf1896525c1a4b5ea107c879386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jR40zKdydnkjQ-BQ.png"/></div></div></figure><p id="5a89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，您也可以移动培训窗口，而不是将其展开，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/3a0922586d4c2c6eeda1d310f0c5b4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wu5B_7l-rcI-6WYS.png"/></div></div></figure><p id="bb6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为简单起见，我们将使用本笔记本中的简单解决方案来拆分数据。</p><h1 id="6428" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">7.高效拟合ARIMA模型</h1><p id="4c0c" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">传统的方法是依次增加系数，查看系数的统计显著性，比较对数似然，当模型未能改善时停止增加。一种更有效的方法是使用<strong class="ih hj"> AutoARIMA </strong>或几个嵌套循环(<strong class="ih hj">网格搜索</strong>)来找到最佳的参数集，为我们的模型产生最佳的Akaike信息标准(AIC)。</p><p id="da34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型的AIC等于AIC = 2k-2lnL其中k是模型的参数个数，L是该函数的最大似然值。通常，我们希望降低模型的复杂性(即降低k ),同时增加模型的似然性/拟合优度(即L)。因此，我们更喜欢AIC值较小的模型，而不是AIC值较大的模型。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="9164" class="ku jn hi kq b fi kv kw l kx ky">p = d = q = range(0, 3) pdq = list(itertools.product(p, d, q)) seasonal_pdq = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]</span></pre><p id="13fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还记得我们拥有4年的数据吗？我们可以将其中的前3年作为“训练数据”，后1年作为“验证集”。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="d47a" class="ku jn hi kq b fi kv kw l kx ky">train_monthly_sales_df = monthly_sales_df[:-12] valid_monthly_sales_df = monthly_sales_df[-12:] #Just to make sure there's no data leakage... train_monthly_sales_df.tail(3) valid_monthly_sales_df.head(3)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es me"><img src="../Images/4bf92cc7047a33a6943b156c4efa4ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/0*UM3aGiG08kxpns-Y.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mf"><img src="../Images/d9e6d9ee68f54532a411b773a19dc48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/0*pHAM-PDJ4hqZqj6e.png"/></div></figure><h1 id="cb40" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">7.1网格搜索</h1><p id="c56f" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">使用良好的循环运行GridSearch。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="209a" class="ku jn hi kq b fi kv kw l kx ky">bestAIC = np.inf<br/>bestModel = None<br/>for param in pdq:<br/>    print('param:',param)<br/>    try:<br/>        mod = sm.tsa.statespace.SARIMAX(train_monthly_sales_df,<br/>                                        order=param,<br/>                                        enforce_stationarity=False,<br/>                                        enforce_invertibility=False,<br/>                                       trend='c')<br/>        results = mod.fit()<br/>        print('ARIMA{} - AIC:{}'.format(param, results.aic))<br/>        if results.aic &lt; bestAIC:<br/>            bestAIC = results.aic<br/>            bestModel = results<br/>            print('****BEST****')<br/>    except:<br/>        continue</span><span id="0506" class="ku jn hi kq b fi lf kw l kx ky">…<br/>param: (0, 2, 0)<br/>ARIMA(0, 2, 0) — AIC:524.1351010222072<br/>param: (0, 2, 1)<br/>ARIMA(0, 2, 1) — AIC:478.17920833300695<br/>param: (0, 2, 2)<br/>ARIMA(0, 2, 2) — AIC:457.24955345064654<br/>****BEST****<br/>…</span><span id="cd0f" class="ku jn hi kq b fi lf kw l kx ky">bestModel.summary()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/c92d07face35a2ce1eb75e207e770b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0pXdTqzQvJfnSH0J.png"/></div></div></figure><p id="53d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GridSearch方法揭示了<strong class="ih hj"> ARIMA(0，2，2) </strong>具有最低的AIC，因此是最好的模型！</p><h1 id="28c2" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">7.2自动ARIMA</h1><p id="4710" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">AutoARIMA是一种逐步搜索p、d、q参数的多种组合并选择具有最小AIC的最佳模型的方法。最初的包是R版本，但幸运的是，现在可以在pmdarima库中用Python获得它。</p><p id="5e17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">auto.arima()函数将在估计前进行差分，以确保估计值的一致性。回归系数和ARIMA模型的估计是使用最大似然法同时完成的。</p><p id="8c3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回想一下，ARIMA假设是平稳的，所以我们将使用这个时间序列，我们已经把我们的时间序列差了1阶。第一个值是NA，所以我们应该从第二个索引开始。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="4818" class="ku jn hi kq b fi kv kw l kx ky">auto_model = auto_arima(train_monthly_sales_df,start_p=1, start_q=1,<br/>                      test='adf',       # use adftest to find optimal 'd'<br/>                      max_p=3, max_q=3, # maximum p and q<br/>                      m=1,              # frequency of series<br/>                      d=None,           # let model determine 'd'<br/>                      seasonal=False,   # No Seasonality<br/>                      start_P=0, <br/>                      D=0, <br/>                      trace=True,<br/>                      error_action='ignore',  <br/>                      suppress_warnings=True, <br/>                      stepwise=True)</span><span id="b39c" class="ku jn hi kq b fi lf kw l kx ky">...<br/>Fit ARIMA: order=(2, 2, 0) seasonal_order=(0, 0, 0, 0); AIC=512.450, BIC=518.556, Fit time=0.012 seconds<br/>Fit ARIMA: order=(2, 2, 2) seasonal_order=(0, 0, 0, 0); AIC=505.208, BIC=514.366, Fit time=0.110 seconds<br/>Near non-invertible roots for order (2, 2, 2)(0, 0, 0, 0); setting score to inf (at least one inverse root too close to the border of the unit circle: 1.000)<br/>Total fit time: 0.490 seconds</span></pre><p id="54e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AutoARIMA确定ARIMA(0，2，2)模型具有最佳结果，这与我们的网格搜索方法相一致！请注意，系数非常接近，尽管并不精确。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="d671" class="ku jn hi kq b fi kv kw l kx ky">auto_model.summary()</span></pre><h1 id="98b8" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">8.验证模型</h1><p id="9c23" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们应该绘制模型诊断图，以检查模型是否有效。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="e4ac" class="ku jn hi kq b fi kv kw l kx ky">auto_model.plot_diagnostics(figsize=(14, 8)) plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/f9ab922b40c502e09c9e9406eacb9d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fgxEzZJkhwnjKu4w.png"/></div></div></figure><p id="b662" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">残差接近正态分布(左下角)是一个好迹象。虽然不完美；标准化残差显示，还有一些信号尚未建模。相关图看起来很好；自相关在界限内。</p><h1 id="cdd6" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">9.用ARIMA预测</h1><p id="af73" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">使用最佳模型，让我们尝试预测1年期间的值，看看它有多准确。</p><p id="fdf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些技术提示:我们可以使用get_prediction()和get_forecast()函数进行预测。最初让我困惑的一件事是它们之间的区别。注意get_prediction()和get_forecast()其实是一样的。后者旨在根据最近可用的数据进行一步样本外预测，或执行多步样本外预测，该预测由“步骤”参数进行参数化。</p><p id="56c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:ts_model.forecast(步骤=12)</p><p id="aee2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">predict()更加灵活，您只需提供开始和结束日期，可以跨越样本内和样本外。如果你不提供结束日期，它只会做一个样本内预测。</p><p id="8bdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:ts _ model . get _ prediction(start = PD . to _ datetime(' 2014–01–01 ')，end = PD . to _ datetime(' 2017–12–01 ')，dynamic=False)</p><h1 id="7863" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">9.1生成预测</h1><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="b6bc" class="ku jn hi kq b fi kv kw l kx ky">#autoarima<br/>auto_oos_forecasts, auto_oos_forecasts_ci = auto_model.predict(n_periods = 12, return_conf_int=True)<br/>#turn it into series so that we could plot easily...<br/>auto_oos_forecasts = pd.Series(auto_oos_forecasts, index=valid_monthly_sales_df.index)</span><span id="ee42" class="ku jn hi kq b fi lf kw l kx ky">#gridsearch<br/>#in-sample forecasts<br/>is_forecasts = bestModel.get_prediction(start=pd.to_datetime('2014-01-01'),dynamic=False)<br/>#out-of-sample forecasts<br/>oos_forecasts = bestModel.get_prediction(start=pd.to_datetime('2017-01-01'), end=pd.to_datetime('2017-12-01'),dynamic=False)</span><span id="165d" class="ku jn hi kq b fi lf kw l kx ky">#forecasted values stored in is_forecasts.predicted_mean<br/>#conf_int contains the confidence intervals<br/>is_forecasts_ci = is_forecasts.conf_int()<br/>oos_forecasts_ci = oos_forecasts.conf_int()</span></pre><h1 id="379e" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">9.2可视化预测</h1><p id="dd38" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">最后，我们可以看到模型的预测值与实际观察值之间的差异。由于模型也提供了95%的预测区间，我们也将它们包含在图中，以便更好地了解上限值和下限值。为了严谨起见，我们将显示通过GridSearch方法和AutoARIMA选择的两个模型的预测。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="7e66" class="ku jn hi kq b fi kv kw l kx ky">ax = monthly_sales_df.plot(label='observed')<br/>is_forecasts.predicted_mean.plot(ax=ax, label='In-sample forecast(GridSearch)', alpha=.7, figsize=(14, 7))<br/>oos_forecasts.predicted_mean.plot(ax=ax, label='Out-of-sample forecast(GridSearch)', alpha=.7, figsize=(14, 7))<br/>auto_oos_forecasts.plot(ax=ax, label='Out-of-sample forecast(AutoARIMA)', alpha=.7, figsize=(14, 7))<br/>ax.fill_between(is_forecasts_ci.index,<br/>               is_forecasts_ci.iloc[:, 0],<br/>               is_forecasts_ci.iloc[:, 1], color='k', alpha=.2)<br/>ax.fill_between(oos_forecasts_ci.index,<br/>               oos_forecasts_ci.iloc[:, 0],<br/>               oos_forecasts_ci.iloc[:, 1], color='k', alpha=.2)<br/>ax.set_xlabel('Date')<br/>ax.set_ylabel('Sales')<br/>plt.title('Sales Predictions vs Actual')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/f3c9433f8533d37852e17b70b0ecc06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XNOS1pLToKZaBNfx.png"/></div></div></figure><p id="edc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一些观察结果:</p><p id="65ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)模型产生了相当不错的样本内预测(显然),但样本外预测看起来像一条恒定的线，尽管它大体上在正确的方向上。</p><p id="0dce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)随着预测的深入，预测区间增大，表现出不确定性。每个时间步的预测都有一些变化，这些变化是作为步数的函数累积的。</p><h1 id="a2e8" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">9.3定量评估</h1><p id="9af1" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">评估准确性和比较模型的定量方法是使用RMSE和MSE等度量，这些度量基本上衡量实际值和预测值之间的差异。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="0f97" class="ku jn hi kq b fi kv kw l kx ky">y_forecasted = oos_forecasts.predicted_mean<br/>y_truth = monthly_sales_df['2017-01-01':]<br/>mse = ((y_forecasted - y_truth.iloc[:,0]) ** 2).mean()<br/>print('The Mean Squared Error of our forecasts is {}'.format(round(mse, 2)))<br/>print('The Root Mean Squared Error of our forecasts is {}'.format(round(np.sqrt(mse), 2)))</span><span id="4100" class="ku jn hi kq b fi lf kw l kx ky">The Mean Squared Error of our forecasts is 454280.48<br/>The Root Mean Squared Error of our forecasts is 674.0</span></pre><p id="4341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它告诉我们，我们的模型能够在实际销售额的674.0范围内预测测试集中的平均日销售额。由于我们每天的销售额从大约400英镑到超过1200英镑不等，误差的方差相当高，如果没有模型，我们甚至可以做得更好。</p><h1 id="8bde" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">10.季节性——萨里玛</h1><p id="e196" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">请注意，我们上面的图没有利用我们之前发现的季节模式。事实证明，我们可以在ARIMA模型中加入季节(S)成分，通过对季节周期重复相同的AR、MA、I成分，我们称之为<strong class="ih hj"> SARIMA </strong>。</p><p id="4711" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们想要捕获前一个节日期间(12个月前)，我们可以包括添加一个phi(ϕ参数和一个保存该值的季节术语，或者甚至是前两个期间(24)。这实际上非常类似于一个月前的原始ar术语。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/9d35219c3785f1a366f6fb1d35f01f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xNmrGIQxTXkEaiDn.png"/></div></div></figure><p id="988e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同时，我们还添加了一个额外的括号，其中包含了用符号表示的季节性订单:SARIMA(p，D，q)(P，D，Q，s)</p><p id="fccd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">季节性AR、I、MA顺序用大写字母表示,“s”表示周期的长度。如果s=1，意味着没有季节性。假设时间序列的频率是每月一次，我们可以用s=12来表示每年的季节性。</p><p id="c5e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果我们有:萨里玛(1，0，2)(2，0，1，12)</p><p id="b525" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">含义:忽略第一个括号，第二个括号中的前三个订单只是ARIMA订单的季节性变化。我们包括12和24个周期之前的滞后值。直觉上，我们对每个“s”值都感兴趣。</p><p id="f16f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从形式上看，它是这样的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/90cff527f19d59f778b8efe8cb1028f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vmbV6i9jtB6XHGgc.png"/></div></div></figure><h1 id="8d82" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">10.1自动季节性</h1><p id="e054" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们使用与上面相同的方法，除了一些参数变化来激活季节性参数空间中的搜索。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="a147" class="ku jn hi kq b fi kv kw l kx ky">auto_sea_model = auto_arima(train_monthly_sales_df, start_p=1, start_q=1,<br/>                      test='adf',       # use adftest to find optimal 'd'<br/>                      max_p=3, max_q=3, # maximum p and q<br/>                      m=12,              # frequency of series<br/>                      d=None,           # let model determine 'd'<br/>                      seasonal=True,   # No Seasonality<br/>                      start_P=0, <br/>                      D=None, <br/>                      trace=True,<br/>                      error_action='ignore',  <br/>                      suppress_warnings=True, <br/>                      stepwise=True)</span><span id="e3fe" class="ku jn hi kq b fi lf kw l kx ky">auto_sea_model.summary()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mg"><img src="../Images/b86be6a94e9d9e907acf03d22f8b5a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EobeSf-k-Vadifo7.png"/></div></div></figure><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="74be" class="ku jn hi kq b fi kv kw l kx ky">#autoarima<br/>#technical note: the predict() for autoarima lib is different from statsmodel's arima<br/>auto_sea_is_forecasts, auto_sea_is_forecasts_ci = auto_sea_model.predict_in_sample(return_conf_int=True)<br/>auto_sea_is_forecasts = pd.Series(auto_sea_is_forecasts, index=train_monthly_sales_df.index)<br/>auto_sea_is_forecasts_ci = pd.DataFrame(auto_sea_is_forecasts_ci,index=train_monthly_sales_df.index)</span><span id="ff6f" class="ku jn hi kq b fi lf kw l kx ky">auto_sea_oos_forecasts, auto_sea_oos_forecasts_ci = auto_sea_model.predict(n_periods = 12, return_conf_int=True)<br/>#turn it into series so that we could plot easily...<br/>auto_sea_oos_forecasts = pd.Series(auto_sea_oos_forecasts, index=valid_monthly_sales_df.index)<br/>auto_sea_oos_forecasts_ci = pd.DataFrame(auto_sea_oos_forecasts_ci,index=valid_monthly_sales_df.index)</span></pre><h1 id="973f" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">10.2可视化预测</h1><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="0cbb" class="ku jn hi kq b fi kv kw l kx ky">ax = monthly_sales_df.plot(label='observed')<br/>auto_sea_is_forecasts.plot(ax=ax, label='In-sample forecast(AutoARIMA-Seasonal)', alpha=.7, figsize=(14, 7))<br/>auto_sea_oos_forecasts.plot(ax=ax, label='Out-of-sample forecast(AutoARIMA-Seasonal)', alpha=.7, figsize=(14, 7))<br/>ax.fill_between(auto_sea_is_forecasts_ci.index,<br/>               auto_sea_is_forecasts_ci.iloc[:, 0],<br/>               auto_sea_is_forecasts_ci.iloc[:, 1], color='k', alpha=.2)<br/>ax.fill_between(auto_sea_oos_forecasts_ci.index,<br/>               auto_sea_oos_forecasts_ci.iloc[:, 0],<br/>               auto_sea_oos_forecasts_ci.iloc[:, 1], color='k', alpha=.2)<br/>ax.set_xlabel('Date')<br/>ax.set_ylabel('Sales')<br/>plt.title('Sales Predictions vs Actual')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/b6c19b63c0fba5bca13f6e92a5b2325c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ELh1nv2K7jExW-Ls.png"/></div></div></figure><p id="9b53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与之前的尝试相比，季节模型很好地捕捉了季节性，包括样本内和样本外预测。</p><h1 id="ba01" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">10.3定量评估</h1><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="56c4" class="ku jn hi kq b fi kv kw l kx ky">y_forecasted = auto_sea_oos_forecasts.values<br/>y_truth = monthly_sales_df['2017-01-01':]<br/>mse = ((y_forecasted - y_truth.iloc[:,0]) ** 2).mean()<br/>print('The Mean Squared Error of our forecasts is {}'.format(round(mse, 2)))<br/>print('The Root Mean Squared Error of our forecasts is {}'.format(round(np.sqrt(mse), 2)))</span><span id="45a5" class="ku jn hi kq b fi lf kw l kx ky">The Mean Squared Error of our forecasts is 89577.16 <br/>The Root Mean Squared Error of our forecasts is 299.29</span></pre><p id="38b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RMSE从674.0降到了299.29！</p><p id="c997" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们经历了一个分析和拟合SARIMA模型的端到端过程。在下一篇文章中，我们将着眼于使用机器学习模型进行时间序列预测，看看我们是否能得到更好的结果。此外，我们还将讨论一些实际挑战，例如更高频率的预测(每天一次或每天一次)。</p><p id="b43e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经删除了一些代码和乳胶由于格式化；看完整代码<a class="ae jl" href="https://github.com/wyseow/timeseries" rel="noopener ugc nofollow" target="_blank">这里@ Github </a>或者<a class="ae jl" href="http://datageeko.com/time-series-from-arima-to-deep-learning-part-1/" rel="noopener ugc nofollow" target="_blank">我的博客post@DataGeeko.com</a>。感谢您的阅读。</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><p id="78c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="li">原载于</em><a class="ae jl" href="http://datageeko.com/time-series-from-arima-to-deep-learning-part-1/" rel="noopener ugc nofollow" target="_blank"><em class="li">http://datageeko.com</em></a><em class="li">。</em></p></div></div>    
</body>
</html>