<html>
<head>
<title>A beginner’s guide to learning R with the Titanic dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用泰坦尼克号数据集学习R的初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-beginners-guide-to-learning-r-with-the-titanic-dataset-a630bc5495a8?source=collection_archive---------1-----------------------#2019-11-03">https://medium.com/analytics-vidhya/a-beginners-guide-to-learning-r-with-the-titanic-dataset-a630bc5495a8?source=collection_archive---------1-----------------------#2019-11-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9acb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个初学者的学习指南，我假设你有一些机器学习的基础知识。</p><p id="b618" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近因为课程要求，开始学习R语言。我有一些用Python做ML的经验。因此，对于那些试图学习数据科学所需的R基础知识或想要过渡到R的人来说，这是一个快速入门指南。这个指南也将描述我学习和理解r的过程。所以让我们快速地开始吧！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7485c93494d726a305a2a8cc652bbf74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ae00Bjo8x3qx1YZGEIdWw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">皇家邮轮泰坦尼克号，由F.G.O .斯图亚特(1843-1923)设计</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="426a" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">安装R and R工作室</strong></h1><p id="0a94" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">这里可以安装<a class="ae ld" href="https://cran.rstudio.com/" rel="noopener ugc nofollow" target="_blank">的R，这里</a>可以安装<a class="ae ld" href="https://rstudio.com/products/rstudio/download/" rel="noopener ugc nofollow" target="_blank">的R Studio。</a></p><p id="70ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我会推荐使用<a class="ae ld" href="https://www.anaconda.com/distribution/" rel="noopener ugc nofollow" target="_blank"> Anaconda </a>来安装。如果您已经安装了Anaconda，那么您可以创建一个R环境并在该环境上安装R Studio。</p><p id="774c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打开Anaconda导航器。转到环境。创建新环境:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es le"><img src="../Images/850a473dd3d0e47045934e0fa13c60b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*1lCyeqo7ofBpwqPgRvTPGw.png"/></div></figure><p id="86ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建环境后，在Anaconda Navigator上转到home。在下拉列表中选择Applications on : r_env。</p><p id="d70e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你会看到一张R工作室的卡片。点击安装。安装成功后，启动R Studio。现在让我们从r开始。</p><h1 id="3c08" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">一些非常有用的R函数和信息</h1><blockquote class="lk ll lm"><p id="1545" class="if ig ln ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated">索引从r中的1开始。</p></blockquote><h2 id="80de" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">数据帧、矩阵、向量</h2><p id="62c2" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">与Python类似，数据框存储不同数据类型的值。矩阵存储相同数据类型的值。向量是一维数组。</p><h2 id="a30b" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">赋值运算符</h2><p id="2df5" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">你可以使用</p><h2 id="47c9" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">The c( ) function</h2><p id="ac24" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">The c() function is a very handy function used to create vectors (or 1-d array) or concatenate two or more vectors.</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="a03e" class="lr kb hi mg b fi mk ml l mm mn">myarray &lt;- c( 1, 2, 3.4, c(2, 4))</span></pre><h2 id="b4f5" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">The paste( ) function</h2><p id="eccc" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">The paste function is used to concatenate strings. It is useful for printing results with a message:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="36c6" class="lr kb hi mg b fi mk ml l mm mn">paste(“The dimensions of the data frame are “, paste (dim(data.frame), collapse = ‘, ‘))</span></pre><h2 id="b8cb" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">%&gt; %运算符</h2><p id="019b" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">%&gt;%用于创建管道。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="17d7" class="lr kb hi mg b fi mk ml l mm mn">argument %&gt;% function </span></pre><p id="bff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无非是</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="06ee" class="lr kb hi mg b fi mk ml l mm mn">function(argument)</span></pre><h2 id="58f1" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">访问行和列</h2><p id="f385" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">您可以使用' $ '访问数据框的列。使用以下命令访问名称列:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="0d7e" class="lr kb hi mg b fi mk ml l mm mn">data.frame$Name</span></pre><p id="7183" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">若要获取行和列的子集，请使用“:”。例如，为了获得第10至12行和第4至5列，</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="2865" class="lr kb hi mg b fi mk ml l mm mn">data.frame[10:12,4:5]</span></pre><p id="e4b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">若要访问不连续的行或列，请使用“c()”。例如，为了获得第1至5、7和11行以及第3至4和7列，</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="4537" class="lr kb hi mg b fi mk ml l mm mn">data.frame[c(1:5, 7, 11), c(3:4, 7)]</span></pre><h2 id="3903" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">访问满足特定条件的行</h2><p id="5160" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">为了获得Pclass列的值为1的行的第4到第6列，</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="7da3" class="lr kb hi mg b fi mk ml l mm mn">data.frame[data.frame$Pclass == 1, 4:6]</span></pre><p id="7b98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也可以通过使用，</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="d809" class="lr kb hi mg b fi mk ml l mm mn">subset(data.frame[,4:6], data.frame$Pclass==1)</span></pre><h2 id="8a61" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">行数</h2><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="9539" class="lr kb hi mg b fi mk ml l mm mn">number.of.rows = nrow(data.frame)</span></pre><h2 id="29e3" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">计算NA值</h2><p id="a2ad" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">NA值的数量可以使用is.na()和sum()函数来计算。如果值为na，则is.na()返回布尔值true，否则返回false。sum()，顾名思义，给出传递的值的总和。数据集中NA值的数量:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="a65b" class="lr kb hi mg b fi mk ml l mm mn">sum(is.na(data.frame))</span></pre><h2 id="ba49" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">删除列</h2><p id="b719" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">您可以使用以下方法删除列:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="9144" class="lr kb hi mg b fi mk ml l mm mn">data.frame$ColumnName &lt;- NULL</span></pre><h2 id="7d6d" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">删除行</h2><p id="2224" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">您可以使用以下命令删除第1、3和4行:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="4fd0" class="lr kb hi mg b fi mk ml l mm mn">data.frame &lt;- data.frame[-c(1,3,4)]</span></pre><h1 id="3949" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">这个圆点是怎么回事？</h1><p id="11a1" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">所以当我第一次看到R中的一些函数时，我认为它们的名字中包含了一个点，这是OOP风格。(点)运算符。后来在编码时，有很多这样的例子。(点)。我做了一些谷歌搜索，发现圆点只是(大部分)为了方便而使用。它不代表任何种类的运算符。但是，也有一些例外，更多细节可以在<a class="ae ld" href="https://stackoverflow.com/questions/7526467/what-does-the-dot-mean-in-r-personal-preference-naming-convention-or-more" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="bff8" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">1.加载泰坦尼克号数据集</h1><h2 id="0367" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">导入数据集</h2><p id="e4ee" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">数据集可以在这里获得【https://www.kaggle.com/c/titanic/data T2】</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mo"><img src="../Images/8b3b4bcfad92ec7b2a6ac0b5c9522d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*BtdaMuelAtGHWEAN2on2cQ.png"/></div></figure><p id="22a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在R Studio中导入数据集非常容易。您只需点击导入数据集按钮，选择要导入的文件或输入URL。</p><p id="8d6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还可以使用red.csv()函数加载数据集。这里我们传递了参数na.string= " "以便空值被读取为na值</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="2582" class="lr kb hi mg b fi mk ml l mm mn">data.frame = read.csv(“.../path_to_/train.csv”, na.strings = “”)</span></pre><h1 id="97af" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">2.安装软件包</h1><p id="bed6" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">这一步更通用，取决于您将需要的库。出于我们的目的，我们将需要以下库:</p><p id="dd94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">psych，GGally，dplyr，ggplot2，rpart，rpart.plot，Amelia</p><p id="26bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些包各自提供了什么将在后面讨论。您可以使用以下命令安装和加载这些软件包</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="3fc2" class="lr kb hi mg b fi mk ml l mm mn">install.packages(‘psych’)</span><span id="1e8e" class="lr kb hi mg b fi mp ml l mm mn">library(psych)</span></pre><h1 id="18b5" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">3.清理和准备数据集</h1><p id="3fbc" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">首先，让我们使用，</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="9350" class="lr kb hi mg b fi mk ml l mm mn">View(data.frame)</span></pre><p id="4d25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">凭第一直觉，我们发现列舱和年龄有许多NA值。所以让我们画一个缺失图，一个显示缺失值的图。为了绘制缺失图，我们需要加载Amelia库。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="de39" class="lr kb hi mg b fi mk ml l mm mn">library(Amelia)<br/>missmap(data.frame, col=c(“black”, “grey”))</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mq"><img src="../Images/0b367109168401dd388c47349d88755f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UpqLwB4sTCslPN4fa51yDg.png"/></div></div></figure><p id="7400" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所见，Cabin列有许多NA值，我们将删除它。由于PassengerID是记录的唯一标识符，我们将删除它。直觉上，名字、票价、上船和船票栏不会决定生存，所以我们也将它们删除。因此，我们将使用select()函数从dplyr库中选择剩余的列:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="0d46" class="lr kb hi mg b fi mk ml l mm mn">library(dplyr)<br/>data.frame = select(data.frame, Survived, Pclass, Age, Sex, SibSp, Parch)</span></pre><p id="cf05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要处理年龄列中的NA值。我们将使用以下方式删除这些行:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="1945" class="lr kb hi mg b fi mk ml l mm mn">data.frame = na.omit(data.frame)</span></pre><p id="c1f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用str()检查数据的结构:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="89fb" class="lr kb hi mg b fi mk ml l mm mn">&gt; str(data.frame)</span><span id="ed98" class="lr kb hi mg b fi mp ml l mm mn">'data.frame': 891 obs. of  6 variables: <br/>$ Survived: int  0 1 1 1 0 0 0 0 1 1 ... <br/>$ Pclass  : int  3 1 3 1 3 3 1 3 3 2 ... <br/>$ Age     : num  22 38 26 35 35 NA 54 2 27 14 ... <br/>$ Sex     : Factor w/ 2 levels "female","male": 2 1 1 1 2 2 2 2 1 1 ... <br/>$ SibSp   : int  1 1 0 1 0 0 0 3 0 1 ... <br/>$ Parch   : int  0 0 0 0 0 0 0 1 2 0 ...</span></pre><p id="aaca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到Survived和Pclass列都是整数。但它们实际上是分类变量。要将它们转换成分类变量(或因子)，请使用factor()函数。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="412f" class="lr kb hi mg b fi mk ml l mm mn">data.frame$Survived = factor(data.frame$Survived)</span><span id="e18d" class="lr kb hi mg b fi mp ml l mm mn">data.frame$Pclass = factor(data.frame$Pclass, order=TRUE, levels = c(3, 2, 1))</span></pre><p id="0233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Survived是一个名词性分类变量，而Pclass是一个序数分类变量。对于顺序变量，我们提供order=TRUE和levels参数，以值的升序排列(Pclass 3 &lt; Pclass 2 &lt; Pclass 1)。</p><h1 id="fa14" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">4.可视化数据</h1><p id="11e1" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">现在让我们通过绘制一些图表来可视化数据。我们将主要关注条形图，因为它们很容易解释。</p><h2 id="eeac" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">相关图</h2><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="9806" class="lr kb hi mg b fi mk ml l mm mn">library(GGally)</span><span id="1d70" class="lr kb hi mg b fi mp ml l mm mn">ggcorr(data.frame,<br/>       nbreaks = 6,<br/>       label = TRUE,<br/>       label_size = 3,<br/>       color = “grey50”)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mr"><img src="../Images/0b61dd3ec5082392fb852bebb3fe2373.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*grBYyzqs5z-Tm93DaC1u4A.png"/></div></figure><h2 id="359f" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">幸存计数</h2><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="2100" class="lr kb hi mg b fi mk ml l mm mn">library(ggplot2)<br/>ggplot(data.frame, aes(x = Survived)) +<br/>  geom_bar(width=0.5, fill = "coral") +<br/>  geom_text(stat='count', aes(label=stat(count)), vjust=-0.5) +<br/>  theme_classic()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ms"><img src="../Images/ca49f48394968044ab4379ff6cf66e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*PZKl6vNtICqg6SnPv67d4Q.png"/></div></figure><p id="8b87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ggplot函数将data.frame作为输入。x轴和y轴变量使用aes()函数指定。因为我们只对计数感兴趣，所以没有提供y值。+运算符用于指定绘图中的附加组件。geom_bar()用于条形图，width指定条形的宽度，fill指定条形的颜色。geom_text()用于用stat=count标记条形，vjust是文本的垂直对齐方式。theme_classic()是一个提供配色方案的内置工具。</p><h2 id="a1c9" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">按性别统计幸存人数</h2><p id="1285" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">在前面的情节中，我们可以通过添加男性和女性幸存者的计数来添加更多信息。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="560e" class="lr kb hi mg b fi mk ml l mm mn">ggplot(data.frame, aes(x = Survived, fill=Sex)) +<br/> geom_bar(position = position_dodge()) +<br/> geom_text(stat=’count’, <br/>           aes(label=stat(count)), <br/>           position = position_dodge(width=1), vjust=-0.5)+<br/> theme_classic()</span></pre><p id="e0d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们简单地为fill参数提供了性别属性。这个属性应该是一个因素。为了并排显示条形，我们将位置称为position_dodge()。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mt"><img src="../Images/3275618ffe023ca36ce93ebfe800f34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*R1XyuIE86ET-q-t5kr0MNA.png"/></div></figure><p id="0c15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以推断，幸存的人数很少，而幸存的女性人数多于男性。</p><p id="5c7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，我们绘制了更多的图表。</p><h2 id="3da8" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">通过Pclass生存</h2><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="552a" class="lr kb hi mg b fi mk ml l mm mn">ggplot(data.frame, aes(x = Survived, fill=Pclass)) +<br/> geom_bar(position = position_dodge()) +<br/> geom_text(stat=’count’, <br/>           aes(label=stat(count)), <br/>           position = position_dodge(width=1), <br/>           vjust=-0.5)+<br/> theme_classic()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mu"><img src="../Images/fb8849a95491547473e77596ef6fd4fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*SmdK8eCXW1qj5T-tHkCpqA.png"/></div></figure><p id="f98a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以推断头等舱乘客的生还机会比其他人多。</p><h2 id="6a3b" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">年龄密度</h2><p id="8ac1" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">可以使用geom_density创建密度图。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="a503" class="lr kb hi mg b fi mk ml l mm mn">ggplot(data.frame, aes(x = Age)) +<br/> geom_density(fill=’coral’)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mv"><img src="../Images/87a99f27a2255112437d5444b105dfc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*EglmA1eaZETqkiUF-O311g.png"/></div></figure><p id="ff0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数乘客年龄在20到40岁之间。</p><h2 id="300e" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">按年龄分列的存活率</h2><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="86e7" class="lr kb hi mg b fi mk ml l mm mn"># Discretize age to plot survival<br/>data.frame$Discretized.age = cut(data.frame$Age, c(0,10,20,30,40,50,60,70,80,100))</span><span id="f7d2" class="lr kb hi mg b fi mp ml l mm mn"># Plot discretized age<br/>ggplot(data.frame, aes(x = Discretized.age, fill=Survived)) +<br/>  geom_bar(position = position_dodge()) +<br/>  geom_text(stat='count', aes(label=stat(count)), position = position_dodge(width=1), vjust=-0.5)+<br/>  theme_classic()</span><span id="3518" class="lr kb hi mg b fi mp ml l mm mn">data.frame$Discretized.age = NULL</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mw"><img src="../Images/657fa36e194411f0c21d88ca77a97ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vAfxOg1tky60sR0qnxKGsA.png"/></div></div></figure><p id="393c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们创建了一个名为Discretized.age的临时属性来绘制分布图。我们使用cut()函数将年龄离散化，并在向量中指定切割。绘制后丢弃的临时属性。</p><h1 id="4449" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">5.创建培训和测试数据</h1><p id="5b64" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我们可以编写如下函数，将数据分为训练集和测试集。我们传递一个分数参数，它决定了必须选择的记录的分数。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="a813" class="lr kb hi mg b fi mk ml l mm mn">train_test_split = function(data, fraction = 0.8, train = TRUE) {<br/>  total_rows = nrow(data)<br/>  train_rows = fraction * total_rows<br/>  sample = 1:train_rows<br/>  if (train == TRUE) {<br/>    return (data[sample, ])<br/>  } else {<br/>    return (data[-sample, ])<br/>  }<br/>}</span></pre><p id="6d3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后使用函数创建训练集和测试集，如下所示:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="dfd4" class="lr kb hi mg b fi mk ml l mm mn">train &lt;- train_test_split(data.frame, 0.8, train = TRUE)<br/>test &lt;- train_test_split(data.frame, 0.8, train = FALSE)</span></pre><h1 id="f0a5" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">6.决策树模型</h1><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="01ab" class="lr kb hi mg b fi mk ml l mm mn">library(rpart)<br/>library(rpart.plot)<br/>fit &lt;- rpart(Survived~., data = train, method = ‘class’)<br/>rpart.plot(fit, extra = 106)</span></pre><p id="181e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">rpart库中提供了决策树模型。该模型是使用rpart()构建的。第一个参数定义了目标标签和特征。“~”左侧的属性指定目标标注，左侧的属性指定用于训练的特征。“data”参数是您的训练数据，method =“class”表示我们正在尝试解决一个分类问题。下一个函数绘制了如下的决策树。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mx"><img src="../Images/9c9ffc55ebc564c36d18be761ab4b0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*lFGWj07LUMcKf2i0FitplA.png"/></div></figure><h1 id="1ba1" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">7.准确(性)</h1><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="f20c" class="lr kb hi mg b fi mk ml l mm mn">predicted = predict(fit, test, type = type)<br/>table = table(test$Survived, predicted)<br/>dt_accuracy = sum(diag(table_mat)) / sum(table_mat)<br/>paste("The accuracy is : ", dt_accuracy)</span></pre><p id="8575" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练完模型后，我们使用predict()函数在测试集上进行预测。我们通过拟合的模型、测试数据和type = 'class '进行分类。它返回一个预测向量。table()函数生成实际标签与预测标签的表格，也称为混淆矩阵。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="5356" class="lr kb hi mg b fi mk ml l mm mn"> predicted<br/>    0  1 </span><span id="ac6a" class="lr kb hi mg b fi mp ml l mm mn">0 113 19  |  (TN)   (FP)</span><span id="11a7" class="lr kb hi mg b fi mp ml l mm mn">1  18 65  |  (FN)   (TP)</span></pre><p id="2879" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用(TP + TN)/(TP + TN + FP + FN)计算精度。我得到了81.11%的准确率</p><h2 id="cb2f" class="lr kb hi bd kc ls lt lu kg lv lw lx kk iq ly lz ko iu ma mb ks iy mc md kw me bi translated">微调</h2><p id="470e" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">您可以通过选择minsplit(决策的最小样本数)、minbucket(叶节点的最小样本数)、maxdepth(树的最大深度)来使用控制参数微调决策树。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="d4e7" class="lr kb hi mg b fi mk ml l mm mn">control = rpart.control(minsplit = 8,<br/>                         minbucket = 2,<br/>                         maxdepth = 6,<br/>                         cp = 0)<br/>tuned_fit = rpart(Survived~., data = data_train, method = ‘class’, control = control)<br/>dt_predict = predict(tuned_fit, test, type = ‘class’)<br/>table_mat = table(test$Survived, dt_predict)<br/>dt_accuracy_2 = sum(diag(table_mat)) / sum(table_mat)<br/>paste(“The accuracy is : “, dt_accuracy_2)</span></pre><p id="4e51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过微调，准确率上升到87.41%</p><h1 id="bf39" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">8.逻辑回归模型</h1><p id="57a2" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">为了建立逻辑回归模型，我们使用广义线性模型glm()进行分类。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="48c4" class="lr kb hi mg b fi mk ml l mm mn">data_rescale = mutate_if(data.frame,<br/>                          is.numeric,<br/>                          list(~as.numeric(scale(.))))<br/>r_train = train_test_split(data_rescale, 0.7, train = TRUE)<br/>r_test = train_test_split(data_rescale, 0.7, train = FALSE)<br/>logit = glm(Survived~., data = r_train, family = ‘binomial’)<br/>summary(logit)<br/>lr_predict = predict(logit, r_test, type = ‘response’)</span><span id="5a4c" class="lr kb hi mg b fi mp ml l mm mn"># confusion matrix<br/>table_mat = table(r_test$Survived, lr_predict &gt; 0.68)<br/>lr_accuracy = sum(diag(table_mat)) / sum(table_mat)<br/>paste(“The accuracy is : “, lr_accuracy)</span></pre><p id="e2ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用as.numeric()和scale()函数对数据进行缩放。“.”(点)在这里指定了完整的数据集。它会自动忽略因素。你可以用summary()得到模型的概要。我们使用type = 'response '的predict函数来获取概率，从而获得预测。在table()函数中，我们传递了一个参数predict&gt;0.68，这是一个阈值，表示如果预测的概率大于0.68，则我们将该记录分类为1(幸存)。</p><p id="4a69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我得到了80%的准确率。</p><h1 id="efcc" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">9.朴素贝叶斯模型</h1><p id="2d84" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">e1071库中有朴素贝叶斯模型。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="97b6" class="lr kb hi mg b fi mk ml l mm mn">library(e1071)<br/>nb_model = naiveBayes(Survived ~., data=train)<br/>nb_predict = predict(nb_model,test)<br/>table_mat = table(nb_predict, test$Survived)<br/>nb_accuracy = sum(diag(table_mat)) / sum(table_mat)<br/>paste(“The accuracy is : “, nb_accuracy)</span></pre><p id="fa17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我得到了81.81%的准确率。</p><h1 id="f31a" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">10.kNN模型</h1><p id="aad2" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">kNN模型在“类”库中可用。但是，首先，</p><ul class=""><li id="d52d" class="my mz hi ih b ii ij im in iq na iu nb iy nc jc nd ne nf ng bi translated">knn()需要数字变量。如果在数据框中使用因子，则会引发错误。</li><li id="b3cd" class="my mz hi ih b ii nh im ni iq nj iu nk iy nl jc nd ne nf ng bi translated">knn()只接受矩阵或数据帧作为训练和测试参数，而不接受向量。</li></ul><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="26e0" class="lr kb hi mg b fi mk ml l mm mn">library(class)<br/>library(dummies)</span><span id="af1f" class="lr kb hi mg b fi mp ml l mm mn"># one hot encoding using dummy<br/>ohdata = cbind(data.frame, dummy(data.frame$Pclass))<br/>ohdata = cbind(ohdata, dummy(ohdata$Sex))</span><span id="ef55" class="lr kb hi mg b fi mp ml l mm mn"># drop original factor variables<br/>ohdata$Pclass = NULL<br/>ohdata$Sex = NULL<br/>ohtrain = train_test_split(ohdata, 0.8, train = TRUE)<br/>ohtest = train_test_split(ohdata, 0.8, train = FALSE)<br/>train_labels = select(ohtrain, Survived)[,1]<br/>test_labels = select(ohtest, Survived)[,1]</span><span id="9bda" class="lr kb hi mg b fi mp ml l mm mn"># drop labels for prediction<br/>ohtrain$Survived=NULL<br/>ohtest$Survived=NULL<br/>knn_predict = knn(train = ohtrain,<br/>                  test = ohtest,<br/>                  cl = train_labels,<br/>                  k=10)<br/>table_mat = table(knn_predict, test_labels)<br/>accuracy_knn = sum(diag(table_mat)) / sum(table_mat)</span></pre><p id="36d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用dummy()为Pclass和Sex属性创建一次性编码。原始因子属性被删除。训练、测试特征和标签被分离，并且幸存属性从训练、测试集中被丢弃。</p><p id="bea9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意train_labels和test_labels的“[，1]”。这是因为select()返回的是一个向量。但是我们需要一个数据框架(或者矩阵)。</p><p id="3c31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们应用kNN并计算准确率。我得到了85.3%的准确率</p><h1 id="4d50" class="ka kb hi bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">11.结论</h1><p id="3449" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">嗯，R的学习曲线一开始很陡，但是一旦你掌握了它，你就会很容易上手。这只是机器学习过程中对R的一个基本介绍，你可以用R做更多的事情。话虽如此，我仍然更喜欢Python，因为它的易用性和多功能性。</p><p id="a2fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在机器学习部分，决策树模型表现最好，准确率约为87%。另一种基于决策树的算法是随机森林算法。看看决策树的性能，我们可以预期使用随机森林的集成方法会有相似或更好的性能。</p></div></div>    
</body>
</html>