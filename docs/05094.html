<html>
<head>
<title>Apache Spark Memory Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Spark内存管理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/apache-spark-memory-management-49682ded3d42?source=collection_archive---------1-----------------------#2020-04-11">https://medium.com/analytics-vidhya/apache-spark-memory-management-49682ded3d42?source=collection_archive---------1-----------------------#2020-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个博客描述了spark执行器内存管理背后的概念</p><p id="ed45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你正在阅读这篇博客，那么你可能知道spark的架构，至少在高层次上。简而言之，spark是一个执行框架，它提供了一种并行处理数据的方法。与Hadoop不同，Spark应用程序占用大量内存。这就需要理解spark中的内存管理是如何完成的，这将帮助您调整spark的配置，以充分利用可用的资源。在spark中，所有的计算都是在Executor中完成的，因此这篇博客主要关注executor内存管理。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/bb5632188adea81d577b278a0769315d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SmdoKxtRERqjtlBs"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">弗兰克·麦肯纳在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="8985" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">执行者记忆崩溃</h1><p id="a413" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在spark 1.6之前，内存管理的机制是不同的，本文将介绍spark 1.6及更高版本中的内存管理。早期的内存管理是使用StaticMemoryManager类完成的，在spark 1.6及更高版本中，内存管理是由UnifiedMemoryManager类完成的。</p><p id="4309" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了Spark executor中的内存是如何隔离的</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/d8e81a56ca4e0f550e7e66b8b650ca01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sM-zKpc2aUGyo4O5lyRfLg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">火花执行器内存分配</figcaption></figure><p id="5dea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了便于理解，我们以分配给执行器的4GB内存为例，保留默认配置，看看每个段得到多少内存。</p><p id="a1a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">控制执行器内存分配的两个主要配置:</p><p id="f242" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">spark . memory . fraction-默认为0.75</p><p id="5c2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">spark . memory . storage fraction-默认为0.5</p><h2 id="7b79" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">1.保留内存</h2><p id="9d44" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是系统保留的内存，其大小是硬编码的。从Spark 1.6.0开始，它的值是300MB，也就是说这300MB的RAM是不能改变的，除非重新编译Spark。这种记忆储存火花内部物体。需要注意的一点是，如果执行器内存小于保留内存的1.5倍，Spark将失败，并显示“请使用更大的堆大小”错误消息。</p><p id="f8b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">公式</em> : <strong class="ih hj">预留内存= 300MB </strong></p><p id="6579" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">4GB</em>的计算:<strong class="ih hj">保留内存= 300MB </strong></p><h2 id="ee73" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">2.用户存储器</h2><p id="9242" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是存储所有用户定义的数据结构、用户创建的任何UDF等的存储区域。该内存段不由spark管理，spark不会知道/维护该内存段。这个内存池的大小可以计算为(Java堆—保留内存)* (1.0 — spark.memory.fraction)，默认情况下等于(Java堆— 300MB) * 0.25。</p><p id="19cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">公式</em> : <strong class="ih hj">用户内存= </strong> <strong class="ih hj"> (Java堆—保留内存)*(1.0—spark . Memory . fraction)</strong></p><p id="121f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">4GB的计算</em> : <strong class="ih hj">用户内存=(4024 MB—300 MB)*(1.0–0.75)= 949 MB</strong></p><h2 id="1f2b" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">3.火花记忆</h2><p id="a181" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这个内存池由Spark管理。它负责在执行任务(如连接)时存储中间状态，或者存储广播变量。所有缓存/持久化的数据将被存储在该段中，具体地说是存储在该段的存储器中。</p><p id="6966" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">公式</em> : <strong class="ih hj"> (Java堆—保留内存)* spark.memory.fraction </strong></p><p id="a139" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">4GB的计算</em>:<strong class="ih hj">(4096 MB-300 MB)* 0.75 = 2847 MB</strong></p><p id="4164" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这分为两部分存储内存和执行内存。我们将简要讨论这两个部分:</p><p id="99c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">存储内存:</strong></p><p id="fac9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存储内存用于存储所有的缓存数据，广播变量也存储在这里。任何包含内存持久化选项，spark都会将数据存储在这个段中。Spark通过基于最近最少使用(LRU)机制删除旧的缓存对象，为新的缓存请求清理空间。一旦缓存的数据超出存储空间，就会被写入磁盘或根据配置重新计算。广播变量以MEMORY_AND_DISK持久级别存储在这个段中。</p><p id="2f25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">公式</em> : <strong class="ih hj">存储内存= (Java堆—保留内存)* spark . Memory . fraction * spark . Memory . Storage fraction</strong></p><p id="06c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">4GB的计算</em> : <strong class="ih hj">存储内存=(4096 MB—300 MB)* 0.75 * 0.5 = ~ 1423 MB</strong></p><p id="181f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">执行内存:</strong></p><p id="334e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spark将这个内存区域用于任务执行期间创建的对象。例如，它用于存储哈希聚合步骤的哈希表，它用于存储内存中映射端的混洗中间缓冲区等。如果没有足够的可用内存，该池也支持磁盘溢出，但是该池中的块不能被其他任务强制逐出。</p><p id="b388" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">公式</em> : <strong class="ih hj">执行内存= (Java堆—保留内存)* spark . Memory . fraction *(1.0—spark . Memory . storage fraction)</strong></p><p id="2d99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">4GB的计算</em> : <strong class="ih hj">执行内存=(4096 MB—300 MB)* 0.75 *(1.0—0.5)= ~ 1423 MB</strong></p><p id="69a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在spark 1.6及以上版本中，执行内存和存储内存没有硬性的界限。由于执行内存的性质，块不能从这个池中被强制逐出，否则执行将会中断，因为它所引用的块将不会被找到。但是对于存储内存，可以根据需要将块从内存中逐出，写入磁盘或重新计算(如果持久性级别是MEMORY_ONLY)。关于存储和执行内存，有几件事需要记住:</p><p id="c3a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm"> 1。只有在执行内存中没有使用块时，存储内存才能从执行内存中借用空间。</em></p><p id="cdfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm"> 2。如果存储内存中没有使用块，执行内存也可以从存储内存中借用空间。</em></p><p id="98d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm"> 3。如果来自执行存储器的块被存储存储器使用，并且执行需要更多的存储器，它可以强制驱逐存储存储器占用的多余块</em></p><p id="5dd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm"> 4。如果存储内存中的块被执行内存使用，并且存储需要更多的内存，它不能强制驱逐执行内存占用的多余块，它将最终拥有更少的内存区域。它将等待Spark释放执行内存存储的多余块，然后占用它们。</em></p><h2 id="7c65" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">4GB执行程序内存分配的内存故障</h2><p id="7ac9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">保留内存— 300MB — 7.32%</p><p id="031b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用户内存— 949MB — 23.16%</p><p id="22b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">火花内存— 2847MB —69.5%</p><p id="be2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想知道可用于存储缓存数据的空间是多少，这是总内存细分(请注意，没有硬性限制，这是初始分配):</p><p id="e268" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">初始存储内存(50%的spark内存)— 1423MB — 34.75%</p><p id="0054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该百分比值仅用于4GB执行器内存的计算，对于不同的执行器内存配置，这些值不适用。这只是为了便于理解。</p><p id="252e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读本文:)</p></div></div>    
</body>
</html>