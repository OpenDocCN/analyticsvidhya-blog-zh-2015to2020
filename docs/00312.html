<html>
<head>
<title>Demystifying H2O.ai | Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘H2O.ai |使用Python</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/demystifying-h2o-ai-using-python-a85986e918d7?source=collection_archive---------0-----------------------#2019-03-24">https://medium.com/analytics-vidhya/demystifying-h2o-ai-using-python-a85986e918d7?source=collection_archive---------0-----------------------#2019-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="ab fe cl ij"><img src="../Images/3315f5d23189c2a50aa6e642a63b24e6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*vG03fma-Ee7OJLHJs4F3WA.png"/></div></figure><p id="c344" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在“揭开H2O的神秘面纱”系列的前一篇文章中，我提供了H2O及其建筑的概述。现在让我们看看使用H2O的pythonic方式。</p><p id="7273" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这篇文章是为人类揭开H2O.ai神秘面纱系列文章的一部分:)</p><p id="89f5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" rel="noopener" href="/@rehan_ahmad/demystifying-h2o-ai-an-overview-debc08850e20">第1部分:揭开H2O.ai的神秘面纱|概述</a></p><p id="69f1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第2部分:使用Python揭开H2O.ai的神秘面纱</p><p id="6afe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" rel="noopener" href="/@rehan_ahmad/demystifying-h2o-ai-using-h2o-flow-c580f64bee82">第三部分:揭秘H2O.ai |使用H2O流</a></p><p id="81be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" rel="noopener" href="/@rehan_ahmad/demystifying-h2o-ai-productionizing-2d4596b1a895">第四部分:揭秘H2O.ai |生产化</a></p><p id="f1db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">H2O为Python开发者提供了一个与H2O集群交互的接口。通过Python API，我们可以调用负责集群中机器学习的java代码。</p><h1 id="1d39" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">安装依赖关系<strong class="ak"> <em class="kj"> : </em> </strong></h1><p id="680e" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated"><strong class="io hj"> <em class="kp">安装H2O: </em> </strong></p><p id="f3e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">1.下载H2O 。这是一个zip文件，包含入门所需的一切。</p><p id="5c4b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.从您的终端运行:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="fd31" class="kz jm hi kv b fi la lb l lc ld">cd ~/Downloads<br/>unzip h2o-3.22.1.6.zip<br/>cd h2o-3.22.1.6<br/>java -jar h2o.jar</span></pre><p id="def4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.将您的浏览器指向<a class="ae jk" href="http://localhost:54321/" rel="noopener ugc nofollow" target="_blank"> http://localhost:54321 </a></p><p id="9d2d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="kp">安装H2O Python API: </em> </strong></p><p id="ac0d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">1.先决条件:Python 2.7.x、3.5.x或3.6.x</p><p id="c197" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.安装依赖项(如果需要，在前面加上' sudo '):</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="994d" class="kz jm hi kv b fi la lb l lc ld">pip install requests<br/>pip install tabulate<br/>pip install “colorama&gt;=0.3.8”<br/>pip install future</span></pre><p id="e98c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.在命令行中，一次复制并粘贴一行命令:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="0573" class="kz jm hi kv b fi la lb l lc ld"># The following command removes the H2O module for Python.<br/>pip uninstall h2o</span><span id="16ab" class="kz jm hi kv b fi le lb l lc ld"># Next, use pip to install this version of the H2O Python module.<br/>pip install <a class="ae jk" href="http://h2o-release.s3.amazonaws.com/h2o/rel-xu/6/Python/h2o-3.22.1.6-py2.py3-none-any.whl" rel="noopener ugc nofollow" target="_blank">http://h2o-release.s3.amazonaws.com/h2o/rel-xu/6/Python/h2o-3.22.1.6-py2.py3-none-any.whl</a></span></pre></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h1 id="286e" class="jl jm hi bd jn jo lm jq jr js ln ju jv jw lo jy jz ka lp kc kd ke lq kg kh ki bi translated">将数据加载到数据框架</h1><p id="b63a" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">我们要看的例子是基于一些数字属性预测白葡萄酒质量的回归问题。</p><p id="5f0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以从以下网址下载CSV文件形式的数据集:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="f8d1" class="kz jm hi kv b fi la lb l lc ld"><a class="ae jk" href="https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-white.csv" rel="noopener ugc nofollow" target="_blank">https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-white.csv</a></span></pre><p id="3deb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看将数据加载到H2O数据框架的不同方法。</p><p id="7054" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="kp">注:H2O数据帧类似于Pandas或R数据帧，但驻留在H2O共享内存簇中。由于它驻留在内存中，所有操作都非常快。</em></p><p id="7ca8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">方法1 </strong>:从本地文件加载CSV。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="16e5" class="kz jm hi kv b fi la lb l lc ld"># Method 1 - Import data from a local CSV file<br/>data_from_csv = h2o.import_file("winequality-white.csv")<br/>data_from_csv.head(5)</span></pre><p id="e6c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">方法2 </strong>:从任何外部web源加载数据</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="7bf9" class="kz jm hi kv b fi la lb l lc ld"><em class="kp"># Method 2 - Import data from the web</em></span><span id="079d" class="kz jm hi kv b fi le lb l lc ld">data_from_web <strong class="kv hj">=</strong> h2o.import_file("https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-white.csv")</span><span id="13ea" class="kz jm hi kv b fi le lb l lc ld">data_from_web.head(5)</span></pre><p id="5739" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">方法三</strong>:从熊猫数据帧加载数据到H2O帧</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="cb60" class="kz jm hi kv b fi la lb l lc ld"># Method 3 - Convert Python data frame into H2O data frame</span><span id="fac1" class="kz jm hi kv b fi le lb l lc ld">## Import Wine Quality data using Pandas<br/>import pandas as pd<br/>wine_df = pd.read_csv('winequality-white.csv', sep = ';')<br/>wine_df.head(5)<br/>## Convert Pandas data frame into H2O data frame<br/>data_from_df = h2o.H2OFrame(wine_df)<br/>data_from_df.head(5)</span></pre><h1 id="01c1" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">数据帧上的基本操作</h1><p id="8acf" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">现在我们已经看到了加载数据集的不同方法，让我们继续我们的例子。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="0eea" class="kz jm hi kv b fi la lb l lc ld">wine = h2o.import_file("winequality-white.csv")</span></pre><p id="ef5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="kp">注意:“wine”数据帧不保存到python内存中，而是驻留在H2O集群内存中，只有指向数据的指针驻留在python内存中。</em></p><p id="d405" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看我们正在处理的所有特性。我们的目标特征是“质量”。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="3d3f" class="kz jm hi kv b fi la lb l lc ld"># Define features (or predictors)<br/>features = list(wine.columns) # we want to use all the information<br/>features.remove('quality')    # we need to exclude the target <br/>                               'quality' (otherwise there is nothing <br/>                                to predict)<br/>features</span><span id="b247" class="kz jm hi kv b fi le lb l lc ld">Output:</span><span id="6c58" class="kz jm hi kv b fi le lb l lc ld">['fixed acidity',<br/> 'volatile acidity',<br/> 'citric acid',<br/> 'residual sugar',<br/> 'chlorides',<br/> 'free sulfur dioxide',<br/> 'total sulfur dioxide',<br/> 'density',<br/> 'pH',<br/> 'sulphates',<br/> 'alcohol']</span></pre><p id="9988" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了检查模型性能，我们可以将数据分成训练集和测试集。这个功能可以使用split_frame()函数来实现。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="7fe2" class="kz jm hi kv b fi la lb l lc ld"># Split the H2O data frame into training/test sets<br/># so we can evaluate out-of-bag performance<br/>wine_split = wine.split_frame(ratios = [0.8], seed = 1234)</span><span id="2d48" class="kz jm hi kv b fi le lb l lc ld">wine_train = wine_split[0] # using 80% for training<br/>wine_test = wine_split[1]  # using the rest 20% for out-of-bag <br/>                             evaluation</span></pre><p id="0b9e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">wine_train.shape，wine_test.shape</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="74d5" class="kz jm hi kv b fi la lb l lc ld">(3932, 12) (966, 12)</span></pre><h1 id="45e4" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">在H2O平台上建立模型</h1><p id="d96a" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">既然我们的数据被很好地分割了，是时候进行一些建模了。对于这个例子，我选择使用GBM(梯度推进机器),但是你可以使用H2O平台支持的任何可用算法。</p><p id="1561" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们使用默认设置来尝试GBM模型，以获得一个基础模型来比较优化后的性能。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="2eeb" class="kz jm hi kv b fi la lb l lc ld"># Build a Gradient Boosting Machines (GBM) model with default <br/>                                                     settings</span><span id="ef1d" class="kz jm hi kv b fi le lb l lc ld"># Import the function for GBM<br/>from h2o.estimators.gbm import H2OGradientBoostingEstimator</span><span id="f0b6" class="kz jm hi kv b fi le lb l lc ld"># Set up GBM for regression<br/># Add a seed for reproducibility<br/>gbm_default = H2OGradientBoostingEstimator(model_id = 'gbm_default', seed = 1234)</span><span id="c361" class="kz jm hi kv b fi le lb l lc ld"># Use .train() to build the model<br/>gbm_default.train(x = features, <br/>                  y = 'quality', <br/>                  training_frame = wine_train)<br/># Check the GBM model summary<br/>gbm_default<br/>--------------------------------------------------------------------</span><span id="0071" class="kz jm hi kv b fi le lb l lc ld">Output:<br/>gbm Model Build progress: |███████████████████████████████████████████████| 100%<br/>Model Details<br/>=============<br/>H2OGradientBoostingEstimator :  Gradient Boosting Machine<br/>Model Key:  gbm_default<br/><br/><br/>ModelMetricsRegression: gbm<br/>** Reported on train data. **<br/><br/>MSE: 0.33754946668043595<br/>RMSE: 0.5809900745111193<br/>MAE: 0.4582897982543992<br/>RMSLE: 0.0859869651179757<br/>Mean Residual Deviance: 0.33754946668043595</span></pre><p id="12ce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如你在输出中看到的，H2O给出了一堆为回归问题自动定制的指标。输出还包含评分历史和特性重要性，由于篇幅限制，我选择不显示它们。</p><p id="8479" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以在模型没有看到的数据上检查模型的性能。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="f755" class="kz jm hi kv b fi la lb l lc ld"># Check the model performance on test dataset<br/>gbm_default.model_performance(wine_test)<br/>--------------------------------------------------------------------<br/>Output:</span><span id="cefd" class="kz jm hi kv b fi le lb l lc ld">ModelMetricsRegression: gbm<br/>** Reported on test data. **<br/><br/>MSE: 0.4569904494269438<br/>RMSE: 0.6760106873614823<br/>MAE: 0.5248612169030329<br/>RMSLE: 0.10032043310648843<br/>Mean Residual Deviance: 0.4569904494269438</span></pre><p id="8d98" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了根据我们的模型对未来数据进行预测，我们可以使用模型的predict()函数传递未来数据。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="eda1" class="kz jm hi kv b fi la lb l lc ld"># Use GBM model to make predictions<br/>yhat_test_gbm = gbm_default.predict(wine_test)<br/>yhat_test_gbm.head(5)<br/>--------------------------------------------------------------------<br/>Output:</span><span id="df2c" class="kz jm hi kv b fi le lb l lc ld">gbm prediction progress: |████████████████████████████████████████████████| 100%</span><span id="5ed0" class="kz jm hi kv b fi le lb l lc ld">predict<br/>5.78661<br/>5.96088<br/>5.32867<br/>6.19424<br/>5.7198</span></pre><h1 id="07c9" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">设置算法的超参数</h1><p id="9cfa" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">让我们尝试改进我们的模型。一种方法是对算法使用手动设置。以下是一些可以调整的设置。我不打算解释每一个设定背后的理论，因为这篇文章的目的是集中在H2O。</p><p id="24b4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你需要了解更多关于提高模型性能和调整GBM算法的超参数，你可以参考下面的文章:<a class="ae jk" href="https://www.analyticsvidhya.com/blog/2016/02/complete-guide-parameter-tuning-gradient-boosting-gbm-python/" rel="noopener ugc nofollow" target="_blank">梯度增强机器中超参数调整(Python中)</a></p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="2404" class="kz jm hi kv b fi la lb l lc ld"># increase the number of trees for more accuracy<br/>ntrees = 10000,</span><span id="1f76" class="kz jm hi kv b fi le lb l lc ld"># Row Random picking for more generalization<br/>sample_rate = 0.9, </span><span id="886b" class="kz jm hi kv b fi le lb l lc ld"># Columnar Random picking for more generalization<br/>col_sample_rate = 0.9,</span><span id="e01d" class="kz jm hi kv b fi le lb l lc ld"># Add cross validation <br/>nfolds = 5,</span><span id="23e1" class="kz jm hi kv b fi le lb l lc ld"># Early stopping <br/>stopping_metric = 'mse', # let early stopping feature determine<br/>stopping_rounds = 15,     # the optimal number of trees<br/>score_tree_interval = 1</span></pre><p id="cf52" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看具有这些设置的模型实例化函数调用。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="9be1" class="kz jm hi kv b fi la lb l lc ld"># Build a GBM with manual settings, CV and early stopping</span><span id="5620" class="kz jm hi kv b fi le lb l lc ld"># Set up GBM for regression<br/># Add a seed for reproducibility<br/>gbm_manual_cv_es = H2OGradientBoostingEstimator(<br/>                                      model_id = 'gbm_manual_cv_es', <br/>                                       seed = 1234,<br/>                                       ntrees = 10000,<br/>                                       sample_rate = 0.9,<br/>                                       col_sample_rate = 0.9,<br/>                                       nfolds = 5,<br/>                                       stopping_metric = 'mse',<br/>                                       stopping_rounds = 15,<br/>                                       score_tree_interval = 1) <br/># Use .train() to build the model<br/>gbm_manual_cv_es.train(x = features, <br/>                       y = 'quality', <br/>                       training_frame = wine_train)<br/># Check the model summary<br/>gbm_manual_cv_es.summary()<br/># Check the cross-validation model performance<br/>gbm_manual_cv_es</span><span id="470b" class="kz jm hi kv b fi le lb l lc ld">--------------------------------------------------------------------<br/>Output:</span><span id="7bf4" class="kz jm hi kv b fi le lb l lc ld">gbm Model Build progress: |███████████████████████████████████████████████| 100%<br/>Model Details<br/>=============<br/>H2OGradientBoostingEstimator :  Gradient Boosting Machine<br/>Model Key:  gbm_manual_cv_es<br/><br/><br/>ModelMetricsRegression: gbm<br/>** Reported on train data. **<br/><br/>MSE: 0.20686547419217588<br/>RMSE: 0.4548246631309431<br/>MAE: 0.34894778424095163<br/>RMSLE: 0.06741983008017692<br/>Mean Residual Deviance: 0.20686547419217588<br/><br/>ModelMetricsRegression: gbm<br/>** Reported on cross-validation data. **<br/><br/>MSE: 0.43719485835036376<br/>RMSE: 0.6612071221261638<br/>MAE: 0.5071563697468089<br/>RMSLE: 0.09876420394757868<br/>Mean Residual Deviance: 0.43719485835036376</span></pre><p id="03ec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们在测试集上检查性能。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="d7fa" class="kz jm hi kv b fi la lb l lc ld"># Check the model performance on test dataset<br/>gbm_manual_cv_es.model_performance(wine_test)<br/>--------------------------------------------------------------------<br/>Output:<br/>ModelMetricsRegression: gbm<br/>** Reported on test data. **<br/><br/>MSE: 0.426937189802319<br/>RMSE: 0.6534043080683805<br/>MAE: 0.49245882283169323<br/>RMSLE: 0.09727407043431956<br/>Mean Residual Deviance: 0.426937189802319</span></pre><p id="61f5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">度量清楚地显示了模型性能的改进。</p><blockquote class="lr ls lt"><p id="1c0a" class="im in kp io b ip iq ir is it iu iv iw lu iy iz ja lv jc jd je lw jg jh ji jj hb bi translated">但是如何为手动设置获得一组完美的值呢？</p></blockquote><h1 id="3191" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">H2O的网格搜索和随机搜索</h1><p id="0994" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">一种方法是为每个设置分配一组值，运行所有组合并比较结果，以获得设置的最佳值集。这就是所谓的“网格搜索”。如果有太多的设置和太多的组合要运行，我们可以设置最大数量的组合来随机检查，以克服计算限制。这就是所谓的“随机网格搜索”。让我们看看如何在H2O做到这两点。</p><p id="db45" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="kp">网格搜索:</em> </strong></p><p id="ef26" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先设置搜索标准并定义超参数的值集。</p><p id="07bf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="kp">注意:设置、参数和超参数都是不同的术语，用于上下文中的同一事物。</em></p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="48b8" class="kz jm hi kv b fi la lb l lc ld"># define the criteria for full grid search<br/>search_criteria = {'strategy': "Cartesian"}</span><span id="9e94" class="kz jm hi kv b fi le lb l lc ld"># define the range of hyper-parameters for grid search<br/>hyper_params = {'sample_rate': [0.7, 0.8, 0.9],<br/>                'col_sample_rate': [0.7, 0.8, 0.9]}</span></pre><p id="fa90" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看网格搜索函数调用。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="722e" class="kz jm hi kv b fi la lb l lc ld"># Set up GBM grid search<br/># Add a seed for reproducibility<br/>gbm_full_grid = H2OGridSearch(<br/>                    H2OGradientBoostingEstimator(<br/>                        model_id = 'gbm_full_grid', <br/>                        seed = 1234,<br/>                        ntrees = 10000,   <br/>                        nfolds = 5,<br/>                        stopping_metric = 'mse', <br/>                        stopping_rounds = 15,     <br/>                        score_tree_interval = 1),<br/>                    search_criteria = search_criteria, <br/>                    hyper_params = hyper_params)</span><span id="3fa2" class="kz jm hi kv b fi le lb l lc ld"># Use .train() to start the grid search<br/>gbm_full_grid.train(x = features, <br/>                    y = 'quality', <br/>                    training_frame = wine_train)</span></pre><p id="2727" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在要获得具有最佳超参数集的最佳模型。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="f8ec" class="kz jm hi kv b fi la lb l lc ld"># Extract the best model from full grid search<br/>gbm_full_grid_sorted = gbm_full_grid.get_grid(sort_by='mse', decreasing=False)<br/>best_model_id = gbm_full_grid_sorted.model_ids[0]<br/>best_gbm_from_full_grid = h2o.get_model(best_model_id)<br/>best_gbm_from_full_grid.summary()</span></pre><figure class="kq kr ks kt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lx"><img src="../Images/5a9ed1f2292ca8c0d1303c4fb3aa421d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LsQilyEtocTwwOz0pHjuMw.png"/></div></div></figure><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="8a61" class="kz jm hi kv b fi la lb l lc ld"># Check the model performance on test dataset<br/>best_gbm_from_full_grid.model_performance(wine_test)<br/>--------------------------------------------------------------------<br/>Output:<br/>ModelMetricsRegression: gbm<br/>** Reported on test data. **<br/><br/>MSE: 0.4225488547806245<br/>RMSE: 0.6500375795141574<br/>MAE: 0.49083490901261195<br/>RMSLE: 0.09684966383616216<br/>Mean Residual Deviance: 0.4225488547806245</span></pre><p id="de31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="kp">随机网格搜索:</em> </strong></p><p id="115f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要将网格搜索变成随机网格搜索，我们需要做的唯一更改是将搜索类别更改为“RandomDiscrete ”,并将max_models参数添加到搜索标准中。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="f451" class="kz jm hi kv b fi la lb l lc ld"><em class="kp"># define the criteria for random grid search</em> <br/>search_criteria = {'strategy': "RandomDiscrete", <br/>                 'max_models': 9,  <br/>                       'seed': 1234}</span></pre><p id="4db4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">之后，你可以添加更多的设置和更多的组合。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="94b1" class="kz jm hi kv b fi la lb l lc ld"><em class="kp"># define the range of hyper-parameters for grid search</em> <em class="kp"># 27 combinations in total</em> <br/>hyper_params = {'sample_rate': [0.7, 0.8, 0.9],  <br/>                'col_sample_rate': [0.7, 0.8, 0.9],     <br/>                'max_depth': [3, 5, 7]}</span></pre><p id="c623" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这一步之后，它与上面看到的代码非常相似。让我们来看看结果。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="5701" class="kz jm hi kv b fi la lb l lc ld"># Check the model performance on test dataset<br/>best_gbm_from_rand_grid.model_performance(wine_test)<br/>--------------------------------------------------------------------<br/>ModelMetricsRegression: gbm<br/>** Reported on test data. **<br/><br/>MSE: 0.38887438717699785<br/>RMSE: 0.6235979371173367<br/>MAE: 0.45221978663123497<br/>RMSLE: 0.09308978440162519<br/>Mean Residual Deviance: 0.38887438717699785</span></pre><p id="4240" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">显然，这是对基本模型性能的巨大改进。H2O提供了更多这样的优化功能，以提高大规模的模型性能。</p><h1 id="02c0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">在H2O堆垛</h1><p id="9bb5" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">H2O还提供了一个签名功能来堆叠不同的模型，以获得最先进的结果。这尤其有助于赢得卡格尔比赛。</p><p id="bc43" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="kp"/></strong>:</p><p id="2058" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，让我们尝试使用不同的估计量建立最佳模型。在这个例子中，我使用网格搜索创建了最佳GBM、DRF和DNN模型。</p><p id="21bc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="kp"> GBM型号:</em></p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="f291" class="kz jm hi kv b fi la lb l lc ld"><em class="kp"># define the range of hyper-parameters for GBM grid search</em><br/><em class="kp"># 27 combinations in total</em><br/>hyper_params = {'sample_rate': [0.7, 0.8, 0.9],<br/>                'col_sample_rate': [0.7, 0.8, 0.9],<br/>                'max_depth': [3, 5, 7]}<br/><em class="kp"># Set up GBM grid search</em><br/><em class="kp"># Add a seed for reproducibility</em><br/>gbm_rand_grid = H2OGridSearch(<br/>                    H2OGradientBoostingEstimator(<br/>                        model_id = 'gbm_rand_grid', <br/>                        seed = 1234,<br/>                        ntrees = 10000,   <br/>                        nfolds = 5,<br/>                        fold_assignment = "Modulo",               <br/>                        keep_cross_validation_predictions = <strong class="kv hj">True</strong>, <br/>                        stopping_metric = 'mse', <br/>                        stopping_rounds = 15,     <br/>                        score_tree_interval = 1),<br/>                    search_criteria = search_criteria, <br/>                    hyper_params = hyper_params)<br/><em class="kp"># Use .train() to start the grid search</em><br/>gbm_rand_grid.train(x = features, <br/>                    y = 'quality', <br/>                    training_frame = wine_train)<br/>gbm_rand_grid_sorted = gbm_rand_grid.get_grid(sort_by='mse', decreasing=<strong class="kv hj">False</strong>)<br/><em class="kp"><br/># Extract the best model from random grid search</em> best_gbm_model_id = gbm_rand_grid_sorted.model_ids[0] best_gbm_from_rand_grid = h2o.get_model(best_gbm_model_id)</span></pre><p id="772e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="kp"> DRF车型</em>:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="44b3" class="kz jm hi kv b fi la lb l lc ld"><em class="kp"># define the range of hyper-parameters for DRF grid search</em> <em class="kp"># 27 combinations in total</em> <br/>hyper_params = {'sample_rate': [0.5, 0.6, 0.7], <br/>                'col_sample_rate_per_tree': [0.7, 0.8, 0.9],    <br/>             'max_depth': [3, 5, 7]}<br/><em class="kp"># Set up DRF grid search</em><br/><em class="kp"># Add a seed for reproducibility</em><br/>drf_rand_grid = H2OGridSearch(<br/>                    H2ORandomForestEstimator(<br/>                        model_id = 'drf_rand_grid', <br/>                        seed = 1234,<br/>                        ntrees = 200,   <br/>                        nfolds = 5,<br/>                        fold_assignment = "Modulo",                 <br/>                        keep_cross_validation_predictions = <strong class="kv hj">True</strong>),  <br/>                    search_criteria = search_criteria, <br/>                    hyper_params = hyper_params)<br/><em class="kp"># Use .train() to start the grid search</em><br/>drf_rand_grid.train(x = features, <br/>                    y = 'quality', <br/>                    training_frame = wine_train)<br/>drf_rand_grid_sorted = drf_rand_grid.get_grid(sort_by='mse', decreasing=<strong class="kv hj">False</strong>)<br/><em class="kp"><br/># Extract the best model from random grid search</em> best_drf_model_id = drf_rand_grid_sorted.model_ids[0] best_drf_from_rand_grid = h2o.get_model(best_drf_model_id)</span></pre><p id="f970" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="kp"> DNN模式</em>:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="3ca6" class="kz jm hi kv b fi la lb l lc ld"><em class="kp"># define the range of hyper-parameters for DNN grid search</em><br/><em class="kp"># 81 combinations in total</em><br/>hyper_params = {'activation': ['tanh', 'rectifier', 'maxout'],<br/>                'hidden': [[50], [50,50], [50,50,50]],<br/>                'l1': [0, 1e-3, 1e-5],<br/>                'l2': [0, 1e-3, 1e-5]}<br/><em class="kp"># Set up DNN grid search</em><br/><em class="kp"># Add a seed for reproducibility</em><br/>dnn_rand_grid = H2OGridSearch(<br/>                    H2ODeepLearningEstimator(<br/>                        model_id = 'dnn_rand_grid', <br/>                        seed = 1234,<br/>                        epochs = 20,   <br/>                        nfolds = 5,<br/>                        fold_assignment = "Modulo",                <br/>                        keep_cross_validation_predictions = <strong class="kv hj">True</strong>), <br/>                    search_criteria = search_criteria, <br/>                    hyper_params = hyper_params)<br/><em class="kp"># Use .train() to start the grid search</em><br/>dnn_rand_grid.train(x = features, <br/>                    y = 'quality', <br/>                    training_frame = wine_train)<br/>dnn_rand_grid_sorted = dnn_rand_grid.get_grid(sort_by='mse', decreasing=<strong class="kv hj">False</strong>)</span><span id="5cff" class="kz jm hi kv b fi le lb l lc ld"><em class="kp"># Extract the best model from random grid search</em><br/>best_dnn_model_id = dnn_rand_grid_sorted.model_ids[0]<br/>best_dnn_from_rand_grid = h2o.get_model(best_dnn_model_id)</span></pre><p id="21fd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="kp">模型堆叠:</em></p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="7a7e" class="kz jm hi kv b fi la lb l lc ld"><em class="kp"># Define a list of models to be stacked</em><br/><em class="kp"># i.e. best model from each grid</em><br/>all_ids = [best_gbm_model_id, best_drf_model_id, best_dnn_model_id]</span><span id="4371" class="kz jm hi kv b fi le lb l lc ld"><em class="kp"># Set up <br/>Stacked Ensemble</em> ensemble = H2OStackedEnsembleEstimator(<br/>                                           model_id = "my_ensemble",<br/>                                        base_models = all_ids)</span><span id="5b14" class="kz jm hi kv b fi le lb l lc ld"><em class="kp"># use .train to start model stacking</em><br/><em class="kp"># GLM as the default metalearner</em><br/>ensemble.train(x = features, <br/>               y = 'quality', <br/>               training_frame = wine_train)<br/>ensemble.model_performance(wine_test)<br/>--------------------------------------------------------------------<br/>Output:<br/>Stacked Ensembles        (MSE) :  0.39948493548786057</span></pre><p id="11df" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的例子广泛地涉及了回归问题，但是分类也是同样的代码。H2O自动根据目标变量的类型检测它是回归还是分类。如果它是一个类别，它将调用分类代码，如果它是一个数字变量，它将调用回归。指定二进制或多类仅仅是实例化调用中一个族属性的改变。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="ba4b" class="kz jm hi kv b fi la lb l lc ld"><em class="kp"># Set up GLM for binary classification</em><br/>glm_default = H2OGeneralizedLinearEstimator(family = 'binomial', model_id = 'glm_default')</span></pre><p id="ebb5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这篇文章清楚地展示了使用Python API调用H2O代码是多么容易，以及H2O提供了多少复杂性来完成机器学习活动。</p><p id="084c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">阅读系列文章，了解更多关于H2O平台的信息。</p><blockquote class="lr ls lt"><p id="37f7" class="im in kp io b ip iq ir is it iu iv iw lu iy iz ja lv jc jd je lw jg jh ji jj hb bi translated">关于我</p></blockquote><p id="5f4d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我是<a class="ae jk" href="https://wavelabs.ai/" rel="noopener ugc nofollow" target="_blank"> Wavelabs.ai </a>的资深机器学习专家。我们Wavelabs帮助您利用人工智能(AI)来彻底改变用户体验并降低成本。我们使用人工智能独特地增强您的产品，以达到您的全部市场潜力。我们试图将尖端研究引入您的应用中。</p><p id="3bd0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们擅长与H2O平台合作，为您提供前所未有的快速、可扩展的机器学习体验。</p><p id="1ae8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">欢迎访问<a class="ae jk" href="https://wavelabs.ai/" rel="noopener ugc nofollow" target="_blank"> Wavelabs.ai </a>了解更多信息。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><p id="a46b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">嗯，这些都在这个博客里。感谢阅读:)</p><p id="96e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">保持好奇！</p><p id="af87" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以通过<a class="ae jk" href="https://www.linkedin.com/in/rehan-a-18675296" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div></div>    
</body>
</html>