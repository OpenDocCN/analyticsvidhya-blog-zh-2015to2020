<html>
<head>
<title>How to Build a Market Simulator Using Markov Chains and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用马尔可夫链和Python构建市场模拟器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-build-a-market-simulator-using-markov-chains-and-python-b925a106b1c4?source=collection_archive---------6-----------------------#2020-02-06">https://medium.com/analytics-vidhya/how-to-build-a-market-simulator-using-markov-chains-and-python-b925a106b1c4?source=collection_archive---------6-----------------------#2020-02-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="fa6c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是马尔可夫链</h1><p id="35be" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">马尔可夫链是一种数学系统，其中根据概率规则从一种状态转移到另一种状态。按照马尔可夫系统，从一个状态到下一个状态的转换只取决于当前状态，而不是先前状态，状态是离散的，可以用矩阵形式表示。</p><p id="f2a7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里有一个例子</p><p id="c06d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">假设有一个品牌X卖dosas。有更多的品牌销售dosas，这些都是X的竞争对手。根据目前的市场分析，X拥有大约20%的市场份额，因此80%的市场被其他品牌占领。现在，X想通过广告和活动来扩大业务。比方说，活动结束后</p><ul class=""><li id="c686" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">90%已经使用X的人仍然使用X</li><li id="f3e7" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">60%不消费X的人会转而消费X</li></ul><p id="92dd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">两个品牌X和假设X '(不是X)代表两种状态</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ku"><img src="../Images/4d70849e78f01210b66ef867f6b20b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*zUJC6f8zns_fAIMxotORuQ.png"/></div></figure><p id="780d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们用转换图来展示上述结论</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lc"><img src="../Images/76cbef3e35bdb69a6f6bb1c91cdc0970.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Gt-3tK7zzxi4sjrolaT0CQ.png"/></div></figure><p id="ef15" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">该图表示某物停留在同一状态或移动到另一状态的概率。让我们用概率矩阵来表示，P–</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ld"><img src="../Images/60ca1c87a04850302df078b58022839b.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*5491USeBzxQ9LjrHsBFA-A.png"/></div></figure><p id="6dbe" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">其中XX = 0.9代表留在X的人，XX' (0.1)代表用X '的人，X'X (0.6)代表转用X的人，X'X' (0.4)代表吃其他品牌dosas的人。以上称为转移概率矩阵，显示了从当前状态到下一个状态的转移。</p><p id="402c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这些状态是dosa商店广告/活动的结果。起步状态怎么样？</p><p id="8241" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们把初始状态表示为Si。</p><p id="4a1d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果你还记得，dosa的份额最初是x品牌的20%。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es le"><img src="../Images/2ff54411e1501b2c070b536c8bef38cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*EBwWc02bF1yJo7YZzAw76w.png"/></div></figure><p id="2e2a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这叫做初始状态分布矩阵。基于这些信息，我们可以预测人们在接下来的一周内消费品牌X的概率。假设Si是本周的州。所以，下周这个州就是S1了。为了找到这个，我们必须用概率矩阵乘以初始状态</p><p id="4c43" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">S1 = [0.2 0.8] 0.9 0.1 0.6 0.4</p><p id="b434" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi">= [0.2*0.9 + 0.8*0.6 0.2*0.1 + 0.8*0.4]</p><p id="0453" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi">= [0.66 0.34]</p><p id="1aab" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这意味着，一周后，市场份额有望上升至66%。我们可以把这个公式概括为:</p><p id="93ad" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">S1 = Si*P</p><p id="5532" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">S2 = S1*P —用于预测初始状态2周后的状态</p><p id="3335" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> Sn = S(n-1)*P </strong></p><p id="fe46" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">通过使用相同的概率矩阵来尝试这些值，并查看这些值如何逐周变化。</p><p id="ee54" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在上面的例子中，我们有两个状态。随着状态数量的增加，矩阵的大小也会增加。</p><h1 id="a83e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">如何用Python实现马尔可夫链</h1><p id="6ab4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Python有很多库可以帮助你创建马尔可夫链。因为我们的文章是关于使用马尔可夫链建立一个市场模拟器，我们将牢记我们的市场模拟器来探索我们的代码。</p><p id="c52e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们已经了解了什么是马尔可夫链，知道它是一个可以应用到各种现实场景中，根据当前状态预测未来结果的概念。数据可以是任何范围的—一周、一个月、一个季度、一年—这取决于您对结果所需的精确度。</p><p id="8b3d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你可以从任何地方获得数据集，比如雅虎财经，甚至是提供免费金融和经济数据集的Quandl，只要使用Python 的quandl <a class="ae lf" href="http://www.techgeekbuzz.com/python-package/" rel="noopener ugc nofollow" target="_blank">包。这种做法一直持续到2018年，但我们仍然可以将这些数据用于学习目的。下面是如何提取它——</a></p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lg"><img src="../Images/81bdc5301285ad29634fee356da714f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*oDVxVSTnqSZ7p36b"/></div></figure><p id="46b0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们使用了微软公司的数据。你可以选择facebook、亚马逊或其他任何网站。</p><p id="86e0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">正如我们所看到的，数据中有开盘价、最高价、最低价、调整后的收盘价和其他值。然而，对于预测，我们可能不一定对精确的值感兴趣。我们需要知道的只是“转变”——例如，如果未来3天的值是25.50、28.00、29.00，那么第4天的值是多少？会涨还是会跌？</p><p id="196a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">但是在将我们的数据分为高或低之前，我们需要知道收盘、高、低和成交量值的百分比变化。</p><p id="3d50" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了使用百分比变化函数和许多其他数据操作函数，我们需要导入pandas包。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="4cf4" class="lm ig hi li b fi ln lo l lp lq">import pandas as pd</span><span id="6d6e" class="lm ig hi li b fi lr lo l lp lq"># Get the closing gap</span><span id="3a84" class="lm ig hi li b fi lr lo l lp lq">Close_Gap = dataset[‘Close’].pct_change()</span><span id="fd46" class="lm ig hi li b fi lr lo l lp lq"># The high percent change from the immediate previous row</span><span id="22d8" class="lm ig hi li b fi lr lo l lp lq">High_Gap = dataset[‘High’].pct_change()</span><span id="3b24" class="lm ig hi li b fi lr lo l lp lq">Low_Gap = dataset[‘Low’].pct_change()</span><span id="0b6a" class="lm ig hi li b fi lr lo l lp lq">Volume_Gap = dataset[‘Volume’].pct_change()</span><span id="d5d0" class="lm ig hi li b fi lr lo l lp lq">Daily_Change = (dataset[‘Close’] — dataset[‘Open’]) / dataset[‘Open’]</span><span id="5eb3" class="lm ig hi li b fi lr lo l lp lq">Outcome_Next_Day_Direction = (dataset[‘Volume’].shift(-1) — dataset[‘Volume’])</span></pre><p id="82cb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们创建一个空的新数据集，并用上面的数据和一些其他有用的细节填充它——</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="7f1b" class="lm ig hi li b fi ln lo l lp lq">new_dataset = []</span><span id="9472" class="lm ig hi li b fi lr lo l lp lq">new_dataset.append(pd.DataFrame({‘Close_Gap’:Close_Gap,</span><span id="103d" class="lm ig hi li b fi lr lo l lp lq">‘High_Gap’:High_Gap,</span><span id="a2fb" class="lm ig hi li b fi lr lo l lp lq">‘Low_Gap’:Low_Gap,</span><span id="3c3c" class="lm ig hi li b fi lr lo l lp lq">‘Volume_Gap’:Volume_Gap,</span><span id="f98c" class="lm ig hi li b fi lr lo l lp lq">‘Daily_Change’:Daily_Change,</span><span id="064c" class="lm ig hi li b fi lr lo l lp lq">‘Outcome_Next_Day_Direction’:Outcome_Next_Day_Direction}))</span></pre><p id="8585" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在让我们把新的数据集打印成-</p><p id="9bfa" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><code class="du ls lt lu li b">print(new_dataset)</code></p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lv"><img src="../Images/8291bfc8ea8fef9c204c10ffe757729b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/0*J-r15FUrtapNglWr"/></div></figure><p id="9d13" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了更清楚起见，让我们使用head()方法只获取几个值。但是我们必须首先将列表转换成DataFrame对象。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="414e" class="lm ig hi li b fi ln lo l lp lq">new_dataset_df = pd.concat(new_dataset)</span><span id="dd9c" class="lm ig hi li b fi lr lo l lp lq">print(new_dataset_df.head())</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lw"><img src="../Images/a90b656f941ab1a1d97a9ec7a07ebf7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/0*0hOvbkZJzwBYcnbd"/></div></figure><p id="1b4e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们不需要确切的数值。为了让我们的转移矩阵和概率起作用，我们需要的只是稳定状态。根据高低形态，我们可以预测未来的市场状况。</p><p id="1dce" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这意味着我们可以简单地将这些值分成三类——低、中、高——或者简而言之——L、M、h。这就是所谓的宁滨数据。</p><p id="696d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">幸运的是，Python的pandas包提供了一个函数qcut，可以将数据分成大小相等的块。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="b37e" class="lm ig hi li b fi ln lo l lp lq"># Close_Gap</span><span id="a4cd" class="lm ig hi li b fi lr lo l lp lq">new_dataset_df[‘Close_Gap_LMH’] = pd.qcut(new_dataset_df[‘Close_Gap’], 3, labels=[“L”, “M”, “H”])</span><span id="a110" class="lm ig hi li b fi lr lo l lp lq"># High_Gap</span><span id="0b15" class="lm ig hi li b fi lr lo l lp lq">new_dataset_df[‘High_Gap_LMH’] = pd.qcut(new_dataset_df[‘High_Gap’], 3, labels=[“L”, “M”, “H”])</span><span id="a79c" class="lm ig hi li b fi lr lo l lp lq"># Low_Gap</span><span id="5603" class="lm ig hi li b fi lr lo l lp lq">new_dataset_df[‘Low_Gap_LMH’] = pd.qcut(new_dataset_df[‘Low_Gap’], 3, labels=[“L”, “M”, “H”])</span><span id="53d9" class="lm ig hi li b fi lr lo l lp lq"># Volume_Gap</span><span id="5be6" class="lm ig hi li b fi lr lo l lp lq">new_dataset_df[‘Volume_Gap_LMH’] = pd.qcut(new_dataset_df[‘Volume_Gap’], 3, labels=[“L”, “M”, “H”])</span><span id="d02a" class="lm ig hi li b fi lr lo l lp lq"># Daily_Change</span><span id="d20b" class="lm ig hi li b fi lr lo l lp lq">new_dataset_df[‘Daily_Change_LMH’] = pd.qcut(new_dataset_df[‘Daily_Change’], 3, labels=[“L”, “M”, “H”])</span><span id="568c" class="lm ig hi li b fi lr lo l lp lq">With this information of L, M, H, we can find the event pattern which we get by concatenating the H L M values of close gap, volume gap and daily change –</span><span id="b821" class="lm ig hi li b fi lr lo l lp lq">new_dataset_df[‘Event_Pattern’] = new_dataset_df[‘Close_Gap_LMH’].astype(str) + new_dataset_df[‘Volume_Gap_LMH’].astype(str) + new_dataset_df[‘Daily_Change_LMH’].astype(str)</span><span id="7fde" class="lm ig hi li b fi lr lo l lp lq">print(new_dataset_df.tail(20)</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lx"><img src="../Images/0f525dec0093dfbf03bd42ebbdecde1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/0*pVQTwFpS4AIVjeIc"/></div></figure><p id="3da8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，我们看到了很多导致这种模式的变化——LML，嗯，MHH，MLH等等。让我们压缩这些数据，得到一系列事件的字符串。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ly"><img src="../Images/e429d658f942d3345bc1f7a793f0e082.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/0*vxmOX9m2K4DHqov3"/></div></figure><p id="9082" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">减少数据集，压缩它，只得到最有趣和最突出的变化，去掉弱的变化。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/3b7ac511a42f81ff2fda2ea5c34dcd51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-QAnwBVNukyEuBvq"/></div></div></figure><p id="7956" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一旦我们得到了这些，我们必须将我们的数据分成训练集和测试集。大多数数据必须进入训练集，以尽可能准确地训练模型。</p><p id="3f30" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这可以通过使用sklearn包中的train_test_split来完成。假设我们给出大约80%的数据用于训练，那么只有0.2%或20%的数据用于测试。</p><p id="1e7d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以根据outcome_next_day_direction(积极或消极)拆分数据。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="8e8f" class="lm ig hi li b fi ln lo l lp lq">compressed_set_pos = compressed_set[compressed_set[‘Outcome_Next_Day_Direction’]==1][‘Event_Pattern’]</span><span id="e41b" class="lm ig hi li b fi lr lo l lp lq">print(compressed_set_pos.shape)</span><span id="2444" class="lm ig hi li b fi lr lo l lp lq">compressed_set_neg = compressed_set[compressed_set[‘Outcome_Next_Day_Direction’]==0][‘Event_Pattern’]</span><span id="efe7" class="lm ig hi li b fi lr lo l lp lq">print(compressed_set_neg.shape)</span></pre><p id="1adf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">得到结果方向后，现在让我们构建马尔可夫网格。</p><ul class=""><li id="7083" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">从压缩集中找出唯一的事件模式。例如，LHM、MLH等</li><li id="8fcf" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">用from_event(如LMH)和to_event(如MLM)组成一个模式</li><li id="0580" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">如果找到匹配，连接模式值</li><li id="cad5" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">创建“至/自”栅格和枢轴</li><li id="44cb" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">用零填充NaN值</li><li id="9fc2" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">用正负压缩集构建转换网格</li></ul><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es me"><img src="../Images/636703b4ec15974d0719a60b3584bd82.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/0*0zG0tfnfYohkZVDi"/></div></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mf"><img src="../Images/693d0c9b06fa46dab58e914a2346268a.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/0*4OWPLnKjHeIys6PM"/></div></figure><p id="02a7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">基于这个矩阵，预测结果是简单的。我们必须找出概率，并用实际值和预测值创建一个混淆矩阵。</p><p id="d0cc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">要获得构建矩阵网格和预测结果的代码，请访问代码链接<a class="ae lf" href="https://www.youtube.com/watch?v=sdp49vTanSk&amp;t=584s" rel="noopener ugc nofollow" target="_blank"> viralml </a>。该视频基于一篇博客，详细描述了<a class="ae lf" href="https://pkghosh.wordpress.com/2015/07/06/customer-conversion-prediction-with-markov-chain-classifier/" rel="noopener ugc nofollow" target="_blank">马尔可夫链如何用于股票市场预测。</a></p><h1 id="bcb8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="86da" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">预测股票市场价值是马尔可夫原理最常见的实时应用之一。在本文中，我们试图涵盖基础知识，并继续解释如何建立一个模拟器。您可以尝试使用任何数据集在您的机器上运行代码，并检查结果的准确性。使用马尔可夫链的主要繁琐部分是清理和缩减数据集，以找到和分割数据集。接下来的部分——就是了。</p></div></div>    
</body>
</html>