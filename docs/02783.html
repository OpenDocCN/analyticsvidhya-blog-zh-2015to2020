<html>
<head>
<title>Recommendation System using collaborative filtering in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Python协同过滤的推荐系统</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/recommendation-system-using-collaborative-filtering-cc310e641fde?source=collection_archive---------2-----------------------#2020-01-02">https://medium.com/analytics-vidhya/recommendation-system-using-collaborative-filtering-cc310e641fde?source=collection_archive---------2-----------------------#2020-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="94de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">本博客用python </em>展示了一个基于 <strong class="ih hj"> <em class="jd">协同过滤的推荐系统</em> </strong> <em class="jd"/></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/352074ca4745e086ae65e416511f95b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:48/0*9p8dCwhSkqHKrPB7"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jm"><img src="../Images/d1be4ecd091f2613ad32a3cd6204c4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dqiFp9Z-1cxYJPoA.png"/></div></div></figure><p id="4f22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开始用python实现基于元数据的推荐系统之前，我建议您花4分钟阅读这篇博客，它用外行的术语定义了推荐系统及其类型。</p><p id="74f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jr" rel="noopener" href="/@saketgarodia/the-world-of-recommender-systems-e4ea504341ac?source=friends_link&amp;sk=508a980d8391daa93530a32e9c927a87">https://medium . com/@ saketgarodia/the-world-of-recommender-systems-e4ea 504341 AC？source = friends _ link&amp;sk = 508 a 980d 8391 DAA 93530 a 32 e 9c 927 a 87</a></p><p id="0de7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这篇博客，我将展示如何在Kaggle的MovieLens 100k数据集上用Python实现一个基于<strong class="ih hj"> <em class="jd">协同过滤的</em> </strong>推荐系统。</p><p id="8fb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用的数据集是Kaggle上的MovieLens 100k数据集:</p><div class="js jt ez fb ju jv"><a href="https://www.kaggle.com/prajitdatta/movielens-100k-dataset" rel="noopener  ugc nofollow" target="_blank"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hj fi z dy ka ea eb kb ed ef hh bi translated">MovieLens 100K数据集</h2><div class="kc l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">稳定的基准数据集。1000名用户对1700部电影的100，000次评分</h3></div><div class="kd l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">www.kaggle.com</p></div></div><div class="ke l"><div class="kf l kg kh ki ke kj jk jv"/></div></div></a></div><p id="d900" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始实施它。</p><h1 id="aed2" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">问题定式化</h1><p id="0a81" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated"><em class="jd">利用其他用户的力量，建立一个基于协同过滤技术推荐电影的推荐系统。</em></p><h1 id="15ff" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">履行</h1><p id="a38c" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">首先，让我们导入所有必要的库，我们将使用它们来创建一个基于内容的推荐系统。让我们也导入必要的数据文件。</p><p id="ca46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用<strong class="ih hj"> surprise </strong>包，它内置了SVD、KMean clustering等协作过滤模型。</p><pre class="jf jg jh ji fd ln lo lp lq aw lr bi"><span id="d237" class="ls kl hi lo b fi lt lu l lv lw">#importing necessary libraries</span><span id="b403" class="ls kl hi lo b fi lx lu l lv lw">import numpy as np</span><span id="e092" class="ls kl hi lo b fi lx lu l lv lw">import pandas as pd</span><span id="2ad9" class="ls kl hi lo b fi lx lu l lv lw">from sklearn.metrics.pairwise import cosine_similarity</span><span id="ff36" class="ls kl hi lo b fi lx lu l lv lw">from sklearn.metrics import mean_squared_error</span><span id="7b0e" class="ls kl hi lo b fi lx lu l lv lw">from sklearn.model_selection import train_test_split</span><span id="f43b" class="ls kl hi lo b fi lx lu l lv lw">from surprise import Reader, Dataset, KNNBasic</span><span id="5654" class="ls kl hi lo b fi lx lu l lv lw">from surprise.model_selection import cross_validate</span><span id="3a47" class="ls kl hi lo b fi lx lu l lv lw">from surprise import SVD</span><span id="cbda" class="ls kl hi lo b fi lx lu l lv lw">r_cols = ['user_id', 'movie_id', 'rating', 'timestamp']</span><span id="1f34" class="ls kl hi lo b fi lx lu l lv lw">ratings = pd.read_csv('u.data',  sep='\t', names=r_cols,</span><span id="6aa5" class="ls kl hi lo b fi lx lu l lv lw">encoding='latin-1')</span><span id="4d51" class="ls kl hi lo b fi lx lu l lv lw">ratings.head()</span><span id="a26a" class="ls kl hi lo b fi lx lu l lv lw">i_cols = ['movie_id', 'title' ,'release date','video release date', 'IMDb URL', 'unknown', 'Action', 'Adventure',</span><span id="f884" class="ls kl hi lo b fi lx lu l lv lw">'Animation', 'Children\'s', 'Comedy', 'Crime', 'Documentary', 'Drama', 'Fantasy',</span><span id="f769" class="ls kl hi lo b fi lx lu l lv lw">'Film-Noir', 'Horror', 'Musical', 'Mystery', 'Romance', 'Sci-Fi', 'Thriller', 'War', 'Western']</span><span id="f29f" class="ls kl hi lo b fi lx lu l lv lw">movies = pd.read_csv('u.item',  sep='|', names=i_cols, encoding='latin-1')</span><span id="d17e" class="ls kl hi lo b fi lx lu l lv lw">movies.head()</span><span id="bed0" class="ls kl hi lo b fi lx lu l lv lw">u_cols = ['user_id', 'age', 'sex', 'occupation', 'zip_code']</span><span id="337f" class="ls kl hi lo b fi lx lu l lv lw">users = pd.read_csv('u.user', sep='|', names=u_cols,</span><span id="4069" class="ls kl hi lo b fi lx lu l lv lw">encoding='latin-1')</span><span id="08fd" class="ls kl hi lo b fi lx lu l lv lw">users.head()</span></pre><p id="d80c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，我们有<strong class="ih hj"> 1682部独特的电影</strong>和<strong class="ih hj"> 10万的总收视率</strong>由<strong class="ih hj"> 943个用户</strong>为这些独特的电影。</p><p id="9753" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要将我们的“评级”数据框架分成两部分——第一部分训练算法来预测评级，第二部分测试预测的评级是否接近预期。这将有助于评估我们的模型。</p><p id="6fa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将y作为“用户id ”,只是为了确保分裂导致<strong class="ih hj">分层采样</strong>,并且我们在训练集中拥有所有的用户id，以使我们的算法强大。</p><pre class="jf jg jh ji fd ln lo lp lq aw lr bi"><span id="d7be" class="ls kl hi lo b fi lt lu l lv lw">#Assign X as the original ratings dataframe and y as the user_id column of ratings.</span><span id="51c2" class="ls kl hi lo b fi lx lu l lv lw">X = ratings.copy()</span><span id="12b2" class="ls kl hi lo b fi lx lu l lv lw">y = ratings[‘user_id’]</span><span id="540d" class="ls kl hi lo b fi lx lu l lv lw">#Split into training and test datasets, stratified along user_id</span><span id="adb7" class="ls kl hi lo b fi lx lu l lv lw">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, stratify=y, random_state=42)</span></pre><p id="15fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在<strong class="ih hj">培训</strong>组中有<strong class="ih hj"> 75k评级</strong>，在<strong class="ih hj">测试</strong>组中有<strong class="ih hj"> 25k </strong>来评估我们的模型。</p><pre class="jf jg jh ji fd ln lo lp lq aw lr bi"><span id="066a" class="ls kl hi lo b fi lt lu l lv lw">df_ratings = X_train.pivot(index=’user_id’, columns=’movie_id’, values=’rating’)</span><span id="002b" class="ls kl hi lo b fi lx lu l lv lw">Now, our df_ratings dataframe is indexed by user_ids with movie_ids belonging to different columns and the values are the ratings with most of the values as Nan as each user watches and rates only few movies. Its a <strong class="lo hj">sparse</strong> dataframe.</span></pre><p id="4403" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是我们稀疏评级数据框的外观:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="ab fe cl ly"><img src="../Images/09c99dca31a366a637147aaa3c3575a7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*e-_-O2gQOinDyVTN7nNTaA.png"/></div></figure><p id="4303" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将使用两种不同的方法进行协同过滤。在第一种方法中，我们将使用评级的<strong class="ih hj">加权平均值</strong>，我们将使用基于模型的分类方法实施第二种方法，如<strong class="ih hj"> KNN (K最近邻)</strong>和<strong class="ih hj"> SVD(奇异值分解)</strong>。我们稍后将讨论KNN和奇异值分解。</p><p id="5ce2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一种方法中，我们将使用余弦相似度作为权重，使用评级的<strong class="ih hj">加权平均值</strong>。与输入用户更相似的用户将在我们对输入用户的评级计算中具有更高的权重。</p><p id="f9e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先用0代替空值，因为余弦相似度对NA值不起作用，让我们继续使用评级的加权平均值来构建推荐器函数。</p><h1 id="2dcf" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><strong class="ak">方法一:加权平均法</strong></h1><pre class="jf jg jh ji fd ln lo lp lq aw lr bi"><span id="a211" class="ls kl hi lo b fi lt lu l lv lw">df_ratings_dummy = df_ratings.copy().fillna(0)</span><span id="344c" class="ls kl hi lo b fi lx lu l lv lw">df_ratings_dummy.head()<br/>#cosine similarity of the ratings</span><span id="ef54" class="ls kl hi lo b fi lx lu l lv lw">similarity_matrix = cosine_similarity(df_ratings_dummy, df_ratings_dummy)</span><span id="bfb1" class="ls kl hi lo b fi lx lu l lv lw">similarity_matrix_df = pd.DataFrame(similarity_matrix, index=df_ratings.index, columns=df_ratings.index)</span><span id="6ec5" class="ls kl hi lo b fi lx lu l lv lw">#calculate ratings using weighted sum of cosine similarity</span><span id="d9db" class="ls kl hi lo b fi lx lu l lv lw">#function to calculate ratings<br/></span><span id="8eca" class="ls kl hi lo b fi lx lu l lv lw">def calculate_ratings(id_movie, id_user):</span><span id="ff6c" class="ls kl hi lo b fi lx lu l lv lw">if id_movie in df_ratings:</span><span id="3939" class="ls kl hi lo b fi lx lu l lv lw">cosine_scores = similarity_matrix_df[id_user] #similarity of id_user with every other user</span><span id="b9d5" class="ls kl hi lo b fi lx lu l lv lw">ratings_scores = df_ratings[id_movie]      #ratings of every other user for the movie id_movie</span><span id="e89d" class="ls kl hi lo b fi lx lu l lv lw">#won't consider users who havent rated id_movie so drop similarity scores and ratings corresponsing to np.nan</span><span id="c0df" class="ls kl hi lo b fi lx lu l lv lw">index_not_rated = ratings_scores[ratings_scores.isnull()].index</span><span id="5a39" class="ls kl hi lo b fi lx lu l lv lw">ratings_scores = ratings_scores.dropna()</span><span id="b29a" class="ls kl hi lo b fi lx lu l lv lw">cosine_scores = cosine_scores.drop(index_not_rated)</span><span id="9d70" class="ls kl hi lo b fi lx lu l lv lw">#calculating rating by weighted mean of ratings and cosine scores of the users who have rated the movie</span><span id="632e" class="ls kl hi lo b fi lx lu l lv lw">ratings_movie = np.dot(ratings_scores, cosine_scores)/cosine_scores.sum()</span><span id="ddeb" class="ls kl hi lo b fi lx lu l lv lw">else:</span><span id="3312" class="ls kl hi lo b fi lx lu l lv lw">return 2.5</span><span id="57fc" class="ls kl hi lo b fi lx lu l lv lw">return ratings_movie</span></pre><p id="962f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经编写了一个函数来计算给定用户和电影的评级，让我们看看它在测试集上的表现如何。</p><pre class="jf jg jh ji fd ln lo lp lq aw lr bi"><span id="4f9b" class="ls kl hi lo b fi lt lu l lv lw">calculate_ratings(3,150) #predicts rating for user_id 150 and movie_id 3</span></pre><p id="f5cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">2.9926409218795715</p><p id="dd6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们构建一个函数score_on_test_set，它使用<strong class="ih hj"> root_mean_squared_error </strong>在测试集上评估我们的模型</p><pre class="jf jg jh ji fd ln lo lp lq aw lr bi"><span id="78a2" class="ls kl hi lo b fi lt lu l lv lw">#evaluates on test set</span><span id="c1af" class="ls kl hi lo b fi lx lu l lv lw">def score_on_test_set():</span><span id="1f92" class="ls kl hi lo b fi lx lu l lv lw">user_movie_pairs = zip(X_test[‘movie_id’], X_test[‘user_id’])</span><span id="a287" class="ls kl hi lo b fi lx lu l lv lw">predicted_ratings = np.array([calculate_ratings(movie, user) for (movie,user) in user_movie_pairs])</span><span id="c808" class="ls kl hi lo b fi lx lu l lv lw">true_ratings = np.array(X_test[‘rating’])</span><span id="03b3" class="ls kl hi lo b fi lx lu l lv lw">score = np.sqrt(mean_squared_error(true_ratings, predicted_ratings))</span><span id="7f92" class="ls kl hi lo b fi lx lu l lv lw">return score<br/>test_set_score = score_on_test_set()</span><span id="b2c9" class="ls kl hi lo b fi lx lu l lv lw">print(test_set_score)</span></pre><p id="0285" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试集上的均方误差为<strong class="ih hj"> 1.0172。</strong></p><p id="983f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> test_set的均方根误差为1.01 </strong>，这有点令人惊讶。这意味着我们的算法在使用加权平均评分来预测新用户的电影评分方面非常有效。现在让我们使用基于<strong class="ih hj">模型的</strong>方法，看看我们能在多大程度上改善均方根误差。</p><h1 id="2ee0" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">方法1:基于模型的方法</h1><p id="1734" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在基于模型的方法中，我们将使用两个模型:<strong class="ih hj"> KNN </strong>和<strong class="ih hj">奇异值分解</strong>。惊喜包内置了不同模型的库来构建推荐系统，我们将使用相同的库。</p><p id="b645" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj">基于KNN的方法</strong>中，预测是通过找到与要预测其评级的input_user相似的一群用户，然后取这些评级的平均值来完成的。KNN是一种著名的分类算法。</p><p id="755c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> SVD(奇异值分解)方法</strong>中，通过应用<strong class="ih hj">矩阵分解技术</strong>将稀疏的用户电影(收视率)矩阵压缩成密集矩阵。如果M是用户*电影矩阵，SVD将其分解为3部分:M = UZV，其中U是用户概念<em class="jd">矩阵，Z是不同概念的权重，V是概念电影</em>矩阵。“概念”可以通过把它想象成类似电影的超集来直观地理解，就像“悬疑惊悚片”类型可以是一个概念，等等。</p><p id="da73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦SVD将原始矩阵分解成3，密集矩阵就直接用于使用输入电影所属的概念来预测(用户，电影)对的评级。</p><pre class="jf jg jh ji fd ln lo lp lq aw lr bi"><span id="3a01" class="ls kl hi lo b fi lt lu l lv lw"># installing surprise library</span><span id="957b" class="ls kl hi lo b fi lx lu l lv lw">!pip install surprise</span><span id="54be" class="ls kl hi lo b fi lx lu l lv lw">#Define a Reader object</span><span id="996a" class="ls kl hi lo b fi lx lu l lv lw">#The Reader object helps in parsing the file or dataframe containing ratings</span><span id="82f3" class="ls kl hi lo b fi lx lu l lv lw">ratings = ratings.drop(columns=’timestamp’)</span><span id="ce64" class="ls kl hi lo b fi lx lu l lv lw">reader = Reader()</span><span id="e602" class="ls kl hi lo b fi lx lu l lv lw">#dataset creation</span><span id="8383" class="ls kl hi lo b fi lx lu l lv lw">data = Dataset.load_from_df(ratings, reader)</span><span id="91fd" class="ls kl hi lo b fi lx lu l lv lw">#model</span><span id="84fb" class="ls kl hi lo b fi lx lu l lv lw">knn = KNNBasic()</span><span id="3879" class="ls kl hi lo b fi lx lu l lv lw">#Evaluating the performance in terms of RMSE</span><span id="42b8" class="ls kl hi lo b fi lx lu l lv lw">cross_validate(knn, data, measures=[‘RMSE’, ‘mae’], cv = 3)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lz"><img src="../Images/b0df46bdbbf90b58b3cb521f0dba76b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*Eqzuy7j7PpxpoZBXIyW56g.png"/></div></figure><p id="bf89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，与加权平均法相比，KNN的<strong class="ih hj">均方根误差</strong>甚至进一步降低到了<strong class="ih hj"> 0.98 </strong>。在预测电影收视率方面，KNN无疑比加权平均法表现得更好。</p><p id="c2da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看看SVD的表现。</p><pre class="jf jg jh ji fd ln lo lp lq aw lr bi"><span id="aeaf" class="ls kl hi lo b fi lt lu l lv lw">#Define the SVD algorithm object</span><span id="6efc" class="ls kl hi lo b fi lx lu l lv lw">svd = SVD()</span><span id="bfee" class="ls kl hi lo b fi lx lu l lv lw">#Evaluate the performance in terms of RMSE</span><span id="08eb" class="ls kl hi lo b fi lx lu l lv lw">cross_validate(svd, data, measures=[‘RMSE’], cv = 3)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ma"><img src="../Images/9668e2d0a4a27aef41cf626b02e5959b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*cGQRk-iAHPyL3cZi__vRgA.png"/></div></figure><p id="69c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">误差甚至进一步降低到0.948的“rmse”值，这是我们使用的3种方法中最好的结果。</p><pre class="jf jg jh ji fd ln lo lp lq aw lr bi"><span id="5904" class="ls kl hi lo b fi lt lu l lv lw">trainset = data.build_full_trainset()</span><span id="b2f1" class="ls kl hi lo b fi lx lu l lv lw">svd.fit(trainset)</span><span id="8eb6" class="ls kl hi lo b fi lx lu l lv lw">ratings[ratings[‘user_id’] == 5]</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mb"><img src="../Images/cdf665ce0812b75a948f93df63d82e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*JBJwYOBuP5wljsgUWje5sQ.png"/></div></figure><pre class="jf jg jh ji fd ln lo lp lq aw lr bi"><span id="2683" class="ls kl hi lo b fi lt lu l lv lw">svd.predict(1, 110)</span></pre><p id="1d60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过<strong class="ih hj"> SVD </strong>模型对用户id 1和电影110的预测是2.14，而实际评分是2，这有点令人惊讶。</p><p id="0b0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要了解基于内容和元数据的方法，请浏览我的以下博客:</p><ol class=""><li id="08c8" class="mc md hi ih b ii ij im in iq me iu mf iy mg jc mh mi mj mk bi translated">基于内容的推荐系统:<a class="ae jr" rel="noopener" href="/@saketgarodia/content-based-recommender-systems-in-python-2b330e01eb80?source=friends_link&amp;sk=339a4eaa360453fe6952a10190ec5e9e">https://medium . com/@ saketgarodia/content-based-Recommender-Systems-in-python-2b 330 e 01 EB 80？</a></li><li id="e681" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">基于元数据的推荐系统:<a class="ae jr" rel="noopener" href="/@saketgarodia/metadata-based-recommender-systems-in-python-c6aae213b25c"><em class="jd">https://medium . com/@ saketgarodia/metadata-based-Recommender-Systems-in-python-c 6 aae 213 b 25 c</em></a></li></ol><p id="b584" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢你。</p></div></div>    
</body>
</html>