<html>
<head>
<title>Time-Cost Effective ML Model Deployment using AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Lambda进行省时高效的ML模型部署</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-cost-effective-ml-model-deployment-using-aws-lambda-8d60d8854e8e?source=collection_archive---------20-----------------------#2020-07-19">https://medium.com/analytics-vidhya/time-cost-effective-ml-model-deployment-using-aws-lambda-8d60d8854e8e?source=collection_archive---------20-----------------------#2020-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="d50c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="6496" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本文中，我将介绍在AWS lambda上部署ML模型的两种不同方法。</p><p id="5e6e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">AWS Lambda总是第一选择，因为它便宜，可自动扩展，我们只为我们提出的请求付费。</p><p id="5da0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">第一种方法是从s3 bucket读取ML模型的经典方式，对于第二种方法，ML模型将与lambda函数代码一起压缩，并直接上传到Lambda。</p><h2 id="c772" class="kg ig hi bd ih kh ki kj il kk kl km ip jo kn ko it js kp kq ix jw kr ks jb kt bi translated">方法1</h2><p id="a61a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在Lambda上部署ML模型，并将ML模型放在s3存储桶中。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/710229f034c1e648363a67547fc0cc85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uTCFY9UJqN-IlbyWnnlHew.png"/></div></div></figure><blockquote class="lg lh li"><p id="e148" class="jd je lj jf b jg kb ji jj jk kc jm jn lk kd jq jr ll ke ju jv lm kf jy jz ka hb bi translated">S <em class="hi">步骤#1 </em> <strong class="jf hj"> <em class="hi">创建压缩层</em> </strong></p></blockquote><p id="b085" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">层是包含库、自定义运行时或其他依赖项的ZIP存档。</p><p id="10d5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于我的模型，sklearn和pandas库都是必需的，因此我使用Docker创建了一个Lambda层(sklearn和pandas库)。</p><p id="1729" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">创建一个文件，将其命名为“createLayer.sh ”,并将下面的代码复制到其中。</p><pre class="kv kw kx ky fd ln lo lp lq aw lr bi"><span id="67b2" class="kg ig hi lo b fi ls lt l lu lv">if [ "$1" != "" ] || [$# -gt 1]; then</span><span id="53af" class="kg ig hi lo b fi lw lt l lu lv">echo "Creating layer compatible with python version $1"</span><span id="33be" class="kg ig hi lo b fi lw lt l lu lv">docker run -v "$PWD":/var/task "lambci/lambda:build-python$1" /bin/sh -c "pip install -r requirements.txt -t python/lib/python$1/site-packages/; exit"</span><span id="a571" class="kg ig hi lo b fi lw lt l lu lv">zip -r sklearn_pandas_layer.zip python &gt; /dev/null</span><span id="4886" class="kg ig hi lo b fi lw lt l lu lv">rm -r python</span><span id="b70b" class="kg ig hi lo b fi lw lt l lu lv">echo "Done creating layer!"</span><span id="da33" class="kg ig hi lo b fi lw lt l lu lv">ls -lah sklearn_pandas_layer.zip</span><span id="81cd" class="kg ig hi lo b fi lw lt l lu lv">else</span><span id="61e8" class="kg ig hi lo b fi lw lt l lu lv">echo "Enter python version as argument - ./createlayer.sh 3.6"</span><span id="302e" class="kg ig hi lo b fi lw lt l lu lv">fi</span></pre><p id="0d1a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，在同一个目录中，创建另一个文件‘requirements . txt’来存储您想要为其创建层的库的名称和版本。在我的例子中，我将为pandas和sklearn库创建一个层，包括下面提到的版本。</p><pre class="kv kw kx ky fd ln lo lp lq aw lr bi"><span id="8f8f" class="kg ig hi lo b fi ls lt l lu lv">pandas==0.23.4<br/>scikit-learn==0.20.3</span></pre><p id="42df" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">接下来，转到你已经放置了2个以上文件的终端，运行下面的命令为lambda层生成一个压缩文件夹。</p><p id="290b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">要运行的命令:</p><pre class="kv kw kx ky fd ln lo lp lq aw lr bi"><span id="77e3" class="kg ig hi lo b fi ls lt l lu lv">./createlayer.sh 3.6</span></pre><p id="ec48" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">生成的图层是zip格式，适合上传到s3。这个zip文件的内容应该是这样的:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lx"><img src="../Images/789c4e7183fbab7ef0bdac315897c4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61sghOZ0qxkTFPNs9o3nKg.png"/></div></div></figure><p id="7694" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">步骤#2 <strong class="jf hj">放置ML模型和Lambda层在S3 </strong></p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ly"><img src="../Images/eaadb5b51f7f60e5065d47cd66ae219c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UiBRsyQAwIdZqT9LjWB0wg.png"/></div></div></figure><p id="435e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">步骤#3 <strong class="jf hj">配置λ函数&amp;λ层</strong></p><p id="0149" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在这里，我们已经准备好了模型和lambda层。让我们通过创建一个新的lambda函数来开始配置lambda。将步骤#1中的lambda层添加到s3 bucket的函数中。</p><p id="c991" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为lambda函数添加层，点击层→创建层。如下所示定义层的配置。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lz"><img src="../Images/4d7341bc42908e25eca0b24283070d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tx0IjxH-UHCNlG0eG1b11g.png"/></div></div></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ma"><img src="../Images/23415bb98f7b59190dae8a115e9e1902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnWO3L4tutIdwJA8K2iiyw.png"/></div></div></figure><p id="84fb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当层被创建时，你在屏幕上得到下面的成功信息。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mb"><img src="../Images/bf9da1b45df392613a073481c2c3b137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7X6P2TMz5l4CcaNx5Hatw.png"/></div></div></figure><p id="33f4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">关于λ层的一些要点:-</p><ol class=""><li id="0d47" class="mc md hi jf b jg kb jk kc jo me js mf jw mg ka mh mi mj mk bi translated">Lambda层需要是压缩文件</li><li id="5c28" class="mc md hi jf b jg ml jk mm jo mn js mo jw mp ka mh mi mj mk bi translated">对于给定的lambda函数，最多可以有五个lambda层</li><li id="191b" class="mc md hi jf b jg ml jk mm jo mn js mo jw mp ka mh mi mj mk bi translated">lambda层不能大于250MB(总计，解压缩后)</li></ol><p id="8dac" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，转到Lambda function，点击“层”添加一个Lambda层。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mq"><img src="../Images/98eddc43b5fe09f51214fb223a14dae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ysunwjp1HsFjvORsjQUbRQ.png"/></div></div></figure><p id="330e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">选择自定义层选项，并选择新创建的lambda层及其特定版本。单击“添加”将其添加到Lambda函数中。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mr"><img src="../Images/688760976e2d466df6aa7aca5b0d65d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_pTpN1WMzrL5iPoGQORAxQ.png"/></div></div></figure><p id="ce8e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在lambda处理函数中编写以下代码</p><pre class="kv kw kx ky fd ln lo lp lq aw lr bi"><span id="5179" class="kg ig hi lo b fi ls lt l lu lv">import json<br/>import pickle<br/>import sklearn<br/>import boto3<br/>import pathlib<br/>import json</span><span id="292f" class="kg ig hi lo b fi lw lt l lu lv">s3 = boto3.resource('s3')<br/>filename = 'ml_model.pkl'<br/>file = pathlib.Path('/tmp/'+filename)<br/>if file.exists ():<br/>    print ("File exist")<br/>else :<br/>    s3.Bucket('deployingmlmodel').download_file(filename, '/tmp/ml_model.pkl')<br/>def lambda_handler(event, context):</span><span id="8b44" class="kg ig hi lo b fi lw lt l lu lv">    model = pickle.load(open('/tmp/'+filename, 'rb'))<br/>y    print("provide input here")<br/>    #pred = model.predict(""provide input here"")</span></pre><p id="4722" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">总的来说，lambda现在应该有1层和上面提到的Lambda函数中的代码。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ms"><img src="../Images/0052694ba803f0f7c52f28ba4bf56954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15ebjZXaUbGepfxrfijQHQ.png"/></div></div></figure><p id="c557" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们已经成功地添加了所需的依赖项(sklearn和pandas ),并在AWS Lambda上部署了ML模型。现在可以测试和查看ML模型预测了。</p><h2 id="89d3" class="kg ig hi bd ih kh ki kj il kk kl km ip jo kn ko it js kp kq ix jw kr ks jb kt bi translated">方法2</h2><p id="42aa" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通过用lambda函数压缩ML模型，将它直接上传到Lambda</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mt"><img src="../Images/da8dec092423b1ef6d9ecca854607ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZxmEd91Va3m0lzFgHi39zg.png"/></div></div></figure><p id="682c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先在Predict.py中创建一个模型文件&amp; lambda处理程序代码的压缩文件，然后将这个压缩文件(ml model和Predict.py的)上传到lambda的<em class="lj"> upload a .zip file </em>选项。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mu"><img src="../Images/15fcfadd578d307e23f2a6f71ab78eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*LuZPHeyZp2tKVA91IbG0ww.png"/></div></figure><p id="f81a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用下面突出显示的选项<em class="lj">上传. zip文件</em>将其上传到Lambda</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mv"><img src="../Images/52af38fa05974a9c03c4957b8a4700e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4MJ8EIu6dReMiYPYlBqxSg.png"/></div></div></figure><p id="2f00" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果你的压缩文件小于10MB，你可以直接从这里上传，或者先保存在s3中，然后从那里引用压缩文件。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mu"><img src="../Images/3aa1953131006eac32bee7192429d169.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*QFQE6JAGuO_Vxl8f6ukRxA.png"/></div></figure><p id="ef98" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一旦上传成功，你的Lambda函数应该是这样的。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ms"><img src="../Images/add8142d6860077c65e18a9a6c601013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ilo6oB1JBpzDAvYbIOJxw.png"/></div></div></figure><p id="cd0e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们已经成功地部署了zip格式的ML模型以及LambdaHandler代码。</p><p id="97bb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">从两个方面检查您的响应时间。对我来说，我的第一个电话在10-12秒内得到了回复，接下来的电话不到1秒。</p><h1 id="a783" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">使其生效</strong></h1><p id="e60b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">虽然Lambda方法具有成本效益，但对于第一次调用，如果Lambda容器没有运行，那么当Lambda函数被调用时，它必须在Lambda运行时环境中下载Lambda容器，这是一个耗时的过程。</p><p id="4651" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以这里的问题是，如何从第一次调用开始就使Lambda逼近时间有效？</p><p id="ab97" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">按照下面解释的过程添加lambda触发器，在使用lambda方法进行ML模型部署时，可以节省一些时间。</p><p id="d6dc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">添加lambda触发器的步骤:</strong>添加一个CloudWatch事件来保持lambda的热度，并确保Lambda容器一直在运行。在下面的截图中，我创建了一个新的规则来触发Lambda函数' DeployMlModel '每5分钟触发一次，这样它就会不断地检查模型是否可用，否则就下载它。因此，它将使ML模型始终可用，而不是在api调用期间下载模型。它还可以被配置为在特定的时间段运行，例如营业时间或非营业时间。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ms"><img src="../Images/8969d73f71b75d5860fa77646895873a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWtpPOxDvUpErZ4RFqnoeQ.png"/></div></div></figure><p id="e02b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">创建规则后，您可以查看它，如下所示。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mw"><img src="../Images/3568996a1893af50036213a3b94a190b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ptv2MJ_haV-9bOrPHIOdNA.png"/></div></div></figure><p id="0736" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在下面的截图中，你还可以看到一个触发器被添加到Lambda中。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mx"><img src="../Images/164f9f131641df9f79bd1405ab7e3753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yus8H3fau76IRVl1HO4VfQ.png"/></div></div></figure><p id="3959" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在CloudWatch日志中，您可以验证Lambda每5分钟调用一次，因此它将从s3下载模型，响应时间将大大减少。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es my"><img src="../Images/52f8cfcc9da3e330363f968720e48a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*205Vh6JBFo1DWFNuhtlDDA.png"/></div></div></figure><p id="e87d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在有了CloudWatch event，即使是第一次调用的响应时间也不到1秒。</p><h1 id="4ae6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">最终注释</h1><p id="dbba" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">lambda的唯一缺陷是它的部署包大小限制为250MB。这意味着您可以压缩到一个部署包中的代码/依赖项的大小仅限于250MB。因此，如果你的代码和lambda层的大小超过了大小限制，你会收到下面的错误。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mz"><img src="../Images/9c4fc4b34d95055df7e6ad02185c6735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qZKxPXlcONev0CH4EDwyw.png"/></div></div></figure><p id="7d7e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我希望你喜欢这篇文章，下面是我写这篇文章时提到的几个链接:</p><h1 id="fd77" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考</h1><p id="8f00" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">创建lambda层</p><p id="0edf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><a class="ae na" href="https://aws.amazon.com/premiumsupport/knowledge-center/lambda-layer-simulated-docker/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/premium support/knowledge-center/lambda-layer-simulated-docker/</a></p><p id="a696" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Lambda的云观察事件</p><p id="fe26" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><a class="ae na" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/RunLambdaSchedule.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/Amazon cloud watch/latest/events/runlambdaschedule . html</a></p></div></div>    
</body>
</html>