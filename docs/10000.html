<html>
<head>
<title>Deep Learning Project — Handwritten Digit Recognition using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习项目——使用Python进行手写数字识别</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deep-learning-project-handwritten-digit-recognition-using-python-14a55901eec9?source=collection_archive---------8-----------------------#2020-09-29">https://medium.com/analytics-vidhya/deep-learning-project-handwritten-digit-recognition-using-python-14a55901eec9?source=collection_archive---------8-----------------------#2020-09-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="1a51" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Python深度学习项目</h1><p id="084e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了让机器更加智能，开发人员正在钻研机器学习和深度学习技术。人类通过一次又一次的练习和重复来学习完成一项任务，这样它就记住了如何完成任务。然后他大脑中的神经元自动触发，他们可以快速执行他们所学的任务。深度学习也和这个很像。它针对不同类型的问题使用不同类型的神经网络架构。例如，对象识别、图像和声音分类、对象检测、图像分割等。</p><h1 id="91b0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是手写数字识别？</h1><p id="a832" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">手写数字识别是计算机识别人类手写数字的能力。这对机器来说是一项艰巨的任务，因为手写数字并不完美，可以有许多不同的风格。手写数字识别是这个问题的解决方案，它使用数字的图像并识别图像中存在的数字。</p><h1 id="7c33" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">关于Python深度学习项目</h1><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/39f81c6008404ca900914069d140f762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R6ZeFI0R2uYKTNhs.gif"/></div></div></figure><p id="d083" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">在本文中，我们将使用MNIST数据集实现一个手写数字识别应用程序。我们将使用一种特殊类型的深度神经网络，即<strong class="jf hj"> <em class="ks">卷积神经网络</em> </strong>。最后，我们将构建一个GUI，您可以在其中绘制数字并立即识别它。</p><h1 id="6035" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">先决条件</h1><p id="d348" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有趣的Python项目要求你具备Python编程的基础知识，深度学习Keras库，以及构建GUI的Tkinter库。</p><p id="ba6d" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">使用以下命令为此项目安装必要的库:</p><p id="5379" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">pip安装NumPy，TensorFlow，Keras，pillow，</p><h1 id="d617" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">MNIST数据集</h1><p id="8903" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这可能是机器学习和深度学习爱好者中最受欢迎的数据集之一。MNIST数据集包含6万张从0到9的手写数字的训练图像和1万张用于测试的图像。因此，MNIST数据集有10个不同的类。手写数字图像被表示为28×28的矩阵，其中每个单元包含一个灰度像素值。</p><h1 id="9860" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">基于手写数字识别构建Python深度学习项目</h1><p id="c520" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下面是实现手写数字识别项目的步骤:</p><h1 id="07e2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">1.导入库并加载数据集</h1><p id="26ae" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">首先，我们将导入训练模型所需的所有模块。Keras图书馆已经包含了一些数据集，MNIST就是其中之一。因此，我们可以轻松地导入数据集并开始使用它。mnist.load_data()方法返回训练数据及其标签，以及测试数据及其标签。</p><pre class="kc kd ke kf fd kt ku kv kw aw kx bi"><span id="d706" class="ky ig hi ku b fi kz la l lb lc">import keras</span><span id="372f" class="ky ig hi ku b fi ld la l lb lc">from keras.datasets import mnist</span><span id="6ac1" class="ky ig hi ku b fi ld la l lb lc">from keras.models import Sequential</span><span id="1712" class="ky ig hi ku b fi ld la l lb lc">from keras.layers import Dense, Dropout, Flatten</span><span id="71ae" class="ky ig hi ku b fi ld la l lb lc">from keras.layers import Conv2D, MaxPooling2D</span><span id="a9ea" class="ky ig hi ku b fi ld la l lb lc">from keras import backend as K</span><span id="de60" class="ky ig hi ku b fi ld la l lb lc"># the data, split between train and test sets</span><span id="fdfe" class="ky ig hi ku b fi ld la l lb lc">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><span id="34d8" class="ky ig hi ku b fi ld la l lb lc">print(x_train.shape, y_train.shape)</span></pre><h1 id="3470" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">2.预处理数据</h1><p id="81cb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">图像数据不能直接输入到模型中，因此我们需要执行一些操作并处理数据，以便为我们的神经网络做好准备。训练数据的维数为(60000，28，28)。CNN模型将需要多一个维度，因此我们将矩阵整形为(60000，28，28，1)。</p><pre class="kc kd ke kf fd kt ku kv kw aw kx bi"><span id="b915" class="ky ig hi ku b fi kz la l lb lc">x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)</span><span id="da26" class="ky ig hi ku b fi ld la l lb lc">x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)</span><span id="2873" class="ky ig hi ku b fi ld la l lb lc">input_shape = (28, 28, 1)</span><span id="7f5d" class="ky ig hi ku b fi ld la l lb lc"># convert class vectors to binary class matrices</span><span id="7819" class="ky ig hi ku b fi ld la l lb lc">y_train = keras.utils.to_categorical(y_train, num_classes)</span><span id="c4da" class="ky ig hi ku b fi ld la l lb lc">y_test = keras.utils.to_categorical(y_test, num_classes)</span><span id="2590" class="ky ig hi ku b fi ld la l lb lc">x_train = x_train.astype(‘float32’)</span><span id="2950" class="ky ig hi ku b fi ld la l lb lc">x_test = x_test.astype(‘float32’)</span><span id="9e69" class="ky ig hi ku b fi ld la l lb lc">x_train /= 255</span><span id="bd77" class="ky ig hi ku b fi ld la l lb lc">x_test /= 255</span><span id="f1b1" class="ky ig hi ku b fi ld la l lb lc">print(‘x_train shape:’, x_train.shape)</span><span id="2d2f" class="ky ig hi ku b fi ld la l lb lc">print(x_train.shape[0], ‘train samples’)</span><span id="82c0" class="ky ig hi ku b fi ld la l lb lc">print(x_test.shape[0], ‘test samples’)</span></pre><h1 id="3c71" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">3.创建模型</h1><p id="7390" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们将在Python数据科学项目中创建我们的CNN模型。CNN模型通常由卷积层和池层组成。它对以网格结构表示的数据更有效，这就是为什么CNN对图像分类问题有效的原因。丢弃层用于停用一些神经元，并且在训练时，它降低模型的拟合度。然后，我们将使用Adadelta优化器编译该模型。</p><pre class="kc kd ke kf fd kt ku kv kw aw kx bi"><span id="b82f" class="ky ig hi ku b fi kz la l lb lc">batch_size = 128</span><span id="bb2b" class="ky ig hi ku b fi ld la l lb lc">num_classes = 10</span><span id="3174" class="ky ig hi ku b fi ld la l lb lc">epochs = 10</span><span id="a443" class="ky ig hi ku b fi ld la l lb lc">model = Sequential()</span><span id="fede" class="ky ig hi ku b fi ld la l lb lc">model.add(Conv2D(32, kernel_size=(3, 3),activation=’relu’,input_shape=input_shape))</span><span id="6383" class="ky ig hi ku b fi ld la l lb lc">model.add(Conv2D(64, (3, 3), activation=’relu’))</span><span id="407c" class="ky ig hi ku b fi ld la l lb lc">model.add(MaxPooling2D(pool_size=(2, 2)))</span><span id="069a" class="ky ig hi ku b fi ld la l lb lc">model.add(Dropout(0.25))</span><span id="b57a" class="ky ig hi ku b fi ld la l lb lc">model.add(Flatten())</span><span id="89de" class="ky ig hi ku b fi ld la l lb lc">model.add(Dense(256, activation=’relu’))</span><span id="271c" class="ky ig hi ku b fi ld la l lb lc">model.add(Dropout(0.5))</span><span id="0a47" class="ky ig hi ku b fi ld la l lb lc">model.add(Dense(num_classes, activation=’softmax’))</span><span id="6c7c" class="ky ig hi ku b fi ld la l lb lc">model.compile(loss=keras.losses.categorical_crossentropy,optimizer=keras.optimizers.Adadelta(),metrics=[‘accuracy’])</span></pre><h1 id="fd58" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">4.训练模型</h1><p id="da94" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Keras的model.fit()函数将开始模型的训练。它需要训练数据、验证数据、时期和批量大小。</p><p id="68ec" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">训练模型需要一些时间。训练后，我们将权重和模型定义保存在“mnist.h5”文件中。</p><pre class="kc kd ke kf fd kt ku kv kw aw kx bi"><span id="8e70" class="ky ig hi ku b fi kz la l lb lc">hist = model.fit(x_train, y_train,batch_size=batch_size,epochs=epochs,verbose=1,validation_data=(x_test, y_test))</span><span id="d723" class="ky ig hi ku b fi ld la l lb lc">print(“The model has successfully trained”)</span><span id="13a8" class="ky ig hi ku b fi ld la l lb lc">model.save(‘mnist.h5’)</span><span id="b222" class="ky ig hi ku b fi ld la l lb lc">print(“Saving the model as mnist.h5”)</span></pre><h1 id="5761" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">5.评估模型</h1><p id="8d6d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们的数据集中有10，000张图片，这些图片将用于评估我们的模型的效果。测试数据没有包含在数据的训练中，因此，它是我们模型的新数据。MNIST数据集非常均衡，因此我们可以获得大约99%的准确率。</p><pre class="kc kd ke kf fd kt ku kv kw aw kx bi"><span id="4713" class="ky ig hi ku b fi kz la l lb lc">score = model.evaluate(x_test, y_test, verbose=0)</span><span id="9292" class="ky ig hi ku b fi ld la l lb lc">print(‘Test loss:’, score[0])</span><span id="ffa9" class="ky ig hi ku b fi ld la l lb lc">print(‘Test accuracy:’, score[1])</span></pre><h1 id="6f06" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">6.创建GUI来预测数字</h1><p id="79ab" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在对于GUI，我们已经创建了一个新文件，在其中我们构建了一个交互式窗口来在画布上绘制数字，通过一个按钮，我们可以识别数字。Tkinter库来自Python标准库。我们创建了一个函数predict_digit()，它将图像作为输入，然后使用训练好的模型来预测数字。</p><p id="8214" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">然后我们创建App类，它负责为我们的应用程序构建GUI。我们创建一个画布，我们可以通过捕获鼠标事件来绘制画布，并使用一个按钮来触发predict_digit()函数并显示结果。</p><p id="365f" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">以下是我们的gui_digit_recognizer.py文件的完整代码:</p><pre class="kc kd ke kf fd kt ku kv kw aw kx bi"><span id="85c0" class="ky ig hi ku b fi kz la l lb lc">from keras.models import load_model</span><span id="808e" class="ky ig hi ku b fi ld la l lb lc">from tkinter import *</span><span id="77e8" class="ky ig hi ku b fi ld la l lb lc">import tkinter as tk</span><span id="47df" class="ky ig hi ku b fi ld la l lb lc">import win32gui</span><span id="d74b" class="ky ig hi ku b fi ld la l lb lc">from PIL import ImageGrab, Image</span><span id="e29b" class="ky ig hi ku b fi ld la l lb lc">import numpy as np</span><span id="3d3d" class="ky ig hi ku b fi ld la l lb lc">model = load_model(‘mnist.h5’)</span><span id="1dd9" class="ky ig hi ku b fi ld la l lb lc"><strong class="ku hj">def</strong> predict_digit(img):</span><span id="6e6d" class="ky ig hi ku b fi ld la l lb lc">#resize image to 28x28 pixels</span><span id="c445" class="ky ig hi ku b fi ld la l lb lc">img = img.resize((28,28))</span><span id="b5f9" class="ky ig hi ku b fi ld la l lb lc">#convert rgb to grayscale</span><span id="a17c" class="ky ig hi ku b fi ld la l lb lc">img = img.convert(‘L’)</span><span id="34ff" class="ky ig hi ku b fi ld la l lb lc">img = np.array(img)</span><span id="418c" class="ky ig hi ku b fi ld la l lb lc">#reshaping to support our model input and normalizing</span><span id="7b18" class="ky ig hi ku b fi ld la l lb lc">img = img.reshape(1,28,28,1)</span><span id="4518" class="ky ig hi ku b fi ld la l lb lc">img = img/255.0</span><span id="d9bf" class="ky ig hi ku b fi ld la l lb lc">#predicting the class</span><span id="7aa3" class="ky ig hi ku b fi ld la l lb lc">res = model.predict([img])[0]</span><span id="5615" class="ky ig hi ku b fi ld la l lb lc"><strong class="ku hj">return</strong> np.argmax(res), max(res)</span><span id="9900" class="ky ig hi ku b fi ld la l lb lc"><strong class="ku hj">class</strong> App(tk.Tk):</span><span id="b81d" class="ky ig hi ku b fi ld la l lb lc"><strong class="ku hj">def</strong> __init__(self):</span><span id="bfbe" class="ky ig hi ku b fi ld la l lb lc">tk.Tk.__init__(self)</span><span id="8a08" class="ky ig hi ku b fi ld la l lb lc">self.x = self.y = 0</span><span id="d4a3" class="ky ig hi ku b fi ld la l lb lc"># Creating elements</span><span id="2343" class="ky ig hi ku b fi ld la l lb lc">self.canvas = tk.Canvas(self, width=300, height=300, bg = “white”, cursor=”cross”)</span><span id="80fb" class="ky ig hi ku b fi ld la l lb lc">self.label = tk.Label(self, text=”Thinking..”, font=(“Helvetica”, 48))</span><span id="0331" class="ky ig hi ku b fi ld la l lb lc">self.classify_btn = tk.Button(self, text = “Recognise”, command = self.classify_handwriting)</span><span id="25fc" class="ky ig hi ku b fi ld la l lb lc">self.button_clear = tk.Button(self, text = “Clear”, command = self.clear_all)</span><span id="6ed7" class="ky ig hi ku b fi ld la l lb lc"># Grid structure</span><span id="adf3" class="ky ig hi ku b fi ld la l lb lc">self.canvas.grid(row=0, column=0, pady=2, sticky=W, )</span><span id="ba18" class="ky ig hi ku b fi ld la l lb lc">self.label.grid(row=0, column=1,pady=2, padx=2)</span><span id="b7a1" class="ky ig hi ku b fi ld la l lb lc">self.classify_btn.grid(row=1, column=1, pady=2, padx=2)</span><span id="e3cb" class="ky ig hi ku b fi ld la l lb lc">self.button_clear.grid(row=1, column=0, pady=2)</span><span id="80d2" class="ky ig hi ku b fi ld la l lb lc">#self.canvas.bind(“&lt;Motion&gt;”, self.start_pos)</span><span id="2b32" class="ky ig hi ku b fi ld la l lb lc">self.canvas.bind(“&lt;B1-Motion&gt;”, self.draw_lines)</span><span id="a39f" class="ky ig hi ku b fi ld la l lb lc"><strong class="ku hj">def</strong> clear_all(self):</span><span id="eff7" class="ky ig hi ku b fi ld la l lb lc">self.canvas.delete(“all”)</span><span id="e9cc" class="ky ig hi ku b fi ld la l lb lc"><strong class="ku hj">def</strong> classify_handwriting(self):</span><span id="0f4e" class="ky ig hi ku b fi ld la l lb lc">HWND = self.canvas.winfo_id() # get the handle of the canvas</span><span id="12eb" class="ky ig hi ku b fi ld la l lb lc">rect = win32gui.GetWindowRect(HWND) # get the coordinate of the canvas</span><span id="e35b" class="ky ig hi ku b fi ld la l lb lc">im = ImageGrab.grab(rect)</span><span id="a5a1" class="ky ig hi ku b fi ld la l lb lc">digit, acc = predict_digit(im)</span><span id="4edf" class="ky ig hi ku b fi ld la l lb lc">self.label.configure(text= str(digit)+’, ‘+ str(int(acc*100))+’%’)</span><span id="dcfd" class="ky ig hi ku b fi ld la l lb lc"><strong class="ku hj">def</strong> draw_lines(self, event):</span><span id="c27d" class="ky ig hi ku b fi ld la l lb lc">self.x = event.x</span><span id="0f8b" class="ky ig hi ku b fi ld la l lb lc">self.y = event.y</span><span id="ed88" class="ky ig hi ku b fi ld la l lb lc">r=8</span><span id="52cb" class="ky ig hi ku b fi ld la l lb lc">self.canvas.create_oval(self.x-r, self.y-r, self.x + r, self.y + r, fill=’black’)</span><span id="9d4f" class="ky ig hi ku b fi ld la l lb lc">app = App()</span><span id="b8de" class="ky ig hi ku b fi ld la l lb lc">mainloop()</span></pre><p id="029a" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">截图:</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es le"><img src="../Images/1c209cdcd9b942d1766dbd70501e4b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/0*1slL-fDxy1zAIPOB.png"/></div></figure><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lf"><img src="../Images/b2433fc118e537fc80e54fbd0ca2d5f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/0*hFBMKQC7zsnO1pWD.png"/></div></figure><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lg"><img src="../Images/ead3f4416ea7b319b174f2908602eea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/0*fXY3USoMEeXpUd14.png"/></div></figure><h1 id="99aa" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">摘要</h1><p id="2e97" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这篇文章中，我们成功地在手写数字识别app上构建了一个Python深度学习项目。我们已经建立并训练了卷积神经网络，它对于图像分类非常有效。稍后，我们构建GUI，在画布上绘制一个数字，然后对数字进行分类并显示结果。</p></div></div>    
</body>
</html>