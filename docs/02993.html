<html>
<head>
<title>StatefulWidget vs StatelessWidget in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有状态小部件vs无状态小部件</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/statefulwidget-vs-statelesswidget-in-flutter-d38765fa5a76?source=collection_archive---------8-----------------------#2020-01-11">https://medium.com/analytics-vidhya/statefulwidget-vs-statelesswidget-in-flutter-d38765fa5a76?source=collection_archive---------8-----------------------#2020-01-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3a6242c637a9241522668c379e35730a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AQrtNPrzb5QEumzHlEuBg.jpeg"/></div></div></figure><h1 id="752c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">无状态小部件</h1><p id="de34" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">无状态窗口小部件是指这样的窗口小部件，当您更新绑定到它的任何值时，您希望创建一个不需要动态更改的UI。例如，如果您想制作一个标题不需要动态更改的按钮，那么您可以为按钮创建一个单独的小部件作为无状态小部件。</p><p id="826e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">顾名思义，无状态小部件是不可变的。</p><p id="8a88" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">无状态小部件保持不变，即使用户与它们交互。这种小部件没有状态，所以它们不能根据一个内部状态而改变。它们只能对更高的小部件变化做出反应。</p><p id="ef94" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">无状态窗口小部件不能在应用运行时改变它们的状态，这意味着当应用运行时窗口小部件不能被重绘。</p><p id="dabd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们从传统的“Hello World”示例开始</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e1db" class="la ir hi kw b fi lb lc l ld le">import 'package:flutter/material.dart';</span><span id="290f" class="la ir hi kw b fi lf lc l ld le">void main() =&gt; runApp(MyHome());<br/></span><span id="362b" class="la ir hi kw b fi lf lc l ld le">class MyHome extends StatelessWidget {</span><span id="4e37" class="la ir hi kw b fi lf lc l ld le">const MyHome({Key key}) : super(key: key);</span><span id="b30b" class="la ir hi kw b fi lf lc l ld le">@override</span><span id="0234" class="la ir hi kw b fi lf lc l ld le">Widget build(BuildContext context) {</span><span id="f664" class="la ir hi kw b fi lf lc l ld le">return MaterialApp(</span><span id="b6ce" class="la ir hi kw b fi lf lc l ld le">home: Scaffold(</span><span id="ce05" class="la ir hi kw b fi lf lc l ld le">appBar: AppBar(title: Text("Stateless Widget Demo",)),</span><span id="827f" class="la ir hi kw b fi lf lc l ld le">body: Center(</span><span id="9e03" class="la ir hi kw b fi lf lc l ld le">child: Text("Hello World,"),</span><span id="7810" class="la ir hi kw b fi lf lc l ld le">), ), );</span><span id="c10b" class="la ir hi kw b fi lf lc l ld le">} }</span></pre><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/6f58c4e1d08ca9ea736b56e8d1b472c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FC84ueo77cF9IsEniw4gew.png"/></div></div></figure></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="54b8" class="iq ir hi bd is it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn bi translated">有状态小部件</h1><p id="338a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">有状态窗口小部件与无状态窗口小部件正好相反。这意味着当您想要根据用户与它的交互方式动态地改变某些东西时，您可以使用有状态小部件。例如，如果您想在单击按钮时更改应用程序的背景颜色，在这种情况下，您可以使用有状态小部件。</p><p id="b741" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">有状态小部件可以包含另一个无状态小部件，反之亦然。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="7f39" class="la ir hi kw b fi lb lc l ld le">class MyHomePage extends StatefulWidget {</span><span id="ec54" class="la ir hi kw b fi lf lc l ld le"><em class="lt">@override</em></span><span id="8c62" class="la ir hi kw b fi lf lc l ld le">_MyHomePageState createState() =&gt; _MyHomePageState();</span><span id="8732" class="la ir hi kw b fi lf lc l ld le">}</span><span id="ed50" class="la ir hi kw b fi lf lc l ld le">class _MyHomePageState extends State&lt;MyHomePage&gt; {</span><span id="f2ae" class="la ir hi kw b fi lf lc l ld le"><em class="lt">@override</em></span><span id="a39c" class="la ir hi kw b fi lf lc l ld le">Widget build(BuildContext context) {</span><span id="ba50" class="la ir hi kw b fi lf lc l ld le">return MaterialApp(</span><span id="4279" class="la ir hi kw b fi lf lc l ld le">home: Scaffold(</span><span id="50c3" class="la ir hi kw b fi lf lc l ld le">appBar: AppBar(title: Text("Stateless Widget Demo",)),</span><span id="87cf" class="la ir hi kw b fi lf lc l ld le">body: Center(</span><span id="32d4" class="la ir hi kw b fi lf lc l ld le">child: Text("Hello World,"),</span><span id="785b" class="la ir hi kw b fi lf lc l ld le">), ), );</span><span id="4fb4" class="la ir hi kw b fi lf lc l ld le">}</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="f88e" class="iq ir hi bd is it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn bi translated">有状态小部件生命周期</h1><p id="58cd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">生命周期有以下简化的步骤:</p><ul class=""><li id="437f" class="lu lv hi jq b jr km jv kn jz lw kd lx kh ly kl lz ma mb mc bi translated">创建状态()</li><li id="a082" class="lu lv hi jq b jr md jv me jz mf kd mg kh mh kl lz ma mb mc bi translated">已安装==真</li><li id="43f3" class="lu lv hi jq b jr md jv me jz mf kd mg kh mh kl lz ma mb mc bi translated">initState()</li><li id="16d1" class="lu lv hi jq b jr md jv me jz mf kd mg kh mh kl lz ma mb mc bi translated">didChangeDependencies()</li><li id="05fe" class="lu lv hi jq b jr md jv me jz mf kd mg kh mh kl lz ma mb mc bi translated">构建()</li><li id="c7a4" class="lu lv hi jq b jr md jv me jz mf kd mg kh mh kl lz ma mb mc bi translated">didUpdateWidget()</li><li id="4043" class="lu lv hi jq b jr md jv me jz mf kd mg kh mh kl lz ma mb mc bi translated">setState()</li><li id="d05b" class="lu lv hi jq b jr md jv me jz mf kd mg kh mh kl lz ma mb mc bi translated">停用()</li><li id="de3d" class="lu lv hi jq b jr md jv me jz mf kd mg kh mh kl lz ma mb mc bi translated">处置()</li><li id="b667" class="lu lv hi jq b jr md jv me jz mf kd mg kh mh kl lz ma mb mc bi translated">已安装==假</li></ul><p id="6272" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一言以蔽之:执行。</p><p id="2e60" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">tldr的适应是状态对象看起来是永久的，然而StatefulWidgets(和所有的Widget子类)在设置改变时被丢弃和重新构建。对Flutter来说，修改一个非永久性的小玩意是非常经济的。</p><p id="0028" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">由于State不会在每次重构时不堪重负，它会避开代价高昂的计算，并在每次逐行重构时获取states属性、getters、setters等等。</p><p id="0ed8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">重要的是这是允许颤振活动存在的东西。因为状态不会被丢弃，所以它可以根据信息的变化不断地修改它的小部件，并且在需要时，假设有任何变化。</p><blockquote class="mi mj mk"><p id="f92a" class="jo jp lt jq b jr km jt ju jv kn jx jy ml ko kb kc mm kp kf kg mn kq kj kk kl hb bi translated"><strong class="jq hj"> createState() </strong></p></blockquote><p id="bd23" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当Flutter被告知要创建一个<strong class="jq hj"> StatefulWidget </strong>时，它会立即调用<strong class="jq hj"> createState() </strong>。这种技术必须存在。偶尔一个StatefulWidget应该比这个更混乱。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2d96" class="la ir hi kw b fi lb lc l ld le">class MyHomePage extends StatefulWidget {<br/>  @override<br/>  _MyHomePageState createState() =&gt; new _MyHomePageState();<br/>}</span></pre><blockquote class="mi mj mk"><p id="b17b" class="jo jp lt jq b jr km jt ju jv kn jx jy ml ko kb kc mm kp kf kg mn kq kj kk kl hb bi translated"><strong class="jq hj">挂载为真</strong></p></blockquote><p id="8679" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当<strong class="jq hj"> createState </strong>成为State类时，一个<strong class="jq hj"> buildContext </strong>被分配给该状态。</p><p id="b9bd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一个<strong class="jq hj"> BuildContext </strong>是小部件树中设置这个小部件的位置，这个位置非常混乱。这里有一个更长的澄清。</p><p id="a00b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">所有小部件都有一个bool this.mounted属性。当buildContext被指定时，它变成the。当小部件被卸载时调用setState是一个错误。</p><p id="a647" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">提示:当您所在州的策略调用setState()时，该属性很有价值，但不清楚何时或多久会调用该技术。也许它是由一股清新的溪流带来的。在调用setState()之前，可以利用if (mounted) {…来确保状态存在。</p><blockquote class="mi mj mk"><p id="cb31" class="jo jp lt jq b jr km jt ju jv kn jx jy ml ko kb kc mm kp kf kg mn kq kj kk kl hb bi translated"><strong class="jq hj"> initState() </strong></p></blockquote><p id="e18c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是创建小部件时调用的第一个方法(当然是在类构造函数之后。)</p><p id="e7b6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><code class="du mo mp mq kw b"><strong class="jq hj">initState</strong></code>被调用一次<strong class="jq hj">且只有一次</strong>。它还必须调用<code class="du mo mp mq kw b">super.initState()</code>。</p><p id="3c5e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这种<code class="du mo mp mq kw b">@override</code>方法的最佳时机是:</p><p id="6728" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为创建的小部件实例初始化依赖于特定BuildContext的数据。初始化依赖于树中此小部件“父”的属性。</p><p id="a0a8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">订阅Streams、ChangeNotifiers或任何其他可能更改此小部件上的数据的对象。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="992b" class="la ir hi kw b fi lb lc l ld le">@override<br/>initState() {<br/>  super.initState();<br/>  // Add listeners to this class<br/>  cartItemStream.listen((data) {<br/>    _updateWidget(data);<br/>  });<br/>}</span></pre><blockquote class="mi mj mk"><p id="252f" class="jo jp lt jq b jr km jt ju jv kn jx jy ml ko kb kc mm kp kf kg mn kq kj kk kl hb bi translated"><strong class="jq hj">didChangeDependencies()</strong></p></blockquote><p id="7650" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">第一次构建小部件时，在<code class="du mo mp mq kw b">initState</code>之后立即调用didChangeDependencies方法。</p><p id="7207" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">每当这个小部件<em class="lt">依赖于来自</em>的数据的对象被调用时，它也会被调用。例如，如果它依赖于InheritedWidget，则更新。</p><p id="5681" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><code class="du mo mp mq kw b">build</code>是不是<strong class="jq hj">总是在<code class="du mo mp mq kw b">didChangeDependencies</code>被调用之后</strong>才被调用，所以这个很少需要。然而，这个方法是你必须调用的第一个变化<code class="du mo mp mq kw b">BuildContext.inheritFromWidgetOfExactType</code>。这实际上会使这个状态“监听”它从其继承数据的小部件上的变化。</p><p id="7866" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">文档还建议，如果您需要在InheritedWidget更新时进行网络调用(或任何其他昂贵的操作),这可能会很有用。</p><blockquote class="mi mj mk"><p id="2d2a" class="jo jp lt jq b jr km jt ju jv kn jx jy ml ko kb kc mm kp kf kg mn kq kj kk kl hb bi translated"><strong class="jq hj"> build() </strong></p></blockquote><p id="45ca" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">它是必需的，<code class="du mo mp mq kw b">@override</code>并且必须返回一个<code class="du mo mp mq kw b">Widget</code>。</p><blockquote class="mi mj mk"><p id="1f37" class="jo jp lt jq b jr km jt ju jv kn jx jy ml ko kb kc mm kp kf kg mn kq kj kk kl hb bi translated"><strong class="jq hj"> didUpdateWidget </strong></p></blockquote><p id="3323" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果父窗口小部件改变了，必须重新构建这个窗口小部件(因为它需要给它不同的数据)，但是它是用同一个<code class="du mo mp mq kw b">runtimeType</code>重新构建的，那么这个方法被调用。</p><p id="2bb3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是因为Flutter正在重用寿命较长的<code class="du mo mp mq kw b">state</code>。在这种情况下，需要再次初始化一些数据，就像在<code class="du mo mp mq kw b">initState()</code>中一样。</p><p id="51e9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果状态的<code class="du mo mp mq kw b">build()</code>方法依赖于一个流或其他可以改变的对象，那么在<code class="du mo mp mq kw b">didUpdateWidget()</code>中取消订阅旧对象并重新订阅新实例。</p><p id="ba3b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在这之后，Flutter总是调用<code class="du mo mp mq kw b">build()</code>，因此任何后续的对<code class="du mo mp mq kw b">setState</code>的调用都是多余的。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8991" class="la ir hi kw b fi lb lc l ld le">@override<br/>void didUpdateWidget(Widget oldWidget) {<br/>  if (oldWidget.importantProperty != widget.importantProperty) {<br/>    _init();<br/>  }<br/>}</span></pre><blockquote class="mi mj mk"><p id="57e2" class="jo jp lt jq b jr km jt ju jv kn jx jy ml ko kb kc mm kp kf kg mn kq kj kk kl hb bi translated"><strong class="jq hj"> setState() </strong></p></blockquote><p id="d79d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">'<strong class="jq hj"> setState </strong>()'方法经常被Flutter框架本身和开发人员调用。</p><p id="a740" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">它用来通知框架“数据已经改变”，这个<code class="du mo mp mq kw b">build context</code>处的小部件应该被重建。</p><p id="73e2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><code class="du mo mp mq kw b">setState()</code>接受一个<strong class="jq hj">不能异步</strong>的回调。正是因为这个原因，它可以根据需要经常被调用，因为重画成本很低:-)</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="0225" class="la ir hi kw b fi lb lc l ld le">void updateProfile(String name) {<br/> setState(() =&gt; this.name = name);<br/>}</span></pre><blockquote class="mi mj mk"><p id="b109" class="jo jp lt jq b jr km jt ju jv kn jx jy ml ko kb kc mm kp kf kg mn kq kj kk kl hb bi translated"><strong class="jq hj">停用()</strong></p></blockquote><p id="f1df" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">取消激活</strong>()’在<code class="du mo mp mq kw b">State</code>从树中移除时被调用，<em class="lt">但在当前帧变化完成前可能会被重新插入</em>。这种方法的存在基本上是因为<code class="du mo mp mq kw b">State</code>对象可以从树中的一点移动到另一点。</p><blockquote class="mi mj mk"><p id="ac5d" class="jo jp lt jq b jr km jt ju jv kn jx jy ml ko kb kc mm kp kf kg mn kq kj kk kl hb bi translated"><strong class="jq hj"> dispose() </strong></p></blockquote><p id="04ee" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">dispose</strong>()’在<code class="du mo mp mq kw b">State</code>对象被移除时被调用，这是永久的。</p><p id="428c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个方法是取消订阅和取消所有动画，流等。</p><blockquote class="mi mj mk"><p id="eb86" class="jo jp lt jq b jr km jt ju jv kn jx jy ml ko kb kc mm kp kf kg mn kq kj kk kl hb bi translated"><strong class="jq hj">已安装是假的</strong></p></blockquote><p id="6de5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><code class="du mo mp mq kw b">state</code>对象永远不能重新挂载，调用<code class="du mo mp mq kw b">setState()</code>时会抛出一个错误。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="dcc7" class="iq ir hi bd is it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn bi translated">你如何能有所贡献？</h1><ul class=""><li id="56ea" class="lu lv hi jq b jr js jv jw jz mr kd ms kh mt kl lz ma mb mc bi translated">在<a class="ae mu" href="https://twitter.com/jayeshpatel1995" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae mu" href="https://in.linkedin.com/in/jayeshpansheriya" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>或<a class="ae mu" href="https://www.instagram.com/jay_pansheriya" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上与我联系。</li><li id="38ea" class="lu lv hi jq b jr md jv me jz mf kd mg kh mh kl lz ma mb mc bi translated">跟着我上<a class="ae mu" href="https://github.com/jayeshpansheriya" rel="noopener ugc nofollow" target="_blank"> Github </a>。</li></ul><h1 id="da68" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">表示你的支持</h1><p id="953a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果你喜欢阅读这篇文章，请点击下面的按钮。你鼓掌越多，就越能激励我写得更好！</p></div></div>    
</body>
</html>