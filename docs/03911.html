<html>
<head>
<title>A simple Word_Predictor using RNN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RNN的简单单词预测器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-simple-word-predictor-using-rnn-460884c97e6c?source=collection_archive---------4-----------------------#2020-02-25">https://medium.com/analytics-vidhya/a-simple-word-predictor-using-rnn-460884c97e6c?source=collection_archive---------4-----------------------#2020-02-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/27dd98bf7d11d0f8aef83ff63975f1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eph9cEjfaKmqVkYwIfyag.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">抄送:<a class="ae iu" href="https://www.flickr.com/photos/stevensnodgrass/6274372541/" rel="noopener ugc nofollow" target="_blank">https://www.flickr.com/photos/stevensnodgrass/6274372541/</a></figcaption></figure><p id="ee78" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不知道你们中有多少人会同意我说的话，当我的手机中的自动更正功能有时会自动为我填充时，我真的很恼火。但是这个想法很吸引人，比如它是怎么做到的？答案就是<a class="ae iu" href="https://en.wikipedia.org/wiki/T9_(predictive_text)" rel="noopener ugc nofollow" target="_blank"> T9 </a>算法。Gmail中有一个几乎类似的功能，叫做Smart Compose。在这里，工作是通过深度学习来完成的。在这里，我们试图使用相同的深度学习方法来构建一个文本生成器。</p><p id="929f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以基本上，单词预测或文本生成是一个语言建模问题，是机器学习和深度学习中的经典思维方式。在这里，我们尝试使用递归神经网络或RNN进行单词预测。神经网络实际上是一种设计，灵感来自于人类大脑的工作方式。他们识别模式和聚类，并利用它们给我们提供强大的洞察力和不同层次的出色应用。</p><p id="d9bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> RNN或递归神经网络，</strong>顾名思义，是一个重复的神经网络。它们是前一步骤的<strong class="ix hj">输出作为当前步骤的输入。</strong>深度学习已经有了卷积神经网络，但为什么会出现RNN的想法呢？这是因为CNN无法处理连续的数据。<br/> <em class="jt">顺序数据</em>是一种相互依赖的数据类型。它总是依赖于前一个阶段来传播自己。例如股票预测，这种预测只有通过对股票市场中大量数据的彻底研究才有可能。同样，只有把所有以前用过的词联系起来才能进行对话。CNN的问题在于它不依赖于它之前的数据或者说每一步都是自力更生的。对于我们提到的任务，我们必须选择RNNs。</p><p id="3dd5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯，RNN确实在给深度学习提供更多可能性方面发挥了重要作用。RNN在建筑的基础上有很多不同的变体，我们现在要用的是LSTM·RNN。<strong class="ix hj"> LSTM </strong>代表<strong class="ix hj">长短期记忆</strong>。因此，在我们的问题上下文中，假设我们必须预测这个句子，“她正在<em class="jt">厨房里做饭”</em>因此，为了生成单词<em class="jt">厨房，</em> RNN需要在其模型内关联单词<em class="jt">做饭</em>，这是可能的，因为它记得它之前的几个状态。我们准备好了，但是如果句子是这样的，会发生什么呢，“我出生在印度，但是我很小的时候搬到了伦敦……我很想学习我的母语<em class="jt">印地语。”</em>这里的问题是，预测词<em class="jt">印地语</em>和它用来关联和预测的词<em class="jt">印度</em>之间有很多句子。RNN缺乏长期保存信息的能力，这通常被称为<strong class="ix hj">长期依赖。</strong> LSTM是这个问题的解决方案。这是一个专门为解决这个问题而构建的架构。</p><p id="c76a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了让我们的项目在上面指定的RNNs和LSTM上工作，我们需要两个库。对于没有接触过这方面的人，我来介绍一下<em class="jt"> keras </em>这是一个用python编写的开源神经网络，可以运行在Tensorflow之上。这个库是深度学习最方便最容易入门的。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/85dd855678c4ecd985ba419313b3afd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_0khoA2XGCtArlsR3N6EQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><em class="jz">导入必要的库。</em></figcaption></figure><p id="add4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到Word_Prediction，首先，我们选择一个用于训练模型的数据集。下一步是去掉所有的标点符号，并且把所有的字母都变成小写。最后，我们需要对文本进行排序，并在列表中获取每个唯一的单词。就这样，各位，我们已经清理了数据。为什么我们需要做这些准备工作？现在让这个想法停留一下，让我们看看代码。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/54369ee9280b5ce9fd3a541a9aca3185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Peq7zRCQ01xGcQQBs5W-xw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">获取数据集和数据预处理步骤</figcaption></figure><p id="c492" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经准备好了数据集，我们可以开始工作了。接下来要做的事情是创建一个包含数据集中所有唯一单词的字典，键值对是一个单词索引组合。这样做是为了我们可以通过只指定索引来获得一个单词。现在我们用索引词键值对制作另一个同类字典。反之亦然的功能。这可以称为唯一单词的映射，这样做是为了方便访问。我们不能直接对单词建模，所以，我们必须把字符转换成整数，这就是索引的全部原因。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/7fcbd967f77aca683fb3a049ba32b126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bkFTufBlWRBh4O6aAI-F7g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">索引</figcaption></figure><p id="3cbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据集文本被分割成固定长度为40个单词的子序列，任意长度。我们可以很容易地把数据按句子分开。这实际上可能是这样的，(这里假设序列长度= 5)，<br/>他们都坐在<em class="jt">一个</em> <br/>都坐在一个<em class="jt">桑迪<br/> </em>坐在一个沙地<em class="jt">角落</em> <br/>在一个沙地角落<br/>的<em class="jt">这里每个第6个字都是从长度为5的前一个种子预测的。</em> <br/>因此，在X中，我们有每个训练模式，每个模式有40个时间步长，后面是存储在y中的相应输出。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/724294858f956c7d2dfac9824182c3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqHYCsHT8xTuCckDlaW2-A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">准备数据集</figcaption></figure><p id="831a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要转换准备好的数据集，以便它适合与Keras一起使用。首先，我们必须将输入序列列表转换成LSTM网络所期望的形式。然后，我们需要将整数重新调整到0到1的范围内，以使LSTM网络更容易学习这些模式。这是因为LSTM默认使用sigmoid激活函数，这是一个概率函数，其值在0到1的范围内。最后，我们需要将单个单词转换成整数(或一键编码)。每个y值被转换成一个稀疏向量，该向量具有唯一的字的长度，除了模式所表示的字的列中有一个1之外，全是零。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/67bd0ce1738c84dc01be4dea6684d365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6OzJ1jgutSEtnUsylBE7g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">为LSTM网络重新模拟准备好的数据集</figcaption></figure><p id="5b73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们将开始定义LSTM网络，首先初始化keras中的序列。以下代码行将不同的层添加到模型中，(i) LSTM层参数是它应该预期的输入形状和表示时间步长总数的单位数，(ii)Dropout layer帮助我们避免过度拟合的问题，我们可以根据需要重复这些层，以使模型给出有效的输出。密集层连接所有先前的层，并且它具有在其参数中指定的显式激活函数。最后，我们需要编译所有这些层。<br/> <em class="jt">(请务必查看keras文档，了解每一层及其参数)</em></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/48e8fc6d91b86f62363ff521097971c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4l7KSSuuaiKdIgLtcyJDA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">构建网络</figcaption></figure><p id="ee95" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">模型检查点是一种每当在时期结束时观察到损失改善时将所有网络权重记录到文件中的方法。我们将使用最佳的权重集(最低损失),以便我们可以拥有我们的模型的最佳版本。基本上这就是我们在下面的代码块中所做的。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/b6321b54bf2f3cfa278fca2c3fbabd1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aqyms-1F9fpavHTQaeXDVQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">检查指向</figcaption></figure><p id="158e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以开始训练阶段了，为此，我们将对模型进行拟合。因此，随着时代的结束，我们得到一个输出，它可能令人满意，也可能不令人满意。但是我们总是可以通过<a class="ae iu" href="https://towardsdatascience.com/hyperparameter-optimization-with-keras-b82e6364ca53" rel="noopener" target="_blank">超参数调整</a>和增加几层来尝试改进模型。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/e164490a3632c114642c7e2a7bffc807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AcMwMcWwB8O-jOpiCASI9A.png"/></div></div></figure><p id="a735" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们需要将保存的权重加载到先前在检查点保存的模型中。就这样，好戏开始了，随机选择一个参考序列，我们将尝试预测序列的其余部分。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/1f8c5f8ddf00e0ebb3adeacbc5c458b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OgMMohoBzyoXxh1kSmJoQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">获得的产量</figcaption></figure><p id="cd3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们现在建成的RNN网络预测的产量。这是一个非常基本的文本生成器，对RNNs的利用最少。我希望这是有帮助的，所有人都可以使用RNNs尝试简单的应用程序。</p></div></div>    
</body>
</html>