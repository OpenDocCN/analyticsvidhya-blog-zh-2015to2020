<html>
<head>
<title>Encryption at rest — What’s involved?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">静态加密—涉及哪些内容？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/encryption-at-rest-whats-involved-ef8dba69f65b?source=collection_archive---------8-----------------------#2019-10-02">https://medium.com/analytics-vidhya/encryption-at-rest-whats-involved-ef8dba69f65b?source=collection_archive---------8-----------------------#2019-10-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7eb1b908e01d393c8b6a340708c98016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*27-KQxwqK6zlAaHdXaRmQA.gif"/></div></div></figure><p id="d709" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">加密技术已经存在了很多很多年。当我们现在想到它时，我们会想到计算机。但它远远早于计算机。在我看来，加密的方法和现在的技术都很迷人！我将向您介绍什么是加密的步骤，希望在本文结束时，您能够理解和欣赏“静态加密”。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/095aa984494bacc4184e9066c647fa24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*O8dd6A5SuzvCD-eG6xsNEg.gif"/></div></figure><p id="47b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，什么是加密，什么是<em class="jt">静态加密</em>和<em class="jt">为什么</em>很重要？为什么会有一整个研究领域致力于此？</p><h1 id="1df2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">加密</h1><p id="6fa7" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">从根本上来说，加密是一种行为，即把一些容易阅读的东西(一个短语或一段文本)转换成看起来像纯胡言乱语的东西。在加密中，将人类可读的文本编码成字符串，如果没有用于加密的“密钥”就无法读取，通常称为“密码密钥”。一个古老而基本的例子是凯撒密码。这是通过将字母表映射到移位字母表来实现的，很像下面的例子:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/ccdad242805fd535c62516bd1d916a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/1*wYwm3x8RfMpqW6RlKtomhQ.gif"/></div></figure><p id="7497" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你所看到的，移位三只不过意味着将字母表向左移动三个位置。这样，A变成了D，B变成了E，依此类推。让我们再举一个例子，使用移位5来编码短语“密码很酷”:</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="35f8" class="ld jv hi kz b fi le lf l lg lh">Alphabet:           ABCDEFGHIJKLMNOPQRSTUVWXYZ<br/>5-Shifted Alphabet: FGHIJKLMNOPQRSTUVWXYZABCDE</span><span id="35fa" class="ld jv hi kz b fi li lf l lg lh">Plain text:  Ciphers are cool<br/>Cipher text: HNUMJWX FWJ HTTQ</span></pre><p id="1472" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你所看到的，每个字母都被另一个字母所取代，从而将短语转换成了胡言乱语。这是一个非常简单的密码，计算机只需几分之一秒就能解密。现代密码要强大得多，通常需要复杂的方程式和算法来生成加密文本。</p><p id="1c67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们使用互联网时，我们的电脑、笔记本电脑、手机或其他类似设备发送的信息通常(在完美的世界中应该总是)在通过互联网传输之前被加密——这给了我们传输中的加密。这通常比静态加密更受关注，因为它是更常见的攻击点。</p><p id="eef2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们设置一个简单的场景来解释传输中加密的重要性。你在电脑上，给某个社交媒体平台上的朋友发消息，比如说脸书。如果在你的网络上有其他人(一个“监听器”)，或者在你和脸书的服务器之间有其他人，他们可以截取和读取你和你朋友之间发送的信息。然而，当这些消息被加密时，收听者将无法解释你发送的内容。至少要付出相当多的额外努力。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/2d1f6552b2f2b63c54fb04e286dc176b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gAHzp4nZka25GdUAPtEu6w.png"/></div></div></figure><p id="b773" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上概述了加密的重要性，以及数据在互联网上传输时是如何暴露的。</p><h1 id="36c5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">那么，静态加密？</h1><p id="e1de" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">正如您可能猜到的，静态加密是在数据<em class="jt">未</em>传输或被程序使用时加密数据的行为。这使得它处于“持久”状态，通常保存在硬盘或其他类似的存储设备上。</p><p id="d766" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于普通用户来说，这可能不是一个问题，可能是你永远不需要担心的事情。但当你开始关注存储敏感数据的大型企业级设备时，比如托管数据库的计算机，这就变得非常重要了。如果有人设法通过互联网访问计算机，或者更糟的是亲自访问，该怎么办？如果他们能访问存储在上面的数据呢？只要在谷歌上搜索“数据泄露”并切换到新闻标签，你就会看到这对大公司会有什么影响。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/66e436beb102099acd0c53220b17edfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eR-JLUe0cqjBSPeWJbEcoQ.png"/></div></div></figure><p id="f4c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了静态加密，这些担忧可以得到缓解。是的，黑客也许能够解密他们发现的东西，但如果选择了合适的加密方法，从统计上来说，这需要很长时间(想想几十年或几百年)。</p><p id="e358" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如Caesar密码是一种非常基本的加密形式一样，有许多现代密码可供选择来使用静态加密。举一个用于云计算的例子，让我们看看Oracle的静态加密方法，称为透明数据加密(TDE)。查看Oracle数据库18c版本的文档，他们采用的加密形式之一是国际标准<strong class="is hj"> AES </strong> ( <strong class="is hj">高级加密标准</strong>)。</p><p id="bb20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是那是什么，它是如何工作的，如果人类用手而不是电脑来做它会是什么样子？在你继续下去之前，我会在接下来的章节中深入研究这个算法背后的数学。</p><h1 id="5621" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">高级加密标准(AES)</h1><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/0a7e436bd8dce9173c7f45df85461aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SZganAZjxb3mn9Q74DhfmQ.png"/></div></div></figure><p id="74cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">AES是这种算法的通用名称，但它实际上并不是最初的名称。1997年，美国国家标准与技术研究所(NIST)开始着手寻找新的加密标准。随着时间的推移，当时的标准DES变得越来越脆弱，越来越容易被攻破。在几年的过程中，不同的加密方法被提交和考虑。从该计划中选择出来成为AES的密码是由文森特·里门和琼·代蒙创造的<strong class="is hj"> Rijndael密码</strong>(读作‘rain-Dahl’)。</p><p id="4c17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">DES受到使用56位固定长度密钥的限制。这相当于你键盘上7个字符的长度，对现在几乎所有的网站来说都太短了，因为太容易猜了。AES的亮点在于它允许不同长度的密钥——128位、192位和256位。所有这些都将应用于128位块中的数据。随着密钥长度的变化，它越长就越安全。</p><p id="083e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回到56位是7个字符，128(最小密钥长度)是16个字符。更难猜测。因此，随着时间的推移，可以使用越来越长的密钥，或者您可以评估数据的敏感性，并决定从一开始就使用更长的密钥。进行评估的原因是，密钥越长，所需的计算也越多。</p><p id="9792" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么AES中的密钥是如何用来加密数据的呢？在上面的凯撒密码中，密钥只是告诉你字母表移动多远的数字，在上面的例子中是5。AES要复杂得多。这是潜水深度超出预期的地方。当我开始写这篇文章的时候，我想给你们一个简单的数学概述；这一意图的结果是用python 编写了一个<a class="ae lm" href="https://github.com/HughGDA/rijndael/blob/master/rijndael.py" rel="noopener ugc nofollow" target="_blank">脚本，可以用128位密钥执行简单的AES。</a></p><p id="36a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们开始之前，有一些警告:</p><ul class=""><li id="d66f" class="ln lo hi is b it iu ix iy jb lp jf lq jj lr jn ls lt lu lv bi translated">我使用了大量的字符串，而不是二进制和十六进制数字，这样做是为了尽可能的详细，并且更容易形象化每一步发生了什么。</li><li id="b865" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">这是一个基本的实现，旨在帮助理解主题，所以我限制了输入以适应示例的格式。</li><li id="5bfe" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">同样，由于这是一个理解而不是实现的工具，我选择了一些更容易理解的数学而不是高效的数学。</li></ul><p id="614c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这次分解中，我不会讨论整个脚本(剧透:它很长)，但我会从最适用的来描述正在发生的事情。</p><h2 id="e8b5" class="ld jv hi bd jw mb mc md ka me mf mg ke jb mh mi ki jf mj mk km jj ml mm kq mn bi translated">(AES的)基础知识</h2><p id="e43e" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">在最基本的情况下，Rijndael密码接受一些纯文本输入，即一个密码密钥，并根据密钥长度确定轮数。鉴于我编写这个程序是为了处理一个128位的密钥，我添加了rounds作为输入，但实际上它应该是一个固定的数字。尽管在可能的情况下，我尽可能灵活地保留了脚本，希望它能在以后变得更加强大。</p><p id="610f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该算法将纯文本转换成二进制，将这种二进制表示分解成长度为128位的块。这种二进制表示相当于32个十六进制字符，或16个键盘字符。计算中使用的矩阵将明文块和密钥的32个十六进制字符组织成4x4矩阵，其中每个矩阵元素是一个十六进制对。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/1545d4ff8c8ac7d3e58664ea99ec7473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwUW1FOmtU-NmogsQIJy8w.png"/></div></div><figcaption class="mp mq et er es mr ms bd b be z dx translated">示例4x4矩阵</figcaption></figure><p id="4672" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些矩阵是按列构造的(虽然在我的代码中，为了便于计算，我在某些部分将其转换为按行的，但让我们假装我没有这样做)。这意味着，如果我们把左边的例子变回一个字符串，它会变成:“02 9B 24 54 A6…”等等。这很重要，因为如果它们是按行构造的，输出会有很大的变化。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mt mu l"/></div><figcaption class="mp mq et er es mr ms bd b be z dx translated">Rijndael密码的主要功能</figcaption></figure><p id="5a0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在初始回合之前，有必要生成“扩展密钥”。就我自己的理解，我一直认为这是第零步。在我看来，至少就数学而言，这是最复杂的一步。有必要在整个密码中引入更多的安全性。</p><p id="8792" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在“第零步”之后，第一轮由<em class="jt"> addRoundKey </em>步组成，随后是九轮128位密钥(更大的密钥更多)。每一轮由<em class="jt"> byteSubstitution </em>，接着是<em class="jt"> shiftRow </em>，接着是<em class="jt"> mixColumn </em>，接着是<em class="jt"> addRoundKey </em>组成。省略<em class="jt">混合列</em>步骤，接着进行第十轮。这是一大堆扔给你的术语，现在来解释一下它的意思。</p><h1 id="ff78" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">扩展圆形密钥—零步</h1><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="960c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">rcon '(称为舍入常数，我们将在后面的步骤中研究)在每列的顶行中是非零的。舍入常数的非零元素计算如下:</p><ul class=""><li id="2e49" class="ln lo hi is b it iu ix iy jb lp jf lq jj lr jn ls lt lu lv bi translated">对于舍入零，使用01(十六进制表示)</li><li id="87bd" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">每隔一轮是在2⁸的伽罗瓦域内用不可约多项式x⁸+x⁴+x +x+1加倍的前一轮</li><li id="75ec" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">等等，那两点到底是什么？？</li></ul><h2 id="96de" class="ld jv hi bd jw mb mc md ka me mf mg ke jb mh mi ki jf mj mk km jj ml mm kq mn bi translated">伽罗瓦域</h2><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/4dd4b4a05066d17c8d5d1dfaa2decaaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*hoedaPHCbAdx5jIQTN_vAQ.jpeg"/></div><figcaption class="mp mq et er es mr ms bd b be z dx translated">计数点击器</figcaption></figure><p id="2814" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个简单的解释是，它是一个有限域——在一个无限域中，数字可以一直上升，但在一个有限域中，它们会环绕上升。</p><p id="7ea2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以遥控器为例。按下按钮，它上升一级。转到“9999”并点击按钮，它会返回到“0000”。伽罗瓦域就是这样，但要复杂得多。</p><p id="976b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来分解一下上一节的要点。2⁸告诉我们，我们的字段使用二进制数，基数为2(即由0和1组成)，它有8个位置。因此，我们字段中的数字可以是最多包含8个字符的二进制数。</p><p id="b609" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个数字超过8个字符怎么办？这就是“不可约多项式”的由来。较长数的伽罗瓦域等价物是较长数对不可约多项式取模，即当您将较长数除以不可约多项式时的余数。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/bbd5e40c731efa14c2d8805c1f0095da.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*ZBEXNXpaCaCTsFEw4o0TCg.png"/></div></figure><p id="245b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢天谢地，二进制使得模运算简单多了。二进制数的除法相当于排列每个数的最高有效位，并执行“异或”(XOR)运算。</p><p id="d113" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了异或，你有两个输入和两个输出，1或0(二进制，对吗？).你决定的方式是，如果两个输入相同，它是0，如果它们都不同，它是1。所以你一直排列你的数，直到余数小于不可约多项式。</p><p id="2982" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“但是不可约多项式不是二进制的！”我听到你说。别担心，我们可以解决这个问题。给定的多项式转换成二进制表示:</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="8fdd" class="ld jv hi kz b fi le lf l lg lh">x⁸+x⁴+x³+x+1 == 1x⁸+0x⁷+0x⁶+0x⁵+1x⁴+1x³+0x²+1x¹+1x⁰ == 100011011</span></pre><p id="4092" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们展开它，我们可以看到，长形式的多项式只是某个x值的1或0倍。去掉x，我们可以看到一个二进制数出现。</p><p id="4bdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有了圆周率常数，接下来呢？</p><h2 id="814e" class="ld jv hi bd jw mb mc md ka me mf mg ke jb mh mi ki jf mj mk km jj ml mm kq mn bi translated">扩展圆形密钥</h2><p id="4ff8" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">在计算出舍入常数之后(或者在我的代码中，只是简单地提供)，必须扩展密钥。一开始它是一个4x4的矩阵。展开后，它应该有额外的列数，等于轮数乘以矩阵的大小(分别是10和4)，在我们的例子中，给出40个额外的列，总共44个。</p><p id="91f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在计算中，通常是从0开始计数。所以我们得到的键给出了位置为0，1，2和3的列。这有什么关系？对于扩展密钥，我们有两条规则要遵循；如果新列<strong class="is hj">是位于可被4整除的位置的</strong>，我们做一件事，如果<strong class="is hj">不是</strong>，我们做另一件事。</p><p id="fbfe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果它<em class="jt">是</em>被4 <em class="jt">整除就更复杂了，那我们就从这个开始吧。为了举例，我们将讨论添加到我们的原始密钥上——以“AES基础知识”一节中的示例4x4矩阵作为初始密钥。这意味着我们的下一列将是第五列。但是因为我们从0开始计数，这将是位置4。对于可被4整除的位置，取前一列(在本例中是位置3)，将每个元素上移一个位置，然后执行字节替换。</em></p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/99c495742d548759c5ed3be98968a174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lvUAO8y-BBLd9mNpGkqmew.png"/></div></div><figcaption class="mp mq et er es mr ms bd b be z dx translated">字节替换表</figcaption></figure><p id="2735" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">按照上面的替换表进行字节替换。如您所见，它查找X和y。这些是每个元素中的十六进制对，对的左边是X，右边是y。例如，在SHIFT列的下面，元素0是“88”。因此，我们在X=8和Y=8处扫描，以找到“C4”。查看元素1，“5E”，我们在X=5和Y=E处查找“58”。我们对元素2和元素3做同样的事情。结果见SUB栏。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/7259c83b9eaa29989457b533cb69c5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VzvnTW-D4qXtx_9x1w1EgQ.png"/></div></div></figure><p id="d4ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有一种计算替换的方法，我写的脚本实现了这种方法。然而，这篇文章已经够长了，所以我将在以后解释它的工作原理。</p><p id="2530" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">找到列SUB后，它必须与当前的RCON列进行异或运算。每四个新列与一个RCON列相关联。因此，对于位置4到7，我们使用第一个RCON列(列“0”)，对于位置8到11，使用第二个，依此类推。然后，XOR的结果再次与前面4个位置的列进行XOR。在我们的例子中，位置-4就是位置0:</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="70f5" class="ld jv hi kz b fi le lf l lg lh">current position = 4<br/>4-4=0</span></pre><p id="7bbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在所有xor运算中，有必要将十六进制转换成二进制，我在这里省略了。新的第五列在上面显示为位置4的列！</p><p id="e9c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不能被4整除的位置就容易多了。您只需将位置-1的列与位置-4的列进行异或运算。所以位置5就是位置4或位置1。对于我们的128位密钥，这一直持续到我们有44列，由我们的原始密钥加上我们的40个新列组成。</p><h2 id="bb2e" class="ld jv hi bd jw mb mc md ka me mf mg ke jb mh mi ki jf mj mk km jj ml mm kq mn bi translated">添加关键步骤</h2><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/735f0dd18580cc615767e0157a00ded7.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*K_7uj3kP1x7OIdiGU9VfWw.png"/></div></figure><p id="7e32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该步骤在每轮开始前执行一次<em class="jt">，然后在每轮结束时再次执行。从我们的44列扩展键中，每次执行此步骤时，都需要找到正确的四列来使用。我用的方程是<code class="du na nb nc kz b">round*4 to (round+1)*4</code>。还记得我之前说过我喜欢认为存在“第零步”吗？这是我这样描述它的另一个原因；<code class="du na nb nc kz b">round = 0</code>，给出了第一个addRoundKey的0到4列。在python中，你可以这样描述数字的范围:<code class="du na nb nc kz b">in range(0,4)</code>，这意味着从0到4的数字，但不包括4。这导致范围为“0，1，2，3”。</em></p><p id="4b8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们已经选择了四个键列，这四列纯文本以十六进制形式表示。同样，我们将从头开始采用4x4矩阵作为键的列0到3，并引入一个新矩阵作为纯文本:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/8e7098df83d407d2fd37ad2839a0e066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bFW3S-Rv-Pawu_s2h1FpA.png"/></div></div></figure><p id="c226" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦我们有了正确的键列和纯文本，我们就逐个元素地执行XOR运算来寻找新的矩阵。这意味着我们从第一列的第一行得到“02”异或“90”得到“92”。然后我们看第一行的第二列；A6 '异或' AB '得到' 0D '。我们遵循这种匹配两个矩阵中的位置的趋势，并以这种方式继续下去，直到每个元素都被异或。</p><h2 id="ce74" class="ld jv hi bd jw mb mc md ka me mf mg ke jb mh mi ki jf mj mk km jj ml mm kq mn bi translated">按替换步骤</h2><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/7dbc40b694c2efab10db0b352220ed52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qWu0i8pACPfxiROK8I1sA.png"/></div></div></figure><p id="89fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能很高兴知道你现在已经到达了一个很短的部分，正如我在上面的"<strong class="is hj">扩展圆密钥"</strong>中已经讨论过的。我们只需按照addRoundKey的“结果”矩阵中的表格做同样的事情。就这样，byteSubstitution步骤到此结束！</p><h2 id="2d4b" class="ld jv hi bd jw mb mc md ka me mf mg ke jb mh mi ki jf mj mk km jj ml mm kq mn bi translated">移位行步骤</h2><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="4ffa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，这应该是一个不错的小步骤。我们将使用byteSubstitution中的“After sub”矩阵。首先，我们需要标记从0开始计数的每一行；所以我们有0，1，2，3行。接下来，将每一行的每个元素向左移动与该行的标签相等的次数。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/92ba66e68ebf87c646a7b036f0c4dcfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*NPlbF5AzfO1MqgsqEp4DBQ.png"/></div></div></figure><p id="8170" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也就是说顶行不动，1行左移一次，2行左移两次，3行左移三次。行是环绕的，所以如果移动的话，最左边的元素会移动到最右边。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/74a2508904a88d3471753c5b82c2ff2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2UTxMPIxKhIncq224OHuSg.png"/></div></div></figure><h2 id="76fc" class="ld jv hi bd jw mb mc md ka me mf mg ke jb mh mi ki jf mj mk km jj ml mm kq mn bi translated">混合列步骤</h2><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es nh"><img src="../Images/671eebfc0fe4dee5d716cb5b6543ee10.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*cULD7u55dkK4vAvzfuxuEQ.png"/></div></figure><p id="4623" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们回到稍微长一点的步骤，使用一点矩阵运算。对于这一步，我们使用标准矩阵(如左图所示),并将其乘以上一步的“移位后”矩阵。</p><p id="c390" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住:矩阵乘法的顺序非常重要。所以这一步是<code class="du na nb nc kz b">standard matrix * matrix from previous step</code>。要快速复习矩阵乘法，<a class="ae lm" href="http://bit.ly/matrixRefresher" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><p id="8cb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要记住我们之前接触过的伽罗瓦域，所以如果结果太高，我们需要执行模运算，就像点击器循环一样。幸运的是，使用二进制有三个好处，可以节省我们很多时间:</p><ul class=""><li id="5452" class="ln lo hi is b it iu ix iy jb lp jf lq jj lr jn ls lt lu lv bi translated">你可以在数字的末尾加上一个0来乘以2</li><li id="48df" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">乘以3等同于乘以2，然后将结果与原始数字进行异或运算</li><li id="0c6f" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">具有二进制数的伽罗瓦域中的加法等同于两个数的异或运算</li></ul><p id="7be0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">执行标准矩阵乘法会导致以下结果:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/64818026919baef1f2397ff8ae6f39b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hxk5ktGrfeDfGrsSCzO_XA.png"/></div></div></figure><p id="b518" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们将左边的第一行和右边的第一列转换成二进制，以显示发生了什么。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="a588" class="ld jv hi kz b fi le lf l lg lh">ROW:<br/>02 = 00000010, 03 = 00000011, 01 = 00000001, 01 = 00000001<br/>COLUMN:<br/>4F = 01001111<br/>7E = 01111110<br/>8A = 10001010<br/>6E = 01101110</span><span id="7cc1" class="ld jv hi kz b fi li lf l lg lh">MULTIPLICATION<br/>(4F*02)+(7E*03)+(8A*01)+(6E*01)<br/>= (4F*02)+(7E*03)+(8A)+(6E)<br/>= (4F*02)+((7E*02) XOR 7E)+8A+6E</span><span id="fade" class="ld jv hi kz b fi li lf l lg lh">SIMPLIFY<br/>4F*02 = 01001111<br/>        00000010<br/>        --------<br/>        10011110</span><span id="417c" class="ld jv hi kz b fi li lf l lg lh">7E*02 = 01111110<br/>        00000010<br/>        --------<br/>        11111100<br/>    XOR 01111110<br/>    ------------<br/>        10000010</span><span id="beb8" class="ld jv hi kz b fi li lf l lg lh">ADDITION (REPLACE WITH XOR)<br/>(10011110 XOR 10000010) XOR (10001010 XOR 01101110)<br/>= 00011100 XOR 11100100<br/>= 11111000<br/>== F8</span></pre><p id="e45c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与该算法中的其他一些步骤相比，mixColumns是相对“简单”的数学，但这一步漫长的二进制算术说服了我编写python脚本来伴随它。</p><h2 id="5754" class="ld jv hi bd jw mb mc md ka me mf mg ke jb mh mi ki jf mj mk km jj ml mm kq mn bi translated">现在都在一起</h2><p id="1eae" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">现在我们知道了每一步是什么，以及它是如何工作的(至少在某种程度上)，让我们来看看它们是如何排列的。</p><ol class=""><li id="ac3d" class="ln lo hi is b it iu ix iy jb lp jf lq jj lr jn nj lt lu lv bi translated">生成扩展密钥</li><li id="0830" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn nj lt lu lv bi translated">在第0轮执行一次addRoundKey</li><li id="8dba" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn nj lt lu lv bi translated">对于除最后一轮以外的每一轮do: byteSubstitution、shiftRow、mixColumn、addRoundKey</li><li id="edd6" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn nj lt lu lv bi translated">最后一轮do: byteSubstitution，shiftRow，addRoundKey</li></ol><p id="25ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像这样把一切放在一起，听起来似乎很简单。</p><h1 id="3d6f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">所以现在我安全了，对吧？</h1><p id="fdf4" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">是也不是。现在我们知道了AES密码的工作原理，这对于保护数据大有帮助，但这只是您应该采取的许多步骤之一。加密您的静态数据，加密传输中的数据，设置一个强大而安全的网络接口，甚至可以使用虚拟专用网络(VPN)来增加一点额外的安全性。这完全取决于您需要多大程度的数据保护。</p><p id="e60c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但请始终考虑；没有一个万全之策。为了保证数据的安全，你需要多种安全功能。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/a830080220f3b97371d0f990eada0e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHq5_2DfB7ASTicH0aBTkw.png"/></div></div></figure><p id="7db3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你认为使用静态数据或其他数据库安全方法对你或你的企业有用，考虑注册甲骨文云试用:<a class="ae lm" href="http://bit.ly/OCTrialLink" rel="noopener ugc nofollow" target="_blank">http://bit.ly/OCTrialLink</a></p><p id="9200" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有问题或意见吗？在https://www.linkedin.com/in/hugh-gallagher/<a class="ae lm" href="https://www.linkedin.com/in/hugh-gallagher/" rel="noopener ugc nofollow" target="_blank">的LinkedIn上找到我</a></p><blockquote class="nk"><p id="8f08" class="nl nm hi bd nn no np nq nr ns nt jn dx translated"><em class="nu"> *所有观点均为本人观点，不代表甲骨文* </em></p></blockquote><blockquote class="nv nw nx"><p id="6bf2" class="iq ir jt is b it ny iv iw ix nz iz ja oa ob jd je oc od jh ji oe of jl jm jn hb bi translated">感谢<a class="og oh ge" href="https://medium.com/u/90b0c48b8b03?source=post_page-----ef8dba69f65b--------------------------------" rel="noopener" target="_blank">瑞安·林奇</a>和<a class="og oh ge" href="https://medium.com/u/a7a7d9c1661c?source=post_page-----ef8dba69f65b--------------------------------" rel="noopener" target="_blank">格雷斯·拜尔斯</a>在剪辑过程中的帮助。</p></blockquote></div></div>    
</body>
</html>