<html>
<head>
<title>C++: shared_ptr and how to write your own</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++: shared_ptr以及如何编写自己的</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/c-shared-ptr-and-how-to-write-your-own-d0d385c118ad?source=collection_archive---------0-----------------------#2020-04-13">https://medium.com/analytics-vidhya/c-shared-ptr-and-how-to-write-your-own-d0d385c118ad?source=collection_archive---------0-----------------------#2020-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/d318a53016064ef8b30b39e867d57d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*o9jsZUig2iHjR9OFVI1x1w.png"/></div></figure><p id="10d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在之前的<a class="ae jk" rel="noopener" href="/@karankakwani/c-smart-pointers-and-how-to-write-your-own-c0adcbdce04f">帖子</a>中，我们讨论了<strong class="io hj">智能指针</strong>——它们是什么，以及它们如何优于管理动态分配内存的普通指针。我们还学习了STL中的智能指针类，即<code class="du jl jm jn jo b">unique_ptr</code>，以及如何实现我们自己的智能指针类。</p><p id="dd1d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，我们将讨论<code class="du jl jm jn jo b">shared_ptr</code>以及如何编写一个像标准shared_ptr类一样工作的类。<code class="du jl jm jn jo b">shared_ptr</code>是一个引用计数的智能指针，即它可以与其他<code class="du jl jm jn jo b">shared_ptr</code>实例共享动态分配对象的所有权。换句话说，几个<code class="du jl jm jn jo b">shared_ptr</code>对象可以在堆上拥有(指向)同一个内存(对象)。这与<code class="du jl jm jn jo b">unique_ptr</code>相反，其中只有一个底层原始指针的所有者。那么，<code class="du jl jm jn jo b">shared_ptr</code>是如何工作的，它是如何知道何时释放底层指针所指向的内存的呢？</p><p id="8d8a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du jl jm jn jo b">shared_ptr</code>维护关于多少shared_ptr对象拥有相同底层指针的引用计数。并且由底层指针指向的存储器在以下情况下被删除:-</p><ol class=""><li id="0bb5" class="jp jq hi io b ip iq it iu ix jr jb js jf jt jj ju jv jw jx bi translated">参考计数变为零，即最后剩下的<code class="du jl jm jn jo b">shared_ptr</code>对象被销毁。</li><li id="0773" class="jp jq hi io b ip jy it jz ix ka jb kb jf kc jj ju jv jw jx bi translated">拥有该指针的最后一个剩余的<code class="du jl jm jn jo b">shared_ptr</code>对象被分配了其他指针。</li></ol><p id="57c2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du jl jm jn jo b"><a class="ae jk" href="https://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noopener ugc nofollow" target="_blank">shared_ptr</a></code>存在于标准C++的<a class="ae jk" href="https://docs.microsoft.com/en-us/cpp/standard-library/memory?view=vs-2019" rel="noopener ugc nofollow" target="_blank"> &lt;内存&gt; </a>头文件的<code class="du jl jm jn jo b">std</code>命名空间中。在这篇文章中，我们将学习如何编写自己的<code class="du jl jm jn jo b">shared_ptr</code>类。让我们称这个类为my_shared_ptr。我们将使它成为一个模板类，以保持它独立于数据类型。就像<code class="du jl jm jn jo b">unique_ptr</code>一样，我们的类需要有一个指针。此外，我们需要一个计数变量来保存引用计数。方法如下:-</p><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="362d" class="kl km hi jo b fi kn ko l kp kq">typedef unsigned int uint;</span><span id="89d4" class="kl km hi jo b fi kr ko l kp kq">template&lt;class T&gt;<br/>class my_shared_ptr<br/>{<br/>private:<br/>    T * ptr = nullptr;<br/>    uint * refCount = nullptr;</span><span id="cc3a" class="kl km hi jo b fi kr ko l kp kq">public:<br/>    // default constructor<br/>    my_shared_ptr() : ptr(nullptr), refCount(new uint(0))<br/>    {<br/>    }<br/>};</span></pre><p id="c6be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意，refCount变量被声明为指针。我们不能让它成为一个整数变量，因为它不可能在不同的<code class="du jl jm jn jo b">my_shared_ptr</code>对象之间保持相同的值。当然，我们也不能把它公开，因为那样会暴露这个类的一个非常重要的特性，而且它可能会被外部修改。通过使它成为一个指针，我们可以在不同的<code class="du jl jm jn jo b">my_shared_ptr</code>间共享它，所有的人都可以访问和修改同一个计数器。</p><p id="95bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，可以添加复制构造函数和复制赋值，如下所示</p><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="4bda" class="kl km hi jo b fi kn ko l kp kq">/*** Copy Semantics ***/</span><span id="b947" class="kl km hi jo b fi kr ko l kp kq">// copy constructor<br/>my_shared_ptr(const my_shared_ptr &amp; obj)<br/>{<br/>    this-&gt;ptr = obj.ptr; // share the underlying pointer<br/>    this-&gt;refCount = obj.refCount; // share refCount<br/>    if (nullptr != obj.ptr)<br/>    {<br/>        // if the pointer is not null, increment the refCount<br/>        (*this-&gt;refCount)++; <br/>    }<br/>}</span><span id="ede1" class="kl km hi jo b fi kr ko l kp kq">// copy assignment<br/>my_shared_ptr&amp; operator=(const my_shared_ptr &amp; obj)<br/>{<br/>    // cleanup any existing data</span><span id="ea18" class="kl km hi jo b fi kr ko l kp kq">    // Assign incoming object's data to this object<br/>    this-&gt;ptr = obj.ptr; // share the underlying pointer<br/>    this-&gt;refCount = obj.refCount; // share refCount<br/>    if (nullptr != obj.ptr)<br/>    {<br/>        // if the pointer is not null, increment the refCount<br/>        (*this-&gt;refCount)++; <br/>    }<br/>}</span></pre><p id="182d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的类也将支持移动语义。我在另一篇关于如何编写自己的STL字符串类的<a class="ae jk" rel="noopener" href="/swlh/write-your-own-c-stl-string-class-e20113a8de79">文章</a>中提到并简要讨论了移动语义。因此，我们可以在我们的类中有如下的移动构造函数和移动赋值</p><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="97dd" class="kl km hi jo b fi kn ko l kp kq">/*** Move Semantics ***/</span><span id="a7e4" class="kl km hi jo b fi kr ko l kp kq">// move constructor<br/>my_shared_ptr(my_shared_ptr &amp;&amp; dyingObj)<br/>{<br/>    this-&gt;ptr = dyingObj.ptr; // share the underlying pointer<br/>    this-&gt;refCount = dyingObj.refCount; // share refCount<br/>    dyingObj.ptr = dyingObj.refCount = nullptr; // clean up dyingObj<br/>}</span><span id="e57e" class="kl km hi jo b fi kr ko l kp kq">// move assignment<br/>my_shared_ptr&amp; operator=(my_shared_ptr &amp;&amp; dyingObj)<br/>{<br/>    // cleanup any existing data<br/>    <br/>    this-&gt;ptr = dyingObj.ptr; // share the underlying pointer<br/>    this-&gt;refCount = dyingObj.refCount; // share refCount<br/>    dyingObj.ptr = dyingObj.refCount = nullptr; // clean up dyingObj<br/>}</span></pre><p id="b2bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，我们需要<code class="du jl jm jn jo b">-&gt;</code>和<code class="du jl jm jn jo b">*</code>操作符的操作符重载来取消对底层指针的引用。我们可以重载这些操作符，如下所示</p><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="4c70" class="kl km hi jo b fi kn ko l kp kq">T* operator-&gt;() const<br/>{<br/>    return this-&gt;ptr;<br/>}</span><span id="bb75" class="kl km hi jo b fi kr ko l kp kq">T&amp; operator*() const<br/>{<br/>    return this-&gt;ptr;<br/>}</span></pre><p id="8b56" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du jl jm jn jo b">const</code>在一个函数中签名使它成为一个常量成员函数，这保证了这个函数不会对对象做任何改变。将类的getter函数作为const成员函数是一个很好的实践。</p><p id="3570" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以添加其他函数——一个函数获取管理同一底层指针的不同<code class="du jl jm jn jo b">my_shared_ptr</code>实例的数量，另一个函数访问被管理的原始指针本身。</p><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="bb74" class="kl km hi jo b fi kn ko l kp kq">uint get_count() const<br/>{<br/>    return *refCount; // *this-&gt;refCount<br/>}</span><span id="76ff" class="kl km hi jo b fi kr ko l kp kq">T* get() const<br/>{<br/>    return this-&gt;ptr;<br/>}</span></pre><p id="2874" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好了，<code class="du jl jm jn jo b">my_shared_ptr</code>类已经完成，可以使用了。下面是<code class="du jl jm jn jo b">my_shared_ptr</code>类的完整实现。可以编写另一个带有<code class="du jl jm jn jo b">&lt;T[]&gt;</code>的模板版本来支持数组的创建。</p><figure class="kd ke kf kg fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="5cfe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是一个如何使用这个类的例子</p><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="1fcd" class="kl km hi jo b fi kn ko l kp kq">#include &lt;iostream&gt;<br/>using namespace std;</span><span id="2c1f" class="kl km hi jo b fi kr ko l kp kq">class Box<br/>{<br/>public:<br/>    int length, width, height;<br/>    Box() : length(0), width(0), height(0)<br/>    {<br/>    }<br/>};</span><span id="ca34" class="kl km hi jo b fi kr ko l kp kq">int main()<br/>{<br/>    my_shared_ptr&lt;Box&gt; obj;<br/>    cout &lt;&lt; obj.get_count() &lt;&lt; endl; // prints 0</span><span id="a278" class="kl km hi jo b fi kr ko l kp kq">    my_shared_ptr&lt;Box&gt; box1(new Box());<br/>    cout &lt;&lt; box1.get_count() &lt;&lt; endl; // prints 1<br/>    my_shared_ptr&lt;Box&gt; box2(box1); // calls copy constructor<br/>    cout &lt;&lt; box1.get_count() &lt;&lt; endl; // prints 2<br/>    cout &lt;&lt; box2.get_count() &lt;&lt; endl; // also prints 2<br/> <br/>    return 0;<br/>}</span></pre><p id="e810" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">P/S:这可能不是shared_ptr类的彻底实现。这只是为了让读者了解shared_ptr类是如何工作的，以及如何编写自己的类。读者可以根据需要添加其他功能。</p></div></div>    
</body>
</html>