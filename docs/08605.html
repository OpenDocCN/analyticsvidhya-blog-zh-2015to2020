<html>
<head>
<title>What About a 6-Week Machine Learning Project? Beginners Friendly Cat vs Dog Classification Problem.(Week 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为期6周的机器学习项目怎么样？初学者友好的猫vs狗分类问题。(第二周)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/what-about-a-6-week-machine-learning-project-f1091a5b712a?source=collection_archive---------28-----------------------#2020-08-04">https://medium.com/analytics-vidhya/what-about-a-6-week-machine-learning-project-f1091a5b712a?source=collection_archive---------28-----------------------#2020-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/9caf68faf8ef5eaffec8a7886f4700e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*vpqAraAqil1bMdpDROQ7kg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">从第一周开始观想</figcaption></figure><p id="c7f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">又一周(2)我的6周ML项目开始了，在非常令人兴奋的第一周结束后。第1周列出的所有任务都已按时完成，并成功通过了预期结果的测试。</p><p id="f83f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一周的主要目标是:</p><ol class=""><li id="3dc4" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">获取图像和标签。</li><li id="16d7" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">创建我们自己的验证集。</li><li id="378a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">预处理图像。</li><li id="ed42" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">将数据批量化。</li></ol><h1 id="324f" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">回顾:第1周</h1><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es la"><img src="../Images/2a508d7928fd5b4cfa89af605a6bd185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLYqBCNVaIuSKt-M1YSoWw.jpeg"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">每周任务(使用Draw.io创建)</figcaption></figure><h1 id="925e" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">获取图像和标签</h1><p id="0ddb" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">这些图片是从<a class="ae lo" href="https://www.kaggle.com/tongpython/cat-and-dog" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>下载的，然后上传到Google Drive。然后，驱动器被安装到Google Colab上，数据以<code class="du lp lq lr ls b">.zip()</code>格式解压缩。</p><pre class="lb lc ld le fd lt ls lu lv aw lw bi"><span id="8a0a" class="lx kd hi ls b fi ly lz l ma mb"><em class="mc">!unzip "drive/My Drive/CatVsDog/catvsdog.zip" -d "drive/My Drive/CatVsDog"</em></span></pre><p id="306e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有两个独立的主文件夹，training_set和testing_set，每个测试和训练集又分为cat和dog。找到了猫和狗的文件路径，猫的标签为<code class="du lp lq lr ls b">[1, 0]</code>，狗的标签为<code class="du lp lq lr ls b">[0, 1]</code>。在这个过程中使用了一个<code class="du lp lq lr ls b">label_img()</code>函数。</p><pre class="lb lc ld le fd lt ls lu lv aw lw bi"><span id="00e4" class="lx kd hi ls b fi ly lz l ma mb"><strong class="ls hj">def</strong> label_img(img):<br/>    word_label = img.split('.')[-3]<br/>    <em class="mc"># conversion to one-hot array [cat,dog]</em><br/>    <em class="mc">#                            [much cat, no dog]</em><br/>    <strong class="ls hj">if</strong> word_label == 'cat': <strong class="ls hj">return</strong> [1,0]<br/>    <em class="mc">#                             [no cat, very doggo]</em><br/>    <strong class="ls hj">elif</strong> word_label == 'dog': <strong class="ls hj">return</strong> [0,1]</span></pre><h1 id="2123" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">创建我们自己的验证集</h1><p id="505d" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">下一个任务是创建一个验证集，因为Kaggle没有提供单独的验证集。验证集是从training_set的一些猫和狗的图像中生成的。<code class="du lp lq lr ls b">sklearn.model_selection import train_test_split</code>在为猫和狗拆分数据时派上了用场。</p><pre class="lb lc ld le fd lt ls lu lv aw lw bi"><span id="5888" class="lx kd hi ls b fi ly lz l ma mb"><em class="mc"># Lets make use of our friendly Scikit-Learn now</em><br/><strong class="ls hj">from</strong> <strong class="ls hj">sklearn.model_selection</strong> <strong class="ls hj">import</strong> train_test_split<br/><br/><em class="mc"># Split the cat into training and testing using the NUM_IMAGES</em><br/>X_cat_train, X_cat_val, y_cat_train, y_cat_val = train_test_split(X_cat[:NUM_IMAGES],<br/>                                                                     y_cat[:NUM_IMAGES],<br/>                                                                  test_size=0.2,<br/>                                                                  random_state=42)<br/><em class="mc"># Split the dog into training and testign using the NUM_IMAGES</em><br/>X_dog_train, X_dog_val, y_dog_train, y_dog_val = train_test_split(X_dog[:NUM_IMAGES],<br/>                                                                  y_dog[:NUM_IMAGES],<br/>                                                                  test_size=0.2,<br/>                                                                  random_state=42)</span></pre><h1 id="a014" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">预处理图像</h1><p id="0081" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">创建验证集后，所有的图像都必须转换成数字，这是将图像转换成数字的基本步骤，或者说<code class="du lp lq lr ls b">tensors.</code>在一个在线课程中，我发现了一个漂亮而方便的图像预处理功能。这里使用了相同的函数，这对于运行这个过程非常有帮助。</p><p id="db9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该功能通常执行以下操作:</p><ol class=""><li id="67e3" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">将图像文件路径作为输入。</li><li id="ab9d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">使用Tensorflow读取图像并保存到图像中。</li><li id="e614" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">把我们的图像变成张量。</li><li id="2dfa" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">调整图像大小。</li><li id="6f5d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">返回修改后的图像。</li></ol><p id="735d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在实际构造这个函数之前，所有猫和狗的图像都被分别转换为Numpy数组。</p><pre class="lb lc ld le fd lt ls lu lv aw lw bi"><span id="c40c" class="lx kd hi ls b fi ly lz l ma mb"><em class="mc"># First we define the image size</em><br/>IMG_SIZE = 224<br/><br/><em class="mc"># Lets carry on with the function we are talking about</em><br/><strong class="ls hj">def</strong> preprocess_image(image_path, img_size=IMG_SIZE):<br/>  <em class="mc">"""</em><br/><em class="mc">  Takes the image path and turns the images into required tensors</em><br/><em class="mc">  1. Read an image file.</em><br/><em class="mc">  2. Turn the jpeg image into numerical tensors with 3 color channels.</em><br/><em class="mc">  3. Covert the colour channel values from 0 to 255 to 0 to 1 values.</em><br/><em class="mc">  4. Resize the image into `224, 224`.</em><br/><em class="mc">  """</em><br/><br/>  image = tf.io.read_file(image_path)<br/>  image = tf.image.decode_jpeg(image, channels=3)<br/>  image = tf.image.convert_image_dtype(image, tf.float32)<br/>  image = tf.image.resize(image, size=[IMG_SIZE, IMG_SIZE])<br/>  <strong class="ls hj">return</strong> image</span></pre><h1 id="43c6" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">将数据批量化</h1><p id="ae27" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">将我们的数据分批处理总是很好的，因为如果我们正在处理大约5000到10000张图像的大型数据集，并且我们处理这些数据，它们可能一次就放不进内存。所以把数据分成批次总是很好的，这里一次32张图片。</p><p id="f604" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先需要生成一个<code class="du lp lq lr ls b">(image, label)</code>形式的元组，我们使用函数<code class="du lp lq lr ls b">get_our_image_label</code>来完成这个任务。</p><pre class="lb lc ld le fd lt ls lu lv aw lw bi"><span id="402e" class="lx kd hi ls b fi ly lz l ma mb"><em class="mc"># Funtion to create the tuple we are talking about</em><br/><strong class="ls hj">def</strong> get_our_image_label(image_path, label):<br/>  <em class="mc">"""</em><br/><em class="mc">  Here we will take the image_path, label, preprocess it and returns tuple `image, label`</em><br/><em class="mc">  """</em><br/>  image = preprocess_image(image_path)<br/>  <strong class="ls hj">return</strong> image, label</span></pre><p id="6477" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后构建了一个函数<code class="du lp lq lr ls b">create_data_batches</code>,以便将我们的数据转换成大小为32的批次。这个函数为猫和狗的训练集(混洗)、验证集和测试集创建数据批次。</p><pre class="lb lc ld le fd lt ls lu lv aw lw bi"><span id="6bed" class="lx kd hi ls b fi ly lz l ma mb"><em class="mc"># First of all start with defining a size</em><br/>BATCH_SIZE = 32<br/><br/><em class="mc"># Our function to turn the data into batches</em><br/><strong class="ls hj">def</strong> create_data_batches(x, y=<strong class="ls hj">None</strong>, batch_size=BATCH_SIZE, valid_data=<strong class="ls hj">False</strong>, test_data=<strong class="ls hj">False</strong>):<br/>  <em class="mc">"""</em><br/><em class="mc">  This function just created data batches for image, label pairs.</em><br/><em class="mc">  We do the shuffling if it is the training data, not for validation data.</em><br/><em class="mc">  We also accpect the test data which do not have any label</em><br/><em class="mc">  """</em><br/>  <em class="mc"># 1. Test data</em><br/>  <strong class="ls hj">if</strong> test_data:<br/>    print("creating test data batches.....")<br/>    data = tf.data.Dataset.from_tensor_slices(tf.constant(x)) <em class="mc"># Only for filepath as there is no labels</em><br/>    data_batch = data.map(preprocess_image).batch(BATCH_SIZE)<br/>    <strong class="ls hj">return</strong> data_batch<br/>  <br/>  <em class="mc"># 2. Validation data</em><br/>  <strong class="ls hj">elif</strong> valid_data:<br/>    print("creating validation data batches....")<br/>    data = tf.data.Dataset.from_tensor_slices((tf.constant(x), tf.constant(y))) <em class="mc"># here both for filepath and label as its validation data</em><br/>    data_batch = data.map(get_our_image_label).batch(BATCH_SIZE)<br/>    <strong class="ls hj">return</strong> data_batch<br/><br/>  <em class="mc"># 3. Training data</em><br/>  <strong class="ls hj">else</strong>:<br/>    print("creating training data batches....")<br/>    data = tf.data.Dataset.from_tensor_slices((tf.constant(x), tf.constant(y))) <em class="mc"># here both filepath and label as its training data</em><br/>    <em class="mc"># Here we shuffles our data and we do it before mapping inorder to have a faster performance</em><br/>    data = data.shuffle(buffer_size=len(x))<br/>    data = data.map(get_our_image_label)<br/>    data_batch = data.batch(BATCH_SIZE)<br/>    <strong class="ls hj">return</strong> data_batch</span></pre><p id="9aea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是在所有的数据批次之后，如果我们打印发生的事情，它将会是这样的:</p><pre class="lb lc ld le fd lt ls lu lv aw lw bi"><span id="d6c6" class="lx kd hi ls b fi ly lz l ma mb"><strong class="ls hj">((TensorSpec(shape=(None, 224, 224, 3), dtype=tf.float32, name=None),<br/>  TensorSpec(shape=(None, 2), dtype=tf.int64, name=None)),<br/> (TensorSpec(shape=(None, 224, 224, 3), dtype=tf.float32, name=None),<br/>  TensorSpec(shape=(None, 2), dtype=tf.int64, name=None)))</strong></span></pre><p id="1300" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这对普通读者或观察输出的人来说毫无意义。因此，事先想象这些总是好的。</p><p id="d621" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="mc">可视化数据批次</em> </strong></p><p id="ebe7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们编写了一个方便的函数来将我们的数据批量化，但是运行这个函数只能看到一些文本和数字，这对每个人来说都很难理解到底发生了什么。因此，如果我们被这些类型的障碍所困扰，总是试着去观想，这将是一件好事，任何人都可以很容易理解。</p><p id="651e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为为任务编写函数总是有用的，因为我们可以避免代码的重复，所以另一个函数被用来完成可视化任务。</p><p id="e32d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">对于卡特彼勒:</strong></p><pre class="lb lc ld le fd lt ls lu lv aw lw bi"><span id="1d13" class="lx kd hi ls b fi ly lz l ma mb"><em class="mc"># Lets do this for our cat</em><br/><strong class="ls hj">import</strong> <strong class="ls hj">matplotlib.pyplot</strong> <strong class="ls hj">as</strong> <strong class="ls hj">plt</strong><br/><br/><strong class="ls hj">def</strong> show_images_cat(images):<br/>  <em class="mc">"""</em><br/><em class="mc">  We just plot say 25 images along with their labels</em><br/><em class="mc">  """</em><br/>  plt.figure(figsize=(10, 10))<br/>  <em class="mc"># We planned for 25 images, lets loop through 25 images</em><br/>  <strong class="ls hj">for</strong> i <strong class="ls hj">in</strong> range(25):<br/>    <em class="mc"># Create subplots with 5 rows, 5 columns each</em><br/>    ax = plt.subplot(5, 5, i+1)<br/>    plt.imshow(images[i])<br/>    plt.title("cat")<br/>    plt.axis("off")</span></pre><p id="bfdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">对于狗:</strong></p><pre class="lb lc ld le fd lt ls lu lv aw lw bi"><span id="8731" class="lx kd hi ls b fi ly lz l ma mb"><em class="mc"># Lets do the same for dogs </em><br/><strong class="ls hj">import</strong> <strong class="ls hj">matplotlib.pyplot</strong> <strong class="ls hj">as</strong> <strong class="ls hj">plt</strong><br/><br/><strong class="ls hj">def</strong> show_images_dog(images):<br/>  <em class="mc">"""</em><br/><em class="mc">  We just plot say 25 images along with their labels</em><br/><em class="mc">  """</em><br/>  plt.figure(figsize=(10, 10))<br/>  <em class="mc"># We planned for 25 images, lets loop through 25 images</em><br/>  <strong class="ls hj">for</strong> i <strong class="ls hj">in</strong> range(25):<br/>    <em class="mc"># Create subplots with 5 rows, 5 columns each</em><br/>    ax = plt.subplot(5, 5, i+1)<br/>    plt.imshow(images[i])<br/>    plt.title("dog")<br/>    plt.axis("off")</span></pre><p id="bc7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行此函数后，我们得到猫和狗的图像，在每个图像上方列出了它们的标签，即猫或狗，如下所示:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es md"><img src="../Images/3f94306fb2fb9063bc643c4e1e81205c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*a_K280iSbYDkyoPCH-wB0g.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">抽样输出</figcaption></figure><p id="4aae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lo" href="https://github.com/Rohithv07/6WeekPro" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">Github Repo</strong></a><strong class="is hj">:第1周的来源代码</strong></p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="0564" class="kc kd hi bd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz bi translated">现在期待第2周</h1><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es la"><img src="../Images/cb938ca66fda2a40b4ec13757ee3d447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOaxFEKBN_vtwLH-X7BLUg.jpeg"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">每周任务(使用Draw.io创建)</figcaption></figure><p id="e22f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第2周计划的后续任务旨在建立一个模型，创建回调。</p><p id="1317" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了构建模型，我们首先为我们的模型定义输入形状(以张量的形式)，然后输出形状并从<a class="ae lo" href="https://www.tensorflow.org/hub" rel="noopener ugc nofollow" target="_blank"> Tensorflow hub </a>中选择合适的模型url。</p><p id="f088" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是Tensorflow Hub？</strong></p><p id="3063" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TensorFlow Hub是一个用于发布、发现和消费机器学习模型的可重用部分的库。</p><p id="044e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是回调？</strong></p><p id="14b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回调是一个模型在训练过程中可以使用的辅助函数，用于保存进度、检查进度或在模型停止改进时提前停止训练。</p><p id="e112" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将创建两个回调，一个用于Tensorboard，帮助跟踪我们的模型进度，另一个用于提前停止，防止我们的模型训练太长时间。</p><p id="4a07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是第二周的课程计划。对于完成最终产品，我没有失去一点精力或兴奋，因为在这个为期6周的项目上投资时间没有损失，因为做点什么总比什么都不做好。</p></div></div>    
</body>
</html>