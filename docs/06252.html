<html>
<head>
<title>📈 Tuning LSTM to predict stock price in SET50</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">📈调整LSTM预测SET50中的股票价格</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/tuning-lstm-to-predict-stock-price-in-set50-with-lower-than-5-5-error-e19b422304b7?source=collection_archive---------7-----------------------#2020-05-16">https://medium.com/analytics-vidhya/tuning-lstm-to-predict-stock-price-in-set50-with-lower-than-5-5-error-e19b422304b7?source=collection_archive---------7-----------------------#2020-05-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2da21fbb8d6c1576bc24b424f92f3ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iPsESaMSKvlq5dEA"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马库斯·斯皮斯克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c0a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">知道未来总是更好的，尤其是在股票交易中，因为我们可以很好地计划何时买入何时卖出以获利。</p><p id="ad0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我在互联网上搜索时，我发现了一些使用长期短期记忆(LSTM)等深度学习算法预测股票价格的例子。<br/>然而，我还没有看到很多例子和结果，当我们对不同数量的股票使用该模型时，针对不同的预测范围调整LSTM以获得最佳结果和模型的准确性。</p><p id="0fd7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">🎯<strong class="ix hj">在这篇博文中，我将分享以下活动的过程和结果:</strong></p><ol class=""><li id="0103" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">使用LSTM构建股票预测器，并调整一只选定股票的参数，以预测其在未来1、5和10天的调整后收盘价。我打算调整参数的方式是:</li></ol><ul class=""><li id="cf41" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js kc jz ka kb bi translated">从所有参数的最低值开始，只允许调整一个参数。</li><li id="49bf" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">在构建、训练和验证参数的不同值的循环中循环，以找到这些参数的最佳值。</li><li id="5009" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">对所有参数都这样做，以查看哪个参数和哪个值的误差最小。</li><li id="98b4" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">用值更新特定的参数，而其他参数仍然是最低的。</li><li id="6316" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">重复所有步骤，直到误差不再降低，这将是最佳参数值的设置。</li></ul><p id="b034" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.通过使用从以前的主题中找到的一组参数来建立一个模型，以对另一组股票进行预测，并测量该模型可以在可接受的误差率下预测多少股票。</p><p id="eb05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.构建用户友好的脚本，用户可以:</p><ul class=""><li id="6029" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js kc jz ka kb bi translated">提供股票列表、历史数据的日期范围，并训练模型。</li><li id="41dd" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">通过选择股票和价格预测的日期范围来查询预测价格。</li></ul><p id="8175" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">数据来源</strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/02074f34239f188141fcf78d144bb64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qxjNOrSbbTihTSmm"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@will0629?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">将</a>放在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="95e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我居住在泰国，我的模型的目标股票列表将是泰国证券交易所中价值最高的50只股票(或SET50)。名单在这里:<a class="ae iu" href="https://www.settrade.com/C13_MarketSummary.jsp?detail=SET50." rel="noopener ugc nofollow" target="_blank">https://www.settrade.com/C13_MarketSummary.jsp?detail=SET50。</a>我将用作调整LSTM参数的样本的股票将是SET50中的一只股票。我使用的数据将来自雅虎财经——https://finance.yahoo.com/<a class="ae iu" href="https://finance.yahoo.com/" rel="noopener ugc nofollow" target="_blank"/>，它提供了开盘价、最高价、最低价、收盘价、调整后收盘价和交易量的历史数据。</p><p id="5f61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">指标</strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/c7c432519a0f5eb8eb68e6dfeef6f3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*drbdSBff8tf8LfOY"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张家瑜</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6a87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个研究主题的指标将是预测准确性的度量。因为，这将是预测线与实际线拟合程度的度量。均方差是衡量模型准确性的合适指标(越低越好)。我们甚至可以用平方根来找出数据和预测线之间的实际距离。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/848e4404bba5b1e39a03dde4f1de56bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YKfl2OVb9vvcVsP1"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">克里斯·里德在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6605" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⚠️ <strong class="ix hj">长文及前方技术内容</strong></p><p id="f56c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的内容将是上面列出的每个主题的深层实现。可以从这里阅读带有可执行源代码的Jupyter笔记本版本—<a class="ae iu" href="https://github.com/pathompong-y/stock_predictor/blob/master/stock_predictor_tuning_study.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/path ompong-y/stock _ predictor/blob/master/stock _ predictor _ tuning _ study . ipynb</a></p><p id="dbd6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想运行笔记本，并与内容相处，请检查项目的资源库上的说明—<a class="ae iu" href="https://github.com/pathompong-y/stock_predictor/blob/master/stock_predictor_tuning_study.ipynb" rel="noopener ugc nofollow" target="_blank">https://github.com/pathompong-y/stock_predictor/</a></p><p id="97e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">👌<strong class="ix hj">TLDR——结果和忙碌的家伙们如何自己做:)</strong></p><ul class=""><li id="065d" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js kc jz ka kb bi translated">通过迭代调整每个LSTM参数，我们可以降低模型的均方误差。我的试验中影响最大的参数是纪元和历史点(用于预测的历史数据范围)。</li><li id="8d32" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">为了优化误差，逐个股票地做比将一组参数推广到每个股票要好。</li><li id="16de" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">你可以用这个Jupyter笔记本试试我的参数。<br/><a class="ae iu" href="https://github.com/pathompong-y/stock_predictor/blob/master/stock_predictor.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/path ompong-y/stock _ predictor/blob/master/stock _ predictor . ipynb</a><br/>它不需要在你的电脑上安装，因为它将在【https://colab.research.google.com】上运行。说明已经在笔记本里了。</li><li id="8a89" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">使用此笔记本，您可以(1)提供股票列表和历史数据的日期范围来训练模型。我的参数将被自动应用(2)通过提供从训练数据的结束日期开始的日范围来查询预测价格。它最多可以预测10天。预测的MSE也会回归给你。</li><li id="5394" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">我不保证任何预测结果的准确性:)</li></ul></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="cf56" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">1.根据1、5和10天的预测，为集合50中的一个股票建立LSTM并优化参数</h1><p id="3204" class="pw-post-body-paragraph iv iw hi ix b iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated"><strong class="ix hj"> <em class="ly"> 1.1选择工作区，安装yfinance库</em> </strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/79a4d1a462c45ca64c8e3dab57b15692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*koDDW6xz9xsHo0sx"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">詹姆斯·庞德在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fddb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们需要从雅虎财经获得股票数据。<strong class="ix hj"> yfinance </strong>库是我们需要安装的包。它包含了从雅虎财经获取数据的功能。文档可以在这里找到—<a class="ae iu" href="https://pypi.org/project/yfinance/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/yfinance/</a>。</p><p id="4ec7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用安装yfinance！pip安装命令。</p><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="d37d" class="mf kw hi mb b fi mg mh l mi mj">!pip install yfinance<br/>import yfinance as yf</span></pre><p id="43f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于LSTM需要TensorFlow来构建和训练模型，我在谷歌的合作实验室—<a class="ae iu" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank">https://colab.research.google.com</a>上开发了这款笔记本，该实验室提供免费的Jupyter笔记本工作空间，安装了TensorFlow GPU支持。它还能够读取/写入文件到谷歌驱动器，这对于我来说非常方便，因为我的机器没有GPU。</p><p id="bae7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Keras是一个深度学习库，它实现了我将在这次探索中使用的LSTM——<a class="ae iu" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank">https://keras.io/</a>。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/2c2266a228f7170089b5d361d8836b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EI8GkXQf9ddkDWR5GMXf_Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我笔记本上的合作实验室截图</figcaption></figure><p id="bdad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="ly"> 1.2准备数据</em> </strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/0e57c5fc073c77252172782d37b4c8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4CxY4BpeA0XzeTdJ"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">弗兰·雅克耶在Unsplash<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的照片</a></figcaption></figure><p id="10aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们将在下一个主题中使用所有的SET50数据，所以我将下载它们。我选择探究的股票是INTUCH。BK就是我最近用来交易的那个。</p><p id="1fda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我使用collaboratory的Google Drive挂载功能来存储下载的数据以及在这台笔记本上工作时的中间结果。</p><p id="813b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">yfinance下面有一个方便的命令，可以下载2行内的历史数据。首先，我们必须使用股票代码名称启动yfinance的实例。之后，我们可以使用历史功能下载历史数据。yfinance文档中的更多细节:<a class="ae iu" href="https://pypi.org/project/yfinance/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/yfinance/</a></p><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="ca29" class="mf kw hi mb b fi mg mh l mi mj"># Instantiate object from stock ticker<br/>stock_data = yf.Ticker(stock)</span><span id="f2bb" class="mf kw hi mb b fi mm mh l mi mj"># yfinance history function is able to define period to download historical data<br/>pd.DataFrame(stock_data.history(period='max',auto_adjust=False,actions=False)).to_csv(file)</span></pre><p id="85f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我将数据保存到CSV之后，我对它们进行了一些研究，以检查数据的完整性、空数据和预期的特征(开盘、盘高、盘低、收盘、调整收盘、成交量)。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/38eeee72d2c147a355c5aa3dff969530.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*nNz1A25r6v2VLJCnSEaZAQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">插管。BK的例子数据来自雅虎财经</figcaption></figure><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/4e229055a27c33c9f596f706b2808b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*ZgZkb0Ks3ZUIfi-RSY08-Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">检查数据帧的空值和数据类型</figcaption></figure><p id="e7ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据快速检查，这些数据完全可以使用。</p><p id="a8ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">获得所有数据后，我们必须准备好训练模型。下面是要做的事情列表:</p><ol class=""><li id="5bed" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">删除空行(如果有的话),因为我们无论如何都不能使用它。</li><li id="5503" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">丢弃ate，因为我们不能在模型训练中使用它作为特征。</li><li id="5b97" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">将数据标准化为0-1之间的值，因为这将有助于神经网络具有更好的性能。这是根据这个帖子:<a class="ae iu" href="https://towardsdatascience.com/why-data-should-be-normalized-before-training-a-neural-network-c626b7f66c7d" rel="noopener" target="_blank">https://towardsdatascience . com/why-data-should-normalized-before-training-a-neural-network-c 626 b 7 f 66 c 7d</a>。为了标准化和扩展数据备份，我们可以使用Python的预处理。MinMaxScaler()。我们必须保留我们用来缩小数据的对象，并使用同一个对象放大数据。</li><li id="8139" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">转换数据格式。我们将预测预测日范围(1、5和10)期间的调整收盘。因此，数据集将由每天的开盘价、最高价、最低价和成交量组成，我们将使用这些数据来进行预测。</li><li id="a530" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">例如，如果我们说要使用30个历史点。我们数据集的一行将由以下特征组成:<br/> <code class="du mp mq mr mb b">[dayAopen, dayAclose, dayAvolume, dayAhigh, dayAlow,dayA-1open, dayA-1close, dayA-1volume, dayA-1high, dayA-1low....dayA-29low]</code></li></ol><p id="b07e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是我用来执行上述所有活动的代码。</p><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="b974" class="mf kw hi mb b fi mg mh l mi mj"># Construct the CSV filepath for INTUCH.BK</span><span id="1716" class="mf kw hi mb b fi mm mh l mi mj">stock = 'INTUCH.BK'<br/>filename = gdrive_path+stock+'.csv'</span><span id="22e9" class="mf kw hi mb b fi mm mh l mi mj"># Read the file and drop null row</span><span id="7b6a" class="mf kw hi mb b fi mm mh l mi mj">df = pd.read_csv(filename)<br/>df_na = df.dropna(axis=0)</span><span id="86f8" class="mf kw hi mb b fi mm mh l mi mj"># Drop Date as this is time series data, Date isn't used. Also drop Close as we will predict Adj Close.</span><span id="370d" class="mf kw hi mb b fi mm mh l mi mj">df_na = df_na.drop(['Date','Close'],axis=1)</span><span id="191e" class="mf kw hi mb b fi mm mh l mi mj"># As neural network has better performance with normalize data, we will normalize the data before train and predict</span><span id="6dac" class="mf kw hi mb b fi mm mh l mi mj"># After we got the predict result, we will scale them back to normal value to measure error rate.</span><span id="3c04" class="mf kw hi mb b fi mm mh l mi mj"># Normalise all data to the value range of 0-1 as neural network algorithm has better performance with this data range</span><span id="4ab1" class="mf kw hi mb b fi mm mh l mi mj">data_normaliser = preprocessing.MinMaxScaler()</span><span id="e063" class="mf kw hi mb b fi mm mh l mi mj">y_normaliser = preprocessing.MinMaxScaler()</span><span id="0320" class="mf kw hi mb b fi mm mh l mi mj">data_normalised = data_normaliser.fit_transform(df_na)</span><span id="57c5" class="mf kw hi mb b fi mm mh l mi mj"># The length of dataset, number of day to predict and number of features</span><span id="f046" class="mf kw hi mb b fi mm mh l mi mj">history_points = 30<br/>predict_range = 1</span><span id="5e96" class="mf kw hi mb b fi mm mh l mi mj"># Prepare the data in the format of [day-1-open,day-1-max,day-1-min,...day-history_point ] as 1 row input for predict the 'predict_range' price for train and test</span><span id="85a8" class="mf kw hi mb b fi mm mh l mi mj">ohlcv_histories_normalised = np.array([data_normalised[i  : i + history_points].copy() for i in range(len(data_normalised) - history_points - predict_range +1)])</span><span id="d79f" class="mf kw hi mb b fi mm mh l mi mj"># Get the actual price [day1-adj close,day2-adj close....day-predict_range adj close] for train and test</span><span id="a647" class="mf kw hi mb b fi mm mh l mi mj">next_day_adjclose_values_normalised = np.array([data_normalised[i + history_points:i + history_points + predict_range,3].copy() for i in range(len(data_normalised) - history_points - predict_range+1)])</span><span id="b72c" class="mf kw hi mb b fi mm mh l mi mj"># Create the same array as the normalised adj close but with the actual value not the scaled down value. This is used to calculate the prediction accuracy</span><span id="ce1e" class="mf kw hi mb b fi mm mh l mi mj">next_day_adjclose_values = np.array([df_na.iloc[i + history_points:i + history_points+predict_range]['Adj Close'].values.copy() for i in range(len(df_na) - history_points - predict_range+1)])</span><span id="338c" class="mf kw hi mb b fi mm mh l mi mj"># Use the passed normaliser to fit the actual value so that we can scale the predicted result back to actual value</span><span id="9192" class="mf kw hi mb b fi mm mh l mi mj">y_normaliser.fit(next_day_adjclose_values)</span></pre><p id="b95d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，数据准备好了。由于我们要训练模型，我们将不得不分割数据来训练和测试。</p><p id="d421" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">较旧的数据将成为训练集，较新的数据将成为测试集。我选择90%的数据作为训练数据，10%的数据作为测试数据。</p><p id="35b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，我们可以使用Python的数组切片来拆分数据。下面的代码是我的函数中的例子。ohlcv_histories是我们之前准备的数据。</p><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="5ef4" class="mf kw hi mb b fi mg mh l mi mj">n = int(ohlcv_histories.shape[0] * 0.9)</span><span id="0e21" class="mf kw hi mb b fi mm mh l mi mj">ohlcv_train = ohlcv_histories[:n]<br/>y_train = next_day_adj_close[:n]</span><span id="3a87" class="mf kw hi mb b fi mm mh l mi mj">ohlcv_test = ohlcv_histories[n:]<br/>y_test = next_day_adj_close[n:]</span></pre><p id="d684" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="ly"> 1.3构建、训练和验证模型</em> </strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/6997f01d791584c76265e3b8a265b3b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UzRwYkhH8kDjbIMT"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">克里斯汀·图曼扬在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="bd4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，准备创建LSTM模型，训练，并通过使用均方误差验证模型。我将使用的LSTM是一个简单的由隐藏层，下降层和预测层组成。</p><p id="ccbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我创建了一个函数，这样我就可以改变模型的参数。当我们建立LSTM模型时，我们改变的参数是:</p><ul class=""><li id="3886" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js kc jz ka kb bi translated">隐藏层数—LSTM层</li><li id="1d0c" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">丢失概率——忘记前一节点信息的概率</li><li id="71ca" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">历史点-在每次迭代中训练模型时使用的数据范围(例如，来自训练集中所有数据的每次迭代的30天)</li><li id="21a3" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">特征数量-特征的数量。如果我们添加更多的功能，这个数字必须改变。</li><li id="23ea" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">优化器(我们通常会使用“adam”)</li></ul><p id="86e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是函数内部的代码。</p><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="702b" class="mf kw hi mb b fi mg mh l mi mj"># Initialize LSTM using Keras library</span><span id="fab7" class="mf kw hi mb b fi mm mh l mi mj">model = Sequential()</span><span id="023f" class="mf kw hi mb b fi mm mh l mi mj"># Defining hidden layer number and the shape of the input (number of data in the dataset and the number of feature)</span><span id="5790" class="mf kw hi mb b fi mm mh l mi mj">model.add(LSTM(layer_num, input_shape=(history_points, features_num)))</span><span id="5fbe" class="mf kw hi mb b fi mm mh l mi mj"># Add forget (dropout) layer with probability per argument</span><span id="91ce" class="mf kw hi mb b fi mm mh l mi mj">model.add(Dropout(dropout_prob))</span><span id="ba26" class="mf kw hi mb b fi mm mh l mi mj"># End the network with hiddenlayer per the size of forecast day e.g. 1,5,10</span><span id="4541" class="mf kw hi mb b fi mm mh l mi mj">model.add(Dense(predict_range))</span><span id="8e7c" class="mf kw hi mb b fi mm mh l mi mj"># Build and return the model per the selected optimizer</span><span id="abe9" class="mf kw hi mb b fi mm mh l mi mj">model.compile(loss='mean_squared_error', optimizer=optimizer)</span></pre><p id="3b4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们从compile()获得模型结果后，我们可以用训练数据来拟合它。拟合数据时，我们可以更改的其他参数有:</p><ul class=""><li id="84d8" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js kc jz ka kb bi translated">批量</li><li id="9ea6" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">世</li></ul><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="7eeb" class="mf kw hi mb b fi mg mh l mi mj">model.fit(x=ohlcv_train, y=y_train, batch_size=batch_size, epochs=epoch, shuffle=True, validation_split=0.1)</span></pre><p id="9490" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦模型完成训练，我们可以使用测试数据来预测结果，并通过计算均方误差(MSE)将结果与实际结果进行比较。然而，我们得到的实际结果是按比例放大的值(正常价格，而不是我们从模型中得到的标准化的0-1)</p><p id="06dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在计算MSE之前，我们必须将预测价格按比例缩小。</p><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="c534" class="mf kw hi mb b fi mg mh l mi mj"># The model is train. Test with the test dataset</span><span id="9f37" class="mf kw hi mb b fi mm mh l mi mj">y_test_predicted = model.predict(ohlcv_test)</span><span id="9b0f" class="mf kw hi mb b fi mm mh l mi mj"># Scale up the result to actual value with y_normaliser that we use earlier</span><span id="c2c6" class="mf kw hi mb b fi mm mh l mi mj">y_test_predicted = y_normaliser.inverse_transform(y_test_predicted)</span><span id="bc20" class="mf kw hi mb b fi mm mh l mi mj"># Calculate the error with MSE</span><span id="144c" class="mf kw hi mb b fi mm mh l mi mj">real_mse = np.mean(np.square(unscaled_y_test - y_test_predicted))</span><span id="685b" class="mf kw hi mb b fi mm mh l mi mj">scaled_mse = real_mse / (np.max(unscaled_y_test) - np.min(unscaled_y_test)) * 100</span></pre><p id="2172" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们有了完整的代码来准备数据、构建、训练和验证模型，并且还能够在构建和训练模型时更改参数，以找到给出最低MSE的集合。</p><p id="0857" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于第一次尝试，我尝试用所有最低参数进行1天预测。我使用的历史点是下载的所有历史数据的30天。</p><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="870f" class="mf kw hi mb b fi mg mh l mi mj"># Must be the same as history point that we use to prepare data</span><span id="a2b4" class="mf kw hi mb b fi mm mh l mi mj">history_points = 30</span><span id="7047" class="mf kw hi mb b fi mm mh l mi mj"># Must be the same number of features when we prepare data</span><span id="99fd" class="mf kw hi mb b fi mm mh l mi mj">features_num = 5</span><span id="b7c0" class="mf kw hi mb b fi mm mh l mi mj"># LSTM parameters</span><span id="b6d2" class="mf kw hi mb b fi mm mh l mi mj">layer_num = 30</span><span id="890b" class="mf kw hi mb b fi mm mh l mi mj">predict_range = 1</span><span id="3bb3" class="mf kw hi mb b fi mm mh l mi mj">optimizer = 'adam'</span><span id="bb21" class="mf kw hi mb b fi mm mh l mi mj">dropout_prob = 1.0</span><span id="7dc6" class="mf kw hi mb b fi mm mh l mi mj"># Create LSTM model object</span><span id="d168" class="mf kw hi mb b fi mm mh l mi mj">model = get_LSTM_Model(layer_num, history_points, features_num,predict_range,optimizer,dropout_prob)</span><span id="5d61" class="mf kw hi mb b fi mm mh l mi mj"># Parameter for model training</span><span id="d18b" class="mf kw hi mb b fi mm mh l mi mj">batch_size = 10</span><span id="bdbf" class="mf kw hi mb b fi mm mh l mi mj">epoch = 10</span><span id="cc6b" class="mf kw hi mb b fi mm mh l mi mj"># Train model with our train data</span><span id="6a6c" class="mf kw hi mb b fi mm mh l mi mj">model.fit(x=ohlcv_train, y=y_train, batch_size=batch_size, epochs=epoch, shuffle=True, validation_split=0.1)</span></pre><p id="44eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">得到结果后，我们可以把预测价格和实际价格画出来，看看它们有什么不同。</p><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="074d" class="mf kw hi mb b fi mg mh l mi mj">real = plt.plot(unscaled_y_test, label='real')<br/>pred = plt.plot(y_test_predicted, label='predicted')</span><span id="37f8" class="mf kw hi mb b fi mm mh l mi mj">plt.legend(['Real', 'Predicted'])<br/>plt.show()</span></pre><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/603f5b2d3c502460abf727e3af39b0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*pEfVTmcVgNBCm5z-gR3Cng.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">第一次尝试的MSE约为6.18</figcaption></figure><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/0ff6edcc9465e5c752df5e1bedcd94a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kj9an8KmG_z0-NQO4RyteQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来自插入预测的示例结果。参数是最低的一个，和10一样。</figcaption></figure><p id="91b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以说，结果能够很好地捕捉趋势。当价格呈上升趋势时，它会不断预测低于实际价格，而预测高于实际价格。</p><p id="6d89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="ly"> 1.4优化1、5、10天预测参数</em> </strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/43ff092e3244a5e39ee9183d726e3eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yVaD3Y06QR7SJJHW"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张家瑜</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="ebb8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，是时候通过寻找最佳参数值来加强我们的模型了。总之，下面是要优化的参数列表:</p><ul class=""><li id="b827" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js kc jz ka kb bi translated">隐藏层数</li><li id="c97d" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">退出概率</li><li id="a703" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">历史要点</li><li id="eb35" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">批量</li><li id="1f8d" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">世</li></ul><p id="ab0d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我做的方法是创建一个函数，该函数将遍历一个参数的范围，而所有其他参数值将固定，以查看特定参数的哪个值给出最低的MSE。所以，我总共有5个函数。</p><p id="ce6c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是该函数的示例。其他函数共享相同的结构，但只是改变了参数。</p><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="0840" class="mf kw hi mb b fi mg mh l mi mj">def get_best_history_points(predict_range, max_history_points, stock_list, hidden_layer=10, batch_size=10,epoch=10,dropout_probability=1.0,mode='file'):</span><span id="f772" class="mf kw hi mb b fi mm mh l mi mj">mse_list = []</span><span id="9c27" class="mf kw hi mb b fi mm mh l mi mj">exception_list = []</span><span id="36fb" class="mf kw hi mb b fi mm mh l mi mj">for history_points in range(30,max_history_points+1,round(max_history_points/10)):</span><span id="acfa" class="mf kw hi mb b fi mm mh l mi mj">for stock in stock_list:</span><span id="ee30" class="mf kw hi mb b fi mm mh l mi mj">try:</span><span id="c7bb" class="mf kw hi mb b fi mm mh l mi mj">model, scaled_mse = train_and_validate_stock_predictor(stock,history_points,predict_range,hidden_layer,batch_size,epoch,dropout_probability,mode)</span><span id="e1e7" class="mf kw hi mb b fi mm mh l mi mj">print("Predict {} days for {} with MSE = {}".format(str(predict_range),str(stock),str(scaled_mse)))</span><span id="e184" class="mf kw hi mb b fi mm mh l mi mj">mse_list.append([history_points,stock,scaled_mse])</span><span id="9c2d" class="mf kw hi mb b fi mm mh l mi mj">pd.DataFrame(mse_list).to_csv('/content/drive/My Drive/Colab Notebooks/stocklist_'+str(predict_range)+'_mse_history_'+mode+'.csv')</span><span id="c866" class="mf kw hi mb b fi mm mh l mi mj">except Exception as e:</span><span id="1394" class="mf kw hi mb b fi mm mh l mi mj">print("exception "+str(e)+"on "+stock)<br/>exception_list.append([predict_range,stock,str(e)])<br/>pd.DataFrame(exception_list).to_csv('/content/drive/My Drive/Colab Notebooks/exception_list.csv')</span><span id="1555" class="mf kw hi mb b fi mm mh l mi mj">continue</span></pre><p id="7f85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我开始运行所有的函数，看看哪个参数在哪个值下给出最低的MSE。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/74540ddf2337f095a73427336b106361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*zR_SitzVJguP5q8nRjHvYw.png"/></div></figure><p id="c158" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从第一轮开始，我们发现epoch = 90的MSE最低，约为2.85</p><p id="8882" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将再次运行除epoch之外的所有函数，并将epoch值固定为60，作为所有函数的输入。这是为了找到可以进一步降低MSE的其他参数。我重复这些步骤，直到MSE不再下降。</p><p id="ef5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我得到了在2.79左右给出最低MSE的结果如下:</p><ul class=""><li id="5be4" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js kc jz ka kb bi translated">隐藏层数= 10</li><li id="d4da" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">退出概率= 1.0</li><li id="286e" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">批量=10</li><li id="1978" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">纪元=90</li><li id="e834" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">历史点数=90</li></ul><p id="9466" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我试图通过添加一些常用于股票交易的技术分析指标来进一步优化MSE。我选择MACD和均线，它们计算起来并不复杂。示例代码如下。它会把20天和50天的MACD和均线添加到股票数据框架中。</p><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="72c1" class="mf kw hi mb b fi mg mh l mi mj"># Extract Close data to calculate MACD</span><span id="23e4" class="mf kw hi mb b fi mm mh l mi mj">df_close = df[['Close']]</span><span id="2afe" class="mf kw hi mb b fi mm mh l mi mj">df_close.reset_index(level=0, inplace=True)</span><span id="3bf0" class="mf kw hi mb b fi mm mh l mi mj">df_close.columns=['ds','y']</span><span id="4744" class="mf kw hi mb b fi mm mh l mi mj"># Calculate MACD by using DataFrame's EWM https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.ewm.html</span><span id="b2d8" class="mf kw hi mb b fi mm mh l mi mj">exp1 = df_close.y.ewm(span=12, adjust=False).mean()</span><span id="8516" class="mf kw hi mb b fi mm mh l mi mj">exp2 = df_close.y.ewm(span=26, adjust=False).mean()</span><span id="bf5f" class="mf kw hi mb b fi mm mh l mi mj">macd = exp1-exp2</span><span id="8066" class="mf kw hi mb b fi mm mh l mi mj"># Merge MACD back as new column to the input df</span><span id="74c7" class="mf kw hi mb b fi mm mh l mi mj">df = pd.merge(df,macd,how='left',left_on=None, right_on=None, left_index=True, right_index=True)</span><span id="7d76" class="mf kw hi mb b fi mm mh l mi mj"># Rename DataFrame columns</span><span id="3774" class="mf kw hi mb b fi mm mh l mi mj">df.columns = ['Date','Open','High','Low','Close','Adj Close','Volume','MACD']</span><span id="86a3" class="mf kw hi mb b fi mm mh l mi mj"># Add new columns using EMA windwos size. EWM can use directly.</span><span id="ae6e" class="mf kw hi mb b fi mm mh l mi mj">df[ema1] = df['Close'].ewm(span=20, adjust=False).mean()</span><span id="2de7" class="mf kw hi mb b fi mm mh l mi mj">df[ema2] = df['Close'].ewm(span=50, adjust=False).mean()</span><span id="2ba3" class="mf kw hi mb b fi mm mh l mi mj">return df</span></pre><p id="919d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，具有附加数据的MSE反而增加到大约6.7。因此，将它们相加用于1天预测可能不是这样。</p><p id="3d32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查找1天参数的全部步骤如前所述。因此，我重复5天和10天预测的所有步骤，并得到如下结果:</p><p id="1453" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">2.78毫秒时的1天预测</strong></p><ul class=""><li id="f157" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js kc jz ka kb bi translated">历史分数:90</li><li id="f21b" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">隐藏层:10</li><li id="8d42" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">批量:10个</li><li id="93f9" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">辍学概率:1.0</li><li id="0357" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">纪元:90年</li><li id="8a16" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">添加MACD和EMA？:没有</li></ul><p id="b767" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">7.56毫秒时的5天预测</strong></p><ul class=""><li id="a298" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js kc jz ka kb bi translated">历史分数:30</li><li id="ffac" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">隐藏层:70</li><li id="aa0e" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">批量:10个</li><li id="9fa3" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">辍学概率:1.0</li><li id="6e96" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">纪元:60年</li><li id="a6c9" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">添加MACD和EMA？:没有</li></ul><p id="89a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">14.55毫秒时的10天预测</strong></p><ul class=""><li id="a1b0" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js kc jz ka kb bi translated">历史分数:50</li><li id="65be" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">隐藏层:60</li><li id="5a79" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">批量:10个</li><li id="83d2" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">辍学概率:0.3</li><li id="3907" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">纪元:80年</li><li id="7a79" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">添加MACD和EMA？:没有</li></ul><p id="387e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对我来说，增加MACD和均线对预测任何范围的INTUCH都没有帮助，这很令人惊讶。不过，我还是会保留这个功能，改为在SET50中用其他股票试一试。</p><p id="aa3d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们有了每天预测范围的参数。我们可以用SET50股票来尝试它们，看看有多少股票可以在1天、5天和10天的预测中达到可接受的精度。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/6e133a8897dc96ed4a69126c00949cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OF20Dim7Q1qAWw_uvcvyhA.png"/></div></div></figure></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="2f75" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">2.将上面设置的参数应用于SET50，看看它与其他股票的配合如何</h1><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b7831dd5af39d3ba286daa8839753bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R0026r9SIjJ51WBI"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马库斯·斯皮斯克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9ff8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1、5、10天贯穿50只股票需要很长时间。为了节省时间，我必须复制我的笔记本，并在3个浏览器选项卡上同时运行它们。<br/>我通过使用均方差直方图来可视化每一天的预测结果。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es my"><img src="../Images/10eb98f22290d83de173522e0dbba403.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*nIddOGxDv_rqtaf1Zic4Ew.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">1天预测MSE直方图</figcaption></figure><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/4c8b9f47fc0ddfe673506bbdec47e126.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*9wSgPJnh9ySnvC2x2W-z1A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">5天预测MSE直方图</figcaption></figure><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es na"><img src="../Images/ed94c402681372b5b57ea0990f873857.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*MdTpVo116Rm7iBvY_IMX2A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">10天预测MSE直方图</figcaption></figure><blockquote class="nb"><p id="843e" class="nc nd hi bd ne nf ng nh ni nj nk js dx translated">预测范围越大，MSE越高。</p></blockquote><p id="b797" class="pw-post-body-paragraph iv iw hi ix b iy nl ja jb jc nm je jf jg nn ji jj jk no jm jn jo np jq jr js hb bi translated">我还使用相同的参数值再次运行5天预测，但这次将MACD和EMA添加到数据集，以查看在有和没有附加数据的情况下结果有何不同。</p><p id="0810" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MSE微分直方图如下:</p><pre class="kj kk kl km fd ma mb mc md aw me bi"><span id="3b9c" class="mf kw hi mb b fi mg mh l mi mj">df_set50_five_days = pd.read_csv('/content/drive/My Drive/Colab Notebooks/set50_5_mse.csv')</span><span id="7fea" class="mf kw hi mb b fi mm mh l mi mj">df_set50_five_days_add = pd.read_csv('/content/drive/My Drive/Colab Notebooks/set50_5_mse_add_data.csv')</span><span id="128b" class="mf kw hi mb b fi mm mh l mi mj">df_set50_five_days_diff = pd.DataFrame(df_set50_five_days['1'] - df_set50_five_days_add['1'])</span><span id="e2d3" class="mf kw hi mb b fi mm mh l mi mj">plt.hist(df_set50_five_days_diff['1'], bins=100, color='#0504aa',</span><span id="cc9d" class="mf kw hi mb b fi mm mh l mi mj">alpha=0.7, rwidth=0.85)</span></pre><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es nq"><img src="../Images/492fd1a5bc5bbab125c933bafac3b7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*XI9p9946W0bckT5y-l9xNA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">大约50%的股票具有MSE增量，而另外50%的股票具有MSE减量</figcaption></figure><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es nr"><img src="../Images/6988e1e35fed4e4b4138fa6ab0a6268f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*Wy2H1Ar-faWzddE463DN-g.png"/></div></figure><p id="4166" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有趣的是，他们中大约一半人的成绩较好，另一半人的成绩较差。</p><p id="246d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">我们可以看到的一些结论是:</strong></p><ul class=""><li id="a2e2" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js kc jz ka kb bi translated">用于建立和训练模型的当前参数是基于一个示例股票而创建的，然而，可以用于预测其他股票，其中一些甚至比示例情况具有更好的准确性。</li><li id="b330" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js kc jz ka kb bi translated">我们可以看到，在我们添加MACD和均线作为训练附加特征后，一些股票的MSE增加了，一些股票的10天预测的MSE也减少了。基于此，很明显，为了优化股票价格预测的准确性，我们应该缩小一只股票的范围，因为该参数不会对所有股票给出好的结果，因为每只股票的价格都会因不同因素的影响而变化。</li></ul></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="cb6b" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">3.创建用户友好的功能，供用户选择他们感兴趣的股票，训练和查询股票价格预测</h1><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ns"><img src="../Images/3d3402ce5eeb5ebca27628ce549bf3cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w5AEnwfhikzR575F"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bdd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我得到最适合1天、5天和10天预测的LSTM参数集之后，我将尝试构建一个脚本，用户可以用它来训练模型和查询股票价格预测。</p><p id="c405" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于使用Keras的LSTM模型需要Tensorflow和一台像样的机器来运行，因此构建web服务器来构建和训练模型的成本相当高。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nt"><img src="../Images/99ba6a240dbfc6374dc4f11c7dd9187b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qaCaR7yDRE5Eo4iesDyQlg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Heroku是我尝试过的一个，但自由级不能管理运行模型训练这么长时间。</figcaption></figure><p id="2fbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在Heroku上试过免费层的网络服务器，但是免费层的网络服务器任何功能的执行时间都是有限的。因此，不可能运行需要超过5分钟的模型训练。</p><p id="62dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，我决定把笔记本分开。新的将有2个代码单元。一个用于接收股票列表和一系列训练数据，另一个用于查询预测价格。</p><p id="955d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我需要将我的所有功能打包到一个文件中，以便通过将笔记本和功能文件一起上传到新的collaboratory空间并准备好运行来轻松使用它。<br/>用户将能够提供股票列表和数据的日期范围来训练模型。然后，查询限制在10天预测的预测价格。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nu"><img src="../Images/a0d84bcc8c1fac8687bbbf428a99359a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHfWlP9KnHxPDwMrEanWIg.png"/></div></div></figure><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nv"><img src="../Images/9944915f0ef63bd6d83ef50c3860b923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTNbBeniFY4rC8dbA3bQJw.png"/></div></div></figure><p id="198f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在我的资料库里找到这个笔记本的副本。已经提供了设置的说明—<a class="ae iu" href="https://github.com/pathompong-y/stock_predictor/blob/master/stock_predictor.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/path ompong-y/stock _ predictor/blob/master/stock _ predictor . ipynb</a></p><p id="b6cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，最方便的运行方式是使用<a class="ae iu" href="https://colab.research.google.com" rel="noopener ugc nofollow" target="_blank">https://colab.research.google.com</a></p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nw"><img src="../Images/344ec481e2eb50b2de1594284473ea14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yEEtDW7OnAeAfeyl"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@lusvardi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Lusvardi </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="9288" class="kv kw hi bd kx ky nx la lb lc ny le lf lg nz li lj lk oa lm ln lo ob lq lr ls bi translated">💻结论</h1><ol class=""><li id="20b0" class="jt ju hi ix b iy lt jc lu jg oc jk od jo oe js jy jz ka kb bi translated">调整LSTM参数的一种方式是通过从将每个参数设置为最低开始逐一迭代调整，并且一次仅迭代改变一个参数，以找到具有最低MSE的值。然后，将该参数值与其他参数一起使用，并迭代找到下一个参数的最佳值。</li><li id="64c4" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">预测范围越大，我们得到的误差就越大。</li><li id="13cb" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">添加技术分析指标，如MACD和均线，有助于提高50%的股票在5天内预测的准确性。</li><li id="a0e8" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">在一天结束时，为了优化预测的准确性，我们必须一个股票一个股票地做，因为会影响它的特征是不同的。</li></ol><h1 id="bdf2" class="kv kw hi bd kx ky nx la lb lc ny le lf lg nz li lj lk oa lm ln lo ob lq lr ls bi translated">👓进一步改进</h1><ol class=""><li id="ea41" class="jt ju hi ix b iy lt jc lu jg oc jk od jo oe js jy jz ka kb bi translated">我们有很多进一步改进模型的可能性，例如我们可以调整均线范围，甚至增加其他技术分析指标，并尝试组合使用它们。</li><li id="1a97" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">我们也可以将股票重新分组，使其价格变动基于相同的一组特定标准。例如，将石油和天然气公司分组在一起，我们可以添加石油价格作为额外的数据特征，因为这些公司的股票价格将受到石油价格运动的影响。</li></ol><p id="a81b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样。感谢你阅读这篇长文，我希望它能给你一些启发，让你有灵感去进一步改进它。</p><p id="6834" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我也是这个领域的新手，请让我知道我在这里分享的工作的任何错误或进一步改进的地方。那会很感激我的。</p><p id="97f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一个项目再见！</p></div></div>    
</body>
</html>