<html>
<head>
<title>@Async and Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">@Async和Spring Boot</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/async-and-spring-boot-d0f5c38f82c2?source=collection_archive---------1-----------------------#2019-09-11">https://medium.com/analytics-vidhya/async-and-spring-boot-d0f5c38f82c2?source=collection_archive---------1-----------------------#2019-09-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5380" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多线程很好…感觉我们实际上是在利用CPU的计算能力！虽然默认情况下每个应用程序有不同的线程用于不同的目的，但是根据需要生成我们自己的线程是个好主意。</p><p id="0e31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，Spring Boot是JEE最流行的应用程序开发框架之一，它有自己内置的线程池支持。这是一个关于我们如何使用Spring的<strong class="ih hj"> @Autowire </strong>和<strong class="ih hj"> CompletableFuture </strong>在我们的Web应用中实现多线程的故事。这不是Spring的教程，而是我们如何为已经了解Spring和多线程环境的观众解决一个特殊的问题。</p><p id="73c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们应用的结构和问题</strong></p><p id="69c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们利用Spring Boot框架开发了一个RESTful Web服务。应用程序还需要与一些外部服务对话，这些对外部服务的调用可以是同步的，也可以是异步的。</p><p id="35ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们还需要有一个结构，新来的开发人员可以灵活地编写多线程代码。下面是一个简化的应用程序图，有助于理解整个场景。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/dde389c48577ff9b818fa24fc0db6786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mi7vauCo3-lMUrMcicXcHg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">讨论中的应用程序的结构</figcaption></figure><p id="4290" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，问题是要编写一个好的多线程代码，可以在同一个守护线程中执行，还有一些框架，重用逻辑会更容易。</p><p id="2b77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">关于@Async的问题</strong></p><p id="cdad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring自带@Async注释，让我们的工作变得简单。你所需要做的，就是注释你想要异步执行的函数。但是有一个问题。@Async暗示不能使用<strong class="ih hj"> this调用这种带注释的函数。</strong>关键词。此外，将任何函数标记为@Async意味着它将总是在其他线程中运行，而不是我们想要的。</p><p id="9414" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们是如何解决的</strong></p><p id="9c79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我会一步一步来。</p><p id="c849" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一件事是为我们的应用程序创建一个线程池bean。创建它将使我们能够控制正在创建、排队和重用的线程的策略。在源代码中，<strong class="ih hj">Executor.java</strong>是负责这个的代码。<strong class="ih hj">@ Bean(" custom thread executor ")</strong>就是发生这种情况的地方。这意味着出于其他目的，我们也可以以类似的方式创建其他池。</p><p id="75f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如上面所讨论的，我们不能在外部服务调用中实现任何并发性，因为该部分需要是可重用的组件并且是分离的。<strong class="ih hj">ExternalService.java</strong>是执行任何资源扩展操作的类。在这篇文章中，我通常引用外部服务调用，但在现实世界中，任何被认为是资源密集型的操作，比如io操作，从一些输入设备读取输入，都应该在专用线程中执行。</p><p id="e90f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">控制器和服务层都需要解耦和自由，因为它们的工作只是将请求转移到所需的逻辑/实现。</p><p id="87cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">真正的魔术发生在<strong class="ih hj">CustomLogicExtension.java</strong>档。这是CustomLogic.java的<strong class="ih hj">的扩展，其中我们所有的业务逻辑相关的方法被分组进行抽象。</strong></p><p id="d635" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在在<strong class="ih hj">CustomLogixExtension.java文件中，</strong><strong class="ih hj">do function()</strong>方法使用<strong class="ih hj"> CompletableFuture </strong>类进行异步调用。在<strong class="ih hj"> java.util.concurrent </strong>包中有一大堆不同的类和方法，使异步调用变得轻而易举。因此，在我们的实现中，我们在<strong class="ih hj"> supplyAsync </strong>方法中进行异步调用。这个方法调用一些外部服务。现在，外部服务可能需要很长时间，并且不在我们的控制之下，所以我们不能停止应用程序。更确切地说，调用进一步移动，一个通用文本被返回给控制器，在这种情况下是来自定制逻辑的<strong class="ih hj"> <em class="jt"> hello。</em> </strong></p><p id="abfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，作为我们从外部服务获得的响应或任何异常，我们对其采取行动。<strong class="ih hj">然后AcceptAsync </strong>就是发生这种情况的地方。<strong class="ih hj"> </strong>任何企业应用程序都可能需要更新数据库，调用其他服务，或者根据收到的结果打印日志。这是可以执行所有此类操作的地方。在文档中，有多种实现，允许我们在执行完成后返回或不返回任何数据。<em class="jt">详细文档可以在</em> <a class="ae ju" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" rel="noopener ugc nofollow" target="_blank"> <em class="jt">这里找到</em> </a> <em class="jt">。</em></p><p id="b268" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，遗嘱执行人在哪里发挥作用呢？CompletableFuture允许指定我们自己的线程执行器。这意味着我们可以指定接口使用的线程池，或者返回Spring的默认线程池。然而，在我看来，创建和配置一个单独的线程池是至关重要的，因为它可以对应用程序的资源进行更多的控制，并使监控更加容易。上面讨论的<strong class="ih hj"> @async </strong>也允许传入线程池。</p><p id="5675" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同步和异步执行的灵活性如何？通过使用CompletableFuture类，我们确保了代码在单独的线程中执行。但是如果我们需要在同一个守护线程上运行呢？很简单<strong class="ih hj"> new ExternalService()。callToExternalService()；</strong>就是所谓的外部服务。我们能做的是在CustomLogicExtension.java类中创建一个简单的函数，比如说<strong class="ih hj">callAsync()</strong><em class="jt">—</em><strong class="ih hj"><em class="jt"/></strong><em class="jt">我还没有在回购代码中创建这样的函数— </em>它将保存异步实现，而同步实现将驻留在CustomLogicExtension.java的doFunction()方法中。小菜一碟！</p><p id="d8bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦代码被执行并且GET call被发送到:<a class="ae ju" href="https://localhost:8080/hello" rel="noopener ugc nofollow" target="_blank">https://localhost:8080/hello</a>我们开始接收响应。但是在控制台中，我们可以看到实际发生的情况。我让创建的线程休眠10000毫秒。因此可以清楚地看到效果。</p><p id="55cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的屏幕截图中，您可以看到正在创建的新线程。请注意，只创建了10个线程，因为我们的线程池有10个线程。在10个线程之后，先前的线程被重用。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jv"><img src="../Images/9dadc2a6fb68468810a5c4afcb993111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qt7OBiE6fzjqubwaBUWxJg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">螺纹名称打印在上面的屏幕截图中，前缀为<strong class="bd jw">自定义</strong>。</figcaption></figure><p id="9a17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论</strong></p><p id="ed7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这只是使用<strong class="ih hj">线程执行器</strong>和<strong class="ih hj"> CompletableFuture </strong>实现并发的一种方式。也可以有其他方法来实现相同的结果。但是对于我们的目的来说，这已经足够了。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><blockquote class="ke kf kg"><p id="2649" class="if ig jt ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">如果不小心实现，线程有时会带来麻烦和意想不到的结果。在我的职业生涯中，我就遇到过这样的情况。我已经在<a class="ae ju" rel="noopener" href="/@umairkhan62/multi-threaded-chaos-69216bb2c45a"> <strong class="ih hj"> Java Threads和Chaos </strong> </a>中解释了这个问题，从生产数据中获得了意想不到的模糊结果。</p></blockquote></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="3564" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在<a class="ae ju" href="https://github.com/umairk83/Some-code-stuff/tree/master/async-demo" rel="noopener ugc nofollow" target="_blank"> Github </a>库找到完整的代码。请随意使用代码。是时候结束我的java进程了。</p><p id="4929" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">.</p><p id="2261" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">.</p><p id="98a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一篇文章再见…</p></div></div>    
</body>
</html>