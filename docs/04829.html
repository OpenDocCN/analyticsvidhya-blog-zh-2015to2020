<html>
<head>
<title>Matrix Multiplication in CUDA — A Simple Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CUDA中的矩阵乘法——简单指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/matrix-multiplication-in-cuda-a-simple-guide-bab44bc1f8ab?source=collection_archive---------1-----------------------#2020-04-02">https://medium.com/analytics-vidhya/matrix-multiplication-in-cuda-a-simple-guide-bab44bc1f8ab?source=collection_archive---------1-----------------------#2020-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5292" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今年春季学期，我参加了<em class="jd">编程加速器架构</em>课程，并花了一些时间在CUDA中实现矩阵乘法。我想和大家分享一下我的经历会很不错！</p><h1 id="4820" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">基础</h1><p id="24f9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">假设我们要将矩阵<strong class="ih hj"> <em class="jd"> A </em> </strong>与矩阵<strong class="ih hj"> <em class="jd"> B </em> </strong>相乘来计算矩阵<strong class="ih hj"> <em class="jd"> C </em> </strong>。假设<strong class="ih hj"> <em class="jd"> A </em> </strong>是A<strong class="ih hj"><em class="jd">p</em>×<em class="jd">w</em></strong>矩阵，B是a <strong class="ih hj"> <em class="jd"> w × q </em> </strong>矩阵，那么<strong class="ih hj"> <em class="jd"> C </em> </strong>将是<strong class="ih hj"> <em class="jd"> p × q </em> </strong>矩阵。矩阵乘法很简单。要计算<strong class="ih hj"><em class="jd">【C】</em></strong>中的<strong class="ih hj">【T37(I，j)】</strong>第I行<strong class="ih hj"><em class="jd"><strong class="ih hj"><em class="jd">第A行</em> </strong>与<strong class="ih hj"><em class="jd">【B</em></strong>第j列<em class="jd"/></em></strong>(图1)。所以<strong class="ih hj"> <em class="jd"> C </em> </strong>中的单个元素将是一个向量-向量乘法。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/94a395f2af549bc41d858cb50e53d51d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OD8WI1NpCGQHfMVE1tmIlg.jpeg"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">图1:矩阵乘法会发生什么？</figcaption></figure><p id="e149" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在CUDA中实现并行矩阵乘法的一个显而易见的方法是让每个线程做一个向量-向量乘法，即C矩阵中的每个元素将由一个单独的CUDA线程来计算。</p><h1 id="8b0a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">简单的CUDA实现</h1><p id="fcd7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在CUDA编程模型中，线程被组织成线程块和网格。线程块是编程模型允许的最小线程组，网格是多个线程块的排列。如果你不熟悉线程块和网格，请参考<a class="ae kx" href="https://stackoverflow.com/questions/2392250/understanding-cuda-grid-dimensions-block-dimensions-and-threads-organization-s" rel="noopener ugc nofollow" target="_blank">这个</a>。线程块或网格可以排列成一维、二维或三维</p><p id="584d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们是乘2-D矩阵，所以只有在2-D中安排线程块和网格才有意义。在大多数现代NVIDIA GPUs中，一个线程块最多可以有1024个线程。因此我们可以使用一个32×32的二维线程块(让我们假设我们的线程块大小是<strong class="ih hj"><em class="jd">BLOCK _ SIZE x BLOCK _ SIZE</em></strong>)。现在我们应该如何安排我们的网格？由于输出矩阵是<strong class="ih hj"> <em class="jd"> p × q </em> </strong>，我们至少需要有<strong class="ih hj"><em class="jd"/></strong>在<strong class="ih hj"><em class="jd">y</em></strong>-dimension<strong class="ih hj"><em class="jd">⌈q/32⌉</em></strong>在<strong class="ih hj"> <em class="jd"> x </em> </strong> -dimension中的线程块数(图2)。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ky"><img src="../Images/942e83340fd249e96c26fc91772ece06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IRC_FgK70P94OCm69cZseQ.jpeg"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">图2:简单矩阵乘法的线程块和网格组织</figcaption></figure><p id="5710" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，使用CUDA可以如下指定块和网格尺寸。这里我假设矩阵中的列在<strong class="ih hj"><em class="jd">x</em></strong>-维度中被索引，而行在<strong class="ih hj"><em class="jd"/></strong>-维度中被索引。所以<strong class="ih hj"><em class="jd">x</em></strong>-维网格会有<strong class="ih hj"><em class="jd"/></strong>块。</p><pre class="ki kj kk kl fd kz la lb lc aw ld bi"><span id="d57d" class="le jf hi la b fi lf lg l lh li">dim3 dim_grid(ceilf(P/(float)BLOCK_SIZE), ceilf(Q/(float)BLOCK_SIZE), 1);<br/>dim3 dim_block(BLOCK_SIZE, BLOCK_SIZE, 1);</span></pre><p id="bbf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们继续我们的矩阵乘法核心。首先，我们需要内核的哪些参数？我们需要<strong class="ih hj"> <em class="jd"> A </em> </strong>矩阵、<strong class="ih hj"> <em class="jd"> B </em> </strong>矩阵和结果<strong class="ih hj"> <em class="jd"> C </em> </strong>矩阵。假设我们所有的矩阵都按照<a class="ae kx" href="https://en.wikipedia.org/wiki/Row-_and_column-major_order" rel="noopener ugc nofollow" target="_blank">行优先顺序</a>排列(即一行中的元素将被放置在连续的内存位置)。我们还需要<strong class="ih hj"> <em class="jd">宽度</em> </strong>这是每个线程必须完成的向量-向量乘法的长度。因为我们拿<strong class="ih hj"> <em class="jd"> q/32 </em> </strong>和<strong class="ih hj"> <em class="jd"> p/32 </em> </strong> CUDA内核启动器会启动比我们需要的更多的线程。因此我们需要值<strong class="ih hj"> <em class="jd"> P </em> </strong>和<strong class="ih hj"><em class="jd">Q</em></strong>(<strong class="ih hj"><em class="jd">C</em></strong>矩阵的维度)来检查给定的线程是否计算了输出矩阵中的有效元素。</p><pre class="ki kj kk kl fd kz la lb lc aw ld bi"><span id="12e7" class="le jf hi la b fi lf lg l lh li">template&lt;typename T&gt;<br/>__global__<br/>void naive_matrix_multiply(const T *A, const T *B, T* C, int width, int P, int Q)<br/>{<br/>  int r = blockIdx.y * blockDim.y + threadIdx.y;   <br/>  int c = blockIdx.x * blockDim.x + threadIdx.x;<br/>  // check boundry conditions<br/>  if( r &lt; P &amp;&amp; c &lt; Q){<br/>    // do the multiplication for one row and col<br/>    T value = 0;<br/>    for(int k = 0; k &lt; width; k++){<br/>      value += A[r * width + k] * B[k * Q + c];<br/>    }<br/>    // store the result<br/>    C[r * Q + c] = value;<br/>  }</span><span id="7ac9" class="le jf hi la b fi lj lg l lh li">}</span></pre><p id="aba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要理解这段代码，首先你需要知道每个CUDA线程将独立执行这段代码。将有<strong class="ih hj"> <em class="jd"> P×Q </em> </strong>个线程执行这段代码。因为每个线程都在计算C矩阵中的一个元素，所以我们必须首先计算这个元素的行和列。</p><p id="59f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线程排列在二维网格中的二维线程块中。CUDA提供了一个简单的索引机制来获取线程块内的线程ID(<em class="jd">threadidx . x</em>、<em class="jd"> threadIdx.y </em>和<em class="jd"> threadIdx.z </em>)和网格内的块id ( <em class="jd"> blockIdx.x </em>、<em class="jd"> blockIdx.y </em>和<em class="jd"> blockIdx.z </em>)。在我们的例子中，行在<strong class="ih hj"><em class="jd">y</em></strong>-维度中被索引。为了根据CUDA <em class="jd"> threadIdx </em>和<em class="jd"> blockIdx </em>计算第<strong class="ih hj">行<em class="jd"> r </em>行的索引，我们可以将<em class="jd"> blockIdx.y </em>乘以<em class="jd"> blockDim.y </em>得到线程总数达到<em class="jd"> blockIdx.y </em>块数。然后我们添加<em class="jd"> threadIdx.y </em>，它是该线程所属的块中沿着<strong class="ih hj"> <em class="jd"> y </em> </strong>维度的线程ID(图3)。列<strong class="ih hj"> <em class="jd"> c </em> </strong>的列索引可以沿着<strong class="ih hj"><em class="jd">×维度类似地计算。</em></strong></strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lk"><img src="../Images/83f8585a13109bad89b69d8db3d2af63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSff1tdlMOazM9VR76NCYQ.jpeg"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">图3:行计算</figcaption></figure><p id="3f31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来的步骤非常简单。我们需要检查<strong class="ih hj"> <em class="jd"> r </em> </strong>和<strong class="ih hj"> <em class="jd"> c </em> </strong>是否在界限内<strong class="ih hj"> <em class="jd"> P </em> </strong>和<strong class="ih hj"> <em class="jd"> Q </em> </strong>。然后我们把<strong class="ih hj"><em class="jd">A</em><em class="jd">c</em></strong>列<strong class="ih hj"> <em class="jd"> B </em> </strong>中的<strong class="ih hj"> <em class="jd"> r </em> </strong>第7行 与<strong class="ih hj"><strong class="ih hj">c</strong>做向量-向量相乘。由于<strong class="ih hj"> <em class="jd"> A </em> </strong>和<strong class="ih hj"> <em class="jd"> B </em> </strong>是按照行优先顺序在内存中布局的，所以我们可以使用<code class="du ll lm ln la b">A[r*width + k]</code>(<em class="jd">0≤k≤宽度</em>)来访问<strong class="ih hj"><em class="jd">r</em></strong><strong class="ih hj"><em class="jd">A</em></strong>中的所有元素。<strong class="ih hj"> <em class="jd"> B </em> </strong>中的接入列<strong class="ih hj"> <em class="jd"> c </em> </strong>有点棘手。第0行第<strong class="ih hj"> <em class="jd"> c </em> </strong>列的值很容易！也就是整个<strong class="ih hj"> <em class="jd"> B </em> </strong>数组中索引<strong class="ih hj"> <em class="jd"> c </em> </strong>的值。现在第1行第<strong class="ih hj"> <em class="jd"> c </em> </strong>列的值将在<code class="du ll lm ln la b">B[1*Q + c]</code>。怎么会这样记住<strong class="ih hj"> <em class="jd"> Q </em> </strong>是<strong class="ih hj"> <em class="jd"> B </em> </strong>中的列数。因此，为了访问第1行的第<strong class="ih hj"><em class="jd"/></strong>c列，我们从第0行的第<strong class="ih hj"><em class="jd"/></strong>c列索引开始，沿着整个<strong class="ih hj"><em class="jd"/></strong>B</strong>数组，通过<strong class="ih hj"> <em class="jd"> Q </em> </strong>元素进行跳转。现在要访问列<strong class="ih hj"> <em class="jd"> c </em> </strong>中的所有元素，我们可以使用<code class="du ll lm ln la b">B[k*Q + c]</code>(<em class="jd">0≤k≤宽度</em>)，非常简单！。计算完矢量-矢量积后，最后一步是存储结果。于是我们计算出了输出矩阵<strong class="ih hj"> <em class="jd"> C </em> </strong>中的<strong class="ih hj"> <em class="jd"> r </em> </strong>第<strong class="ih hj"> <em class="jd"> c </em> </strong>列。该元素的索引将简单地为<code class="du ll lm ln la b">r*Q + c</code>。</p><p id="020b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然，这种矩阵乘法非常简单，并且没有充分发挥GPU的潜力。在下一篇文章中，我将解释如何使用共享内存和分块来优化这段代码。</p><p id="6a0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您仍然对本教程的代码感兴趣，可以从这里的获得。</p></div></div>    
</body>
</html>