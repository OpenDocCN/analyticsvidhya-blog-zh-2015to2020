<html>
<head>
<title>The mutability question with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的可变性问题</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-mutability-question-with-python-582c5fbe3b35?source=collection_archive---------15-----------------------#2020-05-26">https://medium.com/analytics-vidhya/the-mutability-question-with-python-582c5fbe3b35?source=collection_archive---------15-----------------------#2020-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5ead" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">可变或不可变的对象，为什么？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f6d0b421d51646f70b8ee3f11c5e89b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IRGB-4OAoO8KSqH_huDPFw.png"/></div></div></figure><p id="b56c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi kf translated">python中的对象分为两种类型:<strong class="jl hj"> <em class="ko">可变</em> </strong>和<strong class="jl hj"> <em class="ko">不可变</em> </strong>。为了更好地理解它们的含义和它们之间的区别，让我们介绍一些基本的工具和概念。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="0898" class="kw kx hi bd ky kz la lb lc ld le lf lg js lh li lj jw lk ll lm ka ln lo lp lq bi translated"><strong class="ak"> I. Id和类型</strong></h2><ul class=""><li id="34c3" class="lr ls hi jl b jm lt jp lu js lv jw lw ka lx ke ly lz ma mb bi translated"><strong class="jl hj"> id : </strong>一个对象Id或<strong class="jl hj"> <em class="ko"> identity </em> </strong>是对象在内存中的地址，一旦创建就唯一且不可更改，Python为我们提供了函数<strong class="jl hj"><em class="ko">【Id()’</em></strong>，返回一个对象的身份，以及一个Id的比较工具<strong class="jl hj"><em class="ko">‘is’</em></strong>。(注意，<strong class="jl hj"> <em class="ko">'是'</em> </strong>通常与逻辑符号<strong class="jl hj"> <em class="ko"> '==' </em> </strong>混淆，而它们没有相同的效果，第二个比较被拖对象的<strong class="jl hj"> <em class="ko">值</em> </strong>，而<strong class="jl hj"> <em class="ko">'是'</em> </strong>比较它们的id)</li><li id="8288" class="lr ls hi jl b jm mc jp md js me jw mf ka mg ke ly lz ma mb bi translated"><strong class="jl hj">类型:</strong>每一个物体都有其唯一不变的类型，它回答了这样的问题:这个物体有大小吗？一个长度？解析器？长度计算器？嗯，我们确信它有一个类型支持关于对象的所有数据。Python给了我们“type()”函数，它打印出一个对象的类型。</li></ul></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="387c" class="kw kx hi bd ky kz la lb lc ld le lf lg js lh li lj jw lk ll lm ka ln lo lp lq bi translated">二。可变对象</h2><p id="c67a" class="pw-post-body-paragraph jj jk hi jl b jm lt ij jo jp lu im jr js mh ju jv jw mi jy jz ka mj kc kd ke hb bi translated">简单地说，可变对象是指在创建后可以改变的对象。在Python中，我们计算3种不同的可变对象:</p><p id="6792" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">。列表:</strong>顾名思义，列表类型是不同类型对象列表。我们可以访问一个列表，删除一个元素，添加一个元素或者改变一个现有元素的值(因为列表的元素通常是不可变的，所以我们在内存中创建了另一个对象，而没有修改现有的对象)，这要感谢它的可变特性。在下面的示例中，我们可以看到适用于列表的不同操作:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="8ab0" class="kw kx hi ml b fi mp mq l mr ms">&gt;&gt;&gt; my_list = [1, 2, 3]<br/>&gt;&gt;&gt; my_list.append('string')<br/>&gt;&gt;&gt; my_list.pop(my_list[0])  #this operation deletes the element                  from the list and not from the memory as my_list[0] is int : an immutable object<br/>&gt;&gt;&gt; my_list<br/>[2, 3, 'string']</span></pre><p id="3ee7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">。字典是一个无序的、可变的和有索引的集合。在Python中，字典是用花括号写的，它们有键和值。</strong></p><p id="a4e3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">。集合:</strong>集合是一种无序的集合数据类型，它是可迭代的、可变的并且没有重复的元素。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="ae23" class="kw kx hi bd ky kz la lb lc ld le lf lg js lh li lj jw lk ll lm ka ln lo lp lq bi translated">三。不可变对象</h2><p id="fbc2" class="pw-post-body-paragraph jj jk hi jl b jm lt ij jo jp lu im jr js mh ju jv jw mi jy jz ka mj kc kd ke hb bi translated">不出所料，Python中的不可变对象是一个不可改变的、不可到达的对象，我们不能访问它从而修改它。换句话说，修改这个对象的值会导致为另一个对象分配空间。我们认为Python中有3个不可变对象:</p><ul class=""><li id="5684" class="lr ls hi jl b jm jn jp jq js mt jw mu ka mv ke ly lz ma mb bi translated"><strong class="jl hj"> Int : </strong>整数存储数值。这里有一个我们应用这个概念的简单例子:</li></ul><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="31b8" class="kw kx hi ml b fi mp mq l mr ms">&gt;&gt;&gt; x = 55<br/>&gt;&gt;&gt; id(x)<br/>94000217707880<br/>&gt;&gt;&gt; x = 18<br/>&gt;&gt;&gt; id(x)<br/>140060181730800</span></pre><p id="05f0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如我们注意到的，对先前创建的对象进行更改会导致创建另一个具有另一个id的对象。</p><ul class=""><li id="639b" class="lr ls hi jl b jm jn jp jq js mt jw mu ka mv ke ly lz ma mb bi translated"><strong class="jl hj">元组:</strong>我们可以说Python中的元组是列表的不可变版本，因为它们几乎是相同的东西，除了元组是不可变的，并且是用圆括号而不是方括号创建的。</li><li id="8b3e" class="lr ls hi jl b jm mc jp md js me jw mf ka mg ke ly lz ma mb bi translated"><strong class="jl hj">字符串:</strong>字符串只是一系列不可改变的字符，因此在Python语言中是不可变的。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/d5a8590a24848753d59c40dc63af58f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*ZlTJqCjUN51PG5-ivNictQ.png"/></div></div></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="b878" class="kw kx hi bd ky kz la lb lc ld le lf lg js lh li lj jw lk ll lm ka ln lo lp lq bi translated">四。为什么这很重要，Python对待可变对象和不可变对象有什么不同:</h2><ul class=""><li id="67ee" class="lr ls hi jl b jm lt jp lu js lv jw lw ka lx ke ly lz ma mb bi translated">这很重要因为程序员有他自己的理由创建不可改变的对象，以防止它们被修改，从而创建不可改变的对象，或者创建其他大小和元素可变的对象，从而选择可变的对象，换句话说，上下文使我们做出的选择有意义。</li><li id="ce5d" class="lr ls hi jl b jm mc jp md js me jw mf ka mg ke ly lz ma mb bi translated"><strong class="jl hj">Python如何处理它们:</strong>我们已经介绍了“is”和“==”操作符，这将有助于我们了解Python处理这两种类型对象的不同方式。事实上下面的例子解释了很多:</li></ul><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="22b6" class="kw kx hi ml b fi mp mq l mr ms">&gt;&gt;&gt; string_1 = "immutable"<br/>&gt;&gt;&gt; string_2 = "immutable"<br/>&gt;&gt;&gt; string_1 == string_2<br/>True<br/>&gt;&gt;&gt; string_1 is string_2<br/>True</span></pre><p id="fd50" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里我们注意到string类型的不可变对象有两个指针；string_1和string_2都指向内存中的同一个位置。事实上，使用id()函数会得到相同的整数。</p><p id="3134" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">而在下一个例子中，我们看到了相反的情况:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="a061" class="kw kx hi ml b fi mp mq l mr ms">&gt;&gt;&gt; list_1 = [1, 2, 3]<br/>&gt;&gt;&gt; list_2 = [1, 2, 3]<br/>&gt;&gt;&gt; list_1 == list_2<br/>True                       #the tow lists share the same value<br/>&gt;&gt;&gt; list_1 is  list_2      # But they point to different locations<br/>False</span></pre></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="fbe0" class="kw kx hi bd ky kz la lb lc ld le lf lg js lh li lj jw lk ll lm ka ln lo lp lq bi translated">动词 （verb的缩写）参数如何传递给函数，这对可变和不可变对象意味着什么</h2><p id="205d" class="pw-post-body-paragraph jj jk hi jl b jm lt ij jo jp lu im jr js mh ju jv jw mi jy jz ka mj kc kd ke hb bi translated">在这一部分中，我们将看到每当我们对别名(分配给对象的标签)进行更改时，对象的可变性质是如何影响原始对象的:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="b6a8" class="kw kx hi ml b fi mp mq l mr ms">&gt;&gt;&gt; list_1 = [1, 2, 3]<br/>&gt;&gt;&gt; list_2 = list_1<br/>&gt;&gt;&gt; list_2.pop(list_2[0])<br/>&gt;&gt;&gt; list_1<br/>[2, 3]</span></pre><p id="ba29" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">方法pop(本例中是类list的函数)能够对原始对象list_1进行更改，这是因为我们将一个位置地址传递给了函数pop()，这是list_1所在的位置，因此更改将发生在第一个list及其所有别名上，因为它们实际上只是指向它。</p><p id="69f0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">另一方面，不可变对象如果赋给另一个变量，将永远不会改变，因为与可变对象相反，这里我们处理的是原始对象的副本，因此是一个完全不同的内存位置，传递给函数Python将创建一个相同值的新对象，并对其进行更改。</p></div></div>    
</body>
</html>