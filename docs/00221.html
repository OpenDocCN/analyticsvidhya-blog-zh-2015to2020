<html>
<head>
<title>Implementing the Particle Swarm Optimization (PSO) Algorithm in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现粒子群优化算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/implementing-particle-swarm-optimization-pso-algorithm-in-python-9efc2eb179a6?source=collection_archive---------0-----------------------#2018-12-24">https://medium.com/analytics-vidhya/implementing-particle-swarm-optimization-pso-algorithm-in-python-9efc2eb179a6?source=collection_archive---------0-----------------------#2018-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d5cb85e697fda634a4a8f2b05734a40e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HqmkZNappDjjbUvG"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@johnnyafrica?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">陈焕昌</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="11d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">人工智能有很多定义。根据<a class="ae iu" href="https://www.merriam-webster.com/dictionary/artificial%20intelligence" rel="noopener ugc nofollow" target="_blank">韦氏词典</a>的说法，人工智能是计算机科学的一个大领域，它在计算机中模拟智能行为。基于此，一种基于<a class="ae iu" href="https://en.wikipedia.org/wiki/Metaheuristic" rel="noopener ugc nofollow" target="_blank">元启发式</a>的算法实现被称为<strong class="ix hj">粒子群优化</strong>(最初是为了模拟鸟类寻找食物、鱼群移动等而提出的。)能够模拟群体的行为，以便迭代地优化数值问题。例如，它可以被分类为像蚁群算法、人工蜂群算法和细菌觅食一样的群体智能算法。</p><p id="a447" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由J. Kennedy an R.Eberhart在1995年提出的文章“粒子群优化”变得非常流行，因为他的持续优化过程允许多目标和更多的变化。该方法在于不断搜索最佳解，在每次迭代中以计算出的一定速度移动粒子(在这种情况下表示为(x，y)位置)。每个粒子的运动都有他自己的最佳已知位置的影响，也是空间搜索中的最佳已知位置。预期的最终结果是粒子群收敛到最优解。值得一提的是，PSO不使用梯度下降，所以一旦它不要求问题必须是可微的，它就可以用于非线性问题。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="e706" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">算法</h1><p id="7e67" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">让我们观察伪算法:</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/e56ff16f80107055d01b2d21d9bdec4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLmYH2QiwttYcjUMhvKWcA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">上传者<a class="ae iu" href="https://www.researchgate.net/profile/Ganesh_Venayagamoorthy" rel="noopener ugc nofollow" target="_blank">加内什·k·维纳亚加莫瑞</a></figcaption></figure><p id="56e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，在2 for循环中，它在所有维度的允许范围内用随机均匀分布初始化粒子的位置(有些问题需要处理到几个维度)。之后，对于每个粒子，它计算其适应值并与他自己的最佳位置进行比较(p_best值是该特定粒子曾经的最佳位置)然后它选择g_best中所有粒子的最佳位置。</p><p id="4c7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们仔细看看定义粒子维度下一次迭代速度的方程:</p><ul class=""><li id="7779" class="li lj hi ix b iy iz jc jd jg lk jk ll jo lm js ln lo lp lq bi translated">Vᵢ(k+1)是下一个迭代速度</li><li id="0d67" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js ln lo lp lq bi translated">w是惯性参数。此参数影响由最后一个速度值给出的运动传播。</li><li id="7266" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js ln lo lp lq bi translated">C₁和C₂是加速度系数。C₁价值强调个人最佳价值，C₂强调社会最佳价值。</li><li id="6715" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js ln lo lp lq bi translated">Pᵢ是最佳个人位置，Pg是所有粒子的最佳位置。在该方程中，测量了这些参数中的每一个到粒子实际位置的距离。</li><li id="327a" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js ln lo lp lq bi translated">rand₁和rand₂是随机数，其中0 ≤ rand ≤ 1，它们控制每个值的影响:社会和个人，如下所示。</li></ul><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/ac517f83d52ee8bcfae57cfd0ea2e9d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1DFdUEBX3vVeuZVpM11fA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">谷歌图片</figcaption></figure><p id="e11a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，计算新粒子的位置，直到指定的迭代次数或达到误差标准。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="e76b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">履行</h1><p id="ab4b" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们的目标是找到某个函数的极小点。在这种情况下，函数是<em class="lx"> f(x，y) = x + y + 1。</em>因此，该算法将与二维位置数组一起工作，并且适合度值将是Z坐标。同样，我们知道我们的目标是找到坐标[0，0]，它是<em class="lx"> f(x，y)的最小值。</em></p><p id="73d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了用python实现该算法，使用了OOP(在这一点上，它被认为是你知道它的基础)来帮助我们实现和理解代码中的所有步骤。在这里，它使用numpy库(查看更多信息<a class="ae iu" href="http://www.numpy.org/" rel="noopener ugc nofollow" target="_blank">这里</a>)来处理数组操作，一旦我们与多维空间合作。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/1bdb56934e4d62c997b3dc2917076cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/0*MiPvsl6sCX6ovLYX"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">x +y的3D图形(Wolframalpha)</figcaption></figure><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/3e7af74a605ceee324476af1bb1c505a.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/0*5tPBP48U0oD3-yps"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">x + y的等高线图(Wolframalpha)</figcaption></figure><p id="ce2b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从粒子课开始。</p><h2 id="16a9" class="lz kb hi bd kc ma mb mc kg md me mf kk jg mg mh ko jk mi mj ks jo mk ml kw mm bi translated">颗粒</h2><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/be0875eda99d6504d1a2b49cb02f69c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfEcPy7wT4RSuwKgNonZJw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">粒子类别</figcaption></figure><p id="015c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当一个粒子自动启动时，我们对2个位置进行排序，限制在-50到+50的范围内。<strong class="ix hj"> pbest_position </strong>(该粒子的最佳个体位置)以初始位置开始，同样，当我们寻找最小值时，<strong class="ix hj"> pbest_value </strong>以+inf(可以是任何更大的值)开始。它还定义了一个方法<strong class="ix hj"> __str__ </strong>()来打印实际位置和最佳的单个值。<strong class="ix hj"> move </strong>()方法添加了位置向量和在搜索中计算的尺寸速度，我们将在前面看到。</p><h2 id="c8b3" class="lz kb hi bd kc ma mb mc kg md me mf kk jg mg mh ko jk mi mj ks jo mk ml kw mm bi translated">搜索空间</h2><p id="cba9" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">搜索空间是控制算法程序的实体。在该实现中，它负责保持所有粒子，识别和设置所有粒子的个体最佳位置值，管理目标误差标准，计算最佳全局值和设置最佳全局位置。在简历中，它包含了所有主要步骤。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/fe30f31575c14ba1bacec1e37a9d8c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkSgOAkKudNugNxEyjgMGA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">空间状态类</figcaption></figure><p id="767f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">方法<strong class="ix hj"> set_pbset </strong>和<strong class="ix hj"> set_gbest </strong>有相似的实现方式。首先，它遍历所有粒子，计算粒子位置的适应值，并与最佳个体位置(在<strong class="ix hj"> set_pbest </strong>处)和最佳全局位置(在<strong class="ix hj"> set_gbest </strong>处)进行比较。</p><p id="e65c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">方法move_particles计算每个维度中每个粒子的新矢量速度，如前所述。</p><h2 id="8c51" class="lz kb hi bd kc ma mb mc kg md me mf kk jg mg mh ko jk mi mj ks jo mk ml kw mm bi translated">主循环</h2><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/2e8f4a019e07151caa8bf0a2e37d8b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tEUpf7OjYrpejbzEYOENYw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">主循环</figcaption></figure><p id="5dcc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，它启动了一个目标为1的搜索空间。该目标代表目标的适应值，这意味着目标是<em class="lx"> f(x，y) = 1 </em>。然后，该算法将找到<em class="lx"> x </em>和<em class="lx"> y </em>的哪个值给出等于1的结果，如之前在我们想要找到最小值的函数形状处所示。等高线图也告诉我们，我们要找出的值是[0，0]。目标误差和粒子数(n_particles)将由用户设置。然后用一个列表生成器启动所有的粒子，然后开始迭代。</p><p id="9581" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在所有迭代中，首先找到最佳个体位置和最佳全局位置来评估目标误差准则。如果这个标准没有达到最小误差，粒子将计算移动的速度，然后在新的位置停止，直到达到迭代次数或最小误差标准。最后一行只是打印出找到的最佳结果。</p><p id="16dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查看下面的完整代码</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="a724" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">w、C₁和C₂的值是手动选择的，所以要小心使用，因为它们可能会变得更长。</p><h1 id="b6b4" class="ka kb hi bd kc kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx bi translated">结果</h1><p id="3aa5" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">使用python解释器，我们输入迭代次数的值、目标误差标准和进入群体的粒子数。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/037cdd9ccd430dd7add23f66c09f4775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*YYwWiBsHg7KKg72JITAX2A.png"/></div></figure><p id="d059" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，它打印出找到的最佳结果:</p><pre class="le lf lg lh fd my mz na nb aw nc bi"><span id="1f08" class="lz kb hi mz b fi nd ne l nf ng">The best solution is: [ 5.06237850e-04 -1.14851873e-05] in n_iterations: 22</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="9897" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个易于实现和使用的算法。希望你们都喜欢！</p><p id="6940" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">任何批评，提示或暗示也将受到欢迎:)</p></div></div>    
</body>
</html>