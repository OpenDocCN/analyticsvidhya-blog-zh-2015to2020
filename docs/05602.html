<html>
<head>
<title>Delegates in C#- Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的委托-第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/delegates-in-c-part-1-3c577a7a5c52?source=collection_archive---------30-----------------------#2020-04-26">https://medium.com/analytics-vidhya/delegates-in-c-part-1-3c577a7a5c52?source=collection_archive---------30-----------------------#2020-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f9ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">带示例的代表初学者指南</p><h2 id="9088" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">委托-(名称空间:系统。代表)</strong></h2><p id="31d7" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated"><strong class="ih hj">定义:</strong>委托是一种类型，它安全地<strong class="ih hj">封装了</strong>一个方法，类似于C和C++中的函数指针。与函数指针不同，委托是<strong class="ih hj">面向对象的</strong>、<strong class="ih hj">类型安全的</strong>和<strong class="ih hj">安全的</strong>。委托的类型由委托的名称定义。</p><p id="df7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(以上定义来自<strong class="ih hj"> MSDN </strong>。)</p><p id="f2da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运筹学</p><p id="9e1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">委托是一种引用类型，它保存对<strong class="ih hj">方法</strong>或<strong class="ih hj">方法</strong>的组的引用</p><p id="dcfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于初学者来说，这些术语中的一些可能很陌生，人们可能会有几个问题:</p><p id="993d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题1-如何声明和实例化一个委托？</p><p id="ab6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题2——如何将方法与它联系起来？</p><p id="e69c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题3——在现实世界中，这些委托用在哪里？我是否有意或无意地遇到过它们？</p><p id="e9ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回到前两个问题:</p><h2 id="9503" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">问题1——如何声明和实例化一个委托？</h2><h2 id="868e" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">问题2——如何将方法与它联系起来？</h2><p id="7cf7" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated"><em class="kd">语法:委托&lt;返回类型&gt; &lt;委托名称&gt; &lt;参数表&gt; </em></p><p id="2b4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">声明</strong> <em class="kd"> :-公共委托int my delegate(string s)；</em></p><p id="66cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">"<strong class="ih hj"> MyDelegate </strong>"这是一个接受字符串作为参数并返回整数的委托。委托和它希望引用的方法必须有<strong class="ih hj">相同的签名</strong>。</p><h2 id="114e" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">实例化一个委托&amp;将一个或多个方法关联到它。</h2><p id="5e72" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">使用<strong class="ih hj"> new </strong>关键字实例化一个委托，并将其与一个方法相关联。</p><p id="6f1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:<strong class="ih hj"> <em class="kd">公共委托int NumberTailor(int x，int y)</em></strong><em class="kd">；</em></p><p id="9edd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们是这样实例化它的:</p><p id="ef3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="kd">var delegate 1 = new number tailor(delegate helpers。add numbers)；</em>T45】</strong></p><p id="e85d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="kd">var delegate 2 = new number tailor(delegate helpers。多乘数)；</em>T49】</strong></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ke"><img src="../Images/e3e1b79c644ce7ec968084f19fa45179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*Fmslj1ddXMHNlpOuFlcqog.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">函数和委托签名应该相同。</figcaption></figure><p id="514a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们调用这些方法:</p><p id="81d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kd">控制台。WriteLine(delegate1(10，29))；</em>T53】</strong></p><p id="7385" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">控制台<em class="kd">。WriteLine(delegate 2(252500))；</em>T57】</strong></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ke"><img src="../Images/ad87f8f8179bc8c837c0dc209532c646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*a6dNJWFDDVcTYd_0QS2cxQ.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">通过委托调用方法及其输出。</figcaption></figure><p id="2ef8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如前面在声明部分提到的，委托可以用来调用任何与其签名匹配的方法，但是，函数必须严格遵守其签名，否则它会抛出编译错误(后面显示的例子)。</p><h2 id="e6d0" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">组播代理</strong></h2><p id="2254" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">我们现在来看一个例子，在这个例子中，我们可以向委托添加对多个方法的引用。</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="28fe" class="jd je hi kr b fi kv kw l kx ky">class DelegateHelpers</span><span id="82f6" class="jd je hi kr b fi kz kw l kx ky">{</span><span id="64e1" class="jd je hi kr b fi kz kw l kx ky">public static string TamperWithEvidence(string evidence)</span><span id="d133" class="jd je hi kr b fi kz kw l kx ky">{</span><span id="2023" class="jd je hi kr b fi kz kw l kx ky">var tamperedEvidence = string.Empty;</span><span id="67c4" class="jd je hi kr b fi kz kw l kx ky">if (evidence.ToLower().Contains(“evidence”))</span><span id="0ce9" class="jd je hi kr b fi kz kw l kx ky">{</span><span id="39d8" class="jd je hi kr b fi kz kw l kx ky">tamperedEvidence = evidence.Replace(“evidence”, “***d****”);</span><span id="71a3" class="jd je hi kr b fi kz kw l kx ky">}</span><span id="bc4c" class="jd je hi kr b fi kz kw l kx ky">return tamperedEvidence;</span><span id="f656" class="jd je hi kr b fi kz kw l kx ky">}</span><span id="8a72" class="jd je hi kr b fi kz kw l kx ky">public static string DoNotTamperWithEvidence(string evidence)</span><span id="974c" class="jd je hi kr b fi kz kw l kx ky">{</span><span id="bd6c" class="jd je hi kr b fi kz kw l kx ky">return string.Empty;</span><span id="5030" class="jd je hi kr b fi kz kw l kx ky">}</span><span id="be2a" class="jd je hi kr b fi kz kw l kx ky">}</span></pre><p id="9204" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码是我们将通过委托引用的两个方法中的一个。注意这里，<strong class="ih hj">donottamperwitheevidence(string)</strong>方法总是返回一个空字符串，而<strong class="ih hj">tamperwitheevidence(string)</strong>则返回一个被篡改的证据字符串。</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="fd8b" class="jd je hi kr b fi kv kw l kx ky">class Program</span><span id="0cd2" class="jd je hi kr b fi kz kw l kx ky">{</span><span id="f896" class="jd je hi kr b fi kz kw l kx ky">public delegate string StringTailor(string str);</span><span id="6102" class="jd je hi kr b fi kz kw l kx ky">static void Main(string[] args)</span><span id="8099" class="jd je hi kr b fi kz kw l kx ky">{</span><span id="ee7c" class="jd je hi kr b fi kz kw l kx ky">var stringTailor = new StringTailor(DelegateHelpers.TamperWithEvidence);</span><span id="0764" class="jd je hi kr b fi kz kw l kx ky">//stringTailor += DelegateHelpers.DoNotTamperWithEvidence;</span><span id="08e5" class="jd je hi kr b fi kz kw l kx ky">var oldString = “The was evidence against him.”;</span><span id="89d1" class="jd je hi kr b fi kz kw l kx ky">var newString = stringTailor(oldString);</span><span id="a6f6" class="jd je hi kr b fi kz kw l kx ky">Console.WriteLine(“old string = “ + oldString</span><span id="8de8" class="jd je hi kr b fi kz kw l kx ky">+ “\nnew string = “ + newString</span><span id="0b4a" class="jd je hi kr b fi kz kw l kx ky">);</span><span id="8043" class="jd je hi kr b fi kz kw l kx ky">}</span><span id="018a" class="jd je hi kr b fi kz kw l kx ky">}</span></pre><p id="f8db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码是我们的主要方法，其中我们通过委托调用我们的方法。这里需要注意的一点是，我们已经用<strong class="ih hj">注释掉了向委托</strong>添加新方法引用的那一行。让我们看看同样的输出。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es la"><img src="../Images/ed50b5c210bc974d3ce846b4d108c095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*pybBvLkAL_ZRz8dIYyIYgA.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">没有多播委托的输出。</figcaption></figure><p id="add3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">可以使用“+=”将多个方法分配给一个委托，</strong>让我们通过查看同一个示例来理解流程，只是我们取消了“+=”的注释。</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="7ea5" class="jd je hi kr b fi kv kw l kx ky">class Program</span><span id="b232" class="jd je hi kr b fi kz kw l kx ky">{</span><span id="bbcf" class="jd je hi kr b fi kz kw l kx ky">public delegate string StringTailor(string str);</span><span id="ffe5" class="jd je hi kr b fi kz kw l kx ky">static void Main(string[] args)</span><span id="8fdd" class="jd je hi kr b fi kz kw l kx ky">{</span><span id="88ce" class="jd je hi kr b fi kz kw l kx ky">var stringTailor = new StringTailor(DelegateHelpers.TamperWithEvidence);</span><span id="8829" class="jd je hi kr b fi kz kw l kx ky">stringTailor += DelegateHelpers.DoNotTamperWithEvidence;</span><span id="3503" class="jd je hi kr b fi kz kw l kx ky">var oldString = “The was evidence against him.”;</span><span id="d67e" class="jd je hi kr b fi kz kw l kx ky">var newString = stringTailor(oldString);</span><span id="1c9b" class="jd je hi kr b fi kz kw l kx ky">Console.WriteLine(“old string = “ + oldString</span><span id="c80e" class="jd je hi kr b fi kz kw l kx ky">+ “\nnew string = “ + newString</span><span id="d8cd" class="jd je hi kr b fi kz kw l kx ky">);</span><span id="5b90" class="jd je hi kr b fi kz kw l kx ky">}</span><span id="1ac4" class="jd je hi kr b fi kz kw l kx ky">}</span></pre><p id="650d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们已经取消了对行<strong class="ih hj">“string tailor+= delegate helpers”的注释。请勿篡改证据，</strong>并且由于该方法的引用是最后添加到委托中的，因此它将最后执行，这意味着我们应该总是得到作为<strong class="ih hj"> sting的输出。空的</strong>，因为委托<strong class="ih hj">遍历了</strong>所有被引用的方法。</p><p id="8468" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出:</strong></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lb"><img src="../Images/3373b9e85577665f15b82ea417ea96bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*6otYG_7yrTin6XYsU0cWhA.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">返回单个值和解释的多播委托的输出。</figcaption></figure><h2 id="ec9d" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">将委托作为参数发送:</strong></h2><p id="7bfd" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">设置类是我们打印相机设置的类。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lc"><img src="../Images/e74401baa06fd512b05b45202616070d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*U8tbghakETccFaeBoj6ECA.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">设置类。</figcaption></figure><p id="3cb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Camera </strong>是接受委托然后调用设置类的类。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ld"><img src="../Images/d7c409213628d4771840b24d4c8876eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*23hMMkVq8dHD2mqJRnKMpQ.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">委托的相机类。</figcaption></figure><p id="facf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意我们是如何在这里声明委托的，以及我们是如何将委托作为动作<setting>传递的，其中设置是一个类。</setting></p><p id="49eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在Main()中调用Camera。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/ad3b276f333accae93992758c16ca4e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*7aiKeY9CeHNappG6kiO3Sw.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">委托动作<setting>的主要方法和传递。</setting></figcaption></figure><p id="0d48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们在这里只添加了设置类的三个方法的引用，结果可以在下面的输出中看到:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lj"><img src="../Images/d4ef3ff72a41d25599122c80fad3a475.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*Spzu5tgJeVrBDFqZHGJg6A.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">输出仅显示添加到操作项的方法。</figcaption></figure><p id="b555" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意<strong class="ih hj">只有三个方法</strong>被<strong class="ih hj">调用</strong>，这三个方法被我们明确地<strong class="ih hj">添加了</strong><strong class="ih hj">引用</strong>到我们的<strong class="ih hj"> ActionHandler </strong>。AutoISO()被调用，因为我们没有将它添加到操作项中。</p><h2 id="a255" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">代表的属性</strong></h2><p id="5300" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">1-代理允许<strong class="ih hj">方法</strong>作为<strong class="ih hj">参数</strong>被<strong class="ih hj">传递。</strong></p><p id="3342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2-委托类似于函数指针，只是它们是<strong class="ih hj">类型安全的</strong></p><p id="7df5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">类型安全:</strong>如果我们试图传递一个方法给不<strong class="ih hj">“匹配模式”的委托，</strong>我们将收到一个编译时错误<strong class="ih hj">“方法不匹配委托模式！</strong><em class="kd"/>。这里，模式意味着参数的类型和数量</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lk"><img src="../Images/5a21bf26ff8969a980a35486ceb0a7bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adx2LjqTd857MK68pn8tcA.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jf">当<strong class="bd jf">委托</strong>的<strong class="bd jf">签名</strong>与<strong class="bd jf">方法</strong>的<strong class="bd jf">不一致</strong>时，出现错误</strong>消息。</figcaption></figure><p id="a3ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3-委托可用于定义<strong class="ih hj">回调方法</strong>。</p><p id="5552" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">回调方法/函数:</strong>一个<strong class="ih hj">回调</strong>是当一个进程完成执行一个特定任务时被调用的函数。回调在异步逻辑中使用。要创建一个回调，你需要<strong class="ih hj">在一个变量中存储</strong>一个函数地址，这是使用<strong class="ih hj">委托</strong>或新的lambda语义<strong class="ih hj"> Func &lt; &gt;或Action实现的。</strong></p><p id="2e5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4- <strong class="ih hj">事件</strong> <strong class="ih hj">处理</strong>是使用委托完成的。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ll"><img src="../Images/521ac195ce0d7258275b0edc5e12e76b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*becfQjI9ytHMw_2jysm6rw.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">WPF应用程序上单击事件的事件处理程序，将该事件分配给<strong class="bd jf"> btnNew_Click()。</strong></figcaption></figure><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lm"><img src="../Images/7357bda35bbeb8ab736d88ae3186198c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*C_frIcvnfYuMKGnaV1dHIw.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jf"> RoutedEventHandler </strong>是来自C#的基本<strong class="bd jf">路由事件处理程序</strong>委托。</figcaption></figure><p id="5d0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的例子是<strong class="ih hj">隐式</strong>使用Visual Studio 2017或更高版本创建事件时完成的。这是对问题3的回答，既是现实世界中委托的应用，也是我们在不知不觉中遇到它们的地方。</p><p id="37e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ln lo lp kr b">var delegate2 = new NumberTailor(DelegateHelpers.MultiplyNumbers);</code></p></div></div>    
</body>
</html>