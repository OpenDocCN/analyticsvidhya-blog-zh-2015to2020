<html>
<head>
<title>Insight on GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于GraphQL的见解</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/graphql-a-quick-look-a8ab0c03105?source=collection_archive---------37-----------------------#2020-05-07">https://medium.com/analytics-vidhya/graphql-a-quick-look-a8ab0c03105?source=collection_archive---------37-----------------------#2020-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a11af249b688c8486fae1b1bec3fb8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZm8vP6dwaPVdYESHEAwEA.png"/></div></div></figure><p id="417c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GraphQL是一种用于API的查询语言，它还提供了一个运行时来用可用的数据完成这些查询。2012年，脸书在寻找一种数据获取API，它足够强大，可以描述整个脸书，同时又足够简单，便于产品开发人员学习，这导致了这种新语法的创新。简单地说，它的目的是将数据从服务器加载到客户端。</p><p id="f5ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但它以一种更高效、更灵活的方式来实现。</p><p id="37bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它将确认正在加载的数据是相关且必要的。以脸书和Facebook Messenger应用程序为例。通过只获取他们需要的信息，他们保留了可能被更大的有效载荷占用的带宽。与REST API调用的整个JSON负载相比，这可以用于只需要更新应用程序UI的某些部分来提高整体速度的情况。</p><p id="865f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">graphql的格式是，它是一个发送到服务器的字符串，将作为JSON返回。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/e97abf9bc4f64d2e9fa54c89560c38a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*k8rM7NjfKoz8IfBD3D6Hsg.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">左边是查询，右边是响应。</figcaption></figure><h2 id="c2ef" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated"><strong class="ak">graph QL的优势</strong></h2><p id="5ff2" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">GraphQL相对于REST的一个突出优势是，当REST在多个回合中获取资源时，GraphQL可以通过一个请求来完成。本质上，请求就像一个复用的休止符。因此它避免了获取更多的数据，也防止了多个API调用，如下所示。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/410118efa8cd777e6b54f45a5863fe6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*99DMbmXTG4ZfFmBBwCy2yA.png"/></div></figure><p id="87fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GraphQL的分层性质遵循对象之间的关系，其中RESTful服务可能需要多次往返或复杂的SQL join语句。这种数据层次结构与图形结构的数据存储和层次化的用户界面很好地结合在一起。</p><p id="9d0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GraphQL查询的每一级将匹配特定的类型，并且每种类型将描述一组可用的字段，这些字段将在执行查询之前提供描述性的错误消息。</p><p id="4a9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您想要获取更多数据并避免多次调用时，您将需要创建另一个API，可能需要从后端开发人员那里请求它。但是有了GraphQL你就可以独立工作了。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h2 id="c383" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated"><strong class="ak"> GraphQL vs REST </strong></h2><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/3baf20f9529b126c8cd46ccae8021b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bA6HmvAQVXQhwd7EJoMl4w.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">REST如何要求您基于ID获取用户详细信息和用户的位置详细信息</figcaption></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/1883920e5684f82a3f3f47a5b0b5ac57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anXXzIcD0sdyT7G1_TksIg.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">在GraphQL中，所有这些都包含在一个请求中</figcaption></figure><p id="126a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了从GraphQL API中获取初始资源，与REST非常相似:即:你传递一个名字和一些参数。但是与使用多个URL获取数据的REST不同，GraphQL使用对单个URL端点的特别查询，该端点根据查询返回数据。</p><p id="b60e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以使用“POST”查询来定义你想要的数据，而不是GET。</p><p id="2a7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在一个单一的镜头中，您以“图形”格式获取相关数据，如上图所示。</p><p id="88aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您在POST请求中发送数据的查询有一个结构和语法，即GraphQL。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/005387f359b1cfe7a336dc70fb4b8f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4tu3-iKkJQ3xk_Ps-c5TtA.png"/></div></div></figure></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><p id="c5f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参考文献</strong></p><div class="lh li ez fb lj lk"><a href="https://www.apollographql.com/blog/graphql-vs-rest-5d425123e34b" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">GraphQL与REST</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">通常，GraphQL被认为是思考API的一种革命性的新方法。而不是与僵化的…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">www.apollographql.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly io lk"/></div></div></a></div><p id="ad05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lz" href="https://hasura.io/learn/graphql/react/intro-to-graphql/" rel="noopener ugc nofollow" target="_blank">https://hasura.io/learn/graphql/react/intro-to-graphql/</a></p><p id="1763" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">【https://smartbear.com/blog/design/what-is-graphql/ T2】号</p></div></div>    
</body>
</html>