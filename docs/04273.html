<html>
<head>
<title>Searching and Analyzing the COVID19 Genome</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">搜索和分析COVID19基因组</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/searching-and-analyzing-the-covid19-genome-4439bb38cd88?source=collection_archive---------14-----------------------#2020-03-12">https://medium.com/analytics-vidhya/searching-and-analyzing-the-covid19-genome-4439bb38cd88?source=collection_archive---------14-----------------------#2020-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/0a4074add6f261f5d7aaa26965718cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*1YPhYuMnD431434FM4vqgw.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">技术网络的信用</figcaption></figure><p id="76fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着病例和死亡人数的持续上升，问题仍然存在，冠状病毒到底是什么？有许多不同类型的冠状病毒。有些接近无害，而有些甚至比新冠肺炎更致命。但是，这并没有告诉我们是什么让这种病毒与众不同。它感染的人数是SARS的10倍以上，杀死的人数是它的几倍。然而，没有人知道是什么赋予了这种病毒如此强大的传染能力。</p><p id="0c75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是我们知道的是它的基因组序列。<code class="du jp jq jr js b">nCoV2019</code>是一种RNA病毒。然而，来自中国北京中国疾病预防控制中心的研究人员发表了冠状病毒的反转录DNA基因组序列。<code class="du jp jq jr js b">nCoV2019</code>的基因组大约有29000个碱基对长。比人类或老鼠这样的复杂生物要短得多。然而，仍然有足够的力量感染全世界成千上万的人。</p><h1 id="8e9f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">脱氧核糖核酸</h1><p id="cca6" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">在我们开始查看从中国武汉患者身上收获的冠状病毒基因组之前，让我们先了解一下什么是DNA。脱氧核糖核酸(DNA)是由4种不同类型的碱基组成的双链梯形结构。它们是胸腺嘧啶、腺嘌呤、鸟嘌呤和胞嘧啶。在排序上，更常见的分别写成<code class="du jp jq jr js b">T</code>、<code class="du jp jq jr js b">A</code>、<code class="du jp jq jr js b">G</code>、<code class="du jp jq jr js b">C</code>。DNA序列表示为有限的碱基序列，按照它们在实际DNA中出现的顺序排列。在编程语言中，DNA序列可以表示为仅包含四个可能字符的字符串，<code class="du jp jq jr js b">'T', 'A', 'G', 'C'</code>。</p><p id="adaf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">理论上，以下可以代表一串DNA:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="30e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<code class="du jp jq jr js b">char</code>类型来表示DNA碱基有一些挑战。首先，<code class="du jp jq jr js b">char</code>可以是<code class="du jp jq jr js b">-128</code>和<code class="du jp jq jr js b">127</code>之间的任何值。基因组分析肯定不需要负值，我们只需要四个值来代表四个可能的碱基。第二，使用一个<code class="du jp jq jr js b">const char*</code>文字强制每个基数用它的<code class="du jp jq jr js b">ASCII</code>值来表示。这个值不符合顺序，比如<code class="du jp jq jr js b">'A'</code>是65，而<code class="du jp jq jr js b">'G'</code>是71。这防止碱基被用作<em class="jo">索引</em>，因为它们彼此不相邻。</p><p id="4244" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，处理机器字大小的数据比处理比机器字更小的数据更有效。例如，在大多数C/C++编译器上，小于机器字大小的结构中的字段将被填充:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="b884" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，C字符串以一个空字符<code class="du jp jq jr js b">'\0'</code>结束。对于DNA来说，这是无效的，因为<code class="du jp jq jr js b">0</code>是一个有效的DNA序列成员。单个整数不能终止DNA序列，</p><h1 id="4b1c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">类型</h1><p id="47c6" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated"><em class="jo">本文中的代码可以在</em> <a class="ae jt" href="https://github.com/jweinst1/ncov2019-analyzer" rel="noopener ugc nofollow" target="_blank"> <em class="jo">这个资源库</em> </a>中找到</p><p id="8e88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了克服<code class="du jp jq jr js b">char</code>类型的缺点，可以使用包装在<code class="du jp jq jr js b">struct</code>中的枚举类型，用一个案例代表每个基数:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="39cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给定这种类型，DNA序列可以通过以下方式构建:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="59c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，为了有效地迭代和搜索DNA序列，我们需要适当的方法将文本数据转换成DNA，以及封装<code class="du jp jq jr js b">DNA::Base*</code>的数据结构。</p><h1 id="555d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">转换</h1><p id="4e9c" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">接下来，我们需要一种方法将DNA文本数据转换成<code class="du jp jq jr js b">DNA::Base</code>类型。假设DNA数据是UTF-8或ASCII编码的，如下函数可以工作:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="1731" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法假设DNA数据可以是大写或小写。大多数<code class="du jp jq jr js b">C++</code>编译器会从包含5个或更多案例的switch语句中生成一个跳转表。因此，将<code class="du jp jq jr js b">const char*</code>数据转换为<code class="du jp jq jr js b">const DNA::Base*</code>数据的复杂度应该只与文本数据的长度成线性关系。这个新构建的DNA序列可以像搜索字符串一样进行迭代和搜索，除了在任何索引处只有四个可能的值。为了更直接，我们需要能够封装DNA的数据结构。</p><h1 id="8ba1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">容器</h1><p id="26a5" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">可用于保存dna的最简单的dna数据结构是一个<em class="jo">片</em>。片是一个具有静态大小的对象，拥有一块写入了<code class="du jp jq jr js b">Base::DNA</code>的内存。切片可以表示为:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="c7f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的方法中，要么可以构造一个空的<em class="jo"/><code class="du jp jq jr js b">DNASlice</code>，要么可以从C字符串中构造一个切片。空白切片可能有助于表示正在运行的DNA搜索中缺少匹配。<code class="du jp jq jr js b">DNA::fromCStr()</code>函数在这里被<code class="du jp jq jr js b">const char*</code>构造函数重用。即使DNA数据现在可以被封装，我们也无法将其可视化。为此，需要一种定制的打印方法来处理<code class="du jp jq jr js b">DNA::Base*</code>内存。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="6ce3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述实现通过在<code class="du jp jq jr js b">dna1</code>的任何开始位置检测<code class="du jp jq jr js b">dna2</code>的匹配来工作。它别名<code class="du jp jq jr js b">dna2</code>到<code class="du jp jq jr js b">matcher</code>，这允许<code class="du jp jq jr js b">matcher</code>在只找到部分匹配的情况下被复位。在任何迭代之前，我们知道如果<code class="du jp jq jr js b">size2 &gt; size1</code>为真，那么<code class="du jp jq jr js b">dna2</code>不可能包含在<code class="du jp jq jr js b">dna1</code>中。</p><p id="2f12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">布尔变量:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="ad52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用于确定函数何时处于匹配的<em class="jo">状态</em>以及何时处于初始<em class="jo">状态</em>，仍在寻找匹配的第一个碱基。如果在初始状态，我们只有找到第一个碱基才能过渡到匹配状态。现在，在匹配状态下，以下条件适用:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="fe7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要么我们匹配<code class="du jp jq jr js b">dna2</code>的最后一个碱基，从而找到一个<em class="jo">完全</em>匹配，然后进一步进行完全匹配，要么我们在到达终点之前未能匹配一个碱基，导致匹配状态重置。</p><h1 id="b733" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">搜索</h1><p id="d3fd" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">既然已经讨论和演示了DNA的转换、迭代和封装，我们可以展示如何搜索DNA。以前，使用FSA显示为一种线性搜索特定DNA亚序列的方法。这种方法是有用的，因为它可以计算在一个更大的序列中一些DNA亚序列的多次出现。然而，它缺乏能够扫描和识别许多许多DNA序列的性能。</p><p id="5865" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一种更有效的方法是使用专门针对dna的trie结构。通常，尽管trie具有非常快的查找时间，但是它的缺点是由于需要的每个节点的数量和大小而使用大量的内存。通常，trie节点可能如下所示。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="c3bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，节点有128个子节点槽，因为C中的<code class="du jp jq jr js b">char</code>类型的最大值通常是<em class="jo">127。然而，这可能会因在<code class="du jp jq jr js b">&lt;limits.h&gt;</code>中定义的<code class="du jp jq jr js b">SCHAR_MAX</code>的值而有所不同。就空间复杂性而言，使用这样定义的节点的trie将占用大量内存，并插入相当数量的键。一般来说，trie使用的空间和内存与其键中支持的字符范围相关。</em></p><h2 id="5364" class="ld jv hi bd jw le lf lg ka lh li lj ke jb lk ll ki jf lm ln km jj lo lp kq lq bi translated">DNA测试</h2><p id="0e4a" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">就DNA而言，只有4种可能的字符！<code class="du jp jq jr js b">A, G, C, T</code>。因此，DNA trie节点看起来像这样。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="aa12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于DNA序列中任何给定位置的任何给定碱基，下一个碱基只有四个可能的值。因此，这个原则可以用来使一个<code class="du jp jq jr js b">DNA::Base</code>函数作为一个<code class="du jp jq jr js b">DNANode</code>的子节点中的索引。然后可以像下面这样访问子节点</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="5e7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果一个节点只需要大约32-40字节，这使得它比覆盖整个有符号范围的节点更有空间效率。接下来，我们可以选择trie将用它的键映射哪些属性和值。搜索DNA时有三种重要的数据类型。一个是存在性，比如dna的一个子序列是否包含在一个更大的序列中。另一个是计算某个子序列出现的次数。最后，可以在DNA中搜索子序列出现最多的区域。</p><p id="40a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">核心trie类如下所示:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="9b30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了插入到trie中，我们需要递归遍历trie，并为trie中尚不存在的任何基路径创建新节点。一旦到达输入DNA的末尾，节点的计数就增加1。可以选择将输入的DNA视为嵌套序列，并对其中包含的所有子序列进行计数。使得如果输入是<code class="du jp jq jr js b">ACCG</code>，我们将增加<code class="du jp jq jr js b">A</code>、<code class="du jp jq jr js b">AC</code>、<code class="du jp jq jr js b">ACC</code>，而不仅仅是<code class="du jp jq jr js b">ACCG</code>。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="9421" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，trie必须能够查找与插入到trie中的每个DNA序列相关的计数。方法类似于<code class="du jp jq jr js b">insert</code>，但是返回一个<code class="du jp jq jr js b">long</code>:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="70db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果<code class="du jp jq jr js b">find</code>返回<code class="du jp jq jr js b">-1</code>，这意味着DNA序列不存在于trie中。如果它返回<code class="du jp jq jr js b">0</code>，这意味着序列确实存在于trie中，但是没有被插入超过一次。后续返回值指示在trie中跟踪的序列的计数。尽管可以直接使用<code class="du jp jq jr js b">TrieNode</code>,但是将它包装在另一个类中更有效，该类管理一个根节点，所有传入的插入和查找都被路由到这个根节点。这样的类看起来可能是这样的:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="25aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的类中，<code class="du jp jq jr js b">_count</code>跟踪插入到trie中的序列的数量，但不是唯一的序列。否则，就没有快速计算字符串数量的方法。<code class="du jp jq jr js b">&lt;&lt;</code>操作符用于插入，使类感觉类似于流类。目的是让trie能够插入大量的DNA块。</p><p id="7716" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">DNA Trie最适合于人们正在寻找的重要序列已知的情况。这样，不同的DNA片段可以进入，并且<code class="du jp jq jr js b">find()</code>可以用于特定的、重要的序列。</p><h1 id="40ae" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">新冠肺炎基因组</h1><p id="e2e2" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">最后，我讨论了在高性能环境中分析DNA的工具和技术。接下来，我们来谈谈实际的冠状病毒基因组。</p><p id="5b67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像大多数冠状病毒一样，这种冠状病毒是RNA病毒。然而，DNA可以从RNA转录而来，使分析更加一致。<code class="du jp jq jr js b">COVID-19</code>的基因组在磁盘上大约8kb。这不代表任何现存的新冠肺炎，这一特殊序列取自中国武汉的患者。病毒可以随着感染的传播而进化。</p><p id="90e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">包含基因组的文件可以在</em> <a class="ae jt" href="https://github.com/jweinst1/ncov2019-analyzer/blob/master/data/COVID-19-genome.txt" rel="noopener ugc nofollow" target="_blank"> <em class="jo">这里找到</em> </a> <em class="jo">。演职员表中的演职员表由吴、赵、s、于、b、陈、杨明、王、w、宋、郑国光、胡、y、敖、郑国光、田、陈建宏、裴、杨燕、袁、张永林、戴、冯辉、刘、杨、王、秦明、郑、郑建杰、徐、李、霍尔姆斯、陈建华、张永志提供</em></p><p id="07d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">分析基因组的第一步是决定寻找什么样的模式是重要的，以及这些模式有多大。比方说，我们想知道模式<code class="du jp jq jr js b">ACGGTTCCAAT</code>出现了多少次。我们可以读取新冠肺炎的基因组，每隔11个碱基对其进行切片，并将其输入到DNA Trie的实例中。</p><h1 id="a0a6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">规划搜索</h1><p id="c1eb" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">基于前面讨论的技术，我们现在可以在新冠肺炎基因组中寻找我们想要的东西。理想情况下，最好一次搜索一个或多个序列。需要一个解决方案来接受任意数量的<code class="du jp jq jr js b">const char*</code>字符串，将它们转换成<code class="du jp jq jr js b">DNA::Base*</code>，并插入到一个<code class="du jp jq jr js b">DNATrie</code>中。为了简单起见，可以使用<code class="du jp jq jr js b">main()</code>函数及其变量参数。我们还需要一个可以在<code class="du jp jq jr js b">vector&lt;&gt;</code>中使用的类来保存潜在的许多搜索序列并存储每次搜索的结果，例如:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="b50a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">注意:上述结构没有自己的</em> <code class="du jp jq jr js b"><em class="jo">seq</em></code> <em class="jo">字段。它纯粹是设计来接受argv数组的成员，或者任何它不拥有的C字符串。</em></p><p id="3ef1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目标是直接从主<code class="du jp jq jr js b">argv</code>和<code class="du jp jq jr js b">argc</code>填充一个矢量<code class="du jp jq jr js b">GenomeArguments</code>。这些参数对象将用于将新冠肺炎基因组切割成不同大小的块。这些块将被插入到<code class="du jp jq jr js b">DNATrie</code>中。最后，将在trie中查找每个基因组参数的计数。</p><p id="b036" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，新冠肺炎基因组必须从包含转录DNA序列的<code class="du jp jq jr js b">.txt</code>文件中读取。这些功能可以组合成一个单一的<code class="du jp jq jr js b">main()</code>功能。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="9c96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个命令行参数是基因组文件的路径。剩下的命令行参数是在更大的新冠肺炎基因组中搜索的序列。这段代码假设运行它的任何操作系统都可以使用C标准库中的<code class="du jp jq jr js b">fopen</code>函数，并且不使用UTF-16路径名。</p><p id="7823" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该实现将执行以下操作来运行基因组搜索。</p><ol class=""><li id="df18" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">检查基因组文件是否可以打开。</li><li id="1990" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">将命令行参数转换成<code class="du jp jq jr js b">GenomeArgument</code>。</li><li id="2e9d" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">对于每个基因组参数，插入到trie中进行初始计数(从-1到0递增)。</li><li id="61e1" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">然后，根据同样的论点，得到它的大小，并确保它低于极限。</li><li id="c836" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">然后，基于同样的理由，检查它的大小是否已经被用来切割基因组。</li><li id="3507" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">然后，对于同一仪器，逐片读取基因组并插入trie。</li><li id="a562" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">最后，对于同一个论点，在trie中查找论点并报告它的频率。</li></ol><p id="ee86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是搜索新冠肺炎基因组最直接的方法。包含生成这样一个程序所需的类和函数的单个C++源文件可以在这里的repo中找到。</p><h1 id="46ba" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">示例搜索</h1><p id="966c" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">现在，在所有的准备工作之后，让我们试着看看我们能在冠状病毒的基因组中发现什么。</p><p id="bd58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">提醒一下，这是新冠肺炎的文字表述</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="8ed1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们来看一些短长度的序列，比如<code class="du jp jq jr js b">ag</code>、<code class="du jp jq jr js b">gg</code>和<code class="du jp jq jr js b">ctag</code>。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="0150" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">即使这些是非常小的目标子序列，也有一个有趣的观察结果。<br/> <code class="du jp jq jr js b">a</code>和<code class="du jp jq jr js b">g</code>比<code class="du jp jq jr js b">c</code>、<code class="du jp jq jr js b">t</code>和<code class="du jp jq jr js b">a</code>以及<code class="du jp jq jr js b">g</code>更有可能同时出现。接下来，让我们看看<br/>特定目标序列的一些变体。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="887b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果只搜索<code class="du jp jq jr js b">tc</code>，它在新冠肺炎基因组中出现得非常普遍。然而，如果我们寻找<code class="du jp jq jr js b">tctc</code>，它的订单不太常见。<br/>同样，<code class="du jp jq jr js b">tctctc</code>是订单不太常见。随着时间的推移，重复的模式似乎变得越来越不常见。但如果这是真的，更多的随机模式应该更常见。让我们检查一下。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="78e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上面的基因组搜索中，有一些有趣的观察结果:</p><ul class=""><li id="ff75" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn mf lx ly lz bi translated"><code class="du jp jq jr js b">ggg</code>和<code class="du jp jq jr js b">ccc</code>比<code class="du jp jq jr js b">aaa</code>和<code class="du jp jq jr js b">ggg</code>更不容易出现</li><li id="51fc" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn mf lx ly lz bi translated">尽管<code class="du jp jq jr js b">c</code>在同质序列中不太常见，但它在混合序列中更常见<code class="du jp jq jr js b">tac</code>。</li></ul><p id="9d3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对长度为3的同源序列的频率的巨大差异的一个可能的解释是新冠肺炎基因组的末端大部分是<code class="du jp jq jr js b">a</code>:</p><blockquote class="mg mh mi"><p id="6efd" class="iq ir jo is b it iu iv iw ix iy iz ja mj jc jd je mk jg jh ji ml jk jl jm jn hb bi translated">^结束</p></blockquote><p id="7c5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以看到在基因组末端附近有更多的<code class="du jp jq jr js b">ttt</code>重复。</p><h1 id="2fae" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="679d" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">随着这种病毒在世界范围内传播，目前还没有已知的治疗方法，我们必须对它有更多的了解。您可以通过使用这样的技术从统计和计算的角度来研究病毒，从而获得洞察力。</p><p id="ff66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您对构建和运行本文中描述的一些示例程序感兴趣，您可以在这里找到它们</p></div></div>    
</body>
</html>