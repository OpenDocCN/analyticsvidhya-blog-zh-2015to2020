<html>
<head>
<title>Permutations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排列</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/permutations-b7f6054f67f9?source=collection_archive---------9-----------------------#2020-02-19">https://medium.com/analytics-vidhya/permutations-b7f6054f67f9?source=collection_archive---------9-----------------------#2020-02-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f6ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Leetcode 46问题。</p><p id="1571" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个非常好的问题，因为它触及了算法中最重要的主题，如递归、回溯。这或许可以解释为什么这个问题是一个热门的面试问题。</p><h1 id="da8d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">46.排列</h1><div class="kb kc ez fb kd ke"><a href="https://leetcode.com/problems/permutations/" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hj fi z dy kj ea eb kk ed ef hh bi translated">排列- LeetCode</h2><div class="kl l"><h3 class="bd b fi z dy kj ea eb kk ed ef dx translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="km l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">leetcode.com</p></div></div><div class="kn l"><div class="ko l kp kq kr kn ks kt ke"/></div></div></a></div><h1 id="eac4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">C++解决方案</h1><h2 id="2ce2" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">递归</h2><p id="170c" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">基本理念:</p><p id="ac20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于长度为n的num。</p><p id="fea8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从0到N-1中选取num，然后从剩余的N-1个元素中递归生成排列。做完这个，把结果结合在一起。python递归代码将更清楚地演示这一过程。</p><p id="dc6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以有一个幼稚的方法来接num[0]到num[N-1]，它是swap(0，I)，i in [0，1，2 …N-1]。下图显示了这一过程:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ln"><img src="../Images/66322ad25b5f403cc7146da1665c2b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PxTtCXd8-_oIPMhOd8VqhA.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">天真地交换。这里我给出4个元素来演示</figcaption></figure><p id="6b2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单交换的问题是在交换之后，剩余的值不是原来的顺序。为了解决这个问题，我们可以使用更智能的交换，如下图所示:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ln"><img src="../Images/62ce9052c39c45dee4ce4c8e71974c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLjn1KL8EuBMsAq9Grp6iw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">基于以前的互换结果的更聪明的互换可以很好地维持原有的顺序。</figcaption></figure><p id="cc4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是基于smarter swap的代码。</p><p id="d3ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行时间</p><pre class="lo lp lq lr fd mc md me mf aw mg bi"><span id="2275" class="ku je hi md b fi mh mi l mj mk">/*<br/>jimmy shen<br/>02/20/2020<br/>A code to implement the naive o(n^n) permutation algorithm.<br/>runtime 12 ms <br/>time complexity O(n!)<br/>space complexity O(n) as we have temp<br/>*/</span><span id="39fe" class="ku je hi md b fi ml mi l mj mk">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {<br/>        vector&lt;vector&lt;int&gt;&gt; res;<br/>        recursive_permute(nums, res, 0);<br/>        return res;<br/>    }   <br/>    void recursive_permute(vector&lt;int&gt;&amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;res, int pos){<br/>        // if we reach the size of nums, we are done.<br/>        vector&lt;int&gt; temp = nums;<br/>        if(pos == temp.size()-1){<br/>            res.push_back(temp);<br/>            return;<br/>        }<br/>        else{<br/>            for(int i=pos; i&lt;temp.size(); i++){<br/>                swap(temp[pos], temp[i]);<br/>                recursive_permute(temp, res, pos+1);<br/>            }<br/>        }<br/>    }<br/>};</span></pre><h2 id="ff2f" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">追踪</h2><p id="128e" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">流程简介:</p><ol class=""><li id="cd81" class="mm mn hi ih b ii ij im in iq mo iu mp iy mq jc mr ms mt mu bi translated">对于第一层，我们在[0，1，2]中交换(0，i) i。我在交换函数中使用index来解释这个想法。在代码中它是swap(nums[0]，nums[i])</li><li id="54f6" class="mm mn hi ih b ii mv im mw iq mx iu my iy mz jc mr ms mt mu bi translated">对于第二层，我们从第二个位置开始，重复前面的步骤。</li><li id="1b27" class="mm mn hi ih b ii mv im mw iq mx iu my iy mz jc mr ms mt mu bi translated">当我们到达叶节点或底部的情况下，我们回溯到前一个节点，并继续遍历。</li><li id="a6d9" class="mm mn hi ih b ii mv im mw iq mx iu my iy mz jc mr ms mt mu bi translated">就是DFS +回溯。如果你不熟悉DFS和回溯。试着谷歌一下，先理解这些概念。</li></ol><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ln"><img src="../Images/9bfe32ce964e831e2f0930da3b30de41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EP37CH4xz4crtADNM8VK0Q.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">排列过程演示。我使用ABC，而不是[1，2，3]。想法是一样的。</figcaption></figure><p id="f4f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行时间</p><pre class="lo lp lq lr fd mc md me mf aw mg bi"><span id="14c5" class="ku je hi md b fi mh mi l mj mk">Runtime: 8 ms, faster than 98.91% of C++ online submissions for Permutations.</span><span id="1f09" class="ku je hi md b fi ml mi l mj mk">Memory Usage: 9.2 MB, less than 95.52% of C++ online submissions for Permutations.</span><span id="09fa" class="ku je hi md b fi ml mi l mj mk">/*<br/>jimmy shen<br/>02/20/2020<br/>A code to implement the naive o(n^n) permutation algorithm.<br/>runtime 12 ms <br/>time complexity O(n!)<br/>space complexity O(1)<br/>*/</span><span id="4f00" class="ku je hi md b fi ml mi l mj mk">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {<br/>        vector&lt;vector&lt;int&gt;&gt; res;<br/>        dfs(nums, res, 0);<br/>        return res;<br/>    }   <br/>    void dfs(vector&lt;int&gt;&amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;res, int pos){<br/>        // if we reach the size of nums, we are done.<br/>        if(pos &gt;= nums.size()){<br/>            res.push_back(nums);<br/>            return;<br/>        }<br/>        else{<br/>            for(int i=pos; i&lt;nums.size(); i++){<br/>                swap(nums[pos], nums[i]);<br/>                dfs(nums, res, pos+1);<br/>                //recover the nums to do backtracking<br/>                swap(nums[pos], nums[i]);<br/>            }<br/>        }<br/>    }<br/>};</span></pre><p id="3f4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，我们可以发现当pos等于nums.size-1时，我们就完成了，就好像我们只剩下一个元素，我们不需要交换。所以下面的代码也是有效的。</p><pre class="lo lp lq lr fd mc md me mf aw mg bi"><span id="92a6" class="ku je hi md b fi mh mi l mj mk">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {<br/>        vector&lt;vector&lt;int&gt;&gt; res;<br/>        dfs(nums, res, 0);<br/>        return res;<br/>    }   <br/>    void dfs(vector&lt;int&gt;&amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;res, int pos){<br/>        // if we reach the size of nums, we are done.<br/>        if(pos == nums.size()-1){<br/>            res.push_back(nums);<br/>            return;<br/>        }<br/>        else{<br/>            for(int i=pos; i&lt;nums.size(); i++){<br/>                swap(nums[pos], nums[i]);<br/>                dfs(nums, res, pos+1);<br/>                //recover the nums to do backtracking<br/>                swap(nums[pos], nums[i]);<br/>            }<br/>        }<br/>    }<br/>};</span></pre><h2 id="3add" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">递归和回溯的区别。</h2><p id="b6a8" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">本质上，他们有很多相似之处。这是因为递归使用了一种DFS方式来解决问题。主要的区别在于回溯，在DFS之后，我们交换回来以确保当我们回到父节点时，其他分支的进一步探索将从正确的起点开始。这就是为什么当我们到达DFS搜索的底部时，我们需要另一个交换。</p><p id="694d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于递归，我们不需要交换回来。然而，我们将原始的num复制到temp，并在此基础上继续进行递归操作。</p><p id="220c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们看起来非常相似，但是实现方式略有不同，递归的内存复杂度是O(n ),其中n是nums的大小。回溯的是O(1)。</p><h1 id="e72e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Python解决方案</h1><h2 id="aada" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">追踪</h2><p id="19ba" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">运行时间</p><pre class="lo lp lq lr fd mc md me mf aw mg bi"><span id="6586" class="ku je hi md b fi mh mi l mj mk">Runtime: 36 ms, faster than 83.58% of Python3 online submissions for Permutations.</span><span id="775b" class="ku je hi md b fi ml mi l mj mk">Memory Usage: 13 MB, less than 96.43% of Python3 online submissions for Permutations.</span><span id="f4e6" class="ku je hi md b fi ml mi l mj mk">class Solution:<br/>    def permute(self, nums: List[int]) -&gt; List[List[int]]:<br/>        res = []<br/>        def dfs(pos):<br/>            if pos==len(nums)-1:<br/>                # using deep copy here to harvest the result<br/>                res.append(nums[:])<br/>            for i in range(pos, len(nums)):<br/>                #swap<br/>                nums[pos], nums[i] = nums[i], nums[pos]<br/>                dfs(pos+1)<br/>                nums[pos], nums[i] = nums[i], nums[pos]<br/>        dfs(0)<br/>        return res</span></pre><h2 id="fa3f" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">递归:</h2><p id="0b5b" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">运行时间</p><pre class="lo lp lq lr fd mc md me mf aw mg bi"><span id="14cf" class="ku je hi md b fi mh mi l mj mk">Runtime: 40 ms, faster than 58.63% of Python3 online submissions for Permutations.</span><span id="8542" class="ku je hi md b fi ml mi l mj mk">Memory Usage: 12.9 MB, less than 100.00% of Python3 online submissions for Permutations.</span><span id="57e6" class="ku je hi md b fi ml mi l mj mk">class Solution:<br/>    def permute(self, nums: List[int]) -&gt; List[List[int]]:<br/>        if len(nums) &lt;=1:return [nums]<br/>        return [[n]+p<br/>                for i, n in enumerate(nums)<br/>                for p in self.permute(nums[:i]+nums[i+1:]) ]</span></pre><h2 id="7a0a" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">Python作弊</h2><p id="777b" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">Python有itertlools.permutations，我们可以直接用。在面试中，如果你被问到如何实现排列，这是不可接受的。然而，当你被问到一个更难的问题时，它将是有用的，其中排列只是那个更难的问题的一个子问题。</p><pre class="lo lp lq lr fd mc md me mf aw mg bi"><span id="5197" class="ku je hi md b fi mh mi l mj mk">class Solution:<br/>    def permute(self, nums: List[int]) -&gt; List[List[int]]:<br/>        return [list(perm) for perm in itertools.permutations(nums)]</span></pre><h2 id="d2e6" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated"><a class="ae na" href="https://leetcode.com/problems/permutations-ii" rel="noopener ugc nofollow" target="_blank"> 47。排列二</a></h2><h2 id="0af7" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">天真的回溯(800多毫秒)</h2><pre class="lo lp lq lr fd mc md me mf aw mg bi"><span id="57d9" class="ku je hi md b fi mh mi l mj mk">class Solution {<br/>public:<br/>    void backtrack(vector&lt;int&gt;&amp; nums, set&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt; curr, vector&lt;int&gt;&amp; seen) {<br/>        if (curr.size() == nums.size()) {<br/>            ret.insert(curr);<br/>            return;<br/>        }<br/>        for (int j = 0; j&lt; nums.size(); ++j) {<br/>            if (!seen[j]) {<br/>                seen[j] = 1;<br/>                curr.push_back(nums[j]);<br/>                backtrack(nums, ret, curr, seen);<br/>                seen[j] = 0;<br/>                curr.pop_back();<br/>            }<br/>        }<br/>    }<br/>    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {<br/>        vector&lt;int&gt; curr,  seen(nums.size(), 0);<br/>        set&lt;vector&lt;int&gt;&gt; ret;<br/>        backtrack(nums, ret, curr, seen);<br/>        vector&lt;vector&lt;int&gt;&gt; fin_ret(ret.begin(), ret.end());<br/>        return fin_ret;<br/>        <br/>    }<br/>};</span></pre><p id="20fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更好的(12毫秒)</p><pre class="lo lp lq lr fd mc md me mf aw mg bi"><span id="806d" class="ku je hi md b fi mh mi l mj mk">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {<br/>        sort(nums.begin(), nums.end());<br/>        vector&lt;vector&lt;int&gt;&gt; perms;<br/>        permute(nums, 0, perms);<br/>        return perms;<br/>    }<br/>private:<br/>    void permute(vector&lt;int&gt; nums, int start, vector&lt;vector&lt;int&gt;&gt;&amp; perms) {<br/>        int n = nums.size();<br/>        if (start == n - 1) {<br/>            perms.push_back(nums);<br/>        } else {<br/>            for (int i = start; i &lt; n; i++) {<br/>                if ((i == start) || (nums[i] != nums[start])) {<br/>                    swap(nums[i], nums[start]);<br/>                    permute(nums, start + 1, perms);<br/>                }<br/>            }<br/>        }<br/>    }<br/>};</span></pre><p id="005e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读。任何意见，让我知道。</p></div></div>    
</body>
</html>