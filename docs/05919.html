<html>
<head>
<title>LOOSE EQUALS (==) || STRICT EQUALS (===)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">宽松等于(==) ||严格等于(===)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/loose-equals-strict-equals-29969c61ef8c?source=collection_archive---------28-----------------------#2020-05-05">https://medium.com/analytics-vidhya/loose-equals-strict-equals-29969c61ef8c?source=collection_archive---------28-----------------------#2020-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/08b81fb0fa6ef348e68eca44dae92905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZEewwPUpaaStzHHf"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">菲利贝托·桑蒂兰在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="be3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我问一位同事“两倍等于”和“三倍等于”(我们这么称呼它)之间的区别，他看着我的眼睛说:“两倍等于”检查值是否相等，而“三倍等于”检查类型和值是否相等，如果回答正确的话，就等着被授予奖杯。</p><p id="3e7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个错误的答案。</p><p id="d0a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我也是这么回答的，直到我读了凯尔·辛普森的《YDKJS》。一本了不起的书。我认为所有的JS程序员都会从阅读中受益匪浅。</p><p id="7235" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧，回到课堂。</p><p id="f07b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正确答案是，松散等号(==)允许在相等比较中进行强制，而严格等号(===)不允许。</p><p id="a4fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">花点时间消化一下。</p><p id="4e33" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在前一种情况下(回答不准确)，似乎<strong class="ix hj">" = = "</strong>比<strong class="ix hj"> "==" </strong>做得更多，因为它还必须检查类型。在正确答案中，<strong class="ix hj"> "==" </strong>做了更多的工作，因为如果值是不同的类型，它必须处理强制。</p><p id="eaef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不过这与性能无关，<strong class="ix hj"> "==" </strong>不会比<strong class="ix hj"> "===" </strong>慢。如果比较两个相同类型的值，<strong class="ix hj"> "==" </strong>和<strong class="ix hj"> "===" </strong>使用相同的算法。如果你比较两个不同类型的值，性能不是重要的因素。最大的问题应该是:在这次行动中，我到底要不要强迫？</p><p id="4663" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想要强制，用<strong class="ix hj"> "==" </strong>，但是如果你不想强制，用<strong class="ix hj">" = = "</strong>。</p><p id="196c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Es5规范的第<a class="ae iu" href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.1" rel="noopener ugc nofollow" target="_blank"> 11.9.3节中，<strong class="ix hj"> "==" </strong>操作符的行为被定义为“抽象等式比较算法”。</a></p><p id="e7c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个子句(11.9.3.1)说，如果被比较的两个值属于同一类型，那么它们只是基于它们的同一性进行比较。即42只等于42，“foo”只等于“foo”。</p><p id="d5ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">11.9.3中算法的其余部分规定，如果使用==来比较不同类型的值，则需要隐式强制一个或两个值。这种强制会发生，因此这两个值最终会成为相同的类型，从而可以基于值的同一性来评估它们是否相等。</p><h2 id="08b6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">比较:字符串与数字</strong></h2><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/15e92e132612ba3df48b7c89307c9f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rm6izLDqTV9EuQMIb3ZZzg.png"/></div></div></figure><p id="8764" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于克里斯蒂亚诺===罗纳尔多返回false，我们并不感到惊讶，因为不允许强迫。</p><p id="dd1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，<strong class="ix hj">cristiano = = Ronaldo</strong>comparison使用松散等式，这意味着如果其中一个值恰好是不同的类型，比较算法将对其中一个或两个值执行隐式强制。</p><p id="215a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能想知道值之间发生了什么样的强制。<strong class="ix hj">克里斯蒂亚诺</strong>的值是被强制为字符串还是<strong class="ix hj">c罗</strong>的值被强制为数字？</p><p id="89a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看<a class="ae iu" href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.1" rel="noopener ugc nofollow" target="_blank"> ES5规范第11 . 9 . 3 . 4–5条</a>是怎么说的:</p><blockquote class="kt ku kv"><p id="6bb9" class="iv iw kw ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated">1.如果Type(x)是Number，Type(y)是String，则返回比较结果x == ToNumber(y)。</p><p id="ff38" class="iv iw kw ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated">2.如果Type(x)是String，Type(y)是Number，则返回Number(x) == y的比较结果。</p></blockquote><p id="4bc7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从规范中，我们可以推断出，<strong class="ix hj"> ronaldo </strong>是一个字符串(" 7 ")，通过<strong class="ix hj"> ToNumber </strong>抽象操作被强制转换为一个数字(7)，然后，当比较这些值是否相等时，它返回<strong class="ix hj"> true </strong>，因为结果值现在相等。</p><h2 id="71b8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">比较:将任何内容转换为布尔值</strong></h2><p id="82c4" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">当您试图将一个值直接与<strong class="ix hj">真</strong>或<strong class="ix hj">假</strong>进行比较时，松散等式(==)的隐式强制的最大问题之一就会出现。</p><p id="d8c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/d77d8b158b3038008cf761cc1378b4c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4rHizLNX5Q4k2igl71TePg.png"/></div></div></figure><p id="b740" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">WTF？怎么会<strong class="ix hj">罗纳尔多</strong>这是一个“真值”，而不是<strong class="ix hj">“= =”</strong>为真。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">giphy的gif</figcaption></figure><p id="7774" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看<a class="ae iu" href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.1" rel="noopener ugc nofollow" target="_blank"> ES5规范第11 . 9 . 3 . 6–7条</a>:</p><blockquote class="kt ku kv"><p id="417f" class="iv iw kw ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated">1.如果Type(x)是Boolean，则返回Number(x) == y的比较结果。</p><p id="ad89" class="iv iw kw ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated">2.如果Type(y)为布尔值，则返回比较结果x == ToNumber(y)。</p></blockquote><p id="1f61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在我们的示例代码中应用规范:Type (verdict)是布尔值，所以执行<strong class="ix hj"> ToNumber(verdict) </strong>来强制其值变为1 (true == 1)。</p><p id="6fbe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，<strong class="ix hj"> 1 == "山羊"</strong>求值。类型还是不一样的，于是算法被重新协商(递归)，它会试图将“山羊”强制为一个明显失败的数:<strong class="ix hj"> NaN </strong>，1 == NaN为<strong class="ix hj"> false </strong>。</p><p id="cfbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“GOAT”确实是真的，但是<strong class="ix hj">“GOAT”= =真</strong>根本不是在执行布尔测试/强制。<strong class="ix hj">“山羊”</strong>不是被胁迫为一个布尔(真)，而是，<strong class="ix hj">真</strong>被胁迫为1，然后【山羊】<strong class="ix hj"> </strong>被胁迫为楠。</p><p id="28e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> ToBoolean </strong>甚至没有涉及，所以【山羊】<strong class="ix hj"> </strong>的真假与<strong class="ix hj"> == </strong>操作无关。每当布尔值在<strong class="ix hj"> == </strong>的两边时，它总是先强制为一个数字。<strong class="ix hj"> </strong>是啊，真奇怪。</p><p id="bfee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">建议在任何情况下都不要使用<strong class="ix hj"> ==真</strong>或<strong class="ix hj"> ==假</strong>。</p><h2 id="92be" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">隐式强制的安全使用</strong></h2><p id="94d1" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">注意可能出现在<strong class="ix hj"> == </strong>比较的任何一边的值。为了有效地避免这种比较的问题，这里有一些启发性的规则可以遵循:</p><p id="dd4f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.如果比较的任何一方可以有<strong class="ix hj">真</strong>或<strong class="ix hj">假</strong>值，永远不要使用<strong class="ix hj"> == </strong>。</p><p id="b69c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.如果比较的任何一方可以有<strong class="ix hj"> [] </strong>，<strong class="ix hj"> "" </strong>，或者<strong class="ix hj"> 0 </strong>的值，认真考虑不用<strong class="ix hj"> == </strong>。</p><p id="68b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最好使用严格的等式而不是宽松的等式，以避免不必要的强制。遵循以上规则将会大大有助于防止所有可能伤害你的强制手段。</p><p id="5a76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你们都保持安全和强壮？</p></div></div>    
</body>
</html>