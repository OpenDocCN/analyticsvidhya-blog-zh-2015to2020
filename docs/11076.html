<html>
<head>
<title>ReactJS in Simple English — state (2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单英语反应—状态(2)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/reactjs-in-simple-english-state-2-af0fbc722cbe?source=collection_archive---------22-----------------------#2020-11-16">https://medium.com/analytics-vidhya/reactjs-in-simple-english-state-2-af0fbc722cbe?source=collection_archive---------22-----------------------#2020-11-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4754" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次我们将更深入地了解状态，包括<em class="jd"> shouldComponentUpdate() </em>、<em class="jd"> PureComponent </em>和上下文API</p><p id="30b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们继续之前，让我们看看ReactJS是如何更新我们的页面的</p><ol class=""><li id="6286" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">检测到道具或状态的变化</li><li id="2312" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">触发器<em class="jd">shouldcomponentdupdate()</em>，默认返回true，这意味着它总是转到下一步<em class="jd"> render() </em></li><li id="fd40" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">调用render() 来渲染新的虚拟DOM</li><li id="1e82" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">将旧的虚拟DOM与新呈现的虚拟DOM进行比较</li><li id="0fe9" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">如果发现任何差异，更新真实的DOM，只更新不同的部分，而不是整个DOM</li></ol><p id="cff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，如果props或state发生任何变化，React将始终呈现()包含所有组件的新虚拟DOM，并将其与上一个版本进行比较。<br/>例如，用户只需点击提交按钮并触发模态面板和确认对话框。显然，这是屏幕上的一个小变化，可能是一个布尔状态指示确认对话框必须显示，与其他组件无关。<br/>但是，React仍然会呈现一个包含所有组件的虚拟DOM，并与旧版本进行核对。想想看，如果我们有一个大型应用程序，每一个变化都会触发相同的行为-渲染并再次检查所有组件。这将耗费大量资源并降低应用程序的速度。</p><p id="cf60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了提高性能，我们可以在<em class="jd">shouldComponentUpdate()</em>中实现一些检查，或者应用<em class="jd"> PureComponent </em>，以便跳过一些不必要的<em class="jd"> render() </em>并加快检查速度(因为新呈现的DOM将包含更少的组件)</p><ol class=""><li id="85bc" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj">shouldcomponentdupdate()</strong></li></ol><p id="3545" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是React中的生命周期挂钩之一，默认情况下返回true，这意味着它总是转到下一步<em class="jd"> render()。</em>我们可以在这里实现一些检查，所以如果状态/道具在那个类中没有改变，那么我们就不包括在接下来的渲染中。</p><p id="cb80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地理解，让我们举个例子。在这个例子中，我们有3个班级。应用程序包含PureInventory和库存</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es js"><img src="../Images/e90321255bffa644b33bde7fd58915bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*bEFWtLqC6a_PCsGg_7dbSg.jpeg"/></div></figure><p id="65e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">App类用三个变量初始化状态——App/ PureInventory/ Inventory的计数器和为App/pure Inventory/Inventory添加计数器的函数，我们通过props传递它们</p><p id="6591" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在render方法中，它包括两个子元素——pure Inventory和Inventory，以及一个时钟——每当render触发时，时钟就会更新</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="ea3d" class="kf kg hi kb b fi kh ki l kj kk">//App.js</span><span id="8a30" class="kf kg hi kb b fi kl ki l kj kk">class App extends Component {</span><span id="89a7" class="kf kg hi kb b fi kl ki l kj kk">state = {<br/>   counter: 0,<br/>   childCounter: 0,<br/>   pureChildCounter: 0<br/>};</span><span id="c599" class="kf kg hi kb b fi kl ki l kj kk">increaseCounterHandler = () =&gt; {<br/>   this.setState((state) =&gt; {<br/>   return { counter: state.counter + 1 };<br/>   });<br/>};</span><span id="face" class="kf kg hi kb b fi kl ki l kj kk">increaseChildCounterHandler = () =&gt; {<br/>   this.setState((state) =&gt; {<br/>   return { childCounter: state.childCounter + 1 };<br/>   });<br/>};</span><span id="1b7d" class="kf kg hi kb b fi kl ki l kj kk">increasePureChildCounterHandler = () =&gt; {<br/>   this.setState((state) =&gt; {<br/>   return { pureChildCounter: state.pureChildCounter + 1 };<br/>   });<br/>};</span><span id="7d40" class="kf kg hi kb b fi kl ki l kj kk">render() {<br/>   console.log("parent render");<br/>   return (<br/>      &lt;div className="App"&gt;<br/>         &lt;button onClick={this.increaseCounterHandler}&gt;<br/>         Increase App Counter<br/>         &lt;/button&gt;<br/>         &lt;p&gt;App Counter {this.state.counter}&lt;/p&gt;<br/>         &lt;p&gt;Last Update {new Date().toLocaleString()}&lt;/p&gt;<br/>         &lt;div&gt;<br/>         &lt;Inventory <br/>            clicked={this.increaseChildCounterHandler} childCounter=    {this.state.childCounter}/&gt;<br/>         &lt;PureInventory<br/>            clicked={this.increasePureChildCounterHandler}   pureChildCounter={this.state.pureChildCounter}/&gt;<br/>         &lt;/div&gt;<br/>      &lt;/div&gt;<br/>      );<br/>}<br/>}</span></pre><p id="28a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PureInventory类，一个非常简单的类，有一个增加计数器的按钮和一个时钟——每当渲染触发时，时钟就会更新</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="1818" class="kf kg hi kb b fi kh ki l kj kk">//PureInventory.js</span><span id="20a1" class="kf kg hi kb b fi kl ki l kj kk">class PureInventory extends Component {</span><span id="85b5" class="kf kg hi kb b fi kl ki l kj kk">render() {<br/>      console.log("pure children render");<br/>      return (<br/>         &lt;div&gt;<br/>            &lt;button onClick={this.props.clicked}&gt; Increase PureInventory Counter &lt;/button&gt;<br/>            &lt;p&gt;PureInventory Counter {this.props.pureChildCounter}&lt;/p&gt;    &lt;p&gt;Last Update {new Date().toLocaleString()}&lt;/p&gt;<br/>         &lt;/div&gt;<br/>      );<br/>}<br/>}</span></pre><p id="8741" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与PureInventory类类似，Inventory类有一个增加计数器的按钮和一个时钟——每当渲染触发时，时钟就会更新</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="6b00" class="kf kg hi kb b fi kh ki l kj kk">class Inventory extends Component {</span><span id="1b8b" class="kf kg hi kb b fi kl ki l kj kk">render() {<br/>   console.log("children render");<br/>   return (<br/>      &lt;div&gt;<br/>      &lt;button onClick={this.props.clicked}&gt;Increase Inventory Counter&lt;/button&gt;<br/>      &lt;p&gt;Inventory Counter {this.props.childCounter}&lt;/p&gt;<br/>      &lt;p&gt;Last Update {new Date().toLocaleString()}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>      );<br/>}<br/>}</span></pre><p id="da6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所述，默认情况下(如果你还没有实现<em class="jd">shouldComponentUpdate()</em><em class="jd">/PureComponent</em>)，状态的任何变化都会触发<em class="jd"> render() </em>(所有类的)在新的虚拟DOM中重新渲染所有的东西</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es km"><img src="../Images/b8eb335fa1d50d8a25eedd860c8ade7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8rivldLgAkxIb3E-JLm-w.jpeg"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">应用计数器增加，子库存和纯库存也重新呈现，因为上次更新的时间相同</figcaption></figure><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kv"><img src="../Images/1210235d6ca1f049bc0f0285c86c355c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3xBH0AsLb3VMGyUwc_Tkg.jpeg"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">库存计数器增加，父库存和纯库存也会重新渲染，因为上次更新的时间相同</figcaption></figure><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kw"><img src="../Images/c485ec79b81f72f2851496690a4c7321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37QyH7rJ_6kmo024nYw9yQ.jpeg"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">纯子级计数器增加，父级和子级也重新渲染，因为上次更新的时间相同</figcaption></figure><p id="2bc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们可以在PureInventory类中实现<em class="jd">shouldComponentUpdate(nextProps，nextState)</em>-<em class="jd">nextProps</em>表示已更改的属性，<em class="jd"> nextState </em>表示已更改的状态。<br/>因此，我们可以将当前道具/状态与变化后的道具/状态进行比较。<br/>在这种情况下，PureInventory只得到1个道具——pure child counter，我们通过<em class="jd">对比新旧道具！== </em>，这意味着只有当新的pureChildCounter与当前的pureChildCounter不同时才进一步(<em class="jd"> render() </em>)。</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="7d89" class="kf kg hi kb b fi kh ki l kj kk">//PureInventory.js</span><span id="8cf8" class="kf kg hi kb b fi kl ki l kj kk">class PureInventory extends Component {</span><span id="0b02" class="kf kg hi kb b fi kl ki l kj kk">shouldComponentUpdate(nextProps, nextState) {<br/>   return <br/>   this.props.pureChildCounter !== nextProps.pureChildCounter;<br/>}</span><span id="02a3" class="kf kg hi kb b fi kl ki l kj kk">render() {<br/>      console.log("pure children render");<br/>      return (<br/>         &lt;div&gt;<br/>            &lt;button onClick={this.props.clicked}&gt; Increase Pure Child Counter &lt;/button&gt;<br/>            &lt;p&gt;Pure Child Counter {this.props.pureChildCounter}&lt;/p&gt;    &lt;p&gt;Last Update {new Date().toLocaleString()}&lt;/p&gt;<br/>         &lt;/div&gt;<br/>      );<br/>}<br/>}</span></pre><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kv"><img src="../Images/3d2abd82e5aec86f145da5d655619959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kpD6N0rk5VS-oVyqWLh6Sw.jpeg"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">在PureInventory类中实现shouldComponentUpdate()后，如果计数器的增加是在App或Inventory中(与PureInventory无关)，它不再重新呈现</figcaption></figure><p id="0c22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试试这个工作示例</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="9ed3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<em class="jd">纯组件</em></p><p id="32d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> PureComponent </em>与<em class="jd">shouldComponentUpdate()</em>非常相似，除了<em class="jd"> PureComponent </em>会检查所有道具/状态，但是你可以在<em class="jd">shouldComponentUpdate()</em>中定制</p><p id="cb7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实现<em class="jd"> PureComponent </em>很简单，只需导入它并扩展"<em class="jd"> PureComponent </em>而不是"<em class="jd"> Component </em>"，其他都一样</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="800e" class="kf kg hi kb b fi kh ki l kj kk">import React, { PureComponent } from "react";</span><span id="5d82" class="kf kg hi kb b fi kl ki l kj kk">class PureInventory extends PureComponent {</span><span id="e3ee" class="kf kg hi kb b fi kl ki l kj kk">render() {</span><span id="6c30" class="kf kg hi kb b fi kl ki l kj kk">   console.log("pure children render");<br/>   return (<br/>   &lt;div&gt;<br/>   &lt;button onClick={this.props.clicked}&gt;<br/>   Increase Pure Child Counter<br/>   &lt;/button&gt;<br/>   &lt;p&gt;Pure Child Counter {this.props.pureChildCounter}&lt;/p&gt;<br/>   &lt;p&gt;Last Update {new Date().toLocaleString()}&lt;/p&gt;<br/>   &lt;/div&gt;<br/>   );<br/>}<br/>}</span><span id="0d20" class="kf kg hi kb b fi kl ki l kj kk">export default PureInventory;</span></pre><p id="1039" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试试工作示例</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="9523" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么时候使用<em class="jd">shouldComponentUpdate()</em>/<em class="jd">PureComponent</em>？</p><p id="a661" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">视情况而定，如果有些组件总是随父组件更新，那么对它们进行任何检查都是浪费资源。对于某些情况，你非常确定不应该涉及到其他组件，就像我们在开头提到的——带有模态面板的确认对话框，<em class="jd">shouldComponentUpdate()</em>将是合适的，因为你确切地了解应该检查什么。如果应用程序很复杂，PureComponent会更好，节省实现和测试时间，减少出错的机会。</p><p id="4f53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">shouldComponentUpdate()</em>/<em class="jd">pure component</em>如何比较道具/状态？</p><p id="521b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PureComponent 实现了一个浅层比较，这意味着如果数据是一个原始值，它会自己比较数据。但是，如果它是一个对象，它将比较对象引用，而不是对象中的值。<br/>在<em class="jd">shouldcomponentdupdate()</em>中，你可以实现任何你想要的东西，但是如果你在这里实现深度比较，可能会让你的应用变慢。<br/>这就是为什么在<a class="ae kz" href="https://link.medium.com/FHbgapkXobb" rel="noopener">最后一段</a>中，我强调我们“替换”了状态，但没有编辑里面的数据。</p><p id="e55b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.上下文API</p><p id="6290" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae kz" href="https://link.medium.com/FHbgapkXobb" rel="noopener">最后一段</a>中，我们走过了基本的about状态，我们可以通过props将状态传递给另一个类/组件。想想看，如果我们有一个大型应用程序，从上到下，它可能有几层，如果我们想通过一个道具，我们必须通过每一层，这需要大量不必要的编码和额外的时间来维护它。</p><p id="6d87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看这个例子，应用程序包含布局，布局包含菜单和配置文件。如果我们想把一个道具从应用程序传递到菜单和配置文件，那么我们也必须通过布局。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es la"><img src="../Images/234892a916c4b2e682c7e591eda4548f.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*_3kOAynmhtdeQ2ZJ5t_7lg.jpeg"/></div></div></figure><p id="6d2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顶级— App.js</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="7d18" class="kf kg hi kb b fi kh ki l kj kk">//App.js<br/>class App extends Component {</span><span id="d83a" class="kf kg hi kb b fi kl ki l kj kk">state = {<br/>   adminMenu: false,<br/>   customerMenu: true,<br/>   name: "Fifi",<br/>   position: "Customer Service Operator"<br/>};</span><span id="a881" class="kf kg hi kb b fi kl ki l kj kk">render() {<br/>   return (<br/>      &lt;div className="App"&gt;<br/>      &lt;Layout<br/>         adminMenu={this.state.adminMenu}<br/>         customerMenu={this.state.customerMenu}<br/>         name={this.state.name}<br/>         position={this.state.position}<br/>      /&gt;<br/>      &lt;/div&gt;<br/>   );</span><span id="0de3" class="kf kg hi kb b fi kl ki l kj kk">}<br/>}</span></pre><p id="eafb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“中间人”——layout . js</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="b695" class="kf kg hi kb b fi kh ki l kj kk">//Layout.js<br/>import React, { Component } from "react";<br/>import Profile from "./Profile/Profile";<br/>import Menu from "./Menu/Menu";<br/>import "../styles.css";</span><span id="71ea" class="kf kg hi kb b fi kl ki l kj kk">class Layout extends Component {<br/>   render() {<br/>      console.log(this.props.customerMenu);<br/>      return (<br/>         &lt;div className="main-container"&gt;<br/>         &lt;div className="left-container"&gt;<br/>         &lt;Menu customerMenu={this.props.customerMenu} adminMenu={this.props.adminMenu}<br/>         /&gt;<br/>         &lt;/div&gt;<br/>         &lt;div className="right-container"&gt;<br/>         &lt;Profile name={this.props.name} position={this.props.position} /&gt;<br/>         &lt;/div&gt;<br/>         &lt;/div&gt;<br/>   );</span><span id="dd22" class="kf kg hi kb b fi kl ki l kj kk">}<br/>}<br/>export default Layout;</span></pre><p id="1abf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">底层— Menu.js</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="bd40" class="kf kg hi kb b fi kh ki l kj kk">class Menu extends Component {</span><span id="3a1e" class="kf kg hi kb b fi kl ki l kj kk">   render() {<br/>      return (<br/>         &lt;div&gt;<br/>         &lt;p&gt;{this.props.adminMenu ? &lt;a href="#"&gt;Admin&lt;/a&gt; : null}&lt;/p&gt;<br/>         &lt;p&gt;{this.props.customerMenu ? &lt;a href="#"&gt;Customer&lt;/a&gt; : null}&lt;/p&gt;<br/>         &lt;/div&gt;<br/>      );<br/>}<br/>}</span></pre><p id="1b0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">底层— Profile.js</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="bd61" class="kf kg hi kb b fi kh ki l kj kk">class Profile extends Component {</span><span id="8120" class="kf kg hi kb b fi kl ki l kj kk">   render() {<br/>      return (<br/>         &lt;div&gt;<br/>         &lt;p&gt;Name: {this.props.name}&lt;/p&gt;<br/>         &lt;p&gt;Position: {this.props.position}&lt;/p&gt;<br/>         &lt;/div&gt;<br/>         );<br/>}<br/>}</span></pre><p id="5652" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的例子说明，如果我们把道具从App传到菜单/ Profile，就必须经过Layout。</p><p id="3d92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自从上下文API的引入，我们可以绕过布局，应用程序可以直接将属性传递给菜单/配置文件</p><p id="7293" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何在ReactJS中实现上下文API？</p><p id="b5da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们必须创建一个fail来初始化上下文及其默认值</p><p id="5110" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> createContext({}) </em>里面的这个值只是一个参考。即使我们在这里留空，我们仍然可以在后面的<em class="jd"> &lt;提供者&gt; </em>中包含它。</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="60db" class="kf kg hi kb b fi kh ki l kj kk">//user-context.js<br/>import React from "react";</span><span id="d83b" class="kf kg hi kb b fi kl ki l kj kk">const userContext = React.createContext({});</span><span id="5990" class="kf kg hi kb b fi kl ki l kj kk">export default userContext;</span></pre><p id="bbc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在App.js中，我们初始化状态和传递状态的起点，我们必须导入我们刚刚创建的上下文文件。</p><p id="6366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，在<em class="jd">render()</em>——我们用来传递属性的地方，我们必须包装包含菜单和配置文件的树——我们想要将属性传递到的目的地，在本例中为&lt; Layout/ &gt;，并用&lt; UserContext包装它。提供者&gt;，它的值属性包含我们想要传递的那些状态，或者我们可以只传递整个状态</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="d569" class="kf kg hi kb b fi kh ki l kj kk">import UserContext from "./context/user-context";</span><span id="1ece" class="kf kg hi kb b fi kl ki l kj kk">class App extends Component {</span><span id="9aa3" class="kf kg hi kb b fi kl ki l kj kk">state = {<br/>      adminMenu: false,<br/>      customerMenu: true,<br/>      name: "Fifi",<br/>      position: "Customer Service Operator",<br/>      testRender: 1,<br/>      message: "testing"<br/>   };</span><span id="ae14" class="kf kg hi kb b fi kl ki l kj kk">//to test the behavior of context API later<br/>increaseCounter = (greeting) =&gt; {<br/>   this.setState((state) =&gt; {<br/>      return { testRender: state.testRender + 1 };<br/>   });<br/>};</span><span id="3979" class="kf kg hi kb b fi kl ki l kj kk">render() {<br/>   console.log("App render");<br/>   console.log("counter:", this.state.testRender);<br/>   return (<br/>      &lt;div className="App"&gt;<br/>      &lt;UserContext.Provider</span><span id="7b55" class="kf kg hi kb b fi kl ki l kj kk">      //pass the whole state<br/>      <em class="jd">value={this.state}</em></span><span id="3b6a" class="kf kg hi kb b fi kl ki l kj kk">      //or only pass some value in state<br/>      /*value={{<br/>         adminMenu: this.state.adminMenu,<br/>         customerMenu: this.state.customerMenu,<br/>         name: this.state.name,<br/>         position: this.state.position<br/>      }}*/<br/>      &gt;</span><span id="b684" class="kf kg hi kb b fi kl ki l kj kk">&lt;Layout /&gt;<br/>   &lt;/UserContext.Provider&gt;<br/>   &lt;/div&gt;<br/>   );<br/>}<br/>}</span></pre><p id="c197" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在侧面，另一个目的地，我们想通过道具。导入我们在第一步创建的上下文文件。这一次我们必须用<usercontext.consumer>包装引用上下文变量的JSX。在内部，在我们引用上下文变量之前，我们必须在这里声明一个arrow函数，用<em class="jd"> context </em>作为参数，然后我们可以包装JSX返回并引用那里的上下文变量</usercontext.consumer></p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="b78b" class="kf kg hi kb b fi kh ki l kj kk">import React, { Component, PureComponent } from "react";<br/>import UserContext from "../../context/user-context";</span><span id="ef8d" class="kf kg hi kb b fi kl ki l kj kk">class Menu extends Component {<br/>   render() {<br/>      console.log("Menu render");<br/>      return (<br/>         &lt;UserContext.Consumer&gt;<br/>         {(context) =&gt; (<br/>            &lt;div&gt;<br/>            &lt;p&gt;{context.adminMenu ? &lt;a href="#"&gt;Admin&lt;/a&gt; : null}&lt;/p&gt;<br/>            &lt;p&gt;{context.customerMenu ? &lt;a href="#"&gt;Customer&lt;/a&gt; : null}&lt;/p&gt;<br/>            &lt;/div&gt;<br/>         )}<br/>         &lt;/UserContext.Consumer&gt;<br/>         );</span><span id="580f" class="kf kg hi kb b fi kl ki l kj kk">}<br/>}<br/>export default Menu;</span></pre><p id="6dba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在侧面，另一个目的地，我们想通过道具。导入我们在第一步创建的上下文文件。这次我们将尝试另一种语法(要求16.6或更高版本)。在Profile类中，我们必须声明一个静态变量— <em class="jd">静态上下文类型</em>(React保留的字)并分配给<em class="jd">用户上下文</em>(我们刚刚导入的上下文文件)</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="d019" class="kf kg hi kb b fi kh ki l kj kk">import UserContext from "../../context/user-context";</span><span id="8046" class="kf kg hi kb b fi kl ki l kj kk">class Profile extends Component {<br/>   static contextType = UserContext;<br/>   <br/>   render() {<br/>      console.log("Profile render");<br/>      return (<br/>         &lt;div&gt;<br/>         &lt;p&gt;Name: {this.context.name}&lt;/p&gt;<br/>         &lt;p&gt;Position: {this.context.position}&lt;/p&gt;<br/>         &lt;/div&gt;<br/>      );</span><span id="5924" class="kf kg hi kb b fi kl ki l kj kk">}<br/>}</span></pre><p id="4499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> &lt;消费者&gt; </em>和<em class="jd">上下文类型</em>有什么区别？</p><ol class=""><li id="42f1" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><em class="jd"> &lt;消费者&gt; </em>在React 16.3中可用，<em class="jd">上下文类型</em>在React 16.6以上必需</li><li id="8515" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">&lt;<em class="jd">消费者</em> &gt;允许同时消费多个上下文，而<em class="jd">上下文类型</em>只允许消费单个上下文</li><li id="bc8c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">&lt;<em class="jd">消费者</em> &gt;只能与JSX一起使用，而<em class="jd">上下文类型</em>可以在类中的任何地方使用</li><li id="0e8e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><em class="jd"> contextType </em>总是随着Parent一起触发<em class="jd"> render() </em>一旦你声明<em class="jd">static context type = user context</em>无论你在对方<em class="jd">上应用<em class="jd">shouldcomponentdupdate()</em>或<em class="jd"> PureComponent <br/> </em>，&lt;消费者&gt; </em>得到类似的行为，但是如果你应用<em class="jd">shouldcomponentdupdate()</em>或<em class="jd"> PureComponent </em></li></ol><p id="85b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试试工作示例</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="kx ky l"/></div></figure></div></div>    
</body>
</html>