<html>
<head>
<title>Exploratory and Predictive Data Analysis of the Adult income data-set</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成人收入数据集的探索性和预测性数据分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/exploratory-and-predictive-data-analysis-of-the-adult-income-data-set-58a4d3abc04d?source=collection_archive---------24-----------------------#2020-01-21">https://medium.com/analytics-vidhya/exploratory-and-predictive-data-analysis-of-the-adult-income-data-set-58a4d3abc04d?source=collection_archive---------24-----------------------#2020-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cb65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个<a class="ae jd" href="https://archive.ics.uci.edu/ml/datasets/Adult" rel="noopener ugc nofollow" target="_blank">数据集</a>在UCI ML知识库中，有大约45000个人的人口统计细节，如年龄、性别、种族等。我将分享我预测个人收入是否超过50K的方法。</p><p id="1b18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个项目，我使用了python和Jupyter Notebook。一开始，我导入了相关的库(在上帝创造天地之前)。除此之外，根据你的选择设置可视化的大小。。我用了一种概率方法来处理分类变量。这个项目的全部代码可以在<a class="ae jd" href="https://github.com/codebat137/JupyterNoteboooks/blob/master/adult_income.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="1f4b" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">import</strong> <strong class="jj hj">pandas</strong> <strong class="jj hj">as</strong> <strong class="jj hj">pd</strong><br/><strong class="jj hj">import</strong> <strong class="jj hj">numpy</strong> <strong class="jj hj">as</strong> <strong class="jj hj">np</strong><br/><strong class="jj hj">import</strong> <strong class="jj hj">sklearn</strong> <strong class="jj hj">as</strong> <strong class="jj hj">sk</strong><br/><strong class="jj hj">import</strong> <strong class="jj hj">seaborn</strong> <strong class="jj hj">as</strong> <strong class="jj hj">sns</strong><br/><strong class="jj hj">import</strong> <strong class="jj hj">matplotlib.pyplot</strong> <strong class="jj hj">as</strong> <strong class="jj hj">plt</strong><br/>%matplotlib inline<br/>plt.rcParams["figure.figsize"] = (20,10)</span></pre><p id="6ac7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们导入训练数据集并开始吧。我们必须手动添加列标签，因为该数据集没有列标签。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="7053" class="jn jo hi jj b fi jp jq l jr js">data = pd.read_csv('adult.data')<br/>data.info()<br/>data.columns = ['age','work-class','fnlwgt','education','edu-num','marital',            'occup','relatnip','race','sex','gain','loss','hours','citizenship','&gt;50k']</span></pre><p id="7da8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述单元格的输出。由此可以推断，我们不必太担心缺失值。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="1d0d" class="jn jo hi jj b fi jp jq l jr js">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 32560 entries, 0 to 32559<br/>Data columns (total 15 columns):<br/>39                32560 non-null int64<br/> State-gov        32560 non-null object<br/> 77516            32560 non-null int64<br/> Bachelors        32560 non-null object<br/> 13               32560 non-null int64<br/> Never-married    32560 non-null object<br/> Adm-clerical     32560 non-null object<br/> Not-in-family    32560 non-null object<br/> White            32560 non-null object<br/> Male             32560 non-null object<br/> 2174             32560 non-null int64<br/> 0                32560 non-null int64<br/> 40               32560 non-null int64<br/> United-States    32560 non-null object<br/> &lt;=50K            32560 non-null object<br/>dtypes: int64(6), object(9)<br/>memory usage: 3.7+ MB</span></pre><p id="390e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于最后一列有一个对象类型，我们需要找出使用的唯一标签，然后将其映射到整数类型。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="8e57" class="jn jo hi jj b fi jp jq l jr js">data['&gt;50k'].unique()</span></pre><p id="6e85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相应的输出:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="9765" class="jn jo hi jj b fi jp jq l jr js">array([' &lt;=50K', ' &gt;50K'], dtype=object)</span></pre><p id="8e58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将收入小于或等于50k对应的标签映射到0，另一个映射到1。我们还将再次获取信息，并检查列的数据类型是否已经更改为int。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="e55b" class="jn jo hi jj b fi jp jq l jr js">data['&gt;50k'] = data['&gt;50k'].map({' &lt;=50K':0,' &gt;50K':1})<br/>data.info()</span></pre><p id="3b31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您可以从输出中推断的那样，该列的数据类型已经更改为64位整数类型。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="d92d" class="jn jo hi jj b fi jp jq l jr js">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 32560 entries, 0 to 32559<br/>Data columns (total 15 columns):<br/>age            32560 non-null int64<br/>work-class     32560 non-null object<br/>fnlwgt         32560 non-null int64<br/>education      32560 non-null object<br/>edu-num        32560 non-null int64<br/>marital        32560 non-null object<br/>occup          32560 non-null object<br/>relatnip       32560 non-null object<br/>race           32560 non-null object<br/>sex            32560 non-null object<br/>gain           32560 non-null int64<br/>loss           32560 non-null int64<br/>hours          32560 non-null int64<br/>citizenship    32560 non-null object<br/>&gt;50k           32560 non-null int64<br/>dtypes: int64(7), object(8)<br/>memory usage: 3.7+ MB</span></pre><p id="6ae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我写了一个函数，目的是根据分类变量的任何值，得到收入超过50K的概率。例如，每种性别、公民身份等的收入超过50K的概率是多少？为了实现这个目标，我计算了50k '列的平均值。因为唯一可能的值是0和1，所以平均值将对应于得到1的概率。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="163d" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">def</strong> rep_mean(var,data):   <br/>   l = list(data[var].unique())<br/>   d = dict()     <br/>   <strong class="jj hj">for</strong> obj <strong class="jj hj">in</strong> l:      <br/>      d[obj] = data[data[var]==obj]['&gt;50k'].mean()<br/>   <strong class="jj hj">return</strong> d</span></pre><p id="36ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在work-class列上检查这个函数，因为它恰好是分类函数。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="dad7" class="jn jo hi jj b fi jp jq l jr js">temp1 = rep_mean('work-class',data)<br/>temp1</span></pre><p id="b3d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出返回一个字典。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="8ce7" class="jn jo hi jj b fi jp jq l jr js">{' Self-emp-not-inc': 0.2849271940181031,<br/> ' Private': 0.21867289390200917,<br/> ' State-gov': 0.27216653816499614,<br/> ' Federal-gov': 0.38645833333333335,<br/> ' Local-gov': 0.29479216435738176,<br/> ' ?': 0.10403050108932461,<br/> ' Self-emp-inc': 0.557347670250896,<br/> ' Without-pay': 0.0,<br/> ' Never-worked': 0.0}</span></pre><p id="3ea7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个字典可以映射到work-class列。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="705b" class="jn jo hi jj b fi jp jq l jr js">data['work-class'] = data['work-class'].map(temp1)<br/>data.info()</span></pre><p id="1e0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您可以从输出中推断的那样，它的数据类型已经更改为64位浮点数。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="fc2e" class="jn jo hi jj b fi jp jq l jr js">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 32560 entries, 0 to 32559<br/>Data columns (total 15 columns):<br/>age            32560 non-null int64<br/>work-class     32560 non-null float64<br/>fnlwgt         32560 non-null int64<br/>education      32560 non-null object<br/>edu-num        32560 non-null int64<br/>marital        32560 non-null object<br/>occup          32560 non-null object<br/>relatnip       32560 non-null object<br/>race           32560 non-null object<br/>sex            32560 non-null object<br/>gain           32560 non-null int64<br/>loss           32560 non-null int64<br/>hours          32560 non-null int64<br/>citizenship    32560 non-null object<br/>&gt;50k           32560 non-null int64<br/>dtypes: float64(1), int64(7), object(7)<br/>memory usage: 3.7+ MB</span></pre><p id="6902" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我对其他分类列，也就是‘object’列做了同样的处理。整个实现可以在<a class="ae jd" href="https://github.com/codebat137/JupyterNoteboooks/blob/master/adult_income.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我通过将几列的值相加，并对概率和相关系数的乘积求和，创建了几个虚拟变量。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="2e6c" class="jn jo hi jj b fi jp jq l jr js">data['net'] = data['gain']+data['loss']<br/>x = data.corr() <br/>x</span></pre><p id="8214" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我选择不在这里显示相关表，因为它没有清晰地呈现。我把这些变量放在一起，因为它们彼此之间有很强的相关性。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="be0f" class="jn jo hi jj b fi jp jq l jr js">data['thresh1'] = 1000*(0.368866*data['education']+0.351885*data['occup'])</span><span id="2366" class="jn jo hi jj b fi jt jq l jr js">data['thresh2'] = 1000*(0.447396*data['marital']+0.453578*data['relatnip'])</span></pre><p id="3d01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用了很多算法测试。最后我选择了梯度提升，尽管它在训练数据上表现不佳。然而，与决策树和随机森林不同，它没有过度拟合的问题。完整的代码和输出可以在Github的<a class="ae jd" href="https://github.com/codebat137/JupyterNoteboooks/blob/master/adult_income.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>