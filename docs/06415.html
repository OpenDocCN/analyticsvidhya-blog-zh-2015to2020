<html>
<head>
<title>New features of Java 14 in practice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 14在实践中的新特性</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/new-features-of-java-14-in-practice-75dbaba25003?source=collection_archive---------19-----------------------#2020-05-21">https://medium.com/analytics-vidhya/new-features-of-java-14-in-practice-75dbaba25003?source=collection_archive---------19-----------------------#2020-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f295de9bc75da8c43ea169efb221af94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zaci8XE14a-xZy2r7U1nqg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@azhar93?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿兹哈鲁尔·伊斯拉姆</a>在<a class="ae iu" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3905" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近发布的JDK 14总共带来了16项主要增强功能。在本文中，我将带您浏览最有趣的部分，大多与语言支持有关。</p><p id="6094" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 1。</strong> <br/>记录(预览功能)可能是一个新版本中最令人印象深刻的部分。这是Java中一种新的类型声明。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7ab1" class="kc kd hi jy b fi ke kf l kg kh">public record User(long id, String name) {}</span></pre><p id="b91d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只用一行代码我们就得到了一个新的final类，它的所有字段都是final。在编译时，<code class="du ki kj kk jy b">record</code>会自动生成样板文件<code class="du ki kj kk jy b">constructors</code>、<code class="du ki kj kk jy b">public get</code>、<code class="du ki kj kk jy b">equals()</code>、<code class="du ki kj kk jy b">hashCode()</code>、<code class="du ki kj kk jy b">toString()</code>。不会有任何设定者，因为所有字段都是最终的。</p><p id="1554" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以开始使用新用户<code class="du ki kj kk jy b">record</code>,就像我们习惯使用类一样:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="a1a7" class="kc kd hi jy b fi ke kf l kg kh">public static void main(String[] args) {<br/>    User user = new User(1L, "Mark");<br/>    user.id();<br/>    user.name();<br/>}</span></pre><p id="7352" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记录作为数据载体，对于支持开箱即用的不变性有严格的限制。</p><p id="8cb3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它们不能是抽象的，扩展任何其他类，甚至它的隐式超类。这是因为<code class="du ki kj kk jy b">record’s</code> API是由它维护的状态定义的，不允许它的组成类修改它。</p><p id="5e3f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">出于同样的原因,<code class="du ki kj kk jy b">record</code>不能有本地方法声明，因为它不能依赖外部逻辑。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5703" class="kc kd hi jy b fi ke kf l kg kh">public native String getSystemTime(); //compilation error<br/><br/>static {<br/>    System.<em class="kl">loadLibrary</em>("nativedatetimeutils");<br/>}</span></pre><p id="7d78" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<code class="du ki kj kk jy b">record</code>不能显式声明实例字段或者有setter方法。只有记录的标题定义了记录值的状态。这就是下面的代码无法编译的原因:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c07c" class="kc kd hi jy b fi ke kf l kg kh">void setId(long id){<br/>    this.id = id; //compilation error<br/>}</span></pre><p id="1d35" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<code class="du ki kj kk jy b">record</code>可以使用您最喜欢的java库之一，比如Gson或Jackson，序列化成JSON:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="6fa1" class="kc kd hi jy b fi ke kf l kg kh">Gson gson = new Gson();<br/><br/>String userJson = gson.toJson(user);<br/>System.<em class="kl">out</em>.println(userJson); //outputs {"id":1,"name":"Mark"}</span></pre><p id="e0d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并反序列化回来:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="67f6" class="kc kd hi jy b fi ke kf l kg kh">User newUser = gson.fromJson(userJson, User.class);<br/>System.<em class="kl">out</em>.println(newUser); //outputs User[id=1, name=Mark]</span></pre><p id="2a60" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个更有趣的事实是每个<code class="du ki kj kk jy b">record</code>的超类是记录本身:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="9434" class="kc kd hi jy b fi ke kf l kg kh">Class&lt;?&gt; superclass = user.getClass().getSuperclass();<br/>System.<em class="kl">out</em>.println(superclass); //class java.lang.Record</span></pre><p id="d494" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不幸的是，<code class="du ki kj kk jy b">records</code>不能用作轻量级持久域对象，每个对象代表关系数据库中的一个表。这是因为JPA需要一个记录没有的无参数构造函数。JPA provider必须使用反射来获取和设置实体的字段，这也是不可能的，因为记录的字段是最终的。所以下面的代码不会编译:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2b4c" class="kc kd hi jy b fi ke kf l kg kh">@Entity<br/>public record User(long id, String name) { //compilation error<br/><br/>}</span></pre><p id="8b18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您将需要继续使用旧的已知龙目语:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="cb16" class="kc kd hi jy b fi ke kf l kg kh">@Getter<br/>@NoArgsConstructor<br/>@AllArgsConstructor<br/>public class Product {<br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.<em class="kl">IDENTITY</em>)<br/>    private Long id;<br/><br/>    @Size(max = 40)<br/>    private String name;<br/>}</span></pre><p id="68af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。模式匹配为</strong> <code class="du ki kj kk jy b">instanceof</code> <strong class="ix hj">【预览】</strong></p><p id="12f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Java 14之前，如果你想做<code class="du ki kj kk jy b">instanceof</code>检查，然后把对象转换成一个变量，你应该做以下事情:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c73a" class="kc kd hi jy b fi ke kf l kg kh">if (obj instanceof User) {<br/>    String s = (User) obj;<br/>    // use s<br/>}</span></pre><p id="9fc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Java 14中，这可以简化为一行:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5b6c" class="kc kd hi jy b fi ke kf l kg kh">if (obj instanceof String s) {<br/>    // can use s here<br/>}</span></pre><p id="d0c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管在大多数情况下您可能会尝试一个新特性，但是您仍然应该避免在产品代码中使用<code class="du ki kj kk jy b">instanceof</code>。多态性的良好使用应该优先于条件的基本使用。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="bff3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。文本块(第二次预览)</strong></p><p id="f0eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个特性给Java语言增加了<code class="du ki kj kk jy b">text blocks</code>。文本块是由多行组成的字符串文字。使用<code class="du ki kj kk jy b">text blocks</code>有助于避免大多数转义序列、字符串连接。总的来说，它简化了编写程序的过程，使得用几行源代码来表达字符串变得容易。</p><p id="1477" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java 14之前:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f6c7" class="kc kd hi jy b fi ke kf l kg kh">String someHtml = "&lt;html&gt;\n" +<br/>        "   &lt;body&gt;\n" +<br/>        "      &lt;p&gt;Hello World&lt;/p&gt;\n" +<br/>        "   &lt;/body&gt;\n" +<br/>        "&lt;/html&gt;\n";</span></pre><p id="6f58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用Java 14:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5fbc" class="kc kd hi jy b fi ke kf l kg kh">String java14 = """<br/>                &lt;html&gt;<br/>                    &lt;body&gt;<br/>                        &lt;p&gt;Hello World&lt;/p&gt;<br/>                    &lt;/body&gt;<br/>                &lt;/html&gt;<br/>        """;</span></pre></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="114f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 4。开关表达式</strong></p><p id="957b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Java 12和Java 13中，<code class="du ki kj kk jy b">Switch Expressions</code>是一个预览特性，从Java 14开始，它已经成为一个标准的语言特性。新开关可以用作使用箭头语法的表达式:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5af2" class="kc kd hi jy b fi ke kf l kg kh">switch (article.state()) {<br/>    case <em class="kl">DRAFT </em>-&gt; System.<em class="kl">out</em>.println(1);<br/>    case <em class="kl">PUBLISHED </em>-&gt; System.<em class="kl">out</em>.println(2);<br/>    case <em class="kl">UNKNOWN </em>-&gt; System.<em class="kl">out</em>.println(3);<br/>}</span></pre><p id="f0ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java 14之前:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f8c8" class="kc kd hi jy b fi ke kf l kg kh">switch (article.state()) {<br/>    case <em class="kl">DRAFT</em>:<br/>        System.<em class="kl">out</em>.println(1);<br/>        break;<br/>    case <em class="kl">PUBLISHED</em>:<br/>        System.<em class="kl">out</em>.println(2);<br/>        break;<br/>    case <em class="kl">UNKNOWN</em>:<br/>        System.<em class="kl">out</em>.println(3);<br/>        break;<br/>}</span></pre><p id="3a17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在可以产生/返回值了</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b263" class="kc kd hi jy b fi ke kf l kg kh">int result = switch (article.state()) {<br/>    case <em class="kl">DRAFT </em>-&gt; 6;<br/>    case <em class="kl">PUBLISHED </em>-&gt; 7;<br/>    case <em class="kl">UNKNOWN </em>-&gt; 8;<br/>};</span></pre><p id="d5d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java 14之前:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="a9eb" class="kc kd hi jy b fi ke kf l kg kh">int result;<br/>switch (article.state()) {<br/>    case <em class="kl">DRAFT</em>:<br/>        result = 6;<br/>        break;<br/>    case <em class="kl">PUBLISHED</em>:<br/>        result = 7;<br/>        break;<br/>    case <em class="kl">UNKNOWN</em>:<br/>        result = 8;<br/>        break;<br/>    default:<br/>        throw new UnsupportedOperationException();<br/>}</span></pre></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="2ce7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 5。有用的NullPointerExceptions </strong></p><p id="9e67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个特性将有助于更快地跟踪和解决JVM产生的NullPointerExceptions。在Java 14之前，这些消息根本不提供信息:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="07f8" class="kc kd hi jy b fi ke kf l kg kh">public static void main(String[] args) {<br/>    User user = new User(1L, null);<br/><br/>    System.<em class="kl">out</em>.println(<em class="kl">toUpperCase</em>(user));<br/>}<br/><br/>private static String toUpperCase(User user) {<br/>    return user.name().toUpperCase(); // produces NPE<br/>}</span></pre><p id="c2c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该消息将类似于:</p><p id="eb1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kl">演示时线程“main”Java . lang . nullpointerexception<br/>出现异常。Main.main(Main.java:16)" </em></p><p id="a747" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过新的增强功能，将“XX:+ShowCodeDetailsInExceptionMessages”添加到虚拟机选项将使消息看起来像:</p><p id="ed02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kl">线程“main”中出现异常java.lang.NullPointerException:无法调用“String.toUpperCase()”，因为“test。在演示时，User.name()"为空<br/>。演示时的main . toupper case(main . Java:20)<br/>。Main.main(Main.java:16) </em></p><h2 id="85aa" class="kc kd hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated">摘要</h2><p id="be1e" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">Java 14最新特性的概述到此结束。现在，您已经掌握了Java世界中最新特性的知识和实践经验。我希望你喜欢这篇文章，并发现它很有用。坚持练习，因为明天的战斗是在今天的练习中赢得的！</p></div></div>    
</body>
</html>