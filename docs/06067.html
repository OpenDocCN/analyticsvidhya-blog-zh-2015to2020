<html>
<head>
<title>Categorical Encoding Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分类编码方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/categorical-encoding-methods-535b5c289512?source=collection_archive---------24-----------------------#2020-05-10">https://medium.com/analytics-vidhya/categorical-encoding-methods-535b5c289512?source=collection_archive---------24-----------------------#2020-05-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0ac142ab1139fd7dfb76addc5785585a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MVfN_Sz9z83YSapK"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">尼克·希利尔在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="660f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博客中，我们将探讨为什么我们需要分类编码和不同的方法来对变量进行分类编码。</p><p id="5beb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顾名思义，对分类类型的变量执行分类编码。这意味着变量中的每个类别都被分配了一个数值来表示实际值。编码是必需的，因为大多数机器学习算法不能处理分类值。它们需要数值才能发挥作用，有时算法的性能取决于编码的执行方式。</p><p id="60f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有各种方法来执行编码，例如</p><ol class=""><li id="aba3" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">一个热编码。</li><li id="9f57" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">标签/序数/整数编码。</li><li id="efed" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">频率或百分比编码。</li><li id="b57c" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">平均编码。</li><li id="2e18" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">概率比编码。</li></ol><p id="57a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数时候，在解决方案中使用一种热编码或标签编码。我们将讨论这些编码方法是什么，以及python中可以用来实现这些方法的库。</p><ol class=""><li id="5669" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><strong class="ix hj">一个热编码</strong> —这里分类变量的每个值都有自己的列。该列为布尔类型，根据记录是否包含值，包含1和0。1表示该值存在，否则为0。这种方法有几个优点，因为它覆盖了变量的所有值，并且变量几乎没有信息损失。然而，当基数变量很高时，缺点就很明显了。在这种情况下，它会增加数据集中的列数，从而增加数据集的大小。Python实现可以通过使用pandas的<a class="ae iu" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.get_dummies.html" rel="noopener ugc nofollow" target="_blank"> getdummies( ) </a>方法或scikit-learn的<a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank"> OneHotEncoder( ) </a>方法来实现。这两者之间的一个重要区别是，pandas库不负责在训练集和测试集中保持相同的列，但scikit-learn会这样做。但是，scikit-learn不返回数据帧，而是返回一个数组。</li><li id="d072" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hj">标签/序数/整数编码</strong> —在标签编码中，分类值被赋予任意整数。无论如何，这个数字和这个数字所属的类别没有任何关系。这种方法很快，但会带来一个问题，即算法可能会将列的编码值作为序号，并假定这些值之间的关系是有序的。该方法不会添加任何新信息，如果有新的类别添加到列中，结果可能会很糟糕。标签编码可以通过scikit-learn库中的<a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html" rel="noopener ugc nofollow" target="_blank"> LabelEncoder( ) </a>方法来实现。</li><li id="1bf5" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hj">频率或百分比编码</strong> —该方法用具有值的观察值数量或观察值百分比替换类别。这将捕获所有的类别表示。这对于基于树的方法很有效。但是，这种方法有一些缺点，因为它涉及到以频率或百分比的形式为一个类别分配数字。因此，如果有两个类别具有相同的频率或百分比值，它们将被赋予相同的值，这可能导致一些信息丢失。要用python实现这一点，我们需要使用value_counts()方法计算这些值，然后用结果替换实际的类别值。</li><li id="d635" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hj">平均值编码</strong> —此处类别被替换为目标变量相对于类别值的平均值。这种方法很快，可以处理回归问题。但是，当两个类别具有相同的平均值并导致相同的赋值时，可能会出现潜在的信息丢失。该实现相对较快，并且涉及目标变量相对于类别的平均值的计算，并且可以通过group by来完成。</li><li id="efb7" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hj">概率比编码</strong> —这种方法最有可能用于二进制分类的情况。它包括计算目标变量为真的概率或类别为1的概率以及目标为假/ 0的概率。然后计算两者的比率，并用该比率替换类别值。这意味着比率[P (1) / 1 — P (1)]。这种方法的python实现需要使用group by函数。同样，这也适用于二元分类的情况。</li></ol><p id="3b6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">任何编码方法都应该首先应用于训练集，然后使用相同的输出对测试集进行编码以保持一致性，否则会导致不同的输出。</p></div></div>    
</body>
</html>