<html>
<head>
<title>III. Creating profitable trading strategies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">三。创造有利可图的交易策略</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/iii-creating-profitable-trading-strategies-1858a2fc8b85?source=collection_archive---------9-----------------------#2020-12-28">https://medium.com/analytics-vidhya/iii-creating-profitable-trading-strategies-1858a2fc8b85?source=collection_archive---------9-----------------------#2020-12-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="e624" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">得益于深度学习模型的两种盈利方式。</p></blockquote><p id="ea34" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi jj translated">本文是描述创建、回溯测试和部署交易机器人的分步过程的系列文章的一部分。第一篇文章关注的是<strong class="ik hi">计算预测变量</strong>，而第二篇文章关注的是<strong class="ik hi">构建深度学习模型</strong>，第三篇文章关注的是<strong class="ik hi">用模型识别有利可图的交易策略</strong>，最后一篇文章关注的是程序中的实际实现(<strong class="ik hi">部署</strong>)。本文末尾给出了链接。</p><p id="c931" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">既然我们已经用训练集建立了模型，并在验证集上对它们进行了比较(文章II — [1])，我们将在全新的数据(测试集)面前对2个策略进行回测。<strong class="ik hi">第一种方法</strong>是简单地从验证集中挑选出表现最好的模型，并在它预测到看涨趋势时遵循它的建议(<em class="ij"> preds = 1 </em>)。<strong class="ik hi">第二种方法</strong>更加进化:我们寻找阈值<em class="ij"> l </em>，这样我们可以在选择最佳模型预测概率高于<em class="ij"> l的时间步长时产生最高的ROI，即我们寻找<em class="ij"> l </em>的</em>，这样将我们的交易限制在<em class="ij"> proba_best_model &gt; l </em>产生最佳利润的情况下。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="da2a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><strong class="ik hi"> 0 —加载库和数据集</strong></p><p id="be0e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><strong class="ik hi"> I —定义回测函数</strong></p><p id="166d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><strong class="ik hi">II——一个简单的策略:选择我们最好的模型，在看涨时跟随它</strong></p><p id="495b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><strong class="ik hi">III——更先进的战略</strong></p><p id="02c1" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><strong class="ik hi">四—结论</strong></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="c69d" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">0-加载库和数据集</h1><p id="0ccf" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is jg kz iv iw jh la iz ja ji lb jd je jf ha bi translated">和前两篇文章一样，我们首先需要导入库、数据，并定义常数(更多细节见其他文章)。特别是我们定义了<strong class="ik hi"><em class="ij"/></strong><strong class="ik hi"><em class="ij">止盈</em> </strong>，<strong class="ik hi"><em class="ij">NPC的列表</em> </strong> <em class="ij"> </em>，我们在构建模型的时候进行比较。为了进行回溯测试，我们还需要为每笔交易设置<strong class="ik hi"> <em class="ij">费用</em> </strong>的值:在波洛涅克斯[2]交易所的情况下，这些费用大约是0.125%，但是您可以根据自己的情况调整这个值。我们还定义了<strong class="ik hi"> <em class="ij">最小交易数</em> </strong> <em class="ij"> </em>来考虑第二种方法中的策略(50笔交易是一个好的阈值)。初始化代码如下所示:</p><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图1:数据加载和初始化</figcaption></figure><h1 id="32f1" class="jz ka hh bd kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks lr ku kv kw bi translated">I —为回溯测试定义函数</h1><p id="8150" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is jg kz iv iw jh la iz ja ji lb jd je jf ha bi translated">一旦我们导入了数据，现在就该创建两个回溯测试函数了。第一个是计算收益和损失的函数，给定一组特定的<em class="ij">止损</em>、<em class="ij">止盈</em>和交易<em class="ij">费用</em>。这一步很重要，这样我们的回溯测试才能与现实生活中的交易条件保持一致。</p><p id="1d60" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">第二个功能实际上是回溯测试功能。它将测试集作为输入，我们想要回测的模型，以及我们的常量。<strong class="ik hi">然后计算测试集上的预测，并在名为<em class="ij">' earnings bully '</em></strong>的列中计算回测收益。当我们试图构建一个<em class="ij">看涨</em>的交易机器人时，我们过滤掉<em class="ij">看跌</em>的预测(<em class="ij"> preds = 0 </em>)。用我们的止损和止盈设置，我们可以看看计算后这个柱的样子。我们记得'<em class="ij">结果</em>是地面真实结果，而'<em class="ij">预测值</em>是模型的预测值:</p><figure class="lc ld le lf fd lg er es paragraph-image"><div class="er es ls"><img src="../Images/21c2fae38e556bae81090df78f6f24c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*LxdkMt3B54helavFy6NrFg.png"/></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图2:盈利看涨栏的概述</figcaption></figure><p id="6745" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">生成回溯测试的代码如下所示:</p><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图3:定义收入计算的函数</figcaption></figure><h1 id="d7aa" class="jz ka hh bd kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks lr ku kv kw bi translated">一个简单的策略:选择我们最好的模型，在看涨时跟随它</h1><p id="f4b5" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is jg kz iv iw jh la iz ja ji lb jd je jf ha bi translated">一旦我们定义了回溯测试函数，我们可以试着看看第一种方法。这种方法只是简单地跟随最佳模型的看涨预测。然后我们显示<strong class="ik hi"><em class="ij"/></strong>(利润和损失)概况、<strong class="ik hi">进入点</strong>，以及<strong class="ik hi"> <em class="ij"> ROI </em> </strong>(投资回报)。最后，我们不妨评价一下，性能到底棒到什么程度。为了做到这一点，我们将该方法的表现与测试期间的平均回报进行比较(止损<em class="ij">止损</em>和止盈<em class="ij">止盈</em>):也就是说，如果我们总是在测试集的每个时间步押注<em class="ij">看涨</em>，我们就会看到预期回报。使用这种技术，我们可以真正评估我们的方法的性能，不受市场条件的影响。我们将获得一个名为<em class="ij"> avg_return_benchmark </em>的指标，并将其与我们的性能进行比较。为此，我们通过<em class="ij">t-test</em>【3】与平均基准进行比较，测试我们性能的统计显著性。</p><p id="ff39" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">性能优于基准测试，<strong class="ik hi">当我们进行t检验(p值&lt; &lt; 0.05) </strong>时，它甚至是有意义的。</p><p id="dd0b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">在我们的例子中，我们得到的是这样的:</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/7634702deb8822ac2f3d176a7560d5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKyKd4cDui13QWenQigiDg.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图4:我们的最佳模型在测试集上的PnL演化</figcaption></figure><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/cbee9a8cac6e3dce2cb9ea92a1bfdcd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqUxs0mTQjF9dr5Afsk1Lg.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图5:最佳模型的入口点</figcaption></figure><figure class="lc ld le lf fd lg er es paragraph-image"><div class="er es ma"><img src="../Images/86c93be20d28dba4657e3063cda1064c.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*zNow2Au2-OY4I2agEeWPNw.png"/></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图6:评估性能的重要性</figcaption></figure><p id="9e5f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">我们甚至可以放大到2020年的前3个月，以更好地捕捉交易机器人的相关性。我们可以看到，交易机器人在正确的时间进行了有利可图的押注，并在市场崩溃时不再看涨。如果我们在那里使用它，它首先会让我们赢钱，其次会避免损失一些钱:</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/ef07040e2108252b541a8033488588c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QH1mjvOFhDuOq-rIKivvMA.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图7:2020年1月至3月期间放大的方法1</figcaption></figure><p id="cfbb" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">出于信息目的，这种方法在测试集上产生了3.3698% 的每笔交易的<strong class="ik hi">投资回报率，其中<strong class="ik hi"> 897笔交易</strong>被执行，516笔交易最终实现了止盈(<strong class="ik hi"> 57.52%的准确率</strong>)。</strong></p><p id="a8fe" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">生成和回溯测试第一个策略的代码如下:</p><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图6:创建并评估第一种方法</figcaption></figure><h1 id="cd05" class="jz ka hh bd kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks lr ku kv kw bi translated">III——更先进的战略</h1><p id="a5ff" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is jg kz iv iw jh la iz ja ji lb jd je jf ha bi translated">如前所述，第二种方法的原理可以总结如下:<strong class="ik hi">我们选择最佳模型，并寻找阈值<em class="ij"> l </em>，以便将交易限制在<em class="ij">proba _ bully&gt;l</em>产生最有利可图的策略</strong>的情况下。为此，我们需要在<strong class="ik hi"><em class="ij">validation _ set</em></strong>上评估最佳模型，否则该方法将无法推广。第一步是创建一个函数，该函数创建一个像这样的摘要表(<em class="ij">图8 </em>)，我们可以显示它以供说明(<em class="ij">图9 </em>):</p><figure class="lc ld le lf fd lg er es paragraph-image"><div class="er es mb"><img src="../Images/5307113af0d1c05932df5860c89a16f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*uhxZ7WITqT4Q0pattZufJQ.png"/></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图8:验证集上最佳模型的每个部分的概要表</figcaption></figure><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/2e5f4e7dbbaadb30019b9568faa71058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAFOhHirD9wg4CI-mIGtqw.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图9:引用表的绘制:当l = 0.95时，ROI最大</figcaption></figure><p id="5c35" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">一旦我们计算并保存了这个表，我们只需选择产生最佳ROI的阈值。在我们的示例中，我们可以看到最佳阈值是<em class="ij"> l =0.95 </em>。然后，我们可以在测试集上评估这种策略(保持预测where<em class="ij">proba _ best _ model&gt;0.95</em>)，以便我们可以看到这种方法如何在全新的数据上执行。我们观察到<strong class="ik hi">该策略再次产生了巨大的利润，投资回报率甚至比第一种方法更高(3.41%比2.90%) </strong>。所有这些观察结果都倾向于证实我们方法的稳健性和有效性。</p><p id="90a2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">另外，<strong class="ik hi">性能也很有意义(p值&lt; &lt; 0.05) </strong>，这是很棒的一点:</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/ac1b6dcd555fae5a337040b78496b570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P7OKZRyc1avAyBBWGWfNg.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图10:第二种方法在测试集上的PnL</figcaption></figure><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/04bcb76d62bf90fbd2d0e664762b7648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XLPHLXB3dWMBSRBIZ1QHnA.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图11:第二种方法的入口点</figcaption></figure><figure class="lc ld le lf fd lg er es paragraph-image"><div class="er es mc"><img src="../Images/057161158dda24644c2459f123a66d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*eCbuMab04bxnxEe_N97iIQ.png"/></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图12:评估性能的重要性</figcaption></figure><p id="c21b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">在第一种方法中，我们可以在第一个月中放大以查看这种交易机器人的相关性:</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/34e994c70777c6c174ca6e02544d356e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rd3lURjWx5V7xx_2jU5CQ.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图13:2020年1月至3月期间的方法2放大图</figcaption></figure><p id="c15d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">当我们查看这种方法的统计数据时，我们可以注意到，它比我们之前介绍的第一种方法更具选择性。在相同的测试期间，它花费了<strong class="ik hi">更少的交易</strong>，并且有了<strong class="ik hi">更好的成功率</strong>。</p><p id="e55b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">这种方法在测试集上产生了4.1668% 的每笔交易的<strong class="ik hi">投资回报率，进行了<strong class="ik hi"> 498笔交易</strong>，最终有313笔交易达到了止盈(<strong class="ik hi"> 62.85%的准确率</strong>)。</strong></p><p id="c7b2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">生成第二种方法的代码写在那里:</p><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图14:创建第二种方法</figcaption></figure><h1 id="33b5" class="jz ka hh bd kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks lr ku kv kw bi translated">四、结论</h1><p id="640d" class="pw-post-body-paragraph ih ii hh ik b il kx in io ip ky ir is jg kz iv iw jh la iz ja ji lb jd je jf ha bi translated">首先，我们可能记得完整的代码可以在资源库[4]中找到。我甚至做了一个名为<strong class="ik hi"><em class="ij">Pipeline _ I _ to _ iii . py</em></strong><em class="ij"/>【5】的脚本:你只需要设置<em class="ij">止损</em>、<em class="ij">止盈</em>、<em class="ij">拆分日期</em>和<em class="ij">数据集位置</em>，管道自动完成所有步骤(变量计算、PCA、建立模型、评估、识别盈利策略)！通过使用与我在本系列文章中使用的完全相同的数据集(也可以在资源库中找到)，您最终会发现完全相同的结果。</p><p id="2922" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">在这篇文章中，我们创造了两个有利可图的交易策略。这些策略的表现优于基准指标——即<em class="ij">即</em>它们是准确的，产生了足够的利润——甚至产生了显著的结果。我们检查了这些策略在全新的数据上产生的利润，这表明它们在现实生活中的实施从长远来看也会产生利润。</p><p id="dda7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">值得注意的是，我们可以观察到该模型不再预测任何<em class="ij">看涨</em>趋势，因为BTC价格已经突破15k美元:这可能是因为我们的数据集不是<em class="ij">平稳的</em>。该模型认为，在列车运行期间，价格会降至其通常值。<strong class="ik hi">我们可以避免这个问题，首先让它保持稳定，针对短期波动改变止损/止盈，或者更简单地说，增加一些标准化的控制变量，如MACD。</strong>然而，如果我们将管道应用于多年来一直处于有限范围内的资产，问题可能会自行解决。此外，由于交易机器人的目的是押注<em class="ij">短期</em>趋势，而不是长期投资，这不是一个大问题。我们还可以观察到，模型预测看涨趋势的最近时间是高度准确的(<strong class="ik hi">高<em class="ij">选择性</em> </strong>)。</p><p id="6eab" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">现在我们已经确定并测试了我们的策略，我们可能希望在现实交易中实施它们。这正是下一篇文章(第四篇)的目的，它将揭示如何在Python中部署这样的交易机器人。交易机器人将使用加密货币交易平台Poloniex API开发。然而，该框架可以很容易地适应任何其他API或编码系统。</p><p id="46fb" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">另外，我写的关于高级交易机器人的论文全文可以在[6]找到。不要犹豫留下任何反馈/问题/ <em class="ij">掌声</em>或联系我以获取更多信息。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="99f0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><strong class="ik hi">联系人:</strong> sebcararo@hotmail.fr</p><p id="2b3b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><strong class="ik hi">系列其他文章:</strong></p><ul class=""><li id="8df3" class="md me hh ik b il im ip iq jg mf jh mg ji mh jf mi mj mk ml bi translated"><a class="ae mm" rel="noopener" href="/analytics-vidhya/i-a-turnkey-python-code-for-creating-a-stock-forecasting-dataset-ad25f673f3b7"> I .用于创建股票预测数据集的交钥匙Python代码|作者sébastien Cararo | Analytics vid hya | 2020年12月| Medium </a></li><li id="71f3" class="md me hh ik b il mn ip mo jg mp jh mq ji mr jf mi mj mk ml bi translated"><a class="ae mm" rel="noopener" href="/analytics-vidhya/ii-forecasting-crypto-tendencies-with-deep-learning-in-python-5948909617db">二。利用Python中的深度学习预测加密趋势|作者sébastien Cararo | Analytics vid hya | 2020年12月| Medium </a></li><li id="b5d0" class="md me hh ik b il mn ip mo jg mp jh mq ji mr jf mi mj mk ml bi translated"><a class="ae mm" rel="noopener" href="/analytics-vidhya/iv-deploy-a-poloniex-trading-bot-c3af87eba48c">四。部署Poloniex交易机器人|作者:sébastien Cararo | Analytics vid hya | 2020年12月| Medium </a></li></ul><p id="22b3" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><strong class="ik hi">另一篇文章</strong> <em class="ij">(用机器学习构建体育博彩算法)</em> <strong class="ik hi"> </strong> <a class="ae mm" rel="noopener" href="/analytics-vidhya/how-covid-19-prevented-me-from-being-a-millionnaire-in-2020-5b2144e8bdef">新冠肺炎如何阻止我在2020年成为百万富翁|作者sébastien Cararo | Analytics vid hya | 2020年12月| Medium </a></p><p id="5352" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><strong class="ik hi">来源:</strong></p><p id="373d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">[1]第二条</p><p id="ed30" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><a class="ae mm" rel="noopener" href="/analytics-vidhya/ii-forecasting-crypto-tendencies-with-deep-learning-in-python-5948909617db">二。利用Python中的深度学习预测加密趋势|作者sébastien Cararo | Analytics vid hya | 2020年12月| Medium </a></p><p id="7a37" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">[2]波兰交易所</p><div class="ms mt ez fb mu mv"><a href="https://poloniex.com/exchange/USDT_BTC" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hi fi z dy na ea eb nb ed ef hg bi translated">加密资产交易所</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">购买、出售和交易比特币(BTC)、以太坊(ETH)、创(TRX)、系绳(USDT)以及市场上最好的替代币</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">poloniex.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj lt mv"/></div></div></a></div><p id="4d38" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">[3] T检验</p><div class="ms mt ez fb mu mv"><a href="https://www.scribbr.com/statistics/t-test/" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hi fi z dy na ea eb nb ed ef hg bi translated">T检验介绍|定义、公式和例子</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">t检验是一种统计检验，用于比较两组的平均值。它经常用于假设检验…</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">www.scribbr.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj lt mv"/></div></div></a></div><p id="a005" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">[4]完整代码</p><div class="ms mt ez fb mu mv"><a href="https://github.com/Seb943/TBpolo/blob/master/Codes/III.AssessAccuracyAndBacktest.py" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hi fi z dy na ea eb nb ed ef hg bi translated">Seb943/TBpolo</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">使用Python和Poloniex API的盈利交易机器人— Seb943/TBpolo</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">github.com</p></div></div></div></a></div><p id="5afa" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">[5]<em class="ij">Pipeline _ I _ to _ iii . py</em>(仍在仓库内)</p><p id="911d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><a class="ae mm" href="https://github.com/Seb943/TBpolo/blob/master/Codes/Pipeline_I_to_III.py" rel="noopener ugc nofollow" target="_blank">位于主SEB 943/TB polo(github.com)的TB polo/Pipeline _ I _ to _ iii . py</a></p><p id="b5b9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated">[6]全文</p><p id="8bbe" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><a class="ae mm" href="https://seb943.github.io/Data/Paper_CreatingATradingBot.pdf" rel="noopener ugc nofollow" target="_blank">https://seb943.github.io/Data/Paper_CreatingATradingBot.pdf</a></p><p id="a7e9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jg iu iv iw jh iy iz ja ji jc jd je jf ha bi translated"><strong class="ik hi">软件:</strong>Pyzo IDE上的Python 3.8.5</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es nl"><img src="../Images/79fb68a1336be5f4abbb0f6fbd835e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jq8ndUzBrLl-ynPtKhppaA.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">图15:封面图片</figcaption></figure></div></div>    
</body>
</html>