<html>
<head>
<title>Clustering Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚类数据</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/clustering-data-2c1b28b72472?source=collection_archive---------23-----------------------#2020-06-08">https://medium.com/analytics-vidhya/clustering-data-2c1b28b72472?source=collection_archive---------23-----------------------#2020-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8da2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，数据聚类就是将数据点划分为数据组，我们将具有相似特征的组分离出来，并将它们分配到聚类中。</p><p id="c4eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们为什么要这么做？好吧，我们试着用一个例子来理解这一点。假设您是一家汽车租赁公司的主管，您想开始为客户提供公司车队的服务。你会怎么做？您可以单独调查每个客户，这将非常耗时且耗费大量资源。研究每笔交易/每名客户的租赁详情，并为他们每个人制定策略，如何？绝对不行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/563764d55a97ff5698b5920a508d00e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*-K5FUhtTSwhtEpBsx5Isug.png"/></div></figure><p id="4d3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是…如果你能把所有的顾客分成三组，比如商务旅客、休闲旅客和学生，那会怎么样呢？现在，您可以针对这些群体定制您公司的车队产品。那就是聚类。我们把商务旅客分成一个部分，度假者分成另一个部分，等等。</p><p id="1555" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们知道了什么是聚类，以及它为什么会有帮助，让我们来讨论一种特定类型的聚类算法:K-Means。</p><p id="b326" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">K-Means是最简单和最流行的无监督机器学习算法之一。无监督的机器学习将仅使用输入变量(也称为自变量)从给定的一组数据中做出推断(我们不会用K-Means预测任何东西)。</p><p id="1dfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">K-Means从一组随机选择的质心开始，作为每个聚类的起始点，然后遍历这些聚类以优化每个质心的位置。当发生以下两种情况之一时，K-Means将停止优化质心:质心已经稳定，这意味着它们的值没有变化，因为聚类成功，或者已经达到我们指定的迭代次数。</p><p id="659d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">K-Means速度很快，可以在数千甚至数百万个数据点上运行，但也有缺点。首先，当一些数据点比其他数据点分布得更密集时，它不能很好地工作。其次，由数据科学家来选择聚类的数量(<em class="jl"> k </em>)，这需要一个明智的定性决策。让我们快速浏览一下为k-means导入适当库的过程，以及一个示例:</p><p id="3dd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤1(导入库):</strong></p><pre class="je jf jg jh fd jm jn jo jp aw jq bi"><span id="9d4c" class="jr js hi jn b fi jt ju l jv jw">import numpy as np <br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from sklearn.cluster import KMeans</span></pre><p id="45b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步(生成一些要使用的数据):</strong></p><pre class="je jf jg jh fd jm jn jo jp aw jq bi"><span id="7a50" class="jr js hi jn b fi jt ju l jv jw">X = -2 * np.random.rand(100,2)</span><span id="634b" class="jr js hi jn b fi jx ju l jv jw">X1 = 1 + 2 * np.random.rand(50, 2)</span><span id="98b4" class="jr js hi jn b fi jx ju l jv jw">X[50:100, :] = X1</span><span id="3d8a" class="jr js hi jn b fi jx ju l jv jw">plt.scatter(X[:, 0], X[:, 1])</span></pre><p id="c83d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码框中，我们生成了100个随机数据点，分成两组，每组50个点。Matplotlib然后为我们绘制数据，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jy"><img src="../Images/12b85456ac2dbfc3ebced22f9f984729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPBA1O939mbc03isqq4EzQ.png"/></div></div></figure><p id="d2be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第三步(K均值和聚类中心):</strong></p><pre class="je jf jg jh fd jm jn jo jp aw jq bi"><span id="e307" class="jr js hi jn b fi jt ju l jv jw">km = KMeans(n_clusters = 2)</span><span id="cc3b" class="jr js hi jn b fi jx ju l jv jw">km.fit(X)</span></pre><p id="c0b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们在上面选择了2的k值，因为我们显然有两个数据集群。</p><pre class="je jf jg jh fd jm jn jo jp aw jq bi"><span id="61c0" class="jr js hi jn b fi jt ju l jv jw">km.cluster_centers_</span></pre><p id="9e43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤4(绘制质心):</strong></p><pre class="je jf jg jh fd jm jn jo jp aw jq bi"><span id="d2b3" class="jr js hi jn b fi jt ju l jv jw">plt.scatter(X[:, 0], X[:, 1])</span><span id="7d8c" class="jr js hi jn b fi jx ju l jv jw">plt.scatter(-1.14772566, -1.0781176, marker = '*', color = 'red', s = 500)</span><span id="4ec6" class="jr js hi jn b fi jx ju l jv jw">plt.scatter(1.85158417, 2.02497047, marker = '*', color = 'green', s = 500)</span><span id="b03b" class="jr js hi jn b fi jx ju l jv jw">plt.show();</span></pre><p id="ea0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码看起来很复杂，但它所做的只是从我们随机生成的数据中绘制出原始的分散点，然后绘制出星形的质心。质心的坐标来自我们在步骤3中运行的km.cluster_centers_ code。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kd"><img src="../Images/685826b9d1d582ef76258f4ee5bd93fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WvRvVZg4Us2UC2O-FHeifQ.png"/></div></div></figure><p id="d76d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第五步(测试):</strong></p><pre class="je jf jg jh fd jm jn jo jp aw jq bi"><span id="2831" class="jr js hi jn b fi jt ju l jv jw">km.labels_</span></pre><p id="3e8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是上面代码的输出:</p><pre class="je jf jg jh fd jm jn jo jp aw jq bi"><span id="7e11" class="jr js hi jn b fi jt ju l jv jw">array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>       0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,<br/>       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,<br/>       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])</span></pre><p id="4337" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在上面看到的是我们散点图的文本版本:一半的数据点在聚类0中，另一半在聚类1中。</p><p id="38ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">K-Means是迄今为止最流行的无监督机器学习算法。理解起来并不复杂，甚至解释起来也不复杂，而且很快给你结果。还有其他更复杂的无监督算法，但K-Means非常适合初学者。试试吧！</p></div></div>    
</body>
</html>