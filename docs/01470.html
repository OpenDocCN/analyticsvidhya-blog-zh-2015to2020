<html>
<head>
<title>Dealing with multiple iterables in Python using zip()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用zip()在Python中处理多个可迭代对象</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dealing-with-multiple-iterables-in-python-using-zip-daa9487956b1?source=collection_archive---------4-----------------------#2019-10-24">https://medium.com/analytics-vidhya/dealing-with-multiple-iterables-in-python-using-zip-daa9487956b1?source=collection_archive---------4-----------------------#2019-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c1bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python的zip()函数创建了一个迭代器，它将聚合两个或更多可迭代对象的元素。zip()映射多个容器的相似索引，这样它们就可以作为一个实体使用。</p><p id="220a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> zip()是可用的内置命名空间。</strong> <br/> <code class="du jd je jf jg b">'zip' in dir(__builtins__)</code> <br/>真实</p><h2 id="c63f" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">zip()接受iterables并返回元组的迭代器，其中第I个元组包含来自每个参数序列或iterables的第I个元素。</h2><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="92c2" class="jh ji hi jg b fi kk kl l km kn">## First example of zip()<br/>atomic_num = [1, 2, 3, 6, 7, 8]<br/>chem_element = ['H', 'He', 'Li', 'C', 'N', 'O']<br/><br/># both iterables passed to zip() are lists<br/>zipped = zip(chem_element, atomic_num)<br/><br/># zipped holds an iterator object<br/>print(type(zipped));<br/>&lt;class 'zip'&gt;<br/><br/># extracting elements <br/>for tup in zipped:<br/>    print(tup)<br/>('H', 1)<br/>('He', 2)<br/>('Li', 3)<br/>('C', 6)<br/>('N', 7)<br/>('O', 8)</span></pre><p id="7851" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，zip(chem_element，atomic_num)返回一个迭代器，它产生(x，y)形式的元组。x值取自化学元素，y值取自原子数量。</p><p id="d70e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们处理像列表、元组或字符串这样的序列，那么iterables肯定是从左到右求值的。然而，对于其他类型的可重复项，我们可能会看到奇怪的行为</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="e455" class="jh ji hi jg b fi kk kl l km kn">## String and list as iterables passed to zip()<br/><br/>s = 'rgb'<br/>colors = ['Red', 'Green', 'Blue']<br/><br/>for t in zip(s, colors):<br/>    print(t)<br/>------<br/>Output:<br/>('r', 'Red')<br/>('g', 'Green')<br/>('b', 'Blue')</span><span id="0df7" class="jh ji hi jg b fi ko kl l km kn">## using zip() with sets<br/>s1 = {12, 13,11}<br/>s2 = {'l', 'm', 'k'}<br/><br/>for t in zip(s1, s2):<br/>    print(t)<br/>--------<br/>Output:<br/>(11, 'k')<br/>(12, 'm')<br/>(13, 'l')</span></pre><p id="9faf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们注意到的集合，数据不是从左到右提取的</p><h2 id="a267" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">处理长度不等的可重复项</h2><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="93e1" class="jh ji hi jg b fi kk kl l km kn">## using zip() with two iterables of unequal length<br/><br/>A = [1, 2, 3, 4, 5]<br/>B = [20, 25, 27]<br/><br/>for t in zip(A, B):<br/>    print(t)<br/>------<br/>Output:<br/>(1, 20)<br/>(2, 25)<br/>(3, 27)</span></pre><p id="ce52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用zip()时，注意iterables的长度很重要。我们作为参数传入的iterables可能长度不同。在这些情况下，zip()输出的元素数量将等于最短iterable的长度。zip()将完全忽略任何更长的可重复项中的剩余元素</p><h2 id="ee39" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">使用itertools.zip_longest()</h2><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="4462" class="jh ji hi jg b fi kk kl l km kn">from itertools import zip_longest<br/>numbers = [1,2,3]<br/>letters = ['a', 'b', 'c', 'd']<br/>floats = [10.1, 11.2, 12.3, 13.4, 14.5, 15.6]</span><span id="771b" class="jh ji hi jg b fi ko kl l km kn">print("Using zip()\n--------------")<br/>for t in zip(numbers, letters, floats):<br/>    print(t)</span><span id="9dda" class="jh ji hi jg b fi ko kl l km kn">print("\nUsing zip_longest()\n-----------------")<br/>for t in zip_longest(numbers, letters, floats):<br/>    print(t)<br/>    <br/>Using zip()<br/>--------------<br/>(1, 'a', 10.1)<br/>(2, 'b', 11.2)<br/>(3, 'c', 12.3)</span><span id="86ef" class="jh ji hi jg b fi ko kl l km kn">Using zip_longest()<br/>-----------------<br/>(1, 'a', 10.1)<br/>(2, 'b', 11.2)<br/>(3, 'c', 12.3)<br/>(None, 'd', 13.4)<br/>(None, None, 14.5)<br/>(None, None, 15.6)</span></pre><p id="5c1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们看到的，使用zip_longest()迭代将继续，直到最长的可迭代次数用完:</p><h2 id="7e78" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">Python 3和2中zip()的比较</h2><p id="78e9" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">Python的zip()函数在该语言的两个版本中工作方式不同。<br/>在Python 2中，zip()返回元组列表<br/>在Python 3中，然而，zip()返回迭代器。</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="785d" class="jh ji hi jg b fi kk kl l km kn">## Python 2.7</span><span id="a125" class="jh ji hi jg b fi ko kl l km kn">X = [1,2,3]<br/>Y = ['a','b','c']</span><span id="2e61" class="jh ji hi jg b fi ko kl l km kn">zipped = zip(X,Y);<br/>print(type(zipped));<br/>print(zipped);</span><span id="0d98" class="jh ji hi jg b fi ko kl l km kn">for t in zip(X,Y):<br/>    print(t)<br/>------<br/>output:<br/>&lt;type 'list'&gt;<br/>[(1, 'a'), (2, 'b'), (3, 'c')]<br/>(1, 'a')<br/>(2, 'b')<br/>(3, 'c')</span><span id="1f6c" class="jh ji hi jg b fi ko kl l km kn">## Python 3.6<br/>X = [1,2,3]<br/>Y = ['a','b','c']</span><span id="d6ca" class="jh ji hi jg b fi ko kl l km kn">zipped = zip(X,Y);<br/>print(type(zipped));<br/>print(zipped);</span><span id="a463" class="jh ji hi jg b fi ko kl l km kn">for t in zip(X,Y):<br/>    print(t) </span><span id="212d" class="jh ji hi jg b fi ko kl l km kn">-------<br/>Output:<br/>&lt;class 'zip'&gt;<br/>&lt;zip object at 0x000002A5A9D1DC08&gt;<br/>(1, 'a')<br/>(2, 'b')<br/>(3, 'c')</span></pre><h2 id="7583" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">在多个可迭代对象上循环</h2><p id="9939" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在多个可迭代对象上循环是Python的zip()函数最常见的用例之一。如果您需要遍历多个列表、元组或任何其他序列，那么您很可能会求助于zip()</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="298f" class="jh ji hi jg b fi kk kl l km kn">##<br/>import numpy as np<br/>s = 'A'*5<br/>n = np.arange(1,6)</span><span id="3c72" class="jh ji hi jg b fi ko kl l km kn">for letter,digit in zip(s,n):<br/>    print("{}{}".format(letter, digit))</span><span id="bcbd" class="jh ji hi jg b fi ko kl l km kn">---------<br/>Output:<br/>A1<br/>A2<br/>A3<br/>A4<br/>A5</span></pre><h2 id="f105" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">并行遍历字典</h2><p id="52a0" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在Python 3.6及更高版本中，字典是有序集合，这意味着它们按照引入时的顺序保存元素。如果您利用了这个特性，那么您可以使用Python zip()函数以一种安全和一致的方式遍历多个字典</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="9aa4" class="jh ji hi jg b fi kk kl l km kn">student = {'name': ['Arjun', 'Ram', 'John'] }</span><span id="1700" class="jh ji hi jg b fi ko kl l km kn">stud_id = {'stud_id': [1,2,3]}</span><span id="7c6b" class="jh ji hi jg b fi ko kl l km kn">for k1, k2 in zip(student, stud_id):<br/>    for v1, v2 in zip(student[k1], stud_id[k2]):<br/>        print(v1, v2)<br/>--------------<br/>Output:<br/>Arjun 1<br/>Ram 2<br/>John 3</span></pre><h2 id="dec4" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">合并两个列表并并行排序</h2><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="5935" class="jh ji hi jg b fi kk kl l km kn">atomic_num = [1, 2, 3, 6, 7, 8]<br/>chem_element = ['H', 'He', 'Li', 'C', 'N', 'O']</span><span id="1ae4" class="jh ji hi jg b fi ko kl l km kn"># Sort data in alphabetic order of chemical element name<br/>data1 = list(sorted(zip(chem_element, atomic_num), key = lambda t : t[0]))<br/>print(data1)</span><span id="47f5" class="jh ji hi jg b fi ko kl l km kn">print("-"*60)<br/># Sort data in descending order of atomin number<br/>data2 = list(sorted(zip(chem_element, atomic_num), key = lambda t : t[1], reverse=True))<br/>print(data2)</span><span id="28db" class="jh ji hi jg b fi ko kl l km kn">---------------<br/>Output:<br/>[('C', 6), ('H', 1), ('He', 2), ('Li', 3), ('N', 7), ('O', 8)]<br/>------------------------------------------------------------<br/>[('O', 8), ('N', 7), ('C', 6), ('Li', 3), ('He', 2), ('H', 1)]</span></pre><h2 id="b129" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">并行处理列表并进行计算</h2><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="965c" class="jh ji hi jg b fi kk kl l km kn">sales = [50000, 56000, 62000, 70000]<br/>cost  = [15000, 15000, 16000, 16000]<br/>month = ['Jan', 'Feb', 'Mar', 'Apr']</span><span id="8312" class="jh ji hi jg b fi ko kl l km kn">for m,s,c in zip(month, sales, cost):<br/>    print(f"For month {m}, Sales : {s}, Cost : {c}, Profit : {s-c}")<br/>-------------<br/>Output:<br/>For month Jan, Sales : 50000, Cost : 15000, Profit : 35000<br/>For month Feb, Sales : 56000, Cost : 15000, Profit : 41000<br/>For month Mar, Sales : 62000, Cost : 16000, Profit : 46000<br/>For month Apr, Sales : 70000, Cost : 16000, Profit : 54000</span></pre><h2 id="0cdc" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">使用zip()构建词典</h2><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="23a1" class="jh ji hi jg b fi kk kl l km kn">keys = ['rainbow', 'traffic', 'apple', 'banana']<br/>values =['vibgyor', ['red', 'green', 'yellow'], ['red', 'green'], 'yellow']</span><span id="f990" class="jh ji hi jg b fi ko kl l km kn">items_dict = dict(zip(keys, values))<br/>print(items_dict)<br/>-----------<br/>Output:<br/>{'rainbow': 'vibgyor', 'traffic': ['red', 'green', 'yellow'], 'apple': ['red', 'green'], 'banana': 'yellow'}</span></pre></div></div>    
</body>
</html>