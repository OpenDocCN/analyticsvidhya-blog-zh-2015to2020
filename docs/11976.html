<html>
<head>
<title>Serverless number crunching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器数字处理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/serverless-number-crunching-cefbfe42d1c3?source=collection_archive---------17-----------------------#2020-12-26">https://medium.com/analytics-vidhya/serverless-number-crunching-cefbfe42d1c3?source=collection_archive---------17-----------------------#2020-12-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ff5b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用AWS lambda、API Gateway和S3构建交互式和可视化的双层全无服务器数字处理应用程序</h2></div><p id="2d83" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几年来，使用flask server部署API端点一直是生产数据产品(ML或其他)的首选方式。对于负载不规则的应用程序，无服务器部署提供了多种优势，如降低成本和维护。在本文中，我们将通过一个这样的应用程序的例子，其中大量的计算负载发生在AWS lambda后端，通过API网关连接到具有交互式散景的前端。JS图形静态托管在AWS S3。前端和后端完全无服务器，具有最大的可扩展性。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/cd6af112b8a28b355b03c5b8096dc503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H4-uWmapxPhPxj1VVQWB1A.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">应用简化方案，由作者绘制</figcaption></figure></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h2 id="bec5" class="kq kr hi bd ks kt ku kv kw kx ky kz la jg lb lc ld jk le lf lg jo lh li lj lk bi translated"><strong class="ak">通用架构</strong></h2><p id="0412" class="pw-post-body-paragraph ix iy hi iz b ja ll ij jc jd lm im jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">为了我们前端的高灵活性，我们将使用准静态网站。“准静态”意味着它没有任何服务器端呈现，只使用最少的客户端javascript来查询API和更新图形。这允许有非常简单和快速的前端。关于主机——只要允许javascript，什么都可以。亚马逊S3上的一个为桶启用了网络托管选项的存储就足够了(参见<a class="ae lq" href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html" rel="noopener ugc nofollow" target="_blank">S3上的静态托管</a>)。</p><p id="a072" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我们将图形和用户界面从后端移除，它唯一的任务就是接收输入、处理数据并提供响应。AWS lambda函数可以做到所有这些，只要我们符合它的限制。好处包括高可扩展性、无需维护服务器，以及Lambda免费层(与普通AWS免费层不同，它不仅适用于新用户，而且不会在1年后过期)。关键问题是你的应用程序是否适合lambda用例，因为我们在谈论实际的数字处理，而不仅仅是查询腌ML模型——情况并不总是这样。那么，主要的局限性是什么呢？以下是最重要的:</p><ul class=""><li id="1ff9" class="lr ls hi iz b ja jb jd je jg lt jk lu jo lv js lw lx ly lz bi translated">执行时间限制为900秒(注意默认值只有3秒，我的基准代码很容易达到这个限制)</li><li id="db1f" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">内存限制为128到3008 Mb</li><li id="02ce" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">依赖项(默认运行时几乎没有预装包，管理依赖项有点麻烦，最大部署包250 Mb解压缩)</li><li id="bc92" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">关于<a class="ae lq" href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html" rel="noopener ugc nofollow" target="_blank"> AWS </a>的完整限制列表</li></ul><p id="c311" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，AWS Lambda Python运行时包含最少的库。使用Python进行任何模拟的任何东西都可能需要一些公共库，如numpy、Scipy或ML库，如scikit-learn、pyTorch等。</p><p id="249c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在AWS lambda上获得依赖关系并不像在Azure或GCP等其他平台上那样简单，在这些平台上，一个简单的<em class="mf"> requirements.txt </em>就可以完成这项工作。</p><p id="ca82" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在AWS上，你要么需要提供本地安装的库，要么通过lambda层使用。对于本地安装选项，您需要在一个压缩文件夹中提供库以及其余的代码。确保遵守256 Mb的文件夹大小限制，并且您的代码和依赖项可以与lambda运行时环境的其余部分一起平稳运行。</p><p id="1458" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最好的方法是下载amazon Linux的docker映像，并测试其中的所有内容。这个主题被其他一些作者很好地涵盖了(一个基本的指令，更多的<a class="ae lq" href="https://blog.quiltdata.com/an-easier-way-to-build-lambda-deployment-packages-with-docker-instead-of-ec2-9050cd486ba8" rel="noopener ugc nofollow" target="_blank">全面的</a>版本，带有多一点的Docker)</p><p id="bc84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于lambda层，我们将遵循更简单的方法。层是预构建的依赖包，如果您使用AWS本身的依赖包，它们可以保证与运行时的其他部分一起平稳运行。如果一层不能满足你的需求，你可以用五层。通过我们在lambda函数中只留下数字运算的方法，我们的依赖列表可以减少到可行的最小值。更多关于图层的信息可以在<a class="ae lq" href="https://adhorn.medium.com/getting-started-with-aws-lambda-layers-for-python-6e10b1f9a5d" rel="noopener">的介绍帖</a>中找到。</p><p id="f56b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个例子中，我考虑了一个跟踪某个马尔可夫过程的时间演化的代码，其中处于状态<em class="mf"> n </em>的每个对象都有可能保持不变，或者改变到状态<em class="mf"> n-1 </em>或<em class="mf"> n+1 </em>。我们正在观察这类物体集合中的状态数随时间的演化。</p><p id="2ee9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从这个概括的描述中你看到这是一个非常普通的任务，它可以描述任何事情，从化学反应到生态系统中物种之间的平衡。</p><p id="e6d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的特殊情况下，这是一个称为电荷繁殖的过程，它出现在全球从事核物理研究的大型研究实验室中，如CERN (CH)、Brookhaven国家实验室(NY，US)等。理解AWS部分不重要，吹牛而已:)</p><p id="56b6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重要的是，从描述中我们看到所需库的全部范围是非常有限的，用于数组处理的numpy和用于求解微分方程的Scipy是我们唯一需要的东西。</p><p id="3fc3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个组合在AWS上作为一个单独的层很容易获得，例如，作为Python 3.7运行时的AWSLambda-Python37-SciPy1x层。</p><p id="6267" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们需要将lambda函数绑定到我们的前端。虽然lambda可以通过直接的API调用来调用，但这需要AWS凭证，并且在标准实践中，lambda由其他AWS事件(如CloudWatch alarms)调用，或者在这种情况下由专用的AWS服务— API网关调用。API Gateway允许您通过简单的http请求(如GET、POST和GET response)来访问您的lambda。</p><p id="f69d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">毕竟我们的架构看起来如下:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mg"><img src="../Images/6752b456a65e7f082016ad55f01601ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pg_wA2dgI9DPWIiWFQBXKg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者绘制的详细应用方案</figcaption></figure><p id="aaa6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">前端托管在一个S3桶中，使用jquery与API端点对话，使用Bokeh绘制图形，使用bootstrap将我们的UI放在基于列的灵活布局中。我使用可选的AWS route 53为bucket提供DNS别名，但是出于测试目的，一个有意义的S3 bucket名称也很好。</p><p id="1a86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们有API网关将前端和后端绑定在一起。最后，在后端，我们有进行主要模拟的代码，elements.json中的原始数据和一个带有lambda函数处理程序的文件。全部加载为压缩文件夹。通过带有numpy和scipy的单一lambda层来满足依赖性。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h2 id="0d97" class="kq kr hi bd ks kt ku kv kw kx ky kz la jg lb lc ld jk le lf lg jo lh li lj lk bi translated"><strong class="ak">实现</strong></h2><p id="8d7b" class="pw-post-body-paragraph ix iy hi iz b ja ll ij jc jd lm im jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">一旦我们完成了架构，让我们看看实际的实现。先从后端说起。Lambda处理程序，由事件触发的函数做一些简单的事情(参见<a class="ae lq" href="https://github.com/AndyShor/PyCB_AWS" rel="noopener ugc nofollow" target="_blank"> github repo </a>中的完整后端)。</p><p id="f40f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Lambda函数从请求中获取输入值</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="d21f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，它使用我们加载到lambda文件夹(csd.py)的代码中的函数来设置问题，并让scipy求解微分方程系统。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="56bf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦完成，它就以某种形式生成一个响应，该响应将被接受为一个带有适当头的有效响应(稍后将详细介绍)。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="253f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成lambda函数后，创建一个测试事件并检查函数是否按预期返回响应是很有用的。如果您发送一个带有有效“querystring”值的GET请求，它应该会正确响应。</p><p id="0faf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们移到前端。在前端，我们有两个主要动作。</p><p id="737c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.获取所有UI元素的值，创建一个查询字符串并向API发出Get请求</p><p id="91b1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.从API接收数据，并通过用新数据替换旧数据来更新散景图。</p><p id="4508" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们最终的应用程序看起来非常简单，但是它拥有我们需要的所有功能。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mj"><img src="../Images/3afe87760506c3ab67565b6f8bdb4793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kihM1Dm9GEPvDErt_c7onQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">应用程序截图，由作者拍摄</figcaption></figure><p id="3ff3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从表单元素获取值并生成查询字符串几乎不需要解释(这里是对本地部署的服务)。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="4e3a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们开始策划吧。我用散景来绘图，因为我非常喜欢它产生的交互式绘图和它提供的灵活性。客户端绘图有一些替代方案，如<a class="ae lq" href="https://www.chartjs.org/" rel="noopener ugc nofollow" target="_blank"> charts.js </a>，但我发现散景更适合复杂的绘图。通常我在Python中使用它，但是您也可以访问底层的javascript，尽管它似乎功能不太丰富，也没有很好的文档记录。一个地块的最小功能模型可以在BokehJS <a class="ae lq" href="https://docs.bokeh.org/en/latest/docs/user_guide/bokehjs.html" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。为了让散景工作，你需要在你的html前端添加以下链接，注意导入顺序，这很重要。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="230c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在所有的UI元素(基本的html输入)之后，前端包括一个呈现按钮、绘图、查询API和刷新绘图的脚本。用对数x轴建立我们的基本图形如下所示</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="b5fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过清除渲染对象(plot.renderers)列表、根据用户输入更新x坐标范围、添加新线条和相关图例项来实现图形更新</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="c6a3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将把HTML、JS和CSS放入一个启用了虚拟主机选项的S3桶中(按照AWS <a class="ae lq" href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html" rel="noopener ugc nofollow" target="_blank">文档</a>)并做最后的步骤。</p><p id="abff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，为了将前端和后端绑定在一起，我们需要创建一个API网关，它具有与lambda函数集成的功能。创建一个新的REST API网关。然后，在资源中我们需要创建一个GET方法并使用代理集成类型，这样我们的网关就像代理服务器一样工作。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mk"><img src="../Images/b9790d2ed34c6695e5565e9240fdbdb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DD4XAu37CS_iuhdI1bE94A.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">API Gateway AWS控制台截图，作者拍摄</figcaption></figure><p id="9593" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，回应的形式开始发挥作用。您的响应必须有一个响应代码头和一个字符串化的json作为有效负载，否则您将会以错误502“格式错误的响应”结束。</p><p id="5691" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你现在试图通过API invoke URL访问你的lambda，使用像<a class="ae lq" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>这样的http请求测试工具，或者一个简单的终端命令'<em class="mf"> curl api-invoke-url？你应该会收到一个合适的答案。如果你试图通过点击前端的按钮来做同样的事情，你会发现什么都不管用。如果你把地址串从浏览器复制到邮递员，它就工作了。</em></p><p id="f1c2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">怎么了？</p><p id="ce5c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你刚刚和CORS有了第一次接触。如果你使用Chrome，你可以打开开发者工具，在控制台上看到你的前端正在尝试做正确的请求。但是你的浏览器不允许。因为CORS问题。CORS是跨产地资源共享。由于您的前端和API调用URL在不同的域中，浏览器不会让网站与API对话，除非API明确确认该网站被允许这样做。</p><p id="9659" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一项旨在保护用户的安全功能。想象一下，我们的网站看起来不像最基本的HTML演示，而是看起来完全像你的互联网银行界面，而不是联系AWS上的API，它实际上试图代表你的银行作为中间人联系你。CORS就是为了防止这样的事情发生。如果我们想使用它，我们需要在我们的API网关中启用CORS(转到操作—启用CORS)。在那里我们需要指定，哪些请求的来源是允许的(一个特定的网址，或者任何人' * ')。启用CORS将在您的集成中创建另一个名为选项的方法。OPTIONS方法的响应必须在方法响应中至少包括以下标题<code class="du ml mm mn mo b">Access-Control-Allow-Methods, Access-Control-Allow-Headers, Access-Control-Allow-Origin</code>。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mp"><img src="../Images/9d749add05987602e85fe3b58266202e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXQRmajGoNniLPDzK9efxQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">选项方法回复标题，作者截图</figcaption></figure><p id="d679" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在选项集成响应中也应该有一些标题。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mq"><img src="../Images/ab76602bc16c99334071df2a3de12fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5JPvNvfSCGm49nRS6G3Fw.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">选项集成回应标题，作者截图</figcaption></figure><p id="0a22" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的lambda函数响应还必须具有<code class="du ml mm mn mo b">Access-Control-Allow-Origin</code>头(正如你在上面的代码中看到的)。</p><p id="66ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦解决了这个问题(修改后不要忘记重新部署lambda或API gateway)，一切都应该开始工作了。你可以在这里看到我们在<a class="ae lq" href="http://pycb.cloudshore.eu" rel="noopener ugc nofollow" target="_blank">工作的示例项目。源文件可以在</a><a class="ae lq" href="https://github.com/AndyShor/PyCB_AWS" rel="noopener ugc nofollow" target="_blank"> github </a>上找到。</p><p id="5f83" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是了。我们刚刚做到了。托管在无服务器云基础设施上的双层web应用程序。</p><p id="d11d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这样一个有限的努力，这是一个非常健康的流行词汇，并且所有这些都有一个实际的应用案例！</p></div></div>    
</body>
</html>