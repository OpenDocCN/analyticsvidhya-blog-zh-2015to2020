<html>
<head>
<title>One Class Collaborative Filtering (OCCF)— To Predict Whether A User Reads A Book</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一类协同过滤(OCCF)——预测用户是否在阅读一本书</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/one-class-collaborative-filtering-occf-to-predict-whether-a-user-reads-a-book-286ce31a2d9b?source=collection_archive---------3-----------------------#2019-11-20">https://medium.com/analytics-vidhya/one-class-collaborative-filtering-occf-to-predict-whether-a-user-reads-a-book-286ce31a2d9b?source=collection_archive---------3-----------------------#2019-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d876" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最近参加了由加州大学圣地亚哥分校主办的Kaggle竞赛，这是推荐系统和网络挖掘课程的一部分。</p><p id="6c8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">提供了良好阅读数据集的子集，表明用户对书籍的评级。目标是预测给定一个用户和一本书，该用户是否阅读该书。</p><p id="e232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我对3 / 847名学生进行了排名，并通过这篇博文分享了我对这个问题的解决方案。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e41c93e508b7f3bcbd5d1a5bd9cd1b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cSMzdxtZTk0u_qwZ"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="bf64" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">资料组</h1><p id="5448" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">训练数据由200，000个用户-图书交互组成，即11357个独立用户和7170个独立图书的(userID，bookID，rating)三元组。评分范围为0-5分。</p><p id="f752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试数据由20K (userID，bookID)组成。还已知测试集是通过负采样生成的，即对于用户阅读的给定书籍(userID，bookID)，生成负样本(userID，bookID’)，使得用户(userID)没有阅读该书籍(bookID’)。测试数据中没有看不见的用户或书籍。</p><h1 id="7398" class="jw jx hi bd jy jz kz kb kc kd la kf kg kh lb kj kk kl lc kn ko kp ld kr ks kt bi translated">模型</h1><p id="7a92" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">简而言之，我的解决方案是基于潜在因素的单类协同过滤(OCCF)模型，由逻辑回归推动。细节在4个小节中解释。</p><h2 id="7cce" class="le jx hi bd jy lf lg lh kc li lj lk kg iq ll lm kk iu ln lo ko iy lp lq ks lr bi translated">A.一类协同过滤(OCCF)</h2><p id="1c88" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">典型地，潜在因素协同过滤通过嵌入(大小为K的潜在因素)来表示每个用户和书。<br/>假设U[u]和B[b]分别是用户U和图书B的潜在因素。<br/>然后，用户(u)阅读一本书(b)的对数似然性计算如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ls"><img src="../Images/f8401078b57982f4b116bfded29d891e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTH9D3X2aO5YXrDEFnmqYA.png"/></div></div></figure><p id="4563" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了预测读取，我们可以将训练数据中的所有(userID，bookID)对视为正例，将看不见的对视为反例。然而，完美的模型会将所有看不见的配对视为不正确的反例。<br/>不在训练数据中的(userID，bookID)对可能意味着用户对这本书不感兴趣或者他不知道这本书。我们无法区分这两种情况。</p><p id="99be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，OCCF学习因素，以便用户(u)和书(b)的因素之间的内积模拟用户(u)对书(b)的偏好。<br/>我们期望OCCF在训练数据中为(u，b)对输出较高的分数，否则较低。设得分S(u，b) = U[u]。乙[乙]。我们也可以在这里包括偏见条款。</p><p id="c53f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了通过OCCF学习，我们在每个时期重复以下程序:</p><ol class=""><li id="b16c" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">对于每个训练对(u，b) —对看不见的N个负对(u，b’)进行采样。因此，我们有三元组(u，b，b’)。让我们称之为小批量。</li><li id="3bcb" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">对于每个三元组(u，b，b’)，我们将增益定义如下:</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mh"><img src="../Images/7091907dc5674d8547779a629b3cc46a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCrpUzF49cWHel8v3N-pPA.png"/></div></div></figure><p id="a767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.更新参数以通过梯度下降最大化该小批量的平均增益。</p><p id="08f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定测试集中的(u，b)对，我计算了用户u阅读的所有书籍b '的S(u，b ')。让这些分数的最小值为<em class="mi"> Smin </em>。然后，我预测了0 if S(u，b) &lt; 0.50 * <em class="mi"> Smin </em>(当<em class="mi"> Smin </em> &gt; 0)和1 if S(u，b) &lt; <em class="mi"> Smin </em>(当<em class="mi"> Smin </em> &lt; 0)。</p><p id="ffd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用因子大小6、N=20，250个时期、Adam优化器(最初200个时期的学习率为0.01，之后为0.0001)和l 2正则化0.0001来训练该模型。<br/>排行榜和验证准确率约为70-72%。</p><h2 id="1093" class="le jx hi bd jy lf lg lh kc li lj lk kg iq ll lm kk iu ln lo ko iy lp lq ks lr bi translated">B.特征抽出</h2><p id="ec3d" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">以前的模型只依赖于在旅途中学习的潜在特征。从数据中提取了其他几个特征，因为我认为它们有助于改进模型。<br/>对于训练集中的每个(u，b ),我计算了:</p><ol class=""><li id="b532" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">计算用户u阅读的书籍b和所有其他书籍b '之间的Jaccard相似性。取前K个Jaccard相似性的平均值，并将其作为不同K值的特征。我使用K = 3、5和7。</li><li id="dbbd" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">类似于前面的特征，用户u和所有其他阅读书籍b的用户u '之间的相似性</li><li id="fd81" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">书的受欢迎程度——阅读一本书的用户数量与总的互动次数之比。</li><li id="5ebd" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">用户活动——用户阅读的书籍数量与总的互动次数之比。</li></ol><h2 id="5454" class="le jx hi bd jy lf lg lh kc li lj lk kg iq ll lm kk iu ln lo ko iy lp lq ks lr bi translated">C.助推</h2><p id="f064" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">来自OCCF模型的输出预测以及上面提取的特征被输入到逻辑回归模型中。这个想法是通过利用计算出的显式特征来学习和纠正OCCF模型所犯的错误。排行榜和验证准确率约为74–75%。</p><h2 id="8d9c" class="le jx hi bd jy lf lg lh kc li lj lk kg iq ll lm kk iu ln lo ko iy lp lq ks lr bi translated">D.最后一招</h2><p id="e572" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">考虑测试集是如何生成的。对于每个(u，b)对，抽取一个负样本b ’,并将(u，b)和(u，b’)添加到测试集中。因此，对于每个用户来说，有50%已读的书和50%未读的书。</p><p id="c1ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将这一事实用于OCCF模型和逻辑回归模型。<br/>对于OCCF模型，给定测试集中的用户u，我们计算测试集中与用户u一起出现的所有书籍b的S(u，b)。我们将得分最高的50%的书籍标记为已读，其他书籍标记为未读。<br/>对于逻辑回归模型，我们考虑生成的模型概率。对于每个用户，我们将分类器最有把握的50%的书籍标记为已读，其他的标记为未读。</p><p id="a009" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这帮助我在公共排行榜上达到了78.966%的准确率，在私人排行榜上达到了79.885%(排名3)。</p><p id="c150" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">源代码可以在<a class="ae mj" href="https://github.com/tusharsircar95/Bayesian-Personalized-Ranking" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="7e30" class="jw jx hi bd jy jz kz kb kc kd la kf kg kh lb kj kk kl lc kn ko kp ld kr ks kt bi translated">结论</h1><p id="0a8e" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在这个问题中，我应用了一种不同类型的因素模型，这种模型在项目需要相对排名而不是预测评级的情况下非常有用。我还将一个纯粹基于潜在因素的模型与显式特征相结合，以提高准确性。这也是现实生活中可以利用的东西。</p><h1 id="9726" class="jw jx hi bd jy jz kz kb kc kd la kf kg kh lb kj kk kl lc kn ko kp ld kr ks kt bi translated">参考</h1><ol class=""><li id="2898" class="lt lu hi ih b ii ku im kv iq mk iu ml iy mm jc ly lz ma mb bi translated">荣攀等人的《一类协同过滤》。艾尔。(<a class="ae mj" href="http://www.rongpan.net/publications/pan-oneclasscf.pdf" rel="noopener ugc nofollow" target="_blank">http://www.rongpan.net/publications/pan-oneclasscf.pdf</a>)</li><li id="0b79" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">“BPR:来自隐式反馈的贝叶斯个性化排序”。艾尔。(<a class="ae mj" href="https://arxiv.org/pdf/1205.2618.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1205.2618.pdf</a></li></ol></div></div>    
</body>
</html>