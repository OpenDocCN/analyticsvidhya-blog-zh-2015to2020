<html>
<head>
<title>Functions are FUN in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的函数很有趣</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/functions-44d437906a58?source=collection_archive---------17-----------------------#2019-11-25">https://medium.com/analytics-vidhya/functions-44d437906a58?source=collection_archive---------17-----------------------#2019-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="60c5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Python编程</h2></div><p id="87c4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在您的程序 中，经常会出现某段代码<strong class="iz hj"> <em class="jt">重复多次的情况。它或者是字面上的重复，或者只有一些小的修改，包括在同一算法中使用其他变量。还会发生这样的情况，程序员无法抗拒简化工作，并开始使用剪贴板和复制粘贴操作来克隆这样的代码片段。当突然发现克隆的代码中有错误时，可能会非常令人沮丧。程序员将有很多苦差事去寻找所有需要改正的地方。更正导致错误的风险也很高。</em></strong></p><p id="be18" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以定义第一个条件，它可以帮助您决定何时开始编写您自己的函数:<strong class="iz hj"> <em class="jt">如果代码的某个特定片段开始出现在多个地方，请考虑以函数</em> </strong>的形式将其隔离的可能性，该函数是从之前放置原始代码的地方调用的。</p><p id="7aa1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个好的细心的开发人员<strong class="iz hj">将代码</strong>(或者更准确地说:问题)分成隔离良好的片段，并且<strong class="iz hj">以函数</strong>的形式对它们进行编码。</p><p id="a8cd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以陈述第二个条件:<strong class="iz hj"> <em class="jt">如果一段代码变得太大，以至于阅读和理解它可能会产生问题，那么可以考虑把它分成单独的、更小的问题，并以单独函数的形式实现每一个问题。</em> </strong></p><p id="6ac5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">经常发生的情况是，问题是如此之大和复杂，以至于它不能被分配给一个单独的开发人员，一个开发人员团队不得不去解决它。这个问题必须由几个开发人员分担，以确保他们高效、无缝的合作。</p><p id="1cc9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这直接把我们带到了第三个条件:如果你要把工作分配给多个程序员，<strong class="iz hj"> <em class="jt">分解问题，让产品被实现为一组单独编写的功能，打包在不同的模块中。</em> </strong></p><blockquote class="ju jv jw"><p id="af30" class="ix iy jt iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="iz hj">函数从何而来？</strong></p></blockquote><p id="e50a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常它来自三个地方，</p><ul class=""><li id="741b" class="ka kb hi iz b ja jb jd je jg kc jk kd jo ke js kf kg kh ki bi translated">来自python本身</li><li id="630c" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated">来自python的<strong class="iz hj">预装模块</strong></li><li id="89eb" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated"><strong class="iz hj">直接来自你的代码</strong></li></ul><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ko"><img src="../Images/5f6220f180e498f04081d8af4c67fc61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5vAnCSy2b6wWD3P0Roy2A.png"/></div></div></figure><blockquote class="ju jv jw"><p id="8d5f" class="ix iy jt iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="iz hj">怎么做出这样的函数？</strong></p></blockquote><p id="83e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是最简单的函数定义:</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es la"><img src="../Images/acb18fac9f95aeb3094052ca1c7427d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*XvzV8TWcQMeodU65IwySmA.png"/></div></div></figure><ul class=""><li id="a5fb" class="ka kb hi iz b ja jb jd je jg kc jk kd jo ke js kf kg kh ki bi translated">它总是以<strong class="iz hj">关键字</strong> <code class="du lb lc ld le b">def</code>开始(对于<em class="jt">定义</em>)</li><li id="e5cc" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated">在<code class="du lb lc ld le b">def</code>之后是函数的<strong class="iz hj">名称(命名函数的规则与命名变量的规则完全相同)</strong></li><li id="6f4b" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated">在函数名之后，有一对<strong class="iz hj">括号</strong>(这里它们什么也不包含，但是很快就会改变)</li><li id="fd27" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated">该行必须以冒号<strong class="iz hj">结尾</strong>；</li><li id="abce" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated">紧接在<code class="du lb lc ld le b">def</code>之后的一行开始<strong class="iz hj">函数体</strong>——一对(至少一个)必要的<strong class="iz hj">嵌套指令</strong>，每次调用函数时都会执行；注意:<strong class="iz hj">函数在嵌套结束</strong>的地方结束，所以你必须小心。</li></ul><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lf"><img src="../Images/ca1e6a43c471166d1fb0bb023fab5539.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*Lge2CMk14yHTjrduwlidig.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">注意:我们根本不使用这个函数——在代码中没有对它的<strong class="bd lk">调用。</strong></figcaption></figure><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ll"><img src="../Images/7cc376cfa40b3dd973eaecb683a0acf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*Mer6KAVLy1ib4B_PbPWodg.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">运行它时，您会看到以下输出:</figcaption></figure><p id="d817" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着Python读取了函数的定义并记住了它们，但是没有你的允许不会启动它们。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lm"><img src="../Images/620f6ddb6bd4c081c02ade036eec6f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*ydZA14axZDTPFe201A7lGQ.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">我们现在已经修改了代码——我们已经在开始和结束消息之间插入了<strong class="bd lk">函数的调用</strong>:</figcaption></figure><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ln"><img src="../Images/1b1ff9642a14eb9349d2ed3ac25aab3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*Yy_z4jvNdrcOjFe5Pj8PuQ.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">现在输出看起来不同了</figcaption></figure><blockquote class="ju jv jw"><p id="6e5c" class="ix iy jt iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="iz hj">函数如何工作？</strong></p></blockquote><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lo"><img src="../Images/c3a02ac6d707723b2ccd17f027794fb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlC_s01OmGs5_pcgyR6iHA.png"/></div></div></figure><ul class=""><li id="26d8" class="ka kb hi iz b ja jb jd je jg kc jk kd jo ke js kf kg kh ki bi translated">当你<strong class="iz hj">调用</strong>一个函数时，Python会记住它发生的地方，<em class="jt">会跳转到被调用的函数中；</em></li><li id="c6c5" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated">然后执行函数的主体<strong class="iz hj">；</strong></li><li id="8439" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated">到达函数的末尾会强制Python将<strong class="iz hj">返回到调用点之后的位置。</strong></li></ul><p id="7681" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两个非常重要的条件。这是其中的第一个:</p><p id="14be" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你不能调用一个在调用时未知的函数。</p><h1 id="ce30" class="lp lq hi bd lk lr ls lt lu lv lw lx ly io lz ip ma ir mb is mc iu md iv me mf bi translated">记住——Python从上到下阅读你的代码。它不会为了找到一个忘记放在正确位置的函数而向前看(“正确”的意思是“在调用之前”)。)</h1><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mg"><img src="../Images/c73a1c06f8ece255b17b0c28ee7f2ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*c_6_K8UQ9OlN_tqoA_tu2Q.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">不要试图强迫Python去寻找你没有在正确的时间交付的函数。</figcaption></figure><p id="ae67" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个条件听起来稍微简单一点:</p><h1 id="03b0" class="lp lq hi bd lk lr ls lt lu lv lw lx ly io lz ip ma ir mb is mc iu md iv me mf bi translated"><strong class="ak">不能有同名的函数和变量。</strong></h1><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mh"><img src="../Images/04293deecfb75ea5858aeb846a6d6483.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*tW-rQ1RTM1WjCXu2kHHO8w.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">给名称消息赋值会导致Python忘记它以前的角色。名为<code class="du lb lc ld le b">message</code>的功能变得不可用。</figcaption></figure><p id="0806" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当该函数可以配备一个能够接受调用者提供的数据的接口时，它的全部功能就显现出来了。这些数据可以修改函数的行为，使其更加灵活，更能适应不断变化的条件。</p><p id="0088" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参数实际上是一个变量，但有两个重要因素使参数不同且特殊:</p><ul class=""><li id="58f5" class="ka kb hi iz b ja jb jd je jg kc jk kd jo ke js kf kg kh ki bi translated"><strong class="iz hj">参数只存在于已经定义了参数的函数内部</strong>，唯一可以定义参数的地方是<code class="du lb lc ld le b">def</code>语句中一对括号之间的空格；</li><li id="fc19" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated"><strong class="iz hj">在函数调用</strong>时，通过指定相应的参数来为参数赋值。</li></ul><p id="bd5a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住:<strong class="iz hj">在函数定义</strong>中指定一个或多个参数也是一个需求，您必须在调用期间完成它。您必须<strong class="iz hj">提供与定义的参数</strong>一样多的参数。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mi"><img src="../Images/7579cc22b17defa2b2accc5172a40be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*YSFvn-lhvhOkGBXoHXRlyw.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">这个片段说明了这种现象</figcaption></figure><p id="2f84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像这样的情况会激活一个叫做<strong class="iz hj">阴影</strong>的机制:</p><ul class=""><li id="b57a" class="ka kb hi iz b ja jb jd je jg kc jk kd jo ke js kf kg kh ki bi translated">参数<code class="du lb lc ld le b">x</code>隐藏任何同名的变量，但是...</li><li id="b4a3" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated">…仅在定义参数的函数内部。</li></ul><p id="2276" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">名为</strong> <code class="du lb lc ld le b">number</code> <strong class="iz hj">的参数与名为</strong> <code class="du lb lc ld le b">number</code>的变量是完全不同的实体。</p><p id="cf1b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个函数可以有任意多的参数，但是参数越多，就越难记住它们的作用和目的。</p><p id="2922" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">前面介绍的所有函数都有某种效果——它们产生一些文本并将其发送到控制台。</p><p id="7724" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，函数——就像它们的数学兄弟一样——可能会有结果。</p><p id="ef32" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了让<strong class="iz hj">函数返回一个值</strong>(但不仅仅是为了这个目的)，你可以使用<em class="jt">返回</em>指令。</p><p id="6bf4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注意:如果一个函数不打算产生结果，使用</strong> <code class="du lb lc ld le b"><strong class="iz hj">return</strong></code> <strong class="iz hj">指令不是必须的——它将在函数结束时隐式执行。</strong></p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mj"><img src="../Images/f6144ff78b415f5f67424b9aa4382bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*RS5_OJfo6gG3Wr3T7UvESg.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">无论如何，在控件到达函数的最后一行之前，您可以用它来按需终止函数的活动。</figcaption></figure><p id="0fcd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尝试提供<strong class="iz hj"> False </strong>作为参数，并查看结果:happyNewYear(False)</p><p id="4816" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">别忘了:</strong></p><ul class=""><li id="c598" class="ka kb hi iz b ja jb jd je jg kc jk kd jo ke js kf kg kh ki bi translated">你总是<strong class="iz hj">被允许忽略函数的结果</strong>，并对函数的效果感到满意(如果函数有任何效果的话)</li><li id="9b20" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated">如果一个函数想要返回一个有用的结果，它必须包含<code class="du lb lc ld le b">return</code>指令的第二个变体。</li></ul><blockquote class="ju jv jw"><p id="c49c" class="ix iy jt iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="iz hj">说几句不关</strong></p></blockquote><p id="5833" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面给大家介绍一个很好奇的值(说实话是一个none值)名叫<strong class="iz hj"> None </strong>。</p><p id="c06e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它的数据不代表任何合理的价值——实际上，它根本不是一个价值；因此，它<strong class="iz hj">不能参与任何表达式</strong>。</p><p id="d844" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只有两种情况下<code class="du lb lc ld le b">None</code>可以安全使用:</p><ul class=""><li id="d1c3" class="ka kb hi iz b ja jb jd je jg kc jk kd jo ke js kf kg kh ki bi translated">当你<strong class="iz hj">把它赋给一个变量</strong>(或者把它作为<strong class="iz hj">函数的结果</strong>返回)</li><li id="4194" class="ka kb hi iz b ja kj jd kk jg kl jk km jo kn js kf kg kh ki bi translated">当你<strong class="iz hj">将其与一个变量</strong>进行比较，以诊断其内部状态。</li></ul><p id="1ec2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像这里一样:</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mk"><img src="../Images/0d249fa7f172f55a7352a17532ea70e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*ZOoXLZoxuAtKtUn8BBFVnw.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated"><strong class="bd lk">不要忘记这一点:如果一个函数没有使用return expression子句返回某个值，则假定它隐式返回</strong> <code class="du lb lc ld le b"><strong class="bd lk">None</strong></code> <strong class="bd lk">。</strong></figcaption></figure><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ml"><img src="../Images/be698ef054875b4802f345faeb975c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*9uoW_6pTh_bl71pHWKRcrw.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">下次你看到函数结果<code class="du lb lc ld le b">None</code>时不要感到惊讶——这可能是函数内部一个细微错误的征兆。</figcaption></figure><p id="9b64" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python可识别的任何实体都可以扮演函数参数的角色，尽管必须确保函数能够处理它。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mm"><img src="../Images/30d25d4e7a74a808f6e86ecc75b7faf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*q2yuTB9O2YHkEAHjoAm_6g.png"/></div></figure><p id="6c0b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python可以识别的任何实体都可以是函数结果。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mn"><img src="../Images/290a1897219077c62e0796e01c4ab775.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*3NGPvIFautfUrGs0dZU2_g.png"/></div></figure><p id="a0d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">存在于函数外部的变量在函数体内有一个<em class="jt">作用域</em>，不包括那些定义同名变量的函数。</strong></p><p id="4983" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这也意味着存在于函数之外的变量的<strong class="iz hj">范围只有在获取其值</strong>(读取)时才受支持。赋值会强制创建函数自己的变量。</p><p id="40c9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望你现在已经回答了下面的问题:<em class="jt">这是否意味着一个函数不能修改在它之外定义的变量？</em></p><p id="f6e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一个特殊的Python方法可以<strong class="iz hj">扩展一个变量的范围，包括函数体</strong>(即使你不仅想读取值，还想修改它们)。这样的效果是由一个名为<code class="du lb lc ld le b">global</code>的关键词造成的</p><p id="99c1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在带有变量名称(或用逗号分隔的名称)的函数中使用该关键字，可以强制Python避免在函数中创建新变量——将使用可从外部访问的变量。</p><p id="6dda" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，这个名字变成了全局的(它有一个<strong class="iz hj">全局范围</strong>，它是read还是assign的主题并不重要)。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mo"><img src="../Images/f7d033af989ad066cac591bb526ed273.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*iupVsDe18EH60GYITv7-eQ.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">这应该是足够的证据来表明<code class="du lb lc ld le b">global</code>关键字确实实现了它的承诺。</figcaption></figure></div></div>    
</body>
</html>