<html>
<head>
<title>React Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回应面试问题</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/react-interview-questions-272936f3e1fe?source=collection_archive---------11-----------------------#2020-05-14">https://medium.com/analytics-vidhya/react-interview-questions-272936f3e1fe?source=collection_archive---------11-----------------------#2020-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="5686" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">里程碑3 -第4天</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/c14bdbf0bc6515839d720fe88f5436fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*_GHPqt27yGkiYGL4KevOnQ.png"/></div></figure><h2 id="99a3" class="jl ig hi bd ih jm jn jo il jp jq jr ip js jt ju it jv jw jx ix jy jz ka jb kb bi translated">1.登录后如何进行自动重定向？</h2><p id="831d" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km js kn ko kp jv kq kr ks jy kt ku kv kw hb bi translated">渲染一个<strong class="ke hj"> <em class="kx"> &lt;重定向&gt; </em> </strong>组件，由<strong class="ke hj"> <em class="kx"> react-router </em> </strong>包提供，将导航到一个新的位置。与服务器端重定向一样，新位置将覆盖历史堆栈中的当前位置。</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="19e4" class="jl ig hi kz b fi ld le l lf lg">import React, { Component } from 'react'<br/>import { Redirect } from 'react-router'<br/><br/>export default class LoginComponent extends Component {<br/>  render() {<br/>    if (this.state.isLoggedIn === true) {<br/>      return &lt;Redirect to="/your/redirect/page" /&gt;<br/>    } else {<br/>      return &lt;div&gt;{'Login Please'}&lt;/div&gt;<br/>    }<br/>  }<br/>}</span></pre><h2 id="02f8" class="jl ig hi bd ih jm jn jo il jp jq jr ip js jt ju it jv jw jx ix jy jz ka jb kb bi translated">2.如何使用React Intl格式化日期？</h2><p id="025b" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km js kn ko kp jv kq kr ks jy kt ku kv kw hb bi translated"><strong class="ke hj"><em class="kx">inject ntl()</em></strong>高阶组件将通过组件中的props为您提供对<strong class="ke hj"> <em class="kx"> formatDate() </em> </strong>方法的访问。该方法由<strong class="ke hj"><em class="kx">formatted date</em></strong>的实例在内部使用，它返回格式化日期的字符串表示。</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="a88b" class="jl ig hi kz b fi ld le l lf lg">import { injectIntl, intlShape } from 'react-intl'<br/><br/>const stringDate = this.props.intl.formatDate(date, {<br/>  year: 'numeric',<br/>  month: 'numeric',<br/>  day: 'numeric'<br/>})<br/><br/>const MyComponent = ({intl}) =&gt; (<br/>  &lt;div&gt;{`The formatted date is ${stringDate}`}&lt;/div&gt;<br/>)<br/><br/>MyComponent.propTypes = {<br/>  intl: intlShape.isRequired<br/>}<br/><br/>export default injectIntl(MyComponent)</span></pre><h2 id="7c66" class="jl ig hi bd ih jm jn jo il jp jq jr ip js jt ju it jv jw jx ix jy jz ka jb kb bi translated">3.Redux和RxJS有什么相似之处吗？</h2><p id="b321" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km js kn ko kp jv kq kr ks jy kt ku kv kw hb bi translated">尽管两者用于不同的目的，但它们之间几乎没有相似之处:</p><blockquote class="lh li lj"><p id="faa5" class="kc kd kx ke b kf lk kh ki kj ll kl km lm ln ko kp lo lp kr ks lq lr ku kv kw hb bi translated">我) <strong class="ke hj"> Redux </strong>是一个管理整个应用程序状态的工具。它通常被用作UIs的架构，可以假定50%是Angular的替代方案。</p><p id="5d8c" class="kc kd kx ke b kf lk kh ki kj ll kl km lm ln ko kp lo lp kr ks lq lr ku kv kw hb bi translated"><strong class="ke hj"> RxJS </strong>是一个反应式编程库。它通常被用作JavaScript中完成异步任务的工具。可以假定它是JavaScript承诺的替代方案。</p><p id="3f0c" class="kc kd kx ke b kf lk kh ki kj ll kl km lm ln ko kp lo lp kr ks lq lr ku kv kw hb bi translated"><strong class="ke hj"> ii) </strong> <strong class="ke hj"> Redux </strong>使用反应式范例，因为存储是反应式的。商店从远处观察行动，并改变自己。</p><p id="67e5" class="kc kd kx ke b kf lk kh ki kj ll kl km lm ln ko kp lo lp kr ks lq lr ku kv kw hb bi translated">RxJS 也使用了反应式范例，但是它不是一个架构，而是为我们提供了基本的构建模块，可观察的，来完成这个模式。</p></blockquote><h2 id="a138" class="jl ig hi bd ih jm jn jo il jp jq jr ip js jt ju it jv jw jx ix jy jz ka jb kb bi translated">4.React中的状态是什么？</h2><p id="dbd7" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km js kn ko kp jv kq kr ks jy kt ku kv kw hb bi translated">在<strong class="ke hj"> React </strong>意义上，“<strong class="ke hj"> state </strong>是一个对象，表示app中可以改变的部分。每个组件可以维护自己的<strong class="ke hj">状态</strong>，它存在于一个名为this的对象中。<strong class="ke hj">状态</strong>。</p><blockquote class="lh li lj"><p id="5af1" class="kc kd kx ke b kf lk kh ki kj ll kl km lm ln ko kp lo lp kr ks lq lr ku kv kw hb bi translated">状态是私有的，完全由组件控制。除了拥有该状态的组件之外，没有其他组件可以访问该状态。</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ls"><img src="../Images/d1409bfabc5a217a9248e9c50fa05d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q4iKgmOS74sRKW_Q.jpg"/></div></div></figure><p id="63ea" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated"><strong class="ke hj">状态的示例:</strong></p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="5c99" class="jl ig hi kz b fi ld le l lf lg">class User extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/><br/>    this.state = {<br/>      message: 'Welcome to React world'<br/>    }<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1&gt;{this.state.message}&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><h2 id="4437" class="jl ig hi bd ih jm jn jo il jp jq jr ip js jt ju it jv jw jx ix jy jz ka jb kb bi translated">5.如何将参数传递给事件处理程序或回调？</h2><p id="6ff2" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km js kn ko kp jv kq kr ks jy kt ku kv kw hb bi translated"><strong class="ke hj">方法1: <br/> </strong>使用<em class="kx">箭头功能</em></p><blockquote class="lh li lj"><p id="d500" class="kc kd kx ke b kf lk kh ki kj ll kl km lm ln ko kp lo lp kr ks lq lr ku kv kw hb bi translated"><button onclick="{()"> this.handleClick(id)} /&gt;</button></p></blockquote><p id="2874" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated">这相当于调用了<strong class="ke hj"> <em class="kx"> bind() </em> </strong>函数</p><blockquote class="lh li lj"><p id="90bc" class="kc kd kx ke b kf lk kh ki kj ll kl km lm ln ko kp lo lp kr ks lq lr ku kv kw hb bi translated"><button onclick="{this.handleClick.bind(this," id=""/></p></blockquote><p id="db27" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated"><strong class="ke hj">方法二:</strong></p><p id="4002" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated">向数组函数传递参数</p><blockquote class="lh li lj"><p id="760a" class="kc kd kx ke b kf lk kh ki kj ll kl km lm ln ko kp lo lp kr ks lq lr ku kv kw hb bi translated"><button onclick="{this.handleClick(id)}"/><br/>handle click =(id)=&gt;()=&gt;{ console . log("您好，您的票号是"，id)}；</p></blockquote><h2 id="110d" class="jl ig hi bd ih jm jn jo il jp jq jr ip js jt ju it jv jw jx ix jy jz ka jb kb bi translated">6.使用带props参数的超级构造函数的目的是什么？</h2><p id="308b" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km js kn ko kp jv kq kr ks jy kt ku kv kw hb bi translated">在调用<strong class="ke hj"> <em class="kx"> super() </em> </strong>方法之前，子类构造函数不能使用<strong class="ke hj"> <em class="kx">这个</em> </strong>引用。这同样适用于ES6子类。将props参数传递给<strong class="ke hj"> <em class="kx"> super() </em> </strong>调用的主要原因是为了访问子构造函数中的<strong class="ke hj"> <em class="kx"> this.props </em> </strong>。</p><blockquote class="lh li lj"><p id="c80e" class="kc kd kx ke b kf lk kh ki kj ll kl km lm ln ko kp lo lp kr ks lq lr ku kv kw hb bi translated"><strong class="ke hj"> this.props </strong>只在构造函数内部不同。在构造函数之外也是如此。</p></blockquote><p id="620d" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated"><strong class="ke hj">传球道具:</strong></p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="4f09" class="jl ig hi kz b fi ld le l lf lg">class MyComponent extends React.Component {<br/>  constructor(props) {<br/>    super(props)</span><span id="e075" class="jl ig hi kz b fi lx le l lf lg">    console.log(this.props) // prints { name: 'John', age: 42 }<br/>  }<br/>}</span></pre><p id="203f" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated"><strong class="ke hj">不传球道具:</strong></p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="b51e" class="jl ig hi kz b fi ld le l lf lg">class MyComponent extends React.Component {<br/>  constructor(props) {<br/>    super()</span><span id="8c00" class="jl ig hi kz b fi lx le l lf lg">    console.log(this.props) // prints undefined</span><span id="715c" class="jl ig hi kz b fi lx le l lf lg">    // but props parameter is still available<br/>    console.log(props) // prints { name: 'John', age: 42 }<br/>  }</span><span id="b011" class="jl ig hi kz b fi lx le l lf lg">  render() {<br/>    // no difference outside constructor<br/>    console.log(this.props) // prints { name: 'John', age: 42 }<br/>  }<br/>}</span></pre><h2 id="826b" class="jl ig hi bd ih jm jn jo il jp jq jr ip js jt ju it jv jw jx ix jy jz ka jb kb bi translated">7.索引作为键有什么影响？</h2><p id="27f4" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km js kn ko kp jv kq kr ks jy kt ku kv kw hb bi translated">React需要跟踪元素，因此<strong class="ke hj"> <em class="kx">键</em> </strong>应该始终稳定，唯一&amp;可预测。</p><p id="93af" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated">下面的代码限制了React的优化能力。在这里，每个元素的键将基于排序，而不是绑定到所表示的数据。</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="cd26" class="jl ig hi kz b fi ld le l lf lg">{todos.map((todo, index) =&gt;<br/>  &lt;Todo<br/>    {...todo}<br/>    key={index}<br/>  /&gt;<br/>)}</span></pre><p id="f40d" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated">但是，如果我们使用元素数据作为唯一键，假设<strong class="ke hj"> <em class="kx"> todo.id </em> </strong>对于这个列表是唯一的并且是稳定的，React将能够重新排序元素，而不需要重新评估它们。</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="1417" class="jl ig hi kz b fi ld le l lf lg">{todos.map((todo) =&gt;<br/>  &lt;Todo {...todo}<br/>    key={todo.id} /&gt;<br/>)}</span></pre><h2 id="8305" class="jl ig hi bd ih jm jn jo il jp jq jr ip js jt ju it jv jw jx ix jy jz ka jb kb bi translated">8.我需要用钩子重写我所有的类组件吗？</h2><p id="c3a8" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km js kn ko kp jv kq kr ks jy kt ku kv kw hb bi translated">不一定。但是我们可以在不重写任何现有代码的情况下，在一些组件(或新组件)中尝试挂钩。因为没有计划删除ReactJS中的类。</p><h2 id="d857" class="jl ig hi bd ih jm jn jo il jp jq jr ip js jt ju it jv jw jx ix jy jz ka jb kb bi translated">9.钩子覆盖了类的所有用例吗？</h2><p id="23a4" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km js kn ko kp jv kq kr ks jy kt ku kv kw hb bi translated">Hooks并没有涵盖类的所有用例，但是计划很快会添加它们。目前，还没有与不常见的<strong class="ke hj"><em class="kx">getsnapshotbeforedupdate</em></strong>和<strong class="ke hj"><em class="kx">componentDidCatch</em></strong>生命周期等价的钩子。</p><h2 id="6a29" class="jl ig hi bd ih jm jn jo il jp jq jr ip js jt ju it jv jw jx ix jy jz ka jb kb bi translated">10.如何确保钩子在你的项目中遵循规则？</h2><p id="b194" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km js kn ko kp jv kq kr ks jy kt ku kv kw hb bi translated">我们可以通过使用名为<strong class="ke hj"> <em class="kx">的ESLint插件来确保这一点</em></strong></p><p id="f92a" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated"><strong class="ke hj">有两条规则:</strong></p><p id="067f" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated"><em class="kx"> i)在项目中添加插件(通过执行命令行)</em></p><blockquote class="lh li lj"><p id="0cef" class="kc kd kx ke b kf lk kh ki kj ll kl km lm ln ko kp lo lp kr ks lq lr ku kv kw hb bi translated">npm安装eslint-plugin-react-hooks@next</p></blockquote><p id="c82d" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated"><em class="kx"> ii)在</em> <strong class="ke hj"> <em class="kx"> ESLint配置文件</em> </strong>中应用以下配置</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="cfb9" class="jl ig hi kz b fi ld le l lf lg">{<br/>  "plugins": [<br/>    // ...<br/>    "react-hooks"<br/>  ],<br/>  "rules": {<br/>    // ...<br/>    "react-hooks/rules-of-hooks": "error"<br/>  }<br/>}</span></pre><p id="c913" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated">今天就到此为止…感谢阅读。如果你喜欢这篇文章，请鼓掌。快乐学习:)</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="d173" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated"><strong class="ke hj"> <em class="kx">文章参考:</em> </strong></p><p id="72b9" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated"><a class="ae mf" href="https://github.com/sudheerj/reactjs-interview-questions" rel="noopener ugc nofollow" target="_blank"><em class="kx">https://github.com/sudheerj/reactjs-interview-questions</em></a></p><p id="2859" class="pw-post-body-paragraph kc kd hi ke b kf lk kh ki kj ll kl km js ln ko kp jv lp kr ks jy lr ku kv kw hb bi translated"><a class="ae mf" href="https://daveceddia.com/visual-guide-to-state-in-react/" rel="noopener ugc nofollow" target="_blank"><em class="kx"/>https://daveceddia.com/visual-guide-to-state-in-react/</a></p></div></div>    
</body>
</html>