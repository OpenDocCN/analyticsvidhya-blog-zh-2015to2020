<html>
<head>
<title>Quick Guide to matplotlib.pyplot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">matplotlib.pyplot快速指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/quick-guide-to-matplotlib-pyplot-the-object-oriented-way-bc92ae470605?source=collection_archive---------11-----------------------#2019-09-12">https://medium.com/analytics-vidhya/quick-guide-to-matplotlib-pyplot-the-object-oriented-way-bc92ae470605?source=collection_archive---------11-----------------------#2019-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="95d5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">面向对象的方法</h2></div><p id="b600" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章的代码和文本也可以在jupyter notebook上找到，可以在这里找到。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/3e62934977288f4eb09574576c5d4a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bizr1bZNmGQVfmXp0yB6yQ.jpeg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">来源——维基百科</figcaption></figure><blockquote class="kk"><p id="59e3" class="kl km hi bd kn ko kp kq kr ks kt js dx translated">“一幅画胜过千言万语”</p></blockquote><p id="aef6" class="pw-post-body-paragraph ix iy hi iz b ja ku ij jc jd kv im jf jg kw ji jj jk kx jm jn jo ky jq jr js hb bi translated">弗雷德·r·巴纳德说的在任何情况下都是正确的。视觉以简洁的方式传达更清晰的信息，特别是在数据科学和机器学习方面，可视化发挥着至关重要的作用。适当的可视化使庞大而复杂的数据更容易理解，更有意义。你可能会想，说了这么多关于图像的东西，我仍然在写这篇文字博客。好吧，我会尽我所能在可能的地方描绘出来。所以，回到主题… <br/> <strong class="iz hj"> Matplotlib </strong>是python社区中最著名和最广泛使用的数据可视化工具。它的<strong class="iz hj"> pyplot </strong>子模块是命令行风格函数的集合，使matplotlib像MATLAB一样工作。在本文中，我们将使用无状态方法(即面向对象的方法)浏览以下主题</p><ul class=""><li id="68b4" class="kz la hi iz b ja jb jd je jg lb jk lc jo ld js le lf lg lh bi translated">面向对象方式的简单绘图</li><li id="5673" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">支线剧情的使用()</li><li id="a8f3" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">使情节吸引人</li><li id="f919" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">使用子情节的多个轴()</li></ul><h2 id="f120" class="ln lo hi bd lp lq lr ls lt lu lv lw lx jg ly lz ma jk mb mc md jo me mf mg mh bi translated">所以，让我们开始吧-</h2><p id="3b1f" class="pw-post-body-paragraph ix iy hi iz b ja mi ij jc jd mj im jf jg mk ji jj jk ml jm jn jo mm jq jr js hb bi translated">说到简单，在抽象层次上，您可以直接使用matplotlib，只需将pyplot作为plt导入并使用plot函数。</p><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="baac" class="ln lo hi mo b fi ms mt l mu mv">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="6c43" class="ln lo hi mo b fi mw mt l mu mv">x = np.linspace(0,10,15)<br/>y = x**2</span><span id="ecb5" class="ln lo hi mo b fi mw mt l mu mv">plt.plot(x,y)</span></pre><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es mx"><img src="../Images/2696588a2a33a03b75245ab44b82a4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*oSIYOVLTYiEkFHw-aFDSug.png"/></div></figure><p id="ce67" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是使用面向对象的方法是更直观的方式，当一起处理多个轴和图形时会变得很方便。</p><ul class=""><li id="0cd2" class="kz la hi iz b ja jb jd je jg lb jk lc jo ld js le lf lg lh bi translated">首先，让我们创建一个图形对象。这代表一个空画布，您可以在其中添加一组轴来绘制一些东西。</li><li id="f44e" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">现在，我们可以使用add_axes()方法向图形添加一组轴。它以一个列表作为参数，该列表包含四个值— <strong class="iz hj">左</strong>、<strong class="iz hj">底</strong>、<strong class="iz hj">宽</strong>、<strong class="iz hj">高</strong>，即轴在画布中的位置。所有这些值都在0和1之间。</li><li id="2303" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">最后，您可以使用plot()方法在轴上绘图。</li></ul><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="b472" class="ln lo hi mo b fi ms mt l mu mv">fig = plt.figure()</span><span id="422f" class="ln lo hi mo b fi mw mt l mu mv">ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])</span><span id="6679" class="ln lo hi mo b fi mw mt l mu mv">ax.plot(x,y)</span></pre><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es mx"><img src="../Images/2696588a2a33a03b75245ab44b82a4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*oSIYOVLTYiEkFHw-aFDSug.png"/></div></figure><p id="5580" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可能看起来比典型的方法更难，但是如果我说你不需要自己创建图形和添加轴呢？是的，这可以用<strong class="iz hj">支线剧情()</strong>函数来完成。<strong class="iz hj"> plt.subplots() </strong>返回一个带有图形对象和轴数组(默认为单轴)的元组，可用于直接绘图。让我们把情节变得更有吸引力和可读性-</p><ul class=""><li id="dc2d" class="kz la hi iz b ja jb jd je jg lb jk lc jo ld js le lf lg lh bi translated">使用grid()方法添加网格。</li><li id="d788" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">plot()方法中的“r —”参数用于红色虚线。</li><li id="8b7d" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">lw=2将线宽设置为原始宽度的两倍。</li><li id="2589" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">marker='o '，markeredgecolor='blue '，markersize=10表示标记形状为圆形，边缘颜色为蓝色，大小为10。</li><li id="933b" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">指定地块的标题和标签。</li></ul><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="bfdc" class="ln lo hi mo b fi ms mt l mu mv">fig, ax = plt.subplots()</span><span id="7f4a" class="ln lo hi mo b fi mw mt l mu mv">ax.grid() # for grid</span><span id="1d68" class="ln lo hi mo b fi mw mt l mu mv">ax.plot(x, y, ‘r — ‘, lw=2, marker=’o’, markeredgecolor=’blue’, markersize=10)</span><span id="c90d" class="ln lo hi mo b fi mw mt l mu mv">ax.set_title(‘My Data Plot’)<br/>ax.set_xlabel(‘X label Here’)<br/>ax.set_ylabel(‘Y label Here’)</span></pre><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es my"><img src="../Images/14cb6a29e10254dad54c5cd81fa23a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*Be-W8SknVe1EKWqFQyO4fw.png"/></div></figure><p id="ad38" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">单组轴也可以用于绘制多个项目。可以通过给每个图添加标签来分隔这些图。当您调用<strong class="iz hj"> ax.legend() </strong>方法时，这些标签显示为图例。还可以通过将loc参数添加到图例中来将位置添加到图例中。默认情况下，它被设置为最佳位置。</p><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="5d69" class="ln lo hi mo b fi ms mt l mu mv">fig, ax = plt.subplots()</span><span id="b8f7" class="ln lo hi mo b fi mw mt l mu mv">ax.grid()<br/>ax.plot(x, x**2, ‘b — ‘, label=’^2’)<br/>ax.plot(x, x**2.5, ‘r’, marker=’^’, label=’^2.5')<br/>ax.plot(x, x**3, ‘purple’, marker=’*’, label=’^2’)<br/>ax.legend()</span><span id="57b1" class="ln lo hi mo b fi mw mt l mu mv">ax.set_title(‘My Data Plot’)<br/>ax.set_xlabel(‘X label Here’)<br/>ax.set_ylabel(‘Y label Here’)</span></pre><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es mz"><img src="../Images/6e02d58651b53074384c806c3a88bbb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*f6X9U39ALwY0Nn2JarP0iw.png"/></div></figure><p id="d408" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我前面提到的，<strong class="iz hj"> plt.subplots() </strong>返回一个带有图形对象和轴数组的元组。默认情况下，参数<em class="na"> nrows </em>和<em class="na"> ncols </em>被设置为1，这就是为什么我们得到一个单轴对象。现在，将<em class="na"> nrows </em>和<em class="na"> ncols </em>的值更改为2，我们将得到<em class="na"> ax </em>作为包含4个对象的轴的数组。</p><p id="6863" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="na">注意:- </em>您也可以通过向<em class="na"> figsize </em>参数传递一个元组来根据需要更改图形大小。该元组以英寸表示该图的<em class="na">长度</em>和<em class="na">宽度</em>。这里我取了<em class="na"> figsize=(12，8) </em>。</p><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="58ed" class="ln lo hi mo b fi ms mt l mu mv">fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(12,8))</span></pre><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es nb"><img src="../Images/1d94facc0282ca61a1d0d272379d3949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMHMFGsIrMA3DNKjlSoxhg.png"/></div></div></figure><p id="d67a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看一下<em class="na"> ax </em>的形状、类型和内容，我们可以清楚地看到这是一把2x2 numpy的ndarray。</p><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="3234" class="ln lo hi mo b fi ms mt l mu mv">print(ax.shape)<br/>print(‘ — — — — — — — — — — — — — — — — — — — -’)<br/>print(type(ax))<br/>print(‘ — — — — — — — — — — — — — — — — — — — -’)<br/>print(ax)</span></pre><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es nc"><img src="../Images/14286ded6bf406163013208143bb2099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*p8XZ-_rf3OgsX3AbJ4arzg.png"/></div></figure><p id="65f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些AxesSubplots对象可以简单地通过索引或迭代数组来访问。</p><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="b57d" class="ln lo hi mo b fi ms mt l mu mv">fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(12,8))</span><span id="292e" class="ln lo hi mo b fi mw mt l mu mv">a = np.random.randn(500)<br/>ax[0][0].hist(a, bins= 50, color=’purple’)<br/>ax[0][0].set_title(‘Gaussian Distributed Plot’)</span><span id="ea15" class="ln lo hi mo b fi mw mt l mu mv">a = np.arange(50)<br/>b = np.sin(a)<br/>ax[0][1].grid()<br/>ax[0][1].plot(a,b,’b’, marker=’o’)<br/>ax[0][1].set_title(‘My Sine Plot’)</span><span id="f4a2" class="ln lo hi mo b fi mw mt l mu mv">ax[1][0].grid()<br/>ax[1][0].plot(x, x**2, ‘b — ‘, label=’²’)<br/>ax[1][0].plot(x, x**2.5, ‘r’, marker=’^’, label=’².5')<br/>ax[1][0].plot(x, x**3, ‘purple’, marker=’*’, label=’³’)<br/>ax[1][0].legend()</span><span id="b79b" class="ln lo hi mo b fi mw mt l mu mv">ax[1][1].grid()<br/>ax[1][1].plot(x,y)<br/>ax[1][1].set_title(‘My Data Plot’)<br/>ax[1][1].set_xlabel(‘X label Here’)<br/>ax[1][1].yaxis.set_label_position(“right”)<br/>ax[1][1].set_ylabel(‘Y label Here’)</span><span id="611d" class="ln lo hi mo b fi mw mt l mu mv">fig.tight_layout()</span></pre><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es nd"><img src="../Images/e53ec2c978eba24c6bf9bcaed40b10d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ASM-we0I9UDsnZtJ1Sa4w.png"/></div></div></figure><p id="ab55" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="na">注意:-</em><em class="na">fig . tight _ layout()</em>用于确保两个轴子图不相互重叠。</p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="db2b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望这篇文章对你有帮助。敬请期待更多；)</p></div></div>    
</body>
</html>