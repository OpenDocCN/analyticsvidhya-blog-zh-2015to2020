<html>
<head>
<title>Introduction to Genetic Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗传算法导论</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/genetic-algorithms-with-python-part-i-introduction-3e36dc4a609b?source=collection_archive---------29-----------------------#2020-04-05">https://medium.com/analytics-vidhya/genetic-algorithms-with-python-part-i-introduction-3e36dc4a609b?source=collection_archive---------29-----------------------#2020-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a7e5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">遗传算法的简单概念介绍。</h2></div><p id="e6b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">计算机科学的早期先驱们对生物学和心理学的兴趣不亚于对电子学的兴趣，他们将自然系统视为如何实现其愿景的指导性隐喻。</p><p id="eb14" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过他们的努力，出现了三种受生物学启发的问题解决策略。第一个已经发展到神经网络领域，第二个发展到机器学习，第三个发展到现在所谓的“进化计算”，其中遗传算法是最突出的例子。</p><h1 id="42a9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">遗传算法</h1><p id="cf7d" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">“搜索算法”是“搜索”问题解决方案的策略。遗传算法是一种受自然选择和遗传学机制启发的搜索算法。但是在找到解决方案之前，我们首先需要定义一个解决方案是什么样子的。</p><h2 id="ba02" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated">编码解决方案</h2><p id="1ae4" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">让我们用一个玩具问题来理解编码。考虑一个有5个开关和一个灯泡的盒子。开关的特定组合(打开和关闭)打开灯泡。我们的目标是找到打开灯泡的正确开关组合。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es le"><img src="../Images/a802d67382eca6f4846188a99e26f446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6IJm1UxndvCsBrbSQNWow.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">编码解决方案</figcaption></figure><p id="4174" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在已经确定了问题，接下来是解决办法。解决方案是一些开关的组合。我们如何表示开关的组合？一种简单的方法是将其表示为开关状态序列，比如['关'，'开'，'关'，'开'，'关']。我们可以将其进一步简化为一串“0”和“1 ”,其中“0”表示开关关闭,“1”表示开关打开。例如，字符串“01011”表示第二、第四和第五开关打开，其余开关关闭。</p><p id="b80b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">找到盒子的解现在是找到正确的长度为5的二进制字符串。这个“编码参数集”的过程是遗传算法不同于其他搜索算法的一个方面。</p><p id="d288" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们已经定义了一个解决方案的样子，让我们继续实际的算法本身。遗传算法由以下步骤组成:</p><ol class=""><li id="01fa" class="lu lv hi iz b ja jb jd je jg lw jk lx jo ly js lz ma mb mc bi translated">复制/选择</li><li id="b552" class="lu lv hi iz b ja md jd me jg mf jk mg jo mh js lz ma mb mc bi translated">交叉</li><li id="7c57" class="lu lv hi iz b ja md jd me jg mf jk mg jo mh js lz ma mb mc bi translated">变化</li></ol><h1 id="299e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">生殖</h1><p id="d7c9" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">我们从随机候选解的<strong class="iz hj">群体</strong>开始。由于是随机的，这些可能不是正确的解决方案。然而，这是我们第一代<strong class="iz hj">T3。繁殖过程包括通过从现有群体中选择成员来创建新的解决方案群体。我们选择成员的依据是什么？</strong></p><p id="accd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单来说，我们要求好的方案更容易被选中(而且是多次)，而差的方案不太容易被选中。这将意味着，随着每一个连续的世代，我们期望群体包含更多的好解副本，而坏解被过滤掉。</p><p id="4fb4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我们怎么知道解决方案是好是坏呢？为此，我们定义了一个“<strong class="iz hj">适合度</strong>标准，让我们比较候选解决方案。</p><h2 id="ee1c" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated">健康</h2><p id="c8ce" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">回到开关盒的例子，假设开关盒对于组合“10110”完全点亮。这种组合是我们的目标解决方案。此外，假设对于接近目标解决方案的每个组合，框都部分变亮。换句话说，每一个被正确拨动的开关都会增加灯泡的亮度。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es le"><img src="../Images/278a2957fb16eb214e9fc6a8590b618a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8dyATulyWnLhV9DVqUZ9Q.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">计算候选解的适合度</figcaption></figure><p id="a444" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">按照这个逻辑，对于组合‘01001’(每个开关都被错误地切换)，灯泡将完全关闭，而对于组合‘10111’(除了最后一个开关之外，所有开关都被正确切换)，灯泡将接近全亮度。因此，灯泡的亮度作为候选解决方案的适合性标准。</p><p id="b914" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了对这个灯泡及其亮度进行建模，我们可以简单地将“灯泡的亮度”替换为“正确切换的开关数量”，从而获得每个候选解决方案的适合度的数值。</p><p id="df5f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们有了每个候选解“适合”程度的数值度量，我们需要创建一个包含更多适合解的新群体。有很多方法可以做到这一点，本文将介绍'轮盘赌轮选择'。</p><h2 id="a140" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated">轮盘赌选择</h2><p id="c3ac" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">顾名思义，我们将当前群体中的所有候选解放在轮盘赌上，更合适的候选解占据更大的区域。这将确保候选人是根据他们的健康状况按比例挑选的。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es le"><img src="../Images/37ee35e7135b7b315454fcdf44a440e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tODi5tZrj9H0OObUmWttDg.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">轮盘赌选择</figcaption></figure><p id="388a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们只需多次旋转轮盘，将胜出的候选人复制到下一代。我们注意到，更适合的候选人可能会被选择多次，而不太适合的候选人可能根本不会被选择。下一步是交叉。</p><h1 id="085d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">交叉</h1><p id="ebb7" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">通过选择导致更好的解决方案的更多副本，它不会产生新的解决方案。毕竟，我们不能简单地希望初始随机群体恰好包含最佳解决方案！这就是交叉的用武之地。在本文中，我们将关注单点交叉。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es le"><img src="../Images/8a7bb8956a882fd60fcd33059088750a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xs1SDVulyk5sqXW05JCFcg.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">交叉</figcaption></figure><p id="c4f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在单点交叉中，所有单个字符串都被分组成对。对于一对字符串，在1和字符串长度之间随机选择一个随机数<em class="mi"> k </em>。对于这对字符串，第<em class="mi">个</em>字符之后的每个字符(位)都被交换。对所有的字符串对都这样做。</p><p id="5964" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们有一种方法来确保新的解决方案可以被引入到人群中。最后一步是突变。</p><h1 id="f3bc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">变化</h1><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mj"><img src="../Images/7a247e2062b8c915afe5fecc106d5f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ahgojyWyWv7ucz6U7W8kEg.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">变化</figcaption></figure><p id="943f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">突变包括时不时地随机改变一点。换句话说，每个字符串的每一位都有很小的机会被改变(1变成0，0变成1)。</p><p id="e35a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">突变是必要的，因为有时最佳解决方案不能从现有的解决方案中形成。例如，如果群体中的所有字符串都以“0”作为第一位，而最佳解决方案要求以“1”作为第一位，那么再多的复制和交叉也不能产生最佳解决方案。</p><h1 id="a6e4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">重复！</h1><p id="3f98" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">选择、交叉和变异的一个循环产生了新的一代。这个循环重复多次。多少次了？嗯，在我们找到解决办法之前最好是这样。但是万一我们的算法需要太长时间才能找到一个解，或者根本找不到一个解，我们可以设置一个代数的限制。</p><h1 id="e2b9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">结论</h1><p id="deaf" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">至此，你应该对遗传算法的工作原理有了一个基本的了解，并准备开始实施。我有一篇文章安排在下周发表，我们将用python实现一个遗传算法来解决一个简单的问题。谢谢你。</p></div></div>    
</body>
</html>