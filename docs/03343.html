<html>
<head>
<title>Why we should never update React State directly!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们不应该直接更新反应状态！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/why-we-should-never-update-react-state-directly-c1b794fac59b?source=collection_archive---------2-----------------------#2020-01-27">https://medium.com/analytics-vidhya/why-we-should-never-update-react-state-directly-c1b794fac59b?source=collection_archive---------2-----------------------#2020-01-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6b1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何工作过或学习过一点<strong class="ih hj"> React </strong>的人可能都知道我们不应该直接改变或更新状态。相反，我们应该总是声明一个新对象<code class="du jd je jf jg b">const obj = {}</code>并使用<code class="du jd je jf jg b">this.setState({ obj })</code>并让react处理它，就像我在下面的例子中所做的那样。但是为什么呢？</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="56d3" class="jp jq hi jg b fi jr js l jt ju">state = {<br/>    counters: [<br/>      { id: 1, value: 4 },<br/>      { id: 2, value: 0 },<br/>      { id: 3, value: 0 },<br/>      { id: 4, value: 0 },<br/>      { id: 5, value: 0 }<br/>    ]<br/>  };</span><span id="3028" class="jp jq hi jg b fi jv js l jt ju">handleIncrements = counter =&gt; {<br/>    const counters = [...this.state.counters];<br/>    const index = counters.indexOf(counter);<br/>    counters[index] = { ...counter };<br/>    counters[index].value++;<br/>    this.setState({ counters });<br/>  };</span><span id="37d8" class="jp jq hi jg b fi jv js l jt ju">};</span></pre><p id="00d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了掌握这个问题，我们首先需要知道React lifecycle是如何工作的。<br/> <em class="jw">(想要简答的可以向下滚动到底部)</em></p><p id="6f13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React有三个生命周期阶段:</p><ol class=""><li id="47e4" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated">贴装阶段:<br/>第一次贴装元件时。它有三个我们常用的生命周期钩子:<br/> i .构造器<br/> ii。渲染<br/>二。组件安装</li><li id="8bbf" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">更新阶段:<br/>当组件已经挂载并且状态或属性发生变化时。它有两个我们常用的生命周期挂钩:<br/> i. render <br/> ii。componentDidUpdate</li><li id="c135" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">卸载阶段:<br/>删除组件时。它有一个我们常用的生命周期钩子:<br/> i. componentWillUnmount</li></ol><p id="ea0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些生命周期挂钩都按顺序调用。</p><p id="b77c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在React中，无论组件是在安装阶段还是在更新阶段进行渲染，它总是渲染树中的所有组件。假设我们有一个这样的应用程序结构:</p><figure class="jh ji jj jk fd km er es paragraph-image"><div class="er es kl"><img src="../Images/6025c556e963fcb17fd5863b04481fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*4jNs9MbPRc9_Lvxqy6S0ww.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">简单的组件树截图来自Mosh教程</figcaption></figure><p id="bf31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们运行这个应用程序时，如果我们声明了上面提到的所有生命周期钩子，并且在每个钩子中声明了<code class="du jd je jf jg b">console.log()</code>，我们将会看到钩子是按照下面的顺序被调用的。</p><p id="a65b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一、App-constructor <br/> ii。App渲染<br/>三。NavBar-rendered (NavBar是无状态功能组件)<br/> iv。Counters-rendered (Counters是一个无状态的功能组件)<br/>v .(4)Counter-rendered(Counter是一个无状态的功能组件)<br/> vi。App-didMount</p><p id="5788" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果你不知道什么是无状态功能组件，它是一个没有状态或构造函数或任何生命周期挂钩的组件，并且完全由它们的父组件控制。它们只呈现一个react组件。</p><p id="b24e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么现在，当一个状态或道具被改变时会发生什么？它再次呈现其所有组件。</p><blockquote class="kt ku kv"><p id="92e5" class="if ig jw ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><strong class="ih hj">注意，我已经说过所有的组件都被再次渲染，而不是再次更新。</strong></p></blockquote><p id="9f48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在下面的屏幕截图中看到的，只有增加的span被更新(在inspect元素中，您可以看到紫色的变化)。那么，它是如何工作的呢？</p><figure class="jh ji jj jk fd km er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/081d199c51b55e7903d56ce7a462584d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJ3DvpchDXsweQYDS05vDw.png"/></div></div></figure><p id="1b41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi le translated">eact保存了其所有虚拟DOM的跟踪记录。每当发生变化时，所有的组件都会被渲染，然后将这个新的虚拟DOM与旧的虚拟DOM进行比较。只有发现的差异才会反映在原始DOM中。</p><p id="9877" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，从声明中可以明显看出，如果我们直接改变状态，它也将改变先前虚拟DOM中的状态引用。因此，React看不到状态的变化，所以在我们重新加载之前，它不会反映在原始DOM中。当我们用<code class="du jd je jf jg b">React.PureComponent</code>而不是<code class="du jd je jf jg b">React.component</code>扩展一个组件时，问题就更明显了，React试图通过在没有发现变化的情况下不渲染组件来优化一些时间。<br/>此外，直接改变状态会导致奇怪的错误和难以优化的组件。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="7cbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你喜欢这个博客。如果你想看更多我的博客，你可以在<a class="ae lu" rel="noopener" href="/@anuragbhattacharjee">媒体</a>这里关注我。</p><p id="498d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我是阿努拉格。从2014年开始专业从事软件工程师工作。我经常就我经常看到人们问的问题写博客，并认为这些问题很重要。在我的空闲时间，我喜欢开发简单有用的网络和移动应用程序。您可以在此与我联系:</p><p id="a071" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">🔗<a class="ae lu" href="https://www.linkedin.com/in/anuragbhattacharjee/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/anuragbhattacharjee/</a>T7】🕸<a class="ae lu" href="http://anuragbhattacharjee.com" rel="noopener ugc nofollow" target="_blank">http://anuragbhattacharjee.com</a></p><p id="62db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐编码😀</p><figure class="jh ji jj jk fd km er es paragraph-image"><div class="er es lv"><img src="../Images/742ae66482886541c85ceff0e0505f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*Z17G3WSZ2OR5ndpvrtBFVw.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">祝你好运</figcaption></figure></div></div>    
</body>
</html>