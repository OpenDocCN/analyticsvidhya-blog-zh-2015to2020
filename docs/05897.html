<html>
<head>
<title>What is Transfer Learning &amp; Weight Initialization?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是迁移学习和权重初始化？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/what-is-transfer-learning-weight-initialization-a997d83963bb?source=collection_archive---------6-----------------------#2020-05-05">https://medium.com/analytics-vidhya/what-is-transfer-learning-weight-initialization-a997d83963bb?source=collection_archive---------6-----------------------#2020-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a62e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎大家！这是我在一个月内完成<em class="jd">深度学习纳米学位</em>的旅程中的第七篇文章！我已经完成了该学位总共六个模块中第三个模块的46%。今天的话题包括对<em class="jd">CNN</em>、<em class="jd">转移学习</em>的更深入的了解，以及一点关于<em class="jd">权重初始化</em>的利弊。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/54e2863ff7f1479ed136de4190d81cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVvHuxYp-9RC529uCiOXaA.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">转移学习</figcaption></figure><h1 id="838e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">第8天</h1><p id="297a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们要讨论的第一课是“<strong class="ih hj">迁移学习</strong>”。</p><h1 id="2629" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">迁移学习</strong></h1><p id="6c98" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">对于ML从业者来说，从头开始编写模型并不总是有效的，即形成下降模型架构、层的大小、功能等。工程师经常做的一件事就是迁移学习。它是什么，是我们使用一个预先构建的模型，并根据我们的需求对其进行优化和更改。</p><p id="2d07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果我们想要构建一个花分类器，我们可以使用一个<a class="ae kx" href="https://pytorch.org/hub/pytorch_vision_vgg/" rel="noopener ugc nofollow" target="_blank"> VGG模型</a>。主要原因是，我们可以使用一个训练好的模型并改变一些参数来获得所需的答案，而不是制作一个新模型并从头开始训练它。<em class="jd">的好处</em>？让我们回顾一下<em class="jd">培训</em>一个模特实际上是做什么的。我们初始化一些随机权重，稍后会详细介绍。执行历元、前馈和反向传播，并更新权重。所以，如果我们采用一个预先构建的模型，它会有权重实际上是为一个任务训练的，而不仅仅是随机数。因此，我们将能够很容易地操纵他们做我们想要的工作。</p><p id="edb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能会问如何操纵它们。让我们更详细地讨论一下这些层实际上做了什么。假设我们采用人脸分类模型，它的架构是有3个隐藏层。这些层所做的是，第一层总是寻找最简单的模式，即直线，这就是这一层的范围。第二层负责保存比直线更复杂的图案信息，例如圆或椭圆等。最后一层是负责最复杂信息的层，即眼睛、嘴巴、鼻子等。我们从中了解到的是<strong class="ih hj">第一层总是简单的，具有一般信息</strong>和<strong class="ih hj">隐藏的层越多，模型可以得到的模式就越复杂</strong>。</p><blockquote class="ky"><p id="ad4f" class="kz la hi bd lb lc ld le lf lg lh jc dx translated">迁移学习包括采用预先训练的神经网络，并使神经网络适应新的不同的数据集。</p></blockquote><figure class="lj lk ll lm ln jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es li"><img src="../Images/e7aad0c856ab4061bf88df9c522fd3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jM_VmCM4oLXzARSeqGkfUw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">隐藏层保存信息示例</figcaption></figure><h2 id="3261" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">那好吧。</h2><p id="e843" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">问题是，当我们导入一个预构建的模型时，我们不会保留所有的层。让我们讨论迁移学习的类型。</p><h2 id="0cc1" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">训练最后几层</h2><p id="3448" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在这种类型中，我们导入一个模型。保留一些第一层，用我们新做的层替换最后一层。然后，我们保持从模型中导入的第一个层不变，不改变它们的权重，只训练我们包含的层。这可以减少大规模训练模型所需的时间。我们为什么要训练这些？嗯，第一层包含基本信息，因此可以使用，但在深层，复杂性增加，主要模式出现。因此，我们更改这些层，因为我们希望我们的模型能够对我们的需求进行分类，而不是根据它以前构建的内容进行分类。因此，我们训练层保持我们想要的数据。然后这个练习，根据我们的需要训练模型。</p><h2 id="8783" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">查找调谐</h2><p id="72a1" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">它与上层模型相同，它导入先前训练的模型并使用其早期层，并用新构建的层替换其深度学习，但这里的不同之处在于，我们训练所有层，新制作的层以及导入的层。这是为了获得更准确的结果。为什么我们只对随机重量做这个？同样，这些都有一定的工作权重，我们只需要稍微改变一下，就可以让它工作，而不会浪费大量的计算能力，这是从随机权重开始的。以前的权重和新的权重之间总是存在某种相对性，因此更容易达到。</p><h2 id="96ca" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">我们面对的是什么？</h2><p id="d90c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在让我们讨论一些不同的可能性。</p><h2 id="a490" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">-新数据很少</h2><p id="8d07" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果新数据集很小并且与原始训练数据相似:</p><ul class=""><li id="67e7" class="mc md hi ih b ii ij im in iq me iu mf iy mg jc mh mi mj mk bi translated">切掉神经网络的末端。</li><li id="2f4b" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">添加与新数据集中的类数量相匹配的新完全连接图层。</li><li id="70dd" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">随机化新的完全连接层的权重</li><li id="1ec8" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">冻结预训练网络的所有权重。</li><li id="6a32" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">训练网络以更新新的全连接层的权重。</li></ul><h2 id="2979" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">-小数据集，不同的数据</h2><p id="194b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果新数据集很小并且不同于原始训练数据:</p><ul class=""><li id="4eca" class="mc md hi ih b ii ij im in iq me iu mf iy mg jc mh mi mj mk bi translated">除了靠近网络开始处的一些预训练层之外，切掉所有层。</li><li id="f701" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">向剩余的预训练层添加与新数据集中的类别数量相匹配的新的完全连接层。</li><li id="7068" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">随机化新的完全连接层的权重。</li><li id="302c" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">冻结预训练网络的所有权重。</li><li id="d716" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">训练网络以更新新的全连接层的权重。</li></ul><h2 id="ba44" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">-大型数据集，相似的数据</h2><p id="5a8f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果新数据集很大并且与原始训练数据相似:</p><ul class=""><li id="6a6e" class="mc md hi ih b ii ij im in iq me iu mf iy mg jc mh mi mj mk bi translated">移除最后一个完全连接的图层，并替换为与新数据集中的类数量相匹配的图层。</li><li id="cf71" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">随机初始化新的全连接层中的权重。</li><li id="8278" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">使用预训练的权重初始化其余的权重。</li><li id="ab30" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">重新训练整个神经网络。</li></ul><h2 id="996a" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">-大型数据集，不同的数据</h2><p id="8544" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果新数据集很大并且不同于原始训练数据:</p><ul class=""><li id="5a4a" class="mc md hi ih b ii ij im in iq me iu mf iy mg jc mh mi mj mk bi translated">移除最后一个完全连接的图层，并替换为与新数据集中的类数量相匹配的图层。</li><li id="b747" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">用随机初始化的权重从头开始重新训练网络。</li><li id="993c" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">或者，您可以使用与“大型且相似的”数据案例相同的策略</li></ul><p id="67f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">转移话题</em>到此结束。</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><h1 id="277e" class="ju jv hi bd jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn nb kp kq kr bi translated">重量初始化</h1><p id="9e72" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在使用预训练模型时，我们可以从现有的最佳权重开始，但除此之外，我们至少需要从某个地方开始。这在某种程度上，在决定模型的输出和精度方面，起着重要的作用。让我们举一些例子。所有的例子都是为时尚MNIST数据集训练的模型。</p><blockquote class="nc nd ne"><p id="a71b" class="if ig jd ih b ii ij ik il im in io ip nf ir is it ng iv iw ix nh iz ja jb jc hb bi translated"><code class="du ni nj nk nl b"><em class="hi">Fashion-MNIST</em></code> <em class="hi">是</em> <a class="ae kx" href="https://jobs.zalando.com/tech/" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Zalando </em> </a> <em class="hi">的文章图片的数据集——由60000个样本的训练集和10000个样本的测试集组成。每个示例都是28x28灰度图像，与10个类别的标签相关联。我们打算将</em> <code class="du ni nj nk nl b"><em class="hi">Fashion-MNIST</em></code> <em class="hi">作为原始</em> <a class="ae kx" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> MNIST数据集</em> </a> <em class="hi">的直接替代，用于基准机器学习算法。它共享训练和测试分割的相同图像大小和结构。——</em><a class="ae kx" href="https://github.com/zalandoresearch/fashion-mnist" rel="noopener ugc nofollow" target="_blank"><em class="hi">来自Github </em> </a></p></blockquote><h2 id="9bba" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">零权重</h2><p id="9466" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在这种情况下，我们将权重向量的所有元素初始化为零，认为从中性开始会有好处，并且零是概率集的下限。</p><h2 id="aa23" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">一维砝码</h2><p id="e490" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在这种情况下，我们将所有元素初始化为1，这是概率的上限。</p><p id="ab1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">产量？</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es nm"><img src="../Images/0426dc4f4e48568aa6efc66bde3779da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*jC_q8BQgymBLH50KfY21kw.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">权重= 0和1</figcaption></figure><p id="b11f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里发生了什么？我们认为这些是中性值，因此最容易训练。当权重等于零时，梯度变得相同，这样想，所有的值都相等，因此，梯度相同。因此，在执行反向传播时，神经网络很难选择需要改变的节点。当权重为1时呢？在这种情况下，梯度是相同的，因此，网络很难选择需要改变的节点。这些都是非常大的概率，模型很难让它们回到应有的位置。</p><blockquote class="ky"><p id="f44a" class="kz la hi bd lb lc ld le lf lg lh jc dx translated">使用一致的权重会使反向传播失败。</p></blockquote><h2 id="2c29" class="lo jv hi bd jw lp nn lr ka ls no lu ke iq np lw ki iu nq ly km iy nr ma kq mb bi translated">均匀分布</h2><p id="b0ea" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在这种情况下，权重从我们提供的集合中选择任意数字的概率相等。我们从连续分布中挑选。为什么？以避免重复的重量。使用的语法如下。请注意，这里的<em class="jd">数字</em>是要生成的数值的数量。</p><pre class="jf jg jh ji fd ns nl nt nu aw nv bi"><span id="4b24" class="lo jv hi nl b fi nw nx l ny nz">#Uniform Distribution<br/>np.random.unfiorm(low_bound, high_bound, number)</span><span id="7120" class="lo jv hi nl b fi oa nx l ny nz">#Setting Weights between 0 and 1, 'm' being the name of classifier<br/>m.weight.data.uniform_(0.0, 1.0)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ob"><img src="../Images/8556672f26307546f3d323782c7c13de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*w1RmIzCyL62u8mi36uPLPg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">均匀分布</figcaption></figure><p id="18c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，使用均匀分布更好，但我们可以做得更好。</p><h2 id="c518" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">一般规则</h2><p id="4ca7" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">设置神经网络中的权重的一般规则是将它们设置为接近零，但不要太小。好的做法是在[−𝑦，𝑦]的范围内开始你的重量，其中𝑦 = 1/√𝑛.让我们以y = 0.5为例。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es oc"><img src="../Images/c757eb058db44b94aad849e3d1d94823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*B58vXRRBHZKyvFLwkyqLcQ.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">一般规则</figcaption></figure><p id="9057" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看到这样的结果，我可以说我们正朝着正确的方向前进。最后一次。</p><h2 id="9a3c" class="lo jv hi bd jw lp lq lr ka ls lt lu ke iq lv lw ki iu lx ly km iy lz ma kq mb bi translated">正态分布</h2><p id="ce9b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">与均匀分布不同，<a class="ae kx" href="https://en.wikipedia.org/wiki/Normal_distribution" rel="noopener ugc nofollow" target="_blank">正态分布</a>更有可能选择接近其平均值的数字。正态分布的平均值应为0，标准偏差为𝑦 = 1/√𝑛.它的语法如下。</p><pre class="jf jg jh ji fd ns nl nt nu aw nv bi"><span id="1986" class="lo jv hi nl b fi nw nx l ny nz">np.random.normal(mean, standard_deviation, Shape_of_output)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es od"><img src="../Images/f96e1f74723edb4da99717138a62a3d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*t243B_kL_WlSKzUeLvAEfw.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">正态分布</figcaption></figure><p id="b458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到正态分布优于一般规律&amp;均匀分布，但是不要搞错了，这个结果只是在这个数据集的情况下。并且根据所使用的数据集，不同的初始化会更好。</p><blockquote class="nc nd ne"><p id="f2fe" class="if ig jd ih b ii ij ik il im in io ip nf ir is it ng iv iw ix nh iz ja jb jc hb bi translated">该层的节点/输入越多，初始化必须越小。是成反比的。权重应该居中到零。</p></blockquote><blockquote class="ky"><p id="6db5" class="kz la hi bd lb lc oe of og oh oi jc dx translated">权重初始化发生一次，在模型创建时和训练之前。具有良好的初始权重可以使神经网络接近最优解。这使得神经网络能够更快地找到最佳解决方案。</p></blockquote></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="6ce1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我今天能做的。今天的话题很有趣，可以了解它们如何让从业者的生活更轻松。渴望进入“狗品种分类器”项目。下一集再见！</p></div></div>    
</body>
</html>