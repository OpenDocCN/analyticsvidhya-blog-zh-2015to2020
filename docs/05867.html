<html>
<head>
<title>Compare more than two lists — Google pytrends — a python library for Google Trends Search for more than 5 keywords</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较两个以上的列表——Google py Trends——一个用于Google Trends搜索超过5个关键词的python库</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/google-pytrends-a-python-library-for-google-trends-search-for-more-than-5-keywords-bcf01cfd0064?source=collection_archive---------14-----------------------#2020-05-04">https://medium.com/analytics-vidhya/google-pytrends-a-python-library-for-google-trends-search-for-more-than-5-keywords-bcf01cfd0064?source=collection_archive---------14-----------------------#2020-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6c30e5a0922877300f7899eba6a679ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67Ithw-YJewU_l-c4McjcQ.jpeg"/></div></div></figure><p id="c4e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大家好。这是我在媒体上的第一个故事。我一直在纠结这个问题，所以我想，这将是一个好的开始，让每个人都知道一个更简单的解决方法。所以事不宜迟，让我们开始吧。</p><p id="65d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个需要自动化google trends部分的人都必须知道python的pytrends库。我们有很多关于它的相关查询、相关关键词、兴趣等信息。但是如果有5个以上的关键字，我们仍然需要从所有的关键字中找到一个搜索最多的。</p><p id="75f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，让我们从一个列表中有10个关键字开始。我们将开始分组前5个，并找到一个中等排名的关键字。此处的链接将帮助您更好地理解谷歌趋势搜索如何处理5个以上的关键词。<a class="ae jo" href="https://digitaljobstobedone.com/2017/07/10/how-do-you-compare-large-numbers-of-items-in-google-trends/" rel="noopener ugc nofollow" target="_blank">https://digitaljobstobedone . com/2017/07/10/how-do-you-compare-large-number-of-items-in-Google-trends/</a>。</p><p id="4c2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们正在做的是自动化这整个部分，只是为了达到最后最搜索的关键字的结果的结论。最初，第一组将由5个关键词组成，然后列表将包含不到5个关键词和前一组中排名中等的关键词。让我们从代码的第一部分开始。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="70d1" class="jy jz hi ju b fi ka kb l kc kd"><strong class="ju hj">def </strong>keywords_more_than_5(searches):</span><span id="61a1" class="jy jz hi ju b fi ke kb l kc kd">#searches is the list with more than 5 keywords<br/>#kw is an empty list to create a new list of 5 or less than 5 keywords<br/>    i = 0<strong class="ju hj"><br/>    </strong>interest_over_time_df = {}</span><span id="bb06" class="jy jz hi ju b fi ke kb l kc kd">#count increases according to the number of groups and that number of dictionaries will be created </span><span id="41ff" class="jy jz hi ju b fi ke kb l kc kd">    count = 0<br/>    flag=0<br/>    <strong class="ju hj">while </strong>i &lt; len(searches) :<br/>        kw = []<br/>        <strong class="ju hj">if </strong>i &lt; len(searches):<br/>            kw.append(searches[i])<br/>        <strong class="ju hj">if </strong>i + 1 &lt; len(searches):<br/>            kw.append(searches[i + 1])<br/>        <strong class="ju hj">if </strong>i + 2 &lt; len(searches):<br/>            kw.append(searches[i + 2])<br/>        <strong class="ju hj">if </strong>i + 3 &lt; len(searches):<br/>            kw.append(searches[i + 3])<br/>        <strong class="ju hj">if </strong>i + 4 &lt; len(searches):<br/>            kw.append(searches[i + 4])<br/>        flag=1<br/>        i=i+5</span><span id="30f7" class="jy jz hi ju b fi ke kb l kc kd"><strong class="ju hj">        i</strong>nterest_over_time_df[count] = list_pytrends(kw)</span></pre><p id="5e9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码中，keywords_more_than_5是一个接受搜索的函数——一个超过5个关键字的列表作为它的参数。i=0是搜索列表的索引。interest_over_time_df是一个新的字典，计数将跟踪将要创建的组和字典的数量。最初标志=0，这将有助于我们在某个时候进行平均缩放。现在，我们将为5个关键字创建一个空间，并根据列表长度检查每个索引。对于第一组，当i=0时，列表的第4个索引将被认为是第5个关键字，并且列表kw将具有其中的所有5个元素。我们已经完成了第一组的创建。现在下一步是将这个列表发送到pytrends，正如我们在函数list_pytrends上面看到的。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="99fa" class="jy jz hi ju b fi ka kb l kc kd"><strong class="ju hj">def list_</strong>pytrends(kw):<br/>    pytrend = TrendReq()<br/>    pytrend.build_payload(kw_list=kw, geo=<strong class="ju hj">'AE'</strong>, timeframe=<strong class="ju hj">'today 12-m'</strong>, cat=124)<br/>    interest_over_time_df = pytrend.interest_over_time()<br/>    interest_over_time_df = interest_over_time_df.drop(<strong class="ju hj">'isPartial'</strong>, axis=1)<br/>    <strong class="ju hj">return </strong>interest_over_time_df</span></pre><p id="518a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个函数提供了pytrends的所有必需品，比如列表、位置、时间表和类别。这个链接是针对所有类别的，你可以在你的代码中嵌入这些类别来找到基于特定类别的完美结果。<a class="ae jo" href="https://github.com/pat310/google-trends-api/wiki/Google-Trends-Categories" rel="noopener ugc nofollow" target="_blank">https://github . com/pat 310/Google-Trends-API/wiki/Google-Trends-Categories</a>。现在，我们知道了调用内置函数interest_over_time()的任务，该函数将返回pandas.Dataframe。现在，该Dataframe将被视为第一组关键字，这将帮助我们根据第一组中所有关键字的平均值找到中等排名的关键字。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="eeea" class="jy jz hi ju b fi ka kb l kc kd">#find only the middle brand until the last group</span><span id="6ac9" class="jy jz hi ju b fi ke kb l kc kd"><strong class="ju hj">if </strong>kw[len(kw)-2]!=searches[len(searches)-1]:<br/>        middle_brand = middle_product(interest_over_time_df[count])<br/><br/>interest_over_time_df[count].loc[<strong class="ju hj">'mean'</strong>]=interest_over_time_df[count].mean(0)<br/>       <strong class="ju hj">if </strong>flag==1:<br/>               interest_over_time_df[count].loc[<strong class="ju hj">'scaling'</strong>]=interest_over_time_df[count].mean(0)<br/> count += 1</span></pre><p id="5b74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是时候从数据帧中找到中间产品，并向数据帧添加一个均值行和一个缩放行，我将在后面解释。对于第一组，缩放将保持与平均行相同，因此旗帜进入图片。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="7651" class="jy jz hi ju b fi ka kb l kc kd"><strong class="ju hj">def </strong>middle_product(interest_over_time_df):<br/>    avg_list = interest_over_time_df.mean(0)<br/>    x = {k: v <strong class="ju hj">for </strong>k, v <strong class="ju hj">in </strong>sorted(avg_list.items(), key=<strong class="ju hj">lambda </strong>item: item[1])}<br/>    j = 0<br/>    <strong class="ju hj">for </strong>key <strong class="ju hj">in </strong>x:<br/>        <strong class="ju hj">if </strong>(j == 2):<br/>            middle_brand = (key)<br/>            avg_value=x[key]<br/>        j = j + 1<br/><br/>    <strong class="ju hj">return </strong>middle_brand,avg_value</span></pre><p id="4743" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在为了找到中间产品，我们有一个字典avg_list，由python中axis=0的均值函数组成。我们根据平均值对字典进行排序，然后选择中间品牌及其对应的平均值，这将有助于我们稍后找到缩放行。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="792c" class="jy jz hi ju b fi ka kb l kc kd">if i!=0:<br/>   flag=0<br/>   kw.append(middle_brand[0])<br/>   prev_middle_brand=middle_brand[1]<br/>   i = i + 4</span></pre><p id="55be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">张贴这个，我们将在I中有增量，我们将移动到下一个组，这将导致我们添加接下来的4个关键字和中间排名关键字。我们将保存中间关键字的平均值，以找到缩放值。同样，重复的任务将通过找到数据帧来完成，该数据帧将具有其均值行和附加到其上的缩放行。但是现在缩放行将与第一组不同。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b02a" class="jy jz hi ju b fi ka kb l kc kd">interest_over_time_df[count].loc[<strong class="ju hj">'scaling'</strong>]=scaling_func(interest_over_time_df[count],prev_middle_brand)<br/></span></pre><p id="abe0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了将产品作为一个整体进行比较，我们在下一组中添加了相同的关键字，但我们将根据什么来比较它们，两组的平均值是不同的，因此通过对它们进行缩放，我们将在一个基础上对它们进行比较。把新组的所有平均值乘以上一组的中间积的平均值，再除以它自己组的平均值，就可以做一些很好的分析了。因此，缩放函数什么也不做，只是为我们提供缩放后的值。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="bb99" class="jy jz hi ju b fi ka kb l kc kd"><strong class="ju hj">def </strong>scaling_func(df,avg_val_prev):<br/>    scaling_list=df.values[-1].tolist()<br/>    common=scaling_list[len(scaling_list)-1]<br/>    list=[]<br/>    <strong class="ju hj">for avg_value in </strong>scaling_list:<br/>        avg_value=avg_value*avg_val_prev/common<br/>        list.append(avg_value)<br/>    <strong class="ju hj">return </strong>list</span></pre><p id="9ee1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">缩放列表将具有附加到数据帧的平均值行中的平均值，并且应用相同的方法，我们将具有包含缩放值的列表，该列表将实际用于比较产品之间的共同点，这样继续下去，我们将具有尽可能多的组，它们可以用5个或少于5个关键字来创建。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="a54d" class="jy jz hi ju b fi ka kb l kc kd">df = pd.concat(interest_over_time_df, axis=1)<br/>df.columns = df.columns.droplevel(0)<br/>create_excel(df,searches,string,<strong class="ju hj">""</strong>)<br/>scaling_list=df.values[-1].tolist()<br/>keyword_list=list(df.columns.values)<br/>dict={}<br/>keyword_list=keyword_list[1:]<br/>scaling_list=scaling_list[1:]<br/><strong class="ju hj">for </strong>i <strong class="ju hj">in </strong>range(0,len(keyword_list)):<br/>    dict[keyword_list[i]]=scaling_list[i]<br/>x = {k: v <strong class="ju hj">for </strong>k, v <strong class="ju hj">in </strong>sorted(dict.items(), key=<strong class="ju hj">lambda </strong>item: item[1],reverse=<strong class="ju hj">True</strong>)}<br/>list_x=[]<br/><strong class="ju hj">for </strong>key <strong class="ju hj">in </strong>x:<br/>    list_x.append(key)<br/>keywords_less_than_5(list_x[0:5],string)</span></pre><p id="c3ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是将所有数据帧组合在一起的时候了，所以pd.concat也在做同样的事情。将分析视为一个整体将是一个伟大的想法，所以我创建了一个函数create_excel。现在，我们将所有的缩放值和关键字一起放在一个字典中，我们将按降序排列它们，并拥有我们自己的5个在谷歌上搜索最多的关键字。为了得到最终结果，我们将在一个名为keywords_less_than_5的函数中发送最终列表作为参数。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="8001" class="jy jz hi ju b fi ka kb l kc kd"><strong class="ju hj">def </strong>keywords_less_than_5(name_list):<br/>     interest_over_time_df = list_pytrends(name_list)<br/>     create_graphs(interest_over_time_df)<br/>     create_excel(interest_over_time_df,name_list)</span></pre><p id="c0cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经有了所有关键字的最终数据框架，现在是时候创建一个最终的excel表格和一个最终的图表，显示其中搜索次数最多的关键字。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b220" class="jy jz hi ju b fi ka kb l kc kd"><strong class="ju hj">def </strong>create_graphs(interest_over_time_df,string):<br/>    sns.set(color_codes=<strong class="ju hj">False</strong>)<br/>    ax = interest_over_time_df.plot.line(figsize=(9, 6),title=<strong class="ju hj">"Interest Over Time"</strong>)<br/>    ax.set_xlabel(<strong class="ju hj">'Date'</strong>)<br/>    ax.set_ylabel(<strong class="ju hj">'Trends Index'</strong>)<br/>    ax.tick_params(axis=<strong class="ju hj">'both'</strong>, which=<strong class="ju hj">'major'</strong>, labelsize=13)<br/>    ax.figure.savefig(<strong class="ju hj">'static/plot_'</strong>+string+<strong class="ju hj">'.png'</strong>)<br/><br/><strong class="ju hj">def </strong>create_excel(interest_over_time_df,name_list,string,final):<br/>    interest_over_time_df.reset_index(level=0, inplace=<strong class="ju hj">True</strong>)<br/>    pd.melt(interest_over_time_df, id_vars=<strong class="ju hj">'date'</strong>, value_vars=name_list)<br/>     interest_over_time_df.to_excel(<strong class="ju hj">'static/trends_'</strong>+string+<strong class="ju hj">'_'</strong>+final+<strong class="ju hj">'.xlsx'</strong>)</span></pre><p id="5c2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，它以一个漂亮的图表和一个完美的最终关键字excel表结束。</p><p id="b0a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最终代码如下所示</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="bb31" class="jy jz hi ju b fi ka kb l kc kd"><strong class="ju hj">def </strong>keywords_more_than_5(searches,string):<br/>    i = 0<br/>    middle_brand = <strong class="ju hj">""<br/>    </strong>interest_over_time_df = {}<br/>    count = 0<br/>    flag=0<br/>    <strong class="ju hj">while </strong>i &lt; len(searches) :<br/>        kw = []<br/>        <strong class="ju hj">if </strong>i &lt; len(searches):<br/>            kw.append(searches[i])<br/>        <strong class="ju hj">if </strong>i + 1 &lt; len(searches):<br/>            kw.append(searches[i + 1])<br/>        <strong class="ju hj">if </strong>i + 2 &lt; len(searches):<br/>            kw.append(searches[i + 2])<br/>        <strong class="ju hj">if </strong>i + 3 &lt; len(searches):<br/>            kw.append(searches[i + 3])<br/>        <strong class="ju hj">if </strong>i == 0:<br/>            <strong class="ju hj">if </strong>i + 4 &lt; len(searches):<br/>                kw.append(searches[i + 4])<br/>            flag=1<br/>            i=i+5<br/>        <strong class="ju hj">else</strong>:<br/>            flag=0<br/>            kw.append(middle_brand[0])<br/>            prev_middle_brand=middle_brand[1]<br/>            i = i + 4<br/>        interest_over_time_df[count] = list_pytrends(kw)<br/>        <strong class="ju hj">if </strong>kw[len(kw)-2]!=searches[len(searches)-1]:<br/>            middle_brand = middle_product(interest_over_time_df[count])<br/><br/>        interest_over_time_df[count].loc[<strong class="ju hj">'mean'</strong>] = interest_over_time_df[count].mean(0)<br/>        <strong class="ju hj">if </strong>flag==1:<br/>            interest_over_time_df[count].loc[<strong class="ju hj">'scaling'</strong>]=interest_over_time_df[count].mean(0)<br/>        <strong class="ju hj">else</strong>:<br/>           interest_over_time_df[count].loc[<strong class="ju hj">'scaling'</strong>]=scaling_func(interest_over_time_df[count],prev_middle_brand)<br/>        count += 1<br/>    df = pd.concat(interest_over_time_df, axis=1)<br/>    df.columns = df.columns.droplevel(0)<br/>    create_excel(df,searches,string,<strong class="ju hj">""</strong>)<br/>    scaling_list=df.values[-1].tolist()<br/>    keyword_list=list(df.columns.values)<br/>    dict={}<br/>    keyword_list=keyword_list[1:]<br/>    scaling_list=scaling_list[1:]<br/>    <strong class="ju hj">for </strong>i <strong class="ju hj">in </strong>range(0,len(keyword_list)):<br/>        dict[keyword_list[i]]=scaling_list[i]<br/>    x = {k: v <strong class="ju hj">for </strong>k, v <strong class="ju hj">in </strong>sorted(dict.items(), key=<strong class="ju hj">lambda </strong>item: item[1],reverse=<strong class="ju hj">True</strong>)}<br/>    list_x=[]<br/>    <strong class="ju hj">for </strong>key <strong class="ju hj">in </strong>x:<br/>        list_x.append(key)<br/>    <br/>    keywords_less_than_5(list_x[0:5],string)</span><span id="5e2e" class="jy jz hi ju b fi ke kb l kc kd"><strong class="ju hj">def </strong>middle_product(interest_over_time_df):<br/>    avg_list = interest_over_time_df.mean(0)<br/><br/>    x = {k: v <strong class="ju hj">for </strong>k, v <strong class="ju hj">in </strong>sorted(avg_list.items(), key=<strong class="ju hj">lambda </strong>item: item[1])}<br/>    j = 0<br/>    <strong class="ju hj">for </strong>key <strong class="ju hj">in </strong>x:<br/>        <strong class="ju hj">if </strong>(j == 2):<br/>            middle_brand = (key)<br/>            avg_value=x[key]<br/>        j = j + 1<br/><br/>    <strong class="ju hj">return </strong>middle_brand,avg_value<br/><br/><br/><strong class="ju hj">def </strong>scaling_func(df,avg_val_prev):<br/>    scaling_list=df.values[-1].tolist()<br/>    common=scaling_list[len(scaling_list)-1]<br/>    list=[]<br/>    <strong class="ju hj">for avg_value in </strong>scaling_list:<br/>        avg_value=avg_value*avg_val_prev/common<br/>        list.append(avg_value)<br/>    <strong class="ju hj">return </strong>list</span><span id="39ed" class="jy jz hi ju b fi ke kb l kc kd"><strong class="ju hj">def </strong>keywords_less_than_5(name_list):<br/>     interest_over_time_df = list_pytrends(name_list)<br/>     create_graphs(interest_over_time_df)<br/>     create_excel(interest_over_time_df,name_list)</span><span id="01a6" class="jy jz hi ju b fi ke kb l kc kd"><strong class="ju hj">def </strong>create_graphs(interest_over_time_df,string):<br/>    sns.set(color_codes=<strong class="ju hj">False</strong>)<br/>    ax = interest_over_time_df.plot.line(figsize=(9, 6),title=<strong class="ju hj">"Interest Over Time"</strong>)<br/>    ax.set_xlabel(<strong class="ju hj">'Date'</strong>)<br/>    ax.set_ylabel(<strong class="ju hj">'Trends Index'</strong>)<br/>    ax.tick_params(axis=<strong class="ju hj">'both'</strong>, which=<strong class="ju hj">'major'</strong>, labelsize=13)<br/>    ax.figure.savefig(<strong class="ju hj">'static/plot_'</strong>+string+<strong class="ju hj">'.png'</strong>)<br/><br/><strong class="ju hj">def </strong>create_excel(interest_over_time_df,name_list,string,final):<br/>    interest_over_time_df.reset_index(level=0, inplace=<strong class="ju hj">True</strong>)<br/>    pd.melt(interest_over_time_df, id_vars=<strong class="ju hj">'date'</strong>, value_vars=name_list)<br/>     interest_over_time_df.to_excel(<strong class="ju hj">'static/trends_'</strong>+string+<strong class="ju hj">'_'</strong>+final+<strong class="ju hj">'.xlsx'</strong>)</span></pre><p id="9249" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望有帮助:-)。感谢您的宝贵时间！！</p></div></div>    
</body>
</html>