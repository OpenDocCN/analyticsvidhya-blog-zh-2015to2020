<html>
<head>
<title>Solving Noisy Text CAPTCHAs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决嘈杂的文本验证码</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/solving-noisy-text-captchas-126734c3c717?source=collection_archive---------2-----------------------#2020-01-15">https://medium.com/analytics-vidhya/solving-noisy-text-captchas-126734c3c717?source=collection_archive---------2-----------------------#2020-01-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="302c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">验证码作为一种机制存在，以防止机器人发送垃圾API，抓取网站，以及整体滥用供人类使用的互联网特权。从概念上来说，CAPTCHA已经从简单的无衬线字体中的简单黑白分离字符发展到包括多种颜色、噪声、变化的字体、变化的字符比例和复杂的消息/单词，如图1所示，其中简单的无衬线字体很少或没有变换(例如旋转)。虽然最初很难解决，但系统最终发展到包括图像验证码、音频验证码和称为reCAPTCHA的多模式用户交互验证码，这些都可以在图3中看到。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/1f9d88155ff026b01e403acb8c90039b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*pV2Ku6kJ4kOPUnY9.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">图一。</strong>简单文本验证码示例</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/2243451900173d94175a55354b3043a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*kRCyxiquZvtE1Xg1qYSIUg.jpeg"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">图二。</strong>更复杂文本验证码的示例</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jr"><img src="../Images/8c4b92b94219d1b49f33c2849c1f4f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*ZLFBsVOc3W6U-qrm.jpg"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">图三。</strong>验证码的三种现代形式。左上:reCAPTCHA。左下角:音频验证码。右图:验证码图片</figcaption></figure><h1 id="9ffd" class="js jt hi bd jp ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">工作</h1><p id="292a" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">虽然有些显而易见，但这个项目更大的目标是通过预测隐藏在消息中的字符来破译文本验证码。然而，这本身是一项困难的任务，因为存在验证码的36⁴排列，假设验证码包含4个字符，其中每个字符可以是36个字符(a-z0–9)中的一个。因此，不是在36⁴-way分类任务上评估监督模型，而是将目标简化为字符识别，这需要通过分割验证码进行额外的预处理，但是创建了36路分类任务而不是36⁴-way分类任务。</p><h1 id="1d9f" class="js jt hi bd jp ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">资料组</h1><p id="a377" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">到2020年写这篇博客的时候，文本验证码已经相对过时了。尽管如此，它们确实存在，并且将它们用作计算机视觉辅助项目的玩具问题来说明传统的视觉技术(例如腐蚀、去噪等)是有价值的。)和深度学习技术(即CNN)。在这个项目中，将使用类似于图2所示的验证码。这些验证码是通过使用Python验证码库(<a class="ae ku" href="https://github.com/lepture/captcha/" rel="noopener ugc nofollow" target="_blank">https://github.com/lepture/captcha/</a>)以140x76的分辨率由4个字符生成的，包含大写英文字母(A-Z)和数字0-9，总共36个不同的字符。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kv"><img src="../Images/4d5f91dd8cc8187b60df9de87518d528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wiwh8tUKBZBZSHiy.jpg"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">图4。</strong>本项目数据集中使用的文本验证码示例</figcaption></figure><h1 id="e23b" class="js jt hi bd jp ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">预处理</h1><h2 id="30cc" class="la jt hi bd jp lb lc ld jx le lf lg kb iq lh li kf iu lj lk kj iy ll lm kn ln bi translated">挑战</h2><p id="8845" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">由于几种不同的特征，这种形式的文本验证码难以破译。首先，图像包含两种形式的噪声:点噪声和线噪声。点噪点通常很容易管理，尤其是以椒盐噪点的形式，但这张图像中的点看起来大小不一，呈圆形，这使它稍微有点困难。同时，线噪声增加了额外的挑战，因为它与试图从图像中破译的字符相交，同时是曲线而不是完美的线性。第二，图像是彩色的，背景是非白色的。二进制阈值处理相对容易地解决了这个挑战，但是在背景和字符具有相似颜色的情况下，它仍然是一个障碍。第三，人物重叠。第四，字符不像图1中那样处于固定的角度。第五，字符在大小上既不是定宽也不是定高。第六，字符之间的比例不同。</p><p id="bb09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预处理验证码有两个步骤。首先，除了在下一步中帮助分割之外，从图像中去除噪声以减少由训练过的网络学习到的偏差。第二，字符被分割，以便将问题转化为字符识别任务。因此，由于N个验证码每个包含4个字符，所以为我们的模型的字符识别数据集生成了4N个字符。</p><p id="79f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，RGB图像作为灰度图像读入，以简化任何去噪过程；所有像素值都在0–255的范围内。接下来，用阈值230对图像进行二值化。因此，所有小于等于230的像素亮度值都转换为亮度值0(黑色)，大于230的像素亮度值都转换为255(白色)。这个阈值完全是经验性的，在手动检查图像后，在几乎所有可观察到的情况下都有效。</p><h2 id="567f" class="la jt hi bd jp lb lc ld jx le lf lg kb iq lh li kf iu lj lk kj iy ll lm kn ln bi translated">消除噪音</h2><p id="e459" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">现在，一旦图像被简化为基本形式，预处理的第一个真正步骤是去除噪声。如前所述，图像中存在的两种形式的噪声是圆形噪声和水平曲线噪声。</p><p id="8b77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像首先被反转，因此字母是白色的，背景是黑色的。然后，用(2，2)的核进行1次迭代的腐蚀，以削弱圆和线噪声。通常，对于较大的图像和较厚的圆/线噪声，该内核应该较大，但它适用于此任务中的数据集。</p><p id="ad84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，中值滤波器来削弱任何额外的线。第一个中值滤波器是(5，1)，代表长度为5的垂直滤波器，可以去除图像中几乎所有的线噪声。巧合的是，这也有助于削弱一些圈子的噪音。然后，维度(1，3)的水平滤波器移除大部分圆形噪声。在这一点上，我们不仅侵蚀了噪音，而且还侵蚀了一些保持我们的角色健全和完整所必需的实际角色数据。因此，使用滤波器大小(2，2)对1次迭代执行膨胀，以使字母更大。这里要注意的关键是，膨胀比任何残留的噪声图像更能让字母恢复生机。然而，由于膨胀，残留的小噪声可能在整个图像中变得更加明显，因此大小为(3，3)的最终中值滤波器在图像上通过，以去除任何残留的最终弱噪声。</p><p id="27b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在项目进行过程中，经验评估对于确保所有预处理和训练程序正确执行至关重要。因此，在对去噪图像进行一些定性评估后，偶尔会出现一些额外的噪声。最初，我不打算处理这个问题，因为它需要额外的工作来获得额外的好处，但它最终导致了细分的挑战。因此，一些最终程序被用于去除最终噪声。首先，霍夫圆变换检测圆心和它们的半径，它们用作去除任何附加圆噪声的掩模。检测半径在0和2之间的圆，每个圆之间的最小距离为1。然后，在去除圆之后，用(3，3)核对图像进行1次迭代，以从圆噪声中去除任何边缘。(5，1)垂直中值滤波器清除了额外的水平噪声。倒数第二个过程是使用(3，3)滤波器进行2次迭代的膨胀，以恢复图像，这最终会创建浮肿的字符，并在图像中引入更多的噪声。最后一步是用大小为(3，3)的核对图像进行1次迭代。从质量上来说，这几乎消除了所有的噪声，无论是圆形的还是线性的。</p><p id="c2b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，图像应该几乎完全没有噪声，只包含散布在整个图像中与字符相交的残余噪声。</p><h2 id="587e" class="la jt hi bd jp lb lc ld jx le lf lg kb iq lh li kf iu lj lk kj iy ll lm kn ln bi translated">字符分割</h2><p id="a008" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">一旦噪声被去除，单个字符被从图像中分割出来，以便在字符分类任务中训练模型。</p><p id="9c05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，使用OpenCV的connectedComponents(…)函数检测图像的连通分量。然后，分水岭算法试图进一步分割重叠字符。</p><p id="1475" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理想情况下，由于所有字符都不相交，并且图像中没有残留噪声，因此应该返回4个分量，表示4个字符。但是，有时会出现错误，指示字符重叠(几乎无法分割)或噪音被识别为字符的情况。第一种情况很难，但有可能解决，而第二个问题很容易解决。例如，在包含4个字符的140x76图像中，在验证码完全不可读之前，字符只能如此之大和如此之小。这样，根据经验确定包含少于100个像素的字符掩模是“噪声”，因此从图像的任何未来预处理中去除它。第二，当图像包含≥ 2200个像素时，字符被认为是“联合字符”，这意味着掩码包含两个相互交叉的字符。为了解决这个问题，使用了一种简单的方法。掩码直接从中间分开，左边的子掩码是一个字符，右边的子掩码是另一个字符。这种去除“噪声”屏蔽和细分“联合字符”屏蔽的迭代方法被执行10次迭代。此时，如果恰好没有生成4个掩码，则验证码被从数据集中丢弃，这被认为是一个糟糕的例子，因为所有4个字符的掩码都不能被识别。通过统计分析，在生成的掩码中存在一致的5%的误差，这表明N个生成的验证码中有5%被从用于训练和评估的最终数据集中丢弃。到目前为止，在Google Colab虚拟机上预处理100万验证码大约需要3个小时。</p><p id="51c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦检索到字符，预处理和分割的最后一步是将它们方形化。这是一个要求，因为卷积神经网络(CNN)需要固定大小的输入。因此，具有45x67和76x65尺寸的字符会导致模型抛出大小不匹配错误。为了补救这一点，背景像素被添加到已经分割的字符图像中，以强制字符为76×76，同时也在图像中居中。整个过程如图5所示，显示了预处理的4个主要步骤(原始图像、二值化、去噪和分割)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/409ae7042097eae84354507def897c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*sW8-hFvIkIMQLg6HJH_fUA.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/22701812e82949f8ee8cd591479fd4fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*JiMDYBZv6ekdZYGUbxhVuQ.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/18cc2396066ea7dbffe3b9b28af95f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*I1ey77s1Ge_RtHMZCWWA7w.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lo"><img src="../Images/967d9906c10e75d4051437936eb57334.png" data-original-src="https://miro.medium.com/v2/resize:fit:182/format:webp/0*JJ8ALSPllm3RyuBn.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">图5。</strong>第一张图片:原始RGB验证码图片。第二张图片:二进制验证码。第三张图片:去噪验证码。第4-7张图片:从验证码中分割出来的字符</figcaption></figure><p id="129b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在去噪和分割验证码之后，我们已经从N个验证码图像到空间A-Z0–9(36个类别)中的4N个字符。现在是训练模型识别这些字符的时候了。</p><h1 id="fedf" class="js jt hi bd jp ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">模型</h1><p id="7505" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">该模型最初是一个预训练的AlexNet，后来转变为一个定制的卷积神经网络(CNN)。该网络可描述如下:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="8498" class="la jt hi lq b fi lu lv l lw lx">2D Conv: in = 1, out = 20, kernel = (5, 5), stride = 1, padding = 4<br/>ReLU()<br/>2D Max Pool: kernel = (2, 2), stride = 2, padding = 0, dilation = 1<br/>2D Conv: in = 20, out = 50, kernel = (5, 5), stride = 1, padding = 4<br/>ReLU()<br/>2D Max Pool: kernel = (2, 2), stride = 2, padding = 0, dilation = 1<br/>Flatten()<br/>FC: in = 24200, out = 500, bias = true<br/>ReLU()<br/>FC: in = 500, out = 36, bias = true</span></pre><p id="567d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与最近的视觉文献相比，这种深度学习架构相对较浅，但它完成了工作。这个模型的PyTorch实现可以在model.py文件的代码中找到。这个模型没有什么特别的，但保持它相对简单是有用的，因为更先进/最新的深度学习架构得到了测试(VGG，雷斯网)，它们实际上比这个模型表现得更差，这表明可能对数据集过度拟合。此外，从从业者的角度来看，在整个过程中根据需要修复/修改架构更加容易。</p><p id="8fc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ly">注:</em>对于卷积层，in = #个输入通道，out = #个输出通道。对于全连接层(FC)，in = #个输入神经元，out = #个输出神经元。最后，对于最后一个FC层，out = 36，因为有36个类。</p><h1 id="6a8d" class="js jt hi bd jp ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">培养</h1><p id="59d6" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">该模型的训练是一个相对简单的过程，非常类似于处理MNIST分类的项目。Adam优化器与交叉熵损失一起使用(“总和”减少，而不是“平均值”减少)。根据经验，对于优化器，学习率为0.0001，权重衰减为0.98，批处理大小为32时效果最佳。当我用100个时期训练时，模型通常在不到20个时期内收敛。</p><p id="49ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">培训阶段使用的模型如上所述。值得注意的是，所有传入网络的图像尺寸都是76x76x1(第三通道表示灰度)。</p><p id="6f49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">学习率衰减进行了实验，但由于缺乏影响，最终从最终培训中省略。然而，批量大小确实起了作用。人们发现，一个批次的&lt; 32 hurt performance significantly, while a batch size &gt; 512只略微损害了准确性。</p><p id="344f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，最终使用0.00005的学习率来训练批量为512的模型。虽然在32 ≤ <em class="ly"> batch_size </em> ≤ 512的范围内没有观察到批量大小产生显著影响，但是选择更大的批量大小以加速训练过程。</p><p id="ae29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练模型的一些最重要的设计选择实际上必须处理数据集。数据集大小和分区大小对模型的性能都有相当大的影响。第一次试验是在1000个验证码(约4000个字符)的数据集上进行的。这最终增加到10K、100K和1M验证码，分别生成大约40K、400k和4M个字符。实际上，由于前面提到的来自<em class="ly">预处理</em>部分的5% CAPTCHA分段错误率，数据集中的字符数最终低于估计数。这些数据集大小的精确度在<em class="ly">结果</em>部分进行了说明。同时，分别以60%/20%/20%的比率进行初始训练/验证/测试分割。然而，深度学习的一个简洁特征是，验证和测试规模不需要保持与训练集规模的特定比例，就可以被认为是“体面的”或“无偏见的”。因此，一旦数据集增加到1M验证码，拆分就转变为80%/10%/10%，这仍然为验证和测试拆分保留了大的平衡分区，同时允许模型查看更多的训练图像，从而提高未来的鲁棒性。</p><p id="2c8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，在进行了所有的设计选择之后，对模型进行了训练。使用上述超参数，培训在NVIDIA K80 GPU(从Google Colab获得)上进行了大约10个小时。</p><h1 id="badc" class="js jt hi bd jp ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结果</h1><p id="d606" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这个项目主要关注的是验证码的解码，同时也利用了字符识别子任务的重要贡献。主任务和子任务都在这一部分进行了评估，但只有字符识别任务进行了定性评估。</p><p id="eb2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这项任务最重要的评估标准是准确性，这是定量的。当通过CAPTCHA设计一个健壮的安全系统时，F1-score、precision和recall等指标几乎没有用。架构师只关心确保非人类用户的低成功率。在这个实验中，当系统可以识别验证码中的所有4个字符时，我们数据集的假设是成功的；任何更少都表示失败。因此，计算精度相对简单。直觉上，高的CAPTCHA解码率意味着高的字符识别准确度。因此，精确度用于任务/数据集，结果显示如下。</p><h2 id="0594" class="la jt hi bd jp lb lc ld jx le lf lg kb iq lh li kf iu lj lk kj iy ll lm kn ln bi translated">数量的</h2><p id="9ef7" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在讨论定量结果之前，先讨论一下预期结果是很重要的。在MNIST分类任务中，通常会遇到达到99%以上分类准确率的模型，但该任务和该任务之间的区别是MNIST是10路分类(不是36路)，数字不需要预处理，因为它们是事先精心策划给研究人员的。因此，在训练模型之前，预期的准确度应该在80-100%之间。此外，假设模型在字符分类任务上达到X%的准确度，我们可以估计CAPTCHA任务的准确度，因为它是简单的字符排列。例如，如果模型达到80%的字符分类准确率，每个类别都有相同的成功可能性，我们预计验证码的准确率为(0.8)⁴ = 0.4096 = 40.96%)。在表1的右栏中观察到所有预期的验证码准确性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lz"><img src="../Images/5601040f29f831eacaecc5584f2b41b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/0*65mPZz2MDm1W1gfM.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">表1。</strong>左栏是我们的模型在字符分类任务上达到的给定准确率。右栏包含预期的验证码准确率。这些数字是理论上的，不是经验上的。</figcaption></figure><p id="e312" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，肯定的情况是字符分类为90%，这表明得到整个验证码的情况比随机翻转好。然而，理想的情况是字符准确度为95%或99%，这导致了自信的CAPTCHA解码模型。但是，关于精度期望的理论讨论已经足够了。让我们来看看实际的经验结果。</p><p id="06fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，在训练我们的模型之后，我们观察字符识别的准确性:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ma"><img src="../Images/4d970e266398a669105c9bfee35d9850.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/0*jqcebOxcbo2I-N3u.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">表二。</strong>左边是数据集大小乘以生成的验证码数量。请记住，在预处理期间，5%的验证码被识别为“坏的”，每个验证码有4个字符，80%/10%/10%的训练/验证/测试分割用于字符识别训练。</figcaption></figure><p id="549a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们通过利用每个分段字符上的字符分类模型来观察验证码成功率:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mb"><img src="../Images/03a8c590f0fade8d54540edb1e43456e.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/0*c1tTwVkcKwtj7nEC.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">表3。</strong>显示在不同数据集大小上训练的模型在CAPTCHA数据集上的经验准确度。</figcaption></figure><p id="081e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如表2所示，数据集大小在字符分类准确性中起着重要作用，达到了近91%的准确性，这是一个积极的迹象。然而，当在成熟的验证码上使用91%的准确度模型时(通过与训练集相同的预处理阶段来分割字符)，返回44.41%的准确度，这比表1中的预期准确度低大约20%。这是一个有趣的结果，不仅是因为其本身的低准确性，而且是因为其准确性明显低于预期。</p><p id="b2d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乍一看，最初的假设是数据集是不平衡的。然而，经过一些分析后，认为情况并非如此。此外，由于数据集包含100万个验证码和大约400万个字符，我们假设这些字符是统一生成的，因此这是第二次验证，类别不平衡不是问题。所以，在这个想法被否决后，对单个字母的准确性进行了分析。如下图所示，几乎所有字母的准确率都在90%或更高，只有两个例外，O和0，这两个字母的准确率都很低，徘徊在50–70%的范围内。然而，这种情况的原因很简单，因为O和0在形状上非常相似。精度可在表4中观察到。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/8065f3c5b28124957c8239db387b7103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/0*vqt49qdNLKXGyHfi.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">表4。</strong>每个字符的精确度。</figcaption></figure><p id="4c40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在那次分析之后，我调查了模型错误分类的角色。表5包含属于特定类别的错误分类字符的比例。这个表提供了一些信息，显示一些字符比其他字符更容易被错误分类。虽然“O”是错误分类率最高的字符并不令人惊讶，但考虑到其低分类精度，“0”在错误率中排在第七位则有点令人惊讶。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es md"><img src="../Images/6bb974d866e933d7c49d3f746abc964e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/0*rDGqPyPerXrf_DL8.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">表五。</strong>字符的错误率。例如，如果有100个分类错误的字符，我们预计其中大约有7个O(0.0714 * 100 = 7.14 ~ 7个O)和1个Q (0.0095 * 100 = 0.95 ~ 1个Q)。</figcaption></figure><p id="0004" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管有这些分析，也不能确定为什么验证码的准确性比预期的低这么多。然而，尽管如此，准确度仍然是可管理的，考虑到44%的成功率并不是世界上最糟糕的情况，并且大多数文本验证码机制允许用户生成新的验证码。</p><h2 id="5adf" class="la jt hi bd jp lb lc ld jx le lf lg kb iq lh li kf iu lj lk kj iy ll lm kn ln bi translated">定性的</h2><p id="720d" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">虽然定量结果是客观和简单的，但定性结果也总是受到重视。不值得浪费你的时间来展示预测给定字符标签的模型。相反，t-SNE曲线是为数字创建的，如图6和图7所示。在图6中，76x76字符图像被展平以产生5775个图像“特征”/像素，而没有被传递到分类器中。相反，图7通过完全训练的字符分类模型传递图像，并且从最后完全连接的层中提取500个特征。虽然执行t-SNE(一种迭代的非线性降维技术)足以产生一些好看的图，但t-SNE在计算上是昂贵的，根据方法的不同，运行时间为O(NlogN)或O(N)。因此，图像特征通过PCA(封闭形式的线性维数缩减技术)被缩减到100个分量，然后这些分量被传递到t-SNE算法中以产生下面的可视化。这大大减少了训练t-SNE算法所需的时间。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lz"><img src="../Images/58016e4437c0cb09726212335435a6cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/0*S-kJ-TARfNKeq5Ox.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">图6。</strong>使用原始图像显示类别的t-SNE图。</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es me"><img src="../Images/c8b6c9033c71ce27c4edf001709a5de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/0*lYsqB_DqvboUZsVV.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp">图七。</strong>从完全训练的模型中提取的角色特征的t-SNE图。</figcaption></figure><p id="eeee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ly">注:</em>这些图说的是“数字”，其实应该是“字符”。这些图实际上是所有36个类别的，而不是一个子集。</p><p id="4c88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得讨论的一个要点是类的可分性。前后剧情令人咋舌。通过训练的模型，类内变异性显著降低，而类间可分性适度增加。值得将这个来自具有91%分类准确度的模型的图与MNIST t-SNE图(来自仅在10个类别上具有99.2%准确度的模型)进行比较，可以在这里找到:<a class="ae ku" href="https://github.com/kingsman142/mnist-classification" rel="noopener ugc nofollow" target="_blank">https://github.com/kingsman142/mnist-classification</a>。显然，可分性并不理想，但是对于36个类的可视化，我对结果很满意。在3D绘图中，我假设存在更大的类间可分性，但这超出了本项目的范围。</p><p id="54f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ly">注</em>:我计划为两个图创建图例，显示每个类的颜色，但结果证明matplotlib的工作量太大，不值得，而且会使图看起来很丑，所以我避免了麻烦。</p><h1 id="e46d" class="js jt hi bd jp ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">讨论</h1><h2 id="1346" class="la jt hi bd jp lb lc ld jx le lf lg kb iq lh li kf iu lj lk kj iy ll lm kn ln bi translated">假设</h2><p id="a419" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">本项目中有一个无止境的假设列表，以使其更容易处理，我们将尝试列出尽可能多的假设:</p><ul class=""><li id="89ac" class="mf mg hi ih b ii ij im in iq mh iu mi iy mj jc mk ml mm mn bi translated">在所有验证码中，线噪声总是相同的宽度</li><li id="ad02" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">线条噪点总是比字符的笔画宽度细</li><li id="d9b7" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">图像总是140x76</li><li id="e02e" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">圆形噪波总是相同的半径</li><li id="e641" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">验证码中只使用了4个字符</li><li id="0c77" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">验证码数据集图像都包含大致相同的样式</li><li id="a5e1" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">验证码数据集的样式并不是所有生成验证码的Python库或研究论文中最复杂的样式</li><li id="6747" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">线路噪声通常总是水平的，而不是垂直的</li><li id="d91a" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">人物没有被掏空</li><li id="6c4e" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">验证码不是3D的</li><li id="878b" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">不使用小写字母(将问题转化为62类问题)</li><li id="c6cf" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">一次最多连接两个字符</li><li id="58ec" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">背景和文字之间有足够的对比度，阈值处理在预处理中是有效的</li></ul><h2 id="273c" class="la jt hi bd jp lb lc ld jx le lf lg kb iq lh li kf iu lj lk kj iy ll lm kn ln bi translated">挑战</h2><p id="f221" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">假设的另一面是挑战，这是通过这个特定的数据集使任务具有挑战性的困难。它们可以在下面找到:</p><ul class=""><li id="5f6e" class="mf mg hi ih b ii ij im in iq mh iu mi iy mj jc mk ml mm mn bi translated">字符的大小不是固定宽度的</li><li id="2b17" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">字符的大小没有固定的高度</li><li id="3894" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">不在固定(x，y)位置的字符</li><li id="1a9d" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">字符没有固定的角度</li><li id="a312" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">图像为RGB格式，颜色差异很大</li><li id="5489" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">图像有圆形噪声</li><li id="e8b3" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">图像有曲线噪声</li><li id="0261" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">圆形噪声不是盐和胡椒风格的，这使得用中值滤波器去除非常简单</li><li id="9549" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">线路噪声不是完全线性的，因此必须利用多种组合梯度技术和滤波器来尽可能消除它</li><li id="d3ac" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">字符的比例不同(一些比另一些大/小)</li><li id="8fa0" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">验证码只包含4个字符</li></ul><h2 id="f743" class="la jt hi bd jp lb lc ld jx le lf lg kb iq lh li kf iu lj lk kj iy ll lm kn ln bi translated">可能的研究</h2><p id="470b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">对研究的深入分析可能会在今后对这份报告进行修正，但它们没有报告的内容重要。因此，下面将列出多个问题，其中包含有用的启发性问题:</p><ul class=""><li id="e950" class="mf mg hi ih b ii ij im in iq mh iu mi iy mj jc mk ml mm mn bi translated">阈值处理在预处理步骤中有帮助吗？阈值对预处理图像有影响吗？</li><li id="b670" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">去噪有帮助吗？虽然直觉的答案是肯定的，但如果我们只是天真地将角色分开呢？假设数据集足够大，字符分类准确率会显著下降吗？</li><li id="7a5f" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">与其他更复杂的技术相比，从中间分割连体角色会影响性能吗？</li><li id="2317" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">字符的白色填充(当切分字符时)重要吗？</li><li id="eaf4" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">如果我们完全平衡数字数据集会发生什么？它已经相当平衡了，但是值得研究一下平衡是否会影响精度1-2%。</li></ul><h2 id="e2a8" class="la jt hi bd jp lb lc ld jx le lf lg kb iq lh li kf iu lj lk kj iy ll lm kn ln bi translated">结果</h2><p id="e11d" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在这份报告中，更大的任务是解决嘈杂的文本验证码。虽然更大的目标是验证码，但一个必要的字符分类子任务被执行，实现了约91%的准确率。然而，尽管有这种令人印象深刻的准确性，但在现实中，在CAPTCHA任务上的准确性是44.41%，这比给定字符分类准确性的预期低约20%。尽管如此，通过定性评估，模型显示与原始数据本身相比，类内可变性和类间可分性有所改善，这是一个重要且至关重要的观察结果。</p><p id="d581" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在未来，值得探索更高级的预处理步骤以更有效地分割字符，以及执行数据增强技术和确定验证码解码准确性低的根本原因。</p><p id="91a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总而言之，我认为这个项目是成功的。它包含大量代码，除了现代深度学习模型之外，还需要传统的低级计算机视觉技术。更大的目标有一个必须首先完成的子任务，并且在两个任务上都取得了令人满意的结果，这导致了在现实世界中解决有噪声的文本验证码的实际应用。</p><h1 id="e63a" class="js jt hi bd jp ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">技术</h1><p id="463e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在预处理、培训和评估方面，使用了以下技术来构建整个系统(未提供版本):</p><ul class=""><li id="dc08" class="mf mg hi ih b ii ij im in iq mh iu mi iy mj jc mk ml mm mn bi translated">Python3</li><li id="c34f" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">PyTorch</li><li id="8340" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">sci kit-学习</li><li id="a2d0" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">Scipy</li><li id="48d5" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">OpenCV</li><li id="08ae" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">NumPy</li><li id="7634" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">Matplotlib</li></ul><p id="5ede" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完整代码可以在这里找到:<a class="ae ku" href="https://github.com/kingsman142/captcha-solver" rel="noopener ugc nofollow" target="_blank">https://github.com/kingsman142/captcha-solver</a>。</p><p id="83c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个预先训练好的模型可以在这里找到:<a class="ae ku" href="https://drive.google.com/open?id=16Vwha7uxy7coe9y-Nkh6skYPW3Kz8xZA" rel="noopener ugc nofollow" target="_blank">https://drive.google.com/open?id = 16 vwha 7 uxy 7 coe9y-nkh 6 sky pw 3 kz 8 xza</a>。为了使用它，在项目根目录中创建一个模型/目录，并将模型放在那里，然后按照上面存储库中的说明来评估模型。</p></div></div>    
</body>
</html>