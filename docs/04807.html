<html>
<head>
<title>Deploy Production Ready Keras model with TensorFlow Serving and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TensorFlow服务和Docker部署生产就绪的Keras模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deploy-production-ready-keras-model-with-tensorflow-serving-and-docker-85615245a9ed?source=collection_archive---------3-----------------------#2020-04-01">https://medium.com/analytics-vidhya/deploy-production-ready-keras-model-with-tensorflow-serving-and-docker-85615245a9ed?source=collection_archive---------3-----------------------#2020-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e976" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">从模型原型到生产就绪服务</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/354daffbf4f83bfad9e77bbd20283c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5kUpNehkO90yJtW2.png"/></div></div></figure><h1 id="7ac0" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="9dc2" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">作为一名数据科学家，有几次我被要求训练一个模型，其最终用途将是自动化某些任务，或者实时做出决策。在这种情况下，人们对模型背后的数学或准备数据集来训练模型的统计技术不感兴趣。他们希望我们为他们提供一个URL端点，在那里他们可以发布一个带有特定值的请求，并从模型中获得结果。</p><p id="babc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将首先训练一个Keras模型，然后用TensorFlow Serving和Docker部署它。</p><p id="7472" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个例子，我们将使用Kaggle的<a class="ae kt" href="https://www.kaggle.com/c/dogs-vs-cats/data" rel="noopener ugc nofollow" target="_blank">数据集</a>来训练经典的<em class="jd">狗vs猫</em>分类器。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/105e56d81d6ed5cf329ef4dc57b6d60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2aUQfgyB9q1MRbNyFBkBg.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">Kaggle数据集上的图像示例</figcaption></figure><h1 id="f3b9" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Keras模型</h1><p id="70cf" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">那么，什么是<a class="ae kt" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>？</p><blockquote class="kz"><p id="0a74" class="la lb hi bd lc ld le lf lg lh li jc dx translated">Keras是一种高级神经网络API，用Python编写，能够在TensorFlow、CNTK或Theano之上运行。它的开发重点是支持快速实验。能够以尽可能少的延迟从想法到结果是做好研究的关键。</p></blockquote><p id="c6c2" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">Keras让我们能够通过使用它们的API，以简单而优雅的方式训练深度学习模型。在本文中，我们将使用TensorFlow 2.x框架中的Keras模块。这是我们将使用的模块和库:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="8f0e" class="lu jr hi lq b fi lv lw l lx ly">from tensorflow.keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img<br/>from tensorflow.keras.models import Sequential, load_model<br/>from tensorflow.keras.layers import Flatten, Dense, Dropout<br/>from tensorflow.keras import optimizers<br/>from tensorflow.keras import backend as K<br/>from tensorflow.keras.applications.vgg16 import VGG16, preprocess_input<br/>import requests<br/>import numpy as np</span></pre><p id="02db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先下载Kaggle数据集，然后创建<em class="jd">训练</em>、<em class="jd">验证</em>和<em class="jd">测试</em>图像集，并参考保存图像的路径。</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="e705" class="lu jr hi lq b fi lv lw l lx ly">img_height = 256<br/>img_width = 256<br/>channels = 3<br/>batch_size = 8<br/>epochs = 20</span><span id="0608" class="lu jr hi lq b fi lz lw l lx ly"># Image Data Generators<br/>train_datagen = ImageDataGenerator(<br/>       rotation_range=40,<br/>       width_shift_range=0.2,<br/>       height_shift_range=0.2,<br/>       rescale=1./255,<br/>       shear_range=0.2,<br/>       zoom_range=0.2,<br/>       fill_mode='nearest')</span><span id="6608" class="lu jr hi lq b fi lz lw l lx ly">test_datagen = ImageDataGenerator(rescale=1./255)</span><span id="3192" class="lu jr hi lq b fi lz lw l lx ly"># Training, Validation and Test datasets<br/>training_set = train_datagen.flow_from_directory(<br/>    './dogscats/training',<br/>     target_size = (img_height, img_width),<br/>     batch_size = batch_size,<br/>     class_mode = 'binary')</span><span id="19b9" class="lu jr hi lq b fi lz lw l lx ly">validation_set = train_datagen.flow_from_directory(<br/>    './dogscats/validation',<br/>     target_size = (img_height, img_width),<br/>     batch_size = batch_size,<br/>     class_mode = 'binary')</span><span id="65fc" class="lu jr hi lq b fi lz lw l lx ly">test_set = train_datagen.flow_from_directory(<br/>    './dogscats/sample',<br/>     target_size = (img_height, img_width),<br/>     batch_size = 1,<br/>     shuffle = False,<br/>     class_mode = 'binary')</span></pre><p id="e1c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此命令将创建这三个数据集，当然会将它们分为以下两类:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="2a9c" class="lu jr hi lq b fi lv lw l lx ly">{'cats': 0, 'dogs': 1}</span></pre><p id="e9d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们继续训练一个简单的VGG16，它有一些<em class="jd">密集连接的层</em>和一个具有<em class="jd"> sigmoid激活</em>功能的输出神经元。因此，该模型将返回我们属于<em class="jd">狗</em>类的概率。</p><p id="b235" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用带有<em class="jd"> imagenet </em>数据集的预训练VGG16，并且仅重新训练最后5层，当然还有我们的<em class="jd">密集连接模型</em>:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="ef9e" class="lu jr hi lq b fi lv lw l lx ly"># VGG16 Model<br/>model = VGG16(weights = "imagenet", <br/>              include_top=False, <br/>              input_shape = (img_width, img_height, channels))</span><span id="c849" class="lu jr hi lq b fi lz lw l lx ly">for layer in model.layers[:-5]:<br/>    layer.trainable = False</span><span id="7aeb" class="lu jr hi lq b fi lz lw l lx ly">top_model = Sequential()<br/>top_model.add(model)<br/>top_model.add(Flatten())<br/>top_model.add(Dense(256, activation='relu'))<br/>top_model.add(Dropout(0.5))<br/>top_model.add(Dense(1, activation='sigmoid'))</span><span id="3157" class="lu jr hi lq b fi lz lw l lx ly"># Compile the model<br/>top_model.compile(loss='binary_crossentropy',<br/>                  optimizer=optimizers.RMSprop(lr=1e-4, decay=1e-6),<br/>                  metrics=['accuracy'])</span><span id="bc7a" class="lu jr hi lq b fi lz lw l lx ly"># Fit the model<br/>history = top_model.fit_generator(<br/>          training_set,<br/>          steps_per_epoch=training_set.n // batch_size,<br/>          epochs=epochs,<br/>          validation_data=validation_set,<br/>          validation_steps=validation_set.n // batch_size)</span></pre><p id="79a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是重要的部分，当训练结束时，将模型保存为<em class="jd"> tf </em>格式(我也将它保存为<em class="jd"> h5 </em>格式，这样我们就可以将预测与两个文件进行比较):</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="a0ef" class="lu jr hi lq b fi lv lw l lx ly"># Save the model<br/>top_model.save('output/vgg16_cats_vs_dogs.h5', save_format='h5')<br/>top_model.save('output/vgg16_cats_vs_dogs.pb', save_format='tf')</span></pre><p id="6aaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个命令应该会在<em class="jd">中创建以下文件。/输出</em>目录:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="b41c" class="lu jr hi lq b fi lv lw l lx ly">├── vgg16_cats_vs_dogs.h5<br/>├── vgg16_cats_vs_dogs.pb<br/>|         ├── assets<br/>│         ├── saved_model.pb<br/>│         └── variables<br/>│                  ├── variables.data-00000-of-00001<br/>│                  └── variables.index</span></pre><p id="8540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们用<em class="jd"> h5 </em>模型来预测下面一只猫的图像:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ma"><img src="../Images/a4f5ed1e01231c75c5776d03d0516d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*WVonhUX4MlT0wbo2LxF1bA.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">来自Kaggle数据集的猫图像</figcaption></figure><p id="412d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用下面的脚本，我们加载训练好的模型和图像，将图像转换为适当的格式，并通过使用<em class="jd"> predict </em>方法将其传递给训练好的模型:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="c25f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这几行代码返回以下数组:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="17de" class="lu jr hi lq b fi lv lw l lx ly">array([[1.5236342e-08]], dtype=float32)</span></pre><p id="4c04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们还记得，在之前的模型定义中，我们选择了只有一个输出神经元的模型，因此这个数字是图像属于“1”类(本例中为狗)的概率。因此，属于“猫”类的概率是该数字的补数:0.99999984763658。所以这个模型在这种情况下表现很好。</p><h1 id="e632" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">张量流服务</h1><p id="7f58" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated"><a class="ae kt" href="https://www.tensorflow.org/tfx/guide/serving" rel="noopener ugc nofollow" target="_blank"> TensorFlow Serving </a>是一个灵活、高性能的机器学习模型服务系统，专为生产环境而设计。TensorFlow服务使部署新算法和实验变得容易，支持模型版本化，同时保持相同的服务器架构和API。TensorFlow服务提供了与TensorFlow模型的现成集成，但可以轻松扩展为服务于其他类型的模型和数据。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es md"><img src="../Images/0c77808ba141e3dcefbc6590124670cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ySQ1nJ9vo4OLIQEE.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">张量流服务管道</figcaption></figure><h2 id="a126" class="lu jr hi bd js me mf mg jw mh mi mj ka iq mk ml ke iu mm mn ki iy mo mp km mq bi translated">在本地主机上部署我们的Keras模型</h2><p id="62bc" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">要启动本地服务器，我们需要在本地机器上安装一个TensorFlow服务实例。我们将使用Docker，而不是下载并安装所有必需的库</p><p id="478d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将生成以下Dockerfile文件:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="2289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一些我们应该定义的参数:</p><ul class=""><li id="0e65" class="mr ms hi ih b ii ij im in iq mt iu mu iy mv jc mw mx my mz bi translated">DOCKER_PORT:是DOCKER公开端点的端口，您将与您的端口匹配，以便您可以在本地机器上运行它。在我的情况下将是<em class="jd"> 8080。</em></li><li id="9430" class="mr ms hi ih b ii na im nb iq nc iu nd iy ne jc mw mx my mz bi translated">BASE_PATH:是模型所在的绝对路径。我的情况是<em class="jd"> /app/models。</em></li><li id="a7c4" class="mr ms hi ih b ii na im nb iq nc iu nd iy ne jc mw mx my mz bi translated">MODEL_NAME:是您拥有<em class="jd"> saved_model.pb </em>和<em class="jd">变量</em>目录的目录。在我的情况下将是<em class="jd">猫与狗的对决</em>。</li></ul><p id="7fe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我的<em class="jd">模型</em>目录看起来的样子(你的应该是同一个)</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="3d8b" class="lu jr hi lq b fi lv lw l lx ly">├── models<br/>|      ├── cats_vs_dogs<br/>|                ├── 1<br/>│                   ├── saved_model.pb<br/>│                   └── variables<br/>│                           ├── variables.data-00000-of-00001<br/>│                           └── variables.index</span></pre><p id="9d8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值“1”表示模型版本，因此如果迭代模型，可以生成不同的版本，并使用其他数字作为文件夹名称保存在那里，TensorFlow服务将始终提供最高的版本号。</p><p id="7ed7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要启动本地服务器，您必须执行以下命令(在您保存前一个docker文件的目录下):</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="d030" class="lu jr hi lq b fi lv lw l lx ly">docker build -t tf-serving-cats-dogs .</span></pre><p id="2cdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦构建完成，就执行以下命令:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="dea2" class="lu jr hi lq b fi lv lw l lx ly">docker run -p 8080:8080 tf-serving-cats-dogs</span></pre><p id="089e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您看到以下消息，是因为模型已正确加载，您可以开始向端点发出请求了:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="f6d3" class="lu jr hi lq b fi lv lw l lx ly">[evhttp_server.cc : 238] NET_LOG: Entering the event loop …</span></pre><p id="355f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，当这个Docker映像运行时，以下端点可用:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="bd18" class="lu jr hi lq b fi lv lw l lx ly"><a class="ae kt" href="http://localhost:8080/v1/models/cats_vs_dogs:predict" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/models/cats_vs_dogs:predict</a></span></pre><p id="1bae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们使用之前的cat图像向该端点发出POST请求(与我们使用<em class="jd"> h5 </em> Keras模型预测的相同):</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="2a3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">端点的响应如下:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="ee68" class="lu jr hi lq b fi lv lw l lx ly">{'predictions': [[1.5236342e-08]]}</span></pre><p id="a700" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到,<em class="jd"> h5 </em>模型对象返回的概率完全相同。</p><h2 id="3241" class="lu jr hi bd js me mf mg jw mh mi mj ka iq mk ml ke iu mm mn ki iy mo mp km mq bi translated">在TensorFlow服务上服务多个模型</h2><p id="2b3c" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在同一个服务上服务多个模型是非常简单的。首先，您应该编写下面的配置文件，其中指出了每个模型的名称和基本路径。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="3166" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Dockerfile也非常相似，但是现在我们没有定义<em class="jd">模型名称</em>和<em class="jd">模型基础路径</em>参数，而是应该只指出<em class="jd">模型配置文件</em>参数:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="455f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在构建并运行映像之后，我们将有以下两个可用的端点:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="2c70" class="lu jr hi lq b fi lv lw l lx ly"><a class="ae kt" href="http://localhost:8080/v1/models/cats_vs_dogs:predict" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/models/cats_vs_dogs:predict</a><br/><a class="ae kt" href="http://localhost:8080/v1/models/cats_vs_dogs:predict" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/models/model_2:predict</a></span></pre><h1 id="9515" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="a66f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在这篇文章中，我们展示了从使用Keras API的深度学习模型原型到生产就绪服务的速度。我们看到了通过使用Docker公开一个包含模型的端点来设置TensorFlow服务是多么简单。</p></div></div>    
</body>
</html>