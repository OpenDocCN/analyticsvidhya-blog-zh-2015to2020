<html>
<head>
<title>Image Convolution From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始图像卷积</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/image-convolution-from-scratch-d99bf639c32a?source=collection_archive---------0-----------------------#2019-12-01">https://medium.com/analytics-vidhya/image-convolution-from-scratch-d99bf639c32a?source=collection_archive---------0-----------------------#2019-12-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="53a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两个函数的数学运算，产生第三个函数，表示一个函数的形状如何被另一个函数修改。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/fe6d0040fb7f885c24e91121aec67be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*Fr6Umze2waDjWVHB2yzT4A.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图像卷积—核滤波</figcaption></figure><p id="7bbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卷积背后的思想是研究一个函数与另一个函数映射时如何产生一个新的修改函数。当同样的情况应用于信号时，称为卷积1d，图像称为卷积2d，视频称为卷积3d。本文主要关注卷积2d。</p><h1 id="ebc3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">概观</h1><p id="847a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们可以把一幅图像想象成一个二维矩阵，包含0到255范围内的像素颜色值。数学上，我们可以通过应用各种矩阵运算来操纵这个矩阵。</p><p id="d1e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用<a class="ae ks" href="http://bit.ly/2R8Auux" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>(一个灵活的图像处理库)，NumPy用于矩阵和数组操作，Matplotlib用于绘制图像。</p><h2 id="e3a9" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">例子</h2><p id="63e4" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们使用<code class="du lh li lj lk b">imread()</code>对象来读取图像。默认情况下，<code class="du lh li lj lk b">cv2.imread()</code>读取蓝色、绿色和红色格式的图像。我们需要把它转换成红色、蓝色和绿色的格式，这样才有意义。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="aef5" class="kt jq hi lk b fi lp lq l lr ls"># Image url ==&gt; <a class="ae ks" href="https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png" rel="noopener ugc nofollow" target="_blank">https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png</a><br/># Download the image and save it as 'lena.png' in your directory</span><span id="c150" class="kt jq hi lk b fi lt lq l lr ls">import cv2<br/>import numpy as np<br/>import math<br/>import matplotlib.pyplot as plt</span><span id="dd94" class="kt jq hi lk b fi lt lq l lr ls">src = cv2.imread('lena.png')<br/>img = cv2.cvtColor(src, cv2.COLOR_BGR2RGB)<br/>plt.figure(figsize=(8, 5))<br/>plt.axis("off")<br/>plt.imshow(img)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/5f782722e988c1d45930f80bad92712e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*jRWkWF1DmxFQhEJ7RJM44g.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">莉娜原始图片(谷歌)</figcaption></figure><h2 id="9ebe" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">图像到矩阵</h2><p id="b04f" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们取灰度图像的矩阵值，其中每个像素包含0到255之间的值。彩色图像的问题在于，每个像素值是3个值的组合，可能是<code class="du lh li lj lk b">[R, G, B]</code>或<code class="du lh li lj lk b">[B, G, R]</code>的形式，这会使计算变得复杂。所以，为了简单起见，我们取一张灰度图像。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="ba1d" class="kt jq hi lk b fi lp lq l lr ls">img = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)<br/>plt.imsave('lena_gray.png', img, cmap='gray')<br/>gsrc = cv2.imread('lena_gray.png', 0)<br/>img_mat = []<br/>for i in range(0, gsrc.shape[0]):<br/>    row = []<br/>    for j in range(0, gsrc.shape[1]):<br/>        pixel = gsrc.item(i, j)<br/>        row.append(pixel)<br/>    img_mat.append(row)</span></pre><p id="9454" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们查看矩阵，我们会看到它包含0到255范围内的像素值。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="124c" class="kt jq hi lk b fi lp lq l lr ls">&gt;&gt;&gt; img_mat = np.array(img_mat)<br/>&gt;&gt;&gt; print(img_mat)<br/>[[142 149 145 ...  94  94  94]<br/> [145 149 142 ...  97  97  97]<br/> [149 138 149 ...  97  94  94]<br/> ...<br/> [113 117 121 ...  32  32  32]<br/> [113 113 117 ...  28  28  32]<br/> [100 113 113 ...  28  32  36]]<br/>&gt;&gt;&gt; print(img_mat.shape)<br/>(512, 512)</span></pre><p id="e47b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们转置上面的矩阵，看看图像是否被转置。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="6b87" class="kt jq hi lk b fi lp lq l lr ls">&gt;&gt;&gt; img_tran_mat = img_mat.T<br/>&gt;&gt;&gt; print(img_tran_mat)<br/>[[142 145 149 ... 113 113 100]<br/> [149 149 138 ... 117 113 113]<br/> [145 142 149 ... 121 117 113]<br/> ...<br/> [ 94  97  97 ...  32  28  28]<br/> [ 94  97  94 ...  32  28  32]<br/> [ 94  97  94 ...  32  32  36]]<br/>&gt;&gt;&gt; print(img_tran_mat.shape)<br/>(512, 512)</span></pre><p id="097a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你看出原矩阵和转置矩阵的区别了吗？现在使用<code class="du lh li lj lk b">imwrite()</code>方法将矩阵保存为图像——该方法读取矩阵和数字，并作为图像写入。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="3a9b" class="kt jq hi lk b fi lp lq l lr ls">&gt;&gt;&gt; cv2.imwrite('lena_gray_tran.png', img_tran_mat)</span></pre><p id="894a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看区别，了解一下。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="eda2" class="kt jq hi lk b fi lp lq l lr ls">fig = plt.figure(figsize=(16, 25))</span><span id="8801" class="kt jq hi lk b fi lt lq l lr ls">orig = cv2.imread('lena_gray.png')<br/>tran = cv2.imread('lena_gray_tran.png')</span><span id="3a27" class="kt jq hi lk b fi lt lq l lr ls">ax1 = fig.add_subplot(2,2,1)<br/>ax1.axis("off")<br/>ax1.title.set_text('Original')<br/>ax1.imshow(orig)</span><span id="a1b1" class="kt jq hi lk b fi lt lq l lr ls">ax2 = fig.add_subplot(2,2,2)<br/>ax2.axis("off")<br/>ax2.title.set_text('Transposed')<br/>ax2.imshow(tran)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/b1dee0587b78845f7a838aa2d15cfc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wiCU4U5hn3RHmkzog-nm8A.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">Lena —原始与移调</figcaption></figure><p id="963d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到一个完全转置的图像，这是因为我们之前执行的转置矩阵。</p><h1 id="45ce" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">从头开始图像卷积的代码</h1><p id="1716" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">对于卷积，我们需要一个单独的内核滤波器，它对整个图像进行操作，从而产生一个完全修改的图像。</p><blockquote class="ma"><p id="15e0" class="mb mc hi bd md me mf mg mh mi mj jc dx translated"><em class="mk"> g(x，y) = w * f(x，y)；w =内核，g =结果，f =输入</em></p></blockquote><p id="c149" class="pw-post-body-paragraph if ig hi ih b ii ml ik il im mm io ip iq mn is it iu mo iw ix iy mp ja jb jc hb bi translated">在图像处理中；内核、卷积矩阵或遮罩是一种小型矩阵，用于模糊、锐化、浮雕、边缘检测等。这是通过在内核和图像之间进行卷积来实现的。</p><h2 id="caa8" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">图像卷积的步骤</h2><ol class=""><li id="e064" class="mq mr hi ih b ii kn im ko iq ms iu mt iy mu jc mv mw mx my bi translated">将图像转换为灰度并获得矩阵。</li><li id="7177" class="mq mr hi ih b ii mz im na iq nb iu nc iy nd jc mv mw mx my bi translated">从原始矩阵中获得包含大小为核的子矩阵的巨型矩阵。</li><li id="f956" class="mq mr hi ih b ii mz im na iq nb iu nc iy nd jc mv mw mx my bi translated">通过在内核和每个子矩阵之间进行逐元素乘法来执行卷积，并将结果求和为单个整数或浮点值。通过这样做，获得一个变换或过滤的矩阵。</li><li id="3dec" class="mq mr hi ih b ii mz im na iq nb iu nc iy nd jc mv mw mx my bi translated">将变换或过滤后的矩阵转换成图像。</li><li id="0fe8" class="mq mr hi ih b ii mz im na iq nb iu nc iy nd jc mv mw mx my bi translated">结束。</li></ol><h2 id="5a98" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">第一步</h2><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="a042" class="kt jq hi lk b fi lp lq l lr ls">def convert_image_matrix(img_name):<br/>    src = cv2.imread(img_name)<br/>    img = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)<br/>    name, ext = img_name.split('.')<br/>    plt.imsave(str(name + '_gray.' + ext), img, cmap='gray')<br/>    <br/>    gray_img = cv2.imread(str(name + '_gray.' + ext), 0)<br/>    gimg_shape = gray_img.shape<br/>    gimg_mat = []<br/>    for i in range(0, gimg_shape[0]):<br/>        row = []<br/>        for j in range(0, gimg_shape[1]):<br/>            pixel = gray_img.item(i, j)<br/>            row.append(pixel)<br/>        gimg_mat.append(row)<br/>    gimg_mat = np.array(gimg_mat)<br/>    return gimg_mat</span></pre><p id="dab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述函数返回包含像素值的二维NumPy数组。</p><h2 id="9136" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">第二步</h2><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="e4da" class="kt jq hi lk b fi lp lq l lr ls">def get_sub_matrices(orig_matrix, kernel_size):<br/>    width = len(orig_matrix[0])<br/>    height = len(orig_matrix)<br/>    if kernel_size[0] == kernel_size[1]:<br/>        if kernel_size[0] &gt; 2:<br/>            orig_matrix = np.pad(orig_matrix, kernel_size[0] - 2, mode='constant')<br/>        else: pass<br/>    else: pass<br/>    <br/>    giant_matrix = []<br/>    for i in range(0, height - kernel_size[1] + 1):<br/>        for j in range(0, width - kernel_size[0] + 1):<br/>            giant_matrix.append(<br/>                [<br/>                    [orig_matrix[col][row] for row in range(j, j + kernel_size[0])]<br/>                    for col in range(i, i + kernel_size[1])<br/>                ]<br/>            )<br/>    img_sampling = np.array(giant_matrix)<br/>    return img_sampling</span></pre><p id="7bfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的函数返回了一个巨大的矩阵，其中包含了大小为kernel的子矩阵，稍后将再次使用这些子矩阵。合成矩阵也可以称为采样矩阵。</p><p id="8b84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在该函数中，使用方法<code class="du lh li lj lk b"><a class="ae ks" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.pad.html" rel="noopener ugc nofollow" target="_blank">np.pad()</a></code>通过添加<code class="du lh li lj lk b">0</code>来保存沿边缘出现的数据，因此在应用卷积时不会有任何数据丢失。</p><h2 id="f3df" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">第三步</h2><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="5ba9" class="kt jq hi lk b fi lp lq l lr ls">def get_transformed_matrix(matrix_sampling, kernel_filter):<br/>    transform_mat = []<br/>    for each_mat in matrix_sampling:<br/>        transform_mat.append(<br/>            np.sum(np.multiply(each_mat, kernel_filter))<br/>        )<br/>    reshape_val = int(math.sqrt(matrix_sampling.shape[0]))<br/>    transform_mat = np.array(transform_mat).reshape(reshape_val, reshape_val)<br/>    return transform_mat</span></pre><p id="a86e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">巨型矩阵或采样矩阵作为参数与上述函数中的内核过滤器一起传递，以执行卷积。</p><h2 id="322a" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">第四步</h2><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="95d8" class="kt jq hi lk b fi lp lq l lr ls">def original_VS_convoluted(img_name, kernel_name, convoluted_matrix):<br/>    name, ext = img_name.split('.')<br/>    cv2.imwrite(str(name + '_' + kernel_name + '.' + ext), convoluted_matrix)<br/>    orig = cv2.imread(str(name + '_gray.' + ext))<br/>    conv = cv2.imread(str(name + '_' + kernel_name + '.' + ext))<br/>    <br/>    fig = plt.figure(figsize=(16, 25))<br/>    ax1 = fig.add_subplot(2,2,1)<br/>    ax1.axis("off")<br/>    ax1.title.set_text('Original')<br/>    ax1.imshow(orig)<br/>    ax2 = fig.add_subplot(2,2,2)<br/>    ax2.axis("off")<br/>    ax2.title.set_text(str(kernel_name).title())<br/>    ax2.imshow(conv)<br/>    return True</span></pre><p id="799f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述函数是将原始图像与卷积后的变换图像进行比较的绘图函数。</p><h2 id="4257" class="kt jq hi bd jr ku kv kw jv kx ky kz jz iq la lb kd iu lc ld kh iy le lf kl lg bi translated">卷积的类型</h2><p id="c63c" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们有几种可以应用于图像的卷积运算。他们中很少有人是</p><ul class=""><li id="c849" class="mq mr hi ih b ii ij im in iq ne iu nf iy ng jc nh mw mx my bi translated"><strong class="ih hj">恒等运算</strong>:返回与自变量相同值的函数。</li></ul><blockquote class="ma"><p id="0232" class="mb mc hi bd md me ni nj nk nl nm jc dx translated">f(x)= x；内核= [[0，0，0]，[0，1，0]，[0，0，0]]</p></blockquote><pre class="nn no np nq nr ll lk lm ln aw lo bi"><span id="60f4" class="kt jq hi lk b fi lp lq l lr ls">&gt;&gt;&gt; img_name = 'lena.png'<br/>&gt;&gt;&gt; img_mat = convert_image_matrix(img_name)<br/>&gt;&gt;&gt; identity_kernel = np.array([[0,0,0],[0,1,0],[0,0,0]])<br/>&gt;&gt;&gt; img_sampling = get_sub_matrices(img_mat, identity_kernel.shape)<br/>&gt;&gt;&gt; transform_mat = get_transformed_matrix(img_sampling, identity_kernel)<br/>&gt;&gt;&gt; original_VS_convoluted(img_name,'identity', transform_mat)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/e5136a79f122a777bc9dd9dd4fd7dbf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftyOniLvuhQN1v1qlRvY6g.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">Lena——原始与相同</figcaption></figure><p id="5915" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从以上结果可以清楚地看出，原始图像和变换后的图像之间没有区别。</p><ul class=""><li id="ba41" class="mq mr hi ih b ii ij im in iq ne iu nf iy ng jc nh mw mx my bi translated"><strong class="ih hj">边缘检测操作</strong>:功能包括多种数学方法，旨在识别数字图像中图像亮度发生变化的点。Canny的边缘检测技术有效地工作。</li></ul><blockquote class="ma"><p id="084d" class="mb mc hi bd md me ni nj nk nl nm jc dx translated">内核= [[-1，-1，-1]，[-1，8，-1]，[-1，-1，-1]]</p></blockquote><pre class="nn no np nq nr ll lk lm ln aw lo bi"><span id="fa0c" class="kt jq hi lk b fi lp lq l lr ls">&gt;&gt;&gt; img_name = 'lena.png'<br/>&gt;&gt;&gt; img_mat = convert_image_matrix(img_name)<br/>&gt;&gt;&gt; identity_kernel = np.array([[-1,-1,-1],[-1,8,-1],[-1,-1,-1]])<br/>&gt;&gt;&gt; img_sampling = get_sub_matrices(img_mat, identity_kernel.shape)<br/>&gt;&gt;&gt; transform_mat = get_transformed_matrix(img_sampling, identity_kernel)<br/>&gt;&gt;&gt; original_VS_convoluted(img_name,'canny_edge', transform_mat)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/13ae30c8d855795176dfd1b90e25352d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnajkkE4bRSuzBWynpvIRw.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">Lena —原创vs canny_edge</figcaption></figure><p id="e44f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的结果，我们可以说，边缘被白色突出，其余的都是黑色。该算法能够识别眼睛和头发等特定细节的边缘。然而，还有其他种类的边缘检测算法。</p><ul class=""><li id="20c5" class="mq mr hi ih b ii ij im in iq ne iu nf iy ng jc nh mw mx my bi translated"><strong class="ih hj">锐化操作</strong>:增加图像亮暗区域对比度的功能。</li></ul><blockquote class="ma"><p id="2db7" class="mb mc hi bd md me ni nj nk nl nm jc dx translated">内核= [[0，-1，0]，[-1，5，-1]，[0，-1，0]]</p></blockquote><pre class="nn no np nq nr ll lk lm ln aw lo bi"><span id="0df4" class="kt jq hi lk b fi lp lq l lr ls">&gt;&gt;&gt; img_name = 'lena.png'<br/>&gt;&gt;&gt; img_mat = convert_image_matrix(img_name)<br/>&gt;&gt;&gt; identity_kernel = np.array([[0,-1,0],[-1,5,-1],[0,-1,0]])<br/>&gt;&gt;&gt; img_sampling = get_sub_matrices(img_mat, identity_kernel.shape)<br/>&gt;&gt;&gt; transform_mat = get_transformed_matrix(img_sampling, identity_kernel)<br/>&gt;&gt;&gt; original_VS_convoluted(img_name,'sharpen', transform_mat)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/7236a32f62e9871b3a43ee563048bb23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GcSMsBNxMeLci06q0TFy8Q.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">莉娜——原创vs锐化</figcaption></figure><p id="2d11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的结果可以清楚地看出，变换后的图像仍然存在某种噪声，我们还看到较亮的区域变得更亮，而较暗的区域变得更暗。</p><ul class=""><li id="b0ed" class="mq mr hi ih b ii ij im in iq ne iu nf iy ng jc nh mw mx my bi translated"><strong class="ih hj">Box blur operation</strong>:Function是一种线性滤波器，其结果图像中的每个像素的值等于其输入图像中相邻像素的平均值。</li></ul><blockquote class="ma"><p id="8879" class="mb mc hi bd md me ni nj nk nl nm jc dx translated">内核= (1 / 9) * [[1，1，1]，[1，1，1]，[1，1，1]]</p></blockquote><pre class="nn no np nq nr ll lk lm ln aw lo bi"><span id="a970" class="kt jq hi lk b fi lp lq l lr ls">&gt;&gt;&gt; img_name = 'lena.png'<br/>&gt;&gt;&gt; img_mat = convert_image_matrix(img_name)<br/>&gt;&gt;&gt; identity_kernel = (1/9)*np.array([[1,1,1],[1,1,1],[1,1,1]])<br/>&gt;&gt;&gt; img_sampling = get_sub_matrices(img_mat, identity_kernel.shape)<br/>&gt;&gt;&gt; transform_mat = get_transformed_matrix(img_sampling, identity_kernel)<br/>&gt;&gt;&gt; original_VS_convoluted(img_name,'box_blur', transform_mat)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/7c344f958de5d099378bd5e7a6e4defd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vq80KQuqjOMl3SrFk49zQ.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">莉娜——原创vs方块_模糊</figcaption></figure><p id="5c55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从结果中，我们注意到转换后的图像比原始图像稍微平滑一些。正如我们现在所知道的，当核与子矩阵一起操作时，求和结果立即被平均，从而使其具有归一化值。</p><ul class=""><li id="3513" class="mq mr hi ih b ii ij im in iq ne iu nf iy ng jc nh mw mx my bi translated"><strong class="ih hj">高斯模糊操作</strong>:该函数也称为高斯平滑函数，通常用于减少图像中的噪声。</li></ul><blockquote class="ma"><p id="4cef" class="mb mc hi bd md me ni nj nk nl nm jc dx translated">kernel = (1 / 16) * [[1，2，1]，[2，4，2]，[1，2，1]]</p></blockquote><pre class="nn no np nq nr ll lk lm ln aw lo bi"><span id="40bb" class="kt jq hi lk b fi lp lq l lr ls">&gt;&gt;&gt; img_name = 'lena.png'<br/>&gt;&gt;&gt; img_mat = convert_image_matrix(img_name)<br/>&gt;&gt;&gt; identity_kernel = (1/16)*np.array([[1,2,1],[2,4,2],[1,2,1]])<br/>&gt;&gt;&gt; img_sampling = get_sub_matrices(img_mat, identity_kernel.shape)<br/>&gt;&gt;&gt; transform_mat = get_transformed_matrix(img_sampling, identity_kernel)<br/>&gt;&gt;&gt; original_VS_convoluted(img_name,'gaussian3', transform_mat)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/1aefe4cbb8c166316021d8a790e4b1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KvcTElop2uYlXvasGg5V3A.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">莉娜——原创vs高辛3</figcaption></figure><p id="5a49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">高斯算法可以很好地降低图像噪声，并以更漂亮的方式呈现图像。转换后的图像实际上看起来比原始图像更平滑。</p><p id="53f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的自定义卷积随机调整内核矩阵。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/c570ff912cf32e78b8074ab0dd0a21b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7JC-YUdnCFk0kurZo3YBA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">莉娜——原创vs定制_conv</figcaption></figure><h1 id="8085" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><ul class=""><li id="5f80" class="mq mr hi ih b ii kn im ko iq ms iu mt iy mu jc nh mw mx my bi translated">卷积是一种简单的数学运算，是许多常见图像处理运算符的基础。</li><li id="b8af" class="mq mr hi ih b ii mz im na iq nb iu nc iy nd jc nh mw mx my bi translated">它在数学领域有各种应用，如概率和统计，线性系统等。</li></ul><p id="5956" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PS:虽然卷积是处理图像操作的概念，但是能够实现和理解它的数学原理是很好的。在下一篇文章中，我将解释为什么我使用默认内核来实现某种转换。</p><p id="33d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢，你可以在这里的的<a class="ae ks" href="https://www.buymeacoffee.com/msameeruddin" rel="noopener ugc nofollow" target="_blank">给我买咖啡。</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://www.buymeacoffee.com/msameeruddin"><div class="er es ns"><img src="../Images/06448f8cbc306659f8d216abe23fee28.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/0*vCyri4MG0M-hkM9o.png"/></div></a></figure><h1 id="ef42" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">参考</h1><ol class=""><li id="4840" class="mq mr hi ih b ii kn im ko iq ms iu mt iy mu jc mv mw mx my bi translated"><code class="du lh li lj lk b">cv2</code>文档:<a class="ae ks" href="http://bit.ly/2R8Auux" rel="noopener ugc nofollow" target="_blank">http://bit.ly/2R8Auux</a>。</li><li id="1e22" class="mq mr hi ih b ii mz im na iq nb iu nc iy nd jc mv mw mx my bi translated">卷积:<a class="ae ks" href="https://en.wikipedia.org/wiki/Convolution" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Convolution</a>。</li><li id="f4f4" class="mq mr hi ih b ii mz im na iq nb iu nc iy nd jc mv mw mx my bi translated">内核过滤器:<a class="ae ks" href="https://en.wikipedia.org/wiki/Kernel_(image_processing)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Kernel _(image _ processing)</a>。</li><li id="124b" class="mq mr hi ih b ii mz im na iq nb iu nc iy nd jc mv mw mx my bi translated">图片来源:谷歌图片。</li></ol></div></div>    
</body>
</html>