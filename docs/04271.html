<html>
<head>
<title>Understanding Slope Calculation For Backpropagation, The Simple Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解反传斜率计算的简单方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-slope-calculation-for-backpropagation-the-simple-way-d9d99793ac9f?source=collection_archive---------12-----------------------#2020-03-12">https://medium.com/analytics-vidhya/understanding-slope-calculation-for-backpropagation-the-simple-way-d9d99793ac9f?source=collection_archive---------12-----------------------#2020-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8166" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都知道反向传播是神经网络中最难的概念之一。学习者在探索算法时最头疼的是如何计算后续权重的斜率。</p><p id="dcac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">提示:为了更好地理解，建议在桌面上查看这篇文章，因为有许多图像形式的数学方程。</p><p id="260b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将理解如何使用计算图的简单概念来计算实现反向传播算法所需的梯度下降中的斜率。</p><p id="feb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑一个等式，</p><p id="004e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> F(a，b，c)=5*(a*b+c) </em></p><p id="e81f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们，</p><p id="03cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">u = a * b；v = u+c；F = 5v </em></p><p id="048b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述等式的计算图可以绘制为:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/32e465676dd8e8a8c5b8524216339d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*LRhr6ZiJb_qMaNUXrWNP3Q.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图一</figcaption></figure><p id="a623" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从图1中可以看出<em class="jd"> F </em>依赖于<em class="jd"> v，v </em>依赖于<em class="jd"> u </em>并且<em class="jd">u</em>随后依赖于<em class="jd"> a </em>以及<em class="jd">b</em>我们可以得出<em class="jd"> a </em>和<em class="jd"> F </em>之间的关系</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jq"><img src="../Images/1cafdd20ab3d47122ab633ae832e03d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*bAgsGUz2kqUO40dUl83jzw.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图2</figcaption></figure><p id="661a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们来谈谈衍生品:</p><p id="b1f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> F </em> w.r.t .变量<em class="jd"> v </em>的导数简单地由下式给出:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jr"><img src="../Images/208e465ba70547d06713658cf3efaa54.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*O-k_VDsV9XTdcsZAlx0yfg.png"/></div></figure><p id="c5ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在为了计算<em class="jd"> F </em> w.r.t <em class="jd"> u </em>的导数，由于<em class="jd"> F </em>是从<em class="jd"> v </em>计算的，而<em class="jd"> v </em>依赖于<em class="jd"> u </em>，因此，我们需要通过<em class="jd">v</em>从<em class="jd"> F </em>遍历回<em class="jd"> u </em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es js"><img src="../Images/a81336016920e0fe6c8703fd2d26f793.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*2ylj-8_s5qIuBxWZN_bmOQ.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图3</figcaption></figure><p id="cfce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此我们会得到，</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jt"><img src="../Images/cd8e7852e631e1164345453c2862c785.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*H_2WX49y_fUNCm8gOT6z8Q.png"/></div></figure><p id="02dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，对于F的导数，我们必须遵循这条路径</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ju"><img src="../Images/b16c69b50c1ecf64e9b71886cf72302e.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*1ScNtOhZPvDLn3ap-E1VRg.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图4</figcaption></figure><p id="5792" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到了</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jv"><img src="../Images/d0f13e048e471dbccb3bbb13a6c69c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*wRuJwR2kn7NIT-8B9IhrSA.png"/></div></figure><h1 id="36ad" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">神经网络</h1><p id="56bf" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">现在就神经网络而言，这里，后续层中的节点值是通过称为前向传播的乘加过程来计算的，在该过程中，假设L与相应的权重W相乘并相加，通过将相加的结果传递通过激活函数来计算最终值。这里我们将考虑sigmoid激活函数。</p><p id="32f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以画出神经网络的计算图</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/df4b880fb5df233ce193d311d099b30d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Igk1dtUDJPKq-SesDv2hxw.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图5</figcaption></figure><p id="f584" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，图5不是实际的神经网络表示，而是它的计算图。</p><p id="e996" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上图我们可以观察到:</p><p id="5936" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有</p><p id="167d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输入</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es le"><img src="../Images/d833abf9d28c6ccb20c125f56338bc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*9Qia_taJSfCA_SfwKSzTNg.png"/></div></figure><p id="fbf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重量</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lf"><img src="../Images/48fb1ed10e35264046eb3a1527e6862c.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*FLqbJX-g4OfQylI8D13AhQ.png"/></div></figure><p id="cbc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">隐藏层的乘加处理</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lg"><img src="../Images/79a204b6c74c6fc2ed7b0f0e23f5d9bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*l4rfT2Ge9eLCQnnYdbbaPQ.png"/></div></figure><p id="3573" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">替换我们的Sigmoid激活函数</strong>中最后一次操作的输出</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lh"><img src="../Images/96df63b5983e6e3c0ca15b1ceac2687c.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*g5KbPWTx2U7MEA7GN25ktw.png"/></div></figure><p id="cd33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出层的乘加处理</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es li"><img src="../Images/2f61d887c76e5694a0142292d242f007.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*orialIhfk1RM5VpuVmI3Fw.png"/></div></figure><p id="4c6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">应用s形激活功能</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lj"><img src="../Images/8d0852549b6e02da6028998c3ac4e0e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*5iowdHwa2dgnrCu4Pu2SVA.png"/></div></figure><p id="af2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就完成了我们对<strong class="ih hj"> <em class="jd">正向传播的处理。</em> </strong></p><p id="ac5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算输出<em class="jd"> O </em>与实际值<em class="jd"> Y </em>相差多少的误差函数我们将使用<strong class="ih hj"> <em class="jd">均值</em> </strong> <strong class="ih hj"> <em class="jd">平方误差函数。</em>T11】</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lk"><img src="../Images/5133dac849411f3963eb67cc9f017960.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*pGP7oCREXn-oj-HR2VXNFA.png"/></div></figure><p id="1c58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:这里我们只演示了单个样本的计算</p><h1 id="2654" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">反向传播</h1><p id="6d1b" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">反向传播算法的主要目的是通过梯度下降改变权重来计算权重的最佳值，直到我们获得最佳权重。</p><p id="73b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">获得最佳权重的梯度下降方程由下式给出:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ll"><img src="../Images/722c10ae72010cbe6d02a9fd8d5051ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*QvN7fpGpvI79th7BWhvcsg.png"/></div></figure><p id="ab35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在哪里</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lm"><img src="../Images/820b0dff16ec0518f9f60a1d9f616268.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*9iwrHHw7OJfmvaFfNfdUtw.png"/></div></figure><p id="e2bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">表示要更新的权重。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ln"><img src="../Images/d96a9eabb6b6ccbb0c7dfab3fb67c33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*Gi4QK_foC_6LPR5JxYGUQg.png"/></div></figure><p id="f3fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代表学习率。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lo"><img src="../Images/10450c740c09670d785679318846bd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*fO1BOZdZlIcRjdCyRQZKdQ.png"/></div></figure><blockquote class="lp lq lr"><p id="2987" class="if ig jd ih b ii ij ik il im in io ip ls ir is it lt iv iw ix lu iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">是我们的损失函数w.r.t .的导数，要更新的权重</em> </strong></p></blockquote><p id="59fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们主要关心的是如何计算损失函数相对于待更新权重的斜率。为此，我们将不得不再次为我们的计算图(图5)中的变量绘制一个关系图，用于正向传播。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lv"><img src="../Images/ae074e40e3ce219467b636b9b1fb39e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*gjEPEe0l5jCbMlseG-56kw.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图6</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lw"><img src="../Images/92878aa9bd6ea55719d8e46250dd9f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*-PrL2E-j69p7445bmoYBPw.png"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lx"><img src="../Images/510fc1a41e781f99f862a94c9a4e5d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*hXeGPoZNUNvAgLNenIkW-g.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图7</figcaption></figure><p id="edc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到，</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ly"><img src="../Images/21a9a4b345f156cfa18e14688809d4fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*lOWBdvqBh3yAWKan_U066g.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">等式1</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lz"><img src="../Images/9c8dc8b63fff95afc039060c9f277f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*l9NIdsobQ3qI-veAcYoCew.png"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ma"><img src="../Images/c259ea000cc120c1ad275fd75a3f7de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*QHAALXQYaiywsRmPr5s1Yg.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图8</figcaption></figure><p id="fafa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们获得，</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mb"><img src="../Images/4729d520c8b05170a3c393c78a92edad.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*Nu2pLNneHbHR2NYai8nv0Q.png"/></div></figure><p id="12cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，通过这种简单的追踪权重w.r.t .的方法，我们可以很容易地使用反向传播和梯度下降来更新我们的权重。</p><p id="2a7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">我希望这篇文章对你有用！</em></p><p id="8649" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">在LinkedIn上联系我:</em><a class="ae mc" href="https://www.linkedin.com/in/suyash-gupta-9b247b154/" rel="noopener ugc nofollow" target="_blank">【https://www.linkedin.com/in/suyag10/】T21</a></p></div></div>    
</body>
</html>