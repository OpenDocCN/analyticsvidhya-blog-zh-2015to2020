<html>
<head>
<title>Machine Learning for Fraud Detection Using XGBoost Classifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于XGBoost分类器的欺诈检测机器学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-for-fraud-detection-using-xgboost-classifier-75670e3c6a85?source=collection_archive---------2-----------------------#2019-12-30">https://medium.com/analytics-vidhya/machine-learning-for-fraud-detection-using-xgboost-classifier-75670e3c6a85?source=collection_archive---------2-----------------------#2019-12-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/15cfc3dcea3cc24fa1abe0444a1d221a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Na45YxJbn2e5O3XcpKszDA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">杰斐逊·桑托斯在Upsplash上拍摄的照片</figcaption></figure><h1 id="96ff" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="1a0c" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">想象你站在超市的收银台前，身后排着长队，收银员悄悄地宣布你的卡被拒绝了。此时此刻，你可能不会考虑决定你命运的数据科学。</p><p id="d90a" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">尽管你确定你有足够的资金支付所有费用，但这张卡仍然不接受付款。之后，你站到一边，让收银员为另一位顾客服务，你收到了银行的通知或信息，“如果你真的想花500英镑买切达奶酪，请按1”。</p><p id="8df1" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">这一刻对每个遇到这种命运的人来说都很尴尬。如果我们能提供一个好的欺诈防范系统，每年为消费者或客户节省数百万美元，那就太好了。来自IEEE计算智能学会(也称为IEEE-CIS)的研究人员希望改善这种情况，同时提升消费者体验。系统的性能越好，我们可以预防的资金就越多。</p><p id="9403" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">IEEE-CIS工作于各种人工智能和机器学习领域，包括深度神经网络、模糊系统、进化计算和群体智能。今天，他们与全球领先的支付服务公司<a class="ae kv" href="https://trustvesta.com/" rel="noopener ugc nofollow" target="_blank"> Vesta Corporation </a>合作，寻求欺诈防范行业的最佳解决方案，现在邀请您加入这项挑战。</p><p id="2d56" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">请参考竞争网站的链接:IEEE-CIS欺诈检测</p><div class="kw kx ez fb ky kz"><a href="https://www.kaggle.com/c/ieee-fraud-detection/overview" rel="noopener  ugc nofollow" target="_blank"><div class="la ab dw"><div class="lb ab lc cl cj ld"><h2 class="bd hj fi z dy le ea eb lf ed ef hh bi translated">IEEE-CIS欺诈检测</h2><div class="lg l"><h3 class="bd b fi z dy le ea eb lf ed ef dx translated">你能从客户交易中发现欺诈吗？</h3></div><div class="lh l"><p class="bd b fp z dy le ea eb lf ed ef dx translated">www.kaggle.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln io kz"/></div></div></a></div><p id="2eac" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">本文的主要目标是使用竞争对手提供的数据集，提供欺诈检测的基准模型和方法。我希望这篇文章能够帮助那些在机器学习竞赛中努力入门的人，或者那些想了解什么样的AI或机器学习可以应用到现实世界的项目中的人。我们作为一个由3名成员组成的团队开始了这场比赛，我们希望分享帮助我们成为6381个团队中前3%的方法。</p><p id="a092" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">事不宜迟，我们开始吧！</p><h1 id="7297" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">这场比赛的目的</h1><p id="899e" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在这场比赛中，我们在一个大规模数据集上建立了一个机器学习模型，这个数据集源于Vesta的现实世界电子商务交易，包含了从设备类型到产品功能的广泛功能。我们也有机会根据数据创建新的功能来改进我们的结果。</p><p id="f65d" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">如果我们成功发明了一种真正好的方法，我们将提高全球数百万人的欺诈交易警报的有效性，帮助成千上万的企业减少欺诈损失，增加利润。再者，我们会拯救和我们遇到同样命运的人，让他们脸上露出笑容。</p><h1 id="bd0a" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">环境设置</h1><p id="b7c5" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">语言:Python 3.5.5</p><p id="19e0" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">主库:</p><ol class=""><li id="4f92" class="lo lp hi ju b jv kq jz kr kd lq kh lr kl ls kp lt lu lv lw bi translated">Numpy</li><li id="0bf9" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp lt lu lv lw bi translated">熊猫</li><li id="7ba9" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp lt lu lv lw bi translated">sci kit-学习</li><li id="6cfb" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp lt lu lv lw bi translated">海生的</li><li id="f33d" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp lt lu lv lw bi translated">Matplotlib</li><li id="bd72" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp lt lu lv lw bi translated">CatBoost</li></ol><h1 id="d0da" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">数据探索</h1><p id="7d2f" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">数据集可以在Kaggle网站<a class="ae kv" href="https://www.kaggle.com/c/ieee-fraud-detection/data" rel="noopener ugc nofollow" target="_blank">这里</a>找到并下载。</p><p id="0159" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">数据分为两个文件<code class="du mc md me mf b">identity</code>和<code class="du mc md me mf b">transaction</code>，由<code class="du mc md me mf b">TransactionID</code>连接。请注意，并非所有事务都有相同的身份数据。</p><h2 id="a4f4" class="mg iv hi bd iw mh mi mj ja mk ml mm je kd mn mo ji kh mp mq jm kl mr ms jq mt bi translated">分类特征—交易</h2><ul class=""><li id="0c86" class="lo lp hi ju b jv jw jz ka kd mu kh mv kl mw kp mx lu lv lw bi translated"><code class="du mc md me mf b">ProductCD</code></li><li id="5c94" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><code class="du mc md me mf b">card1</code> - <code class="du mc md me mf b">card6</code></li><li id="21ef" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><code class="du mc md me mf b">addr1</code>，<code class="du mc md me mf b">addr2</code></li><li id="6657" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><code class="du mc md me mf b">P_emaildomain</code></li><li id="89b6" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><code class="du mc md me mf b">R_emaildomain</code></li><li id="7c6c" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><code class="du mc md me mf b">M1</code> - <code class="du mc md me mf b">M9</code></li></ul><h2 id="2eb2" class="mg iv hi bd iw mh mi mj ja mk ml mm je kd mn mo ji kh mp mq jm kl mr ms jq mt bi translated">分类特征——同一性</h2><ul class=""><li id="0e1c" class="lo lp hi ju b jv jw jz ka kd mu kh mv kl mw kp mx lu lv lw bi translated"><code class="du mc md me mf b">DeviceType</code></li><li id="1a80" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><code class="du mc md me mf b">DeviceInfo</code></li><li id="101a" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><code class="du mc md me mf b">id_12</code> - <code class="du mc md me mf b">id_38</code></li></ul><p id="5668" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><code class="du mc md me mf b">TransactionDT</code>特性是给定参考日期时间的时间增量(不是实际的时间戳)。</p><h2 id="969a" class="mg iv hi bd iw mh mi mj ja mk ml mm je kd mn mo ji kh mp mq jm kl mr ms jq mt bi translated">列描述</h2><p id="ee03" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated"><strong class="ju hj">交易表</strong></p><ul class=""><li id="c1ae" class="lo lp hi ju b jv kq jz kr kd lq kh lr kl ls kp mx lu lv lw bi translated"><strong class="ju hj"> TransactionDT </strong>:给定参考日期时间的时间增量(不是实际的时间戳)</li><li id="05a4" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><strong class="ju hj">交易金额</strong>:交易支付金额，美元</li><li id="222e" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><strong class="ju hj"> ProductCD </strong>:产品代码，每笔交易的产品</li><li id="67d3" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><strong class="ju hj"> card1 — card6 </strong>:支付卡信息，如卡种、卡类、发卡行、国家等。</li><li id="fee3" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><strong class="ju hj">地址</strong>:地址</li><li id="0b61" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><strong class="ju hj">距离</strong>:距离</li><li id="c7e1" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><strong class="ju hj"> P_ and (R__) emaildomain </strong>:购买者和接收者电子邮件域</li><li id="9111" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><strong class="ju hj"> C1-C14 </strong>:计数，比如找到多少个地址与支付卡关联等。实际意义被掩盖了。</li><li id="c095" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><strong class="ju hj"> D1-D15 </strong>:时间差，如前一笔交易的间隔天数等。</li><li id="1b17" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><strong class="ju hj"> M1-M9 </strong>:匹配，如名片上的姓名、地址等。</li><li id="7434" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp mx lu lv lw bi translated"><strong class="ju hj">vxxxx</strong>:Vesta设计了丰富的功能，包括排名、计数和其他实体关系。</li></ul><p id="7fe8" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><strong class="ju hj">分类特征</strong><br/>product CD<br/>card 1—card 6<br/>addr 1，addr 2<br/>P<em class="my">email domain R</em>email domain<br/>M1—M9</p><h2 id="662f" class="mg iv hi bd iw mh mi mj ja mk ml mm je kd mn mo ji kh mp mq jm kl mr ms jq mt bi translated"><strong class="ak">身份表</strong></h2><p id="25e5" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">此表中的变量是身份信息—与交易相关的网络连接信息(IP、ISP、代理等)和数字签名(UA/browser/os/version等)。它们由Vesta的欺诈保护系统和数字安全合作伙伴收集。<br/>(字段名被屏蔽，出于隐私保护和合同协议的考虑，将不提供成对字典)</p><p id="f385" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">分类特征:<br/>设备类型<br/>设备信息<br/> id <em class="my"> 12 — id </em> 38</p><p id="5b73" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><em class="my">鸣谢:所有信息均由Kaggle竞赛网站提供。</em></p><h1 id="369c" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">方法学</h1><figure class="na nb nc nd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/7ae58855cb8994775280d412c227c5fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u4rW76MWGXZvSZ8XKVd0UQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">用于欺诈检测的机器学习框架</figcaption></figure><ol class=""><li id="f505" class="lo lp hi ju b jv kq jz kr kd lq kh lr kl ls kp lt lu lv lw bi translated">首先，我们首先根据事务文件和身份文件的唯一ID合并它们的训练数据。</li><li id="6461" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp lt lu lv lw bi translated">一旦我们获得了训练样本，我们就将这些数据平均分成5个数据样本块。我还想提一下，分层K-Fold与普通K-Fold分裂有点不同，它只能用于二进制分类问题，如我们的情况(0和1值)。分层K-Fold将数据分成多个Fold，在每个组块的两个类中包含大致相同数量的样本。</li><li id="3efd" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp lt lu lv lw bi translated">准备好所有数据后，是时候创建一个模型/分类器来概括这些数据并做出预测了。</li><li id="95be" class="lo lp hi ju b jv lx jz ly kd lz kh ma kl mb kp lt lu lv lw bi translated">最后，通过将它们平均来集合预测，以产生最终预测。</li></ol><h1 id="5c28" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak"> XGBoost参数</strong></h1><pre class="na nb nc nd fd ne mf nf ng aw nh bi"><span id="42d5" class="mg iv hi mf b fi ni nj l nk nl">clf = xgb.XGBClassifier(<br/>        n_estimators=500,<br/>        max_depth=9,<br/>        learning_rate=0.05,<br/>        subsample=0.9,<br/>        colsample_bytree=0.9,<br/>        missing=-999,<br/>        random_state=2019,<br/>        tree_method='auto',<br/>        n_jobs = -1,<br/>        <br/>    )</span></pre><ul class=""><li id="1cd6" class="lo lp hi ju b jv kq jz kr kd lq kh lr kl ls kp mx lu lv lw bi translated">分层K倍= 5个数据块</li></ul><h1 id="0a19" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">代码</strong></h1><p id="22a6" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">导入库</p><pre class="na nb nc nd fd ne mf nf ng aw nh bi"><span id="6d3e" class="mg iv hi mf b fi ni nj l nk nl">import os</span><span id="abf9" class="mg iv hi mf b fi nm nj l nk nl">import numpy as np<br/>import pandas as pd<br/>from sklearn import preprocessing<br/>import xgboost as xgb<br/>from catboost import CatBoostClassifier</span></pre><p id="cf54" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">加载数据</p><pre class="na nb nc nd fd ne mf nf ng aw nh bi"><span id="dfa1" class="mg iv hi mf b fi ni nj l nk nl">%%time<br/>train_transaction = pd.read_csv('train_transaction.csv', index_col='TransactionID')<br/>test_transaction = pd.read_csv('test_transaction.csv', index_col='TransactionID')</span><span id="2418" class="mg iv hi mf b fi nm nj l nk nl">train_identity = pd.read_csv('train_identity.csv', index_col='TransactionID')<br/>test_identity = pd.read_csv('test_identity.csv', index_col='TransactionID')</span><span id="749b" class="mg iv hi mf b fi nm nj l nk nl">sample_submission = pd.read_csv('sample_submission.csv', index_col='TransactionID')</span><span id="4312" class="mg iv hi mf b fi nm nj l nk nl">train = train_transaction.merge(train_identity, how='left', left_index=True, right_index=True)<br/>test = test_transaction.merge(test_identity, how='left', left_index=True, right_index=True)</span><span id="a6b4" class="mg iv hi mf b fi nm nj l nk nl">print(train.shape)<br/>print(test.shape)</span><span id="ed73" class="mg iv hi mf b fi nm nj l nk nl">y_train = train['isFraud'].copy()<br/>del train_transaction, train_identity, test_transaction, test_identity</span><span id="e5e0" class="mg iv hi mf b fi nm nj l nk nl"># Drop target, fill in NaNs<br/>X_train = train.drop('isFraud', axis=1)<br/>X_test = test.copy()</span><span id="504d" class="mg iv hi mf b fi nm nj l nk nl">del train, test</span><span id="0afb" class="mg iv hi mf b fi nm nj l nk nl"># Label Encoding<br/>for f in X_train.columns:<br/>    if X_train[f].dtype=='object' or X_test[f].dtype=='object': <br/>        lbl = preprocessing.LabelEncoder()<br/>        lbl.fit(list(X_train[f].values) + list(X_test[f].values))<br/>        X_train[f] = lbl.transform(list(X_train[f].values))<br/>        X_test[f] = lbl.transform(list(X_test[f].values))</span></pre><p id="69df" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">减少内存使用</p><pre class="na nb nc nd fd ne mf nf ng aw nh bi"><span id="87db" class="mg iv hi mf b fi ni nj l nk nl">%%time<br/># From kernel <a class="ae kv" href="https://www.kaggle.com/gemartin/load-data-reduce-memory-usage" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/gemartin/load-data-reduce-memory-usage</a><br/># WARNING! THIS CAN DAMAGE THE DATA <br/>def reduce_mem_usage(df):<br/>    """ iterate through all the columns of a dataframe and modify the data type<br/>        to reduce memory usage.        <br/>    """<br/>    start_mem = df.memory_usage().sum() / 1024**2<br/>    print('Memory usage of dataframe is {:.2f} MB'.format(start_mem))<br/>    <br/>    for col in df.columns:<br/>        col_type = df[col].dtype<br/>        <br/>        if col_type != object:<br/>            c_min = df[col].min()<br/>            c_max = df[col].max()<br/>            if str(col_type)[:3] == 'int':<br/>                if c_min &gt; np.iinfo(np.int8).min and c_max &lt; np.iinfo(np.int8).max:<br/>                    df[col] = df[col].astype(np.int8)<br/>                elif c_min &gt; np.iinfo(np.int16).min and c_max &lt; np.iinfo(np.int16).max:<br/>                    df[col] = df[col].astype(np.int16)<br/>                elif c_min &gt; np.iinfo(np.int32).min and c_max &lt; np.iinfo(np.int32).max:<br/>                    df[col] = df[col].astype(np.int32)<br/>                elif c_min &gt; np.iinfo(np.int64).min and c_max &lt; np.iinfo(np.int64).max:<br/>                    df[col] = df[col].astype(np.int64)  <br/>            else:<br/>                if c_min &gt; np.finfo(np.float16).min and c_max &lt; np.finfo(np.float16).max:<br/>                    df[col] = df[col].astype(np.float16)<br/>                elif c_min &gt; np.finfo(np.float32).min and c_max &lt; np.finfo(np.float32).max:<br/>                    df[col] = df[col].astype(np.float32)<br/>                else:<br/>                    df[col] = df[col].astype(np.float64)<br/>        else:<br/>            df[col] = df[col].astype('category')</span><span id="645c" class="mg iv hi mf b fi nm nj l nk nl">end_mem = df.memory_usage().sum() / 1024**2<br/>    print('Memory usage after optimization is: {:.2f} MB'.format(end_mem))<br/>    print('Decreased by {:.1f}%'.format(100 * (start_mem - end_mem) / start_mem))<br/>    <br/>    return df<br/>X_train = reduce_mem_usage(X_train)<br/>X_test = reduce_mem_usage(X_test)</span></pre><p id="40e7" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">清除数据中表示的任何空值</p><pre class="na nb nc nd fd ne mf nf ng aw nh bi"><span id="0dce" class="mg iv hi mf b fi ni nj l nk nl">#data cleaning<br/>def clean_inf_nan(df):<br/>    return df.replace([np.inf, -np.inf], np.nan)</span><span id="456b" class="mg iv hi mf b fi nm nj l nk nl"># Cleaning infinite values to NaN<br/>X_train = clean_inf_nan(X_train)<br/>X_test = clean_inf_nan(X_test) # replace all nan,inf,-inf to nan so it will be easy to replace<br/>for i in X_train.columns:<br/>    X_train[i].fillna(X_train[i].median(),inplace=True) # fill with median because mean may be affect by outliers.<br/>#X.isna().sum().sum()<br/>for i in X_test.columns:<br/>    X_test[i].fillna(X_test[i].median(),inplace=True)</span></pre><p id="f7a6" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">主模型</p><pre class="na nb nc nd fd ne mf nf ng aw nh bi"><span id="cab7" class="mg iv hi mf b fi ni nj l nk nl">#%%time<br/>from sklearn.model_selection import StratifiedKFold<br/>from sklearn.metrics import roc_auc_score</span><span id="7ff9" class="mg iv hi mf b fi nm nj l nk nl">EPOCHS = 5</span><span id="2479" class="mg iv hi mf b fi nm nj l nk nl">kf = StratifiedKFold(n_splits = EPOCHS, shuffle = True)</span><span id="3d4a" class="mg iv hi mf b fi nm nj l nk nl">y_preds = np.zeros(sample_submission.shape[0])<br/>y_oof = np.zeros(X_train.shape[0])</span><span id="6d3d" class="mg iv hi mf b fi nm nj l nk nl">for tr_idx, val_idx in kf.split(X_train, y_train):<br/>    <br/>    clf = xgb.XGBClassifier(<br/>        n_estimators=500,<br/>        max_depth=9,<br/>        learning_rate=0.05,<br/>        subsample=0.9,<br/>        colsample_bytree=0.9,<br/>        missing=-999,<br/>        random_state=2019,<br/>        tree_method='auto',<br/>        n_jobs = -1,<br/>        <br/>    )<br/>    <br/>    X_tr, X_vl = X_train.iloc[tr_idx, :], X_train.iloc[val_idx, :]<br/>    y_tr, y_vl = y_train.iloc[tr_idx], y_train.iloc[val_idx]<br/>    <br/>    clf.fit(X_tr, y_tr)<br/>    <br/>    y_pred_train = clf.predict_proba(X_vl)[:,1]<br/>    y_oof[val_idx] = y_pred_train<br/>    <br/>    print('ROC AUC {}'.format(roc_auc_score(y_vl, y_pred_train)))<br/>    <br/>    y_preds+= clf.predict_proba(X_test)[:,1] / EPOCHS</span></pre><h1 id="b581" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">评估指标</strong></h1><p id="1845" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">为了定义我们的模型有多好，我们需要使用最合适的评估指标。幸运是，Scikit-Learn提供了许多有用的指标供我们使用。然而，我们将使用与Kaggle竞赛网站中显示的相同的指标，称为ROC AUC SCORE。</p><p id="c4d6" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html" rel="noopener ugc nofollow" target="_blank"> ROC AUC得分</a>:根据预测得分计算受试者工作特征曲线下面积(ROC AUC)。越高越好。</p><h1 id="ccea" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">训练的每个折叠/组块的结果</strong></h1><p id="8ada" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">ROC AUC:0.9645106433450377<br/>ROC AUC:0.9623382759183995<br/>ROC AUC:0.96282828 2124302243<br/>ROC AUC:0.962020565 684446</p><h1 id="bdd0" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">私人排行榜得分和排名</strong></h1><p id="b6b9" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">ROC AUC: 0.929200</p><p id="0a8e" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">排名:6381支队伍中的153支</p><p id="0cf0" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">成绩:银牌</p><p id="e701" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">团队成员总数:3</p><h1 id="5c11" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">结论</strong></h1><p id="274e" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">总之，机器学习和深度学习在解决现实世界的问题方面显示出了有希望的结果。欺诈检测系统是机器学习可以应用的一个很好的例子。虽然它不能解决我们现在面临的所有问题，但我相信每一项发明都是新一代技术进步的垫脚石。希望在不久的将来，我们能够实现一个更强大的系统，防止任何不好的事情发生。</p><p id="ee21" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">干杯！！！</p><p id="a9d7" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">如果你想了解我的文章和:D项目的最新进展，请在媒体上关注我</p><h1 id="0066" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">联系人</strong></h1><p id="bf9f" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated"><a class="ae kv" href="https://www.linkedin.com/in/rom-uddamvathanak-3099a7153/" rel="noopener ugc nofollow" target="_blank">领英</a></p></div></div>    
</body>
</html>