<html>
<head>
<title>THE STORY OF LOGISTIC REGRESSION CONTINUES…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归的故事还在继续…</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-story-of-logistic-regression-contiues-2170395afb39?source=collection_archive---------16-----------------------#2020-09-07">https://medium.com/analytics-vidhya/the-story-of-logistic-regression-contiues-2170395afb39?source=collection_archive---------16-----------------------#2020-09-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cfd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将继续讲述逻辑回归的故事，如果你还没有阅读上一篇文章，这里是<a class="ae jd" rel="noopener" href="/analytics-vidhya/the-story-of-logistic-regression-3a978fdc4fe2"> <strong class="ih hj">链接</strong> </a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/6105a082cf1fe1fe4e5578f67ae7589c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*3FgpptTWzpd2RLgKbV-HvA.jpeg"/></div></div></figure><p id="8723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我把事情说得简单明了，即使在这篇文章中，我也无法完成逻辑回归，因为这是一个广泛的话题，我们正在详细讨论它，所以最好计划一下我们将在这篇文章中讨论的内容。</p><h2 id="e504" class="jq jr hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated">我们将涵盖:</h2><ol class=""><li id="36b5" class="kl km hi ih b ii kn im ko iq kp iu kq iy kr jc ks kt ku kv bi translated"><strong class="ih hj"> <em class="kw">西格玛函数的概率方法。</em> </strong></li><li id="d8fe" class="kl km hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated"><strong class="ih hj"> <em class="kw">最优化理论。</em>T11】</strong></li><li id="2b0f" class="kl km hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated"><strong class="ih hj"> <em class="kw">我们将通过几何推导 LR 的优化问题。</em>T15】</strong></li><li id="9787" class="kl km hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated"><strong class="ih hj"> <em class="kw">权重向量</em> </strong></li><li id="d8f8" class="kl km hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated"><strong class="ih hj"> <em class="kw">我们将处理过度拟合问题。</em> </strong></li><li id="700c" class="kl km hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated"><strong class="ih hj"> <em class="kw">我们将详细看到 L1 和 L2 的正规化。</em> </strong></li></ol><p id="a603" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们开始吧，</p><h2 id="883d" class="jq jr hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated"><strong class="ak"> <em class="lc">西格玛函数的概率方法</em> </strong></h2><p id="cb2c" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">现在我们已经导出了优化问题，它可以通过挖掘距离来处理异常值，我们知道为什么要使用 sigma 函数。我们使用西格玛函数的原因之一是它有很好的概率解释。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lg"><img src="../Images/0a985bf8d603a998627c0c8b3382f82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JAo1M7GnyWduQB2outkF5A.jpeg"/></div></div></figure><p id="14b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看西格玛函数的概率解释。</p><p id="8cab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例 1</p><p id="ff4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有同样的分类问题，其中我们用否定来分类肯定，所以让我们想象一个查询点位于超平面上，现在直觉上有 50 -50 的机会将查询点分类为肯定的和否定的。那么点为正的概率是多少，毫无疑问是 0.5，负的也是一样。</p><p id="caf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">P(Y=1)=0.5</p><p id="d4d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一个 sigma 函数，其定义为</p><p id="5088" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">sigma=1/(1+e^(-s))这里是 LR，</p><p id="547b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">s=yi*w^T*xi，对于上面的问题，w^T*xi 是“0 ”,因为点位于超平面上，所以 s=0，这意味着 sigma =0.5 与概率相同(上面找到的)</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lh"><img src="../Images/ec7065c7f61f61e642e234c026f22cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOCK04n5UXqYUjB8EVbpEA.jpeg"/></div></div></figure><p id="9680" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例 2</p><p id="94f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有相同的分类问题，其中我们用否定分类肯定，所以让我们想象一个查询点位于距离超平面 100 处，如图所示，现在首先根据我们的 sigmoid 函数，下面是 sigma 函数的图形。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es li"><img src="../Images/74bec2b219e5ae972a15a605049e7493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wi2ycMEusv3_bfoLsSJeXQ.jpeg"/></div></div></figure><p id="4623" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当这个点在一个很远的距离，比如说从超平面的 w^T*xi(distance)是 100，正如我上面提到的，在 w 的同一个方向上，根据图表，它的值将是 0.99999，你也可以从公式中得到，意味着 P(Y=1)=0.99999 意味着有 99%的可能性 y 属于正类。所以我们可以很容易地得出一个结论，</p><p id="9451" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="kw">【sigma(w^t*xi)=p(y=1】)</em></strong>，其中 P(y=1)等于概率当 y=1 时表示该点属于正类。</p><p id="3e32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kw">显然</em></strong><strong class="ih hj"><em class="kw">【sigma(w^t*xi】)的值在 0 到 1 之间，概率值在 0 到 1 之间。</em> </strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lj"><img src="../Images/70a3c7f6e38a7c9d09a526c310664ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*by0CAYmo0kwJXIx4SZfw1w.jpeg"/></div></div></figure><h2 id="bced" class="jq jr hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated"><strong class="ak"> <em class="lc">逻辑回归优化理论</em> </strong></h2><p id="7a29" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">所以我们需要一些优化工具来优化我们的 LR 问题。我们也可以解决前面的优化问题，但我们希望做得更好。</p><p id="5d91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经看到了我们的优化问题，它受离群值的影响较小。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lk"><img src="../Images/5af7d0c8807bdab8ce93093a5191390b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9jUzD1Qm56s2g01o5Ba8g.jpeg"/></div></div></figure><p id="d71b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了找到更优化的一个，让我们了解一些优化理论。</p><p id="7492" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">单调函数</strong></p><p id="d897" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我有两个点 x1 和 x2，我知道 x1&gt;x2，所以如果有一个函数 g(x1)和一个函数 g(x2)</p><p id="66fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果 g(x1) &gt;g(x2)，则</p><p id="b1ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">g(x)是类似 log(x)的单调递增函数</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ll"><img src="../Images/759e6465cb9b3b8da618c673e6027851.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*jFhiLC2oSNMmTItkGXsKiw.png"/></div></figure><p id="5f98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如图所示，如果 x 增加，log(x)也会增加。Log(x)是一个运动增量函数。</p><p id="8554" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，假设我们有一个优化问题，我们需要找到 x 的最佳值，使 x^2 最小</p><p id="361c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们很容易给出它的答案是“0”。正如我们在下图中看到的，对于 x=0，x^2 是 0，这是最小值，所以从上图中 x*值是 0。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lm"><img src="../Images/4e888cd8ffcaddd68aca476c006e9e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*CbcBp8OrbZiVc38sp-2uNw.png"/></div></figure><p id="e3ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们假设我有一个函数 g(x) =log(x)，我想找到 x 的最佳值，我可以得到 g(f(x))的最小值，其中 f(x)是 x^2.</p><p id="0e33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我又有一个优化问题，我们需要找到使 g(f(x))最小的 x</p><p id="0bca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">g(f(x))= log(x^2).</p><p id="26a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在最优化理论说，如果 g(x)是单调递增的，那么我们在第一个问题中找到的 x*等于我们在第二个问题中找到的 x’(当使用 g(f(x))的时候。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ln"><img src="../Images/1b78d1e1fe8431e0525c742c8e0f9df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngZ-X5x-j-haDP9m_gUmEw.jpeg"/></div></div></figure><p id="068c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也可以从下图中看到，我们发现 x*=0，所以如果我们看到 log(x^2 的图，我们可以看到它在 0 处最小，这是因为 log(x)是一个单调递增的函数。</p><p id="28be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将这一理论应用于我们的 LR 优化问题</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lo"><img src="../Images/cda9eb21eb4bab3ad4daecd8560df0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ic1DiQFRTrMT12pfhLAxpA.jpeg"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lp"><img src="../Images/046c25b1e7039782087a6b83ab7194f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L07o---9oprw_HLKZNph3A.jpeg"/></div></div></figure><p id="c8a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">权重向量</strong></p><p id="920f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在一个想法很容易被误解</p><p id="bbb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“w*”向量，首先这是我们在解决优化问题后得到的向量。</p><p id="6c02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们如何解决？</strong></p><p id="903c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在以后讨论这个细节，但是现在让我们假设我们得到了 w*(最优 w)，现在我只把 w*写成 w。</p><p id="2969" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以“w”是一个 d 维向量，因为否则 w^T*x 是不可能的，因为 x 也是 d 维的。</p><p id="33d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，尺寸仅仅意味着特征</p><p id="caa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以将 w 向量理解为每个特征的权重。</p><p id="ee05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">w= <w1 w2="" w3=""/></p><p id="8f20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于功能</p><p id="5190" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">f= <f1 f2="" f3=""/></p><p id="48ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个要素的权重。</p><p id="42ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看测试时会发生什么。</p><p id="37e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你有一个查询点(xq ),你需要找到它的类标签(yq ),可以是正的也可以是负的。</p><p id="917c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以如果</p><p id="57de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> w^T*xq &gt; 0 然后 yq=+ve </strong></p><p id="4a49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中 w 是我们在解决优化问题后找到的最优 w。</p><p id="1f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果</p><p id="2244" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> w^T*xq &lt; 0 然后 yq=-ve </strong></p><h2 id="9814" class="jq jr hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated">过度拟合问题</h2><p id="c4ae" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">现在我们有一个问题，让我们来解决它。</p><p id="ce28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们得到了优化的问题</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lq"><img src="../Images/d73fcfc98011d9d1ffc11f50d62f4141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wB8skSg4BdVFNzAeEB2-ag.jpeg"/></div></div></figure><p id="e453" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如说 zi=yi*w^T*xi</p><p id="3508" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在如果我们分析一下，我们自然知道，exp(-zi)总是大于等于零，(1+exp(-zi))总是大于零，log 是一个单调函数</p><p id="ea95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">log(1+exp(-zi))&gt;0</p><p id="1ff7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以不同 zi 的所有 log 值之和大于零，这意味着如果我们想找到最小值，它必须为零。所以基本上我们需要找出 w*，对于它，整个求和项变为零。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lr"><img src="../Images/7bc3d24922e733d5eebd283382a3fa98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3omYBWENGuI52K620rM_A.jpeg"/></div></div></figure><p id="93e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们仔细分析，我们可以说只有在 x=1 时，log 值为“0”，log(1)=0，意味着 1+exp(-zi)=1，意味着 exp(-zi)变为 0，因此 zi 必须变为无穷大。</p><p id="8eec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">子，我们给定了易和，当我们说子变得无穷大时，这意味着 w 必须变得无穷大，如果子是无穷大，我们还说子&gt; 0 意味着我们总是正确地分类所有的训练点，这意味着我们过度拟合模型。</p><p id="dc08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们回忆一下，我们正在忘记一个关键的方面，w 垂直于超平面。</p><p id="283a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">w^t*w=1，我们没有在任何地方使用这个条件。</p><p id="f5d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们用这个。</p><p id="8aaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何处理这个问题？</strong></p><p id="411f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案是正则化，有两种类型的正则化 L1 和 L2，正则化简单地说就是增加另一项，这样它就能创造稳定性，减少过度拟合。</p><p id="0207" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> L2 正规化</strong></p><p id="e1ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们这样写优化问题，</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ls"><img src="../Images/36a3a8530125b01ef8bdaee7c1971812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8lEZEIzHuAw9Fe5TGl_WQ.jpeg"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lt"><img src="../Images/bc2a9faa3ca5191815d736b1c08d9716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rtQ06FED-lideipJvOEQA.jpeg"/></div></div></figure><p id="65ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们想找到使整个项最小的 w，如果我们想减少对数项，我们需要增加 w，如果我们增加 w 项，那么正则项将是最大值，我们不会得到最小值，正则项没有用。</p><p id="6078" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们减小 w 的值，那么对数项将不再是 0，我们也找不到最小值。</p><p id="e102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里λ是一个超参数，可以通过<a class="ae jd" rel="noopener" href="/analytics-vidhya/k-fold-cross-validations-in-machine-learning-7fd2f48e0a6f"> <strong class="ih hj">交叉验证</strong> </a>找到</p><p id="b060" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以如果 lamda 是“0”意味着没有正则项意味着过拟合。</p><p id="f3e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果 lambda 为无穷大，意味着损失项的影响将会更小，因此没有使用训练数据，模型将会欠拟合。</p><p id="c01a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> L1 正规化</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ls"><img src="../Images/8225aab9794b018fb1dfba9fa234a36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnfbltDFAdKTaf-YnFVn-w.jpeg"/></div></div></figure><p id="eb92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">L1 正则化是伟大的，如果你想低延迟，特别是在互联网公司，使用预期结果来在几秒钟内。</p><p id="5084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它实际上创建了一个逻辑回归的解，即“w”太稀疏，这意味着如果 w 不太重要，如果一些特征在解决方案中不太重要，那么 L1 将使 w 为零。</p><p id="8d0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PPPPPP</p><p id="4e30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" rel="noopener" href="/analytics-vidhya/most-common-data-science-question-part-1-e049e338af4f"> <strong class="ih hj">为什么 L1 在《W》中创造了与 L2 正则化相比的稀疏性？？</strong>T13】</a></p><p id="d0f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有另一种正则化方法，那就是<strong class="ih hj">弹性网</strong>。我们基本上结合了 L1 和 L2，并通过交叉验证简单地找到了两个超参数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lu"><img src="../Images/4267f1b9e127d9d45da9ce84602285a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoosp-N_CbZjs-8UBFv6gA.jpeg"/></div></div></figure><p id="6bad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这篇文章就是这样，这或多或少是逻辑回归背后的故事。</strong></p><p id="0d67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">感谢阅读。</strong></p></div></div>    
</body>
</html>