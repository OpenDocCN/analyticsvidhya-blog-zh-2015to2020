<html>
<head>
<title>I tried replicating the recommendation engines used by e-commerce platforms, here’s how it went….</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我试图复制电子商务平台使用的推荐引擎，下面是它是如何进行的…</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/i-tried-replicating-the-recommendation-engines-used-by-e-commerce-platforms-heres-how-it-went-a1ed3d7c82c9?source=collection_archive---------25-----------------------#2020-06-30">https://medium.com/analytics-vidhya/i-tried-replicating-the-recommendation-engines-used-by-e-commerce-platforms-heres-how-it-went-a1ed3d7c82c9?source=collection_archive---------25-----------------------#2020-06-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/85be035469b4b09c855b914fe005ea62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OWeJN2eO17A3CEWREw70tw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">购物时相似t恤/羊毛衫的推荐{ <a class="ae iu" href="https://pixabay.com/photos/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1031469" rel="noopener ugc nofollow" target="_blank"> Source </a></figcaption></figure><p id="b7c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为各种电子商务网站的消费者，当平台开始推荐与以前购买相似的商品、搜索历史甚至只是看起来相似的商品时，我总是很好奇。随着隔离让我感到极度无聊，我决定进一步深入推荐引擎的世界，好家伙，我失望了。事实证明，这些算法并不难理解。因此，为了好玩，我决定创建一个推荐系统。</p><h1 id="f874" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">提纲</strong></h1><blockquote class="kr ks kt"><p id="1c73" class="iv iw ku ix b iy iz ja jb jc jd je jf kv jh ji jj kw jl jm jn kx jp jq jr js hb bi translated"><em class="hi">数据收集</em></p><p id="6b5a" class="iv iw ku ix b iy iz ja jb jc jd je jf kv jh ji jj kw jl jm jn kx jp jq jr js hb bi translated"><em class="hi">创建迁移学习模型并保存</em></p><p id="9f57" class="iv iw ku ix b iy iz ja jb jc jd je jf kv jh ji jj kw jl jm jn kx jp jq jr js hb bi translated"><em class="hi">获取推荐</em></p><p id="a9cf" class="iv iw ku ix b iy iz ja jb jc jd je jf kv jh ji jj kw jl jm jn kx jp jq jr js hb bi translated"><em class="hi">创建用户界面并嵌入模型</em></p><p id="8979" class="iv iw ku ix b iy iz ja jb jc jd je jf kv jh ji jj kw jl jm jn kx jp jq jr js hb bi translated"><em class="hi">部署</em></p></blockquote><p id="e9af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">剧透:我确实做了一个静态的朴素模型，它适用于一些静态图像。</strong> <a class="ae iu" href="https://productrecom-n.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">点击这里获取推荐！</strong>T19】</a></p><p id="16bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很明显，现在只有大量的推荐引擎，但大多数都只迎合了数字领域的需求。电影推荐是最常用的推荐系统。因此，试图找出如何创建一个模型是一项相当艰巨的任务。最后，我决定可以使用迁移学习模型来提取特征，正如许多教程所见，只有余弦相似度可以用于获得推荐。</p><p id="3948" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:添加了代码片段，但是对于整个源代码，<a class="ae iu" href="https://github.com/niharika412/product_recommendations" rel="noopener ugc nofollow" target="_blank">点击这里。</a></p><h1 id="5ddd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">数据收集</strong></h1><p id="6527" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">数据收集很容易。编写一些python代码，您就可以准备好数据了。我决定收集自己的数据，但是任何包含产品图片的数据集都可以！Kaggle有许多这样的数据集。</p><p id="6edd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一些数据抓取的代码——我首先从网站上抓取图片链接，然后下载图片。</p><h1 id="5cee" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">迁移学习</strong></h1><p id="f6bd" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">迁移学习就是操纵和实现一个模型，这个模型是为解决一个问题而创建的，用来解决一个不同但相关的问题。基本上就是用一个用来分类猫和狗的模型来分类汉堡和披萨。有许多型号可供选择，即。InceptionV3、VGG16、ResNet型号和都具有相同的用途，但架构不同。我选择了VGG16模型进行特征提取。</p><p id="9a01" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">特征提取是从原始变量的初始集合中评估图像并识别用于处理的可管理组的过程。</p><p id="073a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">特征提取后，用余弦相似度来识别相似图像。余弦相似度使用以下公式计算。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/dabb0ca6a1bbcf81c7cc35aee293535c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJXxsZ1SdnaLZPXvVyxDbQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">余弦相似性</figcaption></figure><p id="e86e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这基本上创建了一个效用矩阵，可用于进一步索引图像并获得最相似的图像！</p><p id="1a6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一些转移学习代码:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="eaa0" class="ln ju hi lj b fi lo lp l lq lr"><em class="ku"># load the model</em><br/>vgg_model = vgg16.VGG16(weights='imagenet')<br/><br/><em class="ku"># remove the last layers in order to get features instead of predictions</em><br/>feat_extractor = Model(inputs=vgg_model.input, outputs=vgg_model.get_layer("fc2").output)<br/><br/><em class="ku"># print the layers of the CNN</em><br/>feat_extractor.summary()</span></pre><p id="a31e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">点击此处查看整个笔记本！</p><h1 id="9fb8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">获取推荐</strong></h1><p id="167f" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在特征提取之后，获得推荐是容易的。目标只是索引图像并获得相似的项目。</p><p id="1eef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用了以下函数:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="e6eb" class="ln ju hi lj b fi lo lp l lq lr"><strong class="lj hj">def</strong> retrieve_most_similar_products(given_img):<br/><br/>    print("-----------------------------------------------------------------------")<br/>    print("original product:")<br/><br/>    original = load_img(given_img, target_size=(imgs_model_width, imgs_model_height))<br/>    plt.imshow(original)<br/>    plt.show()<br/><br/>    print("-----------------------------------------------------------------------")<br/>    print("most similar products:")<br/><br/>    closest_imgs = cos_similarities_df[given_img].sort_values(ascending=<strong class="lj hj">False</strong>)[1:nb_closest_images+1].index<br/>    closest_imgs_scores = cos_similarities_df[given_img].sort_values(ascending=<strong class="lj hj">False</strong>)[1:nb_closest_images+1]</span></pre><h1 id="b401" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">创建用户界面</strong></h1><p id="bd76" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">创建接口有很多选项，我选择Plotly-Dash只是因为它完全是用Python编写的，只带了一点CSS(Bootstrap)。官方网站上的dash教程非常容易理解和实现。我想出了如何添加回调和输入、输出，于是我有了一个工作模型。作为一个几乎没有创造力的人，我花了几个小时才想出了配色方案。</p><p id="273f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是模型的外观:</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/9578dd5694f8331657c5875370fe3779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*PrK_1VuSYNNzM6rOLVKybA.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">推荐</figcaption></figure><h1 id="71f5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">部署</strong></h1><p id="4083" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">Dash应用通常部署在Heroku上。现在，我尝试这样做，但遇到了一堆错误和警告。原来，heroku只允许高达500MB的slug大小(原型大小),而我的模型大小大约是528MBs。因此，整个应用程序大约有800兆字节。因此，我必须为界面上的所有图像生成推荐，静态地存储它们，并在用户每次请求时调用它们。这意味着该模型不能直接用于获得预测，但是至少应用程序运行得很快，并且正在工作。但是，这个模型可以直接在您的本地机器上使用(我称之为动态用户界面)。</p><p id="13ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是部署的模型:<a class="ae iu" href="https://productrecom-n.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">产品推荐👢</a></p><p id="cd0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于整个源代码:</p><div class="lt lu ez fb lv lw"><a href="https://github.com/niharika412/product_recommendations" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab dw"><div class="ly ab lz cl cj ma"><h2 class="bd hj fi z dy mb ea eb mc ed ef hh bi translated">niharika 412/产品_推荐</h2><div class="md l"><h3 class="bd b fi z dy mb ea eb mc ed ef dx translated">🎈基于迁移学习和余弦图像相似度的产品推荐🎀 👚 👢在线购物网站…</h3></div><div class="me l"><p class="bd b fp z dy mb ea eb mc ed ef dx translated">github.com</p></div></div></div></a></div><p id="4464" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>