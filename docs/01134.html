<html>
<head>
<title>Group Manipulation In R — 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R — 3中的群操纵</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/group-manipulation-in-r-3-5554a0c1b544?source=collection_archive---------3-----------------------#2019-10-03">https://medium.com/analytics-vidhya/group-manipulation-in-r-3-5554a0c1b544?source=collection_archive---------3-----------------------#2019-10-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="e907" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">如果您还没有阅读R数据分析系列的第2部分，请仔细阅读下面这篇文章，在这篇文章中，我们讨论了R-2中的<a class="ae jh" rel="noopener" href="/@viveksrinivasan/statistical-visualization-in-r-2-9e9070bcdecf">统计可视化。</a></p><p id="a765" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这篇文章的内容是我在IIM-B时代得到的几本书的要点。</p><p id="ebf8" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">人人为我——贾里德·p·兰德</p><p id="d850" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">实用数据科学与R — Nina Zumel和John Mount</p><p id="61b3" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">文中讨论的所有代码块都以R markdown的形式出现在<a class="ae jh" href="https://github.com/viveksrinivasanss/Data_Science_Using_R" rel="noopener ugc nofollow" target="_blank"> Github链接</a>中。</p></blockquote><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/8de5d64c43dfbb58ca6ab26f2d770da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCsUHv7JSHRPO7AVDQDjSQ.jpeg"/></div></div></figure><p id="7f64" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi jx translated"><span class="l jy jz ka bm kb kc kd ke kf di"/>数据分析的一般经验法则是，处理数据或数据管理消耗80 %的精力。这通常需要对数据的不同部分进行重复操作— <code class="du kg kh ki kj b">split-apply-combine</code>。也就是说，我们根据某种度量将数据分割成离散的部分，对每个部分应用某种转换，然后将所有部分组合在一起。在R中有很多方法可以迭代数据，我们将看到一些最方便的方法。</p><h1 id="9296" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">应用系列</h1><p id="00c4" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it ju lk iw ix jv ll ja jb jw lm je jf jg hb bi translated">r内置了<code class="du kg kh ki kj b">apply</code>函数及其所有相关函数，如<code class="du kg kh ki kj b">tapply</code>、<code class="du kg kh ki kj b">lapply</code>、<code class="du kg kh ki kj b">sapply </code>和<code class="du kg kh ki kj b">mapply.</code>，让我们看看每个函数在处理数据时是如何使用的。</p><h2 id="26c6" class="ln kl hi bd km lo lp lq kq lr ls lt ku ju lu lv ky jv lw lx lc jw ly lz lg ma bi translated">应用</h2><p id="5531" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it ju lk iw ix jv ll ja jb jw lm je jf jg hb bi translated"><code class="du kg kh ki kj b">apply </code>是用户通常学习的这个家族的第一个成员，也是本质上限制最多的。它必须用在<code class="du kg kh ki kj b">matrix</code>上，这意味着所有元素必须是同一类型，无论它们是<code class="du kg kh ki kj b">character</code>、<code class="du kg kh ki kj b">numeric </code>还是<code class="du kg kh ki kj b">logical</code>。如果用于其他对象，如<code class="du kg kh ki kj b">data.frame</code>，它将首先被转换为<code class="du kg kh ki kj b">matrix </code>。</p><p id="0929" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated"><code class="du kg kh ki kj b">apply </code>的第一个参数是我们正在处理的对象。第二个参数是应用函数的边距，1表示在<code class="du kg kh ki kj b">rows </code>上操作，2表示在<code class="du kg kh ki kj b">columns</code>上操作。第三个参数是我们想要应用的函数。任何随后的参数都将被传递给函数。</p><p id="9afd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">为了说明它的用法，我们从一个简单的例子开始，对一个<code class="du kg kh ki kj b">matrix</code>的行或列求和。注意，这也可以使用内置的<code class="du kg kh ki kj b">rowSums </code>和<code class="du kg kh ki kj b">colSums</code>来完成，产生相同的结果。</p><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="3edc" class="ln kl hi kj b fi mf mg l mh mi">theMatrix &lt;- matrix(1:9, nrow=3)<br/>apply(theMatrix,1,sum) ## Row Sum<br/>apply(theMatrix,2,sum) ## Column Sum</span></pre><p id="9d69" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">类似于大多数的<code class="du kg kh ki kj b">R</code>函数，我们有一个参数<code class="du kg kh ki kj b">na.rm</code>来处理矩阵或任何其他数据类型中的缺失值<code class="du kg kh ki kj b">NA</code>。我们给<code class="du kg kh ki kj b">theMatrix</code>加一些<code class="du kg kh ki kj b">NA </code>吧。</p><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="34a7" class="ln kl hi kj b fi mf mg l mh mi">theMatrix[2,1] &lt;- NA<br/>apply(theMatrix,1,sum)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mj"><img src="../Images/2682b28eb817013d1f5d9d3e57f01b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6BqjsJGqcMG2OcLpdEdiw.png"/></div></div></figure><p id="0461" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">通过向<code class="du kg kh ki kj b">apply </code>函数添加<code class="du kg kh ki kj b">na.rm</code>参数，它将忽略缺失的值，并计算行和列的总和。</p><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="d88e" class="ln kl hi kj b fi mf mg l mh mi">apply(theMatrix,1,sum,na.rm=TRUE)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mk"><img src="../Images/64585bc5ad452690fc28a32dc89bfafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tyHQr5OeTpXPjapVDEM6fQ.png"/></div></div></figure><h2 id="d634" class="ln kl hi bd km lo lp lq kq lr ls lt ku ju lu lv ky jv lw lx lc jw ly lz lg ma bi translated">轻快活泼</h2><p id="955d" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it ju lk iw ix jv ll ja jb jw lm je jf jg hb bi translated"><code class="du kg kh ki kj b">lapply </code>的工作方式与<code class="du kg kh ki kj b">apply </code>相似，但它将函数应用于<code class="du kg kh ki kj b">list </code>的每个元素，并将结果作为<code class="du kg kh ki kj b">list </code>返回。</p><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="0e0b" class="ln kl hi kj b fi mf mg l mh mi">theList &lt;- list(A=matrix(1:9,3), B=1:5,C=matrix(1:4,2), D=2)<br/>lapply(theList,sum)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ml"><img src="../Images/ad6f2293c2bbf837424f16b0abd8356c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4b6LFJbQQx8DRE6sHfqeA.png"/></div></div></figure><p id="3589" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">处理<code class="du kg kh ki kj b">lists </code>有时候感觉有点麻烦，所以把结果返回为<code class="du kg kh ki kj b">vector </code>代替，<code class="du kg kh ki kj b">sapply </code>可以像<code class="du kg kh ki kj b">lapply</code>一样投入使用。而矢量在技术上是<code class="du kg kh ki kj b">list</code>的一种形式，所以<code class="du kg kh ki kj b">lapply </code>和<code class="du kg kh ki kj b">sapply </code>也可以把<code class="du kg kh ki kj b">vector </code>作为它们的输入</p><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="d562" class="ln kl hi kj b fi mf mg l mh mi">sapply(theList,sum)</span><span id="96b5" class="ln kl hi kj b fi mm mg l mh mi">## Counting no of characters in each word<br/>theNames &lt;- c("Jared","Deb","Paul")<br/>sapply(theNames,nchar)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mn"><img src="../Images/3365efb78d8ccc86064422c45d076d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3_G1AujL9RzeQrk28zoZA.png"/></div></div></figure><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mo"><img src="../Images/7c9ba6af67417da0237270a722545ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9dcujv6lLpN76W82ZoJgQ.png"/></div></div></figure><h2 id="f98e" class="ln kl hi bd km lo lp lq kq lr ls lt ku ju lu lv ky jv lw lx lc jw ly lz lg ma bi translated">地图</h2><p id="0356" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it ju lk iw ix jv ll ja jb jw lm je jf jg hb bi translated">也许apply家族中最容易被忽略但却非常有用的成员是<code class="du kg kh ki kj b">mapply</code>，它将一个函数应用于multiple <code class="du kg kh ki kj b">lists</code>的每个元素。通常，当面对这种情况时，人们会求助于使用循环，这当然是不必要的。让我们构建两个列表，通过一个例子来理解<code class="du kg kh ki kj b">mapply </code>的用法。我们在R中使用内置的<code class="du kg kh ki kj b">identical </code>函数，通过元素到元素的比较来查看两个列表是否相同。</p><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="535d" class="ln kl hi kj b fi mf mg l mh mi">## build two lists<br/>firstList &lt;- list(A=matrix(1:16,4),B=matrix(1:16,2),c(1:5))<br/>secondList &lt;- list(A=matrix(1:16,4),B=matrix(1:16,8),c(15:1))</span><span id="718a" class="ln kl hi kj b fi mm mg l mh mi">## test element by element if they are identical<br/>mapply(identical,firstList,secondList)</span></pre><p id="b72b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated"><code class="du kg kh ki kj b">mapply </code>也可以用自定义函数代替r中的内置函数，我们来构建一个简单的函数，将a <code class="du kg kh ki kj b">lists</code>中每个对应元素的行数相加。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mk"><img src="../Images/fc88d436d68a07a5b1c20f638fc85db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hVprxGKDXfAkRsefbEpqtw.png"/></div></div></figure><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="e53b" class="ln kl hi kj b fi mf mg l mh mi">simpleFunc &lt;- function(x,y) {<br/>              NROW(x) + NROW(y)<br/>              }<br/>mapply(simpleFunc,firstList,secondList)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mp"><img src="../Images/d05362b55020de37fc8e560d8df0cd48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Llb52QCDbCSV53B-UFnCmw.png"/></div></div></figure><p id="162a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated"><code class="du kg kh ki kj b">apply </code>家族中还有许多其他成员，它们要么不常被使用，要么已经被<code class="du kg kh ki kj b">plyr </code>家族中的函数所取代。它们包括</p><ul class=""><li id="ee9d" class="mq mr hi il b im in iq ir ju ms jv mt jw mu jg mv mw mx my bi translated">塔普利</li><li id="bc5f" class="mq mr hi il b im mz iq na ju nb jv nc jw nd jg mv mw mx my bi translated">rapply</li><li id="6cda" class="mq mr hi il b im mz iq na ju nb jv nc jw nd jg mv mw mx my bi translated">eapply</li><li id="8d32" class="mq mr hi il b im mz iq na ju nb jv nc jw nd jg mv mw mx my bi translated">vapply</li><li id="e2d8" class="mq mr hi il b im mz iq na ju nb jv nc jw nd jg mv mw mx my bi translated">经过</li></ul><h2 id="f07e" class="ln kl hi bd km lo lp lq kq lr ls lt ku ju lu lv ky jv lw lx lc jw ly lz lg ma bi translated">总计</h2><p id="bb97" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it ju lk iw ix jv ll ja jb jw lm je jf jg hb bi translated">习惯了<code class="du kg kh ki kj b">SQL </code>术语的人通常想把运行group by和aggregation作为他们的第一个R任务。做到这一点的方法是使用名副其实的<code class="du kg kh ki kj b">aggregate </code>函数。我们有多种方法调用，<code class="du kg kh ki kj b">aggregate</code>，我们将看到使用<code class="du kg kh ki kj b">formula </code>符号调用它的最方便的方法。</p><p id="dfab" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated"><code class="du kg kh ki kj b">formulas</code>由左右两边组成，中间用波浪号<code class="du kg kh ki kj b">(~)</code>隔开。公式方法的使用类似于我们在上一篇文章中使用ggplot2创建图形的方式。左侧代表我们要进行计算的变量，右侧代表我们要进行分组计算的一个或多个变量。为了演示骨料的用法，我们曾经求助于ggplot2中的钻石数据。</p><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="21a5" class="ln kl hi kj b fi mf mg l mh mi">require(ggplot2)<br/>data(diamonds)<br/>head(diamonds)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ne"><img src="../Images/41e9675bfbbb20137804d359f2f5ba1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVPcuWId1HjSU-Le3vY-9A.png"/></div></div></figure><p id="3328" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">作为第一个例子，我们将计算钻石数据中每种切割类型的<code class="du kg kh ki kj b">average </code>价格。第一个参数<code class="du kg kh ki kj b">aggregate</code>是<code class="du kg kh ki kj b">formula</code>指定价格应该通过切割来打破。第二个参数是要使用的数据，在本例中是钻石。第三个参数是应用于每个数据子集的函数。</p><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="7f0b" class="ln kl hi kj b fi mf mg l mh mi">aggregate(price~cut, diamonds,mean)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es nf"><img src="../Images/0b8943ef052915794a58d61eafc51c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jY2Zh3vNMOt906aYlG98rQ.png"/></div></div></figure><p id="6a52" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">请注意，我们只指定了列名，而不必标识数据，因为在第二个参数中已经给出了数据。在指定函数的第三个参数之后，该函数的其他命名参数可以按如下方式传递。</p><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="6588" class="ln kl hi kj b fi mf mg l mh mi">aggregate(price~cut, diamonds,mean,na.rm=TRUE)</span></pre><p id="dd27" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">要按多个变量对数据进行分组，请将附加变量添加到公式的右侧，并用加号(+)分隔。</p><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="e5d3" class="ln kl hi kj b fi mf mg l mh mi">aggregate(price~cut + color, diamonds,mean)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mn"><img src="../Images/2133557b21a13d39a158102466ea0460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwEubHsWN2tOTXVrmHyQIg.png"/></div></div></figure><p id="72ca" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">要合计两个变量，必须使用公式左侧的<code class="du kg kh ki kj b">cbind </code>将它们组合在一起。</p><pre class="jj jk jl jm fd mb kj mc md aw me bi"><span id="8a3b" class="ln kl hi kj b fi mf mg l mh mi">aggregate(cbind(price,carat)~ cut + color,diamonds,mean)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ng"><img src="../Images/587e58b88a1b5d25b6d677fa70d819bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kn5lQ0O_34OOBz2cYz51Sw.png"/></div></div></figure><p id="de36" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">重要的是要注意，从上面的例子只能提供一个函数，因此适用于变量。要应用多个功能，使用扩展和增强<code class="du kg kh ki kj b">data.frames</code>功能的<code class="du kg kh ki kj b">dplyr </code>或<code class="du kg kh ki kj b">data.table</code>包更容易。</p><p id="1da0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">汇总数据是分析过程中非常重要的一步。有时它是最终目标，有时它是应用更高级方法的准备。在本文中，我们已经看到了在r中执行组操作的常用方法。在下一篇文章中，我们将使用两个通用的包<code class="du kg kh ki kj b">dplyr </code>和<code class="du kg kh ki kj b">data.table</code>来比较高级的组操作技术。</p><p id="8166" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated"><a class="ae jh" rel="noopener" href="/@viveksrinivasan/advanced-data-wrangling-in-r-4-f98693b92851"> <em class="ik">高级-R—4中的数据争论</em> </a></p><blockquote class="if ig ih"><p id="fe71" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">一定要通过评论和分享文章来分享你的想法和支持。</p></blockquote></div></div>    
</body>
</html>