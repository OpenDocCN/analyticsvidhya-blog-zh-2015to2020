<html>
<head>
<title>Integration of TensorFlow JS model with Angular Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">张量流JS模型与角度应用的集成</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/integration-of-tensorflow-js-model-with-angular-application-9d42c6c540a6?source=collection_archive---------2-----------------------#2019-11-30">https://medium.com/analytics-vidhya/integration-of-tensorflow-js-model-with-angular-application-9d42c6c540a6?source=collection_archive---------2-----------------------#2019-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="60ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是关于各种ML模型与angular的集成，以创建一些有趣的机器学习web应用程序。因此，在TensorFlow Js的帮助下，我们可以完全在浏览器的客户端运行机器学习程序，以非常低的延迟进行更快的预测。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/06027c01bbd96096451d58d495d7c9b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSCTPSkBlfzImFNoidFQIg.jpeg"/></div></div></figure><p id="ce2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们开始吧。第一步是将现有的saved_model或freeze model转换为model.json。对于转换，我们将使用tensorflowjs_converter</p><p id="768e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一步</strong> : <strong class="ih hj">型号转换</strong>。</p><p id="5342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用以下命令首先安装TensorFlow Js来转换您的现有模型</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="a115" class="ju jv hi jq b fi jw jx l jy jz">$ pip install tensorflowjs</span></pre><p id="87bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TensorFlow Js最好的一点是它独立于模型的类型。它与保存的模型以及用于转换的冻结模型都兼容。</p><p id="66a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<strong class="ih hj">保存的模型</strong>:运行以下命令。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="09d5" class="ju jv hi jq b fi jw jx l jy jz">$ tensorflowjs_converter \<br/>    --input_format=tf_saved_model \<br/>    --output_node_names='MobilenetV1/Predictions/Reshape_1' \<br/>    --saved_model_tags=serve \<br/>    /mobilenet/saved_model \<br/>    /mobilenet/web_model</span></pre><p id="9f27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>其中<strong class="ih hj"> /mobilenet/saved_model </strong>是saved_model.pb文件及其权重所在的<strong class="ih hj">输入路径</strong>目录，而<strong class="ih hj"> /mobilenet/web_model </strong>是存储转换后的model.json及其碎片文件的<strong class="ih hj">输出路径</strong>。</p><p id="bb0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<strong class="ih hj">冻结模型</strong>:运行以下命令</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="a722" class="ju jv hi jq b fi jw jx l jy jz">$ tensorflowjs_converter \<br/>    --input_format=tf_frozen_model \<br/>    --output_node_names='MobilenetV1/Predictions/Reshape_1' \<br/>    /mobilenet/frozen_model.pb \<br/>    /mobilenet/web_model</span></pre><p id="2682" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:其中<strong class="ih hj">/mobilenet/frozen _ model . Pb</strong>为<strong class="ih hj">输入路径</strong>，而<strong class="ih hj"> /mobilenet/web_model </strong>为<strong class="ih hj">输出路径</strong>，model.json将在转换后存储在其中。</p><p id="958c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:如果在模型转换过程中遇到NonMaxSupressionV5错误，则尝试通过将tensorflow版本降级到1.14.0来重新训练模型，然后再次遵循相同的模型转换过程。</strong></p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="c20c" class="ju jv hi jq b fi jw jx l jy jz">For successful model conversion the following are the requirements:<br/>1. tensorflow  v_1.14.0<br/>2. tensorflowjs v_1.3.2</span></pre></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="2f64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们用角度来整合模型</strong></p><p id="5b4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们假设使用angular-cli创建了所需的组件。</p><p id="cc98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步</strong>:在客户端安装TensorFlow Js。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="61d5" class="ju jv hi jq b fi jw jx l jy jz">$ npm install @tensorflow/tfjs -- save</span></pre><p id="2bf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤3: </strong>将model.json文件及其生成的碎片文件放在assets文件夹中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kh"><img src="../Images/13403f1cf46dd93d6780a2558cc25876.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*entLDJH3uJOD9uUy46TTHg.png"/></div></figure><p id="22b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤4: </strong>为了预测，我们在组件的HTML中添加一个画布和一个视频元素。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="eeb1" class="ju jv hi jq b fi jw jx l jy jz">&lt;video #videoCamera hidden id="video"&gt;&lt;/video&gt;<br/>&lt;canvas #canvas id="canvas"&gt;&lt;/canvas&gt;</span></pre><p id="7921" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据要求确定它们的宽度和高度。</p><p id="309a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加<strong class="ih hj"> ViewChild </strong> decorator以获取元素的引用，并添加摄像机配置。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="9c16" class="ju jv hi jq b fi jw jx l jy jz"><a class="ae ki" href="http://twitter.com/ViewChild" rel="noopener ugc nofollow" target="_blank">@ViewChild</a>('videoCamera', {static: true}) videoCamera: ElementRef;<br/><a class="ae ki" href="http://twitter.com/ViewChild" rel="noopener ugc nofollow" target="_blank">@ViewChild</a>('canvas', {static: true}) canvas: ElementRef;</span></pre><p id="2175" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下代码块用于初始化<strong class="ih hj">摄像机</strong>及其配置。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kj"><img src="../Images/ef50d53c9f40708411d0cbeb1ec39fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrLZ4l31YJbXwKIhRQioIg.png"/></div></div></figure><p id="3799" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第五步:</strong>现在该加载模型预热了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kk"><img src="../Images/a447d75449e838ccd321108d45fa556c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVDm_Zj3sQsmA577vd0ojg.png"/></div></div></figure><p id="c3bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们使用了tf.loadGraphModel()而不是tf.loadFrozenModel()，因为TFJS在其最新更新中不赞成使用tf.loadFrozenModel()函数。最新的TFJS版本支持两个加载模型的函数</p><ol class=""><li id="58d4" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">tf.loadGraphModel()</li><li id="accb" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">tf.loadLayersModel()</li></ol><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="7004" class="ju jv hi jq b fi jw jx l jy jz"><strong class="jq hj"><em class="kz">The fun fact</em></strong><br/>TensorFlow Js has just renamed the function names.<br/>tf.loadFrozenModel() ---------&gt; tf.loadGraphModel()<br/>tf.loadModel() ----------&gt; tf.loadLayersModel()</span></pre><p id="dc31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第六步:</strong>将连续的视频流传递给模型进行预测。</p><p id="0395" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要对图像进行预处理，将画布图像转换为<strong class="ih hj"> float32 </strong>格式。然后将预处理后的图像传递到模型中进行预测。该模型将张量作为输出返回，我们需要将它转换为数组格式。下面是预测连续图像帧的代码块。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="2f66" class="ju jv hi jq b fi jw jx l jy jz">async predictFrames(video,model) {</span><span id="2a4c" class="ju jv hi jq b fi la jx l jy jz">     const image = tf.tidy(() =&gt; {<br/>           let img = this.canvas.nativElement;<br/>           img = tf.browser.fromPixels(img);<br/>           img = tf.cast(img, 'float32');<br/>           return img.expandDims(0);<br/>     }</span><span id="928e" class="ju jv hi jq b fi la jx l jy jz">     const result = await this.model.executeAsync(image) as any;<br/>     const prediciton = Array.from(result.dataSync());</span><span id="bf33" class="ju jv hi jq b fi la jx l jy jz">     if(predicion.length &gt; 0) {<br/>         this.renderPrediction(prediction);<br/>     } else {<br/>         const canvas = this.canvas.nativeElement;<br/>         const ctx = canvas.getContext('2d');<br/>         canvas.width = 350;<br/>         canvas.height = 450;<br/>         ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);<br/>         ctx.drawImage(video, 0, 0, 350, 450);<br/>     }</span><span id="02ad" class="ju jv hi jq b fi la jx l jy jz">     requestAnimationFrame(() =&gt; {<br/>         this.predictImages(video, model);<br/>     });<br/>}</span></pre><p id="5799" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">预测图像函数</strong>被递归调用<strong class="ih hj"/>进行<strong class="ih hj">连续预测。</strong></p><p id="d31c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第七步:为<strong class="ih hj">预测绘制<strong class="ih hj">边界框</strong>。</strong></p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="c818" class="ju jv hi jq b fi jw jx l jy jz">renderPredictions(predictions: any) {<br/>     const canvas = this.canvas.nativeElement;<br/>     const ctx = canvas.getContext("2d");<br/>     ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);             </span><span id="53d0" class="ju jv hi jq b fi la jx l jy jz">     ctx.textBaseline = "top";<br/>     ctx.drawImage(this.videoCamera.nativeElement, 0, 0, 350, 450); <br/>     <br/>     predictions.forEach(prediction =&gt; {<br/>        const x = prediction.bbox[0];<br/>        const y = prediction.bbox[1];<br/>        const width = prediction.bbox[2];<br/>        const height = prediction.bbox[3];</span><span id="8a87" class="ju jv hi jq b fi la jx l jy jz">        // Boundary box<br/>        ctx.strokeStyle = "#EB3434";<br/>        ctx.fillStyle = "#EB3434";<br/>        ctx.lineWidth = 3;<br/>        ctx.beginPath();<br/>        ctx.rect(x, y, width, height);<br/>        ctx.stroke();</span><span id="ca60" class="ju jv hi jq b fi la jx l jy jz">        // label<br/>        const textWidth = ctx.measureText(prediction.class).width;<br/>        const textHeight = parseInt(font, 10); // base 10<br/>        ctx.fillRect(x, y, textWidth + 4, textHeight + 4);</span><span id="81c2" class="ju jv hi jq b fi la jx l jy jz">     });</span><span id="75e2" class="ju jv hi jq b fi la jx l jy jz">     // rendering the classname at the end to draw over the rect<br/>     predictions.forEach(prediction =&gt; {<br/>        const x = prediction.bbox[0];<br/>        const y = prediction.bbox[1];<br/>        if (prediction.class) {<br/>           ctx.fillStyle = "#FFFFFF";<br/>        } <br/>        ctx.fillText(prediction.class, x, y);<br/>     });<br/>}</span></pre><p id="5135" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们成功地将model.json与angular集成在一起。在浏览器中加载模型的主要好处是减少延迟和传输时间。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="ac63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:不同的模型以张量的形式返回不同的输出。</strong></p><p id="3fa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是解释</p><p id="6d72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">控制台的下图是模型输出的示例</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lb"><img src="../Images/439a1306bd71d11a7a57b561a5bd6e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVBpSiBw6892lMdVmbpkSg.png"/></div></div></figure><p id="4f84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个张量表示了很多东西，但是现在让我们集中在形状上。我们可以在两个数组中找到不同之处。<strong class="ih hj">第一张量</strong>包含形状为<strong class="ih hj">【1，1917，2】</strong>的<strong class="ih hj">盒子分类分数</strong>，第二张量<strong class="ih hj">包含形状为<strong class="ih hj">【1，1917，1，4】的<strong class="ih hj">盒子位置</strong>。</strong></strong></p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="8cdb" class="ju jv hi jq b fi jw jx l jy jz"><em class="kz">where 1917 = the number of box detectors;<br/>         2 = the number of classes;<br/>         4 = the number of co-ordinates for the box.</em></span></pre><p id="c586" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是完整代码块的链接:<a class="ae ki" href="https://github.com/kushhingol/tfjs-integration" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://github.com/kushhingol/tfjs-integration</em></a></p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="b718" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结</strong></p><ol class=""><li id="cde0" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">在这篇文章中，我们最初讨论了现有的转换。使用tensorflowjs将pb模型转换为model.json。</li><li id="bff4" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">第二部分包括使用tensorflowjs将model.json与angular集成。</li><li id="9f32" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">讨论了张量形式的模型输出及其各种表示和形状。</li><li id="89a9" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><strong class="ih hj">主要原因</strong>:将模型加载到浏览器本身的主要原因和好处是消除延时和数据传输延迟。现在有了TensorFlow Js，在tfjs converter的帮助下，完全可以将您现有的模型转换为javascript版本。当涉及到实时预测时，许多应用程序更喜欢这种技术来实现更快预测和准确的结果。</li></ol></div></div>    
</body>
</html>