<html>
<head>
<title>Python lists shallow and deep copy.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python列出了浅拷贝和深拷贝。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-lists-shallow-and-deep-copy-fdcddb0c4555?source=collection_archive---------0-----------------------#2019-04-21">https://medium.com/analytics-vidhya/python-lists-shallow-and-deep-copy-fdcddb0c4555?source=collection_archive---------0-----------------------#2019-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b2cd3967c4078e2c6c8cce64903fd683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9yDzOi0dpV3GgbbUadRKA.jpeg"/></div></div></figure><p id="9868" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有东西，如int、float、str、lists等。是Python中的对象。当我们声明一个变量的时候-</p><p id="4a87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">a=10</p><p id="3ea8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它创建一个对值为10的<strong class="is hj"> int </strong>对象的引用。在图中，它可以表示为</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/e3216bb5e64a84da80a1230df2edf565.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*I6XN4TTajS_Ho3T54rFjMw.png"/></div></figure><p id="bec3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以如果我们写下这个片段-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="55d7" class="jy jz hi ju b fi ka kb l kc kd">a=10<br/>print(a)<br/>print(id(a))</span></pre><p id="e2e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它给了我们输出-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="5b6f" class="jy jz hi ju b fi ka kb l kc kd">10<br/>4446123712</span></pre><p id="a76f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的<strong class="is hj"> id() </strong>给出了一个对象的<strong class="is hj"> </strong>唯一标识符值，该值在其生命周期内保持不变。这意味着当两个对象具有相同的id时，它们是完全相同的。但是，可以有对该对象的多个引用。因此，任何被赋值为<strong class="is hj"> 10 </strong>的整数变量都指向由变量<strong class="is hj"> a </strong>指向的同一个对象。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="2a9b" class="jy jz hi ju b fi ka kb l kc kd">a=10<br/>b=10<br/>print(id(a))<br/>print(id(b))<br/>print(id(10))</span></pre><p id="3ce0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码给了我们输出-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="286c" class="jy jz hi ju b fi ka kb l kc kd">4446123712<br/>4446123712<br/>4446123712</span></pre><p id="9543" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着<strong class="is hj"> a </strong>和<strong class="is hj"> b </strong>指向同一个对象<strong class="is hj"> 10。</strong>注意，整数对象10本身具有相同的id值。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/e415f745968cd79b918c2dc700507376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*V2JDgwgjvB0G3XrwFafV9g.png"/></div></figure><p id="2201" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于<strong class="is hj"> a </strong>和<strong class="is hj"> b </strong>指向同一个对象，那么当我们改变<strong class="is hj"> a </strong>的值时<strong class="is hj"> b </strong>的值是否也会改变？</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="3d93" class="jy jz hi ju b fi ka kb l kc kd">a=a+5</span></pre><p id="3857" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在如果我们打印出<strong class="is hj"> a </strong>和<strong class="is hj"> b </strong>的值以及它们指向的对象的id会怎么样？</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="e1f1" class="jy jz hi ju b fi ka kb l kc kd">a=a+5<br/>print(a)<br/>print(b)<br/>print(id(a))<br/>print(id(b))</span></pre><p id="2d3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出是-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="13c3" class="jy jz hi ju b fi ka kb l kc kd">15<br/>10<br/>4446123872<br/>4446123712</span></pre><p id="0e04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里发生的事情是创建了一个值为<strong class="is hj"> 15 </strong>的新对象，现在<strong class="is hj"> a </strong>指向该对象。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kf"><img src="../Images/05e350c67dfe46efb30f5414a401e74a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*WwMqtxWsOyypGnuvrYQ0Kw.png"/></div></figure></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="a874" class="kn jz hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">复制列表。</h1><p id="3afa" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">让我们看看当我们声明一个只有整数对象的列表时会发生什么。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9eae" class="jy jz hi ju b fi ka kb l kc kd">a=[1]*5<br/>print(a)</span></pre><p id="6e63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它给了我们输出-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="15af" class="jy jz hi ju b fi ka kb l kc kd">[1, 1, 1, 1, 1]</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/d8006b6c01c3db52cd55a88f556f22d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*8pb3qmwqATxbUAMqeMmEiw.png"/></div></figure><p id="b6dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">变量a指向底层的列表对象。现在我们将变量<strong class="is hj"> a </strong>赋值给<strong class="is hj"> b. </strong></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="76f7" class="jy jz hi ju b fi ka kb l kc kd">b=a<br/>print(b)</span></pre><p id="bcaa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这给了我们输出</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="7ef5" class="jy jz hi ju b fi ka kb l kc kd">[1, 1, 1, 1, 1]</span></pre><p id="417c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不出所料。a指向的列表的每个元素并不是一个一个复制到b指向的列表中。相反，只有引用被复制到b。变量a和b现在指向同一个列表对象。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/7df2f334156ebf34964e9d6ca68297f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*1ceSFUbCtCnXvApSsA5jPw.png"/></div></figure><p id="e8d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以通过引用a或b来修改列表。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="89f1" class="jy jz hi ju b fi ka kb l kc kd">b[0]=2<br/>print(b)<br/>print(a)</span></pre><p id="980f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给了我们输出</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="8517" class="jy jz hi ju b fi ka kb l kc kd">[2, 1, 1, 1, 1]<br/>[2, 1, 1, 1, 1]</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/4ad1c3ec9b37011ae8543dcb88bb22f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*rNKD_bYCnld77u5cyghIDQ.png"/></div></figure><p id="4ffb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过打印a和b的id，我们可以验证它们是否指向同一个列表对象。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="7cb5" class="jy jz hi ju b fi ka kb l kc kd">print(id(a))<br/>print(id(b))</span></pre><p id="7ea7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给了我们输出-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9661" class="jy jz hi ju b fi ka kb l kc kd">4500229128<br/>4500229128</span></pre></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="b015" class="kn jz hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">浅抄深抄。</h1><p id="270a" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">浅层副本只是最外层容器的副本。看看下面的代码。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="e9bd" class="jy jz hi ju b fi ka kb l kc kd">a=[[1,2,3],4,5]<br/>b=a<br/>print(a)<br/>print(b)</span></pre><p id="39da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这给了我们输出-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="73d8" class="jy jz hi ju b fi ka kb l kc kd">[[1, 2, 3], 4, 5]<br/>[[1, 2, 3], 4, 5]</span></pre><p id="82e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是意料之中的，因为a和b指向同一个底层列表对象。我们可以使用a或b来修改列表。</p><p id="e33c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们只想创建最外层容器的副本，我们可以这样做-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="33ee" class="jy jz hi ju b fi ka kb l kc kd">a=[[1,2,3],4,5]<br/>b = list(a)<br/>print(a)<br/>print(b)</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/b353cc03ed1a43e531a7ee5deca422f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7WZSd-dAzfBEy57s_ohEAQ.png"/></div></div></figure><p id="1693" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">list()方法将a指向的列表元素复制到b指向的列表中，通过打印它们的id，我们可以看到它们指向不同的列表。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="7d52" class="jy jz hi ju b fi ka kb l kc kd">a=[[1,2,3],4,5]<br/>b = list(a)<br/>print(a)<br/>print(b)<br/>print(id(a))<br/>print(id(b))</span></pre><p id="c0ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码给出了输出-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9d18" class="jy jz hi ju b fi ka kb l kc kd">[[1, 2, 3], 4, 5]<br/>[[1, 2, 3], 4, 5]<br/>4500623176<br/>4501514312</span></pre><p id="d969" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到list()方法只通过打印内部元素的id执行了一次浅层复制。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="4f60" class="jy jz hi ju b fi ka kb l kc kd">for i in a:<br/>    print(id(i))<br/>print()<br/>for j in b:<br/>    print(id(j))</span></pre><p id="aca2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="1020" class="jy jz hi ju b fi ka kb l kc kd">4500014408<br/>4446123520<br/>4446123552</span><span id="4b51" class="jy jz hi ju b fi lt kb l kc kd">4500014408<br/>4446123520<br/>4446123552</span></pre><p id="0d67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们现在修改b-指向的列表</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9279" class="jy jz hi ju b fi ka kb l kc kd">b[2] = 6<br/>print(a)<br/>print(b)</span></pre><p id="3cec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给了我们输出-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="5557" class="jy jz hi ju b fi ka kb l kc kd">[[1, 2, 3], 4, 5]<br/>[[1, 2, 3], 4, 6]</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/a2be3cfffe08bf76ec54be9079550cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sssxiexqL7balvlj3-vIBA.png"/></div></div></figure><p id="491c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为b[2]指向的对象是不可变的，所以它创建了一个值为6和的新对象，并将b[2]赋给它。a[2]没有改变，它仍然指向同一个int对象5。</p><p id="a6b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是现在如果我们写代码-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="817e" class="jy jz hi ju b fi ka kb l kc kd">a[0].append(7)<br/>print(a)<br/>print(b)</span></pre><p id="b496" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们得到-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="cf42" class="jy jz hi ju b fi ka kb l kc kd">[[1, 2, 3, 7], 4, 5]<br/>[[1, 2, 3, 7], 4, 6]</span></pre><p id="ae76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们看到，我们在a[0]指向的列表中所做的更改也反映在b[0]中。这是因为列表是一个可变对象。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/0e3a68ef518f4dded2dddf385101b90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POvH5RjreZnT8YSmlFoXRA.png"/></div></div></figure><p id="043d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要获得完全相同的副本，我们必须进行深层复制。深层副本是每个内部对象的递归副本。这两个副本彼此独立，任何级别上一个副本中的更改都不会反映在另一个副本中。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="4fdc" class="jy jz hi ju b fi ka kb l kc kd">import copy<br/>a=[[1,2,3],4,5]<br/>b=copy.deepcopy(a)<br/>b[0].append(6)<br/>print(a)<br/>print(b)</span></pre><p id="5c12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给了我们输出-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="08cd" class="jy jz hi ju b fi ka kb l kc kd">[[1, 2, 3], 4, 5]<br/>[[1, 2, 3, 6], 4, 5]</span></pre><p id="32f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，当我们修改b时，对a没有影响。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="d30b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是这篇文章的内容。如果你喜欢，请分享。</p></div></div>    
</body>
</html>