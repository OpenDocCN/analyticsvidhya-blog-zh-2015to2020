<html>
<head>
<title>Advanced Locking in Java: Conditional Locking, wait, notify and notifyAll</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的高级锁定:条件锁定、等待、通知和notifyAll</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/advanced-locking-in-java-conditional-locking-wait-notify-and-notifyall-15de8b61edd9?source=collection_archive---------2-----------------------#2020-10-23">https://medium.com/analytics-vidhya/advanced-locking-in-java-conditional-locking-wait-notify-and-notifyall-15de8b61edd9?source=collection_archive---------2-----------------------#2020-10-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(使用条件锁定有效控制线程同步)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/33c0a2f2444d48832aeb3c2240f603ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QZ4nmqEqdgauXrBS"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">等待信号</figcaption></figure><p id="cd04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一个场景，其中两个线程共享一些资源并执行两个不同的任务。我们希望我们的线程只在另一个线程完成了某项任务b之后才执行某项任务A。<br/><strong class="ih hj"><em class="jt">简而言之，线程在执行任务A之前必须检查某些条件是否得到满足。</em> </strong></p><h1 id="4c91" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">设计高效的方法:</h1><p id="2538" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">让我们称我们的线程为信号线程，其他线程为信号线程</p><h2 id="1809" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated"><strong class="ak">发出信号的线程:</strong></h2><ol class=""><li id="f680" class="ll lm hi ih b ii ks im kt iq ln iu lo iy lp jc lq lr ls lt bi translated">需要获取共享资源的锁</li><li id="f1f0" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">等待某个条件满足<br/> <strong class="ih hj">如果不满足:</strong> <br/> <em class="jt"> a .释放共享资源上的锁<br/> b .线程必须无限休眠(放弃所有CPU周期)直到某个其他线程发出信号让它起床。</em> <br/> <strong class="ih hj">如果满足:</strong> <br/> <em class="jt"> a .执行任务<br/> b .释放共享资源的锁</em></li><li id="b1b2" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">如果有其他线程发出信号让它起床。<br/>T22 a .获取资源的锁<br/> b .执行任务<br/> c .释放共享资源的锁</li></ol><h2 id="41ca" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated"><span class="l lz ma mb bm mc md me mf mg di">S</span>T28】信号线程:</h2><p id="303f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">获取资源锁<br/>执行前置任务<br/>释放共享资源锁<br/>信号通知其他线程起床</p><blockquote class="mh"><p id="9d70" class="mi mj hi bd mk ml mm mn mo mp mq jc dx translated">似乎太多事要做了？<br/> Fret Not JAVA为我们提供了一种优雅的使用条件的方式。</p></blockquote><figure class="ms mt mu mv mw ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mr"><img src="../Images/d9b2c380db6c573300101d11c1b8f166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p8jqI3y9jm-XAZkm"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">工具</figcaption></figure><p id="93b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java给了我们一些漂亮的方法来实现上面讨论的方法。</p><h1 id="dea7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">方法1:</h1><ol class=""><li id="b210" class="ll lm hi ih b ii ks im kt iq ln iu lo iy lp jc lq lr ls lt bi translated"><strong class="ih hj"><em class="jt">【await():</em></strong><em class="jt">使当前线程等待，直到它收到信号或被中断，并且与该条件相关联的锁被自动释放。<br/>同样，当线程返回时，它保证持有这个锁。</em></li><li id="e60c" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated"><strong class="ih hj"><em class="jt">signal():</em></strong><em class="jt">唤醒一个等待线程。(随机选择。)</em></li><li id="8de4" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated"><strong class="ih hj"><em class="jt">【signal all():</em></strong><em class="jt">唤醒所有等待的线程。<br/>调用signal和signalAll方法的线程必须锁定资源</em></li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mx"><img src="../Images/ef56b951164a54760348bfe4596e267b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*E21SSzJWTOytqeUAxfhRZg.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">有条件的方法</figcaption></figure><p id="3d4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">预排<br/> </strong> <em class="jt">线程A连续检查是否满足条件，如果不满足，它将释放资源上的锁，并进入“睡眠”(释放CPU)[</em><strong class="ih hj"><em class="jt">conditions . await()]</em></strong><em class="jt">。<br/>当线程B命中</em><strong class="ih hj"><em class="jt">condition . signal()</em></strong><em class="jt">时，它唤醒线程A(随机)。<br/>现在，如果条件满足，线程A可以完成它的工作，否则，对线程A重复该过程。</em></p><h1 id="6a84" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">方法2:</h1><p id="3a3b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们可以用对象类的wait()、notify()和notifyAll()方法扩展这个思想。由于所有的类都是从对象类派生出来的，我们可以使用上述方法来实现类似的行为。</p><h2 id="8e60" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">替换语义学</h2><blockquote class="my mz na"><p id="aa26" class="if ig jt ih b ii ij ik il im in io ip nb ir is it nc iv iw ix nd iz ja jb jc hb bi translated"><em class="hi">锁定- &gt;同步或锁定(此)<br/>解锁→ }或解锁(此)<br/>等待- &gt;等待<br/>信号- &gt;通知<br/>通知- &gt;通知全部</em></p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ne"><img src="../Images/37524047a09f07de92c39afb2f902e58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSt75LU1I1ZciVMHQtdPPg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">带对象的方法</figcaption></figure><p id="18a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">预排<br/> </strong> <em class="jt">线程A连续检查是否满足条件，如果不满足，则释放资源上的锁并进入“睡眠(释放CPU)</em><strong class="ih hj"><em class="jt">【wait()】</em></strong><em class="jt">”。<br/>当线程B命中</em><strong class="ih hj"><em class="jt">notify()</em></strong><em class="jt">时，它唤醒线程A(随机)。<br/>现在，如果条件满足，线程A可以完成它的工作，否则，对线程A重复该过程。</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nf"><img src="../Images/cf2878413cb287a38a5e242148df9463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZAyFNsbxboRxOjG6"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">你做得很好</figcaption></figure><h2 id="c8c0" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">拿走！！</h2><p id="cece" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当线程相互依赖时，条件锁定允许为线程同步创建复杂的锁定契约。</p><p id="9478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用条件锁，我们可以根据锁的获取和条件来很好地满足程序的流程。</p></div><div class="ab cl ng nh gp ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hb hc hd he hf"><p id="71dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里阅读更多关于并发编程的内容</p><p id="a17e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Java中的锁:</strong><a class="ae nn" rel="noopener" href="/analytics-vidhya/understanding-java-thread-synchronization-with-methods-vs-objects-vs-locks-5428e3342fee">https://medium . com/analytics-vid hya/understanding-Java-thread-synchron ization-with-methods-vs-objects-vs-Locks-5428 e 3342 fee</a></p><p id="c519" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重入锁:</strong><a class="ae nn" rel="noopener" href="/analytics-vidhya/unlock-the-power-of-reentrant-lock-in-java-d55ae9135443">https://medium . com/analytics-vid hya/unlock-the-power-of-Reentrant-lock-in-Java-d55ae 9135443</a></p></div></div>    
</body>
</html>