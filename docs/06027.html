<html>
<head>
<title>Aws Sagemaker: Train, Test &amp; Deploy Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Aws Sagemaker:培训、测试和部署模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/aws-sagemaker-train-test-deploy-models-97f1e45e481f?source=collection_archive---------7-----------------------#2020-05-09">https://medium.com/analytics-vidhya/aws-sagemaker-train-test-deploy-models-97f1e45e481f?source=collection_archive---------7-----------------------#2020-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0404" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">学习在AWS Sagemaker上训练、测试和部署模型</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8fe2ea7fb30096bc1337c7780baac14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yOgbvdvVQjS5-w9p"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">马文·迈耶在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="b6a5" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">什么是AWS SageMaker？</h1><p id="d72e" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">AWS Sagemaker是一个机器学习端到端服务，解决了训练、调整和部署机器学习模型的问题。</p><p id="fcad" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">它为我们提供了一个运行在Amazon托管的虚拟机上的Jupyter笔记本实例。我们可以在笔记本上执行所有的数据分析和预处理，以及模型开发和验证，就像在本地机器上一样。此外，它使我们能够通过创建一个可以通过任何web应用程序访问的API端点来部署我们的模型，从而获得结果。</p><p id="aaa1" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在不要再浪费时间了，<em class="lh">让我们开始吧。</em></p><p id="6c7e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><a class="ae jn" href="https://github.com/gitSuyash/Aws-Sagemaker/tree/master/train-test-deploy" rel="noopener ugc nofollow" target="_blank"> <strong class="ki hj"> <em class="lh">直接给我弄代码</em> </strong> </a> <strong class="ki hj"> <em class="lh">。</em>T15】</strong></p><h2 id="edab" class="li jp hi bd jq lj lk ll ju lm ln lo jy kp lp lq ka kt lr ls kc kx lt lu ke lv bi translated">步骤0:创建笔记本实例</h2><p id="52e6" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们的Aws Sagemaker主页如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/4065d9405a21a25213a42e13ad36e415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_8XBHVCpUGheNer4i9tepA.png"/></div></div></figure><ol class=""><li id="ac0a" class="lx ly hi ki b kj lc km ld kp lz kt ma kx mb lb mc md me mf bi translated">从侧面菜单栏中选择<em class="lh">笔记本实例</em></li></ol><p id="9f28" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">你会到达这里</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/99cdd49261b855265d3aea29be772622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-RHzaenHIrOtNVuS4kRCiw.png"/></div></div></figure><p id="3e35" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">2.现在点击<em class="lh">创建笔记本实例</em></p><p id="b24c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">3.为您的笔记本命名，让其他字段保持原样</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/a678f3b8f285fb4ddf251503f74ebcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46SmS0ylW9Dt9AlP5jDnQA.png"/></div></div></figure><p id="fcde" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">4.在权限和加密中创建一个IAM角色，该角色告诉Aws我们可以访问的各种资源</p><p id="4e5d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们从下拉列表中选择<em class="lh">创建一个新角色</em></p><p id="8de9" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">配置时，我们选择<em class="lh"> None </em>，因为我们没有任何S3存储桶需要指定</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/28c2e7c3f9e36f650af99048eeae40da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obeNxwIMgOXIB6_UrmMhag.png"/></div></div></figure><p id="9e87" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">5.点击<em class="lh">创建角色</em></p><p id="119f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">将其他选项设置为默认值，并点击<em class="lh">创建笔记本实例</em></p><p id="9784" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">您将被引导到这里，几秒钟后，您的笔记本实例将显示状态<em class="lh">“正在使用中”</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/94356410e19d619a1437663d195ac09f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6dhao7qhhYf2jyfIVUFFTg.png"/></div></div></figure><p id="c37a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">6.点击<em class="lh">打开Jupyter </em>并开始开发。</p><p id="1e75" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在让我们继续我们的主要目标，即训练和部署一个模型，从而创建一个端点作为模型和应用程序之间的接口。</p><p id="93de" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> <em class="lh">要遵循的步骤:</em> </strong></p><ol class=""><li id="ea0a" class="lx ly hi ki b kj lc km ld kp lz kt ma kx mb lb mc md me mf bi translated"><strong class="ki hj"> <em class="lh">导入必要的库&amp;加载数据到笔记本</em> </strong></li><li id="33cf" class="lx ly hi ki b kj mk km ml kp mm kt mn kx mo lb mc md me mf bi translated"><strong class="ki hj"> <em class="lh">准备&amp;预处理数据</em> </strong></li><li id="3e3d" class="lx ly hi ki b kj mk km ml kp mm kt mn kx mo lb mc md me mf bi translated"><strong class="ki hj"> <em class="lh">将处理后的数据上传到S3 (S3是亚马逊的仓储设施)</em> </strong></li><li id="f29c" class="lx ly hi ki b kj mk km ml kp mm kt mn kx mo lb mc md me mf bi translated"><strong class="ki hj"> <em class="lh">训练你的模型</em> </strong></li><li id="28e3" class="lx ly hi ki b kj mk km ml kp mm kt mn kx mo lb mc md me mf bi translated"><strong class="ki hj"> <em class="lh">测试型号</em> </strong></li><li id="0f4f" class="lx ly hi ki b kj mk km ml kp mm kt mn kx mo lb mc md me mf bi translated"><strong class="ki hj"> <em class="lh">部署型号</em> </strong></li></ol><h2 id="40b6" class="li jp hi bd jq lj lk ll ju lm ln lo jy kp lp lq ka kt lr ls kc kx lt lu ke lv bi translated">步骤1:导入必要的库并在笔记本中加载数据</h2><p id="90a2" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们从导入我们需要的库以及Sagemaker特定的库开始。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="a3e3" class="li jp hi mq b fi mu mv l mw mx">import os <br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from sklearn.datasets import load_boston<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import mean_squared_error as mse</span><span id="36bd" class="li jp hi mq b fi my mv l mw mx">#Sagemaker specific libraries<br/>import sagemaker <br/>from sagemaker import get_execution_role<br/>from sagemaker.amazon.amazon_estimator import get_image_uri<br/>from sagemaker.predictor import csv_serializer</span></pre><p id="5765" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在继续之前，我们将把我们正在操作的当前sagemaker会话存储到一个变量中。这个变量将存储一些我们以后需要访问的重要信息。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="93ad" class="li jp hi mq b fi mu mv l mw mx">session = sagemaker.Session()</span></pre><p id="ff42" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">传统上，我们可以通过调用<em class="lh"> pd.read_csv </em>或<em class="lh"> pd.read_json </em>或任何其他方法来加载数据，这取决于数据的来源或类型。</p><p id="9b2e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">然而，为了简单起见，我们将使用scikit-learn中提供的波士顿数据集。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="1720" class="li jp hi mq b fi mu mv l mw mx">boston = load_boston()</span></pre><h2 id="2ccc" class="li jp hi bd jq lj lk ll ju lm ln lo jy kp lp lq ka kt lr ls kc kx lt lu ke lv bi translated">步骤2:准备和预处理数据</h2><p id="a61d" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">将我们的数据保存在数据帧中</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="39db" class="li jp hi mq b fi mu mv l mw mx">X_bos = pd.DataFrame(boston.data, columns = boston.feature_names)<br/>Y_bos = pd.DataFrame(boston.target)</span></pre><p id="eb35" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">由于我们有很多东西要涵盖，因此我们不会在这里做任何预处理，除了将我们的数据分为测试和训练数据集。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="1ba3" class="li jp hi mq b fi mu mv l mw mx">X_train, X_test, Y_train, Y_test = train_test_split(X_bos, Y_bos, test_size=0.30)</span><span id="345f" class="li jp hi mq b fi my mv l mw mx">X_train, X_val, Y_train, Y_val = train_test_split(X_train, Y_train, test_size=0.30)</span></pre><p id="33bc" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在上面的步骤中，我们已经进一步分割了我们的训练数据以获得验证数据，从而保持对模型的过度拟合的检查。</p><h2 id="fd3b" class="li jp hi bd jq lj lk ll ju lm ln lo jy kp lp lq ka kt lr ls kc kx lt lu ke lv bi translated">步骤3:将数据上传到S3</h2><p id="b64f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">下一步包括在本地保存我们的数据文件，然后将它们上传到S3。</p><p id="05f9" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">当我们使用SageMaker构造一个训练作业时，会执行一个容器来执行训练操作。该容器可以访问存储在S3的数据。这意味着我们需要将我们想要用于培训的数据上传到S3。此外，当我们在测试模型时执行批量转换作业时，SageMaker希望输入数据存储在S3上。我们将使用SageMaker API来完成这项工作。</p><p id="e9d2" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在本地保存数据</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="0821" class="li jp hi mq b fi mu mv l mw mx">data_dir = './boston_data'<br/>if not os.path.exists(data_dir):<br/>    os.makedirs(data_dir)</span><span id="f293" class="li jp hi mq b fi my mv l mw mx">X_test.to_csv(os.path.join(data_dir, 'test.csv'), header=False, index=False)</span><span id="7115" class="li jp hi mq b fi my mv l mw mx">pd.concat([Y_val, X_val], axis=1).to_csv(os.path.join(data_dir, 'validation.csv'), header=False, index=False)</span><span id="3159" class="li jp hi mq b fi my mv l mw mx">pd.concat([Y_train, X_train], axis=1).to_csv(os.path.join(data_dir, 'train.csv'), header=False, index=False)</span></pre><p id="b66f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">请注意，在创建我们的训练和验证数据时，标签被连接为第一列。我们这样做是因为，对于训练和验证数据，假设每行中的第一个条目是目标变量。</p><p id="f2ae" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在，我们将使用sagemaker的upload_data方法将数据上传到S3。数据将被上传到与当前Sagemaker会话相关联的默认S3存储桶中。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="d5a1" class="li jp hi mq b fi mu mv l mw mx">prefix = 'boston-ML'</span><span id="0dcc" class="li jp hi mq b fi my mv l mw mx">test_location = session.upload_data(os.path.join(data_dir, 'test.csv'), key_prefix=prefix)</span><span id="3557" class="li jp hi mq b fi my mv l mw mx">val_location = session.upload_data(os.path.join(data_dir, 'validation.csv'), key_prefix=prefix)</span><span id="9628" class="li jp hi mq b fi my mv l mw mx">train_location = session.upload_data(os.path.join(data_dir, 'train.csv'), key_prefix=prefix)</span></pre><p id="b339" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们提供了一个自定义前缀，本质上是一个S3文件夹，以确保您不会意外干扰从其他笔记本或项目上传的数据。</p><h2 id="9d10" class="li jp hi bd jq lj lk ll ju lm ln lo jy kp lp lq ka kt lr ls kc kx lt lu ke lv bi translated">第四步:训练你的模型</h2><p id="a3a1" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">为了训练我们的模型，我们必须创建一个估计器对象，并且我们需要提供包含我们的训练代码的容器的位置。由于我们将使用sagemaker提供的内置XGBoost开源算法，因此，这个容器是由Amazon提供的。容器的全名很长，取决于我们所在的地区。幸运的是，Sagemaker提供了一个有用的名为get_image_uri的实用方法，它为我们构造了图像名称。</p><p id="7173" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">为了使用<em class="lh"> get_image_uri </em>方法，我们需要向它提供我们的当前区域，这可以从我们之前创建的<em class="lh"> session </em>对象中获得，以及我们希望使用的算法的名称。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="adc6" class="li jp hi mq b fi mu mv l mw mx">container = get_image_uri(session.boto_region_name, 'xgboost')</span></pre><p id="ab1a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">除此之外，我们还必须为我们的estimator对象提供IAM角色，这是我们在发布notebook实例时创建的。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="60a0" class="li jp hi mq b fi mu mv l mw mx">role = get_execution_role()</span></pre><p id="459a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">既然我们知道了使用哪个容器，我们就可以构造估计器对象了。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="c90a" class="li jp hi mq b fi mu mv l mw mx">xgb = sagemaker.estimator.Estimator(container, role,      train_instance_count=1, train_instance_type='ml.m4.xlarge', output_path='s3://{}/{}/output'.format(session.default_bucket(), prefix), sagemaker_session=session)</span></pre><p id="3d2f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">估计器对象中的各种参数定义如下:</p><p id="394e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><em class="lh">容器</em>:包含了保存我们训练代码的训练容器的镜像名称。</p><p id="e3dc" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><em class="lh">角色</em>:要使用的IAM角色(在本例中是我们当前的角色)</p><p id="5118" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><em class="lh"> train_instance_count </em>:用于训练的实例数量或我们希望使用的虚拟机数量</p><p id="f366" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><em class="lh"> train_type_instance </em>:用于训练的实例类型</p><p id="b999" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><em class="lh"> output_path </em>:在哪里保存输出，我们的模型工件或者模型的权重</p><p id="7ab0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><em class="lh"> sagemaker_session </em>:当前sagemaker会话</p><p id="141d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">接下来，我们将通过在我们的估计器对象上调用<em class="lh"> set_hyperparameters </em>方法来为我们的XGboost模型设置一些超参数。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="b510" class="li jp hi mq b fi mu mv l mw mx">xgb.set_hyperparameters(max_depth=5,<br/>                        eta=0.2,<br/>                        gamma=4,<br/>                        min_child_weight=6,<br/>                        subsample=0.8,<br/>                        objective='reg:linear',<br/>                        early_stopping_rounds=10,<br/>                        num_round=200)</span></pre><p id="2615" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在，我们将在我们的估计器对象上调用<em class="lh"> fit </em>方法，并传递训练和验证数据在S3的位置。我们还需要确保Sagemaker知道我们的数据是CSV格式的。</p><p id="00b4" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在，我们将在我们的估计器对象上调用<em class="lh"> fit </em>方法，并传递训练和验证数据在S3的位置。我们还需要确保Sagemaker知道我们的数据是CSV格式的。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="a940" class="li jp hi mq b fi mu mv l mw mx">s3_input_train = sagemaker.s3_input(s3_data=train_location, content_type='csv')</span><span id="2ff8" class="li jp hi mq b fi my mv l mw mx">s3_input_validation = sagemaker.s3_input(s3_data=val_location, content_type='csv')</span><span id="47f4" class="li jp hi mq b fi my mv l mw mx">xgb.fit({'train': s3_input_train, 'validation':s3_input_validation})</span></pre><h2 id="e0ec" class="li jp hi bd jq lj lk ll ju lm ln lo jy kp lp lq ka kt lr ls kc kx lt lu ke lv bi translated">步骤5:测试模型</h2><p id="6836" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">为了测试我们的模型，我们将使用Sagemaker的<em class="lh"> BatchTransform </em>技术。它告诉sagemaker如何分割数据、推断输出和组合结果等..</p><p id="e5ff" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们需要确保向SageMaker提供我们提供给模型的数据类型，在我们的例子中是text/CSV，以便它知道如何序列化我们的数据。此外，我们需要确保让SageMaker知道如果整个数据集太大而不能一次发送到我们的模型，如何将我们的数据分割成块。</p><p id="bc21" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">创建我们的transformer对象，并将其应用到我们在S3的测试数据中。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="abbb" class="li jp hi mq b fi mu mv l mw mx">xgb_transformer = xgb.transformer(instance_count = 1, instance_type = 'ml.m4.xlarge')</span><span id="7f45" class="li jp hi mq b fi my mv l mw mx">xgb_transformer.transform(test_location, content_type='text/csv', split_type='Line')</span></pre><p id="2f46" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">当我们要求SageMaker这样做时，它将在后台执行批量转换作业。因为我们需要等待这项工作的结果，然后才能继续。</p><p id="f894" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们可以使用wait()方法从我们的批处理转换作业中获得一些输出，这让我们知道是否有什么地方出错了。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="28d5" class="li jp hi mq b fi mu mv l mw mx">xgb_transformer.wait()</span></pre><p id="d19a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">批处理转换作业完成后，生成的输出将存储在S3上。如果我们希望分析我们的笔记本内部的输出，我们可以使用一点笔记本的魔力，从它的S3位置复制输出文件，并将其保存在本地。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="9892" class="li jp hi mq b fi mu mv l mw mx">!aws s3 cp --recursive $xgb_transformer.output_path $data_dir</span></pre><p id="df9b" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">阅读和评估我们模型的输出。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="75a9" class="li jp hi mq b fi mu mv l mw mx">Y_pred = pd.read_csv(os.path.join(data_dir, 'test.csv.out'), header=None)</span><span id="7a1c" class="li jp hi mq b fi my mv l mw mx">error = np.sqrt(mse(Y_pred,Y_test))</span></pre><h2 id="d5a3" class="li jp hi bd jq lj lk ll ju lm ln lo jy kp lp lq ka kt lr ls kc kx lt lu ke lv bi translated">步骤6:部署我们的模型</h2><p id="0b52" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">这是我们开发的最后阶段，我们为模型创建一个端点，以便利用AWS提供的各种附加服务(如Lambda Function &amp; AWS API Gateway Proxy)与各种应用程序进行交互。然而，这里我们的主要目标是创建一个端点。</p><p id="9a36" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">部署模型可以作为批量转换作业的替代方法来测试我们的模型。这里，我们首先创建端点，然后简单地将测试数据传递给它。</p><p id="ff61" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">为了部署我们的模型，我们只需要在我们的估计器对象上调用<em class="lh"> deploy </em>方法。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="48c9" class="li jp hi mq b fi mu mv l mw mx">xgb_predictor = xgb.deploy(initial_instance_count = 1, instance_type = 'ml.m4.xlarge')</span></pre><p id="e407" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们需要告诉端点我们发送的数据是什么格式，以便SageMaker可以执行序列化。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="fa58" class="li jp hi mq b fi mu mv l mw mx">xgb_predictor.content_type = 'text/csv'<br/>xgb_predictor.serializer = csv_serializer</span></pre><p id="2b54" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在预测器对象上调用<em class="lh">预测</em>方法来测试我们部署的模型。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="9846" class="li jp hi mq b fi mu mv l mw mx">Y_pred = xgb_predictor.predict(X_test.values).decode('utf-8')</span></pre><p id="933d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">存储在Y_pred中的预测当前存储为逗号分隔的字符串，因此我们希望将其分解为一个NumPy数组。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="3717" class="li jp hi mq b fi mu mv l mw mx">Y_pred = np.fromstring(Y_pred, sep=',')</span></pre><p id="3a23" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在，在评估上面的输出时，指标分数应该与我们在批处理转换作业中获得的分数相同。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="39f1" class="li jp hi mq b fi mu mv l mw mx">Y_pred = pd.read_csv(os.path.join(data_dir, 'test.csv.out'), header=None)</span><span id="db2f" class="li jp hi mq b fi my mv l mw mx">error = np.sqrt(mse(Y_pred,Y_test))</span></pre><p id="b02f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> <em class="lh">但是端点在哪里..？？</em> </strong></p><p id="a36b" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">它在这里</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="dec6" class="li jp hi mq b fi mu mv l mw mx">xgb_predictor.endpoint</span></pre><p id="44b8" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">访问预测器对象的端点属性为我们提供了模型的端点，我们可以进一步使用它来与模型进行交互。</p><p id="1023" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">总是在工作完成后删除端点。</p><pre class="iy iz ja jb fd mp mq mr ms aw mt bi"><span id="3b0d" class="li jp hi mq b fi mu mv l mw mx">xgb_predictor.delete_endpoint()</span></pre><p id="92fc" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">T11】</strong></p></div></div>    
</body>
</html>