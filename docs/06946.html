<html>
<head>
<title>DiscoverDaily: A Flask Web Application Built with the Spotify API and Deployed on Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DiscoverDaily:用Spotify API构建的Flask Web应用程序，部署在Google Cloud上</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/discoverdaily-a-flask-web-application-built-with-the-spotify-api-and-deployed-on-google-cloud-6c046e6e731b?source=collection_archive---------3-----------------------#2020-06-08">https://medium.com/analytics-vidhya/discoverdaily-a-flask-web-application-built-with-the-spotify-api-and-deployed-on-google-cloud-6c046e6e731b?source=collection_archive---------3-----------------------#2020-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b6e46eed79b73b3e32ae3e8b5484e7d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ggtLghCsJXwJht2h4aMpg.png"/></div></div></figure><p id="278a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">几年前，当我注册了一个Spotify试用账户时，我相信我会在计费开始前删除这个账户。然而，我很快就被Spotify的时尚布局、易用性和用户定制迷住了。虽然Spotify确实值得每月4.99美元的学生折扣价，但我错过了iTunes中容易获得的小功能:每个曲目的个人播放计数器和最常播放的前25个播放列表。</p><p id="9a03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于没有iTunes(或现在的Apple Music)经验的人来说，每个用户都有一个播放列表，按顺序列出了他们最常播放的歌曲。该播放列表会自动更新，并允许用户轻松查看和播放他们最喜爱和最怀旧的音乐。我决定尝试为Spotify用户重新创建这个功能，包括自动更新和所有功能。</p><p id="3bc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文记录了我如何在Flask中构建这个特性，以及一个播放列表生成器和间隔计时器，然后将它部署到Google Cloud，以便其他人可以访问它。我在这里介绍:</p><ul class=""><li id="0c5d" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">使用Spotify API处理授权</li><li id="ad19" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">使用Flask路由和对Spotify API的请求构建功能</li><li id="f793" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">整合MySQL数据库，允许自动更新播放列表</li><li id="deff" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">将应用部署到Google Cloud</li></ul><p id="3fca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">web应用程序不再运行(由于维护数据库的相关成本)，但是完整的代码可以在<a class="ae kc" href="https://github.com/lucaoh21/Spotify-Discover-2.0" rel="noopener ugc nofollow" target="_blank"> Github </a>上查看。</p><h1 id="70ab" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Spotify API</h1><p id="5e81" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated"><a class="ae kc" href="https://developer.spotify.com/" rel="noopener ugc nofollow" target="_blank"> Spotify的web API </a>提供了一组端点，让每个用户都可以访问私人数据，比如他们的播放列表和回放。注册应用程序后，您将获得一个应用程序ID和密码(请安全保存)。要开始向API发出请求，您需要获得用户授权。这是通过四个步骤完成的。</p><ol class=""><li id="698b" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lg ju jv jw bi translated">通过让用户登录并授予访问权限来请求授权</li><li id="b354" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lg ju jv jw bi translated">代表用户请求访问和刷新令牌</li><li id="22e4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lg ju jv jw bi translated">使用访问令牌向API发出请求</li><li id="9bf5" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lg ju jv jw bi translated">在访问令牌到期后，使用刷新令牌请求新令牌</li></ol><h2 id="476b" class="lh ke hi bd kf li lj lk kj ll lm ln kn jb lo lp kr jf lq lr kv jj ls lt kz lu bi translated">批准</h2><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="943d" class="lh ke hi ma b fi me mf l mg mh"><a class="ae kc" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/authorize')<br/>def authorize():<br/>  client_id = app.config['CLIENT_ID']<br/>  redirect_uri = app.config['REDIRECT_URI']<br/>  scope = app.config['SCOPE']</span><span id="5b5a" class="lh ke hi ma b fi mi mf l mg mh">  state_key = createStateKey(15)<br/>  session['state_key'] = state_key<br/><br/>  authorize_url = '<a class="ae kc" href="https://accounts.spotify.com/en/authorize?'" rel="noopener ugc nofollow" target="_blank">https://accounts.spotify.com/en/authorize?'</a><br/>  params = {'response_type': 'code', 'client_id': client_id,<br/>            'redirect_uri': redirect_uri, 'scope': scope, <br/>            'state': state_key}</span><span id="9d58" class="lh ke hi ma b fi mi mf l mg mh">  query_params = urlencode(params)<br/>  response = make_response(redirect(authorize_url + query_params))<br/>  return response</span></pre><p id="3b4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我创建了一个<em class="mj"> config.py </em>文件来存储我的客户端ID和密码，以及我的数据库信息(确保将这个文件添加到。gitignore以避免暴露数据)。在用户尝试访问某个功能后，他们将被重定向到登录Spotify。重定向包括一个状态密钥，以确保请求和响应都来自同一个浏览器，从而防止攻击。作用域允许应用程序代表用户访问特定的API端点，例如<em class="mj"> playlist-modify-public </em>，它允许应用程序创建一个播放列表并向其中添加曲目。</p><h2 id="8a9e" class="lh ke hi bd kf li lj lk kj ll lm ln kn jb lo lp kr jf lq lr kv jj ls lt kz lu bi translated">访问令牌</h2><p id="2033" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">用户登录后，Spotify重定向到一个回调URL，该URL是在注册应用程序时设置的。在回调期间，检查返回的状态密钥以确认响应是可信的，然后请求访问令牌。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="3508" class="lh ke hi ma b fi me mf l mg mh">def getToken(code):<br/>  token_url = '<a class="ae kc" href="https://accounts.spotify.com/api/token'" rel="noopener ugc nofollow" target="_blank">https://accounts.spotify.com/api/token'</a><br/>  authorization = app.config['AUTHORIZATION']<br/>  redirect_uri = app.config['REDIRECT_URI']</span><span id="51e9" class="lh ke hi ma b fi mi mf l mg mh">  headers = {'Authorization': authorization, <br/>             'Accept': 'application/json', <br/>             'Content-Type': 'application/x-www-form-urlencoded'}<br/>  body = {'code': code, 'redirect_uri': redirect_uri, <br/>          'grant_type': 'authorization_code'}</span><span id="f411" class="lh ke hi ma b fi mi mf l mg mh">  post_response = requests.post(token_url,headers=headers,data=body)</span><span id="4dfd" class="lh ke hi ma b fi mi mf l mg mh">  if post_response.status_code == 200:<br/>    pr = post_response.json()<br/>    return pr['access_token'], pr['refresh_token'], pr['expires_in']<br/>  else:<br/>    logging.error('getToken:' + str(post_response.status_code))<br/>    return None</span></pre><p id="4729" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了第一次接收访问令牌，根据OAuth 2.0协议，使用(ID:secret)的编码版本发出POST请求。成功的请求具有状态代码<code class="du mk ml mm ma b">200</code>，在这种情况下，将返回访问令牌、刷新令牌和到期长度。或者，记录一个错误，并返回<code class="du mk ml mm ma b">None</code>以指示故障。刷新访问令牌的工作方式类似，刷新令牌作为附加的主体参数提供。</p><h2 id="6fcd" class="lh ke hi bd kf li lj lk kj ll lm ln kn jb lo lp kr jf lq lr kv jj ls lt kz lu bi translated">请求Spotify API</h2><p id="1206" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">授予访问令牌后，应用程序可以开始向各种<a class="ae kc" href="https://developer.spotify.com/documentation/web-api/reference/" rel="noopener ugc nofollow" target="_blank"> API端点</a>发出请求(只要在授权中设置了适当的范围)。因为我的应用程序必须访问数十个不同的端点，所以我编写了标准化的函数来发出GET、POST、PUT和DELETE请求。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="6e39" class="lh ke hi ma b fi me mf l mg mh">def makeGetRequest(session, url, params={}):<br/>  headers = {"Authorization": "Bearer {}".format(session['token'])}<br/>  response = requests.get(url, headers=headers, params=params)</span><span id="275b" class="lh ke hi ma b fi mi mf l mg mh">  if response.status_code == 200:<br/>    return response.json()<br/>  elif response.status_code == 401 <br/>       and checkTokenStatus(session) != None:<br/>    return makeGetRequest(session, url, params)<br/>  else:<br/>    logging.error('makeGetRequest:' + str(response.status_code))<br/>    return None</span></pre><p id="2737" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Flask session对象用于存储用户的访问和刷新令牌，以及各种其他数据。会话对象可以存储特定的用户信息，类似于cookies。然而，会话会加密地签署cookie，这样用户在不知道密钥的情况下无法修改cookie，密钥应该安全地存储在<em class="mj"> config.py </em>文件中。</p><p id="8a81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于GET请求，指示成功的唯一状态代码是<code class="du mk ml mm ma b">200</code>，在这种情况下，响应以JSON格式返回。当访问令牌过期时，出现一个<code class="du mk ml mm ma b">401</code>状态代码。出现此错误时，将检查访问令牌的健康状况。否则，返回null表示失败。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="8559" class="lh ke hi ma b fi me mf l mg mh">def checkTokenStatus(session):<br/>  if time.time() &gt; session['token_expiration']:<br/>    payload = refreshToken(session['refresh_token'])</span><span id="d73b" class="lh ke hi ma b fi mi mf l mg mh">  if payload != None:<br/>    session['token'] = payload[0]<br/>    session['token_expiration'] = time.time() + payload[1]<br/>  else:<br/>    logging.error('checkTokenStatus')<br/>    return None</span><span id="521b" class="lh ke hi ma b fi mi mf l mg mh">  return "Success"</span></pre><p id="1646" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果访问令牌已经过期，则利用刷新令牌请求获得新令牌。响应正文包括访问令牌的生命周期(对于Spotify API通常为一小时)，可用于确定新令牌何时到期。</p><h1 id="397d" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">构建功能</h1><p id="e99a" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">我希望我的应用程序有三个主要特性:</p><ol class=""><li id="ca23" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lg ju jv jw bi translated"><strong class="is hj"> TopTracks </strong>:用户可以创建一个播放列表，其中包含过去一个月、六个月或有史以来最常听的音乐，并且可以选择每天更新播放列表以保持最新。</li><li id="abf4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lg ju jv jw bi translated"><strong class="is hj">创建</strong>:用户可以通过输入最多五个艺术家或曲目名称并设置各种可调谐属性来创建播放列表。</li><li id="c118" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lg ju jv jw bi translated"><strong class="is hj">间隔计时器</strong>:用户可以输入他们想要的间隔时间和长度，应用程序将在跳到下一首曲目之前，在指定的时间段内播放指定播放列表中的歌曲。</li></ol><h2 id="802b" class="lh ke hi bd kf li lj lk kj ll lm ln kn jb lo lp kr jf lq lr kv jj ls lt kz lu bi translated">热门曲目</h2><p id="8456" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">当用户首次访问该网站时，他们会看到过去一个月、六个月以及所有时间内最常听的歌曲，因为Spotify播放小部件，所以他们可以了解自己最喜欢的音乐。这是通过从API请求顶部曲目、解析曲目id的响应以及使用一点前端Jinja魔术来显示小部件来实现的。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="cfdf" class="lh ke hi ma b fi me mf l mg mh">{% for track in track_ids[1] %}<br/>  &lt;div&gt;<br/>    &lt;iframe class="iframe-track" allowtransparency="true"<br/>     src="<a class="ae kc" href="https://open.spotify.com/embed/track/{{" rel="noopener ugc nofollow" target="_blank">https://open.spotify.com/embed/track/{{</a> track }}"<br/>     allow="encrypted-media" frameborder="0"&gt;&lt;/iframe&gt;<br/>  &lt;/div&gt;<br/>{% endfor %}</span></pre><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/df13cda02171d4254714d103e33b8837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h2FZ8NqLSqDFc2LnhOJw-g.png"/></div></div><figcaption class="mo mp et er es mq mr bd b be z dx translated">TopTracks网站视图</figcaption></figure><p id="0479" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尝试根据三个时间段之一保存播放列表会提示一个模式，用户可以在该模式中选择他们想要保存的播放列表、这些播放列表的名称以及他们是否想要每天更新它们。在提交时，在后端发出请求以创建新的播放列表，获取指定时间段的热门曲目，并将这些曲目添加到新的播放列表中。创建新播放列表的功能如下所示。播放列表ID稍后用于添加曲目，而播放列表URI允许重定向到Spotify应用程序。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="8674" class="lh ke hi ma b fi me mf l mg mh">def createPlaylist(session, playlist_name):<br/>  url = '<a class="ae kc" href="https://api.spotify.com/v1/users/'" rel="noopener ugc nofollow" target="_blank">https://api.spotify.com/v1/users/'</a> + session['user_id']<br/>        + '/playlists'<br/>  data = {'name': playlist_name, <br/>          'description': 'Created by Discover Daily'}<br/>  playlist = makePostRequest(session, url, data) </span><span id="542d" class="lh ke hi ma b fi mi mf l mg mh">  if playlist == None:<br/>    return None</span><span id="e17b" class="lh ke hi ma b fi mi mf l mg mh">  return playlist['id'], playlist['uri']</span></pre><h2 id="3427" class="lh ke hi bd kf li lj lk kj ll lm ln kn jb lo lp kr jf lq lr kv jj ls lt kz lu bi translated">创造</h2><p id="db8c" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">Spotify <a class="ae kc" href="https://developer.spotify.com/documentation/web-api/reference/browse/get-recommendations/" rel="noopener ugc nofollow" target="_blank">推荐端点</a>允许最多五个种子生成曲目推荐列表。我允许用户输入曲目和艺术家名字的组合作为种子，然后为他们提供几个可调整的属性，如<em class="mj">能量</em>和<em class="mj">流行度</em>。如果选择了一个属性，其值将用作推荐轨迹的目标。填写完所需的信息后，会根据这些建议创建一个播放列表。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/8cf9eca24093e9cdf6a9bee921034844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*npUMGA26C1T-fpdOr4Nd6Q.gif"/></div></div><figcaption class="mo mp et er es mq mr bd b be z dx translated">创建播放列表网站的视图</figcaption></figure><p id="ab1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更容易搜索艺术家和曲目，我加入了jQuery UI Autocomplete小部件。当用户输入文本时，将文本作为参数的GET请求被发送到后端。然后，基于该输入的对曲目和艺术家姓名的请求被发送到API。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="1f03" class="lh ke hi ma b fi me mf l mg mh">def searchSpotify(session, search, limit=4):<br/>  url = '<a class="ae kc" href="https://api.spotify.com/v1/search'" rel="noopener ugc nofollow" target="_blank">https://api.spotify.com/v1/search'</a><br/>  params = {'limit': limit, 'q': search + '*', <br/>            'type': 'artist,track'}<br/>  payload = makeGetRequest(session, url, params)</span><span id="556b" class="lh ke hi ma b fi mi mf l mg mh">  if payload == None:<br/>    return None</span><span id="659b" class="lh ke hi ma b fi mi mf l mg mh">  results = []<br/>  for item in payload['artists']['items']:<br/>    results.append([item['name'], item['id'], item['popularity']])</span><span id="d69a" class="lh ke hi ma b fi mi mf l mg mh">  for item in payload['tracks']['items']:<br/>    results.append(item['name'], item['id'], item['popularity']])</span><span id="53a8" class="lh ke hi ma b fi mi mf l mg mh">  results.sort(key=lambda x: int(x[2]), reverse=True)</span><span id="4f2f" class="lh ke hi ma b fi mi mf l mg mh">  results_json = []<br/>  for item in results:<br/>    results_json.append({'label': item[0], 'value': item[1]})</span><span id="ef9a" class="lh ke hi ma b fi mi mf l mg mh">  return results_json</span></pre><p id="e38e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<code class="du mk ml mm ma b">'*'</code>标识符使得输入不必完全匹配音轨或艺术家的名字。该列表按受欢迎程度(从高到低)排序，以便用户首先看到最有可能的请求。根据jQuery Autocomplete小部件协议，结果被放入JSON，名称和值对为<code class="du mk ml mm ma b">'label': name</code>和<code class="du mk ml mm ma b">'value': ID</code>。虽然名称会显示给用户，但id是隐藏的，仅在创建播放列表时用作种子。</p><h2 id="b258" class="lh ke hi bd kf li lj lk kj ll lm ln kn jb lo lp kr jf lq lr kv jj ls lt kz lu bi translated">限时器</h2><p id="7f76" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">间隔计时器对各种活动都很有用，包括健身，在健身时经常很难不停地看手表。虽然有很多定时器在时间间隔到期时会发出警报，但它们都没有音乐功能。这个定时器的工作方式是在指定的时间内循环播放曲目，并通过JavaScript<em class="mj">setInterval()</em>函数提供一个有用的倒计时定时器。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/432552cdf8e2a9853f0870b98127985e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qygyhLK_OXvS_puSkK7A6Q.gif"/></div></div><figcaption class="mo mp et er es mq mr bd b be z dx translated">间隔计时器站点视图</figcaption></figure><p id="6641" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最初加载页面时，会向Spotify API发出请求，为用户收集所有可用的播放列表和设备。同样，它们通过Jinja循环显示给用户。</p><p id="40f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">倒计时定时器在前端处理，当用户单击开始、重置、暂停或恢复时，以及当间隔时间达到0并跳过曲目时，向后端发出请求。基本流程是:</p><ol class=""><li id="8056" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lg ju jv jw bi translated">单击Start:使用输入的表单数据向后端发出POST请求。向API发出请求以切换无序播放，并且利用用户输入来设置回放上下文。另一个请求是获取当前播放的曲目，以便可以向用户显示曲目名称和专辑封面。</li><li id="371f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lg ju jv jw bi translated">间隔命中数为0:使用skip命令向后端发出GET请求。向API发出跳到下一个轨道的请求，并且当前轨道信息作为响应被发送回前端。</li></ol><p id="ee6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为间隔功能使用回放，所以可能会出现两个独特的请求错误，应该向用户显示:<code class="du mk ml mm ma b">403</code>表示用户没有Spotify Premium，而<code class="du mk ml mm ma b">404</code>表示所选设备未激活，不能用于回放。在可能发生这种情况的请求中，这些错误是通过Flask的<em class="mj"> abort() </em>函数来处理的，该函数会提前中止带有HTTP错误代码的请求。然后，这些错误可以通过前端JavaScript警报呈现给用户。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="f63c" class="lh ke hi ma b fi me mf l mg mh">response = startPlaybackContext(session,playlist,session['device'])<br/>  if response == 403:<br/>    abort(403)<br/>  if response == 404:<br/>    abort(404)</span><span id="ee7b" class="lh ke hi ma b fi mi mf l mg mh">def startPlaybackContext(session, playlist, device):<br/>  url = '<a class="ae kc" href="https://api.spotify.com/v1/me/player/play'" rel="noopener ugc nofollow" target="_blank">https://api.spotify.com/v1/me/player/play'</a><br/>  params = {'device_id': device}<br/>  data = {'context_uri': playlist, <br/>          'offset': {'position': 0}, 'position_ms': 0}<br/>  payload = makePutRequest(session, url, params, data)<br/>  return payload</span></pre><p id="cf6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Spotify通常需要几毫秒来处理播放命令，如开始和跳过。因此，请求当前曲目时返回的信息实际上可能是针对前一首曲目的。因此，如果返回的曲目已经前进了超过5秒钟(表明它是旧曲目)，应用程序将等待几毫秒，然后再次尝试获取当前曲目信息。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="8884" class="lh ke hi ma b fi me mf l mg mh">def getTrack(session):<br/>  url = '<a class="ae kc" href="https://api.spotify.com/v1/me/player/currently-playing'" rel="noopener ugc nofollow" target="_blank">https://api.spotify.com/v1/me/player/currently-playing'</a><br/>  curr = makeGetRequest(session, url)</span><span id="cc07" class="lh ke hi ma b fi mi mf l mg mh">  if curr == None:<br/>    return None</span><span id="b299" class="lh ke hi ma b fi mi mf l mg mh">  if curr['progress_ms'] != None and curr['progress_ms'] &gt; 5000:<br/>    time.sleep(0.2)<br/>    curr = makeGetRequest(session, url)<br/>    if curr == None:<br/>      return None</span><span id="1c9a" class="lh ke hi ma b fi mi mf l mg mh">  name = curr['item']['name']<br/>  img = curr['item']['album']['images'][0]['url']</span><span id="165a" class="lh ke hi ma b fi mi mf l mg mh">  return {'name': name, 'img': img}</span></pre><h1 id="b9e0" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">整合数据库以进行自动更新</h1><p id="8d40" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">为了重新创建苹果的<strong class="is hj">前25名最常播放的</strong>播放列表，当用户最常听的音乐发生变化时，应用程序必须自动更新用户保存的TopTracks播放列表。这需要两个附加组件:</p><ol class=""><li id="9c3c" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lg ju jv jw bi translated">一个数据库，用于存储已注册自动更新其TopTracks播放列表的用户的信息</li><li id="1507" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lg ju jv jw bi translated">一种计划更新的方法</li></ol><h2 id="0615" class="lh ke hi bd kf li lj lk kj ll lm ln kn jb lo lp kr jf lq lr kv jj ls lt kz lu bi translated">数据库建设</h2><p id="2051" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">因为我计划在Google Cloud上部署站点，所以使用Cloud SQL for MySQL作为我的数据库是合乎逻辑的，这使得建立和维护MySQL关系数据库相对容易。在Google Cloud上<a class="ae kc" href="https://cloud.google.com/sql/docs/mysql/create-manage-databases" rel="noopener ugc nofollow" target="_blank">创建数据库</a>之后，必须在Flask应用程序中建立连接。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="e31e" class="lh ke hi ma b fi me mf l mg mh">engine = sqlalchemy.create_engine(<br/>         sqlalchemy.engine.url.URL(<br/>         drivername = 'mysql+pymysql',<br/>         username = 'root',<br/>         password = app.config['DATABASE_PASSWORD'],<br/>         database = app.config['DATABASE_NAME'],<br/>         query = {'unix_socket': '/cloudsql/' <br/>                  + app.config['DATABASE_CONNECTION']},<br/>         ),<br/>)</span><span id="af8c" class="lh ke hi ma b fi mi mf l mg mh">Session = sessionmaker(bind=engine)<br/>Base = declarative_base()<br/>Base.metadata.create_all(engine)</span></pre><p id="a0c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过用<em class="mj"> sessionmaker() </em>配置会话工厂并将其与引擎绑定，每当调用<em class="mj"> Session() </em>时，就可以为数据库创建一个新的会话对象。会话对象管理ORM映射对象的操作，在数据库中添加和更新用户时是必需的。调用<em class="mj"> create_all() </em>确保已经创建了正确的表。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="7a74" class="lh ke hi ma b fi me mf l mg mh">class User(Base):<br/>  __tablename__ = 'users'<br/>  id = Column(Integer, primary_key=True)<br/>  username = Column(String(64), index=True, unique=True)<br/>  refresh_token = Column(String(150), index=True, unique=True)<br/>  playlist_id_short = Column(String(30), index=True, unique=True)<br/>  playlist_id_medium = Column(String(30), index=True, unique=True)<br/>  playlist_id_long = Column(String(30), index=True, unique=True)</span></pre><p id="a51c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该表由六列组成，包括必需的ID主键。当用户注册TopTracks播放列表时，使用用户名列来确保他们以前没有注册过。如果用户已经存在于表中，那么只更新播放列表id。当用户最初创建了一个时间段的播放列表，而现在正在添加不同时间段的播放列表时，就会出现这种情况。否则，将创建一个新的<em class="mj"> User() </em>对象，并将其插入到表中。下面，您可以看到如何使用会话工厂来创建会话对象，这些对象允许对数据库进行更新。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="3fc7" class="lh ke hi ma b fi me mf l mg mh">def addUser(username, refresh_token, playlist_id_short=None,<br/>            playlist_id_medium=None, playlist_id_long=None):<br/>  session = Session()<br/>  id_exists = session.query(User.id).<br/>              filter_by(username=username).scalar()</span><span id="676e" class="lh ke hi ma b fi mi mf l mg mh">  if id_exists == None:<br/>    user = User(username=username, refresh_token=refresh_token,<br/>           playlist_id_short=playlist_id_short,<br/>           playlist_id_medium=playlist_id_medium,<br/>           playlist_id_long=playlist_id_long)<br/>    session.add(user)<br/>    logging.info('New auto user: ' + username)</span><span id="b22b" class="lh ke hi ma b fi mi mf l mg mh">  else:<br/>    user = session.query(User).get(id_exists)<br/>    logging.info('Auto user updated: ' + user.username)</span><span id="96d1" class="lh ke hi ma b fi mi mf l mg mh">    if playlist_id_short != None:<br/>      user.playlist_id_short = playlist_id_short<br/>    if playlist_id_medium != None:<br/>      user.playlist_id_medium = playlist_id_medium<br/>    if playlist_id_long != None:<br/>      user.playlist_id_long = playlist_id_long</span><span id="7494" class="lh ke hi ma b fi mi mf l mg mh">  session.commit()<br/>  session.close()</span></pre><h2 id="1d44" class="lh ke hi bd kf li lj lk kj ll lm ln kn jb lo lp kr jf lq lr kv jj ls lt kz lu bi translated">自动更新</h2><p id="89ca" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">刷新令牌列是必需的，以便在更新播放列表时可以请求新的访问令牌。为了调度这些更新，使用了来自AP调度器模块的后台调度器。通过向调度程序添加一个带有时间参数的作业，每个周期都会调用指定的函数。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="dd96" class="lh ke hi ma b fi me mf l mg mh">from models import updatePlaylists<br/>scheduler = BackgroundScheduler()<br/>scheduler.add_job(updatePlaylists, trigger='interval', days=1)<br/>scheduler.start()</span></pre><p id="6d85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<em class="mj"> updatePlaylist() </em>函数中，表中的所有行都被迭代。如果应用程序无法用存储的刷新令牌建立授权，或者如果用户已经删除了他们的所有TopTracks播放列表，则从表中删除该行。否则，对于每个TopTracks播放列表，该播放列表被清除，然后用当前收听最多的曲目重新填充。</p><h1 id="9ead" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">部署到Google云平台</h1><p id="22fd" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在将应用部署到谷歌云平台(GCP)之前，必须创建一个<em class="mj"> app.yaml </em>文件来存储GCP需要的所有配置，包括Python版本、路由等。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="b514" class="lh ke hi ma b fi me mf l mg mh">runtime: python37<br/>entrypoint: gunicorn -b :$PORT main:app<br/>handlers:<br/>- url: /static<br/>  static_dir: static<br/>- url: /(.*)<br/>  script: auto</span></pre><p id="91fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了正确记录数据库中的错误和更新，我还引入了GCP日志。实现这一点最简单的方法是将常规的Python日志链接到<a class="ae kc" href="https://cloud.google.com/logging" rel="noopener ugc nofollow" target="_blank"> Google的logger </a>，然后使用标准的Python <em class="mj"> logging.error() </em>或<em class="mj"> logging.warning() </em>函数。如果记录器成功连接，您可以在Google Cloud控制台日志查看器中看到所有输出的日志。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="955b" class="lh ke hi ma b fi me mf l mg mh">import google.cloud.logging<br/>client = google.cloud.logging.Client()<br/>client.get_default_handler()<br/>client.setup_logging()</span></pre><p id="79c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，可以使用以下命令将应用程序部署到GCP，并查看创建的web应用程序。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="4686" class="lh ke hi ma b fi me mf l mg mh">&gt;&gt; gcloud app deploy<br/>&gt;&gt; gcloud app browse</span></pre></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><p id="0d34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你已经读到这里，我建议你看看我的<a class="ae kc" href="https://github.com/lucaoh21/Spotify-Discover-2.0" rel="noopener ugc nofollow" target="_blank">代码</a>。欢迎在评论区发表关于这篇文章或我的申请的任何问题或评论。我将高兴地回答这些问题。感谢阅读！</p></div></div>    
</body>
</html>