<html>
<head>
<title>Stock Prices Prediction Using Machine Learning and Deep Learning Techniques (with Python codes)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习和深度学习技术预测股票价格(使用Python代码)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/stock-prices-prediction-using-machine-learning-and-deep-learning-techniques-with-python-codes-a630c0d3f137?source=collection_archive---------0-----------------------#2018-10-25">https://medium.com/analytics-vidhya/stock-prices-prediction-using-machine-learning-and-deep-learning-techniques-with-python-codes-a630c0d3f137?source=collection_archive---------0-----------------------#2018-10-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="0b1e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="0328" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">预测股票市场的表现是最困难的事情之一。预测中涉及的因素很多——物理因素与生理因素、理性与非理性行为等等。所有这些因素结合在一起，使得股价波动很大，很难高度准确地预测。</p><p id="e2e2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们能把机器学习作为这个领域的游戏改变者吗？使用组织的最新公告、季度收入结果等功能。，机器学习技术有可能挖掘出我们以前没有看到的模式和见解，这些可以用来做出准确无误的预测。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/ab476a16b9976d5a6286d316b877b4af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*yHcCt7m6k4imv8F5.jpg"/></div></figure><p id="c63c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在本文中，我们将使用上市公司股票价格的历史数据。我们将实施一系列机器学习算法来预测这家公司的未来股价，从简单的算法开始，如平均和线性回归，然后转移到高级技术，如自动ARIMA和LSTM。</p><p id="6b62" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">本文背后的核心思想是展示这些算法是如何实现的，所以我将简要描述这种技术，并在必要时提供相关链接来温习概念。如果你是时间序列世界的新手，我建议你先浏览以下文章:</p><ul class=""><li id="b269" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka kt ku kv kw bi translated"><a class="ae kx" href="https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/" rel="noopener ugc nofollow" target="_blank">创建时间序列预测的综合初学者指南</a></li><li id="fb2a" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka kt ku kv kw bi translated"><a class="ae kx" href="https://www.analyticsvidhya.com/blog/2015/12/complete-tutorial-time-series-modeling/" rel="noopener ugc nofollow" target="_blank">时间序列建模完整教程</a></li></ul><h1 id="68db" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目录</h1><ol class=""><li id="852d" class="ko kp hi jf b jg jh jk jl jo ld js le jw lf ka lg ku kv kw bi translated">理解问题陈述</li><li id="33e7" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka lg ku kv kw bi translated">移动平均数</li><li id="7505" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka lg ku kv kw bi translated">线性回归</li><li id="0fb1" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka lg ku kv kw bi translated">k-最近邻</li><li id="d51f" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka lg ku kv kw bi translated">ARIMA汽车</li><li id="6744" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka lg ku kv kw bi translated">先知</li><li id="e166" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka lg ku kv kw bi translated">长短期记忆(LSTM)</li></ol><h1 id="8444" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">理解问题陈述</h1><p id="8662" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将很快深入到本文的实现部分，但首先重要的是确定我们的目标是解决什么。广义来说，股票市场分析分为两部分——基本面分析和技术分析。</p><ul class=""><li id="27d6" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka kt ku kv kw bi translated">基本面分析包括根据公司当前的商业环境和财务表现来分析公司未来的盈利能力。</li><li id="4638" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka kt ku kv kw bi translated">另一方面，技术分析包括阅读图表和使用统计数字来确定股票市场的趋势。</li></ul><p id="e566" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你可能已经猜到了，我们的重点是技术分析部分。我们将使用来自<a class="ae kx" href="https://www.quandl.com/" rel="noopener ugc nofollow" target="_blank"> Quandl </a>的数据集(你可以在这里找到各种股票的历史数据)，对于这个特定的项目，我使用了“<a class="ae kx" href="https://www.quandl.com/data/NSE/TATAGLOBAL-Tata-Global-Beverages-Limited" rel="noopener ugc nofollow" target="_blank">塔塔全球饮料</a>的数据。是时候开始了！</p><p id="c553" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们将首先加载数据集，并为问题定义目标变量:</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="d973" class="lm ig hi li b fi ln lo l lp lq">#import packages<br/>import pandas as pd<br/>import numpy as np<br/><br/>#to plot within notebook<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/><br/>#setting figure size<br/>from matplotlib.pylab import rcParams<br/>rcParams['figure.figsize'] = 20,10<br/><br/>#for normalizing data<br/>from sklearn.preprocessing import MinMaxScaler<br/>scaler = MinMaxScaler(feature_range=(0, 1))<br/><br/>#read the file<br/>df = pd.read_csv('NSE-TATAGLOBAL(1).csv')<br/><br/>#print the head<br/>df.head()</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lr"><img src="../Images/130755d1e3600e4528d08fcda4ea2820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/0*AtiK6kiOrY7V-t78.png"/></div></figure><p id="03c5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">数据集中有多个变量—日期、开盘、盘高、盘低、最后、收盘、total_trade_quantity和成交量。</p><ul class=""><li id="c443" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka kt ku kv kw bi translated">列<em class="ls">开盘</em>和<em class="ls">收盘</em>代表股票在某一天交易的起始和最终价格。</li><li id="0ddb" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka kt ku kv kw bi translated"><em class="ls">高</em>、<em class="ls">低</em>和<em class="ls">最后</em>代表当天股票的最高、最低和最后价格。</li><li id="35b6" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka kt ku kv kw bi translated"><em class="ls">总交易量</em>是当天买卖的股票数量<em class="ls">成交量(Lacs) </em>是特定公司在给定日期的成交量。</li></ul><p id="bb98" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">另一个需要注意的重要事情是，市场在周末和公共假期是关闭的。再次注意上表，一些日期值缺失—2018年2月10日、2018年6月10日、2018年7月10日。在这些日期中，2日是国定假日，而6日和7日是周末。</p><p id="5115" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">损益计算通常由股票当天的收盘价决定，因此我们将收盘价作为目标变量。让我们绘制目标变量，以了解它在我们的数据中是如何形成的:</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="8622" class="lm ig hi li b fi ln lo l lp lq">#setting index as date<br/>df['Date'] = pd.to_datetime(df.Date,format='%Y-%m-%d')<br/>df.index = df['Date']<br/><br/>#plot<br/>plt.figure(figsize=(16,8))<br/>plt.plot(df['Close'], label='Close Price history')</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lt"><img src="../Images/a45b6704b5c93da7704554cf8d3cd2e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oa0-RYIBYpOP8DVi.png"/></div></div></figure><p id="4f09" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在接下来的部分中，我们将使用不同的技术来预测股票的每日收盘价。</p><h1 id="da5d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">移动平均数</h1><h1 id="65c5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="1201" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">“平均”是我们日常生活中最常用的词之一。例如，计算平均分以确定整体表现，或者找到过去几天的平均温度以了解今天的温度——这些都是我们定期进行的例行任务。因此，这是在我们的数据集上进行预测的一个很好的起点。</p><p id="769d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">每天的预测收盘价将是一组先前观察值的平均值。我们将使用移动平均技术，而不是简单的平均，移动平均技术对每个预测使用最新的一组值。换句话说，对于每个后续步骤，在从集合中删除最早的观察值时，会考虑预测值。这里有一个简单的图表，可以帮助你更清楚地理解这一点。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ly"><img src="../Images/2eb78d7605df1e74882ed7d0b848766b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8XVvtkmLKXOdzhjU.png"/></div></div></figure><p id="06eb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们将在数据集上实现这项技术。第一步是创建一个只包含<em class="ls">日期</em>和<em class="ls">收盘</em>价格列的dataframe，然后将它分成训练集和验证集来验证我们的预测。</p><h1 id="b34d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">履行</h1><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="6931" class="lm ig hi li b fi ln lo l lp lq">#creating dataframe with date and the target variable<br/>data = df.sort_index(ascending=True, axis=0)<br/>new_data = pd.DataFrame(index=range(0,len(df)),columns=['Date', 'Close'])<br/><br/>for i in range(0,len(data)):<br/>     new_data['Date'][i] = data['Date'][i]<br/>     new_data['Close'][i] = data['Close'][i]</span></pre><p id="921d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在将数据拆分为训练和验证时，我们不能使用随机拆分，因为这将破坏时间成分。所以在这里，我将去年的数据设置为验证，将之前4年的数据设置为训练。</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="8cb0" class="lm ig hi li b fi ln lo l lp lq">#splitting into train and validation<br/>train = new_data[:987]<br/>valid = new_data[987:]</span><span id="cfd6" class="lm ig hi li b fi lz lo l lp lq">new_data.shape, train.shape, valid.shape<br/>((1235, 2), (987, 2), (248, 2))</span><span id="f23b" class="lm ig hi li b fi lz lo l lp lq">train['Date'].min(), train['Date'].max(), valid['Date'].min(), valid['Date'].max()<br/><br/>(Timestamp('2013-10-08 00:00:00'),<br/>Timestamp('2017-10-06 00:00:00'),<br/>Timestamp('2017-10-09 00:00:00'),<br/>Timestamp('2018-10-08 00:00:00'))</span></pre><p id="2c23" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下一步是为验证集创建预测，并使用实际值检查RMSE。</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="eb60" class="lm ig hi li b fi ln lo l lp lq">#make predictions<br/>preds = []<br/>for i in range(0,248):<br/>    a = train['Close'][len(train)-248+i:].sum() + sum(preds)<br/>    b = a/248<br/>    preds.append(b)</span></pre><h1 id="a550" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结果</h1><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="b60d" class="lm ig hi li b fi ln lo l lp lq">#calculate rmse<br/>rms=np.sqrt(np.mean(np.power((np.array(valid['Close'])-preds),2)))<br/>rms</span><span id="c3d5" class="lm ig hi li b fi lz lo l lp lq">104.51415465984348</span></pre><p id="ab34" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">仅仅检查RMSE并不能帮助我们理解模型的表现。我们把这个形象化一点，以便更直观的理解。这是预测值和实际值的曲线图。</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="90ae" class="lm ig hi li b fi ln lo l lp lq">#plot<br/>valid['Predictions'] = 0<br/>valid['Predictions'] = preds<br/>plt.plot(train['Close'])<br/>plt.plot(valid[['Close', 'Predictions']])</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ma"><img src="../Images/f26873c6539b5c798ebda3a15bb57ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hDsWtDQ54jS4LC_O.png"/></div></div></figure><h1 id="8428" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">推理</h1><p id="7897" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">RMSE值接近105，但结果并不乐观(从图中可以看出)。预测值与训练集中的观察值在相同的范围内(最初有增加的趋势，然后缓慢减少)。</p><p id="d8e6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在下一节中，我们将研究两种常用的机器学习技术——线性回归和kNN，并了解它们在我们的股票市场数据上的表现。</p><h1 id="9d8a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">线性回归</h1><h1 id="23c7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="b518" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">可以在这些数据上实现的最基本的机器学习算法是线性回归。线性回归模型返回一个确定自变量和因变量之间关系的方程。</p><p id="93d2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">线性回归的方程式可以写成:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mb"><img src="../Images/e3456f0c2357a83c3e7b6967949549d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/0*gqzZX5kcFjPmPFJX.png"/></div></figure><p id="a62b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里，x1，x2，…xn代表自变量，而系数θ1，θ2，…θn代表权重。你可以参考下面的文章来更详细地研究线性回归:</p><ul class=""><li id="4f11" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka kt ku kv kw bi translated">线性、脊形和套索回归综合初学者指南。</li></ul><p id="523f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于我们的问题陈述，我们没有一组独立变量。我们只有日期。让我们使用日期列来提取诸如日、月、年、周一/周五等特征。然后拟合线性回归模型。</p><h1 id="dfbf" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">履行</h1><p id="6a9d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将首先按升序对数据集进行排序，然后创建一个单独的数据集，这样创建的任何新要素都不会影响原始数据。</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="8d99" class="lm ig hi li b fi ln lo l lp lq">#setting index as date values<br/>df['Date'] = pd.to_datetime(df.Date,format='%Y-%m-%d')<br/>df.index = df['Date']<br/><br/>#sorting<br/>data = df.sort_index(ascending=True, axis=0)<br/><br/>#creating a separate dataset<br/>new_data = pd.DataFrame(index=range(0,len(df)),columns=['Date', 'Close'])<br/><br/>for i in range(0,len(data)):<br/>    new_data['Date'][i] = data['Date'][i]<br/>    new_data['Close'][i] = data['Close'][i]</span></pre><p id="dc6f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这就产生了如下特性:</p><p id="157b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">'年'，'月'，'周'，'日'，'日周'，'日年'，'是_月_结束'，'是_月_开始'，'是_季度_结束'，'是_季度_开始'，'是_年_结束'，和'是_年_开始'。</p><p id="77b7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="ls">注意:我使用了fastai库中的add_datepart。如果您没有安装它，您可以简单地使用命令</em><strong class="jf hj"><em class="ls">pip install fastai</em></strong><em class="ls">。否则，您可以使用python中简单for循环来创建这些功能。我在下面展示了一个例子。</em></p><p id="9ab7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">除此之外，我们还可以添加我们认为与预测相关的一组特征。例如，我的假设是，一周的第一天和最后一天对股票收盘价的影响可能远远超过其他日子。因此，我创建了一个特性来识别某一天是星期一/星期五还是星期二/星期三/星期四。这可以使用以下代码行来完成:</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="292d" class="lm ig hi li b fi ln lo l lp lq">new_data['mon_fri'] = 0<br/>for i in range(0,len(new_data)):<br/>    if (new_data['Dayofweek'][i] == 0 or new_data['Dayofweek'][i] == 4):<br/>        new_data['mon_fri'][i] = 1<br/>    else:<br/>        new_data['mon_fri'][i] = 0</span></pre><p id="5d75" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果星期几等于0或4，则列值将为1，否则为0。同样，您可以创建多个特征。如果你对有助于预测股价的功能有什么想法，请在评论区分享。</p><p id="44eb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们现在将数据分为训练集和验证集，以检查模型的性能。</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="21f2" class="lm ig hi li b fi ln lo l lp lq">#split into train and validation<br/>train = new_data[:987]<br/>valid = new_data[987:]<br/><br/>x_train = train.drop('Close', axis=1)<br/>y_train = train['Close']<br/>x_valid = valid.drop('Close', axis=1)<br/>y_valid = valid['Close']<br/><br/>#implement linear regression<br/>from sklearn.linear_model import LinearRegression<br/>model = LinearRegression()<br/>model.fit(x_train,y_train)</span></pre><h1 id="78d8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结果</h1><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="2a12" class="lm ig hi li b fi ln lo l lp lq">#make predictions and find the rmse<br/>preds = model.predict(x_valid)<br/>rms=np.sqrt(np.mean(np.power((np.array(y_valid)-np.array(preds)),2)))<br/>rms</span><span id="ef66" class="lm ig hi li b fi lz lo l lp lq">121.16291596523156</span></pre><p id="f7cd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">RMSE值高于以前的技术，这清楚地表明线性回归表现不佳。让我们看看这个图，理解为什么线性回归没有做好:</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="75b9" class="lm ig hi li b fi ln lo l lp lq">#plot<br/>valid['Predictions'] = 0<br/>valid['Predictions'] = preds<br/><br/>valid.index = new_data[987:].index<br/>train.index = new_data[:987].index<br/><br/>plt.plot(train['Close'])<br/>plt.plot(valid[['Close', 'Predictions']])</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lt"><img src="../Images/591a508e2f6c65540803dfc95f27643f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JnVma4iBHGfd7zvi.png"/></div></div></figure><h1 id="0525" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">推理</h1><p id="5f15" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">线性回归是一种简单的技术，很容易解释，但有几个明显的缺点。使用回归算法的一个问题是模型过度适应日期和月份列。该模型将考虑一个月前同一<em class="ls">日期</em>或一年前同一<em class="ls">日期/月份</em>的值，而不是从预测的角度考虑以前的值。</p><p id="18e0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">从上面的情节可以看出，对于2016年1月和2017年1月，股价出现了下跌。该模型预测2018年1月也是如此。线性回归技术可以很好地解决诸如<a class="ae kx" href="https://datahack.analyticsvidhya.com/contest/practice-problem-big-mart-sales-iii/" rel="noopener ugc nofollow" target="_blank"> Big Mart sales </a>这样的问题，其中独立特征对于确定目标值很有用。</p><h1 id="fdbd" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">k-最近邻</h1><h1 id="906f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="f004" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这里可以使用的另一个有趣的ML算法是kNN (k最近邻)。基于独立变量，kNN发现新数据点和旧数据点之间的相似性。让我用一个简单的例子来解释一下。</p><p id="2c8e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">考虑11个人的身高和年龄。根据给定的特征(“年龄”和“身高”)，该表可以用如下所示的图形格式表示:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mc"><img src="../Images/60b07b8b779a3f969336c234ad15ec58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7KbSrWepsCF71Dmm.png"/></div></div></figure><p id="d4fa" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了确定ID #11的权重，kNN考虑这个ID的最近邻居的权重。ID #11的权重被预测为其邻居的平均值。如果我们现在考虑三个邻居(k=3)，ID#11的重量将= (77+72+60)/3 = 69.66千克。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es md"><img src="../Images/174189a8436ee3510b27bba1049c72fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/0*y24pKsTpPNhDTaZq.png"/></div></figure><p id="15cc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">关于kNN的详细了解，可以参考以下文章:</p><ul class=""><li id="ca91" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka kt ku kv kw bi translated"><a class="ae kx" href="https://www.analyticsvidhya.com/blog/2018/03/introduction-k-neighbours-algorithm-clustering/" rel="noopener ugc nofollow" target="_blank">k近邻介绍:简化</a></li><li id="6732" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka kt ku kv kw bi translated"><a class="ae kx" href="https://www.analyticsvidhya.com/blog/2018/08/k-nearest-neighbor-introduction-regression-python/" rel="noopener ugc nofollow" target="_blank">回归K近邻算法实用介绍</a></li></ul><h1 id="106b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">履行</h1><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="b7d8" class="lm ig hi li b fi ln lo l lp lq">#importing libraries<br/>from sklearn import neighbors<br/>from sklearn.model_selection import GridSearchCV<br/>from sklearn.preprocessing import MinMaxScaler<br/>scaler = MinMaxScaler(feature_range=(0, 1))</span></pre><p id="3828" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用与上一节相同的训练和验证集:</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="c2a1" class="lm ig hi li b fi ln lo l lp lq">#scaling data<br/>x_train_scaled = scaler.fit_transform(x_train)<br/>x_train = pd.DataFrame(x_train_scaled)<br/>x_valid_scaled = scaler.fit_transform(x_valid)<br/>x_valid = pd.DataFrame(x_valid_scaled)<br/><br/>#using gridsearch to find the best parameter<br/>params = {'n_neighbors':[2,3,4,5,6,7,8,9]}<br/>knn = neighbors.KNeighborsRegressor()<br/>model = GridSearchCV(knn, params, cv=5)<br/><br/>#fit the model and make predictions<br/>model.fit(x_train,y_train)<br/>preds = model.predict(x_valid)</span></pre><h1 id="867f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结果</h1><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="0451" class="lm ig hi li b fi ln lo l lp lq">#rmse<br/>rms=np.sqrt(np.mean(np.power((np.array(y_valid)-np.array(preds)),2)))<br/>rms</span><span id="b707" class="lm ig hi li b fi lz lo l lp lq">115.17086550026721</span></pre><p id="5120" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">RMSE值没有很大的差异，但是预测值和实际值的图表应该提供更清晰的理解。</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="750e" class="lm ig hi li b fi ln lo l lp lq">#plot<br/>valid['Predictions'] = 0<br/>valid['Predictions'] = preds<br/>plt.plot(valid[['Close', 'Predictions']])<br/>plt.plot(train['Close'])</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ma"><img src="../Images/fc27789e2c237995d197c1435b342d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bosrTi_D7FXIwm14.png"/></div></div></figure><h1 id="1523" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">推理</h1><p id="0c3d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">RMSE值几乎类似于线性回归模型，该图显示了相同的模式。像线性回归一样，kNN也确定了2018年1月的下降，因为这是过去几年的模式。我们可以有把握地说，回归算法在这个数据集上表现不佳。</p><p id="b214" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们来看看一些时间序列预测技术，看看它们在面对股票价格预测挑战时表现如何。</p><h1 id="b8e1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">ARIMA汽车</h1><h1 id="c268" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="89b3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">ARIMA是一种非常流行的时间序列预测统计方法。ARIMA模型考虑过去的值来预测未来的值。ARIMA有三个重要参数:</p><ul class=""><li id="1fd5" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka kt ku kv kw bi translated">p(用于预测下一个值的过去值)</li><li id="eec3" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka kt ku kv kw bi translated">q(用于预测未来值的过去预测误差)</li><li id="021d" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka kt ku kv kw bi translated">d(差分阶数)</li></ul><p id="82ac" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">ARIMA的参数调整耗费大量时间。因此，我们将使用自动ARIMA，它会自动选择提供最小误差的(p，q，d)的最佳组合。要了解更多关于自动ARIMA的工作原理，请参考这篇文章:</p><ul class=""><li id="bb8c" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka kt ku kv kw bi translated"><a class="ae kx" href="https://www.analyticsvidhya.com/blog/2018/08/auto-arima-time-series-modeling-python-r/" rel="noopener ugc nofollow" target="_blank">使用Auto ARIMA构建高性能时间序列模型</a></li></ul><h1 id="5f1e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">履行</h1><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="9b98" class="lm ig hi li b fi ln lo l lp lq">from pyramid.arima import auto_arima<br/><br/>data = df.sort_index(ascending=True, axis=0)<br/><br/>train = data[:987]<br/>valid = data[987:]<br/><br/>training = train['Close']<br/>validation = valid['Close']<br/><br/>model = auto_arima(training, start_p=1, start_q=1,max_p=3, max_q=3, m=12,start_P=0, seasonal=True,d=1, D=1, trace=True,error_action='ignore',suppress_warnings=True)<br/>model.fit(training)<br/><br/>forecast = model.predict(n_periods=248)<br/>forecast = pd.DataFrame(forecast,index = valid.index,columns=['Prediction'])</span></pre><h1 id="ed41" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结果</h1><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="664b" class="lm ig hi li b fi ln lo l lp lq">rms=np.sqrt(np.mean(np.power((np.array(valid['Close'])-np.array(forecast['Prediction'])),2)))<br/>rms</span><span id="a098" class="lm ig hi li b fi lz lo l lp lq">44.954584993246954</span></pre><p id="f3af" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">RMSE值从115降低到45。</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="146f" class="lm ig hi li b fi ln lo l lp lq">#plot<br/>plt.plot(train['Close'])<br/>plt.plot(valid['Close'])<br/>plt.plot(forecast['Prediction'])</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lt"><img src="../Images/cd7f1097edcab865e8be3a0c82a47580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*13WhSuguzXgPNE3a.png"/></div></div></figure><h1 id="12e6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">推理</h1><p id="3306" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">正如我们前面看到的，自动ARIMA模型使用过去的数据来理解时间序列中的模式。使用这些值，模型捕捉到了序列中的增长趋势。尽管使用这种技术的预测远好于之前实现的机器学习模型的预测，但这些预测仍然不接近真实值。</p><p id="69d3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">从图中可以明显看出，该模型捕捉到了该系列中的一个趋势，但并未将重点放在季节性部分。在下一节中，我们将实现一个时间序列模型，该模型将序列的趋势和季节性都考虑在内。</p><h1 id="3379" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">先知</h1><h1 id="5afc" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="5a60" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有许多时间序列技术可以在股票预测数据集上实现，但是这些技术中的大多数在拟合模型之前需要大量的数据预处理。由脸书设计和首创的Prophet是一个时间序列预测库，它不需要数据预处理，实现起来非常简单。Prophet的输入是一个包含两列的data frame:date和target (ds和y)。</p><p id="e161" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Prophet试图捕捉过去数据中的季节性，当数据集很大时效果很好。这里有一篇有趣的文章，以简单直观的方式解释了Prophet:</p><ul class=""><li id="26b9" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka kt ku kv kw bi translated"><a class="ae kx" href="https://www.analyticsvidhya.com/blog/2018/05/generate-accurate-forecasts-facebook-prophet-python-r/" rel="noopener ugc nofollow" target="_blank">使用脸书先知</a>生成快速准确的时间序列预测。</li></ul><h1 id="79bb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">履行</h1><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="41ad" class="lm ig hi li b fi ln lo l lp lq">#importing prophet<br/>from fbprophet import Prophet<br/><br/>#creating dataframe<br/>new_data = pd.DataFrame(index=range(0,len(df)),columns=['Date', 'Close'])<br/><br/>for i in range(0,len(data)):<br/>    new_data['Date'][i] = data['Date'][i]<br/>    new_data['Close'][i] = data['Close'][i]<br/><br/>new_data['Date'] = pd.to_datetime(new_data.Date,format='%Y-%m-%d')<br/>new_data.index = new_data['Date']<br/><br/>#preparing data<br/>new_data.rename(columns={'Close': 'y', 'Date': 'ds'}, inplace=True)<br/><br/>#train and validation<br/>train = new_data[:987]<br/>valid = new_data[987:]<br/><br/>#fit the model<br/>model = Prophet()<br/>model.fit(train)<br/><br/>#predictions<br/>close_prices = model.make_future_dataframe(periods=len(valid))<br/>forecast = model.predict(close_prices)</span></pre><h1 id="33d4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结果</h1><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="2df8" class="lm ig hi li b fi ln lo l lp lq">#rmse<br/>forecast_valid = forecast['yhat'][987:]<br/>rms=np.sqrt(np.mean(np.power((np.array(valid['y'])-np.array(forecast_valid)),2)))<br/>rms</span><span id="9fdf" class="lm ig hi li b fi lz lo l lp lq">57.494461930575149</span><span id="6840" class="lm ig hi li b fi lz lo l lp lq">#plot<br/>valid['Predictions'] = 0<br/>valid['Predictions'] = forecast_valid.values<br/><br/>plt.plot(train['y'])<br/>plt.plot(valid[['y', 'Predictions']])</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lt"><img src="../Images/303f0efc8bdd94764e8adb33e0f7506a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*STsZeP-cJM10NHOU.png"/></div></div></figure><h1 id="d78f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">推理</h1><p id="b653" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Prophet(像大多数时间序列预测技术一样)试图从过去的数据中捕捉趋势和季节性。该模型通常在时间序列数据集上表现良好，但在这种情况下却名不副实。</p><p id="3bef" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">事实证明，股票价格没有特定的趋势或季节性。这在很大程度上取决于目前市场的行情，因此价格会有涨有跌。因此，像ARIMA、萨里玛和预言家这样的预测技术对于这个特殊的问题不会显示出好的结果。</p><p id="4e07" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们继续尝试另一种先进的技术——长短期记忆(LSTM)。</p><h1 id="96a8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">长短期记忆(LSTM)</h1><h1 id="5074" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="6ac8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">LSTMs被广泛用于序列预测问题，并被证明是非常有效的。它们如此有效的原因是因为LSTM能够存储过去重要的信息，并忘记不重要的信息。LSTM有三个城门:</p><ul class=""><li id="4aef" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka kt ku kv kw bi translated"><strong class="jf hj">输入门:</strong>输入门向细胞状态添加信息</li><li id="ee16" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka kt ku kv kw bi translated"><strong class="jf hj">遗忘之门:</strong>它删除模型不再需要的信息</li><li id="9ee5" class="ko kp hi jf b jg ky jk kz jo la js lb jw lc ka kt ku kv kw bi translated"><strong class="jf hj">输出门:</strong>LSTM的输出门选择要显示的信息作为输出</li></ul><p id="ae37" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">要更详细地了解LSTM及其建筑，你可以阅读下面的文章:</p><ul class=""><li id="6d89" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka kt ku kv kw bi translated"><a class="ae kx" href="https://www.analyticsvidhya.com/blog/2017/12/fundamentals-of-deep-learning-introduction-to-lstm/" rel="noopener ugc nofollow" target="_blank">长短期记忆简介</a></li></ul><p id="a1a8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，让我们将LSTM实现为一个黑盒，并检查它在特定数据上的性能。</p><h1 id="c86a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">履行</h1><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="1cb6" class="lm ig hi li b fi ln lo l lp lq">#importing required libraries<br/>from sklearn.preprocessing import MinMaxScaler<br/>from keras.models import Sequential<br/>from keras.layers import Dense, Dropout, LSTM<br/><br/>#creating dataframe<br/>data = df.sort_index(ascending=True, axis=0)<br/>new_data = pd.DataFrame(index=range(0,len(df)),columns=['Date', 'Close'])<br/>for i in range(0,len(data)):<br/>    new_data['Date'][i] = data['Date'][i]<br/>    new_data['Close'][i] = data['Close'][i]<br/><br/>#setting index<br/>new_data.index = new_data.Date<br/>new_data.drop('Date', axis=1, inplace=True)<br/><br/>#creating train and test sets<br/>dataset = new_data.values<br/><br/>train = dataset[0:987,:]<br/>valid = dataset[987:,:]<br/><br/>#converting dataset into x_train and y_train<br/>scaler = MinMaxScaler(feature_range=(0, 1))<br/>scaled_data = scaler.fit_transform(dataset)<br/><br/>x_train, y_train = [], []<br/>for i in range(60,len(dataset)):<br/>    x_train.append(scaled_data[i-60:i,0])<br/>    y_train.append(scaled_data[i,0])<br/>x_train, y_train = np.array(x_train), np.array(y_train)<br/><br/>x_train = np.reshape(x_train, (x_train.shape[0],x_train.shape[1],1))<br/><br/># create and fit the LSTM network<br/>model = Sequential()<br/>model.add(LSTM(units=50, return_sequences=True, input_shape=(x_train.shape[1],1)))<br/>model.add(LSTM(units=50))<br/>model.add(Dense(1))<br/><br/>model.compile(loss='mean_squared_error', optimizer='adam')<br/>model.fit(x_train, y_train, epochs=1, batch_size=1, verbose=2)<br/><br/>#predicting 246 values, using past 60 from the train data<br/>inputs = new_data[len(new_data) - len(valid) - 60:].values<br/>inputs = inputs.reshape(-1,1)<br/>inputs  = scaler.transform(inputs)<br/><br/>X_test = []<br/>for i in range(60,inputs.shape[0]):<br/>    X_test.append(inputs[i-60:i,0])<br/>X_test = np.array(X_test)<br/><br/>X_test = np.reshape(X_test, (X_test.shape[0],X_test.shape[1],1))<br/>closing_price = model.predict(X_test)<br/>closing_price = scaler.inverse_transform(closing_price)</span></pre><h1 id="c00c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结果</h1><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="413f" class="lm ig hi li b fi ln lo l lp lq">rms=np.sqrt(np.mean(np.power((np.array(valid['Close'])-np.array(valid['Predictions'])),2)))<br/>rms</span><span id="d34d" class="lm ig hi li b fi lz lo l lp lq">11.772259608962642</span></pre><p id="2109" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">rmse大幅下降！让我们对照实际值来检查一下预测。</p><pre class="kh ki kj kk fd lh li lj lk aw ll bi"><span id="185e" class="lm ig hi li b fi ln lo l lp lq">#for plotting<br/>train = new_data[:989]<br/>valid = new_data[989:]<br/><br/>valid['Predictions'] = 0<br/>valid['Predictions'] = closing_price<br/><br/>plt.plot(train['Close'])<br/>plt.plot(valid[['Close','Predictions']])</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lt"><img src="../Images/1876d846d46e051fb6f974eaaf5e4b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qVC9F7fe8jQoM34c.png"/></div></div></figure><h1 id="2111" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">推理</h1><p id="8144" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">哇！LSTM轻而易举地超越了我们迄今为止看到的任何算法。LSTM模型可以针对各种参数进行调整，例如更改LSTM层数、添加下降值或增加历元数。但是，LSTM的预测是否足以确定股票价格是上涨还是下跌呢？肯定不是！</p><p id="cfab" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">正如我在文章开始时提到的，股票价格受到有关公司的新闻和其他因素的影响，如公司的非货币化或合并/拆分。还有一些无形的因素通常是无法预先预测的。</p><h1 id="25fa" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结束注释</h1><p id="7d11" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">时间序列预测是一个非常有趣的领域，这是我在写这些文章的时候意识到的。社区中有一种看法，认为这是一个复杂的领域，虽然有一点道理，但一旦掌握了基本技术，就不会那么难了。</p><p id="0e8e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我很想知道LSTM是如何解决一种不同的时间序列问题的，并鼓励你自己也尝试一下。如果你有任何问题，欢迎在下面的评论区联系我。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="7dd5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="ls">原载于2018年10月25日</em><a class="ae kx" href="https://www.analyticsvidhya.com/blog/2018/10/predicting-stock-price-machine-learningnd-deep-learning-techniques-python/" rel="noopener ugc nofollow" target="_blank"><em class="ls">【www.analyticsvidhya.com】</em></a><em class="ls">。</em></p></div></div>    
</body>
</html>