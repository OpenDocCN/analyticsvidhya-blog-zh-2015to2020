<html>
<head>
<title>Weather forecasting with Recurrent Neural Networks in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中递归神经网络的天气预报</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/weather-forecasting-with-recurrent-neural-networks-1eaa057d70c3?source=collection_archive---------0-----------------------#2019-12-29">https://medium.com/analytics-vidhya/weather-forecasting-with-recurrent-neural-networks-1eaa057d70c3?source=collection_archive---------0-----------------------#2019-12-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/e40ff9143f47c00a1509e86088565ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HBCC_V18PM8jGGZjDpXgCg.jpeg"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">来源:图片来自<a class="ae jc" href="https://www.pexels.com/photo/abstract-blur-branch-christmas-259698/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a></figcaption></figure><p id="1a2c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">随着数据科学和技术的进步，我们几乎可以在世界各地获得精确的天气预报。从气象站和卫星收集的数据用于分析和预测极端天气造成的气象灾害。根据研究，基于对过去天气的观察，我们可以预测未来的天气。机器学习可以用历史天气数据来预测天气。请记住，天气预测是一个有根据的猜测！</p><p id="138f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本文中，我们将开发一个具有递归神经网络的深度学习模型，通过考虑30天的历史温度数据来提供某个位置的4天温度预测。</p><p id="3d57" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因此，让我们从简单介绍递归神经网络开始。</p><h1 id="5332" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">什么是递归神经网络(RNN)？</strong></h1><p id="ad3d" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">RNN是一种深度学习模型，用于时间序列预测、语音识别等。与传统的神经网络不同，递归网络使用它们的记忆(也称为状态)来预测序列输出。简而言之，当我们希望根据之前的连续输入预测未来的结果时，可以使用RNN。例如，我们可以使用RNN通过提供前一个单词来预测句子中的下一个单词。</p><h1 id="27cc" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">RNN天气预报。</h1><p id="1fff" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">现在我们已经了解了RNN，让我们开始开发一个RNN模型，它可以根据30天的历史温度数据提供4天的温度预测。我已经使用了<a class="ae jc" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Google colab </a>来实现这段代码，Spyder用于可视化，有很多工具你可以根据自己的喜好来使用。</p><p id="6247" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你可以从<a class="ae jc" href="https://drive.google.com/drive/folders/12JTdHancAxquTuDxNJGwuKf-93I4cOGI?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>下载历史天气数据集，也可以随意使用任何你选择的有温度数据的天气数据集。</p><p id="9b1c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们加载数据集并查看前几行:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="f8d7" class="lj kc hi lf b fi lk ll l lm ln">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd</span><span id="2c4a" class="lj kc hi lf b fi lo ll l lm ln">#import dataset from data.csv file<br/>dataset = pd.read_csv('data.csv')<br/>dataset = dataset.dropna(subset=["Temperature"])<br/>dataset=dataset.reset_index(drop=True)</span><span id="a2ba" class="lj kc hi lf b fi lo ll l lm ln">training_set = dataset.iloc[:,4:5].values</span></pre><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lp"><img src="../Images/104ee92ba23d4b6c4e5c8fb873479e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*6eDbGXeIrmfh2qGG9sd2Eg.png"/></div></figure><p id="48a5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们只包括温度列，因为我们要预测温度，并删除所有没有值或有NaN的行。</p><p id="4939" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下一步，我们将不得不应用特征缩放来归一化0到1范围内的温度。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="bbea" class="lj kc hi lf b fi lk ll l lm ln">#Feature Scaling <br/>from sklearn.preprocessing import MinMaxScaler</span><span id="dc17" class="lj kc hi lf b fi lo ll l lm ln">sc = MinMaxScaler(feature_range=(0,1))<br/>training_set_scaled = sc.fit_transform(training_set)</span></pre><p id="4ad8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将创建一个训练集，以便每30天我们将提供未来4天的温度作为输出。换句话说，我们的RNN的输入是30天的温度数据，输出是4天的温度预报。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="73c7" class="lj kc hi lf b fi lk ll l lm ln">x_train = []<br/>y_train = []</span><span id="1641" class="lj kc hi lf b fi lo ll l lm ln">n_future = 4 # next 4 days temperature forecast<br/>n_past = 30 # Past 30 days </span><span id="7f8b" class="lj kc hi lf b fi lo ll l lm ln">for i in range(0,len(training_set_scaled)-n_past-n_future+1):<br/>    x_train.append(training_set_scaled[i : i + n_past , 0])     <br/>    y_train.append(training_set_scaled[i + n_past : i + n_past + n_future , 0 ])</span><span id="677f" class="lj kc hi lf b fi lo ll l lm ln">x_train , y_train = np.array(x_train), np.array(y_train)</span><span id="f324" class="lj kc hi lf b fi lo ll l lm ln">x_train = np.reshape(x_train, (x_train.shape[0] , x_train.shape[1], 1) )</span></pre><p id="22ec" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> x_train </strong>包含当天之前的30次温度输入，<strong class="jf hj"> y_train </strong>包含当天之后的4天温度输出。由于x_train和y_train是列表，我们必须将它们转换为numpy数组，以使训练集适合我们的模型。</p><p id="0ecb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们已经准备好了我们的训练数据，所以让我们继续建立一个预测天气的RNN模型。</p><ol class=""><li id="0901" class="lq lr hi jf b jg jh jk jl jo ls js lt jw lu ka lv lw lx ly bi translated">首先，我们将从keras.models和keras layers ie导入keras序列模型。LSTM，密集和辍学。你可以参考Keras文档了解更多关于Keras模型和图层的信息<a class="ae jc" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank">这里</a></li></ol><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="bf9d" class="lj kc hi lf b fi lk ll l lm ln">from keras.models import Sequential<br/>from keras.layers import LSTM,Dense ,Dropout<br/># Fitting RNN to training set using Keras Callbacks. Read Keras callbacks docs for more info.</span></pre><p id="45ad" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">2.让我们定义我们的RNN层。我们将通过使用<strong class="jf hj"> sequential() </strong>顺序添加层来创建一个顺序模型。第一层是具有30个存储单元的双向LSTM，<strong class="jf hj"> return_sequence=True </strong>表示返回输出序列中的最后一个输出，<strong class="jf hj"> input_shape </strong>描述输入的结构。使用双向LSTM，输出层同时从过去(正向)和未来(反向)状态获得反馈。我们添加了3个隐藏层和一个输出层，该层具有输出4天温度的线性激活函数。最后，我们用训练数据拟合了RNN模型。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="ca3e" class="lj kc hi lf b fi lk ll l lm ln">regressor = Sequential()</span><span id="8b82" class="lj kc hi lf b fi lo ll l lm ln">regressor.add(Bidirectional(LSTM(units=30, return_sequences=True, input_shape = (x_train.shape[1],1) ) ))<br/>regressor.add(Dropout(0.2))</span><span id="d6f7" class="lj kc hi lf b fi lo ll l lm ln">regressor.add(LSTM(units= 30 , return_sequences=True))<br/>regressor.add(Dropout(0.2))</span><span id="765c" class="lj kc hi lf b fi lo ll l lm ln">regressor.add(LSTM(units= 30 , return_sequences=True))<br/>regressor.add(Dropout(0.2))</span><span id="e1d8" class="lj kc hi lf b fi lo ll l lm ln">regressor.add(LSTM(units= 30))<br/>regressor.add(Dropout(0.2))<br/>regressor.add(Dense(units = n_future,activation='linear'))</span><span id="0758" class="lj kc hi lf b fi lo ll l lm ln">regressor.compile(optimizer='adam', loss='mean_squared_error',metrics=['acc'])<br/>regressor.fit(x_train, y_train, epochs=500,batch_size=32 )</span></pre><p id="3740" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">注意:</strong>我使用了Adam optimizer，因为它的计算效率很高。</p><p id="a456" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">3.创建测试数据来测试我们的模型性能。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="30ec" class="lj kc hi lf b fi lk ll l lm ln"># read test dataset<br/>testdataset = pd.read_csv('data (12).csv')<br/>#get only the temperature column<br/>testdataset = testdataset.iloc[:30,3:4].values</span><span id="77ef" class="lj kc hi lf b fi lo ll l lm ln">real_temperature = pd.read_csv('data (12).csv')<br/>real_temperature = real_temperature.iloc[30:,3:4].values</span><span id="6f70" class="lj kc hi lf b fi lo ll l lm ln">testing = sc.transform(testdataset)<br/>testing = np.array(testing)<br/>testing = np.reshape(testing,(testing.shape[1],testing.shape[0],1))</span></pre><p id="564c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">4.现在我们已经准备好了测试数据，我们可以测试我们的RNN模型了。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="fc58" class="lj kc hi lf b fi lk ll l lm ln">predicted_temperature = regressor.predict(testing)</span><span id="e5b5" class="lj kc hi lf b fi lo ll l lm ln">predicted_temperature = sc.inverse_transform(predicted_temperature)</span><span id="42af" class="lj kc hi lf b fi lo ll l lm ln">predicted_temperature = np.reshape(predicted_temperature,(predicted_temperature.shape[1],predicted_temperature.shape[0]))</span></pre><p id="83a5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">模型的输出是标准化的形式，因此为了获得实际温度值，我们将<strong class="jf hj"> inverse_transform() </strong>应用于<strong class="jf hj"> predicted_temperature </strong>和<strong class="jf hj"> </strong>，然后对其进行整形。</p><p id="e043" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们比较一下预测温度和实际温度。正如我们所看到的，该模型在给定的测试数据下表现良好。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="6e7d" class="lj kc hi lf b fi lk ll l lm ln">real_temperature<br/>array([[82.],        [82.],        [83.],        [83.]])</span><span id="6b45" class="lj kc hi lf b fi lo ll l lm ln">predicted_temperature<br/>array([[83.76233 ],  [83.957565],  [83.70461 ],  [83.6326  ]])</span></pre><p id="1062" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们预测一个月的温度并将其可视化，我们会得到以下结果。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lz"><img src="../Images/51615d47b1eeb200ab7bee7ce1d0dcb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*6ixTVRwtB5x5bPCkKonifg.png"/></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">一个月以上的气温预测</figcaption></figure><h1 id="d78b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="d052" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">递归神经网络在时间序列预测方面最为人所知，因为它们可以处理序列数据，也可以与卷积神经网络(CNN)集成，用于处理复杂的混合模型，但它们也需要占用大量内存来进行处理。我想向您推荐一些提高模型准确性的方法:</p><ol class=""><li id="db0d" class="lq lr hi jf b jg jh jk jl jo ls js lt jw lu ka lv lw lx ly bi translated">增加或减少纪元的数量。尝试不同的历元数，如100、200、300…等等</li><li id="b518" class="lq lr hi jf b jg ma jk mb jo mc js md jw me ka lv lw lx ly bi translated">最好的方法之一是使用大型数据集并训练模型，但这可能需要较长的时间。安装CUDA就可以和Keras一起使用GPU了。更多信息，请参考<a class="ae jc" rel="noopener" href="/@ab9.bhatia/set-up-gpu-accelerated-tensorflow-keras-on-windows-10-with-anaconda-e71bfa9506d1">这篇</a>文章。</li><li id="904e" class="lq lr hi jf b jg ma jk mb jo mc js md jw me ka lv lw lx ly bi translated">向RNN添加更多LSTM图层。</li></ol></div></div>    
</body>
</html>