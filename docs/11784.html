<html>
<head>
<title>Parameterized Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">参数化学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/parameterized-learning-91f701f9cabb?source=collection_archive---------14-----------------------#2020-12-18">https://medium.com/analytics-vidhya/parameterized-learning-91f701f9cabb?source=collection_archive---------14-----------------------#2020-12-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="931e" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">参数化学习是一种可以用一组固定大小的参数来概括数据的学习模型。无论你向参数模型扔多少数据，它都不会改变它需要多少参数的想法。Russel 和 Norvig(2009 年)</p></blockquote><h2 id="295e" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated"><strong class="ak">参数化模型包括四个主要部分——包括数据、评分、损失函数以及权重和偏差。我们将通过一个实例来了解每个组件。</strong></h2></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="f889" class="km ji hi bd jj kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky jz kz la lb kd lc bi translated">数据</h1><p id="fb63" class="pw-post-body-paragraph ii ij hi il b im ld io ip iq le is it js lf iw ix jw lg ja jb ka lh je jf jg hb bi translated">数据将是我们的输入组件，我们将使用它来训练我们的模型。该数据包括输入数据及其相应的分类标签。(监督学习数据)。</p><p id="e8c4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">我们的数据集包括三个不同的类——猫、狗和熊猫(每个都有 1000 张图像)，但在本文中，我们不会看到如何通过从图像中提取特征来训练我们的模型，而是会知道 ML 模型的所有主要组件是什么。</p><div class="li lj lk ll fd ab cb"><figure class="lm ln lo lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><img src="../Images/4ca5757767606ad77c475c9ffcaecbec.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*uWfgEvXdC6wpcWYtNsxQBw.jpeg"/></div></figure><figure class="lm ln lz lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><img src="../Images/d62db532e744c486115132f30e765ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*V9pLbLTYA6GHNct31_S2jw.jpeg"/></div></figure><figure class="lm ln ma lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><img src="../Images/4f0f48ba0960bd93df26025ad0d4da1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*YhyXB_IMt3obwvfgXNDyZA.jpeg"/></div><figcaption class="mb mc et er es md me bd b be z dx mf di mg mh translated">猫、狗和熊猫</figcaption></figure></div><pre class="li lj lk ll fd mi mj mk ml aw mm bi"><span id="3e42" class="jh ji hi mj b fi mn mo l mp mq"># import the necessary packages<br/>import numpy as np<br/>import cv2</span><span id="4356" class="jh ji hi mj b fi mr mo l mp mq"># initialize the class labels and set the seed of the pseudorandom<br/># number generator so we can reproduce our results<br/>labels = [“dog”, “cat”, “panda”]<br/>np.random.seed(2020)</span><span id="8928" class="jh ji hi mj b fi mr mo l mp mq"># load our example image, resize it, and then flatten it into our<br/># "feature vector" representation<br/>orig = cv2.imread("beagle.png")<br/>image = cv2.resize(orig, (32, 32)).flatten()</span></pre><p id="4360" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">上面的代码片段只是读取图像，将多维矩阵转换成一维矩阵。比如说；如果你有一个尺寸为(宽度，高度，深度)的图像，那么它将被转换为(1，宽度*高度*深度)。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="20e8" class="km ji hi bd jj kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky jz kz la lb kd lc bi translated">得分</h1><p id="fe0d" class="pw-post-body-paragraph ii ij hi il b im ld io ip iq le is it js lf iw ix jw lg ja jb ka lh je jf jg hb bi translated">该组件将我们的数据作为输入，并将其映射到类标签/名称。它基本上以 x 作为输入，应用一个定义的函数 f(x ),并返回/投射到类名中。</p><blockquote class="if ig ih"><p id="7780" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">得分=权重*输入+偏差</p></blockquote><pre class="li lj lk ll fd mi mj mk ml aw mm bi"><span id="661a" class="jh ji hi mj b fi mn mo l mp mq"># randomly initialize our weight matrix and bias vector — in a<br/># *real* training and classification task, these parameters would<br/># be *learned* by our model, but for the sake of this example,<br/># let’s use random values<br/>W = np.random.randn(3, 3072)<br/>b = np.random.randn(3)</span><span id="249d" class="jh ji hi mj b fi mr mo l mp mq"># compute the output scores by taking the dot product between the<br/># weight matrix and image pixels, followed by adding in the bias<br/>scores = W.dot(image) + b </span></pre></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="3536" class="km ji hi bd jj kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky jz kz la lb kd lc bi translated">损失函数</h1><p id="0ca3" class="pw-post-body-paragraph ii ij hi il b im ld io ip iq le is it js lf iw ix jw lg ja jb ka lh je jf jg hb bi translated">有多种损失函数，如 ReLu、Sigmoid、Tanh 等。损失函数用于通过比较我们预测的和真实的标签来量化我们预测的类别的准确性。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="3469" class="km ji hi bd jj kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky jz kz la lb kd lc bi translated">权重和偏差</h1><p id="b3ac" class="pw-post-body-paragraph ii ij hi il b im ld io ip iq le is it js lf iw ix jw lg ja jb ka lh je jf jg hb bi translated">权重矩阵(表示为 W)只不过是分配给输入中特定特征的值，偏差表示为 b。我们用于分类标签的模型的这两个参数可以根据我们的输出结果随时进行训练和优化。</p><p id="cbb7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">只有我们设置并准备好所有这些参数，模型才能用正则化参数进行调整。</p><pre class="li lj lk ll fd mi mj mk ml aw mm bi"><span id="7727" class="jh ji hi mj b fi mn mo l mp mq"># loop over the scores + labels and display them<br/>for (label, score) in zip(labels, scores):<br/>   print(“[INFO] {}: {:.2f}”.format(label, score))</span><span id="0513" class="jh ji hi mj b fi mr mo l mp mq"># draw the label with the highest score on the image as our<br/># prediction<br/>cv2.putText(orig, “Label: {}”.format(labels[np.argmax(scores)]),<br/> (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)</span><span id="61ec" class="jh ji hi mj b fi mr mo l mp mq"># display our input image<br/>cv2.imshow(“Image”, orig)</span></pre><figure class="li lj lk ll fd ln er es paragraph-image"><div class="er es ms"><img src="../Images/f351858bf638bb81430ab1d6db006f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*PDEOJ2jU8GajgKyRPgdL0Q.png"/></div></figure><p id="b13c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">随机分配给 W 和 b 的权重在这张图片中表现良好，具有更高的准确性。但是训练将会发生，并且权重和偏差将会相对于标签预测进行更新。</p><blockquote class="if ig ih"><p id="96b5" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">[信息]狗:7963.93<br/>[信息]猫:-2930.99<br/>[信息]熊猫:3362.47</p></blockquote></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="f293" class="km ji hi bd jj kn ko kp jn kq kr ks jr kt ku kv jv kw kx ky jz kz la lb kd lc bi translated">参考:</h1><p id="9c80" class="pw-post-body-paragraph ii ij hi il b im ld io ip iq le is it js lf iw ix jw lg ja jb ka lh je jf jg hb bi translated">Adrian Rosebrock 用 Python 实现计算机视觉的深度学习(入门包)</p></div></div>    
</body>
</html>