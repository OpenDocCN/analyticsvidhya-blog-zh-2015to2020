<html>
<head>
<title>Writing apps for Elasticsearch, here are some things you should take care of.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Elasticsearch编写应用程序，这里有一些你应该注意的事情。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/writing-apps-for-elasticsearch-here-are-some-things-you-should-take-care-of-828135c2995b?source=collection_archive---------19-----------------------#2019-11-10">https://medium.com/analytics-vidhya/writing-apps-for-elasticsearch-here-are-some-things-you-should-take-care-of-828135c2995b?source=collection_archive---------19-----------------------#2019-11-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/fe23c7b06fa8e4f976c753bfdcc715ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*MqpRoHQPr6czzcIzU-baEg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图片来自<a class="ae iq" href="http://www.percona.com" rel="noopener ugc nofollow" target="_blank">percona.com</a></figcaption></figure><p id="788a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我最近一直在用<code class="du jp jq jr js b">Python</code>编写一个应用程序，它与一个Elasticsearch集群通信，从/向它读取/写入数据(<code class="du jp jq jr js b">document</code>)。让我们以下面的代码为例，它与我们的Elasticsearch集群进行通信。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="b1c0" class="kb kc hi js b fi kd ke l kf kg">from elasticsearch import Elasticsearch</span><span id="0132" class="kb kc hi js b fi kh ke l kf kg"><br/>def add_document(i_index, i_doc_type, i_id, i_body):<br/>    es = es_connect()<br/>    try:<br/>        res=es.index(index=i_index, doc_type=i_doc_type, id=i_id, body=i_body)<br/>        count_success=res.get("_shards",{}).get("successful")<br/>        return count_success<br/>    except Exception as ex:<br/>        raise Exception(ex)</span><span id="d9c8" class="kb kc hi js b fi kh ke l kf kg">def es_connect():<br/>    try:<br/>        es = Elasticsearch(hosts=[{"host": es_host, "port": es_port}])<br/>        return es<br/>    except Exception as ex: <br/>        raise Exception("Failed connecting to Elasticsearch")</span></pre><p id="ff6c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">您可能已经发现，可以调用<code class="du jp jq jr js b">add_document</code>来向指定的Elasticsearch <code class="du jp jq jr js b"> index</code>和<code class="du jp jq jr js b">doctype</code>添加一个<code class="du jp jq jr js b">document</code>，最终调用<code class="du jp jq jr js b">es_connect</code>来使用主机:<code class="du jp jq jr js b">es_host</code>和端口:<code class="du jp jq jr js b">es_port</code>连接到Elasticsearch集群。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="99bf" class="kb kc hi js b fi kd ke l kf kg">def get_document(i_index, i_doc_type, i_id):<br/>    es = es_connect()<br/>    try:<br/>        res=es.get(index=i_index, doc_type=i_doc_type, id=i_id)<br/>        return res <br/>    except Exception as ex: <br/>        raise Exception("Document ID not found")will be setup Thu</span></pre><p id="cdd1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在假设您的应用程序有两个组件/服务<code class="du jp jq jr js b">componentA</code>和<code class="du jp jq jr js b">componentB.</code> <code class="du jp jq jr js b">componentA</code>向Elasticsearch集群添加一个文档，而<code class="du jp jq jr js b">componentB</code>尝试获取相同的文档，更新它，然后将其添加回Elasticsearch集群。</p><p id="7a4a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我在这个场景中遇到的问题是，有时当<code class="du jp jq jr js b">componentB</code>试图获取es文档时，操作会因<code class="du jp jq jr js b">Document not found</code>而失败，即使<code class="du jp jq jr js b">componentA</code>写了文档，而我们试图获取具有相同文档id的文档。现在，如果我们看到官方的弹性搜索文档</p><blockquote class="ki kj kk"><p id="e638" class="ir is kl it b iu iv iw ix iy iz ja jb km jd je jf kn jh ji jj ko jl jm jn jo hb bi translated">默认情况下，Elasticsearch每秒钟都会定期刷新索引，但仅限于在过去30秒内收到一个或更多搜索请求的索引。</p></blockquote><p id="eeac" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">因此，如果执行<code class="du jp jq jr js b">componentA</code>和<code class="du jp jq jr js b">componentB</code>之间的时间差小于<code class="du jp jq jr js b">1 second</code>，则由<code class="du jp jq jr js b">componentA</code>编写的文档可能无法在所有节点上进行搜索。换句话说，我们可以说,<code class="du jp jq jr js b">componentA</code>编写的文档在编写后不能立即用于搜索。为了解决这个问题，我们将研究一个名为<code class="du jp jq jr js b">refresh</code>的参数。</p><h1 id="69d4" class="kp kc hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">恢复精神</h1><p id="f4f4" class="pw-post-body-paragraph ir is hi it b iu lm iw ix iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hb bi translated">我们可以在索引级别设置刷新值，更改索引的设置，或者您可以在使用<code class="du jp jq jr js b">.index</code>函数/API存储文档时提供刷新设置。您可以查看此<a class="ae iq" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-refresh.html" rel="noopener ugc nofollow" target="_blank">文档</a>了解如何设置步进设置。</p><p id="b055" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对于下面的另一个选项，您可以更改调用<code class="du jp jq jr js b">.index</code>函数的代码</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="0776" class="kb kc hi js b fi kd ke l kf kg">def add_document(i_index, i_doc_type, i_id, i_body):<br/>    es = es_connect()<br/>    try:<br/>        res=es.index(index=i_index, doc_type=i_doc_type, id=i_id, body=i_body, refresh='true')<br/>        count_success=res.get("_shards",{}).get("successful")<br/>        return count_success<br/>    except Exception as ex: <br/>        raise Exception(ex)</span></pre><p id="2f9f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果你注意到我们已经引入了<code class="du jp jq jr js b">refresh=’true’</code>，现在将使用<code class="du jp jq jr js b">add_document</code>功能添加到Elasticsearch集群的文档，将在添加到集群后立即可供搜索。</p><p id="fbb7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi lr translated"><span class="l ls lt lu bm lv lw lx ly lz di"> T </span>以下是在性能部分使用<code class="du jp jq jr js b">refresh=’true’</code>的一些后果，因此请确保您仅在应用程序因添加文档后立即不可用而出现功能问题时才使用它。关于这一点的更多信息可以在<a class="ae iq" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-refresh.html" rel="noopener ugc nofollow" target="_blank">这个链接</a>中阅读。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h1 id="9bbb" class="kp kc hi bd kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll bi translated">VersionConflictEngineException</h1><p id="59db" class="pw-post-body-paragraph ir is hi it b iu lm iw ix iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hb bi translated"><code class="du jp jq jr js b">VersionConflictEngineException</code>通常在我们试图更新Elasticsearch index的文档时会遇到，顾名思义，版本存在一些问题。</p><p id="2dbc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对于每个Elasticsearch文档，它都维护该文档的一个版本。例如，如果我们只是创建一个索引，并尝试将一个文档放入该索引中</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="1bbb" class="kb kc hi js b fi kd ke l kf kg">POST /index_name/_doc<br/>{<br/>    "user" : "Vivek",<br/>    "post_date" : "2009-11-15T14:12:12",<br/>    "message" : "trying out Elasticsearch"<br/>}</span><span id="f454" class="kb kc hi js b fi kh ke l kf kg">#returns<br/>{<br/>    "_index": "index_name",<br/>    "_type": "_doc",<br/>    "_id": "7kRpUW4BJVpxMvy30qnq",<br/>    "_version": 1,<br/>    "result": "created",<br/>    "_shards": {<br/>        "total": 2,<br/>        "successful": 1,<br/>        "failed": 0<br/>    },<br/>    "_seq_no": 0,<br/>    "_primary_term": 1<br/>}</span></pre><p id="89e1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">可以清楚的看到文档是被创建的，创建文档的版本是<code class="du jp jq jr js b">“_version”:1</code>。现在让我们假设我们正试图从我们的python代码中更新这个文档，并且<code class="du jp jq jr js b">update_document</code>的定义如下所示</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="b555" class="kb kc hi js b fi kd ke l kf kg">def update_document(i_index, i_doc_type, i_id, i_body):<br/>        es= es_connect()<br/>        try:<br/>                result =  es.update(index=i_index, doc_type=i_doc_type, id=i_id, body=i_body)<br/>                return result<br/>        except Exception as e:<br/>                print("There was an exception updating the document", e)</span></pre><p id="6158" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在考虑这个场景，在更新文档之前，我们得到Elasticsearch文档(用<code class="du jp jq jr js b">version 1</code>)，然后尝试用一些修改过的数据更新它。但是在我们从Elasticsearch获得数据并更新它的过程中，一些其他程序或过程改变了同一个文档，最终改变了那个文档的版本(making is <code class="du jp jq jr js b">version 2</code>)。现在，如果我们的程序试图更新同一个文档，它将看到当它获得该文档时，它有<code class="du jp jq jr js b">version 1</code>，但现在它已被更改为2，更新该文档可能会覆盖其他人对该文档所做的更改，这就是为什么我们得到<code class="du jp jq jr js b">VersionConflictEngineException</code>。</p><p id="5847" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">换句话说，我们可以说，如果我们从Elasticsearch集群获得文档的<code class="du jp jq jr js b">version n</code>，我们将尝试更新相同的版本，如果具有相同ID的文档现在具有<code class="du jp jq jr js b">version n+x</code>(当我们尝试更新它时)，这仅仅意味着同时其他人对该文档进行了一些更改，这将导致<code class="du jp jq jr js b">VersionConflictEngineException</code>。</p><p id="e6fe" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们通常通过重试更新相同的文档，但使用更新的版本号来处理这个问题。在得到这个错误后，我们可以做的是发出另一个get请求，获取文档的更新文档(最新版本),然后用我们的更改更新该文档。</p><p id="0d63" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在出现的重要问题是，我们应该重试多少次来更新文档？根据我的个人经验，我认为如果<code class="du jp jq jr js b">n</code>进程试图同时更新你的文档，最好重试<code class="du jp jq jr js b">n-1</code>次。</p><p id="3104" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">作为手动重试更新文档的一部分，我们可以在调用<code class="du jp jq jr js b">update</code> API时传递一个参数(<code class="du jp jq jr js b">retry_on_conflict</code>，如果<code class="du jp jq jr js b">VersionConflictEngineException </code>发生，API将负责重试更新。以下是<code class="du jp jq jr js b">elasticsearch</code>包中该参数的描述。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="adb4" class="kb kc hi js b fi kd ke l kf kg">:arg retry_on_conflict: Specify how many times should the operation be<br/>            retried when a conflict occurs (default: 0)</span></pre><p id="ad37" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我很乐意听到你对此的反馈，如果你对这篇文章有任何问题/建议，你可以在推特上联系我。</p></div></div>    
</body>
</html>