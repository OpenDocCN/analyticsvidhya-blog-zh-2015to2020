<html>
<head>
<title>Lexicographic permutation generation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">词典排列生成</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/lexicographic-permutation-generation-4040e240900c?source=collection_archive---------9-----------------------#2020-04-04">https://medium.com/analytics-vidhya/lexicographic-permutation-generation-4040e240900c?source=collection_archive---------9-----------------------#2020-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1d07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从“什么是排列和字典序”这个问题开始。。这是一个二合一问题。假设您有三个不同颜色的球-红色、绿色和蓝色，您想以所有可能的方式排列它们，以便每个新的排列都与之前的输出不同，如下图所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/ab179fae47d8e2345d39de022456fb8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:240/format:webp/1*ULaaXFe9936pfFFOy0g0vA.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">维基百科(一个基于wiki技术的多语言的百科全书协作计划ˌ也是一部用不同语言写成的网络百科全书ˌ 其目标及宗旨是为全人类提供自由的百科全书)ˌ开放性的百科全书</figcaption></figure><p id="d540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在某种意义上是排列。用数学术语来说，它是一个集合的元素在一个序列中的排列。另一方面，词典编纂是基于单词组成字母的字母顺序(借用自<a class="ae jp" href="https://en.wikipedia.org/wiki/Lexicographical_order" rel="noopener ugc nofollow" target="_blank">维基百科</a>)对单词进行字母排序的方式的生成。</p><p id="b242" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们的重点不是这些术语的理论部分，而是实际部分，以及如何使用计算机科学中的算法来生成它们。</p><p id="f99e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">字典序生成的概念是组合学中一个有趣的话题，我们将在这里研究如何生成它们。当按字典顺序生成排列时，我们需要记住一些事情。</p><ol class=""><li id="ad1f" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">不同物体的数量——在我们的例子中是上面的球<em class="jz"> (n)。</em></li><li id="7778" class="jq jr hi ih b ii ka im kb iq kc iu kd iy ke jc jv jw jx jy bi translated">要生成的排列数，即<em class="jz"> n </em>阶乘<em class="jz"> (n！)</em>。</li><li id="b036" class="jq jr hi ih b ii ka im kb iq kc iu kd iy ke jc jv jw jx jy bi translated">对于字典序，给定两个长度相同的序列<em class="jz"> n，</em>T10】a1，a2，…，an 和<em class="jz"> b1，b2，…，bn </em>。第一个比第二个小，如果<em class="jz">ai&lt;bi(0≤I&lt;n)</em>为第一个<em class="jz"> i </em>其中<em class="jz"> ai </em>和<em class="jz"> bi </em>是序列的不同成员。</li></ol><p id="5e0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住这一点，让我们用一种更高级的编程语言(Python)为这个想法写一个算法。我们要写两个算法。一个是简单的，效率较低的，第二个是优雅的，速度更快的版本。我们将看到如何从时间复杂度的角度来分析这两者。</p><p id="5a5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从生成所有排列的第一个经典方法开始，按字典顺序访问它们。我们在一个序列中有<em class="jz"> n </em>个元素<em class="jz"> {a1，a2，…，an} </em>初始排序，使得<em class="jz"> a1 ≤ a2 ≤ … an。</em></p><p id="7a95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法将使用<em class="jz"> {ABCD} </em>作为我们的测试用例。和函数名；<em class="jz">第一种算法使用字典序_perms() </em>，第二种算法使用<em class="jz">字典序_perms() </em>。</p><p id="af8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一部分:算法1 </strong></p><p id="21e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[步骤1:检查<em class="jz"> n </em>确定n是否≤ 1。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="f9bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【第二步:拜访并找到<em class="jz"> j </em>拜访排列<em class="jz"> a1，a2 … an </em>并找到<em class="jz"> j </em>。设置<em class="jz"> j = last -1 </em>。我们使用最后的<em class="jz">而不是<em class="jz"> n </em>，因为我们的算法使用零索引。如果<em class="jz"> aj ≥ aj+1 </em>，我们将<em class="jz"> j </em>减1，直到<em class="jz"> j </em>能够满足<em class="jz"> aj &lt; aj+1 </em>。如果j &lt; 0，这意味着我们已经访问了所有的排列，算法终止。</em></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="1e0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【第三步:增加<em class="jz"> aj </em>找到j后，我们知道<em class="jz"> aj </em>是当前排列中最小的下标，因此为了得到下一个字典式排列，<em class="jz"> aj </em>必须增加如下。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="d9a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【第四步:倒车<em class="jz"> aj+1 …安</em>互换<em class="jz"> aj+1 ← →安。</em>然后最后拿出放值。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="8275" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用out测试用例{ABCD}的简单输出；</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kh"><img src="../Images/ff43f07db525431b8115704f8b70c99a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*R1uWEF3mQWQK8TsOo1WzBQ.png"/></div></figure><p id="7b6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一节将集中在使前面的算法在大的<em class="jz"> n </em>或任何<em class="jz"> n </em>上快一点。当元素都不同时，前一个过程的步骤2找到一半时间的<em class="jz"> j = last - 1 </em>。因此，这个特例将在下一节中帮助我们加速算法。</p><p id="01a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二部分:算法2 </strong></p><p id="c03a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[步骤1:与上一步相同]</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="153d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[第二步:检查并置换所有的<em class="jz"> n </em>和<em class="jz">n-1</em>；最简单的情况]设置<em class="jz"> y = an-1 </em>，<em class="jz"> z = an </em>，如果<em class="jz"> y &lt; z </em>则进行检查和互换。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="3328" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[步骤3:y≥z时的下一个最容易的情况]设置<em class="jz"> x = an-2 </em>(到倒数第二个元素)并对照<em class="jz"> y </em>检查<em class="jz"> x </em>。这一步，我们将处理<em class="jz"> x ≥ y </em>的情况。</p><p id="480f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[步骤3.1:查找j]设置<em class="jz"> j = last - 3 </em>并用<em class="jz"> y = aj更新<em class="jz"> y </em>。</em></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="bf3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[步骤3.2:轻松增加]检查新的<em class="jz"> y &lt; z </em>是否。如果是这样，用<em class="jz"> z </em>更新<em class="jz"> aj </em>并用<em class="jz"> y </em> an用<em class="jz"> x. </em>更新<em class="jz"> aj+1 </em></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="34f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【步骤else部分】如果x &lt; y then we perform this step. It basically does the interchange of<em class="jz"> an-2，an-1，an </em>具有正确的值<em class="jz"> x，y，z </em>如下图所示。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="04a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[步骤4:开始反向操作]这发生在上面的else块的下面。运行完以上所有步骤后。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="b549" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[步骤5:最后一次反转]这确保了我们有正确的词典生成的置换。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="4684" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至此我们有了一个完整的算法，可以正确生成所有的<em class="jz"> n！</em>按字典顺序排列。注意，第2部分的输出与第1部分相同。</p><p id="c654" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们检查一下第二种算法的运行速度有多快。根据下面的输出，我们可以推断算法2比算法1快两倍。这是由于我们之前观察到<em class="jz"> j = last - 1 </em>有一半时间是执行的，也就是<em class="jz"> n！/2.</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kh"><img src="../Images/56e46703adb830a7d5b0f4301c17d9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*6WKS9wfco4VCBAxU4qey6Q.png"/></div></div></figure><p id="4244" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong></p><ul class=""><li id="eaa8" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc km jw jx jy bi translated"><a class="ae jp" href="https://en.wikipedia.org/wiki/Permutation" rel="noopener ugc nofollow" target="_blank">排列</a></li><li id="8ee6" class="jq jr hi ih b ii ka im kb iq kc iu kd iy ke jc km jw jx jy bi translated"><a class="ae jp" href="https://en.wikipedia.org/wiki/Lexicographical_order" rel="noopener ugc nofollow" target="_blank">词典编纂顺序</a></li><li id="7741" class="jq jr hi ih b ii ka im kb iq kc iu kd iy ke jc km jw jx jy bi translated">Donald e . Knuth——计算机编程的艺术，第4卷，分册2_生成所有元组和排列——Addison-Wesley Professional(2005)</li><li id="c500" class="jq jr hi ih b ii ka im kb iq kc iu kd iy ke jc km jw jx jy bi translated">罗伯特·塞奇威克的排列生成方法</li></ul></div></div>    
</body>
</html>