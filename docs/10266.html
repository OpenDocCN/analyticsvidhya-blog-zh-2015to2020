<html>
<head>
<title>Creating RESTful services with Go — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Go 创建 RESTful 服务—第 2 部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-restful-services-with-go-part-2-1fc89b76f03f?source=collection_archive---------10-----------------------#2020-10-11">https://medium.com/analytics-vidhya/creating-restful-services-with-go-part-2-1fc89b76f03f?source=collection_archive---------10-----------------------#2020-10-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/736b429aabc23b846d951c9920c01731.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*FD7WOYaGpVMUyA52tjIxGg.png"/></div></figure><p id="6f39" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">在这篇博客中，我们将构建一个完全成熟的 REST API </strong>,它公开 GET、POST、DELETE 和 PUT 端点，这将允许您执行所有的 CRUD 操作。正如在<a class="ae jk" rel="noopener" href="/swlh/creating-microservices-with-go-part-1-2f9aff360db5">上一篇文章</a>中提到的，博客系列将封装一个生产就绪的项目。因此，博客的这一部分将为网上咖啡店打下基础。</p><p id="bf1a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这部分博客的代码将在这里托管:<a class="ae jk" href="https://github.com/nandangrover/go-microservices" rel="noopener ugc nofollow" target="_blank">https://github.com/nandangrover/go-microservices</a>。这个系列的第二部分，也就是这个博客的文档可以在这个<a class="ae jk" href="https://github.com/nandangrover/go-microservices/tree/restful_services_2" rel="noopener ugc nofollow" target="_blank">分支</a>中找到。</p><p id="8aa6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了保持简单并专注于基本概念，我们将不与任何后端数据库技术交互来存储我们将要使用的产品。然而，我们将以这样一种方式编写这个 REST API，它将很容易更新我们将定义的函数，以便它们对数据库进行后续调用来执行任何必要的 CRUD 操作。</p><h1 id="925b" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">RESTful 服务有哪些？</h1><p id="8a3e" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">REST 是一种设计 web 服务的架构方法。REST APIs 是围绕<em class="ko">资源</em>设计的，这些资源是客户端可以访问的任何类型的对象、数据或服务。一个资源有一个<em class="ko">标识符</em>，它是唯一标识该资源的 URI。例如，特定客户订单的 URI 可能是:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="2a92" class="ky jm hi ku b fi kz la l lb lc"><a class="ae jk" href="https://adventure-works.com/orders/1" rel="noopener ugc nofollow" target="_blank">https://adventure-works.com/orders/1</a></span></pre><p id="375c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">客户端通过交换资源的<em class="ko">表示</em>与服务进行交互。许多 web APIs 使用 JSON(当然，这不是必需的)作为交换格式。例如，对上面列出的 URI 的 GET 请求可能会返回以下响应正文:</p><p id="21b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du ld le lf ku b">{"orderId":1,"orderValue":99.90,"productId":1,"quantity":1}</code></p><p id="5d1c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">HTTP 协议定义了几种为请求分配语义的方法。大多数 RESTful web APIs 使用的常见 HTTP 方法有:</p><ul class=""><li id="1229" class="lg lh hi io b ip iq it iu ix li jb lj jf lk jj ll lm ln lo bi translated"><strong class="io hj"> GET </strong>在指定的 URI 检索资源的表示。响应消息的正文包含所请求资源的详细信息。</li><li id="736c" class="lg lh hi io b ip lp it lq ix lr jb ls jf lt jj ll lm ln lo bi translated">在指定的 URI 创建一个新的资源。请求消息的主体提供了新资源的详细信息。注意，POST 也可以用来触发实际上不创建资源的操作。</li><li id="8b1d" class="lg lh hi io b ip lp it lq ix lr jb ls jf lt jj ll lm ln lo bi translated">在指定的 URI 创建或替换资源。请求消息的主体指定了要创建或更新的资源。</li><li id="14ff" class="lg lh hi io b ip lp it lq ix lr jb ls jf lt jj ll lm ln lo bi translated"><strong class="io hj">补丁</strong>执行资源的部分更新。请求主体指定要应用于资源的一组更改。</li><li id="0d8c" class="lg lh hi io b ip lp it lq ix lr jb ls jf lt jj ll lm ln lo bi translated"><strong class="io hj">删除</strong>删除指定 URI 的资源。</li></ul><p id="bb4f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以使用 GraphQL 或 gRPC 架构来构建我们的微服务结构。那我们为什么没有呢？Well REST 实现起来相对简单。在以后的博客中，我会用上面提到的一些技术重新设计后端。</p><h1 id="8fe5" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">文件结构是什么样的？</h1><p id="d008" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">在上一篇博客中，我们添加了两个名为 hello 和 goodbye 的新处理程序。我们不再需要那些了，所以我们已经删除了它们。相反，我们创建了一个名为<strong class="io hj">产品的新处理程序。我们将通过这个处理程序执行 CRUD 操作。因为我们正在创建一个咖啡店，所以我们需要一个存储我们产品的数据存储。<strong class="io hj"> Products.go </strong>将产品的字段存储为 go 结构。</strong></p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/b9d8d926e6070f6dd8e7fa43b7da4e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*kxSW-aPMWwR4GvxbbwjaEg.png"/></div></figure><h1 id="4ea1" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">产品处理程序和数据存储</h1><p id="cebd" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">让我们先看看我们的处理程序。我们首先检查 API 请求的 HTTP 动词，即 GET、POST 和 PUT。我们还编写了关于<strong class="io hj">产品</strong>结构的方法。这些可以被 p.MethodName 调用，这对抽象我们的逻辑和可重用性很有帮助。如果你看看代码的底层结构，你会发现函数式编程的一些原则。<strong class="io hj"> Golang </strong>不是一种<strong class="io hj">函数式</strong>语言，但是它有很多特性，使我们能够在开发中应用<strong class="io hj">函数式</strong>原则，使我们的代码更加优雅、简洁、可维护、易于理解和测试。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="bfb8" class="ky jm hi ku b fi kz la l lb lc">package handlers</span><span id="018c" class="ky jm hi ku b fi lv la l lb lc">import (<br/> "log"<br/> "net/http"<br/> "regexp"<br/> "strconv"</span><span id="9dbe" class="ky jm hi ku b fi lv la l lb lc">"github.com/nandangrover/go-microservices/data"<br/>)</span><span id="9c24" class="ky jm hi ku b fi lv la l lb lc">//Products structure that holds a logger<br/>type Products struct {<br/> l *log.Logger<br/>}</span><span id="8677" class="ky jm hi ku b fi lv la l lb lc">// NewProducts function return the pointer to Products structure<br/>func NewProducts(l *log.Logger) *Products {<br/> return &amp;Products{l}<br/>}</span><span id="d82f" class="ky jm hi ku b fi lv la l lb lc">func (p *Products) ServeHTTP(rw http.ResponseWriter, r *http.Request) {<br/> if r.Method == http.MethodGet {<br/>  p.getProducts(rw, r)<br/>  return<br/> }<br/> if r.Method == http.MethodPost {<br/>  p.addProduct(rw, r)<br/>  return<br/> }<br/> if r.Method == http.MethodPut {<br/>  // expect the id in the URI<br/>  regex := regexp.MustCompile(`/([0-9]+)`)<br/>  group := regex.FindAllStringSubmatch(r.URL.Path, -1)</span><span id="1e2b" class="ky jm hi ku b fi lv la l lb lc">if len(group) != 1 || len(group[0]) != 2 {<br/>   http.Error(rw, "Invalid URI", http.StatusBadRequest)<br/>   return<br/>  }</span><span id="4d9c" class="ky jm hi ku b fi lv la l lb lc">idString := group[0][1]<br/>  // Ignore the error for now<br/>  id, _ := strconv.Atoi(idString)</span><span id="ec5e" class="ky jm hi ku b fi lv la l lb lc">p.updateProducts(id, rw, r)<br/> }<br/> // catch all other http verb with 405<br/> rw.WriteHeader(http.StatusMethodNotAllowed)<br/>}</span><span id="8080" class="ky jm hi ku b fi lv la l lb lc">func (p *Products) getProducts(rw http.ResponseWriter, r *http.Request) {<br/> p.l.Println("Handle GET products")</span><span id="637b" class="ky jm hi ku b fi lv la l lb lc">listOfProducts := data.GetProducts()<br/> // Use encoder as it is marginally faster than json.marshal. It's important when we use multiple threads<br/> // d, err := json.Marshal(listOfProducts)<br/> err := listOfProducts.ToJSON(rw)<br/> if err != nil {<br/>  http.Error(rw, "Unable to marshal json", http.StatusInternalServerError)<br/> }<br/>}</span><span id="0c18" class="ky jm hi ku b fi lv la l lb lc">func (p *Products) addProduct(rw http.ResponseWriter, r *http.Request) {<br/> p.l.Println("Handle POST product")</span><span id="8461" class="ky jm hi ku b fi lv la l lb lc">prod := &amp;data.Product{}<br/> // The reason why we use a buffer reader is so that we don't have to allocate all the memory instantly to a slice or something like that,<br/> err := prod.FromJSON(r.Body)<br/> if err != nil {<br/>  http.Error(rw, "Unable to unmarshal json", http.StatusBadRequest)<br/> }<br/> // p.l.Printf("Prod %#v", prod)<br/> data.AddProduct(prod)<br/>}</span><span id="1d63" class="ky jm hi ku b fi lv la l lb lc">func (p *Products) updateProducts(id int, rw http.ResponseWriter, r *http.Request) {<br/> p.l.Println("Handle Put product")</span><span id="c4e5" class="ky jm hi ku b fi lv la l lb lc">prod := &amp;data.Product{}<br/> // The reason why we use a buffer reader is so that we don't have to allocate all the memory instantly to a slice or something like that,<br/> err := prod.FromJSON(r.Body)<br/> if err != nil {<br/>  http.Error(rw, "Unable to unmarshal json", http.StatusBadRequest)<br/> }</span><span id="0f21" class="ky jm hi ku b fi lv la l lb lc">err = data.UpdateProduct(id, prod)<br/> if err == data.ErrProductNotFound {<br/>  http.Error(rw, "Product not found", http.StatusNotFound)<br/>  return<br/> }</span><span id="a872" class="ky jm hi ku b fi lv la l lb lc">if err != nil {<br/>  http.Error(rw, "Product not found", http.StatusInternalServerError)<br/>  return<br/> }</span><span id="1a0e" class="ky jm hi ku b fi lv la l lb lc">}</span></pre><p id="5cce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">我们产品的数据存储</strong>定义了每个咖啡店产品的结构。我们需要导出产品，因此产品结构中的每个键都需要有一个大写的第一个字符。</p><p id="1730" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们还在这个文件中存储了一些 helper 实用程序方法，比如 ToJSON 和 FromJSON。这些方法有助于将我们的产品结构转换成 JSON，反之亦然。抽象在这里肯定是可能的，但是我们将在下一篇博客中更多地讨论它。</p><p id="3a17" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，我们还有一个变量<strong class="io hj"> productList </strong>，它存储了对 Product struct 的一部分引用。在切片内部，我们添加了一些虚拟数据，可以用来执行 CRUD 操作。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="ae2a" class="ky jm hi ku b fi kz la l lb lc">package data</span><span id="0f01" class="ky jm hi ku b fi lv la l lb lc">import (<br/> "encoding/json"<br/> "fmt"<br/> "io"<br/> "time"<br/>)</span><span id="e997" class="ky jm hi ku b fi lv la l lb lc">//Product defines the structure for an API product<br/>//Since encoding/json is a package residing outside our package we need to uppercase the first character of the fields inside the structure<br/>//To get nice json field names we can add struct tags though. This will output the key name as the tag name<br/>type Product struct {<br/> ID          int     `json:"id"`<br/> Name        string  `json:"name"`<br/> Description string  `json:"description"`<br/> Price       float32 `json:"price"`<br/> SKU         string  `json:"sku"`<br/> CreatedOn   string  `json:"-"`<br/> UpdatedOn   string  `json:"-"`<br/> DeletedOn   string  `json:"-"`<br/>}</span><span id="a9bf" class="ky jm hi ku b fi lv la l lb lc">// Products is a type defining slice of struct Product<br/>type Products []*Product</span><span id="b7e9" class="ky jm hi ku b fi lv la l lb lc">// ToJSON is a Method on type Products (slice of Product), used to covert structure to JSON<br/>func (p *Products) ToJSON(w io.Writer) error {<br/> // NewEncoder requires an io.Reader. http.ResponseWriter is the same thing<br/> encoder := json.NewEncoder(w)<br/> return encoder.Encode(p)<br/>}</span><span id="a82c" class="ky jm hi ku b fi lv la l lb lc">// FromJSON is a Method on type Products (slice of Product)<br/>func (p *Product) FromJSON(r io.Reader) error {<br/> decoder := json.NewDecoder(r)<br/> return decoder.Decode(p)<br/>}</span><span id="2e45" class="ky jm hi ku b fi lv la l lb lc">//GetProducts - Return the product list<br/>func GetProducts() Products {<br/> return productList<br/>}</span><span id="19a3" class="ky jm hi ku b fi lv la l lb lc">//AddProduct - Add the product to our struct Product<br/>func AddProduct(p *Product) {<br/> p.ID = getNextID()<br/> productList = append(productList, p)<br/>}</span><span id="60bf" class="ky jm hi ku b fi lv la l lb lc">//UpdateProduct - Updates the product to our struct Product<br/>func UpdateProduct(id int, p *Product) error {<br/> _, pos, err := findProduct(id)<br/> if err != nil {<br/>  return err<br/> }</span><span id="85af" class="ky jm hi ku b fi lv la l lb lc">p.ID = id<br/> productList[pos] = p</span><span id="c1f2" class="ky jm hi ku b fi lv la l lb lc">return nil<br/>}</span><span id="c8ce" class="ky jm hi ku b fi lv la l lb lc">func findProduct(id int) (*Product, int, error) {<br/> for i, p := range productList {<br/>  if p.ID == id {<br/>   return p, i, nil<br/>  }<br/> }<br/> return nil, -1, ErrProductNotFound<br/>}</span><span id="87ec" class="ky jm hi ku b fi lv la l lb lc">// ErrProductNotFound is the Standard Product not found error structure<br/>var ErrProductNotFound = fmt.Errorf("Product not found")</span><span id="8ed2" class="ky jm hi ku b fi lv la l lb lc">// Increments the Product ID by one<br/>func getNextID() int {<br/> lastProduct := productList[len(productList)-1]<br/> return lastProduct.ID + 1<br/>}</span><span id="531e" class="ky jm hi ku b fi lv la l lb lc">var productList = []*Product{<br/> &amp;Product{<br/>  ID:          1,<br/>  Description: "Latte",<br/>  Name:        "Milky coffee",<br/>  SKU:         "abc323",<br/>  Price:       200,<br/>  UpdatedOn:   time.Now().UTC().String(),<br/>  CreatedOn:   time.Now().UTC().String(),<br/> },<br/> &amp;Product{<br/>  ID:          2,<br/>  Description: "Expresso",<br/>  Name:        "Strong coffee",<br/>  SKU:         "errfer",<br/>  Price:       150,<br/>  UpdatedOn:   time.Now().UTC().String(),<br/>  CreatedOn:   time.Now().UTC().String(),<br/> },<br/>}</span></pre><h1 id="7863" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">检索产品—获取</h1><p id="20f4" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">要检索我们的产品，我们可以通过基于 Unix 的终端以这种方式发送请求:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="a580" class="ky jm hi ku b fi kz la l lb lc">curl -v localhost:9090 | jq</span></pre><blockquote class="lw lx ly"><p id="516e" class="im in ko io b ip iq ir is it iu iv iw lz iy iz ja ma jc jd je mb jg jh ji jj hb bi translated">jq 有助于格式化响应。</p></blockquote><p id="2775" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">products.go 处理程序根据这个请求被激活。在 ServeHTTP 方法中，我们编写了一个 if 条件，用于检查 HTTP 请求的 HTTP 谓词。MethodGet，本质上就是字符串“Get”。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="0487" class="ky jm hi ku b fi kz la l lb lc">if r.Method == http.MethodGet {<br/>  p.getProducts(rw, r)<br/>  return<br/> }</span></pre><p id="3aec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于 GET 请求，依次调用<strong class="io hj"> getproducts() </strong>方法。我们向该方法发送 HTTP ResponseWriter 和请求。这个方法反过来从我们的数据存储中获取<strong class="io hj">产品列表</strong>切片。因为它是一个片，我们使用定义在类型 Products 上的 to JSON 实用程序方法将它转换成 JSON，它是 struct Product 的一个片。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="6b85" class="ky jm hi ku b fi kz la l lb lc">func (p *Products) getProducts(rw http.ResponseWriter, r *http.Request) {<br/> p.l.Println("Handle GET products")</span><span id="a013" class="ky jm hi ku b fi lv la l lb lc">listOfProducts := data.GetProducts()<br/> // Use encoder as it is marginally faster than json.marshal. It's important when we use multiple threads<br/> // d, err := json.Marshal(listOfProducts)<br/> err := listOfProducts.ToJSON(rw)<br/> if err != nil {<br/>  http.Error(rw, "Unable to marshal json", http.StatusInternalServerError)<br/> }<br/>}</span></pre><p id="b884" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Encode 将 v 的 JSON 编码写入流中，后跟一个换行符。我们本可以使用<strong class="io hj"> json。元帅</strong>在这里，但是我们没有。编码器和解码器将 struct 写入流的切片，或者从流的切片中读取数据并将其转换为 struct。在内部，它还实现了 marshal 方法。唯一的区别是，如果您想要处理字符串或字节，请使用 marshal，如果您想要读取或写入某些编写器接口(如我们的 ResoponseWriter)的任何数据，请使用 encodes 和 decode。这反过来也更快。我们不会注意到单个 API 调用的任何速度差异，但是使用编码器而不是封送器可以更好地处理成千上万个并发的 API 调用。你可以在这里阅读更多关于编码/json 包<a class="ae jk" href="https://golang.org/pkg/encoding/json/#Encoder" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="17be" class="ky jm hi ku b fi kz la l lb lc">// ToJSON is a Method on type Products (slice of Product), used to covert structure to JSON<br/>func (p *Products) ToJSON(w io.Writer) error {<br/> // NewEncoder requires an io.Reader. http.ResponseWriter is the same thing<br/> encoder := json.NewEncoder(w)<br/> return encoder.Encode(p)<br/>}</span></pre><p id="62fd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，该编码器将我们的响应写入 ResponseWriter。我们的 API 调用的最终输出如下所示:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="de43" class="ky jm hi ku b fi kz la l lb lc">[<br/>  {<br/>    "id": 1,<br/>    "name": "Milky coffee",<br/>    "description": "Latte",<br/>    "price": 200,<br/>    "sku": "abc323"<br/>  },<br/>  {<br/>    "id": 2,<br/>    "name": "Strong coffee",<br/>    "description": "Expresso",<br/>    "price": 150,<br/>    "sku": "errfer"<br/>  }<br/>]</span></pre><h1 id="a44f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">添加新产品—帖子</h1><p id="9805" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">要添加新产品，我们可以通过基于 Unix 的终端以这种方式发送请求:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="4e39" class="ky jm hi ku b fi kz la l lb lc">curl -v localhost:9090 -XPOST -d {"name": "Tea", "description": "Cuppa Tea", "price": 10}</span></pre><p id="7646" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">添加产品的结构类似于获取产品。我们遵循相同的数据传输流程:处理程序到数据存储。处理程序识别 HTTP 动词并调用适当的方法，即<strong class="io hj"> addProduct </strong>。</p><p id="1b1f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个方法反过来创建了一个对我们的产品结构的引用，它定义了我们产品的结构。在请求体中收到的 JSON 数据被发送到来自 JSON 的实用程序方法，以将其解码成对我们定义的结构(即产品)的结构化引用。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="aa44" class="ky jm hi ku b fi kz la l lb lc">func (p *Products) addProduct(rw http.ResponseWriter, r *http.Request) {<br/> p.l.Println("Handle POST product")</span><span id="ca95" class="ky jm hi ku b fi lv la l lb lc">prod := &amp;data.Product{}<br/> // The reason why we use a buffer reader is so that we don't have to allocate all the memory instantly to a slice or something like that,<br/> err := prod.FromJSON(r.Body)<br/> if err != nil {<br/>  http.Error(rw, "Unable to unmarshal json", http.StatusBadRequest)<br/> }<br/> // p.l.Printf("Prod %#v", prod)<br/> data.AddProduct(prod)<br/>}</span></pre><p id="93f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们已经将产品存储为对 struct 产品的引用，我们将它附加到我们的<strong class="io hj"> productList </strong>片，它作为我们的临时数据库存储。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="4832" class="ky jm hi ku b fi kz la l lb lc">func AddProduct(p *Product) {<br/> p.ID = getNextID()<br/> productList = append(productList, p)<br/>}</span></pre><p id="8b68" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为我们的产品生成一个新的 id，并将其附加到我们的切片中。如果我们向我们的产品 API 发送 GET 请求，我们将看到现在列出了 3 个产品，而不是 2 个。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="b6ce" class="ky jm hi ku b fi kz la l lb lc">[<br/>  {<br/>    "id": 1,<br/>    "name": "Milky coffee",<br/>    "description": "Latte",<br/>    "price": 200,<br/>    "sku": "abc323"<br/>  },<br/>  {<br/>    "id": 2,<br/>    "name": "Strong coffee",<br/>    "description": "Expresso",<br/>    "price": 150,<br/>    "sku": "errfer"<br/>  },</span><span id="1133" class="ky jm hi ku b fi lv la l lb lc">{<br/>    "id": 3,<br/>    "name": "Tea",<br/>    "description": "Cuppa Tea",<br/>    "price": 10<br/>  }<br/>]</span></pre><h1 id="2c96" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">更新现有产品—上传</h1><p id="2d19" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">要更新现有产品，我们可以通过基于 Unix 的终端以这种方式发送请求:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="2227" class="ky jm hi ku b fi kz la l lb lc">curl -v localhost:9090/2 -XPUT -d {"name": "Frappuccino", "description": "Cuppa frappuccino", "price": 100}</span></pre><p id="ab17" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">更新产品的结构类似于获取产品。我们遵循相同的数据传输流程:处理程序到数据存储。处理程序识别 HTTP 动词并调用适当的方法，即<strong class="io hj"> updateProducts </strong>。</p><p id="4948" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">PUT 请求比简单的 POST 或 GET 更难解析，因为我们必须从 URI 中提取请求的 ID。我们如何做到这一点？我们使用一些正则表达式。</p><p id="c246" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为我们的 ID 是一个数字，所以我们编写一个 regexp 来搜索一组可以重复的数字(0–9 ),用+标记表示。在运行 FindAllStringSubmatch 时，如果我们获得一个成功的匹配，匹配的字符串驻留在一个多维数组中。我们从索引[0][1]中提取必要的组。我将由您来决定为什么索引驻留在[1]而不是[0]中。</p><p id="639e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Regexp 非常有趣，在很多方面都很有帮助。你可以在这里阅读更多关于 Golang 标准图书馆提供的方法。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="cc62" class="ky jm hi ku b fi kz la l lb lc">if r.Method == http.MethodPut {<br/>  // expect the id in the URI<br/>  regex := regexp.MustCompile(`/([0-9]+)`)<br/>  group := regex.FindAllStringSubmatch(r.URL.Path, -1)</span><span id="e3fb" class="ky jm hi ku b fi lv la l lb lc">if len(group) != 1 || len(group[0]) != 2 {<br/>   http.Error(rw, "Invalid URI", http.StatusBadRequest)<br/>   return<br/>  }</span><span id="2ba2" class="ky jm hi ku b fi lv la l lb lc">idString := group[0][1]<br/>  // Ignore the error for now<br/>  id, _ := strconv.Atoi(idString)</span><span id="aa4d" class="ky jm hi ku b fi lv la l lb lc">p.updateProducts(id, rw, r)<br/> }</span></pre><p id="37fa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们有了需要更新的产品 id，我们可以从请求体中提取更新的信息。</p><p id="701d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将把我们身体中的产品信息解码成指向数据存储中产品的结构引用。这个步骤类似于 POST 请求。我们的数据存储中的<strong class="io hj"> UpdateProduct </strong>方法被称为 next。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="abea" class="ky jm hi ku b fi kz la l lb lc">func (p *Products) updateProducts(id int, rw http.ResponseWriter, r *http.Request) {<br/> p.l.Println("Handle Put product")</span><span id="f60c" class="ky jm hi ku b fi lv la l lb lc">prod := &amp;data.Product{}<br/> // The reason why we use a buffer reader is so that we don't have to allocate all the memory instantly to a slice or something like that,<br/> err := prod.FromJSON(r.Body)<br/> if err != nil {<br/>  http.Error(rw, "Unable to unmarshal json", http.StatusBadRequest)<br/> }</span><span id="86a5" class="ky jm hi ku b fi lv la l lb lc">err = data.UpdateProduct(id, prod)<br/> if err == data.ErrProductNotFound {<br/>  http.Error(rw, "Product not found", http.StatusNotFound)<br/>  return<br/> }</span><span id="2636" class="ky jm hi ku b fi lv la l lb lc">if err != nil {<br/>  http.Error(rw, "Product not found", http.StatusInternalServerError)<br/>  return<br/> }</span><span id="a240" class="ky jm hi ku b fi lv la l lb lc">}</span></pre><p id="751c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要更新我们的产品，我们需要先找到它。这是一件好事，我们有来自 URI 的 ID，因为这是我们产品的唯一唯一标识符。我们通过迭代我们的<strong class="io hj"> productList </strong>切片并返回产品引用、它在切片中的索引和一个错误(如果找到了产品，则返回零)来实现这一点。我们使用这个索引(pos 是这个索引的变量名)，用在请求体中收到的 JSON 替换引用(显然它现在被解码为对 product struct 的引用)。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="7cdd" class="ky jm hi ku b fi kz la l lb lc">//UpdateProduct - Updates the product to our struct Product<br/>func UpdateProduct(id int, p *Product) error {<br/> _, pos, err := findProduct(id)<br/> if err != nil {<br/>  return err<br/> }</span><span id="43db" class="ky jm hi ku b fi lv la l lb lc">p.ID = id<br/> productList[pos] = p</span><span id="8e9a" class="ky jm hi ku b fi lv la l lb lc">return nil<br/>}</span><span id="fe86" class="ky jm hi ku b fi lv la l lb lc">func findProduct(id int) (*Product, int, error) {<br/> for i, p := range productList {<br/>  if p.ID == id {<br/>   return p, i, nil<br/>  }<br/> }<br/> return nil, -1, ErrProductNotFound<br/>}</span></pre><p id="70f5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">索引 2 处的产品现在应该已经更新了。如果我们向我们的产品 API 发送一个 GET 请求，我们将看到第二个产品用新值进行了更新。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="8223" class="ky jm hi ku b fi kz la l lb lc">[<br/>  {<br/>    "id": 1,<br/>    "name": "Milky coffee",<br/>    "description": "Latte",<br/>    "price": 200,<br/>    "sku": "abc323"<br/>  },<br/>  {<br/>    "id": 2,<br/>    "name": "Frappuccino",<br/>    "description": "Cuppa Frappuccino",<br/>    "price": 100,<br/>    "sku": "errfer"<br/>  },</span><span id="cf08" class="ky jm hi ku b fi lv la l lb lc">{<br/>    "id": 3,<br/>    "name": "Tea",<br/>    "description": "Cuppa Tea",<br/>    "price": 10<br/>  }<br/>]</span></pre><h1 id="0db8" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">下一步是什么？</h1><p id="a199" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">我们将研究臭名昭著的大猩猩框架，也许还有一些很酷的 swagger 文档技术。我们还将在下一篇博客中研究如何处理文件。单元测试和全面的数据库集成显然即将到来，但我们将首先考虑建立一个强大的基础。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="2c19" class="jl jm hi bd jn jo mj jq jr js mk ju jv jw ml jy jz ka mm kc kd ke mn kg kh ki bi translated">参考</h1><ul class=""><li id="11d2" class="lg lh hi io b ip kj it kk ix mo jb mp jf mq jj ll lm ln lo bi translated">代码库:<a class="ae jk" href="https://github.com/nandangrover/go-microservices" rel="noopener ugc nofollow" target="_blank">https://github.com/nandangrover/go-microservices</a></li><li id="4bda" class="lg lh hi io b ip lp it lq ix lr jb ls jf lt jj ll lm ln lo bi translated">第二部分 GitHub 链接:<a class="ae jk" href="https://github.com/nandangrover/go-microservices/tree/restful_services_2" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/nandang rover/go-micro services/tree/restful _ services _ 2</a></li><li id="6215" class="lg lh hi io b ip lp it lq ix lr jb ls jf lt jj ll lm ln lo bi translated">Golang 的 Freecodecamp 教程:<a class="ae jk" href="https://www.youtube.com/watch?v=YS4e4q9oBaU&amp;ab_channel=freeCodeCamp.org" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=YS4e4q9oBaU&amp;ab _ channel = freecodecamp . org</a></li><li id="3d11" class="lg lh hi io b ip lp it lq ix lr jb ls jf lt jj ll lm ln lo bi translated">Rest API 设计原则:<a class="ae jk" href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/architecture/best-practices/API-design</a></li><li id="382f" class="lg lh hi io b ip lp it lq ix lr jb ls jf lt jj ll lm ln lo bi translated">JSON 包 Golang:<a class="ae jk" href="https://golang.org/pkg/encoding/json/" rel="noopener ugc nofollow" target="_blank">https://golang.org/pkg/encoding/json/</a></li><li id="3040" class="lg lh hi io b ip lp it lq ix lr jb ls jf lt jj ll lm ln lo bi translated">https://golang.org/pkg/regexp/<a class="ae jk" href="https://golang.org/pkg/regexp/" rel="noopener ugc nofollow" target="_blank"/></li></ul></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><div class="kp kq kr ks fd mr"><a rel="noopener follow" target="_blank" href="/swlh/creating-microservices-with-go-part-1-2f9aff360db5"><div class="ms ab dw"><div class="mt ab mu cl cj mv"><h2 class="bd hj fi z dy mw ea eb mx ed ef hh bi translated">使用 Go 创建微服务-第 1 部分</h2><div class="my l"><h3 class="bd b fi z dy mw ea eb mx ed ef dx translated">来自 JavaScript 背景，我一直想学习一门静态类型的编程语言，早些时候…</h3></div><div class="mz l"><p class="bd b fp z dy mw ea eb mx ed ef dx translated">medium.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ik mr"/></div></div></a></div></div></div>    
</body>
</html>