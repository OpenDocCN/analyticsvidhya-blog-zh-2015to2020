<html>
<head>
<title>Parallelism(and concurrency) in Node.js and Python and Golang and comparison them — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js、Python和Golang中的并行性(和并发性)及其比较—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/parallelism-and-concurrency-in-node-js-and-python-and-golang-and-comparison-them-part-1-44c837988c43?source=collection_archive---------11-----------------------#2020-03-28">https://medium.com/analytics-vidhya/parallelism-and-concurrency-in-node-js-and-python-and-golang-and-comparison-them-part-1-44c837988c43?source=collection_archive---------11-----------------------#2020-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们谈论并行和并发编程时，学习和正确使用它看起来有点困难。你需要学习许多主题，学习起来可能会很恐怖，我想谈谈它的亮点，这篇文章使你能够在你想使用并行和并发编程时正确使用，你应该注意哪些<strong class="ih hj">主题</strong>？还有<strong class="ih hj">你怎样才能写出一个高效的程序</strong>？。最后，我们在Node.js、Python和Golang中查看它，然后进行比较</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/96848e07530cc15326ee11a3877cec71.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*BWrdPcX2X8glpX_d_shWVw.jpeg"/></div></figure><p id="ac90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们简单地看一下我们将要谈论的话题:</p><ul class=""><li id="f26b" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">多处理器结构</li><li id="05be" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">过程</li><li id="5b11" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">线</li><li id="a62a" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">协同程序</li><li id="fe30" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">并行与并发</li><li id="ec92" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">存储器组织</li><li id="7796" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">并行编程模型</li><li id="f173" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">Node.js中的并行性(和并发性)</li><li id="1d6b" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">Python中的并行性(和并发性)</li><li id="95cc" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">Golang中的并行(和并发)</li></ul><h1 id="541f" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">多处理器结构</h1><p id="7b2c" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">首先，我们来看看CPU</p><p id="5b0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">中央处理器负责执行进程。在底层，每个进程都有特定的命令，并发送给CPU执行(大概你说CPU把它们摘下来运行，这是你的想法:)。</p><p id="b51c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi lc translated"><span class="l ld le lf bm lg lh li lj lk di"> F </span> etch: CPU从寄存器(类似内存)中获取数据和指令</p><p id="3a17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi lc translated">解码:解码指令</p><p id="7879" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi lc translated">E  xecute:对数据执行指令，操作结果存储在另一个寄存器中</p><p id="43c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个处理器可以执行关于其类别的指令。<a class="ae ll" href="https://en.wikipedia.org/wiki/Michael_J._Flynn" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">弗林</strong> </a> <strong class="ih hj">分类法</strong>在四个部分中定义了多处理器</p><ul class=""><li id="3944" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">SISD处理器一次可以处理一条指令和一段数据。这种结构不支持并行编程</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lm"><img src="../Images/814dd43fb3099438576f20e755aa7014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pd_yOXh9gvps9iitd6yFA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">单一指令，单一数据</figcaption></figure><ul class=""><li id="462d" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated"><strong class="ih hj"> SIMD </strong> <br/>这种结构适合计算类似数组和链表的并行数据结构。</li><li id="4a20" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated"><strong class="ih hj"> MISD </strong></li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lv"><img src="../Images/1e3de94d6a9d089bb38e24c82251faf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qEv8IjKOHiMb92nlQba6-A.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated"><em class="lw">多指令，单数据</em></figcaption></figure><ul class=""><li id="f256" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated"><strong class="ih hj"> MIMD </strong> <em class="lx"> <br/> </em>非常适合排比</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es ly"><img src="../Images/a49ab97c103a0c899d735e1c52dacc3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IU4byF8MwsAgSQyGzm7SSg.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated"><em class="lw">多个指令，多个数据</em></figcaption></figure><blockquote class="lz ma mb"><p id="22c2" class="if ig lx ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">注意:如果你正在写一个并行程序，你应该知道处理器的种类。</p></blockquote><h1 id="82cf" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">过程</h1><p id="c2e4" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">该进程是运行在内存中的代码的实时实例。在OOP中，当你创建一个实例时，一个类是一个死的对象，它将是活的。假设您的代码是一个类，进程是该类的一个实例。</p><h1 id="0b72" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">线</h1><p id="8f90" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">线程是一个轻量级进程，它是可由它创建的进程的一部分，每个进程可以创建许多线程，分配给父进程的资源在线程之间共享。如果线程的数量超过一个阈值，程序的效率就会下降，CPU无法处理它们，只能创建线程并在它们之间切换。</p><p id="017e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于线程您应该知道的主题:</p><h2 id="8731" class="mf ka hi bd kb mg mh mi kf mj mk ml kj iq mm mn kn iu mo mp kr iy mq mr kv ms bi translated">线程安全</h2><p id="338c" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">单线程是安全的，但是当你创建多个线程时，如果它们想要相互通信，就需要一个<strong class="ih hj">共享内存</strong>。我将在进程间通信部分谈论它。当不止一个进程继续访问共享内存时，不应该发生争用情况，所有线程在争用情况下都应该是安全的。</p><h2 id="e81d" class="mf ka hi bd kb mg mh mi kf mj mk ml kj iq mm mn kn iu mo mp kr iy mq mr kv ms bi translated">本地线程</h2><p id="3624" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">默认情况下，进程在中创建的所有线程都是本机线程，因为它使用操作系统的功能。有一种方法，当没有操作系统的支持时，你仍然可以创建一个线程，在下一节我会解释它。</p><h2 id="6bd0" class="mf ka hi bd kb mg mh mi kf mj mk ml kj iq mm mn kn iu mo mp kr iy mq mr kv ms bi translated">绿色线</h2><p id="fac5" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">为了使用线程，你的操作系统应该支持它。如果您想在不支持操作系统的情况下使用线程，有一种方法可以让您正在编写代码的宿主语言创建和处理线程。那些线叫绿色线。</p><blockquote class="lz ma mb"><p id="7d37" class="if ig lx ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>绿色线程比本地线程慢</p></blockquote><h2 id="1123" class="mf ka hi bd kb mg mh mi kf mj mk ml kj iq mm mn kn iu mo mp kr iy mq mr kv ms bi translated">纤维线</h2><p id="a0e5" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">纤程是一种由用户创建的Gread线程，可以产生、停止和恢复。它不会阻塞代码并在后台执行。您可以一次调用多个纤程，它们将并发运行。</p><h2 id="4c14" class="mf ka hi bd kb mg mh mi kf mj mk ml kj iq mm mn kn iu mo mp kr iy mq mr kv ms bi translated"><strong class="ak">协程</strong></h2><p id="4e79" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">协程有点像纤程，但它不像线程，就像函数一样，当调用它时，程序的控制器将转移到协程，直到它完成或放弃。</p><h1 id="a995" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">并行与并发</h1><p id="376e" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这个过程可以手动创建，也可以动态创建，我们将在本文的剩余部分讨论这个过程。假设您运行代码的两个实例，这些进程同时运行，但实际上不是并行或并发的，它返回给CPU如何处理进程。CPU使用一些算法来选择一个进程，并在一个称为量程的特定时间内运行，当量程将要完成时，CPU切换到另一个进程。</p><p id="df5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个理解并行和并发之间的区别的例子。</p><p id="6f7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你在读这篇文章的时候，你可能同时在听音乐(<strong class="ih hj">并行</strong>)，突然你的手机上有一条消息，你不得不移动你的头查看手机，在这种情况下，你不能同时读文章和查看手机，这叫并发。当进程(或线程)并发运行时，因为处理器的速度在它们之间切换得很快，所以它们看起来是同时运行的</p><p id="6a2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你的头有两部分，一部分是眼睛，另一部分是耳朵，因此你可以同时读和听，所以我们需要一个以上的处理器或一个带一些内核的处理器来支持并行。</p><h1 id="746e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">存储器组织</h1><h2 id="d1d6" class="mf ka hi bd kb mg mh mi kf mj mk ml kj iq mm mn kn iu mo mp kr iy mq mr kv ms bi translated">访问内存！</h2><p id="d190" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">进程运行需要数据，这些数据存储在内存中，假设只有一个进程正在运行，它可以访问内存而不用担心内存是可访问的。但是，当多个处理器运行多个进程时，根据处理器算法，每个进程都可以在轮到它时运行。如果它们是并发运行的，你不应该担心它们对内存的访问，你应该创建一些共享内存，这样它们都可以在没有竞争条件的情况下访问内存。当不止一个进程运行时，问题就来了，我们应该知道竞争条件(访问进程到<strong class="ih hj">共享内存</strong>)并为每个进程创建本地内存，称为<strong class="ih hj">分布式内存</strong>。</p><blockquote class="lz ma mb"><p id="8684" class="if ig lx ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong>要知道内存速度要和CPU速度兼容因为比CPU慢，想想就知道了…</p></blockquote><h2 id="6781" class="mf ka hi bd kb mg mh mi kf mj mk ml kj iq mm mn kn iu mo mp kr iy mq mr kv ms bi translated">共用存储器</h2><p id="8ca9" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">进程间共享的区域，可以访问和更改它(<strong class="ih hj">进程间通信</strong>)，在这种情况下会出现竞争情况。</p><p id="6a97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进程通过共享内存相互传递数据的方式有很多种，继续读，我们会讲到的。</p><h2 id="93eb" class="mf ka hi bd kb mg mh mi kf mj mk ml kj iq mm mn kn iu mo mp kr iy mq mr kv ms bi translated">分布式存储器</h2><p id="ac06" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">属于各自进程的本地内存。</p><h1 id="4628" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">进程间通信</h1><p id="2d2a" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">进程和线程需要相互通信，它可以传递数据，暂停其他进程，锁定其他进程，另一方面，管理其他进程。</p><p id="a5ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进程通过共享内存相互通信，由于它们同时运行可能会携带数据的不一致性和竞争情况，当一个进程使用共享内存时，应该保护共享内存，有一些方法可以处理这个问题，这些方法可以使用:</p><ul class=""><li id="1a1b" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated"><strong class="ih hj"> Lock <br/> </strong>当两个进程将要访问共享内存时，使用这种方法。当p1正在访问共享内存时，将<strong class="ih hj">锁</strong>更改为<strong class="ih hj">真</strong>，此时如果p2因为<strong class="ih hj">锁</strong>为<strong class="ih hj">真而需要共享内存，则</strong>被拒绝并在循环中等待(<strong class="ih hj">自旋锁</strong>)，直到p1将<strong class="ih hj">锁</strong>更改为<strong class="ih hj">假</strong>。它会使进程陷入死锁。</li></ul><pre class="je jf jg jh fd mt mu mv mw aw mx bi"><span id="753a" class="mf ka hi mu b fi my mz l na nb">set lock to false</span><span id="eb1a" class="mf ka hi mu b fi nc mz l na nb">create thread1<br/>create thread2</span><span id="b29c" class="mf ka hi mu b fi nc mz l na nb">allocate shared memory</span><span id="b9aa" class="mf ka hi mu b fi nc mz l na nb">define x in shared memory and assign 0 to it</span><span id="9b11" class="mf ka hi mu b fi nc mz l na nb">thread1 is going to access x in shared memory<br/>    if lock == false<br/>        set lock to true<br/>    else<br/>        wait until lock switched to false</span><span id="d387" class="mf ka hi mu b fi nc mz l na nb">thread2 is going to access x in shared memory<br/>    if lock == false<br/>        set lock to true<br/>    else<br/>        wait until lock switched to false</span></pre><ul class=""><li id="1cfe" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated"><strong class="ih hj">信号量<br/>T3】锁是一个<strong class="ih hj">布尔</strong>变量，可以有两个值。如果将其更改为<strong class="ih hj">数字</strong>(或任何可以有两个以上值的数据结构)，它会显示信号量。信号量由操作系统底层管理，分为两部分，信号量变量用0初始化，信号量队列由操作系统管理。<br/>信号量抽象对象<code class="du nd ne nf mu b">{qeueu:[], value: 0, acquire:Function, release: Function}</code> <br/>考虑n个进程将要访问共享内存，p1首先发送访问它的指令，它调用acquire。acquire是一种方法，它首先减小值，如果值为非负，则给共享内存进行处理。p1必须调用release。release是一个方法，当进程完成并增加值时调用它，并执行队列中的第一个进程。获取和释放应该自动运行，这意味着CPU不能因为执行这个而切换到其他进程。</strong></li></ul><pre class="je jf jg jh fd mt mu mv mw aw mx bi"><span id="572a" class="mf ka hi mu b fi my mz l na nb">semaphore = aks host language to give you Semaphore object<br/>create thread1<br/>create thread2<br/>create thread3<br/>create thread4</span><span id="0db0" class="mf ka hi mu b fi nc mz l na nb">allocate shared memory</span><span id="ff56" class="mf ka hi mu b fi nc mz l na nb">define x in shared memory and assign 0 to it</span><span id="3053" class="mf ka hi mu b fi nc mz l na nb">thread1 is going to access x in shared memory<br/>    invoke acquire()<br/>    once has proceeded of manipulating data in shared memory<br/>        invoke release()</span><span id="3954" class="mf ka hi mu b fi nc mz l na nb">thread2 is going to access x in shared memory<br/>    invoke acquire()<br/>    once has proceeded of manipulating data in shared memory<br/>        invoke release()<br/>...</span></pre><ul class=""><li id="1706" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated"><strong class="ih hj">队列<br/> </strong>该方法在进程数多于两个时使用。每个进程应该将它们的相关id存储到队列中，当它到达队列的前面时，就能够访问共享内存。由于正在运行一个进程，队列中的其他进程将暂停，直到它完成。</li><li id="f167" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated"><strong class="ih hj">Socket<br/>T15】这是一个通过网络传输数据的平台。考虑进程托管在不同的计算机上甚至同一台计算机上，并且想互相发送数据，它们可以通过套接字在网络上找到对方。</strong></li></ul></div><div class="ab cl ng nh gp ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hb hc hd he hf"><h1 id="95d0" class="jz ka hi bd kb kc nn ke kf kg no ki kj kk np km kn ko nq kq kr ks nr ku kv kw bi translated">概观</h1><p id="e087" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们探讨了并行性和并发性的基本主题，线程和不同类型的线程，共享内存和访问它，以及我们如何保护它以防止竞争情况。进程间通信可以有更多类似<strong class="ih hj">消息传递</strong>的方法。让我在接下来的部分谈论它们，我将特别在Golang部分谈论<strong class="ih hj">并行编程模型</strong>和<strong class="ih hj">并发设计模式</strong>。</p><h1 id="d7e1" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">下一部分</h1><p id="81f8" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在下一部分中，我将讨论并行性！和Node.js中的并发性.可能你们大多数人听说Node.js是单线程，你们是对的但不多，我将深入到Node.js中的<strong class="ih hj">事件循环</strong>、<strong class="ih hj">集群</strong>、<strong class="ih hj">子进程</strong>、<strong class="ih hj">工作者线程</strong>和<strong class="ih hj">池</strong></p><h1 id="943c" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">下下一个…部分</h1><p id="d2b9" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">本文分为五个部分:</p><ol class=""><li id="7b3b" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc ns jr js jt bi translated">并行性的基本术语—第1部分</li><li id="e351" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc ns jr js jt bi translated">Node.js中的并行性(和并发性)——第2部分</li><li id="bb26" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc ns jr js jt bi translated">Python中的并行性(和并发性)——第3部分</li><li id="dfa2" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc ns jr js jt bi translated">Golang中的并行性(和并发性)第4部分</li><li id="de13" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc ns jr js jt bi translated">Node.js、Python和Golang中并行性(和并发性)的比较—第5部分</li></ol></div></div>    
</body>
</html>