<html>
<head>
<title>Practical Guide to Pandas Essentials for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫入门实用指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/practical-pandas-part-2-9ebacf682678?source=collection_archive---------6-----------------------#2019-09-14">https://medium.com/analytics-vidhya/practical-pandas-part-2-9ebacf682678?source=collection_archive---------6-----------------------#2019-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="130f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这是一个为那些开始使用这个最重要的数据分析库的人提供的学习熊猫关键技能的教程。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a8a18de9d34f726c0add1f1f2d216891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NnkmEPaguuMBQdvGwtzfWw.jpeg"/></div></div></figure><p id="f62b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi kf translated"><span class="l kg kh ki bm kj kk kl km kn di"> T </span>这是学习熊猫图书馆实际应用系列的第二篇文章，不要被太多的细节所淹没。这是为那些不熟悉熊猫并想学习如何快速执行最常见的数据分析任务的人准备的。因此，这一系列将涵盖启动你的熊猫学习所需的细节，而不是回顾熊猫可以做的一切。</p><p id="aa84" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Jupyter笔记本可以从GitHub访问，也可以在本教程的末尾找到。我鼓励您下载笔记本，然后运行脚本。</p><p id="fbf4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">本教程涵盖</p><ol class=""><li id="b621" class="ko kp hi jl b jm jn jp jq js kq jw kr ka ks ke kt ku kv kw bi translated">选择行和列</li><li id="715f" class="ko kp hi jl b jm kx jp ky js kz jw la ka lb ke kt ku kv kw bi translated">更改数据帧的值</li><li id="81f3" class="ko kp hi jl b jm kx jp ky js kz jw la ka lb ke kt ku kv kw bi translated">追加数据帧</li><li id="f406" class="ko kp hi jl b jm kx jp ky js kz jw la ka lb ke kt ku kv kw bi translated">处理重复</li><li id="bb98" class="ko kp hi jl b jm kx jp ky js kz jw la ka lb ke kt ku kv kw bi translated">处理缺失值</li><li id="0ed9" class="ko kp hi jl b jm kx jp ky js kz jw la ka lb ke kt ku kv kw bi translated">更改列类型</li></ol><h1 id="ae81" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">快速回顾上一节课</h1><p id="52ab" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">在<a class="ae lz" rel="noopener" href="/@gangulym23/practical-pandas-50586fe90cf8"> <strong class="jl hj">上一期教程</strong> </a>中，我们已经介绍了基本的数据操作，如读、写、添加新列、重新编码现有列和删除列。下面是jupyter笔记本的<a class="ae lz" href="https://github.com/maddyg/Practical-Pandas-Learning/blob/master/Practical%20Pandas%20-%20Part%201.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hj"> github链接</strong> </a>。还发布在下面:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ma mb l"/></div></figure><h1 id="c481" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">创建数据集</h1><p id="91e5" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">首先，让我们为本教程创建数据集，这与上一教程中使用的<code class="du mc md me mf b">iris</code>数据集相同。</p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="5610" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"><em class="mp"># import libraries</em></strong><br/>import pandas as pd<br/>from sklearn import datasets</span><span id="1b41" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp">#creating the dataset for this tutorial</em></strong><br/>iris = datasets.load_iris()<br/>print(“Iris data shape :”, iris[‘data’].shape)<br/>df=pd.DataFrame(iris.data,columns=iris.feature_names)<br/>df[‘target’]=iris[‘target’]</span><span id="9a69" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp"># Use map to recode column</em></strong><br/>species_mapping=<br/>{<br/>0:iris[‘target_names’][0],<br/>1:iris[‘target_names’][1],<br/>2:iris[‘target_names’][2]<br/>}<br/>print(‘Checking species mapping: ‘)<br/>print(species_mapping)<br/>print(‘\n’)</span><span id="8b2f" class="mk ld hi mf b fi mq mm l mn mo">df[‘Species’] = df[‘target’].map(species_mapping)<br/>print(“Checking if Species is created : “)<br/>print(df.head())<br/>print(‘\n’)</span><span id="f520" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp">#show few records</em></strong><br/>print(df.head())</span></pre><p id="5bc9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">瞧啊。我们的数据集有150行和4列。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/1b1102eca7394c02f8e3c1388ab8163e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_Q2BZaai3oK864qRCheIw.png"/></div></div></figure><h1 id="740e" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">从数据框中选择行和列</h1><p id="e800" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">我们执行的最常见的数据任务之一是通过选择一组行或列或两者的组合来选择数据子集。除非我们知道幕后发生了什么，否则这对熊猫来说可能有点棘手(而且令人沮丧)。让我们看看如何在熊猫身上完成这些任务。</p><h2 id="97dd" class="mk ld hi bd le ms mt mu li mv mw mx lm js my mz lo jw na nb lq ka nc nd ls ne bi translated">。iloc和。通信线路（LinesofCommunication）</h2><p id="2a49" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">。iloc和。loc是索引器，用于在pandas中选择行和列。<strong class="jl hj"> iloc可用于通过数字</strong>和<strong class="jl hj">选择行或列。loc可用于选择带有行标签或布尔掩码的行</strong>。注意，上面创建的数据帧具有作为行标签的行号，当没有列被指定为pandas数据帧的行标签时，这是默认的行索引。让我们用一些例子来学习。</p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="d2dd" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"># select 1st row using .iloc<br/></strong>print("\n")<br/>print("Select row 1 using iloc (returns series) :")<br/>df.iloc[0]</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/fefc80ac959777233963178e54ac0818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YvnfmxBU-LKsx9oayEtCQ.png"/></div></div></figure><p id="6bd9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是我们如何通过使用<strong class="jl hj">获得数据帧的第一行。iloc </strong>。请注意，这将返回一个series对象，而不是dataframe，这通常不是我们所需要的。让我们看看如何得到一个数据帧。</p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="06c8" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"># select 1st row using .iloc</strong><br/>print(“\n”)<br/>print(“Select row 1 using iloc (returns dataframe) :”)<br/>df.iloc[[0],:]</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/68f99c5f440ccdb3a360acf5a603c75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEKpnb9SujJxNPHbxzaBMA.png"/></div></div></figure><p id="aaaa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，这将第一行作为dataframe返回。这同样适用于选择列，当您需要数据框架时，请使用双括号。</p><blockquote class="nh ni nj"><p id="6f3a" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="24d9" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#select 1st column using loc<br/></strong>print(“\n”)<br/>print(“Select 1 column using .loc (returns series) :”)<br/>df.loc[:,’sepal length (cm)’]</span></pre><blockquote class="nh ni nj"><p id="7ff5" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nn"><img src="../Images/6be83c0fb174d45f54dfb33ac8fefb88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*2lbSUfUBKJimzMaWthRTEA.png"/></div></figure><blockquote class="nh ni nj"><p id="eeaa" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="473a" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#select 1st column using iloc</strong><br/>print("\n")<br/>print("Select column 1 using using iloc (returns dataframe) :")<br/>df.iloc[:,[0]]</span></pre><blockquote class="nh ni nj"><p id="d822" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es no"><img src="../Images/0b209f109a48e0ce9ab03a9e4f8b16c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J72IyQhjBQZXFrc4mBw4VA.png"/></div></div></figure><blockquote class="nh ni nj"><p id="b690" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="3feb" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#select 1st column using iloc<br/></strong>print("\n")<br/>print("Select column 1 using using iloc (returns dataframe) :")<br/>df.iloc[:,[0]]</span></pre><blockquote class="nh ni nj"><p id="642a" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es np"><img src="../Images/7be7336ef77414db7a1e7e58cea7d330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vkupEUnXWsADI25gThPHPw.png"/></div></div></figure><p id="8d69" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还可以使用. iloc选择多行和多列。</p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="69f6" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"><em class="mp">#select multiple rows using iloc</em></strong><br/>df.iloc[0:5] #returns a dataframe<br/>df.iloc[0:5,:] #returns a dataframe</span><span id="026b" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp">#select multiple columns using iloc</em></strong><br/>df.iloc[:,0:3] #returns a dataframe</span><span id="786c" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp">#select rows and columns with iloc</em></strong><br/>df.iloc[0:5,0] #returns a series<br/>df.iloc[0:5,[0]] #returns a dataframe<br/>df.iloc[0:5,0:3] #returns a dataframe</span></pre><p id="281c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，让我们看看如何使用<strong class="jl hj">进行同样的操作。锁定</strong>。</p><blockquote class="nh ni nj"><p id="d3d6" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="f08f" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#select 1st row using loc<br/></strong>print(“\n”)<br/>print(“Select 1 row using loc (returns series) :”)<br/>df.loc[0] <br/>df.loc[0,:]</span></pre><blockquote class="nh ni nj"><p id="5efc" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nq"><img src="../Images/6ab10b470e6839ca8b2a161341a1803a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MpqJeoG71m7TjQkkHAADIg.png"/></div></div></figure><blockquote class="nh ni nj"><p id="1d7e" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代号</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="6b64" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#select 1st row using loc<br/></strong>print(“\n”)<br/>print(“Select 1 row using loc (returns dataframe) :”)<br/>df.loc[[0],:] # returns a dataframe, not specifying colunms returns all columns</span></pre><blockquote class="nh ni nj"><p id="bc2c" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nr"><img src="../Images/34bfd231fe582305f0e8e02a3d23b47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PW_eyecBcL8hqbBmqkCpTA.png"/></div></div></figure><blockquote class="nh ni nj"><p id="6b8b" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated">密码</p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="3901" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"># select 1st column using loc<br/></strong>print(“\n”)<br/>print(“Select 1 column using loc (returns series) :”)<br/>df.loc[:,’sepal length (cm)’]</span></pre><blockquote class="nh ni nj"><p id="dcfa" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated">输出</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ns"><img src="../Images/b0f6497e566d70b77e2acd9ddb3df798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcIV7eaS9di9pARrdVIzDw.png"/></div></div></figure><blockquote class="nh ni nj"><p id="e8b3" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="27a2" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"># select 1st column using loc<br/></strong>print(“\n”)<br/>print(“Select 1 column using loc (returns dataframe) :”)<br/>df.loc[:,[‘sepal length (cm)’]]</span></pre><blockquote class="nh ni nj"><p id="926a" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nt"><img src="../Images/ae65950db90b56af70837cd5d029d7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lBKw_BCYmwEmVLVdZg093A.png"/></div></div></figure><p id="6b7c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们也可以用. loc选择多个行和列。</p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="3280" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"><em class="mp">#select multiple rows using loc<br/></em></strong>df.loc[0:5,:] # returns a dataframe</span><span id="180b" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp">#select multiple columns using loc<br/></em></strong>df.loc[:,[‘sepal length (cm)’,’sepal width (cm)’]] </span><span id="897d" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp">#select rows and columns with loc<br/></em></strong>df.loc[0:5,[‘sepal length (cm)’]] <br/>df.loc[0:5,[‘sepal length (cm)’,’sepal width (cm)’]] </span></pre><p id="9211" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们最常用的选择是条件选择，对于这些我们需要使用. loc。</p><blockquote class="nh ni nj"><p id="b8eb" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="781e" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#select rows with conditions using loc<br/></strong>bool_mask = df[‘sepal length (cm)’]&gt;4 <br/>df.loc[bool_mask]</span></pre><blockquote class="nh ni nj"><p id="a7a0" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nu"><img src="../Images/fea1f7d9c35296fa5e86397034781f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdcOhr78JWxcY5auOIOKxA.png"/></div></div></figure><p id="7cc9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">请注意使用数字选择带有iloc和loc的行时的区别，iloc的工作方式类似于常规的python索引，而loc则不同。</p><blockquote class="nh ni nj"><p id="c3f7" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="b0c4" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#Note the difference</strong></span><span id="b897" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#loc returns all rows 0 to 5 with matching labels<br/></strong><em class="mp">print(".loc")<br/>print(df.loc[0:5,[‘target’]])</em></span><span id="5b85" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#iloc returns rows 0 to 4, just like regular python indexing in lists, tuples, dictionaries<br/></strong><em class="mp">print(".iloc")<br/>print(df.iloc[0:5,[4]])</em></span></pre><blockquote class="nh ni nj"><p id="ea14" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nv"><img src="../Images/d4bb03c2378b067fb60eee8e85088b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*zJJadgUUvns8HtSYS910mQ.png"/></div></figure><h1 id="a433" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">。Isin()</h1><p id="642b" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">当您需要检查一行或多列中的特定值时,<code class="du mc md me mf b">isin()</code>函数非常方便。一种方法是纠正多个<code class="du mc md me mf b">==</code>条件，但这可能会非常繁琐。下面我们来看一个例子。</p><blockquote class="nh ni nj"><p id="2f5c" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated">密码</p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="33eb" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"># select all rows where species is “setosa” or “versicolor”<br/></strong>df_new=df.loc[df[‘Species’].isin([‘setosa’,’versicolor’]),:]<br/>print(df_new.Species.unique())</span></pre><blockquote class="nh ni nj"><p id="583d" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated">输出</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nw"><img src="../Images/7223acfd39b3fdb4f5b665827295ec4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*r5TA9IRHAnSmfQsNi2mXUA.png"/></div></figure><p id="d3fc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们已经成功地过滤了物种为“setosa”和“versicolor”的所有行。类似地，我们也可以对物种是<strong class="jl hj">而不是</strong>“setosa”或“versicolor”的所有行使用<code class="du mc md me mf b">isin()</code>。</p><blockquote class="nh ni nj"><p id="7395" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="21d8" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"># select all rows where species is not “setosa” and “versicolor”<br/></strong>df_new=df.loc[~df[‘Species’].isin([‘setosa’,’versicolor’]),:]<br/>print(df_new.Species.unique())</span></pre><blockquote class="nh ni nj"><p id="7ad1" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><h1 id="889b" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">修改数据帧</h1><h2 id="eb5a" class="mk ld hi bd le ms mt mu li mv mw mx lm js my mz lo jw na nb lq ka nc nd ls ne bi translated">视图和副本</h2><p id="6ad9" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">现在我们已经很好地理解了如何使用loc和iloc，让我们继续了解如何修改数据帧或通过修改现有数据帧来创建新数据帧。为了理解这一点，我们需要了解熊猫的视图和拷贝。到目前为止，我们一直在创建数据帧的视图，这只是数据帧的子集，当修改数据帧时，我们需要小心我们是在修改视图还是原始数据帧。让我们看看下面的例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nx"><img src="../Images/a89cf01b7f879f01dde061d2bc4acc40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5oWVimJztSG-xaG7Wn69Ew.png"/></div></div><figcaption class="ny nz et er es oa ob bd b be z dx translated">图片由https://www.dataquest.io/blog/settingwithcopywarning/<a class="ae lz" href="https://www.dataquest.io/blog/settingwithcopywarning/" rel="noopener ugc nofollow" target="_blank">提供</a></figcaption></figure><p id="9061" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们试着用下面的脚本修改我们的数据帧。</p><blockquote class="nh ni nj"><p id="44b0" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="3fd9" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#we want to modify row 5 value for column "target"<br/></strong>df_copy=df</span><span id="f53d" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"># print rows where sepal length&lt;=4.5 and column target</strong><br/>print(“Original value : “,df_copy[df_copy[‘sepal length (cm)’]&lt;=4.5][[‘target’]])</span><span id="95e1" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"># lets modify this value</strong><br/>df_copy[df_copy[‘sepal length (cm)’]&lt;=4.5][[‘target’]]=2</span><span id="6d9b" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"># lets check if the value has changed</strong><br/>print(“Modified value : “,df_copy[df_copy[‘sepal length (cm)’]&lt;=4.5][[‘target’]])</span></pre><blockquote class="nh ni nj"><p id="5ff9" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oc"><img src="../Images/7863ef4c78cc8d547020795a853030e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*OhTmTIJ1JJe99KOWF0gb8Q.png"/></div></figure><p id="9021" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">值没有变！我们收到了熊猫的警告。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es od"><img src="../Images/3c2aacc03cc01dd5bb146c11f4c9354b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNq2ORNkofRI-aVY6tRIKA.png"/></div></div><figcaption class="ny nz et er es oa ob bd b be z dx translated">SettingWithCopyWarning</figcaption></figure><p id="9fa6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们得到<code class="du mc md me mf b">SettingWithCopyWarning</code>,因为pandas不确定是原始数据帧被修改了还是视图被修改了。我们可以看到萼片长度&lt; = 4.5的目标列没有改变。这个警告是熊猫让我们知道事情可能不像预期的那样发展的一种方式。我们可以通过使用。loc或。iloc和不使用链接。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oe"><img src="../Images/5951029b5af0bb5f098851468133132f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFIQwwlLMc7-83iYHBsl2w.png"/></div></div><figcaption class="ny nz et er es oa ob bd b be z dx translated">图片提供—<a class="ae lz" href="https://www.dataquest.io/blog/settingwithcopywarning/" rel="noopener ugc nofollow" target="_blank">https://www.dataquest.io/blog/settingwithcopywarning/</a></figcaption></figure><p id="3419" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，让我们看看如何消除这个警告。</p><blockquote class="nh ni nj"><p id="9683" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="23da" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#print rows where sepal length&lt;=4.5 and column target<br/></strong>print("Original value : ",df_copy.loc[df_copy['sepal length (cm)']&lt;=4.5,['target']])</span><span id="be6f" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#lets modify this value<br/></strong>df_copy.loc[df_copy['sepal length (cm)']&lt;=4.5,['target']]=2</span><span id="b196" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#lets check if the value has changed<br/></strong>print("Modified value : ",df_copy.loc[df_copy['sepal length (cm)']&lt;=4.5,['target']])</span></pre><blockquote class="nh ni nj"><p id="cb67" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es of"><img src="../Images/b3aed86a9232f7a587e6e255b5308ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*GtJqNx6tECyfcM5ArwIk2g.png"/></div></figure><p id="0d45" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">瞧啊。现在值已经变了。当修改数据帧时，我们应该避免使用链接<code class="du mc md me mf b">[df_copy['sepal length (cm)']&lt;=4.5][['target']]]</code>,而使用。loc或. iloc. <strong class="jl hj"> <em class="mp"> <br/> </em> </strong>现在，我们试着用. loc修改dataframe。</p><blockquote class="nh ni nj"><p id="0862" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代号</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="3dac" class="mk ld hi mf b fi ml mm l mn mo">df_copy = df</span><span id="891d" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#create a copy of dataframe</strong><br/>df_copy_sub= df_copy.loc[df_copy[‘sepal length (cm)’]&lt;=4.5,:]</span><span id="a264" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#original value</strong><br/>print(“Original value “, df_copy_sub[‘target’])</span><span id="ee2d" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#lets modify this value</strong><br/>df_copy_sub[‘target’]=3</span><span id="4d21" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#lets check if the value has changed</strong><br/>print(“Modified value :”,df_copy_sub[‘target’])</span></pre><blockquote class="nh ni nj"><p id="46c1" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es og"><img src="../Images/bdc50aedc44231c66d5bb5f9ed87ac7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*o42P6nygbG-_dX8AuxrzpA.png"/></div></figure><p id="f51b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然我们已经使用了. loc，但是<code class="du mc md me mf b">SettingWithCopyWarning</code>警告再次出现。这是因为df_copy不是df的副本，所以当我们试图修改df_copy时，pandas再次被混淆。为了避免这种情况，最好使用<code class="du mc md me mf b">df_copy=df.copy()</code>而不是<code class="du mc md me mf b">df_copy=df</code>。</p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="f88f" class="mk ld hi mf b fi ml mm l mn mo">df_copy=df.copy()<br/># save the dataframe<br/>df_copy_sub= df_copy.loc[df_copy['sepal length (cm)']&lt;=4.5,:].copy()</span><span id="738b" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp">#check original value<br/></em></strong>print(df_copy_sub['target'])</span><span id="fe42" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp">#lets modify this value<br/></em></strong>df_copy_sub['target']=3</span><span id="4bee" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp">#lets check if the value has changed<br/></em></strong>print(df_copy_sub['target']) #it get changed</span></pre><p id="b6a0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，我们摆脱了讨厌的<code class="du mc md me mf b">SettingWithCopyWarning</code>。</p><h2 id="2e91" class="mk ld hi bd le ms mt mu li mv mw mx lm js my mz lo jw na nb lq ka nc nd ls ne bi translated">追加数据帧</h2><p id="ad55" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">在处理数据时，在列或行上追加2个数据帧是很常见的，pandas提供了一种简单的方法来通过<code class="du mc md me mf b">concat</code>函数实现这一点。</p><h2 id="4caa" class="mk ld hi bd le ms mt mu li mv mw mx lm js my mz lo jw na nb lq ka nc nd ls ne bi translated">使用选项<code class="du mc md me mf b">axis=1</code>可将数据帧附加到列上</h2><blockquote class="nh ni nj"><p id="0060" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="2819" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#lets create a copy of existing data frame<br/></strong>df_1= df.copy()<br/>df_2= df.copy()</span><span id="a000" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#lets append by column<br/></strong>df_append_bycol= pd.concat([df_1,df_2],axis=1)<br/><strong class="mf hj">#another way to append by column<br/></strong>df_append_bycol= pd.concat([df_1,df_2],axis=”columns”)</span><span id="4eff" class="mk ld hi mf b fi mq mm l mn mo">print(“Original Dataframe — “,df.shape) <br/>print(“Appended Dataframe — “,df_append_bycol.shape)</span></pre><blockquote class="nh ni nj"><p id="4d19" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oh"><img src="../Images/ecfea8f427bf3b7221d2c2049330dae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*2D38dWKwBxFge33ZuZmWhQ.png"/></div></figure><p id="7226" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所得到的附加数据帧的列数是我们简单地将数据帧附加到自身的列数的两倍。接下来，让我们看看当两个数据帧没有相同的维度时，如何在列上追加数据帧。</p><h2 id="d24f" class="mk ld hi bd le ms mt mu li mv mw mx lm js my mz lo jw na nb lq ka nc nd ls ne bi translated">行数不相等</h2><p id="a543" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">检查当两个数据帧的行数不相等时会发生什么。在下面的例子中，第一个数据帧只有6行，而第二个数据帧有150行。串接的数据帧在第6行之后的所有行中的前5列(来自第一个数据帧)中具有NaN值。</p><blockquote class="nh ni nj"><p id="9b1a" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="e696" class="mk ld hi mf b fi ml mm l mn mo">df_1= df.loc[0:5,:].copy() # df_1 has only 6 rows<br/>df_2= df.copy()</span><span id="a261" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#lets append by column<br/></strong>df_append_bycol= pd.concat([df_1,df_2],axis=1)<br/>print(“Original Dataframe — “,df.shape) <br/>print(“Appended Dataframe — “,df_append_bycol.shape)</span><span id="82f8" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#notice the first 5 columns are NaN from row 7 onwards<br/></strong>print("Concatenated Dataframe")<br/>print(df_append_bycol.head(20))</span></pre><blockquote class="nh ni nj"><p id="4475" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oi"><img src="../Images/f2b1d6a5eb0a49c03cf922fd74682780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNM18HpLQ7LP5ZYWV8KeXg.png"/></div></div></figure><h2 id="fc8d" class="mk ld hi bd le ms mt mu li mv mw mx lm js my mz lo jw na nb lq ka nc nd ls ne bi translated">不同的行索引</h2><p id="6f67" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">检查当两个数据帧具有不同的行索引时会发生什么。在下面的示例中，第一个数据帧的行索引为5到10，而第二个数据帧的行索引为0到149。除了第5到10行之外，连接的数据帧在所有行的前5列中具有NaN值(来自第一个数据帧)。正在发生的是<code class="du mc md me mf b">concat</code>函数合并了行索引上的两个数据帧，所以当连接数据帧时，我们也需要留意行索引。如果您不关心索引，这可以通过重置dataframe的索引来更改。</p><blockquote class="nh ni nj"><p id="23fc" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="3209" class="mk ld hi mf b fi ml mm l mn mo">df_1= df.loc[5:10,:].copy() # df_1 has only 6 to 10 from original dataframe<br/>df_2= df.copy()</span><span id="3e41" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#lets append by column<br/></strong>df_append_bycol= pd.concat([df_1,df_2],axis=1)<br/>print(“Original Dataframe — “,df.shape) <br/>print(“Appended Dataframe — “,df_append_bycol.shape)</span><span id="d6e1" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#notice the first 5 columns are not NaN only for rows 5 to 10<br/></strong>print("Concatenated Dataframe")<br/>print(df_append_bycol.head(20))</span></pre><blockquote class="nh ni nj"><p id="3a55" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oj"><img src="../Images/9c0b693706636776faf4bd4c81473bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDTE0ckX0L2Cfp1yyxfXqg.png"/></div></div></figure><blockquote class="nh ni nj"><p id="019d" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="3178" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#reset index<br/></strong>df_1= df.loc[5:10,:].copy().reset_index(drop=True) <br/>df_2= df.copy()</span><span id="2600" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#lets append by column<br/></strong>df_append_bycol= pd.concat([df_1,df_2],axis=1)</span><span id="ee9e" class="mk ld hi mf b fi mq mm l mn mo">print(“Original Dataframe — “,df.shape)<br/>print(“Appended Dataframe — “,df_append_bycol.shape)<br/>print(“\n”)</span><span id="c0b1" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#notice the first 5 columns are not NaN for rows 5 to 10 </strong>print(“Concatenated Dataframe with reset index”)<br/>print(df_append_bycol.head(20))</span></pre><blockquote class="nh ni nj"><p id="b810" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ok"><img src="../Images/ee08852b3d184918e70c4c1f143410ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0L7KE59l1RUxNTYAzBwlLg.png"/></div></div></figure><h2 id="df80" class="mk ld hi bd le ms mt mu li mv mw mx lm js my mz lo jw na nb lq ka nc nd ls ne bi translated">使用选项<code class="du mc md me mf b">axis=0</code>可将数据帧附加到行上</h2><p id="e5a4" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">当按行追加数据帧时，行索引也会被追加并需要重置。此外，2个数据帧中的列名应该相同，否则熊猫将被视为不同的列。</p><blockquote class="nh ni nj"><p id="f273" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="c5d8" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#lets create a copy of existing data frame “df”<br/></strong>df_1= df.loc[0:5,:].copy()<br/>df_2= df.loc[0:5,:].copy()</span><span id="2158" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#lets append by row<br/></strong>df_append_byrow= pd.concat([df_1,df_2],axis=0) # check the row index<br/>print(“\n”)<br/>print(“Original Dataframe — “,df.shape)<br/>print(“Appended Dataframe — “,df_append_bycol.shape)<br/>print(“\n”)<br/>print(“Concatenated Dataframe without reset index”)<br/>print(df_append_byrow.head(10))</span></pre><blockquote class="nh ni nj"><p id="a359" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ol"><img src="../Images/9f994ff74bb866b2423619601a52d588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2VAfc1vkz5MYtdeJ-dyVeQ.png"/></div></div></figure><blockquote class="nh ni nj"><p id="14af" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="bce4" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#lets append by row and reset index<br/></strong>df_append_byrow= pd.concat([df_1,df_2],axis=0).reset_index(drop=True)</span><span id="bf0f" class="mk ld hi mf b fi mq mm l mn mo">print(“\n”)<br/>print(“Original Dataframe — “,df_1.shape)<br/>print(“Appended Dataframe — “,df_append_byrow.shape)<br/>print(“\n”)</span><span id="076d" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#check the row index<br/></strong>print(“Concatenated Dataframe with reset index”)<br/>print(df_append_byrow.head(10))</span></pre><blockquote class="nh ni nj"><p id="00f8" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es om"><img src="../Images/1c8319a053b7f9f845c05999e0dfaf1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NjxW202inbyB1NErq8RnKg.png"/></div></div></figure><h2 id="b485" class="mk ld hi bd le ms mt mu li mv mw mx lm js my mz lo jw na nb lq ka nc nd ls ne bi translated">列数不相等</h2><p id="949f" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">检查当两个数据帧的列数不相等时会发生什么。在下面的示例中，第一个数据帧只有3列，而第二个数据帧有5列。串联数据帧的前10行(来自第一个数据帧)的列中有它所缺少的NaN值。</p><p id="7525" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有趣的事实！注意，在连接的数据帧中，列的顺序已经改变，<code class="du mc md me mf b">concat</code>按字母顺序对列重新排序，使用<code class="du mc md me mf b">sort= False</code>将其关闭。</p><blockquote class="nh ni nj"><p id="e9f9" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="23d8" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#lets take a smaller subset to be able to inspect the results<br/></strong>df_1= df.iloc[0:10,0:1].copy() # df_1 has only 6 rows<br/>df_2= df.iloc[0:10,:].copy()</span><span id="4dd5" class="mk ld hi mf b fi mq mm l mn mo">print(df_1.head())<br/>print(df_2.head())</span><span id="d070" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#lets append by row<br/></strong>df_append_byrow= pd.concat([df_1,df_2],axis=0,sort=False)</span><span id="7745" class="mk ld hi mf b fi mq mm l mn mo">print("\n")<br/>print(“Original Dataframe1 — “,df_1.shape)<br/>print(“Original Dataframe2 — “,df_2.shape)</span><span id="472b" class="mk ld hi mf b fi mq mm l mn mo">print("Appended Dataframe - ",df_append_byrow.shape)<br/>print("\n")<br/>print("Concatenated Dataframe")<br/>print(df_append_byrow.head(20))</span></pre><blockquote class="nh ni nj"><p id="9ba3" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es on"><img src="../Images/25e41b48ac7e667ace6928649ef6bfa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M1fMmuraSiGxoyP4twKY-A.png"/></div></div></figure><h2 id="c724" class="mk ld hi bd le ms mt mu li mv mw mx lm js my mz lo jw na nb lq ka nc nd ls ne bi translated">处理重复</h2><p id="ecfb" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">在开始对数据进行任何分析之前，寻找重复的行和列并适当地处理它们是基本的数据健全性检查之一。你猜对了，熊猫有一个很棒的功能来做到这一点——T2。使用此功能，我们可以<strong class="jl hj">删除所有重复项</strong>或<strong class="jl hj">保留第一个/最后一个重复项</strong>(按其他列排序后)。当使用<code class="du mc md me mf b">subset</code>选项搜索重复项时，我们也可以只考虑列的子集。让我们看看这是如何工作的。</p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="8311" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"><em class="mp">#lets first add some duplicate rows to our dataframe<br/></em></strong>df_1= df.loc[0:5,:].copy()<br/>df_2= df.loc[0:5,:].copy()<br/>df_hasduplicates=pd.concat(<br/>                [df_1,df_2],axis=0).reset_index(drop=True) <br/></span></pre><p id="2812" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们有重复记录的数据集已经准备好，这个数据帧应该有每个记录的一个副本。现在，让我们首先删除所有重复的内容。</p><blockquote class="nh ni nj"><p id="b459" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代号</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="323d" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#drop them all<br/></strong>df_noduplicates= df_hasduplicates.drop_duplicates()<br/>print(“Dataframe without duplicates “,df_noduplicates.shape)<br/>print(df_noduplicates.head(5))</span></pre><blockquote class="nh ni nj"><p id="d48e" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oo"><img src="../Images/369786d964e6e11c35d67b3b945bd57f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*eIYLASZs6eF1jKQsuKdULw.png"/></div></figure><p id="cce9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以看到数据帧恢复到原始形状，这意味着所有重复数据都已被删除。接下来，我们尝试只删除那些在<strong class="jl hj">目标</strong>列中有重复值的记录。</p><blockquote class="nh ni nj"><p id="9493" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="ae9c" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#let’s check how many duplicate values are there in target column<br/>#we can check using group by function (will be covered in a later article)</strong><br/>print(“Dataframe with duplicates”)<br/>print(df_hasduplicates[‘target’].value_counts())<br/>print(“\n”)</span><span id="a57b" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#drop the rows with duplicate target column</strong><br/>df_noduplicates= df_hasduplicates.drop_duplicates(subset=[‘target’])<br/><strong class="mf hj"># let’s check if target column has duplicates now<br/></strong>print(“Dataframe without duplicates “)<br/>print(df_noduplicates[‘target’].value_counts())<br/>print(“\n”)</span></pre><blockquote class="nh ni nj"><p id="8898" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es op"><img src="../Images/3dd6ef153c56926efd038340e5a7fd52.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*ASrR4uarW_p9UP-bD2j7hQ.png"/></div></figure><p id="3590" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以看到，具有重复值的数据帧有8个值为0的记录、2个值为1的记录和2个值为2的记录，没有重复值的数据帧每种类型有1个值。</p><p id="e6af" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，这里pandas为目标列的每个值保留第一条记录。接下来，让我们尝试使用选项<code class="du mc md me mf b">keep</code>来记录最短的萼片长度。</p><blockquote class="nh ni nj"><p id="f037" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="c029" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#drop the rows with duplicate target column while keeping the row with lowest sepal length<br/>#first sort by target and petal length<br/></strong>df_hasduplicates.sort_values([‘target’,’sepal length (cm)’],ascending=False,inplace=True)</span><span id="a1e6" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#drop duplicates<br/></strong>df_noduplicates_2= df_hasduplicates.drop_duplicates(subset=[‘target’],keep=’last’)</span><span id="3825" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#let’s check if target column has duplicates now<br/></strong>print(“Dataframe without duplicates “)<br/>print(df_noduplicates_2[‘target’].value_counts())<br/>print(“\n”)</span></pre><blockquote class="nh ni nj"><p id="c450" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oq"><img src="../Images/e350dc51ffa3098a6f6ce6c22ef8d219.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*2wi3sV7SXirLlvTDHC84Kw.png"/></div></figure><p id="2b62" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">同样，所有重复的值都消失了，如果你这次检查数据框，萼片长度的最小值被保留。对于目标列的第一个和第二个值，最低值碰巧在第一列，因此这两个记录的输出不会改变。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nr"><img src="../Images/cef0eeaceaf62aa2b5929bb3ceaab8a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpeNfY_ofFB640mK5XIkog.png"/></div></div></figure><h2 id="4f6c" class="mk ld hi bd le ms mt mu li mv mw mx lm js my mz lo jw na nb lq ka nc nd ls ne bi translated">处理缺失值</h2><p id="0605" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">知道如何找到和替换丢失的值是数据分析的关键。在pandas中，我们可以用<code class="du mc md me mf b">dropna()</code>函数过滤掉任何或所有缺失值的行和列。让我们看看熊猫让我们管理缺失的价值观的不同方式。</p><p id="ce23" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，让我们在数据集中引入一些缺失值。</p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="194f" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"><em class="mp">#import numpy library<br/></em></strong>import numpy as np</span><span id="f70e" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp">#lets first introduce some missing values into our dataframe<br/></em></strong>df_copy = df.copy()<br/>print(df_copy.shape)</span><span id="0ab0" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"><em class="mp">#lets randomly pick some rows and column positions and assign them to NaN<br/></em></strong>np.random.seed(200)<br/>row=np.random.randint(0,df_copy.shape[0]-1,10)<br/>col=np.random.randint(0,df_copy.shape[1]-1,1)<br/>print(row,col)<br/>df_copy.iloc[row,col]=np.nan</span></pre><p id="f080" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们的数据集有缺失值。让我们看看如何检查数据帧中的缺失值。</p><blockquote class="nh ni nj"><p id="17c6" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代号</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="d1fc" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"># Check how many missing values in total<br/></strong>print(“No. of missing values :”,df_copy.isnull().sum().sum())<br/>print(“\n”)</span><span id="0c4f" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj"># Check how many missing values by columns<br/></strong>print(“No. of missing values :”)<br/>print(df_copy.isnull().sum())</span></pre><blockquote class="nh ni nj"><p id="79d6" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es or"><img src="../Images/ca4bcfced8616d168b1af9b0046becd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*kukiwwEeFyPFWkp93O-78A.png"/></div></figure><p id="a613" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好了，我们的数据集中有5个缺失值，它们都在目标列中。接下来，假设您想要删除所有带有<strong class="jl hj">缺失值的记录。</strong>这就是我们如何使用<strong class="jl hj"> dropna </strong>函数来实现的。</p><blockquote class="nh ni nj"><p id="604f" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="hi">代码</em> </strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="d694" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#Drop rows with any missing values <br/></strong>df_nonull=df_copy.dropna(how=’any’)<br/>print(df_nonull.isnull().sum())</span></pre><blockquote class="nh ni nj"><p id="1e8b" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="hi">输出</em> </strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es os"><img src="../Images/7da3683dfa95f7f0f829411d184b99e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*SbLqSFaZHw0IwnvtM6KA3Q.png"/></div></div></figure><p id="3c9c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如我们所看到的，不再有丢失的值，所有丢失值的行都被删除了。我们也可以删除特定列有缺失值的记录。让我们看看我们如何能做到这一点。</p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="0f77" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"># Drop rows with missing values in sepal length column<br/></strong>df_nonull=df_copy.dropna(subset=[‘sepal length (cm)’],how=’any’)<br/>print(df_nonull.isnull().sum())</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ot"><img src="../Images/4c1ff2d1e6b6ede27096bde3d6d94618.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*Q-vmX7dlQvLqHJif7TYAzg.png"/></div></figure><p id="ef98" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于列<strong class="jl hj">萼片长度</strong>开始时没有任何缺失值，因此没有记录从数据帧中删除。对列<strong class="jl hj">目标</strong>进行同样的尝试！</p><p id="e8e1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，让我们看看如何使用<strong class="jl hj">来过滤数据帧中没有丢失值的列。</strong>函数的全部()。假设您只想保留没有缺失值的列。</p><blockquote class="nh ni nj"><p id="8077" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="8b1c" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#get all columns with no null values<br/></strong>df_nonull=df_copy.loc[:,df_copy.notnull().all()]<br/>print(df_nonull.isnull().sum()) <br/>print(“Columns with no null values:”, df_nonull.columns.values)</span></pre><blockquote class="nh ni nj"><p id="2cd7" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ou"><img src="../Images/52f81468f76dcbab15961320f2a6d397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpdhzjSIYXrF1aZrCzSscw.png"/></div></div></figure><p id="d6dc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以看到这些列没有缺失值。接下来，按照类似的思路，让我们看看如何过滤所有包含非空值的列。</p><blockquote class="nh ni nj"><p id="1ba1" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p></blockquote><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="2f04" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#get all columns with any non-null values<br/></strong><em class="mp">df_nonull=df_copy.loc[:,df_copy.notnull().any()]<br/>print(df_nonull.isnull().sum()) <br/>print(“Columns with any non-null values:”, df_nonull.columns.values)</em></span></pre><blockquote class="nh ni nj"><p id="dedd" class="jj jk mp jl b jm jn ij jo jp jq im jr nk jt ju jv nl jx jy jz nm kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ov"><img src="../Images/b14b9a57a0f9d450e82053b1416aba8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w50Z1B2NHy6Kojikx6mnTg.png"/></div></div></figure><p id="2f95" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以看到，在这个数据帧中，所有列都有一些非空值。接下来，让我们看看如何获取所有缺少值的列。</p><p id="cbda" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="5153" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"># get all columns with any non-null values</strong><br/>df_nonull=df_copy.loc[:,df_copy.isnull().any()]<br/>print(df_nonull.isnull().sum()) <br/>print(“Columns with any null values:”, df_nonull.columns.values)</span></pre><p id="1da9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ow"><img src="../Images/3bd65f6a4f297871860f66c74ae1b93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*pO9cuHl-0yIWQYZ6S2qL4Q.png"/></div></figure><p id="e564" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如所料，“target”是唯一一个包含空值的列。因此，我们在这里看到了一些处理缺失值的方法，但是请注意，这些方法仅涉及如何识别缺失值，估算缺失值的方法将在后面的文章中介绍。</p><h2 id="77f5" class="mk ld hi bd le ms mt mu li mv mw mx lm js my mz lo jw na nb lq ka nc nd ls ne bi translated">更改数据类型</h2><p id="5bc1" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">在pandas中，最常用的数据类型是整数、浮点、对象、类别和日期时间。我们可以通过使用<code class="du mc md me mf b">.dtypes</code>函数获得任何数据帧中所有列的数据类型。以不适合分析的格式读取数据(尤其是从sql数据库读取时)是很常见的，需要在分析前将其更改为合适的数据类型。为了转换成数字，我们可以使用<code class="du mc md me mf b">astype()</code>函数或<code class="du mc md me mf b">to_numeric()</code>函数，这很方便，尤其是当你缺少数值的时候。有些情况下，我们只需要选择某个数据类型的列来执行分析，pandas有一个非常有用的函数<code class="du mc md me mf b">select_dtypes()</code>来完成这个任务。让我们用例子来学习。</p><ol class=""><li id="7bed" class="ko kp hi jl b jm jn jp jq js kq jw kr ka ks ke kt ku kv kw bi translated">检查数据帧中的数据类型。</li></ol><p id="e7b5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">代号</strong></p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="9492" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj"><em class="mp">#check datatypes in our dataframe<br/></em></strong>print(df.dtypes)</span></pre><p id="e36c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ox"><img src="../Images/f54e099d3790f81f5e97a0c2ed626a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*P3Ez_u8QlBX9i7T8zLDxWQ.png"/></div></figure><p id="7a0a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">2.选择特定类型的所有列。</p><p id="4c3f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="96ad" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#lets select all float columns<br/></strong>df_float = df.select_dtypes(include=’float64')<br/>print(df_float.dtypes)</span></pre><p id="b5bd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oy"><img src="../Images/a74b01c8911c7ac4e6afaed81a26c352.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*uCOv_iaDTuLhvmuvSEjVSQ.png"/></div></figure><p id="05f4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">3.更改列类型，注意转换后“目标”列的数据类型。</p><p id="7ed2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">代码</strong></p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="4c32" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#lets convert target column to float type<br/></strong>df[‘target’]=df[‘target’].astype(‘float64’)<br/>print(df.dtypes)</span></pre><p id="6024" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">输出</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oz"><img src="../Images/9959fb9349a2eee291ade152f3eb7b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*8S2GiKk-01kUuvQgjDW-pA.png"/></div></figure><p id="4f84" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">4.存在缺失值时转换数据类型。</p><p id="a93e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Pandas不允许在转换为整数类型时缺少值，并会抛出错误，所以如果一列有缺少值，那么我们可以转换为浮点型，或者先估算缺少的值，然后再转换为整数。</p><pre class="iy iz ja jb fd mg mf mh mi aw mj bi"><span id="6b7f" class="mk ld hi mf b fi ml mm l mn mo"><strong class="mf hj">#lets introduce some missing values in target column<br/></strong>row=np.random.randint(0,df.shape[0],5)<br/>df_copy=df.copy()<br/>df_copy.loc[row,’target’]=np.nan</span><span id="bb6c" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#check for missing values<br/></strong>print(“Missing values :”,df_copy[‘target’].isnull().sum())</span><span id="4b84" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#lets convert target column to int type using astype()<br/></strong>df_copy[‘target’]=df_copy[‘target’].astype(int)</span><span id="2cc3" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#you get an ERROR !!</strong></span><span id="fcbe" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#now try this<br/></strong>df_copy[‘target’]=pd.to_numeric(df_copy[‘target’],errors=’coerce’)<br/>print(df_copy.dtypes)</span><span id="eed8" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#or this<br/></strong>df_copy[‘target’]=df_copy[‘target’].astype(float)</span><span id="e9b7" class="mk ld hi mf b fi mq mm l mn mo"><strong class="mf hj">#no ERROR !!</strong></span></pre><p id="6b8e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">本教程到此为止。希望你觉得有用，感谢阅读！这是笔记本。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ma mb l"/></div></figure></div></div>    
</body>
</html>