<html>
<head>
<title>Simple movie review classifier in 3 steps!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的3步电影评论分类器！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/simple-movie-review-classifier-in-3-steps-2a97c8869dbc?source=collection_archive---------32-----------------------#2020-05-13">https://medium.com/analytics-vidhya/simple-movie-review-classifier-in-3-steps-2a97c8869dbc?source=collection_archive---------32-----------------------#2020-05-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="47af" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">机器学习|自然语言处理</h2><div class=""/><div class=""><h2 id="6b4c" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">只用几行代码就构建了一个+ve/-ve电影评论分类器</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/2a68ef5c695d4392416546499654d6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B3UuBARut9t7J7uB"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">照片由<a class="ae jw" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jw" href="https://unsplash.com/@georgiavagim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔治亚·瓦格姆</a>拍摄</figcaption></figure><p id="6740" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">虽然有许多方法可以用来建立一个分类器来分类一个电影评论是正面还是负面，但我们可以在单词袋和朴素贝叶斯的帮助下，通过3个简单的步骤来建立一个简单的分类器！让我们直接进入编码部分。我们将使用IMDB电影评论数据集。</p><h1 id="dc51" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">1.导入和预处理！</h1><p id="3b38" class="pw-post-body-paragraph jx jy hi jz b ka ll is kc kd lm iv kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">我们将使用sklearn的朴素贝叶斯分类器和单词包中的计数矢量器来创建特征字典和矢量。</p><pre class="jh ji jj jk fd lq lr ls lt aw lu bi"><span id="ead0" class="lv ku hi lr b fi lw lx l ly lz">import re<br/>from sklearn.naive_bayes import MultinomialNB<br/>from sklearn.feature_extraction.text import CountVectorizer</span></pre><p id="80aa" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在是我们预处理语料库的时候了。我们需要清理我们的文本，以便在创建时，功能字典中没有无效的标记。</p><pre class="jh ji jj jk fd lq lr ls lt aw lu bi"><span id="4577" class="lv ku hi lr b fi lw lx l ly lz">for line in open('full_train.txt', encoding="utf8"):<br/>    reviews_train.append(line.strip().lower())<br/>for i in range(len(reviews_train)):<br/>    reviews_train[i] = re.sub(r'&lt;br.?.?&gt;','',reviews_train[i])<br/>reviews_test = []<br/>for line in open('full_test.txt', encoding="utf8"):<br/>    reviews_test.append(line.strip().lower())<br/>for i in range(len(reviews_test)):<br/>    reviews_test[i] = re.sub(r'&lt;br.?.?&gt;','',reviews_test[i])</span></pre><h1 id="198c" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">2.矢量化和标注</h1><p id="b32b" class="pw-post-body-paragraph jx jy hi jz b ka ll is kc kd lm iv kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">在我们的数据集中，对于训练和测试数据，前12500个是正面的，其他12500个是负面的评论。我们将在<em class="ma"> CountVectorizer的帮助下把我们的数据(训练数据和测试数据)转换成向量。</em>点击 <em class="ma">可以了解更多关于<em class="ma">计数矢量器</em> <a class="ae jw" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html" rel="noopener ugc nofollow" target="_blank">。它创建了特征字典，在它的帮助下，我们可以将我们的评论转换成向量。</a></em></p><pre class="jh ji jj jk fd lq lr ls lt aw lu bi"><span id="7aa3" class="lv ku hi lr b fi lw lx l ly lz">training_labels = [1 if i &lt; 12500 else 0 for i in range(25000)]<br/>test_labels = [1 if i &lt; 12500 else 0 for i in range(25000)]<br/># Defining bow_vectorizer:<br/>bow_vectorizer = CountVectorizer()<br/># Defining training_vectors:<br/>training_vectors = bow_vectorizer.fit_transform(reviews_train)<br/># Defining test_vectors:<br/>test_vectors = bow_vectorizer.transform(reviews_test)</span></pre><p id="bd51" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><em class="ma">。fit_transform() </em>方法用于根据给定的参数创建特征字典，并将输入转换为向量。同理，<em class="ma">。transform() </em>方法仅将输入转换为基于特征字典的矢量。</p><h1 id="1a9d" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">3.预测！</h1><p id="920f" class="pw-post-body-paragraph jx jy hi jz b ka ll is kc kd lm iv kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">是时候训练和预测我们的朴素贝叶斯模型了。我们将以向量的形式连同标签一起提供培训评论。训练之后，我们需要将输入转换成向量，然后再输入到模型中进行预测。</p><pre class="jh ji jj jk fd lq lr ls lt aw lu bi"><span id="a11a" class="lv ku hi lr b fi lw lx l ly lz">classifier = MultinomialNB()</span><span id="cc71" class="lv ku hi lr b fi mb lx l ly lz">def pos_or_not(label):<br/>   return "Positive" if label else "Negative"</span><span id="589c" class="lv ku hi lr b fi mb lx l ly lz">classifier.fit(training_vectors, training_labels)<br/>accuracy = classifier.score(test_vectors, test_labels)<br/>print("Accuracy: ", accuracy*100, "%")</span><span id="b219" class="lv ku hi lr b fi mb lx l ly lz">sentence = input().strip().lower()<br/>input_vector = bow_vectorizer.transform([sentence])</span><span id="8639" class="lv ku hi lr b fi mb lx l ly lz">print("Probability for review being Negative:",classifier.predict_proba(input_vector)[0][0])<br/>print("Probability for review being Positive:",classifier.predict_proba(input_vector)[0][1])<br/>predict = classifier.predict(input_vector)<br/>print(pos_or_not(predict))</span></pre><p id="8115" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">让我们通过预测评论来测试我们的模型:“我喜欢时装秀上的场景，杰西走在t台上，看着她面前的蓝色霓虹三角形。”下面是预测标签和概率的结果。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mc"><img src="../Images/de6fa2f4d7a80ae49c5a5dfee9295ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qrjE35z-9YlSb7Uj.gif"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">我们模型的输出</figcaption></figure><p id="035b" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">如果我们像这样改变评论:“我不喜欢时装秀上的场景，当杰西走在t台上，看着她面前的蓝色霓虹灯三角形。”我们将获得以下输出。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es md"><img src="../Images/90a9c8a12ba626eb75116908a78daa96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MT2dp_3UwxItRN5j.png"/></div></div></figure><p id="d28a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这是用朴素贝叶斯分类器制作的最简单的电影评论分类器。上面的代码和数据集可以在<a class="ae jw" href="https://github.com/jackfrost1411/movie-review-classifier" rel="noopener ugc nofollow" target="_blank">这里</a>找到。你可以在LinkedIn上的这里找到我<a class="ae jw" href="https://www.linkedin.com/in/dhruvil-shah-363a98173" rel="noopener ugc nofollow" target="_blank">。编码快乐！</a></p></div></div>    
</body>
</html>