# 阿帕奇卡夫卡基础部分-1

> 原文：<https://medium.com/analytics-vidhya/apache-kafka-fundementials-part-1-70baedf80662?source=collection_archive---------5----------------------->

这是我关于阿帕奇卡夫卡系列的第一篇博客，在这篇博客中，我试图清除其架构和基本组件的污垢。

![](img/737c8e9020dfd06fa746a8aa23f944cf.png)

# 为什么选择消息传递系统:

一个**消息传递系统**是建立企业集成的常用方法之一，本文的目标是帮助构建关于不同**消息传递系统、**之间的区别的坚实知识，并理解企业应用集成的不同设计考虑。

# 理解消息传递系统的基本原理:

如果您不了解每个应用程序使用由其他外部应用程序处理的数据的应用程序，或者使用来自一个或多个外部数据源的数据的应用程序，您就不会来到这里。
**消息传递系统**作为此类应用之间数据交换的集成通道。

在应用程序集成系统设计中，有几个重要的原则应该牢记在心:
**松耦合:**这个概念的实现确保了应用程序之间最小的依赖性。紧密耦合的应用程序是基于其他应用程序的预定义规范进行编码的，规范中的任何变化都会导致应用程序之间的链中断。

**通用接口定义:**确保应用程序之间交换的数据格式一致，这有助于建立应用程序之间的消息交换标准，确保信息交换的一些最佳实践能够轻松实施。

> 对于消息交换来说，Apache Avro 是一个很好选择，因为它以紧凑的二进制格式序列化数据，并支持模式评估。

**延迟:**消息在发送方和接收方之间传输所花费的时间即使在异步通信模式下，高延迟也不是一件令人满意的事情。

**可靠性:**确保应用程序的暂时不可用不会影响其他需要交换数据的相关应用程序。

# 更好地理解消息传递系统:

消息传递系统是应用程序中最常用的信息/数据交换机制之一。一些其他使用的机制可以是**远程生产者调用**、**文件共享**、**共享数据库**。
基于消息的应用程序集成包括连接到公共消息传递系统的离散企业应用程序，并向其发送数据或从其接收数据。消息传递系统充当这些应用程序之间的集成组件。

企业已经开始采用微服务架构*'这与集成系统设计原则之一* ***松耦合*** *'* 非常契合，其中最有用的好处之一是应用程序之间的解耦。

## 基本消息传递概念:

*   **消息队列**:有时是 can**队列**有时是所谓的**通道**。用简单的话来说，它们是发送方和接收方应用程序之间的连接器，它们的核心目标是及时可靠地在两种类型的应用程序之间接收和发送数据。
*   **消息**(数据包):消息是通过网络传输到消息队列的原子数据包。发送方用协议和报头信息包装消息，然后将其发送到消息队列，接收方以类似的方式从包装中提取消息以供进一步处理。
*   **Sender** (producer):它表示应用程序充当需要发送到某个目的地的数据源。它们建立到消息队列端点的连接，并以较小的数据包发送数据。根据所使用的消息传递系统的类型，发送方应用程序可以决定是逐个发送数据还是成批发送数据。
*   **接收者**(消费者):接收者或消费者应用程序是发送者应用程序发送的消息的接收者。它们通过持久连接从消息队列中提取或接收数据。一旦收到消息，它们就从中提取数据以供进一步处理。
*   **数据传输协议** : **AMQP** (高级消息队列协议) **STOMP** (面向流文本的消息协议)
    **MQTT** (消息队列遥测协议) **HTTP** (超文本传输协议)。
*   **传输模式**:同步、异步、批处理模式。

> **AMQP** 是 Apache Kafka 使用的协议， **MQTT** 是物联网应用最常用的协议。

# 点对点消息系统简介:

在点对点(PTP)消息传递模型中，消息生产者称为发送者，消费者称为接收者。它们使用称为队列的目的地交换消息。发送方向队列发送消息，接收方从队列中接收消息。点对点消息的区别在于一条消息只能被一个消费者使用。
可能有多个消费者在监听队列中的同一条消息，但只有一个消费者会收到这条消息。通常，在 PTP 模型中，接收方请求发送方发送到队列的消息，而不是订阅通道并接收特定队列上发送的所有消息。
您可以将支持 PTP 消息模型的队列看作 FIFO 队列。在这样的队列中，消息按照接收的顺序进行排序，当它们被使用时，就会从队列的头部删除。

## PTP 消息模型类型:

*   **一劳永逸的处理模式**:生产者向集中队列发送消息，不立即等待任何确认。
*   **异步请求/回复 PTP 模型**:消息发送方在一个队列上发送消息，然后在回复队列上进行阻塞等待，等待接收方的响应。请求/回复模型在发送方和接收方之间提供了高度的解耦。

> 当您希望一个接收方一次且仅一次处理任何给定消息时，以及当您需要在不同技术平台或编程语言中编写的组件之间进行同步通信时，可以使用 PTP..

## PTP 模式的启示:

*   多个发送方可以生成消息并将其发送到一个队列。发送者可以共享一个连接或者使用不同的连接，但是他们都可以访问同一个队列。
*   多个接收者可以使用队列中的消息，但是每个消息只能由一个接收者使用。
*   接收者可以共享一个连接或者使用不同的连接，但是他们都可以访问同一个队列。
*   发送方和接收方没有时间依赖性。
*   消息按照产生的顺序放在队列中，但是它们被消费的顺序取决于诸如**消息截止日期**、**消息优先级**、在消费消息时是否使用了**选择器**以及消费者的**相对消息处理速率**等因素。
*   发送方和接收方可以在运行时动态添加和删除，从而允许消息传递系统根据需要扩展或收缩。

# 发布-订阅消息传递系统:

在这种类型的模型中，订户注册其对特定主题或事件的兴趣，并随后被异步通知该事件。这些事件是由发布者生成的。它与 PTP 消息传递模型的不同之处在于，一个主题可以有多个接收者，每个接收者都接收每条消息的副本。当您需要向许多消息消费者广播事件或消息时，可以使用**发布/订阅消息模型**。与 **PTP** 消息传递模型不同，所有监听主题的消息消费者(称为**订户**)都会收到消息。

## **发布/订阅消息传递模型的要点:**

*   消息通过一个称为主题的通道共享。主题是一个集中的地方，生产者可以发布消息，订阅者可以消费消息。
*   每条消息都被传递给一个或多个消息消费者，称为订阅者。
*   发布者通常不知道也不知道哪些订阅者正在接收主题消息。
*   消息被推送给消费者，这意味着消息在消费者没有请求的情况下被传递给消费者。消息通过一个名为**主题**的虚拟通道进行交换。传递给主题的消息会自动推送给所有合格的消费者。
*   生产者和消费者之间没有耦合。订阅者和
    发布者可以在运行时动态添加，这允许系统随着时间的推移增加或减少复杂性。
*   每个订阅主题的客户端都会收到发布到该主题的消息副本
    。由一个发布者产生的单个消息可能被复制并分发给成百上千的订阅者。

> 任何需要向多个消费者通知一个事件的情况都是使用发布/订阅模型的好方法。

# 高级排队消息协议(AQMP):

AQMP 是异步消息队列的开放协议，生产者将消息发送给代理，代理再将消息传递给消费者。每个代理都有一个名为 exchange 的组件，负责将消息从生产者路由到适当的消息队列。

## AQMP 信息系统:

*   出版商。
*   消费者。
*   经纪人/服务器。

每个组件在数量上可以是多个，并且位于独立的主机上。发布者和消费者通过绑定到代理内部交换的消息队列相互通信。AQMP 提供可靠、有保证、有序的消息传递。

# 在大数据流应用中使用消息传递系统:

让我们了解一下大数据应用程序中的不同层:
**摄取层:**处理所需的输入数据在某个存储系统中被摄取。
**:处理层:**包含业务逻辑，处理接收层接收到的数据，并应用某种转换，使其成为可用的形式。每个应用程序可能具有不同的处理逻辑和能力。
**消费层:**该层包含由处理层处理的数据。这些经过处理的数据是一个单一的事实点，包含了对业务决策者来说非常重要的信息。可以有多个消费者将相同的数据用于不同的目的，或者将不同的数据用于相同的目的。

> 流媒体应用可能属于第二层——处理层。

## 对任何流媒体应用程序都很重要的几点:

*   ***高消耗率* :** 流数据来源可以是点击流数据，也可以是社交媒体数据，这些数据的消息产生率太高。我们可能希望有一个能够以更高的速率消耗数据的消息队列。
*   **保证传递:**一些流媒体应用不能承受消息丢失；我们需要一个系统来保证在任何需要的时候将消息传递给流应用程序。
*   **持久化能力:**可以有多个应用程序以不同的速率使用相似的数据。我们可能希望有一个消息传递系统，它将数据保留一段时间，并将数据异步提供给不同的应用程序。这有助于解耦所有应用和设计微服务架构。
*   **安全性:**我们可能不希望与使用同一消息系统的其他应用
    共享一些数据。你需要一个系统来确保这种安全性。
*   容错:应用程序永远不想拥有一个不能在需要时传递消息或数据的系统。

# 参考资料:

***用 Apache Kafka 构建数据流应用程序—***Chanchal Singh 和 Manish Kumar 的书

# 在以下位置找到我:

**领英:**[https://www.linkedin.com/in/yamenshaban/](https://www.linkedin.com/in/yamenshaban/)