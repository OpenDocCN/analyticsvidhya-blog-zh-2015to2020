<html>
<head>
<title>2D Convolution using Python &amp; NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和NumPy的2D卷积</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/2d-convolution-using-python-numpy-43442ff5f381?source=collection_archive---------0-----------------------#2020-06-18">https://medium.com/analytics-vidhya/2d-convolution-using-python-numpy-43442ff5f381?source=collection_archive---------0-----------------------#2020-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/193ce1ad13f2b17d288437616391cd29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LS6qplIzS5oRWNii2KcWcA.png"/></div></div></figure><p id="22a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2D卷积在创建卷积神经网络或仅用于模糊、锐化、边缘检测等一般图像处理过滤器时非常有用。它们基于使用内核并遍历输入图像来创建输出图像的思想。如果你是卷积的新手，我会高度推荐deeplearning.ai在卷积神经网络上的播放列表。</p><p id="1926" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们将实现一个2D卷积，然后使用2D卷积将边缘检测内核应用于图像。</p><h1 id="2d6f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">进口</h1><p id="ccc2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了实现2D卷积，我们需要两个库:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2cf2" class="lb jq hi kx b fi lc ld l le lf">import cv2 <br/>import numpy as np</span></pre><p id="ec8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OpenCV将用于预处理图像，而NumPy将用于实现实际的卷积。</p><h1 id="78e8" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">预处理图像</h1><p id="80de" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了获得2D卷积的最佳效果，通常建议您对图像进行灰度处理。为此，我们可以编写一个方法。我们先来看看:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1fe0" class="lb jq hi kx b fi lc ld l le lf">def processImage(image):</span></pre><p id="6500" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个方法将有一个参数，它将是图像文件的名称。您将希望确保您的图像存储在与python文件相同的目录中，否则您可能必须指定完整的路径。要读取内容并将其转换为灰度，我们可以添加以下代码行:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ff31" class="lb jq hi kx b fi lc ld l le lf">image = cv2.imread(image) <br/>image = cv2.cvtColor(src=image, code=cv2.COLOR_BGR2GRAY) <br/>return image</span></pre><p id="a02c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当使用OpenCV读取图像时，默认模式是BGR，而不是RGB，因此我们希望将code参数指定为BGR2GRAY，从而允许我们将BGR图像转换为灰度图像。然后我们将返回新的图像。</p><p id="50e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">全过程图像方法:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><h1 id="7c2b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2D卷积</h1><p id="5f48" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">要开始2D卷积方法，我们需要以下方法标题:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c8f8" class="lb jq hi kx b fi lc ld l le lf">def convolve2D(image, kernel, padding=0, strides=1):</span></pre><p id="ca4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使得图像和内核由用户指定，并且图像周围的默认填充为0，默认步幅为1。</p><p id="c0a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一件事，我们必须做的是应用互相关到我们的内核，这可以通过使用NumPy非常容易地完成，只需水平翻转矩阵，然后垂直。这看起来像:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="dbd5" class="lb jq hi kx b fi lc ld l le lf">kernel = np.flipud(np.fliplr(kernel))</span></pre><p id="8ed9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们需要计算输出图像的矩阵大小。这可以通过以下公式非常简单地实现:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/1eacc1b78767978a062e0f8ec13db5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*V5ZIZg7cGHLASKbnRbKBJQ.png"/></div></div></figure><p id="50cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这必须在每个维度(x，y)上实现。首先，我们必须收集图像和内核的x和y尺寸。这可以通过以下方式实现:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="76e8" class="lb jq hi kx b fi lc ld l le lf">xKernShape = kernel.shape[0] <br/>yKernShape = kernel.shape[1] <br/>xImgShape = image.shape[0] <br/>yImgShape = image.shape[1]</span></pre><p id="2591" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们可以对每个输出维度应用大小公式:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c0a9" class="lb jq hi kx b fi lc ld l le lf">xOutput = int(((xImgShape — xKernShape + 2 * padding) / strides) + 1)</span><span id="347a" class="lb jq hi kx b fi lj ld l le lf"> yOutput = int(((yImgShape — yKernShape + 2 * padding) / strides) + 1)</span></pre><p id="b4b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们可以用推导出的维度创建一个新的矩阵:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="147b" class="lb jq hi kx b fi lc ld l le lf">output = np.zeros((xOutput, yOutput))</span></pre><p id="c895" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法特别依赖于在每一侧均匀填充。首先，我们要检查填充是否为0，如果是，为了避免错误，我们不想应用不必要的操作。所以我们从下面的条件语句开始:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="83c4" class="lb jq hi kx b fi lc ld l le lf">if padding != 0:</span></pre><p id="bab2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们用填充的维度创建一个新的零数组。这可以通过以下方式实现:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7abb" class="lb jq hi kx b fi lc ld l le lf">imagePadded = np.zeros((image.shape[0] + padding*2, image.shape[1] + padding*2))</span></pre><p id="6361" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:我们将填充乘以2，因为我们在所有边上都应用了均匀的填充，所以填充1会将填充图像的尺寸增加2。</p><p id="04b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们用实际图像替换填充图像的内部部分:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6136" class="lb jq hi kx b fi lc ld l le lf">imagePadded[int(padding):int(-1 * padding), int(padding):int(-1 * padding)] = image</span></pre><p id="abd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果没有填充，我们有一个else语句使填充的图像等于图像:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="23c9" class="lb jq hi kx b fi lc ld l le lf">else: <br/>    imagePadded = image</span></pre><p id="5701" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们进入卷积的核心。我们必须遍历图像并应用元素乘法，然后对其求和，并将其设置为等于输出数组中的相应元素。首先，我们可以编写第一个循环:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f742" class="lb jq hi kx b fi lc ld l le lf">for y in range(image.shape[1]):</span></pre><p id="fad8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将用于遍历所有y维元素。然后我们有一个break语句:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2b6c" class="lb jq hi kx b fi lc ld l le lf">if y &gt; image.shape[1] — yKernShape: <br/>    break</span></pre><p id="0332" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个语句允许我们检查我们是否在y方向上位于图像的末端。一旦我们到达图像矩阵的最右下角，它将退出完整的卷积。</p><p id="9fcc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们有一个条件语句来考虑跨度:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d882" class="lb jq hi kx b fi lc ld l le lf">if y % strides == 0:</span></pre><p id="7ddc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将确保步长等于指定的步幅量。</p><p id="8661" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们有一个循环，遍历x维中的每个元素:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="727e" class="lb jq hi kx b fi lc ld l le lf">for x in range(image.shape[0]):</span></pre><p id="3fcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们接下来要检查的是内核是否在图像的最右边。如果是，那么它将脱离x循环，然后在y方向向下移动，并重新开始卷积过程。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="8198" class="lb jq hi kx b fi lc ld l le lf">if x &gt; image.shape[0] — xKernShape: <br/>    break</span></pre><p id="83a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们有主卷积运算符，它应用卷积，对元素求和，并将其附加到输出矩阵:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="225a" class="lb jq hi kx b fi lc ld l le lf">try:<br/>   if x % strides == 0: <br/>      output[x, y] = (kernel * imagePadded[x: x + xKernShape, y: y + yKernShape]).sum() </span><span id="5f8c" class="lb jq hi kx b fi lj ld l le lf">except: <br/>   break</span></pre><p id="ec5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后我们返回输出！</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="9d8d" class="lb jq hi kx b fi lc ld l le lf">return output</span></pre><p id="5e50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整的卷积方法如下所示:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><h1 id="516d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">测试2D卷积；</h1><p id="4235" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我决定将边缘检测内核应用到我的2D卷积中。这是我最初的图像:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/75edb5da879f047b4c778ad562b3e5b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*APsEcslehRkCD9IXq6P2Mw.jpeg"/></div></figure><p id="1aff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我使用的内核是:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6718" class="lb jq hi kx b fi lc ld l le lf">kernel = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])</span></pre><p id="3381" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我完整的main方法看起来像:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="65a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用卷积后，我得到了以下边缘:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/ef79da2f534c104b839ab0e30e72785c.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*OA1xAIXiVzeiFDZN-67FnQ.jpeg"/></div></figure><p id="e15a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我认为可以肯定地说，它工作得相当好！我的完整代码可以在Github的这里找到。如果你有任何问题或者只是想表达一些想法，你可以在推特上联系我<a class="ae jo" href="https://twitter.com/samratdotjs" rel="noopener ugc nofollow" target="_blank"> @samratdotjs </a>！</p><p id="6880" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>