<html>
<head>
<title>Machine Learning to Predict the Survivals of Titanic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习预测泰坦尼克号的幸存者</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-to-predict-the-survivals-of-titanic-5968167e5ece?source=collection_archive---------7-----------------------#2020-11-22">https://medium.com/analytics-vidhya/machine-learning-to-predict-the-survivals-of-titanic-5968167e5ece?source=collection_archive---------7-----------------------#2020-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ad7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">泰坦尼克号生存预测项目是一个为数据科学领域的初学者所熟知的项目。它涵盖了数据清理、数据探索、数据可视化和机器学习的所有基础知识。</p><p id="303b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将解释我是如何应对这个挑战以达到0.8的准确率，并在Kaggle的泰坦尼克号比赛中取得前9%的成绩。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="49a4" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">1.必要的库</h1><p id="e5cc" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">该项目中使用的库/包有:</p><ul class=""><li id="7d46" class="kn ko hi ih b ii ij im in iq kp iu kq iy kr jc ks kt ku kv bi translated"><a class="ae kw" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>:用于数据分析处理的库。</li><li id="2be0" class="kn ko hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated"><a class="ae kw" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>:用于数据可视化的库。这是Python的绘图库。</li><li id="187d" class="kn ko hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated"><a class="ae kw" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> seaborn </a>:建立在matplotlib之上的库。它还用于数据可视化。</li><li id="1c2a" class="kn ko hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated"><a class="ae kw" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>:支持各种监督和非监督学习算法的机器学习库。</li><li id="365d" class="kn ko hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated"><a class="ae kw" href="https://xgboost.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>:一个提供梯度增强决策树的库。它以高性能和高速度著称。</li></ul><blockquote class="lc ld le"><p id="991f" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">有趣的事实:)</em> </strong> <em class="hi">熊猫的名字是对“Python数据分析”的一种文字游戏。根据</em> <a class="ae kw" href="https://en.wikipedia.org/wiki/Pandas_(software)" rel="noopener ugc nofollow" target="_blank"> <em class="hi">维基百科</em> </a> <em class="hi">的说法，该名称来源于“panel data”，这是计量经济学中的一个术语，用来描述包含同一个体多个时间段的观察值的数据集。</em></p></blockquote><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="7f12" class="ls jl hi lo b fi lt lu l lv lw">import pandas as pd<br/>import matplotlib.pypolt as plt <br/>import seaborn as sns</span><span id="84ad" class="ls jl hi lo b fi lx lu l lv lw">from sklearn.model_selection import train_test_split<br/>from xgboost import XGBClassifier<br/>from sklearn.model_selection import RandomizedSearchCV</span></pre><h1 id="ed31" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">2.获取数据</h1><p id="6882" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">任何数据科学项目的第一步都是获取数据。数据可以以多种形式出现。在这个项目中，训练和测试数据是结构化的，标记为从CSV文件导入的数据。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="71d7" class="ls jl hi lo b fi lt lu l lv lw">train_data = pd.read_csv("train.csv")<br/>test_data = pd.read_csv("test.csv")</span></pre><h1 id="73ea" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">3.探索和预处理数据</h1><p id="3758" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">在这一部分，借助数据可视化对数据进行分析，并根据分析结果对数据进行预处理。注意，在训练数据上完成的所有数据预处理也应该在测试数据上完成。</p><p id="f147" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python中的<em class="lf"> train_data.info() </em>有助于获得数据集的简短摘要</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8cbf" class="ls jl hi lo b fi lt lu l lv lw">train_data.info()</span></pre><figure class="lj lk ll lm fd me er es paragraph-image"><div class="er es md"><img src="../Images/1d6d92d236c1e325b397db0585b3d61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*1IRchY9GpE8zJxvsQ3QQ_w.png"/></div></figure><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="a71d" class="ls jl hi lo b fi lt lu l lv lw">columns = train_data.columns</span><span id="e9d2" class="ls jl hi lo b fi lx lu l lv lw">for col in columns:<br/>   print("unique values in {} column is: {}". format(col,<br/>   train_data[col].value_counts().size))<br/>____________________________________________________________________</span><span id="8616" class="ls jl hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="lf">unique values in PassengerId column is: 891 <br/>unique values in Survived column is: 2 <br/>unique values in Pclass column is: 3 <br/>unique values in Name column is: 891 <br/>unique values in Sex column is: 2 <br/>unique values in Age column is: 88 <br/>unique values in SibSp column is: 7 <br/>unique values in Parch column is: 7 <br/>unique values in Ticket column is: 681 <br/>unique values in Fare column is: 248 <br/>unique values in Cabin column is: 147 <br/>unique values in Embarked column is: 3<br/></em></strong>____________________________________________________________________</span></pre><p id="b727" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练集由891行组成。每个乘客都有一个唯一的PassengerId。摘要显示某些功能缺少值，并且有三种不同类型的功能:int64、float64和object。</p><p id="c7f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lf"> train_data[col]。value_counts()。size </em>允许了解每一列的唯一值/元素的数量(即:特性)。<a class="ae kw" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.value_counts.html" rel="noopener ugc nofollow" target="_blank"><em class="lf">pandas . series . value _ counts</em></a><em class="lf"/>返回系列中唯一值的大小。</p><p id="2f9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第3.1-3.8节描述了这些特性，并讨论了如何处理它们。</p><h1 id="3433" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">3.1性</h1><p id="671b" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">性别特征用于获得船上性别分布的概况。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="ce44" class="ls jl hi lo b fi lt lu l lv lw">print("Total number of male passengers:")<br/>print(train_data.loc[train_data.Sex=="male"].Sex.size)<br/>print("Total number of female passengers:")<br/>print(train_data.loc[train_data.Sex=="female"].Sex.size)<br/>____________________________________________________________________      </span><span id="33ae" class="ls jl hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="lf">Total number of male passengers: 577 <br/>Total number of female passengers: 314<br/></em></strong>____________________________________________________________________</span></pre><p id="d499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管男性乘客比女性多，但数据显示女性比男性有更多的生存机会。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="05f5" class="ls jl hi lo b fi lt lu l lv lw">print("The percentage of survived with respect to Sex:")<br/>print(100 * train_data.groupby("Sex").Survived.mean())<br/>____________________________________________________________________</span><span id="01bc" class="ls jl hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="lf">The percentage of survived with respect to Sex: <br/>Sex <br/>female    74.203822 <br/>male      18.890815 <br/>Name: Survived, dtype: float64<br/></em></strong>____________________________________________________________________</span></pre><h1 id="dc9d" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">3.2年龄</h1><p id="b77e" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">因为年龄是float64类型，所以使用直方图来理解存活和年龄特征之间的关系。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="dfc1" class="ls jl hi lo b fi lt lu l lv lw">g = sns.FacetGrid(col="Survived", data=train_data, height = 2, aspect=3)<br/>g.map(sns.distplot, "Age", kde=False, bins=80)</span></pre><figure class="lj lk ll lm fd me er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mh"><img src="../Images/2a5061082bfab9e47e1026f4b6428dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIuoqZcMQ6bMp-Z2aKAwWg.png"/></div></div></figure><p id="43af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直方图显示，儿童有更高的生存机会。为了更好的理解，使用<a class="ae kw" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.cut.html" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> pandas.cut </em> </a>对年龄特征进行分类。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="5a16" class="ls jl hi lo b fi lt lu l lv lw">def cut_age(df, cut_values, label_names):</span><span id="41e4" class="ls jl hi lo b fi lx lu l lv lw"><em class="lf">   # fill missing values with -0.5<br/>   </em>df["Age"] = df["Age"].fillna(-0.5)<br/>   df["Age"]=pd.cut(df["Age"], bins=cut_values, labels=label_names)<br/>   return df</span><span id="e115" class="ls jl hi lo b fi lx lu l lv lw">cut_values=[-1, 0, 3, 12, 19, 35, 60, 80]</span><span id="5b42" class="ls jl hi lo b fi lx lu l lv lw">label_names=["Missing", "Infants", "Children", "Teenagers", "Young    Adults", "Middle-Age Adults", "Seniors"]</span><span id="6a86" class="ls jl hi lo b fi lx lu l lv lw">train_data=cut_age(train_data, cut_values, label_names)<br/>test_data=cut_age(test_data, cut_values, label_names)</span><span id="5d0d" class="ls jl hi lo b fi lx lu l lv lw">sns.catplot(x="Age", row="Survived", kind="count", height=3, aspect=4, data=train_data)</span></pre><figure class="lj lk ll lm fd me er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mm"><img src="../Images/3a7e05c2525645036030d8adf10cab9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBpQreF5_AYD6mHHgv2s-w.png"/></div></div></figure><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="62f4" class="ls jl hi lo b fi lt lu l lv lw">print(100 * train_data.groupby("Age").Survived.mean())<br/>____________________________________________________________________</span><span id="c9e8" class="ls jl hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="lf">Age <br/>Missing              29.378531 <br/>Infants              66.666667 <br/>Children             51.282051 <br/>Teenagers            41.052632 <br/>Young Adults         38.438438 <br/>Middle-Age Adults    40.000000 <br/>Seniors              22.727273 <br/>Name: Survived, dtype: float64<br/></em></strong>____________________________________________________________________</span></pre><p id="182a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果确实证明，儿童比其他年龄组存活的时间更长。</p><h1 id="f076" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">3.3 SibSp和炒制</h1><ul class=""><li id="91df" class="kn ko hi ih b ii ki im kj iq mn iu mo iy mp jc ks kt ku kv bi translated">SibSp特征指示乘客与兄弟姐妹(即:兄弟/姐妹)和配偶(即:丈夫/妻子)的关系</li><li id="c422" class="kn ko hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated">Parch特征表示乘客与船上父母(即:父亲/母亲)或子女的关系</li></ul><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8849" class="ls jl hi lo b fi lt lu l lv lw">print("The percentage of survived with respect to SibSp:")<br/>print(100 * train_data.groupby("Age").Survived.mean())<br/>____________________________________________________________________</span><span id="7beb" class="ls jl hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="lf">The percentage of survived with respect to SibSp: <br/>SibSp <br/>0    34.539474 <br/>1    53.588517 <br/>2    46.428571 <br/>3    25.000000 <br/>4    16.666667 <br/>5     0.000000 <br/>8     0.000000 <br/>Name: Survived, dtype: float64<br/></em></strong>____________________________________________________________________</span><span id="6de7" class="ls jl hi lo b fi lx lu l lv lw">print("The percentage of survived with respect to Parch:")<br/>print(100 * train_data.groupby("Parch").Survived.mean())<br/>____________________________________________________________________</span><span id="0c27" class="ls jl hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="lf">The percentage of survived with respect to Parch: <br/>Parch <br/>0    34.365782 <br/>1    55.084746 <br/>2    50.000000 <br/>3    60.000000 <br/>4     0.000000 <br/>5    20.000000 <br/>6     0.000000 <br/>Name: Survived, dtype: float64<br/></em></strong>____________________________________________________________________</span></pre><p id="bdb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果显示，独自一人(没有家庭成员)的个体比有1到3个家庭成员在船上的个体有更少的生存机会。但是，当家庭成员超过3个时，生存机会下降。更准确地说，Parch和SibSp特性将合并成一个特性，称为Fam_membs。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="089a" class="ls jl hi lo b fi lt lu l lv lw">def Cr_fam_membs(df):<br/>   df["FamMembs"]= df["Parch"] + df["SibSp"]<br/>   df=df.drop(["SibSp", "Parch"], axis=1)<br/>   return df</span><span id="d7a4" class="ls jl hi lo b fi lx lu l lv lw">train_data=Cr_fam_membs(train_data)<br/>test_data=Cr_fam_membs(test_data)</span><span id="1cdd" class="ls jl hi lo b fi lx lu l lv lw">print(100 * train_data.groupby("FamMembs").Survived.mean())<br/><strong class="lo hj"><em class="lf">____________________________________________________________________<br/>FamMembs <br/>0     30.353818 <br/>1     55.279503 <br/>2     57.843137 <br/>3     72.413793 <br/>4     20.000000 <br/>5     13.636364 <br/>6     33.333333 <br/>7      0.000000 <br/>10     0.000000 <br/>Name: Survived, dtype: float64<br/></em></strong>____________________________________________________________________</span></pre><p id="4636" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了限制Fam_membs功能中的类别数量，它将被分为以下4个类别:</p><ul class=""><li id="73e3" class="kn ko hi ih b ii ij im in iq kp iu kq iy kr jc ks kt ku kv bi translated">IsAlone: 0个家庭成员</li><li id="e73a" class="kn ko hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated">小家庭:1-3个成员</li><li id="49b7" class="kn ko hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated">中等家庭:4-6个家庭成员</li><li id="2c20" class="kn ko hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated">大家庭:7-10个成员</li></ul><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="3c11" class="ls jl hi lo b fi lt lu l lv lw">train_data["FamMembs"]=train_data["FamMembs"].apply(lambda s:    "IsAlone" if s==0 else s)<br/>train_data["FamMembs"]=train_data["FamMembs"].apply(lambda s: "Small family" if (s==1 or s==2 or s==3) else s)<br/>train_data["FamMembs"]=train_data["FamMembs"].apply(lambda s: "Meduim family" if (s==4 or s==5 or s==6) else s)<br/>train_data["FamMembs"]=train_data["FamMembs"].apply(lambda s: "Large family" if (s==7 or s==10) else s)</span><span id="4176" class="ls jl hi lo b fi lx lu l lv lw">test_data["FamMembs"].value_counts()<br/><strong class="lo hj"><em class="lf">____________________________________________________________________<br/></em></strong><br/><strong class="lo hj"><em class="lf">IsAlone          253 <br/>Small family     145 <br/>Meduim family     14 <br/>Large family       6 <br/>Name: FamMembs, dtype: int64<br/></em></strong>____________________________________________________________________</span></pre><p id="33b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">家庭成员特征使人们更容易理解家庭规模如何影响生存机会。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="4657" class="ls jl hi lo b fi lt lu l lv lw">print("The percentage of survived with respect to Fam_membs:")<br/>print(100 * train_data.groupby("FamMembs").Survived.mean())<br/>____________________________________________________________________<strong class="lo hj"><em class="lf">The percentage of survived with respect to Fam_membs: <br/>FamMembs <br/>IsAlone          30.353818 <br/>Large family      0.000000 <br/>Meduim family    20.408163 <br/>Small family     57.876712 <br/>Name: Survived, dtype: float64<br/></em></strong>____________________________________________________________________</span><span id="5e42" class="ls jl hi lo b fi lx lu l lv lw">sns.catplot(x="FamMembs", row="Survived", kind="count", height=3, aspect=4, data=train_data)</span></pre><figure class="lj lk ll lm fd me er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mq"><img src="../Images/ccc83d89b8f2baedd1ae4898715c95cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CvzU2xkncYHG2XqkW_NgQ.png"/></div></div></figure><h1 id="5d66" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">3.4 Pclass</h1><p id="2076" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">Pclass代表乘客的等级。它被分为一、二、三三等。正如所料，属于一等舱的乘客存活率最高，属于三等舱的乘客存活率最低。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9381" class="ls jl hi lo b fi lt lu l lv lw">print(“The percentage of survived with respect to Pclass:”)<br/>print(100 * train_data.groupby(“Pclass”).Survived.mean())<br/>____________________________________________________________________<strong class="lo hj"><em class="lf">The percentage of survived with respect to Pclass: <br/>Pclass <br/>1    62.962963 <br/>2    47.282609 <br/>3    24.236253 <br/>Name: Survived, dtype: float64<br/></em></strong>____________________________________________________________________</span></pre><h1 id="5c19" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">3.5上船</h1><p id="1875" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">装船港是C =瑟堡，Q =皇后镇和S =南安普敦。由于装载特征中的缺失值仅限于2，因此在训练数据中，它们由最频繁出现的值填充。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="6027" class="ls jl hi lo b fi lt lu l lv lw">train_data["Embarked"]=train_data["Embarked"].fillna(train_data["Embarked"].mode()[0])</span></pre><h1 id="76a2" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">3.6票价</h1><p id="2928" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">与年龄特征相似，票价采用<a class="ae kw" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.qcut.html" rel="noopener ugc nofollow" target="_blank"> <em class="lf">熊猫分类。qcut </em> </a>。<em class="lf">大熊猫之间的主要区别在于<em class="lf">大熊猫。qcut </em>会创建相同大小的箱子，而<em class="lf">大熊猫。cut </em>用于精确指定箱子的边缘。<em class="lf">熊猫。cut </em>不使用，因为不清楚票价是如何分配的，以及它与其他特征之间的关系；因此，箱子的边缘不容易确定。查看本<a class="ae kw" href="https://github.com/kheirie/First-ML-Project---Titanic/blob/main/towards-machine-learning-with-titanic.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>了解更多关于如何针对Pclass和loaded特性分析Fare特性的详细信息。</em></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="38a0" class="ls jl hi lo b fi lt lu l lv lw">def qcut_fare(df, q, labels):<br/>   df["Fare"]=pd.qcut(df["Fare"], q, labels=labels)<br/>   return df</span><span id="9cbe" class="ls jl hi lo b fi lx lu l lv lw">labels=["range1", "range2", "range3", "range4"]<br/>train_data=qcut_fare(train_data, 4, labels)</span></pre><p id="6ced" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">q=4用于根据<a class="ae kw" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.describe.html" rel="noopener ugc nofollow" target="_blank"> <em class="lf">大熊猫的默认百分位数进行数据划分。系列描述</em> </a>(即:范围1: min-0.25，范围2: 0.25-0.5，范围3: 0.5-0.75，范围4: 0.75-max)。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="97de" class="ls jl hi lo b fi lt lu l lv lw">train_data[“Fare”].describe()<br/>____________________________________________________________________<strong class="lo hj"><em class="lf">count    891.000000<br/>mean      32.204208<br/>std       49.693429<br/>min        0.000000<br/>25%        7.910400<br/>50%       14.454200<br/>75%       31.000000<br/>max      512.329200<br/>Name: Fare, dtype: float64<br/></em></strong>____________________________________________________________________</span><span id="0874" class="ls jl hi lo b fi lx lu l lv lw">sns.catplot(x="Fare", data=train_data, kind="count", height=2, aspect=3)</span></pre><figure class="lj lk ll lm fd me er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mr"><img src="../Images/80fcd8e8ee500e00a6af3c9424388f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RD_Rai6zHXTiFX3zkOPuFQ.png"/></div></div></figure><h1 id="1e55" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">3.7姓名</h1><p id="a49a" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">很容易认为名称功能没有用，因为每个人都有一个唯一的名字。然而，仔细观察这个特性，你会发现名字有标题，这对预测很有用。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8637" class="ls jl hi lo b fi lt lu l lv lw">train_data["Name"]<br/>____________________________________________________________________<strong class="lo hj"><em class="lf">0                                Braund, Mr. Owen Harris<br/>1      Cumings, Mrs. John Bradley (Florence Briggs Th...<br/>2                                 Heikkinen, Miss. Laina<br/>3           Futrelle, Mrs. Jacques Heath (Lily May Peel)<br/>4                               Allen, Mr. William Henry<br/>                             ...                        <br/>886                                Montvila, Rev. Juozas<br/>887                         Graham, Miss. Margaret Edith<br/>888             Johnston, Miss. Catherine Helen "Carrie"<br/>889                                Behr, Mr. Karl Howell<br/>890                                  Dooley, Mr. Patrick<br/>Name: Name, Length: 891, dtype: object<br/></em></strong>____________________________________________________________________</span></pre><p id="a781" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">名称特征中的名称由头衔(即:先生、夫人、小姐)(如果有的话)或“其他”(在没有头衔或头衔非常罕见的情况下)代替。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="40b8" class="ls jl hi lo b fi lt lu l lv lw">train_data["Name"]=train_data["Name"].apply(lambda s: s.split(', ')[1].split('.')[0])</span><span id="a1c2" class="ls jl hi lo b fi lx lu l lv lw">train_data["Name"].value_counts()<em class="lf"><br/></em>____________________________________________________________________<strong class="lo hj"><em class="lf">Mr              517<br/>Miss            182<br/>Mrs             125<br/>Master           40<br/>Dr                7<br/>Rev               6<br/>Major             2<br/>Col               2<br/>Mlle              2<br/>Mme               1<br/>Sir               1<br/>Ms                1<br/>the Countess      1<br/>Capt              1<br/>Jonkheer          1<br/>Don               1<br/>Lady              1<br/>Name: Name, dtype: int64<br/></em></strong>____________________________________________________________________</span><span id="a9c2" class="ls jl hi lo b fi lx lu l lv lw">train_data["Name"]=train_data["Name"].replace(["Ms", "Mlle"], "Miss")<br/>train_data["Name"]=train_data["Name"].replace(["Sir"], "Mr")<br/>train_data["Name"]=train_data["Name"].replace(["Mme"], "Mrs")<br/>train_data["Name"]=train_data["Name"].replace(["Dr", "Rev", "Col", "Major", "Capt", "Master", "Lady", "the Countess", "Don", "Dona", "Jonkheer"], "Other")</span><span id="26e4" class="ls jl hi lo b fi lx lu l lv lw">sns.catplot(x="Name", hue="Survived", kind="count", data=train_data)</span></pre><figure class="lj lk ll lm fd me er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es ms"><img src="../Images/2bd574d0b6294a043efacced21c0ad36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*brSDbba_Z6Z-hjck79mGOw.png"/></div></div></figure><p id="9405" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据性别特征推断，上图证明女性(“夫人”和“小姐”)比男性(“先生”)有更多的生存机会。</p><h1 id="abf4" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">3.8舱室</h1><p id="99b5" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">即使“机舱”功能有许多缺失值，也不会直接删除。它用于创建一个名为“甲板”的新功能。舱室位于不同的甲板上，即:A、B、C、D、E、F、G和t。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="d947" class="ls jl hi lo b fi lt lu l lv lw"><em class="lf"># fill the missing values with "Unknown"</em><br/>train_data[“Cabin”]=train_data[“Cabin”].fillna(“Unknown”) </span><span id="de5b" class="ls jl hi lo b fi lx lu l lv lw"><em class="lf"># remove digits to create the deck feature<br/></em>train_data["Deck"]=train_data["Cabin"].str.replace("([0-9\s])+","")</span><span id="0d09" class="ls jl hi lo b fi lx lu l lv lw">train_data["Deck"].value_counts()<br/>____________________________________________________________________<strong class="lo hj"><em class="lf">Unknown    687<br/>C           51<br/>B           36<br/>D           32<br/>E           32<br/>A           15<br/>F            9<br/>BB           7<br/>CC           4<br/>G            4<br/>CCC          4<br/>FG           3<br/>BBB          2<br/>BBBB         2<br/>FE           1<br/>T            1<br/>DD           1<br/>Name: Deck, dtype: int64<br/></em></strong>____________________________________________________________________</span></pre><p id="be91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据显示，一些乘客有不止一个客舱。其中一些在同一层甲板上，另一些在不同的甲板上。为了解决这个问题，创建了一个新功能来指示每个乘客的客舱总数。如果乘客舱未知，则为0。对于由一个以上字母组成的甲板，取第一个字母。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="64c5" class="ls jl hi lo b fi lt lu l lv lw">def total_cabins(row):<br/>   if row.Deck == "Unknown":<br/>      row["TotalCab"] = 0<br/>   elif len(row.Deck) &gt; 1:<br/>      row["TotalCab"] = len(row.Deck)<br/>   else:<br/>      row["TotalCab"] = 1<br/>   return row</span><span id="178d" class="ls jl hi lo b fi lx lu l lv lw">train_data=train_data.apply(total_cabins, axis=1)</span><span id="5ba3" class="ls jl hi lo b fi lx lu l lv lw">train_data["TotalCab"].value_counts()<br/>____________________________________________________________________<strong class="lo hj"><em class="lf">0    687<br/>1    180<br/>2     16<br/>3      6<br/>4      2<br/>Name: TotalCab, dtype: int64<br/></em></strong>____________________________________________________________________</span><span id="2b06" class="ls jl hi lo b fi lx lu l lv lw">train_data["Deck"]=train_data["Deck"].apply(lambda s: s[0] if s != "Unknown" else s)</span><span id="a478" class="ls jl hi lo b fi lx lu l lv lw">train_data["Deck"].value_counts()<br/>____________________________________________________________________<strong class="lo hj"><em class="lf">Unknown    687<br/>C           59<br/>B           47<br/>D           33<br/>E           32<br/>A           15<br/>F           13<br/>G            4<br/>T            1<br/>Name: Deck, dtype: int64<br/></em></strong>____________________________________________________________________</span></pre><h1 id="eb2f" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">3.9删除不必要的栏目</h1><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="80f9" class="ls jl hi lo b fi lt lu l lv lw">train_data=train_data.drop(["Survived", "Cabin", "Ticket"], axis=1)</span></pre><h1 id="03d6" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">4.处理分类价值</h1><p id="1b2f" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">机器学习模型只理解数值。<a class="ae kw" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank"> <em class="lf">一热编码</em> </a>用于将非数字数据转换为数字数据。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="137b" class="ls jl hi lo b fi lt lu l lv lw">from sklearn.preprocessing import OneHotEncoder</span><span id="282a" class="ls jl hi lo b fi lx lu l lv lw">OHE = OneHotEncoder(handle_unknown='ignore', sparse=False)</span><span id="90cd" class="ls jl hi lo b fi lx lu l lv lw">features = ["Pclass", "Name", "Sex", "Age", "Fare", "Embarked",<br/>            "FamMembs", "Deck", "TotalCab"]</span><span id="04fc" class="ls jl hi lo b fi lx lu l lv lw">OHE_train_cols=pd.DataFrame(OHE.fit_transform(train_data[features]))</span><span id="8982" class="ls jl hi lo b fi lx lu l lv lw">OHE_train_cols.index=train_data.index<br/><br/>num_train=train_data.drop(features, axis=1)</span><span id="5f58" class="ls jl hi lo b fi lx lu l lv lw">train_data = pd.concat([num_train, OHE_train_cols], axis=1)</span><span id="a137" class="ls jl hi lo b fi lx lu l lv lw">print(train_data.shape)<br/>____________________________________________________________________</span><span id="163d" class="ls jl hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="lf">(891, 42)<br/></em></strong>____________________________________________________________________</span></pre><h1 id="8c37" class="jk jl hi bd jm jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh bi translated">5.使用RandomizedSearchCV调整XGBoost参数</h1><p id="1277" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated"><a class="ae kw" href="https://xgboost.ai/" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>代表极限梯度提升。这是一种基于决策树的模型集成算法，实现了梯度推进框架。它专为速度和性能而设计。XGBoost在处理结构化/表格数据时证明了它的优越性，这个项目就是这样。</p><p id="f630" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这个项目中解决的问题被认为是一个分类问题，因为结果要么是1(幸存)，要么是0(未幸存)。在这种情况下使用XGBClassifier。</p><p id="3625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kw" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.RandomizedSearchCV.html" rel="noopener ugc nofollow" target="_blank"> RandomizedSearchCV </a>用于寻找最佳参数。它传递给定的参数集，计算分数并给出最佳的参数集。这个过程有时被称为超参数调整。它还执行train_test_split。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="c542" class="ls jl hi lo b fi lt lu l lv lw">from xgboost import XGBClassifier<br/>from sklearn.model_selection import RandomizedSearchCV</span><span id="4b30" class="ls jl hi lo b fi lx lu l lv lw">xgb=XGBClassifier(objective='reg:logistic')</span><span id="4f17" class="ls jl hi lo b fi lx lu l lv lw">params={<br/>    'n_estimators': [200, 500, 1000],<br/>    'learning_rate': [0.01, 0.05, 0.1],<br/>    'max_depth': [5, 7, 9],<br/>    'colsample_bytree': [ 0.4, 0.6, 0.8],<br/>    'subsample': [0.8, 0.9, 1],<br/>    'gamma': [0, 0.5, 1]<br/>}</span><span id="86d8" class="ls jl hi lo b fi lx lu l lv lw"><em class="lf"># split the data into train and validation data</em><br/>X_train, X_valid, y_train, y_valid = train_test_split(train_data, y, test_size=0.25)</span><span id="cfb5" class="ls jl hi lo b fi lx lu l lv lw">clf=RandomizedSearchCV(xgb, param_distributions=params, n_iter=50, n_jobs=-1, verbose=1)</span><span id="5cfa" class="ls jl hi lo b fi lx lu l lv lw">clf.fit(train_data, y)<br/></span></pre><figure class="lj lk ll lm fd me er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mt"><img src="../Images/6ba24a05c3df6bbfff51d3ed47dbbba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYUUSQMkFDUMrBuhCc02Fg.png"/></div></div></figure><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8e3f" class="ls jl hi lo b fi lt lu l lv lw">score=clf.best_score_<br/>params=clf.best_params_<br/>print("Best score: ",score)<br/>print("Best parameters: ", params)</span><span id="5981" class="ls jl hi lo b fi lx lu l lv lw">____________________________________________________________________</span><span id="c750" class="ls jl hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="lf">Best score:  0.812874251497006 <br/>Best parameters:  {'subsample': 1, 'n_estimators': 500, 'max_depth': 9, 'learning_rate': 0.01, 'gamma': 0.5, 'colsample_bytree': 0.4}<br/></em></strong>____________________________________________________________________</span></pre><p id="bcd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找到准确性，将预测与验证目标进行比较。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="616f" class="ls jl hi lo b fi lt lu l lv lw">predictions = clf.predict(X_valid)</span><span id="185d" class="ls jl hi lo b fi lx lu l lv lw">count = 0<br/>for i in range(len(predictions)):<br/>   if predictions[i] == y_valid.to_list()[i]:<br/>      count = count + 1 <em class="lf"># count if a match is found</em></span><span id="3666" class="ls jl hi lo b fi lx lu l lv lw">accuracy = count/len(y_valid)</span><span id="5068" class="ls jl hi lo b fi lx lu l lv lw">print("accuracy is ", accuracy)<br/>____________________________________________________________________</span><span id="d583" class="ls jl hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="lf">accuracy is  0.8251121076233184<br/></em></strong>____________________________________________________________________</span></pre></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="81b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">泰坦尼克号生存预测项目被认为是开始数据科学之旅的最佳项目之一。在这个项目中，涵盖了数据可视化、数据预处理和特征工程等概念。此外，在处理结构化数据时，我们感受到了XGBoost模型的强大功能。</p><p id="65bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">建设性的意见和问题总是受欢迎的！</p><p id="3e14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">其他有用资源:</strong></p><ul class=""><li id="4032" class="kn ko hi ih b ii ij im in iq kp iu kq iy kr jc ks kt ku kv bi translated">尼克拉斯·唐加斯预测泰坦尼克号乘客的生存</li><li id="5be2" class="kn ko hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated"><a class="ae kw" rel="noopener" href="/better-programming/titanic-survival-prediction-using-machine-learning-4c5ff1e3fa16">利用机器学习进行泰坦尼克号生存预测</a></li><li id="fbb9" class="kn ko hi ih b ii kx im ky iq kz iu la iy lb jc ks kt ku kv bi translated"><a class="ae kw" href="https://machinelearningmastery.com/gentle-introduction-xgboost-applied-machine-learning/#:~:text=XGBoost%20is%20an%20algorithm%20that,designed%20for%20speed%20and%20performance." rel="noopener ugc nofollow" target="_blank">应用机器学习XGBoost的温和介绍</a></li></ul></div></div>    
</body>
</html>