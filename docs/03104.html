<html>
<head>
<title>School Java Project Mondrian Art</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学校Java项目蒙德里安艺术</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/school-java-project-mondrian-art-5d2c0bbf8940?source=collection_archive---------6-----------------------#2020-01-16">https://medium.com/analytics-vidhya/school-java-project-mondrian-art-5d2c0bbf8940?source=collection_archive---------6-----------------------#2020-01-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/c8209a26309961c181f999c974714221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9115cHJbCTISuf2B27V5A.png"/></div></div></figure><div class=""/><div class=""><h2 id="38d3" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">您可以看到并享受的递归:-D</h2></div><p id="259e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">对大多数人来说，他们看到的第一个递归例子是阶乘。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="3c54" class="kn ko ht kj b fi kp kq l kr ks">🄹 vim Factorial.java                    <br/>🄹 javac Factorial.java &amp;&amp; java Factorial<br/>5! = 120</span></pre><p id="af72" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">下面是它的实现方式:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="ecd6" class="kn ko ht kj b fi kp kq l kr ks">class Factorial {<br/>  private static int fact(int n) {<br/>    if(n == 0) {<br/>      return 1;<br/>    }<br/>    return n * fact(n - 1);<br/>  }</span><span id="bf68" class="kn ko ht kj b fi kt kq l kr ks">  public static void main(String[] args) {<br/>    System.out.println("5! = " + fact(5));<br/>  }<br/>}</span></pre><p id="b6ac" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">今天我们来玩蒙德里安艺术的视觉递归。<a class="ae ku" href="https://en.wikipedia.org/wiki/Piet_Mondrian" rel="noopener ugc nofollow" target="_blank">皮耶·蒙德里安</a>是荷兰画家和理论家，被认为是20世纪最伟大的艺术家之一。他被认为是20世纪抽象艺术的先驱之一，因为他改变了他的艺术方向，从具象绘画转向越来越抽象的风格，直到他的艺术词汇减少到简单的几何元素。</p><p id="b668" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了简单起见，我们将所有代码放在一个文件Piet.java中。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="c3e6" class="kn ko ht kj b fi kp kq l kr ks">🄹 vim Piet.java</span></pre><p id="e59a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们在JFrame中画一条线来湿一下手。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="a320" class="kn ko ht kj b fi kp kq l kr ks">import javax.swing.JFrame;<br/>import javax.swing.JPanel;<br/>import java.awt.Graphics;</span><span id="7492" class="kn ko ht kj b fi kt kq l kr ks">class CanvasPanel extends JPanel {<br/>  <br/>  public void paintComponent(Graphics g) {<br/>    g.drawLine(0, 0, getWidth(), getHeight());<br/>  }<br/>}</span><span id="0a84" class="kn ko ht kj b fi kt kq l kr ks">class Piet {<br/>  Piet() {<br/>    JFrame f = new JFrame("Piet Mondrian");<br/>    f.setSize(500, 309);<br/>    f.setLocation(50, 50);<br/>    f.add(new CanvasPanel());<br/>    f.setVisible(true);<br/>  }<br/>  <br/>  public static final void main(String[] args) {<br/>    new Piet();<br/>  }<br/>}</span></pre><p id="52cb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">编译并运行它。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="ca37" class="kn ko ht kj b fi kp kq l kr ks">🄹 javac Piet.java &amp;&amp; java Piet</span></pre><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/2da5a2105d5e86b318d9fae09f225d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*1EVOPn-BkJ752xu-oXt3yQ.png"/></div></figure><p id="5ac0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">将画线代码重构为一个名为<code class="du kw kx ky kj b">drawLineInRect</code>的函数。这次试试垂直线。</p><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/227e749fd7e450447a29e9fba27e47b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*BWbXB_iWgO_nyMEuTS1duA.png"/></div></figure><p id="8f96" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">到目前为止完整的代码:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="1390" class="kn ko ht kj b fi kp kq l kr ks">import javax.swing.JFrame;<br/>import javax.swing.JPanel;<br/>import java.awt.Graphics;<br/>import java.awt.Rectangle;</span><span id="5aff" class="kn ko ht kj b fi kt kq l kr ks">class CanvasPanel extends JPanel {<br/>  <br/>  public void paintComponent(Graphics g) {<br/>    Rectangle rect = new Rectangle(0, 0, getWidth(), getHeight());<br/>    drawLineInRect(rect, g);<br/>  }</span><span id="52b2" class="kn ko ht kj b fi kt kq l kr ks">private void drawLineInRect(Rectangle rect, Graphics g) {<br/>    int randomOffset = rect.width / 3;<br/>    int fromX = rect.x + randomOffset;<br/>    int fromY = rect.y; <br/>    int toX = fromX;<br/>    int toY = rect.y + rect.height;<br/>    g.drawLine(fromX, fromY, toX, toY);<br/>  }<br/>}</span><span id="f7e9" class="kn ko ht kj b fi kt kq l kr ks">class Piet {<br/>  Piet() {<br/>    JFrame f = new JFrame("Piet Mondrian");<br/>    f.setSize(500, 309);<br/>    f.setLocation(50, 50);<br/>    f.add(new CanvasPanel());<br/>    f.setVisible(true);<br/>  }<br/>  <br/>  public static final void main(String[] args) {<br/>    new Piet();<br/>  }<br/>}</span></pre><p id="6f81" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们让这条垂直线变得随机。</p><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/61f3ffd7faddc0390887076cfa5fd1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*91lbfkjX_KSD18TkdCA_xQ.png"/></div></figure><p id="de2a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">到目前为止完整的代码:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="9c80" class="kn ko ht kj b fi kp kq l kr ks">import javax.swing.JFrame;<br/>import javax.swing.JPanel;<br/>import java.awt.Graphics;<br/>import java.awt.Rectangle;<br/><strong class="kj hu">import java.util.Random;</strong></span><span id="5b88" class="kn ko ht kj b fi kt kq l kr ks">class CanvasPanel extends JPanel {<br/>  <strong class="kj hu">private Random rand = new Random();</strong></span><span id="0760" class="kn ko ht kj b fi kt kq l kr ks">  public void paintComponent(Graphics g) {<br/>    Rectangle rect = new Rectangle(0, 0, getWidth(), getHeight());<br/>    drawLineInRect(rect, g);<br/>  }</span><span id="2b22" class="kn ko ht kj b fi kt kq l kr ks">  private void drawLineInRect(Rectangle rect, Graphics g) {<br/>    <strong class="kj hu">int randomOffset = rand.nextInt(rect.width);</strong><br/>    int fromX = rect.x + randomOffset;<br/>    int fromY = rect.y; <br/>    int toX = fromX;<br/>    int toY = rect.y + rect.height;<br/>    g.drawLine(fromX, fromY, toX, toY);<br/>  }<br/>}</span><span id="f98a" class="kn ko ht kj b fi kt kq l kr ks">class Piet {<br/>  Piet() {<br/>    JFrame f = new JFrame("Piet Mondrian");<br/>    f.setSize(500, 309);<br/>    f.setLocation(50, 50);<br/>    f.add(new CanvasPanel());<br/>    f.setVisible(true);<br/>  }<br/>  <br/>  public static final void main(String[] args) {<br/>    new Piet();<br/>  }<br/>}</span></pre><p id="b307" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">用黄色填充左边的小矩形。</p><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/94992bbc245f1920013708f9534cb7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*5iSY5TpsczkKgXRagWs33A.png"/></div></figure><p id="a561" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">到目前为止完整的代码:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="c802" class="kn ko ht kj b fi kp kq l kr ks">import javax.swing.JFrame;<br/>import javax.swing.JPanel;<br/>import java.awt.Graphics;<br/>import java.awt.Rectangle;<br/><strong class="kj hu">import java.awt.Color;</strong><br/>import java.util.Random;</span><span id="ac21" class="kn ko ht kj b fi kt kq l kr ks">class CanvasPanel extends JPanel {<br/>  private Random rand = new Random();</span><span id="4d6f" class="kn ko ht kj b fi kt kq l kr ks">  public void paintComponent(Graphics g) {<br/>    Rectangle rect = new Rectangle(0, 0, getWidth(), getHeight());<br/>    drawLineInRect(rect, g);<br/>  }</span><span id="754c" class="kn ko ht kj b fi kt kq l kr ks">  private void drawLineInRect(Rectangle rect, Graphics g) {<br/>    int randomOffset = rand.nextInt(rect.width);<br/>    int fromX = rect.x + randomOffset;<br/>    int fromY = rect.y;<br/>    int toX = fromX;<br/>    int toY = rect.y + rect.height;<br/>    g.drawLine(fromX, fromY, toX, toY);</span><span id="95be" class="kn ko ht kj b fi kt kq l kr ks">    <strong class="kj hu">Rectangle rect0 = new Rectangle(rect.x, rect.y, randomOffset, rect.height);<br/>    g.setColor(Color.orange);<br/>    g.fillRect(rect0.x, rect0.y, rect0.width, rect0.height);<br/>  }</strong><br/>}</span><span id="0a6c" class="kn ko ht kj b fi kt kq l kr ks">class Piet {<br/>  Piet() {<br/>    JFrame f = new JFrame("Piet Mondrian");<br/>    f.setSize(500, 309);<br/>    f.setLocation(50, 50);<br/>    f.add(new CanvasPanel());<br/>    f.setVisible(true);<br/>  }</span><span id="878f" class="kn ko ht kj b fi kt kq l kr ks">  public static final void main(String[] args) {<br/>    new Piet();<br/>  }<br/>}</span></pre><p id="539e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">用不同的颜色填充两个小矩形。</p><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/aa64aa7451f0cf3f8f9554ba49b4be79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*7jFSRsFKtFaKYaniitWOKw.png"/></div></figure><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="40e0" class="kn ko ht kj b fi kp kq l kr ks">class CanvasPanel extends JPanel {<br/>  private Random rand = new Random();</span><span id="1869" class="kn ko ht kj b fi kt kq l kr ks">  public void paintComponent(Graphics g) {<br/>    Rectangle rect = new Rectangle(0, 0, getWidth(), getHeight());<br/>    drawLineInRect(rect, g);<br/>  }</span><span id="7ea4" class="kn ko ht kj b fi kt kq l kr ks">  private void drawLineInRect(Rectangle rect, Graphics g) {<br/>    int randomOffset = rand.nextInt(rect.width);<br/>    int fromX = rect.x + randomOffset;<br/>    int fromY = rect.y;<br/>    int toX = fromX;<br/>    int toY = rect.y + rect.height;<br/>    g.drawLine(fromX, fromY, toX, toY);</span><span id="a3f3" class="kn ko ht kj b fi kt kq l kr ks">    Rectangle rect0 = new Rectangle(rect.x, rect.y, randomOffset, rect.height);<br/>    g.setColor(Color.orange);<br/>    g.fillRect(rect0.x, rect0.y, rect0.width, rect0.height);<br/>    <strong class="kj hu">Rectangle rect1 = new Rectangle(rect.x + randomOffset, rect.y, rect.width - randomOffset, rect.height);<br/>    g.setColor(Color.green);<br/>    g.fillRect(rect1.x, rect1.y, rect1.width, rect1.height);</strong><br/>  }<br/>}</span></pre><p id="bb3e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">有一个问题:垂直线消失了，即被两个小矩形覆盖。我们需要的是这样的东西:</p><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/6d2ef86c720c0a61d59d66e35c62655f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*pNtzFOGB4NcY5t462wOlVg.png"/></div></figure><p id="dbf2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在画完两个矩形后画线就固定了。我们还需要为线条设置黑色。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="9665" class="kn ko ht kj b fi kp kq l kr ks">class CanvasPanel extends JPanel {<br/>  private Random rand = new Random();</span><span id="fd87" class="kn ko ht kj b fi kt kq l kr ks">  public void paintComponent(Graphics g) {<br/>    Rectangle rect = new Rectangle(0, 0, getWidth(), getHeight());<br/>    drawLineInRect(rect, g);<br/>  }</span><span id="78d9" class="kn ko ht kj b fi kt kq l kr ks">  private void drawLineInRect(Rectangle rect, Graphics g) {<br/>    int randomOffset = rand.nextInt(rect.width);</span><span id="b025" class="kn ko ht kj b fi kt kq l kr ks">    Rectangle rect0 = new Rectangle(rect.x, rect.y, randomOffset, rect.height);<br/>    g.setColor(Color.orange);<br/>    g.fillRect(rect0.x, rect0.y, rect0.width, rect0.height);<br/>    Rectangle rect1 = new Rectangle(rect.x + randomOffset, rect.y, rect.width - randomOffset, rect.height);<br/>    g.setColor(Color.green);<br/>    g.fillRect(rect1.x, rect1.y, rect1.width, rect1.height);</span><span id="9ae9" class="kn ko ht kj b fi kt kq l kr ks">    int fromX = rect.x + randomOffset;<br/>    int fromY = rect.y;<br/>    int toX = fromX;<br/>    int toY = rect.y + rect.height;<br/>    g.setColor(Color.black);<br/>    g.drawLine(fromX, fromY, toX, toY);<br/>  }<br/>}</span></pre><p id="4a9c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">修改方法<code class="du kw kx ky kj b">drawLineInRect</code>,使其为纵向矩形绘制一条垂直线，为横向矩形绘制一条水平线。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="cec8" class="kn ko ht kj b fi kp kq l kr ks">class CanvasPanel extends JPanel {<br/>  private Random rand = new Random();</span><span id="3908" class="kn ko ht kj b fi kt kq l kr ks">  public void paintComponent(Graphics g) {<br/>    Rectangle rect = new Rectangle(0, 0, getWidth(), getHeight());<br/>    drawLineInRect(rect, g);<br/>  }</span><span id="c9ce" class="kn ko ht kj b fi kt kq l kr ks">  private void drawLineInRect(Rectangle rect, Graphics g) {<br/>    i<strong class="kj hu">nt randomOffset;<br/>    Rectangle rect0, rect1;<br/>    int fromX, fromY, toX, toY;</strong></span><span id="7b5a" class="kn ko ht kj b fi kt kq l kr ks"><strong class="kj hu">    if (rect.width &lt; rect.height) {<br/>      randomOffset = rand.nextInt(rect.height);<br/>      rect0 = new Rectangle(rect.x, rect.y, rect.width, randomOffset);<br/>      rect1 = new Rectangle(rect.x, rect.y + randomOffset, rect.width, rect.height - randomOffset);<br/>      fromX = rect.x;<br/>      fromY = rect.y + randomOffset;<br/>      toX = fromX + rect.width;<br/>      toY = fromY;<br/>    } else {<br/>      randomOffset = rand.nextInt(rect.width);<br/>      rect0 = new Rectangle(rect.x, rect.y, randomOffset, rect.height);<br/>      rect1 = new Rectangle(rect.x + randomOffset, rect.y, rect.width - randomOffset, rect.height);<br/>      fromX = rect.x + randomOffset;<br/>      fromY = rect.y;<br/>      toX = fromX;<br/>      toY = rect.y + rect.height;<br/>    }</strong></span><span id="6981" class="kn ko ht kj b fi kt kq l kr ks">    g.setColor(Color.orange);<br/>    g.fillRect(rect0.x, rect0.y, rect0.width, rect0.height);<br/>    g.setColor(Color.green);<br/>    g.fillRect(rect1.x, rect1.y, rect1.width, rect1.height);</span><span id="91e7" class="kn ko ht kj b fi kt kq l kr ks">    g.setColor(Color.black);<br/>    g.drawLine(fromX, fromY, toX, toY);<br/>  }<br/>}</span></pre><p id="9966" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们可以通过改变画面宽度来测试肖像模式:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="e913" class="kn ko ht kj b fi kp kq l kr ks">class Piet {<br/>  Piet() {<br/>    JFrame f = new JFrame("Piet Mondrian");<br/>    f.setSize(<strong class="kj hu">250</strong>, 309);<br/>    f.setLocation(50, 50);<br/>    f.add(new CanvasPanel());<br/>    f.setVisible(true);<br/>  }<br/> <br/>  public static final void main(String[] args) {<br/>    new Piet();<br/>  }<br/>}</span></pre><figure class="ke kf kg kh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kz"><img src="../Images/a6b760212a7a7ff868158575b551898a.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*5JYWkVT-UtcEYoYPNionaA.png"/></div></div></figure><p id="d12e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">把它改回500，我们在横向模式下得到一个矩形。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="937b" class="kn ko ht kj b fi kp kq l kr ks">class Piet {<br/>  Piet() {<br/>    JFrame f = new JFrame("Piet Mondrian");<br/>    f.setSize(<strong class="kj hu">500</strong>, 309);<br/>    f.setLocation(50, 50);<br/>    f.add(new CanvasPanel());<br/>    f.setVisible(true);<br/>  }<br/> <br/>  public static final void main(String[] args) {<br/>    new Piet();<br/>  }<br/>}</span></pre><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/4d0285d0d6e3bccfff0a7198ce3813fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*aDzU-VCzVHdOJ0c87u5F-A.png"/></div></figure><p id="d1a5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">你准备好了吗？我们将进行递归调用的第一次尝试。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="367d" class="kn ko ht kj b fi kp kq l kr ks">class CanvasPanel extends JPanel {<br/>  private Random rand = new Random();</span><span id="18b1" class="kn ko ht kj b fi kt kq l kr ks">  public void paintComponent(Graphics g) {<br/>    Rectangle rect = new Rectangle(0, 0, getWidth(), getHeight());<br/>    drawLineInRect(rect, g);<br/>  }</span><span id="396b" class="kn ko ht kj b fi kt kq l kr ks">  private void drawLineInRect(Rectangle rect, Graphics g) {<br/><strong class="kj hu">    if (rect.width &lt; 50 &amp;&amp; rect.height &lt; 50) {<br/>      return;<br/>    }</strong></span><span id="ac2d" class="kn ko ht kj b fi kt kq l kr ks">    int randomOffset;<br/>    Rectangle rect0, rect1;<br/>    int fromX, fromY, toX, toY;</span><span id="e4fb" class="kn ko ht kj b fi kt kq l kr ks">    if (rect.width &lt; rect.height) {<br/>      randomOffset = rand.nextInt(rect.height);<br/>      rect0 = new Rectangle(rect.x, rect.y, rect.width, randomOffset);<br/>      rect1 = new Rectangle(rect.x, rect.y + randomOffset, rect.width, rect.height - randomOffset);<br/>      fromX = rect.x;<br/>      fromY = rect.y + randomOffset;<br/>      toX = fromX + rect.width;<br/>      toY = fromY;<br/>    } else {<br/>      randomOffset = rand.nextInt(rect.width);<br/>      rect0 = new Rectangle(rect.x, rect.y, randomOffset, rect.height);<br/>      rect1 = new Rectangle(rect.x + randomOffset, rect.y, rect.width - randomOffset, rect.height);<br/>      fromX = rect.x + randomOffset;<br/>      fromY = rect.y;<br/>      toX = fromX;<br/>      toY = rect.y + rect.height;<br/>    }</span><span id="ad7e" class="kn ko ht kj b fi kt kq l kr ks">    g.setColor(Color.orange);<br/>    g.fillRect(rect0.x, rect0.y, rect0.width, rect0.height);<br/>    g.setColor(Color.green);<br/>    g.fillRect(rect1.x, rect1.y, rect1.width, rect1.height);</span><span id="b956" class="kn ko ht kj b fi kt kq l kr ks">    g.setColor(Color.black);<br/>    g.drawLine(fromX, fromY, toX, toY);</span><span id="6d80" class="kn ko ht kj b fi kt kq l kr ks"><strong class="kj hu">    drawLineInRect(rect0, g);<br/>    drawLineInRect(rect1, g);</strong><br/>  }<br/>}</span></pre><p id="1158" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们得到了:</p><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/df7ddf462072f7519852ca2000f5c83d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*mekDkB0-zAV0LF6g_WzWAA.png"/></div></figure><p id="dc16" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">问题来自填充的矩形覆盖了一些线。它可以通过填充每个矩形的插图来解决:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="8475" class="kn ko ht kj b fi kp kq l kr ks">int gap = 1;<br/>g.setColor(Color.orange);<br/>g.fillRect(rect0.x + gap, rect0.y + gap, rect0.width - 2*gap, rect0.height - 2*gap);<br/>g.setColor(Color.green);<br/>g.fillRect(rect1.x + gap, rect1.y + gap, rect1.width - 2*gap, rect1.height - 2*gap);</span></pre><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/91929f8e2daccd933f5d424f4b234762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*-QZN27pMapT2AfPrWlZJ8Q.png"/></div></figure><p id="7f97" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">酷！让我们通过引入随机填充颜色来使它更酷。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="f246" class="kn ko ht kj b fi kp kq l kr ks">class CanvasPanel extends JPanel {<br/>  <strong class="kj hu">private static final int LINE_WIDTH = 1;</strong><br/>  private Random rand = new Random();</span><span id="9e3b" class="kn ko ht kj b fi kt kq l kr ks">  public void paintComponent(Graphics g) {<br/>    Rectangle rect = new Rectangle(0, 0, getWidth(), getHeight());<br/>    drawLineInRect(rect, g);<br/>  }</span><span id="6461" class="kn ko ht kj b fi kt kq l kr ks">  private void drawLineInRect(Rectangle rect, Graphics g) {<br/>    if (rect.width &lt; 100 &amp;&amp; rect.height &lt; 62) {<br/>      return;<br/>    }</span><span id="09f2" class="kn ko ht kj b fi kt kq l kr ks">    int randomOffset;<br/>    Rectangle rect0, rect1;<br/>    int fromX, fromY, toX, toY;</span><span id="528d" class="kn ko ht kj b fi kt kq l kr ks">    if (rect.width &lt; rect.height) {<br/>      randomOffset = rand.nextInt(rect.height);<br/>      rect0 = new Rectangle(rect.x, rect.y, rect.width, randomOffset);<br/>      rect1 = new Rectangle(rect.x, rect.y + randomOffset, rect.width, rect.height - randomOffset);<br/>      fromX = rect.x;<br/>      fromY = rect.y + randomOffset;<br/>      toX = fromX + rect.width;<br/>      toY = fromY;<br/>    } else {<br/>      randomOffset = rand.nextInt(rect.width);<br/>      rect0 = new Rectangle(rect.x, rect.y, randomOffset, rect.height);<br/>      rect1 = new Rectangle(rect.x + randomOffset, rect.y, rect.width - randomOffset, rect.height);<br/>      fromX = rect.x + randomOffset;<br/>      fromY = rect.y;<br/>      toX = fromX;<br/>      toY = rect.y + rect.height;<br/>    }</span><span id="9c7c" class="kn ko ht kj b fi kt kq l kr ks">    <strong class="kj hu">fillInRect(rect0, LINE_WIDTH, g);<br/>    fillInRect(rect1, LINE_WIDTH, g);</strong></span><span id="33a4" class="kn ko ht kj b fi kt kq l kr ks">    g.setColor(Color.black);<br/>    g.drawLine(fromX, fromY, toX, toY);</span><span id="0ae0" class="kn ko ht kj b fi kt kq l kr ks">    drawLineInRect(rect0, g);<br/>    drawLineInRect(rect1, g);<br/>  }</span><span id="9308" class="kn ko ht kj b fi kt kq l kr ks">  <strong class="kj hu">private void fillInRect(Rectangle rect, int gap, Graphics g) {<br/>    float red = rand.nextFloat();<br/>    float grn = rand.nextFloat();<br/>    float blu = rand.nextFloat();<br/>    Color randomColor = new Color(red, grn, blu);<br/>    g.setColor(randomColor);<br/>    g.fillRect(rect.x + gap, rect.y + gap, rect.width - 2*gap, rect.height - 2*gap);<br/>  }</strong><br/>}</span></pre><p id="c4bb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">第一件艺术品出来了:</p><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/06279790dd63bcbe76292a84a68ccb90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*WQfbCb9eUXqXv2sV0d0WZQ.png"/></div></figure><p id="926a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我忍不住又烤了一个。</p><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/821efbba3df09b0772aa7ab39cd7057f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*p-iZtdAJT-H9RN87myYi1w.png"/></div></figure><p id="26c9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了增加笔画宽度，我们需要<code class="du kw kx ky kj b">Graphics2D</code>的帮助。但这几乎不是问题，因为Swing中的每个图形都是Graphics2D对象(出于兼容性原因，它只保留了旧的接口)。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="8367" class="kn ko ht kj b fi kp kq l kr ks">import javax.swing.JFrame;<br/>import javax.swing.JPanel;<br/>import java.awt.Graphics;<br/><strong class="kj hu">import java.awt.Graphics2D;<br/>import java.awt.BasicStroke;</strong><br/>import java.awt.Rectangle;<br/>import java.awt.Color;<br/>import java.util.Random;</span><span id="a47a" class="kn ko ht kj b fi kt kq l kr ks">class CanvasPanel extends JPanel {<br/>  <strong class="kj hu">private static final int LINE_WIDTH = 5;</strong><br/>  private Random rand = new Random();</span><span id="8402" class="kn ko ht kj b fi kt kq l kr ks">  public void paintComponent(Graphics g) {<br/>    Rectangle rect = new Rectangle(0, 0, getWidth(), getHeight());<br/>    drawLineInRect(rect, g);<br/>  }</span><span id="0ccf" class="kn ko ht kj b fi kt kq l kr ks">  private void drawLineInRect(Rectangle rect, Graphics g) {<br/>    if (rect.width &lt; 200 &amp;&amp; rect.height &lt; 124) {<br/>      return;<br/>    }</span><span id="b218" class="kn ko ht kj b fi kt kq l kr ks">    int randomOffset;<br/>    Rectangle rect0, rect1;<br/>    int fromX, fromY, toX, toY;</span><span id="1614" class="kn ko ht kj b fi kt kq l kr ks">    if (rect.width &lt; rect.height) {<br/>      randomOffset = rand.nextInt(rect.height);<br/>      rect0 = new Rectangle(rect.x, rect.y, rect.width, randomOffset);<br/>      rect1 = new Rectangle(rect.x, rect.y + randomOffset, rect.width, rect.height - randomOffset);<br/>      fromX = rect.x;<br/>      fromY = rect.y + randomOffset;<br/>      toX = fromX + rect.width;<br/>      toY = fromY;<br/>    } else {<br/>      randomOffset = rand.nextInt(rect.width);<br/>      rect0 = new Rectangle(rect.x, rect.y, randomOffset, rect.height);<br/>      rect1 = new Rectangle(rect.x + randomOffset, rect.y, rect.width - randomOffset, rect.height);<br/>      fromX = rect.x + randomOffset;<br/>      fromY = rect.y;<br/>      toX = fromX;<br/>      toY = rect.y + rect.height;<br/>    }</span><span id="c8ef" class="kn ko ht kj b fi kt kq l kr ks">    <strong class="kj hu">fillInRect(rect0, LINE_WIDTH / 2, g);<br/>    fillInRect(rect1, LINE_WIDTH / 2, g);</strong></span><span id="18da" class="kn ko ht kj b fi kt kq l kr ks">    g.setColor(Color.black);<br/>    <strong class="kj hu">Graphics2D g2 = (Graphics2D)g;<br/>    g2.setStroke(new BasicStroke(LINE_WIDTH));<br/>    g2.drawLine(fromX, fromY, toX, toY);</strong></span><span id="c165" class="kn ko ht kj b fi kt kq l kr ks">    drawLineInRect(rect0, g);<br/>    drawLineInRect(rect1, g);<br/>  }</span><span id="795f" class="kn ko ht kj b fi kt kq l kr ks">  private void fillInRect(Rectangle rect, int gap, Graphics g) {<br/>    float red = rand.nextFloat();<br/>    float grn = rand.nextFloat();<br/>    float blu = rand.nextFloat();<br/>    Color randomColor = new Color(red, grn, blu);<br/>    g.setColor(randomColor);<br/>    g.fillRect(rect.x + gap, rect.y + gap, rect.width - 2*gap, rect.height - 2*gap);<br/>  }<br/>}</span></pre><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/c0e191109b9d080ccfe0d6403a88b625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*bXP_KkL56__d4ztpeI22tA.png"/></div></figure><p id="0310" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最外面的框架没有被覆盖。这可以通过对第一个矩形使用负插入来解决。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="18f0" class="kn ko ht kj b fi kp kq l kr ks">class CanvasPanel extends JPanel {<br/>  private static final int LINE_WIDTH = 5;<br/>  private Random rand = new Random();</span><span id="d2c3" class="kn ko ht kj b fi kt kq l kr ks">  public void paintComponent(Graphics g) {<br/>    Rectangle rect = new Rectangle(<strong class="kj hu">-LINE_WIDTH/2, -LINE_WIDTH/2, getWidth() + LINE_WIDTH, getHeight() + LINE_WIDTH</strong>);<br/>    drawLineInRect(rect, g);<br/>  }<br/>  // ...</span></pre><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/eb9cb5bf79337bc06baed4533cf819be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*ry7jvxzjULHk95LsLKALrQ.png"/></div></figure><p id="e6ae" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是LINE_WIDTH = 8的艺术:</p><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/f8c429161be2ddd9924816e599b4440d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*vle0onRRiIi1WYi84GJcbg.png"/></div></figure><p id="c203" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">再次运行我们得到另一个:</p><figure class="ke kf kg kh fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/54588b10c81eecd6dd283d759431e407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*yvRJainpjXwRumX3VgIVWA.png"/></div></figure></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="ac48" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">完整的源代码:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="191e" class="kn ko ht kj b fi kp kq l kr ks">import javax.swing.JFrame;<br/>import javax.swing.JPanel;<br/>import java.awt.Graphics;<br/>import java.awt.Graphics2D;<br/>import java.awt.BasicStroke;<br/>import java.awt.Rectangle;<br/>import java.awt.Color;<br/>import java.util.Random;</span><span id="b4ba" class="kn ko ht kj b fi kt kq l kr ks">class CanvasPanel extends JPanel {<br/>  private static final int LINE_WIDTH = 8;<br/>  private Random rand = new Random();</span><span id="2cd2" class="kn ko ht kj b fi kt kq l kr ks">  public void paintComponent(Graphics g) {<br/>    Rectangle rect = new Rectangle(-LINE_WIDTH/2, -LINE_WIDTH/2, getWidth() + LINE_WIDTH, getHeight() + LINE_WIDTH);<br/>    drawLineInRect(rect, g);<br/>  }</span><span id="4629" class="kn ko ht kj b fi kt kq l kr ks">  private void drawLineInRect(Rectangle rect, Graphics g) {<br/>    if (rect.width &lt; 200 &amp;&amp; rect.height &lt; 124) {<br/>      return;<br/>    }</span><span id="ee79" class="kn ko ht kj b fi kt kq l kr ks">    int randomOffset;<br/>    Rectangle rect0, rect1;<br/>    int fromX, fromY, toX, toY;</span><span id="ccaa" class="kn ko ht kj b fi kt kq l kr ks">    if (rect.width &lt; rect.height) {<br/>      randomOffset = rand.nextInt(rect.height);<br/>      rect0 = new Rectangle(rect.x, rect.y, rect.width, randomOffset);<br/>      rect1 = new Rectangle(rect.x, rect.y + randomOffset, rect.width, rect.height - randomOffset);<br/>      fromX = rect.x;<br/>      fromY = rect.y + randomOffset;<br/>      toX = fromX + rect.width;<br/>      toY = fromY;<br/>    } else {<br/>      randomOffset = rand.nextInt(rect.width);<br/>      rect0 = new Rectangle(rect.x, rect.y, randomOffset, rect.height);<br/>      rect1 = new Rectangle(rect.x + randomOffset, rect.y, rect.width - randomOffset, rect.height);<br/>      fromX = rect.x + randomOffset;<br/>      fromY = rect.y;<br/>      toX = fromX;<br/>      toY = rect.y + rect.height;<br/>    }</span><span id="6f33" class="kn ko ht kj b fi kt kq l kr ks">    fillInRect(rect0, LINE_WIDTH / 2, g);<br/>    fillInRect(rect1, LINE_WIDTH / 2, g);</span><span id="711e" class="kn ko ht kj b fi kt kq l kr ks">    g.setColor(Color.black);<br/>    Graphics2D g2 = (Graphics2D)g;<br/>    g2.setStroke(new BasicStroke(LINE_WIDTH));<br/>    g2.drawLine(fromX, fromY, toX, toY);</span><span id="451f" class="kn ko ht kj b fi kt kq l kr ks">    drawLineInRect(rect0, g);<br/>    drawLineInRect(rect1, g);<br/>  }</span><span id="1f54" class="kn ko ht kj b fi kt kq l kr ks">  private void fillInRect(Rectangle rect, int gap, Graphics g) {<br/>    float red = rand.nextFloat();<br/>    float grn = rand.nextFloat();<br/>    float blu = rand.nextFloat();<br/>    Color randomColor = new Color(red, grn, blu);<br/>    g.setColor(randomColor);<br/>    g.fillRect(rect.x + gap, rect.y + gap, rect.width - 2*gap, rect.height - 2*gap);<br/>  }<br/>}</span><span id="07de" class="kn ko ht kj b fi kt kq l kr ks">class Piet {<br/>  Piet() {<br/>    JFrame f = new JFrame("Piet Mondrian");<br/>    f.setSize(500, 309);<br/>    f.setLocation(50, 50);<br/>    f.add(new CanvasPanel());<br/>    f.setVisible(true);<br/>  }<br/> <br/>  public static final void main(String[] args) {<br/>    new Piet();<br/>  }<br/>}</span></pre><p id="9980" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最有趣的部分是对函数<code class="du kw kx ky kj b">drawLineInRect</code>的递归调用。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="2f2b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是我用Xcode在Swift上实现的一个类似的蒙德里安艺术:</p><figure class="ke kf kg kh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lh"><img src="../Images/567e1eeaeae979f8780f748fda08237b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4jIswn4MY1t-mBjOmYF9Fg.png"/></div></div></figure><p id="b861" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我把对应的Swift代码放在这里做比较:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="0608" class="kn ko ht kj b fi kp kq l kr ks">import UIKit</span><span id="8840" class="kn ko ht kj b fi kt kq l kr ks">class PietView: UIView {<br/>    let lineWidth: CGFloat = 11<br/>    let percent: CGFloat = 0.46<br/>    var minW: CGFloat = 0<br/>    var minH: CGFloat = 0</span><span id="5453" class="kn ko ht kj b fi kt kq l kr ks">    override func draw(_ rect: CGRect) {<br/>        minW = rect.width * percent<br/>        minH = rect.height * percent<br/>        <br/>        let inset = -lineWidth/2<br/>        let rectWithInset = rect.inset(by: UIEdgeInsets(top: inset, left: inset, bottom: inset, right: inset))<br/>        drawLineIn(rect: rectWithInset)<br/>    }</span><span id="8fa4" class="kn ko ht kj b fi kt kq l kr ks">    func drawLineIn(rect: CGRect) {<br/>        if rect.width &lt; minW &amp;&amp; rect.height &lt; minH {<br/>            return<br/>        }<br/>        <br/>        let path = UIBezierPath()<br/>        <br/>        let randomOffset: CGFloat<br/>        let fromX, fromY, toX, toY : CGFloat<br/>        let rect0: CGRect<br/>        let rect1: CGRect<br/>        <br/>        if rect.width &lt; rect.height {<br/>            randomOffset = CGFloat(arc4random() % UInt32(rect.height))<br/>            fromX = rect.origin.x<br/>            fromY = rect.origin.y + randomOffset<br/>            toX = fromX + rect.width<br/>            toY = fromY<br/>            rect0 = CGRect(x: rect.origin.x, y: rect.origin.y, width: rect.width, height: randomOffset)<br/>            rect1 = CGRect(x: rect.origin.x, y: rect.origin.y + randomOffset, width: rect.width, height: rect.height - randomOffset)<br/>        } else {<br/>            randomOffset = CGFloat(arc4random() % UInt32(rect.width))<br/>            fromX = rect.origin.x + randomOffset<br/>            fromY = rect.origin.y<br/>            toX = fromX<br/>            toY = fromY + rect.height<br/>            rect0 = CGRect(x: rect.origin.x, y: rect.origin.y, width: randomOffset, height: rect.height)<br/>            rect1 = CGRect(x: rect.origin.x + randomOffset, y: rect.origin.y, width: rect.width - randomOffset, height: rect.height)<br/>        }<br/>        <br/>        fillIn(rect: rect0, inset: lineWidth/2)<br/>        fillIn(rect: rect1, inset: lineWidth/2)<br/>        <br/>        path.move(to: CGPoint(x: fromX, y: fromY))<br/>        path.addLine(to: CGPoint(x: toX, y: toY))<br/>        path.lineWidth = lineWidth<br/>        path.stroke()<br/>        <br/>        drawLineIn(rect: rect0)<br/>        drawLineIn(rect: rect1)<br/>    }<br/>    <br/>    private func fillIn(rect: CGRect, inset: CGFloat) {<br/>        let rectWithInset = rect.inset(by: UIEdgeInsets(top: inset, left: inset, bottom: inset, right: inset))<br/>        let rectPath = UIBezierPath(rect: rectWithInset)<br/>        let r = CGFloat(Int(arc4random()) % 1000) / 1000<br/>        let g = CGFloat(Int(arc4random()) % 1000) / 1000<br/>        let b = CGFloat(Int(arc4random()) % 1000) / 1000<br/>        let a = CGFloat(Int(arc4random()) % 1000) / 1000<br/>        let color = UIColor(red: r, green: g, blue: b, alpha: a)<br/>        color.setFill()<br/>        rectPath.fill()<br/>    }<br/>}</span></pre></div></div>    
</body>
</html>