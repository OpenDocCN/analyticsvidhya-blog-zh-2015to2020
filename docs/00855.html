<html>
<head>
<title>MLE, the Foundation of Naive Bayes Classifiers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最大似然法，朴素贝叶斯分类器的基础</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/mle-the-foundation-of-naive-bayes-classifiers-ebb27963c3fa?source=collection_archive---------8-----------------------#2019-09-13">https://medium.com/analytics-vidhya/mle-the-foundation-of-naive-bayes-classifiers-ebb27963c3fa?source=collection_archive---------8-----------------------#2019-09-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/873da987bdb76f50d729102cada19d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aRmGVGeQ5fEe_E-V"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">埃里克·麦克林在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a0ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">朴素贝叶斯分类器根据<a class="ae iu" rel="noopener" href="/datadriveninvestor/back-to-bayes-ics-e5dd4405c927">贝叶斯定理</a>的原理对数据进行分类。给定先前事件的信息或已知数据点的知识，这些分类器预测后续观察的结果。</p><p id="513c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想象一下抛硬币。你对这枚硬币一无所知，它可能是一枚公平的硬币(有50%的机会是正面或反面)，或者它可能偏向一个方向。一次抛硬币不足以预测未来的结果，硬币不可能百分之百是正面的。一百万次翻转似乎太多了。假设你抛硬币十次并记录结果，我们如何用这一系列的抛硬币来估计这个概率参数？</p><h1 id="1a9d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">MLE</h1><p id="f931" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><strong class="ix hj">最大似然估计</strong> (MLE)是一种估计参数的方法，这种方法可以最大化一系列事件发生的概率。在我们的硬币例子中，唯一的参数是硬币是正面还是反面的概率，或者硬币有多偏向或公平。例如，在硬币公平的情况下(我们仍然对这枚硬币一无所知)，连续掷出十个头像的几率很小，掷出五个头像的几率很高。假设我们翻转了六个正面和四个反面。在这种情况下，最大似然估计的目标是估计使这个序列最有可能发生的参数，或<em class="kw">硬币偏差</em>(我们的参数)。</p><p id="bb46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，给定序列的概率表示为各个翻转概率的乘积:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/edf3410c8dcc30c7685d21ea7d121b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuAklmhGgL4l3n3rf68haQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">给定对硬币正面结果的未知偏差，一系列硬币投掷的概率</figcaption></figure><p id="a62d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MLE需要两个假设来简化这个例子。我们的每一次翻转都是<strong class="ix hj">独立的</strong>，即翻转1的结果对翻转2的结果没有影响。每次投掷也是<strong class="ix hj">独立分布</strong>，即在每次观察中，相同的硬币以相同的方式投掷。这个<strong class="ix hj"> IID </strong>假设允许我们用相同的参数替换上面等式中的硬币偏差。</p><p id="21f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">抛a头的概率是θ，抛a尾的概率是(1-θ)。你可以将这些概率相乘，用一个似然函数来表示一个翻转序列。例如，正面-正面-反面序列可以表示为:θ*θ*(1-θ)。</p><h1 id="ab68" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">ARGMAX</h1><p id="e8ec" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">给定已知的硬币投掷顺序，我们现在能够从上面的概率函数中推导出θ参数。我们可以选择使用函数的导数，或者我们可以使用对数将它转换成一个单调函数；总是增加或总是减少的函数。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/9d097d0851bb15ec6441e5b0e4f58e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_Em69wKXJL4K0hog7fWDQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">单调函数的可视化，通过<a class="ae iu" href="https://en.wikipedia.org/wiki/Monotonic_function" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="1548" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的目标是导出参数θ，使得我们的抛硬币序列最有可能发生；也就是寻找最大值或<strong class="ix hj"> argmax </strong>的<strong class="ix hj">自变量的过程。该对数函数的<a class="ae iu" href="https://www.youtube.com/watch?v=z3cQpVJZI44" rel="noopener ugc nofollow" target="_blank">导数导致我们得出以下等式:</a></strong></p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/545f03ab1ad5636aadc5b2a0d207d28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*ijZO0kmFhIQxYaFnCYEmkA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">θ的估计值，硬币偏向正面。h代表头翻转的次数，T代表尾翻转的次数，Patrick van der Smagt的视频如上所述。</figcaption></figure><p id="0c77" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你翻转6个正面和4个反面，你会得到θ = 0.6。</p><h1 id="dfbd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="a3e3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是最大似然估计的一个简单例子，但它可以计算出更高级的例子。最大似然法是朴素贝叶斯分类器的基础。他们的主要缺点是，他们严重基于以前的观察；例如，不太可能的序列会影响分类器的性能。</p></div></div>    
</body>
</html>