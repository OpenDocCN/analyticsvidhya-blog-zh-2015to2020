<html>
<head>
<title>AI for Trading Series №4: Time Series Modelling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能交易系列№4:时间序列建模</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-modelling-d6531c9a6338?source=collection_archive---------14-----------------------#2020-12-06">https://medium.com/analytics-vidhya/time-series-modelling-d6531c9a6338?source=collection_archive---------14-----------------------#2020-12-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="dcfc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解时间序列分析的高级方法，包括 ARMA，ARIMA。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d1212aa1365670b6be079484b920e970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvX5H2x_urnYKNS6_PCUnA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">艾萨克·史密斯在<a class="ae jn" href="https://unsplash.com/s/photos/graphs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3cb0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本系列中，我们将介绍以下执行时间序列分析的方法</p><ol class=""><li id="5936" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">随机游动</li><li id="41af" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">移动平均线模型(MA 模型)</li><li id="f9d5" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">自回归模型(AR 模型)</li><li id="8b2f" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">自回归移动平均模型(ARMA 模型)</li><li id="2027" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">自回归综合移动平均线(ARIMA 模型)</li></ol><h1 id="5686" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">随机行走模型</h1><p id="05bf" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">随机游走假说是一种金融理论，认为股票市场价格根据随机游走而变化，因此无法预测。一个随机游走模型相信[1]:</p><ol class=""><li id="9bf3" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">股票价格的变化具有相同的分布，并且相互独立。</li><li id="ffe9" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">股票价格或市场过去的运动或趋势不能用来预测其未来的运动。</li><li id="3111" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">在不承担额外风险的情况下，跑赢市场是不可能的。</li><li id="96ff" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">认为技术分析是不可靠的，因为它导致图表分析师只在波动发生后才买入或卖出证券。</li><li id="50b5" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">认为基本面分析不可靠，因为收集的信息质量通常很差，而且容易被误解。</li></ol><p id="b2d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">随机行走模型可以表示为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lv"><img src="../Images/cee3e334faa68f9c2589401dc2382fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*ve-6qAtIMJdpv_aHYHIrAw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">随机行走方程</figcaption></figure><p id="87b7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该公式表示当前时间 t 的位置是先前位置和噪声的和，用<em class="lw"> Z. </em>表示</p><h2 id="1e32" class="lx kz hi bd la ly lz ma le mb mc md li jx me mf lk kb mg mh lm kf mi mj lo mk bi translated">用随机游走模拟收益</h2><ol class=""><li id="e428" class="kk kl hi jq b jr lq ju lr jx ml kb mm kf mn kj kp kq kr ks bi translated"><strong class="jq hj">导入库</strong></li></ol><p id="9f84" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里，我们正在导入可视化和模拟随机行走模型所需的重要库。</p><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="a0d8" class="lx kz hi mp b fi mt mu l mv mw">from statsmodels.graphics.tsaplots import plot_acf<br/>from statsmodels.tsa.stattools import acf<br/><br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>import pandas as pd<br/>import numpy as np<br/><br/>sns.set()<br/>plt.style.use('ggplot')<br/>plt.rcParams['figure.figsize'] = (14, 8)</span></pre><p id="8354" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们生成 1000 个随机点，方法是给上一个点加上一个随机度，以 0 为起点生成下一个点。</p><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="419b" class="lx kz hi mp b fi mt mu l mv mw"><em class="lw"># Draw samples from a standard Normal distribution (mean=0, stdev=1).</em><br/>points = np.random.standard_normal(1000)<br/><br/><em class="lw"># making starting point as 0</em><br/>points[0]=0<br/><br/><em class="lw"># Return the cumulative sum of the elements along a given axis.</em><br/>random_walk = np.cumsum(points)<br/>random_walk_series = pd.Series(random_walk)</span></pre><p id="c26e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 2。绘制模拟随机漫步</strong></p><p id="f017" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们绘制数据集。</p><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="ab1f" class="lx kz hi mp b fi mt mu l mv mw">plt.figure(figsize=[10, 7.5]); <em class="lw"># Set dimensions for figure</em><br/>plt.plot(random_walk)<br/>plt.title("Simulated Random Walk")<br/>plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/d700681ee534e3dc81eed7acb3627ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3bUJjABfq75o-35jITt6cA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">模拟随机行走</figcaption></figure><p id="59d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 3。自相关图</strong></p><p id="526f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">自相关图旨在显示时间序列的元素是正相关、负相关还是相互独立。自相关图在纵轴上显示自相关函数(acf)的值。它的范围从–1 到 1。</p><p id="922a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以计算时间序列观测值与先前时间步长观测值的相关性，称为<em class="lw">滞后</em>。因为时间序列观测值的相关性是用先前时间的相同序列的值计算的，这被称为序列相关性，或<em class="lw">自相关</em>。</p><p id="9cf4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">滞后时间序列的自相关图称为自相关函数，或缩写为 ACF。该图有时被称为相关图或自相关图。</p><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="e176" class="lx kz hi mp b fi mt mu l mv mw">random_walk_acf = acf(random_walk)<br/>acf_plot = plot_acf(random_walk_acf, lags=20)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/4ca44417ce5e23590ee3b9d397ebe458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZoHkTI5Z5N2XzlzJnxwGw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">自相关图</figcaption></figure><p id="eee6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">查看相关图，我们可以说<em class="lw">过程不是静止的。</em>但是有一种方法可以去除这种趋势。我会尝试不同的方法，使这个过程成为一个静态过程-</p><ol class=""><li id="cfa1" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">知道一个随机游走给前一个点增加了一个随机噪声，如果我们取每个点和它前一个点的差，就应该得到一个纯随机的随机过程。</li><li id="67c5" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">获取价格的对数收益。</li></ol><p id="0ddb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 4。2 分之差</strong></p><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="38c3" class="lx kz hi mp b fi mt mu l mv mw">random_walk_difference = np.diff(random_walk, n=1)<br/><br/>plt.figure(figsize=[10, 7.5]); <em class="lw"># Set dimensions for figure</em><br/>plt.plot(random_walk_difference)<br/>plt.title('Noise')<br/>plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/c7d6aa3322b70ad12629c87b661455e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ulpgqw9DR8-1Ec55gWe0Pg.png"/></div></div></figure><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="9a1d" class="lx kz hi mp b fi mt mu l mv mw">cof_plot_difference = plot_acf(random_walk_difference, lags=20);</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/202007ee5b3f13f9cbf2490d1ab2f4ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tngkT8W78DRLWwZFFK03ew.png"/></div></div></figure><p id="9e75" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们看到这是一个纯随机过程的相关图，自相关系数在滞后 1 时下降。</p><h1 id="635d" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">移动平均模型(移动平均模型)</h1><p id="dd8e" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">在 MA 模型中，我们从平均 mu 开始，为了获得时间 t 的值，我们添加来自先前时间戳的残差的线性组合。在金融中，残差是指过去的数据点无法捕捉到的新的不可预测的信息。残差是模型过去预测值和实际值之间的差值。</p><p id="2f53" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">移动平均模型被定义为 MA(q ),其中 q 是滞后。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/7b750d36695c14b8263ba4104976d32f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tpwshRuOc43HY4TepwCR9g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用滞后'<em class="nc"> q '表示移动平均模型；</em>(来源:<a class="ae jn" href="https://www.udacity.com/course/ai-for-trading--nd880" rel="noopener ugc nofollow" target="_blank"> AI 在 Udacity 上交易纳米学位课程</a>)</figcaption></figure><p id="1800" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以 3 阶 MA 模型为例，表示为 MA(3):</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/b6ca7e3f7fd511951ea3fdd2acc7cf0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LPWKaXeMn5PQRp9UF29NQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">滞后=3 的移动平均模型的表示；马(3)</figcaption></figure><p id="c95b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的等式表明，时间 t 处的位置 y 取决于时间 t 处的噪声，加上时间 t-1 处的噪声(具有某个权重ε)，加上时间 t-2 处的一些噪声(具有某个权重)，加上时间 t-3 处的一些噪声。</p><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="e620" class="lx kz hi mp b fi mt mu l mv mw">from statsmodels.tsa.arima_process import ArmaProcess<br/><br/><em class="lw"># start by specifying the lag</em><br/>ar3 = np.array([3])<br/><br/><em class="lw"># specify the weights : [1, 0.9, 0.3, -0.2]</em><br/>ma3 = np.array([1, 0.9, 0.3, -0.2])<br/><br/><em class="lw"># simulate the process and generate 1000 data points</em><br/>MA_3_process = ArmaProcess(ar3, ma3).generate_sample(nsample=1000)</span><span id="f5e5" class="lx kz hi mp b fi ne mu l mv mw">plt.figure(figsize=[10, 7.5]); <em class="lw"># Set dimensions for figure</em><br/>plt.plot(MA_3_process)<br/>plt.title('Simulation of MA(3) Model')<br/>plt.show()<br/>plot_acf(MA_3_process, lags=20);</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/8857ae65353a0b36aa49bcb7508d70ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkP5H5xGAHmbc7WWK8GDPg.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/af47766785710d8b1548d000ede6e1b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAJBKJkiu_i0rTrm2N2iCA.png"/></div></div></figure><p id="9787" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如你所看到的，在第三阶段有显著的相关性。之后，相关性不再显著。这是有意义的，因为我们指定了一个滞后为 3 的公式。</p><h1 id="10e3" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">自回归模型(AR 模型)</h1><p id="6291" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">自回归模型(AR 模型)试图拟合以前值的线性组合线。它包括一个<em class="lw">截距</em>，该截距与之前的值无关。它还包含<em class="lw">误差项</em>来表示先前项无法预测的运动。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nh"><img src="../Images/2a138fd8cb46c056d06d15f7ebd82612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztI8wVZxCOO5LNpZ7Z-_tQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">AR 模型(来源:<a class="ae jn" href="https://www.udacity.com/course/ai-for-trading--nd880" rel="noopener ugc nofollow" target="_blank"> AI 在 Udacity </a>上交易纳米学位课程)</figcaption></figure><p id="1ac7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">AR 模型由其<em class="lw">滞后</em>定义。如果一个 AR 模型只使用昨天的值而忽略其他的，它被称为<em class="lw"> AR 滞后 1 </em>，如果模型使用前两天的值而忽略其他的，它被称为<em class="lw"> AR 滞后 2 </em>等等。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ni"><img src="../Images/6c2ab15c84204c35e244e9ddab20a761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NUjRkMIuOtuqFgIafueCw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">AR Lag(来源:<a class="ae jn" href="https://www.udacity.com/course/ai-for-trading--nd880" rel="noopener ugc nofollow" target="_blank"> AI 在 Udacity </a>上交易纳米学位课程)</figcaption></figure><p id="9daf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通常，自回归模型仅适用于平稳时间序列。这限制了参数φ的范围。例如，AR(1)模型会将 phi 限制在-1 和 1 之间。随着模型阶数的增加，这些约束变得更加复杂，但是在 Python 中建模时会自动考虑这些约束。</p><h2 id="34a0" class="lx kz hi bd la ly lz ma le mb mc md li jx me mf lk kb mg mh lm kf mi mj lo mk bi translated">模拟具有自回归特性的收益序列</h2><p id="2ee6" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">为了模拟 AR(3)过程，我们将使用<a class="ae jn" href="https://www.statsmodels.org/stable/generated/statsmodels.tsa.arima_process.ArmaProcess.html" rel="noopener ugc nofollow" target="_blank"> ArmaProcess </a>。</p><p id="bd57" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为此，让我们举一个我们用来模拟随机行走模型的例子:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/b6ca7e3f7fd511951ea3fdd2acc7cf0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LPWKaXeMn5PQRp9UF29NQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">MA(3)模型的表示</figcaption></figure><p id="7bbd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为我们正在处理一个 3 阶的自回归模型，我们需要定义滞后 0，1，2 和 3 的系数。此外，我们将取消移动平均线过程的影响。最后，我们将生成 10000 个数据点。</p><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="0a9d" class="lx kz hi mp b fi mt mu l mv mw">ar3 = np.array([1, 0.9, 0.3, -0.2])<br/>ma = np.array([3])<br/>simulated_ar3_points = ArmaProcess(ar3, ma).generate_sample(nsample=10000)</span><span id="dad1" class="lx kz hi mp b fi ne mu l mv mw">plt.figure(figsize=[10, 7.5]); <em class="lw"># Set dimensions for figure</em><br/>plt.plot(simulated_ar3_points)<br/>plt.title("Simulation of AR(3) Process")<br/>plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nj"><img src="../Images/e3080e34e974bf2d332eb5dd8a4cf2b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aMCKt0Yr0OmrOJNi1FQqUw.png"/></div></div></figure><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="957d" class="lx kz hi mp b fi mt mu l mv mw">plot_acf(simulated_ar3_points);</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nk"><img src="../Images/bc3d2680a2f6351d2f803f1baf95866a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T694uA9uO9IS_OqnGyml9A.png"/></div></div></figure><p id="aba0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">查看相关图，我们可以看到系数在缓慢衰减。现在让我们画出相应的偏相关图。</p><h2 id="97a1" class="lx kz hi bd la ly lz ma le mb mc md li jx me mf lk kb mg mh lm kf mi mj lo mk bi translated">部分自相关图</h2><p id="db41" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">观测值和先前时间步长的观测值的自相关由直接相关和间接相关组成。这些间接相关性是观测值相关性的线性函数，观测值位于中间时间步长。</p><p id="e1d8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">偏相关函数试图消除的就是这些间接相关性。</p><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="1a36" class="lx kz hi mp b fi mt mu l mv mw">from statsmodels.graphics.tsaplots import plot_pacf<br/><br/>plot_pacf(simulated_ar3_points);</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nl"><img src="../Images/5e79c107815bee643df9b1d3be0129f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bhMvAZjLHK9CKu9FQ8WX9Q.png"/></div></div></figure><p id="fd4f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如你所看到的，滞后 3 之后，系数并不显著。因此，部分自相关图对于确定 AR(p)过程的阶数是有用的。您也可以使用 import 语句<code class="du nm nn no mp b">from statsmodels.tsa.stattools import pacf</code>查看这些值</p><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="85fc" class="lx kz hi mp b fi mt mu l mv mw">from statsmodels.tsa.stattools import pacf<br/><br/>pacf_coef_AR3 = pacf(simulated_ar3_points)<br/>print(pacf_coef_AR3)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es np"><img src="../Images/6ffaa82abf64645d06c3028fc3e1c1ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRkdIDL5MqLyAEJNdTwS0A.png"/></div></div></figure><h1 id="70ad" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">自回归移动平均模型</h1><p id="19b8" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">ARMA 模型用一个<em class="lw"> p 和 q </em>来定义。<em class="lw"> p </em>是自回归的滞后，<em class="lw"> q </em>是移动平均的滞后。基于回归的训练模型要求数据<em class="lw">稳定</em>。对于非平稳数据集，均值、方差和协方差可能会随时间而变化。这造成了根据过去预测未来的困难。</p><p id="deb2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">回顾自回归模型(AR 模型)的方程:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nh"><img src="../Images/2a138fd8cb46c056d06d15f7ebd82612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztI8wVZxCOO5LNpZ7Z-_tQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">AR 模型。(来源:<a class="ae jn" href="https://www.udacity.com/course/ai-for-trading--nd880" rel="noopener ugc nofollow" target="_blank"> AI 在 Udacity 上交易纳米学位课程</a>)</figcaption></figure><p id="1427" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看移动平均线模型(MA 模型)的方程:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/7b750d36695c14b8263ba4104976d32f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tpwshRuOc43HY4TepwCR9g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">马模型。(来源:<a class="ae jn" href="https://www.udacity.com/course/ai-for-trading--nd880" rel="noopener ugc nofollow" target="_blank"> AI 在 Udacity 上交易纳米学位课程</a>)</figcaption></figure><p id="7ae0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">ARMA 模型的方程就是两者的简单组合:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nq"><img src="../Images/46e8270d2f68ee2e240befecee38d2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPECUofmDP3vUp7qYYPolg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ARMA 模型</figcaption></figure><p id="33ac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，该模型可以解释随机噪声(移动平均部分)和前一步(自回归部分)的时间序列之间的关系。</p><h2 id="85ad" class="lx kz hi bd la ly lz ma le mb mc md li jx me mf lk kb mg mh lm kf mi mj lo mk bi translated"><strong class="ak">模拟 ARMA(1，1)过程</strong></h2><p id="2cb1" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">这里，我们将模拟一个 ARMA(1，1)模型，其方程为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nr"><img src="../Images/6d23e57e0f88390cd94aebbce3f88255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pkGbVPStbHj6xd1LVDrFmA.png"/></div></div></figure><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="3250" class="lx kz hi mp b fi mt mu l mv mw">ar1 = np.array([1, 0.6])<br/>ma1 = np.array([1, -0.2])<br/>simulated_ARMA_1_1_points = ArmaProcess(ar1, ma1).generate_sample(nsample=10000)</span><span id="95f6" class="lx kz hi mp b fi ne mu l mv mw">plt.figure(figsize=[15, 7.5]); <em class="lw"># Set dimensions for figure</em><br/>plt.plot(simulated_ARMA_1_1_points)<br/>plt.title("Simulated ARMA(1,1) Process")<br/>plt.xlim([0, 200])<br/>plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ns"><img src="../Images/d2671c68bff8a08464a811f6f89f6746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ROdvmCb_Pr4QWGnswnxyg.png"/></div></div></figure><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="ec85" class="lx kz hi mp b fi mt mu l mv mw">plot_acf(simulated_ARMA_1_1_points);<br/>plot_pacf(simulated_ARMA_1_1_points);</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nt"><img src="../Images/ed6c665550ebb75c7457515eaa6090a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUIBFfRnCgotGE8ODQlmWw.png"/></div></div></figure><p id="8a9c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如你所看到的，两条曲线显示了相同的正弦趋势，这进一步支持了 AR(p)过程和 MA(q)过程都在起作用的事实。</p><h1 id="fce4" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">自回归综合移动平均(ARIMA)</h1><p id="1947" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">这个模型是自回归、移动平均模型和差分的结合。在这种情况下，整合是分化的对立面。</p><p id="ac2e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">微分有助于消除时间序列中的趋势，使其保持平稳。<br/>它只是简单地包括从时间 t 中减去点 a t-1</p><p id="7dcd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">数学上，ARIMA(p，d，q)现在需要三个参数:</p><ol class=""><li id="f516" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">p:自回归过程的阶</li><li id="6b62" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">d:差异程度(差异的次数)</li><li id="6349" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">问:移动平均线过程的顺序</li></ol><p id="452d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该等式可以表示如下:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nu"><img src="../Images/3a1cb66683e9e07843e24da324914ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GiVoIElKAbAZZnp-W-6lqA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ARIMA 模型的表示</figcaption></figure><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="1a21" class="lx kz hi mp b fi mt mu l mv mw">np.random.seed(200)<br/><br/>ar_params = np.array([1, -0.4])<br/>ma_params = np.array([1, -0.8])<br/><br/>returns = ArmaProcess(ar_params, ma_params).generate_sample(nsample=1000)<br/><br/>returns = pd.Series(returns)<br/>drift = 100<br/><br/>price = pd.Series(np.cumsum(returns)) + drift</span><span id="28c5" class="lx kz hi mp b fi ne mu l mv mw">returns.plot(figsize=(15,6), color=sns.xkcd_rgb["orange"], title="simulated return series")<br/>plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nv"><img src="../Images/6355e141fdbe614a5c796d60a1eccf6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DNYvWyffySNj1N5_gmftA.png"/></div></div></figure><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="a13e" class="lx kz hi mp b fi mt mu l mv mw">price.plot(figsize=(15,6), color=sns.xkcd_rgb["baby blue"], title="simulated price series")<br/>plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nw"><img src="../Images/e020766ebae085c2e1748e4c45ca59ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbnFu9_elfPObiB9CYh_yA.png"/></div></div></figure><h2 id="a6cf" class="lx kz hi bd la ly lz ma le mb mc md li jx me mf lk kb mg mh lm kf mi mj lo mk bi translated">提取静态数据</h2><p id="8ec8" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">获得平稳时间序列的一种方法是获取时间序列中各点之间的差值。这个时间差叫做<em class="lw">变化率。</em></p><p id="66bd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du nm nn no mp b">rate_of_change = current_price / previous_price</code></p><p id="03ff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">相应的<em class="lw">日志返回</em>将变为:</p><p id="c8c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du nm nn no mp b">log_returns = log(current_price) - log(previous_price)</code></p><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="5055" class="lx kz hi mp b fi mt mu l mv mw">log_return = np.log(price) - np.log(price.shift(1))<br/>log_return = log_return[1:]<br/>_ = plot_acf(log_return,lags=10, title='log return autocorrelation')</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nx"><img src="../Images/e932b05dc7ec0b6600cf03f283a49951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwFdmN5GB_eu_jAhSWR5yA.png"/></div></div></figure><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="1158" class="lx kz hi mp b fi mt mu l mv mw">_ = plot_pacf(log_return, lags=10, title='log return Partial Autocorrelation', color=sns.xkcd_rgb["crimson"])</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nw"><img src="../Images/4ce8080d933f2d0c30240a3fde91581d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*euofA7dpEchWxSJ7wXhhOg.png"/></div></div></figure><pre class="iy iz ja jb fd mo mp mq mr aw ms bi"><span id="e076" class="lx kz hi mp b fi mt mu l mv mw">from statsmodels.tsa.arima_model import ARIMA<br/><br/>def fit_arima(log_returns):<br/>        ar_lag_p = 1<br/>        ma_lag_q = 1<br/>        degree_of_differentiation_d = 0<br/><br/>        <em class="lw"># create tuple : (p, d, q)</em><br/>        order = (ar_lag_p, degree_of_differentiation_d, ma_lag_q)<br/><br/>        <em class="lw"># create an ARIMA model object, passing in the values of the lret pandas series,</em><br/>        <em class="lw"># and the tuple containing the (p,d,q) order arguments</em><br/>        arima_model = ARIMA(log_returns.values, order=order)<br/>        arima_result = arima_model.fit()<br/><br/>        <em class="lw">#TODO: from the result of calling ARIMA.fit(),</em><br/>        <em class="lw"># save and return the fitted values, autoregression parameters, and moving average parameters</em><br/>        fittedvalues = arima_result.fittedvalues<br/>        arparams = arima_result.arparams<br/>        maparams = arima_result.maparams<br/><br/>        return fittedvalues,arparams,maparams</span><span id="2b90" class="lx kz hi mp b fi ne mu l mv mw">fittedvalues,arparams,maparams = fit_arima(log_return)<br/>arima_pred = pd.Series(fittedvalues)<br/>plt.plot(log_return, color=sns.xkcd_rgb["pale purple"])<br/>plt.plot(arima_pred, color=sns.xkcd_rgb["jade green"])<br/>plt.title('Log Returns and predictions using an ARIMA(p=1,d=1,q=1) model');<br/>print(f"fitted AR parameter <strong class="mp hj">{</strong>arparams[0]<strong class="mp hj">:</strong>.2f<strong class="mp hj">}</strong>, MA parameter <strong class="mp hj">{</strong>maparams[0]<strong class="mp hj">:</strong>.2f<strong class="mp hj">}</strong>")</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/d0c1dc1dcf4a37039ff68190a11b34db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_SeDzrHS26r9DRIaQx5xg.png"/></div></div></figure></div><div class="ab cl ny nz gp oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="hb hc hd he hf"><h2 id="7ebb" class="lx kz hi bd la ly lz ma le mb mc md li jx me mf lk kb mg mh lm kf mi mj lo mk bi translated">参考</h2><ol class=""><li id="4249" class="kk kl hi jq b jr lq ju lr jx ml kb mm kf mn kj kp kq kr ks bi translated"><a class="ae jn" href="https://towardsdatascience.com/how-to-model-time-series-in-python-9983ebbf82cf" rel="noopener" target="_blank">https://towards data science . com/how-to-model-time-series-in-python-9983 ebbf 82 cf</a></li><li id="80e7" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="https://towardsdatascience.com/advanced-time-series-analysis-with-arma-and-arima-a7d9b589ed6d" rel="noopener" target="_blank">https://towards data science . com/advanced-time-series-analysis-with-ARMA-and-ARIMA-a7d 9b 589 ed6d</a></li><li id="68de" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="https://towardsdatascience.com/time-series-forecasting-with-autoregressive-processes-ba629717401" rel="noopener" target="_blank">https://towards data science . com/time-series-forecasting-with-auto regressive-processes-ba 629717401</a></li><li id="0bae" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="https://stackoverflow.com/questions/52815990/valueerror-the-computed-initial-ma-coefficients-are-not-invertible-you-should-i" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/52815990/value error-the-computed-initial-ma-coefficients-is-not-inverse-you-should-I</a></li><li id="58c3" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="https://www.udacity.com/course/ai-for-trading--nd880" rel="noopener ugc nofollow" target="_blank">在 Udacity 上交易纳米学位课程的 AI</a>。</li><li id="763d" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="https://github.com/purvasingh96/AI-for-Trading/tree/master/Term%201/Theorey%20%26%20Quizes/04.%20Time%20Series%20Modelling" rel="noopener ugc nofollow" target="_blank">交易用 Github AI 时间序列</a></li><li id="ba36" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="https://www.kaggle.com/purvasingh/time-series-analysis-with-arma-and-arima" rel="noopener ugc nofollow" target="_blank">基于 ARMA 和 ARIMA 的时间序列分析</a></li></ol></div></div>    
</body>
</html>