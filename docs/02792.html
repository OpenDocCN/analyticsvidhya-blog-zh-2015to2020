<html>
<head>
<title>Metadata-based Recommender Systems in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中基于元数据的推荐系统</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/metadata-based-recommender-systems-in-python-c6aae213b25c?source=collection_archive---------11-----------------------#2020-01-02">https://medium.com/analytics-vidhya/metadata-based-recommender-systems-in-python-c6aae213b25c?source=collection_archive---------11-----------------------#2020-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="14bd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><em class="ix">本博客用python </em>展示了一个 <strong class="ak"> <em class="ix">基于元数据的推荐系统</em> </strong> <em class="ix"/></h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es iy"><img src="../Images/318fbe1d2ab74c76eed9aec32c98c475.png" data-original-src="https://miro.medium.com/v2/resize:fit:48/0*VJg_LVU16DVrXKU0"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es jg"><img src="../Images/2a452e7d1f26ed36e04ab948818ec4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*G3Xdsnw7nNEWCL7zhPYZwA.png"/></div></figure><p id="fba0" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">在开始用python实现基于元数据的推荐系统之前，我建议您花4分钟阅读这篇博客，它用外行的术语定义了推荐系统及其类型。</p><p id="2fab" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated"><a class="ae kd" rel="noopener" href="/@saketgarodia/the-world-of-recommender-systems-e4ea504341ac?source=friends_link&amp;sk=508a980d8391daa93530a32e9c927a87">https://medium . com/@ saketgarodia/the-world-of-recommender-systems-e4ea 504341 AC？source = friends _ link&amp;sk = 508 a 980d 8391 DAA 93530 a 32 e 9c 927 a 87</a></p><p id="259d" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">通过这篇博客，我将展示如何在Kaggle的MovieLens 100k数据集上用Python实现一个基于元数据的推荐系统。</p><p id="8fb4" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">我们将使用的数据集是Kaggle上的MovieLens 100k数据集:</p><div class="ke kf ez fb kg kh"><a href="https://www.kaggle.com/prajitdatta/movielens-100k-dataset" rel="noopener  ugc nofollow" target="_blank"><div class="ki ab dw"><div class="kj ab kk cl cj kl"><h2 class="bd hj fi z dy km ea eb kn ed ef hh bi translated">MovieLens 100K数据集</h2><div class="ko l"><h3 class="bd b fi z dy km ea eb kn ed ef dx translated">稳定的基准数据集。1000名用户对1700部电影的100，000次评分</h3></div><div class="kp l"><p class="bd b fp z dy km ea eb kn ed ef dx translated">www.kaggle.com</p></div></div><div class="kq l"><div class="kr l ks kt ku kq kv je kh"/></div></div></a></div><p id="177c" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">让我们开始实施它。</p><h1 id="3b06" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">问题定式化</h1><p id="68a5" class="pw-post-body-paragraph jh ji hi jj b jk lo ij jm jn lp im jp jq lq js jt ju lr jw jx jy ls ka kb kc hb bi translated"><em class="lt">建立一个推荐系统，根据之前看过的电影的流派、演员、剧组和一些关键词推荐电影。</em></p><h1 id="a38c" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated"><strong class="ak">实施</strong></h1><p id="b6aa" class="pw-post-body-paragraph jh ji hi jj b jk lo ij jm jn lp im jp jq lq js jt ju lr jw jx jy ls ka kb kc hb bi translated">首先，让我们导入所有必要的库，我们将使用它们来创建一个基于内容的推荐系统。让我们也导入必要的数据文件。</p><pre class="iz ja jb jc fd lu lv lw lx aw ly bi"><span id="62ce" class="lz kx hi lv b fi ma mb l mc md">#importing necessary libraries</span><span id="d233" class="lz kx hi lv b fi me mb l mc md">import numpy as np</span><span id="8c5e" class="lz kx hi lv b fi me mb l mc md">import pandas as pd</span><span id="8527" class="lz kx hi lv b fi me mb l mc md">from sklearn.metrics.pairwise import cosine_similarity</span><span id="9308" class="lz kx hi lv b fi me mb l mc md">from sklearn.metrics import mean_squared_error</span><span id="e95b" class="lz kx hi lv b fi me mb l mc md">from sklearn.model_selection import train_test_split</span><span id="6679" class="lz kx hi lv b fi me mb l mc md">from sklearn.feature_extraction.text import TfidfVectorizer</span><span id="aaed" class="lz kx hi lv b fi me mb l mc md">from sklearn.metrics.pairwise import linear_kernel</span><span id="9538" class="lz kx hi lv b fi me mb l mc md">from ast import literal_eval</span><span id="b3dc" class="lz kx hi lv b fi me mb l mc md">from sklearn.feature_extraction.text import CountVectorizer</span><span id="74d0" class="lz kx hi lv b fi me mb l mc md">movies = pd.read_csv(‘movies_metadata.csv’)</span><span id="6a65" class="lz kx hi lv b fi me mb l mc md">credits = pd.read_csv(‘credits.csv’)</span><span id="fe0f" class="lz kx hi lv b fi me mb l mc md">#keywords like jealousy, fishing, etc that belongs to particular movies are also part of the metadata.</span><span id="717b" class="lz kx hi lv b fi me mb l mc md">#we will grab keywords from keywords.csv</span><span id="a819" class="lz kx hi lv b fi me mb l mc md">keywords = pd.read_csv(‘keywords.csv’)</span><span id="33c9" class="lz kx hi lv b fi me mb l mc md">#importing necessary columns</span><span id="bc37" class="lz kx hi lv b fi me mb l mc md">movies = movies[[‘id’,’title’,’genres’]]</span><span id="6579" class="lz kx hi lv b fi me mb l mc md">#clean movie_id function</span><span id="e71a" class="lz kx hi lv b fi me mb l mc md">def clean_id(x):</span><span id="8a7c" class="lz kx hi lv b fi me mb l mc md">try:</span><span id="eeea" class="lz kx hi lv b fi me mb l mc md">return int(x)</span><span id="9abf" class="lz kx hi lv b fi me mb l mc md">except:</span><span id="6739" class="lz kx hi lv b fi me mb l mc md">return np.nan</span><span id="e94d" class="lz kx hi lv b fi me mb l mc md">movies['id'] = movies['id'].apply(clean_id)</span><span id="2602" class="lz kx hi lv b fi me mb l mc md">movies = movies[movies['id'].notnull()]</span><span id="bf44" class="lz kx hi lv b fi me mb l mc md">#converting everything into integer</span><span id="bbf9" class="lz kx hi lv b fi me mb l mc md">movies['id'] = movies['id'].astype('int')</span><span id="2925" class="lz kx hi lv b fi me mb l mc md">keywords['id'] = keywords['id'].astype('int')</span><span id="cfac" class="lz kx hi lv b fi me mb l mc md">credits['id'] = credits['id'].astype('int')</span><span id="cfe1" class="lz kx hi lv b fi me mb l mc md">#merging the 3 dataframes to get all the required data on 1 datafarame movies</span><span id="4f6f" class="lz kx hi lv b fi me mb l mc md">movies = movies.merge(credits, on='id')</span><span id="6266" class="lz kx hi lv b fi me mb l mc md">movies = movies.merge(keywords, on='id')</span></pre><p id="0601" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">在合并独立的数据文件credits.csv、keywords.csv和movies_metadata.csv之后，这里是我们在<strong class="jj hj"> <em class="lt"> movies数据帧</em> </strong>中的内容:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mf"><img src="../Images/1a81914535e41ff6a411d078dd94b858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCLgx0WVHgKGD0V5sLf2YQ.png"/></div></div></figure><p id="9190" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">现在，让我们对数据进行必要的讨论，因为这些数据似乎格式混乱，有很多我们在分析中不会用到的信息。</p><p id="f78e" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated"><strong class="jj hj">流派</strong>、<strong class="jj hj">演员表</strong>、<strong class="jj hj">剧组、</strong>和<strong class="jj hj">关键词</strong>列都是对象(或字符串数据类型)。让我们首先使用<strong class="jj hj"> <em class="lt"> literal_eval </em> </strong>将这些字符串转换成python对象(这里是字典列表)并使用pandas和numpy来处理它们，从而从这些列中获得我们将使用的单词。</p><pre class="iz ja jb jc fd lu lv lw lx aw ly bi"><span id="e999" class="lz kx hi lv b fi ma mb l mc md">#changing the 4 columns into python objects ( list of dictionaries here)</span><span id="736d" class="lz kx hi lv b fi me mb l mc md">movies[‘genres’] = movies[‘genres’].apply(literal_eval)</span><span id="e6be" class="lz kx hi lv b fi me mb l mc md">movies[‘cast’] = movies[‘cast’].apply(literal_eval)</span><span id="17a9" class="lz kx hi lv b fi me mb l mc md">movies[‘crew’] = movies[‘crew’].apply(literal_eval)</span><span id="884b" class="lz kx hi lv b fi me mb l mc md">movies[‘keywords’] = movies[‘keywords’].apply(literal_eval)</span><span id="d8c0" class="lz kx hi lv b fi me mb l mc md">#grabbing the names of all the genres attached to each movie</span><span id="42aa" class="lz kx hi lv b fi me mb l mc md">movies[‘genres’] = movies[‘genres’].apply(lambda x: [i[‘name’].lower() for i in x])</span><span id="b9c9" class="lz kx hi lv b fi me mb l mc md">#grabbing the name of the director from all the crew members</span><span id="85f4" class="lz kx hi lv b fi me mb l mc md">#we will only use directors from the creqw column for our purpose</span><span id="a7cf" class="lz kx hi lv b fi me mb l mc md">movies[‘crew’] = movies[‘crew’].apply(lambda x: [i[‘name’].lower() for i in x if i[‘job’]==’Director’])</span><span id="a3bb" class="lz kx hi lv b fi me mb l mc md">#grabbing the cast and keywords from the list of dictionaries of those columns</span><span id="25f6" class="lz kx hi lv b fi me mb l mc md">movies[‘cast’] = movies[‘cast’].apply(lambda x: [i[‘name’].lower() for i in x])</span><span id="6dfc" class="lz kx hi lv b fi me mb l mc md">movies[‘keywords’] = movies[‘keywords’].apply(lambda x: [i[‘name’].lower() for i in x])</span><span id="baa6" class="lz kx hi lv b fi me mb l mc md">#taking maximum 3 cast/genre/keywords for each movie</span><span id="a750" class="lz kx hi lv b fi me mb l mc md">movies[‘genres’] = movies[‘genres’].apply(lambda x: x[:3] if len(x)&gt;3 else x)</span><span id="be46" class="lz kx hi lv b fi me mb l mc md">movies[‘cast’] = movies[‘cast’].apply(lambda x: x[:3] if len(x)&gt;3 else x)</span><span id="6f54" class="lz kx hi lv b fi me mb l mc md">movies[‘keywords’] = movies[‘keywords’].apply(lambda x: x[:3] if len(x)&gt;3 else x)</span></pre><p id="63bc" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">在进行了必要的清理并选择了3个流派、3个关键词和演员后，我们的数据看起来是这样的:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mk"><img src="../Images/038817d523f10a4b966cd5dce937e03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WERaEjaNfp_PZfVc7h4OmQ.png"/></div></div></figure><p id="2e3d" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">现在，我们有了构建基于元数据的推荐系统所需的干净数据。我们只需要<strong class="jj hj">删除名字和姓氏之间的空格</strong>，因为如果我们不删除空格，汤姆克鲁斯<strong class="jj hj">和汤姆汉克斯<strong class="jj hj">的电影将被机器认为是相同的，因为名字“汤姆”很常见。让我们去掉空格，这样汤姆·汉克斯就成了汤姆·汉克斯，汤姆·克鲁斯就成了汤姆·克鲁斯。</strong></strong></p><pre class="iz ja jb jc fd lu lv lw lx aw ly bi"><span id="e475" class="lz kx hi lv b fi ma mb l mc md">#removing spaces</span><span id="ad73" class="lz kx hi lv b fi me mb l mc md">movies[‘cast’] = movies[‘cast’].apply(lambda x: [i.replace(‘ ‘,’’) for i in x])</span><span id="4c9d" class="lz kx hi lv b fi me mb l mc md">movies[‘crew’] = movies[‘crew’].apply(lambda x: [i.replace(‘ ‘,’’) for i in x])</span><span id="2072" class="lz kx hi lv b fi me mb l mc md">movies[‘keywords’] = movies[‘keywords’].apply(lambda x: [i.replace(‘ ‘,’’) for i in x])</span><span id="d073" class="lz kx hi lv b fi me mb l mc md">movies[‘genres’] = movies[‘genres’].apply(lambda x: [i.replace(‘ ‘,’’) for i in x])</span></pre><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es ml"><img src="../Images/295f982d26607f073437058964e5a1d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0FOgHiKvR0OgppiPAd9Dw.png"/></div></div></figure><p id="f7d2" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">现在，演员表中的所有名字都有0个空格，这使得它们是唯一的。</p><p id="cfbd" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">现在，让我们通过在“流派”、“演员”、“工作人员”和“关键字”列中追加值，为所有元数据创建一个列。</p><pre class="iz ja jb jc fd lu lv lw lx aw ly bi"><span id="53e4" class="lz kx hi lv b fi ma mb l mc md">movies[‘metadata’] = movies.apply(lambda x : ‘ ‘.join(x[‘genres’]) + ‘ ‘ + ‘ ‘.join(x[‘cast’]) + ‘ ‘ + ‘ ‘.join(x[‘crew’]) + ‘ ‘ + ‘ ‘.join(x[‘keywords’]), axis = 1)</span></pre><p id="b5f8" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">由于google colab的内存问题，我将只运行前10000部电影来构建推荐系统。相同的代码可用于进一步扩展。</p><p id="31c4" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">我们将使用一个<strong class="jj hj">计数矢量器</strong>从我们的元数据中构建数字特征。我们不会在这里使用TfIdf，因为可能有很多电影是由同一个导演拍摄的，我们绝对不想惩罚那个导演。用户可能希望被推荐属于该导演的电影。我们拥有的大多数单词是名称和流派，它们的数量实际上对推荐电影很有用。</p><p id="0780" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">我将使用<strong class="jj hj">余弦相似度</strong>来找出任意两部电影之间的相似度。现在，让我们使用计数矢量器值创建一个余弦相似性矩阵，然后构建一个推荐器函数。</p><pre class="iz ja jb jc fd lu lv lw lx aw ly bi"><span id="0cd5" class="lz kx hi lv b fi ma mb l mc md">count_vec = CountVectorizer(stop_words=’english’)</span><span id="34c4" class="lz kx hi lv b fi me mb l mc md">count_vec_matrix = count_vec.fit_transform(movies_df[‘metadata’])</span><span id="a8f3" class="lz kx hi lv b fi me mb l mc md">cosine_sim_matrix = cosine_similarity(count_vec_matrix, count_vec_matrix)</span><span id="7c8b" class="lz kx hi lv b fi me mb l mc md">#movies index mapping</span><span id="b9d7" class="lz kx hi lv b fi me mb l mc md">mapping = pd.Series(movies_df.index,index = movies_df[‘title’])</span></pre><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mm"><img src="../Images/eb31f144fd5d1419e7ea45999c4bb7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*Ml6tnfdxijPeXAknDC6bQg.png"/></div></figure><pre class="iz ja jb jc fd lu lv lw lx aw ly bi"><span id="e30b" class="lz kx hi lv b fi ma mb l mc md">#recommender function to recommend movies based on metadata</span><span id="df41" class="lz kx hi lv b fi me mb l mc md">def recommend_movies_based_on_metadata(movie_input):</span><span id="221e" class="lz kx hi lv b fi me mb l mc md">movie_index = mapping[movie_input]</span><span id="98f5" class="lz kx hi lv b fi me mb l mc md">#get similarity values with other movies</span><span id="8195" class="lz kx hi lv b fi me mb l mc md">similarity_score = list(enumerate(cosine_sim_matrix[movie_index]))</span><span id="26f3" class="lz kx hi lv b fi me mb l mc md">similarity_score = sorted(similarity_score, key=lambda x: x[1], reverse=True)</span><span id="a809" class="lz kx hi lv b fi me mb l mc md"># Get the scores of the 15 most similar movies. Ignore the first movie.</span><span id="43f1" class="lz kx hi lv b fi me mb l mc md">similarity_score = similarity_score[1:15]</span><span id="6b10" class="lz kx hi lv b fi me mb l mc md">movie_indices = [i[0] for i in similarity_score]</span><span id="46af" class="lz kx hi lv b fi me mb l mc md">return (movies_df[‘title’].iloc[movie_indices])</span></pre><p id="c705" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">现在我们已经构建了推荐器函数，让我们看看它是如何工作的。让我们尝试使用基于元数据的推荐系统来获得类似于《盲视界》的电影。</p><p id="4a9d" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">推荐_电影_基于_元数据('盲视界')</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mn"><img src="../Images/3399a388c2c3a7e11d2fb4685d85c684.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*luvfEbkRS4zQn7zct56nIA.png"/></div></figure><p id="c13d" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">对于输入电影《盲视界》，通过学习它的元数据，我们被推荐了15部电影。是不是很神奇？</p><p id="7a0d" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">要了解基于内容和协作过滤的方法，请浏览我的以下博客:</p><ol class=""><li id="a981" class="mo mp hi jj b jk jl jn jo jq mq ju mr jy ms kc mt mu mv mw bi translated">基于内容的推荐系统:<a class="ae kd" rel="noopener" href="/@saketgarodia/content-based-recommender-systems-in-python-2b330e01eb80?source=friends_link&amp;sk=339a4eaa360453fe6952a10190ec5e9e">https://medium . com/@ saketgarodia/content-based-Recommender-Systems-in-python-2b 330 e 01 EB 80？</a></li><li id="b6ad" class="mo mp hi jj b jk mx jn my jq mz ju na jy nb kc mt mu mv mw bi translated">使用协同过滤的推荐系统:<a class="ae kd" rel="noopener" href="/@saketgarodia/recommendation-system-using-collaborative-filtering-cc310e641fde"><em class="lt">https://medium . com/@ saketgarodia/recommendation-system-using-Collaborative-Filtering-cc 310 e 641 FDE</em></a></li></ol><p id="51bb" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated"><strong class="jj hj">谢谢</strong></p><p id="3b5d" class="pw-post-body-paragraph jh ji hi jj b jk jl ij jm jn jo im jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">不断学习</p></div></div>    
</body>
</html>