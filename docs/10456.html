<html>
<head>
<title>Building Twitter Conversation Graph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Twitter对话图</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-twitter-conversation-graph-5830bee5a7eb?source=collection_archive---------11-----------------------#2020-10-19">https://medium.com/analytics-vidhya/building-twitter-conversation-graph-5830bee5a7eb?source=collection_archive---------11-----------------------#2020-10-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="974a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">编写一个Java应用程序来检索包含当前地点趋势词的tweets。然后，提取对话并构建网络图。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/51560d9024163debbda2824a791e43bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ci3s5yQuGEpba5rYs0Wfkg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">2020年10月14日推特对话图。地点是泰国</figcaption></figure><p id="d904" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<a class="ae kj" href="https://towardsdatascience.com/building-a-network-graph-from-twitter-data-a5e7b8672e3" rel="noopener" target="_blank">之前的文章</a>中，我们讨论了从Twitter数据构建网络图。我们对推文进行采样，检索用户，查询用户的朋友，并构建图表。在本文中，我们将根据Twitter对话创建另一个网络图。我们将不再使用样本推文。我们需要更多的数据来构建图表。</p><p id="8648" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果不支付一些费用，我们无法获得所有的推文。然而，我们可以发送我们正在听的单词列表。Twitter会发送包含这些词的推文。所以，我们用Twitter趋势作为一个单词列表。</p><p id="6d90" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">下面是我们在这篇文章中要做的事情:</p><ul class=""><li id="189d" class="kk kl hi jp b jq jr jt ju jw km ka kn ke ko ki kp kq kr ks bi translated">了解我们所在地附近的趋势。</li><li id="7f2f" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">创建并处理Twitter流。</li><li id="5206" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">从推文和用户构建边和节点。然后，导出到文件。</li><li id="6d60" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">将边和节点CSV文件导入图形工具Gephi。</li><li id="f200" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">运行图形和布局算法并格式化图形。</li></ul><h1 id="17c6" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">了解我们附近的趋势</h1><p id="3612" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw ls jy jz ka lt kc kd ke lu kg kh ki hb bi translated">以下是获取某个位置的twitter趋势的方法。它接受一个参数，即位置名称，并返回一个趋势列表。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="5af9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">该方法确实:</p><ul class=""><li id="f5bd" class="kk kl hi jp b jq jr jt ju jw km ka kn ke ko ki kp kq kr ks bi translated">它无处不在。然后，它获取与我们指定的位置名称相匹配的那个。</li><li id="f93c" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">通过指定位置WOEID获取趋势。然后，它将结果从数组转换为列表并返回。</li></ul><h1 id="8162" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">创建和处理twitter流</h1><p id="d6cb" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw ls jy jz ka lt kc kd ke lu kg kh ki hb bi translated">下面是创建和处理Twitter流的StreamProcessor类的部分代码。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="93b5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">run方法将创建并处理一个Twitter流。以下是它所做工作的更多细节:</p><ul class=""><li id="ba81" class="kk kl hi jp b jq jr jt ju jw km ka kn ke ko ki kp kq kr ks bi translated">创建一个Twitter流</li><li id="39fc" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">配置Twitter流，以便在tweet到达时调用消费者(函数接口)。消费者提交一个新的可调用任务(<strong class="jp hj"> SaveTweetTask </strong>)来将推文保存到数据库中。</li><li id="7d02" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">它为我们的位置获取趋势。如果有提升的趋势，则将其删除。</li><li id="4731" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">它使用趋势词和指定的语言过滤流。</li><li id="da3a" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">由于趋势经常变化，我们的代码在预先定义的时间内使用趋势作为Twitter流过滤词。然后，它得到新的趋势。如果它们发生了变化，它会清理Twitter流，并用更新的趋势对其进行过滤。</li><li id="8745" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">它永远运行，直到被杀死。然后,“close”方法运行以很好地进行清理。</li></ul><p id="b5dd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">下面是我们程序中的主类。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="ac3d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">该方法确实:</p><ul class=""><li id="729f" class="kk kl hi jp b jq jr jt ju jw km ka kn ke ko ki kp kq kr ks bi translated">它从命令行参数中获取参数。</li><li id="ebd6" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">初始化数据库连接。</li><li id="a3dd" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">它为流处理器构建了一个执行器服务。我们使用单线程执行器，因为我们的数据库是<strong class="jp hj"> SQLite </strong>。我们已经在前一篇文章中解释过了。</li><li id="c3ee" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">实例化流处理器对象</li><li id="b796" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">它添加了一个shutdown钩子，这样当它被杀死时，它会优雅地关闭流处理器和数据库。</li><li id="0290" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">最后，它运行流处理器。</li></ul><h1 id="cb6a" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">构建边和节点</h1><p id="39d1" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw ls jy jz ka lt kc kd ke lu kg kh ki hb bi translated">对于Twitter会话网络，我们将每个用户建模为一个节点。作为对另一条推文的回复的每条推文都是连接写推文的用户和写回复推文的用户的边。实现这个很简单。看看下面的tweet表模式:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/10c38e3eebd74d95e505c0c0984a7fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voZD5yK7ZSUfQ7RjxxMOkA.png"/></div></div></figure><p id="5f4e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当这条推文是对另一条推文的回复时，最后两列(<strong class="jp hj"> in_reply_to_status_id </strong>和<strong class="jp hj"> in_reply_to_user_id </strong>)是相关的。如果这条推文不是回复，则两列值为-1。为了构建一个边，使用<strong class="jp hj">用户id </strong>列作为源节点id，使用<strong class="jp hj"> in_reply_to_user_id </strong>作为目标节点id。因此，我们可以使用下面的简单SQL查询来获取所有tweets的所有边。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="9b45" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">以下SQL语句是获取与会话相关联的节点的查询。这只是一个简单的与用户表的SQL连接。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="57ef" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">运行两个查询并将结果导出到CSV文件。</p><p id="087f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们在2020年10月14日运行了Twitter收集器程序，同时将地点设置为泰国。我们收到了290万条推文。当我们运行上面的SQL语句时，我们得到了4，653条边和3，157个节点。</p><h1 id="5d05" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">将边和节点CSV文件导入Gephi</h1><p id="e127" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw ls jy jz ka lt kc kd ke lu kg kh ki hb bi translated">导入边和节点后，图形如下图所示。Gephi将合并具有相同源和目标的边。因为我们有几千个边和节点，所以这个图看起来很混乱。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/2de42f9c72996908adb7709a0d377858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQ7h-CMWxz0bUOqdt_4rGA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">导入数据后的对话图</figcaption></figure><h1 id="8422" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">图形算法和布局算法</h1><p id="0b80" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw ls jy jz ka lt kc kd ke lu kg kh ki hb bi translated">我们需要运行一些图形和布局算法，使图形看起来不那么凌乱，看起来更有意义。</p><p id="6cf3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，我们运行了<strong class="jp hj"> PageRank </strong>算法。这是一种测量节点的方向和传递影响的图中心算法。具有更高的<strong class="jp hj"> PageRank </strong>值的节点具有更大的功率。下面显示了结果。请注意，一些追随者计数不太高的节点可能具有较高的<strong class="jp hj"> PageRank </strong>值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/f180bd6cdb601509b96036c381147a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXi5Wy0K-easr9dmVNHdJw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">运行PageRank算法后的节点数据</figcaption></figure><p id="3455" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将节点大小配置为与<strong class="jp hj"> PageRank </strong>值成比例。结果如下所示。节点停留在相同的位置。具有较高<strong class="jp hj"> PageRank </strong>的节点看起来比较低<strong class="jp hj"> PageRank </strong>的节点大。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/ceb0e840b4ad4b27fa8e92a41db6a260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tXb__h2WN6t1pRg26kCpbQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">节点大小配置为与PageRank值成比例后的图形</figcaption></figure><p id="b02c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">接下来，我们运行了一个布局算法，使带有边的节点保持在一起。中间没有边的节点被放在更远的地方。我们选择了<strong class="jp hj"> ForceAtlas2 </strong>布局，因为它速度很快，可以处理大量节点和一些要配置的参数。结果如下。我们可以看到有几个大节点和一些边。一些大节点聚集在一起。此外，还有大量远离中心的不连通子图。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/583fae331e0531017cf959b97da0df86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P0qoP82SvVoRjX_vS2bCA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">运行ForceAtlas2布局后的图形</figcaption></figure><p id="977b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">接下来，我们运行了一个社区检测算法。然后，我们根据算法检测到的类别配置节点颜色。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/cb54ef34224283d8445dd4f957559567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHtXsn_ZpzlCcYBCIxe36Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ran模块算法后的图</figcaption></figure><p id="91f1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在最后一步中，我们打开了显示节点标签。将标签设置为与节点大小成比例。可选地，改变背景颜色，因为我们认为这是更好的标签。这是图表。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/75317ca8b05b5e428a3af57a129daf95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6pb6Esa2zvJJkTZwdiqwg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">带节点标签的对话图</figcaption></figure><p id="f759" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在最终的对话图中，我们可以清楚地看到哪些节点对其他节点有更大的影响。此外，我们可以注意到哪些节点属于同一个组。</p><h1 id="ff96" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">结论</h1><p id="de84" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw ls jy jz ka lt kc kd ke lu kg kh ki hb bi translated">我们构建了一个Java应用程序来根据位置趋势收集tweet数据。我们已经从对话推文中生成了图的边和节点。将那些图形数据导入到<strong class="jp hj"> Gephi </strong>中。然后，我们运行了<strong class="jp hj">页面排名</strong>，社区检测和布局算法。对话图将提供一些关于用户和他们之间交互的有见地的信息。</p><h1 id="f7c1" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">改进建议</h1><p id="a870" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw ls jy jz ka lt kc kd ke lu kg kh ki hb bi translated">仅使用地点趋势可能会有问题，因为:</p><ul class=""><li id="1148" class="kk kl hi jp b jq jr jt ju jw km ka kn ke ko ki kp kq kr ks bi translated">我们经常注意到Twitter应用中的趋势与place trends API结果不同。</li><li id="a220" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">我们经历了几天的地方趋势停滞，虽然它很少发生。</li></ul><p id="6568" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">不管怎样，我们应该能处理好这件事。我们在实现中已经有了一个变通方法，但是为了简单起见，没有在本文中展示。另外，我们想为我们的读者做一个练习。</p></div></div>    
</body>
</html>