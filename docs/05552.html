<html>
<head>
<title>Understanding CallBacks using Python — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python理解回调——第2部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-callbacks-using-python-part-2-e71c17fed7e2?source=collection_archive---------4-----------------------#2020-04-25">https://medium.com/analytics-vidhya/understanding-callbacks-using-python-part-2-e71c17fed7e2?source=collection_archive---------4-----------------------#2020-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1ec38f03d8b646f444ae054a25d52c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGLg5iakV401GDidgzP4YQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://inspireski.com/" rel="noopener ugc nofollow" target="_blank">https://inspireski.com/</a></figcaption></figure><p id="19d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇博客是上一篇博客的延续，在上一篇博客中，我们讨论了回调函数，以及如何为我们编写的基本函数添加功能。我推荐在这里阅读<a class="ae iu" rel="noopener" href="/@anandagarwal_13834/understanding-callbacks-a22e8957a73b">第一部分</a>，以获得这个博客的逻辑流程。作为第一部分，博客将直接解释来自这个<a class="ae iu" href="https://github.com/eranandagarwal/callbacks" rel="noopener ugc nofollow" target="_blank"> Github </a>的代码。编程语言是Python，读者应该理解Python中使用的类的非常基础的知识才能继续前进。</p><p id="35ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如下面的总结是我们到目前为止使用的基本函数，这个名为slow_calculation的函数计算从0到4的平方数，然后将它们加到返回的变量上</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/840ead99b4b43516a7e005e414cf1df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*hChsgjjQT_NKaO1vJkKdyg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">慢速计算功能</figcaption></figure><p id="7c46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在前一篇博客中，我们写了回调函数，然后作为参数“cb”传递给slow_calculation函数。如果回调函数被传递，那么它将运行，向基本函数添加修改的特性。</p><p id="3f45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，为了扩展这个概念，我们将为回调编写一个类，并尝试传递它。请参考<a class="ae iu" href="https://github.com/eranandagarwal/callbacks" rel="noopener ugc nofollow" target="_blank"> Github </a>中的<a class="ae iu" href="https://github.com/eranandagarwal/callbacks/blob/master/class_callback.py" rel="noopener ugc nofollow" target="_blank"> class_callback.py </a>获取我在这里粘贴快照的代码。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/c5db53eae42791218c3ecd34ba36faf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*TrucrAOfMCWErZV9ziwthg.png"/></div></figure><p id="2042" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，随着计算，我们要打印“<strong class="ix hj">真棒！！我们在0迭代</strong>”ans等等。此外，问题是感叹号不应该固定为真棒，可以是任何东西。因此，我们有一个show_progress类，它在创建该类时将感叹号作为输入。这是由__init__函数完成的。这些函数被称为邓德函数，它们具有特殊的功能。__init__是类实例化时调用的函数。类似地，还有另一个函数__call__ function，当我们调用这个类的对象时会调用它。因此，当我们调用它时，它接受感叹号和一个num作为输入。</p><p id="0ab6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用<strong class="ix hj"> cb = show_progress("牛逼！!")</strong>，我们得到一个show_progress类的对象，现在可以调用为<strong class="ix hj"> cb(num)，</strong>感谢dunder function __call__。</p><p id="a3d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了在我们的slow_calculation函数中包含这个特性，我们可以将上面的对象传递给它，如下所示:</p><p id="9c76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">慢速_计算(cb) </strong></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/1e55fff1576bb8b95889168d19f63d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*_UdCU9wRNHyUXGe4O7vryA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">类回调的输出</figcaption></figure><p id="7782" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很好，但是现在的要求是我们需要在计算完成之前做一些事情(例如打印“即将开始计算”)，以及在计算完成之后做一些事情(例如打印“完成”)</p><p id="6193" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了增加这些功能，我们以如下方式修改基本函数和回调类:</p><p id="7aeb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先修改slow_calculation函数:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/98121c51478b3c412d1ea82ac6f4d65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*s4Sw5a-9PhV99GfGqOiCYQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">改进的慢速计算功能</figcaption></figure><p id="1b68" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个函数的变化是我们引入了在计算完成之前检查回调函数是否通过。如果通过，它将尝试调用before_call和after_call函数，这些函数将在下面描述的回调类中实现。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kb"><img src="../Images/8c34c0a3191170bc36f6bf6891f5e3cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*kmTVUZw_VXZrA_OPQoF-dQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">带有附加方法的回调类</figcaption></figure><p id="bef0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们的回调类有了两个新方法before_call和after_call，如果回调被传递，它们将出现在slow_calculation函数中。我们将*args和**kwargs作为这些方法的输入，这样，如果我们没有或没有任何数量的参数，我们的代码也不会中断。这些函数简单地打印了snapsort中提到的字符串。</p><p id="ca7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如前所述，我们通过以下方式为此类创建一个对象:</p><p id="02c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> cb = show_progress() </strong></p><p id="cf3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以把这个cb传递给slow_calculation为:<strong class="ix hj"> slow_calculation(cb)。</strong></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kc"><img src="../Images/e6ffabb308789696bed445b56f0195fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*xCxlYzMb0G3vTYvK4_7-EA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">回调的输出</figcaption></figure><p id="4133" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦通过，cb.before_call()和cb.after_call()将在计算前后运行。这个例子向我们展示了回调的威力，它可以修改函数的各个部分，赋予它自定义的功能。</p><p id="5d4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们说，我们需要做的不仅仅是打印计算前后的状态。我们必须打印之前的迭代次数和之后的迭代次数和计算结果。这意味着回调方法应该为before_call方法传递1个参数，为after_call传递2个参数。下面的代码片段:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kd"><img src="../Images/785abb61018cbacb8a6d845f4f4810b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*ru1d4h0ANhuDUOgcpllESA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">不同方法的可变参数回调</figcaption></figure><p id="9773" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们看到show_progress类有两个方法，并带有可变参数。before_call接受一个参数，slow_calculation函数传递迭代次数。类似地，after_call通过迭代传递，并在每次迭代中产生结果。</p><p id="4a9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> cb = show_progress() </strong></p><p id="daeb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">慢速_计算(cb) </strong></p><p id="214e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/647760b1f058f82ee413ff5393ea99e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*DLZnDleMVvRjtRK8iHVY0w.png"/></div></figure><p id="c290" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了在这里添加错误检查，我们的slow_calculation程序可以检查cb，传递的回调函数是否实现了before_call和after_call方法。这可以通过如下修改slow_calculation函数来实现:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kf"><img src="../Images/df50b50883ea8279942535cbb772121a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*6z1bl29znhZgPRmPq5Crnw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">具有hasattrr的慢速计算功能</figcaption></figure><p id="f8cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里使用的hasattr是一种知道某个属性是否是not对象的一部分的方法，如果属性是一部分，则返回True，否则返回False。这确保回调如果没有用before_call和after_call方法实现，将被跳过，并且不会打印任何内容。这确保了事情不会因为回调中的一些错误而中断。</p><p id="9c88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就把我们带到了回调及其不同用法的结尾。我希望你会喜欢回调处理许多定制需求而不修改基本函数的方法。</p><p id="7956" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，总的来说，回调给了我们一种将一个函数传递给另一个函数并在需要时调用它的方法。</p><p id="9089" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">鸣谢:这篇博客不能不感谢杰瑞米·霍华德对回拨的精彩解释。他是Fastai深度学习库的创建者。</p></div></div>    
</body>
</html>