<html>
<head>
<title>Dealing with PyTorch Custom Datasets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理 PyTorch 自定义数据集</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dealing-with-pytorch-custom-datasets-64b6c40fe581?source=collection_archive---------5-----------------------#2020-08-19">https://medium.com/analytics-vidhya/dealing-with-pytorch-custom-datasets-64b6c40fe581?source=collection_archive---------5-----------------------#2020-08-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="893a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将看看如何处理自定义 PyTorch 数据集。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f6f5237335b28a1a054d437b3e33d9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4gaHYsuvpPIYtR_I"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://unsplash.com/@joshuaearle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约书亚·厄尔</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="daf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自定义数据集！！为什么？？</strong></p><p id="872c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为你可以用你渴望的方式塑造它！！！</p><p id="939b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在处理不同的项目时，我们很自然地会开发我们创建自定义数据集的方式。</p><p id="5dc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PyTorch 上有一些官方的自定义数据集示例，比如这里的<a class="ae jt" href="https://pytorch.org/tutorials/beginner/data_loading_tutorial.html" rel="noopener ugc nofollow" target="_blank"/>，但是对于初学者来说似乎有点晦涩难懂(就像我当时一样)。我们将要讨论的题目如下。</p><ol class=""><li id="eb51" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><strong class="ih hj">自定义数据集基础。</strong></li><li id="7fc7" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><strong class="ih hj">使用 Torchvision 变换。</strong></li><li id="8641" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><strong class="ih hj">对付熊猫(read_csv) </strong></li><li id="d417" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><strong class="ih hj">将类嵌入到文件名中</strong></li><li id="b620" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><strong class="ih hj">使用数据加载器</strong></li></ol><h1 id="3d93" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">1.自定义数据集基础。</h1><p id="d052" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">数据集必须包含以下函数，供 DataLoader 稍后使用。</p><ul class=""><li id="2e0e" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ll ka kb kc bi translated">函数，初始逻辑在这里发生，如读取 CSV、分配转换、过滤数据等。,</li><li id="257a" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ll ka kb kc bi translated"><code class="du lm ln lo lp b">__getitem__()</code>返回数据和标签。</li><li id="eb6e" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ll ka kb kc bi translated"><code class="du lm ln lo lp b">__len__()</code>返回数据集的样本数。</li></ul><p id="d94e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，第一部分是创建一个数据集类:</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="c011" class="lu kj hi lp b fi lv lw l lx ly">from torch.utils.data.dataset import Dataset<br/><br/>class MyCustomDataset(Dataset):<br/>    def __init__(self, ...):<br/>        # stuff<br/>        <br/>    def __getitem__(self, index):<br/>        # stuff<br/>        return (img, label)<br/><br/>    def __len__(self):<br/>        return count # of how many examples(images?) you have</span></pre><p id="008a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，<code class="du lm ln lo lp b">MyCustomDataset</code>返回两件事，一个图像，和它的标签。但这并不意味着<code class="du lm ln lo lp b">__getitem__()</code>只限于归还那些。</p><p id="54f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong></p><ul class=""><li id="42f6" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ll ka kb kc bi translated"><code class="du lm ln lo lp b">__getitem()</code>返回单个数据点的特定类型(如张量)，否则，在加载数据时会出现错误，</li></ul><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="ce65" class="lu kj hi lp b fi lv lw l lx ly">TypeError: batch must contain tensors, numbers, dicts or lists; found &lt;class 'PIL.PngImagePlugin.PngImageFile'&gt;</span></pre><h1 id="182e" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak"> 2。使用火炬视觉变换:</strong></h1><p id="3bcf" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">在大多数例子中，我们将在<code class="du lm ln lo lp b">__init__()</code>中看到<code class="du lm ln lo lp b">transforms = None</code>，它将为我们的数据/图像应用 Torchvision 变换。你可以在这里找到所有变换<a class="ae jt" href="https://pytorch.org/docs/0.2.0/torchvision/transforms.html" rel="noopener ugc nofollow" target="_blank">的列表。</a></p><p id="246d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转换最常见的用法是:</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="2461" class="lu kj hi lp b fi lv lw l lx ly">from torch.utils.data.dataset import Dataset<br/>from torchvision import transforms<br/><br/>class MyCustomDataset(Dataset):<br/>    def __init__(self, ..., transforms=None):<br/>        # stuff<br/>        ...<br/>        self.transforms = transforms<br/>        <br/>    def __getitem__(self, index):<br/>        # stuff<br/>        ...<br/>        data = # Some data read from a file or image<br/>        if self.transforms is not None:<br/>            data = self.transforms(data)<br/>        # If the transform variable is not empty<br/>        # then it applies the operations in the transforms with the order that it is created.<br/>        return (img, label)<br/><br/>    def __len__(self):<br/>        return count # of how many data(images?) you have<br/>        <br/>if __name__ == '__main__':<br/>    # Define transforms (1)<br/>    transformations = transforms.Compose([transforms.CenterCrop(100), transforms.ToTensor()])<br/>    # Call the dataset<br/>    custom_dataset = MyCustomDataset(..., transformations)</span></pre><p id="0c13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在数据集类中定义转换。像这样:</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="5590" class="lu kj hi lp b fi lv lw l lx ly">from torch.utils.data.dataset import Dataset<br/>from torchvision import transforms<br/><br/>class MyCustomDataset(Dataset):<br/>    def __init__(self, ...):<br/>        # stuff<br/>        ...<br/>        # (2) One way to do it is define transforms individually<br/>        self.center_crop = transforms.CenterCrop(100)<br/>        self.to_tensor = transforms.ToTensor()<br/>        <br/>        # (3) Or you can still compose them like <br/>        self.transformations = \<br/>            transforms.Compose([transforms.CenterCrop(100),<br/>                                transforms.ToTensor()])<br/>        <br/>    def __getitem__(self, index):<br/>        # stuff<br/>        ...<br/>        data = # Some data read from a file or image<br/>        <br/># When you call transform for the second time it calls __call__()               and applies the transform </span><span id="393e" class="lu kj hi lp b fi lz lw l lx ly">        data = self.center_crop(data)  # (2)<br/>        data = self.to_tensor(data)  # (2)<br/>        <br/>        # Or you can call the composed version<br/>        data = self.transformations(data)  # (3)<br/>        <br/>     # Note that you only need one of the implementations,(2) or (3)<br/>        return (img, label)<br/><br/>    def __len__(self):<br/>        return count # of how many data(images?) you have<br/>        <br/>if __name__ == '__main__':<br/>    # Call the dataset<br/>    custom_dataset = MyCustomDataset(...)</span></pre><h1 id="09df" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak"> 3。对付熊猫(read_csv): </strong></h1><p id="76b9" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">现在我们的数据集包含一个文件名、标签和一个额外的操作指示器，我们将对图像执行一些额外的操作。</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="0007" class="lu kj hi lp b fi lv lw l lx ly">+-----------+-------+-----------------+<br/>| File Name | Label | Extra Operation |<br/>+-----------+-------+-----------------+<br/>| tr_0.png  |     5 | TRUE            |<br/>| tr_1.png  |     0 | FALSE           |<br/>| tr_1.png  |     4 | FALSE           |<br/>+-----------+-------+-----------------+</span></pre><p id="b703" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建从该 CSV 读取图像位置的自定义数据集。</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="584f" class="lu kj hi lp b fi lv lw l lx ly">class CustomDatasetFromImages(Dataset):<br/>    def __init__(self, csv_path):<br/>        """<br/>        Args:<br/>            csv_path (string): path to csv file<br/>            img_path (string): path to the folder where images are<br/>            transform: pytorch transforms for transforms and tensor conversion<br/>        """</span><span id="1b9f" class="lu kj hi lp b fi lz lw l lx ly"># Transforms<br/>        self.to_tensor = transforms.ToTensor()<br/>        # Read the csv file<br/>        self.data_info = pd.read_csv(csv_path, header=None)<br/>        # First column contains the image paths<br/>        self.image_arr = np.asarray(self.data_info.iloc[:, 0])<br/>        # Second column is the labels<br/>        self.label_arr = np.asarray(self.data_info.iloc[:, 1])<br/>        # Third column is for an operation indicator<br/>        self.operation_arr = np.asarray(self.data_info.iloc[:, 2])<br/>        # Calculate len<br/>        self.data_len = len(self.data_info.index)<br/><br/>    def __getitem__(self, index):<br/>        # Get image name from the pandas df<br/>        single_image_name = self.image_arr[index]<br/>        # Open image<br/>        img_as_img = Image.open(single_image_name)<br/><br/>        # Check if there is an operation<br/>        some_operation = self.operation_arr[index]</span><span id="e5ff" class="lu kj hi lp b fi lz lw l lx ly">        # If there is an operation<br/>        if some_operation:<br/>            # Do some operation on image<br/>            # ...<br/>            # ...<br/>            pass</span><span id="098b" class="lu kj hi lp b fi lz lw l lx ly">        # Transform image to tensor<br/>        img_as_tensor = self.to_tensor(img_as_img)<br/><br/>        # Get label of the image based on the cropped pandas column</span><span id="4d16" class="lu kj hi lp b fi lz lw l lx ly">        single_image_label = self.label_arr[index]<br/><br/>        return (img_as_tensor, single_image_label)<br/><br/>    def __len__(self):<br/>        return self.data_len<br/><br/>if __name__ == "__main__":<br/>    # Call dataset<br/>    custom_mnist_from_images =  \<br/>        CustomDatasetFromImages('../data/mnist_labels.csv')</span></pre><p id="487a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个从 CSV 读取图像的例子，其中每个像素的值都列在列中(例如，<strong class="ih hj"> MNIST </strong>)。<code class="du lm ln lo lp b">__getitem__()</code>中逻辑的一点变化。最后，我们只是将图像作为张量和它们的标签返回。数据看起来像这样，</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="8f00" class="lu kj hi lp b fi lv lw l lx ly">+-------+---------+---------+-----+<br/>| Label | pixel_1 | pixel_2 | ... |<br/>+-------+---------+---------+-----+<br/>|     1 |      50 |      99 | ... |<br/>|     0 |      21 |     223 | ... |<br/>|     9 |      44 |     112 |     |<br/>+-------+---------+---------+-----+</span></pre><p id="8a23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，代码看起来像这样:</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="46f1" class="lu kj hi lp b fi lv lw l lx ly">class CustomDatasetFromCSV(Dataset):<br/>    def __init__(self, csv_path, height, width, transforms=None):<br/>        """<br/>        Args:<br/>            csv_path (string): path to csv file<br/>            height (int): image height<br/>            width (int): image width<br/>            transform: pytorch transforms for transforms and tensor conversion<br/>        """</span><span id="1d67" class="lu kj hi lp b fi lz lw l lx ly">        self.data = pd.read_csv(csv_path)<br/>        self.labels = np.asarray(self.data.iloc[:, 0])<br/>        self.height = height<br/>        self.width = width<br/>        self.transforms = transform<br/><br/>    def __getitem__(self, index):<br/>        single_image_label = self.labels[index]</span><span id="744d" class="lu kj hi lp b fi lz lw l lx ly">        # Read each 784 pixels and reshape the 1D array ([784]) to 2D array ([28,28]) <br/>        img_as_np = np.asarray(self.data.iloc[index][1:]).reshape(28,28).astype('uint8')</span><span id="1671" class="lu kj hi lp b fi lz lw l lx ly">	# Convert image from numpy array to PIL image, mode 'L' is for grayscale<br/>        img_as_img = Image.fromarray(img_as_np)<br/>        img_as_img = img_as_img.convert('L')</span><span id="b9b9" class="lu kj hi lp b fi lz lw l lx ly">        # Transform image to tensor<br/>        if self.transforms is not None:<br/>            img_as_tensor = self.transforms(img_as_img)</span><span id="4a1f" class="lu kj hi lp b fi lz lw l lx ly">        # Return image and the label<br/>        return (img_as_tensor, single_image_label)<br/><br/>    def __len__(self):<br/>        return len(self.data.index)<br/>        <br/><br/>if __name__ == "__main__":<br/>    transformations = transforms.Compose([transforms.ToTensor()])<br/>    custom_mnist_from_csv = \<br/>        CustomDatasetFromCSV('../data/mnist_in_csv.csv', 28, 28, transformations)</span></pre><h1 id="25c6" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak"> 4。将类名嵌入为文件名:</strong></h1><p id="f8c7" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">使用图像的文件夹名作为文件名:</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="6471" class="lu kj hi lp b fi lv lw l lx ly">class CustomDatasetFromFile(Dataset):<br/>    def __init__(self, folder_path):<br/>        """<br/>        A dataset example where the class is embedded in the file names<br/>        This data example also does not use any torch transforms<br/><br/>        Args:<br/>            folder_path (string): path to image folder<br/>        """</span><span id="e9e6" class="lu kj hi lp b fi lz lw l lx ly">        # Get image list<br/>        self.image_list = glob.glob(folder_path+'*')</span><span id="47f9" class="lu kj hi lp b fi lz lw l lx ly">        # Calculate len<br/>        self.data_len = len(self.image_list)<br/><br/>    def __getitem__(self, index):<br/>        # Get image name from the pandas df<br/>        single_image_path = self.image_list[index]</span><span id="995e" class="lu kj hi lp b fi lz lw l lx ly">        # Open image<br/>        im_as_im = Image.open(single_image_path)<br/><br/>        # Do some operations on image<br/>        # Convert to numpy, dim = 28x28<br/>        im_as_np = np.asarray(im_as_im)/255</span><span id="1ef6" class="lu kj hi lp b fi lz lw l lx ly">        # Add channel dimension, dim = 1x28x28<br/>        # Note: You do not need to do this if you are reading RGB images<br/>        # or i there is already channel dimension</span><span id="171d" class="lu kj hi lp b fi lz lw l lx ly">        im_as_np = np.expand_dims(im_as_np, 0)</span><span id="56e7" class="lu kj hi lp b fi lz lw l lx ly">        # Some preprocessing operations on numpy array<br/>        # ...<br/>        # ...<br/>        # ...<br/><br/>        # Transform image to tensor, change data type<br/>        im_as_ten = torch.from_numpy(im_as_np).float()<br/><br/>        # Get label(class) of the image based on the file name<br/>        class_indicator_location = single_image_path.rfind('_c')</span><span id="34b7" class="lu kj hi lp b fi lz lw l lx ly">        label = int(single_image_path[class_indicator_location+2:class_indicator_location+3])</span><span id="bc46" class="lu kj hi lp b fi lz lw l lx ly">        return (im_as_ten, label)<br/><br/>    def __len__(self):<br/>        return self.data_len</span></pre><h1 id="a51f" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak"> 5。使用数据加载器:</strong></h1><p id="9eda" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">PyTorch 数据加载器将调用<code class="du lm ln lo lp b">__getitem__()</code>并将它们打包成一个批处理。但是从技术上来说，我们不会使用数据加载器，一次调用一个<code class="du lm ln lo lp b">__getitem__()</code>，并将数据输入模型。现在，我们可以像这样调用数据加载器:</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="dced" class="lu kj hi lp b fi lv lw l lx ly">...<br/>if __name__ == "__main__":<br/>    # Define transforms<br/>    transformations = transforms.Compose([transforms.ToTensor()])</span><span id="d4f9" class="lu kj hi lp b fi lz lw l lx ly">    # Define custom dataset<br/>    custom_mnist_from_csv = \<br/>        CustomDatasetFromCSV('../data/mnist_in_csv.csv',<br/>                             28, 28,<br/>                             transformations)</span><span id="2129" class="lu kj hi lp b fi lz lw l lx ly">    # Define data loader<br/>    mn_dataset_loader = torch.utils.data.DataLoader(dataset=custom_mnist_from_csv,<br/>                                                    batch_size=10,<br/>                                                    shuffle=False)<br/>    <br/>    for images, labels in mn_dataset_loader:<br/>        # Feed the data to the model</span></pre><p id="a0f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，batch_size 决定了在一个批处理中将包装多少个单独的数据点。数据加载器将返回一个形状张量(批次—深度—高度—宽度)</p><pre class="je jf jg jh fd lq lp lr ls aw lt bi"><span id="9a35" class="lu kj hi lp b fi lv lw l lx ly">tensor.shape(10x1x28x28) # if batch_size =10 (For MNIST Data). </span></pre><p id="606c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！！！</p><p id="438b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自定义数据集！！别担心！！</p><p id="4479" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考:</strong></p><ul class=""><li id="97bc" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ll ka kb kc bi translated"><a class="ae jt" href="https://github.com/utkuozbulak/pytorch-custom-dataset-examples#a-custom-custom-custom-dataset" rel="noopener ugc nofollow" target="_blank">https://github . com/utkuozbulak/py torch-custom-dataset-examples # a-custom-custom-custom-dataset</a></li></ul></div></div>    
</body>
</html>