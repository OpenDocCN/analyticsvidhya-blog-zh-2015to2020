<html>
<head>
<title>Modern C++: Strings and string_view</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++:字符串和string_view</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/modern-c-strings-and-string-view-aee48f09fa11?source=collection_archive---------6-----------------------#2020-08-28">https://medium.com/analytics-vidhya/modern-c-strings-and-string-view-aee48f09fa11?source=collection_archive---------6-----------------------#2020-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="98cb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">c样式字符串</h1><p id="bbeb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">除了与C库接口时，应该避免C风格的字符串。c #字符串库函数不提供边界检查和内存分配支持。它们被表示为字符数组。字符串的最后一个字符是空字符<code class="du kb kc kd ke b">\0</code>，因此使用该字符串的代码知道它在哪里结束。字符串所需的空间总是比可读字符数多1。</p><h1 id="b76b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">字符串文字</h1><p id="f936" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">用引号括起来的字符串是字符串文字。它们存储在存储器的只读部分。因为它们存储在只读部分，试图修改字符串文字是<em class="kf">未定义的行为</em>。示例:</p><pre class="kg kh ki kj fd kk ke kl km aw kn bi"><span id="9c33" class="ko ig hi ke b fi kp kq l kr ks">char *str = "world";<br/>str[0] = 'y'; //undefined behavior</span></pre><p id="0294" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">如果代码遵循标准，并将字符串赋值给<code class="du kb kc kd ke b">const char*</code>，编译器将捕捉修改字符串的尝试:</p><pre class="kg kh ki kj fd kk ke kl km aw kn bi"><span id="b488" class="ko ig hi ke b fi kp kq l kr ks">const char * str = "world";<br/>str[0] = 'k'; //compiler will flag this as error.</span></pre><p id="d411" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">要改变字符串，将它们分配给字符数组。在此示例中，编译器创建了一个足够大的数组来保存字符串，并将字符串复制到该数组中。文本不放在只读内存中。</p><pre class="kg kh ki kj fd kk ke kl km aw kn bi"><span id="6b73" class="ko ig hi ke b fi kp kq l kr ks">char str[] = "hello world";<br/>str[0] = 'y';</span></pre><h1 id="55c8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">原始字符串文字</h1><p id="bdf7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">C++提供了原始的字符串文字，这些文字跨越多行代码，不需要对嵌入的双引号进行转义，也不用任何特殊的逻辑来处理转义序列。示例:</p><pre class="kg kh ki kj fd kk ke kl km aw kn bi"><span id="7ed7" class="ko ig hi ke b fi kp kq l kr ks">const char* str = R"(Brave New World)";<br/>const char* str = R"(Line1: Brave <br/>Line2: New World)";</span></pre><p id="911b" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">要在原始字符串中使用<code class="du kb kc kd ke b">)</code>或<code class="du kb kc kd ke b">(</code>，请使用如下所示的唯一分隔符序列:</p><pre class="kg kh ki kj fd kk ke kl km aw kn bi"><span id="b86b" class="ko ig hi ke b fi kp kq l kr ks">const char* str = R"-(Embedded ) parens)-";</span></pre><h1 id="fcb3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">标准::字符串</h1><p id="3d6d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du kb kc kd ke b">string</code>将<code class="du kb kc kd ke b">+</code>运算符重载以表示串联。于是下面产生了<code class="du kb kc kd ke b">hello world</code>:</p><pre class="kg kh ki kj fd kk ke kl km aw kn bi"><span id="e723" class="ko ig hi ke b fi kp kq l kr ks">string one("hello");<br/>string two("world");<br/>string final;<br/>final = one + " " + two;</span></pre><p id="9be4" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">此外，<code class="du kb kc kd ke b">==</code>、<code class="du kb kc kd ke b">!=</code>、<code class="du kb kc kd ke b">&lt;</code>等都是重载的，所以它们使用实际的字符串字符。为了兼容，可以调用<code class="du kb kc kd ke b">c_str()</code>来返回一个C风格的字符串，但是这应该是最后一个操作，不应该在分配了<code class="du kb kc kd ke b">string</code>的堆栈中完成。因为字符串被推断为<code class="du kb kc kd ke b">const char*</code>，所以可以使用<code class="du kb kc kd ke b">s</code>将字符串解释为<code class="du kb kc kd ke b">std::string</code>:</p><pre class="kg kh ki kj fd kk ke kl km aw kn bi"><span id="bc16" class="ko ig hi ke b fi kp kq l kr ks">auto myStr = "hello brave world"s;</span></pre><h1 id="c5f6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">转换策略</h1><p id="d5da" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du kb kc kd ke b">std</code>名称空间有几个将数字转换成字符串的函数。例子:<code class="du kb kc kd ke b">string to_string(int vaL)</code>和<code class="du kb kc kd ke b">string to_string(double val)</code>。要将字符串转换为数字，请使用<code class="du kb kc kd ke b">int stoi(const string&amp; s, size_t *idx = 0, int base=10)</code>等函数。示例:</p><pre class="kg kh ki kj fd kk ke kl km aw kn bi"><span id="dabf" class="ko ig hi ke b fi kp kq l kr ks">const string toConvert = " 123ABC";<br/>size_t index = 0;<br/>int value = stoi(toConvert,&amp;index); //index will be the index of 'A'.</span></pre><h1 id="c426" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">标准::字符串_视图</h1><p id="83ed" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一个<code class="du kb kc kd ke b">string_view</code>是只读的<code class="du kb kc kd ke b">string</code>，但是没有一个<code class="du kb kc kd ke b">const string&amp;</code>的开销。它不复制字符串。要将一个<code class="du kb kc kd ke b">string_view</code>和一个字符串连接起来，使用<code class="du kb kc kd ke b">data()</code>成员函数:</p><pre class="kg kh ki kj fd kk ke kl km aw kn bi"><span id="acc2" class="ko ig hi ke b fi kp kq l kr ks">string str = "Hard";<br/>string_view sview = " Rock";<br/>auto result = str + sview.data();</span></pre><p id="4c30" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">要将<code class="du kb kc kd ke b">string_view</code>传递到函数中，请按值传递它们。对于<code class="du kb kc kd ke b">string_view</code>文字，使用“sv”:</p><pre class="kg kh ki kj fd kk ke kl km aw kn bi"><span id="5653" class="ko ig hi ke b fi kp kq l kr ks">auto sview = "Sample string view"sv;</span><span id="789b" class="ko ig hi ke b fi ky kq l kr ks">string_view extractLastDelimitedElement(string_view sv, char delimiter)<br/>{<br/>    return sv.substr(sv.rfind(delimiter));<br/>}</span></pre><h1 id="9f8a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考资料:</h1><p id="94b3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">m .格雷瓜尔(2018)。<em class="kf">专业C++ </em>。印第安纳州，约翰·威利的儿子们。</p><div class="kz la ez fb lb lc"><a href="https://codingadventures1.blogspot.com/2020/02/c-strings-and-stringview.html" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab dw"><div class="le ab lf cl cj lg"><h2 class="bd hj fi z dy lh ea eb li ed ef hh bi translated">C++字符串和string_view</h2><div class="lj l"><h3 class="bd b fi z dy lh ea eb li ed ef dx translated">除了与C库接口时，应该避免C风格的字符串。c #字符串库函数不提供…</h3></div><div class="lk l"><p class="bd b fp z dy lh ea eb li ed ef dx translated">codingadventures1.blogspot.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq lr lc"/></div></div></a></div></div></div>    
</body>
</html>