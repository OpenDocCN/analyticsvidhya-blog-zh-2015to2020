<html>
<head>
<title>Asynchronous Cloud Functions in GCP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP的异步云功能</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/asynchronous-cloud-functions-in-gcp-python-307130ce6c2b?source=collection_archive---------9-----------------------#2020-05-27">https://medium.com/analytics-vidhya/asynchronous-cloud-functions-in-gcp-python-307130ce6c2b?source=collection_archive---------9-----------------------#2020-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/14326bdbed38f74e3f73d982b28b5ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJPdoFU0QHWv8uUNfMnrTA.jpeg"/></div></div></figure><p id="7428" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文讨论如何使用云函数以异步方式跟踪长时间运行的作业，重点是可跟踪的和有状态的长时间运行的操作。在服务请求的生命周期中，调用者使用所需的参数发出请求，然后请求服务执行一些工作。</p><p id="333e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在同步工作空间中，调用者等待API，直到工作完成，并且它可以直接由单独的云函数处理。<em class="jo">在我们的例子中，API是http触发的云函数</em>。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jp"><img src="../Images/b21afaf05127be990913eb05838f1834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNJn0_Wi4EvIZi-YTuxtSA.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">同步请求/响应</figcaption></figure><p id="db52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在异步工作区中，调用者不会等待任务完成。它通过PubSub通知将基本参数传递给worker(另一个云函数或Kubernetes引擎)，但是它需要能够<em class="jo">查询请求</em>的完成情况。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/e3a4ba62c5142ae35aea091fa83b67a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1R1d18Q_gwxSJhyKD7qog.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">异步请求/响应</figcaption></figure><p id="8a3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦API云函数被http触发，它在nosql数据库(firestore)中创建一个作业状态为“已创建”的有状态字典后，将字典中的参数作为pubsub消息在指定的<em class="jo"> topic_name </em>中发布。firestore中存储的信息将用于跟踪作业的状态，因为“已创建”、“正在运行”和“已完成”将是作业状态的三个离散值。一旦工人使用来自pubsub消息的所需参数接受作业，它就将firestore中的作业状态更改为“正在运行”,并执行任务。在这个时间空间中，如果API询问作业的状态，它将返回“正在运行”。当工作完成时，工人在firestore中将作业的状态更改为“已完成”,之后，如果API检查状态，它将知道作业已完成，并将相应地采取行动以获取结果。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/bd79afb54d13951f49ac2e0c314521db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcIrdoeIOiRbr-850Wnvdg.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">异步云功能架构</figcaption></figure><p id="03dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们深入了解异步云功能的整个架构是如何工作的。</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="4a46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo"> i)set_task </em>():它是云函数http触发API的入口点，POST请求创建作业，并使用<em class="jo"> add_job()将作业状态字典添加到firestore。</em>http触发api的相应部署命令为:</p><pre class="jq jr js jt fd kc kd ke kf aw kg bi"><span id="91ef" class="kh ki hi kd b fi kj kk l kl km">gcloud functions deploy set_task --runtime python37 --trigger-http --allow-unauthenticated</span></pre><p id="b3c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了获得http触发的云功能的URL，我们需要在终端中运行以下命令:</p><pre class="jq jr js jt fd kc kd ke kf aw kg bi"><span id="5b7f" class="kh ki hi kd b fi kj kk l kl km">export URL=$(gcloud functions describe set_task --format='value(httpsTrigger.url)')</span></pre><p id="a8f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">调用基于函数的API来创建一个带有简单任务的作业。我们的任务有一个字段<code class="du kn ko kp kd b">path</code>，它指向GCP的路径，文件存储在该路径上，要对其执行操作:</p><pre class="jq jr js jt fd kc kd ke kf aw kg bi"><span id="da58" class="kh ki hi kd b fi kj kk l kl km">JOBID=$(curl -s --header "Content-Type: application/json" --request POST --data '{"path":"gs://manas_input/sample.jpg"}' $URL )</span></pre><p id="5987" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ii) <em class="jo"> add_job(): </em>该函数处理firestore集合中作业文档的创建，并将<em class="jo">作业id </em>和<em class="jo">路径</em>属性传递给pubsub消息。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/ef1af405d2ad7fd0452edbbb7c728765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*258cKYsKqZYrWfrrX-wZIQ.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">在firestore中创建工作文档</figcaption></figure><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="70c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">iii) <em class="jo"> worker_task() </em>:这是一个worker Cloud函数，由部署时指定的pubsub主题触发。在工人云函数的要点中，我包含了一个50秒的休眠时间，它可以被删除，并且可以包含在GCP路径上要完成的实际工作的代码。该函数在执行实际工作之前将状态设置为“正在运行”。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/24abca32028b6488c6ceeb3f8e0456d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzkFSu8kHXCezleR4DRYlw.png"/></div></div></figure><p id="033e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任务完成后，作业文档的状态更新为已完成。为了部署上述云功能，我们必须运行以下命令:</p><pre class="jq jr js jt fd kc kd ke kf aw kg bi"><span id="7af5" class="kh ki hi kd b fi kj kk l kl km">gcloud pubsub topics create jobs</span><span id="2756" class="kh ki hi kd b fi ks kk l kl km">gcloud functions deploy process_task --runtime python37 --trigger-topic jobs --entry-point worker_task</span></pre><p id="d837" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">iv) <em class="jo"> get_job(): </em>该函数处理函数调用方API的get请求的实现，该API返回作业的状态。</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="fe22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使用GET request获得作业的状态，我们需要运行以下命令:</p><pre class="jq jr js jt fd kc kd ke kf aw kg bi"><span id="b709" class="kh ki hi kd b fi kj kk l kl km">curl -s $URL/$JOBID</span></pre><p id="8712" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就完成了关于如何异步使用云函数来完成一个特定的长时间运行的任务的教程。</p><p id="1556" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">学分:<a class="ae kt" href="https://cloud.google.com/community/tutorials/cloud-functions-async" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/community/tutorials/cloud-functions-async</a></p></div></div>    
</body>
</html>