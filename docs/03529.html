<html>
<head>
<title>Image Classification On Fashion-MNIST dataset Using PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于PyTorch的时尚MNIST数据集上的图像分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/image-classification-with-fashion-mnist-dataset-and-pytorch-719a305d7374?source=collection_archive---------8-----------------------#2020-02-06">https://medium.com/analytics-vidhya/image-classification-with-fashion-mnist-dataset-and-pytorch-719a305d7374?source=collection_archive---------8-----------------------#2020-02-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d71d03500ff1d3b28eb7b10ccbd97de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZLLZPo4kiH-cBzUYEukEVg.png"/></div></div></figure><p id="caa6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PyTorch是由脸书人工智能研究小组开发的著名的Python开源机器学习库。PyTorch相信动态图，不像TensorFlow创建静态图。PyTorch支持CPU和GPU计算。</p><p id="ced5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们将看到机器学习模型的“HELLO WORLD ”,其中有一个非常著名的数据集可用于图像分类，即<em class="jo"> Fashion_MNIST数据集</em>,其中我们将针对给定的图像，判断它是一件衣服(区分两性的各种上装和下装)、鞋类还是一个包。从而确定它属于哪一类的概率。</p><p id="4ec3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">关于数据集:</strong></p><p id="307e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个模型，我将使用由Zalando的文章图像组成的时尚MNIST数据集，这是一组28x28灰度的衣服图像，是MNIST数据集的替代物。在这里，你将学会建立你的神经网络。</p><p id="ec66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下图显示了您将在本文中了解的数据集。</p><h1 id="22c5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">时尚MNIST数据集</h1><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es kn"><img src="../Images/f45264553af6a5d486797fb27c88120a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*bXUcAjzfQ7Ggqec-9KI5PQ.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">时尚MNIST数据集</figcaption></figure><p id="7b3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">时尚MNIST数据集由70，000幅灰度图像和10个类别组成。你可以在这里看到:【https://github.com/zalandoresearch/fashion-mnist#labels】T4</p><p id="1890" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，请遵循以下步骤:</p><ol class=""><li id="be35" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated"><strong class="is hj">通过torchvision加载数据集。</strong></li></ol><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="a17f" class="ll jq hi lh b fi lm ln l lo lp">import torch<br/>from torchvision import datasets, transforms<br/>import helper</span><span id="7571" class="ll jq hi lh b fi lq ln l lo lp"># Define a transform to normalize the data<br/>transform = transforms.Compose([transforms.ToTensor(),<br/>                                #transforms.Lambda(lambda x: x.repeat(3,1,1)),<br/>                                transforms.Normalize((0.5, ), (0.5,))])<br/># Download and load the training data<br/>trainset = datasets.FashionMNIST('~/.pytorch/F_MNIST_data/', download=True, train=True, transform=transform)<br/>trainloader = torch.utils.data.DataLoader(trainset, batch_size=64, shuffle=True)</span><span id="75ad" class="ll jq hi lh b fi lq ln l lo lp"># Download and load the test data<br/>testset = datasets.FashionMNIST('~/.pytorch/F_MNIST_data/', download=True, train=False, transform=transform)<br/>testloader = torch.utils.data.DataLoader(testset, batch_size=64, shuffle=True)</span></pre><p id="f991" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要加载图像，</p><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="84ba" class="ll jq hi lh b fi lm ln l lo lp">image, label = next(iter(trainloader))<br/>helper.imshow(image[0,:]);</span></pre><p id="b738" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们可以看到来自数据集的图像。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/2c633cb34b711b5b3a58e0a1d80bdb9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/1*XqlZl1ZtBsZ1VMSkx-46eA.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">数据集中单件服装的图像</figcaption></figure><p id="16b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。</strong> <strong class="is hj">构建网络</strong></p><p id="9410" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与MNIST一样，每个图像是28×28，总共是784个像素，并且有10个类别。您应该包括至少一个隐藏层。我们建议您对层使用ReLU激活，并从正向过程返回logits或log-softmax。添加多少层以及这些层的大小由您决定。</p><p id="496e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用<strong class="is hj">激活功能(Relu，sigmoid等)</strong>来限制输出信号，并将输出值限制在某个有限值</p><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="8567" class="ll jq hi lh b fi lm ln l lo lp">from torch import nn, optim<br/>import torch.nn.functional as F</span><span id="05b0" class="ll jq hi lh b fi lq ln l lo lp">#Nwtwork Architecture:</span><span id="9719" class="ll jq hi lh b fi lq ln l lo lp">class Classifier(nn.Module):<br/>    def __init__(self):<br/>        super().__init__()<br/>        self.fc1 =  nn.Linear(784,256)<br/>        self.fc2 =  nn.Linear(256,128)<br/>        self.fc3 =  nn.Linear(128,64)<br/>        self.fc4 =  nn.Linear(64,10)<br/>        <br/>    def forward(self,x):<br/>        x = x.view(x.shape[0],-1) ## flattening the Tensor<br/>        <br/>        x = F.relu(self.fc1(x))<br/>        x = F.relu(self.fc2(x))<br/>        x = F.relu(self.fc3(x))<br/>        x = F.log_softmax(self.fc4(x), dim = 1)<br/>        <br/>        return x</span></pre><p id="f3af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。</strong> <strong class="is hj">训练模型</strong></p><p id="652d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一步的模型训练中，我们将像nn一样定义准则(<em class="jo">)。交叉熵或nn。NLLLoss </em>)和优化器<em class="jo"> (optim。</em>亚当只喜欢梯度下降以尽量减少损失)。接下来，我们将通过网络向前传递，以获取logits并计算损耗。此外，使用<strong class="is hj"><em class="jo"/></strong><em class="jo">loss . backward()</em>在网络中执行反向传递，以计算梯度并使用优化器更新权重。</p><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="2ac0" class="ll jq hi lh b fi lm ln l lo lp">#Defining the criterion and optimizer<br/>model = Classifier()<br/>criterion =  nn.NLLLoss()<br/>optimizer = optim.Adam(model.parameters(), lr = 0.005)</span><span id="2dcd" class="ll jq hi lh b fi lq ln l lo lp">#Network Training<br/>epochs = 5</span><span id="5f10" class="ll jq hi lh b fi lq ln l lo lp">for e in range(epochs):<br/>    running_loss=0<br/>    for images, labels in trainloader:<br/>        logps = model(images)<br/>        loss = criterion(logps, labels)<br/>        <br/>        optimizer.zero_grad()<br/>        loss.backward()<br/>        optimizer.step()<br/>        <br/>        running_loss += loss.item()<br/>        <br/>    else:<br/>        <br/>        print(f"Training loss:{running_loss}")</span></pre><p id="e84d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.<strong class="is hj">绘制图像和概率</strong></p><p id="a92a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将使用softmax和plot计算概率。</p><p id="4939" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它会给我们图像所属类别的概率</p><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="0176" class="ll jq hi lh b fi lm ln l lo lp">%matplotlib inline<br/>%config InlineBackend.figure_format = 'retina'</span><span id="e6f3" class="ll jq hi lh b fi lq ln l lo lp">import helper <strong class="lh hj">#user define for library classification and label</strong></span><span id="de1a" class="ll jq hi lh b fi lq ln l lo lp">dataiter = iter(testloader)<br/>images,lables = dataiter.next()<br/>img =  images[2]</span><span id="c6d6" class="ll jq hi lh b fi lq ln l lo lp">ps =  torch.exp(model(img)) #Class probabilities (softmax)</span><span id="66c5" class="ll jq hi lh b fi lq ln l lo lp">#Image and probabilities<br/>helper.view_classify(img,ps,version = 'Fashion')</span></pre><p id="17ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里你已经学会了你的一个机器学习模型。！！</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/f9a18338f03ee35b743441dc6d8d66d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*6s98UDqf62NDn03ejsBfkw.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">分类服装的图像。</figcaption></figure><p id="efe9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我知道这篇文章中有很多技术性的东西，可能会让人望而生畏，或者超出了任何刚刚涉足机器学习的人的范围。我将在未来连续发表文章详细解释其中的许多问题。</p><p id="8add" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要了解更多关于激活函数，优化技术，和损失函数<a class="ae kw" rel="noopener" href="/analytics-vidhya/activation-functions-optimization-techniques-and-loss-functions-75a0eea0bc31"> <em class="jo">点击这里</em> </a></p><p id="5960" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这有所帮助:)</p><p id="34f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢我的帖子，请关注。</p><p id="237c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如需更多帮助，请查看我的Github:-<a class="ae kw" href="https://github.com/Afaf-Athar/FashionMNIST/blob/master/Fashion-%20MNIST.ipynb" rel="noopener ugc nofollow" target="_blank">https://Github . com/Afaf-at har/Fashion mnist/blob/master/Fashion-% 20 mnist . ipynb</a></p></div></div>    
</body>
</html>