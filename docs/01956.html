<html>
<head>
<title>Activation functions used in deep learning, are they differentiable or not?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习用的激活函数，可微不可微？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/activation-functions-used-in-deep-learning-are-they-differentiable-or-not-e1a94e2c67ef?source=collection_archive---------15-----------------------#2019-11-23">https://medium.com/analytics-vidhya/activation-functions-used-in-deep-learning-are-they-differentiable-or-not-e1a94e2c67ef?source=collection_archive---------15-----------------------#2019-11-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="99d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多米尼克等待着</p><h1 id="9c4b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">介绍</h1><p id="8dc5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在最近的一次<a class="ae jd" href="https://dwaithe.github.io/presentations/2017April_back_propagationWaitheDv2.pdf" rel="noopener ugc nofollow" target="_blank">演讲中</a>，我给出了关于神经网络优化的反向传播算法，关于某些激活函数的可微性问题出现了。反向传播算法要求所涉及的所有函数都是可微的，然而一些最常用的激活函数(例如ReLU)实际上在函数输入范围内的某些点上是不可微的。那么这些函数实际上是如何用于反向传播的呢？简单的答案是，从数学的角度来看，我们通过忽略这些函数在不可微点的输出来作弊，并用更易管理的值重写输出。这篇博文深入探讨了这种差异的背景，以及它在这种情况下是如何应用的。我还将描述一种方法，通过这种方法，人们可以处理整体上不可微的函数，以及反向传播和神经网络的含义。为了做到这一点，我大量借鉴了劳拉·阿尔科克的《如何思考分析》一书，以及其他资料，该书被证明对理解这个主题是不可或缺的。</p><h1 id="92f8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">微分和可微性</h1><p id="fa8f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">首先是一些关于微分的背景知识，以及微分的含义。比如函数𝑓(𝑥) = 𝑥就是一个把实数映射成实数的函数(𝑓 : <strong class="ih hj"> ℝ → </strong> <strong class="ih hj"> ℝ </strong>)。函数𝑓(𝑥) = 𝑥是光滑的，在每一点都是可微的。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/07045ce31a5d716236c0b982f5d5fcb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2OctzXSUHESLZpv0.png"/></div></div></figure><p id="996a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">上图</strong>𝑓(𝑥)=𝑥函数的可视化。缩放区域用切线(蓝色)显示在右侧。</p><p id="6031" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数𝑓(𝑥) = 𝑥是连续且可微的:这意味着在𝑓(𝑥的每一点，我们可以画一条切线并逼近梯度。解析地，我们可以推导出𝑓(𝑥的导数，这在整个x上都有效，𝑓(𝑥的导数是𝑓ʹ(𝑥) = 2𝑥.如果将上述功能与另一个功能进行比较，整流线性单元(ReLU)功能通常用作激活功能。ReLU也是连续的，映射(𝑓:<strong class="ih hj">ℝ→</strong>T2】ℝ)所以任何实数输入都会产生一个实数输出。不像𝑓(𝑥) = 𝑥，然而这个函数有一部分是不可微的。当我们放大函数时，可以清楚地看到它是不平滑的(有一个尖角x=0)。尖角是函数上非微分点的典型标志:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/81e03d663b944290101620ded1871a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zlz0Paic4-S6velT.png"/></div></div></figure><p id="402b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">上图</strong>显示ReLU功能(绿色)。缩放区域显示在右侧，切线不正确(蓝色)。</p><p id="afa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一个尖角处，很容易画一条与两条相交线等距的切线，或者甚至画多条切线，就好像想象一条线从一条线旋转到另一条线，然而这些都是不正确的。在任何一点上，一个图形要么有一个有意义的梯度(因此有一个切线)，要么没有。在这个角上，在极限处，没有有意义的切线，所以函数的这个点是不可微的。这样做的原因是，对于在每一点都可微的函数，其差商必须满足以下标准:</p><p id="5856" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">f仅在𝒂可微当且仅当</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kt"><img src="../Images/f75d8c897953de98effbff2649f1611f.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/0*svqnZqVHgoLL5JF6.png"/></div></figure><p id="328b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存在。𝒂和𝑓.非常相似如果我们从上面用𝒂逼近𝑥，我们可以看到差商趋于无穷大，这意味着在这一点上的正切不存在。</p><p id="a6fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你把𝑓(𝑥)in分解成它的组成部分，并对其进行解析微分，它似乎应该是完全可微的:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ku"><img src="../Images/0742898f8f39672de39d1374b10e3ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/0*vgor7y_PjjFOG8xF.png"/></div></figure><p id="2635" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而这是不正确的。该函数在零点不可微，应该将该函数的导数写成如下形式:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kv"><img src="../Images/90800156feb83f3146fedd5e0b67bc48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_2GXb-PXJf7xLbqH.png"/></div></div></figure><p id="f938" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">。总之，具有尖角的非光滑函数将具有不可微的区域。尖角上不能有有意义的切线，并且不能满足微分的核心标准，即极限存在。</p><h1 id="c5b9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">深度学习的激活功能</h1><p id="52f7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">经典的激活函数tanh和逻辑sigmoid函数始终是平滑函数，但是，如果您将一些最近引入的激活函数可视化，您会发现它们并不平滑，并且有拐角，尽管它们始终不可微，但在互联网上很容易找到这些函数的表示，表明它们是:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/9243e772dc8a8113d646a865f8ef3dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EzgZ2bAM5H3NcuoK.png"/></div></div></figure><p id="38fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上中的<strong class="ih hj">激活函数导数使用传统符号表示，尽管事实上一些函数上有不可微的点[ <a class="ae jd" href="https://dwaithe.github.io/blog_20170508.html#two" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]。</strong></p><p id="8317" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的例子中[<a class="ae jd" href="https://dwaithe.github.io/blog_20170508.html#two" rel="noopener ugc nofollow" target="_blank">2</a>]ReLU和PReLU函数是不可微的，尽管有符号。二元阶跃函数也是不可微的，但是上图的作者用线“？”表示了这一点。对于𝑥= 0”。那么这怎么可能呢？我们如何使用不完全可微的函数来构造神经网络，该神经网络由许多这样的函数组成，并且对于要执行的训练过程必须是可微的？</p><h1 id="e04f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用包含不可微点的激活函数进行深度学习</h1><p id="761d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">像ReLU这样的函数被用在神经网络中，因为使用这些简单的方程比更传统的激活函数(如tanh或logistic sigmoid函数)具有计算优势。用于优化神经网络的反向传播算法在系统中包含的所有函数都是可微分的前提条件下工作。如前所述，ReLU和其他变量在特定点上是不可微的，那么如何使用它们呢？本质上，在它们不可微的点上，函数不被评估，输出被替换为可感知的值。例如，对于𝑓ʹ(𝑥的ReLU，我们只指定输出为0或1，这对于我们的使用是合理的。例如，在ano [ <a class="ae jd" href="https://dwaithe.github.io/blog_20170508.html#three" rel="noopener ugc nofollow" target="_blank"> 3 </a> ]中，它指定不评估𝑥，并将其视为𝑥 &gt; = 0时的1。这在数学上并不纯粹，人们可以想象这将导致问题的场景，然而现实情况是，由这些函数组成的神经网络工作良好且稳定，因此这个问题被忽略，有利于计算效率。</p><h1 id="ba85" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="09a6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">有些人可能会说，如果我们无论如何都要指定不可微点的输出，为什么要花额外的文字和符号来解释这个点是不可计算的。其他人会说我们在滥用记谱法，对于外行人来说，我们把事情简单化了。我可以从两个角度理解这一点，从简洁和简单的角度来看，这并不经常出现，这就是为什么像上面这样的文本对于任何感兴趣的人来说，对于完全理解某些情况是如何发生的是有用的。</p><h1 id="1ada" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">参考</h1><p id="9a0c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">[1]<a class="ae jd" href="https://www.amazon.co.uk/Think-About-Analysis-Lara-Alcock/dp/0198723539" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . co . uk/Think-About-Analysis-Lara-Alcock/DP/0198723539</a></p><p id="73f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[2]<a class="ae jd" href="https://www.quora.com/Why-do-we-not-use-a-differentiable-approximation-of-ReLUs" rel="noopener ugc nofollow" target="_blank">https://www . quora . com/Why-do-we-not-use-a-differentiable-approximation-of-ReLUs</a></p><p id="3cc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[3]https://groups.google.com/forum/#!<a class="ae jd" href="https://groups.google.com/forum/#!topic/lasagne-users/_rWsIieuGmA" rel="noopener ugc nofollow" target="_blank">topic/lasagne-users/_ rWsIieuGmA</a></p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><p id="22c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ld">最初发布于</em><a class="ae jd" href="https://dwaithe.github.io/blog_20170508.html" rel="noopener ugc nofollow" target="_blank"><em class="ld">https://dwaithe . github . io</em></a><em class="ld">。</em></p></div></div>    
</body>
</html>