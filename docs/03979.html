<html>
<head>
<title>Pandas parallelize speed up process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫并行加速进程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pandas-parallelize-speed-up-process-2b086508baf9?source=collection_archive---------15-----------------------#2020-02-28">https://medium.com/analytics-vidhya/pandas-parallelize-speed-up-process-2b086508baf9?source=collection_archive---------15-----------------------#2020-02-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c0ea9f48f6fbccd3a2c80ff77ea76c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ph9G4lib8UqLIa083YfpQ.jpeg"/></div></div></figure><p id="3fa9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated">当我们处理数据(无论大小)时，我们会遇到加快处理速度的问题。</p><p id="5e21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了解决这个问题，我们可以使用几个软件包:</p><ul class=""><li id="445a" class="jx jy hi is b it iu ix iy jb jz jf ka jj kb jn kc kd ke kf bi translated">熊猫申请(原生)</li><li id="3a91" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn kc kd ke kf bi translated">下前支索</li><li id="a7d6" class="jx jy hi is b it kg ix kh jb ki jf kj jj kk jn kc kd ke kf bi translated">达斯克</li></ul><p id="0137" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在这里 了解更多关于那些套餐<strong class="is hj"> </strong> <a class="ae kl" href="https://gdcoder.com/speed-up-pandas-apply-function-using-dask-or-swifter-tutorial/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">。尽管这些包的使用相对简单，但使用时的性能并不能推广到所有类型的数据(例如文本数据)。如果我们有了一台大机器(AWS <a class="ae kl" href="https://aws.amazon.com/fr/ec2/pricing/on-demand/" rel="noopener ugc nofollow" target="_blank"> EC2 instance </a>，Google……)，我们就不能使用所有的计算能力来处理你的数据，我们很快就会感到沮丧。</strong></a></p><p id="4c6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本教程的目标是构建一个<strong class="is hj">并行化函数</strong>，旨在利用机器的全部可能性来处理数据。我们将重点关注pandas和for循环并行化过程。</p><p id="4fbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，我们将使用python <strong class="is hj">多处理</strong>池包。</p><h2 id="99b6" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated"><strong class="ak"> 1。什么是多重处理</strong></h2><p id="6750" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">多重处理包允许程序员在给定的机器上充分利用多个处理器。它可以在Unix和Windows上运行。我们将主要使用池类，表示一个工作进程池。它有允许任务以几种不同的方式卸载到工作进程的方法。</p><p id="e734" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多处理是一个<a class="ae kl" href="https://pypi.org/project/multiprocessing/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Pypi </strong> </a>包，安装起来非常容易。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/297dcb5a43e86452569838910ee8d766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5Xs5vKdSBhX5eSE8-B30w.png"/></div></div></figure><h2 id="a3c8" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated"><strong class="ak"> 2。如何使用多重处理进行并行化</strong></h2><p id="7acd" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">假设我们有一个非常大的pandas数据框架，我们需要在一个或多个列上计算并行化。(可以在<a class="ae kl" href="https://github.com/isaac47/dataframe-pyrallelizer" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Github </strong> </a>上找到完整的脚本)。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/354196c0622a2db083dd74afb8237c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fWkwQBw2bI0EqmGY42bzA.png"/></div></div></figure><p id="d485" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将首先构建一个函数来选择要使用的cpu数量。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/8d4f31cb4907855c895b22dca454be03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLXYsBYyNqTaWxrmAgeV0g.png"/></div></div></figure><p id="5d25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个函数帮助我们选择所有可用的CPU或者设置我们想要使用的CPU数量。</p><p id="c9c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将定义应用构造函数的函数。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/e991b061369281acd92668b6b1d99752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6tLoA_o7TevPeX38b1j6Q.png"/></div></div></figure><p id="3999" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">函数定义了每一行的pandas应用过程。“<strong class="is hj"> func_processor </strong>”帮助我们获取多个参数。</p><p id="34d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将在前面函数的基础上构建数据帧并行化函数。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/483f5d15da70fefe6b4c62e641e5e898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_V4amVBqdvGsFaIJB2_WTA.png"/></div></div></figure><p id="4d9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该函数将定义保持并行化过程。我们将首先获得所有的输入和输出参数；然后我们会定义CPUto的使用次数；最后，我们将根据我们选择的CPU数量将大数据帧分割成多个块，并同时应用每个块的映射过程。</p><p id="98d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使用这个函数，让我们举这个例子:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/b9642f1453527979d60f9e94176d14d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsmrrq-YFCX9FE0V_DwrQg.png"/></div></div></figure><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/69d0c6151962661684e3ac8230ebe36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4CBRJfPD-v2hbOkVR8lHyw.png"/></div></div></figure><p id="5a2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们定义应用和运行流程的函数。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/389f01b0762969e75af16c8d99e57c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zuJi9on59CLDXVvQQXiyZg.png"/></div></div></figure><p id="fd55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是结果(在EC2 Aws机器上)</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/7b47c133c175a7e974ee515d1a8df214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5QjFhDoXGO9C-_a3S2y6Q.png"/></div></div></figure><p id="c59d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你所看到的，我们同时使用所有的CPU和必要的内存。</p><p id="9b09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">警告</strong>:当我们使用多进程池时，它会不断地动态创建线程；那会填满内存，搞坏机器。为了解决这个问题，你可以通过激活<strong class="is hj">交换内存</strong>来扩展内存(你可以在这里 阅读更多<a class="ae kl" rel="noopener" href="/@isaackuissu/swap-space-ram-memory-extension-c7d371bdc2f0">)。您还可以设置线程的最大数量(这可能会限制函数的功能)。解决这个问题的最后一个方法是管理内存使用。这个任务可能很强，因为Python默认不提供对内存管理的访问(像C语言一样)。</a></p><p id="7ce7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在我的<strong class="is hj">pyparalizer</strong>包中设计了一个实现这个任务的方法，你可以在这里 找到它<a class="ae kl" href="https://github.com/isaac47/pyparallelizer" rel="noopener ugc nofollow" target="_blank">。这个包在for循环并行化的情况下也有帮助。</a></p><h2 id="947a" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated"><strong class="ak">结论</strong></h2><p id="8d4f" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">当我们处理大量数据时，我们会遇到速度处理问题。这个函数将帮助我们并行化我们的过程，我们可以通过这样做赢得几个小时。如果你像我一样厌倦了做“<strong class="is hj">数据等待</strong>”，那就开始并行化吧。</p><h2 id="6a8d" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">不要做数据等待，开始编码！</h2></div></div>    
</body>
</html>