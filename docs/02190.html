<html>
<head>
<title>Django with Docker and Docker Compose (Python part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django与Docker和Docker Compose (Python第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/django-with-docker-and-docker-compose-python-part-1-da0ed3f61566?source=collection_archive---------3-----------------------#2019-12-05">https://medium.com/analytics-vidhya/django-with-docker-and-docker-compose-python-part-1-da0ed3f61566?source=collection_archive---------3-----------------------#2019-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fa9197f36323d208cdb9990f5df74ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h205DQBt-f7ikKiPpP4Gxg.png"/></div></div></figure><p id="2f2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我写这篇文章的灵感来自于我尝试用django应用程序改变docker开发环境的经历。我会试着写一系列的文章，我会给你一些概念</p><ol class=""><li id="52c7" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">使用docker和django应用程序进行全栈开发</li><li id="572c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">用Django进行测试驱动开发</li><li id="8719" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">自动部署数字海洋和自动气象站的CI/CD管道。</li></ol><p id="8705" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这篇文章能帮助那些对使用docker开发任何应用程序感到紧张的人。</p><p id="8333" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">docker是什么？</strong></p><p id="acf1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Docker是一个开源的自动化工具，它帮助我们将一个应用程序自动打包到一个容器中，容器中包含了运行应用程序所需的所有信息和依赖关系。它更灵活、更可移植、更资源友好、更独立于主机操作系统。</p><p id="7fed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是django框架？</strong></p><p id="ddb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据django文档定义，</p><p id="e73b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“Django是一个高级Python Web框架，它鼓励快速开发和干净、实用的设计。由经验丰富的开发人员构建，它解决了Web开发的许多麻烦，因此您可以专注于编写应用程序，而无需重新发明轮子。它是免费和开源的。”</p><p id="df9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">构建开发环境的先决条件</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="2b4b" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">1. python &gt; 3.7<br/>2. pip3<br/>3. pipenv<br/>4. django 2.2<br/>5. Docker installed in (window or linux or mac os x)</strong></span></pre><p id="9322" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要将<code class="du kr ks kt kh b">pipenv</code>安装到开发环境中，我们需要遵循以下命令。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="47e4" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">For Mac OS x or Linux use this below command installed with python v3.7. if the Mac OS x or Linux already has a python version 2. You must use pip3 and python version 3 for django v2.2.</strong></span><span id="be7b" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">&gt; pip3 install pipenv</strong></span><span id="8fd5" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">For window use this command installed with python v3.7. If you have version 2 installed in window pc. please use pip3 as default package manager.</strong></span><span id="4e2f" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">&gt; pip install pipenv</strong></span></pre><p id="0e53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建文件夹名<code class="du kr ks kt kh b"><strong class="is hj">django-docker</strong></code>并通过。然后转到该文件夹或目录</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="d50c" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">&gt; mkdir django-docker<br/>&gt; cd django-docker</strong></span></pre><p id="46aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du kr ks kt kh b"><strong class="is hj">django-docker</strong></code>目录下创建另一个名为<code class="du kr ks kt kh b"><strong class="is hj">app</strong></code>的文件夹。然后去那个目录</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="3dba" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">&gt; mkdir app<br/>&gt; cd app</strong></span></pre><p id="46fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后用<code class="du kr ks kt kh b"><strong class="is hj">pipenv</strong></code>安装Django (2.2.8)，使用pipenv:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="ff8a" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">&gt; pipenv --python 3.7 install django==2.2.8</strong></span></pre><p id="5f13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="kv"> — python 3.7 </em> </strong>的意思是，用pipenv创建虚拟环境时指定python版本。</p><p id="ba2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，要激活虚拟环境，您需要在终端上运行以下命令</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="8278" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">&gt; pipenv shell</strong></span></pre><p id="7538" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Django </strong>已经作为包安装，你可以在<code class="du kr ks kt kh b"><strong class="is hj">Pipfile</strong></code>中找到定义。要创建django项目结构，您需要使用<code class="du kr ks kt kh b"><strong class="is hj">django-admin</strong></code>，并运行下面的命令来创建项目</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="865f" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">&gt; django-admin startproject main .</strong></span></pre><p id="68c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，您可以在您喜欢的代码编辑器或IDE中打开<code class="du kr ks kt kh b"><strong class="is hj">django-docker</strong></code>目录，我使用vscode作为本文的默认代码编辑器。你可以用你合适的。</p><p id="e52d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建文本文件<code class="du kr ks kt kh b">requirements.txt</code>到<code class="du kr ks kt kh b">app</code>文件夹，添加<code class="du kr ks kt kh b">Django==2.2.8</code>到文本文件。我使用来自<code class="du kr ks kt kh b">requirments.txt</code>文件构建时间用django构建docker映像和容器。</p><p id="8925" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">requirements . txt</strong>文件如下:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="2178" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">#./django-docker/app/requirments.txt</strong><br/>#Packages<br/><strong class="kh hj">Django==2.2.8</strong></span></pre><p id="ffe7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">项目结构为</strong>T4】</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="8813" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">└── app<br/>    ├── main<br/>    │   ├── __init__.py<br/>    │   ├── settings.py<br/>    │   ├── urls.py<br/>    │   └── wsgi.py<br/>    ├── manage.py<br/>    └── requirements.txt<br/>    └── Pipfile<br/>    └── Pipfile.lock</strong></span></pre><p id="dd49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">每个生成的文件都是运行django项目的责任</strong></p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="0698" class="kl km hi kh b fi kn ko l kp kq">1.<strong class="kh hj"> __init__.py</strong> (It tells the python, main is python module for this project and it's an empty file. so `main` will be access as python module)</span><span id="9565" class="kl km hi kh b fi ku ko l kp kq">2. <strong class="kh hj">setting.py </strong>(It contains all the configuration related to django project)</span><span id="3c4c" class="kl km hi kh b fi ku ko l kp kq">3. <strong class="kh hj">urls.py </strong>(It contains all the definition route information of every page of django application. it using for declare the url and route for each page of web application built with django)</span><span id="25f6" class="kl km hi kh b fi ku ko l kp kq">4. <strong class="kh hj">wsgi.py</strong> (This file is use for run the application uwsgi supported server. we can use this file to configure gunicorn web server)</span><span id="d8fd" class="kl km hi kh b fi ku ko l kp kq">5. <strong class="kh hj">manage.py</strong> (It's an wizard for django application, to create app, module and views and manage migration, we will use this file)</span><span id="88f1" class="kl km hi kh b fi ku ko l kp kq">6. <strong class="kh hj">Pipfile</strong> ( It's is a difination file where pip takes the meta information to download package and build, setup the python package(Django Application)</span></pre><p id="99a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要运行项目，请转到终端或cmd来运行以下命令</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="c94c" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">&gt; python manage.py runserver --insecure 0.0.0.0:5555</strong></span></pre><figure class="kc kd ke kf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/1ceb4e41f5c84ea1aa5b61b521387f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Exuop8_3O12iqXA5S69HGQ.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图1.1应用程序运行命令</figcaption></figure><p id="2dc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="kv"> runserver </em> </strong>命令将运行django开发服务器。</p><p id="e7aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="kv"> —不安全的</em> </strong>参数使django应用程序能够在本地开发环境中运行。并使用static files应用程序强制提供静态文件。</p><p id="e447" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 0.0.0.0: &lt;端口&gt; </strong>，我们可以定义django开发服务器将服务于django web应用的端口。</p><p id="3fb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到图1.1中第(1)点的警告，该警告与数据库迁移有关。我们得到了警告，因为我们没有在运行应用程序之前迁移数据库。django默认带有sqlite数据库，如果我们运行migrate命令，它会将所有数据和信息迁移到sqlite数据库。在本文的这一部分，我们现在不需要迁移。</p><p id="ae1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们可以…导航到浏览器，在浏览器中你会看到django欢迎页面。于是django成功安装在<code class="du kr ks kt kh b">pipenv</code>或者虚拟环境中。</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/cf342dc2daf0181e28d9bdf63975688b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwQBK4SBNx0MVcXfc3WskA.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图1.2 django应用程序成功运行</figcaption></figure><h1 id="3d1e" class="ld km hi bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在docker中运行Django项目</h1><p id="7e64" class="pw-post-body-paragraph iq ir hi is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hb bi translated"><strong class="is hj">创建</strong> <code class="du kr ks kt kh b"><strong class="is hj">Dockerfile</strong></code> <strong class="is hj"> docker文件</strong></p><p id="395d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要去根文件夹或目录的项目创建文件名<code class="du kr ks kt kh b">Dockerfile</code>。现在你对什么是docker文件有疑问了。</p><p id="7c00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Docker将通过读取来自<code class="du kr ks kt kh b">Dockerfile</code>的指令自动构建映像。它是一个文本文件，包含了所有组装成图像的命令。它包含必要的软件包，应用程序，命令和各种设置来创建docker镜像。为了对任何应用程序进行归档，我们需要在其中包含dockerfile。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="e5c3" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">From --&gt; </strong><em class="kv">For build the docker image, From instraction must needed, because it will take the information from base image (OS base, other software package images) where to start building docker image.</em></span><span id="26d0" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">WORKDIR --&gt; </strong><em class="kv">It is used for switch to that directory for copy or add files or run some command in that directory in container. It also helps to create the new directory, which are used for building the image, copy the code and settings to it.</em></span><span id="42d8" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">ENV --&gt; </strong><em class="kv">It's use for environment variable of docker images. Docker image contains the lightweight operating system. we can push and override the environment variable from  calling it </em></span><span id="0fb7" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">COPY --&gt; </strong><em class="kv">Helps to copy the file from host machine to docker container.</em></span><span id="422b" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">ADD --&gt; </strong><em class="kv">Helps to copy the file from host machine to docker image or container. It as like as copy instractions, it has extra functionality, it copy the file from remote also</em></span><span id="ac5f" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">RUN --&gt; </strong><em class="kv">Run the command inside the docker image at image building time. It support valid operating system command.   executes command(s) in a new layer and creates a new image</em></span><span id="c643" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">CMD --&gt;  </strong><em class="kv">sets default command and/or parameters, which can be overwritten from command line when docker container runs</em></span><span id="19cf" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">ENTRYPOINT --&gt;  </strong><em class="kv">used for configure the container that will run as an executable. We can add the multiple command shell file .sh file in entrypoint instructions. it will run </em></span><span id="8d83" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">EXPOSE --&gt; </strong><em class="kv">It will help to expose the port for to in docker to access by other container or images. we also mapping with host computer port during run the docker container.</em></span></pre><p id="f632" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是<code class="du kr ks kt kh b">Dockerfile</code>的格式:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="1738" class="kl km hi kh b fi kn ko l kp kq"># Comment<br/><strong class="kh hj">INSTRUCTION</strong> arguments</span></pre><p id="86f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于<code class="du kr ks kt kh b">django-docker</code>应用，我将<code class="du kr ks kt kh b">Dockerfile</code>添加到<code class="du kr ks kt kh b">app</code>目录:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="6d5c" class="kl km hi kh b fi kn ko l kp kq">django-docker<br/><strong class="kh hj">└── app</strong><br/>    ├── main<br/>    │   ├── ......<br/>   <strong class="kh hj"> ├── Dockerfile</strong></span></pre><p id="eb67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kr ks kt kh b"><strong class="is hj">Dockerfile</strong></code>以下为<code class="du kr ks kt kh b">django-docker</code>项目提供说明。出于开发目的，我使用<strong class="is hj"><em class="kv">python:3 . 7 . 5-buster</em></strong>作为构建docker映像和容器的基础映像。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="9d16" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj"># ./django-docker/app/Dockerfile</strong><em class="kv"><br/></em><strong class="kh hj">FROM</strong> python:3.7.5-buster</span><span id="d727" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj"># set work directory</strong><br/><strong class="kh hj">WORKDIR</strong> /opt/app</span><span id="8094" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj"># set environment variables</strong><br/><strong class="kh hj">ENV</strong> PYTHONDONTWRITEBYTECODE 1<br/><strong class="kh hj">ENV</strong> PYTHONUNBUFFERED 1</span><span id="72fa" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj"># install dependencies</strong><br/><strong class="kh hj">RUN</strong> pip install --upgrade pip<br/><strong class="kh hj">COPY</strong> ./requirements.txt /opt/app/requirements.txt <br/><strong class="kh hj">RUN</strong> chmod +x /opt/app/requirements.txt<br/><strong class="kh hj">RUN</strong> pip install -r requirements.txt</span><span id="a9b6" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj"># copy project</strong><br/><strong class="kh hj">COPY</strong> . /opt/app/</span></pre><p id="9e6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kr ks kt kh b"><strong class="is hj">PYTHONDONTWRITEBYTECODE</strong></code>:防止Python将pyc文件写入光盘。<code class="du kr ks kt kh b"><strong class="is hj">PYTHONUNBUFFERED</strong></code>:防止Python缓冲stdout和stderr。</p><h1 id="b2a0" class="ld km hi bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">将Docker合成添加到项目</strong></h1><p id="f59e" class="pw-post-body-paragraph iq ir hi is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hb bi translated">然后在<code class="du kr ks kt kh b">django-docker</code>目录下添加名为<code class="du kr ks kt kh b">docker-compose.yml</code>的docker合成文件。现在你对什么是docker compose以及为什么需要它有疑问了。根据<code class="du kr ks kt kh b">docs.docker.com.</code>中的docker编写文档</p><blockquote class="mf"><p id="b502" class="mg mh hi bd mi mj mk ml mm mn mo jn dx translated">Compose是一个用于定义和运行多容器Docker应用程序或服务的工具。开发人员可以使用YAML文件来配置应用程序服务，只需一个命令，它就可以创建和启动所有服务，以从yml文件中获取信息。”</p></blockquote><pre class="mp mq mr ms mt kg kh ki kj aw kk bi"><span id="c7df" class="kl km hi kh b fi kn ko l kp kq">django-docker<br/>└── app<br/>│   ├── main<br/>│      ├── ......<br/>├── <strong class="kh hj">docker-compose.yml</strong></span></pre><p id="1c2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我创建docker compose yml文件，下面提供了该文件的指令定义，以便为这个web应用程序项目创建<code class="du kr ks kt kh b">services and container</code>。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="9cd7" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">#./django-docker/docker-compose.yml<br/>version</strong>: '3.7'<br/><br/><strong class="kh hj">services</strong>:<br/>  <strong class="kh hj">web</strong>:<br/>    <strong class="kh hj">build</strong>:<br/>         <strong class="kh hj">context</strong>: ./app <br/>         <strong class="kh hj">dockerfile</strong>: Dockerfile<br/>    <strong class="kh hj">command</strong>: python manage.py runserver 0.0.0.0:8000<br/>    <strong class="kh hj">volumes</strong>:<br/>      - ./app/:/opt/app/<br/>    <strong class="kh hj">ports</strong>:<br/>      - 4000:8000<br/>    <strong class="kh hj">env_file</strong>:<br/>      - ./env/django.env</span></pre><p id="33fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">docker-compose文件所有关键字的简单描述，这将在下面讨论，<strong class="is hj">如果您已经了解这些关键字或说明，请跳过该部分。</strong></p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="ffa5" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">version</strong>: contains docker compose file format version. There is several file format available form 1.x to 3.x.</span><span id="3ba6" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">services:</strong> services blocks contains all the applications or services definition which is needed for run the applications successfully. for example if we want to run the web apps, we need a database and other services. so we can add multiple service or app definitions in services blocks.</span><span id="0f1f" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">web:</strong> web is service for our django-docker project, docker compose build images or services with using name as <strong class="kh hj">`web`</strong> by docker-compose, which contains definition of django application to run and deploy.<br/>     <br/>     <strong class="kh hj">services:<br/>             web:<br/>                build:</strong></span><span id="9991" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">build:</strong> there is a lot of option for build instruction. we can build image from another image. we can provide the target folder to build in `build` block. build has some sub blocks, those are<br/>     <br/>    <strong class="kh hj">context:</strong>  which will takes to a directory, which contains a Dockerfile, or a url to a git repository. where the value supplied with relative path, it will send to docker deamon to building process.</span><span id="5413" class="kl km hi kh b fi ku ko l kp kq">    <strong class="kh hj"> build:<br/>          context: ./&lt;dir-name&gt;</strong></span><span id="8f72" class="kl km hi kh b fi ku ko l kp kq">     <strong class="kh hj">dockerfile:</strong> if we want to specify or use different docker file to build docker image by docker compose file. we need to use it.<br/>      <br/>     <strong class="kh hj">build:<br/>          context: ./&lt;dir-name&gt;<br/>          dockerfile: &lt;docker-filename&gt;</strong></span><span id="39d7" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">command:</strong> Run the command in docker container from the docker-compose.yml file. it can run any valid os and os application command inside the container.</span><span id="89ca" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">volumes:</strong> we can mount the specific host path or named volume to docker contains which contains the media files and other files needed for run the application. for my apps i have to mount the /app folder to container.</span><span id="2d08" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">expose:</strong> provide port access to docker system so other container can access the service by this port. expose only publish the port within docker system, so host computer service or app can not get this port to access service.</span><span id="15b3" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">ports:</strong> it use for mapping the ports between <strong class="kh hj">HOST:DOCKERCONTAINER</strong>. other docker container service and host computer service can get access to that port, to get service information.</span><span id="030d" class="kl km hi kh b fi ku ko l kp kq">   <strong class="kh hj"><em class="kv"> if we run the our django application in 8000 port in DOCKERCONTAINER, we want to map 4000 port with host computer just follow the rules</em></strong><br/>          <strong class="kh hj"> ports:<br/>               - HOST-PORT:DOCKERCONTAINER-PORT<br/>           (e.g)<br/>           ports:<br/>               - 4000:8000</strong></span><span id="0146" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">environment:</strong> it will add and override the environment variable to docker container or image. which is then you can use it as environment variable to the specified docker container image.</span><span id="5227" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">env_file:</strong> we can add environment variable file there. we can use it also define the or override the environment variable of the docker container or image. we can add the multiple env file in env_file block.</span></pre><p id="c015" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du kr ks kt kh b">env</code>目录下为docker创建env文件。首先在<code class="du kr ks kt kh b">django-docker</code>目录下创建<code class="du kr ks kt kh b">env</code>目录。然后在<code class="du kr ks kt kh b">env</code>目录或文件夹中创建文件名<code class="du kr ks kt kh b">django.env</code></p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="d492" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">&gt; mkdir env<br/>&gt; cd env</strong></span><span id="c50a" class="kl km hi kh b fi ku ko l kp kq">For Linux and max os x command<br/><strong class="kh hj">&gt; touch django.env</strong><br/>For window you can create from IDE or code editor</span></pre><p id="74aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">env文件的位置如下所示:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="b5aa" class="kl km hi kh b fi kn ko l kp kq">django-docker<br/>└── app<br/>│   ├── main<br/><strong class="kh hj">├── env<br/>│   ├── django.env</strong></span></pre><p id="2a80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kr ks kt kh b">django-docker</code>图像和容器的环境文件</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="7e0a" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj"># ./django-docker/env/django.env</strong></span><span id="6c6c" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">SECRET_KEY</strong>=FirstProjectSecrit <br/><strong class="kh hj">DEBUG</strong>=1 <br/><strong class="kh hj">ALLOWED_HOSTS</strong>=localhost 127.0.0.1 [::1]</span></pre><p id="ee66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后你需要在<code class="du kr ks kt kh b">main</code>项目文件夹中找到一些行并用下面的代码<code class="du kr ks kt kh b">settings.py</code>替换。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="6fac" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">#./app/main/setting.py</strong></span><span id="baea" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">SECRET_KEY = os.environ.get("SECRET_KEY", default="forlocaltest")</strong></span><span id="a9ed" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">DEBUG = int(os.environ.get("DEBUG", default=1))</strong></span><span id="2198" class="kl km hi kh b fi ku ko l kp kq"><strong class="kh hj">ALLOWED_HOSTS = os.environ.get('ALLOWED_HOSTS').split(" ") if os.environ.get('ALLOWED_HOSTS') else ['localhost', '127.0.0.1']</strong></span></pre><p id="f92f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">django应用程序出于安全目的使用SECRET_KEY = 。这用于提供加密签名，应该设置为唯一的、不可预测的值。使用已知的<code class="du kr ks kt kh b"><strong class="is hj">SECRET_KEY</strong></code>运行Django会破坏Django的许多安全保护，并可能导致权限提升和远程代码执行漏洞。</p><p id="610a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> DEBUG = </strong>在调试模式下运行应用程序，这样开发者可以在浏览器中浏览时发现错误。切勿在打开<code class="du kr ks kt kh b"><strong class="is hj">DEBUG</strong></code>的情况下将站点部署到生产环境中。当<code class="du kr ks kt kh b">Debug</code>是<code class="du kr ks kt kh b">True</code>时，就会出现异常，Django会显示一个详细的回溯，包括很多关于你的环境的元数据，比如所有当前定义的Django设置。</p><p id="c223" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> ALLOWED_HOSTS </strong> =表示Django站点可以服务的主机/域名的字符串列表。</p><h1 id="e4a7" class="ld km hi bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">os.environ是做什么的？</h1><blockquote class="mf"><p id="7948" class="mg mh hi bd mi mj mk ml mm mn mo jn dx translated">os.environ是带有映射的python实用程序库，使用操作系统的用户环境变量设置对象。在上面，我创建了env文件，所以当应用程序在docker容器中运行时，env文件中的env变量被添加到docker容器操作系统中。所以我们可以通过os.environ库使用os.environ.get('env-variable ')函数获取evn环境变量数据。</p></blockquote><p id="bef2" class="pw-post-body-paragraph iq ir hi is b it mu iv iw ix mv iz ja jb mw jd je jf mx jh ji jj my jl jm jn hb bi translated">使用docker compose构建docker映像的命令，它将构建映像并使用特定端口建立所有docker容器服务:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="5969" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">&gt; docker-compose up --build</strong></span></pre><p id="3cac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者</p><p id="b2d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您也可以运行下面的命令，它将构建所有服务或docker映像，并在后台运行服务<strong class="is hj"> <em class="kv"> (-d命令参数提供docker在后台运行服务的指令)</em> </strong>，因此我们在终端中看不到命令或日志信息。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="fec1" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">&gt; docker-compose up --build -d</strong></span></pre><p id="f41d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">进入浏览器并导航至<a class="ae lb" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000/ </a>再次查看欢迎屏幕。</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/c12ce13ba51747e92e3fbdb487f71246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7NDtBFdY-UDrW6hY1Fva8Q.png"/></div></div></figure><p id="114c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您在github资源库中找到的完整代码和资源</p><div class="na nb ez fb nc nd"><a href="https://github.com/tariqulislam/django-docker.git" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">tariqulslam/django-docker</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr io nd"/></div></div></a></div></div></div>    
</body>
</html>