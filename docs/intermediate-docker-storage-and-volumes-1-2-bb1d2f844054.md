# 中级码头工人:存储和卷(1/2)

> 原文：<https://medium.com/analytics-vidhya/intermediate-docker-storage-and-volumes-1-2-bb1d2f844054?source=collection_archive---------27----------------------->

我们已经知道，Docker 运行应用程序，并使用基本的分层映像，这些映像抽象了某个系统的某些部分和其他相关的基本概念，如 Docker 容器、运行模式、标记和命名、端口转发等。

现在，我们缺少一个非常重要的功能，即**存储。**我们如何管理数据来填充我们的容器？应用程序需要数据，对吗？所以，现在我要谈谈 Docker 存储和卷。

我们从码头仓库开始，好吗？

# 在 Docker 中存储数据

假设您有一组正在运行的容器，比如一个三层应用程序、一个**数据库**、一个**中间件**和一个**前端**层，从逻辑上(也是最佳实践)所有这些都应该是独立的，因为所有应用程序都需要数据(实际上是生成或使用)。

所以，你会考虑把它存放在什么地方最好？数据必须依赖容器内部还是与容器在一起？。

自然地，容器被设计成短暂的(一次性的)，所以，你启动它，它们做它们的工作，最后，你关闭容器。此时，所使用的数据是不可访问的，当容器关闭时，您将无法访问“会话”数据。你看到了“会话”的类比，对吗？

为了回答你的问题，Docker 容器通常存储在每个主机上，它们也是隔离的，所以数据不能与其他容器共享。容器文件系统不是为高性能 IO 设计的。

在走向理想的解决方案之前( **Docker Volumes** )。我将澄清事实，告诉您卷不是存储数据的唯一方式，但却是更有效的方式。

除了 Docker 卷(将在后面解释)，我们还有两种存储非永久数据的技术。我们将**绑定挂载**到 Docker 容器。还有`tmpfs` **坐骑。**

根据文件系统执行**绑定挂载**描述了挂载到 **Docker 卷**目录的确切路径的过程，基本上，您必须匹配主机上的确切文件路径，这种替代选项在功能方面非常有限，根本不建议使用。

为此，应该在命令中设置`type=bind`,而源文件不能是一个名字，应该是一个特定的文件路径或变量

检查此容器实例:

`docker container run -d --mount type=bind,source=/app,target=/app nginx`

另一种方式是通过`tmpfs`，它将数据存储在运行容器的主机的内存空间中。基本上，在 Linux 主机中有大量的 RAM 内存用于存储数据，我需要告诉你这是错误的吗？。

从开发者的角度来看，知道什么是应用商店是一件事，而对码头工人 T2 来说毫无意义。 **Docker** 提供了不同类型的对象存储解决方案，这可以看作是 Docker 一般是如何存储数据的？。

我们有**块存储**，这种特殊类型用于存储永久应用程序数据，另一种是**对象存储**，它通常用于存储 docker 容器图像。

**块存储**用于 IO 密集型操作，由用户创建，基本上存储固定的数据块。**对象存储**数据与元数据和唯一标识符一起存储，没有一种有组织的方式来存储数据，可伸缩性是渐进的，可以通过 HTTP API 调用来访问。[这个](https://rancher.com/block-object-file-storage-containers/)讲座更好地解释了它。

我将讨论 Docker 层是如何存储的。

# 存储的 Docker 层(图像透视)

我在与**图像管理**相关的其他帖子系列中解释了其中的一些概念，但是由于我们正在解释策略以及 Docker 通常是如何存储数据的，我认为以一种快速的方式来谈论它是很重要的。

如果你知道 Docker 镜像内部是如何工作的？你可以跳过这一节，如果没有，我简单提一下，毕竟你周围可以找到很多资料。

Docker 容器使用分层存储文件系统。这是什么意思？嗯，在内部， **Docker Images** 由多个只读层组成，当图像被实例化到容器中时，顶部的可写层被创建用于用户交互，然后当它被删除时被移除。

Docker 使用**存储驱动**来管理图像层和可写容器层的内容。这个驱动程序处理实现的方式与其他驱动程序不同。

总结一下:只读文件只有在文件被修改的时候才会从较低的只读层带入可写层。

## 基础图像

因此，当构建一个容器时，整个过程从一个**清单文件**开始，这是一个描述容器将由什么组成的文本文件，来自其他人的基础 OS(层)将出现。在这个基础层之上，将会有配置和应用层，它们将组成整个功能。

当这种混合层被实例化时，产生的层将作为一个整体放在我们面前。在此**基础层**的顶部，创建了一个可写层，提供一个临时 FS 来写入临时数据，因为配置更改稍后可能会变成只读文件，这些更改会被带到顶部可写层，并且可以被向下推回。

这整个概念叫做 **Docker Union 文件系统。**

这里有一个实用的解释:

`docker image ls`(这将列出已安装的图像)

`docker image inspect [image]`在底部，你会看到一个组成图像的图层列表。然后，该层列表可以在`docker history [tag]`命令的帮助下显示。

我现在就暂停这个。目前，我们涵盖了很多，并不太容易消化。在这个迷你系列的第二部分，我将最终谈论 Docker 卷、存储驱动程序如何工作以及什么是 **Docker 集群存储。**

下一集见。

快乐编码:)