<html>
<head>
<title>CSV Data Processing Pipeline For ML/DL Projects Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的ML/DL项目的CSV数据处理管道</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-processing-pipeline-for-ml-dl-projects-csv-6e1c8a1fcbfd?source=collection_archive---------10-----------------------#2020-07-02">https://medium.com/analytics-vidhya/data-processing-pipeline-for-ml-dl-projects-csv-6e1c8a1fcbfd?source=collection_archive---------10-----------------------#2020-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ae1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">容易获得的CSV数据集可能并不总是被处理，并且可能需要一些清理。这是机器学习(ML)和深度学习(DL)项目中非常常见的一步。</p><p id="94a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将介绍数据预处理和为Python中的ML/DL应用程序准备CSV数据集的基本技术。根据应用，您可能需要执行这些步骤中的部分或全部…</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d81ff1fbcfcb802deeb00849cb95ac87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6wdvSaC_TGDo--vsI2um3A.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">数据预处理:词云</figcaption></figure><h1 id="63e1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">预处理任务:</h1><ul class=""><li id="03ab" class="kr ks hi ih b ii kt im ku iq kv iu kw iy kx jc ky kz la lb bi translated">导入数据集。</li><li id="09af" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">分离因变量和自变量。</li><li id="195c" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">处理缺失数据。</li><li id="2d9d" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">编码分类数据。</li><li id="4a51" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">拆分数据集(训练集和测试集)。</li><li id="2986" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">特征缩放。</li></ul><h1 id="b194" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">导入数据集:</h1><p id="ba44" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">不同的库可以用来导入数据集，我更喜欢Pandas，因为它最容易使用，并且在一个地方提供了很多数据操作。此外，pandas还集成了读取CSV的功能，使得数据导入任务变得轻而易举。</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="6a54" class="lp ju hi ll b fi lq lr l ls lt">import pandas as pd<br/>dataset = pd.read_csv('path_to_dataset/file_name.csv')</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/bebf16109ece4af6e567f6d68c263874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*0OqpMjAHAmkg1t0vA2T-vw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">示例数据集</figcaption></figure><h1 id="5de2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">分离因变量和自变量:</h1><p id="2c9d" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">我在以前的文章中已经写了一些，我在这里引用一下。</p><blockquote class="lv lw lx"><p id="6f1f" class="if ig ly ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated">简单来说，因变量是那些你需要预测的变量，自变量是我们用来预测因变量的变量。这些需要分开，因为只有独立变量需要传递到网络，而从属变量需要计算它们与网络预测值之间的差异(损失)</p></blockquote><p id="61fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照惯例，自变量被命名为‘X’，因变量被命名为‘y’。现在，考虑到因变量在最后n列…(本例中为1)，它的代码简单如下:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="1d20" class="lp ju hi ll b fi lq lr l ls lt">n = 1<br/>X = dataset.iloc[:, :-n].values<br/>y = dataset.iloc[:, -n].values</span></pre><p id="1acd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使不使用pandas，在python中提取行也很简单，但是提取列有点繁琐。Pandas ' ' iloc '方法更方便，也更容易实现。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mc"><img src="../Images/eebe828dd6e253d8ff65bba77b3a26e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6ykMbziRZeb1N_vRvhzHg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">分离因变量和自变量</figcaption></figure><h1 id="effe" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">处理缺失数据:</h1><p id="b499" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">很多时候，数据集可能会有一些缺失值。如果不处理这些缺失值，将会在拟合我们的模型/训练时导致错误。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es md"><img src="../Images/487f89a927583210aa3fc9a199dc11df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/1*LUNygKOeRy73mc3nSbjh2g.gif"/></div></figure><h2 id="529e" class="lp ju hi bd jv me mf mg jz mh mi mj kd iq mk ml kh iu mm mn kl iy mo mp kp mq bi translated">丢失的值可以通过以下任一方法处理</h2><ul class=""><li id="6075" class="kr ks hi ih b ii kt im ku iq kv iu kw iy kx jc ky kz la lb bi translated">丢弃缺少值的行。</li><li id="7c4c" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">填补(或估算)缺失的值。</li></ul><h2 id="c433" class="lp ju hi bd jv me mf mg jz mh mi mj kd iq mk ml kh iu mm mn kl iy mo mp kp mq bi translated">丢弃行:</h2><p id="a5ed" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">在大多数情况下，丢弃行是不可取的，因为用于训练的数据大小将会减少，而且，如果数据集的属性是平衡的(例如，如果每个类的条目数相等)，删除行将导致数据不平衡，并且您稍后训练的模型可能会有偏差。</p><p id="4526" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在极少数情况下，您确实需要删除行，这可以在pandas中通过“dropna”函数来完成:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="5f3b" class="lp ju hi ll b fi lq lr l ls lt">dataset.dropna(inplace=True)</span></pre><h2 id="5436" class="lp ju hi bd jv me mf mg jz mh mi mj kd iq mk ml kh iu mm mn kl iy mo mp kp mq bi translated">填充(或输入)缺失值:</h2><p id="41a7" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">填充丢失的值是删除行的更好的替代方法。这些值可以用各种方法填写，最常用的方法是用该列的平均值代替。</p><p id="9274" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方法一:使用熊猫</strong></p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="4081" class="lp ju hi ll b fi lq lr l ls lt">dataset.fillna(dataset.mean(), inplace=True)</span></pre><p id="a046" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方法二:使用sklearn </strong></p><p id="0e70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我更喜欢使用sklearn，因为在这里你可以指定要替换什么值(可能是NaN或其他)以及替换所用的技术。正如我提到的，最常见的是用mean替换，但也使用了其他技术，如用mode或median替换，并且可以在sklearn中实现。(在策略参数中指定)</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="a5eb" class="lp ju hi ll b fi lq lr l ls lt">import numpy as np<br/>from sklearn.impute import SimpleImputer</span><span id="2770" class="lp ju hi ll b fi mr lr l ls lt">imputer = SimpleImputer(missing_values=np.nan, strategy='mean')<br/>start = 1<br/>end = 3</span><span id="0cd5" class="lp ju hi ll b fi mr lr l ls lt">imputer.fit(X[:, start:end])<br/>X[:, start:end] = imputer.transform(X[:, start:end])</span></pre><p id="657f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我想填充第2到第3列中缺少的值，索引从0开始，所以我将start设为1，end索引为exclusive，所以end设为3</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ms"><img src="../Images/7f472e7396f3d337fab7f1d43fc436d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7uF0CdJZyjsGoJxvW5fGw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">处理缺失数据</figcaption></figure><h1 id="ff69" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">编码分类数据:</h1><p id="96d8" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">既然我们已经恰当地处理了缺失数据，那么是时候处理分类数据了。</p><p id="b29d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到数据集中的第一列是分类的(它在几个类别中取值)，本质上不是数字。这样的属性需要被转换成数字，以便在项目的下一阶段我们的模型可以很容易地解释它。</p><h2 id="be88" class="lp ju hi bd jv me mf mg jz mh mi mj kd iq mk ml kh iu mm mn kl iy mo mp kp mq bi translated">一个热门编码:</h2><p id="7fb9" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">一个Hot编码器接受属性的所有离散类别，并将这些列添加到数据中，每个类别一列。对于该列，类别的存在由值“1”指示。(例如:对于当前数据，第一列中有3个不同的国家，因此一个热编码器将向数据添加3列，一列为法国，一列为西班牙，一列为德国)</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="9662" class="lp ju hi ll b fi lq lr l ls lt">from sklearn.compose import ColumnTransformer<br/>from sklearn.preprocessing import OneHotEncoder</span><span id="036b" class="lp ju hi ll b fi mr lr l ls lt">ct = ColumnTransformer(transformers=[('encoder', OneHotEncoder(), [0])], remainder='passthrough')</span><span id="0220" class="lp ju hi ll b fi mr lr l ls lt">X = np.array(ct.fit_transform(X))</span></pre><p id="0f0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您在项目中使用Tensorflow，您还可以使用tf.one_hot()函数来获得相同的结果。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mt"><img src="../Images/9fa309f0c07b14e389aea1677a0abb08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sD9K2KMhzZhDEeD-WTVMMQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">编码分类数据</figcaption></figure><h2 id="be93" class="lp ju hi bd jv me mf mg jz mh mi mj kd iq mk ml kh iu mm mn kl iy mo mp kp mq bi translated">标签编码器:</h2><p id="4388" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">如果分类变量是二进制的，或者由于某种原因不能增加列数，可以使用标签编码器。Label encoder通过获取离散属性的数量并为每个属性分配一个数字，将名义属性转换为数字属性。</p><p id="a9b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，这里的因变量是二进制的，所以如果使用标签编码器，则“否”将被转换为0，“是”将被转换为1。(对于更多类别，标签编码器将分配下一个数字，即2、3、4等)。</p><p id="56e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在直觉上对我们更有意义，因为在一个热编码中添加列似乎是多余的，但在实践中，<strong class="ih hj">一个热编码实际上比标签编码更受欢迎。</strong>这是因为ML算法将数值属性视为值的<strong class="ih hj">，这意味着它将认为标签为4的属性比标签为3的属性更有价值(如4 &gt; 3)，尽管实际上两者具有同等的重要性。</strong></p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="269b" class="lp ju hi ll b fi lq lr l ls lt">from sklearn.preprocessing import LabelEncoder<br/>le = LabelEncoder()<br/>y = le.fit_transform(y)</span></pre><p id="cdaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在二进制属性的情况下，标签编码器是优选的，因为只有1和0将是标签，并且没有必要为此添加列。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mu"><img src="../Images/625a8e40589449ea2058625bc97137c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3WNkYG4xRt_VavwD6N8RpA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">标签编码</figcaption></figure><h1 id="b3da" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">拆分数据(训练集和测试集) :</h1><p id="7193" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">同样，我在以前的文章中已经写了一些，我在这里引用一下。</p><blockquote class="lv lw lx"><p id="e63b" class="if ig ly ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated">我们将在某些数据上训练我们的网络。测试决定了我们的模型在现实世界中的工作。考虑一个例子，你学了一个新单词，你的老师给了你一个在句子中使用它的例子。现在，为了表明你已经理解了那个单词的意思，你必须在另一个句子中使用它，在同一个句子中使用它是没有用的。同样，用训练模型的相同数据来测试我们的模型是没有用的。因此，我们分割数据集，并保留其中的一部分进行测试，这将为我们提供一个真实的估计，即模型在以前看不到的数据上工作得有多好。</p></blockquote><p id="1147" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，让我们继续看代码…</p><p id="fead" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">sklearn提供了将数据分成训练集和测试集的最简单的方法，它只需要两行代码。它需要的一个参数是测试集的大小。这表示您想要用作测试集的数据部分。(例如:test_size=0.2将在测试集中保留20%的数据。)</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="d766" class="lp ju hi ll b fi lq lr l ls lt">from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 1)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mv"><img src="../Images/7466307e1ef9425a2c65a01f4474a69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpYTCfaEcvp-o8wr99uDfg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">列车测试分离</figcaption></figure><h1 id="0c80" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">特征缩放:</h1><p id="69de" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">我们几乎完成了…最后一部分是功能缩放。如您所见，训练集中的最后两个属性是数字。同样，由于是数值型的，ML算法将赋予具有较高值的属性更多的重要性，在这种情况下，salary属性的值以千为单位，而age小于100，因此要消除这种偏差并赋予所有属性同等的重要性(归一化)，特征缩放是必不可少的。</p><p id="efa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要素缩放将数字属性调整到通用比例(通常为-1到+1)</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="939e" class="lp ju hi ll b fi lq lr l ls lt">from sklearn.preprocessing import StandardScaler<br/>sc = StandardScaler()<br/>start = 3<br/>X_train[:, start:] = sc.fit_transform(X_train[:, start:])<br/>X_test[:, start:] = sc.transform(X_test[:, start:])</span></pre><p id="3135" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第3列和第4列必须进行缩放，因此开始索引设置为3，没有结束索引表示所有列的其余部分都要考虑。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mw"><img src="../Images/3bd5e5085a5f120c7ac963f1b4d1ec1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asTTkSrzbtRmkgbQ-jeUiA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">特征缩放</figcaption></figure><p id="03c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样…我们已经预处理了我们的数据，现在准备在我们的ML/DL应用程序中使用它。</p><h1 id="758c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">总结:</h1><ul class=""><li id="8b62" class="kr ks hi ih b ii kt im ku iq kv iu kw iy kx jc ky kz la lb bi translated"><strong class="ih hj">导入数据集</strong> <strong class="ih hj"> : </strong>加载数据集。用熊猫(read_csv)。</li><li id="c52d" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">分离变量</strong> <strong class="ih hj"> : </strong>因变量和自变量。使用熊猫(iloc)。</li><li id="ac5c" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">缺失值:</strong>删除或填充。使用sk learn(simple imputr)。</li><li id="2b98" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">编码分类数据:</strong>一个热编码或标签编码器。用sklearn。</li><li id="52da" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">拆分数据:</strong>训练集和测试集。使用sklearn(train_test_split)。</li><li id="6963" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">特征缩放:</strong>归一化属性。使用sklearn(标准定标器)</li></ul><p id="5a24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您阅读我的文章。觉得有用就鼓掌。</p><h1 id="826a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">另请参阅:</h1><div class="mx my ez fb mz na"><a href="https://link.medium.com/j2on2UYdK7" rel="noopener follow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">入门:深度学习项目</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">深度学习(DL)在过去几年里受到了一些严重的影响，我们许多人都对这些感兴趣…</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">link.medium.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no jn na"/></div></div></a></div><div class="mx my ez fb mz na"><a rel="noopener follow" target="_blank" href="/@rohanhirekerur/image-processing-pipeline-for-ml-dl-projects-in-python-2d2438e6621b"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">Python中ML/DL项目的图像处理管道</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">卷积神经网络(CNN)正在迅速普及，并被应用于各种图像处理</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">medium.com</p></div></div><div class="nj l"><div class="np l nl nm nn nj no jn na"/></div></div></a></div><p id="2b85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">资源:</p><p id="4cba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据集和代码:<a class="ae nq" href="https://github.com/Rohan-Hirekerur/Data-Processing" rel="noopener ugc nofollow" target="_blank">查看我的GitHub库</a></p><h1 id="0845" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">更多关于我的信息，请访问:</h1><h2 id="23e0" class="lp ju hi bd jv me mf mg jz mh mi mj kd iq mk ml kh iu mm mn kl iy mo mp kp mq bi translated">GitHub:</h2><div class="mx my ez fb mz na"><a href="https://github.com/Rohan-Hirekerur" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">Rohan-Hirekerur -概述</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">在GitHub上注册你自己的个人资料，这是托管代码、管理项目和构建软件的最佳地方…</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">github.com</p></div></div><div class="nj l"><div class="nr l nl nm nn nj no jn na"/></div></div></a></div><h2 id="e68c" class="lp ju hi bd jv me mf mg jz mh mi mj kd iq mk ml kh iu mm mn kl iy mo mp kp mq bi translated">LinkedIn:</h2><p id="b492" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">www.linkedin.com/in/rohan-hirekerur<a class="ae nq" href="http://www.linkedin.com/in/rohan-hirekerur" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="ecc6" class="lp ju hi bd jv me mf mg jz mh mi mj kd iq mk ml kh iu mm mn kl iy mo mp kp mq bi translated">推特:</h2><p id="dfbb" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">【https://twitter.com/Youthful96 T4】</p></div></div>    
</body>
</html>