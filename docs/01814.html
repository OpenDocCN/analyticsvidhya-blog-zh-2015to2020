<html>
<head>
<title>From Pseudocode to Python code: K-Means Clustering, from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从伪代码到Python代码:K-Means聚类，从零开始</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/from-pseudocode-to-python-code-k-means-clustering-from-scratch-2e32aa469bef?source=collection_archive---------3-----------------------#2019-11-15">https://medium.com/analytics-vidhya/from-pseudocode-to-python-code-k-means-clustering-from-scratch-2e32aa469bef?source=collection_archive---------3-----------------------#2019-11-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/498273d4a11bda658b401bdf53fa6998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzUQg7-GnxXeJBSKaINAcQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">情节和设计:e .鲍彻</figcaption></figure><div class=""/><p id="4155" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在数据科学的多学科领域，作为一名新手准备面试可以很容易地暴露出你知识库中需要重新访问、加强和/或扩展的领域。面试准备过程中的一个分支是做“带回家的任务”。如果你有导师，他们可以给你提供几个，如果没有，你可以在网上搜索任务，那里有很多可以找到。不过，一定要挑战自己，挑一些让你感觉有点不舒服的任务。这样你就能很好地挑战你的知识库。</p><p id="3e8f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为他们的学生提供毕业后支持，HyperionDev  确实会带你经历这个过程，并在这个过程中的某个地方为你提供带回家的挑战。我接受了从零开始编写K-Means聚类算法的任务，并通过各种练习返回基于数据集应用的某些推论。虽然伪代码很简单，但将其翻译成编程代码却是另一回事。接到这个任务后，我想在不研究互联网上的任何例子的情况下从头开始编写算法，而仅仅利用伪代码和我的Python知识(我在互联网上搜索了一些Python相关问题的答案)。这篇文章，将向你展示这一点；我对无监督机器学习算法的解释，Python编程语言中的K-Means聚类。</p><p id="b019" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于有各种可用的聚类算法，每种算法都有自己的标准来执行数据划分。K-Means作为划分聚类算法也不例外，简单来看一些是怎么定义算法的。</p><p id="a6c5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于<a class="ae js" href="https://en.wikipedia.org/wiki/K-means_clustering" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">的K-Means聚类定义的一部分在维基百科</strong> </a>中指出<em class="jt">“K-Means聚类旨在将</em><strong class="iw hy"><em class="jt">【n’</em></strong><em class="jt">个观察值划分为</em><strong class="iw hy"><em class="jt">【K’</em></strong><em class="jt">个聚类，其中每个观察值属于具有最近均值的聚类，作为聚类的原型。”</em>。</p><p id="ac4a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我的《带回家》一书的作者本杰明·穆雷尔指出:</p><p id="f631" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt">“k-means算法背后的关键假设:</em></p><p id="7150" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt"> 1)每个聚类的中心是属于它的所有数据点的平均值(因此得名“k-means”)。</em></p><p id="e25b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt"> 2)每个数据点属于中心点最近的聚类。</em></p><p id="9458" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jt">这两个假设其实足以描述整个算法。k-means算法所做的只是迭代两步，每一步都试图满足其中一个条件！"</em></p><p id="76d3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，为了将每个数据点分配到最近的聚类质心/均值，必须进行数据点和每个聚类质心之间的距离测量。根据测量方法，在此过程中，每个数据点被分配到一个聚类中。虽然有一些不同的距离度量可用，并且它们对聚类的影响也不同(有关更多信息，请参见https://arxiv.org/pdf/1405.7471<strong class="iw hy">的白皮书)，但我被指示在这个特定的任务中使用欧几里德距离度量。两个数据点之间的欧几里德距离测量非常简单。你取两个数据点的平方差之和的平方根。这是x，y平面上两个数据点之间的最短距离。然后，利用该距离度量，将数据点分配给具有最短度量的聚类平均值。</strong></p><figure class="jv jw jx jy fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ju"><img src="../Images/7b2b11fa6d881205818bfa9634286152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrJTQbgJm4GDSUI0K-ws3Q.jpeg"/></div></div></figure><p id="faae" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，让我们继续将算法应用于我们的问题，它的概要和实际编码。我们的问题包含一个数据集，该数据集由世界上两个国家的两个数据集组成，分别包含1953年和2008年的“出生率”和“预期寿命”统计数据。我们希望通过K-Means聚类并使用欧几里德距离作为其距离度量，来了解国家如何根据用户指定的聚类数<em class="jt">“K”</em>以及用户指定的迭代次数聚类在一起。最后要做到类内相似度高，类间相似度低。</p><p id="a059" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我必须编写一个将数据集读入内存的函数。为此，我使用Pandas作为导入的库之一。下面我包括了这个函数的快照，以及我在这个任务中使用的所有导入，每个导入旁边都有一个注释，说明它的用例。</p><figure class="jv jw jx jy fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jz"><img src="../Images/1eb3d9b436fbdf6e956109aa4b65debb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1Ltu-_lQy8PIbxiLZkqnQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">导入和CSV文件读取功能</figcaption></figure><p id="5464" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了正确初始化算法，这也允许将每个数据点分配到其最近的聚类，必须指定从我们的数据集中随机选择的多个质心。质心的数量也是由算法形成的聚类<em class="jt">“k”</em>的数量，并且如前所述由用户指定。</p><p id="4e7f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该算法还必须在数据中迭代一定次数(也由用户指定),然后才能收敛，找到一组稳定的值，使质心不再移动。对于上述所有内容，我包括下面的代码。注意，通过将<strong class="iw hy"> read_csv_pd() </strong>函数赋给一个变量，我可以很容易地将数据转换成一种我可以在各种情况下使用的格式。</p><figure class="jv jw jx jy fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ka"><img src="../Images/5686636e78cd4467da356c1f5dcad078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i5XFZmCHwqrWs44lB6PyNw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">将CSV读取功能分配给变量。创建用户输入和随机质心。</figcaption></figure><p id="9ca8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在再次引用我们的距离度量，我需要写一个函数来计算两个数据点之间的欧几里德距离。这个函数接收两个参数，上一步中建立的质心<em class="jt"> (cent) </em>，以及我们的数据集<em class="jt">【x】</em>的数据点(<em class="jt"> data_points) </em>，我通过index调用它(显示在assign _ to _ cluster _ mean _ centroid()函数中)。below函数迭代地将数据集中每个数据点和每个质心之间的欧几里德距离追加到一个列表中，然后返回它。</p><figure class="jv jw jx jy fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kb"><img src="../Images/b7183d94a79f3ab5167cc3bdc73d0e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpskbaaB9bKSYNbJwNIWNw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">计算两个数据点之间的距离函数</figcaption></figure><p id="6c2a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有了距离列表，我们现在必须创建聚类，我们可以根据计算的最小欧几里得距离(从返回的列表中提取)将属于每个聚类的所有数据点附加到这些聚类中。一旦分配了所有的数据点，还必须用新计算的每个聚类的平均值重写质心。让我们快速浏览一下这个函数(如下所示)。</p><p id="36e2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该函数接收三个参数；a)保存所有数据点和国家名称的数据框<em class="jt">“x”</em>，b)用户指定的<em class="jt">“质心”</em>和c)值<em class="jt">“k”</em>。该函数首先对由<strong class="iw hy"> distance_between() </strong>函数生成并返回的列表进行整形。这是因为我们返回的列表保存了每个数据点和每个质心之间的所有距离测量值。这使得它在实例数量上大于我们的数据集中找到的实例数量。我们希望从列表中提取数据点和任意质心之间的最短距离，以及它的索引。索引值将告诉我们特定数据点属于哪个聚类。这是在第一个“for”循环中完成的，在这个循环中，我们向两个列表添加各自的值。我们将最小距离添加到<em class="jt">“distance _ min[]”</em>列表(如果稍后可能需要该列表)中，并将其索引添加到<em class="jt">“data point _ cen[]”</em>列表中。在将索引值追加到列表中时，我添加+1的原因是我已经将它标准化了，以便返回的集群编号从1开始，而不是从0开始。</p><p id="93bb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">函数中接下来的两个“for”循环负责创建聚类本身，还负责将每个数据点分配给相关的聚类。最后一个“for”循环根据每个聚类计算的新平均值重写质心。然后打印出新分配的质心。</p><figure class="jv jw jx jy fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kc"><img src="../Images/35ded81d21cbfda3893f0414c4637758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4l4z9_yVkhGNWK-VGxHthQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">给每个聚类分配数据点并重写质心函数。</figcaption></figure><p id="f0fd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们进入将所有函数和算法片段集合在一起的主循环之前，我已经在编码过程中决定在主循环开始之前打印出一个散点图。该散点图显示了在进行任何距离测量计算或数据点分配之前，具有随机选择的质心的数据点。</p><figure class="jv jw jx jy fd hk er es paragraph-image"><div class="er es kd"><img src="../Images/9d2316717cb6c71735619a7018b65347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*9nwKZmGvRtlyqXmsN4eGTg.png"/></div></figure><p id="3636" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我在这里包括情节，然后没有代码。您可以在本文末尾找到我的GitHub资源库的链接，python文件中的完整代码将存放在这个资源库中。如我们所见，随机质心启动是成功的。现在我们进入K-Means聚类算法的主循环。</p><p id="6a86" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面，主循环的第一部分。这里，我将<strong class="iw hy">assign _ to _ cluster _ mean _ centroid()</strong>函数赋给一个变量，因为我想在同一个循环中分别调用它的两个返回值。如果我不这样做，函数将在一个循环中执行两次，使它不精确到用户指定的迭代次数。除此之外，循环部分还创建了一个数据框，其中包含两个变量“出生率”和“预期寿命”以及两个额外的列，一个用于每个国家所属的聚类，另一个用于国家本身。请注意我是如何通过索引调用数据的。该循环还返回以下三个推论:</p><ol class=""><li id="f7f9" class="ke kf hx iw b ix iy jb jc jf kg jj kh jn ki jr kj kk kl km bi translated">每组国家的数量，</li><li id="3f5c" class="ke kf hx iw b ix kn jb ko jf kp jj kq jn kr jr kj kk kl km bi translated">每组的国家清单和</li><li id="8646" class="ke kf hx iw b ix kn jb ko jf kp jj kq jn kr jr kj kk kl km bi translated">集群的意思是。</li></ol><figure class="jv jw jx jy fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ks"><img src="../Images/13353110fecf1189ce5d5e37f704dc59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqMmsj5ACMJxt6iaifiUJg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">主循环，第1部分</figcaption></figure><p id="887e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">循环的其余部分返回打印的总距离。该总距离是通过将每个数据点与其相关聚类平均值之间的所有平方距离相加来计算的。在算法的收敛中，总距离应该以低于第一次迭代的总距离的数字结束。循环中的最后一部分还生成了用颜色显示不同编号的簇及其质心的图。参见下面的代码。</p><figure class="jv jw jx jy fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kt"><img src="../Images/fce99a39065f765c62f5a50fea66be07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k81DqtXpjDDjIhzMhDP3UA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">主循环，第2部分</figcaption></figure><p id="1481" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好了，我们的算法可以执行了！我们将使用4个聚类和12次迭代来运行该算法。注意，随着循环的重复，每个数据点和每个聚类均值之间的距离测量在每次迭代时进行。这就是如何将数据点重新分配到不同的聚类，以及如何重新计算每个聚类的平均值并将其指定给相关的质心。</p><p id="4932" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在花时间多次运行该算法的过程中，除了打印的推论之外，我还做了一些有趣的观察。当我被告知注意哪些国家聚集在一起，以及一些国家如何从一个集群转移到下一个集群时，我注意到一件事；位于聚类边缘的国家比靠近特定聚类的中心或均值的国家更倾向于移动到下一个。然而，这个观察结果取决于质心从开始到结束移动的量(因为它们是随机选择的)。该观察还排除了数据集外部的聚类的外边缘，在这种情况下，聚类3和2的外边缘。我最后还注意到，当涉及到“出生率”和“预期寿命”的可变值时，处于某个值范围内的国家往往最终会出现在相同的集群中。尽管每个聚类中这些对的值范围不相等。这种分析符合我们所说的最终应该达到的目标，即高的类内相似度和低的类间相似度。如果您有一个在数据中寻找这些特征的数据集，K-Means聚类是一个很好的划分研究，可以帮您完成这个任务。请参见最终迭代的下图，该图显示了四个聚类和确定为值2220.0的总距离。</p><figure class="jv jw jx jy fd hk er es paragraph-image"><div class="er es ku"><img src="../Images/b408c136d6392d05b5c936a4b946d887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*07ra_2sMuuJ8gwBsNkg1FA.png"/></div></figure><p id="6ac1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对我来说，代码构造的一个很好的检查点是查看每次迭代后打印出来的平均值(记为“推论3”)是否与新计算的质心匹配，因为它们是同一个东西。然而，它们的编码路径是不同的。我在下面列出了最后一次迭代的质心和聚类平均值的最终打印结果。</p><p id="7461" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我们所见，它们是完全相同的:)。</p><pre class="jv jw jx jy fd kv kw kx ky aw kz bi"><span id="8bbe" class="la lb hx kw b fi lc ld l le lf">ITERATION: 12<br/>Centroids for this iteration are:<br/>[[39.055540816326534, 55.145112244897966], <br/>[47.2816907216495, 40.28537649484538], <br/>[13.258812499999998, 76.31897916666664], <br/>[23.438574257425735, 67.88712871287129]]</span><span id="14b9" class="la lb hx kw b fi lg ld l le lf">AVERAGES: <br/>        Birth Rate  Life Expectancy<br/>label                             <br/>1       39.055541        55.145112<br/>2       47.281691        40.285376<br/>3       13.258812        76.318979<br/>4       23.438574        67.887129</span></pre><p id="d587" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要自己尝试算法并进行观察，请访问我的GitHub知识库<a class="ae js" href="https://github.com/EtienneBauscher/K-Means-Clustering/tree/master" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">这里</strong> </a>。我为您提供了三个不同的数据集和python程序文件。您所要做的就是将这些文件复制到您计算机上的本地驱动器，并相应地设置路径和文件名，然后运行程序文件(确保您已经安装了所有的依赖项)。要修改的代码是下面一行。</p><pre class="jv jw jx jy fd kv kw kx ky aw kz bi"><span id="eccc" class="la lb hx kw b fi lc ld l le lf">x = read_csv_pd("SET YOUR PATH HERE", "CALL THE DATASET FILE HERE THAT YOU WANT TO RUN.")</span></pre><p id="fac1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面的短片展示了该算法在4个聚类中12次迭代的收敛性，以及它如何确定提供高类内相似性和低类间相似性的值。</p><p id="6f0e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下次再见，科学快乐，黑客快乐！</p><p id="9130" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">问候，艾蒂安</p><figure class="jv jw jx jy fd hk"><div class="bz dy l di"><div class="lh li l"/></div></figure></div></div>    
</body>
</html>