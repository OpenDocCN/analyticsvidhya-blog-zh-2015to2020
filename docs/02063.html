<html>
<head>
<title>Leetcode: Q70 — Climbing Stairs [Easy]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leetcode: Q70 —爬楼梯[简单]</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/leetcode-q70-climbing-stairs-easy-444a4aae54e8?source=collection_archive---------2-----------------------#2019-11-28">https://medium.com/analytics-vidhya/leetcode-q70-climbing-stairs-easy-444a4aae54e8?source=collection_archive---------2-----------------------#2019-11-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d1c4fa23f83061dcbbf88092d8253c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ixwy9IpiPqEG9ydM_VH6AA.png"/></div></div></figure><figure class="ir is it iu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es iq"><img src="../Images/6907bd3b984e3cb316f5364165b6e11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9m5pR0qZfeYN2hOMlPsnfQ.png"/></div></div></figure><h1 id="ee73" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">分析:</h1><p id="7ea6" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">基本上，这个问题是要求你找到所有可能的组合，这些组合将带你到达顶峰，同时限制你一次只能爬1步或2步。因此，在每一个阶段，你要么选择踩下它，要么跳过它，这就是动态编程的原理。</p><p id="f065" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在让我们看一些例子，看看我们是否能找到一种模式。</p><p id="9780" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">例1: 1步</strong></p><p id="ddb4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">当你只有一步的时候，你只能以一种方式到达顶端，那就是从一楼到一楼。</p><figure class="ir is it iu fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/6ccf2d587e144976658aa88b5de88266.png" data-original-src="https://miro.medium.com/v2/resize:fit:190/format:webp/1*iFIHhcd-GD-pE9EKIC0fgg.png"/></div></figure><p id="3832" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">例2: 2步骤</strong></p><p id="d054" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果你有两个步骤，你可以通过0–1–2或0–2直接到达顶端，因此有两条路径。</p><p id="a6cd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">你从0开始，你有两个选择，要么迈出第一步，要么不迈出第一步。如果你决定迈出第一步，你会走到第一步，然后你必须迈出下一步，这一步会把你带到顶端，在这种情况下是第二步。这给了你第一种方法。</p><p id="5444" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在回到如果你决定不采取第一步。在这种情况下，你直接跳到第2步，这将给你另一种方法。</p><figure class="ir is it iu fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/cfabb661a5ba02d5f071e53393e65587.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*ngnQsMkJ8tD7hkBPR5gJMA.png"/></div></figure><p id="76ec" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">例3: 3步</strong></p><p id="eeda" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">让我们看看你什么时候有三个步骤。你从0开始，你有两个选择，要么进行第一步，要么不进行。如果你决定迈出第一步，接下来你必须为第二步做出同样的决定。要么采取第二步，要么不采取。如果你做了第二步，你的下一步是第三步，这是一条路。</p><p id="c972" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果你决定不走第二步，你可以直接跳到第三步，因为你可以一次走两步，这是你的第二条路。</p><p id="91a4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">第三条路径是当你决定跳过第一步时，直接跳到第二步，然后再跳到第三步。</p><figure class="ir is it iu fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/aa7c8089b59c986fba9fab44398a45b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*w0VpXZ1yAW8uSTLqpXUwzg.png"/></div></figure><p id="108f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">例4: 4步</strong></p><p id="56af" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">让我们再看一个例子。通过对示例1-3进行类似的分析，我们可以推断出您可以通过5种不同的方式到达第4步的顶端。</p><figure class="ir is it iu fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/f63da7b3ef6d0970d5a228c27c9d9198.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*j7BHVqN4h2Yd3mHUx8vqyw.png"/></div></figure><p id="37a0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">我们在这里注意到的模式是，n是(n-1)和(n -2)的和。这是斐波那契数列！</strong></p><h1 id="b5c1" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">解决方案1:带记忆的递归——时间:O(n)，空间:O(n)</h1><p id="a84c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在这个解决方案中，我们将定义一个散列表来存储我们计算的值，这样我们就不必再次重新计算它们(记忆的概念)。</p><p id="ae01" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们已经创建了一个助手函数来进行递归调用。</p><p id="dfe6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们的基本情况是n == 1，我们返回1，n == 2，我们返回2。</p><figure class="ir is it iu fd ij er es paragraph-image"><div class="er es la"><img src="../Images/bca88d741e91258b1430396590a32a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*NovchAIXh6aySubz2bpWnA.png"/></div></figure><p id="62b4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">由于记忆，这个解的时间复杂度是O(n)。</p><p id="9859" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">由于递归堆栈的使用，该解决方案的空间复杂度也是O(n)。</p><p id="ac73" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">运行时间:1 ms，比爬楼梯的Java在线提交快100.00%。</p><p id="4672" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">内存使用:33.2 MB，不到爬楼梯Java在线提交的5.26%。</p><h1 id="81b3" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">解决办法2:自下而上的方法，使用变量——时间O(n ),空间O(1)</h1><p id="a0c1" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在这个解决方案中，我们将尝试利用自底向上的方法，这样我们可以将空间复杂度从O(n)降低到O(1)。这里我们只需要三个变量和一个for循环。</p><figure class="ir is it iu fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/63fc891a6d61648bbcf793da8ef71d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*j42sGfb1jhGrinvvi7K5WA.png"/></div></figure><p id="d2c6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个解的时间复杂度是O(n)。</p><p id="5c4b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个解的空间复杂度是O(1)。</p><p id="4a05" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">尽管您可能会注意到LeetCode的内存使用结果没有显示出改进，但就复杂性而言，从O(n)到O(1)有很大的改进。</p><p id="b2da" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">运行时间:0 ms，比爬楼梯的Java在线提交快100.00%。</p><p id="9204" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">内存使用:33.1 MB，不到爬楼梯Java在线提交的5.26%。</p><h1 id="a577" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">解决方案3:使用矩阵乘法，Binets方法—时间:O(logn)，空间:O(1)</h1><p id="c8ba" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">LeetCode确实展示了一个使用矩阵乘法将时间减少到O(logn)的解决方案，但在我看来，这样的解决方案不会被访问者所期望，因为这些是数学概念，而不仅仅是编程。</p><p id="98bc" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">更多详情请访问Leetcode网站。</p><p id="df67" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">* *以下解决方案来自LeetCode，发布在此以供参考。</p><figure class="ir is it iu fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/9da43b35f1eeeeddbaf844e5f05f1cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*E-XS21yURKsChjBtj4MRLg.png"/></div></figure><p id="e92d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个解决方案的时间复杂度是O(logn ),因为我们只遍历logn位。</p><p id="6a0b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个解的空间复杂度是O(1)。</p><p id="fc1d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">运行时间:0 ms，比爬楼梯的Java在线提交快100.00%。</p><p id="9c5a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">内存使用:33 MB，不到爬楼梯Java在线提交的5.26%。</p><h1 id="a4bd" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">解决方案4:使用公式—时间:O(1)，空间:O(1)</h1><p id="2563" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">LeetCode使用斐波那契数公式展示了一个更加优化的解决方案，在我看来，面试官不会期望你知道这个，因为它是纯数学的。如果他们真的在寻找这个解决方案，他们可能会帮你解决这个问题。</p><p id="4e0b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">更多详情请参考LeetCode。</p><p id="9a31" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">* *以下解决方案来自LeetCode，发布在此以供参考。</p><figure class="ir is it iu fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/c4e3dae159f4df0039ddce76f628ff9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*0Na2fpu3mj5t901ccBCvrg.png"/></div></figure><p id="20ac" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个解的时间复杂度是O(1 ),因为我们只是使用一个公式。</p><p id="2360" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个解的空间复杂度也是O(1)。</p><p id="7d1e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">运行时间:0 ms，比爬楼梯的Java在线提交快100.00%。</p><p id="05b2" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">内存使用:33.2 MB，不到爬楼梯Java在线提交的5.26%。</p></div></div>    
</body>
</html>