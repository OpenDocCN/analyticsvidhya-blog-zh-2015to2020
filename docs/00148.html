<html>
<head>
<title>Polyaxon, Argo and Seldon for Model Training, Package and Deployment in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Polyaxon、Argo和Seldon，用于在Kubernetes进行模型培训、打包和部署</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/polyaxon-argo-and-seldon-for-model-training-package-and-deployment-in-kubernetes-fa089ba7d60b?source=collection_archive---------0-----------------------#2018-10-16">https://medium.com/analytics-vidhya/polyaxon-argo-and-seldon-for-model-training-package-and-deployment-in-kubernetes-fa089ba7d60b?source=collection_archive---------0-----------------------#2018-10-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9497" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Kubernetes中模型管理开源框架的终极组合？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/f89c7679ef1938753d054df074b1c740.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*zfpdBfv2NWJIyM5K6r97XA.png"/></div></figure><p id="ae9b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">n最简单的形式，模型管理可以被看作是训练一个机器学习模型，然后用不同的数据、参数、特征和算法重复这个数十次、数百次或数千次，最终部署<em class="kb">“最佳”</em>的那个。一个更完整的定义是，模型管理涉及为数据科学家开发工具和管道，以进行开发、部署、测量、改进和迭代，以便他们不仅可以为一个特定问题，而且可以为更广泛的数据集和算法继续制作更好的模型。</p><p id="40f1" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">同时，模型管理包括更多传统应用的所有需求，例如API开发和版本控制、包管理、容器化、可再现性、规模、监控、日志等等。</p><p id="8e4d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">本文的目标是提出一个可重复的管道，使您的生活更容易，并使迭代更快。我认为这句话很好地抓住了精神。</p><blockquote class="kc kd ke"><p id="e1f0" class="jf jg kb jh b ji jj ij jk jl jm im jn kf jp jq jr kg jt ju jv kh jx jy jz ka hb bi translated">我们不部署一个模型，我们部署重复制造更多模型的过程。当您将一个ML模型部署到产品中时，您并不是说“这是最好的模型，我们应该永远使用它”。它实际上意味着为模型构建部署管道，并使其更具可重复性。</p><p id="e714" class="jf jg kb jh b ji jj ij jk jl jm im jn kf jp jq jr kg jt ju jv kh jx jy jz ka hb bi translated"><a class="ae ki" href="https://www.youtube.com/watch?v=Z7_AatHRXjI" rel="noopener ugc nofollow" target="_blank">T3】朱丽叶·侯格兰T5】</a></p></blockquote><h1 id="43cb" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">我们是怎么来到这里的</h1><p id="fa95" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">今年，我们看到了许多机器学习平台的崛起，就在<a class="ae ki" href="https://conferences.oreilly.com/strata" rel="noopener ugc nofollow" target="_blank"> Strata </a>，我们看到了从数据存储解决方案，到这些存储解决方案中的数据SQL引擎，到Spark，到数据科学平台，再到现在流行的机器学习平台的潮流变化。</p><p id="5c2f" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">就像谷歌发布了MapReduce和其他文件，供世界其他地方在Hadoop生态系统中遵循一样，谷歌和其他几家大型科技公司的工具也出现了，以解决机器学习问题。我甚至将这与两年前还很年轻的Kubernetes联系起来，现在它已经成为每个云提供商产品的重要组成部分。在这种情况下，不在<a class="ae ki" href="https://www.cncf.io/" rel="noopener ugc nofollow" target="_blank"> CNCF筹码</a>上下赌注是愚蠢的。Projects还包括<a class="ae ki" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>和最近的<a class="ae ki" href="https://www.kubeflow.org/" rel="noopener ugc nofollow" target="_blank"> KubeFlow </a>，后者提供了关于工具组合的更多指导。</p><p id="4eaa" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一个ML模型有很多不同的需求，对于开发/培训来说，你需要GPU，打包比JAR文件更复杂，因为没有一种语言可以用于所有事情，你需要Python，R以及用C和C++编写的其他部分。由于模型中包含大量数据，应用程序从几十Mb增加到+100 Mb。它们从基本上需要几毫秒的数据库操作的端点，发展到进行预测但需要更长时间执行、需要更多CPU和更多RAM的更智能的操作。</p><p id="20e6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">与此同时，传统的日志、监控、安全性、可伸缩性以及其他更传统的应用程序所具有的要求也是这些新型应用程序所需要的。如果您对网站的部分进行了A/B测试，现在您将对所有的ML模型进行A/B测试，以查看哪一个模型的性能更好。如果您扩展了一个节点web服务器，现在您需要扩展一个TensorFlow服务服务器，依此类推。同时，ML模型的开发也更加复杂，需要更多的时间，因为它需要测试算法、特征等等的组合。</p><p id="4435" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">与传统应用程序相比，您可以从ML中获得如此多的价值，但是您需要在许多领域进行巨大的投资。</p><h1 id="cdf5" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">这个实验</h1><p id="eafb" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">本文探索了模型管理的两种新技术的组合，以提供一个解决三组主要问题的管道:</p><ol class=""><li id="92f3" class="lg lh hi jh b ji jj jl jm jo li js lj jw lk ka ll lm ln lo bi translated">分布式超参数训练，也可用于实际的分布式训练:<a class="ae ki" href="https://polyaxon.com/" rel="noopener ugc nofollow" target="_blank">多轴</a></li><li id="a98b" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">使用<a class="ae ki" href="https://github.com/openshift/source-to-image" rel="noopener ugc nofollow" target="_blank"> s2i </a> : <a class="ae ki" href="https://applatix.com/open-source/argo/" rel="noopener ugc nofollow" target="_blank"> Argo </a>的容器映像构建管道</li><li id="1942" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">能够处理单一或更复杂部署的模型的部署:<a class="ae ki" href="https://www.seldon.io/" rel="noopener ugc nofollow" target="_blank"> Seldon </a></li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/e1481393a809a2f039564249f6ac11a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pra_tu7CmXP-w0Yrjnr8TQ.jpeg"/></div></div></figure><p id="b9f8" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最终的输出是一个ML管道，它训练多个模型，探索度量标准以(手动)挑选最好的，将模型打包为docker映像，并将其部署为REST API。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lz"><img src="../Images/45ecc5358df7391caabd2b8c728de469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wfgjmEv-YnkoeW90.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">工作流程图</figcaption></figure><p id="d29b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">所有需要遵循的代码都可以在这里找到:<a class="ae ki" href="https://github.com/danielfrg/polyaxon-argo-seldon-example" rel="noopener ugc nofollow" target="_blank">Daniel frg/polyaxon-Argo-seldon-example</a>。在本地，你只需要几个客户端CLI和克隆几个回购协议。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="1d54" class="mj kk hi mf b fi mk ml l mm mn">$ brew install kubectx<br/>$ brew install kubernetes-helm<br/>$ pip install polyaxon-cli<br/>$ brew install argoproj/tap/argo</span><span id="4d1e" class="mj kk hi mf b fi mo ml l mm mn">$ git clone https://github.com/danielfrg/polyaxon-argo-seldon-example.git<br/>$ git clone <a class="ae ki" href="https://github.com/SeldonIO/seldon-core.git" rel="noopener ugc nofollow" target="_blank">https://github.com/SeldonIO/seldon-core.git</a></span></pre><h1 id="83f4" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">基础设施和安装</h1><p id="4e40" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">这一节是每个项目文档的一个小参考，所以如果这里有什么不工作或者过时了，请务必阅读。</p><p id="3084" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">接下来的几节将介绍五个组件的安装和配置，我们将使用它们来构建模型部署管道:</p><ol class=""><li id="2fdd" class="lg lh hi jh b ji jj jl jm jo li js lj jw lk ka ll lm ln lo bi translated">库伯内特星团，</li><li id="0690" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">用于持久存储的NFS，</li><li id="31d4" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">用于分布式模型训练的Polyaxon，</li><li id="1aaa" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">Argo建立一个集装箱化工作流程模型，以及</li><li id="da4c" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">谢顿进行模型部署。</li></ol><p id="d024" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一旦我们安装和配置了这些组件，我们将从“Polyaxon:训练模型”一节开始训练、构建和部署一个模型。所以如果你想跳过所有的安装步骤，就去那里。</p><h1 id="7db8" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">库伯内特星团</h1><p id="3e9c" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">我使用的是GKE，但也可以是任何Kubernetes集群，要么使用GCP控制台，要么使用如下命令:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="2fc8" class="mj kk hi mf b fi mk ml l mm mn">$ gcloud beta container --project "&lt;project-name&gt;" clusters create "model-mgmt" --zone "us-central1-a" --cluster-version "1.10.7-gke.2" --machine-type "n1-standard-2" --image-type "COS" --disk-size "10" --num-nodes "3" --network "default"</span></pre><p id="d205" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">配置您的本地<code class="du mp mq mr mf b">kubectl</code>:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="5b70" class="mj kk hi mf b fi mk ml l mm mn">$ gcloud container clusters get-credentials model-mgmt --zone us-central1-a</span></pre><h1 id="c013" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">NFS:单节点文件服务器</h1><p id="f5a3" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">这是保存所有代码、模型和数据的地方。使用这个GCP <a class="ae ki" href="https://console.cloud.google.com/marketplace/details/click-to-deploy-images/singlefs" rel="noopener ugc nofollow" target="_blank">单节点文件服务器模板</a>创建一个超级容易。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es ms"><img src="../Images/50eca27f3b565b858e9e4c27317c0b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SELEw_d_SpuMYfmj.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">NFS服务器模板</figcaption></figure><p id="1077" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们需要在NFS服务器中创建几个目录，因此通过复制安装后屏幕中可用的命令或单击<em class="kb">“SSH to…”</em>按钮，SSH进入节点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es mt"><img src="../Images/7d4002ce7e0cebc337168d3c728040cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eRgYSL2ZnAXcZqS2.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">SSH进入NFS服务器</figcaption></figure><p id="29cf" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在实例中，稍后为Polyaxon和Jupyter实验室和Argo创建一些目录结构。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="8144" class="mj kk hi mf b fi mk ml l mm mn">$ cd /data<br/>$ mkdir -m 777 data<br/>$ mkdir -m 777 outputs<br/>$ mkdir -m 777 logs<br/>$ mkdir -m 777 repos<br/>$ mkdir -m 777 upload</span><span id="e3c1" class="mj kk hi mf b fi mo ml l mm mn">$ cd repos<br/>$ mkdir deployments/<br/>$ chmod 777 deployments/</span></pre><p id="b343" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用下面的命令获取NFS服务器的(私有)IP，或者在虚拟机的Google Cloud控制台上搜索。在我的例子中，它是<code class="du mp mq mr mf b">10.240.0.8</code></p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="329c" class="mj kk hi mf b fi mk ml l mm mn">$ gcloud compute instances describe polyaxon-nfs-vm --zone=us-central1-f --format='value(networkInterfaces[0].networkIP)'<br/>10.240.0.8</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es mu"><img src="../Images/2c1fae7c776fd162cb05220ec8ab5a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1hA-oSkgPuw0m9mD.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">查找NFS服务器IP</figcaption></figure><p id="c9d9" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后，为Polyaxon和其他要使用的工具创建一些PVC。<strong class="jh hj">注意</strong>您需要编辑<code class="du mp mq mr mf b">*-pvc.yml</code>文件并添加正确的IP地址:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="4da3" class="mj kk hi mf b fi mk ml l mm mn">$ cd &lt;polyaxon-argo-seldon-example repo&gt;<br/>$ cd gke/</span><span id="f453" class="mj kk hi mf b fi mo ml l mm mn"># And replace with the right ip address in all the files<br/>$ vi data-pvc.yml<br/>$ vi outputs-pvc.yml<br/>$ vi logs-pvc.yml<br/>$ vi repos-pvc.yml<br/>$ vi upload-pvc.yml</span><span id="6bdd" class="mj kk hi mf b fi mo ml l mm mn"># Create the k8s resources<br/>$ kubectl create namespace polyaxon<br/>$ kubens polyaxon<br/>$ kubectl apply -f data-pvc.yml<br/>$ kubectl apply -f outputs-pvc.yml<br/>$ kubectl apply -f logs-pvc.yml<br/>$ kubectl apply -f repos-pvc.yml<br/>$ kubectl apply -f upload-pvc.yml</span></pre><h1 id="8bd7" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">安装Polyaxon</h1><p id="a369" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">有了已经创建的PVC，基于文档安装它<a class="ae ki" href="https://docs.polyaxon.com/" rel="noopener ugc nofollow" target="_blank">就相对容易了。首先是tiller (helm server)服务帐户的一些权限。</a></p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="5b1b" class="mj kk hi mf b fi mk ml l mm mn"># Configure tiller to have the access it needs<br/>$ kubectl --namespace kube-system create sa tiller<br/>$ kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller<br/>$ helm init --service-account tiller</span><span id="d105" class="mj kk hi mf b fi mo ml l mm mn"># Add polyaxon charts<br/>$ helm repo add polyaxon https://charts.polyaxon.com<br/>$ helm repo update</span></pre><p id="1316" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们可以使用Helm启动Polyaxon，我们唯一需要的额外东西是一个<code class="du mp mq mr mf b">polyaxon-config.yml</code>配置文件并运行Helm:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="8246" class="mj kk hi mf b fi mk ml l mm mn">rbac:<br/>  enabled: <strong class="mf hj">true</strong></span><span id="820a" class="mj kk hi mf b fi mo ml l mm mn">ingress:<br/>  enabled: <strong class="mf hj">true</strong></span><span id="2abc" class="mj kk hi mf b fi mo ml l mm mn">serviceType: ClusterIP</span><span id="4725" class="mj kk hi mf b fi mo ml l mm mn">persistence:<br/>  logs:<br/>    existingClaim: polyaxon-pvc-logs<br/>  repos:<br/>    existingClaim: polyaxon-pvc-repos<br/>  upload:<br/>    existingClaim: polyaxon-pvc-upload<br/>  data:<br/>    data1:<br/>      existingClaim: polyaxon-pvc-data<br/>      mountPath: /data<br/>  outputs:<br/>    outputs1:<br/>      existingClaim: polyaxon-pvc-outputs<br/>      mountPath: /outputs</span><span id="1e94" class="mj kk hi mf b fi mo ml l mm mn">$ cd &lt;polyaxon-argo-seldon-example repo&gt;<br/>$ cd polyaxon</span><span id="40cb" class="mj kk hi mf b fi mo ml l mm mn">$ helm install polyaxon/polyaxon --name=polyaxon --namespace=polyaxon -f polyaxon/polyaxon-config.yml</span></pre><p id="13e8" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当该命令完成时，您将得到类似如下的内容:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="3eda" class="mj kk hi mf b fi mk ml l mm mn">Polyaxon is currently running:</span><span id="580e" class="mj kk hi mf b fi mo ml l mm mn">1. Get the application URL by running these commands:<br/>    export POLYAXON_IP=$(kubectl get svc --namespace polyaxon polyaxon-polyaxon-ingress -o jsonpath='{.status.loadBalancer.ingress[0].ip}')<br/>    export POLYAXON_HTTP_PORT=80<br/>    export POLYAXON_WS_PORT=80</span><span id="c43b" class="mj kk hi mf b fi mo ml l mm mn">    echo <a class="ae ki" href="http://$POLYAXON_IP:$POLYAXON_HTTP_PORT" rel="noopener ugc nofollow" target="_blank">http://$POLYAXON_IP:$POLYAXON_HTTP_PORT</a></span><span id="47ef" class="mj kk hi mf b fi mo ml l mm mn">2. Setup your cli by running theses commands:<br/>  polyaxon config set --host=$POLYAXON_IP --http_port=$POLYAXON_HTTP_PORT  --ws_port=$POLYAXON_WS_PORT</span><span id="580b" class="mj kk hi mf b fi mo ml l mm mn">3. Log in with superuser</span><span id="0fb8" class="mj kk hi mf b fi mo ml l mm mn">  USER: root<br/>  PASSWORD: Get login password with</span><span id="0514" class="mj kk hi mf b fi mo ml l mm mn">    kubectl get secret --namespace polyaxon polyaxon-polyaxon-secret -o jsonpath="{.data.POLYAXON_ADMIN_PASSWORD}" | base64 --decode</span></pre><p id="7cfe" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">所以执行这些指令并使用<code class="du mp mq mr mf b">polyaxon-cli</code>登录。默认的<code class="du mp mq mr mf b">username:password</code>对是:<code class="du mp mq mr mf b">root:rootpassword</code>:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="2130" class="mj kk hi mf b fi mk ml l mm mn">$ polyaxon login --username=root --password=rootpassword</span></pre><p id="49f8" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">您也可以访问打印的URL来访问Polyaxon UI。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es mv"><img src="../Images/65730107403d59097e9b8047b896e6cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S9_FoJVMS_grD1O4.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">多轴项目</figcaption></figure><h1 id="5ed0" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">安装Argo</h1><p id="6381" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated"><a class="ae ki" href="https://github.com/argoproj/argo/blob/master/demo.md" rel="noopener ugc nofollow" target="_blank">完整文档此处</a>(权限部分很重要)，基本上:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="53a4" class="mj kk hi mf b fi mk ml l mm mn">$ kubectl create ns argo<br/>$ kubectl apply -n argo -f https://raw.githubusercontent.com/argoproj/argo/v2.2.1/manifests/install.yaml<br/>$ kubectl create rolebinding default-admin --clusterrole=admin --serviceaccount=default:default<br/>$ kubectl patch svc argo-ui -n argo -p '{"spec": {"type": "LoadBalancer"}}'</span></pre><p id="8c53" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，我们可以通过几个工作流访问Argo用户界面，如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es ms"><img src="../Images/657dbf8039377ed9b417db9e0f38edc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vnz8Moo359WzbqoH.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">Argo工作流</figcaption></figure><h1 id="bd7c" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">安装Seldon</h1><p id="f502" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">有多种方法可以安装谢顿，我决定使用头盔，因为我真的不完全理解Ksonnet。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="c5c6" class="mj kk hi mf b fi mk ml l mm mn">$ cd &lt;seldon-core repo&gt;</span><span id="2b5f" class="mj kk hi mf b fi mo ml l mm mn">$ kubectl create namespace seldon<br/>$ kubens seldon<br/>$ kubectl create clusterrolebinding kube-system-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:default</span><span id="2b56" class="mj kk hi mf b fi mo ml l mm mn">$ helm install ./helm-charts/seldon-core-crd --name seldon-core-crd --set usage_metrics.enabled=true<br/>$ helm install ./helm-charts/seldon-core --name seldon-core --namespace seldon  --set ambassador.enabled=true</span></pre><p id="3aba" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在另一个终端中运行这个命令来代理大使服务:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="d1ce" class="mj kk hi mf b fi mk ml l mm mn">$ kubectl port-forward $(kubectl get pods -n seldon -l service=ambassador -o jsonpath='{.items[0].metadata.name}') -n seldon 8003:8080</span></pre><p id="c0dd" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们终于安装了所有需要的东西，让我们来训练和部署一些模型吧！</p><h1 id="b9ea" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">Polyaxon:训练模型</h1><p id="8b6c" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated"><a class="ae ki" href="https://polyaxon.com/" rel="noopener ugc nofollow" target="_blank"> Polyaxon </a>是一个可重复机器学习的工具。它允许你将参数化的代码，例如TensorFlow或PyTorch，推入Polyaxon，在他们所谓的实验中运行。<a class="ae ki" href="https://docs.polyaxon.com/experimentation/concepts/#experiment" rel="noopener ugc nofollow" target="_blank">实验</a>可以是<a class="ae ki" href="https://docs.polyaxon.com/experimentation/concepts/#experiment-group" rel="noopener ugc nofollow" target="_blank">实验组</a>的一部分，用于进行超参数搜索。</p><p id="ee4f" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Polyaxon负责根据命令性定义执行作业，与Kubernetes的方式类似，它还负责保存作业的指标和输出，以供分析和选择。它有一些功能，我们不会在这里使用<a class="ae ki" href="https://docs.polyaxon.com/experimentation/distributed_experiments/" rel="noopener ugc nofollow" target="_blank">分布式训练</a>或使用<a class="ae ki" href="https://docs.polyaxon.com/experimentation/tensorboards/" rel="noopener ugc nofollow" target="_blank"> Tensorboard </a>。</p><p id="e777" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">遵循Polyaxon文档，我们可以基于示例创建一个新项目。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="ee5d" class="mj kk hi mf b fi mk ml l mm mn">$ polyaxon project create --name=mnist --description='Train and evaluate a model for the MNIST dataset'<br/>$ polyaxon init mnist</span></pre><p id="e110" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我想测试超参数搜索，因此polyaxon文件如下所示:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="5144" class="mj kk hi mf b fi mk ml l mm mn">---<br/>version: 1</span><span id="dd1b" class="mj kk hi mf b fi mo ml l mm mn">kind: group</span><span id="853a" class="mj kk hi mf b fi mo ml l mm mn">hptuning:<br/>  concurrency: 5<br/>  random_search:<br/>    n_experiments: 10</span><span id="ee96" class="mj kk hi mf b fi mo ml l mm mn">  matrix:<br/>    lr:<br/>      linspace: 0.001:0.1:5<br/>    momentum:<br/>      uniform: 0.5:0.6</span><span id="9f0b" class="mj kk hi mf b fi mo ml l mm mn">declarations:<br/>  batch_size_train: 128<br/>  batch_size_test: 1000<br/>  epochs: 5<br/>  train_steps: 400</span><span id="c8e8" class="mj kk hi mf b fi mo ml l mm mn">build:<br/> image: pytorch/pytorch:latest<br/> build_steps:<br/>   - pip install --no-cache-dir -U polyaxon-helper</span><span id="3af3" class="mj kk hi mf b fi mo ml l mm mn">run:<br/>  cmd: python run.py  --batch-size={{ batch_size_train }} \<br/>                       --test-batch-size={{ batch_size_test }} \<br/>                       --epochs={{ epochs }} \<br/>                       --lr={{ lr }} \<br/>                       --momentum={{ momentum }} \<br/>                       --epochs={{ epochs }}</span></pre><p id="579d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们可以进行实验了:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="dbab" class="mj kk hi mf b fi mk ml l mm mn">$ cd &lt;polyaxon-argo-seldon-example repo&gt;<br/>$ polyaxon run -u -f polyaxonfile_hyperparams.yml</span></pre><p id="dedd" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">基于参数空间，该命令将创建一个实验组，该组中有10个实验。你可以在Polyaxon UI中看到进度、日志、参数、环境等等。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es mw"><img src="../Images/8eed2aa39dbce7d84b674dc105c96371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uUAwoeYnUVEFOIoB.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">多轴实验</figcaption></figure><p id="584d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当实验完成后，您将拥有10个经过训练的模型，您可以使用Polyaxon查看这些模型的指标，并选择性能最佳的模型进行部署。Polyaxon内部的另一个选项是部署Tensorboard服务器来查看那里的指标，如果您已经以该格式保存了输出，这里我只使用了本机Polyaxon指标。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es ms"><img src="../Images/37917e0a1b0a5a52574a7b1abbbfe7fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JA94RVRIxznwReZY.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">多轴自然度量</figcaption></figure><p id="8c9a" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">您可以查看并下载经过训练的模型，只需查看我们之前启动的NFS服务器，然后转到group and experiment目录，例如:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es mx"><img src="../Images/b5fb9bdd846951605d71fc2015b8495b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u106eQu0XMt3xbs8.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">多轴输出</figcaption></figure><h1 id="b2bf" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">从波利亚克森到阿尔戈</h1><p id="12e5" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">既然我们已经训练和序列化了模型，我们需要使用Seldon对其进行打包和部署。这需要一些手工工作，因为你需要创建一个Python类供Seldon使用，创建<code class="du mp mq mr mf b">requirements.txt</code>并将序列化的模型移动到正确的位置。最后，我们需要使用<a class="ae ki" href="https://github.com/openshift/source-to-image" rel="noopener ugc nofollow" target="_blank"> s2i </a>来创建使用基本塞尔顿图像的图像。</p><p id="833e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">所有这些过程都可以通过下载序列化模型并使用<a class="ae ki" href="https://github.com/openshift/source-to-image" rel="noopener ugc nofollow" target="_blank"> s2i </a>在本地手动完成，但是本着自动化的精神，我决定使用<strong class="jh hj"> Argo </strong>来完成这个任务。</p><p id="25b8" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我还希望将大多数内容保存在Kubernetes集群中，其中模型/数据和其他内容彼此接近，因此我使用了一个Jupyter实验室服务器，您可以使用这个Kubernetes yaml规范启动并运行它:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="254d" class="mj kk hi mf b fi mk ml l mm mn">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: jupyter<br/>  labels:<br/>    app: jupyter<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: jupyter<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: jupyter<br/>    spec:<br/>      containers:<br/>      - name: jupyter<br/>        image: jupyter/datascience-notebook<br/>        command: ["start-notebook.sh"]<br/>        args: ["--NotebookApp.token="]<br/>        env:<br/>        - name: JUPYTER_ENABLE_LAB<br/>          value: "1"<br/>        ports:<br/>        - containerPort: 8888<br/>        volumeMounts:<br/>        - mountPath: /home/jovyan<br/>          name: work-volume<br/>        - mountPath: /output<br/>          name: outputs-volume<br/>      volumes:<br/>      - name: work-volume<br/>        persistentVolumeClaim:<br/>          claimName: polyaxon-pvc-repos<br/>      - name: outputs-volume<br/>        persistentVolumeClaim:<br/>          claimName: polyaxon-pvc-outputs<br/>---<br/>kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: jupyter<br/>spec:<br/>  selector:<br/>    app: jupyter<br/>  type: LoadBalancer<br/>  ports:<br/>  - protocol: TCP<br/>    port: 80<br/>    targetPort: 8888</span></pre><p id="e03b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Jupyter Lab的安装将为您移动系列型号提供合适的支架:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="3d46" class="mj kk hi mf b fi mk ml l mm mn">$ cp /output/root/mnist/groups/12/120/model.dat /home/jovyan/deployments/mnist/</span></pre><p id="7d05" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然后创建谢顿所需的文件:谢顿的Python类、包含<code class="du mp mq mr mf b">environment</code>文件的<code class="du mp mq mr mf b">.s2i</code>目录和<code class="du mp mq mr mf b">requirements.txt</code>。所有这些都可以在回购协议中获得。最后应该是这样的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es my"><img src="../Images/aa401dcc6441c7b00ca0dd375707face.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*etEtYAvM0twUep1h.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">带有谢顿码的朱庇特实验室</figcaption></figure><p id="86af" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">谢顿实际使用的Python类是这样的:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="2ff8" class="mj kk hi mf b fi mk ml l mm mn"><strong class="mf hj">import</strong> torch<br/><strong class="mf hj">from</strong> network <strong class="mf hj">import</strong> Network<br/><strong class="mf hj">from</strong> torchvision <strong class="mf hj">import</strong> datasets, transforms</span><span id="575c" class="mj kk hi mf b fi mo ml l mm mn"><strong class="mf hj">class</strong> <strong class="mf hj">MnistModel</strong>(object):<br/>    <br/>    <strong class="mf hj">def</strong> __init__(self):<br/>        self<strong class="mf hj">.</strong>model <strong class="mf hj">=</strong> Network()<br/>        self<strong class="mf hj">.</strong>model<strong class="mf hj">.</strong>load_state_dict(torch<strong class="mf hj">.</strong>load("./model.dat"))</span><span id="376f" class="mj kk hi mf b fi mo ml l mm mn">    <strong class="mf hj">def</strong> <strong class="mf hj">predict</strong>(self, X, feature_names):<br/>        tensor <strong class="mf hj">=</strong> torch<strong class="mf hj">.</strong>from_numpy(X)<strong class="mf hj">.</strong>view(<strong class="mf hj">-</strong>1, 28, 28)<br/>        t <strong class="mf hj">=</strong> transforms<strong class="mf hj">.</strong>Normalize((0.1307,), (0.3081,))<br/>        tensor_norm <strong class="mf hj">=</strong> t(tensor)<br/>        tensor_norm <strong class="mf hj">=</strong> tensor_norm<strong class="mf hj">.</strong>unsqueeze(0)<br/>        out <strong class="mf hj">=</strong> self<strong class="mf hj">.</strong>model(tensor_norm<strong class="mf hj">.</strong>float())<br/>        predictions <strong class="mf hj">=</strong> torch<strong class="mf hj">.</strong>nn<strong class="mf hj">.</strong>functional<strong class="mf hj">.</strong>softmax(out)<br/>        <strong class="mf hj">print</strong>(predictions)<br/>        <strong class="mf hj">return</strong> predictions<strong class="mf hj">.</strong>detach()<strong class="mf hj">.</strong>numpy()</span></pre><p id="6a00" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这基本上是在<code class="du mp mq mr mf b">__init__</code>函数中加载序列化的模型给后来的用户，在<code class="du mp mq mr mf b">predict</code>函数中，我们有一些简单的PyTorch代码来预处理模型期望的输入。</p><p id="72a8" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们现在有了所有需要的东西，可以使用阿尔戈将模型打包成docker图像，这样谢顿就可以使用了。</p><h1 id="83cf" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">Argo:为模型创建docker图像</h1><p id="ed93" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated">Argo是Kubernetes的工作流管理器。我们将使用Argo构建一个可重用的容器原生工作流，将序列化的模型放入一个容器中，稍后可以使用Seldon进行部署。</p><p id="9e1c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了支持这一点，我创建了一个简单的docker映像，它执行s2i并推送一个映像，<a class="ae ki" href="https://github.com/danielfrg/polyaxon-argo-seldon-example/tree/master/docker-s2i" rel="noopener ugc nofollow" target="_blank"> Dockerfile在这里</a>，docker映像作为<a class="ae ki" href="https://hub.docker.com/r/danielfrg/s2i/" rel="noopener ugc nofollow" target="_blank"> danielfrg/s2i </a>可用。</p><p id="c98b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因为我们要将一个图像推送到Docker hub，所以首先我们需要创建一个带有登录注册中心的凭证的秘密。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="0f9b" class="mj kk hi mf b fi mk ml l mm mn">$ kubectl create secret docker-registry regcred --docker-server=&lt;your-registry-server&gt; --docker-username=&lt;your-name&gt; --docker-password=&lt;your-pword&gt; --docker-email=&lt;your-email&gt;</span></pre><p id="fe9b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有了映像，我们可以使用Argo来管理执行，Argo管道将3样东西挂载到容器:</p><ol class=""><li id="d2ec" class="lg lh hi jh b ji jj jl jm jo li js lj jw lk ka ll lm ln lo bi translated">Polyaxon卷来访问我们在上一节中编写的代码。</li><li id="3f62" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">用于构建映像和推送的Docker套接字</li><li id="4108" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">要推送到存储库的Docker凭据</li></ol><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="f0d1" class="mj kk hi mf b fi mk ml l mm mn">apiVersion: argoproj.io/v1alpha1<br/>kind: Workflow<br/>metadata:<br/>  generateName: model-pkg-<br/>spec:<br/>  entrypoint: model-pkg<br/>  <br/>  volumes:<br/>  - name: work-volume<br/>    persistentVolumeClaim:<br/>      claimName: argo-pvc-repos<br/>  - name: docker-sock-volume<br/>    hostPath:<br/>      path: /var/run/docker.sock<br/>  - name: docker-config<br/>    secret:<br/>      secretName: regcred<br/>      items:<br/>      - key: .dockerconfigjson<br/>        path: config.json</span><span id="ea49" class="mj kk hi mf b fi mo ml l mm mn">  templates:<br/>  - name: model-pkg<br/>    steps:<br/>    - - name: s2i-push<br/>        template: s2i</span><span id="34e7" class="mj kk hi mf b fi mo ml l mm mn">  - name: s2i<br/>    container:<br/>      image: danielfrg/s2i:0.1<br/>      command: ["sh", "-c"]<br/>      args: ["s2i build /src/mnist seldonio/seldon-core-s2i-python3 danielfrg/seldon-mnist:0.2 &amp;&amp; docker push danielfrg/seldon-mnist:0.2"]<br/>      volumeMounts:<br/>      - name: work-volume<br/>        mountPath: /src<br/>      - name: docker-sock-volume<br/>        mountPath: /var/run/docker.sock<br/>      - name: docker-config<br/>        mountPath: /root/.docker<br/>        readOnly: <strong class="mf hj">true</strong></span></pre><p id="0b81" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然后只需执行argo管道</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="0f79" class="mj kk hi mf b fi mk ml l mm mn">$ argo submit argo/pipeline.yaml</span></pre><p id="843e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">流水线使用s2i和基本的Seldon映像<code class="du mp mq mr mf b">seldonio/seldon-core-s2i-python3</code>，构建一个标记为<code class="du mp mq mr mf b">danielfrg/seldon-mnist:0.2</code>的映像，并将这个新映像推送到<a class="ae ki" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker hub </a>。Argo将处理所有的执行，您可以在他们的UI中看到日志和更多内容:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es ms"><img src="../Images/d0a044980989ce60d7e78c04ec3ff2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eaAQZi7cmwDhJjym.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">一个工作流的Argo日志</figcaption></figure><p id="3824" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们在Docker Hub中有了一个映像，我们可以使用Seldon来部署该映像。</p><h1 id="7951" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">谢顿:模型部署</h1><p id="8ae1" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated"><a class="ae ki" href="https://github.com/SeldonIO/seldon-core" rel="noopener ugc nofollow" target="_blank"> Seldon </a>是一个在Kubernetes中管理模型的伟大框架。模型可以作为REST APIs或gRPC端点使用，您可以在模型之间进行复杂的路由，包括A/B测试和多臂土匪。Seldon负责缩放模型，并使用标准API让它运行您的所有模型。</p><p id="001b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">谢顿使用自己的Kubernetes CRD，它只会使用Argo管道推出的Docker图像，谢顿部署CRD规范如下所示:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="9ef2" class="mj kk hi mf b fi mk ml l mm mn">apiVersion: machinelearning.seldon.io/v1alpha2<br/>kind: SeldonDeployment<br/>metadata:<br/>  name: mnist<br/>  labels:<br/>    app: seldon<br/>  namespace: seldon<br/>spec:<br/>  name: mnist<br/>  predictors:<br/>  - componentSpecs:<br/>    - spec:<br/>        containers:<br/>        - image: danielfrg/seldon-mnist:0.2<br/>          imagePullPolicy: Always<br/>          name: classifier<br/>    graph:<br/>      endpoint:<br/>        type: REST<br/>      name: classifier<br/>      type: MODEL<br/>    labels:<br/>      version: v1<br/>    name: mnist<br/>    replicas: 1</span></pre><p id="4334" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这将创建几个Kubernetes Pods，包括模型运行和处理其他路由内容。</p><p id="48b0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">完成所有这些工作后，我们终于可以查询模型了！</p><p id="9c55" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因为我们部署了一个REST API，所以我们可以使用一点Python来查询这个部署的模型，以读取和成像并发出一个HTTP请求:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="b1bd" class="mj kk hi mf b fi mk ml l mm mn"><strong class="mf hj">import</strong> requests<br/><strong class="mf hj">import</strong> numpy <strong class="mf hj">as</strong> np<br/><strong class="mf hj">from</strong> PIL <strong class="mf hj">import</strong> Image</span><span id="5fba" class="mj kk hi mf b fi mo ml l mm mn">API_AMBASSADOR <strong class="mf hj">=</strong> "localhost:8003"<br/></span><span id="c645" class="mj kk hi mf b fi mo ml l mm mn"><strong class="mf hj">def</strong> <strong class="mf hj">load_image</strong>(filename):<br/>    img <strong class="mf hj">=</strong> Image<strong class="mf hj">.</strong>open(filename)<br/>    img<strong class="mf hj">.</strong>load()<br/>    data <strong class="mf hj">=</strong> np<strong class="mf hj">.</strong>asarray(img, dtype<strong class="mf hj">=</strong>"int32")<br/>    <strong class="mf hj">return</strong> data<br/></span><span id="5d21" class="mj kk hi mf b fi mo ml l mm mn"><strong class="mf hj">def</strong> <strong class="mf hj">rest_request_ambassador</strong>(deploymentName, imgpath, endpoint<strong class="mf hj">=</strong>API_AMBASSADOR):<br/>    arr <strong class="mf hj">=</strong> load_image(imgpath)<strong class="mf hj">.</strong>flatten()<br/>    shape <strong class="mf hj">=</strong> arr<strong class="mf hj">.</strong>shape<br/>    payload <strong class="mf hj">=</strong> {"data":{"names":[], "tensor":{"shape":shape, "values":arr<strong class="mf hj">.</strong>tolist()}}}<br/>    response <strong class="mf hj">=</strong> requests<strong class="mf hj">.</strong>post(<br/>        "http://"<strong class="mf hj">+</strong>endpoint<strong class="mf hj">+</strong>"/seldon/"<strong class="mf hj">+</strong>deploymentName<strong class="mf hj">+</strong>"/api/v0.1/predictions",<br/>        json<strong class="mf hj">=</strong>payload)<br/>    <strong class="mf hj">print</strong>(response<strong class="mf hj">.</strong>status_code)<br/>    <strong class="mf hj">print</strong>(response<strong class="mf hj">.</strong>text)</span><span id="d450" class="mj kk hi mf b fi mo ml l mm mn">rest_request_ambassador("mnist", "images/87.png")</span></pre><p id="f094" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">其输出将是对该图像的预测，第87幅图像是9，并且该预测实际上是9。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="fd11" class="mj kk hi mf b fi mk ml l mm mn">{<br/>  "meta": {<br/>    "puid": "6rtbtvkvlftfeusuej5ni4197q",<br/>    "tags": {<br/>    },<br/>    "routing": {<br/>    },<br/>    "requestPath": {<br/>      "classifier": "danielfrg/seldon-mnist:0.2"<br/>    }<br/>  },<br/>  "data": {<br/>    "names": ["t:0", "t:1", "t:2", "t:3", "t:4", "t:5", "t:6", "t:7", "t:8", "t:9"],<br/>    "tensor": {<br/>      "shape": [1, 10],<br/>      "values": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]<br/>    }<br/>  }<br/>}</span></pre><p id="4845" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">谢顿有很多其他的功能，这里没有探讨，检查<a class="ae ki" href="https://github.com/SeldonIO/seldon-core" rel="noopener ugc nofollow" target="_blank">他们的网站</a>。</p><h1 id="a487" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">思想</h1><p id="6e2a" class="pw-post-body-paragraph jf jg hi jh b ji lb ij jk jl lc im jn jo ld jq jr js le ju jv jw lf jy jz ka hb bi translated"><strong class="jh hj">这个看起来真的很难，一定有更好的办法！可能有更好的方法。大多数拥有大数据科学团队的公司都在构建类似的基础架构，其中一些可供使用，例如:</strong></p><ol class=""><li id="b9c6" class="lg lh hi jh b ji jj jl jm jo li js lj jw lk ka ll lm ln lo bi translated"><a class="ae ki" href="https://www.tensorflow.org/tfx/" rel="noopener ugc nofollow" target="_blank"> TFX </a>来自Google/TensorFlow，<a class="ae ki" href="https://dl.acm.org/citation.cfm?id=3098021" rel="noopener ugc nofollow" target="_blank">论文此处</a></li><li id="8654" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="https://github.com/kubeflow/kubeflow" rel="noopener ugc nofollow" target="_blank"> KubeFlow </a>，一个同样来自谷歌的工具集合，它使用的是Seldon</li><li id="0750" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">来自StictFix的<a class="ae ki" href="https://github.com/stitchfix/flotilla-os" rel="noopener ugc nofollow" target="_blank"> Folilla </a>。此外，请查看Juliet Hougland关于<a class="ae ki" href="https://www.youtube.com/watch?v=Z7_AatHRXjI" rel="noopener ugc nofollow" target="_blank"> Stitch Fix如何部署生产模型</a>的精彩演讲</li><li id="a4d5" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="https://github.com/IBM/FfDL" rel="noopener ugc nofollow" target="_blank"> IBM/FfDL </a></li><li id="2021" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="https://eng.uber.com/michelangelo/" rel="noopener ugc nofollow" target="_blank">优步·米开朗基罗</a></li><li id="22da" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="http://clipper.ai/" rel="noopener ugc nofollow" target="_blank"> Clipper </a>，一个为模特服务的更低级的工具</li><li id="929a" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="https://github.com/instacart/lore" rel="noopener ugc nofollow" target="_blank"> Instacart绝杀</a></li></ol><p id="5a8b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当然，也有一些公司的产品可供您购买:</p><ol class=""><li id="2ca2" class="lg lh hi jh b ji jj jl jm jo li js lj jw lk ka ll lm ln lo bi translated"><a class="ae ki" href="https://www.anaconda.com/enterprise/" rel="noopener ugc nofollow" target="_blank">蟒蛇企业</a>(免责声明这是我工作的地方)</li><li id="aad3" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="https://www.dominodatalab.com/" rel="noopener ugc nofollow" target="_blank">多米诺数据实验室</a></li><li id="ef2d" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="https://databricks.com/" rel="noopener ugc nofollow" target="_blank">数据块</a></li><li id="175c" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="https://azure.microsoft.com/en-us/services/machine-learning-studio/" rel="noopener ugc nofollow" target="_blank">全</a> <a class="ae ki" href="https://cloud.google.com/ml-engine/" rel="noopener ugc nofollow" target="_blank">云</a> <a class="ae ki" href="https://aws.amazon.com/sagemaker/" rel="noopener ugc nofollow" target="_blank">提供商</a></li><li id="b52c" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">还有很多。</li></ol><p id="aea1" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">根据您的使用情况，选项是无穷无尽的，您应该选择并构建一切。Kubernetes是一个真正的平台，你可以根据需要扩展它，这就是一个例子。您可以添加很多东西来创建最终的模型管理平台。例如，<a class="ae ki" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank">监控</a>、多用户、认证和安全、审计、作为docker映像的模型目录、中央存储应该是NFS还是对象存储还是其他？</p><p id="1a46" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这些特性中的每一个都会显著增加成本。</p><p id="6277" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj"> Jupyter Hub和Binder </strong>。这个过程与我之前在Kubernetes 的Jupyter Hub上发布的关于多用户开发环境的一些工作整合得相当好。多用户协作是这一过程的关键部分。此外，不要忘记，最终结果通常不是API，而是某种应用程序、仪表板或报告，这些应用程序的部署也很重要。</p><p id="6893" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为什么不用Argo来做模型训练呢？你可以，我认为Polyaxon现在更适合模型训练，因为它就是这样做的，Argo本质上更通用，这很好，但专用工具有时更好。<a class="ae ki" href="https://applatix.com/open-source/argo/get-started/architecture" rel="noopener ugc nofollow" target="_blank"> Argo的架构</a>更加复杂和可扩展，所以其他工具可以建立在它的基础上，我想这最终会发生。</p><p id="d47c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">这该怎么办？</strong>将它作为一个简单的实验来展示在Kubernetes上使用开源框架进行模型管理的可能性。拿着这个，适应你的需要。目标是让你的生活更简单，让迭代更快，模型更好。</p><p id="2b8e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这条管道非常有用。然而，它还远远没有完成。这会节省你一些时间，但是一些手动的部分需要自动化。你需要将这个(或任何东西)整合到你现有的Git和CI/CD工作流程中。</p><h2 id="6cbb" class="mj kk hi bd kl mz na nb kp nc nd ne kt jo nf ng kv js nh ni kx jw nj nk kz nl bi translated">我使用的其他链接和东西</h2><ol class=""><li id="d86a" class="lg lh hi jh b ji lb jl lc jo nm js nn jw no ka ll lm ln lo bi translated"><a class="ae ki" href="https://github.com/polyaxon/polyaxon/blob/master/docs/templates/tutorials/gke_deployment/kubernetes_on_gke.md" rel="noopener ugc nofollow" target="_blank">多轴文件</a></li><li id="63df" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="https://github.com/polyaxon/polyaxon-examples" rel="noopener ugc nofollow" target="_blank">聚轴实例</a></li><li id="9e1b" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="https://github.com/IBM/FfDL/tree/master/community/FfDL-Seldon/pytorch-model" rel="noopener ugc nofollow" target="_blank">FfDL-Seldon/py torch-model</a></li><li id="07cc" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="https://github.com/SeldonIO/seldon-core" rel="noopener ugc nofollow" target="_blank">塞尔顿核心</a></li><li id="fc2e" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated"><a class="ae ki" href="https://applatix.com/open-source/argo/docs/yaml/argo_tutorial_2_create_docker_image_build_workflow.html" rel="noopener ugc nofollow" target="_blank">阿尔戈丁德</a></li></ol></div></div>    
</body>
</html>