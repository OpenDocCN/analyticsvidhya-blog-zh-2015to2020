<html>
<head>
<title>Implementing Chargrid: Network Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现 Chargrid:网络架构</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/implementing-chargrid-network-architecture-cc21eb3d68f8?source=collection_archive---------12-----------------------#2020-10-03">https://medium.com/analytics-vidhya/implementing-chargrid-network-architecture-cc21eb3d68f8?source=collection_archive---------12-----------------------#2020-10-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ebd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Chargrid — OCR(第二部分)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/8a4f9267192a9b199413bf4cc0214f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxmC1fanz6c0Uq8bm1l9Dg.png"/></div></div></figure><p id="6370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上一篇文章中，我解释了理解 2d 结构文档的 chargrid 方法。为了更好地理解，请阅读我的上一篇文章<a class="ae jp" rel="noopener" href="/analytics-vidhya/implementing-chargrid-towards-understanding-2d-documents-c7189d89a0"> chargrid — OCR(Part-1) </a>。</p><p id="b356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一部分，我将解释 chargrid 论文中实现的网络架构。可以查看<a class="ae jp" href="https://github.com/sciencefictionlab/chargrid-pytorch" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> githup 回购</strong> </a>和<a class="ae jp" href="https://arxiv.org/abs/1809.08799" rel="noopener ugc nofollow" target="_blank">研究论文</a>。</p><h2 id="7bb7" class="jq jr hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated"><a class="ae jp" href="https://github.com/sciencefictionlab/chargrid-pytorch/blob/master/Model%20Architecture.MD" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">型号说明</strong> </a> <strong class="ak">见此。</strong></h2><p id="4f9a" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated"><strong class="ih hj">我们开始吧— </strong></p><p id="b1a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">文件理解的网络结构；</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kq"><img src="../Images/f9091bf095cccbc533156cac28b42a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rrtV-CL_BcZG9miKOA4Nsw.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">模型架构——充电网。</figcaption></figure><p id="44e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种模型架构有一个编码器和两个解码器。编码器使用卷积层对 chargrid 的图像进行编码，解码器用于图像的语义分割和预测边界框。</p><h2 id="0f2e" class="jq jr hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated">一点术语-</h2><p id="e371" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated"><strong class="ih hj">输入 chargrid 图像的</strong> —(通道数*高度*宽度)</p><p id="f9ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kv">通道数=3 (rgb) </em></p><p id="871c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> C </strong> —输出基本通道数=64</p><p id="ae55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> d </strong> —扩张率。</p><h2 id="cdcf" class="jq jr hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated">编码器模块:</h2><p id="5bfc" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">该编码器由 5 块 3*3 卷积层、泄漏 Relu 激活、批量归一化和丢弃层组成。</p><p id="45d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在编码器模块中，我们以因子 2 对图像进行下采样，如同在步长为-2 的第一 conv 模块中一样。每当对图像进行下采样时，我们将每个卷积的输出通道 C 的数量增加 2 倍。如图所示，第一个 conv 模块的输出为 2C。</p><p id="73ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在编码器的第三、第四和第五块中，我们分别使用了 d = 2、4、8 的扩展卷积层。</p><blockquote class="kw kx ky"><p id="07de" class="if ig kv ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">D <!-- -->膨胀卷积——简单来说，膨胀卷积就是一种应用于具有定义间隙的输入的卷积。利用该定义，假设我们的输入是 2D 图像，膨胀率 k=1 是正常卷积，k=2 意味着每个输入跳过一个像素，k=4 意味着跳过 3 个像素。</p></blockquote><h2 id="c53d" class="jq jr hi bd js jt ju jv jw jx jy jz ka iq kb kc kd iu ke kf kg iy kh ki kj kk bi translated">解码器模块:</h2><p id="634e" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">这里，我们有两个解码器模块。语义分割解码器和包围盒回归解码器。</p><p id="6a81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你仔细观察这个架构，你会发现这两个解码器网络是相同的，只是最后一层不同。</p><p id="c957" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码器的第三个块和编码器的最后一个块连接(横向连接)的输出首先进入解码器网络的第一个块。这里，我们通过使用 3*3 转置卷积层对图像进行上采样。</p><blockquote class="kw kx ky"><p id="67cf" class="if ig kv ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">转置卷积层— <strong class="ih hj">它们对图像进行上采样</strong>意味着减少通道数量，增加图像的高度和宽度。</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lc"><img src="../Images/b32f48e543ef9e70f318130d05670028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lSYBfVtfaGLGhH-YHkdzEg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">用两个 Conv2D 后跟两个 ConvTranspose2d 对 RGB 图像进行自动编码。</figcaption></figure><p id="920d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用于语义分割的<strong class="ih hj">解码器</strong>有一个额外的卷积层，没有批量标准化，有偏差，并且有 softmax 激活。<br/>最后卷积的输出通道数对应于该解码器分支中的<strong class="ih hj">类数=5 </strong>。</p><p id="bb3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">包围盒回归解码器</strong>的最后一层是线性层。输出通道的数量是用于盒屏蔽的<code class="du ld le lf lg b"><strong class="ih hj">2 * number of anchors per pixel (Na</strong>)</code>和用于 4 个盒坐标的<code class="du ld le lf lg b"><strong class="ih hj">4 * Na</strong></code>。</p><p id="6050" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经使用<strong class="ih hj"> pytorch </strong>来训练充电网络。借助于<strong class="ih hj"> nn.sequential </strong>层编写代码的有效方法，以便更容易理解。</p><p id="bf36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经解释了网络架构的所有模块。在下一篇文章(第 3 部分)中，我将解释模型的数据处理和训练。</p><p id="090d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读，注意安全！</p></div></div>    
</body>
</html>