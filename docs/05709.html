<html>
<head>
<title>Document Scanner using OpenCV (HoughLines Approach)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCV的文档扫描仪(HoughLines方法)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/document-scanner-using-opencv-houghlines-approach-eb276dd4a0a?source=collection_archive---------4-----------------------#2020-04-30">https://medium.com/analytics-vidhya/document-scanner-using-opencv-houghlines-approach-eb276dd4a0a?source=collection_archive---------4-----------------------#2020-04-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ecc63a33cab9526d451cdfee59e8468a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZZYejtUsqQrJYkI1vEwkA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">原始图像(左)，扫描图像(右)</figcaption></figure><p id="3e67" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇文章中，解释了使用python和OpenCV从头开始制作文档扫描仪的步骤。这篇文章的一个有趣的特点是Houghlines已经被用于边界检测。流行的轮廓方法在处理光线不佳、边界嘈杂的图片时存在性能问题，因此这是一种可供选择的方法。</p><p id="1850" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">整个过程将在下面逐步解释。</p><ol class=""><li id="e154" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hj">导入所有需要的库</strong></li></ol><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="2872" class="kk kl hi kg b fi km kn l ko kp">from skimage.filters import threshold_local<br/>import numpy as np<br/>import cv2 as cv</span></pre><p id="232c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 2。读取图像并处理图像进行边缘检测</strong></p><p id="6c1b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">图像被转换为灰度级，并进行模糊处理以平滑图像。形态学膨胀和腐蚀被用来移除不需要的特征(有助于边缘检测)。然后使用canny边缘检测来寻找图像中的边缘。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b3af" class="kk kl hi kg b fi km kn l ko kp">img=cv.imread("document.png")<br/>gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><span id="53eb" class="kk kl hi kg b fi kq kn l ko kp">kernel = np.ones((5,5),np.uint8)<br/>dilation = cv.dilate(gray,kernel,iterations =5)<br/>blur =cv.GaussianBlur(dilation,(3,3),0)<br/>blur= cv.erode(blur,kernel,iterations =5)</span><span id="a14f" class="kk kl hi kg b fi kq kn l ko kp">edge=cv.Canny(blur,100,200)</span></pre><p id="4822" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 3。在canny边缘检测后使用Houghlines寻找图像中的文档边缘</strong></p><p id="7152" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在canny边缘检测之后，Houghlines被用来从图像中找到前n条<em class="kr">(这里是8) </em>线。最初，已经选择了高阈值<em class="kr">(这里是300) </em>，并且阈值被迭代地降低，以获得所需数量的Houghlines。多余的线(具有相似的<em class="kr"> rho </em>和<em class="kr">θ</em>值的线)被移除，并且顶部四条线(对应于四条边)被选择。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="8b04" class="kk kl hi kg b fi km kn l ko kp">t=300;j=0</span><span id="16cf" class="kk kl hi kg b fi kq kn l ko kp">while(j&lt;8 and t&gt;0):     <br/>    try:linesP=cv.HoughLines(edge,1,np.pi/180,t);j=linesP.shape[0]<br/>    except:j=0<br/>    t=t-10</span><span id="6133" class="kk kl hi kg b fi kq kn l ko kp">lines=linesP.reshape(linesP.shape[0],2)<br/>t=0;c=0;lu=[]<br/>for l in lines:<br/>    c=c+1;rho,theta=l<br/>    for lt in lines[c:]:<br/>        t=0<br/>        if(lt[0]!=l[0]):<br/>            rhot,thetat=lt;k=abs(lt-l)&lt;[50,0.5] <br/>            if(k[0] and k[1]):<br/>                t=-1;break                <br/>    lu.append(l)</span><span id="62af" class="kk kl hi kg b fi kq kn l ko kp">lr=np.asarray(lu[:4]);j=np.reshape(lr,[lr.shape[0],1,2])</span></pre><p id="2618" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 4。找到四条最可能的边的交点，以获得文档的角点</strong></p><p id="52cc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">找到对应于边界的垂直边的边的交点，这些交点将是矩形的四个角。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="9e9c" class="kk kl hi kg b fi km kn l ko kp">def l_inter(line1, line2):<br/>    r1, t1 = line1;r2,t2 = line2<br/>    A= np.array([[np.cos(t1),np.sin(t1)],[np.cos(t2),np.sin(t2)]])<br/>    b= np.array([[r1],[r2]]);x0,y0=(0,0)<br/>    if(abs(t1-t2)&gt;1.3):<br/>        return [[np.round(np.linalg.solve(A, b))]]</span><span id="b17f" class="kk kl hi kg b fi kq kn l ko kp">def points_inter(lines):<br/>    intersections = []<br/>    for i, g in enumerate(lines[:-1]):<br/>        for g2 in lines[i+1:]:<br/>            for line1 in g:<br/>                for line2 in g2:<br/>                    if(l_inter(line1, line2)):<br/>                        intersections.append(l_inter(line1, line2)) <br/>    return intersections</span><span id="6b54" class="kk kl hi kg b fi kq kn l ko kp">p=np.asarray(points_inter(j)).reshape(4,2)</span></pre><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/10eca906f09955d09abcb6ced58d0cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkmQh4uUPSL0ecfmkkwWug.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">预处理图像上的Canny边缘检测(左)，原始图像上绘制的Houghlines和拐角(右)</figcaption></figure><p id="d53d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 5。为了展平文档，我们使用透视变换和扭曲透视函数的方法</strong></p><p id="b8f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">点坐标的最大和最小和分别对应于右下角和左上角。同样的麦克斯。和min。差异给出右上角和左下角。然后，这些用于为转换矩阵找到扫描文档的宽度和高度。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="c9dc" class="kk kl hi kg b fi km kn l ko kp">r= np.zeros((4,2), dtype="float32")<br/>s = np.sum(p, axis=1);r[0] = p[np.argmin(s)];r[2] = p[np.argmax(s)]<br/>d = np.diff(p, axis=1);r[1] = p[np.argmin(d)];r[3] = p[np.argmax(d)]<br/>(tl, tr, br, bl) =r</span><span id="4576" class="kk kl hi kg b fi kq kn l ko kp">wA = np.sqrt((tl[0]-tr[0])**2 + (tl[1]-tr[1])**2 )<br/>wB = np.sqrt((bl[0]-br[0])**2 + (bl[1]-br[1])**2 )<br/>maxW = max(int(wA), int(wB))</span><span id="6285" class="kk kl hi kg b fi kq kn l ko kp">hA = np.sqrt((tl[0]-bl[0])**2 + (tl[1]-bl[1])**2 )<br/>hB = np.sqrt((tr[0]-br[0])**2 + (tr[1]-br[1])**2 )<br/>maxH = max(int(hA), int(hB))</span><span id="258b" class="kk kl hi kg b fi kq kn l ko kp">ds= np.array([[0,0],[maxW-1, 0],[maxW-1, maxH-1],[0, maxH-1]], dtype="float32")</span><span id="a736" class="kk kl hi kg b fi kq kn l ko kp">transformMatrix = cv.getPerspectiveTransform(r,ds)<br/>scan = cv.warpPerspective(gray, transformMatrix, (maxW, maxH))</span></pre><p id="ed94" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 6。图像被转换为B &amp; W并保存在系统中</strong></p><p id="2b2d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">进行二值化是为了将扫描的文档转换为黑白。这是通过阈值处理实现的。可以根据您的要求设置阈值和偏移值。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b619" class="kk kl hi kg b fi km kn l ko kp">T = threshold_local(scan,21, offset=10, method="gaussian")<br/>scanBW = (scan &gt; T).astype("uint8")* 255<br/>cv.imwrite("Scan.png",scanBW)</span></pre><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/9a36f78dbd7c58cdba6aa01418c6ce7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*CwkFjNXQ3k14AzYt1haqFw.png"/></div></figure><p id="0e01" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">注:</strong></p><p id="dd78" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">给定示例中使用的各种参数是根据它们在这种情况下的性能选择的。您可能需要针对您的情况尝试不同的参数集。</p><p id="c564" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">你可以在</strong><a class="ae ku" href="https://github.com/Joel1712/Document_scanner" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">https://github.com/Joel1712/Document_scanner</strong></a>上看到完整的源代码</p></div></div>    
</body>
</html>