<html>
<head>
<title>Logistic Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/logistic-regression-8f037d180d6f?source=collection_archive---------12-----------------------#2019-11-08">https://medium.com/analytics-vidhya/logistic-regression-8f037d180d6f?source=collection_archive---------12-----------------------#2019-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3b8b071f17e0c53d31ffeb2a7dd23e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Uuzp5aXD5zytA-F3.png"/></div></div></figure><p id="0bad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">逻辑回归是一种基于概率概念的监督分类算法。这是解决二元分类问题的常用方法。逻辑回归用于将观察值分配给一组离散的类。分类问题的一些例子是垃圾短信或非垃圾短信、在线交易欺诈或非欺诈、恶性或良性癌症。逻辑回归使用逻辑sigmoid函数转换其输出(在0和1之间),以返回概率值。</p><p id="4359" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在分类问题中，对于给定的一组特征(或输入)x，标签(或输出)y只能取离散值。</p><p id="5770" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">逻辑回归建立回归模型(预测连续值输出的模型)来预测给定数据条目是否属于特定类别/类的概率。逻辑回归以sigmoid函数/逻辑函数作为成本函数对数据进行建模。</p><p id="921e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Sigmoid函数:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/4a6b1432b5ad61b2349a9791fbac3fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*bCudIkoy4Ma5v3LSEbil0A.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/bb857a00ceb54d88860491eb9a3638d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*5PCGXd1K3zctyHDicHnZaA.png"/></div></figure><p id="4e59" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">逻辑回归的假设将成本函数限制在0和1之间。因此，sigmoid函数被用作成本函数，因为线性函数无法表示它(线性函数可以具有大于1或小于0的值，根据逻辑回归的假设，这是不可能的)。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/5e1ae266a00a6423a88f034cd8f7c786.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*BUALwGwp772e_CuLjZM-Lg.png"/></div></figure><h1 id="4efe" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">假设表示</h1><p id="b81d" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">线性回归中的假设公式</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/3d7aa3ed09d4cd784dc717635d4a0b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/format:webp/1*ySrNhcYkTh2WIu97JZOUQg.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/366deafe0b1ad36037e3fd9b39de5d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*cWDLU3Mg0UFkg1HhB3CSUQ.png"/></div></figure><p id="9078" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在哪里，</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es la"><img src="../Images/456a60006ad62dd62902c9f4a35263ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:180/format:webp/1*VoLxYUg2MEf7N5IMXFoI6Q.png"/></div></figure><p id="3655" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/f90de2fd54c08d7d013fd4ebcefe6dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:188/format:webp/1*YfJOan0tkX4KOe_6w2huTg.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/8e75a68c41bee8808c9f0b40b237b0f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/format:webp/1*pTCHLyyDm9gsRM_4cgRgUA.png"/></div></figure><p id="9a07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于逻辑回归公式的假设将是</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/bf5a589796067c6883f8006d0969e89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/format:webp/1*PN1HrjbhhHSc1SMcKW8o9g.png"/></div></figure><p id="1051" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这基本上是一个sigmoid函数，</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/ee58010ea8c5070009d861c17e178d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*rh7BYupAbbeez_zoee274A.png"/></div></figure><p id="882f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">。让我们看看这个函数如何总是给我们0到1之间的值。</p><p id="dec0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当...的时候</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es le"><img src="../Images/61524869035705c75c2a425099df7bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:140/format:webp/1*ZBArc8WnN9Q3OTAhWyEkvw.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/b28ec6b9e5cd01f295e5c75f8d62c948.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*sr5X-tw4QYLieX_lJKZKfA.png"/></div></figure><p id="3ab6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">什么时候</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/2deebf04abb63d4a0315ac4b1fd8be60.png" data-original-src="https://miro.medium.com/v2/resize:fit:168/format:webp/1*BolXSPrAC3LQF54kAa-fmA.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/98e37311531bb2f3b7630c4d37f9e884.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*ytOtCLyx7tbp1MCviEM3gA.png"/></div></figure><p id="a7e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，这种假设总是给出0到1之间的值。</p><h1 id="c475" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">判别边界</h1><p id="fe2b" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">例如，我们有2个类，让我们把它们看作垃圾邮件和非垃圾邮件(1-垃圾邮件，0-非垃圾邮件)。我们基本上确定一个阈值，高于该阈值时，我们将输入分类为类别1，如果该值低于该阈值，则我们将其分类为类别2。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/3e72f0f06c54baf9d1fde46b29fede1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tw22iN0ksLDQXGVKecAJxA.png"/></div></div></figure><p id="f4b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上图所示，我们选择阈值为0.5，如果预测函数返回值为0.7，则我们会将此观察结果分类为1类(垃圾邮件)。如果我们的预测返回值为0.2，那么我们会将观察结果分类为第2类(非垃圾邮件)。</p><h1 id="1701" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">价值函数</h1><p id="628d" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">我们知道成本函数</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es li"><img src="../Images/ae01d21d103274d9f50a83d6cdcc8182.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*ObajiHGBqRhuuT2aVw0X0Q.png"/></div></figure><p id="2309" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在线性回归中，成本函数代表优化目标，即我们创建一个成本函数并将其最小化，以便我们可以开发一个误差最小的精确模型。</p><p id="8d6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们在“逻辑回归”中使用线性回归的成本函数，那么它会给我们一个具有许多局部最小值的非凸函数，这将使我们难以找到全局最小值。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/8a52b43d3c00c44e2bc266e2c9a83587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KyGDs495_8w4mTZdXRchw.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">非凸函数</figcaption></figure><p id="d8ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于逻辑回归，成本函数定义为:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/04720a22b10b6748361af45352979124.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*5x_UCVApPvnoZquDycSW8w.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/4e8c6820a72e32395b9821d3b6803889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUdFRbkTOH1gr-EBGpDmKg.png"/></div></div></figure><p id="9e9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述两个函数可以写成一个函数，即</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/9edc9e3feae9f4fdd5a818bb32eb8132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*im42B9Cdiq2WOXQ1UdhQjg.png"/></div></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/b5a52eeb82e24888675a66d24f17b856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*7bCPK4sVdF2PmMkqgPHNSg.png"/></div></figure><h1 id="0499" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">梯度下降</h1><p id="1e70" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">现在，我们必须将成本价值降至最低。这可以通过几种方法来完成。其中<strong class="is hj">梯度下降</strong>最简单易懂。</p><p id="df6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，为了最小化成本函数，我们需要对每个参数运行梯度下降函数，即</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/6a2eb63c6f0c27060f3a9400c2f8c6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*hY35356lceVgBZpktFV5ng.png"/></div></figure><p id="3eb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的目标是最小化成本函数，我们必须对每个参数运行梯度下降函数</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/4c7060bdcede906ade562f41b2dde9f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4XODBQbW2s1rOIADPwEGqg.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">梯度下降简化|图片:吴恩达球场</figcaption></figure><p id="ba77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">梯度下降有一个类比，我们必须想象自己在一个山谷的顶部，我们的目标是到达山脚，感受我们周围地形的坡度。这个动作实际上类似于计算梯度下降，并且采取一个步骤类似于更新参数的一次迭代。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/f92aa8271411ada94af42b11b0725e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wsBakfF2Geh1zgY4HJbwFQ.gif"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">梯度下降类比</figcaption></figure><p id="6a0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦我们达到了局部最小值，我们就最小化了我们的成本函数，我们的模型得到了一个假设，给出了几乎准确的结果。</p><p id="9d1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，我们只关注二元分类。现在让我们简要了解一下使用逻辑回归进行多类分类的方法。</p><p id="8bbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多类分类</p><p id="9071" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在多类分类中，我们将输入分为两类以上，例如，从给定的维度识别物体的形状，识别不同种类的车辆，预测颜色类型等。因此，现在不是y = {0，1}，而是y = {0，1…n}。</p><p id="29b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于我们有y = {0，1…n}，我们将我们的问题分成n+1个二进制分类问题。在每个二元分类问题中，我们预测“y”是其中一个类别的成员的概率。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/578c0674b41c38a4ed7db17e08db16f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*UFmVjnkwXI2UPwYjkcD0FQ.png"/></div></figure><p id="d7e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们选择一个类，然后将所有其他类放在一个单独的第二类中。我们一次又一次地这样做，对每个案例应用二元逻辑回归，然后使用返回最高值的假设作为我们的预测。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/2be3f4468dbfa3f59c42a7ebd7d3ccd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*5svw3ZHqg1rHWQt9toAN0w.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">多类分类</figcaption></figure></div></div>    
</body>
</html>