<html>
<head>
<title>How to manage state in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 React 中管理状态</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-manage-state-in-react-62173c8bfa24?source=collection_archive---------12-----------------------#2020-10-30">https://medium.com/analytics-vidhya/how-to-manage-state-in-react-62173c8bfa24?source=collection_archive---------12-----------------------#2020-10-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/b98981d43d1345e2411b7f5b66222aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6VRj89-jxhxDp6NDOmYrA.png"/></div></div></figure><div class=""/><p id="a303" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在管理 react 组件的状态时，有几种方法可以做到。所以首先我们要定义什么是状态和组件</p><p id="5220" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React 代码由称为组件的实体组成。可以使用 React DOM 库将组件呈现给 DOM 中的特定元素。当呈现一个组件时，可以传入被称为“道具”的值</p><p id="93ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">组件的状态是一组管理其内部发生的事情的方法。例如，您有 ComponentWillMount()方法，该方法在组件呈现时执行，并允许您编写代码在组件呈现时进行 API 调用或向组件分配一些数据。</p><p id="5f1e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是可用的方法:</p><p id="1980" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">方法你可以返回一个布尔值，指定 React 是否应该继续渲染。</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0d75" class="jx jy ht jt b fi jz ka l kb kc">shouldComponentUpdate() {<br/>    return false;<br/>  }</span></pre><p id="0d1f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">当组件将要从 DOM 中移除时，调用方法。</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9c20" class="jx jy ht jt b fi jz ka l kb kc">componentWillUnmount() {<br/>  <br/>  }</span></pre><p id="63d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当组件将要从 DOM 中移除时，调用方法。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="52f9" class="jx jy ht jt b fi jz ka l kb kc">componentWillUnmount() {<br/> <br/>  }</span></pre><p id="95b3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">方法在组件初始化之前被调用，这是设置初始状态和其他初始值的自然位置。</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="06d8" class="jx jy ht jt b fi jz ka l kb kc">constructor(props) {<br/>    super(props);<br/>    this.state = {favoritecolor: "red"};<br/><br/> }</span></pre><p id="6da9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">在呈现 DOM 中的元素之前调用方法。</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="a963" class="jx jy ht jt b fi jz ka l kb kc">getDerivedStateFromProps(props, state) {<br/><br/>  }</span></pre><p id="fa80" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">组件在 DOM 中更新后调用方法。</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2224" class="jx jy ht jt b fi jz ka l kb kc">componentDidUpdate() {<br/>}</span></pre><p id="3356" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">react 中管理状态的这种方式是使用基于类的组件，要知道你是否使用基于类的组件，你必须检查你是如何声明组件的。例如</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9ef0" class="jx jy ht jt b fi jz ka l kb kc">class Header extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {favoritecolor: "red"};<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;h1&gt;My Favorite Color is {this.state.favoritecolor}&lt;/h1&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="b358" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个基于类的组件，因为它以类开始，并且有一个构造函数和一个呈现方法。这里要使用状态你必须使用关键字<strong class="is hu"> this </strong>来引用组件，然后 de 属性 state。要初始化状态，可以在构造函数内部或组件内部完成。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9203" class="jx jy ht jt b fi jz ka l kb kc">class Header extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {count: 0};<br/>  }<br/> **** render() {<br/>    return (<br/>      &lt;button onClick={() =&gt; this.setState({count:count+1})}&gt;The count is {this.state.count}&lt;/button&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="98bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们解释如何在基于类的组件中管理状态，但是在 React 中有两种主要的声明组件的方式，即通过功能组件和基于类的组件。</p><h1 id="940e" class="kd jy ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">功能组件</h1><p id="e1d0" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">功能组件是用一个函数声明的，该函数随后返回一些 JSX。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="05ad" class="jx jy ht jt b fi jz ka l kb kc">Let's start with a simple example of a Functional Component in React defined as App which returns JSX:</span><span id="7b84" class="jx jy ht jt b fi lf ka l kb kc">import React from 'react';<br/> <br/>function App() {<br/>  const greeting = 'Hello Function Component!';<br/> <br/>  return &lt;h1&gt;{greeting}&lt;/h1&gt;;<br/>}<br/> <br/>export default App;</span></pre><p id="9ad2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能已经注意到，功能组件是一个没有呈现功能的 React 组件。函数体中定义的一切都是渲染函数，它最终返回 JSX。</p><p id="0847" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">人们称之为功能性无状态组件，因为它们是无状态的，由一个函数来表达。然而，React 钩子使得函数组件中的状态成为可能。</p><h1 id="aa14" class="kd jy ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">基于类的组件</h1><p id="bd8b" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">使用<a class="ae lg" href="https://en.wikipedia.org/wiki/ECMAScript" rel="noopener ugc nofollow" target="_blank"> ES6 </a>类声明基于类的组件。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="c054" class="jx jy ht jt b fi jz ka l kb kc">import React,{Component} from "react"<br/>import ReactDOM from "react-dom"<br/>class MyComponent extends Component {<br/>render() {<br/>return(<br/>&lt;h1&gt; Hello world &lt;/h1&gt;<br/> )<br/>}<br/>}<br/>ReactDOM.render(&lt;MyComponent/&gt; ,document.getElementById('root'))</span></pre><p id="0ae8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">组件的定义以粗体显示。步骤如下:</p><ul class=""><li id="8f5f" class="lh li ht is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated"><code class="du lq lr ls jt b">MyComponent</code>简单地继承自<code class="du lq lr ls jt b">React.Component</code>类。</li><li id="155d" class="lh li ht is b it lt ix lu jb lv jf lw jj lx jn lm ln lo lp bi translated">调用<code class="du lq lr ls jt b">render()</code>方法在浏览器中显示元素。<code class="du lq lr ls jt b">render()</code>本质上是一种生命周期方法。这是在创建基于类的组件中为数不多的新信息之一。</li></ul><h1 id="169a" class="kd jy ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">反应钩</h1><p id="256a" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">挂钩是让开发人员从功能组件“挂钩”反应状态和生命周期特性的功能。它们使代码可读性强，易于理解。钩子在类内部不起作用——它们让你在没有类的情况下使用 React。</p><p id="aa3a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React 提供了一些内置的钩子，比如<code class="du lq lr ls jt b">useState</code>、<code class="du lq lr ls jt b">useContext</code>、<code class="du lq lr ls jt b">useReducer</code>和<code class="du lq lr ls jt b">useEffect</code>等等。它们都在 Hooks API 参考中有说明。使用最多的<code class="du lq lr ls jt b">useState</code>和<code class="du lq lr ls jt b">useEffect</code>分别用于控制 React 组件中的状态和副作用。</p><h1 id="4cd7" class="kd jy ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">钩子的规则</h1><p id="5909" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">钩子也是有规则的，一定要遵守才能用。</p><ol class=""><li id="fb31" class="lh li ht is b it iu ix iy jb lj jf lk jj ll jn ly ln lo lp bi translated">钩子应该只在顶层调用(而不是在循环或 if 语句中)。</li><li id="97cb" class="lh li ht is b it lt ix lu jb lv jf lw jj lx jn ly ln lo lp bi translated">挂钩只能从 React 函数组件调用，而不能从普通函数或类组件调用</li></ol><h1 id="c57b" class="kd jy ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">但是什么是钩子呢？</h1><p id="8b6c" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">挂钩是让您从功能组件“挂钩”React 状态和生命周期特性的功能。钩子在类内部不起作用——它们让你在没有类的情况下使用 React。(我们<a class="ae lg" href="https://reactjs.org/docs/hooks-intro.html#gradual-adoption-strategy" rel="noopener ugc nofollow" target="_blank">不建议</a>在一夜之间重写你现有的组件，但是如果你愿意，你可以在新的组件中使用钩子。)</p><p id="3d0b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React 提供了几个类似<code class="du lq lr ls jt b">useState</code>的内置钩子。您还可以创建自己的挂钩，以便在不同组件之间重用有状态行为。我们先来看看内置挂钩</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="e2df" class="jx jy ht jt b fi jz ka l kb kc">import React, { useState, useEffect } from 'react';</span><span id="a0e2" class="jx jy ht jt b fi lf ka l kb kc">function Example() {<br/>  const [count, setCount] = useState(0);</span><span id="b876" class="jx jy ht jt b fi lf ka l kb kc">  // Similar to componentDidMount and componentDidUpdate:<br/>  useEffect(() =&gt; {<br/>    // Update the document title using the browser API<br/>    document.title = `You clicked ${count} times`;<br/>  });</span><span id="3888" class="jx jy ht jt b fi lf ka l kb kc">  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="ced6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">效果挂钩 useEffect 增加了从函数组件执行副作用的能力。它与 React 类中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 的作用相同，但是统一到一个 API 中。(在使用效果挂钩时，我们将展示将 useEffect 与这些方法进行比较的示例。)</p><p id="b9d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您调用 useEffect 时，您是在告诉 React 在刷新对 DOM 的更改后运行您的“Effect”函数。效果是在组件内部声明的，因此它们可以访问其属性和状态。默认情况下，React 会在每次渲染后运行效果，包括第一次渲染。(在使用效果钩子时，我们将更多地讨论这与类生命周期的比较。)</p><h1 id="dd53" class="kd jy ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">定制挂钩</h1><p id="9cd2" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">构建您自己的钩子(称为定制钩子)可以让您将组件逻辑提取到可重用的函数中。自定义钩子是一个 JavaScript 函数，它的名字以“use”开头，可以调用其他钩子。钩子的规则也适用于它们，也就是说，定制钩子应该按照 React 执行的规则编写，否则很有可能破坏代码的完整性。查看下面的链接，了解创建定制钩子的规则。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b41d" class="jx jy ht jt b fi jz ka l kb kc">import React, { useState } from 'react';</span><span id="5938" class="jx jy ht jt b fi lf ka l kb kc">function Example() {<br/>  // Declare a new state variable, which we'll call "count"<br/>  const [count, setCount] = useState(0);</span><span id="85a7" class="jx jy ht jt b fi lf ka l kb kc">  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="742b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，useState 是一个钩子(我们一会儿会谈到这是什么意思)。我们在函数组件内部调用它，为它添加一些本地状态。React 将在重新渲染之间保持这种状态。useState 返回一对值:当前状态值和一个允许您更新它的函数。您可以从事件处理程序或其他地方调用该函数。它类似于类中的 this.setState，只是它没有将新旧状态合并在一起。(我们将展示一个使用状态钩子比较 useState 和 this.state 的例子。)</p><p id="6f98" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">参考文献:</strong></p><div class="hh hi ez fb hj lz"><a href="https://reactjs.org/docs/hooks-intro.html" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hu fi z dy me ea eb mf ed ef hs bi translated">介绍钩子-反应</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">钩子是 React 16.8 中的新增功能。它们允许您使用状态和其他 React 特性，而无需编写类。这个…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">reactjs.org</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn hp lz"/></div></div></a></div><div class="hh hi ez fb hj lz"><a href="https://reactjs.org/docs/hooks-reference.html" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hu fi z dy me ea eb mf ed ef hs bi translated">钩子 API 参考-反应</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">钩子是 React 16.8 中的新增功能。它们允许您使用状态和其他 React 特性，而无需编写类。这个…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">reactjs.org</p></div></div><div class="mi l"><div class="mo l mk ml mm mi mn hp lz"/></div></div></a></div><div class="hh hi ez fb hj lz"><a href="https://www.geeksforgeeks.org/reactjs-class-based-components/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hu fi z dy me ea eb mf ed ef hs bi translated">ReactJS |基于类的组件</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">基于类的组件是 ReactJS 中构建的大多数现代 web 应用程序的基础。这些组件更简单…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="mi l"><div class="mp l mk ml mm mi mn hp lz"/></div></div></a></div><div class="hh hi ez fb hj lz"><a href="https://www.robinwieruch.de/react-function-component" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hu fi z dy me ea eb mf ed ef hs bi translated">反应功能部件- RWieruch</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">React 功能组件-也称为 React 功能组件-是编写现代 React 的现状…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">www.robinwieruch.de</p></div></div><div class="mi l"><div class="mq l mk ml mm mi mn hp lz"/></div></div></a></div></div></div>    
</body>
</html>