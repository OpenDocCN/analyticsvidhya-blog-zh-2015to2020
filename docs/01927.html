<html>
<head>
<title>Python RegEx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python正则表达式</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-regex-5852186dcbad?source=collection_archive---------19-----------------------#2019-11-21">https://medium.com/analytics-vidhya/python-regex-5852186dcbad?source=collection_archive---------19-----------------------#2019-11-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1a97" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">找到匹配的两种方法</h2></div><p id="9971" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">RegEx或正则表达式是一种小型语言，使用字符串模式在字符串中搜索一个或多个子字符串。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/a663f635ce8798875d424bf13e7977ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pnAkY7Z68BZeCw38"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">照片由<a class="ae kj" href="https://unsplash.com/@pkvoyage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">praewhida K</a>在<a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2142" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">导入re模块后，我们可以使用四种方法进行查询。</p><ul class=""><li id="134a" class="kk kl hi iz b ja jb jd je jg km jk kn jo ko js kp kq kr ks bi translated">匹配()</li><li id="4282" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">搜索()</li><li id="352d" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">findall()</li><li id="caef" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">finditer()</li></ul><p id="40d9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有这四个方法都可以通过两种方式调用，在模块级调用，或者从编译后的模式对象中调用:</p><ul class=""><li id="f6ca" class="kk kl hi iz b ja jb jd je jg km jk kn jo ko js kp kq kr ks bi translated">模块级函数</li></ul><pre class="ju jv jw jx fd ky kz la lb aw lc bi"><span id="b91b" class="ld le hi kz b fi lf lg l lh li">import re</span><span id="7f02" class="ld le hi kz b fi lj lg l lh li">string = "Lorem ipsum dolor sit amet, consectetur adipiscing elit"<br/>pattern = r'\wo'<br/>res = re.search(pattern, string)</span></pre><ul class=""><li id="af1f" class="kk kl hi iz b ja jb jd je jg km jk kn jo ko js kp kq kr ks bi translated">汇编/编译</li></ul><pre class="ju jv jw jx fd ky kz la lb aw lc bi"><span id="6a06" class="ld le hi kz b fi lf lg l lh li">import re</span><span id="c200" class="ld le hi kz b fi lj lg l lh li">string = "Lorem ipsum dolor sit amet, consectetur adipiscing elit"<br/>pattern = re.compile(r'\wo')<br/>res = pattern.search(string)</span></pre><p id="73e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这两者的区别在两个方面:</p><ul class=""><li id="e988" class="kk kl hi iz b ja jb jd je jg km jk kn jo ko js kp kq kr ks bi translated">如何定义模式</li><li id="4eb9" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">如何调用search()函数</li></ul></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="844e" class="lr le hi bd ls lt lu lv lw lx ly lz ma io mb ip mc ir md is me iu mf iv mg mh bi translated">模块级函数</h1><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mi"><img src="../Images/b0178859d570d3ae071ae9e0fedee160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k9pha5qTeYKfVmBt"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">照片由<a class="ae kj" href="https://unsplash.com/@bk71?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝恩德·克鲁奇</a>在<a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1463" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以search()方法为例，我们可以直接从re模块调用它:re.search()</p><pre class="ju jv jw jx fd ky kz la lb aw lc bi"><span id="0409" class="ld le hi kz b fi lf lg l lh li">re.search(r'\wo', "Lorem ipsum dolor sit amet")</span></pre><p id="329d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个参数是模式，可以是文字模式，也可以是编译模式。第二个参数是要搜索的字符串。当然，这两个变量可以用上面例子中的变量代替。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="cbd0" class="lr le hi bd ls lt lu lv lw lx ly lz ma io mb ip mc ir md is me iu mf iv mg mh bi translated">汇编</h1><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mj"><img src="../Images/cfdeb06eca11b66c95a647a7bd6cf44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pMMusWVvuDawrsCD"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">Marc Zimmer 在<a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="91af" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编译正则表达式需要首先用compile()方法创建一个模式。然后使用该模式调用search()，例如。</p><pre class="ju jv jw jx fd ky kz la lb aw lc bi"><span id="648a" class="ld le hi kz b fi lf lg l lh li">import re</span><span id="cb45" class="ld le hi kz b fi lj lg l lh li">pattern = re.compile(r'\wo', re.IGNORECASE)<br/>res = pattern.search("Lorem ipsum dolor sit amet, consectetur adipiscing elit")</span></pre><p id="6c86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用compile()方法创建模式的好处之一是可以提供一个或多个标志来优化搜索过程，这是第二个参数。</p><ul class=""><li id="6fc4" class="kk kl hi iz b ja jb jd je jg km jk kn jo ko js kp kq kr ks bi translated">关于。答/答美国信息交换标准代码</li><li id="5b2b" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">关于。S / re。DOTALL</li><li id="c41c" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">关于。我/ re。IGNORECASE</li><li id="a224" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">关于。L / re。现场</li><li id="f6c3" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">关于。M / re。多线</li><li id="f97c" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">关于。X / re。冗长的</li></ul><p id="847b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查看<a class="ae kj" href="https://docs.python.org/3/howto/regex.html#use-string-methods" rel="noopener ugc nofollow" target="_blank"> Python文档</a>了解这些标志的更多定义</p><p id="1a58" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用pipe: re设置多个标志。我|re。x，忽略大小写并设置verbose/comments。</p><p id="3ae4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就我个人而言，我更喜欢使用编译方法，因为当我使用re.search()时，我总是忘记两个参数的位置，而且我喜欢先设置模式，这样更方便地使用模式来调用search(0方法。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="df71" class="lr le hi bd ls lt lu lv lw lx ly lz ma io mb ip mc ir md is me iu mf iv mg mh bi translated">正则表达式的其他一些注意事项</h1><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mk"><img src="../Images/30e546502f80892fc7b752c0775289b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eoS_Y4eZvBh3N1se"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">凯尔·格伦在<a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="eee8" class="ld le hi bd ls ml mm mn lw mo mp mq ma jg mr ms mc jk mt mu me jo mv mw mg mx bi translated">关于match()、search()、findall()、finditer()</h2><ul class=""><li id="a857" class="kk kl hi iz b ja my jd mz jg na jk nb jo nc js kp kq kr ks bi translated">match()和search()将返回一个匹配，而findall()和finditer()将返回所有匹配。</li><li id="7421" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">match()和search()将返回一个re。Match对象，而findall()返回一个列表，finditer()返回iterable。</li><li id="a7ff" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">match()将只查找字符串开头的匹配项，而search将搜索整个字符串。</li></ul><h2 id="7d80" class="ld le hi bd ls ml mm mn lw mo mp mq ma jg mr ms mc jk mt mu me jo mv mw mg mx bi translated">使用原始字符串</h2><p id="76af" class="pw-post-body-paragraph ix iy hi iz b ja my ij jc jd mz im jf jg nd ji jj jk ne jm jn jo nf jq jr js hb bi translated">正如开始提到的，regex是python中的一种迷你语言，python解释字符串的方式与regex略有不同，最好使用原始字符串来创建模式。</p><h2 id="eff1" class="ld le hi bd ls ml mm mn lw mo mp mq ma jg mr ms mc jk mt mu me jo mv mw mg mx bi translated">一个特殊字符“？”</h2><ul class=""><li id="b138" class="kk kl hi iz b ja my jd mz jg na jk nb jo nc js kp kq kr ks bi translated">不管有没有</li></ul><pre class="ju jv jw jx fd ky kz la lb aw lc bi"><span id="e46b" class="ld le hi kz b fi lf lg l lh li">p = re.compile(r'\d\d\d-?\d\d\d\d')   #with or without "-"<br/>p = re.compile(r'(\d{2})?d')          # with or without (\d{2})</span></pre><ul class=""><li id="9ed9" class="kk kl hi iz b ja jb jd je jg km jk kn jo ko js kp kq kr ks bi translated">匹配子模式但不要捕捉它。((?:模式)模式)</li></ul><pre class="ju jv jw jx fd ky kz la lb aw lc bi"><span id="ef03" class="ld le hi kz b fi lf lg l lh li">&gt;&gt;&gt; p1 = re.compile(r'(\we)+')<br/>&gt;&gt;&gt; p2 = re.compile(r'(?:\we)+')<br/>&gt;&gt;&gt; m1 = p1.search("references")<br/>&gt;&gt;&gt; m2 = p2.search("references")<br/>&gt;&gt;&gt; m1.groups()<br/>('re',)<br/>&gt;&gt;&gt; m2.groups()<br/>()</span></pre><ul class=""><li id="ec8e" class="kk kl hi iz b ja jb jd je jg km jk kn jo ko js kp kq kr ks bi translated">命名匹配子串。(?P <name>图案)</name></li></ul><pre class="ju jv jw jx fd ky kz la lb aw lc bi"><span id="45e7" class="ld le hi kz b fi lf lg l lh li">&gt;&gt;&gt; p = re.compile(r'name is (?P&lt;name&gt;\w+)(\.| )')<br/>&gt;&gt;&gt; m = p.search('Hi, my name is Jack.')<br/>&gt;&gt;&gt; m.group("name")<br/>'Jack'</span><span id="d2a9" class="ld le hi kz b fi lj lg l lh li">&gt;&gt;&gt; p = re.compile(r'am (?P&lt;fname&gt;\w+) (?P&lt;lname&gt;\w+)(\.| )')<br/>&gt;&gt;&gt; m = p.search('Hi, I am Jack London.')<br/>&gt;&gt;&gt; m.groupdict()<br/>{'fname': 'Jack', 'lname': 'London'}</span></pre><p id="8f38" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ps:那个？后面是大写的P</p><ul class=""><li id="2a8e" class="kk kl hi iz b ja jb jd je jg km jk kn jo ko js kp kq kr ks bi translated">前瞻断言。有还是没有</li></ul><pre class="ju jv jw jx fd ky kz la lb aw lc bi"><span id="0c94" class="ld le hi kz b fi lf lg l lh li">(?!...)  # not have it<br/>(?=...)  # have it</span><span id="c275" class="ld le hi kz b fi lj lg l lh li">re.compile(r"""<br/>    .*              # zero or more characters<br/>    [.]             # with a "."<br/>    (?!exe$)        # should not be end with exe after the ".", this is not pattern but a look ahead assertion<br/>    [^.]*$          # zero or more not '.' characters after the "."<br/>""", re.X)</span></pre><h2 id="a2a7" class="ld le hi bd ls ml mm mn lw mo mp mq ma jg mr ms mc jk mt mu me jo mv mw mg mx bi translated">re的方法。匹配对象</h2><ul class=""><li id="ec86" class="kk kl hi iz b ja my jd mz jg na jk nb jo nc js kp kq kr ks bi translated">。group()，。第一组。组()，。groupdict()</li></ul><p id="ea11" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">。group() ==。组(0)</p><pre class="ju jv jw jx fd ky kz la lb aw lc bi"><span id="1270" class="ld le hi kz b fi lf lg l lh li">&gt;&gt;&gt; p = re.compile(r"c(o)?(a)t")<br/>&gt;&gt;&gt; m = p.search('a cat in coat')<br/>&gt;&gt;&gt; m1 = p.search("a coat on cat")<br/>&gt;&gt;&gt; print(m.group(), m.groups())<br/>&gt;&gt;&gt; print(m1.group(), m1.groups())<br/>&gt;&gt;&gt; print(p.findall('a cat in coat'))</span><span id="98d1" class="ld le hi kz b fi lj lg l lh li">cat (None, 'a')          #(o)? returns None ...<br/>coat ('o', 'a')<br/>[('', 'a'), ('o', 'a')]  #(o)? returns "" ...</span></pre><ul class=""><li id="2725" class="kk kl hi iz b ja jb jd je jg km jk kn jo ko js kp kq kr ks bi translated">。span()，。start()，。结束()</li></ul><pre class="ju jv jw jx fd ky kz la lb aw lc bi"><span id="b8a3" class="ld le hi kz b fi lf lg l lh li">&gt;&gt;&gt; p = re.compile(r"c(o)?(a)t")<br/>&gt;&gt;&gt; m = p.search('a cat in coat')<br/>&gt;&gt;&gt; print(m.span(), m.start(), m.end())</span><span id="feed" class="ld le hi kz b fi lj lg l lh li">(2, 5) 2 5</span></pre><p id="1d1b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天到此为止。</p></div></div>    
</body>
</html>