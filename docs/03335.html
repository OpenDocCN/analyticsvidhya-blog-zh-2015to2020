<html>
<head>
<title>Dijkstra and Floyd Warshall</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迪克斯特拉和弗洛伊德·沃肖尔</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dijkstra-and-floyd-warshall-floyd-war-1937d8ac95f0?source=collection_archive---------17-----------------------#2020-01-26">https://medium.com/analytics-vidhya/dijkstra-and-floyd-warshall-floyd-war-1937d8ac95f0?source=collection_archive---------17-----------------------#2020-01-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1a717a483aafdc529c03d9f28c1c7634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wA9pseGK1S7E2ED9"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">托马斯·金托在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="45f3" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">5321.在阈值距离内找到邻居数量最少的城市</h1><p id="3d77" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/find-the-city-with-small-number of-neighbors-at-threshold-distance/</a></p><p id="2840" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/discuss/490275/Python-DP-based-on-Floyd-Warshall" rel="noopener ugc nofollow" target="_blank"> Floyd Warshall </a>算法可以用来解决这个问题，因为问题规模相对较小。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="111e" class="lf iw hi lb b fi lg lh l li lj">class Solution:<br/>    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -&gt; int:<br/>        dis = [[float('inf')]*n for _ in range(n)]<br/>        for a,b, c in edges:<br/>            dis[a][b]=dis[b][a]=c<br/>        for i in range(n):dis[i][i]=0<br/>        for k in range(n):<br/>            for i in range(n):<br/>                for j in range(n):<br/>                    dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j])<br/>        res = {sum(d&lt;=distanceThreshold for d in dis[i]):i for i in range(n)}<br/>        return res[min(res)]</span></pre><p id="a576" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们也可以用朴素的Dijkstra算法来解决这个问题。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a5f6" class="lf iw hi lb b fi lg lh l li lj">import heapq<br/>class Solution:<br/>    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -&gt; int:<br/>        cost = [[float('inf')]*n for _ in range(n)]<br/>        graph = collections.defaultdict(list)<br/>        for a,b,c in edges:<br/>            cost[a][b]=cost[b][a]=c<br/>            graph[a].append(b)<br/>            graph[b].append(a)<br/>            <br/>        def dijkstra(i):<br/>            dis = [float('inf')]*n<br/>            dis[i], pq =0, [(0, i)]<br/>            heapq.heapify(pq)<br/>            while pq:<br/>                # the extract min which is heappop here has the complexit of O(logv) so the whole complexity is O(VlogV)</span><span id="542c" class="lf iw hi lb b fi lk lh l li lj">d, i = heapq.heappop(pq)<br/>                if d&gt; dis[i]:continue<br/>                for j in graph[i]:<br/>                    this_cost = d+cost[i][j]<br/>                    if this_cost&lt;dis[j]:<br/>                        dis[j] = this_cost<br/># the push operation if we use Fibonacci heap, the complexity is O(1), so the complexity is O(E). Hence the overrall complexity is O(E+VlogV)</span><span id="d520" class="lf iw hi lb b fi lk lh l li lj">                        heapq.heappush(pq, (this_cost, j))<br/>            return sum(d&lt;=distanceThreshold for d in dis)-1<br/>        res = {dijkstra(i):i for i in range(n)}<br/>        return res[min(res)]</span></pre><p id="71b6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">为了全面理解dijkstra算法，请阅读维基百科或下面的博客(中文)。</p><div class="ll lm ez fb ln lo"><a href="https://blog.csdn.net/v_JULY_v/article/details/6182419" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi">经典算法研究系列：二之续、彻底理解Dijkstra算法_网络_结构之法 算法之道-CSDN博客</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx">经典算法研究系列：二之续、彻底理解Dijkstra算法 作者：July 二零一一年二月十三日。参考代码：introduction to algorithms，Second…</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">blog.csdn.net</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc io lo"/></div></div></a></div><p id="7093" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">看起来C++是在用二进制堆而不是Fibonacci堆来实现优先级队列。讨论可以在这里找到。在这种情况下，Dijkstra算法的时间复杂度将为O(VlogV+ElogV)= O(V+E)logV = O(ElogV)。当V远小于E时，斐波那契堆将是更好的实现。</p><p id="030e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://www.quora.com/Why-is-the-C++-STL-priority-queue-implemented-using-a-binary-heap-instead-of-a-Fibonacci-heap" rel="noopener ugc nofollow" target="_blank">https://www . quora . com/Why-is-the-c++-STL-priority-queue-implemented-using-a-binary-heap-代替-a-Fibonacci-heap </a></p><p id="f5a3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这里有一个关于Dijkstra算法的很好的解释</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><div class="ll lm ez fb ln lo"><a href="https://en.wikipedia.org/wiki/Fibonacci_heap" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">斐波那契堆</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">在计算机科学中，斐波纳契堆是一种用于优先级队列操作的数据结构，由一组…</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">en.wikipedia.org</p></div></div><div class="lx l"><div class="mf l lz ma mb lx mc io lo"/></div></div></a></div><p id="5c51" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">不同堆的复杂性可以从上面的链接中找到。这里有一个简短的总结:</p><p id="3bf9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">二进制堆和Fibonacci堆的复杂度在delete-min上是O(log V ),在find-min上是O(1)。然而，Fibonacci对于insert和decrease键都具有O(1)的复杂度。而对于这两种操作，二进制堆的复杂度都是O(log V)。</p><p id="7e6b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">对于本帖提到的问题的代码实现，我们没有使用减键操作。相反，使用了本机插入，在这种情况下，我们可能在队列中有重复的节点，因为一些节点有更大的键。这将以某种方式破坏O(VlogV)的复杂性，因为我们可能有KV而不是V，其中K是指定节点的平均重复数。但是，这样做，Dijkstra的实现就简单多了。我们将时间复杂度从O(VlogV+E)增加到O(KVlogKV+E ),将空间复杂度从O(V)增加到O(KV)。</p><p id="ef63" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">似乎C++和JAVA都不支持减键操作。而是使用惰性删除。</p><p id="0fed" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">“虽然我的回答不会回答原来的问题，但我认为它可能对试图在C++/Java中实现Dijkstra算法的人(像我自己)有用，这是OP的一个评论，</p><p id="db1c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">C++中的<code class="du mg mh mi lb b">priority_queue</code>(或Java中的<code class="du mg mh mi lb b">PriorityQueue</code>)不提供<code class="du mg mh mi lb b">decrease-key</code>操作，如前所述。在实现Dijkstra时使用这些类的一个很好的技巧是使用“惰性删除”。Dijkstra算法的主循环从优先级队列中提取下一个要处理的节点，并分析其所有相邻节点，最终改变优先级队列中节点的最小路径的成本。这就是通常需要<code class="du mg mh mi lb b">decrease-key</code>来更新该节点的值的地方。</p><p id="20d9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">诀窍是根本不要改变<em class="mj">它</em>。相反，该节点的“新副本”(具有其新的更好的成本)被添加到优先级队列中。由于成本较低，该节点的新副本将在队列中的原始副本之前被提取，因此它将被更早地处理。</p><p id="a7ae" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这种“懒惰删除”的问题是，具有较高坏成本的节点的第二个副本最终将从优先级队列中提取出来。但是这总是发生在具有更好成本的第二个添加的副本被处理之后。因此<em class="mj">当从优先级队列中提取下一个节点时，主Dijkstra循环必须做的第一件事</em>是检查该节点是否以前被访问过(并且我们已经知道最短路径)。正是在这个时候，我们将进行“惰性删除”，该元素必须被简单地忽略。</p><p id="a8b4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个解决方案在内存和时间上都是有代价的，因为优先级队列存储了我们没有删除的“死元素”。但是真正的成本将会非常小，而且，依我看，对这种解决方案进行编程，比试图模拟缺失的<code class="du mg mh mi lb b">decrease-key</code>操作的任何其他替代方案都要容易”</p><p id="d1f9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">详情可从下面的链接中找到。</p><div class="ll lm ez fb ln lo"><a href="https://stackoverflow.com/questions/9209323/easiest-way-of-using-min-priority-queue-with-key-update-in-c/9210662" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">在C++中使用带有密钥更新的最小优先级队列的最简单方法</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">嗯，正如Darren已经说过的，std::priority_queue没有降低元素优先级的方法，而且…</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">stackoverflow.com</p></div></div><div class="lx l"><div class="mk l lz ma mb lx mc io lo"/></div></div></a></div><h2 id="8166" class="lf iw hi bd ix ml mm mn jb mo mp mq jf ke mr ms jj ki mt mu jn km mv mw jr mx bi translated">使用标准Dijkstra算法的另一个问题是</h2><h2 id="b76d" class="lf iw hi bd ix ml mm mn jb mo mp mq jf ke mr ms jj ki mt mu jn km mv mw jr mx bi translated">1514年。概率最大的路径</h2><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d4a2" class="lf iw hi lb b fi lg lh l li lj">class Solution {<br/>public:<br/>    double maxProbability(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;double&gt;&amp; succProb, int start, int end) {<br/>        // using this 2d vector will get MLE. <br/>       // vector&lt;vector&lt;float&gt;&gt;cost(n, vector&lt;float&gt;(n, 0));<br/>        map&lt;pair&lt;int,int&gt;, float&gt; cost;<br/>        unordered_map&lt;int, vector&lt;int&gt;&gt; graph;<br/>        for(int i=0;i&lt;edges.size();++i)<br/>        {<br/>            auto a = edges[i][0], b = edges[i][1];<br/>            if(a&lt;b)<br/>            {<br/>                cost[make_pair(a,b)] = succProb[i];<br/>            }<br/>            else<br/>            {<br/>                cost[make_pair(b,a)] = succProb[i];<br/>            }<br/>            graph[a].push_back(b);<br/>            graph[b].push_back(a);<br/>        }<br/>        <br/>        vector&lt;float&gt; dis(n, 0.0);<br/>        dis[start] = 1.0;<br/>        priority_queue&lt;pair&lt;float, int&gt;&gt; pq;<br/>        pq.emplace(1.0, start);<br/>        while (!pq.empty())<br/>        {<br/>            auto d = pq.top().first;<br/>            auto i = pq.top().second;<br/>            pq.pop();<br/>            if (d&lt;dis[i])continue;<br/>            for (auto j: graph[i])<br/>            {<br/>                auto p = 0.0;<br/>                if(i&lt;j)<br/>                {<br/>                    if(cost.count(make_pair(i,j)))p=cost[make_pair(i,j)];<br/>                }<br/>                else<br/>                {<br/>                    if(cost.count(make_pair(j,i)))p=cost[make_pair(j,i)];<br/>                }<br/>                auto this_cost = d*p;<br/>                if (this_cost&gt;dis[j])<br/>                {<br/>                    dis[j] = this_cost;<br/>                    pq.emplace(this_cost, j);<br/>                }<br/>            }<br/>        }<br/>        return dis[end];<br/>    }<br/>};</span></pre><p id="cbb1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们也可以用更简洁的方式来写</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b392" class="lf iw hi lb b fi lg lh l li lj">typedef pair&lt;int, double&gt; id;<br/>typedef pair&lt;double , int&gt; di;</span><span id="7dbe" class="lf iw hi lb b fi lk lh l li lj">class Solution {<br/>public:<br/>    double maxProbability(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;double&gt;&amp; succProb, int start, int end) {<br/>        vector&lt;vector&lt;id&gt;&gt; graph(n);<br/>        for (int i=0; i&lt;edges.size();++i)<br/>        {<br/>            auto u = edges[i][0], v = edges[i][1];<br/>            auto p = succProb[i];<br/>            graph[u].emplace_back(v, p);<br/>            graph[v].emplace_back(u, p);<br/>        }<br/>        vector&lt;double&gt; dis(n, 0.0);<br/>        dis[start] = 1.0;<br/>        priority_queue&lt;di&gt; Q;<br/>        Q.emplace(1.0, start);<br/>        while (!Q.empty())<br/>        {<br/>            auto [cost, u] = Q.top();<br/>            Q.pop();<br/>            // we can not set the condition here as cost&lt;=dis[u], as the first time when we are going to further explore, the condition is exactly cost==dis[u]. for example, ititially the dis[1] = 0.0. Then we updte it dis[1] = 0.5 and put it into the priority queue. Later, when we be back again, we did not explore the neighbors of 1, we SHOULD explore it. And the condition here is exactly dis[1] == 0.5.<br/>            if (cost &lt;dis[u]) continue;<br/>            for (auto [v, p]: graph[u])<br/>            {<br/>                auto this_cost = cost*p;<br/>                if(this_cost&gt;dis[v])<br/>                {<br/>                    dis[v] = this_cost ;<br/>                    Q.emplace(this_cost, v);<br/>                }<br/>            }<br/>        }<br/>        cout&lt;&lt;endl;<br/>        return dis[end];<br/>    }<br/>};</span></pre><p id="4450" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">Dijkstra算法的标准实现</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e2b6" class="lf iw hi lb b fi lg lh l li lj">typedef pair&lt;int, double&gt; id;<br/>typedef pair&lt;double , int&gt; di;</span><span id="47cf" class="lf iw hi lb b fi lk lh l li lj">class Solution {<br/>public:<br/>    double maxProbability(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;double&gt;&amp; succProb, int start, int end) {<br/>        vector&lt;vector&lt;id&gt;&gt; graph(n);<br/>        for (int i=0; i&lt;edges.size();++i)<br/>        {<br/>            auto u = edges[i][0], v = edges[i][1];<br/>            auto p = succProb[i];<br/>            graph[u].emplace_back(v, p);<br/>            graph[v].emplace_back(u, p);<br/>        }<br/>        vector&lt;double&gt; dis(n, -1.0);<br/>        priority_queue&lt;di&gt; Q;<br/>        Q.emplace(1.0, start);<br/>        while (!Q.empty())<br/>        {<br/>            auto [cost, u] = Q.top();<br/>            Q.pop();<br/>            if (dis[u] !=-1.0) continue;<br/>            dis[u] = cost;<br/>            if (u==end) return dis[end]==-1.0?0.0:dis[end]; <br/>            for (auto [v, p]: graph[u])<br/>            {<br/>                auto this_cost = cost*p;<br/>                Q.emplace(this_cost, v);<br/>            }<br/>        }<br/>        return  dis[end]==-1.0?0.0:dis[end];<br/>    }<br/>};</span></pre><h1 id="19c4" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">为什么在Dijkstra算法中不允许负权边？</h1><p id="7f13" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">参见[2]。</p><h1 id="f53a" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">另一个例子</h1><p id="a3a7" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们也可以使用Floyd Warshall算法来解决下面的问题。</p><p id="20f3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/course-schedule-iv" rel="noopener ugc nofollow" target="_blank"> 1462年。课程表四</a></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6c0e" class="lf iw hi lb b fi lg lh l li lj">int dp[100+10][100+10];<br/>class Solution {<br/>public:<br/>    vector&lt;bool&gt; checkIfPrerequisite(int n, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;int&gt;&gt;&amp; queries) <br/>    {<br/>        memset(dp, 0, sizeof(dp));<br/>        for (auto p : prerequisites)<br/>        {<br/>            dp[p[0]][p[1]] = 1;<br/>        }<br/>        for (int k = 0; k &lt; n; ++k)<br/>            for (int i = 0; i &lt; n; ++i)<br/>                for (int j = 0; j &lt; n; ++j)<br/>                    dp[i][j] = dp[i][j] || (dp[i][k] &amp;&amp; dp[k][j]);<br/>        vector&lt;bool&gt; ret;<br/>        for (auto q : queries)<br/>            ret.push_back(dp[q[0]][q[1]]);<br/>        return ret;<br/>    }<br/>};</span></pre><h1 id="9299" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">参考</h1><p id="d6ac" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">[1]https://youtu.be/DAaEMGJk70A<a class="ae iu" href="https://youtu.be/DAaEMGJk70A" rel="noopener ugc nofollow" target="_blank"/></p><p id="8d5b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">[2]https://blog.csdn.net/bhh77611355/article/details/27181285<a class="ae iu" href="https://blog.csdn.net/bhh77611355/article/details/27181285" rel="noopener ugc nofollow" target="_blank"/></p><p id="7814" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">[3]<a class="ae iu" href="https://www.cnblogs.com/gaochundong/p/dijkstra_algorithm.html" rel="noopener ugc nofollow" target="_blank">https://www . cnblogs . com/Gao chun dong/p/Dijkstra _ algorithm . html</a></p></div></div>    
</body>
</html>