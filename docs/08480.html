<html>
<head>
<title>Dask for Python and Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 和机器学习 Dask</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dask-for-python-and-machine-learning-dbe1356b5d7a?source=collection_archive---------7-----------------------#2020-07-31">https://medium.com/analytics-vidhya/dask-for-python-and-machine-learning-dbe1356b5d7a?source=collection_archive---------7-----------------------#2020-07-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3fc2f74027abaf640f396196e8fb0b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nKXwmAjQZ1TmCtFowxGfIQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="df8b" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">路标</h1><ul class=""><li id="f700" class="jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><a class="ae iu" href="#bfd0" rel="noopener ugc nofollow">Dask 上的茶话会</a></li><li id="248d" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated"><a class="ae iu" href="#ddb9" rel="noopener ugc nofollow">为什么达斯克是一个引人注目的人？</a></li><li id="1f1e" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated"><a class="ae iu" href="#5e82" rel="noopener ugc nofollow"> Dask 工作量</a><br/><a class="ae iu" href="#6bc6" rel="noopener ugc nofollow">Dask 总体是什么？</a> <br/> <a class="ae iu" href="#feb9" rel="noopener ugc nofollow">工作量机制</a></li><li id="c7a4" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated"><a class="ae iu" href="#8026" rel="noopener ugc nofollow"> Dask 集合</a> <br/>高级 API: Dataframe、数组、包、Sklearn <br/>低级 API: Delayed、Futures</li><li id="de1f" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated"><a class="ae iu" href="#a327" rel="noopener ugc nofollow">达斯克的阴暗面</a></li><li id="ff82" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">Spark v/s Dask </li></ul></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><p id="4678" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi lo translated">最近我遇到了一个非常有趣的 Python 库，叫做 DASK。它是一个开源的 python 库，具有独特的并行性和可伸缩性。它既可以在本地系统上扩展，也可以在一个机器集群上扩展。它在 Python 相关开发或构建 ML/AI 模型方面创造了自己的空间。</p><p id="0cdd" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated">那么，就从它开始吧。🍵</p><h1 id="bfd0" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">达斯克的茶话会</h1><ul class=""><li id="e6a1" class="jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Dask 是一个<strong class="jv hj">开源</strong> python 库，在 python 中具有并行性和可伸缩性的特性。</li><li id="89ce" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">默认情况下包含在 Anaconda 发行版中。</li><li id="22fa" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">Dask 重用现有的 Python 库，如 pandas 或 numpy，并通过增加可伸缩性来增强它们。另外，<strong class="jv hj"> sklearn 相关的 ML </strong>算法也实现了。</li><li id="c4ba" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">Dask 在数据争论方面表现更好<strong class="jv hj">处理千兆字节的海量数据</strong>比熊猫和<strong class="jv hj">直播数据</strong>就像 Spark 一样</li></ul><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/e4d159707fccbd5369eb8c5a1a42109f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*AduF_lh71BI-TjzXwjKlzA.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="http://httpstwitter.comJohnMillerTXstatus1002186463629504512photo1" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><ul class=""><li id="6773" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated">Dask 遵循<strong class="jv hj">惰性计算</strong>机制，只有在明确请求时才会执行计算。</li></ul><p id="48a3" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated"><strong class="jv hj"> <em class="mf">例如，</em> </strong></p><p id="be81" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated">假设，油漆房间的四面墙，一个油漆工在 4 天内完成，而两个油漆工一次最多需要 2 天。这突出了速度和时间的性能，这也是 Dask 所采用的。</p><h1 id="ddb9" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">为什么 Dask 是一个节目主持人？</h1><ul class=""><li id="a8a1" class="jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="jv hj">利用 PyData 栈中的并行性</strong><br/>py data 栈中的库如 pandas 和 numpy 都是针对单 CPU 内核构建的，这导致了以下问题:<br/> 1 .读取大于 RAM 大小的 python 对象(如 dataframe)会导致<strong class="jv hj">内存不足错误</strong>并使系统崩溃。<br/> 2。运行可能需要<strong class="jv hj">很长时间。<br/> Dask 绕过全局解释器锁(GIL),<strong class="jv hj">通过内部分块 python 对象并并行处理它们来利用多 CPU 内核</strong>。</strong></li></ul><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/03d52f07d7c3b9e0f301a5847f7e62db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*mmf23SwVjzwVtVVXQb5rEQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://subscription.packtpub.com/book/big_data_and_business_intelligence/9781784393670/1/ch01lvl1sec7/the-scientific-python-stack" rel="noopener ugc nofollow" target="_blank"> PyDatatack </a></figcaption></figure><ul class=""><li id="5bef" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated"><strong class="jv hj">可扩展性和分布式计算</strong> <br/> DASK 可以在单个 CPU 上处理大型数据集，利用单个机器或机器集群上的多个内核进行并行计算。</li><li id="2dcb" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated"><strong class="jv hj">内存限制</strong>在熊猫中当大量数据要被读取和处理时。</li></ul><blockquote class="mh"><p id="b010" class="mi mj hi bd mk ml mm mn mo mp mq kg dx translated"><a class="ae iu" href="https://github.com/shachi01/dask_in_python_ml/blob/master/efficient_read_csv.ipynb" rel="noopener ugc nofollow" target="_blank">以优化的方式演示如何在 Python 中读取大型 CSV 文件</a></p><p id="60ba" class="mi mj hi bd mk ml mr ms mt mu mv kg dx translated"><a class="ae iu" rel="noopener" href="/analytics-vidhya/optimized-ways-to-read-large-csvs-in-python-ab2b36a7914e?source=friends_link&amp;sk=01a85157b1a4b2d203a2bc45ab674a4b">要获得更多见解，浏览一下这个博客。</a></p></blockquote><ul class=""><li id="35a4" class="jt ju hi jv b jw mw jy mx ka my kc mz ke na kg kh ki kj kk bi translated">Dask 允许像 Spark 一样的实时数据流，这在熊猫身上是不可能的。</li><li id="33a1" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated"><strong class="jv hj">易于调试和诊断</strong> <br/>美观的<strong class="jv hj"> dask 仪表盘</strong>可持续监控机器的运行进度和性能。</li><li id="5fe8" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated"><strong class="jv hj">一次读取多个 csv</strong><br/>Pandas 使用 read_csv()将单个 CSV 读入内存，但无法将多个 CSV 读入一个。但是 dask 可以像 Spark 一样使用通配符。</li></ul><h1 id="5e82" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">Dask 工作负载</h1><h2 id="6bc6" class="nb iw hi bd ix nc nd ne jb nf ng nh jf ka ni nj jj kc nk nl jn ke nm nn jr no bi translated"><strong class="ak">Dask 整体是什么？</strong></h2><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es np"><img src="../Images/abf138a06e1a5118e7fd1972efbb7642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*XmK9o_-qP80_jFcu6XFVrw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 1</figcaption></figure><p id="69c5" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated">Dask 基本上是用高级和低级 API 构建的，由调度程序监控进程。这一节将更多地讨论调度器，下一节将讨论这些 API。</p><h2 id="feb9" class="nb iw hi bd ix nc nd ne jb nf ng nh jf ka ni nj jj kc nk nl jn ke nm nn jr no bi translated"><strong class="ak">工作量机制</strong></h2><ul class=""><li id="30c2" class="jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Dask 使用了<strong class="jv hj">惰性评估</strong>的概念，这意味着只有当<strong class="jv hj"> compute()被调用时才生成结果。</strong>该执行通过由任务调度器协调的以下 DAG 来执行。</li></ul><p id="51ab" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated">漫威:任务调度器</p><ul class=""><li id="e2ce" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated">图 1 所示的任务调度器协调“分而治之”的计算，利用 CPU 内核之间的并行性。</li><li id="0b49" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">如图 2 所示，任务图是在内存中创建的，任务按顺序在调用 compute()时执行。</li><li id="ecf6" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">它创建并<strong class="jv hj">管理一个有向无环图(DAG) </strong>来建模任务的逻辑表示，也称为任务图。它通过将任务分配给节点工作器进行并行计算，生成单个结果来进行管理。</li></ul><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/45ff3758118603364b4465fd9a699fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*IKbzJFw0xXPIrFjPTsvs-A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://docs.dask.org/en/latest/" rel="noopener ugc nofollow" target="_blank">图二</a></figcaption></figure><p id="279a" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated"><strong class="jv hj">另一个漫威:达格</strong></p><ul class=""><li id="5806" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated">用节点和边表示关系的无环有向图。</li><li id="5932" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">由任务调度程序构造，表示计算结果的步骤。</li><li id="3dc4" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">定向为向上到其终端节点的单向移动</li><li id="b59e" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">visualize()用于将其可视化，如下所示。</li></ul><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es nr"><img src="../Images/1cb5235e945ebfc7c0210fb6bb3cff01.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*M5xgkXK3e5-0F7PI9OPEdA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://examples.dask.org/delayed.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="8026" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">达斯克收藏</h1><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es ns"><img src="../Images/28dc3259f372dfaffe97f7bb2368b80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*uNPS83mGWHE1he3BL2aKyg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 3</figcaption></figure><p id="2093" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated">图 3 中命名的集合分布在单个 CPU 的多核上，然后并行计算。</p><h2 id="5409" class="nb iw hi bd ix nc nd ne jb nf ng nh jf ka ni nj jj kc nk nl jn ke nm nn jr no bi translated">高级 API</h2><ol class=""><li id="8e27" class="jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg nt ki kj kk bi translated"><strong class="jv hj"> Dask 数组:</strong>(并行 Numpy，即 numpy +线程)</li></ol><ul class=""><li id="e472" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated">一个大的 dask 阵列被分成小的 numpy 阵列，分布在多个 CPU 内核上，以<strong class="jv hj">并行</strong>方式运行。</li><li id="1f49" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">加载，即使它们比 RAM 大<strong class="jv hj"/></li><li id="4edc" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">dask 阵列上的任何操作都会在小块上触发相同的操作，每个小块都利用一个内核。这个<strong class="jv hj">加速了计算。</strong></li></ul><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es nu"><img src="../Images/3d1d53845d5535c2062885dc7bb29f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*pVXn5d5yT_OeSxY3uE-r4A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://docs.dask.org/en/latest/array.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="9f06" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated"><strong class="jv hj"> 2。Dask 数据帧:</strong>(平行熊猫，即熊猫+线程)</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es nv"><img src="../Images/23433d7c3d2c6204f836874225c4f9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*kNMon217vbHM1hrByN9jHA.png"/></div></figure><ul class=""><li id="c9d2" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated">与 dask array 相同，一个大数据帧<strong class="jv hj">按照索引</strong>分块成小熊猫数据帧，如图 4 所示，分布在多个 CPU 内核上，并行运行。</li><li id="1cf8" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">加载数据帧<strong class="jv hj">，即使它大于 RAM </strong>。对于实际操作，查看<a class="ae iu" rel="noopener" href="/analytics-vidhya/optimized-ways-to-read-large-csvs-in-python-ab2b36a7914e?source=friends_link&amp;sk=01a85157b1a4b2d203a2bc45ab674a4b">在 Python 中读取大型 CSV 的优化方法</a>。</li><li id="2e77" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">同时在块上执行时也加快了计算速度。</li></ul><p id="e3c0" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated"><strong class="jv hj"> 3。Dask 包:</strong>(平行列表，即列表+穿线)</p><ul class=""><li id="2cc8" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated">Python 对象的并行集合，即更大集合的分区。</li><li id="150a" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">在处理<strong class="jv hj">半或非结构化数据</strong> <br/> <em class="mf">时使用，例如，</em>预处理 JSON、日志文件或文本数据。此外，用户定义的 python 对象。</li></ul><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es nw"><img src="../Images/1fa7821a78bc0e707324f75bc150cb00.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*UMBriucsXmlBWdar-8rpxA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://docs.dask.org/en/latest/bag.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><ul class=""><li id="cd0f" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated"><em class="mf">受益者:</em> <br/>在读取嵌套 JSON 的情况下，包是有帮助的，可以在以后<strong class="jv hj">转换成 dask 数据帧</strong>。</li><li id="b100" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated"><em class="mf">局限性:</em> <br/> 1 .不能改变包的元素，因为它是不可变的。<br/> 2。groupby 函数非常慢。</li></ul><p id="50ae" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated"><strong class="jv hj"> 4。Dask-ML: </strong>(并行 Scikit-learn，即 sklearn+线程)</p><ul class=""><li id="12cd" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated">这个 Dask 库和 sklearn 一样用于构建 ML 模型。</li><li id="55c0" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">使用内部 dask 集合并行化 ML 算法</li><li id="9c11" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">Dask 通过 Joblib 使用现有的 sklearn 估算器和具有 n_jobs 参数的算法进行并行化。它使用 joblib backend 在计算量很大的集群上并行化。</li><li id="c037" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">也可以利用外部库，比如 xgboost 或 tf。</li></ul><blockquote class="mh"><p id="ceda" class="mi mj hi bd mk ml mm mn mo mp mq kg dx translated">就我个人而言，我会说 Dask 仍在为 ML 改进。即使构建一个简单的线性模型，许多正在进行的问题仍然是活跃的。</p></blockquote><h2 id="04f1" class="nb iw hi bd ix nc nx ne jb nf ny nh jf ka nz nj jj kc oa nl jn ke ob nn jr no bi translated">低级 API</h2><ol class=""><li id="d73d" class="jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg nt ki kj kk bi translated"><strong class="jv hj"> Dask 延迟:</strong>(懒惰的平行物体)</li></ol><ul class=""><li id="26a9" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated">延迟的 dask 对象本质上是<strong class="jv hj">懒惰的</strong>，这意味着只有在显式调用 compute()函数时才会被计算。</li><li id="62c9" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">通过将延迟对象包装在函数周围，这些对象相当于 DAG 节点。</li><li id="0e2e" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">任务之间的相互依赖产生了执行和构建 DAG 的一系列步骤。</li><li id="b689" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">对延迟对象调用 compute()会调用调度程序来处理并行资源，并逐步计算 DAG，从而生成结果。</li></ul><p id="e54b" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated"><strong class="jv hj"> 2。达斯克期货:</strong>(热切的平行对象)</p><ul class=""><li id="af1d" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated">期货 dask 接口计算<strong class="jv hj">立即</strong>不太可能延迟对象。</li><li id="04d5" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated"><strong class="jv hj">实时</strong>执行</li><li id="db9b" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">与 dask 数组、数据帧等不同，<strong class="jv hj">需要 Dask 客户端</strong>才能使用未来接口。</li></ul><blockquote class="mh"><p id="e5e8" class="mi mj hi bd mk ml mm mn mo mp mq kg dx translated">在这个<a class="ae iu" href="https://github.com/shachi01/dask_in_python_ml" rel="noopener ugc nofollow" target="_blank"> github 资源库</a>中找到我的实践经验。</p></blockquote><h1 id="a327" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg oc ji jj jk od jm jn jo oe jq jr js bi translated">达斯克的阴暗面</h1><p id="32a1" class="pw-post-body-paragraph kx ky hi jv b jw jx la lb jy jz ld le ka of lg lh kc og lj lk ke oh lm ln kg hb bi translated">使用 Dask 时，需要考虑一些限制。</p><ol class=""><li id="5d0f" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg nt ki kj kk bi translated">熊猫不像 Dask，擅长优化复杂的 SQL 查询。</li><li id="2939" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg nt ki kj kk bi translated">对于那些对并行计算具有挑战性的操作，如排序和洗牌，效果并不好。或者在未排序的数据帧中建立新的索引。</li></ol><h1 id="1bef" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">火花 v/s Dask</h1><p id="0fa0" class="pw-post-body-paragraph kx ky hi jv b jw jx la lb jy jz ld le ka of lg lh kc og lj lk ke oh lm ln kg hb bi translated">除了一些不同之处，并行性和可伸缩性的特性与 Spark 有些相似。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es oi"><img src="../Images/cb99ac6260152e75c6a7cbea202cb0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*Ckss8tX9X7gsrSHTtA_adw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">沙池</figcaption></figure><h1 id="8375" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">参考</h1><ul class=""><li id="303b" class="jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Dask 官方最新文档</li></ul><div class="oj ok ez fb ol om"><a href="https://docs.dask.org/en/latest/" rel="noopener  ugc nofollow" target="_blank"><div class="on ab dw"><div class="oo ab op cl cj oq"><h2 class="bd hj fi z dy or ea eb os ed ef hh bi translated">Dask-Dask 2 . 21 . 0+15 . g26e 722 f 0 . dirty 文档</h2><div class="ot l"><h3 class="bd b fi z dy or ea eb os ed ef dx translated">Dask 由两部分组成:针对计算优化的动态任务调度。这类似于气流，路易吉…</h3></div><div class="ou l"><p class="bd b fp z dy or ea eb os ed ef dx translated">docs.dask.org</p></div></div></div></a></div><ul class=""><li id="006d" class="jt ju hi jv b jw kz jy lc ka mc kc md ke me kg kh ki kj kk bi translated">很棒的书，可以亲自动手</li></ul><div class="oj ok ez fb ol om"><a href="https://www.amazon.in/Data-Science-Scale-Python-Dask/dp/1617295604" rel="noopener  ugc nofollow" target="_blank"><div class="on ab dw"><div class="oo ab op cl cj oq"><h2 class="bd hj fi z dy or ea eb os ed ef hh bi translated">使用 Python 和 Dask 的数据科学</h2><div class="ot l"><h3 class="bd b fi z dy or ea eb os ed ef dx translated">摘要 Dask 是一款原生并行分析工具，旨在与您已有的库无缝集成…</h3></div><div class="ou l"><p class="bd b fp z dy or ea eb os ed ef dx translated">www .亚马逊. in</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa io om"/></div></div></a></div></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><p id="4ebd" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated">如果你喜欢这位作者的博客，请随意关注，因为这位作者保证会带来更多有趣的人工智能相关内容。<br/> 谢谢，<br/>学习愉快！😄</p><p id="8e49" class="pw-post-body-paragraph kx ky hi jv b jw kz la lb jy lc ld le ka lf lg lh kc li lj lk ke ll lm ln kg hb bi translated"><strong class="jv hj"> <em class="mf">可以通过</em></strong><a class="ae iu" href="https://www.linkedin.com/in/kaul-shachi" rel="noopener ugc nofollow" target="_blank"><strong class="jv hj"><em class="mf">LinkedIn</em></strong></a><strong class="jv hj"><em class="mf">取得联系。</em>T13】</strong></p></div></div>    
</body>
</html>