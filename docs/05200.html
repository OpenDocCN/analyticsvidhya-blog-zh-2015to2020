<html>
<head>
<title>Java-Object Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/java-object-oriented-programming-55ecbfb1559e?source=collection_archive---------39-----------------------#2020-04-13">https://medium.com/analytics-vidhya/java-object-oriented-programming-55ecbfb1559e?source=collection_archive---------39-----------------------#2020-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a4c7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">面向对象编程的基本概念</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/d8a111eb8fc32d2e5a16b67870ada429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*WFC1hRhNR4-5W6uPjlOSTg.png"/></div></figure><p id="b7fd" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi kb translated"><span class="l kc kd ke bm kf kg kh ki kj di"> H </span> ello朋友们，上一篇文章，我跟你们讨论了关于类和对象的问题。我想你明白了。所以在这篇文章中，我打算和你讨论一下<strong class="jh hj">的传承</strong>。</p><h1 id="9506" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">遗产</h1><p id="ed24" class="pw-post-body-paragraph jf jg hi jh b ji lc ij jk jl ld im jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated"><strong class="jh hj">什么是传承？</strong></p><p id="86d3" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">继承用于从现有的类中组织和创建可重用的类。继承是面向对象编程中的另一个基本概念。</p><p id="5a14" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">此外……</strong></p><p id="503f" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因此，我们将现有的类称为父类或超类或基类，并将派生类命名为子类或子类。子类继承父类的特征。程序员可以添加新的变量或方法，也可以修改继承的变量或方法。</p><p id="7f3d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">如何创建继承？</strong></p><blockquote class="lh li lj"><p id="cc20" class="jf jg lk jh b ji jj ij jk jl jm im jn ll jp jq jr lm jt ju jv ln jx jy jz ka hb bi translated">例句:我们用旧手机给父母上课，用新手机给孩子上课。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lo"><img src="../Images/bc3298d77c4df7231ff06eb29b1ae2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2annXaAMhgepb50IqsvbMA.jpeg"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lt"><img src="../Images/09cf53a5ae81e786b360ac62fc14c874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xqk8t9pDK2fmQmloFVUqQQ.jpeg"/></div></div></figure><p id="deee" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在新的phone类(子类)中，它从旧的phone类(超类)中获取实质内容。因此我们可以在一个UML类图中展示上面的例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lv"><img src="../Images/115a901c4764e621745b9e62aee27a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*fGXmeDon3A66TLY09OMFyg.jpeg"/></div></figure><p id="5d21" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在UML图中，有一个指向父类的开放箭头。</p><blockquote class="lw"><p id="d9db" class="lx ly hi bd lz ma mb mc md me mf ka dx translated">继承应该创建一个is-a关系，这意味着子节点是父节点的更具体的版本</p></blockquote><p id="daa8" class="pw-post-body-paragraph jf jg hi jh b ji mg ij jk jl mh im jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated"><strong class="jh hj">各种形式的继承</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ml"><img src="../Images/f879452af6e90a06d7cb325f676dd4ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yu4tT4bfw8un-GP7N4bAtg.jpeg"/></div></div></figure><p id="fdaa" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">不仅继承，访问修饰符也非常重要。所以让我们讨论一下访问修饰符。</p><p id="0600" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">什么是访问修饰符？</strong></p><p id="7776" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">java中的访问修饰符指定了字段、方法、构造函数或类的可访问性或范围。我们还可以通过应用来改变字段、构造函数、方法和类的访问级别。</p><p id="60d4" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有4种类型的访问修饰符。</p><ol class=""><li id="cdd5" class="mm mn hi jh b ji jj jl jm jo mo js mp jw mq ka mr ms mt mu bi translated">私人的</li><li id="2efb" class="mm mn hi jh b ji mv jl mw jo mx js my jw mz ka mr ms mt mu bi translated">默认</li><li id="7949" class="mm mn hi jh b ji mv jl mw jo mx js my jw mz ka mr ms mt mu bi translated">保护</li><li id="3833" class="mm mn hi jh b ji mv jl mw jo mx js my jw mz ka mr ms mt mu bi translated">公共</li></ol><p id="0da7" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj"> 1。私有访问修饰符</strong>。</p><p id="a7a2" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这个修饰符中，可以从类外部访问它</p><p id="2ac1" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj"> 2。默认访问修饰符</strong>。</p><p id="7735" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在此修饰符中，访问级别仅与包相关。不能从包外部访问。因此，当您不定义任何访问级别时，它将是默认的。</p><p id="0e2d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj"> 3。受保护的访问修饰符</strong></p><p id="03e2" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">访问级别在包和包内，通过子类。因此，如果不创建子类，就不能从包的外部访问。</p><p id="8ded" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj"> 4。公共访问修改器</strong></p><p id="e720" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">访问级别无处不在。它可以从类内、类外、包内和包外访问。</p><p id="65b6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是一个表格，你可以很容易地理解访问修饰符的用法。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es na"><img src="../Images/2dd682b501636009a7def6e3e193d451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5RagDhN2xDNJL9WLy-nb6g.jpeg"/></div></div></figure><p id="fee4" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">作为本课的总结，我与您讨论了继承和访问修饰符。我认为，你从这篇文章中学到了一些新的东西。</p><h2 id="70f5" class="nb kl hi bd km nc nd ne kq nf ng nh ku jo ni nj kw js nk nl ky jw nm nn la no bi translated">下一章，我希望给你介绍方法重载和方法覆盖。</h2></div></div>    
</body>
</html>