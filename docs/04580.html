<html>
<head>
<title>Using Cron Jobs to deploy FCM Push Notifications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Cron作业部署FCM推送通知</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/using-cron-jobs-to-deploy-fcm-push-notifications-6c3ef1a375c7?source=collection_archive---------6-----------------------#2020-03-25">https://medium.com/analytics-vidhya/using-cron-jobs-to-deploy-fcm-push-notifications-6c3ef1a375c7?source=collection_archive---------6-----------------------#2020-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/9fa5f80d3b6cd7e42c3559f670c63b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*JM-v7gbkyjQ3olu-fBpvgw.png"/></div></figure><div class=""/><p id="f87d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi jk translated"><span class="l jl jm jn bm jo jp jq jr js di"> P </span> ush通知是应用程序使用的第一个也是最重要的沟通渠道。几乎每个主要的应用程序都使用推送通知来处理交易和重新参与。这是每个产品必不可少的跟踪指标。最近的一项研究显示，移动用户平均每天收到63.5条通知，其中大部分来自消息和电子邮件应用。</p><h1 id="9ef0" class="ju jv hp bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">我们开始吧！！</h1><p id="a201" class="pw-post-body-paragraph im in hp io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">以下库将用于实现自动推送通知服务:<em class="kx"><br/>Firebase Messaging Android SDK<br/>pyfcm<br/>python-crontab</em></p><blockquote class="ky kz la"><p id="8e8c" class="im in kx io b ip iq ir is it iu iv iw lb iy iz ja lc jc jd je ld jg jh ji jj hb bi translated">使用MySQL客户端的完整实现可从<a class="ae jt" href="https://github.com/nikhil-sachdeva/parati-notifications" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></blockquote><h2 id="b948" class="le jv hp bd jw lf lg lh ka li lj lk ke ix ll lm ki jb ln lo km jf lp lq kq lr bi translated">本教程可以分为3个步骤:</h2><ol class=""><li id="c9b4" class="ls lt hp io b ip ks it kt ix lu jb lv jf lw jj lx ly lz ma bi translated">在应用程序中集成Firebase和FCM服务。</li><li id="ca48" class="ls lt hp io b ip mb it mc ix md jb me jf mf jj lx ly lz ma bi translated">使用<em class="kx"> pyfcm实现通知服务。</em></li><li id="41ff" class="ls lt hp io b ip mb it mc ix md jb me jf mf jj lx ly lz ma bi translated">通过<em class="kx"> python-crontab使用Cron作业自动化服务。</em></li></ol><h2 id="a77b" class="le jv hp bd jw lf lg lh ka li lj lk ke ix ll lm ki jb ln lo km jf lp lq kq lr bi translated">第一步</h2><p id="8204" class="pw-post-body-paragraph im in hp io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">使用<a class="ae jt" href="https://firebase.google.com/docs/android/setup" rel="noopener ugc nofollow" target="_blank">官方文档</a>和<a class="ae jt" href="https://console.firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> firebase控制台</a>将Firebase集成到app中。然后，将云消息Android库的依赖项添加到您的模块(应用程序级)Gradle文件(通常是<code class="du mg mh mi mj b">app/build.gradle</code>)中:</p><pre class="mk ml mm mn fd mo mj mp mq aw mr bi"><span id="0171" class="le jv hp mj b fi ms mt l mu mv">implementation 'com.google.firebase:firebase-messaging:20.1.2'</span></pre><p id="b3b2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">根据<a class="ae jt" href="https://firebase.google.com/docs/cloud-messaging/android/client" rel="noopener ugc nofollow" target="_blank"> Firebase文档</a>上的教程创建<code class="du mg mh mi mj b"><a class="ae jt" href="https://firebase.google.com/docs/reference/android/com/google/firebase/messaging/FirebaseMessagingService" rel="noopener ugc nofollow" target="_blank">FirebaseMessagingService</a> </code>。</p><p id="85b1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用<code class="du mg mh mi mj b">onNewToken</code>方法检索FCM令牌。服务将使用此令牌向设备发送推送通知。理想情况下，对于每个用户的生命周期，在用户“登录”时将令牌发送到服务器。为此，请实现以下方法。</p><pre class="mk ml mm mn fd mo mj mp mq aw mr bi"><span id="021d" class="le jv hp mj b fi ms mt l mu mv">FirebaseInstanceId.getInstance().getInstanceId()<br/>        .addOnCompleteListener(new OnCompleteListener&lt;InstanceIdResult&gt;() {<br/>            @Override<br/>            public void onComplete(@NonNull Task&lt;InstanceIdResult&gt; task) {<br/>                if (!task.isSuccessful()) {<br/>                    Log.w(TAG, "getInstanceId failed", task.getException());<br/>                    return;<br/>                }<br/><br/>                // Get new Instance ID token<br/>                String token = task.getResult().getToken();</span><span id="473f" class="le jv hp mj b fi mw mt l mu mv">                sendTokenToServer(token);<br/><br/>            }<br/>        });</span></pre><p id="adf2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将使用<em class="kx"> sendTokenToServer() </em>方法将令牌发送到后端数据库，以便根据每个用户ID进行存储。例如，在REST框架中，可以在这里调用POST查询，根据每个用户ID保存令牌。</p><figure class="mk ml mm mn fd hk er es paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="er es mx"><img src="../Images/34406773c840e7145fbb20af052b952a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f73JFzfYkAl43zJ15v9pqw.png"/></div></div><figcaption class="nc nd et er es ne nf bd b be z dx translated">FCM架构</figcaption></figure><h2 id="c8a0" class="le jv hp bd jw lf lg lh ka li lj lk ke ix ll lm ki jb ln lo km jf lp lq kq lr bi translated">第二步</h2><p id="b533" class="pw-post-body-paragraph im in hp io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">现在我们将使用<code class="du mg mh mi mj b"><a class="ae jt" href="https://github.com/olucurious/pyfcm" rel="noopener ugc nofollow" target="_blank">olucurious/PyFCM</a> </code>库向多个设备发送推送通知。有两种方法可以做到这一点— &gt;要么为设备订阅一个主题，要么向FCM令牌列表发送通知。使用<br/>firebase console-&gt;Settings-&gt;Cloud Messaging获取API密钥。</p><h2 id="66b2" class="le jv hp bd jw lf lg lh ka li lj lk ke ix ll lm ki jb ln lo km jf lp lq kq lr bi translated">使用pyfcm发送到FCM令牌列表:</h2><p id="f06f" class="pw-post-body-paragraph im in hp io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">在这种方法中，只有服务器端代码必须编写如下。运行这个python脚本会将消息作为通知发送给设备列表，这些设备的FCM令牌被添加到<em class="kx">registration _ id列表中。</em></p><pre class="mk ml mm mn fd mo mj mp mq aw mr bi"><span id="dbc4" class="le jv hp mj b fi ms mt l mu mv"># Send to single device.<br/>from pyfcm import FCMNotification</span><span id="22b9" class="le jv hp mj b fi mw mt l mu mv">push_service = FCMNotification(api_key="&lt;api-key&gt;")</span><span id="61b1" class="le jv hp mj b fi mw mt l mu mv"># Send to multiple devices by passing a list of ids.</span><span id="9d01" class="le jv hp mj b fi mw mt l mu mv">registration_ids = ["&lt;device registration_id 1&gt;", "&lt;device registration_id 2&gt;", ...]<br/>message_title = "Uber update"<br/>message_body = "Hope you're having fun this weekend, don't forget to check today's news"<br/>result = push_service.notify_multiple_devices(registration_ids=registration_ids, message_title=message_title, message_body=message_body)<br/><br/>print result</span></pre><h2 id="468f" class="le jv hp bd jw lf lg lh ka li lj lk ke ix ll lm ki jb ln lo km jf lp lq kq lr bi translated">使用主题订阅发送通知:</h2><p id="aaa0" class="pw-post-body-paragraph im in hp io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">客户端代码:</p><pre class="mk ml mm mn fd mo mj mp mq aw mr bi"><span id="7fa2" class="le jv hp mj b fi ms mt l mu mv">FirebaseMessaging.getInstance().subscribeToTopic("weather")<br/>        .addOnCompleteListener(new OnCompleteListener&lt;Void&gt;() {<br/>            @Override<br/>            public void onComplete(@NonNull Task&lt;Void&gt; task) {<br/>                String msg = getString(R.string.msg_subscribed);<br/>                if (!task.isSuccessful()) {<br/>                    msg = getString(R.string.msg_subscribe_failed);<br/>                }<br/>                Log.d(TAG, msg);<br/>                Toast.makeText(MainActivity.this, msg, Toast.LENGTH_SHORT).show();<br/>            }<br/>        });</span></pre><p id="5d95" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">服务器端代码:</p><pre class="mk ml mm mn fd mo mj mp mq aw mr bi"><span id="5ca1" class="le jv hp mj b fi ms mt l mu mv">push_service = FCMNotification(SERVER_KEY)<br/>tokens = [<br/>    &lt;registration_id_1&gt;,<br/>    &lt;registration_id_2&gt;,<br/>]<br/><br/>subscribed = push_service.subscribe_registration_ids_to_topic(tokens, 'test')<br/>result = push_service.notify_topic_subscribers(topic_name="weather", message_body=message)<br/><br/><br/>result = push_service.notify_topic_subscribers(message_body=message)</span></pre><blockquote class="ky kz la"><p id="2a3a" class="im in kx io b ip iq ir is it iu iv iw lb iy iz ja lc jc jd je ld jg jh ji jj hb bi translated">重要提示:在python脚本中编写应该触发通知的事件的条件。对于每个FCM令牌，检查用户数据库并根据要求创建条件。</p></blockquote><h2 id="e409" class="le jv hp bd jw lf lg lh ka li lj lk ke ix ll lm ki jb ln lo km jf lp lq kq lr bi translated">第三步</h2><p id="cf34" class="pw-post-body-paragraph im in hp io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">现在为了自动化这个脚本并以固定的时间间隔运行它，将使用<a class="ae jt" href="https://pypi.org/project/python-crontab/" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> python-crontab </em> </a>。</p><pre class="mk ml mm mn fd mo mj mp mq aw mr bi"><span id="cac0" class="le jv hp mj b fi ms mt l mu mv">pip install python-crontab</span></pre><p id="031d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在单独的python文件中，实现一个新的Cron作业，如下所示:</p><pre class="mk ml mm mn fd mo mj mp mq aw mr bi"><span id="25d2" class="le jv hp mj b fi ms mt l mu mv">from crontab import CronTab</span><span id="588f" class="le jv hp mj b fi mw mt l mu mv">cron = CronTab(user='UserName')</span><span id="e01c" class="le jv hp mj b fi mw mt l mu mv">job = cron.new(command='command')</span><span id="a7a8" class="le jv hp mj b fi mw mt l mu mv">job.minute.every(1)</span><span id="9df7" class="le jv hp mj b fi mw mt l mu mv">cron.write()</span></pre><p id="53a2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在命令中，编写脚本需要遵循的命令。这些命令将作为一个<em class="kx"> sh shell脚本</em>从根目录运行。因此，更改保存项目的目录。还有，<em class="kx"> python </em> as命令不能直接使用。必须在命令中提供其路径。要做到这一点，运行"<em class="kx"> whereis python </em>"如下所示。</p><figure class="mk ml mm mn fd hk er es paragraph-image"><div class="er es ng"><img src="../Images/3e686d752acc039db1be697440d3fdcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*ePf9CZOhcV7EQl_pQwHasA.png"/></div><figcaption class="nc nd et er es ne nf bd b be z dx translated">查找已安装库的路径。</figcaption></figure><p id="6c5a" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在将命令更改为以下内容。</p><pre class="mk ml mm mn fd mo mj mp mq aw mr bi"><span id="6bc3" class="le jv hp mj b fi ms mt l mu mv">job = cron.new(command='cd Documents/project-notifs &amp;&amp; /usr/bin/python notifications.py')</span></pre><p id="e4d2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">根据要求确定时间间隔，并运行此python脚本。要检查在后台运行的cron作业，您可以在终端中运行<em class="kx"> crontab -l </em>。如果您希望在python脚本中使用库，请确保使用带有pip install 的<em class="kx"> -H标志将它们安装在主目录中。</em></p><p id="0feb" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，您可以在您的系统上运行这个cron作业，或者在任何<a class="ae jt" href="https://www.whoishostingthis.com/compare/cron-jobs/" rel="noopener ugc nofollow" target="_blank">托管网站</a>上托管这个作业。</p><blockquote class="ky kz la"><p id="1a8c" class="im in kx io b ip iq ir is it iu iv iw lb iy iz ja lc jc jd je ld jg jh ji jj hb bi translated">在我做的一个项目中找到完整的实现<a class="ae jt" href="https://github.com/nikhil-sachdeva/parati-notifications" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote></div></div>    
</body>
</html>