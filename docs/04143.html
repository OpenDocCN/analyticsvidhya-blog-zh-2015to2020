<html>
<head>
<title>AUTOML — TPOT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TPOT汽车公司</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/automl-tpot-9a83509e021f?source=collection_archive---------15-----------------------#2020-03-06">https://medium.com/analytics-vidhya/automl-tpot-9a83509e021f?source=collection_archive---------15-----------------------#2020-03-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/24f76eb9e85727003d3ad45d4b272eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*XF3akvvCtNu3u2745BPBLQ.jpeg"/></div></figure><p id="dfbf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">自动化<a class="ae jk" href="https://en.wikipedia.org/wiki/Machine_learning" rel="noopener ugc nofollow" target="_blank">机器学习</a> (AutoML)是一个热门的新领域，其目标是使选择机器学习算法、它们的参数设置和预处理方法变得容易，从而提高它们在大数据中检测复杂模式的能力。</p><p id="9ed3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">基于树的管道优化工具(TPOT)是为数据科学社区开发的首批AutoML方法和开源软件包之一。TPOT是由Randal Olson博士在宾夕法尼亚大学计算遗传学实验室与Jason H. Moore博士一起做博士后时开发的，目前仍由该团队扩展和支持。</p><p id="62c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">TPOT代表基于树的管道优化工具。把TPOT当成你的数据科学助理。TPOT是一个Python自动化机器学习工具，它使用遗传编程优化机器学习管道。TPOT利用基于Python的scikit-learn库作为它的ML菜单。</p><figure class="jm jn jo jp fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jl"><img src="../Images/14e06224c336d01064a8433ea609f9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yc5A3nvnQjC8k7HGdsXFxg.png"/></div></div></figure><p id="1a42" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">【https://github.com/EpistasisLab/tpot】参考:Github网址:<a class="ae jk" href="https://github.com/EpistasisLab/tpot" rel="noopener ugc nofollow" target="_blank">T5】</a></p><h1 id="4b3f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">遗传表演程序</h1><p id="0156" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">遗传编程(GP)是进化算法(EA)的一种，是机器学习的一个子集。进化算法用于发现人类不知道如何直接解决的问题的解决方案。摆脱了人类的先入之见或偏见，EAs的自适应特性可以产生与人类最大努力相当甚至更好的解决方案。*</p><p id="ba69" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有了正确的数据、计算能力和机器学习模型，你可以发现任何问题的解决方案，但知道使用哪个模型对你来说可能是一个挑战，因为有太多这样的模型，如决策树、SVM、KNN等。</p><p id="439a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是基因编程可以发挥巨大作用并提供帮助的地方。遗传算法受达尔文自然选择过程的启发，它们用于生成计算机科学中优化和搜索问题的解决方案。</p><p id="91c0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">广义地说，遗传算法有三个特性:</p><ul class=""><li id="46f1" class="kx ky hi io b ip iq it iu ix kz jb la jf lb jj lc ld le lf bi translated">选择:你有一个给定问题的可能解决方案的群体和一个适应度函数。在每次迭代中，您都要评估如何用您的适应度函数来适应每个解决方案。</li><li id="e55c" class="kx ky hi io b ip lg it lh ix li jb lj jf lk jj lc ld le lf bi translated">交叉:然后你选择最合适的，并执行交叉，以创造一个新的群体。</li><li id="9a9b" class="kx ky hi io b ip lg it lh ix li jb lj jf lk jj lc ld le lf bi translated">变异:你用一些随机的修改使这些孩子变异，并重复这个过程，直到你得到最合适或最好的解决方案。</li></ul><h1 id="b06f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">装置</h1><p id="6b49" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated"><strong class="io hj">要在您的系统上安装tpot，您可以运行命令</strong></p><p id="7415" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> &gt; &gt; &gt; pip安装tpot </strong></p><p id="a876" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">在命令行终端上。它建立在几个现有的Python库之上</strong></p><p id="426c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">或点击</strong> <a class="ae jk" href="https://pypi.org/project/TPOT/#files" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj">链接</strong> </a> <strong class="io hj">下载。</strong></p><h1 id="783a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">手写数字数据集</h1><p id="59f5" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">下面是一个手写数字数据集光学识别的最小工作示例。</p><pre class="jm jn jo jp fd ll lm ln lo aw lp bi"><span id="6b8b" class="lq jv hi lm b fi lr ls l lt lu">from tpot import TPOTClassifier<br/>from sklearn.datasets import load_digits<br/>from sklearn.model_selection import train_test_split</span><span id="d74b" class="lq jv hi lm b fi lv ls l lt lu">digits = load_digits()<br/>X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,<br/>                                                    train_size=0.75, test_size=0.25, random_state=42)</span><span id="5e8f" class="lq jv hi lm b fi lv ls l lt lu">tpot = TPOTClassifier(generations=5, population_size=50, verbosity=2, random_state=42)<br/>tpot.fit(X_train, y_train)<br/>print(tpot.score(X_test, y_test))<br/>tpot.export('tpot_digits_pipeline.py')</span></pre><p id="579a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">运行这段代码应该会发现一个达到大约98%测试准确率的管道，相应的Python代码应该会导出到<strong class="io hj"> tpot_pipeline.py </strong>文件中，如下所示:</p><pre class="jm jn jo jp fd ll lm ln lo aw lp bi"><span id="0bd0" class="lq jv hi lm b fi lr ls l lt lu">import numpy as np<br/>import pandas as pd<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.pipeline import make_pipeline, make_union<br/>from sklearn.preprocessing import PolynomialFeatures<br/>from tpot.builtins import StackingEstimator<br/>from tpot.export_utils import set_param_recursive</span><span id="3514" class="lq jv hi lm b fi lv ls l lt lu"><strong class="lm hj"># NOTE: Make sure that the outcome column is labeled 'target' in the data file</strong><br/>tpot_data = pd.read_csv('PATH/TO/DATA/FILE', sep='COLUMN_SEPARATOR', dtype=np.float64)</span><span id="c5e9" class="lq jv hi lm b fi lv ls l lt lu">features = tpot_data.drop('target', axis=1)                                            </span><span id="f00b" class="lq jv hi lm b fi lv ls l lt lu">training_features, testing_features, training_target, testing_target =train_test_split(features, tpot_data['target'], random_state=42)</span><span id="fc59" class="lq jv hi lm b fi lv ls l lt lu"><strong class="lm hj"># Average CV score on the training set was: 0.9799428471757372</strong></span><span id="db94" class="lq jv hi lm b fi lv ls l lt lu">exported_pipeline = make_pipeline(<br/>    PolynomialFeatures(degree=2, include_bias=False, interaction_only=False),<br/>    StackingEstimator(estimator=LogisticRegression(C=0.1, dual=False, penalty="l1")),<br/>    RandomForestClassifier(bootstrap=True, criterion="entropy", max_features=0.35000000000000003, min_samples_leaf=20, min_samples_split=19, n_estimators=100)<br/>)</span><span id="8340" class="lq jv hi lm b fi lv ls l lt lu"><strong class="lm hj"># Fix random state for all the steps in exported pipeline</strong></span><span id="d6be" class="lq jv hi lm b fi lv ls l lt lu">set_param_recursive(exported_pipeline.steps, 'random_state', 42)</span><span id="4d8a" class="lq jv hi lm b fi lv ls l lt lu">exported_pipeline.fit(training_features, training_target)<br/>results = exported_pipeline.predict(testing_features)</span></pre><p id="517a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">希望以上的解释能让你对AutoML有一个清晰的总结。</p></div></div>    
</body>
</html>