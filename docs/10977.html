<html>
<head>
<title>Fast and Reliable Stockmarket Backtesting. Pandas Parallel Tips #3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速可靠的股票市场回溯测试。熊猫平行小贴士#3</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/fast-and-reliable-stockmarket-backtesting-pandas-parall-tips-3-5ec984249852?source=collection_archive---------10-----------------------#2020-11-11">https://medium.com/analytics-vidhya/fast-and-reliable-stockmarket-backtesting-pandas-parall-tips-3-5ec984249852?source=collection_archive---------10-----------------------#2020-11-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bf446513e04aad7e6a41fe55708fe7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0qxNWyICQn0Gqm_rw8xTQ.jpeg"/></div></div></figure><p id="a8db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在前两个技巧中，我展示了如何获取数据集中每个交易日的n大动量股票列表。主要目标是实现简洁明了的代码，首先使计算更可靠，然后更快。</p><p id="161d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是怎么真的快呢？使用前一篇文章中给出的代码输出该表大约需要42秒:它获得6600个具有20年价格历史的报价机(1800万行)作为输入，并返回包含3只表现最好的股票的表(15.5万行)。</p><p id="031e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问题是:“我们能否在不牺牲可靠性的情况下减少时间？”<br/>答案是:“是的，使用并行处理。”</p><p id="8741" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的第一点是了解我们是否可以用必须分成几个块的数据进行独立计算。我们来分析一下:</p><ul class=""><li id="4d94" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">首先，我们获取单个股票的价格历史，并计算其每天的第n个动量；</li><li id="7e56" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">然后我们把每一天的动量分类；</li><li id="c326" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">并在特定日期保留3只(5，10，n)表现最好的股票。</li></ul><p id="c762" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，第一次计算可以并行进行，根据不同的报价机列表将价格数据分成几个子集。例如，我有6600家公司的价格历史记录，而我的电脑有12个处理器，所以我可以将整个数据集分成12个块，这样每个块都包含550家公司的完整价格历史记录。获得个股动量后，算法将12个表重组为一个更大的表，然后我们可以排序并保存。</p><p id="d875" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些功能如下:</p><figure class="kc kd ke kf fd ij"><div class="bz dy l di"><div class="kg kh l"/></div></figure><ul class=""><li id="67e0" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">“动量”函数总是计算当前数据集的第n个动量；</li><li id="4634" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">“split_prices”函数将总共6600个报价机数据集分成12个较小的数据集；</li><li id="ebcc" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">“parallel_momentum”函数将18M行价格历史数据、动量值(我们愿意计算)、PC内核数量作为输入，运行“n_cores”并行计算，并返回(几乎)相同的18M行数据集，但每个日期都有动量。</li></ul><p id="4773" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们需要做的就是将获得的动量从最好到最差排序，并从每个日期中选出表现最好的3个。代码如下:</p><figure class="kc kd ke kf fd ij"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="2879" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们所看到的，以这种方式完成的并行计算可以让我们节省大约25%的计算时间:在输出相同的情况下，计算时间从42秒减少到32秒。</p><p id="b298" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是如果我们测量代码不同部分的执行时间，我们会发现最长的是那些对Pandas数据帧进行操作的部分。例如，在函数" split_prices "中有这样的操作:</p><pre class="kc kd ke kf fd ki kj kk kl aw km bi"><span id="4c3c" class="kn ko hi kj b fi kp kq l kr ks">prices[prices['Ticker'].isin(cur_tickers)]</span></pre><p id="e548" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一部分中，该算法获取报价器列表，并告诉Pandas查看所有行的1800万行数据，并在“报价器”列中返回包含这些报价器的数据。这是一个相当长的操作。因此，让我们用一个新的函数“split_prices_fast”替换函数“split_prices”:</p><figure class="kc kd ke kf fd ij"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="d0f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用这种拆分数据的方法运行并行计算，可以为我们带来7秒钟的额外计算加速:</p><figure class="kc kd ke kf fd ij"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="3d0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，现在我们的并行算法比最初的算法快了近1.7倍。</p><p id="827f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是完美的极限是零时间运行代码，所以肯定有可以改进的地方。至于“split_prices_fast”功能:没有评论是为了给你一个机会一步一步地拆解它自己在做什么。</p></div></div>    
</body>
</html>