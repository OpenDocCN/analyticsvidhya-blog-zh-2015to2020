<html>
<head>
<title>Logistic Regression With Geometric Formulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有几何公式的逻辑回归</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/logistic-regression-with-geometric-formulation-5b2cccb7a973?source=collection_archive---------20-----------------------#2020-06-08">https://medium.com/analytics-vidhya/logistic-regression-with-geometric-formulation-5b2cccb7a973?source=collection_archive---------20-----------------------#2020-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2dca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated"><span class="l je jf jg bm jh ji jj jk jl di"> L </span>逻辑回归是一种用于分类的机器学习技术，名称为回归，但实际上是一种分类技术，用于发现因变量和自变量之间的关系，也有许多名称，如logit log函数等。它主要用于二元分类，其中一个或多个因变量是自变量</p><p id="8a34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是可以扩展的，像数据集这样的几个类包含像猫狗大象等图像。它在0和1之间分配概率并将它们相加，这是关于逻辑回归的一个简单解释，因此让我们深入研究逻辑回归的精确公式，并执行一些数学运算来选择逻辑回归</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es jm"><img src="../Images/07c3cc95c034f90700d6143306b2cecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/0*DdfHKevArm0RkyxT"/></div></figure><h1 id="4c18" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak"> <em class="ks">用几何方法进行逻辑回归</em> </strong></h1><p id="dddf" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">逻辑回归可以通过三种方法进行，如几何概率和损失函数。在本文中，我们将尝试执行逻辑回归的几何公式。</p><p id="f40f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在给出的图中简单解释逻辑回归。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ky"><img src="../Images/882a41b7497c3d08d01ec0b96c100139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bIxiEX8LrIgxyuUn"/></div></div></figure><p id="ffa6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定的图显示了由<strong class="ih hj"> <em class="ld">超平面“𝝅”分隔的正和负两个数据帧，并且在该图中正常具有“w”</em></strong>，其中<strong class="ih hj"> <em class="ld"> 0 </em> </strong>被表示为正点，<strong class="ih hj"> <em class="ld"> X </em> </strong>被表示为负点</p><p id="6aa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">其中𝝅=w^t*x+b是一个超平面的条件</em> </strong></p><p id="35e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">物流回归的假设</em> </strong></p><p id="dd80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.在逻辑回归中，类几乎是线性可分的，如上图所示</p><p id="5d4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">逻辑回归的任务是找到最佳的可分离𝝅，它完美地分离正负点</p><p id="27dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们举一个给定数据集的例子。</p><p id="67aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<strong class="ih hj"> <em class="ld"> 𝝅=w^t*x+b ……一个平面的方程</em> </strong></p><p id="3a65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld"> Dn = {+Ve，-Ve} ………………………………..正负数据集</em>和</strong></p><p id="7b0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld"> di =正点到超平面的距离</em> </strong></p><p id="7da7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld"> dj =负点到超平面的距离</em> </strong></p><p id="c523" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">逻辑回归的任务是找到<strong class="ih hj"> <em class="ld"> w &amp; b </em> </strong>其中<strong class="ih hj"> <em class="ld"> w </em> </strong>是超平面的法线，<strong class="ih hj"> <em class="ld"> b </em> </strong>是截距</p><p id="81e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们给定的数据集是包含正负点的用<strong class="ih hj">表示<em class="ld">易</em>表示</strong></p><p id="324e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">yi =+1<em class="ld">为正点</em>为正点</strong></p><p id="2a9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Yi = -1为负点</p><p id="7314" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">伊·，+1)</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es le"><img src="../Images/4be371e5d24f223f21520e155ae1dca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*I5Xs45o2h1lGDeK5"/></div></div></figure><p id="716d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此图中，我们可以定义di的值，即</p><p id="43f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">迪= w^t | Xi/| w |</em>|</strong></p><p id="2e58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<strong class="ih hj"> <em class="ld"> W </em> </strong>是平面的法线，假设<strong class="ih hj"> <em class="ld"> W </em> </strong>是单位矢量||W||=1</p><p id="250e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，xi属于平面和法线的正侧，因此di在另一侧是正的，dj属于平面和法线的相对侧，因此它们是负的，但是在给定的数据集中，有一些点也被错误分类，如图所示</p><p id="68ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此给定数据集和分类器</p><p id="5c98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">迪= W^t Xi &gt; 0 </em> </strong></p><p id="bad4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">t17】DJ = w^t XJ&lt;0t19】</strong></p><p id="f21c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以如果<strong class="ih hj"><em class="ld">0&gt;</em></strong>那么易= +1</p><p id="d31e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和<strong class="ih hj"><em class="ld">XJ&lt;0</em></strong>然后Yi = -1</p><p id="f904" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">逻辑回归中的决策面是直线或平面</p><p id="43ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们讨论一些案例进行分类</p><p id="e860" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">案例编号. 1: </em> </strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lf"><img src="../Images/c97f0584770708737d034874e8d7a261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/0*kQ7JR30J_9lUZ7Qd"/></div></figure><p id="8814" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设所有的数据点都属于超平面的正侧，并且也垂直于该平面，那么在这种情况下</p><p id="6981" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">伊=+1</p><p id="3ed5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么分类器被分类为正点(+Ve)，并且实际数据点也是正的，那么w被正确分类。</p><p id="a6c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">情况一的结论:如果平面是正的(Yi=+1)并且分类器也被预测为正的，则我们的平面被正确分类</em> </strong></p><p id="192e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">案例编号2 : </em> </strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lg"><img src="../Images/1e6fd5d834e0e373cf7e31051a27ce7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/0*uAkAlWHBNUCVGbUI"/></div></figure><p id="9049" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设所有的点都属于负边，与超平面相对，那么<strong class="ih hj"> <em class="ld"> Yi = -1 </em> </strong>然后<strong class="ih hj"><em class="ld">【w^t*xi = 0</em></strong>但是在这种情况下，实际点是负的，预测点也是负的，所以当我们将负和负相乘时，我们得到正</p><p id="c58f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld"> Yi*W^t*Xi &gt; 0……..那么易=+Ve </em> </strong></p><p id="2aea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">案例二的结论:</em> </strong></p><p id="1a3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">所以如果我们在一个数据集中取了一个负的点(Yi)并且分类器也被预测为负，那么Yi*W^t*Xi &gt; 0那么我们可以说逻辑回归模型正确地分类了数据集中的这个点。</em>T59】</strong></p><p id="450c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">案例编号3: </em> </strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lh"><img src="../Images/e2119cb17f8b35fe736eaa3fcfd98062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/0*3UGdqZdVcrEGcCq8"/></div></figure><p id="34fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果实际点是负的，在数据集中显示为红色，但是分类器被预测为正的，那么<strong class="ih hj"><em class="ld">&lt;0</em></strong>因此分类器的等式是<strong class="ih hj"><em class="ld">&lt;0</em></strong>…………………………………………<strong class="ih hj"><em class="ld">yi =-1(实际点)</em> </strong></p><p id="6d29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是模型被预测为<strong class="ih hj"> <em class="ld">【正(+Ve)】</em></strong>它们对于错误分类是会发生的</p><p id="9db7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">案例编号4 : </em> </strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es li"><img src="../Images/82389fdae756214c2824950024734ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/0*EM3-CKHiVSjliwvf"/></div></figure><p id="1d7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，数据集中的实际点是正的，但被错误分类，而模型被预测为负的，因此<strong class="ih hj"> <em class="ld"> Yi=+1 </em> </strong>(实际点)但预测点是<strong class="ih hj"> <em class="ld">负的(-Ve) </em> </strong>即模型被错误分类，<strong class="ih hj"><em class="ld">&lt;0</em></strong></p><p id="8991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">总结所有这些案例</em> </strong></p><p id="fc07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"/></p><p id="f520" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们讨论数学公式，方程是</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lj"><img src="../Images/09005953db635a8d46bd2ed1cd1c85b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/0*dtcvY3nBv0aVThdZ"/></div></figure><p id="5cf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中:</p><p id="b473" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld"> n </em> </strong> =是数据点</p><p id="1b7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">易&amp;</strong>=训练数据集</p><p id="f775" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="ld"/></strong>=变量</p><p id="c89b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题是如何优化这个方程，以作出正确的分类和减少误分类</p><p id="75f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用科学的方式写出给定的等式:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lk"><img src="../Images/d73b7bc600a380a02f7ea23721bfcc44.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*9K5_bZe6gxUiBCCH"/></div></figure><p id="fbc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<strong class="ih hj"> <em class="ld"> w* </em> </strong>是最优的，最佳的<strong class="ih hj"> <em class="ld"> w </em> </strong>任务是找到最佳的<strong class="ih hj"> <em class="ld">【超平面】</em></strong>w(超平面)，最大化<strong class="ih hj"> <em class="ld">正分类(+Ve) </em> </strong>，最小化<strong class="ih hj"> <em class="ld">负点(-Ve) </em> </strong></p><blockquote class="ll lm ln"><p id="af02" class="if ig ld ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">乙状结肠功能:</em> </strong></p></blockquote><p id="2218" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述函数中的问题是如何选择最佳的和最好的分类器，以减少误分类</p><p id="a0e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们首先了解异常值是如何导致错误分类的，然后了解如何通过使用sigmoid函数来最小化错误分类</p><p id="eec2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">案例1 </em> </strong>:假设一些随机的数据点分类</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lr"><img src="../Images/87262fc50f468d48a78b16e6c0117d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/0*PKbWneGFVUhYPV7e"/></div></figure><p id="8619" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由平面Pi和法线W分开，一些<strong class="ih hj">点是正的，由圆圈中的黑色表示，一些负的点由红色的十字表示</strong>和一些远离平面的异常值</p><p id="3938" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们应用这个公式，计算一个点的所有距离的总和</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lk"><img src="../Images/194eec34450aef8070a9c891dfc2d857.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*sEXkffj0YrvHeEWh"/></div></figure><p id="93ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">w * =(1+1+1+1+1+1)+(1+1+1+1+1)-100 =-90</p><p id="06d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于一个错误分类和异常值，我们得到了非常大的值，所以让我们考虑另一种情况</p><p id="7cd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">情况2 </em> </strong>:在这种情况下我们使用不同的超平面来分离点</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es ls"><img src="../Images/4542fc7839b103582bf7847e8b0b32a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/0*Lz05lJ6C1ROuk5SG"/></div></figure><p id="8399" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，当我们使用给定公式计算所有点的和时</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lk"><img src="../Images/29a68aa830da876a1d908cd7e8cb29ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*bAPOpbYcIguEXE9T"/></div></figure><p id="cd34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">w * = 1+2+3+4+5–1–2–3–4–5+1 = 1</p><p id="c70b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目标是找出距离的最大和，在这两种情况下我们找出1&gt;-90，所以我们第二个是我的分类器</p><p id="67e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是当我们W * = 1+2+3+4+5–1–2–3–4–5+1 = 1计算第一种情况和第二种情况超平面的准确性时，我们得到第一种超平面最佳分类器，因为在这种情况下只发生了一次误分类，但是在第二种情况下，由于单个异常点而发生了五次误分类</p><p id="79ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了最小化这个误差，我们使用了<strong class="ih hj"> <em class="ld"> sigmoid函数</em> </strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lt"><img src="../Images/96e6b900a97fa09542eb29881f6068ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*N7KELkfrf-q65LcL"/></div></figure><p id="67b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们f(sigmoid函数)</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lu"><img src="../Images/2fbcfb5f879bf0caa8c05fa03e53aaec.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/0*tYEeRVNKieO9wZoQ"/></div></figure><h2 id="22c0" class="lv jv hi bd jw lw lx ly ka lz ma mb ke iq mc md ki iu me mf km iy mg mh kq mi bi translated">说明:当数据点增加到某一水平时，sigmoid图被捕获基本上是sigmoid，我们将固定在某一极限，在该极限之后，数据点被视为异常值，它们不计入原始数据中这就是sigmoid函数的优点sigmoid函数的一些好的属性是</h2><p id="4ad3" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated"><strong class="ih hj"><em class="ld">= 𝛔(x)</em></strong></p><p id="2ef4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最大值:1</p><p id="a669" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最小值:0</p><p id="0a90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">𝛔(0)=0.5</p><p id="3195" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">适马函数也有概率解释</p><p id="50ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们用sigmoid函数评估我们的最佳公式，并尝试在公式中拟合sigmoid函数</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mj"><img src="../Images/2ee815f0dc404a0ae77aea250d5ba23a.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/0*_GN9WPH6tC0aHFQl"/></div></figure><p id="baf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">利用<strong class="ih hj"><em class="ld">【𝛔(x)= 1/(1+e-x)</em></strong>我们得到这个等式:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mk"><img src="../Images/3d411c26fb8d690932b4cde508cd5581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/0*qY-mmvNm-27hz8de"/></div></figure><p id="c45a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们使用这个等式，那么我们就不会受到异常值的影响</p><blockquote class="ll lm ln"><p id="edd9" class="if ig ld ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">优化逻辑回归:</em> </strong></p></blockquote><p id="c098" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这些方法中，我们将通过使用单调函数来优化下面的方程，单调函数是这样的函数，当一个函数增加时，另一个函数随该函数减少，或者两个函数同时增加或减少，称为单调函数</p><p id="3318" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld"> F(x) = g(x) </em> </strong>当x在增加时，那么g(x)也是增加然后函数单调增加的函数</p><p id="7610" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在那个等式中应用给定的函数</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mk"><img src="../Images/df15bd8ecb961128d7dd35e80ff383ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/0*7taiX_Iha0TGssUP"/></div></figure><p id="06b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld"> g(x) = log(x):单调函数</em> </strong></p><p id="ef1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用这个函数后，我们得到这个方程</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es ml"><img src="../Images/0f096ac8c3a42da43e8c1829ca720493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/0*ClwZO_IL2cBH9hWB"/></div></figure><p id="a1f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们知道<strong class="ih hj"><em class="ld">log(1/x)=-log(x)</em></strong>应用这个函数我们得到</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mm"><img src="../Images/3fd7264afdc6666118fff361568703d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/0*5CGwqTq_p2RdH-wc"/></div></figure><p id="6cbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，当我们试图解决这个对数函数时，我们假设</p><p id="363b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="ld">arg maxf(x)= arg min-f(x)……..1.</em> </strong></p><p id="7f0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">或</em> </strong></p><p id="1fce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="ld">arg max-f(x)= arg minf(x)……2。</em> </strong></p><p id="688e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用这两个函数<strong class="ih hj"> <em class="ld">最终优化方程是</em> </strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mn"><img src="../Images/6a9d211cc872c4abdb51189cc105e691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/0*bQkzwnFE6YurepmE"/></div></figure><p id="c339" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">其中Yi =+1或-1 </em> </strong></p><p id="04db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是逻辑回归几何驱动优化问题</p><blockquote class="ll lm ln"><p id="6d73" class="if ig ld ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">正规化L1 &amp; L2: </em> </strong></p></blockquote><p id="168a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld"> L2正规化</em> </strong></p><p id="5193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正则化是一种技术，其中我们在机器学习算法中引入了一个新术语，用于减少模型的过拟合和欠拟合</p><p id="db90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说:通过防止算法过度拟合训练数据集，正则化可以用于训练模型，这些模型可以更好地概括看不见的数据。</p><p id="7726" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在优化方程中引入L2正则化</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mo"><img src="../Images/6027268fe748a9a824c7b05cf4dda342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/0*UmZpaG-Nc2a3n74B"/></div></figure><p id="40ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这被称为L2正则化术语<strong class="ih hj"><em class="ld">λ*w^t*w</em></strong>……………………………………1。</p><p id="dc4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在物流再生中称为正规化术语</p><p id="bace" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设<strong class="ih hj"> <em class="ld"> λW^t*W = λ||W|| 2 …………。这叫做L2归一化的平方</em> </strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mp"><img src="../Images/6caa61236fec6e86f46c7b8b2a423e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/0*yWpkLA3LsFmreziC"/></div></figure><blockquote class="ll lm ln"><p id="00aa" class="if ig ld ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">其中λ是逻辑回归</em> </strong>中的超参数</p></blockquote><p id="9389" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果lambda等于零，则模型过拟合训练数据，并且方差<strong class="ih hj"><em class="ld"/></strong>高，但是如果lambda非常大，则损失函数减小，模型欠拟合，并且出现高<strong class="ih hj"> <em class="ld">偏差</em> </strong>以找到正确的lambda，在机器学习模型中使用交叉验证</p><p id="3569" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="ld">L1</em>正规化</strong></p><p id="fd4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">L1正则化是L2正则化的另一种选择，概念是相同的，但是这里我们取的是<strong class="ih hj"><em class="ld"/></strong>W的绝对值，等式看起来像<strong class="ih hj"> <em class="ld"> ||W|| = ∑|Wi| range是I = 1到d </em> </strong></p><p id="3e2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，逻辑回归方程可以改为</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mq"><img src="../Images/f38d856c8e7b023b65ddf346813fdf56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/0*y0fc5moPA9Zq7DnB"/></div></figure><p id="6279" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">L1正则化通过选择正确的λ值来避免欠拟合和过拟合，L1正则化还创建了稀疏性，稀疏性意味着不太重要的特征被置零并从数据集中移除</p><p id="7e50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我希望给出的信息能让你对混淆矩阵有基本的了解。如果你喜欢这篇文章，请鼓掌。我希望这对你有帮助</strong></p><p id="737a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在上关注我</p><p id="2502" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">领英:<a class="ae mr" href="https://www.linkedin.com/in/khan-akbar-b07b7218b/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/khan-akbar-b07b7218b/</a></p><p id="f7e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">github:<a class="ae mr" href="https://github.com/khanakbar145" rel="noopener ugc nofollow" target="_blank">https://github.com/khanakbar145</a></p><p id="75ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢你的阅读！</p></div></div>    
</body>
</html>