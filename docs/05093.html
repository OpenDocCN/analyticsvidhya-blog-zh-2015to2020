<html>
<head>
<title>Mocking functions Part I | Better Unit Testing in Python with pytest-mock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模拟函数第一部分|使用pytest-mock在Python中进行更好的单元测试</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/mocking-in-python-with-pytest-mock-part-i-6203c8ad3606?source=collection_archive---------0-----------------------#2020-04-11">https://medium.com/analytics-vidhya/mocking-in-python-with-pytest-mock-part-i-6203c8ad3606?source=collection_archive---------0-----------------------#2020-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="faf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在单元测试中模仿资源和编写单元测试一样重要和常见。然而，许多人不熟悉如何正确地模拟类、对象或函数进行测试，因为在线可用的文档要么太短，要么不必要的复杂。造成这种混乱的主要原因之一是——做同一件事的几种方法。其他所有的文章似乎都以不同的方式嘲笑事物。通过这一系列关于嘲讽的文章，我希望能让这个话题更加清晰。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/2960d419c0490dbf713c61e00b64242d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3bM970bQ7UYqsDyy.png"/></div></div></figure><h2 id="2070" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">先决条件</h2><p id="bf84" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">这是一个关于用pytest嘲讽的教程。我假设您可以使用<code class="du kp kq kr ks b">pytest</code>用Python编写单元测试。</p><h2 id="bbdd" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">为什么要嘲笑？</h2><p id="1438" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">当你在这里读这篇文章的时候，我会假设你对嘲讽很熟悉。如果你不是，让我们来快速概述一下它是什么以及我们为什么需要它。</p><p id="2542" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比方说，您有一个收集股票市场数据并提供某个特定部门中涨幅居前者的信息的服务。您从第三方API获取股票市场信息，并对其进行处理以给出结果。现在，为了测试您的代码，您不希望每次都点击API，因为这会使测试变慢，而且API提供者会向您收取额外点击的费用。你想要的是一个嘲笑！mock用一个虚拟对象代替了一个函数，您可以通过编程来做您想做的任何事情。这也称为“打补丁”。在本系列的其余部分，我将交替使用“模拟”和“修补”。</p><h2 id="29d6" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">模仿所需的包</h2><p id="715e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">与大多数编程语言不同，Python带有一个内置的库，用于单元测试和模拟。它们功能强大，自给自足，并提供您需要的功能。我们将使用的Pytest-mock插件是一个方便的包装器，可以更容易地与<code class="du kp kq kr ks b">pytest</code>结合使用。</p><p id="a171" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你查找关于嘲讽的文章，或者通读Stackoverflow上无休止的问题，你会经常遇到<code class="du kp kq kr ks b">Mock</code>、<code class="du kp kq kr ks b">MagicMock</code>、<code class="du kp kq kr ks b">patch</code>等词。我将在这里揭开它们的神秘面纱。</p><p id="cfeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Python中，无论是函数、对象还是类，你都会用到<code class="du kp kq kr ks b">Mock</code>类。<code class="du kp kq kr ks b">Mock</code>类来自内置的<code class="du kp kq kr ks b">unittest.mock</code>模块。从现在开始，任何时候你遇到<code class="du kp kq kr ks b">Mock</code>，知道它来自<code class="du kp kq kr ks b">unittest</code>图书馆。<code class="du kp kq kr ks b">MagicMock</code>是<code class="du kp kq kr ks b">Mock</code>的子类，实现了一些神奇的方法。魔法方法是你常用的方法，如<code class="du kp kq kr ks b">__str__</code>、<code class="du kp kq kr ks b">__len__,</code>等。</p><p id="4816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数情况下，使用哪一个并不重要，<code class="du kp kq kr ks b">Mock</code>或<code class="du kp kq kr ks b">MagicMock</code>。除非你需要像上面实现的神奇方法，你可以坚持使用<code class="du kp kq kr ks b">Mock</code>。Pytest-mock通过一个易于使用的接口让您可以访问这两个类。</p><p id="4223" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kp kq kr ks b">patch</code>是来自“unittest”模块的另一个函数，它帮助用模拟代替函数。Pytest mock对此也有一个包装器。</p><h2 id="ebba" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">安装Pytest模拟</h2><p id="306b" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">在开始使用pytest-mock之前，您必须安装它。您可以使用pip安装它，如下所示:</p><pre class="je jf jg jh fd kt ks ku kv aw kw bi"><span id="c085" class="jp jq hi ks b fi kx ky l kz la">pip install pytest-mock</span></pre><p id="80e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个pytest插件。所以，它也会安装<code class="du kp kq kr ks b">pytest</code>，如果你还没有安装的话。</p><h2 id="00ab" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">模仿一个简单的函数</h2><p id="66b7" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">由于这是第一篇文章，我们将保持简单。我们将从模仿一个简单的函数开始。</p><p id="9cd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比方说，我们有一个函数<code class="du kp kq kr ks b">get_operating_system</code>可以告诉我们使用的是Windows还是Linux。</p><pre class="je jf jg jh fd kt ks ku kv aw kw bi"><span id="12ca" class="jp jq hi ks b fi kx ky l kz la"># application.py </span><span id="d5a4" class="jp jq hi ks b fi lb ky l kz la">from time import sleep  </span><span id="3b07" class="jp jq hi ks b fi lb ky l kz la">def is_windows():    <br/>    # This sleep could be some complex operation instead<br/>    sleep(5)    <br/>    return True  </span><span id="1e0f" class="jp jq hi ks b fi lb ky l kz la">def get_operating_system():    <br/>    return 'Windows' if is_windows() else 'Linux'</span></pre><p id="d649" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数使用另一个函数<code class="du kp kq kr ks b">is_windows</code>来检查当前系统是否是Windows。假设这个<code class="du kp kq kr ks b">is_windows</code>函数非常复杂，需要几秒钟才能运行。我们可以通过让程序每次被调用时休眠5秒来模拟这个缓慢的函数。</p><p id="f49c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kp kq kr ks b">get_operating_system()</code>的pytest如下:</p><pre class="je jf jg jh fd kt ks ku kv aw kw bi"><span id="2e1c" class="jp jq hi ks b fi kx ky l kz la"># test_application.py<br/><br/>from application import get_operating_system<br/><br/>def test_get_operating_system():<br/>    assert get_operating_system() == 'Windows'</span></pre><p id="7132" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于<code class="du kp kq kr ks b">get_operating_system()</code>调用了一个较慢的函数<code class="du kp kq kr ks b">is_windows</code>，测试将会很慢。这可以在下面运行pytest的输出中看到，它用了5.05秒。</p><pre class="je jf jg jh fd kt ks ku kv aw kw bi"><span id="bb87" class="jp jq hi ks b fi kx ky l kz la">$ pytest<br/>================ test session starts ========================<br/>Python 3.7.3, pytest-5.4.1, py-1.8.1, pluggy-0.13.1<br/>rootdir: /usr/Personal/Projects/pytest-and-mocking<br/>plugins: mock-2.0.0<br/>collected 1 item<br/><br/>test_application.py .                                    [100%]<br/><br/>================ 1 passed in 5.05s ==========================</span></pre><p id="585d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单元测试应该很快。我们应该能在几秒钟内完成数百项测试。一个需要五秒钟的测试会降低测试套件的速度。进入嘲讽，让我们的生活更轻松。如果我们修补慢速功能，我们可以验证<code class="du kp kq kr ks b">get_operating_system</code>的行为，而无需等待五秒钟。</p><p id="f83b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用pytest-mock模拟这个函数。</p><p id="4fb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Pytest-mock提供了一个名为<code class="du kp kq kr ks b">mocker</code>的夹具。它在python内置的模仿结构之上提供了一个很好的接口。使用<code class="du kp kq kr ks b">mocker</code>的方法是将它作为参数传递给测试函数，并从中调用模拟和修补函数。</p><p id="84ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比方说，你想让<code class="du kp kq kr ks b">is_windows</code>函数返回<code class="du kp kq kr ks b">True</code>而不占用那宝贵的五秒钟。我们可以如下修补它:</p><pre class="je jf jg jh fd kt ks ku kv aw kw bi"><span id="193e" class="jp jq hi ks b fi kx ky l kz la">mocker.patch('application.is_windows', return_value=True)</span></pre><p id="5a17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你必须将这里的<code class="du kp kq kr ks b">is_windows</code>称为<code class="du kp kq kr ks b">application.is_windows</code>，因为它是<em class="lc">应用</em>模块中的函数。如果我们只给<code class="du kp kq kr ks b">is_windows</code>打补丁，它会尝试给‘test _ application’文件中一个名为<code class="du kp kq kr ks b">is_windows</code>的函数打补丁，而这个函数显然是不存在的。格式总是<code class="du kp kq kr ks b">&lt;module_name&gt;.&lt;function_name&gt;</code>。知道如何正确地模仿是很重要的，我们将在这个系列中继续研究。</p><p id="a3f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">补丁更新后的测试函数如下:</p><pre class="je jf jg jh fd kt ks ku kv aw kw bi"><span id="13df" class="jp jq hi ks b fi kx ky l kz la"># 'mocker' fixture provided by pytest-mock<br/>def test_get_operating_system(mocker):  <br/>    # Mock the slow function and return True always<br/>    mocker.patch('application.is_windows', return_value=True) <br/>    assert get_operating_system() == 'Windows'</span></pre><p id="83b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当您运行测试时，它将更快地完成。</p><pre class="je jf jg jh fd kt ks ku kv aw kw bi"><span id="bc04" class="jp jq hi ks b fi kx ky l kz la">$ pytest<br/>============ test session starts ==================<br/>Python 3.7.3, pytest-5.4.1, py-1.8.1, pluggy-0.13.1<br/>rootdir: /mnt/c/Personal/Projects/pytest-and-mocking<br/>plugins: mock-2.0.0<br/>collected 1 item<br/><br/>test_application.py .                          [100%]<br/><br/>=========== 1 passed in 0.11s ======================</span></pre><p id="9f53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，测试只进行了0.11秒。我们已经成功地修补了缓慢的功能，并使测试套件更快。</p><p id="70b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模仿的另一个优点是——你可以让模仿函数返回任何东西。您甚至可以让它引发错误来测试您的代码在这些场景中的行为。在以后的文章中，我们将看到所有这些是如何工作的。</p><p id="2f38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果您想测试<code class="du kp kq kr ks b">is_windows</code>返回<code class="du kp kq kr ks b">False</code>的情况，请编写以下测试:</p><pre class="je jf jg jh fd kt ks ku kv aw kw bi"><span id="7ead" class="jp jq hi ks b fi kx ky l kz la">def test_operation_system_is_linux(mocker):<br/>    mocker.patch('application.is_windows', return_value=False) # set the return value to be False<br/>    assert get_operating_system() == 'Linux'</span></pre><p id="eee5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，所有用<code class="du kp kq kr ks b">mocker</code>设置的模拟和补丁都是函数范围的，也就是说，它们只对特定的函数可用。因此，您可以在多个测试中修补同一个函数，并且它们不会相互冲突。</p><p id="8277" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是你第一次接触pytest的嘲讽世界。我们将在接下来的文章中讨论更多的场景。敬请关注，保持安全，在那之前保持敬畏。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="e85e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本系列文章列表:</p><p id="4e24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lk" rel="noopener" href="/analytics-vidhya/mocking-in-python-with-pytest-mock-part-i-6203c8ad3606">嘲讽功能第一部分</a> 🢠当前文章<br/>t13】嘲讽功能第二部分</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="3fcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这篇文章，你可以喜欢这篇文章，以鼓励我尽快推出下一篇文章。如果你认为你认识的人可以从这篇文章中受益，请与他们分享。</p><p id="2374" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想感谢我，可以在推特上打个招呼<a class="ae lk" href="http://twitter.com/durgaswaroop" rel="noopener ugc nofollow" target="_blank"> @durgaswaroop </a>。如果你想支持我，这里有我的贝宝链接:paypal.me/durgaswaroop</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="9c27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">归属:Python Logo—<a class="ae lk" href="https://www.python.org/community/logos/" rel="noopener ugc nofollow" target="_blank">https://www.python.org/community/logos/</a></p></div></div>    
</body>
</html>