<html>
<head>
<title>AsyncIO, Threading, and Multiprocessing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的异步、线程和多重处理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/asyncio-threading-and-multiprocessing-in-python-4f5ff6ca75e8?source=collection_archive---------0-----------------------#2019-08-21">https://medium.com/analytics-vidhya/asyncio-threading-and-multiprocessing-in-python-4f5ff6ca75e8?source=collection_archive---------0-----------------------#2019-08-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8e6058acdbb081175293789ae82e2cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNvid2sPn5qCiR6X6QZbXQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片取自另一篇关于java线程的中型文章</figcaption></figure><p id="f1ab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">AsyncIO是在python中实现并发性的一个相对较新的框架。在本文中，我将把它与多线程和多重处理等传统方法进行比较。在开始举例之前，我将补充一些关于python中并发性的内容。</p><ul class=""><li id="380c" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">CPython强制执行GIL(全局解释器锁),这阻止了充分利用多线程。在运行任何字节码之前，每个线程都需要获得这个互斥锁</li><li id="8539" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">多线程通常是网络I/O或磁盘I/O的首选，因为线程之间不需要激烈竞争来获取GIL。</li><li id="88d8" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">多处理通常是CPU密集型任务的首选。多重处理不需要GIL，因为每个进程都有自己的状态，然而，创建和销毁进程并不简单。</li><li id="53c3" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">带线程模块的多线程是抢占式的，它需要自愿和非自愿的线程交换。</li><li id="b6f7" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">AsyncIO是一个单线程单进程协作多任务处理。asyncio任务独占CPU，直到它希望将CPU让给协调器或事件循环。(稍后将涉及术语)</li></ul><h1 id="bc59" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">实践示例</h1><h2 id="4ee3" class="le kh hi bd ki lf lg lh km li lj lk kq jf ll lm ku jj ln lo ky jn lp lq lc lr bi translated">延迟消息</h2><p id="1bdb" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">程序延迟打印消息。当主线程休眠时，CPU是空闲的，这是对资源的一种不良使用。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><pre class="lx ly lz ma fd md me mf mg aw mh bi"><span id="52bb" class="le kh hi me b fi mi mj l mk ml">12:39:00:MainThread:Main started<br/>12:39:00:MainThread:TWO received<br/>12:39:02:MainThread:Printing TWO<br/>12:39:02:MainThread:THREE received<br/>12:39:05:MainThread:Printing THREE<br/>12:39:05:MainThread:Main Ended</span></pre><h2 id="dbfd" class="le kh hi bd ki lf lg lh km li lj lk kq jf ll lm ku jj ln lo ky jn lp lq lc lr bi translated">线程并发</h2><p id="99bb" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">使用python的线程模块在独立的非守护线程<em class="mm">上多次调用<em class="mm"> delay_message </em>。</em>不出所料，程序执行速度比上面的同步版本快了两秒。当线程空闲(休眠)时，操作系统交换线程。您可以将睡眠与进行系统调用以与外部环境通信联系起来。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><pre class="lx ly lz ma fd md me mf mg aw mh bi"><span id="1d67" class="le kh hi me b fi mi mj l mk ml">12:39:05:MainThread:Main started<br/>12:39:05:Thread-4:TWO received<br/>12:39:05:Thread-5:THREE received<br/>12:39:07:Thread-4:Printing TWO<br/>12:39:08:Thread-5:Printing THREE<br/>12:39:08:MainThread:Main Ended</span></pre><h2 id="95af" class="le kh hi bd ki lf lg lh km li lj lk kq jf ll lm ku jj ln lo ky jn lp lq lc lr bi translated">线程池</h2><p id="6927" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">尽管线程是轻量级的，但是创建和销毁大量线程的代价是昂贵的。<code class="du mn mo mp me b">concurrent.futures</code>建立在线程模块之上，提供了一个简洁的接口来创建线程池和进程池。它没有为函数调用创建新的线程，而是重用了池中现有的线程。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><pre class="lx ly lz ma fd md me mf mg aw mh bi"><span id="3ef4" class="le kh hi me b fi mi mj l mk ml">10:42:36:ThreadPoolExecutor-0_0:TWO received<br/>10:42:36:ThreadPoolExecutor-0_1:THREE received<br/>10:42:38:ThreadPoolExecutor-0_0:Printing TWO<br/>10:42:38:MainThread:TWO Done<br/>10:42:39:ThreadPoolExecutor-0_1:Printing THREE<br/>10:42:39:MainThread:THREE Done</span></pre><h2 id="9d08" class="le kh hi bd ki lf lg lh km li lj lk kq jf ll lm ku jj ln lo ky jn lp lq lc lr bi translated">使用AsyncIO的并发性</h2><ol class=""><li id="a551" class="js jt hi iw b ix ls jb lt jf mq jj mr jn ms jr mt jy jz ka bi translated"><strong class="iw hj">协程:</strong>与传统的单点退出函数不同，协程可以暂停和继续执行。创建协程就像在声明函数之前使用关键字<code class="du mn mo mp me b">async</code>一样简单。</li><li id="6d1e" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr mt jy jz ka bi translated"><strong class="iw hj">事件循环或协调器:</strong>管理其他协程的协程。你可以把它想象成一个调度器或主控器。</li><li id="929f" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr mt jy jz ka bi translated"><strong class="iw hj">可应用对象</strong>协程、任务和未来都是可应用对象。协程可以等待合适的对象。当一个协程在等待一个可请求的对象时，它的执行被暂时挂起，并在Future完成后恢复。</li></ol><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><pre class="lx ly lz ma fd md me mf mg aw mh bi"><span id="0128" class="le kh hi me b fi mi mj l mk ml">07:35:32:MainThread:Main started<br/>07:35:32:MainThread:Current registered tasks: 1<br/>07:35:32:MainThread:Creating tasks<br/>07:35:32:MainThread:Current registered tasks: 3<br/>07:35:32:MainThread:TWO received<br/>07:35:32:MainThread:THREE received<br/>07:35:34:MainThread:Printing TWO<br/>07:35:35:MainThread:Printing THREE<br/>07:35:35:MainThread:Main Ended</span></pre><p id="214c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">尽管程序运行在单线程上，但它可以通过协作式多任务处理实现与多线程代码相同的性能水平。</p><h2 id="f10c" class="le kh hi bd ki lf lg lh km li lj lk kq jf ll lm ku jj ln lo ky jn lp lq lc lr bi translated">创建异步任务的更好方法</h2><p id="8bda" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">使用asyncio.gather一次性创建多个任务。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><pre class="lx ly lz ma fd md me mf mg aw mh bi"><span id="6932" class="le kh hi me b fi mi mj l mk ml">08:09:20:MainThread:Main started<br/>08:09:20:MainThread:ONE received<br/>08:09:20:MainThread:TWO received<br/>08:09:20:MainThread:THREE received<br/>08:09:20:MainThread:FOUR received<br/>08:09:20:MainThread:FIVE received<br/>08:09:21:MainThread:Printing ONE<br/>08:09:22:MainThread:Printing TWO<br/>08:09:23:MainThread:Printing THREE<br/>08:09:24:MainThread:Printing FOUR<br/>08:09:25:MainThread:Printing FIVE<br/>08:09:25:MainThread:Main Ended</span></pre><h2 id="7f08" class="le kh hi bd ki lf lg lh km li lj lk kq jf ll lm ku jj ln lo ky jn lp lq lc lr bi translated">关于在异步任务中阻止调用的警告</h2><p id="0eec" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">正如我前面所说的，asyncio任务拥有使用CPU的独占权利，直到它自愿放弃。如果一个阻塞调用错误地溜进了你的任务，它将会延缓程序的进程。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><pre class="lx ly lz ma fd md me mf mg aw mh bi"><span id="c774" class="le kh hi me b fi mi mj l mk ml">11:07:31:MainThread:Main started<br/>11:07:31:MainThread:Creating multiple tasks with asyncio.gather<br/>11:07:31:MainThread:ONE received<br/>11:07:31:MainThread:TWO received<br/>11:07:31:MainThread:THREE received<br/>11:07:34:MainThread:Printing THREE<br/>11:07:34:MainThread:FOUR received<br/>11:07:34:MainThread:FIVE received<br/>11:07:34:MainThread:Printing ONE<br/>11:07:34:MainThread:Printing TWO<br/>11:07:38:MainThread:Printing FOUR<br/>11:07:39:MainThread:Printing FIVE<br/>11:07:39:MainThread:Main Ended</span></pre><p id="7fe9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当delay_message接收到消息三时，它进行阻塞调用，直到完成任务才放弃对事件循环的控制，从而延缓了执行进度。因此，它比前一次运行多花了<em class="mm">三秒</em>。虽然这个例子看起来是特制的，但是如果你不小心的话，它也可能发生。另一方面，线程是抢占式的，如果操作系统在等待阻塞调用，它会抢先切换线程。</p><h2 id="ef77" class="le kh hi bd ki lf lg lh km li lj lk kq jf ll lm ku jj ln lo ky jn lp lq lc lr bi translated">竞赛条件</h2><p id="78ea" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">如果不考虑竞争条件，多线程代码会很快崩溃。当使用外部库时，这变得尤其棘手，因为我们需要验证它们是否支持多线程代码。例如，流行请求模块的<code class="du mn mo mp me b">session </code>对象不是线程安全的。因此，试图使用一个<code class="du mn mo mp me b">session</code>对象来并行化网络请求可能会产生意想不到的结果。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><pre class="lx ly lz ma fd md me mf mg aw mh bi"><span id="98ce" class="le kh hi me b fi mi mj l mk ml">20:28:15:ThreadPoolExecutor-0_0:Update Started<br/>20:28:15:ThreadPoolExecutor-0_0:Sleeping<br/>20:28:15:ThreadPoolExecutor-0_1:Update Started<br/>20:28:15:ThreadPoolExecutor-0_1:Sleeping<br/>20:28:17:ThreadPoolExecutor-0_0:Reading Value From Db<br/>20:28:17:ThreadPoolExecutor-0_1:Reading Value From Db<br/>20:28:17:ThreadPoolExecutor-0_0:Updating Value<br/>20:28:17:ThreadPoolExecutor-0_1:Updating Value<br/>20:28:17:ThreadPoolExecutor-0_1:Update Finished<br/>20:28:17:ThreadPoolExecutor-0_0:Update Finished<br/>20:28:17:MainThread:Final value is 1</span></pre><p id="45b5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">理想情况下，最终值应该是2。然而，由于线程的抢先交换，<code class="du mn mo mp me b">thread-0</code>在更新值之前被交换，因此<code class="du mn mo mp me b">updates</code>错误地产生最终值为1。我们必须使用锁来防止这种情况发生。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><pre class="lx ly lz ma fd md me mf mg aw mh bi"><span id="9df7" class="le kh hi me b fi mi mj l mk ml">21:02:45:ThreadPoolExecutor-0_0:Update Started<br/>21:02:45:ThreadPoolExecutor-0_0:Sleeping<br/>21:02:45:ThreadPoolExecutor-0_1:Update Started<br/>21:02:45:ThreadPoolExecutor-0_1:Sleeping<br/>21:02:47:ThreadPoolExecutor-0_0:Reading Value From Db<br/>21:02:47:ThreadPoolExecutor-0_0:Updating Value<br/>21:02:47:ThreadPoolExecutor-0_0:Update Finished<br/>21:02:47:ThreadPoolExecutor-0_1:Reading Value From Db<br/>21:02:47:ThreadPoolExecutor-0_1:Updating Value<br/>21:02:47:ThreadPoolExecutor-0_1:Update Finished<br/>21:02:47:MainThread:Final value is 2</span></pre><h2 id="a747" class="le kh hi bd ki lf lg lh km li lj lk kq jf ll lm ku jj ln lo ky jn lp lq lc lr bi translated">AsyncIO很少出现竞争情况</h2><p id="9b79" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">由于任务可以完全控制何时暂停执行，asyncio很少出现竞争情况。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><pre class="lx ly lz ma fd md me mf mg aw mh bi"><span id="a0c3" class="le kh hi me b fi mi mj l mk ml">20:35:49:MainThread:Update Started<br/>20:35:49:MainThread:Sleeping<br/>20:35:49:MainThread:Update Started<br/>20:35:49:MainThread:Sleeping<br/>20:35:50:MainThread:Reading Value From Db<br/>20:35:50:MainThread:Updating Value<br/>20:35:50:MainThread:Update Finished<br/>20:35:50:MainThread:Reading Value From Db<br/>20:35:50:MainThread:Updating Value<br/>20:35:50:MainThread:Update Finished<br/>20:35:50:MainThread:Final value is 2</span></pre><p id="f963" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如您所见，一旦任务在<code class="du mn mo mp me b">sleeping</code>之后被恢复，它就不会放弃控制权，直到完成协程的执行。有了线程，线程交换不是很明显，但是有了asyncio，我们可以控制协程执行应该被暂停的确切时间。尽管如此，当两个协程进入死锁时，它可能会出错。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><h2 id="96ac" class="le kh hi bd ki lf lg lh km li lj lk kq jf ll lm ku jj ln lo ky jn lp lq lc lr bi translated">多重处理</h2><p id="de25" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">如前所述，当实现CPU密集型程序时，多处理非常方便。下面的代码对带有<code class="du mn mo mp me b">30000</code>元素的<code class="du mn mo mp me b">1000</code>列表执行合并排序。如果下面的合并排序实现有点笨拙，请原谅。</p><h2 id="fe8b" class="le kh hi bd ki lf lg lh km li lj lk kq jf ll lm ku jj ln lo ky jn lp lq lc lr bi translated">同步版本</h2><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><pre class="lx ly lz ma fd md me mf mg aw mh bi"><span id="529a" class="le kh hi me b fi mi mj l mk ml">21:24:07:MainThread:Starting Sorting<br/>21:26:10:MainThread:Sorting Completed</span></pre><h2 id="685e" class="le kh hi bd ki lf lg lh km li lj lk kq jf ll lm ku jj ln lo ky jn lp lq lc lr bi translated">异步版本</h2><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><pre class="lx ly lz ma fd md me mf mg aw mh bi"><span id="eeca" class="le kh hi me b fi mi mj l mk ml">21:29:33:MainThread:Starting Sorting<br/>21:30:03:MainThread:Sorting Completed</span></pre><p id="7011" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">默认情况下，进程的数量等于机器上处理器的数量。您可以观察到两个版本之间的执行时间有了相当大的改进。</p><p id="caaa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我将写这篇文章的<code class="du mn mo mp me b">PART 2</code>关于异步网络请求和文件读取。如果您发现代码中有任何错误，请随时发表评论或在<a class="ae mu" href="https://www.linkedin.com/in/ajitsamudrala/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>