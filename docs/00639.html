<html>
<head>
<title>Just Don’t Overfit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">只是不要装太多</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/just-dont-overfit-e2fddd28eb29?source=collection_archive---------5-----------------------#2019-08-20">https://medium.com/analytics-vidhya/just-dont-overfit-e2fddd28eb29?source=collection_archive---------5-----------------------#2019-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="972d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">过度拟合是大多数ML爱好者的一个主要问题，这篇文章将带你通过一些技术来摆脱这个问题。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/497a57646c63e0da7abe89cae6d3d041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/0*Ub0efSWZOlO4OjiX.png"/></div></figure><p id="b6e6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我带回了一个有趣的数据集，最近在Kaggle上遇到的。你可以在这里找到数据集<a class="ae kb" href="https://www.kaggle.com/c/dont-overfit-ii/overview" rel="noopener ugc nofollow" target="_blank"><em class="kc"/></a><em class="kc">。</em></p><p id="ce6d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在给出任何与数据库相关的提示之前，先看看训练集和测试集的比例。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kd"><img src="../Images/eff60ba8333084dcbbdab1a706bf56a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*V7gch8DKNv5lqNv8fIQkpQ.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">测试数据是训练数据的79倍。</figcaption></figure><p id="7c0e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">从训练和测试数据集的比例来看，我们可以清楚地预见到我们的模型将会出现过拟合的问题。这可以通过在我们的模型中添加一些偏见或者使用LASSOCV来处理(如果你不知道它的意思，不要紧张，我会让这一切变得很容易！).那我们还等什么，开始吧！</p><h1 id="c379" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">导入相关库</h1><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="e74f" class="lf kj hi lb b fi lg lh l li lj">import numpy as np <br/>import pandas as pd <br/>from sklearn.linear_model import LassoCV , LassoLarsCV<br/>from sklearn.model_selection import cross_val_score<br/>from sklearn.preprocessing import StandardScaler</span></pre><p id="2ee9" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你猜对了，我们将使用LassoCV来增加偏差和减少方差。即使你现在没有任何想法，不要担心，只要相信我，到本文结束时，你会对套索回归有很好的了解，以及它如何有助于减少过度拟合。</p><p id="c98c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们装上子弹，瞄准目标！</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="6488" class="lf kj hi lb b fi lg lh l li lj">train = pd.read_csv('../input/dont-overfit-ii/train.csv')<br/>test = pd.read_csv('../input/dont-overfit-ii/test.csv')</span><span id="4cc2" class="lf kj hi lb b fi lk lh l li lj">train.shape , test.shape</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/39b4b55e933b710d42ee7ceb6eb296a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*R99dyIgth47-HElMk4p3Ew.png"/></div></figure><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="aade" class="lf kj hi lb b fi lg lh l li lj">train.head()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lm"><img src="../Images/56837fbb63029964ada6a92672c49bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gX6cYdMMnc0vvYuMHDOf0Q.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">有300根独立的柱子</figcaption></figure><p id="3aa4" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因此，在将数据分成自变量和因变量后，我们会得到这样的结果:</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="4a75" class="lf kj hi lb b fi lg lh l li lj">y_train = train['target']<br/>x_train  = train.drop(['id' ,'target'] ,axis = 1)<br/>test = test.drop('id',axis = 1)</span></pre><p id="ad67" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们都做好了进一步处理的准备，但下一步该怎么办呢？现在让我们从基础开始。我们能做的是对数据进行归一化，但是等一下，我们首先需要了解如何进行归一化，主要是为什么要进行归一化。</p><h1 id="e7be" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">标准化/规范化的需求:</h1><h2 id="46d7" class="lf kj hi bd kk lr ls lt ko lu lv lw ks jo lx ly ku js lz ma kw jw mb mc ky md bi translated">规范化与标准化</h2><ul class=""><li id="5626" class="me mf hi jh b ji mg jl mh jo mi js mj jw mk ka ml mm mn mo bi translated"><code class="du mp mq mr lb b">Standard Scaler</code>:以均值为0，标准差为1的方式转换数据。简而言之，它将数据标准化。标准化对于具有负值的数据很有用。它将数据排列成正态分布<strong class="jh hj">。</strong>在分类上比回归更有用。</li><li id="b636" class="me mf hi jh b ji ms jl mt jo mu js mv jw mw ka ml mm mn mo bi translated"><code class="du mp mq mr lb b">Normalizer</code>:将数据挤压在0和1之间。它执行规范化。由于范围和幅度减小，训练过程中的梯度不会爆炸<strong class="jh hj"> </strong>并且您不会获得更高的损失值。在回归中比分类<strong class="jh hj">更有用。</strong></li></ul><h2 id="0db9" class="lf kj hi bd kk lr ls lt ko lu lv lw ks jo lx ly ku js lz ma kw jw mb mc ky md bi translated">为什么？</h2><p id="deb0" class="pw-post-body-paragraph jf jg hi jh b ji mg ij jk jl mh im jn jo mx jq jr js my ju jv jw mz jy jz ka hb bi translated">实际情况是，所有列可能有不同的单位，例如，如果有一个“年龄”列，其值可能是20、25、18等。</p><p id="f308" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">同样，可能还有另一个“薪金”列，其值可能是20，000，000或50，000，000(努力工作的家伙！).主要原因是，如果我们想要关联这两列，解决这个问题的效率会很低，因此，将这两列转换为相同的单位标准化/规范化是很方便的。</p><h2 id="1e09" class="lf kj hi bd kk lr ls lt ko lu lv lw ks jo lx ly ku js lz ma kw jw mb mc ky md bi translated">怎么会？</h2><p id="dff9" class="pw-post-body-paragraph jf jg hi jh b ji mg ij jk jl mh im jn jo mx jq jr js my ju jv jw mz jy jz ka hb bi translated">计算标准定标器的公式为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es na"><img src="../Images/3369f580b276df3aaaf5a26caf9e30a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*N5QGa0TwDu6Mn1gCg6X4_g.png"/></div></figure><h1 id="6381" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">返回代码:</h1><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="d4a5" class="lf kj hi lb b fi lg lh l li lj">scaler  = StandardScaler()<br/>x_train  = scaler.fit_transform(x_train)<br/>test = scaler.fit_transform(test)</span></pre><p id="948f" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们已经将我们的数据转换成了StandardScaler。进入下一阶段，应用LASSOCV(最小绝对收缩和选择操作符交叉验证)</p><h1 id="8fc9" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">最小绝对收缩和选择算子交叉验证</h1><p id="ae21" class="pw-post-body-paragraph jf jg hi jh b ji mg ij jk jl mh im jn jo mx jq jr js my ju jv jw mz jy jz ka hb bi translated">LASSOCV这个术语是什么，为了理解它，让我们把这个术语分成LASSO和CV两部分。</p><p id="9d5e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们来理解第一部分:套索(最小绝对收缩和选择算子)</p><p id="337f" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">假设我们的训练集中有这两个点，我们需要拟合一条具有最小残差的直线，很明显，我们会拟合如下所示的直线:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es nb"><img src="../Images/c8d0d8b5a4aae93ebcd41d00e5dab2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bv98cNy1aB4aExWEHoKXFQ.png"/></div></div></figure><p id="e4ae" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，如果我们在测试集上检查我们的模型，我们会得到这样的结果:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es nc"><img src="../Images/4905e823a1eeea887046100e93f7b2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zh-MHvlM4toyHcaJe841RA.png"/></div></div></figure><p id="d889" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">从结果中我们可以清楚地看到，残差比训练数据集中的残差高得多。</p><p id="8cfc" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这意味着我们高度过度拟合数据集，导致高方差和低偏差。这个示例场景与我们的数据集非常相似，因为训练数据与测试数据的可比性很小。</p><p id="d8ac" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了解决这个问题，使用了套索回归，因为它的主要功能是在预测中包含一些偏差，这有助于长期预测。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es nd"><img src="../Images/6957dd325297b79e38ccf57edbb2dc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g0YuqGLikGO1EbFC6KMiPw.png"/></div></div></figure><p id="26ee" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">套索回归增加了由希腊字母符号λ乘以直线斜率表示的惩罚。</p><p id="e953" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">它有助于增加偏差和减少残差。</p><p id="d2d6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果你还有疑问，这里的是一个不错的教程。</p><p id="f468" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们已经理解了LASSO，让我们来理解交叉验证是什么意思。</p><h2 id="f8f3" class="lf kj hi bd kk lr ls lt ko lu lv lw ks jo lx ly ku js lz ma kw jw mb mc ky md bi translated">交互效度分析</h2><p id="cea7" class="pw-post-body-paragraph jf jg hi jh b ji mg ij jk jl mh im jn jo mx jq jr js my ju jv jw mz jy jz ka hb bi translated">套索函数中的一个重要属性是<em class="kc"> alpha的值。</em>抛开交叉验证不谈，计算<em class="kc"> alpha </em>值背后的数学非常有趣，但实际上，你需要知道的是，Lasso回归带有一个参数，<em class="kc"> alpha </em>和<em class="kc"> alpha </em>越高，越多的特征系数为零，<em class="kc"> alpha的值越低，</em> lasso回归将类似于线性回归。</p><p id="9d39" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">LASSO中使用交叉验证，通过函数调用LASSOCV来计算多个<em class="kc"> alpha </em>值的输出。</p><h1 id="111d" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">返回代码:</h1><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="5d57" class="lf kj hi lb b fi lg lh l li lj">model_lasso = LassoCV(alphas =  [0.05, 0.1, 0.3, 1, 3, 5, 10, 15, 30, 50, 75]).fit(x_train, y_train)<br/>lasso_preds = model_lasso.predict(test)</span></pre><p id="8a0c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">正如在代码中看到的，我们已经从0.05到75的阿尔法列表，最好的结果将存储在lasso_preds中。</p><p id="17ab" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后，我们处于模型的最后阶段，我们需要预测输出并提交它。</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="6174" class="lf kj hi lb b fi lg lh l li lj">#Converting the list into a column , so that it can be stored in the test.csv file</span><span id="06f2" class="lf kj hi lb b fi lk lh l li lj">lasso_preds=lasso_preds.T   #.T stands for transpose.</span></pre><p id="12e0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">加载示例提交文件:</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="2ce4" class="lf kj hi lb b fi lg lh l li lj">submit = pd.read_csv('../input/dont-overfit-ii/sample_submission.csv')<br/>submit.head()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ne"><img src="../Images/7d965f402d11d6d44b519e0a260bd327.png" data-original-src="https://miro.medium.com/v2/resize:fit:230/format:webp/1*kai1l30fsZw2_dT8aJutEQ.png"/></div></figure><p id="0200" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在没有预测的情况下覆盖目标后，我们得到:</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="45ad" class="lf kj hi lb b fi lg lh l li lj">submit['target'] = lasso_preds<br/>submit.head()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nf"><img src="../Images/d532bf2671fe3510e1e0804e93da290f.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*b7Qm2TXFrSNbgsENMwZCxw.png"/></div></figure><p id="d67b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">手指交叉，让我们提交这个csv文件，看看我们的分数。</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="9cfb" class="lf kj hi lb b fi lg lh l li lj">submit.to_csv('submit.csv', index = False)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es ng"><img src="../Images/c40af5826f863286cad3cdae0113a39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pJ9L5VM2pA3QKC7h5etwBg.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">0.843(还不错！)</figcaption></figure><p id="e078" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">好了，现在就这些了，欢迎提出任何建议。我总是乐于学习新的东西，也非常感谢一些评论！</p></div></div>    
</body>
</html>