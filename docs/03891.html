<html>
<head>
<title>How Logistic Regression works?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-logistic-regression-works-c0d5a3949726?source=collection_archive---------12-----------------------#2020-02-24">https://medium.com/analytics-vidhya/how-logistic-regression-works-c0d5a3949726?source=collection_archive---------12-----------------------#2020-02-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7df4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">逻辑回归是基本的机器学习算法，与更复杂的ML算法相比，它承诺更好的结果。在这篇文章中，我很兴奋地写下它的工作原理。</p><blockquote class="jd je jf"><p id="579e" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">出发</p></blockquote><p id="e192" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何工作的机器学习算法都可以在几何空间中表示，因为它遵循基本的数学前提。请这样想，您的数据点设置在某个n维空间中，其中n是数据中的要素数量。下面的例子是在2D空间中，其中蓝色的代表一个等级，橙色的代表另一个等级。</p><p id="2e1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jg">黄色</em>线代表一个平面，我们必须拟合该平面，使得该平面精确地划分两类数据点。让我们称这架飞机为W^T(，因为我们要转置w。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/4c4a30290e26eb6997b3c2999b664828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*zPbPbqvuNa_DAu3N3Y6wag.jpeg"/></div></figure><p id="e926" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">WT垂直于平面，找到它是优化问题，因为我们需要执行强力分析，以查看哪个WT平面或WT矩阵的哪些值正确地分类了数据类，并且它必须拟合尽可能多的点，从而使它离数据点足够远。因此，当我们将WT乘以Xi时，我们得到输出Yi。最佳或优化的WT平面给出了所有f(X) = Yi*WT*Xi (i=1..n)为最大值。</p><p id="d553" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是四种类型的案例，涵盖了易的正价值和负价值。</p><p id="b013" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">情况1: Y*WT*Xi &gt; 0 —当WT*Xi &gt; 0且Yi &gt;0时</p><p id="ee9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">情况2: Y*WT*Xi &gt; 0 —当WT *Xi &lt; 0 and Yi &lt; 0</p><p id="2f9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Case 3: Y*WT*Xi &lt; 0 — when WT *Xi &lt; 0 and Yi &gt; 0时</p><p id="fb5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">情况4: Y*WT*Xi &lt; 0 — when WT *Xi &gt; 0且Yi &lt; 0</p><p id="76fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你认为最大化f(X) = Yi*WT*Xi不是正确的方法。你是对的。为什么？</p><p id="bfb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请允许我向您展示一个例子:)</p><p id="4806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们在2D空间中有四个数据点x1、x2、x3、x4，其中x1是正类，x2、x3、x4是负类。</p><p id="0c45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些法线平面容易受到异常值的影响。怎么会？</p><p id="1aa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以4个数据点x1，x2，x3，x4为例，对于一些低效的WT，我们得到函数f(X) = Y*WT*Xi的50，-1，-2，-3个值。将其相加，我们得到50 -1 -2 -3 = 44，但是如果只有1个点被正确分类，并且对于每一个其他的WT，我们得到小于44的值。</p><p id="6933" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再举一个例子，f(X)对于4个数据点，我们得到28，1，2，3。但是总和是34，其不容易受到异常值的影响，并且该值低于先前的值，因此找到了先前的法线平面，但是在这种情况下，所有四个点都被正确分类。</p><p id="f816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于这个原因，我们使用挤压函数来惩罚较大的数字(异常值)并将范围限制在[0，1]</p><p id="653c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1/(1+e^-x):曲线图</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es js"><img src="../Images/266d7b4640ed0217409da451e30b8e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*RvIlz4rPUVRLGIs271sOJw.jpeg"/></div></figure><p id="af1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择sigma函数来压缩值的原因是它有两个属性:</p><p id="e71d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.概率解释</p><p id="4f32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.容易区分</p><p id="339d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在应用挤压函数后，我们为找到最佳WT而求解的方程是:</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/6f5ae03fbb170897e02439c8b27eb4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*_Gf_xNwm2MCDninUVMfAUA.jpeg"/></div></figure><p id="328a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">argmax最大化函数f(X)。</p><p id="c2d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几何上我们可以证明，如果g(x)是单调递增的，那么g(f(x))也是单调递增的。</p><p id="ea30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/c42beecce1031d9988e32ba3935c6f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*UjInVxal3PCyNmNFIMsQ5A.jpeg"/></div></figure><p id="eb07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">F(x) = X在x = 0时具有最小值</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jt"><img src="../Images/fc5572b1aae82c3e89422ea60e4a88db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJgzRnirljT0F5KSyQyr3A.jpeg"/></div></div></figure><p id="940e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">G(f(x)) = log(x)在0处也有最小值</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/e71362d5c8c9f6b11da2fcfa9a9fd9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*oawOVZhXkBVbbaneXZHXHw.jpeg"/></div></figure><p id="62b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简化原始方程后，我们得到:</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/7512d0b48ac752c7e42bb89d7879d657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*hKMAT4-vU3bsUVLng9vr1Q.jpeg"/></div></figure></div></div>    
</body>
</html>