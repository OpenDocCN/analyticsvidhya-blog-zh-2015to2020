<html>
<head>
<title>Introducing Fastpipeline for ML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ML快速管道简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/introducing-fastpipeline-for-ml-913746a89cd1?source=collection_archive---------13-----------------------#2020-12-04">https://medium.com/analytics-vidhya/introducing-fastpipeline-for-ml-913746a89cd1?source=collection_archive---------13-----------------------#2020-12-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/82d56cd77b86995fd395fd6b2287d7f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNolVAdp3gvg33Kxa4iasg.png"/></div></div></figure><p id="078d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">TLDR；</strong>快速简单的管道，可自动检测重复运行并重复使用中间结果。以下是相关链接:</p><p id="e040" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">文件</strong>:【https://shashank-yadav.github.io/fastpipeline/】T4</p><p id="d517" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">源代码</strong>:<a class="ae jo" href="https://github.com/shashank-yadav/fastpipeline" rel="noopener ugc nofollow" target="_blank">https://github.com/shashank-yadav/fastpipeline</a></p><p id="3b64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你是一名数据科学家，你可能在某些时候使用过<a class="ae jo" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank"> sklearn管道</a>。使用管道使您的工作流易于阅读和理解。它有助于将一个大任务分成逻辑块，同时使您的工作具有可重复性。然而，在我的工作流程中使用sklearn管道时，我发现了几个问题:</p><ol class=""><li id="9794" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">限制性API: </strong> sklearn管道由变压器组成，可以使用现有的，也可以自己创建。但是，它迫使您只能处理类似数组的数据，并遵循fit-transform范式。例如，不可能将除X和y以外的数据从一个步骤传递到另一个步骤。简而言之，该API过于严格，并且与sklearn结构紧密耦合</li><li id="58f5" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">浪费的重新运行:</strong>假设您的管道有5个步骤，在第3步发生了一些故障。现在，如果您在进行所需的更改后重新运行管道，它将从头开始(即使在使用内存参数进行序列化时)。这使得实验既烦人又耗时。</li><li id="9841" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">记录中间数据:</strong>根据定义，管道的每个步骤都会生成一些数据，您可能希望查看这些数据以进行调试。然而，当使用sklearn时，您需要自己手动存储和版本化大部分数据。</li></ol><p id="d414" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我尝试了其他几种解决方案，如Luigi和Airflow，它们似乎主要是为了生产，而不是为了快速实验。像MLFlow这样的其他工具似乎是一个很大的买入。</p><h1 id="6b6e" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">要求:</strong></h1><p id="1bac" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">由于上述原因，我决定构建一个简单的框架，它允许我更快地进行实验，同时利用管道的优势。有5个主要要求:</p><ol class=""><li id="86dd" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">应该是实验过程的一部分，而不是一个障碍</li><li id="eb3a" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">应该允许检查运行期间生成的所有内容</li><li id="2165" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">应该尽可能自动重用结果</li><li id="7d86" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">应该为每次运行生成可用的日志</li><li id="c8cf" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">不应该限制太多，允许使用不同的库</li></ol><p id="322d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个过程产生了<a class="ae jo" href="https://shashank-yadav.github.io/fastpipeline/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">快速管道</strong> </a>。它在合理的程度上满足了上述所有要求。</p><h1 id="ef09" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">示例:</h1><p id="ae01" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">让我们使用快速管道在MNIST上空训练一个SVM分类器:</p><ul class=""><li id="06f8" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lg jv jw jx bi translated">使用<code class="du lh li lj lk b">pip install fastpipeline</code>安装软件包</li><li id="2e3c" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lg jv jw jx bi translated">创建一个文件<code class="du lh li lj lk b">mnist_pipeline.py</code></li><li id="e7c8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lg jv jw jx bi translated">进行必要的导入，并创建一个类<code class="du lh li lj lk b">DataLoader</code>，该类从fastpipeline包中扩展了<code class="du lh li lj lk b">BaseNode</code>类。这是我们称之为<code class="du lh li lj lk b">Node</code>的东西</li></ul><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="a868" class="lt ke hi lk b fi lu lv l lw lx"># Import datasets, classifiers and performance metrics<br/>from sklearn import datasets, svm, metrics<br/>from sklearn.model_selection import train_test_split<br/>import numpy as np</span><span id="38e7" class="lt ke hi lk b fi ly lv l lw lx"># Import pipeline and node constructs<br/>from fastpipeline.base_node import BaseNode<br/>from fastpipeline.pipeline import Pipeline</span><span id="1b17" class="lt ke hi lk b fi ly lv l lw lx"># Node for loading data<br/>class DataLoader(BaseNode):<br/>    def __init__(self):<br/>        super().__init__()<br/>    <br/>    def run(self, input = {}):<br/>        # The digits dataset<br/>        digits = datasets.load_digits()</span><span id="39b3" class="lt ke hi lk b fi ly lv l lw lx">        # To apply a classifier on this data, we need to flatten the image, to<br/>        # turn the data in a (samples, feature) matrix:<br/>        n_samples = len(digits.images)<br/>        data = digits.images.reshape((n_samples, -1))<br/>        return {<br/>            'data': data,<br/>            'target': digits.target<br/>        }</span></pre><ul class=""><li id="6fd7" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lg jv jw jx bi translated">创建另一个<code class="du lh li lj lk b">Node</code>，其输入是<code class="du lh li lj lk b">DataLoader</code>的输出，并训练一个SVM分类器</li></ul><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="1c46" class="lt ke hi lk b fi lu lv l lw lx"># Node for training the classifier<br/>class SVMClassifier(BaseNode):<br/>    def __init__(self, config):<br/>        super().__init__(config)<br/>        gamma = config['gamma']<br/>        # Create a classifier: a support vector classifier<br/>        self.classifier = svm.SVC(gamma=gamma)<br/>    <br/>    def run(self, input):<br/>        data = input['data']<br/>        target = input['target']</span><span id="b58b" class="lt ke hi lk b fi ly lv l lw lx">        # Split data into train and test subsets<br/>        X_train, X_test, y_train, y_test = train_test_split(<br/>            data, target, test_size=0.5, shuffle=False)</span><span id="eba4" class="lt ke hi lk b fi ly lv l lw lx">        # We learn the digits on the first half of the digits<br/>        self.classifier.fit(X_train, y_train)</span><span id="c3fb" class="lt ke hi lk b fi ly lv l lw lx">        # Now predict the value of the digit on the second half:<br/>        y_pred = self.classifier.predict(X_test)</span><span id="b215" class="lt ke hi lk b fi ly lv l lw lx">        return {<br/>            'acc': np.mean(y_test == y_pred),<br/>            'y_test': y_test,<br/>            'y_pred': y_pred <br/>        }</span></pre><ul class=""><li id="6826" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lg jv jw jx bi translated">现在让我们实例化节点并创建管道</li></ul><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="efbe" class="lt ke hi lk b fi lu lv l lw lx">if __name__ == "__main__":<br/>    # Initialize the nodes<br/>    dl_node = DataLoader()<br/>    svm_node = SVMClassifier({'gamma': 0.01})<br/>    <br/>    # Create the pipeline<br/>    pipeline = Pipeline('mnist', [dl_node, svm_node])</span><span id="f3fe" class="lt ke hi lk b fi ly lv l lw lx">    # Run pipeline and see results<br/>    result = pipeline.run(input={})<br/>    print('Accuracy: %s'%result['acc'])</span></pre><ul class=""><li id="42da" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lg jv jw jx bi translated">使用<code class="du lh li lj lk b">$ python mnist.py</code>运行管道。您应该会看到类似这样的内容:</li></ul><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/39b763bc3dc0dcc869d3c185c46dade4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SAkMA3sNdFjGJBFw.jpg"/></div></div></figure><p id="9dd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如所料，这是第一次运行，因此两个节点的输出都是通过调用它们的<code class="du lh li lj lk b">run</code>方法来计算的。这里的日志显示了数据存储的位置</p><ul class=""><li id="2c60" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lg jv jw jx bi translated">尝试使用相同的命令再次运行它:<code class="du lh li lj lk b">$ python mnist.py</code>。这一次你应该会看到一些不同的东西:</li></ul><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/af1c6e8eb711df48de4423f450f82f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S_fv72hqG8oy0TY0.jpg"/></div></div></figure><p id="3c06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为所有的中间输出都已经计算过了，所以管道只是在每一步重新加载数据，而不是重新计算</p><ul class=""><li id="e0db" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lg jv jw jx bi translated">让我们对<code class="du lh li lj lk b">__main__</code>中的config值进行更改:</li></ul><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="19e9" class="lt ke hi lk b fi lu lv l lw lx"># svm_node = SVMClassifier({'gamma': 0.01})<br/>svm_node = SVMClassifier({'gamma': 0.05})</span></pre><ul class=""><li id="fd7e" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lg jv jw jx bi translated">再次运行管道。您会看到类似这样的内容:</li></ul><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/9a9aaf6b09396fe05ce71c9b20d34460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aZiwQUAsICm3EiiU.jpg"/></div></div></figure><p id="f2d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一次，它使用第一个节点的结果，并为第二个节点重新计算，因为我们对配置进行了更改。</p><p id="ffb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你对类<code class="du lh li lj lk b">SVMClassifier</code>做了任何改变，同样的事情会再次发生</p><p id="3d63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">管道运行的日志保存为JSON文件，格式为<code class="du lh li lj lk b">yyyy-mm-dd--hh-mm-ss</code>。对我们来说，在最后一次运行中生成的是:<code class="du lh li lj lk b">2020-12-04--01-46-46.json</code></p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/df37ba0ecb424de4df77202275b5ab92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DMHJRc3pP_qcUD_7WHlzVw.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx translated"><code class="du lh li lj lk b">2020-12-04--01-46-46.json</code></figcaption></figure><p id="40e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，它会告诉您所有已保存数据的路径，还会告诉您上次运行的结果是否被重用。我们将努力使这些日志在未来变得更加丰富和有用。</p><p id="a45c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更多关于内功的详细信息你可以看看这里:<a class="ae jo" href="https://shashank-yadav.github.io/fastpipeline/about/" rel="noopener ugc nofollow" target="_blank">https://shashank-yadav.github.io/fastpipeline/about/</a></p><h1 id="6706" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论:</h1><p id="ce23" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">这个库很容易上手，不需要对你的工作流程做太多改变，你将获得可重复性、快速实验和更好的日志记录。正如帖子开头提到的，这里有一些重要的链接:</p><p id="4424" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">文件</strong>:【https://shashank-yadav.github.io/fastpipeline/ T2】</p><p id="1254" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">【https://github.com/shashank-yadav/fastpipeline】源代码 : <a class="ae jo" href="https://github.com/shashank-yadav/fastpipeline" rel="noopener ugc nofollow" target="_blank">源代码</a></p><p id="b5f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在Github repo中找到一些例子。更多在路上。很高兴听到您的反馈！</p></div></div>    
</body>
</html>