<html>
<head>
<title>What is Microservices Architecture? Implementation of a Microservice in Golang using go-micro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是微服务架构？使用go-micro在Golang中实现微服务</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/what-is-microservices-architecture-implementation-of-a-microservice-in-golang-using-go-micro-772578b37756?source=collection_archive---------16-----------------------#2019-12-04">https://medium.com/analytics-vidhya/what-is-microservices-architecture-implementation-of-a-microservice-in-golang-using-go-micro-772578b37756?source=collection_archive---------16-----------------------#2019-12-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="6d2a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><ul class=""><li id="a45b" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">它是面向服务架构(或SOA)的一种变体。</li><li id="ba93" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">面向服务的架构(SOA)是一种架构方法，其中应用程序利用网络中可用的服务。在这种架构中，通过互联网上的通信呼叫，提供服务以形成应用。</li><li id="3630" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">因此，我们可以将SOA视为客户端-服务器架构的通用版本，其中服务器可以服务于来自任何客户端而不是特定客户端的请求，就像典型的客户端-服务器架构一样。</li><li id="a7c1" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">遵循Unix哲学<em class="ka">“做一件事，把它做好”</em>。</li><li id="4555" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">微服务架构的目的是使系统解耦，更加模块化。系统的不同组件是松散耦合的。这个想法是为了实现“关注点分离”。</li></ul><p id="6437" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated"><strong class="jf hj">现在让我们来谈谈微服务架构的优缺点。</strong></p><h2 id="8ac6" class="ks ig hi bd ih kt ku kv il kw kx ky ip jk kz la it jm lb lc ix jo ld le jb lf bi translated">优势</h2><ol class=""><li id="c6be" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq lg js jt ju bi translated">由于系统被分解成几个独立的服务，因此每个组件都可以单独扩展和固定。这样水平缩放变得容易多了！</li><li id="4f23" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">每个组件都是相互独立的语言和设计。因此，系统可以是多语言的，我们可以选择语言或工具，以最好的方式服务于特定组件的目的。例如，假设我正在构建一个需要高度并发的软件，它还需要实现一些机器学习算法。在整体架构中，由于整个代码库通常是用一种语言编写的，在这种情况下，让这种语言是Python，那么我们可以实现一个非常好的机器学习算法的实现，但却无法使用一个非常好的框架来编写高度并发的web服务器。如果我们能够用支持高并发性的语言(如golang)和python中的机器学习部分来编写web服务器就更好了，因为它有非常好的库。幸运的是，微服务架构让你实现了这一点，因为机器学习部分和web服务器部分可以被制成微服务，它们可以通过网络调用(通常)相互通信，因此相互独立。</li><li id="5f85" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">每个服务的规模越小，理解系统就越容易。在一个整体架构中，系统的整个逻辑同时存在，理解一个特定的部分变得很困难。例如，假设脸书有单体建筑。如果我想了解脸书是如何处理用户注册过程的，那么我将不得不浏览数百万行代码来理解注册是如何工作的。但是，如果脸书有微服务架构，用户注册的是完全不同的服务，那么我可以直接访问该服务并了解其工作流程。随着软件规模的增长和新员工不断加入组织，这个概念变得非常重要。</li><li id="9a2e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">它允许连续交付，因为系统现在是松散耦合的(每个服务相互独立)。<br/>对于eg，假设我的软件有两个部分，注册和签到。如果我的注册工作已经完成，而登录还没有完成，我可以单独部署注册，而不是等待登录完成！</li><li id="8053" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">成本优化可以通过只缩放那些需要缩放的部分来实现。<br/>举个例子，假设我正在开发一个音乐流媒体服务，目前有很多用户注册，但实际上并没有很多人在听音乐。然后，我可以扩大用户注册微服务，而不是流媒体服务，因此成本降低。</li></ol><h2 id="99b0" class="ks ig hi bd ih kt ku kv il kw kx ky ip jk kz la it jm lb lc ix jo ld le jb lf bi translated">不足之处</h2><ol class=""><li id="0874" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq lg js jt ju bi translated">难测试:由于系统现在分为多个部分，现在为了测试整个系统，每个部分(微服务)都需要单独测试。</li><li id="5e55" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">问题倍增:假设整个系统有<strong class="jf hj"> n </strong>个问题，现在它被分成<strong class="jf hj"> m </strong>个微服务，所以现在我们有<strong class="jf hj"> n*m </strong>个问题！</li><li id="12dd" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">安全性降低:每个微服务都有自己的通信接口，因此通信接口的数量增加了，攻击的面积也增加了！</li><li id="15c8" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">依赖关系的数量增加。</li><li id="5a6e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">维护变得复杂。</li><li id="7a8c" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">微服务之间的大多数通信都是通过网络进行的，因此延迟增加了。</li><li id="c8e2" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">一些消息可能会丢失，导致可靠性降低。(这在很大程度上可以通过在Kafka、Rabbit MQ等服务之间使用消息队列来解决)</li></ol><h2 id="d19c" class="ks ig hi bd ih kt ku kv il kw kx ky ip jk kz la it jm lb lc ix jo ld le jb lf bi translated">典型结构</h2><p id="35cd" class="pw-post-body-paragraph kb kc hi jf b jg jh ke kf ji jj kh ki jk lh kk kl jm li kn ko jo lj kq kr jq hb bi translated">微服务由三个主要组件组成:</p><p id="33ad" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">|通信| -&gt; |处理| -&gt; |存储|</p><ol class=""><li id="8636" class="jd je hi jf b jg kd ji kg jk lk jm ll jo lm jq lg js jt ju bi translated">通信主要以HTTP API或gRPC端点的形式实现。它用于接收请求和响应。</li><li id="3d8f" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">处理是微服务的核心逻辑，处理请求并生成响应。</li><li id="8bc1" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">存储是可选的，但是如果微服务需要持久存储，那么它需要有一个单独的数据库。</li></ol></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h2 id="5605" class="ks ig hi bd ih kt ku kv il kw kx ky ip jk kz la it jm lb lc ix jo ld le jb lf bi translated">现在让我们实现一个简单的微服务，它将两个参数作为参数，将它们相加并返回结果。我们将使用golang中的go-micro框架来完成这项工作。</h2><p id="56fa" class="pw-post-body-paragraph kb kc hi jf b jg jh ke kf ji jj kh ki jk lh kk kl jm li kn ko jo lj kq kr jq hb bi translated">首先，为什么要写一个微服务？<br/> 1。语法和Python一样简单，但是由于类型安全、垃圾收集、没有花哨的技巧，产生的软件非常可靠！<br/> 2。它为几乎所有可能的平台生成静态二进制。你可以在Mac中编写代码，为Linux、windows等创建二进制文件。另外，单个二进制可执行文件允许创建小至5 MB的容器，这大大减少了引导时间。<br/> 3。对搭建微服务有很大的支持。事实上，据许多人说，它得到了最好的支持。诸如go-micro、go-kit、gizmo等框架使之变得轻而易举！<br/> 4。太快了！</p><p id="49dd" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">我们选择<a class="ae lu" href="https://github.com/micro/go-micro" rel="noopener ugc nofollow" target="_blank"> go-micro </a>框架是因为它抽象了许多分布式系统的复杂性，并且几乎可以直接开箱即用！一定要看看它的特点。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es lv"><img src="../Images/ed857ba383232d941d866bdab31b2c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gS7TNIltcAyOH6tGSBkYTA.png"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">去微</figcaption></figure><p id="e0db" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">请克隆<a class="ae lu" href="https://github.com/souvikhaldar/golang-microservice-example" rel="noopener ugc nofollow" target="_blank">此</a>存储库，并在以下步骤中引用它。</p><h1 id="5bac" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">先决条件</h1><ol class=""><li id="fd16" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq lg js jt ju bi translated">安装协议生成微<code class="du ml mm mn mo b">go get github.com/micro/protoc-gen-micro</code></li><li id="602d" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">安装Go对协议缓冲区的支持<code class="du ml mm mn mo b">go get -u github.com/golang/protobuf/protoc-gen-go</code></li><li id="a79e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated"><a class="ae lu" href="https://github.com/protocolbuffers/protobuf" rel="noopener ugc nofollow" target="_blank">安装协议缓冲编译器</a></li></ol><h1 id="181b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">编写自己的微服务的步骤</h1><ol class=""><li id="34d7" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq lg js jt ju bi translated">在protobuf中编写API文档，如<code class="du ml mm mn mo b">sum/sum.proto</code>所示</li><li id="766c" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">使用<code class="du ml mm mn mo b">protoc --proto_path=$GOPATH/src:. --micro_out=. --go_out=. sum.proto</code>编译它。</li><li id="cbce" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lg js jt ju bi translated">通过实现在生成的go文件中可以看到的<code class="du ml mm mn mo b">Adder</code>接口来实现服务器。在server.go中)和客户端(看impl。在client.go中)</li></ol><h1 id="2155" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">如何运行这个示例</h1><p id="6602" class="pw-post-body-paragraph kb kc hi jf b jg jh ke kf ji jj kh ki jk lh kk kl jm li kn ko jo lj kq kr jq hb bi translated">打开两个终端，首先在一个终端运行服务器，然后在另一个终端运行客户端。你完了！</p><p id="e7b9" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">这绝对是一个非常简单的服务，但我希望它能帮助您起步。我在一次聚会上讲过这个，你可以在这里分别找到<a class="ae lu" href="https://docs.google.com/presentation/d/1XPZp-ZeiGtQiypJkqyYBfkdvvUWPtKPQQ2p5cm8vkGo/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank">幻灯片</a>和<a class="ae lu" href="https://youtu.be/U7mKebOVoNY" rel="noopener ugc nofollow" target="_blank">视频演示</a>。如果需要更多信息，请在推特上联系我。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="d28a" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated"><em class="ka">原载于2019年12月4日</em><a class="ae lu" href="http://souvikhaldar.info/programming/py_micro/" rel="noopener ugc nofollow" target="_blank"><em class="ka">http://souvikhaldar . info</em></a><em class="ka">。</em></p></div></div>    
</body>
</html>