<html>
<head>
<title>Build a self-improving Recommendation Feed using MithrilJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MithrilJS构建一个自我改进的推荐提要</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-client-side-recommendation-feed-in-mithriljs-3af0b6ca3ba1?source=collection_archive---------22-----------------------#2020-04-12">https://medium.com/analytics-vidhya/building-a-client-side-recommendation-feed-in-mithriljs-3af0b6ca3ba1?source=collection_archive---------22-----------------------#2020-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="38e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我遇到了一个任务，为一个文章收集web应用程序设计一个推荐源。该应用程序帮助用户收集文章片段，并允许用户喜欢出现在提要中的其他用户的某些片段。</p><p id="44a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个新闻源…听起来很熟悉？这种设计模式实际上出现在脸书或推特这样的社交网络中。为什么我们不看看这些推荐算法是如何工作的，然后设计我们自己的推荐算法呢？</p><h1 id="3ba5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">脸书算法</h1><p id="ca77" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在脸书，新闻订阅会根据库存、信号和预测显示最受推荐的帖子(<a class="ae kg" href="https://tinuiti.com/blog/paid-social/facebook-algorithm/" rel="noopener ugc nofollow" target="_blank">https://tinuiti.com/blog/paid-social/facebook-algorithm/</a>)。</p><ul class=""><li id="bbc0" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">可显示的所有帖子的<strong class="ih hj">清单</strong>。</li><li id="ef2a" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj">告诉脸书每个帖子是什么的信号</strong>。</li><li id="5be2" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">预测你对每篇帖子的反应。</li><li id="1be9" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">基于所有考虑的因素分配给内容的<strong class="ih hj">最终分数</strong>。</li></ul><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es kv"><img src="../Images/4801150912ce5923ed12c562167666ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*aEillVYpDol6GQCe.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">脸书的[算法因素]</figcaption></figure><h1 id="fb62" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Twitter的算法</h1><p id="3b08" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在Twitter上，你可以看到热门帖子，或者你关注的人根据最近度、参与度、富媒体和活动转发的帖子。根据Twitter 2017年的博客帖子，它是基于。(<a class="ae kg" href="https://blog.twitter.com/engineering/en_us/topics/insights/2017/using-deep-learning-at-scale-in-twitters-timelines.html" rel="noopener ugc nofollow" target="_blank">https://blog . Twitter . com/engineering/en _ us/topics/insights/2017/using-deep-learning-at-scale-in-twitters-timelines . html</a>)</p><ul class=""><li id="4f0b" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><strong class="ih hj">最近度:</strong>一条推文发布的时间。</li><li id="95ed" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj">参与度:</strong>与一条推文获得多少转发、点击、收藏和印象有关。</li><li id="72bf" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj">富媒体:</strong>你在推文中包含的媒体类型，比如图像、视频和gif。</li><li id="0f7e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj">活跃度:</strong>指用户的活跃度。例如，用户上次登录该网站有多久了，他们有多少追随者，他们使用该平台的次数有多少。</li></ul><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/fe598801750723c64ee3bf4e3884c174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lWEzAYzT7o53kJXO.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">Twitter的[时间轴算法]</figcaption></figure><h1 id="a472" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">从头再来</h1><p id="8b00" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为了想出我们自己的算法，我们需要从头开始。我们将讨论几个与snippets应用程序的用户故事相关的问题:</p><ol class=""><li id="9931" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc lm kn ko kp bi translated">这些建议的目的是什么？</li><li id="4155" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lm kn ko kp bi translated">用户对推荐的反应如何？</li><li id="9726" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lm kn ko kp bi translated">作为一种反馈机制，如何衡量推荐的质量，以产生更好的长期推荐？</li></ol><h1 id="e64c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">建议的目的</h1><p id="1153" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于不同用户收集的代码片段，显示所有代码片段的地方应该是用户可以找到新的和有趣的代码片段的地方。因为我们希望用户喜欢这些建议，甚至采取行动。我们希望这些建议能够提高用户参与度。</p><p id="800f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先来看看数据结构，然后再来看看相关的属性。</p><ul class=""><li id="1cb9" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">文章标题</li><li id="1665" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">出版者</li><li id="d23c" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">片段内容</li><li id="6d77" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">时间戳</li><li id="8280" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">其他元数据…</li></ul><p id="a69c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与社交媒体帖子不同，文章片段的时间戳不应该引起普通用户的关注。片段的顺序应该根据每个用户之前对类似内容的反应来定制。考虑到这一点，我们可以将推荐问题分解成更小的部分，即:</p><ul class=""><li id="817e" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">存储、检索和转换用户反应</li><li id="2ac6" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">为推荐设置分数</li></ul><p id="eb05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很明显，推荐的质量越高，用户对snippet应用的粘性就越大。</p><h1 id="b323" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">用户对建议的反应</h1><p id="8dde" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">与HackerNews等链接聚合器不同，文章片段只能被“喜欢”。所以不存在“否决”或“不喜欢”一个片段的机制。这意味着每个片段的受欢迎程度与用户偏好直接相关。此外，用户还可以将代码片段保存到自己的帐户中。这种节约的行动自然应该比仅仅是喜欢更有分量。因此，我们的片段可爱分数的公式如下:</p><p id="f0f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">得分=“喜欢”数* 0.5 +“保存”数* 0.75 +关键词相关性* 1</p><p id="1685" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在把权重放在第一位，把关键词相关性放在喜欢和保存的最前面。经过一点测试后，它可能会改变。</p><h1 id="db2c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">演示</h1><p id="21d9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">让我们为片段搭建舞台。如果你想看到最终的结果，就去看看演示:<a class="ae kg" href="https://mithril-recommendation.netlify.com/" rel="noopener ugc nofollow" target="_blank">https://mithril-recommendation.netlify.com</a>。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ln"><img src="../Images/14f987be6f0e5596297f5ff9ebc41343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwMqVDk3ntdOtXK3i9FipQ.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">演示时间</figcaption></figure><h1 id="0553" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">衡量建议的质量</h1><p id="f4ce" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在这个演示中，我们允许用户通过直接与片段交互来影响喜欢的分数，例如喜欢、保存或指示他们的主题偏好。随着更多用户的加入，我们应该把rooom留给需要改进的建议。要做到这一点，我们需要定义一个推荐有多好。</p><p id="5561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一种方法是当一个片段位于web应用程序的中心视图时，测量屏幕空闲时间的持续时间。通过这种方式，我们可以获得每个用户对每个片段的关注持续时间，这又可以反馈到评分算法中。</p><h1 id="0b51" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">我们将何去何从？</h1><p id="30c7" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在生产应用程序中，这种推荐提要可以在特定库的帮助下实现，这些库使用协作过滤来实现快速有效的结果。在本教程中，我们试图实现一种不同的方式来推荐项目，而不是重炮。这种方法对于不消耗大量服务器资源的客户端应用程序可能很有用。</p><p id="631c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您阅读本教程！希望它能帮助你在你的项目中开始你自己的推荐feed。</p></div></div>    
</body>
</html>