<html>
<head>
<title>Facial filters using OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCV的面部滤镜</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/facial-filters-using-opencv-d543300ff51?source=collection_archive---------18-----------------------#2020-07-02">https://medium.com/analytics-vidhya/facial-filters-using-opencv-d543300ff51?source=collection_archive---------18-----------------------#2020-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><ol class=""><li id="f1be" class="if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw bi translated">OpenCV是什么？</li></ol><p id="2aac" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">OpenCV(开源计算机视觉库)是一个开源的计算机视觉和机器学习软件库。OpenCV旨在为计算机视觉应用提供一个公共基础设施，并加速机器感知在商业产品中的应用。该库拥有超过2500种优化算法。这些算法可用于检测和识别人脸、识别物体、对视频中的人类动作进行分类、跟踪相机运动、跟踪运动物体、将图像拼接在一起以产生整个场景的高分辨率图像、从图像数据库中找到相似的图像、从使用闪光灯拍摄的图像中去除红眼、跟踪眼球运动等。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/e4d02c24f45ad188f4f70003efd5335a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cb1HvpKrq8YaSdmLxGJ5lA.png"/></div></div></figure><p id="cced" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">2.Haarcascade:</p><p id="362f" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">Haar Cascade是一种机器学习对象检测算法，用于识别图像或视频中的对象。Haarcascade通常用于识别某些面部特征，例如眼睛、微笑、脸。这在我们的项目中非常有用，因为我们需要检测某些面部特征，然后在它们上面覆盖所需的过滤器。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es jy"><img src="../Images/a99393bd431bd89465dd2593d55832dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*Lj6n65iBF0_SctyXmsVEXA.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">haarcascade面部检测的例子</figcaption></figure><p id="51a3" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">3.构建过滤器的步骤包括:</p><p id="2925" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">I .使用haarcascade和openCV检测特定的面部特征。</p><p id="0481" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">二。获取帧中检测到的特征的坐标。</p><p id="2cd2" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">三。用期望的过滤器图像替换由坐标指示的帧部分。</p><p id="6fde" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">I .导入opencv和各自的haarcascade xml文件。</p><pre class="jn jo jp jq fd kd ke kf kg aw kh bi"><span id="bb48" class="ki kj hi ke b fi kk kl l km kn">import cv2<br/>face1 = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')</span><span id="7f07" class="ki kj hi ke b fi ko kl l km kn">cap = cv2.VideoCapture(0) #Use the system camera for capturing video<br/>repl1 = cv2.imread('mask4.png')  #Load the filter image</span></pre><p id="8e97" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">二。</p><pre class="jn jo jp jq fd kd ke kf kg aw kh bi"><span id="be1c" class="ki kj hi ke b fi kk kl l km kn">while True: <br/>    ret,frame = cap.read()  #Saving the captured video frames</span><span id="cb17" class="ki kj hi ke b fi ko kl l km kn"># The frames captured are by default mirrored so they need to be flipped before using further<br/>    frame = cv2.flip(frame,1) </span><span id="28fa" class="ki kj hi ke b fi ko kl l km kn"># Converting the image to grayscale makes it easier for processing <br/>    gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)<br/></span></pre></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="d718" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">将图像转换为灰度后，我们可以开始叠加滤镜。</p><pre class="jn jo jp jq fd kd ke kf kg aw kh bi"><span id="6c4e" class="ki kj hi ke b fi kk kl l km kn">f = face1.detectMultiScale(gray,scaleFactor = 1.1,minNeighbors = 7)</span><span id="85a8" class="ki kj hi ke b fi ko kl l km kn">#This will capture the features in the given image and save them.</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es kw"><img src="../Images/851c40c5757adf4f9a0d76f190ac4754.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*JY-aeXcZ6tDx5Ju_f_J29g.jpeg"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">坐标可视化</figcaption></figure><p id="41d9" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">请参考上图，获取以下覆盖图:</p><pre class="jn jo jp jq fd kd ke kf kg aw kh bi"><span id="3262" class="ki kj hi ke b fi kk kl l km kn">for x,y,w,h in f:<br/>        #frame = cv2.rectangle(frame,(x,y),(x+h,y+w),(0,255,0),2) (Optional : Rectangle can be displayed for reference)</span><span id="f4f8" class="ki kj hi ke b fi ko kl l km kn">frame[y:y+w,x:x+h] = repl1 <br/>        cv2.imshow('Face Recognized',frame)</span><span id="eba4" class="ki kj hi ke b fi ko kl l km kn"># Frame will be closed by pressing 'q' key:<br/>if cv2.waitKey(1) == ord('q'): <br/>        break</span></pre><p id="8433" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">上面的代码将完全正常工作，覆盖将被应用，但是，一旦您试图移向或远离相机，您将观察到覆盖没有根据功能缩放。这个问题需要解决。因此，我们需要动态调整覆盖图像的大小，然后将其应用到我们的框架中。</p><pre class="jn jo jp jq fd kd ke kf kg aw kh bi"><span id="fb93" class="ki kj hi ke b fi kk kl l km kn">repl1 = cv2.resize(repl1,(w,h))</span><span id="2992" class="ki kj hi ke b fi ko kl l km kn">#This needs to be added before the replacement of overlay in the frame.</span></pre><p id="7aaa" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">动态调整大小将极大地改变图像分辨率，但它将解决上述问题。</p><p id="4fd3" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">最后，我们需要在功能完成后关闭系统摄像头。</p><pre class="jn jo jp jq fd kd ke kf kg aw kh bi"><span id="a5d7" class="ki kj hi ke b fi kk kl l km kn">cap.release()          <br/>cv2.destroyAllWindows()</span></pre><p id="35fc" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">就是这样！您可以应用您选择的覆盖，并将其用作过滤器。请注意，这个过滤器应用程序过于简单，并不完全适合这些特性(可以通过优化来实现)。因此，应该仔细选择叠加图像和多尺度参数。</p><p id="53de" class="pw-post-body-paragraph ix iy hi ih b ii ij iz ja ik il jb jc im jd je jf io jg jh ji iq jj jk jl is hb bi translated">演示滤镜图像:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kx"><img src="../Images/01b63000bba56bbe28b0eaf82dd18583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xh0RyBxXbGHTnNgyyL23jw.png"/></div></div></figure></div></div>    
</body>
</html>