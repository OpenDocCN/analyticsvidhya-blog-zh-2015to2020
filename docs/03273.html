<html>
<head>
<title>Using a custom metric in Catboost: Classification as regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Catboost中使用自定义度量:分类为回归</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/using-a-custom-metric-in-catboost-classification-as-regression-1ad42b2e7d?source=collection_archive---------3-----------------------#2020-01-23">https://medium.com/analytics-vidhya/using-a-custom-metric-in-catboost-classification-as-regression-1ad42b2e7d?source=collection_archive---------3-----------------------#2020-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5915318e73ad53fe89d1ab5a5d62268b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5NRkOsBjlVdsDVs7ydhSg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">科林·沃茨在<a class="ae iu" href="https://unsplash.com/s/photos/cat-and-trees?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="de48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博客中，我将分享我在Catboost中为Kaggle比赛定义自定义指标的经验。</p><p id="f46a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Catboost文档<a class="ae iu" href="https://catboost.ai/docs/concepts/python-usages-examples.html#custom-loss-function-eval-metric" rel="noopener ugc nofollow" target="_blank">第</a>页提供了一个如何为过拟合检测器和最佳模型选择实现自定义指标的示例。虽然，我觉得它不够琐碎，所以我写这篇文章作为我自己和其他用户的未来参考，他们可能会发现这些笔记很有用。</p><p id="fb44" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我将设置场景，说明当Catboost有大量的<a class="ae iu" href="https://catboost.ai/docs/references/custom-metric__supported-metrics.html" rel="noopener ugc nofollow" target="_blank">支持的指标</a>可用时，我为什么要使用自定义指标。</p><p id="c851" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">目标</strong>:建立一个模型，根据儿童之前的应用程序使用数据，预测评估组(4个班级)的儿童。参见<a class="ae iu" href="https://www.kaggle.com/c/data-science-bowl-2019" rel="noopener ugc nofollow" target="_blank">ka ggle 2019数据科学碗</a>。</p><p id="3c52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">评估指标</strong> : <a class="ae iu" href="https://en.wikipedia.org/wiki/Cohen%27s_kappa" rel="noopener ugc nofollow" target="_blank">二次加权Kappa</a>(QWK)——这是衡量两个结果之间一致性的指标；我们的预测与地面真相标签。</p><p id="f47b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">策略</strong>:建立一个回归模型，应用一些边界截止点，将回归模型的连续结果转换成可用于QWK度量的离散结果(4个类别)。</p><p id="35db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的问题是，我们正在构建一个回归模型，但是想要使用QWK度量，这是一个分类度量T21。尽管QWK作为wk appa(Catboost分类模型中预定义的指标)可用，但它不能用于回归模型。</p><p id="de7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决这个问题的一种方法是建立一个定制的度量标准，将回归模型的连续结果转换成4类，然后应用外包的QWK度量标准。(<strong class="ix hj">见例2 </strong>)</p><p id="8f29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">示例2 </strong>中的自定义指标可用作回归模型的过度拟合检测器！</p><p id="e215" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要在Catboost中构建自定义指标，必须遵循以下格式。参见Catboost文档<a class="ae iu" href="https://catboost.ai/docs/concepts/python-usages-examples.html#custom-loss-function-eval-metric" rel="noopener ugc nofollow" target="_blank">第</a>页。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="0009" class="kd ke hi jz b fi kf kg l kh ki">class CustomMetric(object):<br/>    def get_final_error(self, error, weight):<br/>        return 0.0</span><span id="6721" class="kd ke hi jz b fi kj kg l kh ki">def is_max_optimal(self):<br/>        return True</span><span id="40a1" class="kd ke hi jz b fi kj kg l kh ki">def evaluate(self, approxes, target, weight):<br/>        # approxes - list of list-like objects (one object per approx dimension)<br/>        # target - list-like object<br/>        # weight - list-like object, can be None<br/>        return 0.0, 0.0</span></pre><p id="a85f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以将类名<code class="du kk kl km jz b">CustomMetric</code>编辑成您想使用的任何名称，但是…</p><p id="2074" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:不要编辑以下任何函数名<br/> </strong> <code class="du kk kl km jz b">get_final_error, is_max_optimal, evaluate</code></p><ol class=""><li id="c291" class="kn ko hi ix b iy iz jc jd jg kp jk kq jo kr js ks kt ku kv bi translated">让我们开始讨论<code class="du kk kl km jz b">evaluate</code>函数。</li></ol><p id="d3ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">变量</strong> <br/> <code class="du kk kl km jz b">approxes</code>:如果使用<code class="du kk kl km jz b">eval_metric</code>参数，这些是您在<code class="du kk kl km jz b">fit</code>方法中由CatBoostRegressor模型提供的预测。<code class="du kk kl km jz b">approxes </code>将以类格式<em class="jt"> DoubleArrayWrapper </em>出现，它们是索引容器(例如元组、列表、集合、字典；这些是内置的<strong class="ix hj">容器</strong>。要访问容器中的内容，我们需要通过它的索引来调用它，并将它赋给一个变量。因此，我们编写<code class="du kk kl km jz b">approx=approxes[0]</code>，如下面两个例子所示。</p><p id="1f32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以把<code class="du kk kl km jz b">approx</code> <strong class="ix hj"> </strong>看作是我们通常的预测列，其形状与我们的标签/目标列相同。</p><p id="0c35" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的例子中，<strong class="ix hj"> Example 2 </strong>，我的目标列的形状是<em class="jt"> N </em> x <em class="jt"> 1 </em>因此，访问每个条目只需调用它们的索引，即<code class="du kk kl km jz b">approx[i] for i in range(len(approx))</code></p><p id="7094" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们能够访问我们的预测条目，我们现在可以进行适当的操作，以便计算我们正在尝试构建的定制指标。</p><p id="458a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些是你的基本事实标签。形状将取决于您为模型构建的度量的类型。</p><p id="6b23" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kk kl km jz b">weight</code>:要在您的自定义指标上使用的重量。这个可以<code class="du kk kl km jz b">None</code>。形状将取决于您为模型构建的度量的类型。</p><p id="08f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">返回语句<br/> </strong>函数<code class="du kk kl km jz b">evaluate</code>要求我们返回一个有序对，例如<code class="du kk kl km jz b">return 0.0, 0.0</code>。</p><p id="851a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该有序对的第一个和第二个条目将分别用作<code class="du kk kl km jz b">get_final_error</code>函数的<code class="du kk kl km jz b">error</code>变量和<code class="du kk kl km jz b">weight</code>变量。</p><p id="63f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.接下来，是<code class="du kk kl km jz b">is_max_optimal</code>功能。</p><p id="6a96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">设置<code class="du kk kl km jz b">return True</code>意味着<strong class="ix hj">较高的返回值比较低的返回值更好。</strong></p><p id="34bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">设置<code class="du kk kl km jz b">return False</code>意味着<strong class="ix hj">较低的返回值比较高的返回值更好。</strong></p><p id="9e7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.最后，我们的最后一个函数是<code class="du kk kl km jz b">get_final_error.</code></p><p id="dee3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">变量</strong> <br/> <code class="du kk kl km jz b">error</code>和<code class="du kk kl km jz b">weight</code>:如上所述，这两个变量是<code class="du kk kl km jz b">evaluate</code>函数的输出。现在，您可以进行适当的操作来获得最终的错误输出(参见<strong class="ix hj">示例1 </strong>)。有时，没有更多的事情要做，简单地返回<code class="du kk kl km jz b">error</code>就像在<strong class="ix hj">例子2 </strong>中那样就足够了。</p><p id="7be1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Return语句<br/> </strong> Catboost期望一个单一实数。</p><p id="c58a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的第一个例子在Catboost <a class="ae iu" href="https://catboost.ai/docs/concepts/python-usages-examples.html#custom-loss-function-eval-metric" rel="noopener ugc nofollow" target="_blank">文档</a>中提供。为了便于参考，我将把它放在这里。</p><p id="fb41" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例1 </strong></p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="8764" class="kd ke hi jz b fi kf kg l kh ki">class LoglossMetric(object):<br/>    def get_final_error(self, error, weight):<br/>        return error / (weight + 1e-38)</span><span id="4a09" class="kd ke hi jz b fi kj kg l kh ki">    def is_max_optimal(self):<br/>        return True</span><span id="2eca" class="kd ke hi jz b fi kj kg l kh ki">    def evaluate(self, approxes, target, weight):<br/>        # approxes is list of indexed containers<br/>        # (containers with only __len__ and __getitem__ defined), one container<br/>        # per approx dimension. Each container contains floats.<br/>        # weight is one dimensional indexed container.<br/>        # target is float.   <br/>        # weight parameter can be None.<br/>        # Returns pair (error, weights sum)</span><span id="1358" class="kd ke hi jz b fi kj kg l kh ki">        assert len(approxes) == 1<br/>        assert len(target) == len(approxes[0])</span><span id="5a69" class="kd ke hi jz b fi kj kg l kh ki">        approx = approxes[0]</span><span id="529b" class="kd ke hi jz b fi kj kg l kh ki">        error_sum = 0.0<br/>        weight_sum = 0.0</span><span id="8252" class="kd ke hi jz b fi kj kg l kh ki">        for i in xrange(len(approx)):<br/>            w = 1.0 if weight is None else weight[i]<br/>            weight_sum += w<br/>            error_sum += w * (target[i] * approx[i] - math.log(1 + math.exp(approx[i])))</span><span id="084f" class="kd ke hi jz b fi kj kg l kh ki">        return error_sum, weight_sum</span></pre><p id="1ed2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面这个例子是我为<a class="ae iu" href="https://www.kaggle.com/c/data-science-bowl-2019" rel="noopener ugc nofollow" target="_blank">数据科学碗2019 Kaggle比赛实现的。</a></p><p id="7335" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例2 </strong></p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="kw kx l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">为Catboost定制Kappa指标</figcaption></figure><p id="befc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">备注:</strong>我定义变量<code class="du kk kl km jz b">pred</code>的原因是<code class="du kk kl km jz b">approx</code>，它是一个' _catboost。“_DoubleArrayWrapper”对象不支持项分配。</p><p id="bc12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Kaggle结果</strong></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/00c40ed4d323b8950d27d866ad07f045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3txnP29FNnXNOVd7aMQLQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd kz"> <em class="la">银牌得分</em> </strong></figcaption></figure><p id="4cc1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的结果是我的一个内核使用我为Catboost定制的Kappa度量得到的分数。不幸的是，我没有选择这个内核作为我的最终提交之一，所以我告别了银牌。</p><p id="4338" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用定制的Kappa指标的优势(正如我在比赛结束后意识到的)是，在交叉验证期间，我能够在回归模型的几个折叠中实现低得多的<em class="jt">均方根误差</em>。这应该是一个更稳定的指标，而不是排行榜上敏感的Kappa指标。</p><p id="3bca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">吸取教训！</p><p id="24c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦有时间，我打算通过我的GitHub 分享我的Kaggle内核的一个干净版本。感谢您阅读至此！</p></div></div>    
</body>
</html>