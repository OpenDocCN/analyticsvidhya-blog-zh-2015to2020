<html>
<head>
<title>Step by Step Train Model using Tensorflow (CNN)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用张量流(CNN)逐步训练模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/step-by-step-train-model-using-tensorflow-cnn-2f243b847c8?source=collection_archive---------3-----------------------#2020-09-09">https://medium.com/analytics-vidhya/step-by-step-train-model-using-tensorflow-cnn-2f243b847c8?source=collection_archive---------3-----------------------#2020-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6fd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Tensorflow逐步训练您自己的图像数据集以进行深度学习</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/bd0f8e872af6b5973bff2aee669bdfe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCunSvgQBQx34gwfJECAxw.png"/></div></div></figure><p id="109e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，有一个最简单的方法来训练你自己的形象。可以用<a class="ae jp" href="https://firebase.google.com/docs/ml" rel="noopener ugc nofollow" target="_blank"> Firebase机器学习</a>。你只需要上传你的图片和定义标签。但是如果你仍然想亲手训练一个模特，你可以继续阅读这个博客。</p><p id="bbfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论如何..你可以在这里找到完整的 <strong class="ih hj"> <em class="jq">源代码</em> </strong> <em class="jq">和数据集</em><a class="ae jp" href="https://github.com/adesueb/nurhadiml" rel="noopener ugc nofollow" target="_blank"><em class="jq"/></a></p><h1 id="c38c" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">准备数据集</h1><p id="6ae0" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">准备尽可能多的样本图像。按照分类/标签将它们放入每个文件夹。</p><p id="8dcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此我将从<a class="ae jp" rel="noopener" href="/@ade.sueb/simple-tflite-running-on-android-phone-2b03ab4c2e2e">这个故事</a>中使用<a class="ae jp" href="https://github.com/adesueb/nurhadiml/tree/master/dataset" rel="noopener ugc nofollow" target="_blank">矿</a>。为此，您可以使用<code class="du ku kv kw kx b">cat and dog</code>或<code class="du ku kv kw kx b">mnist</code>数据集。</p><h1 id="394d" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">加载数据集</h1><h2 id="9d2a" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">创建特征(X)和标签(Y)变量</h2><p id="5765" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">创建变量<code class="du ku kv kw kx b">X_TRAIN</code>和<code class="du ku kv kw kx b">Y_TRAIN</code>。两个人都成了阵的。</p><p id="1409" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建名为<code class="du ku kv kw kx b">labels</code>的变量数组，其中包含模型的标签或分类名称。</p><p id="ba31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将变量<code class="du ku kv kw kx b">labels</code>的索引保存到变量<code class="du ku kv kw kx b">Y_TRAIN</code>中。我们隐式地将标签编码成数字。这样我们就可以把它传给模特。</p><p id="060c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加载图像文件夹。一个接一个地迭代文件，并将标签名称的索引添加到变量数组中。对于这个变量<code class="du ku kv kw kx b">X_TRAIN</code>。</p><pre class="je jf jg jh fd lm kx ln lo aw lp bi"><span id="0dbb" class="ky js hi kx b fi lq lr l ls lt">DATADIR = "dataset"<br/>TESTDIR = "test"<br/>LABELS = ["indosiar", "indosiar_iklan", "sctv", "sctv_iklan"]</span><span id="6269" class="ky js hi kx b fi lu lr l ls lt">X_TRAIN = []<br/>Y_TRAIN = []</span></pre><h2 id="51c8" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">如果需要，增加数据(可选)</h2><p id="03b4" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">当你没有足够的数据集时，这是需要的。您可以翻转或调整图像大小。这样你就可以添加多个数据。</p><h2 id="1808" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">确保输入形状正确</h2><p id="8a64" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">你必须知道你的数据形变量是什么<code class="du ku kv kw kx b">X_TRAIN</code>。因为该形状必须与输入层相同。</p><pre class="je jf jg jh fd lm kx ln lo aw lp bi"><span id="2036" class="ky js hi kx b fi lq lr l ls lt">for label in LABELS:<br/>        path = os.path.join(DATADIR, label)<br/>        class_num = LABELS.index(label)<br/>        for img in os.listdir(path):<br/>            try:<br/>                img_array = cv.imread(os.path.join(path, img))<br/>                new_array = cv.resize(img_array, (IMG_SIZE, IMG_SIZE))<br/>                X_TRAIN.append(new_array)<br/>                Y_TRAIN.append(class_num)<br/>            except Exception as e:<br/>                pass</span></pre><p id="c798" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还需要重塑<code class="du ku kv kw kx b">X_TRAIN</code>。</p><pre class="je jf jg jh fd lm kx ln lo aw lp bi"><span id="439f" class="ky js hi kx b fi lq lr l ls lt">X_TRAIN = np.array(X_TRAIN).reshape(-1, IMG_SIZE, IMG_SIZE,3)</span></pre><p id="5feb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个参数是确定你有多少功能，我们把-1，这样我们就可以使用我们想要的功能。最后一个参数是数据集是RGB还是灰度。1用于灰色，3用于RGB。</p><h1 id="6223" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">构建模型(顺序)</h1><h2 id="e89b" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">输入层</h2><p id="deab" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们可以使用我们想要的图层，并指定输入参数。我们把变量<code class="du ku kv kw kx b">X_TRAIN</code>的形状作为输入参数。</p><pre class="je jf jg jh fd lm kx ln lo aw lp bi"><span id="464d" class="ky js hi kx b fi lq lr l ls lt">model.add(Conv2D(32, (5,5), input_shape = X_TRAIN.shape[1:]))</span></pre><h2 id="5c45" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">隐蔽层</h2><p id="37fc" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">因为我们要用CNN来训练，所以我们用Conv2D层来做这个。</p><p id="4f01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要多少隐藏层？取决于培训结果。我们不止一次训练。我们可以做很多次，直到我们有正确的组成(隐藏层的数量和参数，我们使用的层)的最佳结果。</p><pre class="je jf jg jh fd lm kx ln lo aw lp bi"><span id="5a9a" class="ky js hi kx b fi lq lr l ls lt">model.add(Conv2D(32, (5,5)))<br/>model.add(Activation("relu"))<br/>model.add(MaxPooling2D(pool_size=(2,2)))</span><span id="d3ee" class="ky js hi kx b fi lu lr l ls lt">model.add(Conv2D(32, (5,5)))<br/>model.add(Activation("relu"))<br/>model.add(MaxPooling2D(pool_size=(2,2)))</span></pre><h2 id="7f5c" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">输出或最终层</h2><p id="6d3d" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">对于输出，我们使用密集层。因为我们要将多维数组转换成1D数组，所以我们在密集层之前使用展平。</p><pre class="je jf jg jh fd lm kx ln lo aw lp bi"><span id="5228" class="ky js hi kx b fi lq lr l ls lt">model.add(Flatten())<br/>model.add(Dense(4))</span></pre><h2 id="2e94" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">还要选择正确的激活方式</h2><p id="48d7" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">因为我们的标签是4，所以我们最好使用Softmax作为激活函数。</p><pre class="je jf jg jh fd lm kx ln lo aw lp bi"><span id="0b9c" class="ky js hi kx b fi lq lr l ls lt">model.add(Activation("softmax"))</span></pre><h1 id="f188" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">编译模型</h1><h2 id="2bd4" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">损失函数</h2><p id="3be0" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">因为我们的标签是分类的(多于2个标签)并且我们的最终激活函数是Softmax，那么右边的损失函数是<code class="du ku kv kw kx b">categorical_crossentropy</code>。</p><h2 id="bf6a" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">【计算机】优化程序</h2><p id="2f5e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">对于优化器，我们使用了<code class="du ku kv kw kx b">adam</code>而不是<code class="du ku kv kw kx b">SGD</code>。<code class="du ku kv kw kx b">adam</code>比<code class="du ku kv kw kx b">SGD</code>快，尽管<code class="du ku kv kw kx b">SGD</code>比<code class="du ku kv kw kx b">adam</code>更准确。</p><h2 id="702e" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">韵律学</h2><p id="4c7b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">对于log，我们选择<code class="du ku kv kw kx b">accuracy</code>。</p><pre class="je jf jg jh fd lm kx ln lo aw lp bi"><span id="bc5c" class="ky js hi kx b fi lq lr l ls lt">model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])</span></pre><h1 id="261b" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">火车模型</h1><h2 id="7f6e" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">经过X和Y列车</h2><p id="4b5f" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">只是在第一个和第二个参数处将X_TRAIN和Y_TRAIN传递给model.fit。</p><h2 id="7ad9" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">一批</h2><p id="a7d1" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">对于批量，我们可以使用32或10或任何你想要的。这种批处理使训练过程更快，特别是如果你使用<a class="ae jp" rel="noopener" href="/swlh/use-gpu-for-programming-on-linux-case-tensorflow-b79e15f25351"> GPU进行训练</a>。这个批在一个历元内同时处理多少个数据，这个数量影响到计算的准确性和丢失百分比。</p><h2 id="96d5" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">纪元</h2><p id="1b25" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">每一个时代都是一个训练过程。并且在1次训练之后，通常会用损失函数和优化器来计算。这样训练后的模型越来越好。但是如果我们有太多的纪元，那么就会造成过度拟合。</p><h2 id="1210" class="ky js hi bd jt kz la lb jx lc ld le kb iq lf lg kf iu lh li kj iy lj lk kn ll bi translated">验证数据</h2><p id="7883" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">不一定要有验证数据。您可以通过指定<code class="du ku kv kw kx b">validation</code>参数从训练数据集中分离出来。</p><pre class="je jf jg jh fd lm kx ln lo aw lp bi"><span id="bfb2" class="ky js hi kx b fi lq lr l ls lt">model.fit(X_TRAIN,Y_TRAIN, epochs=10, validation_split=0.1)</span></pre><h1 id="73eb" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">试验模型</h1><p id="d3cd" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">使用不包含在训练数据集中的图像。并为此使用预测函数。</p><pre class="je jf jg jh fd lm kx ln lo aw lp bi"><span id="f8c3" class="ky js hi kx b fi lq lr l ls lt">for img in os.listdir(TESTDIR):<br/>    try:<br/>        img_array = cv.imread(os.path.join(path, img))<br/>        new_img = cv.resize(img_array, (IMG_SIZE, IMG_SIZE))<br/>        new_shape = new_img.reshape(-1, IMG_SIZE, IMG_SIZE, 3)<br/>        predictions = model.predict(new_shape)<br/>        plt.imshow(new_img)<br/>        print(predictions)<br/>        print(LABELS[np.argmax(predictions)])<br/>    except Exception as e:<br/>        pass</span></pre><h1 id="6e6e" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">完整源代码</h1><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lv lw l"/></div></figure></div></div>    
</body>
</html>