<html>
<head>
<title>2x faster than Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比Python快2倍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/2x-faster-than-python-7c15ab0a9286?source=collection_archive---------14-----------------------#2020-01-18">https://medium.com/analytics-vidhya/2x-faster-than-python-7c15ab0a9286?source=collection_archive---------14-----------------------#2020-01-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4cb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TPython现在的速度是Python3的两倍，重量为143KB，这使得它可以在浏览器中使用，当翻译到WASM时，它只有220KB (gz压缩)。TPython甚至比<a class="ae jd" href="https://github.com/micropython/micropython" rel="noopener ugc nofollow" target="_blank">micro ython</a>还要小，396KB。虽然比MicroPython小，但TPython的RAM使用量要高得多，但这主要是由于垃圾收集器中未完成的工作，以及它的设计目标是以内存换取性能。MicroPython是为微控制器设计的，而TPython是为运行在虚幻之类的游戏引擎中而设计的。标准Python对浏览器可行吗？libpython.3.7m.a是32MB，绝对不是。RustPython呢，还是不行，22MB。</p><h1 id="aced" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Pystone基准</h1><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/6ebe7ce8791fdde3e5989b499f7851a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SWL51u0qro4N6_peZOxu5w.png"/></div></div></figure><p id="b507" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面橙色的TPython比青色的Python3快2倍。低于内存使用峰值。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/f81fdf6030360212036f694b48c5cad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFTn5B9cA9-X5k4en4WPvA.png"/></div></div></figure><p id="ff5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就峰值内存使用而言，LuaJIT和MicroPython是明显的赢家，python ++紧随其后。TPython遗留垃圾收集器还需要工作，<a class="ae jd" href="https://gitlab.com/hartsantler/tpythonpp/issues/1" rel="noopener ugc nofollow" target="_blank">修复</a>正在进行中。</p><h1 id="003f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">递归斐波那契基准</h1><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/038ed70a9a0877caca021254a9347527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NY1M6eN3BeQcAwp_xwnU3g.png"/></div></div></figure><p id="0890" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的TPython(橙色)也比Python3(青色)快2倍。这个基准测试很好地测试了调用函数的原始速度。我想知道为什么LuaJIT在这种情况下如此慢，通常它的速度是无与伦比的，但这可能是一个迹象，表明依赖JIT不是最好的方法。注意TPython只是一个优化的解释器，不是JIT。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/8e5e9ceba0d090d3487cb8fc29d1836d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d6WCJk363UzDxgQnhPdqg.png"/></div></div></figure><p id="0159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面我们可以看到使用JIT技术的另一个缺点，那就是内存使用，NodeJS和PyPy对于这样一个简单的基准测试都需要大量的内存使用。而TPython使用的内存比Python3少，甚至比MicroPython也差不了多少。请注意，TPython使用16字节的堆栈分配结构作为其主要数据类型，其中包含类型信息、堆栈分配字符串或指针。Python在堆上分配，所以它的原始数据类型是一个指针(8字节)</p><h2 id="b431" class="ko jf hi bd jg kp kq kr jk ks kt ku jo iq kv kw js iu kx ky jw iy kz la ka lb bi translated">RustPython只是一个闪亮的新玩具</h2><p id="7910" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">RustPython 是大家都很兴奋的新产品，因为它是用Rust编写的，但它只是一个闪亮的新玩具，在速度或大小上永远无法与tPython相提并论。4864个提交，128个贡献者，除了让它慢下来，我想知道他们在做什么？他们说他们的目标是完全实现python语言规范，这是毫无意义的，因为如果你想要一个符合标准的Python，那么你就使用用C编写的标准Python，它与所有现有的Python模块兼容。难道他们没有看到PyPy是如何以同样的方式取代原始Python的吗？让我们看看RustPython在相同的基准测试中表现如何。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/e33f3fc91e3e7d76a5b127ad323087fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWaC7250oPbxQRU1-KVidQ.png"/></div></div></figure><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/f989f941631c1071c1510f2666e38492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJqK2LIhGrK971o1hsO7Rg.png"/></div></div></figure><p id="4a99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将近30秒来计算递归斐波那契，真的吗？Rust的一个大问题是它给编码人员的印象是他们知道自己在做什么，并且可以通过并发获得很好的性能，但实际上如果你知道自己在做什么，你可能会使用C++。</p></div></div>    
</body>
</html>