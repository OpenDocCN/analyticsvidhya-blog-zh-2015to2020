<html>
<head>
<title>Computer Vision — Features from Accelerated Segment Test (FAST)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉—加速分段测试(FAST)的特征</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/computer-vision-features-from-accelerated-segment-test-fast-7d87bc874f1f?source=collection_archive---------23-----------------------#2020-03-17">https://medium.com/analytics-vidhya/computer-vision-features-from-accelerated-segment-test-fast-7d87bc874f1f?source=collection_archive---------23-----------------------#2020-03-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d60a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是计算效率最高的特征检测算法之一，非常适合实时视频处理。让我们直接进入算法，看看它是如何工作的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/6a14b27358999eec8a2d2b4697fb479e.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/0*X-8wgU1SuvTROYcu.jpg"/></div></figure><ol class=""><li id="0e23" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">我们首先在图像中取一个像素<strong class="ih hj"> p </strong>(把这个点看作一个兴趣点，我们以后可能会忽略它)。让它的强度成为<strong class="ih hj"> Ip。</strong></li><li id="88a0" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">然后我们在它周围画一个16像素的圆，叫做半径为3的Bresenham圆，也就是上图中的圆。</li><li id="8a2b" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">然后我们选择一个合适的阈值<strong class="ih hj"> t. </strong></li><li id="c4a6" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">如果在16个像素的圆圈中存在一组比<strong class="ih hj"> Ip+t </strong>更亮或比<strong class="ih hj">Ip-t</strong>更暗的<strong class="ih hj"> n </strong>个连续像素，则我们确定像素<strong class="ih hj"> p </strong>是否为拐角</li><li id="b840" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">该算法进行高速测试，首先使用<strong class="ih hj"> Ip检查像素1、5、9和13的强度。</strong>这4个像素中的至少3个像素应满足4)中规定的阈值标准，以确定兴趣点将存在。</li><li id="cc4d" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">如果它通过了第5步，我们继续检查所有16个像素，看看是否有12个相邻的像素符合标准。否则，我们拒绝利息点。</li><li id="7479" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">当然，对图像中的所有像素重复同样的过程。</li></ol><p id="31eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上就是这样！这是快速算法！然而，它也有一些局限性。</p><ol class=""><li id="051f" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">对于n&lt;12，它不拒绝同样多的候选。</li><li id="e99f" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">像素的选择不是最佳的，因为效率取决于问题的顺序和角点外观的分布。</li><li id="f669" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">高速测试的结果被扔掉，不存储。</li><li id="0e93" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">可能检测到多个彼此相邻的特征。</li></ol><p id="373c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">否则这就是一个超级酷的算法！</p></div></div>    
</body>
</html>