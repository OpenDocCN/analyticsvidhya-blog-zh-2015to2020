<html>
<head>
<title>Understanding Neural Networks: The Secret Lies in Our Brains</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解神经网络:秘密在于我们的大脑</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-neural-networks-the-secret-lies-in-our-brains-5d8dc907ab34?source=collection_archive---------11-----------------------#2019-10-26">https://medium.com/analytics-vidhya/understanding-neural-networks-the-secret-lies-in-our-brains-5d8dc907ab34?source=collection_archive---------11-----------------------#2019-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e691" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阅读是我能保证你能做到的事情。</p><p id="bc1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从我们埋头苦干的长篇报告到每个周末阅读的简短购物清单，这是我们自然而然就会有的东西。</p><p id="c816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，机器学习算法具有令人难以置信的能力，它们可以检测欺诈，驾驶自动驾驶汽车，并以比我们大脑高得多的速度解释数据。然而，让程序理解一个简单的手写文本已经困扰了许多人近半个世纪。</p><p id="3d36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，寻找能够理解文字的东西是合乎逻辑的，比如我们的大脑！我们的大脑是一个<strong class="ih hj">高度复杂的信息处理系统</strong>，有各种各样的<strong class="ih hj">行为</strong>(有些像自然语言一样不可思议，有些像沉迷于第十块巧克力一样)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/438f9c3fae344ae70e77ef09d987afd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*vPESKCRIsvzVgQ2BN017Ew.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">学分:讲解xkcd<a class="ae jq" href="https://www.explainxkcd.com/wiki/index.php/2173:_Trained_a_Neural_Net" rel="noopener ugc nofollow" target="_blank">https://www . Explain xkcd . com/wiki/index . PHP/2173:_ Trained _ a _ Neural _ Net</a></figcaption></figure><p id="1b5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像识别和自然语言处理都是人工智能以前的弱点，随着神经网络的出现，这一点已经改变。神经网络从我们大脑的神经元和行为中获得灵感(除了巧克力)，它们是一种由许多<strong class="ih hj">人工神经元链在一起</strong>组成的程序，以产生<strong class="ih hj">复杂的行为</strong>。</p><p id="35a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单个<strong class="ih hj">神经元</strong>本身很缺乏，只有一套简单的指令。另一方面，连接系统的<strong class="ih hj">行为</strong>变得更加<strong class="ih hj">复杂</strong>。</p><blockquote class="jr js jt"><p id="50de" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">注意:系统的行为依赖于神经元的结构。</p></blockquote></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="f467" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">神经网络有几个关键特征:</strong></p><h2 id="f22d" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">信息处理📁</h2><p id="03d5" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在传统情况下，信息在一个<strong class="ih hj"> CPU </strong>(中央处理器)中处理，它一次只能完成<strong class="ih hj">一项任务</strong>。另一方面，神经网络由神经元的组合组成，所有的神经元都单独处理信息。</p><h2 id="a9f1" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">存储数据📚</h2><p id="1f2a" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在一台计算机内，<strong class="ih hj">数据存储</strong>由<strong class="ih hj">存储器</strong>处理，<strong class="ih hj">处理</strong>由<strong class="ih hj"> CPU </strong>负责。在神经网络<strong class="ih hj">中，神经元</strong>和<strong class="ih hj">都处理</strong>和<strong class="ih hj">存储数据</strong>。</p><p id="5ce9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">数据可以通过两种方式存储:</em></p><ol class=""><li id="9e4c" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated"><strong class="ih hj">短期</strong>——储存在神经元内</li><li id="4628" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated"><strong class="ih hj">长期</strong> —存储在权重内(连接每个神经元的通道)</li></ol></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="f9cc" class="ls kf hi bd kg lt lu lv kk lw lx ly ko lz ma mb kr mc md me ku mf mg mh kx mi bi translated">神经网络如何工作📝</h1><p id="01bf" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">所有的神经网络在输入层、隐藏层或输出层都有神经元。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/29d2357a21e2281873566566cffe009e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SwsCx2pwTcJHMmnxwJ41vQ.png"/></div></div></figure><p id="6a7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输入层</strong>是接收输入<strong class="ih hj">数据</strong>并将其传递给神经网络其余部分的层<strong class="ih hj">。</strong></p><p id="a7fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">隐藏层</strong>从输入节点接收数据，它们<strong class="ih hj">将</strong>乘以一个称为<strong class="ih hj">权重</strong>的值，并且<strong class="ih hj">将一个称为<strong class="ih hj">偏差</strong>的值<strong class="ih hj"> </strong>加到</strong>上。(整个网络依靠<strong class="ih hj">调整权重</strong>和<strong class="ih hj">偏置</strong>来产生尽可能精确的输出。)</p><p id="b1f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出层</strong>是<strong class="ih hj">评估</strong>信息和<strong class="ih hj">计算</strong>输出或结果<strong class="ih hj">标号</strong>的最后一层。</p><p id="cd38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最简单的形式，它是一种绘制线条来划分和分类数据的算法。总而言之，他们学习输入的数据和输出的标签之间的关系。</p><h2 id="45c2" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">找到正确的路线</h2><p id="50b0" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">让我们从一个简单的例子开始，我们画一条直线。</p><p id="6732" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以给我们的模型一组输入数据，包括学生的GPA和ACT成绩。利用这些数据，我们可以试着预测一个学生是否被哈佛录取。感知器所做的是，用x坐标<strong class="ih hj">作为他们的GPA，y坐标<strong class="ih hj">作为他们的ACT分数，在<strong class="ih hj">图</strong>上将每个学生绘制成<strong class="ih hj">点</strong>。我们可以训练这种感知去做的是找到一条线，在这条线上，高于的学生<em class="jd">被哈佛录取，低于</em>的学生<em class="jd">被拒绝。</em></strong></strong></p><h2 id="260b" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">绘制线条</h2><p id="6e95" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">首先，我们来了解一下单个神经元是如何运作的。神经元试图使用<strong class="ih hj"><em class="jd"/></strong>线性回归<strong class="ih hj">两个变量</strong>(在这种情况下是它们的GPA和ACT分数)之间的线性关系建模。这个线性模型方程是对九年级的一种回归…</p><blockquote class="mo"><p id="b56a" class="mp mq hi bd mr ms mt mu mv mw mx jc dx translated">y = mx + b</p></blockquote><figure class="mz na nb nc nd jj er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es my"><img src="../Images/e8d6ab97fb274c1e5c2ff65d11513393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SeBzONQd9O50aFMWMrHig.png"/></div></div></figure><p id="a3d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这条线的目标是尽可能地<strong class="ih hj">区分</strong>被录取的学生和被拒绝的学生。你也可以把这条线看作是你被接受和拒绝的可能性相等的平衡点。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="ec74" class="ls kf hi bd kg lt lu lv kk lw lx ly ko lz ma mb kr mc md me ku mf mg mh kx mi bi translated">理解感知机🎓</h1><p id="8de8" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">现在让我们放大一个<strong class="ih hj">感知器</strong>。一个<strong class="ih hj">感知器</strong>是一种单层的神经网络，它们是<strong class="ih hj">线性分类器</strong>。感知器接受多个输入，在我们的例子中，我们有两个GPA和ACT分数。这些<strong class="ih hj">输入(x) </strong>乘以一个<strong class="ih hj">权重(w) </strong>。如果更容易想象的话，你可以把权重想象成神经元之间连接的强度。在输入与它们相应的权重相乘后，它们被加在一起，一个<strong class="ih hj">偏差</strong>被<strong class="ih hj">相加</strong>(通常偏差也有它自己的权重被乘以)。</p><p id="b729" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">一般形式如下:</em> </strong></p><blockquote class="mo"><p id="aa30" class="mp mq hi bd mr ms mt mu mv mw mx jc dx translated">w₁x₁ + w₂x₂ + b = 0</p></blockquote><p id="1240" class="pw-post-body-paragraph if ig hi ih b ii ne ik il im nf io ip iq ng is it iu nh iw ix iy ni ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">下面是一般形式的简化:</em> </strong></p><blockquote class="mo"><p id="609f" class="mp mq hi bd mr ms mt mu mv mw mx jc dx translated">y = mx + b</p></blockquote><h2 id="ba4f" class="ke kf hi bd kg kh nj kj kk kl nk kn ko iq nl kq kr iu nm kt ku iy nn kw kx ky bi translated">激活功能</h2><p id="a9c3" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">然后我们需要通过一个<strong class="ih hj">激活函数</strong>来传递它，激活函数<strong class="ih hj">定义</strong>神经元的<strong class="ih hj">输出</strong>。在我们的例子中，我们将从<strong class="ih hj"> <em class="jd">步骤开始激活功能</em> </strong>。</p><p id="b31b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">预测(ŷ): </em> </strong></p><blockquote class="jr js jt"><p id="d5ed" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">如果wx + b &gt;= 0，则ŷ = 1</p><p id="1e6e" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">如果wx + b &lt; 0</p></blockquote><p id="3d92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">In actual words, this means that is the equation calculated to above or equal to 0 the algorithm will predict True, otherwise it will predict False.</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es my"><img src="../Images/3252671faaebc20fe5e0d5844b379b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hMtkt3PXpg31XI2LVXb9Q.png"/></div></div></figure><blockquote class="jr js jt"><p id="4722" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">Note: Y hat (ŷ) stands for the <strong class="ih hj">预测了y的</strong>值，ŷ = 0(在我们的例子中，因变量<strong class="ih hj">是学生是否被录取)</strong></p><p id="a786" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">旁注:如果你深入研究神经网络，你会学到sigmoid函数，它将一个值转换成从0到1的数字。</p></blockquote><h2 id="ccbc" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">错误</h2><p id="3f64" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">我们今天编程的错误是正确标签和我们的算法预测之间的<strong class="ih hj">差异</strong>。</p><blockquote class="jr js jt"><p id="953a" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated"><strong class="ih hj">错误值=标签—输出</strong></p></blockquote><p id="fd16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍后，您还可以学习使用<em class="jd">梯度下降</em>来计算误差，梯度下降沿最陡下降的方向移动。换句话说，算法离正确的标签有多远，决定了对算法的改变程度。</p><h2 id="27ff" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">学习率</h2><p id="c6ae" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">所以现在你有了一个误差值，我们可以<strong class="ih hj">重新调整</strong>线方程来正确分类更多的点。所以我们可以把这个方程中误分类点的值输入为x来修正权重，进而调整线条。</p><blockquote class="jr js jt"><p id="896d" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated"><strong class="ih hj">新权重=前一权重+ (x *误差值*学习率)</strong></p></blockquote><p id="a38c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你可能想知道<strong class="ih hj">的学习率</strong>是多少。学习率是为了防止生产线的巨大变化。如果您有一个<strong class="ih hj">异常值</strong>点，并更改整条线以正确分类该点，您最终会得到比以前多得多的错误分类点。</p><h2 id="661f" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">把所有的放在一起</h2><p id="b300" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在这里，我们可以看到输入乘以权重并加上偏差。然后应用阶跃函数生成预测输出，这个通过网络传播信息的过程被称为<em class="jd">正向传播</em>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es my"><img src="../Images/a7fb27a3de2df85c7f0b169b0bf919fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9sBI94AN3ynarMkIdkbASw.png"/></div></div></figure><p id="cecc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们查看乘以误差和学习率的点，以创建更好更准确的权重。(如果你使用梯度下降来计算误差，这个通过网络发回数据的过程被称为<em class="jd">反向传播</em>。)</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="6479" class="ls kf hi bd kg lt lu lv kk lw lx ly ko lz ma mb kr mc md me ku mf mg mh kx mi bi translated">用Python编码💻</h1><p id="5d01" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">现在让我们从编码一个感知器开始。我们将编写AND逻辑运算符，这不是最实用的，但它非常简单，有助于解释神经网络的基础知识。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es no"><img src="../Images/0b30db6a157cbfb44d8000350ad103b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4Tq5kDfH_KrMhra907viQ.png"/></div></div></figure><p id="cbbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">“与”逻辑运算符仅在两个输入都为真时返回真。</em>T11】</strong></p><p id="4102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们取两个可能的输入，真或假，并把它们转换成二进制的</p><p id="def3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也是我们稍后用来训练算法的数据。</p><p id="4b87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将编写的算法简单地根据两个<strong class="ih hj">输入</strong>预测<strong class="ih hj">最终输出</strong>。</p><p id="a022" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将不同的可能输入标绘成图形中的点，我们的目标是用<strong class="ih hj">将</strong>不同颜色的点分开的<strong class="ih hj">线</strong>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/a069ba3ba353537764133b4be9d4bab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NAiYbnBR0uam5vRYRStNAQ.png"/></div></div></figure><h2 id="a57c" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">设置变量</h2><p id="365a" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在我们的python程序中，我们将从定义权重、偏差和学习率的变量开始。</p><pre class="jf jg jh ji fd np nq nr ns aw nt bi"><span id="6e96" class="ke kf hi nq b fi nu nv l nw nx"># The AND logic gate coded as a neural network<br/># This perceptron is not the most efficient neural network but it's simple to code! It's a nice classifer for explaining concepts!</span><span id="fb2f" class="ke kf hi nq b fi ny nv l nw nx">import random<br/>inputOne_Weights = random.random()#Let's randomly assign values<br/>inputTwo_Weights = random.random()#We will adjust the weights later<br/>bias_Weights = random.random()</span><span id="e8a1" class="ke kf hi nq b fi ny nv l nw nx">bias = 1<br/>learning_Rate = 1 #usually it's a lot smaller but we have less data and it's a simple preceptron</span></pre><p id="ae54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将定义一个函数，返回直接从输入、权重和偏差导出的输出</p><pre class="jf jg jh ji fd np nq nr ns aw nt bi"><span id="ae5b" class="ke kf hi nq b fi nu nv l nw nx">def calcOutput (x,y):<br/> output = x*inputOne_Weights + y*inputTwo_Weights+bias*bias_Weights<br/> return output</span></pre><p id="3603" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们定义了主感知器。这是我们计算输出、应用激活函数并使用误差相应地编辑权重的地方。</p><pre class="jf jg jh ji fd np nq nr ns aw nt bi"><span id="105e" class="ke kf hi nq b fi nu nv l nw nx"># x and y are the two different inputs and the label is the correct result for each case<br/>def perceptron (x, y, label):<br/>  output = calcOutput(x,y)<br/>  if output &gt; 0:    output = 1  #Here comes the step function<br/>  else:             output = 0<br/>  errorValue = label - output  #find the error value</span><span id="1894" class="ke kf hi nq b fi ny nv l nw nx"># Adjust the weights according to the error value times the learning rate<br/># Make sure you edit the global variable (outside function)<br/>  global inputOne_Weights  <br/># Let's edit the weights according to the input, error, and learning rates<br/>  inputOne_Weights += x * errorValue * learning_Rate</span><span id="8698" class="ke kf hi nq b fi ny nv l nw nx">global inputTwo_Weights<br/>  inputTwo_Weights += y * errorValue * learning_Rate</span><span id="a27f" class="ke kf hi nq b fi ny nv l nw nx">global bias_Weights<br/>  bias_Weights += bias * errorValue * learning_Rate</span></pre><p id="95cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">定义感知器后，我们需要训练它更好地预测正确的结果。这只是用不同的数据点反复运行感知器。</p><pre class="jf jg jh ji fd np nq nr ns aw nt bi"><span id="ea91" class="ke kf hi nq b fi nu nv l nw nx">def training (epoch): #epoch ~ is number of passes of training data<br/>  for i in range(epoch):<br/>    # Since an AND function only takes two inputs and two types of      values (0 or 1) there are only four pieces of data<br/>    # Here's our test data! We're running it through the perceptron<br/>    perceptron(0,0,0)      <br/>    perceptron(1,0,0)      <br/>    perceptron(0,1,0)<br/>    perceptron(1,1,1)</span></pre><p id="9b00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们把所有的功能放在一起，我们运行整个程序，看看我们的感知是否有效。</p><pre class="jf jg jh ji fd np nq nr ns aw nt bi"><span id="3e58" class="ke kf hi nq b fi nu nv l nw nx">def test (x,y):<br/>  training(56)  # here we choose how many epochs<br/>  output = calcOutput(x,y)<br/>  if output &gt; 0:    output = 1           # Here's our step function<br/>  else:             output = 0<br/>  return output</span><span id="b136" class="ke kf hi nq b fi ny nv l nw nx">x = int(input())   # These are the two inputs<br/>y = int(input())<br/>print(test(x,y))     # Now let's run through the whole program and check if it works</span></pre><p id="7eac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行程序，看看是否有效！浏览所有测试用例，检查程序是否计算出正确的输出。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="0b09" class="ls kf hi bd kg lt lu lv kk lw lx ly ko lz ma mb kr mc md me ku mf mg mh kx mi bi translated">关键要点📌</h1><ul class=""><li id="5267" class="le lf hi ih b ii kz im la iq nz iu oa iy ob jc oc lk ll lm bi translated">神经网络受到我们自己大脑的神经元和结构的启发，它们由神经元组成，每个神经元单独处理信息并通过网络传递</li><li id="231d" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc oc lk ll lm bi translated">与传统方法相比，神经网络在<strong class="ih hj">信息处理</strong>和它们如何<strong class="ih hj">存储数据</strong>方面有一些关键差异，神经元既处理又存储数据</li><li id="e709" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc oc lk ll lm bi translated">神经网络由相互连接的神经元组成，形成三个不同的层:<strong class="ih hj">输入</strong>、<strong class="ih hj">隐藏</strong>和<strong class="ih hj">输出</strong></li><li id="7a21" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc oc lk ll lm bi translated">该算法的核心原理是用一条<strong class="ih hj">线</strong>将<strong class="ih hj">分离</strong>和<strong class="ih hj">分类</strong>(利用<strong class="ih hj"> <em class="jd">线性回归</em> </strong>建立<strong class="ih hj">线性关系</strong>)。</li><li id="7677" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc oc lk ll lm bi translated">感知器将<strong class="ih hj">输入</strong>乘以<strong class="ih hj">权重</strong>，加上<strong class="ih hj">偏差</strong>，并将总和通过<strong class="ih hj">激活函数</strong>。</li><li id="6556" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc oc lk ll lm bi translated">我们使用的激活函数是一个<strong class="ih hj">二进制阶跃函数</strong>，这意味着如果输入数据高于一个<strong class="ih hj">阈值</strong>(在我们的例子中为0)，神经元将被<strong class="ih hj">激活</strong>，并且<strong class="ih hj">将数据向前</strong>发送到下一层。</li><li id="898b" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc oc lk ll lm bi translated">将<strong class="ih hj">输入数据通过</strong>网络从一个神经元传递到另一个神经元的行为被称为<strong class="ih hj">前向传播</strong>。</li><li id="f81f" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc oc lk ll lm bi translated">计算误差并调整权重使其最小化使用了一种叫做<strong class="ih hj">反向传播</strong>的东西。其中<strong class="ih hj">输出误差</strong>向后传播到<strong class="ih hj">调整每层的权重</strong>。</li></ul></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="c1c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">唷，这篇文章真长！恭喜你，现在你对神经网络如何运作有了更好的理解，你甚至已经编写了一个代码！</p><p id="f009" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这激起了你对神经网络的兴趣，并且你学到了一些有趣的东西！</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="4db6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看到下面的图标了吗，有拍手标志的那个？试试点击它，继续试试吧！五彩纸屑，酷吧？如果你想在未来阅读更多的文章或喜欢纸屑，给我的帐户一个关注！</p><p id="1b59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与此同时，请随时在ariel.yc.liu@gmail.com联系我，或者在LinkedIn上联系我。你也可以在这里阅读我的每月简讯<a class="ae jq" href="https://mailchi.mp/929cce6b6e5c/september-newsletter" rel="noopener ugc nofollow" target="_blank">！</a></p><p id="53da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下次见！👋</p></div></div>    
</body>
</html>