<html>
<head>
<title>Facial landmarks detection with dlib and haar cascade</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于dlib和haar级联的人脸标志点检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/facial-landmarks-detection-with-dlib-and-haar-cascade-e3c8195131d7?source=collection_archive---------6-----------------------#2020-11-30">https://medium.com/analytics-vidhya/facial-landmarks-detection-with-dlib-and-haar-cascade-e3c8195131d7?source=collection_archive---------6-----------------------#2020-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/df015ef2952ce9d77cc49870c16b6a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y36-xCaHYMVDAOHy"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">克里斯里德在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="26e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近我在做一个项目，涉及使用Python进行面部标志检测。Python提供了一个名为dlib的库，非常适合这个工作。为了找到任何面部标志，首先必须从图像中提取面部，然后使用提取的面部ROI(感兴趣区域)来获得标志。现在，从图像中检测人脸是计算机视觉领域的一个老把戏。最著名的过程是使用haar级联分类器，它返回一个多维numpy数组。该阵列中元素的数量等于图像中存在的面的数量。这个数组的每个元素包含4个整数。前两个表示左上角，后面是ROI的宽度和高度。</p><p id="c5d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Dlib还提供了一个名为get _ frontal _ face _ detector()的人脸检测函数。这个函数返回矩形对象的数组。rectangle对象表示图像的矩形区域。每个rectangle对象包含四个值，这意味着它还返回包含人脸的ROI的坐标，但格式不同。因此，在haar级联分类器和dlib检测器之间有三个主要区别。首先，当haar cascade检测器返回一个多维numpy数组时，dlib检测器返回一个矩形对象数组。其次，haar级联检测器返回左上角的宽度和高度，而dlib返回左上角(rectangle对象的前两个值)和右下角(rectangle对象的后两个值)。第三，dlib函数只取灰度图像作为参数，而haar级联分类器取两个以上的参数，比例因子和最小邻居。scaleFactor参数指定在每个影像比例下影像大小减少多少，minNeighbors参数指定每个候选矩形需要多少个邻居才能保留它。基本上，通过这两个参数，您可以控制在图像中检测人脸的严格程度或宽松程度。因此，与dlib函数相比，haar cascade具有更大的灵活性。例如，当邻居的值为5时，约翰尼·德普后面的人的脸也会被检测到，但当邻居的值为10时，情况就不是这样了。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/f5cb68694e86d7272781ac7dae74284a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5nO5UIXHoVLaH7ovkKbdRA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">最小邻居= 5(左)和最小邻居= 10(右)的haar级联人脸检测</figcaption></figure><p id="9578" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我很好奇，想看看haar cascade和dlib库是否提供了相同的结果，例如相同的ROI。但是我发现了一点不同。haar级联比dlib函数提取更多的区域。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/dc76c67dd9a454a5455b77744191b854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*4u_tBdhV7mw1P_tyP8eMnw.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">哈尔瀑布与Dlib</figcaption></figure><p id="ac9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在回到面部标志检测。dlib库提供了一个名为shape_predictor()的函数，它接受两个参数，第一个是图像的灰度版本，第二个是保存面部区域坐标的dlib rectangle对象。然后我们可以得到特征点，利用这些特征点我们可以得到面部标志。在我的例子中，我想使用haar级联分类器的结果来检测面部标志。但问题是，dlib库的shape_predictor函数采用的是dlib rectangle对象而不是numpy数组。因此，要使用shape_predictor函数的haar级联结果，我们必须将numpy数组转换为dlib矩形对象。这样我们就可以拥有haar cascade类的灵活性。</p><p id="5ba4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是代码</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="aa2d" class="ke kf hi ka b fi kg kh l ki kj"># importing libraries<br/>import cv2<br/>import numpy as np<br/>import dlib</span><span id="d463" class="ke kf hi ka b fi kk kh l ki kj"># function to convert dlib.full_object_detection to numpy array<br/>def shape_to_np(shape, dtype="int"):<br/> coords = np.zeros((68, 2), dtype=dtype)<br/> for i in range(0, 68):<br/>  coords[i] = (shape.part(i).x, shape.part(i).y)<br/> return coords</span><span id="9780" class="ke kf hi ka b fi kk kh l ki kj"># reading an image and converting it to grayscale<br/>image = cv2.imread('johny.jpg')<br/>gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</span><span id="f47b" class="ke kf hi ka b fi kk kh l ki kj"># loading the classifiers with respected files<br/>face_cascade = cv2.CascadeClassifier("haarcascade_frontalface_default.xml")<br/>predictor = dlib.shape_predictor("shape_predictor_68_face_landmarks.dat")<br/>faces = face_cascade.detectMultiScale(gray,scaleFactor=1.10,minNeighbors=5)</span><span id="98d7" class="ke kf hi ka b fi kk kh l ki kj"># looping through each detected faces and drawing rectangle around the face and circles around the feature points<br/>if len(faces)&gt;0:<br/>    for x,y,w,h in faces:<br/>        cv2.rectangle(image, (x,y), (x+w, y+h), (0, 255, 0),3)<br/>        # creating the rectangle object from the outputs of haar cascade calssifier<br/>        drect = dlib.rectangle(int(x),int(y),int(x+w),int(y+h))<br/>        landmarks = predictor(gray, drect)<br/>        points = shape_to_np(landmarks)<br/>        for i in points:<br/>            x = i[0]<br/>            y = i[1]<br/>            cv2.circle(image, (x, y), 2, (0, 255, 0), -1)</span><span id="b5d8" class="ke kf hi ka b fi kk kh l ki kj">cv2.imshow('image',image)</span></pre><p id="ba83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也可以用dlib查看我的检测面部地标的Github repo，找到需要的文件。</p><div class="kl km ez fb kn ko"><a href="https://github.com/pythonboy178/python-projects/tree/master/Facial_landmark_detection" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab dw"><div class="kq ab kr cl cj ks"><h2 class="bd hj fi z dy kt ea eb ku ed ef hh bi translated">python boy 178/python-项目</h2><div class="kv l"><h3 class="bd b fi z dy kt ea eb ku ed ef dx translated">dlib_with_haar.py文件包含实现dlib shape_predictor()函数的代码</h3></div><div class="kw l"><p class="bd b fp z dy kt ea eb ku ed ef dx translated">github.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc io ko"/></div></div></a></div><p id="e85a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想了解dlib库和haar级联分类器，这里有一些有用的链接</p><ol class=""><li id="cde3" class="ld le hi ix b iy iz jc jd jg lf jk lg jo lh js li lj lk ll bi translated"><a class="ae iu" href="https://www.bogotobogo.com/python/OpenCV_Python/python_opencv3_Image_Object_Detection_Face_Detection_Haar_Cascade_Classifiers.php" rel="noopener ugc nofollow" target="_blank">对象检测:使用哈尔级联分类器的面部检测</a></li><li id="34bc" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated"><a class="ae iu" href="http://dlib.net/python/index.html#dlib.shape_predictor" rel="noopener ugc nofollow" target="_blank"> Dlib文件</a></li><li id="1cb9" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated"><a class="ae iu" href="https://www.pyimagesearch.com/2017/04/03/facial-landmarks-dlib-opencv-python/" rel="noopener ugc nofollow" target="_blank">用dlib、OpenCV和Python实现的面部地标</a></li></ol></div></div>    
</body>
</html>