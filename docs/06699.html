<html>
<head>
<title>Matrix Calculus for DeepLearning (Part2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习的矩阵演算(下)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/matrix-calculus-for-deeplearning-part2-747451ad29e?source=collection_archive---------25-----------------------#2020-05-30">https://medium.com/analytics-vidhya/matrix-calculus-for-deeplearning-part2-747451ad29e?source=collection_archive---------25-----------------------#2020-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0c67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2020年5月29日</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c8055ef0e619be14c6b324e6b9437904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XvvGnvw_VlQB_Lrf.jpg"/></div></div></figure><p id="48d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不能仅仅使用基本的矩阵运算规则来计算非常复杂的函数的偏导数，我们已经看过<a class="ae jp" href="https://kirankamath.netlify.app/blog/matrix-calculus-for-deeplearning-part1/" rel="noopener ugc nofollow" target="_blank">博客第一部分</a>。例如，我们不能直接对像sum( <strong class="ih hj"> w </strong> + <strong class="ih hj"> x </strong>)这样的嵌套表达式求导，而不将其还原为标量等价。我们需要能够使用向量链规则来组合我们的基本向量规则。</p><p id="ff77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在论文中，他们定义并命名了三种不同的链式法则。</p><ol class=""><li id="0926" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">单变量链规则</li><li id="bea3" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">单变量全导数链规则</li><li id="064d" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">向量链规则</li></ol><p id="53dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们需要由嵌套子表达式组成的表达式的导数时，链规则就发挥作用了。链式法则通过将复杂的表达式分解成导数易于计算的子表达式来帮助解决问题。</p><h1 id="262c" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">单变量链规则</h1><p id="d9f7" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">链规则是根据嵌套函数定义的，例如<em class="lh"> y=f(g(x)) </em>用于单变量链规则。</p><p id="f8a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">公式为</p><p id="f3f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">dy/dx = (dy/du) (du/dx)</p><p id="e756" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用单变量链规则求解有4个步骤</p><ol class=""><li id="103f" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">引入中间变量</li><li id="d6a8" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">计算中间变量相对于其参数的导数。</li><li id="45c9" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">通过将所有导数相乘来合并它们</li><li id="2eb5" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">将中间变量代入导数方程。</li></ol><p id="1f46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看嵌套方程y = f (x) = <em class="lh"> ln </em> (sin(x))的例子</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es li"><img src="../Images/0abb4dcab8b5918549eba9fa433c78a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/0*fwTfTOlu4Qp5RcZE.png"/></div></figure><p id="daea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是孤立地计算中间变量的导数！</p><p id="0535" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，只有当单个变量只能以一种方式影响产出时，单变量链规则才适用。正如我们在示例中看到的，只有当x可以通过单个数据流路径影响y时，我们才能使用此链规则处理单个变量<em class="lh"> x </em>的嵌套表达式。</p><h1 id="7c0c" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">单变量全导数链规则</h1><p id="50e3" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">如果我们对<strong class="ih hj"> y = f (x) = x + x </strong>应用单变量链规则，我们会得到错误的答案，因为导数算子不适用于多元函数。方程中x的变化，既影响y作为加法的操作数，也影响y作为平方的操作数。所以我们显然不能应用单变量链规则。所以…</p><p id="3d64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们转向全微分。</p><p id="cf1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是计算(dy/dx)，我们需要把x的变化对y的变化所有可能的贡献加起来。</p><p id="cb3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">全导数链法则公式</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lj"><img src="../Images/882f9637809ebb1640c52f18f50d6798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/0*80kLCjqmNvBTdQdt.png"/></div></figure><p id="58c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总导数假设所有变量潜在地相互依赖，而偏导数假设所有变量，但<em class="lh"> x </em>是常数。</p><p id="fde7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你对x求导时，其他变量也可能是x的函数，所以也要加上它们的贡献。等式的左边看起来像典型的偏导数，但右边实际上是全导数。</p><p id="19d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个例子，</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/9d1eeaed81ed6969225b4d05b02b92f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/0*shZeABxUNias1l5M.png"/></div></figure><p id="ed3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总导数公式总是<em class="lh">对</em>求和，也就是对导数中的项求和。例如，给定y = x × x，而不是y = x + x，全导数链规则公式仍然添加偏导数项，有关更多详细信息，请参见论文中的演示。</p><p id="99a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">全微分公式可以进一步简化。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ll"><img src="../Images/b6636e9e343b6323e1dfa9d1af25d188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/0*sDqWUk96xgMSeazo.png"/></div></figure><p id="be2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当所有中间变量都是单个变量的函数时，这种考虑总导数的链式法则退化为单变量链式法则。</p><h1 id="3d79" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">向量链规则</h1><p id="0f1b" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">样本向量函数相对于标量的导数，<strong class="ih hj"> y </strong> = <strong class="ih hj"> f </strong> (x)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/f0511e009c0386a454e4c1e726c398bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1O9MEs3qhfvg_44T.jpg"/></div></div></figure><p id="e3b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引入两个中间变量，g 1和g 2，每个f i一个，这样y看起来更像<strong class="ih hj">y</strong>=<strong class="ih hj">f</strong>(<strong class="ih hj">g</strong>(x))</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/4c6edaa2c813ec7540e043ccaddc071e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W-RGdM4ajlxxxoDo.jpg"/></div></div></figure><p id="70ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们把这些项分开，把它们分离成一个向量，我们得到一个向量矩阵。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/a991bbce22c768a52c704a7eafbe67ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Af_9ZBseZjTGICSo.jpg"/></div></div></figure><p id="6551" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就完成了链式法则。在第三部分的下一篇博客中，我们将会看到我们如何应用神经激活和损失函数的梯度并总结。</p><p id="cae1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢你。</p><p id="6d01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有用的观点:</p><p id="366f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在markdown中写博客很难转换成上标和下标，所以我列出来了，你可以在markdown中使用(复制粘贴)</p><p id="ea28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上标⁰⁴⁵⁶⁷⁸⁹ᵃᵇᶜᵈᵉᶠᵍʰᶦʲᵏˡᵐⁿᵒᵖʳˢᵗᵘᵛʷˣʸᶻ</p><p id="19b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下标₀₁₂₃₄₅₆₇₈₉ₐᵦ𝒸𝒹ₑ𝒻𝓰ₕᵢⱼₖₗₘₙₒₚᵩᵣₛₜᵤᵥ𝓌ₓᵧ𝓏</p><p id="e5dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"># <strong class="ih hj">博客10 </strong></p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="538c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lh">最初发布于</em><a class="ae jp" href="https://kirankamath.netlify.app/blog/matrix-calculus-for-deeplearning-part2/" rel="noopener ugc nofollow" target="_blank"><em class="lh">https://kirankamath . netlify . app</em></a><em class="lh">。</em></p></div></div>    
</body>
</html>