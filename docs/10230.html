<html>
<head>
<title>Get started with Time Series Forecasting in Python 👍</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python时间序列预测入门👍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/get-started-with-time-series-forecasting-in-python-c8ca78ee84a5?source=collection_archive---------2-----------------------#2020-10-10">https://medium.com/analytics-vidhya/get-started-with-time-series-forecasting-in-python-c8ca78ee84a5?source=collection_archive---------2-----------------------#2020-10-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/8db77f11d252e8a2ee1a3a25f7374944.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*7THmgQHJedVjgyHGZL4Y3g.png"/></div></figure><p id="41ab" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">概述:</strong></p><ul class=""><li id="9c7b" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">什么是时间序列？</li><li id="df21" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">时间序列的不同组成部分。</li><li id="0cd8" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">不同的时间序列预测模型</li><li id="ad51" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">Python中的苹果股价预测</li></ul><p id="4588" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">什么是时间序列？</strong></p><p id="6899" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">时间序列仅仅是在连续的时间点对一个数量变量的有序观察。时间可以是年、月、日、小时等。这取决于数据收集过程。时间序列在许多不同领域都有应用，例如:</p><ul class=""><li id="3c20" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">国民收入和外汇储备</li><li id="8c94" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">行业内的销售额和利润</li><li id="640d" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">股票交易市场</li><li id="bb4e" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">天气统计分析</li><li id="e5eb" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">农业生产</li><li id="71dc" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">人口统计学等。</li></ul><p id="35cb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">数学上，时间序列被定义为</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/0882d26aa128e9f67aee45e83dc8eb65.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/1*HVoPjGfZUro9JQh-kztWSA.gif"/></div></figure><p id="4904" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">其中<code class="du kd ke kf kg b">n</code>表示观察次数。由于各种因素，值<code class="du kd ke kf kg b">Yt</code>随时间<code class="du kd ke kf kg b">t</code>波动，因此时间序列不是时间的常数函数。让我们研究一下引起这些波动的一些因素。这些也被称为时间序列的组成部分。</p><ol class=""><li id="87e3" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj kh jq jr js bi translated"><strong class="io hj">趋势:</strong>数据在一段较长的时间内一般会有增加或减少的趋势称为具有某种趋势。这在企业的经济统计中最为常见。在整个给定的时间段内，增加或减少的方向可能不同。在不同的时间会有不同的趋势。然而，总体趋势可能是向上或向下的。</li><li id="9901" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj kh jq jr js bi translated"><strong class="io hj">季节性:</strong>时间序列中的季节性变化是由于一些因素在不到一年的时间内以规则和周期性的方式发生作用，并且年复一年具有相同的模式。这些因素可能是自然发生的，也可能是人为的干预。季节性研究对于企业在某个季节时间窗内创造更多收入的决策是非常有用的。</li><li id="2264" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj kh jq jr js bi translated"><strong class="io hj">周期型:</strong>波动周期超过一年的时间序列的波动称为周期型。一个完整的周期称为“周期”。你可能听说过“商业周期”，在这种周期中，需求和供给会受到一些经济因素的影响。与季节性不同，循环模式不是周期性的。</li></ol></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="29fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">平稳性</strong></p><p id="8597" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">直观上，平稳性意味着时间序列的统计特性不会随时间而改变。例如，具有上述成分的时间序列趋势、季节性等。不是静止的。平稳过程很容易分析。时间序列的平稳性主要有两种类型——严格平稳性或弱平稳性(在随机过程理论中也称为二阶平稳性)。</p><ul class=""><li id="d4d3" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">严格平稳性:</strong>如果<code class="du kd ke kf kg b">Yt</code>的边际分布在不同的时间点t相同，即</li></ul><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/6528dd4cc446cbf37fd1541fb508e94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*SpKt2JfxasJVdgBwLlrR4g.png"/></div></figure><p id="7778" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，<code class="du kd ke kf kg b">k</code>表示滞后。</p><ul class=""><li id="f001" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">弱平稳性:</strong>一个序列被称为弱平稳的，如果</li></ul><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/2f1365cbfb604b859b5a4b31ff3269c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*58ZPxqjABMt54mHZ8_OBuw.png"/></div></figure><p id="0859" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，协方差不是<code class="du kd ke kf kg b">t</code>的函数。现在，首先想到的问题是，如果级数不是平稳的，我们该怎么办？简单的答案是——让它静止不动。我们怎么做呢？有不同的方法可以做到这一点，但这里有一个简单且最受欢迎的方法——“差异”。</p><p id="304a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">差异</strong></p><p id="46ae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">差分基本上是从时间序列的当前值中减去先前的值，即</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/34b7e74907e8ec35ad4ba7d161e21c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:224/format:webp/1*P7i1dZRcFnyt-GB0pP1VbQ.png"/></div></figure><p id="a1d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后使用这个新的平稳差分序列。有时一阶差分不能使它稳定，那么我们可以去更高阶，像差分一阶差分序列等等。差异稳定了序列的平均值，这有助于消除趋势和季节性。诸如对数变换的其他方法稳定了方差。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="33f2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">自相关函数</strong></p><p id="90e1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">两个随机变量的相关函数度量两个变量的关联。类似地，自相关测量相同时间序列的两个值之间的相关性。这些值由滞后k分隔，滞后k时的ACF可由下式给出:</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/4c11c3c761ba6f327ecc74fe9ebc0ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/1*upx2TxGddsE-IQVjYXpuPA.gif"/></div></figure><p id="3c5f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">偏自相关函数(PACF) </strong></p><p id="b9a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">部分自相关函数是在去除对其他滞后项的任何线性依赖之后<code class="du kd ke kf kg b">Yt</code>和<code class="du kd ke kf kg b">Y{t-k}</code>之间的自相关，由下式给出</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/ca8bd550da05425693e1f1fdfc8f7be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*0Kz0o2-kao0iSuFoNh3Wmw.png"/></div></figure><p id="e3eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为什么ACF和PACF很重要？</p><p id="04c1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦你使时间序列平稳，我们必须计算ACF和PACF相关图，这样我们就可以找到预测模型所需的参数。迷茫？？？不要…继续写这篇文章。一旦我们看完这个例子，你就会明白了。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="eb75" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">白噪声</strong></p><p id="fb8d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">白噪声不过是一个均值为零、方差不变、协方差为零的随机序列。</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/aed6feba6fda527059e32ebc8210b491.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/1*ehWXjR9j9v0fRAAYAmU6Ng.png"/></div></figure><p id="ddfd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果时间序列是白噪声，我们就无法预测。就停在那里！</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="0378" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">预测模型</strong></h1><p id="b99c" class="pw-post-body-paragraph im in hi io b ip lt ir is it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj hb bi translated">现在，让我们讨论四个重要的预测模型。</p><ol class=""><li id="f29f" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj kh jq jr js bi translated"><strong class="io hj">自回归模型(AR(p)) </strong></li></ol><p id="46eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在AR(p)模型中，我们使用变量过去值的线性组合来预测感兴趣的变量。术语A<strong class="io hj"><em class="ly">utoregression</em></strong>表示它是变量对自身的回归。<code class="du kd ke kf kg b">p</code>表示模型中包含的过去值的数量。AR(p)模型由下式给出</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/d3fc19a9293ac9115336254ac73ff2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*BfCLYtN61CFw9KBAS1pjvQ.png"/></div></figure><p id="d020" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.<strong class="io hj">均线模型(MA(q)) </strong></p><p id="bb82" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">移动平均模型不是在回归中使用预测变量的过去值，而是在回归中使用过去的预测误差<code class="du kd ke kf kg b">e</code>。<code class="du kd ke kf kg b">q</code>表示模型中使用的过去误差项的数量。MA(q)模型给出为</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/c63b643e298b7d7bbc9ca7b9c4502447.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*pYkuEepAY9fS7c4FPv8RyA.png"/></div></figure><p id="e9d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.<strong class="io hj">自回归移动平均模型(ARMA(p，q)) </strong></p><p id="bf9a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在很直观的就能弄清楚这个模型有什么。你是对的！它包含两项，即序列的过去值和误差项。<code class="du kd ke kf kg b">p</code>和<code class="du kd ke kf kg b">q</code>分别是AR和MA模型的参数。ARMA(p，q)模型给出如下:</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/70c411706e31184fb724260afaa0bd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*BTSfLEPeW2Gh1KodXu4WIw.png"/></div></figure><p id="5a4e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">4.<strong class="io hj">自回归综合移动平均模型(ARIMA(p，d，q)) </strong></p><p id="5a7b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们将差分与自回归移动平均模型(ARMA)相结合时，我们得到一个ARIMA模型。这有三个参数。<code class="du kd ke kf kg b">p</code>是AR模型的阶数，<code class="du kd ke kf kg b">q</code>是MA模型的阶数，<code class="du kd ke kf kg b">d</code>是差分的阶数。ARIMA(p，d，q)模型由下式给出</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/fb7b263454ac931a3574b8181d8d0065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*N0RiVFhiFXCx-JAHr83DWg.png"/></div></figure><p id="3f33" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">其中虚线Y项是差分级数项。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="20b2" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">博克斯-詹金斯法(B-J法)</h1><p id="a526" class="pw-post-body-paragraph im in hi io b ip lt ir is it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj hb bi translated">Box-Jenkins方法是由George Box和Gwilym Jenkins在他们1970年的开创性教科书<a class="ae mc" href="https://amzn.to/31OLnFH" rel="noopener ugc nofollow" target="_blank">时间序列分析:预测和控制</a>中提出的。</p><p id="d30d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">他们制定了以下三个步骤来预测单变量时间序列:</p><ol class=""><li id="da84" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj kh jq jr js bi translated"><strong class="io hj">识别:</strong>在这个步骤中，我们通过查看ACF和PACF图或者通过一些统计测试来识别ARIMA模型<code class="du kd ke kf kg b">p</code>、<code class="du kd ke kf kg b">d</code>和<code class="du kd ke kf kg b">q</code>的参数。通常，根据ACF和PACF图中的模式选择以下模型:</li></ol><figure class="jz ka kb kc fd ij er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/28ab397d0c044a47f3bb4ee08d9daf46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0lCkfRbPPVwKfYoLdqTwHA.png"/></div></div></figure><p id="e69f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2。估计:</strong>在这一步中，我们通过使用像最大似然估计(MLE) / Yule-Walker过程/矩方法(MOM)这样的方法来估计时间序列回归模型中的以下参数。</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/fdebc12483e33aa42da1bc0b4659b9d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/1*jtjxMtlP5JZR3d2Ns-8bYw.gif"/></div></figure><p id="c994" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 3。诊断检查:</strong>在这一步中，我们使用不同的指标，如AIC、BIC、MAPE等，来检查模型的预测准确性。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="mj"><p id="3a90" class="mk ml hi bd mm mn mo mp mq mr ms jj dx translated">受够了概念！让我们来看看Python中的苹果股价预测。</p></blockquote><p id="e8b1" class="pw-post-body-paragraph im in hi io b ip mt ir is it mu iv iw ix mv iz ja jb mw jd je jf mx jh ji jj hb bi translated">首先让我们加载所有需要的包。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="1675" class="nc kw hi kg b fi nd ne l nf ng">from pandas_datareader import data<br/>from datetime import datetime<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/>from statsmodels.graphics.tsaplots import acf, plot_acf, plot_pacf<br/>from statsmodels.tsa.stattools import adfuller<br/>from pmdarima.arima.utils import ndiffs<br/>from statsmodels.tsa.arima_model import ARIMA<br/>import pmdarima as pm</span></pre><p id="a61d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们从雅虎下载2019年1月1日至2020年1月1日的苹果股票数据，并绘制截至目前的收盘价。在本教程中，我们将使用收盘价作为预测的单变量时间序列。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="4b76" class="nc kw hi kg b fi nd ne l nf ng">aapl = data.DataReader('AAPL', 'yahoo', datetime(2019, 1, 1), datetime(2020, 1, 1))<br/>series1 = aapl.Close.dropna() #original series<br/>ax = plt.axes()<br/>ax.set_facecolor('beige')<br/>plt.plot(series1)</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es if"><img src="../Images/8db77f11d252e8a2ee1a3a25f7374944.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*7THmgQHJedVjgyHGZL4Y3g.png"/></div></figure><p id="2cd6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以看到2019年12个月的增长趋势，这告诉我们股票表现很好。👍</p><p id="a015" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，因为有一个趋势，它不是一个平稳的序列，我们不能使用这个序列进行预测，我们需要差分它，并找到差分的顺序，使它平稳。让我们首先进行一阶差分，看看它是否使序列平稳。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="e591" class="nc kw hi kg b fi nd ne l nf ng">ax = plt.axes()<br/>series2 = aapl.Close.diff().dropna() #first order differenced series<br/>ax.set_facecolor('silver')<br/>plt.plot(series2)</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es nh"><img src="../Images/316f030a84bef1f8dc540562d4894f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*1Jl67HWJaH11YJJlBfEEpw.png"/></div></figure><p id="38e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它确实使它成为了一个固定系列！现在，如果你仍然不相信看到的图，让我们使用一些统计测试，给我们所需的差分顺序，使一系列平稳。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="377b" class="nc kw hi kg b fi nd ne l nf ng"># Adf Test<br/>ndiffs(series1, test='adf')  # output is 1</span><span id="17e7" class="nc kw hi kg b fi ni ne l nf ng"># KPSS test<br/>ndiffs(series1, test='kpss')  # output is 1</span><span id="5436" class="nc kw hi kg b fi ni ne l nf ng"># PP test:<br/>ndiffs(series1, test='pp')  # output is 1</span></pre><p id="16fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，在所有三个测试中，我们得到的差值顺序为1。</p><p id="1faa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">太好了！让我们也检查一下ACF图在差分后是否改变了。可以看到，非平稳序列的ACF衰减缓慢，而平稳序列的ACF衰减很快。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="ed76" class="nc kw hi kg b fi nd ne l nf ng">plt.rcParams.update({'figure.figsize':(12,7), 'figure.dpi':120})<br/># Original Series<br/>fig, axes = plt.subplots(2, 2)<br/>axes[0, 0].plot(series1); <br/>axes[0, 0].set_title('Original Series')<br/>plot_acf(series1, ax=axes[0, 1])</span><span id="b26b" class="nc kw hi kg b fi ni ne l nf ng"># 1st Differencing<br/>axes[1, 0].plot(series2); <br/>axes[1, 0].set_title('1st Order Differencing')<br/>plot_acf(series2, ax=axes[1, 1])</span><span id="0d62" class="nc kw hi kg b fi ni ne l nf ng">plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nj"><img src="../Images/99e966b12779941f753588be2b436469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZrCuLlfKQw4wjZOZbzapw.png"/></div></div></figure><p id="6cd9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们已经确定了参数<code class="du kd ke kf kg b">d</code>的值。接下来，我们要确定分别是AR和MA模型阶数的<code class="du kd ke kf kg b">p</code>和<code class="du kd ke kf kg b">q</code>的值。</p><p id="d24e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了确定<code class="du kd ke kf kg b">p</code>，我们需要看看PACF图，所以让我们在下面绘制它。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="bcf2" class="nc kw hi kg b fi nd ne l nf ng">fig, axes = plt.subplots(1, 2)<br/>axes[0].plot(series2); <br/>axes[0].set_title('1st Differencing')<br/>axes[1].set(ylim=(-1,1))<br/>plot_pacf(series2, ax=axes[1])</span><span id="863d" class="nc kw hi kg b fi ni ne l nf ng">plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nj"><img src="../Images/fddd565c23bbfc2d77fe3cb6df012b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8Qf6VCsywy8Os3-eYUVFw.png"/></div></div></figure><p id="5366" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以看到唯一有意义的滞后是0。于是，搞定<code class="du kd ke kf kg b">p=0</code></p><p id="c5d1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们通过查看ACF图来找到MA(q)模型中的<code class="du kd ke kf kg b">q </code>项。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="3a6a" class="nc kw hi kg b fi nd ne l nf ng">#Find q in MA(q)<br/>plt.rcParams.update({'figure.figsize':(12,3), 'figure.dpi':120})<br/>fig, axes = plt.subplots(1, 2)<br/>axes[0].plot(series2); <br/>axes[0].set_title('1st Differencing')<br/>axes[1].set(ylim=(-1,1))<br/>plot_acf(series2, ax=axes[1])</span><span id="1e10" class="nc kw hi kg b fi ni ne l nf ng">plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nj"><img src="../Images/5864531e816b54013f27dad72a73ddf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qarZNHM-2bFC7_T3BovP3A.png"/></div></div></figure><p id="33f9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以看到唯一有意义的滞后是0。因此，固定q=0</p><p id="177b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们有<code class="du kd ke kf kg b">p=0</code>、<code class="du kd ke kf kg b">d=1</code>和<code class="du kd ke kf kg b">q=0</code>。你还在等什么？？？</p><p id="c36c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们来拟合ARIMA (0，1，0)模型。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="290f" class="nc kw hi kg b fi nd ne l nf ng"># 0,1,0 ARIMA Model<br/>model = ARIMA(series1.dropna(), order=(0,1,0))<br/>model_fit = model.fit(disp=0)<br/>print(model_fit.summary())</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nk"><img src="../Images/d7ee7fe5ec585a97b9058f3f1b5b4ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGL6SSBOEuommeX6kuRCcg.png"/></div></div></figure><p id="23a2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以看到，在系数中，我们只有常数项，没有其他系数。这是因为我们有<code class="du kd ke kf kg b">p=0</code>和<code class="du kd ke kf kg b">q=0</code>，这意味着模型中不包含过去的值和错误。有道理对吗？</p><p id="d31f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">既然我们已经拟合了模型，让我们通过绘制残差图来检查它的准确性。现在，记住我们使用的时间序列模型只不过是参数回归模型。因此，残差应该遵循回归模型的假设，或者简单地说，它们应该是白噪声。现在你明白了——什么是白噪音。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="0564" class="nc kw hi kg b fi nd ne l nf ng"># Plot residual errors<br/>residuals = pd.DataFrame(model_fit.resid)<br/>fig, ax = plt.subplots(1,2)<br/>residuals.plot(title="Residuals", ax=ax[0])<br/>residuals.plot(kind='kde', title='Density', ax=ax[1])<br/>plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nl"><img src="../Images/24904a77404b519a1c267cd9446170e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UR2k3OqwPT52rAAzOm7v8A.png"/></div></div></figure><p id="5f1c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以看到残差是随机白噪声，正态分布！太好了，我们刚刚找到了最适合我们数据的时间序列模型。</p><p id="e6ca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们绘制实际的和拟合的时间序列。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="2b25" class="nc kw hi kg b fi nd ne l nf ng"># Actual vs Fitted<br/>model_fit.plot_predict(dynamic=False)<br/>plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nm"><img src="../Images/e77ef6c20a70bc72e2ea277fc5f20cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNzyvhvDjUTovQ5SBOzmfA.png"/></div></div></figure><p id="c7a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">非常适合！现在我们了解了什么是时间序列建模。让我们预测，这是本教程的主要目标。首先根据我们的数据创建训练和测试集，构建模型，然后进行预测。简单！</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="d31d" class="nc kw hi kg b fi nd ne l nf ng"># Create Training and Test<br/>train = series1.dropna()[:200] #first 200 rows in the training set<br/>test = series1.dropna()[200:] #remaining rows in the test set</span><span id="5697" class="nc kw hi kg b fi ni ne l nf ng">#If it is not a time series, then this is not the ideal way for #train-test split. You may use scikit-learn library and use function #train_test_split() by providing the ratio. Since this is a time-#series data set, we cannot use future values to predict past #values.</span><span id="d0bb" class="nc kw hi kg b fi ni ne l nf ng"># Build Model<br/># model = ARIMA(train, order=(0,1,0))  <br/>model = ARIMA(train, order=(0, 1, 0))  <br/>fitted = model.fit(disp=-1)</span><span id="9b16" class="nc kw hi kg b fi ni ne l nf ng"># Forecast<br/>fc, se, conf = fitted.forecast(53, alpha=0.05)  # 95% conf</span><span id="b45f" class="nc kw hi kg b fi ni ne l nf ng"># Make as pandas series<br/>fc_series = pd.Series(fc, index=test.index)<br/>lower_series = pd.Series(conf[:, 0], index=test.index)<br/>upper_series = pd.Series(conf[:, 1], index=test.index)</span><span id="14c7" class="nc kw hi kg b fi ni ne l nf ng"># Plot<br/>plt.figure(figsize=(12,5), dpi=100)<br/>plt.plot(train, label='training')<br/>plt.plot(test, label='actual')<br/>plt.plot(fc_series, label='forecast')<br/>plt.fill_between(lower_series.index, lower_series, upper_series, <br/>                 color='k', alpha=.15)<br/>plt.title('Forecast vs Actuals')<br/>plt.legend(loc='upper left', fontsize=8)<br/>plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nn"><img src="../Images/b4d0ecae6ecf7477ff94f218db9ab689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBsu9Jb6bdiWUBblBSkXAA.png"/></div></div></figure><p id="ca5d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一个不错的预测，因为实际值位于置信区间内。</p><p id="661b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们看看几个准确性指标，看看这个模型是否好。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="db47" class="nc kw hi kg b fi nd ne l nf ng"># Accuracy metrics<br/>def forecast_accuracy(forecast, actual):<br/>    mape = np.mean(np.abs(forecast - actual)/np.abs(actual))  # MAPE<br/>    me = np.mean(forecast - actual)             # ME<br/>    mae = np.mean(np.abs(forecast - actual))    # MAE<br/>    mpe = np.mean((forecast - actual)/actual)   # MPE<br/>    rmse = np.mean((forecast - actual)**2)**.5  # RMSE<br/>    corr = np.corrcoef(forecast, actual)[0,1]   # corr<br/>    mins = np.amin(np.hstack([forecast[:,None], <br/>                              actual[:,None]]), axis=1)<br/>    maxs = np.amax(np.hstack([forecast[:,None], <br/>                              actual[:,None]]), axis=1)<br/>    minmax = 1 - np.mean(mins/maxs)             # minmax<br/>    acf1 = acf(fc-test)[1]                      # ACF1<br/>    return({'mape':mape, 'me':me, 'mae': mae, <br/>            'mpe': mpe, 'rmse':rmse, 'acf1':acf1, <br/>            'corr':corr, 'minmax':minmax})</span><span id="4535" class="nc kw hi kg b fi ni ne l nf ng">forecast_accuracy(fc, test.values)<br/>#MAPA is 0.065 which implies 93.5% accuracy in the prediction</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es no"><img src="../Images/2b6016aab581c16ebab284665cd7b63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*Q9WTa5o5GYL5MRF8jnNHXA.png"/></div></figure><p id="ec74" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以看到，MAPE(平均绝对预测误差)为0.065，这意味着预测的准确度为93.5%。还不错！</p><p id="7fc7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，如果你不想做这个寻找<code class="du kd ke kf kg b">p</code>、<code class="du kd ke kf kg b">d</code>和<code class="du kd ke kf kg b">q</code>的大程序，那我们就长话短说吧。只需使用auto_arima()函数，它会为您提供最佳的参数和模型。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="cc29" class="nc kw hi kg b fi nd ne l nf ng">#Automate ARIMA model</span><span id="87bc" class="nc kw hi kg b fi ni ne l nf ng">model = pm.auto_arima(series1.dropna(), start_p=0, start_q=0,<br/>                      test='adf',       # use adftest to find optimal 'd'<br/>                      max_p=3, max_q=3, # maximum p and q<br/>                      m=1,              # frequency of series<br/>                      d=None,           # let model determine 'd'<br/>                      seasonal=False,   # No Seasonality<br/>                      start_P=0, <br/>                      D=0, <br/>                      trace=True,<br/>                      error_action='ignore',  <br/>                      suppress_warnings=True, <br/>                      stepwise=True)</span><span id="ee03" class="nc kw hi kg b fi ni ne l nf ng">print(model.summary())</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es np"><img src="../Images/db7f809317f340e1badb3df5ccdd3d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRDlAZX7dO2U5NmQzxTttQ.png"/></div></div></figure><figure class="jz ka kb kc fd ij er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nq"><img src="../Images/e203f4ca65dbf78f9def7867e2116f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Dqlm2u-Vh7ofEdsh603hA.png"/></div></div></figure><p id="fd45" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我们的模型估计确实是正确的。我们数据的最佳模型是ARIMA(0，1，0)。太好了！</p><p id="5030" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，只需查看最佳模型的残差直方图和QQplot。</p><pre class="jz ka kb kc fd my kg mz na aw nb bi"><span id="f440" class="nc kw hi kg b fi nd ne l nf ng">model.plot_diagnostics(figsize=(7,5))<br/>plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nr"><img src="../Images/e43371e07b7ff0c3fba4051714810102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4uAs-aqHRa4mD8ZEVSPFw.png"/></div></div></figure><p id="f18c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">QQplot似乎遵循正态分位数。没有大尾巴。直方图和密度看起来也正常。相关图说，我们有一个平稳的时间序列。太好了！！！！一切都好！！！让我们拍拍背，是时候做些总结了。</p><h2 id="33a6" class="nc kw hi bd kx ns nt nu lb nv nw nx lf ix ny nz lj jb oa ob ln jf oc od lr oe bi translated"><strong class="ak">结尾备注:</strong></h2><p id="11b2" class="pw-post-body-paragraph im in hi io b ip lt ir is it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj hb bi translated">我们刚刚用单变量时间序列探讨了时间序列分析的基本框架。像RNN这样的非参数模型和深度学习模型也用于预测。多元时间序列建模也在实践中使用。前面还有很多东西要学。我将在接下来的故事中讨论更复杂的模型。敬请期待！</p><p id="2d4a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你觉得这个博客有用，请点赞、评论并分享。我很乐意在评论区回答你的问题。</p><h1 id="087e" class="kv kw hi bd kx ky of la lb lc og le lf lg oh li lj lk oi lm ln lo oj lq lr ls bi translated">回头见！</h1></div></div>    
</body>
</html>