<html>
<head>
<title>C++ Classes and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++类和对象</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/c-classes-and-objects-5dae9b3d9fd3?source=collection_archive---------21-----------------------#2020-08-28">https://medium.com/analytics-vidhya/c-classes-and-objects-5dae9b3d9fd3?source=collection_archive---------21-----------------------#2020-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4bf0fa48f423a21323668ca966f2b36a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zP3oNSBHhplE_GzzOS6CMQ.jpeg"/></div></div></figure><p id="c1ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文将使用一个<code class="du jo jp jq jr b">CheckingAccount</code>类作为运行示例。</p><h1 id="0f8f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">写作课</h1><p id="fe3f" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">编写类时，必须考虑由类表示的<em class="kv">行为</em>和<em class="kv">数据成员</em>(数据)。一个类就像一张蓝图，而对象就像根据蓝图建造的建筑。</p><h2 id="8089" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">类别定义</h2><p id="8898" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">下面是<code class="du jo jp jq jr b">CheckingAccount</code>类的第一个剪辑:</p><p id="50e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">checkingaccount.h</code>:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="cffa" class="kw jt hi jr b fi ls lt l lu lv">#ifndef CHECKING_H<br/>#define CHECKING_H<br/>class CheckingAccount<br/>{<br/>    public:<br/>        CheckingAccount(double balance);<br/>        ~CheckingAccount();<br/>        void deposit(double amount);<br/>        bool withdraw(double amount);<br/>        double getBalance() const;<br/>    private:<br/>        double mBalance;<br/>} <br/>#endif</span></pre><p id="ee5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">checkingaccount.cpp</code>:注意<code class="du jo jp jq jr b">::</code>操作符是<em class="kv">范围解析操作符</em>。</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="bbcf" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount::CheckingAccount(double balance) //constructor<br/>{<br/>    mBalance = balance;<br/>}</span><span id="4cfd" class="kw jt hi jr b fi lw lt l lu lv">void CheckingAccount::deposit(double amount)<br/>{<br/>    mBalance += amount;<br/>}</span><span id="1bc8" class="kw jt hi jr b fi lw lt l lu lv">bool CheckingAccount::withdraw(double amount)<br/>{<br/>    if((mBalance - amount) &gt; 0)<br/>    {<br/>        mBalance -= amount;<br/>        return true;<br/>    }<br/>    return false;<br/>}</span><span id="8f46" class="kw jt hi jr b fi lw lt l lu lv">double getBalance() const<br/>{<br/>    return mBalance;<br/>}<br/>//Destructor not implemented as there is no dynamic memory allocated.</span></pre><h2 id="7e64" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">访问控制</h2><ul class=""><li id="60ef" class="lx ly hi is b it kq ix kr jb lz jf ma jj mb jn mc md me mf bi translated"><code class="du jo jp jq jr b">public</code>:任何代码都可以调用<code class="du jo jp jq jr b">public</code>成员函数或者访问<code class="du jo jp jq jr b">public</code>数据成员。</li><li id="d1eb" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated"><code class="du jo jp jq jr b">protected</code>:只有类及其派生类才能访问成员函数或数据成员</li><li id="8d01" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated"><code class="du jo jp jq jr b">private</code>:只有类可以访问成员函数或数据成员。</li></ul><h2 id="f8c0" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">类内成员初始值设定项</h2><p id="3fb5" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">可以像这样直接在类定义中初始化成员变量:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="f346" class="kw jt hi jr b fi ls lt l lu lv">class CheckingAccount<br/>//....<br/>private : <br/>    double mBalance = 0.0;</span></pre><h2 id="a487" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated"><code class="du jo jp jq jr b">this</code>指针</h2><p id="7c7d" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">类的每个成员函数都有一个名为<code class="du jo jp jq jr b">this</code>的隐式指针参数，它指向当前对象。它可用于从数据成员中消除参数的歧义。它还可以用于将对当前对象的引用传递给一个函数，该函数接受对该对象的引用或常量引用。</p><h2 id="7682" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">堆栈上的对象</h2><p id="d362" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">C++允许在堆栈和堆上分配对象。示例:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="3c8f" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount chkAccount(1000.00);<br/>cout &lt;&lt; "Balance is " &lt;&lt; chkAccount.getBalance() &lt;&lt; endl;</span></pre><h2 id="271f" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">堆/空闲存储区上的对象</h2><p id="cb64" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">可以使用原始指针或智能指针之一在堆上分配对象。示例:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="41cd" class="kw jt hi jr b fi ls lt l lu lv">auto myChkAccount = std::make_unique&lt;CheckingAccount&gt;(10000.00); //smart pointer<br/>cout &lt;&lt; myChkAccount-&gt;getBalance() &lt;&lt; endl;</span><span id="f2d7" class="kw jt hi jr b fi lw lt l lu lv">CheckingAccount * chkaccount = new CheckingAccount(10000.00); //prefer smart pointer over this<br/>cout &lt;&lt; chkaccount-&gt;getBalance() &lt;&lt; endl;<br/>delete chkaccount;</span></pre><h1 id="bcb3" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">对象生命周期</h1><p id="c0b8" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">对象生命周期由<em class="kv">创建</em>、<em class="kv">销毁</em>和<em class="kv">分配</em>组成。</p><h2 id="1aaa" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">创造</h2><p id="f9f6" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">当一个对象被创建时，它嵌入的所有对象也被创建。示例:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="c871" class="kw jt hi jr b fi ls lt l lu lv">#include &lt;string&gt;</span><span id="5089" class="kw jt hi jr b fi lw lt l lu lv">class Foo<br/>{<br/>    private: <br/>        std::string mAddress;<br/>}</span><span id="d203" class="kw jt hi jr b fi lw lt l lu lv">int main()<br/>{<br/>    Foo fooObj;<br/>    return 0;<br/>}</span></pre><p id="a367" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">string</code>对象在<code class="du jo jp jq jr b">fooObj</code>创建时创建，在<code class="du jo jp jq jr b">fooObj</code>析构时析构(在这种情况下，超出范围)。</p><h2 id="f7e5" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">构造器</h2><p id="76a4" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">构造函数是一种特殊的成员函数，用于初始化类的值。默认构造函数不接受任何参数，或者所有数据成员都被赋予默认值。</p><h2 id="1b33" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">堆栈上的构造函数</h2><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="0b51" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount account(5000.00);</span></pre><h2 id="d134" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">堆上的构造函数</h2><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="d075" class="kw jt hi jr b fi ls lt l lu lv">auto chkAccount = std::make_unique&lt;CheckingAccount&gt;(5000.00);<br/>CheckingAccount anotherAccount = nullptr;<br/>anotherAccount = new CheckingAccount(100.00);</span></pre><h2 id="96a4" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">当需要默认构造函数时</h2><p id="5fe5" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">创建对象数组时，需要默认的构造函数，因为没有调用任何其他构造函数的选项:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="3297" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount accounts[5];<br/>CheckingAccount* accounts = new CheckingAccount[5];</span></pre><p id="1346" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认构造函数的示例如下:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="3d88" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount::CheckingAccount()<br/>{<br/>    mBalance = 0.0;<br/>}</span></pre><p id="bb91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，在堆栈上使用默认构造函数时，必须省略括号，如下所示:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="69ad" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount chkAccount;<br/>chkAccount.deposit(100.00);</span></pre><p id="da9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果程序员没有编写默认的构造函数，编译器会生成一个。但是，如果编程了任何构造函数，则编译器会省略构造函数的生成。</p><h2 id="bfe5" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">显式删除的构造函数</h2><p id="b4b3" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">如果您只有静态方法，并且不想要构造函数或由编译器生成构造函数，请执行以下操作:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="39d0" class="kw jt hi jr b fi ls lt l lu lv">class CheckingAccount<br/>{<br/>    public: <br/>       CheckingAccount() = delete;<br/>}</span></pre><h2 id="b4cc" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">构造函数初始值设定项</h2><p id="22b4" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">有一种替代方法来初始化构造函数中的数据成员，称为<em class="kv">构造函数初始化器</em>:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="7fca" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount:: CheckingAccount(double balance) : mBalance(balance)<br/>{ <br/>}</span></pre><p id="eb4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当 C++创建一个对象时，必须调用嵌入对象的构造函数本身。构造函数初始化器(ctor-initializer)允许调用这些构造函数，因为在构造函数体中，值被修改，但没有初始化。</p><p id="80c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果一个嵌入对象有一个默认的构造函数，就不需要在<em class="kv">构造函数初始化器</em>中初始化它。否则，初始化<em class="kv">初始化器</em>中的对象。有些类型<em class="kv">必须在<em class="kv">构造器初始化器</em>中初始化</em>，如下所示:</p><ul class=""><li id="4f1c" class="lx ly hi is b it iu ix iy jb ml jf mm jj mn jn mc md me mf bi translated"><code class="du jo jp jq jr b">const</code>数据成员:只能创建和分配一次。</li><li id="43b0" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">引用:只能在引用变量时存在</li><li id="595f" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">没有默认构造函数的嵌入对象</li><li id="b8ff" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">没有默认构造函数的基类</li></ul><p id="088f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，构造函数初始化器按照数据成员在类定义中出现的顺序初始化数据成员，而不是按照它们在初始化器列表中出现的顺序。</p><h1 id="c5a1" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">复制构造函数</h1><p id="0c22" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><em class="kv">复制构造函数</em>让你创建一个对象，它是另一个对象的精确副本。如果程序员没有提供，编译器会生成一个，从源对象中相应的数据成员初始化每个数据成员。<br/>对于嵌入对象，调用它们的复制构造函数。示例:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="3ff2" class="kw jt hi jr b fi ls lt l lu lv">class CheckingAccount<br/>{<br/>    public:<br/>       CheckingAccount(const CheckingAccount &amp;src);<br/>}</span></pre><p id="dabc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实施:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="9bfd" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount::CheckingAccount(const CheckingAccount &amp;src) : mBalance(src.mBalance)<br/>{</span><span id="ab59" class="kw jt hi jr b fi lw lt l lu lv">}</span></pre><p id="ad19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给定数据成员<code class="du jo jp jq jr b">n1</code>、<code class="du jo jp jq jr b">n2</code>、<code class="du jo jp jq jr b">nM</code>，编译器生成一个复制构造函数，如下所示:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="dd09" class="kw jt hi jr b fi ls lt l lu lv">cname::cname(const cname&amp; src)<br/>: n1(src.n1), n2(src.n2),...,nM(src.nM) {}</span></pre><p id="465b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在许多情况下，没有必要显式指定复制构造函数。</p><h2 id="c701" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">当调用 Copy Ctor 时</h2><p id="9fcc" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">每当对象通过值传递给函数或方法时，就调用复制构造函数。示例:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="5910" class="kw jt hi jr b fi ls lt l lu lv">void foo(std::string name)<br/>{<br/>    cout &lt;&lt; "Name is "&lt;&lt;name&lt;&lt;endl;<br/>}</span><span id="aa5c" class="kw jt hi jr b fi lw lt l lu lv">int main()<br/>{<br/>    string name = "John";<br/>    foo(name); //copy constructor<br/>}</span></pre><h2 id="4eae" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">当显式调用复制构造函数时</h2><p id="9309" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">示例:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="2c3d" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount account(5000.00);<br/>CheckingAccount accountCopy(account);</span></pre><h2 id="67b9" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">通过引用传递对象</h2><p id="5494" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">以下是指导方针:</p><ul class=""><li id="1930" class="lx ly hi is b it iu ix iy jb ml jf mm jj mn jn mc md me mf bi translated">通过常量引用传递对象以提高性能(除非需要修改)</li><li id="8b6d" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">按值传递原语</li><li id="80fd" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">通过值传递<code class="du jo jp jq jr b">string_view</code>,因为它只是一个指针和长度</li><li id="f7a2" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">不要传递对堆栈上对象的引用。还一份。</li></ul><p id="265c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要禁止通过值传递对象，请删除复制构造函数:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="f583" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount(const CheckingAccount &amp;src) = delete;</span></pre><h2 id="7ad3" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">初始值设定项列表构造函数</h2><p id="19dc" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><em class="kv"> initializerlist 构造函数</em>是一个第一个参数为<code class="du jo jp jq jr b">std::initializer_list&lt;T&gt;</code>的构造函数，没有附加参数或者附加参数给定默认值。</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="33cf" class="kw jt hi jr b fi ls lt l lu lv">class Sequence<br/>{<br/>    public :<br/>        Sequence(initializer_list&lt;int&gt; params)<br/>        { <br/>            for(const auto&amp; value: params)<br/>            {<br/>                values.push_back(value); //note push_back takes const reference parameter and makes a copy of it internally<br/>            }<br/>        }<br/>    private:<br/>        vector&lt;int&gt; values;<br/>}</span></pre><h2 id="1179" class="kw jt hi bd ju kx ky kz jy la lb lc kc jb ld le kg jf lf lg kk jj lh li ko lj bi translated">委托构造函数</h2><p id="b061" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">委托构造函数使构造函数能够从 ctor-initializer(它必须是唯一的成员初始值设定项)内部调用其他构造函数。</p><h1 id="5d3e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">对象销毁</h1><p id="b804" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">当一个对象被销毁时，对象的析构函数方法被调用，如果析构函数被正确实现，分配的内存被释放。如果程序员不创建析构函数，<br/>编译器会创建一个进行递归成员式析构的析构函数。堆栈上的回调对象在超出范围时被销毁。堆栈上的对象按构造的相反顺序销毁。</p><h1 id="e34f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">重载赋值运算符</h1><p id="8462" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">重载赋值运算符不同于实现复制构造函数，因为“复制”只在对象初始化时发生。该运算符也称为复制赋值运算符。<br/>举例:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="b823" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount&amp; operator=(const CheckingAccount &amp;rhs);</span></pre><p id="6bf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">返回对该对象的引用以允许<em class="kv">链接赋值</em>。重载赋值运算符的示例:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="1db0" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount&amp; CheckingAccount::operator=(const CheckingAccount&amp; rhs)<br/>{<br/>    if(this == &amp;rhs)<br/>    {<br/>        return *this; //have to do this as self assignment is allowed in C++<br/>    }<br/>    mBalance = rhs.mBalance;<br/>    return *this;<br/>}</span></pre><h1 id="8308" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">区分拷贝和转让</h1><p id="b909" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">复制结构的示例:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="0f9e" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount acct1(10.0);<br/>CheckingAccount acct2(acct1);</span><span id="bb33" class="kw jt hi jr b fi lw lt l lu lv">CheckingAccount acct3 = acct2;</span></pre><p id="eccb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">分配示例:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="1f2a" class="kw jt hi jr b fi ls lt l lu lv">acct3 = acct1;</span></pre><h1 id="08b4" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">对象作为返回值</h1><p id="c6c4" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">例如，如果从函数中返回一个<code class="du jo jp jq jr b">std::string</code>并按如下方式赋值，则调用复制构造函数，然后调用赋值操作符:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="36d2" class="kw jt hi jr b fi ls lt l lu lv">string s1;<br/>s1 = getString();</span></pre><p id="5ebb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，调用了两个复制构造函数:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="e323" class="kw jt hi jr b fi ls lt l lu lv">string s1 = getString(); //getString calls copy constructor and s1's copy constructor is called.</span></pre><p id="6877" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编译器经常做<em class="kv">返回值优化(RVO) </em>来消除对返回值的复制构造函数调用。</p><h1 id="ad1c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">复制构造函数和对象数据成员</h1><p id="8efd" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">编译器生成的复制构造函数递归调用每个嵌入对象的复制构造函数。然而，当程序员实现时，只有使用 ctor-initializer 才能确保调用嵌入对象的复制构造函数:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="a803" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount::CheckingAccount(const CheckingAccount &amp;src) : mBalance(src.mBalance) {}</span></pre><p id="5610" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果改为执行以下操作，则使用赋值运算符，因为编译器会在主体执行时调用默认的构造函数:</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="306c" class="kw jt hi jr b fi ls lt l lu lv">CheckingAccount::CheckingAccount(const CheckingAccount &amp;src)<br/>{<br/>    mBalance = src.mBalance; //assignment operator<br/>}</span></pre><h1 id="972d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">参考资料:</h1><p id="eebe" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">m .格雷瓜尔(2018)。<em class="kv">专业 C++ </em>。印第安纳州，约翰·威利的儿子们。</p><div class="mo mp ez fb mq mr"><a href="https://codingadventures1.blogspot.com/2020/02/classes-and-objects.html" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab dw"><div class="mt ab mu cl cj mv"><h2 class="bd hj fi z dy mw ea eb mx ed ef hh bi translated">类别和对象</h2><div class="my l"><h3 class="bd b fi z dy mw ea eb mx ed ef dx translated">本文将使用 CheckingAccount 类作为运行示例。编写类时，必须考虑…</h3></div><div class="mz l"><p class="bd b fp z dy mw ea eb mx ed ef dx translated">codingadventures1.blogspot.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf io mr"/></div></div></a></div></div></div>    
</body>
</html>