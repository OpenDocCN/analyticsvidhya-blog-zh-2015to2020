<html>
<head>
<title>Coding your first GAN algorithm with Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Keras编写您的第一个GAN算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/coding-your-first-gan-algorithm-with-keras-ab2bdf761746?source=collection_archive---------11-----------------------#2020-05-13">https://medium.com/analytics-vidhya/coding-your-first-gan-algorithm-with-keras-ab2bdf761746?source=collection_archive---------11-----------------------#2020-05-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="247b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">喝点咖啡，带上耳机，让我们开始编写你的第一个GAN算法吧！如果你不熟悉GANs或者GANs是如何工作的，在这里查看我的文章。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/2f6bec637995edd39c074d3cf3020fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jjDGryhhnDCPZzNGSL6Dw.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">准备编码。<a class="ae jd" href="http://Photo by Goran Ivos on Unsplash" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="0037" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将马上开始，不浪费任何时间。gan算法由以下组件组成:</p><ol class=""><li id="0d28" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">导入必要的库和数据集</li><li id="5113" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">真实图像样本</li><li id="39b7" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">生成假图像</li><li id="9770" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">创建模型:生成器、鉴别器、GAN</li><li id="1cc1" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">培养</li><li id="2901" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">模型评估</li><li id="e46e" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">预言</li></ol></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="9919" class="kp kq hi bd kr ks kt ku kv kw kx ky kz iq la lb lc iu ld le lf iy lg lh li lj bi translated">1.导入必要的库和数据集</h2><p id="3814" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">我们将从导入基本库开始。神经网络是使用keras API和tensorflow后端创建的。我用的是keras版本' 2.2.5 '和tensorflow版本' 1.15.0 '。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lp"><img src="../Images/c4d4bbc6d15ecf7a11e74b7fb5ee7928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hScixT6X4C4rjk3gvxlGow.png"/></div></div></figure><p id="8d5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导入库之后，我们需要导入训练数据集。我们将使用MNIST数据集来训练模型。MNIST数据集是70，000个28 x 28大小的手写数字图像的集合，范围从0到9。该数据集对初学者特别有用，因为该数据集是公开可用的，完全平衡的，并且只需要很少的预处理。所有的图像都是灰度级的，所以像素值在0到255的范围内。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lq"><img src="../Images/e242d2484be2a143ad40561ff93a82c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*PnwsyKWtxDuj1C8EH01vtQ.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">来自MNIST数据集的样本图像</figcaption></figure><p id="5a24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MNIST数据集已经在keras库中可用，我们只需要加载数据集并将其分配给相应的变量。唯一需要的预处理是将无符号整数像素值从[0，255]转换为[0，1]。下面是导入和预处理数据的代码:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lr"><img src="../Images/fdfa2b766fc4434b8e79d1d40828a2a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AG_U051_gE3uW4gBdY_OEg.png"/></div></div></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="f1b9" class="kp kq hi bd kr ks kt ku kv kw kx ky kz iq la lb lc iu ld le lf iy lg lh li lj bi translated">2.真实图像样本</h2><p id="977b" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">为了对真实图像进行采样，我们将创建一个名为<em class="ls"> sample_real_images </em>的函数。我们将从整个数据集中选择一批图像，并将每个图像标记为“1”。函数的输入将是整个<em class="ls">数据集</em> (x_train) <em class="ls"> </em>和<em class="ls"> batch_size。</em>请注意，我们将对真实图像使用标签“1 ”,对虚假图像使用标签“0”。因此，采样的真实图像的标签被设置为“1”。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lp"><img src="../Images/8ac319da96ea783be60ce4f30654fe1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMDY42TFpfxx-9EarUlT_w.png"/></div></div></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="8958" class="kp kq hi bd kr ks kt ku kv kw kx ky kz iq la lb lc iu ld le lf iy lg lh li lj bi translated">3.生成假图像</h2><p id="72da" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">生成假图像要稍微复杂一些，时间也更长。每幅图像都是从正态高斯分布中采样的n元素向量生成的。相应的，要生成一批图像，我们需要一批矢量。为此，我们将创建两个函数:<em class="ls"> generate_latent_points </em>来生成一批矢量，以及<em class="ls"> generate_fake_images </em>来从这些矢量生成图像。<em class="ls"> generate_latent_points </em>函数的输入将是<em class="ls"> latent_dim </em>(向量的长度)和<em class="ls"> batch_size。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lt"><img src="../Images/95051f1dce89006a317e98c3b61b7517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJB2wViIoFdGSvDu6F4N1g.png"/></div></div></figure><p id="0515" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将定义一个名为<em class="ls"> generate_fake_images </em>的函数，该函数将调用上述函数来生成一批向量，然后生成与每个向量对应的图像。该函数的输入将是一个<em class="ls">模型(生成器)</em>、<em class="ls">向量长度(潜在尺寸)</em>和<em class="ls">批量大小。</em>由于这些是假图像，所有这些图像的标签都被设置为“0”。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lt"><img src="../Images/3901e8650f92813a451c4d4cb2130951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nd7fKE5OYJlGC_pI8FbzlA.png"/></div></div></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="362b" class="kp kq hi bd kr ks kt ku kv kw kx ky kz iq la lb lc iu ld le lf iy lg lh li lj bi translated">4.创建模型</h2><p id="869b" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">在继续之前，我们先回忆一下GAN模型架构。如下图所示，GAN模型由发电机模型和鉴别器模型串联而成。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lu"><img src="../Images/cbfba706b9a72f1617c7be72b9780933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*et3fMPDclTv6ZQSf1xbkag.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">GAN模型架构</figcaption></figure><p id="ace6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们将首先创建鉴别器和发生器的独立模型，然后将它们组合在一起，构成一个完整的GAN模型。还有其他方法来创造，但我发现这是非常简单的理解和实施。</p><p id="a472" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">鉴别器模型为二元分类卷积神经网络。它的任务是区分真实和虚假的图像。我们将获取两个大小相等的小批量图像，一个是真实图像，一个是生成图像，并将其作为输入提供给鉴别器。鉴别器模型的输出将是图像属于真实(“1”)和虚假(“0”)类别的概率。</strong></p><p id="f7b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下参数已被证明可为鉴别器提供更好的性能结果:</p><ol class=""><li id="4a4d" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><a class="ae jd" href="https://keras.io/api/layers/activation_layers/leaky_relu/" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> LeakyRELU </em> </a>斜率为0.2的隐藏层激活功能</li><li id="bbc4" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><a class="ae jd" href="https://keras.io/api/layers/regularization_layers/dropout/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">丢失</em> </a>正则化，神经元丢失率为0.3~0.4</li><li id="12d9" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><a class="ae jd" href="https://keras.io/api/optimizers/adam/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">亚当</em> </a>优化器，学习率为0.0002，动量为0.5</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lv"><img src="../Images/0f93973d6f19e1c51ea1acb1a1f53782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*srebB3QYRi1LuzVGxpYZYw.png"/></div></div></figure><p id="83d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们创建一个发电机模型。对于这个例子，我们将使用100元素的潜在向量来生成图像。100的长度是任意的，我们可以自由选择50、200、500甚至1000作为向量的长度。</p><p id="76fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在卷积神经网络中，图像被转换成多个特征图，随后是汇集、展平过程，最后是几个完全连接的<a class="ae jd" href="https://keras.io/api/layers/core_layers/dense/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">密集</em> </a>层。网络的<strong class="ih hj">输出将是相应图像的类别分数的向量</strong>。由于生成器将从矢量创建图像，<strong class="ih hj">它将遵循卷积神经网络<strong class="ih hj">的精确逆过程</strong>。</strong></p><ol class=""><li id="b988" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">由100个元素组成的矢量将连接到一个<em class="ls">密集图层</em>上，该图层具有足够的节点，可在整形后创建多个要素地图。</li><li id="0c7a" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">使用<a class="ae jd" href="https://keras.io/api/layers/convolution_layers/convolution2d_transpose/" rel="noopener ugc nofollow" target="_blank"><em class="ls">conv 2d transpose</em></a><em class="ls">层进行反卷积或上采样。</em>我们将使用(2x2)的步幅，使每一边的图像尺寸加倍，内核大小是步幅的倍数(CNN的标准做法之一)。</li><li id="87e0" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><em class="ls">斜率为0.2的隐藏层的LeakyRELU </em>激活功能</li><li id="dddc" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">输出层激活函数将是<em class="ls"> sigmoid </em>以具有0和1之间的像素值。</li><li id="c323" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">使用<a class="ae jd" href="https://keras.io/api/layers/normalization_layers/batch_normalization/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">批处理规范化</em> </a>是可选的，但建议用来提高性能。</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lw"><img src="../Images/c597eb8b6cebbd7a77a4b4d6fa513dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sUl3PIN42BA74TO3jRKvJg.png"/></div></div></figure><blockquote class="lx ly lz"><p id="c9bb" class="if ig ls ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">理解我们为什么不编译发电机模型是很重要的。这是因为生成器模型不像鉴别器模型那样被直接训练。生成器模型的性能取决于鉴别器将伪图像分类为真实图像的能力。一旦我们投入到模型的训练中，我们会有更好的理解。</p></blockquote><p id="ac01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将使用<em class="ls"> create_gan_model </em>函数创建一个完整的GAN模型。该合成模型由<em class="ls">生成器</em>模型(一批伪图像)组成，作为<em class="ls">鉴别器</em>模型的输入。我们将鉴别器权重的<em class="ls">可训练属性</em>设置为<em class="ls">假。</em>这样做是为了避免在生成器为假图像进行训练时改变鉴别器的权重。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lt"><img src="../Images/cfef3ae7f82388857207587e34c43d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hruWkdKmffWDqoO8kWcMSQ.png"/></div></div></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="9c23" class="kp kq hi bd kr ks kt ku kv kw kx ky kz iq la lb lc iu ld le lf iy lg lh li lj bi translated">5.培养</h2><p id="de0f" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">下图显示了两种不同的培训途径。鉴别器模型以独立的方式被训练和更新。之前，当我们将权重的<em class="ls">可训练</em>属性设置为<em class="ls"> False时，</em>仅适用于GAN模型中的鉴别器模型。它不会以任何方式影响独立模型。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lu"><img src="../Images/465011469bd5c507583912d684a39f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ACkQwzNVDb4n-YEYKu9ow.jpeg"/></div></div></figure><p id="8820" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于训练，我们将创建一个名为<em class="ls"> train </em>的函数，它将连续训练这两个模型。我们将对模型进行100个时期的训练，并以10个时期为间隔对其性能进行评估。一旦训练开始，我们可以看到在30个时期之后，生成器模型能够生成相当真实的图像。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es md"><img src="../Images/3f6b544ac8cf0e4055bb5041ed644db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HfEE56nwbGiMdiNxvIOvAw.png"/></div></div></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="74b7" class="kp kq hi bd kr ks kt ku kv kw kx ky kz iq la lb lc iu ld le lf iy lg lh li lj bi translated">6.模型评估</h2><p id="4362" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">GAN模型的收敛性没有被完全理解和定义。生成器模型生成的图像需要进行主观评价来判断模型的性能。最常见的方法是定期检查鉴别器的准确性，保存发生器模型及其生成的图像。然后，这些生成的图像需要由用户进行主观评估。为此，我们有三个功能:</p><ol class=""><li id="9557" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><strong class="ih hj">model _ evaluation:</strong><em class="ls"/>我们将在生成的和真实的图像上检查鉴别器模型的准确性。我们还将定期保存生成器和鉴别器模型，以备将来使用和评估。</li><li id="e0d4" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><strong class="ih hj">保存_图像:</strong>保存生成的图像</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es me"><img src="../Images/32a978729fd1f32a5766dc274a6dbe92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3OKQLoeEaQpX4Qxg7bGfw.png"/></div></div></figure><p id="52ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj"> create_animation: </strong>从生成的图像中创建动画。这将有助于可视化发电机模型的演变。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mf"><img src="../Images/8e7a86465d243f6eb579ce0d18bcca9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJxy0xF-UH_QxJ5x24VMQw.png"/></div></div></figure><h2 id="a0c8" class="kp kq hi bd kr ks kt ku kv kw kx ky kz iq la lb lc iu ld le lf iy lg lh li lj bi translated"><strong class="ak"> 7。预测</strong></h2><p id="9ce2" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">一旦训练结束，就该预测和检查结果了。我们将使用最后保存的模型生成20幅图像。下面的结果表明，经过100个时期的训练后，该模型能够生成与训练数据集中的图像相似的相当好的图像。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mg"><img src="../Images/b167ed5ca606ba93edb469e64ca5808a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CeXN0-UWj_nzN2ut4DXwEQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">使用GAN生成器模型生成的数字</figcaption></figure><p id="477b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完整的代码可以在我的github <a class="ae jd" href="https://github.com/kraken24/getting_started_with_gans" rel="noopener ugc nofollow" target="_blank"> <em class="ls">这里</em> </a>找到。</p><p id="4910" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步:我们可以试验不同的超参数，如输入向量的长度、批量、时期数、层数等，看看模型是否能产生更好的结果。</p><p id="915c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你在这篇文章中找到一些有用的东西。如果你喜欢这篇文章，别忘了给它几个掌声！</p><p id="4913" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考资料:</p><ol class=""><li id="e9bb" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><a class="ae jd" href="https://arxiv.org/pdf/1406.2661.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1406.2661.pdf</a></li><li id="07ed" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><a class="ae jd" href="https://www.tensorflow.org/tutorials/generative/dcgan" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/tutorials/generative/dcgan</a></li><li id="0b83" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">更详细的了解，请参考本教程:<a class="ae jd" href="https://machinelearningmastery.com/how-to-develop-a-generative-adversarial-network-for-an-mnist-handwritten-digits-from-scratch-in-keras/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/how-to-develop-a-generative-adversarial-network-for-an-mnist-handled-digits-from-scratch-in-keras/</a></li><li id="2933" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><a class="ae jd" href="https://keras.io/api/datasets/mnist/" rel="noopener ugc nofollow" target="_blank">https://keras.io/api/datasets/mnist/</a></li></ol></div></div>    
</body>
</html>