<html>
<head>
<title>Table Detection and Text Extraction — OpenCV and Pytesseract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">表格检测和文本提取— OpenCV和Pytesseract</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/table-detection-and-text-extraction-5a2934f61caa?source=collection_archive---------0-----------------------#2020-12-13">https://medium.com/analytics-vidhya/table-detection-and-text-extraction-5a2934f61caa?source=collection_archive---------0-----------------------#2020-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b6bb73f79cbc9d4d065e0a20a06bbcb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cz4TwddY_dSiVMpq4dCM3g.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来自<a class="ae iu" href="https://nanonets.com/blog/ocr-with-tesseract/" rel="noopener ugc nofollow" target="_blank">https://nanonets.com/blog/ocr-with-tesseract/</a></figcaption></figure><p id="a587" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定一个包含随机文本和表格的图像，目标是只从表格中提取数据。这是我在一组图片上尝试了文档和文章中的几种不同方法后得出的结果。</p><p id="306b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://pypi.org/project/pytesseract/" rel="noopener ugc nofollow" target="_blank">pytesserac</a>和<a class="ae iu" href="https://pypi.org/project/tesseract-ocr/" rel="noopener ugc nofollow" target="_blank">tesserac-ocr</a>用于图像到文本的转换。</p><p id="e5ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们需要识别图像中包含表格的部分。为此，我们将使用<a class="ae iu" href="https://pypi.org/project/opencv-python/" rel="noopener ugc nofollow" target="_blank"> openCV </a>。</p><p id="e644" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从下载一个包含表格的图像开始。这张图片是从<a class="ae iu" href="http://softlect.in/index.php/html-table-tags/" rel="noopener ugc nofollow" target="_blank">这里</a>下载的。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/1765ee03ba1a106c7657d3c4c27803c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DzRfnN3Lp2yo4g4tIQtQg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="http://softlect.in/index.php/html-table-tags/" rel="noopener ugc nofollow" target="_blank">http://softlect.in/index.php/html-table-tags/</a></figcaption></figure><p id="861b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上传图片到谷歌实验室。</p><div class="jy jz ez fb ka kb"><a href="https://colab.research.google.com/" rel="noopener  ugc nofollow" target="_blank"><div class="kc ab dw"><div class="kd ab ke cl cj kf"><h2 class="bd hj fi z dy kg ea eb kh ed ef hh bi translated">谷歌联合实验室</h2><div class="ki l"><h3 class="bd b fi z dy kg ea eb kh ed ef dx translated">编辑描述</h3></div><div class="kj l"><p class="bd b fp z dy kg ea eb kh ed ef dx translated">colab.research.google.com</p></div></div><div class="kk l"><div class="kl l km kn ko kk kp io kb"/></div></div></a></div><p id="6db2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，必须将图像转换为二进制，即如果像素值大于某个值，则为其分配一个值，如果小于某个值，则分配另一个值。这里，可以为不同类型的阈值处理指定不同的参数。</p><p id="1e3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> cv2.threshold() </strong>:第一个参数是源图像，其中<strong class="ix hj">应该是灰度图像</strong>。第二个参数是用于对像素值进行分类的阈值。第三个参数是maxVal，它表示当像素值大于阈值时给出的值。OpenCV提供不同风格的阈值处理，它由函数的第四个参数决定。</p><p id="5a54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">全局阈值处理:</strong>在全局阈值处理中，任意值被用作阈值。全局，因为相同的值被应用为所有像素的阈值。</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="b205" class="kv kw hi kr b fi kx ky l kz la">thresh,img_bin = cv2.threshold(img,128,255,cv2.THRESH_BINARY)</span><span id="bb5e" class="kv kw hi kr b fi lb ky l kz la">img_bin = 255-img_bin</span><span id="f020" class="kv kw hi kr b fi lb ky l kz la">plotting = plt.imshow(img_bin,cmap='gray')</span><span id="cfba" class="kv kw hi kr b fi lb ky l kz la">plt.title("Inverted Image with global thresh holding")</span><span id="e413" class="kv kw hi kr b fi lb ky l kz la">plt.show()</span></pre><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/1f74fc709bf5d7c93f60dea6c8277ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*-5byXVrRxDMMkcHOjyribA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由作者提供，使用合作实验室生成</figcaption></figure><p id="ef1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Otsu阈值化:</strong>如果需要自动选择阈值的过程，可以尝试Otsu。Otsu将很好地用于双峰图像，即所有像素值的直方图将具有两个峰值。对于该图像，otsu选择大约在两个峰值中间的值作为阈值。所以，Otsu对双峰图像很有效。</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="a3f9" class="kv kw hi kr b fi kx ky l kz la">img_bin1 = 255-img</span><span id="ff1b" class="kv kw hi kr b fi lb ky l kz la">thresh1,img_bin1_otsu = cv2.threshold(img_bin1,128,255,cv2.THRESH_OTSU)</span><span id="30f9" class="kv kw hi kr b fi lb ky l kz la">plotting = plt.imshow(img_bin1_otsu,cmap='gray')</span><span id="b0eb" class="kv kw hi kr b fi lb ky l kz la">plt.title("Inverted Image with otsu thresh holding")</span><span id="7438" class="kv kw hi kr b fi lb ky l kz la">plt.show()</span></pre><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/80601c9ed852faf2fcc443c6d00ff675.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*OvUTQ_roiFFc-R7yyqqjDg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用协同实验室生成的图像</figcaption></figure><p id="1b44" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果都cv2。THRESH_BINARY和cv2。THRESH_OTSU在第四个参数中传递，该函数执行全局和OTSU阈值处理。</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="24e6" class="kv kw hi kr b fi kx ky l kz la">img_bin2 = 255-img</span><span id="7e25" class="kv kw hi kr b fi lb ky l kz la">thresh1,img_bin_otsu = cv2.threshold(img_bin2,128,255,cv2.THRESH_BINARY | cv2.THRESH_OTSU)</span><span id="7ff1" class="kv kw hi kr b fi lb ky l kz la">plotting = plt.imshow(img_bin_otsu,cmap='gray')</span><span id="94a0" class="kv kw hi kr b fi lb ky l kz la">plt.title("Inverted Image with otsu thresh holding")</span><span id="5ab6" class="kv kw hi kr b fi lb ky l kz la">plt.show()</span></pre><p id="0668" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是之后的图像:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/bceb6010d7fc116c86ff37c09a25c407.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*OlZlJsbtDJnyAmb9Yjvs6g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用协同实验室生成的图像</figcaption></figure><p id="ea7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于图像的形状对图像执行形态学操作。它接受图像和一个结构化元素或内核。</p><p id="d85d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">cv2 . getstructuringelement()</strong>:这里内核的形状和大小可以作为参数传递，并相应地生成一个矩阵。</p><p id="f17f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是使用的格式，因为这可能很难记住:</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="927b" class="kv kw hi kr b fi kx ky l kz la"><strong class="kr hj">cv2.getStructuringElement(shape,(num_of_columns,num_of_rows))</strong></span></pre><ul class=""><li id="2576" class="le lf hi ix b iy iz jc jd jg lg jk lh jo li js lj lk ll lm bi translated">第一个参数指定了您想要的内核形状，可以是矩形、圆形甚至椭圆形。</li><li id="de50" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">第二个参数是tuple，表示所需内核的形状、宽度和高度。</li></ul><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="49fa" class="kv kw hi kr b fi kx ky l kz la">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 2))</span></pre><p id="4628" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">np.array(image)。形状用于获取图像尺寸。首先，矩形垂直核定义为1行和1列，即图像的numpy数组的长度除以150。它看起来会像这样:</p><p id="de1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">[1</p><p id="8810" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">1</p><p id="8b61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">1</p><p id="6022" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">1 ]</p><p id="cad0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，我们将使用垂直内核对二值图像执行腐蚀。它将删除所有水平线。</p><h1 id="2d22" class="ls kw hi bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">提取垂直线</h1><p id="3992" class="pw-post-body-paragraph iv iw hi ix b iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo mt jq jr js hb bi translated">垂直核由矩形矩阵组成，该矩阵由等于原始图像像素阵列中的列数除以150的一行和多列组成。</p><h2 id="0f49" class="kv kw hi bd lt mu mv mw lx mx my mz mb jg na nb mf jk nc nd mj jo ne nf mn ng bi translated">侵蚀</h2><p id="0488" class="pw-post-body-paragraph iv iw hi ix b iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo mt jq jr js hb bi translated">对这个图像进行腐蚀会发生什么？</p><p id="82bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在图像上移动的垂直核，只有当垂直核下的所有像素都为1时，才会考虑像素。这样，水平线被侵蚀了，因为只有每列中的像素保留下来。</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="0233" class="kv kw hi kr b fi kx ky l kz la">import numpy</span><span id="a410" class="kv kw hi kr b fi lb ky l kz la">vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, np.array(img).shape[1]//150))</span><span id="661e" class="kv kw hi kr b fi lb ky l kz la">eroded_image = cv2.erode(binary_image, vertical_kernel, iterations=5)</span></pre><h2 id="9a4d" class="kv kw hi bd lt mu mv mw lx mx my mz mb jg na nb mf jk nc nd mj jo ne nf mn ng bi translated">扩张</h2><p id="a0de" class="pw-post-body-paragraph iv iw hi ix b iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo mt jq jr js hb bi translated">现在，让我们在图像上执行膨胀。如果内核下的像素中至少有一个是1，膨胀将使像素为1。这使得竖线更加突出。</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="795c" class="kv kw hi kr b fi kx ky l kz la">vertical_lines = cv2.dilate(eroded_image, vertical_kernel, iterations=5)</span></pre><p id="4b28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">腐蚀和膨胀用于去除噪声。</p><p id="0d1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行腐蚀和膨胀后，图像如下所示:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/e74dfb93ab629c45a5e426bbfcdf3d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_qpjeDXr1LIgDlPwRyn_A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用协同实验室生成的图像</figcaption></figure><h1 id="0088" class="ls kw hi bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">提取水平线</h1><h2 id="c280" class="kv kw hi bd lt mu mv mw lx mx my mz mb jg na nb mf jk nc nd mj jo ne nf mn ng bi translated">侵蚀</h2><p id="6bd4" class="pw-post-body-paragraph iv iw hi ix b iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo mt jq jr js hb bi translated">在图像上移动的水平核，只有当水平核下的所有像素都为1时，才会考虑像素。这样，水平线被侵蚀了，因为只有每列中的像素保留下来。</p><p id="284e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">水平内核看起来像这样:</p><p id="544d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">[1 1 1 1 1 1 1 ]</p><h2 id="fe77" class="kv kw hi bd lt mu mv mw lx mx my mz mb jg na nb mf jk nc nd mj jo ne nf mn ng bi translated">扩张</h2><p id="8d97" class="pw-post-body-paragraph iv iw hi ix b iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo mt jq jr js hb bi translated">这使得水平线更加突出。</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="be35" class="kv kw hi kr b fi kx ky l kz la">image_2 = cv2.erode(img_bin, hor_kernel, iterations=5)</span><span id="ca4f" class="kv kw hi kr b fi lb ky l kz la">hor_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (np.array(img).shape[1]//150, 1))</span><span id="c291" class="kv kw hi kr b fi lb ky l kz la">horizontal_lines = cv2.dilate(image_2, hor_kernel, iterations=5)</span></pre><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/38e6d94dcf2116a203797fb27b7109ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Orcp41BoX3pvB0p6LfUfg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用协同实验室生成的图像</figcaption></figure><p id="68f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">水平线和垂直线以相等的权重相加，以创建混合图像。</p><p id="9cff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">加权图像=第一个图像的权重*第一个图像+第二个图像的权重+ gamma(其为任意常数)。</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="b3fd" class="kv kw hi kr b fi kx ky l kz la">vertical_horizontal_lines = cv2.addWeighted(vertical_lines, 0.5, horizontal_lines, 0.5, 0.0)</span><span id="5819" class="kv kw hi kr b fi lb ky l kz la">vertical_horizontal_lines = cv2.erode(~vertical_horizontal_lines, kernel, iterations=3)</span></pre><p id="2699" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对包含垂直线和水平线的图像应用阈值处理。</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="c4a2" class="kv kw hi kr b fi kx ky l kz la">thresh, vertical_horizontal_lines = cv2.threshold(vertical_horizontal_lines,128,255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)</span><span id="8acd" class="kv kw hi kr b fi lb ky l kz la">b_image = cv2.bitwise_not(cv2.bitwise_xor(img,vertical_horizontal_lines))</span><span id="2469" class="kv kw hi kr b fi lb ky l kz la">plotting = plt.imshow(b_image,cmap='gray')</span><span id="d332" class="kv kw hi kr b fi lb ky l kz la">plt.show()</span></pre><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/b6bc9a4ed7b5eb1e18410452bf152f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C0oFAcwK3pQbjH5cMQGIQA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用协同实验室生成的图像</figcaption></figure><p id="5af4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">安装pytesseract并将其导入colab:</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="3728" class="kv kw hi kr b fi kx ky l kz la">!pip install pytesseract</span><span id="cf36" class="kv kw hi kr b fi lb ky l kz la">!sudo apt install tesseract-ocr</span><span id="b661" class="kv kw hi kr b fi lb ky l kz la">import pytesseract</span></pre><h1 id="d075" class="ls kw hi bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">轮廓</h1><p id="8c2e" class="pw-post-body-paragraph iv iw hi ix b iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo mt jq jr js hb bi translated">图像上的轮廓连接具有相同强度的像素。这对二进制图像更有效。</p><p id="d8ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对具有水平线和垂直线的图像执行阈值处理。</p><p id="6665" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，用<strong class="ix hj"> cv2.findContours() </strong>识别轮廓。</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="a43a" class="kv kw hi kr b fi kx ky l kz la">contours, hierarchy = cv2.findContours(vertical_horizontal_lines, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span></pre><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es nk"><img src="../Images/f9a168d073ca9fbacc04c6108a61ac37.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*Vaa1cmGarOulq7K53LKwLg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用协同实验室生成的图像</figcaption></figure><h1 id="57f2" class="ls kw hi bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">边界框</h1><p id="1c67" class="pw-post-body-paragraph iv iw hi ix b iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo mt jq jr js hb bi translated">为各个轮廓创建边界框。</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="9d49" class="kv kw hi kr b fi kx ky l kz la">boundingBoxes = [cv2.boundingRect(c) for c in cnts]</span><span id="b79c" class="kv kw hi kr b fi lb ky l kz la">(contours, boundingBoxes) = zip(*sorted(zip(cnts, boundingBoxes),</span><span id="e792" class="kv kw hi kr b fi lb ky l kz la">key=lambda x:x[1][1]))</span></pre><p id="5fb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">获得表格中每个单元的所有边界框的高度列表和高度平均值。</p><p id="dd40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图像上的轮廓被绘制并存储在列表<strong class="ix hj">框</strong>中。它被存储为一个列表(x，y，w，h) : x和y是左上角的边界坐标，w和h分别是盒子的宽度和高度。</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="02d6" class="kv kw hi kr b fi kx ky l kz la">boxes = []</span><span id="7fa3" class="kv kw hi kr b fi lb ky l kz la">for contour in contours:</span><span id="05b5" class="kv kw hi kr b fi lb ky l kz la">    x, y, w, h = cv2.boundingRect(contour)</span><span id="828a" class="kv kw hi kr b fi lb ky l kz la">    if (w&lt;1000 and h&lt;500):</span><span id="f5df" class="kv kw hi kr b fi lb ky l kz la">        image = cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2)</span><span id="0a17" class="kv kw hi kr b fi lb ky l kz la">        boxes.append([x,y,w,h])</span><span id="05f8" class="kv kw hi kr b fi lb ky l kz la">plotting = plt.imshow(image,cmap='gray')</span><span id="0202" class="kv kw hi kr b fi lb ky l kz la">plt.title("Identified contours")</span><span id="6eba" class="kv kw hi kr b fi lb ky l kz la">plt.show()</span></pre><h2 id="05ad" class="kv kw hi bd lt mu mv mw lx mx my mz mb jg na nb mf jk nc nd mj jo ne nf mn ng bi translated">要存储行和列:</h2><ul class=""><li id="0790" class="le lf hi ix b iy mp jc mq jg nl jk nm jo nn js lj lk ll lm bi translated">现在行列列表被初始化为空。</li><li id="e01a" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">计算所有盒子的平均高度。</li><li id="7a6f" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">最初，第一个框被追加到列列表中。</li><li id="6ed8" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">列列表本质上是一个临时列表。</li><li id="6143" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">前一个框也被分配给第一个框。</li><li id="0f12" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">遍历剩余的边界框列表。</li><li id="6de2" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">在每次迭代中，检查当前框左上角的y坐标是否小于前一个框的y坐标加上所有高度平均值的一半。</li></ul><p id="d874" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">如果是:</strong></p><ul class=""><li id="7e4e" class="le lf hi ix b iy iz jc jd jg lg jk lh jo li js lj lk ll lm bi translated">当前框被追加到列列表中。</li><li id="f9e1" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">当前框被分配给上一个框。</li><li id="cce2" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">接下来检查我们是否在最后一个索引处。如果是:</li><li id="10d2" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">整列被追加到行列表中。</li></ul><p id="bee8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">如果没有:</strong></p><ul class=""><li id="e453" class="le lf hi ix b iy iz jc jd jg lg jk lh jo li js lj lk ll lm bi translated">列列表被追加到行中。</li><li id="c1b7" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">列列表被指定为空，因为这将启动一个新的空列列表。</li><li id="b22b" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">当前框被赋给前一个框变量。</li><li id="485a" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">当前框被追加到我们刚刚创建的空列列表中。</li></ul><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="a351" class="kv kw hi kr b fi kx ky l kz la">rows=[]</span><span id="6b29" class="kv kw hi kr b fi lb ky l kz la">columns=[]</span><span id="9a79" class="kv kw hi kr b fi lb ky l kz la">heights = [boundingBoxes[i][3] for i in range(len(boundingBoxes))]</span><span id="cae1" class="kv kw hi kr b fi lb ky l kz la">mean = np.mean(heights)</span><span id="36b4" class="kv kw hi kr b fi lb ky l kz la">print(mean)</span><span id="7b74" class="kv kw hi kr b fi lb ky l kz la">columns.append(boxes[0])</span><span id="bcd4" class="kv kw hi kr b fi lb ky l kz la">previous=boxes[0]</span><span id="979d" class="kv kw hi kr b fi lb ky l kz la">for i in range(1,len(boxes)):</span><span id="6551" class="kv kw hi kr b fi lb ky l kz la">    if(boxes[i][1]&lt;=previous[1]+mean/2):</span><span id="cf68" class="kv kw hi kr b fi lb ky l kz la">        columns.append(boxes[i])</span><span id="b30f" class="kv kw hi kr b fi lb ky l kz la">        previous=boxes[i]</span><span id="97fd" class="kv kw hi kr b fi lb ky l kz la">        if(i==len(boxes)-1):</span><span id="f4df" class="kv kw hi kr b fi lb ky l kz la">            rows.append(columns)</span><span id="b97f" class="kv kw hi kr b fi lb ky l kz la">    else:</span><span id="b899" class="kv kw hi kr b fi lb ky l kz la">        rows.append(columns)</span><span id="14f3" class="kv kw hi kr b fi lb ky l kz la">        columns=[]</span><span id="8703" class="kv kw hi kr b fi lb ky l kz la">        previous = boxes[i]</span><span id="01f2" class="kv kw hi kr b fi lb ky l kz la">        columns.append(boxes[i])</span><span id="a9ea" class="kv kw hi kr b fi lb ky l kz la">print("Rows")</span><span id="199e" class="kv kw hi kr b fi lb ky l kz la">for row in rows:</span><span id="aeff" class="kv kw hi kr b fi lb ky l kz la">    print(row)</span></pre><h2 id="1951" class="kv kw hi bd lt mu mv mw lx mx my mz mb jg na nb mf jk nc nd mj jo ne nf mn ng bi translated">让我们获取每行中的总单元格数:</h2><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="e9cb" class="kv kw hi kr b fi kx ky l kz la">total_cells=0</span><span id="8a55" class="kv kw hi kr b fi lb ky l kz la">for i in range(len(row)):</span><span id="9b27" class="kv kw hi kr b fi lb ky l kz la">    if len(row[i]) &gt; total_cells:</span><span id="b1ba" class="kv kw hi kr b fi lb ky l kz la">        total_cells = len(row[i])</span><span id="9f3d" class="kv kw hi kr b fi lb ky l kz la">print(total_cells)</span></pre><ul class=""><li id="e4fc" class="le lf hi ix b iy iz jc jd jg lg jk lh jo li js lj lk ll lm bi translated">单元格到左下角x坐标的宽度被加到单元格中心的x坐标上。</li></ul><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="60c6" class="kv kw hi kr b fi kx ky l kz la">center = [int(rows[i][j][0]+rows[i][j][2]/2) for j in range(len(rows[i])) if rows[0]]</span><span id="65dc" class="kv kw hi kr b fi lb ky l kz la">print(center)</span><span id="11c9" class="kv kw hi kr b fi lb ky l kz la">center=np.array(center)</span><span id="ac4c" class="kv kw hi kr b fi lb ky l kz la">center.sort()</span><span id="6909" class="kv kw hi kr b fi lb ky l kz la">print(center)</span></pre><p id="2f74" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们创建一个盒子的坐标列表:</p><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="0cf8" class="kv kw hi kr b fi kx ky l kz la">boxes_list = []</span><span id="e854" class="kv kw hi kr b fi lb ky l kz la">for i in range(len(rows)):</span><span id="2ed3" class="kv kw hi kr b fi lb ky l kz la">    l=[]</span><span id="b064" class="kv kw hi kr b fi lb ky l kz la">    for k in range(total_cells):</span><span id="eb80" class="kv kw hi kr b fi lb ky l kz la">        l.append([])</span><span id="908a" class="kv kw hi kr b fi lb ky l kz la">    for j in range(len(rows[i])):</span><span id="0b9e" class="kv kw hi kr b fi lb ky l kz la">        diff = abs(center-(rows[i][j][0]+rows[i][j][2]/4))</span><span id="80ff" class="kv kw hi kr b fi lb ky l kz la">        minimum = min(diff)</span><span id="ceff" class="kv kw hi kr b fi lb ky l kz la">        indexing = list(diff).index(minimum)</span><span id="561c" class="kv kw hi kr b fi lb ky l kz la">        l[indexing].append(rows[i][j])</span><span id="6671" class="kv kw hi kr b fi lb ky l kz la">    boxes_list.append(l)</span><span id="1df8" class="kv kw hi kr b fi lb ky l kz la">for box in boxes_list:</span><span id="daf0" class="kv kw hi kr b fi lb ky l kz la">    print(box)</span></pre><h2 id="9cef" class="kv kw hi bd lt mu mv mw lx mx my mz mb jg na nb mf jk nc nd mj jo ne nf mn ng bi translated">使用Pytesseract从图像的单元格中提取文本</h2><ul class=""><li id="7593" class="le lf hi ix b iy mp jc mq jg nl jk nm jo nn js lj lk ll lm bi translated">从图像中提取感兴趣区域。</li><li id="efa5" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">调整单元的大小，然后对提取的单元区域执行形态学操作以去除噪声。</li><li id="1996" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">最后，使用pytesseract将图像转换为字符串。</li><li id="8899" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">字符串被附加到每一行，首先是带有空格的临时字符串，然后我们将这个临时字符串附加到最终的数据帧。</li></ul><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="ac60" class="kv kw hi kr b fi kx ky l kz la">dataframe_final=[]</span><span id="e919" class="kv kw hi kr b fi lb ky l kz la">for i in range(len(boxes_list)):</span><span id="d1f1" class="kv kw hi kr b fi lb ky l kz la">    for j in range(len(boxes_list[i])):</span><span id="2aa9" class="kv kw hi kr b fi lb ky l kz la">    s=''</span><span id="e589" class="kv kw hi kr b fi lb ky l kz la">    if(len(boxes_list[i][j])==0):</span><span id="0fdc" class="kv kw hi kr b fi lb ky l kz la">        dataframe_final.append(' ')</span><span id="5370" class="kv kw hi kr b fi lb ky l kz la">    else:</span><span id="1af6" class="kv kw hi kr b fi lb ky l kz la">        for k in range(len(boxes_list[i][j])):</span><span id="f575" class="kv kw hi kr b fi lb ky l kz la">            y,x,w,h = boxes_list[i][j][k][0],boxes_list[i][j][k][1], boxes_list[i][j][k][2],boxes_list[i][j][k][3]</span><span id="5ebf" class="kv kw hi kr b fi lb ky l kz la">            roi = bitnot[x:x+h, y:y+w]</span><span id="61e5" class="kv kw hi kr b fi lb ky l kz la">            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 1))</span><span id="1b90" class="kv kw hi kr b fi lb ky l kz la">            border = cv2.copyMakeBorder(roi,2,2,2,2, cv2.BORDER_CONSTANT,value=[255,255])</span><span id="1e6e" class="kv kw hi kr b fi lb ky l kz la">            resizing = cv2.resize(border, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)</span><span id="37c6" class="kv kw hi kr b fi lb ky l kz la">            dilation = cv2.dilate(resizing, kernel,iterations=1)</span><span id="8060" class="kv kw hi kr b fi lb ky l kz la">            erosion = cv2.erode(dilation, kernel,iterations=2)</span><span id="5ee3" class="kv kw hi kr b fi lb ky l kz la">            out = pytesseract.image_to_string(erosion)</span><span id="1c7c" class="kv kw hi kr b fi lb ky l kz la">            if(len(out)==0):</span><span id="5f26" class="kv kw hi kr b fi lb ky l kz la">                out = pytesseract.image_to_string(erosion)</span><span id="be99" class="kv kw hi kr b fi lb ky l kz la">            s = s +" "+ out</span><span id="1985" class="kv kw hi kr b fi lb ky l kz la">        dataframe_final.append(s)</span><span id="6343" class="kv kw hi kr b fi lb ky l kz la">print(dataframe_final)</span></pre><h2 id="af32" class="kv kw hi bd lt mu mv mw lx mx my mz mb jg na nb mf jk nc nd mj jo ne nf mn ng bi translated">从生成的数据帧创建numpy数组</h2><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="2432" class="kv kw hi kr b fi kx ky l kz la">arr = np.array(dataframe_final)</span><span id="4f85" class="kv kw hi kr b fi lb ky l kz la">arr</span></pre><h1 id="0e23" class="ls kw hi bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">从数组创建数据帧</h1><ul class=""><li id="42ed" class="le lf hi ix b iy mp jc mq jg nl jk nm jo nn js lj lk ll lm bi translated">该数组被重新整形为具有行数和列数的数据帧。</li><li id="7e0d" class="le lf hi ix b iy ln jc lo jg lp jk lq jo lr js lj lk ll lm bi translated">打印出各列并检查！</li></ul><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="db7f" class="kv kw hi kr b fi kx ky l kz la">import pandas as pd</span><span id="c354" class="kv kw hi kr b fi lb ky l kz la">dataframe = pd.DataFrame(arr.reshape(len(rows), total_cells))</span><span id="886a" class="kv kw hi kr b fi lb ky l kz la">data = dataframe.style.set_properties(align="left")</span><span id="3a04" class="kv kw hi kr b fi lb ky l kz la">#print(data)</span><span id="b851" class="kv kw hi kr b fi lb ky l kz la">#print(dataframe)</span><span id="ba41" class="kv kw hi kr b fi lb ky l kz la">d=[]</span><span id="6454" class="kv kw hi kr b fi lb ky l kz la">for i in range(0,len(rows)):</span><span id="4069" class="kv kw hi kr b fi lb ky l kz la">    for j in range(0,total_cells):</span><span id="3493" class="kv kw hi kr b fi lb ky l kz la">        print(dataframe[i][j],end=" ")</span><span id="fabc" class="kv kw hi kr b fi lb ky l kz la">print()</span></pre><h2 id="e6b2" class="kv kw hi bd lt mu mv mw lx mx my mz mb jg na nb mf jk nc nd mj jo ne nf mn ng bi translated">最后一项任务是将这些数据保存为csv格式，以备将来使用。</h2><ul class=""><li id="384b" class="le lf hi ix b iy mp jc mq jg nl jk nm jo nn js lj lk ll lm bi translated">google colab中会生成一个output.csv文件，可以下载。</li></ul><pre class="ju jv jw jx fd kq kr ks kt aw ku bi"><span id="9924" class="kv kw hi kr b fi kx ky l kz la">dataframe.to_csv("output.csv")</span></pre><p id="a838" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是csv的样子！</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es no"><img src="../Images/97f93c2bebdee61658090cee6b1402bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*_LFHM92mTUn4bizisrS_Kg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用colaboratory，output.csv生成的图像</figcaption></figure><p id="0023" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个链接，链接到一个包含所有代码的colab笔记本。如果你觉得这个有用，请在我的github上留个星吧！</p><div class="jy jz ez fb ka kb"><a href="https://github.com/Soumi7/Table_Data_Extraction/blob/main/medium_table.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="kc ab dw"><div class="kd ab ke cl cj kf"><h2 class="bd hj fi z dy kg ea eb kh ed ef hh bi translated">Soumi7/Table_Data_Extraction</h2><div class="ki l"><h3 class="bd b fi z dy kg ea eb kh ed ef dx translated">GitHub是超过5000万开发人员的家园，他们一起工作来托管和审查代码，管理项目，以及…</h3></div><div class="kj l"><p class="bd b fp z dy kg ea eb kh ed ef dx translated">github.com</p></div></div><div class="kk l"><div class="np l km kn ko kk kp io kb"/></div></div></a></div><p id="d697" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我的github！</p><div class="jy jz ez fb ka kb"><a href="https://github.com/Soumi7" rel="noopener  ugc nofollow" target="_blank"><div class="kc ab dw"><div class="kd ab ke cl cj kf"><h2 class="bd hj fi z dy kg ea eb kh ed ef hh bi translated">Soumi7 -概述</h2><div class="ki l"><h3 class="bd b fi z dy kg ea eb kh ed ef dx translated">在GitHub上注册您自己的个人资料，这是托管代码、管理项目和构建软件的最佳地方…</h3></div><div class="kj l"><p class="bd b fp z dy kg ea eb kh ed ef dx translated">github.com</p></div></div><div class="kk l"><div class="nq l km kn ko kk kp io kb"/></div></div></a></div><p id="4ed2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是下一部分的视频，使用Flask创建web应用程序:</p><p id="efce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.youtube.com/watch?v=flZiBg4wd5k&amp;t=10s" rel="noopener ugc nofollow" target="_blank">发票数据提取|表格数据提取|图像到表格API | Flask — YouTube </a></p><h2 id="6d76" class="kv kw hi bd lt mu mv mw lx mx my mz mb jg na nb mf jk nc nd mj jo ne nf mn ng bi translated">参考</h2><div class="jy jz ez fb ka kb"><a href="https://docs.opencv.org/master/" rel="noopener  ugc nofollow" target="_blank"><div class="kc ab dw"><div class="kd ab ke cl cj kf"><h2 class="bd hj fi z dy kg ea eb kh ed ef hh bi translated">OpenCV: OpenCV模块</h2><div class="kj l"><p class="bd b fp z dy kg ea eb kh ed ef dx translated">docs.opencv.org</p></div></div><div class="kk l"><div class="nr l km kn ko kk kp io kb"/></div></div></a></div><div class="jy jz ez fb ka kb"><a href="https://pypi.org/project/pytesseract/" rel="noopener  ugc nofollow" target="_blank"><div class="kc ab dw"><div class="kd ab ke cl cj kf"><h2 class="bd hj fi z dy kg ea eb kh ed ef hh bi translated">宇宙魔方</h2><div class="kj l"><p class="bd b fp z dy kg ea eb kh ed ef dx translated">pypi.org</p></div></div><div class="kk l"><div class="ns l km kn ko kk kp io kb"/></div></div></a></div><div class="jy jz ez fb ka kb"><a href="https://towardsdatascience.com/a-table-detection-cell-recognition-and-text-extraction-algorithm-to-convert-tables-to-excel-files-902edcf289ec" rel="noopener follow" target="_blank"><div class="kc ab dw"><div class="kd ab ke cl cj kf"><h2 class="bd hj fi z dy kg ea eb kh ed ef hh bi translated">一个表格检测、单元格识别和文本提取算法，将表格转换为excel文件。</h2><div class="ki l"><h3 class="bd b fi z dy kg ea eb kh ed ef dx translated">如何使用OpenCV和pytesseract将表格截图转换成可编辑的数据</h3></div><div class="kj l"><p class="bd b fp z dy kg ea eb kh ed ef dx translated">towardsdatascience.com</p></div></div><div class="kk l"><div class="nt l km kn ko kk kp io kb"/></div></div></a></div></div></div>    
</body>
</html>