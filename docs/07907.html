<html>
<head>
<title>Predicting Diabetes Mellitus in Patients Using Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习预测患者的糖尿病</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-diabetes-mellitus-in-patients-using-machine-learning-3fcba3b86f60?source=collection_archive---------17-----------------------#2020-07-11">https://medium.com/analytics-vidhya/predicting-diabetes-mellitus-in-patients-using-machine-learning-3fcba3b86f60?source=collection_archive---------17-----------------------#2020-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f7d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">糖尿病，由高血糖引起的疾病，可分为1型和2型。</p><p id="747a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1型糖尿病通常在幼儿和青少年的早期诊断中被发现。然而，最近的证据表明，这种情况可以在任何年龄发生，因此所有年龄的人都容易发生。1型糖尿病是一种自身免疫性疾病，它导致胰腺中产生胰岛素的β细胞被清除，从而阻止身体产生足够水平的胰岛素来调节血糖水平。1型糖尿病的另一个术语是胰岛素依赖型糖尿病。</p><p id="5353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，二型糖尿病是普通人群中最常见的诊断，是一种导致高血糖的代谢紊乱。这通常是身体不能利用其产生的胰岛素或不能产生胰岛素的预测。</p><p id="c9b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着全球患者中糖尿病诊断的增长趋势，食品和媒体等行业显然存在一个不可克服的问题，即经常误导个人做出不良生活方式的决定，例如使用电视或广播制作不健康食品或饮料的广告，诱使人们做出不良决定。这并不是说偶尔吃一个汉堡不好，但是随着这些行业的发展频率和趋势，证据清楚地表明了问题的根源。</p><p id="e839" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到2040年，据估计，世界上被诊断患有糖尿病的患者人数将达到6.42亿，这一令人震惊的结果表明，每10个人中就有1个人将患有糖尿病。除了政府在糖尿病治疗上节省资金之外，对个人来说，采取健康的生活方式更有益，而不是等待这种诊断和治疗提供给患者。例如，英国的国民医疗服务体系每年花费至少100亿英镑用于治疗糖尿病患者。</p><p id="0f68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">机器学习技术可用于预测患者患糖尿病的可能性。在这篇文章中评估的技术将是逻辑回归模型，给出一个简单的概述。使用的数据集是皮马印第安人糖尿病数据集。</p><p id="458f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从导入我们通常的嫌疑人开始。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="766a" class="jm jn hi ji b fi jo jp l jq jr">#Importing our libraries</span><span id="5a5e" class="jm jn hi ji b fi js jp l jq jr">import pandas as pd<br/>import numpy as np<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="8ebd" class="jm jn hi ji b fi js jp l jq jr">import warnings<br/>warnings.filterwarnings('ignore')</span></pre><p id="9cae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们导入数据集</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="f88d" class="jm jn hi ji b fi jo jp l jq jr">#Importing our dataset</span><span id="e03b" class="jm jn hi ji b fi js jp l jq jr">diabetes = pd.read_csv('diabetes.csv')</span><span id="62b9" class="jm jn hi ji b fi js jp l jq jr">#We are investigating the dataset to see what columns we have available in our dataset</span><span id="2b4a" class="jm jn hi ji b fi js jp l jq jr">diabetes.head()</span></pre><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jt"><img src="../Images/b4c4915d769aa17df1b9ea4514fdc9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3KEINCIkkHjltYoi_xtFIw.png"/></div></div></figure><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="76b9" class="jm jn hi ji b fi jo jp l jq jr">#Here we will see how many rows and columns of data we have</span><span id="3ace" class="jm jn hi ji b fi js jp l jq jr">diabetes.shape</span></pre><p id="35a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果是包含变量的768行和9列。目标变量是结果。二元分类问题，0表示患者没有糖尿病，1表示有。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="484d" class="jm jn hi ji b fi jo jp l jq jr">diabetes.info()</span></pre><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kb"><img src="../Images/ab29da67f1a980cd99a038dc148fecee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWinWIhyZ3lBtapZ6UW7FQ.png"/></div></div></figure><p id="4dc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们研究了数据集中的数据类型，可以看到没有分类变量，否则在我们建模之前需要将其转换为虚拟变量。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="b6e6" class="jm jn hi ji b fi jo jp l jq jr">#We want to see if there any null values in our dataset</span><span id="5240" class="jm jn hi ji b fi js jp l jq jr">diabetes.isnull().sum()</span></pre><figure class="jd je jf jg fd ju er es paragraph-image"><div class="er es kc"><img src="../Images/e6dded90e333cd9a9f3fe75c1792f700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*_fzzA1CDQhul3S4fnV4jMw.png"/></div></figure><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="c5fa" class="jm jn hi ji b fi jo jp l jq jr">#We are going to investigate the variables in the chart that have the strongest correlation with each variable</span><span id="a57c" class="jm jn hi ji b fi js jp l jq jr">diabetes.corr()</span></pre><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kd"><img src="../Images/db6da3fb7bac7ba46d0e8d686ec2cc65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yMrXjYe4SJST-CJzfohK-A.png"/></div></div></figure><p id="1525" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们在数据集中看到的，最强的相关变量是:</p><ul class=""><li id="9364" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">身体质量指数对血压(0.281805)</li><li id="af8b" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">年龄与血压(0.239528)</li><li id="8559" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">结果与葡萄糖(0.466581)</li><li id="0d86" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">胰岛素v皮肤厚度(0.436783)</li><li id="3721" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">身体质量指数v皮肤厚度(0.392573)</li><li id="f668" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">葡萄糖对胰岛素(0.331357)</li></ul><p id="8d4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还想对我们的目标变量进行数值计算，看看是否有任何会影响我们数据的主要类别不平衡。在这种情况下，这不是一个主要的区别。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="0b3e" class="jm jn hi ji b fi jo jp l jq jr">#We are going to a value counts on our Outcome to see if there is a major class difference that may affect our results</span><span id="3c10" class="jm jn hi ji b fi js jp l jq jr">outcome_count = diabetes['Outcome'].value_counts()<br/>sns.barplot(outcome_count.index, outcome_count.values)</span><span id="2d5d" class="jm jn hi ji b fi js jp l jq jr">plt.title('Overall Outcome of Patients With or Without Diabetes')<br/>plt.xlabel('Outcome of Patients')<br/>plt.ylabel('Number of Diagnoses')</span><span id="0729" class="jm jn hi ji b fi js jp l jq jr">plt.style.use('seaborn')<br/>plt.show()</span></pre><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ks"><img src="../Images/2fbc15d126537979083f6ad4ac08881e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPyyOKE5OTQWHw1ytZxnCQ.png"/></div></div></figure><p id="673b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在做基线模型之前，我们需要创建我们的训练测试分割。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="0858" class="jm jn hi ji b fi jo jp l jq jr">Separating out test data<br/>y = diabetes[‘Outcome’]<br/>X = diabetes[[‘Pregnancies’, ‘Glucose’, ‘BP’, ‘Skin Thickness’, ‘Insulin’, ‘BMI’, ‘Diabetes Pedigree Function’, ‘Age’]]</span><span id="9693" class="jm jn hi ji b fi js jp l jq jr">#Creating our train test split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state=42)</span></pre><p id="89c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们可以进一步调查我们的数据的形状。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="0257" class="jm jn hi ji b fi jo jp l jq jr">print(f'My training data shape is {X_train.shape}')<br/>print(f'My final test data shape is {X_test.shape}')<br/>print(f'My training set dependant data shape is {y_train.shape}')<br/>print(f'My test set dependant shape is {y_test.shape}')</span></pre><p id="c813" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们分别得到的形状是:</p><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kt"><img src="../Images/38760dd49e3fc6b47d96fd37b2341bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_jZ5ieUQBzt5P9Ew4PFUQ.png"/></div></div></figure><p id="3010" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们将测试数据分成一个验证数据集时</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="1ee5" class="jm jn hi ji b fi jo jp l jq jr">X_train_v, X_val, y_train_v, y_val = train_test_split(X_train, y_train, test_size=0.2, random_state=50)</span></pre><p id="d582" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在需要使用标准缩放器来缩放数据。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="07e2" class="jm jn hi ji b fi jo jp l jq jr">#We are going to standardize our variables</span><span id="5a95" class="jm jn hi ji b fi js jp l jq jr">from sklearn.preprocessing import StandardScaler</span><span id="6750" class="jm jn hi ji b fi js jp l jq jr">#Instantiate the class<br/>ss = StandardScaler()</span><span id="ca97" class="jm jn hi ji b fi js jp l jq jr">#Fit the scaler on the training dataset<br/>ss.fit(X_train_v)</span><span id="ab82" class="jm jn hi ji b fi js jp l jq jr">#Transform all the datasets<br/>X_train_v = ss.transform(X_train_v)<br/>X_val = ss.transform(X_val)</span><span id="7a8c" class="jm jn hi ji b fi js jp l jq jr">X_test = ss.transform(X_test)</span></pre><h2 id="3421" class="jm jn hi bd ku kv kw kx ky kz la lb lc iq ld le lf iu lg lh li iy lj lk ll lm bi translated">逻辑回归</h2><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="27e0" class="jm jn hi ji b fi jo jp l jq jr">from sklearn.linear_model import LogisticRegression</span><span id="c9b7" class="jm jn hi ji b fi js jp l jq jr">model_log = LogisticRegression(penalty='l2', fit_intercept=True, solver='lbfgs', random_state = 45)<br/>model_log.fit(X_train_v, y_train_v)</span><span id="d6f3" class="jm jn hi ji b fi js jp l jq jr">y_train_pred_log = model_log.predict_proba(X_train_v)[:,1]</span><span id="40a4" class="jm jn hi ji b fi js jp l jq jr">print("ROC_AUC of training model = ", roc_auc_score(y_train_v, y_train_pred_log))</span></pre><p id="2a25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这为我们的训练数据提供了82.5%的分数。但是对我们更有用的是我们的验证数据。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="3e34" class="jm jn hi ji b fi jo jp l jq jr">y_val_pred_log = model_log.predict(X_val)</span><span id="c62c" class="jm jn hi ji b fi js jp l jq jr">print("Accuracy of validation model = ", accuracy_score(y_val,y_val_pred_log))</span><span id="e671" class="jm jn hi ji b fi js jp l jq jr">print("ROC_AUC of validation model = ", roc_auc_score(y_val, y_val_pred_log))</span></pre><p id="0db8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型的准确率为78.9%，ROC_AUC值为76.8%。ROC_AUC评分是一个很好的指标，因为它提供了结果为1的可能性的指示，即患者是否患有糖尿病。</p></div></div>    
</body>
</html>