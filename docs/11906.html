<html>
<head>
<title>Time-series forecasting using Spark ML: Part — 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spark ML进行时间序列预测:第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-forecasting-using-spark-ml-part-2-31506514c643?source=collection_archive---------0-----------------------#2020-12-23">https://medium.com/analytics-vidhya/time-series-forecasting-using-spark-ml-part-2-31506514c643?source=collection_archive---------0-----------------------#2020-12-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b50d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最后一部分，我们看了问题的基本公式和相关的数据集。我们还做了一些探索性的数据分析，验证了时间序列数据(股票价格)的<em class="jd">平稳性</em>。在这一部分中，我们将深入研究我们开发的使用Spark MLlib执行时序预测的类和实用函数的细节。</p><h1 id="5f6a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">代码描述</strong></h1><p id="8faa" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们开发了一些类和实用函数来执行时间序列分析。为了这项工作，这个包是用Python编写的。我们开发<em class="jd">我们自己的</em>功能工程时序包。<em class="jd">本作提到的代码完全是原创</em>。我们打算将这项工作作为一个机会，从零开始开发一个时间序列包，同时只利用Spark的内部数据结构和内置算法。对于较小的时间序列数据，我们根据<em class="jd"> statsmodels </em>包中提供的模型对我们的包的准确性进行了基准测试。我们还没有探索我们的包的计算效率和速度。我们打算在今后的工作中继续讨论这个问题。</p><p id="3043" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的时序包包含以下组件:</p><p id="9cbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类— <em class="jd"> LagGather，MovingAverageSmoothing，TrendGather </em></p><p id="5371" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">效用函数— <em class="jd">差异、预测、时间序列、检验平稳性、预测、保存预测</em></p><p id="80f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类LagGather、MovingAverageSmoothing和TrendGather可在文件<em class="jd">timeseriesfeaturesgenerator . py</em>中找到，函数Forecast、Difference、TimeSeriesSplit、CheckStationarity、Predict和SavePredictions可在文件<em class="jd"> forecast.py </em>中找到。</p><p id="0bc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">LagGather、MovingAverageSmoothing和TrendGather类本质上是变形金刚。他们转换数据，并生成可用于Spark机器学习算法的特征。我们将在下面的段落中通过示例详细描述每个类。</p><p id="401c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">班落后</em> </strong></p><p id="60c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该类有4个方法，即。setLagLength()、setInputCol()、transform()和getFeatureNames()。该类用于获取给定的<em class="jd">单变量</em>时间序列的时滞值。我们展示了下面的代码块，</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0864" class="kq jf hi km b fi kr ks l kt ku">class LagGather:</span><span id="89f9" class="kq jf hi km b fi kv ks l kt ku"># generates features for machine-learning<br/># previous time-step values are used as features</span><span id="1655" class="kq jf hi km b fi kv ks l kt ku">def __init__(self):</span><span id="b648" class="kq jf hi km b fi kv ks l kt ku"># this class has 2 data members<br/>self.nLags = 0<br/>self.FeatureNames = []</span><span id="2eec" class="kq jf hi km b fi kv ks l kt ku">def setLagLength(self, nLags):</span><span id="3b40" class="kq jf hi km b fi kv ks l kt ku"># this method sets the lag-length<br/># if we want only previous time-step as feature<br/># use lag-length = 1<br/># if we want more lagged time-steps as features<br/># set higher lag-length</span><span id="e6d9" class="kq jf hi km b fi kv ks l kt ku">self.nLags = nLags<br/>return self</span><span id="b1f8" class="kq jf hi km b fi kv ks l kt ku">def setInputCol(self, colname):</span><span id="ed0c" class="kq jf hi km b fi kv ks l kt ku">#sets the input col for which features are generated<br/># this identifies the univariate time-series on<br/># which machine-learning and forecasting is done</span><span id="7333" class="kq jf hi km b fi kv ks l kt ku">self.columnName = colname<br/>return self</span><span id="6d03" class="kq jf hi km b fi kv ks l kt ku">def transform(self, df):</span><span id="5ba4" class="kq jf hi km b fi kv ks l kt ku"># transforms the spark dataframe and creates columns<br/># that have time-lagged values<br/># columns generated as used as features in ML</span><span id="3b11" class="kq jf hi km b fi kv ks l kt ku">df = df.withColumn("Series",lit('Univariate'))<br/>mywindow = Window.orderBy("Series")</span><span id="f853" class="kq jf hi km b fi kv ks l kt ku">for i in range(self.nLags):<br/>    strLag = self.columnName+'_LagBy_'+str(i+1)<br/>    df = df.withColumn(strLag,lag(\<br/>                       df[self.columnName], i+1).over(mywindow))</span><span id="7d4d" class="kq jf hi km b fi kv ks l kt ku">    self.FeatureNames.append(strLag)</span><span id="4c67" class="kq jf hi km b fi kv ks l kt ku">df = df.drop("Series")<br/>return df</span><span id="8781" class="kq jf hi km b fi kv ks l kt ku">def getFeatureNames(self):</span><span id="bb5e" class="kq jf hi km b fi kv ks l kt ku"># this return the names of feature-columns that are<br/># generated by transform method</span><span id="7813" class="kq jf hi km b fi kv ks l kt ku">return self.FeatureNames</span></pre><p id="2360" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> setLagLength() </em>:</p><p id="f5d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法用于设置滞后长度。例如，我们需要先前的时间步长值，我们将滞后长度设置为1，如果我们需要先前时间步长之前的时间序列值，我们将滞后长度设置为2。</p><p id="71dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> setInputCol() </em>:</p><p id="d37a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此方法用于指定要执行延时操作的列。</p><p id="d3d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">变换()</em>:</p><p id="f30d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此方法返回一个值为滞后值的列。</p><p id="f3eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> getFeatureNames() </em>:</p><p id="795f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此方法返回新创建的包含时滞值的列的名称。</p><p id="2e7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用一个例子来演示这个类的工作方式。我们将这个转换应用到刚刚使用quandl包下载的apple_data。我们首先为下载的数据创建一个Spark数据帧。接下来，我们创建一个LagGather对象，并使用该对象转换Spark数据帧。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es kw"><img src="../Images/74c7b94205c09a69bef424615ff689a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*tfIbJ-WCruzYUwc1_qUFjg.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图3a。</strong>对苹果股价数据应用LagGather transformer。</figcaption></figure><p id="cf83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们看到，在转换apple_df数据帧时，我们创建了一个新列“Close_LagBy_1 ”,它包含滞后1个时间步长的列“Close”的值。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es kw"><img src="../Images/4198ed5ade12ab8bcdc2e5e0eea82c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*j5IIMo4-7m7EUAO1QdcNYg.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图3b。</strong>在<em class="le"> apple_df </em>数据帧的“关闭”列上应用LagGather transformer后，我们创建了一个新列“关闭_LagBy_1”</figcaption></figure><p id="95a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们看到列“Close_LagBy_1”包含以前的时间步长值(图3c)。对于第一行，这将是一个空值。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es kw"><img src="../Images/d1f4b7c428f8770011c4e8c3cec85b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*mETK71VgKEv7lXzHXazvpQ.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图3c。</strong>apple _ df上LagGather变换的结果</figcaption></figure><p id="b4be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，我们可以创建值滞后2、3或4个时间步长的列。接下来，我们继续上课。</p><p id="bc87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">类移动平均平滑</strong>:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="19c9" class="kq jf hi km b fi kr ks l kt ku">class MovingAverageSmoothing:<br/>    # this class is used for performing Moving-average smoothing</span><span id="4f31" class="kq jf hi km b fi kv ks l kt ku">    def __init__(self):<br/>        # this class has 2 data members<br/>        self.nLags= 0<br/>        self.FeatureNames = []<br/>        <br/>    def setLagLength(self, nLags):<br/>        # this sets the window size over which moving average is performed<br/>        self.nLags = nLags<br/>        return self<br/>    <br/>    def setInputCol(self, colname):<br/>        #this sets the time-series column on which <br/>        #moving-average is performed<br/>        self.columnName = colname<br/>        return self<br/>    <br/>    def transform(self, df):<br/>        # this transforms the spark dataframe (i.e time-series column)<br/>        # and creates column contain the moving-average over created <br/>        # time-window<br/>        mywindow = Window.rowsBetween(-self.nLags, 0)<br/>        strMovAvg = self.columnName+'_'\<br/>                    + str(self.nLags)+'_MovingAvg'<br/>        df = df.withColumn(strMovAvg,\<br/>                           avg(df[self.columnName]).over(mywindow))<br/>        self.FeatureNames.append(strMovAvg)<br/>        return df <br/>    <br/>    def getFeatureNames(self):<br/>        # this returns the name of feature-column <br/>        # created by transform method    <br/>        return self.FeatureNames</span></pre><p id="514f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MovingAverageSmoothing类生成包含窗口上移动平均值的列。</p><p id="be3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> setLagLength() </em>:</p><p id="346e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此方法设置移动平均值的窗口大小。窗口大小包括当前时间步长。因此，对于滞后长度1，我们对由先前时间步长值和当前时间步长值组成的两个值进行平均。</p><p id="468d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">变换()</em>:</p><p id="dc8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此方法生成一个列，其中包含的值是setLagLength()方法设置的大小窗口的移动平均值。</p><p id="6f36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> setInputCol() </em>:</p><p id="325e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此方法设置计算移动平均值的列。</p><p id="5ab8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> getFeatureNames() </em>:</p><p id="3517" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该方法获取新创建的包含移动平均值的列的名称。</p><p id="4051" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在包含先前时间步长值和当前时间步长值(滞后长度为1)的窗口上执行移动平均平滑。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es kw"><img src="../Images/36efe74f6989ef5dd25239e16a17b2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*XXU2ZU0uc14we239D_YQFA.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图3d。</strong>移动平均平滑，创建的列“Close_1_MovingAvg”具有窗口大小为2(滞后长度为1)的列“Close”的移动平均值</figcaption></figure><p id="c33b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们看另一个类TrendGather。此类用于查找单变量时间序列中的趋势。</p><p id="eff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">班婕</strong>:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="fad7" class="kq jf hi km b fi kr ks l kt ku">class TrendGather:<br/>    <br/>    # this class is used to find trend in time-series data<br/>    def __init__(self):<br/>        # this has 2 data members<br/>        self.nLags= 0 <br/>        self.FeatureNames= []<br/>        <br/>    def setLagLength(self, nLags):<br/>        # this sets the window-size over which trend is determined<br/>        self.nLags = nLags<br/>        return self<br/>    <br/>    def setInputCol(self, colname):<br/>        # this sets the time-series column for which trend is to be<br/>        # determined<br/>        self.columnName = colname<br/>        return self<br/>    <br/>    def transform(self, df):<br/>        # this transforms the spark-dataframe (i.e. time-series column)<br/>        # and generates column containing values +1, or -1 <br/>        # if current value &gt; time-lagged value then column-value = +1.0<br/>        # if current value &lt; time-lagged value then column-value = -1.0<br/>        df = df.withColumn("Series",lit('Univariate'))       <br/>        mywindow = Window.orderBy("Series")<br/>        for i in range(self.nLags):<br/>            strSign = self.columnName +'_Lag_'+str(i+1)+'_Sign'<br/>            df = df.withColumn(strSign,\<br/>                               signum((df[self.columnName] - \<br/>                                       lag(df[self.columnName],i+1)\<br/>                                       .over(mywindow))))<br/>            self.FeatureNames.append(strSign)<br/>        df = df.drop("Series")<br/>        return df<br/>    <br/>    def getFeatureNames(self):<br/>        # this returns name of feature generted by transform method<br/>        return self.FeatureNames</span></pre><p id="c682" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> setLagLength() </em>:</p><p id="1d53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该方法设置趋势计算的窗口大小。如果lag设置为1，则比较先前的时间步长值和当前的时间步长值，以确定是上升趋势还是下降趋势。</p><p id="80b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">变换()</em>:</p><p id="c8a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此方法生成一个包含趋势指示器值的列。趋势指示器值为+1.0或-1.0。上升趋势由+1.0表示，而-1.0表示下降趋势。</p><p id="84c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> setInputCol() </em>:</p><p id="998c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此方法设置确定趋势的列。</p><p id="d524" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> getFeatureNames() </em>:</p><p id="6349" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此方法获取新创建的包含趋势指标值的列的名称。</p><p id="641f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们获得滞后长度为1的趋势，这意味着我们比较以前的时间步长值和当前的时间步长值。如果当前时间步长值大于先前时间步长值，则我们得到+1.0，否则为-1.0。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es kw"><img src="../Images/b89a84633b020fdcee2fd18fb5bb886b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*EkFd-7gq47O6CZQGESDY3w.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图3e。</strong>获取前一个时间步长值和当前时间步长值之间的趋势</figcaption></figure><p id="169e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是对<strong class="ih hj">实用功能</strong>的描述:</p><p id="d2ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">差异</em>:</p><p id="c7c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该功能用于执行时差计算。进行时间差分是为了使序列平稳。我们不对时间序列进行任何其他的去趋势分析。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="bbd6" class="kq jf hi km b fi kr ks l kt ku">def Difference(df, inputCol, outputCol):<br/>    # performs first-order differencing<br/>    lag1Window = window.Window.rowsBetween(-1, 0)<br/>    df = df.withColumn(outputCol, \<br/>                       df[inputCol] -  func.first(df[inputCol]).over(lag1Window))<br/>    return df</span></pre><p id="69f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">预测</em>:</p><p id="ae6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是执行模型训练的主要功能。我们采用Spark的机器学习算法来执行回归。使用前面提到的类生成特征。我们使用具有不同时滞的值作为估计预测的特征。用户可以选择要执行的回归类型；选择是线性回归、决策树回归、随机森林回归和梯度推进树回归。我们使用RMSE作为评估指标。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5ae5" class="kq jf hi km b fi kr ks l kt ku">def Forecast(df, forecast_days, nLags, \<br/>                     timeSeriesColumn, regressor, sparksession):<br/> <br/>    # this performs model training<br/>    # this calls the machine-learning algorithms of Spark ML library</span><span id="7af5" class="kq jf hi km b fi kv ks l kt ku">    #creating labels for machine-learning<br/>    LeadWindow = window.Window.rowsBetween(0,forecast_days)   <br/>    df = df.withColumn("label",func.last(df[timeSeriesColumn]).over(LeadWindow))<br/>    <br/>    features = [timeSeriesColumn]<br/>    <br/>    #Auto-regression feature<br/>    LagTransformer = LagGather()\<br/>                     .setLagLength(nLags)\<br/>                     .setInputCol(timeSeriesColumn)<br/>    df = LagTransformer.transform(df)<br/>    featuresGenerated = LagTransformer.getFeatureNames()<br/>    features.extend(featuresGenerated)<br/>    <br/>    #Other feature generators here:<br/>    #Moving Average Smoothing<br/>    #TrendGather</span><span id="a850" class="kq jf hi km b fi kv ks l kt ku">    # VECTOR ASSEMBLER<br/>    # this assembles the all the features<br/>    df = df.dropna()<br/>    vA = VectorAssembler().setInputCols(features)\<br/>                          .setOutputCol("features")<br/>    df_m = vA.transform(df)</span><span id="890e" class="kq jf hi km b fi kv ks l kt ku">    # Splitting data into train, test<br/>    splitratio = 0.7<br/>    df_train, df_test = TimeSeriesSplit(df_m, splitratio, sparksession)</span><span id="37d7" class="kq jf hi km b fi kv ks l kt ku">    # DECISION-TREE REGRESSOR<br/>    if(regressor == "DecisionTreeRegression"):<br/>           <br/>        dr = DecisionTreeRegressor(featuresCol = "features",\<br/>                                   labelCol = "label", maxDepth = 5)<br/>        model = dr.fit(df_train)<br/>        predictions_dr_test = model.transform(df_test)<br/>        predictions_dr_train = model.transform(df_train)</span><span id="cbfe" class="kq jf hi km b fi kv ks l kt ku">        # RMSE is used as evaluation metric        <br/>        evaluator = RegressionEvaluator(predictionCol="prediction",\<br/>                                        labelCol="label",\<br/>                                        metricName ="rmse")<br/>        RMSE_dr_test = evaluator.evaluate(predictions_dr_test)<br/>        RMSE_dr_train = evaluator.evaluate(predictions_dr_train)<br/>        return (df_test, df_train, \<br/>                predictions_dr_test, predictions_dr_train,\<br/>                RMSE_dr_test, RMSE_dr_train)</span><span id="b9dd" class="kq jf hi km b fi kv ks l kt ku">    # LINEAR REGRESSOR<br/>    if(regressor == 'LinearRegression'):<br/>        lr = LinearRegression(featuresCol = "features", labelCol="label", \<br/>                              maxIter = 100, regParam = 0.4, \<br/>                              elasticNetParam = 0.1)<br/>        model = lr.fit(df_train)<br/>        predictions_lr_test = model.transform(df_test)<br/>        predictions_lr_train = model.transform(df_train)<br/>        <br/>        # RMSE is used as evaluation metric<br/>        evaluator = RegressionEvaluator(predictionCol="prediction",\<br/>                                        labelCol="label",\<br/>                                        metricName ="rmse")<br/>        RMSE_lr_test= evaluator.evaluate(predictions_lr_test)<br/>        RMSE_lr_train = evaluator.evaluate(predictions_lr_train)<br/>        return (df_test, df_train, \<br/>                predictions_lr_test, predictions_lr_train,\<br/>                RMSE_lr_test, RMSE_lr_train)<br/>    <br/>    # RANDOM FOREST REGRESSOR<br/>    if(regressor == 'RandomForestRegression'):<br/>        rfr = RandomForestRegressor(featuresCol="features",\<br/>                                    labelCol="label",\<br/>                                    maxDepth = 5,\<br/>                                    subsamplingRate = 0.8,\<br/>                                    )<br/>        model = rfr.fit(df_train)<br/>        predictions_rfr_test = model.transform(df_test)<br/>        predictions_rfr_train = model.transform(df_train)<br/>        <br/>        # RMSE is used as evaluation metric<br/>        evaluator = RegressionEvaluator(predictionCol="prediction",\<br/>                                        labelCol="label",\<br/>                                        metricName ="rmse")<br/>        RMSE_rfr_test= evaluator.evaluate(predictions_rfr_test)<br/>        RMSE_rfr_train = evaluator.evaluate(predictions_rfr_train)<br/>        return (df_test, df_train, \<br/>                predictions_rfr_test, predictions_rfr_train,\<br/>                RMSE_rfr_test, RMSE_rfr_train)<br/>    <br/>    # GRADIENT BOOSTING TREE REGRESSOR<br/>    if(regressor == 'GBTRegression'):<br/>        gbt = GBTRegressor(featuresCol="features",\<br/>                           labelCol="label",\<br/>                           maxDepth=5,\<br/>                           subsamplingRate=0.8)<br/>        <br/>        model = gbt.fit(df_train)<br/>        predictions_gbt_test = model.transform(df_test)<br/>        predictions_gbt_train = model.transform(df_train)<br/>        <br/>        # RMSE is used as evaluation metric<br/>        evaluator = RegressionEvaluator(predictionCol="prediction",\<br/>                                        labelCol="label",\<br/>                                        metricName ="rmse")<br/>        RMSE_gbt_test= evaluator.evaluate(predictions_gbt_test)<br/>        RMSE_gbt_train = evaluator.evaluate(predictions_gbt_train)<br/>        return (df_test, df_train, \<br/>                predictions_gbt_test, predictions_gbt_train,\<br/>                RMSE_gbt_test, RMSE_gbt_train)</span></pre><p id="5ec7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">时间序列片段:</p><p id="cfec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该功能用于将数据分为训练和测试数据。由于不能对时间序列数据执行随机分割，我们根据分割率将数据分割为训练和测试，使得训练数据包含较早的时间数据，而测试包含较晚的时间数据。例如，如果数据集包含100个样本，并且拆分比率为0.7，则训练数据包含前70个样本，测试数据包含接下来的30个样本。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="60d9" class="kq jf hi km b fi kr ks l kt ku">def TimeSeriesSplit(df_m, splitRatio, sparksession):<br/>     <br/>    # Splitting data into train and test<br/>    # we maintain the time-order while splitting<br/>    # if split ratio = 0.7 then first 70% of data is train data<br/>    # and remaining 30% of data is test data</span><span id="c836" class="kq jf hi km b fi kv ks l kt ku">newSchema  = StructType(df_m.schema.fields + \<br/>                [StructField(“Row Number”, LongType(), False)])<br/>    new_rdd = df_m.rdd.zipWithIndex().map(lambda x: list(x[0]) + [x[1]])<br/>    df_m2 = sparksession.createDataFrame(new_rdd, newSchema)<br/>    total_rows = df_m2.count()<br/>    splitFraction  =int(total_rows*splitRatio)<br/>    df_train = df_m2.where(df_m2[“Row Number”] &gt;= 0)\<br/>                   .where(df_m2[“Row Number”] &lt;= splitFraction)<br/>    df_test = df_m2.where(df_m2[“Row Number”] &gt; splitFraction)<br/>    <br/>    return df_train, df_test</span></pre><p id="b8fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">检查平稳性</em>:</p><p id="4ceb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这用于检查时间序列的平稳性。如果一个时间序列具有常数均值和常数方差，则称它是平稳的。我们使用包<em class="jd"> statsmodels </em>来执行增强的Dick-Fuller平稳性测试。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="51fb" class="kq jf hi km b fi kr ks l kt ku">def CheckStationarity(timeSeriesCol):<br/>    <br/>    # this function works with Pandas dataframe only not with spark dataframes<br/>    # this performs Augmented Dickey-Fuller's test<br/>    <br/>    test_result = adfuller(timeSeriesCol.values)<br/>    print(‘ADF Statistic : %f \n’ %test_result[0])<br/>    print(‘p-value : %f \n’ %test_result[1])<br/>    print(‘Critical values are: \n’)<br/>    print(test_result[4])</span></pre><p id="6c8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">预测</em>:</p><p id="9717" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数用于将差异预测转换为实际预测。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9130" class="kq jf hi km b fi kr ks l kt ku">def Predict(I, df1, df2, timeSeriesCol, predictionCol, joinCol):<br/>    <br/>    # this converts differenced predictions to raw predictions<br/>    dZCol = ‘DeltaZ’+str(i) <br/>    f_strCol = ‘forecast_’+str(i)+’day’<br/>    df = df1.join(df2, [joinCol], how=”inner”)\<br/>                            .orderBy(asc(“Date”))<br/>    df = df.withColumnRenamed(predictionCol, dZCol)<br/>    df = df.withColumn(f_strCol, col(dZCol)+col(timeSeriesCol))<br/>    return df</span></pre><p id="279b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">保存预测</em>:</p><p id="e226" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数调用forecast和predict函数，这些函数使用Spark ML执行机器学习。此外，此功能还用于对结果进行一些后处理，如更改列名、为预测创建新列、生成RMSE统计汇总并将结果保存在中。csv文件。</p><p id="71b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">功能保存预测所需的输入:</p><p id="bd68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.<em class="jd"> df </em>:包含股价数据的主火花数据帧</p><p id="d8fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<em class="jd"> timeSeriesCol </em>:用于预测的时间序列，这里是收盘日价，“收盘”栏</p><p id="69ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<em class="jd">回归类型</em>:机器学习算法的类型(线性回归、决策树回归、随机森林回归、gbt回归)</p><p id="247c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.<em class="jd"> forecast_days </em>:需要预测的未来时间步长(整数)</p><p id="0047" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.<em class="jd"> num_lags </em>:用作特征的先前时间步数(整数)</p><p id="899d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.<em class="jd">文件名</em>:保存结果的文件名，创建两个输出文件filenametest.csv和filenametrain.csv</p><p id="7d1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7.<em class="jd">火花时段</em>:当前火花时段</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8e66" class="kq jf hi km b fi kr ks l kt ku">def SavePredictions(df, \<br/>                    timeSeriesCol,\<br/>                    regressionType,\<br/>                    forecast_days, \<br/>                    feature_nLags,\<br/>                    filename, \<br/>                    sparksession):<br/>    <br/>    # this is the main function which calls forecast and predict<br/>    # this saves predictions in csv files<br/>    <br/>    #Differencing data to remove non-stationarity<br/>    diff_timeSeriesCol = "Diff_"+timeSeriesCol<br/>    df = Difference(df, timeSeriesCol,diff_timeSeriesCol)<br/>    <br/>    RMSE_test = {}<br/>    RMSE_train = {}<br/>    <br/>    #Forecasting and Undifferencing the data<br/>    for i in range(1, forecast_days+1):<br/>    <br/>        # training with Spark's ML algorithms    <br/>        df_test, df_train, \<br/>        predictions_test, predictions_train,\<br/>        RMSE_ts, RMSE_tr = \<br/>        Forecast(df.select("Date",timeSeriesCol,diff_timeSeriesCol),\<br/>                       i, feature_nLags, \<br/>                       diff_timeSeriesCol,regressionType, sparksession)</span><span id="05b6" class="kq jf hi km b fi kv ks l kt ku">RMSE_test.update({'forecast_'+str(i)+'day':RMSE_ts})<br/>        RMSE_train.update({'forecast_'+str(i)+'day':RMSE_tr})</span><span id="0f8f" class="kq jf hi km b fi kv ks l kt ku">#predictions for training data            <br/>        if(i == 1):<br/>            <br/>            #saving the 1-day forecast as separate column<br/>            corr_predict_train = Predict(i, <br/>                                                         df_train.select("Row Number",<br/>                                                                                 "Date",\<br/>                                                                                 timeSeriesCol),\<br/>                                                         predictions_train.select("Row Number",\<br/>                                                                                                "prediction"),<br/>                                                         timeSeriesCol,\<br/>                                                         "prediction",\<br/>                                                         "Row Number")<br/>            <br/>            corr_predict_test = Predict(i, \<br/>                                                        df_test.select("Row Number",\<br/>                                                                               "Date",\<br/>                                                                               timeSeriesCol),\<br/>                                                        predictions_test.select("Row Number",\<br/>                                                                                             "prediction"),<br/>                                                        timeSeriesCol,\<br/>                                                       "prediction",\<br/>                                                       "Row Number") <br/>        else:<br/>            # saving each subsequent forecast as separate column<br/>            strCol_prev= "forecast_" + str(i-1) + "day"</span><span id="ede9" class="kq jf hi km b fi kv ks l kt ku">corr_predict_train = Predict(i, \<br/>                                                         corr_predict_train,\<br/>                                                         predictions_train.select("Row Number",\<br/>                                                                                                "prediction"),\<br/>                                                         strCol_prev,\<br/>                                                         "prediction",\<br/>                                                         "Row Number")<br/>            corr_predict_test = Predict(i, \<br/>                                                        corr_predict_test,\<br/>                                                        predictions_test.select("Row Number",\<br/>                                                                                             "prediction"),\<br/>                                                        strCol_prev,\<br/>                                                        "prediction",\<br/>                                                        "Row Number")</span><span id="b0e2" class="kq jf hi km b fi kv ks l kt ku"># saving actual labels as separate columns<br/>        LeadWindow = window.Window.rowsBetween(0, i)    <br/>        a_strCol = "actual_"+str(i)+"day"<br/>        corr_predict_test = corr_predict_test.withColumn(\<br/>                                       a_strCol, \<br/>                                       func.last(corr_predict_test[timeSeriesCol])\<br/>                                              .over(LeadWindow))<br/>        corr_predict_train = corr_predict_train.withColumn(\<br/>                                         a_strCol, \<br/>                                         func.last(corr_predict_test[timeSeriesCol])\<br/>                                                .over(LeadWindow))</span><span id="49e1" class="kq jf hi km b fi kv ks l kt ku"># Saving data into csv files<br/>    corr_predict_test.write.format("csv").option("header","true")\<br/>                               .save(filename+"test.csv")<br/>    corr_predict_train.write.format("csv").option("header","true")\<br/>                                 .save(filename+"train.csv") <br/>    <br/>    #error statistics summary  <br/>    print("Error statistics summary for %s " %(filename))<br/>    print("RMSE for train data:\n")<br/>    print(RMSE_train)<br/>    print("RMSE for test data:\n")<br/>    print(RMSE_test)<br/>    print('Two output files created')<br/>    print('Predictions for train data: %s' %(filename+'train.csv'))<br/>    print('Predictions for test data: %s' %(filename +'test.csv'))<br/>    return RMSE_train, RMSE_test</span></pre><p id="9040" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong><br/><a class="ae lf" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.arima_model.ARIMA.html" rel="noopener ugc nofollow" target="_blank">https://www . stats models . org/dev/generated/stats models . TSA . ARIMA _ model。ARIMA.html</a><br/><a class="ae lf" href="https://people.duke.edu/~rnau/411diff.htm" rel="noopener ugc nofollow" target="_blank">https://people.duke.edu/~rnau/411diff.htm</a><br/><a class="ae lf" href="https://machinelearningmastery.com/time-series-data-stationary-python/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/time-series-data-stationary-python/</a><br/><a class="ae lf" href="https://en.wikipedia.org/wiki/Augmented_Dickey%E2%80%93Fuller_test" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Augmented _ Dickey % E2 % 80% 93 fuller _ test</a></p><h1 id="6b00" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">结果和可视化</strong></h1><p id="3c08" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们探索Spark ML库来执行时间序列预测。我们寻求一种形式的<em class="jd">自回归</em>模型，</p><p id="50f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Z(t+n) = f(Z(t)，Z(t-1)，Z(t-2) … Z(t-m)</p><p id="dee1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中Z(t+n)是n天预测值，即时间步长t+n，Z(t)是时间步长t的当前值，Z(t-m)是时间步长t-m的值(即滞后长度为m)。如前所述，Z(t)是通过差分(一阶差分)原始股票价格数据获得的。</p><p id="fe33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用线性回归、决策树回归、随机森林回归和梯度推进树回归对函数<em class="jd"> f </em>建模。我们进行1天、3天、5天和7天的预测。为了比较，我们使用非差异或原始股票价格数据重复预测。我们看到，使用差分训练数据做出的预测始终比使用原始训练数据做出的预测更好。</p><p id="6374" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工作代码的入口点是</p><p id="163a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.<em class="jd">main _ time series _ version 1 . py</em>(如果要使用quandl包)</p><p id="dfbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(或)</p><p id="589e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<em class="jd">main _ time series _ version 2 . py</em>(如果您想使用本地文件夹中的数据)</p><p id="ec52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里描述主要功能:</p><p id="5e98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">main _ time series _ version 1 . py</em></strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a50d" class="kq jf hi km b fi kr ks l kt ku">from pyspark.sql import window<br/>from pyspark.sql.functions import col, asc, desc, to_timestamp,\<br/>                                  unix_timestamp, from_unixtime<br/>from pyspark.sql.types import StructType, StructField, LongType<br/>import pyspark.sql.functions as func<br/>from pyspark.sql import SparkSession, SQLContext<br/>from pyspark import SparkConf<br/>from pyspark.ml.regression import LinearRegression, DecisionTreeRegressor<br/>from pyspark.ml.feature import VectorAssembler<br/>from pyspark.ml.evaluation import RegressionEvaluator<br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/>import numpy as np<br/>import quandl<br/>from forecast import Forecast, Difference, Predict, SavePredictions</span><span id="d3db" class="kq jf hi km b fi kv ks l kt ku">if __name__=="__main__":</span><span id="fb7f" class="kq jf hi km b fi kv ks l kt ku">#initializing local variables    <br/>    RMSE_train_df = pd.DataFrame()<br/>    RMSE_test_df = pd.DataFrame()<br/>    <br/>    #setting up spark environment and create spark session object<br/>    conf = SparkConf()<br/>    spark = SparkSession.builder.appName("TimeSeries").master("local")\<br/>                            .config(conf=conf).getOrCreate()<br/>    <br/>    #setting up authentication for quandl<br/>    quandl.ApiConfig.api_key = "***" # (get your own key!)                                 <br/>                      <br/>   <br/>    #obtaining data from Nasdaq.com<br/>    appl = quandl.get("WIKI/AAPL").reset_index()<br/>    fb = quandl.get("WIKI/FB").reset_index()<br/>    googl = quandl.get("WIKI/GOOGL").reset_index()<br/>    nflx = quandl.get("WIKI/NFLX").reset_index()</span><span id="922e" class="kq jf hi km b fi kv ks l kt ku">apple_data = spark.createDataFrame(appl)<br/>    fb_data = spark.createDataFrame(fb)<br/>    google_data = spark.createDataFrame(googl)<br/>    netflix_data = spark.createDataFrame(nflx)<br/>    <br/>    #Performing 1, 2, 3, 4, and 5-day forecasts <br/>    #Features used:<br/>    #Values at time-step t-3, t-2, t-1, t<br/>    <br/>    # setting up parameters for simulation<br/>    timeSeriesCol = "Close"<br/>    regressionType = "LinearRegression"<br/>    forecast_days = 5<br/>    num_lags = 3<br/>    <br/>    # Machine-learning and forecasting for Apple stock<br/>    RMSE_train, RMSE_test = SavePredictions(apple_data,                     timeSeriesCol,                                                             regressionType,                                                            forecast_days,                                                              num_lags,                                                                 "LR_ApplePredictions",                                                      spark)<br/>    RMSE_train_df = RMSE_train_df.append(RMSE_train, ignore_index = True) <br/>    RMSE_test_df = RMSE_test_df.append(RMSE_test, ignore_index = True)<br/>    <br/>    # Machine-learning and forecasting for Facebook stock<br/>    RMSE_train, RMSE_test = SavePredictions(fb_data,                        timeSeriesCol,                                                              regressionType,                                                             forecast_days,                                                               num_lags,                                                                    "LR_FacebookPredictions",                                                    spark)<br/>    RMSE_train_df = RMSE_train_df.append(RMSE_train, ignore_index = True) <br/>    RMSE_test_df = RMSE_test_df.append(RMSE_test, ignore_index = True)<br/>    <br/>    # Machine-learning and forecasting for Google stock<br/>    RMSE_train, RMSE_test = SavePredictions(google_data,timeSeriesCol,                    regressionType,                                                          forecast_days,                                                                 num_lags,"LR_GooglePredictions",                                                                    spark)</span><span id="7a1c" class="kq jf hi km b fi kv ks l kt ku">    RMSE_train_df = RMSE_train_df.append(RMSE_train, ignore_index = True) <br/>    RMSE_test_df = RMSE_test_df.append(RMSE_test, ignore_index = True)<br/> <br/>    # Machine-learning and forecasting for Netflix stock<br/>    RMSE_train, RMSE_test =  SavePredictions(netflix_data,                   timeSeriesCol,                                                               regressionType,                                                              forecast_days,                                                               num_lags,                                                                    "LR_NetflixPredictions",                                                     spark)<br/>    RMSE_train_df = RMSE_train_df.append(RMSE_train, ignore_index = True) <br/>    RMSE_test_df = RMSE_test_df.append(RMSE_test, ignore_index = True)<br/>    <br/>    #Saving RMSE statistics<br/>    RMSE_test_df['Ticker']= ['AAPL','FB','GOOGL','NFLX']<br/>    RMSE_train_df['Ticker']=['AAPL','FB','GOOGL','NFLX']<br/>    RMSE_test_df = RMSE_test_df.set_index('Ticker')<br/>    RMSE_train_df = RMSE_train_df.set_index('Ticker')<br/>    <br/>    fn = regressionType +'.csv'<br/>    RMSE_test_df.to_csv("RMSE_test_"+fn)<br/>    RMSE_train_df.to_csv("RMSE_train_"+fn)</span></pre><p id="5926" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所示，主程序调用“保存预测”。这个函数调用forecast和predict来进行机器学习和预测。预测的结果保存在中。csv文件。此外，函数“SavePredictions”返回用于预测的机器学习算法类型的错误统计的完整摘要。随着模拟的进行，总结也会打印在控制台上。图4a中的控制台显示了使用线性回归的包含所有四种股票的训练数据和测试数据的RMSE统计的典型输出。RMSE是针对差异数据的预测而计算的。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es lg"><img src="../Images/3a3ef6f5b118e3eebcfdc00aac683c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*yKq_XHCzkP-Qw2o-GNfXnQ.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图4a。</strong>线性回归的误差统计汇总，根据<em class="le">差异</em>数据计算预测RMSE</figcaption></figure><p id="58ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦模拟完成，它将生成4个文件夹，其中包含。csv文件。每个文件夹对应一种股票。我们提出了几个股票线性回归的代表性结果。全套结果可在Jupyter笔记本“<em class="jd">linearregressionresults . ipynb</em>”中找到。</p><p id="7b42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">main _ time series _ version 2 . py:</em></strong></p><p id="a421" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数与main_timeseries_verson1.py相同，只是我们不使用quandl来获取数据，而是读取保存在本地文件夹中的数据。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c637" class="kq jf hi km b fi kr ks l kt ku">#reading saved data from local folder<br/>    apple_data = spark.read.format("csv").option("inferSchema","true")\<br/>                      .option("header","true")\<br/>                      .load("./apple.csv")<br/>    fb_data =  spark.read.format("csv").option("inferSchema","true")\<br/>                      .option("header","true")\<br/>                      .load("./fb.csv")<br/>    google_data = spark.read.format("csv").option("inferSchema","true")\<br/>                      .option("header","true")\<br/>                      .load("./google.csv")<br/>    netflix_data = spark.read.format("csv").option("inferSchema","true")\<br/>                      .option("header","true")\<br/>                      .load("./netflix.csv")</span></pre><p id="d70e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">三天预测:</strong></p><p id="9327" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们看到3天预报也很好。不出所料，1天的预报比3天的预报要好。我们绘制了所有四只股票的3天预测，并将其与实际数据进行比较。</p><p id="a107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:我们没有测试数据中最后3个数据点的实际数据。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es lh"><img src="../Images/61d48ff30e0c67feb4f91d900879cd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*4zaqt6H0MC53NjlNqvhAWQ.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图4i。</strong>谷歌三天预测</figcaption></figure><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es li"><img src="../Images/bfd2fbd2b0604b85a124c75c82f2fe83.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*SW0KAZP_DQhH9GU1fxWeCg.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图4j。</strong>脸书三天预报</figcaption></figure><p id="3e63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 5天预报:</strong></p><p id="1972" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不出所料，5天预报不如1天和3天预报好。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es lj"><img src="../Images/e33ae28192a5c974cec6736d6ca67a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*etw5ZGZaKAsY1D6AJH-Xxw.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图4l。</strong>脸书五天预报</figcaption></figure><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es lk"><img src="../Images/f370072462e696967c2a74ac5b27df48.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*aaa2Xi8DqtdgRjpzZJsCQQ.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图4m。</strong>脸书五天天气预报</figcaption></figure><p id="7ff9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们尝试了其他回归方法，如决策树回归、随机森林回归和梯度推进树回归。</p><p id="cf3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有算法对1天的预测都表现良好。为了比较哪一个更好，我们在这里展示了脸书股票价格3天的不同机器学习算法的比较。</p><p id="4f3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">三天对比:</em></p><p id="63d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先比较实际的3天预测值、通过线性回归和决策树回归预测的3天预测值。在下面的三个图中(图4p、图4q和图4r)，实际的3天未来值用蓝点表示。我们做了一个简短的超参数调整，以获得最佳超参数。详细的超参数调整会给出更好的预测，但是非常耗时并且需要更高的计算能力。这些模型可以在以后进行调整以产生更好的结果。</p><p id="f543" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们观察到线性回归和随机森林回归在测试的算法中表现最好。梯度推进树回归和决策树回归显示出振荡，并且具有较差的预测。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es ll"><img src="../Images/752f29ed85dcba63b74e7a0365247abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*36cGBZPL8Uu183LKC2Uslw.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图4p。3天预测b/w线性回归和决策树回归的比较</strong></figcaption></figure><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es lm"><img src="../Images/05fcc773e80857651ff0e4504b117578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*YBUxRycHTXDdn1UNZanOfA.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图4q。3天预报b/w线性回归和随机森林的比较</strong></figcaption></figure><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es lm"><img src="../Images/6d54780b99b51c3a07d1fb32de745495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*yhhRtzUWTP4xodKId8-qbQ.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><strong class="bd jg">图4r。三天预报黑白线性回归和梯度推进树回归的比较</strong></figcaption></figure><p id="5d91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结:</strong></p><p id="3232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用Spark ML库进行时间序列预测。我们使用了4种机器学习算法，即线性回归、决策树回归、随机森林回归和梯度推进树回归，并对脸书、苹果、谷歌、网飞和微软的股价进行了1天、2天、6天的预测。我们观察到短期预测效果良好(使用之前的4个时间步长作为特征)，但是长期预测效果不佳。由于我们没有执行详细的超参数调整，我们可能没有获得最佳参数。此外，我们没有使用多项式特征和从先前时间步长的残差生成的特征(例如，ARIMA模型)。我们预计使用ARIMA模型中的特性会有更好的结果。此外，我们需要通过计算自相关函数和部分自相关函数来确定滞后特征的数量。为了保持分析的原创性，我们故意忽略了这些步骤，否则我们就会开发出另一个ARIMA模型。我们将滞后特征的数量视为超参数，并进行了简单的超参数调整。虽然这不是一个标准的方法，但我们想尝试一些新的东西。</p><p id="5b35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">经验教训:</strong></p><p id="7989" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们做了很多时间序列数据的统计分析。我们学习了如何对时间序列数据进行机器学习。我们还学会了从头开发一个python包。此外，我们还对Spark ML库中实现的算法有所了解</p></div></div>    
</body>
</html>