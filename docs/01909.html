<html>
<head>
<title>Storing Hierarchical Data in DynamoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在DynamoDB中存储分层数据</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/storing-hierarchical-data-in-dynamodb-fd7d73eb9250?source=collection_archive---------1-----------------------#2019-11-21">https://medium.com/analytics-vidhya/storing-hierarchical-data-in-dynamodb-fd7d73eb9250?source=collection_archive---------1-----------------------#2019-11-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c7b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我创建了一个需要在DynamoDB中存储树结构的应用程序。虽然我能够找到一些关于如何做到这一点的文章，但我找不到任何关于很好地解决了我的用例的解决方案的文档。这篇文章试图成为解决类似问题的未来灵魂的文档。本文还假设您具备DynamoDB的工作知识。</p><p id="46e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在设计任何DynamoDB表时，考虑您的查询模式是很重要的。在我的例子中，我需要高效的查询来获取给定节点的所有祖先及其所有后代。即给定下面的绿色节点“G ”,能够有效地返回所有用红色圈出的节点(祖先)和所有用蓝色圈出的节点(后代)。在这种情况下，高效意味着“请求数量不会随着树中节点数量的增加而增加。”此外，祖先和后代应该以一种可以重建树结构的方式返回。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/0eeebc2c461240985772124905f9de2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*yrp_PLaz45yNgn7OFQv_YA.jpeg"/></div></figure><p id="64b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，如果您正在阅读本文，并且认为您的访问模式需求是不同的，那么以不同的方式构建您的表可能会更好。存储每个节点的父节点、存储邻接表或存储嵌套集合都是存储这种数据的有据可查的方式，它们将容易地支持访问模式，例如检索给定节点的直接父节点和子节点。</p><p id="661d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还应该提到将要存储的树结构的一些附加要求。</p><ol class=""><li id="455f" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">数据库中可以有任意数量的不相交的树。</li><li id="1ef2" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">每棵树可以有任意的深度。</li><li id="598c" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">每个节点可以有任意数量的子节点。</li><li id="e8c2" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">当移动一个节点时，它的所有后代都应该随之移动。</li><li id="96b0" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">当删除一个节点时，该节点的所有子节点应该替换它，成为被删除节点的父节点的子节点。</li><li id="96e1" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">当根节点仍有子节点时，不能删除它们。</li><li id="49e4" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">虽然所有这些修改都必须是可能的，但是为了使祖先和后代查询高效，它们可能是昂贵的。</li></ol><h1 id="5d3b" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">第一种方法</h1><p id="d47d" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">因为数据库中可能有多个不相交的树，所以每个节点必须有一个treeId来标识它属于哪个树(还有其他方法，但是它们需要从树根开始的树遍历，这不满足有效读取的约束)。此外，treeId应该是全局二级索引(GSI)的分区键，以便可以在查询中用作键。这就需要GSI排序键来找出如何将查询从整棵树缩小到祖先和后代。</p><p id="1e75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我遇到的第一个有希望的方法是为每个节点存储左索引和右索引，其中左索引根据在树的DFS搜索中节点被触摸的第<em class="lc">个</em>时间增加，而右索引根据它被触摸的最后<em class="lc">个</em>时间增加。在上面的树中，这些索引如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ld"><img src="../Images/4bb238a48658255c58bb80a8559cf3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*qyOiksIwppRaG6K33B08JQ.jpeg"/></div></figure><p id="cecb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从此处，可以通过以下方式查询节点的所有祖先:</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="0e0a" class="lj ka hi lf b fi lk ll l lm ln">ancestors = SELECT *<br/>    WHERE treeId == this.treeId<br/>    AND leftIndex &lt; this.leftIndex<br/>    AND rightIndex &gt; this.rightIndex</span><span id="78cb" class="lj ka hi lf b fi lo ll l lm ln">descendants = SELECT *<br/>    WHERE treeId == this.treeId<br/>    AND leftIndex &gt; this.leftIndex<br/>    AND rightIndex &lt; this.rightIndex</span></pre><p id="04a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果使用关系数据库，这是可以的，但是像这样的查询在DynamoDB中是不可能的。使左索引和右索引成为复合GSI将不起作用，因为分区键已经被treeId占用。据我所知，没有什么聪明的方法既能在排序键中存储左索引和右索引，又能保留在单个索引上搜索大于/小于的能力。</p><p id="c051" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法对于修改树结构还有其他缺点。如果您希望将所有索引保持为整数，那么对树的一些修改将需要对大的子树进行昂贵的重新索引操作。如果你同意使用浮动作为指数，那么你可以减少一些成本，但代价是使用浮动和随之而来的所有问题。</p><h1 id="918b" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">更好的解决方案</h1><p id="a9b8" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我最终采用的方法涉及一个单独的GSI，分区键treeId和排序键是从根到节点的路径的连接。使用这种方法，上述树在表中可以表示为:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="acdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这个结构，给定一个节点，我们可以使用下面的(伪代码)高效地查询祖先和后代</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="948a" class="lj ka hi lf b fi lk ll l lm ln">ancestors = BatchGetItem(nodeIds = this.path.split(#))</span><span id="8d20" class="lj ka hi lf b fi lo ll l lm ln">descendants = Query<br/>    .withKeyCondition(treeId == this.treeId)<br/>    .withConditionExpression(path starts_with this.path)</span></pre><p id="1b35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这满足了我们两个的约束！我们可以有效地查询祖先和后代。并且可以通过查看每个返回节点的路径来重构树结构。</p><p id="3fca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新仍然非常昂贵，因为它要求我们潜在地重写大量的路径字段，但是我们不必重写不在被修改的节点下的节点的路径。此外，我们不必处理浮动:)</p></div></div>    
</body>
</html>