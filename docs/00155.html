<html>
<head>
<title>Connecting a Machine Learning Model to a Web Dashboard using Flask and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flask和React将机器学习模型连接到Web仪表板</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/connecting-a-machine-learning-model-to-a-web-dashboard-using-flask-and-react-3552c1cfc780?source=collection_archive---------0-----------------------#2018-10-23">https://medium.com/analytics-vidhya/connecting-a-machine-learning-model-to-a-web-dashboard-using-flask-and-react-3552c1cfc780?source=collection_archive---------0-----------------------#2018-10-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/63db4c592af9819946a07b5ed31064fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1X2wi57TLuaQtYJObPzbig.png"/></div></div></figure><p id="19ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">比方说，你一直在一台Jupyter笔记本上埋头研究你最新最棒的ML模型。它可以是scikit-learn线性回归模型、Keras卷积神经网络，甚至是spaCy命名的实体识别模型。</p><p id="f245" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这在笔记本中很好，但如果您想将其与一个光滑的web前端集成，用户可以上传文件或输入一些文本来训练或测试模型，该怎么办？如果您想要创建一个能够允许模型充分显示其功能的仪表板，该怎么办呢？</p><p id="494e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样做的好处是你有许多选择。我在这里介绍的只是一个选择，这是我根据自己的经验和对各种语言/框架的熟悉程度做出的选择。工作流程如下所示:</p><ol class=""><li id="edd9" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">使用Jupyter笔记本的灵活性和便利性来训练和调整模型(我将使用gensim库)。将最终的模型/辅助对象/转换后的数据保存到托管服务器的目录中。</li><li id="79a6" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">创建一个Python服务器(我将使用Flask)并为您想要的功能设置HTTP端点。从Jupyter导入您想要的功能。</li><li id="1fd7" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">创建一个web前端(我将使用create-react-app)，设计UI并定义将与后端通信的API调用。</li><li id="24e2" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">在本地主机上测试，在线部署(我将使用PythonAnywhere和Heroku)</li><li id="48c6" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi">???</li><li id="c601" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">利润？？</li></ol><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/2ab2f84d5e9fba65fcfc8fe022c8d8a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hlClAEwmv3WTdyGh.jpg"/></div></div></figure><p id="4b7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我应该提到，这个项目来自我的大会数据科学沉浸式顶点项目。我的<a class="ae ki" href="https://github.com/bookRa/capstoneEDA/blob/master/Technical_Report_Milestone_4.ipynb" rel="noopener ugc nofollow" target="_blank">模型</a>、<a class="ae ki" href="https://github.com/bookRa/abstractor_server" rel="noopener ugc nofollow" target="_blank">服务器</a>和<a class="ae ki" href="https://github.com/bookRa/abstractor" rel="noopener ugc nofollow" target="_blank">前端</a>的源代码可以在我的<a class="ae ki" href="https://github.com/bookRa" rel="noopener ugc nofollow" target="_blank"> github </a>上获得。请从那里分叉/克隆/跟随。</p><p id="db45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于这三个组件中的每一个都可以单独发表一篇博文，因此我将尝试给出它们的实际实现的粗略概述，并重点关注它们如何组合在一起。</p><h1 id="7fbe" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">模型</h1><p id="46a4" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">我的机器学习应用在<a class="ae ki" href="https://en.wikipedia.org/wiki/Topic_model" rel="noopener ugc nofollow" target="_blank">主题建模</a>领域，这是自然语言处理的一个迷人而重要的分支。我们如何训练计算机来总结一个非结构化的文本体，并根据它们的主题将文档的相似性联系起来？</p><p id="8e73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，我将使用来自流行库<a class="ae ki" href="https://radimrehurek.com/gensim/" rel="noopener ugc nofollow" target="_blank"> gensim </a>的强大的潜在狄利克雷分配(LDA)模型。</p><h1 id="ae4a" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">数据</h1><p id="0191" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated"><strong class="is hj">数据收集</strong></p><p id="2c4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将从科学期刊档案馆<a class="ae ki" href="https://arxiv.org/" rel="noopener ugc nofollow" target="_blank"> arXiv </a>搜集大约18000篇期刊摘要。都来自于stat.MachineLearning的范畴，为什么要挑一个来自同一个主题的主题建模语料库呢？为什么…当然是为了挑战！如果我的文档已经被分成生物、化学、计算机科学和经济学，那么说“正如你在这里看到的，我的LDA模型能够区分4个清晰描述的主题”可能有点琐碎此外，在现实生活的应用中，语料库经常有很大的重叠，真正的价值来自于透过表面的相似性来看它们之间真正的区别。</p><p id="0183" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要查看我如何调用arXiv的API的代码，请点击这里的<a class="ae ki" href="https://github.com/bookRa/capstoneEDA/blob/master/a_new_hope.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="9124" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">数据清理</strong></p><p id="4c8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要全面了解主题建模的文本处理，请查看我的<a class="ae ki" rel="noopener" href="/@omar.abdelbadie1/processing-text-for-topic-modeling-c355e907ab23">上一篇文章</a>。清理你的文字<em class="jo">非常重要！</em></p><h1 id="04de" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">拟合模型</strong></h1><p id="118b" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">gensim工作流程通常如下:</p><ol class=""><li id="d62f" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">收集、清理和标记你的语料库(同时删除停用词)。**可选* *使用短语器在语料库中查找常见的二元或三元(或多元)语法。</li><li id="86bd" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">创建一个映射文本-&gt; id的字典</li><li id="98dc" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用ids和基于您打算使用的模型选择的方法来生成语料库的数字表示。有些使用TF-IDF表示，有些(如LDA)使用纯字数统计，也称为BagOfWords。</li><li id="9fd2" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">选择你想要的题目数量[* *关键一步！**]适合。然后坐下来，看着话题滚滚而来。</li></ol><pre class="ke kf kg kh fd lm ln lo lp aw lq bi"><span id="2e68" class="lr kk hi ln b fi ls lt l lu lv"><em class="jo"># The raw documents: </em><br/>abstracts = pd.read_csv('./new_hope_data/arxiv_csML.csv')['summary']<br/>cleaned_texts = [prep_text(doc) for doc in abstracts] </span><span id="3a9c" class="lr kk hi ln b fi lw lt l lu lv">#see my prev post for explanation on prep_text()!</span><span id="18e7" class="lr kk hi ln b fi lw lt l lu lv"><em class="jo"># The gensim phraser I'm using</em><br/>bigrams= gensim.utils.SaveLoad.load('./the_data_strikes_back/bigram_phrases')<br/>bigram_texts= [bigrams[text] for text in cleaned_texts]</span><span id="4c9c" class="lr kk hi ln b fi lw lt l lu lv">dictionary = corpora.Dictionary(bigram_texts)</span><span id="320c" class="lr kk hi ln b fi lw lt l lu lv">bow = [dictionary.doc2bow(text) for text in bigram_texts] #bow = bagO'words</span><span id="9fb5" class="lr kk hi ln b fi lw lt l lu lv">my_lda = LdaModel(corpus=bow, num_topics=6, id2word=dictionary, alpha = 'asymmetric', eta=0.08)</span></pre><p id="2374" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，上面的代码是出于说明的目的。它会起作用，但不一定会产生一个伟大的模型。</p><p id="62e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在处理语料库方面还需要做更多的工作。具体来说，如果您查看字数分布，您会看到:</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/f9c32fdaf3505d3d91f21a552aaf5445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PucugVieqe-OpP5O6GOsfQ.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">x:语料库中的词频；y:字数</figcaption></figure><p id="d1fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在对最少和最常见的单词进行一些过滤后，我们可以获得一个更体面的分布，这将允许我们专注于为不同主题添加意义的单词。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/86bcf370f9c9ba68891c0f684370681e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JralGu1rYY27yr0HLagVA.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">这是更有价值的看看，并适合我们的模型。</figcaption></figure><p id="70a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种过滤，加上对我们的LDA参数的进一步修改，在运行<code class="du md me mf ln b">my_lda.show_topics()</code>之后可以产生以下主题:</p><pre class="ke kf kg kh fd lm ln lo lp aw lq bi"><span id="7e43" class="lr kk hi ln b fi ls lt l lu lv">[(0,<br/>  "gradient" + "optimization" + "sparse" + "solution" + "linear" + "convergence" + "rate" + "point" + "stochastic" + "signal"'),<br/> (1,<br/>  "deep_neural" + "neural_network" + "inference" + "state_art" + "datasets" + "accuracy" + "complex" + "kernel" + "representation" + "existing"'),<br/> (2,<br/>  "policy" + "attack" + "error" + "system" + "reinforcement_learning" + "setting" + "deep_learning" + "provide" + "test" + "behavior"'),<br/> (3,<br/>  "user" + "classifier" + "dataset" + "image" + "datasets" + "multiple" + "label" + "accuracy" + "representation" + "group"'),<br/> (4,<br/>  "node" + "representation" + "neural_network" + "space" + "layer" + "architecture" + "input" + "kernel" + deep" + image"'),<br/> (5,<br/>  "state" + "process" + "agent" + "bayesian" + "object" + "image" + "prior" + "dynamic" + "variable" + "observation"')]</span></pre><p id="14d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些是LDA模型中每个主题最具代表性的单词。如果您仔细观察，并使用<a class="ae ki" href="https://github.com/bmabey/pyLDAvis" rel="noopener ugc nofollow" target="_blank"> pyLDAvis </a>进行目视检查，您可以看到这些主题大致分为以下几个部分:</p><blockquote class="mg mh mi"><p id="06fc" class="iq ir jo is b it iu iv iw ix iy iz ja mj jc jd je mk jg jh ji ml jk jl jm jn hb bi translated">强化学习—策略、强化学习、代理</p><p id="f290" class="iq ir jo is b it iu iv iw ix iy iz ja mj jc jd je mk jg jh ji ml jk jl jm jn hb bi translated">梯度下降-梯度，收敛，优化，凸</p><p id="38d8" class="iq ir jo is b it iu iv iw ix iy iz ja mj jc jd je mk jg jh ji ml jk jl jm jn hb bi translated">神经网络(可以将cnn、、、GAN组合或拆分为两个)—深度神经网络、RNN、CNN、卷积、变分</p><p id="fd9c" class="iq ir jo is b it iu iv iw ix iy iz ja mj jc jd je mk jg jh ji ml jk jl jm jn hb bi translated">ML或“真实生活”数据集的医疗应用——患者、用户、建议、疾病、药物</p><p id="b5c5" class="iq ir jo is b it iu iv iw ix iy iz ja mj jc jd je mk jg jh ji ml jk jl jm jn hb bi translated">贝叶斯/概率方法和估计——贝叶斯、潜在变量/空间、蒙特卡罗、估计</p></blockquote><p id="68cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些只是粗略的估计。LDA不是一颗神奇的子弹:它经常会输出人类无法理解的主题。</p><p id="0cd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧…现在我们有一个可以接受的模型。现在我们想把它部署到网络上，让世界变得更美好！</p><p id="1587" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们想想我们想要什么…</p><h1 id="7a97" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">Web仪表板</h1><p id="aedc" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">Gensim有一些强大的功能，可以根据文档在模型空间中的相似性来比较文档(也就是它们的主题分布有多相似？).它还可以逐字分解主题在文档中的反映方式。让我们利用这一点，创建一个React控制面板，它将:</p><ul class=""><li id="5ed5" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn mm jv jw jx bi translated">取一个抽象输入(或任何输入)，</li><li id="80ab" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn mm jv jw jx bi translated">根据主题分布给单词涂色</li><li id="c846" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn mm jv jw jx bi translated">从我们的语料库中推荐<em class="jo"> n </em>个最相似的文档，供用户浏览/研究启迪。</li></ul><p id="10c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这很有用，对吧？我会用那个…:)</p><p id="df28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再说一遍，我不会在这里详述。我的客户端app是用<code class="du md me mf ln b">create-react-app</code>做的。假设你对ReactJS一无所知，你可以用任何你想要的框架或语言来制作这个应用。这里的钱$hot是在我们如何构造我们的HTTP调用，在我的例子中是使用<code class="du md me mf ln b">axios</code>，一个很好的npm包:</p><pre class="ke kf kg kh fd lm ln lo lp aw lq bi"><span id="4b7d" class="lr kk hi ln b fi ls lt l lu lv">import axios from "axios"</span><span id="4bc6" class="lr kk hi ln b fi lw lt l lu lv">let FLASK_URL = "http://localhost:5000" //the default port for Flask<br/>//after deploying flask app, change this to the URL</span><span id="b319" class="lr kk hi ln b fi lw lt l lu lv">let apiClass = {<br/>    // Allows us to submit a document with which to query the Model<br/>    postAbst: function(my_abst){<br/>        console.log("activating axios")<br/>        return axios.post(FLASK_URL+"/abst_subm", {<br/>            abstract: my_abst<br/>        })<br/>    },<br/>    // In case we don't have an abstract on hand, pull a random one!<br/>    getRandom: function(){<br/>        console.log("getting random")<br/>        return axios.get(FLASK_URL+"/get_rand_abst")<br/>    },<br/>    // We want to get similar documents to our abstract   <br/>    getSimilars: function(my_abst){<br/>        console.log("getting similars")<br/>        return axios.post(FLASK_URL+"/get_similars",{<br/>            abstract: my_abst<br/>        })<br/>    }}</span><span id="119a" class="lr kk hi ln b fi lw lt l lu lv">  export { apiClass }</span></pre><p id="7491" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些axios调用返回JavaScript承诺，解析后更新React应用程序的状态，从而更新适当的字段(下面是一些伪代码。对于真正的交易，<a class="ae ki" href="https://github.com/bookRa/abstractor/blob/master/src/App.js" rel="noopener ugc nofollow" target="_blank">这里是</a>的链接):</p><pre class="ke kf kg kh fd lm ln lo lp aw lq bi"><span id="ad9e" class="lr kk hi ln b fi ls lt l lu lv">When user has text in input field and clicks "submit":<br/>    handleClick function calls apiClass.postAbst(inputText)<br/>    .then(loads the json response into the app's "colorText" state property)<br/>    // The response is an with each word in the abstract and a number associated with its color (or -1 if it has no color)</span><span id="8c4e" class="lr kk hi ln b fi lw lt l lu lv">When state is updated:<br/>    React renders the "colorizedDisplay" area by mapping the array of tuples to &lt;span className={"topic_"tuple[1]}&gt;{tuple[0]}&lt;/span&gt;. The "topic_#" class id informs the color given by the css</span></pre><p id="17a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在一个基本的react应用程序中，管理组件状态和从状态进行渲染非常简单。实际上，棘手的部分是让Flask服务器提供前端使用的正确格式。事实上，现在让我们继续:</p><h1 id="7c8c" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">服务器后端</h1><p id="39fd" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">服务器的基本思想是，我们希望加载我们之前创建并保存在服务器内存中的模型和对象，以便当一个<code class="du md me mf ln b">request</code>出现时，我们调用我们的函数(将<code class="du md me mf ln b">request</code>作为输入)并返回一个可用的JSON对象，该对象将包含单词及其相关主题，以及文档的主题分布。此外，在一个单独的函数中，我们在语料库中查询LDA空间中最相似的文档:</p><pre class="ke kf kg kh fd lm ln lo lp aw lq bi"><span id="97db" class="lr kk hi ln b fi ls lt l lu lv">@app.route("/abst_subm", methods=['POST'])<br/>def about():<br/>    if request.method =='POST':<br/>        my_abst = request.get_json()['abstract'] <br/>        return colorize(my_abst) #colorize is a complicated function<br/>    else:<br/>        return "FLASK says: POST don't GET"</span><span id="54a4" class="lr kk hi ln b fi lw lt l lu lv">@app.route("/get_similars", methods=['POST'])<br/>def similars():<br/>   if request.method =='POST':<br/>        my_abst = request.get_json()['abstract']<br/>        q= get_similar_docs(my_abst)<br/>        results = display_similars(q)<br/>        print("results are: ", results)<br/>        return json.dumps(results)<br/>   else:<br/>        return "Nope nope nope"</span><span id="ad83" class="lr kk hi ln b fi lw lt l lu lv">@app.route("/")<br/>@app.route("/home")<br/>def hello():<br/>    return "Hello World"  @app.route("/get_rand_abst")</span><span id="9519" class="lr kk hi ln b fi lw lt l lu lv">def provide_rand():<br/>    return random.choice(all_abstracts)['summary']</span></pre><p id="3515" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">差不多就是这样。这篇文章是从高空鸟瞰的。要了解更多细节，请随时发表评论并查看GitHub repo。最终结果看起来像这样:</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/783ebd6e6e3c830d73aab667234529da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nm0P-J_KjQLl9o7DQWVkQ.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">主题建模仪表板</figcaption></figure><p id="ad23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Heroku上托管就像将使用create-react-app的GitHub repo链接到Heroku一样简单(自动或手动部署)</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/7464249cb68e864069ea961f79aa2f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/0*l3f6QtYMIWqRmGQf.jpg"/></div></div></figure><p id="55e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在PythonAnywhere上托管也很简单。你可以上传或者从GitHub克隆。然后用WSGI for Flask(或者你正在使用的任何服务器)调整一些设置。PythonAnywhere拥有<em class="jo">优秀的</em>文档，因此您遇到的任何问题都会得到充分解决。如果你想更快更少的麻烦，你可以考虑支付5美元的“黑客”级服务。</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="fd81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，我希望这篇文章能提供一些信息。它可以让您大致了解多语言全栈应用程序的不同部分如何协同工作(答案:RESTfully)。如果你想知道更多关于实现的细节，请查看源代码，有任何问题/建议请联系我。</p></div></div>    
</body>
</html>