<html>
<head>
<title>Parallelism(and concurrency) in Node.js and Python and Golang and comparison them — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js、Python和Golang中的并行性(和并发性)及其比较—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/parallelism-and-concurrency-in-node-js-and-python-and-golang-and-comparison-them-part-2-972b8a2e94b7?source=collection_archive---------10-----------------------#2020-04-05">https://medium.com/analytics-vidhya/parallelism-and-concurrency-in-node-js-and-python-and-golang-and-comparison-them-part-2-972b8a2e94b7?source=collection_archive---------10-----------------------#2020-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b009" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" rel="noopener" href="/@saeedoraji/parallelism-and-concurrency-in-node-js-and-python-and-golang-and-comparison-them-part-1-44c837988c43">在上一部分</a>中，我已经谈到了多线程和多处理(并行性和并发性)的基本术语，如果你失去了它，请首先阅读它，如果你已经了解线程、绿色线程、纤程线程、进程、处理器指令、共享内存、分布式内存、进程间通信和信号量等共享内存的保护方法，你可以跳过它继续阅读。</p><h1 id="0c39" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">node . js中的多线程和多处理</strong></h1><p id="0633" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">可能你会说Node.js是单线程，不支持并行，是的但不多。</p><p id="cadc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文的剩余部分，我将谈论这些主题:</p><ul class=""><li id="cd5e" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">事件循环</li><li id="fe20" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">libuv</li><li id="6500" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">Node.js是多线程还是单线程</li><li id="6948" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">串</li><li id="4c46" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">子进程</li><li id="c14e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">工作线程</li><li id="efde" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">泳池</li></ul><h2 id="3215" class="kv jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated">事件循环</h2><p id="26ca" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我确信你已经阅读了许多关于事件循环的文章，我想从不同的角度看它。</p><p id="2b90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个事件循环有三个部分，<strong class="ih hj">堆栈</strong>，<strong class="ih hj">延迟功能区</strong>，<strong class="ih hj">队列</strong>。</p><p id="110c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆栈用于逐行存储代码(不完全是行，可以是函数调用)</p><p id="745b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">假设这个代码:</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="c007" class="kv jf hi lo b fi ls lt l lu lv">1. let x = 10;</span><span id="c7f6" class="kv jf hi lo b fi lw lt l lu lv">2. console.log(x);</span><span id="645b" class="kv jf hi lo b fi lw lt l lu lv">3. let delayedResultWait = await delayedFunctionWait();</span><span id="1e1d" class="kv jf hi lo b fi lw lt l lu lv">4. console.log(delayedResultWait);</span><span id="3a2b" class="kv jf hi lo b fi lw lt l lu lv">5. delayedFunction(cb);</span><span id="8ac1" class="kv jf hi lo b fi lw lt l lu lv">6. console.log(“the end”);</span></pre><figure class="lj lk ll lm fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es lx"><img src="../Images/e3fec2c0dcc69ccbe02fe399fa7b306f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEX8CDPF9o5R7PIPtKszFA.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">事件循环</figcaption></figure><p id="0b79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆栈指针指向第一行，并将其移动到<strong class="ih hj">堆栈</strong>，然后立即执行，接着第二行将被移动，与第一行执行相同。它转到要执行的第三行，它是一个<strong class="ih hj">延迟函数</strong>，它移动到延迟函数区并等待完成(因为它是一个同步函数)，当结果准备好时，它移动到<strong class="ih hj">队列</strong>，事件循环检查堆栈，如果它是空的，从队列移动到堆栈执行。第四行与前两行相同。当第五行因为是延迟函数而移动到堆栈时，它将移动到相应的区域，现在它转向第六行以移动到堆栈来执行，它将立即运行，现在堆栈是空的在第五行完成后，它移动到队列并立即移动到堆栈，因为堆栈已经是空的。</p><h1 id="6f95" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">libuv</h1><p id="4225" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> <em class="mj">一个线程上一个循环</em> </strong></p><p id="4849" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">libuv使Node.js能够提供<code class="du mk ml mm lo b">event loop</code>。它是用C写的，也有其他的特性，<strong class="ih hj">线程池</strong>，<strong class="ih hj">子进程</strong>，<strong class="ih hj">异步</strong>就是其中的一些。有项目正在使用libuv，Kestrel(C# + libuv +。net core)、Racer(Ruby webserver)、uvloop(python asyncio)都可以提及。</p><h2 id="a0af" class="kv jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated"><strong class="ak">建筑</strong></h2><ul class=""><li id="1944" class="kh ki hi ih b ii kc im kd iq mn iu mo iy mp jc km kn ko kp bi translated">网络输入输出</li><li id="b62b" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">文件输入输出</li><li id="f9b6" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">线程和线程池<br/>libuv是单线程的。它将只为文件I/O创建线程池，这意味着主程序在单个线程中运行，如果有任何I/O请求，将在不同的线程中处理。文件I/O线程都在池中，每个池一次只能创建四个线程。但是不用担心，它可以由用户配置。</li><li id="364c" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">依赖于操作系统</li><li id="bd82" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">独立于操作系统</li></ul><h1 id="92cb" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Node.js是多线程还是单线程</h1><p id="2abe" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在<strong class="ih hj"> worker_threads </strong>到来之前，不可能在Node.js中创建线程。为什么我这样开始这一节？我想说Node.js在worker _ threas出现之前是一个单独的线程，这意味着用户无法创建线程，还记得之前的<a class="ae jd" rel="noopener" href="/@saeedoraji/parallelism-and-concurrency-in-node-js-and-python-and-golang-and-comparison-them-part-1-44c837988c43">部分</a>吗，线程的类型是什么？你还记得<strong class="ih hj">青丝</strong>吗？你不能在Node.js中创建线程，这意味着主机语言不支持它，但操作系统仍然支持本机线程，所以Node.js在后台创建了许多线程，正如你所知Javascript是异步的，你已经知道什么是事件循环，什么是事件循环部分？看上面！它有三个部分，其中之一是延迟函数区，当事件循环把一个函数放在那里时，意味着Node.js为它创建单独的线程。</p><h1 id="90ed" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">串</h1><p id="764c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">聚类是一个常见的术语，用于许多主题，如人工智能、机器学习。一般来说，它指的是将一些事情拆分为管理负载。</p><p id="23f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Node.js中的集群是一个<strong class="ih hj">节点实例</strong>，它可以创建多个工作线程，这些工作线程可以在不同的CPU内核上独立运行，而不会相互影响。这意味着它们中的每一个都有不同的事件循环和内存，是的，你不能在集群创建的工人之间共享内存。但是，仍然有两种方法可以通过主进程(创建工作进程的主进程)使工作进程相互通信:</p><ol class=""><li id="275b" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc mq kn ko kp bi translated">主进程监听特定的端口，工作进程可以向该端口发送数据。</li><li id="6561" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc mq kn ko kp bi translated">主进程创建一个套接字，并在各个进程之间共享它。</li></ol><figure class="lj lk ll lm fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mr"><img src="../Images/327ddd281dedb9f9bf189063507e4cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rGNqAlZFOmioxDK_nxwghg.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">工人被创造时的样子</figcaption></figure><p id="d47c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在图片中看到的:)，CPU有四个内核，当工作人员创建时，它被随机分配给每个内核。主进程也在随机内核中运行。</p><blockquote class="ms mt mu"><p id="ae0e" class="if ig mj ih b ii ij ik il im in io ip mv ir is it mw iv iw ix mx iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>如果主进程将被杀死，那么所有的工作进程都已经被关闭。</p><p id="8f7d" class="if ig mj ih b ii ij ik il im in io ip mv ir is it mw iv iw ix mx iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong> TCP连接在工作者之间共享。这意味着您可以在工人之间共享同一个端口。当您希望通过Http处理传入的请求时，它非常有用。</p></blockquote><h2 id="3238" class="kv jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated">什么时候可以使用集群？</h2><p id="dcc5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这个问题的最佳答案是:<strong class="ih hj">搬运货物</strong>，什么意思？</p><p id="dc64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您想要创建一个HttpServer。你需要什么？简单来说，通过<code class="du mk ml mm lo b">httpServer</code>导入<code class="du mk ml mm lo b">http</code>模块，创建服务器。当您运行代码时，它会创建一个节点实例，所有传入的请求都将在一个节点实例中处理。请求越来越多，越来越多，现在怎么办？您应该创建更多的实例来处理请求，并将它们全部放在负载平衡器<strong class="ih hj">下。Node.js让你的生活比<strong class="ih hj">集群</strong>更轻松。导入<code class="du mk ml mm lo b">Cluster</code>,然后派生并创建一些工人，并运行您的代码，它会自动由一个主进程管理，传入的请求会传播到工人。</strong></p><p id="1f3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用集群的另一个好例子是操纵数组。想象一下，你想对一个巨大的数组进行排序，有很多算法可以使用，其中之一是<strong class="ih hj">归并排序</strong>。在这种算法中，数组被分成更低的数组，然后每块数组一起进行二进制批量比较，这种比较一直保持到整个数组被合并。该数组将在主进程中加载，然后它会拆分并通过套接字传递给worker，每个worker对数组的一部分进行排序，并在从workers master收集的所有数据都将相互合并时传递给master。</p><h2 id="7043" class="kv jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated">你能创造多少工人？</h2><p id="ff91" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj">工作线程数量</strong>取决于<strong class="ih hj">CPU内核数量</strong>。这并不意味着您不能创建超过个内核，这是可能的，但效率不高。所以避免制造更多。</p><blockquote class="ms mt mu"><p id="9a38" class="if ig mj ih b ii ij ik il im in io ip mv ir is it mw iv iw ix mx iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>工人并行运行</p></blockquote><h1 id="4a44" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用群集</h1><figure class="lj lk ll lm fd ly"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">通过集群和工人对庞大的数组进行排序</figcaption></figure><blockquote class="ms mt mu"><p id="01b8" class="if ig mj ih b ii ij ik il im in io ip mv ir is it mw iv iw ix mx iz ja jb jc hb bi translated"><strong class="ih hj">注</strong>:工人做完后应该被杀死</p></blockquote><h2 id="2a07" class="kv jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated">可以使用群集的另一个例子是:</h2><ul class=""><li id="66c3" class="kh ki hi ih b ii kc im kd iq mn iu mo iy mp jc km kn ko kp bi translated">创建用于处理Http请求的负载平衡器</li><li id="c5e0" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">在大数组中寻找最大数</li><li id="9552" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">在大数组中搜索特定值</li><li id="62ca" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">很多这样的例子</li></ul><h1 id="46c4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">子进程</h1><p id="2484" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">此模块使您能够创建流程。不是指节点流程，可以是每个可以执行的流程，比如执行<code class="du mk ml mm lo b">python</code>或者<code class="du mk ml mm lo b">golang</code>流程。当然连<code class="du mk ml mm lo b">node.js</code>工艺都可以用它来做。这个模块将创建的所有进程都依赖于父进程，这意味着如果父进程将被终止，所有相应的进程也将被终止。</p><h2 id="324b" class="kv jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated"><strong class="ak">怎么用child_process写并行代码？</strong></h2><p id="5e0a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><code class="du mk ml mm lo b">child_process</code>有一个功能，你可以创建任何你想要的过程。<code class="du mk ml mm lo b">spawn</code>就是那个功能。参见示例:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="0fd9" class="kv jf hi lo b fi ls lt l lu lv">const { spawn } = require('child_process');</span><span id="b2ae" class="kv jf hi lo b fi lw lt l lu lv">// create bash process<br/>const ls = spawn('ls', ['-lh', '/usr']);</span><span id="3901" class="kv jf hi lo b fi lw lt l lu lv">//create python process <br/>const python = spawn('python', ['./p.py', 'whatever you want to pass as a swtich']);</span><span id="2160" class="kv jf hi lo b fi lw lt l lu lv">//create node process <br/>const ls = spawn('node', ['./p.js', 'as well python process']);<br/></span></pre><p id="5d7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">spawn有一个返回结果的回调函数。</p><p id="2f87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有一个调用<code class="du mk ml mm lo b">fork</code>的函数与<code class="du mk ml mm lo b">spawn</code>相同，只是有一点不同，它创建了一个节点实例，可以通过套接字与子进程通信。</p><p id="5315" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">举例:</strong></p><p id="aba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> parent.js </strong>长这样:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="a219" class="kv jf hi lo b fi ls lt l lu lv">const { fork } = require('child_process');</span><span id="95a5" class="kv jf hi lo b fi lw lt l lu lv">const p1 = fork('./p1.js');</span><span id="9295" class="kv jf hi lo b fi lw lt l lu lv">const p2 = fork('./p2.js');</span><span id="4279" class="kv jf hi lo b fi lw lt l lu lv">p1.send({msg: "this data sent from parent"});</span><span id="7c4c" class="kv jf hi lo b fi lw lt l lu lv">// message can send to p2 as well as p1<br/>// if p1 want to communicate to each other it can be done across parent process only</span><span id="c38e" class="kv jf hi lo b fi lw lt l lu lv">p1.on('message', console.log);</span><span id="c31b" class="kv jf hi lo b fi lw lt l lu lv">// after child process is finished, don't rememeber to kill it.<br/></span></pre><p id="f28c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> p1.js </strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="76e6" class="kv jf hi lo b fi ls lt l lu lv">console.log("p1");</span><span id="9465" class="kv jf hi lo b fi lw lt l lu lv">process.on('message', (msg) =&gt; {<br/>    console.log(msg, 'in p1')<br/>})</span><span id="1530" class="kv jf hi lo b fi lw lt l lu lv">process.send({msg: '' })</span></pre><p id="4ed9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> p2.js </strong>，还有p1或者任何你想要的，都可以放。</p><h1 id="da5f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">文章的其余部分…</h1><p id="c982" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">别担心！在下一部分中，我将深入探讨<code class="du mk ml mm lo b"><strong class="ih hj">worker_thread</strong></code>和<code class="du mk ml mm lo b"><strong class="ih hj">pool</strong></code>。我将向您展示如何创建线程和共享内存，并保护共享内存免受竞争情况的影响。</p><h1 id="3096" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">下下一个…部分</h1><p id="f406" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">本文分为五个部分:</p><ol class=""><li id="45d5" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc mq kn ko kp bi translated">并行性的基本术语—第1部分</li><li id="e6be" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc mq kn ko kp bi translated">Node.js中的并行性(和并发性)——第2部分–1</li><li id="72d0" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc mq kn ko kp bi translated">Node.js中的并行性(和并发性)——第2-2部分</li><li id="3c3e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc mq kn ko kp bi translated">Python中的并行性(和并发性)——第3部分</li><li id="b1b4" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc mq kn ko kp bi translated">Golang中的并行性(和并发性)第4部分</li><li id="8a07" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc mq kn ko kp bi translated">Node.js、Python和Golang中并行性(和并发性)的比较—第5部分</li></ol></div></div>    
</body>
</html>