<html>
<head>
<title>Getting Started with scikit-learn Pipelines for Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">scikit入门-用于机器学习的学习管道</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/getting-started-with-scikit-learn-pipelines-for-machine-learning-fa88efdca3b9?source=collection_archive---------9-----------------------#2020-03-26">https://medium.com/analytics-vidhya/getting-started-with-scikit-learn-pipelines-for-machine-learning-fa88efdca3b9?source=collection_archive---------9-----------------------#2020-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8024" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从头开始建造管道</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/971ec97e4c5efd943eb74401652fdc36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYywBmpCmmna_JlFf-NRrg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图片来源:<a class="ae jn" href="https://www.wocintechchat.com/blog/wocintechphotos" rel="noopener ugc nofollow" target="_blank">https://www.wocintechchat.com/blog/wocintechphotos</a></figcaption></figure><p id="52ab" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">(本帖中的所有代码也包含在<a class="ae jn" href="https://github.com/hoffm386/simple-sklearn-pipeline-example" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中。)</p><h1 id="5b3a" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">为什么要使用管道？</h1><p id="af36" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">使用<a class="ae jn" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>的典型整体机器学习工作流程如下所示:</p><ol class=""><li id="55b9" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated">将所有数据载入<code class="du lq lr ls lt b">X</code>和<code class="du lq lr ls lt b">y</code></li><li id="47d6" class="lh li hi jq b jr lu ju lv jx lw kb lx kf ly kj lm ln lo lp bi translated">使用<code class="du lq lr ls lt b">X</code>和<code class="du lq lr ls lt b">y</code>进行<a class="ae jn" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank">试运行分割</a>，生成<code class="du lq lr ls lt b">X_train</code>、<code class="du lq lr ls lt b">X_test</code>、<code class="du lq lr ls lt b">y_train</code>和<code class="du lq lr ls lt b">y_test</code></li><li id="e166" class="lh li hi jq b jr lu ju lv jx lw kb lx kf ly kj lm ln lo lp bi translated">在<code class="du lq lr ls lt b">X_train</code>上安装<a class="ae jn" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank">标准定标器</a>和<a class="ae jn" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html" rel="noopener ugc nofollow" target="_blank">简单估算器</a>等预处理程序</li><li id="23c6" class="lh li hi jq b jr lu ju lv jx lw kb lx kf ly kj lm ln lo lp bi translated">使用安装的预处理程序转换<code class="du lq lr ls lt b">X_train</code>，并执行任何其他预处理步骤(如删除列)</li><li id="d7e8" class="lh li hi jq b jr lu ju lv jx lw kb lx kf ly kj lm ln lo lp bi translated">创建各种模型，调整超参数，并选择一个适合预处理<code class="du lq lr ls lt b">X_train</code>和<code class="du lq lr ls lt b">y_train</code>的最终模型</li><li id="20b8" class="lh li hi jq b jr lu ju lv jx lw kb lx kf ly kj lm ln lo lp bi translated">使用安装的预处理程序转换<code class="du lq lr ls lt b">X_test</code>，并执行任何其他预处理步骤(如删除列)</li><li id="3f16" class="lh li hi jq b jr lu ju lv jx lw kb lx kf ly kj lm ln lo lp bi translated">在预处理的<code class="du lq lr ls lt b">X_test</code>和<code class="du lq lr ls lt b">y_test</code>上评估最终模型</li></ol><p id="24bf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面是遵循这些步骤的示例代码片段，使用了来自<a class="ae jn" href="https://college.cengage.com/mathematics/brase/understandable_statistics/7e/students/datasets/mlr/frames/frame.html" rel="noopener ugc nofollow" target="_blank">统计教科书</a>的<a class="ae jn" href="https://raw.githubusercontent.com/hoffm386/simple-sklearn-pipeline-example/master/antelope.csv" rel="noopener ugc nofollow" target="_blank">羚羊数据集</a>(“羚羊. csv”)。目标是根据成年羚羊数量、年降雨量和冬季严寒程度来预测春季小鹿的数量。这是一个非常小的数据集，应该仅用于示例目的！此示例跳过任何超参数调整，并在对预处理的测试数据进行评估之前，简单地对预处理的训练数据拟合普通的线性回归模型。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">没有管道的例子</figcaption></figure><p id="cdeb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">训练测试分割是机器学习工作流程中最重要的组成部分之一。它有助于数据科学家理解模型性能，尤其是在过度拟合方面。适当的训练-测试分离意味着我们必须对训练数据和测试数据分别执行预处理步骤，因此不会有信息从测试集“泄漏”到训练集中。</p><p id="f5f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是作为一个软件开发人员来看这段代码，一个问题立刻凸显出来:第4步和第6步实际上是一样的。到底干嘛了(不要重复自己)？！解决方案:管道。管道的设计完全避免了这个问题。您只需声明一次预处理步骤，然后就可以根据需要将它们应用于<code class="du lq lr ls lt b">X_train</code>和<code class="du lq lr ls lt b">X_test</code>。</p><h1 id="f857" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">首先，编写没有管道的代码</h1><p id="ccf3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">是的，你没看错。在您真正成为使用管道的专家之前，最好先写出重复/冗余版本的代码，然后重构代码以使用管道。如果您希望编写功能性管道代码，那么先返回并创建类似上面代码片段的东西！</p><h1 id="a978" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">第二，反复添加预处理步骤</h1><p id="8f90" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">管道产生的错误消息可能非常难以破译！因此，如果您一次添加多个步骤，并且出现问题，您将很难找出问题所在。一个更好的计划是一次添加一个步骤，并在进行过程中仔细检查它是否仍然有效。</p><p id="9ed6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我的一般策略是从任何有依赖关系的步骤开始，例如一个简单的估算器(因为如果有丢失的数据，其他预处理步骤可能会失败)。在这个示例中，让我们从OneHotEncoder开始。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="7148" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们放大一些细节。首先，<strong class="jq hj">装配</strong>(ML过程中的#3)。旧版本是:</p><pre class="iy iz ja jb fd mb lt mc md aw me bi"><span id="b869" class="mf kl hi lt b fi mg mh l mi mj">ohe = OneHotEncoder(sparse=False, handle_unknown="ignore")</span><span id="d579" class="mf kl hi lt b fi mk mh l mi mj">ohe.fit(X_train[["winter_severity_index"]])</span></pre><p id="3ff2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">新版本是:</p><pre class="iy iz ja jb fd mb lt mc md aw me bi"><span id="eee5" class="mf kl hi lt b fi mg mh l mi mj">pipe = Pipeline(steps=[<br/>    ("encode_winter", ColumnTransformer(transformers=[           <br/>        ("ohe", OneHotEncoder(sparse=False, handle_unknown="ignore"), ["winter_severity_index"])<br/>    ], remainder="passthrough"<br/>))])<br/>pipe.fit(X_train, y_train)</span></pre><p id="ebfd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们仍然有相同的编码器和相同的参数，但是现在它嵌套在ColumnTransformer中，column transformer嵌套在管道中。我们没有用子集化<code class="du lq lr ls lt b">X_train</code>(用<code class="du lq lr ls lt b">[[]]</code>)来指定哪些列要进行一键编码，而是将它传递给ColumnTransformer。(参见<a class="ae jn" href="https://towardsdatascience.com/using-columntransformer-to-combine-data-processing-steps-af383f7d5260" rel="noopener" target="_blank">这篇来自我以前的学生Allison Honold的文章</a>，了解更多关于ColumnTransformers的细节。)然后，我们不直接使用编码器，而是将其添加为流水线的第一个“步骤”。</p><p id="265c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第二，<strong class="jq hj">转换</strong>(ML过程中的#4和#6)。旧版本是:</p><pre class="iy iz ja jb fd mb lt mc md aw me bi"><span id="f12d" class="mf kl hi lt b fi mg mh l mi mj">train_winter_array = ohe.transform(X_train[["winter_severity_index"]])</span><span id="31bc" class="mf kl hi lt b fi mk mh l mi mj">train_winter_df = pd.DataFrame(train_winter_array, index=X_train.index)</span><span id="5f33" class="mf kl hi lt b fi mk mh l mi mj">X_train = pd.concat([train_winter_df, X_train], axis=1)</span><span id="4bd5" class="mf kl hi lt b fi mk mh l mi mj">X_train.drop("winter_severity_index", axis=1, inplace=True)</span><span id="27ce" class="mf kl hi lt b fi mk mh l mi mj">test_winter_array = ohe.transform(X_test[["winter_severity_index"]])</span><span id="394f" class="mf kl hi lt b fi mk mh l mi mj">test_winter_df = pd.DataFrame(test_winter_array, index=X_test.index)</span><span id="c0ab" class="mf kl hi lt b fi mk mh l mi mj">X_test = pd.concat([test_winter_df, X_test], axis=1)</span><span id="50ec" class="mf kl hi lt b fi mk mh l mi mj">X_test.drop("winter_severity_index", axis=1, inplace=True)</span></pre><p id="5b31" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">新版本是:</p><pre class="iy iz ja jb fd mb lt mc md aw me bi"><span id="2585" class="mf kl hi lt b fi mg mh l mi mj">columns_with_ohe = [0, 1, 2, 3, "adult_antelope_population", "annual_precipitation"]</span><span id="6053" class="mf kl hi lt b fi mk mh l mi mj">X_train_array = pipe.transform(X_train)</span><span id="df15" class="mf kl hi lt b fi mk mh l mi mj">X_train = pd.DataFrame(X_train_array, columns=columns_with_ohe)</span><span id="c366" class="mf kl hi lt b fi mk mh l mi mj">X_test_array = pipe.transform(X_test)</span><span id="3b8a" class="mf kl hi lt b fi mk mh l mi mj">X_test = pd.DataFrame(X_test_array, columns=columns_with_ohe)</span></pre><p id="ff61" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如您所见，我们已经从使用管道中获得了一些好处。我们不再需要手动连接编码数据和原始数据，或者手动删除原始列。</p><p id="c800" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，在这一点上，我们有一点“黑”，我们是硬编码的列名，以便后面的代码能够工作。为了创建“低降水量”列，我们需要“年降水量”列的名称，但是一次性编码已经删除了所有的列名称。让我们继续将预处理步骤添加到管道中，并确保在自定义转换之后进行一次性编码<em class="ml">，这样我们就不再需要这种“黑客”了。</em></p><h1 id="f078" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">第三，根据需要创建自定义变压器</h1><p id="0cd4" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">出于功能工程的目的，我们经常希望使用Pandas来做一些不太常见的任务，以便像OneHotEncoder一样作为scikit-learn预处理器来包含。要在管道中实现这一点，您需要创建一个定制的transformer类。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="edf4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">再看具体的，老版的<strong class="jq hj">装</strong>就是……什么都没有。我们没有使用任何有关训练数据的信息来执行转换。旧版本的<strong class="jq hj">改造</strong>为:</p><pre class="iy iz ja jb fd mb lt mc md aw me bi"><span id="8409" class="mf kl hi lt b fi mg mh l mi mj">X_train["low_precipitation"] = [int(x &lt; 12) for x in X_train["annual_precipitation"]]</span><span id="eaa1" class="mf kl hi lt b fi mk mh l mi mj">X_test["low_precipitation"] = [int(x &lt; 12) for x in X_test["annual_precipitation"]]</span></pre><p id="d7b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">拟合和变换</strong>的新版本是我们增加了一个新的类沉淀变换器:</p><pre class="iy iz ja jb fd mb lt mc md aw me bi"><span id="a7de" class="mf kl hi lt b fi mg mh l mi mj">class PrecipitationTransformer(BaseEstimator, TransformerMixin):<br/>    def fit(self, X, y):<br/>        return self<br/>    def transform(self, X, y=None):<br/>        X_new = X.copy()<br/>        X_new["low_precipitation"] = [int(x &lt; 12) for x in X_new["annual_precipitation"]]<br/>        return X_new</span></pre><p id="2949" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以及管道中的一个“步骤”:</p><pre class="iy iz ja jb fd mb lt mc md aw me bi"><span id="fce9" class="mf kl hi lt b fi mg mh l mi mj">...<br/>("transform_precip", PrecipitationTransformer()),<br/>...</span></pre><p id="cde6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不算短，但确实避免了重复！</p><h1 id="ff34" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">第四，加入你的模型</h1><p id="4ce3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我认为，作为最后一步添加模型是管道真正闪光的地方。添加它的方式与添加预处理步骤的方式相同:</p><pre class="iy iz ja jb fd mb lt mc md aw me bi"><span id="561a" class="mf kl hi lt b fi mg mh l mi mj">...<br/>("linreg_model", LinearRegression())<br/>...</span></pre><p id="0162" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是最终的工作流程。我们在某种程度上减少了代码行数，但更重要的是我们不再重复任何东西！</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="6002" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">查看前面提到的关于ColumnTransformers 的<a class="ae jn" href="https://towardsdatascience.com/using-columntransformer-to-combine-data-processing-steps-af383f7d5260" rel="noopener" target="_blank">博客文章，scikit-learn的</a><a class="ae jn" href="https://scikit-learn.org/stable/auto_examples/compose/plot_column_transformer_mixed_types.html" rel="noopener ugc nofollow" target="_blank">这个例子</a>，或者<a class="ae jn" href="https://towardsdatascience.com/custom-transformers-and-ml-data-pipelines-with-python-20ea2a7adb65" rel="noopener" target="_blank">这个中型文章</a>以获得更高级的例子。</p><p id="d288" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢您的阅读，如果您有任何问题，请在评论中告诉我！</p></div></div>    
</body>
</html>