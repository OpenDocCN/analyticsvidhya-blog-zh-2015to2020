<html>
<head>
<title>The First Few Lines of Arrays in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">锈中数组的前几行</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-first-few-lines-of-arrays-in-rust-b5d181b357a4?source=collection_archive---------13-----------------------#2020-03-14">https://medium.com/analytics-vidhya/the-first-few-lines-of-arrays-in-rust-b5d181b357a4?source=collection_archive---------13-----------------------#2020-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/295d4c2a2952415f0f9864c98e62df10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jx4BQJUo-ovhZuUBpiu9Ag.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">paweczerwi ski在<a class="ae iu" href="https://unsplash.com/s/photos/array?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="iv iw ix"><p id="d6ff" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="hi">一个固定大小的数组，表示为[T；N]，用于元素类型T，以及非负的编译时常量大小n</em></p></blockquote><p id="40bf" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这是你在Rust中阅读关于<a class="ae iu" href="https://doc.rust-lang.org/std/primitive.array.html" rel="noopener ugc nofollow" target="_blank"> <em class="ja">数组</em> </a>类型文档的前几行时所发现的。</p><p id="ebfd" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">让我们一点一点地检查这个。<br/>首先，我们有以下内容</p><blockquote class="iv iw ix"><p id="f811" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="hi">固定大小的数组… </em></p></blockquote><p id="d10a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">好了，现在我们知道数组在内存中永远不会增长或收缩。如果你创建了一个能够容纳5个类型为<em class="ja"> bool </em>的元素的数组，它将永远是一个可以容纳5个<em class="ja">bool</em>的数组。</p><p id="f868" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们继续寻找描述</p><blockquote class="iv iw ix"><p id="4a62" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">…表示为[T；N]</p></blockquote><p id="349c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><em class="ja">【T；告诉我们声明数组时使用的格式。<br/>不过是<em class="ja"> T </em>和<em class="ja"> N </em>？</em></p><blockquote class="iv iw ix"><p id="1406" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">…对于元素类型，T</p></blockquote><p id="5c7d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><em class="ja"> T </em>表示数组元素的类型。如果我们想在数组中存储数字，那么<em class="ja"> T </em>可以<em class="ja"> </em>引用<em class="ja"> i32 </em>中的Rust、<em class="ja">【i32；n】。为了更好地理解，我们需要阅读下一部分</em></p><blockquote class="iv iw ix"><p id="5215" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">…以及非负的编译时常量大小n。</p></blockquote><p id="0cea" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><em class="ja"> N </em>代表我们数组的大小，文档中提到了<em class="ja"> N </em>必须遵循的两条规则。</p><p id="2796" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj">第一条规则<br/> </strong> <em class="ja"> N </em>需要是非负数。让我们违反规则，看看会发生什么:-)</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="f47c" class="kj kk hi kf b fi kl km l kn ko">let array_with_negative_size: [i32; -3];</span></pre><p id="1e76" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这会产生编译器错误</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="c375" class="kj kk hi kf b fi kl km l kn ko">error[E0600]: cannot apply unary operator `-` to type `usize`</span></pre><p id="90c5" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">有了这个错误，我们可以看到编译器期望<em class="ja"> usize </em>作为<em class="ja"> N的类型。</em>类型<em class="ja"> usize </em>代表一个无符号整数，所以它永远不能小于<em class="ja"> 0 </em>。</p><p id="f6a8" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj">第二个规则<br/> </strong> <em class="ja"> N </em>需要是一个编译时常数。如果用于<em class="ja"> N </em>的what ever表达式不可替换为常数值，则规则被破坏。</p><p id="fa92" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这里我们尝试使用传递给函数的参数<em class="ja"> n </em>作为<em class="ja"> N. </em>的值</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="cd80" class="kj kk hi kf b fi kl km l kn ko">fn compile_time_array_size(n: usize) {<br/>  let array_with_positive_size: [i32; n];<br/>}</span></pre><p id="5c67" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这会产生编译器错误</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="303d" class="kj kk hi kf b fi kl km l kn ko">error[E0435]: attempt to use a non-constant value in a constant</span></pre><p id="1f02" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">现在我们有了。</p><h1 id="15a5" class="kp kk hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">更进一步…</h1><blockquote class="iv iw ix"><p id="9db1" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="hi">创建数组有两种语法形式:</em></p><p id="f4fc" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="hi">每个元素的列表，即【x，y，z】。</em></p><p id="8e96" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="hi">一个重复的表达式[x；N]，它产生一个包含x的N个副本的数组，x的类型必须是Copy。</em></p></blockquote><p id="6488" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">如果你继续阅读文档，这就是你的发现。<br/>它强调了实际创建数组的两种方法。</p><h2 id="b474" class="kj kk hi bd kq lm ln lo ku lp lq lr ky jx ls lt lc jy lu lv lg jz lw lx lk ly bi translated">方法<strong class="ak">一</strong></h2><blockquote class="iv iw ix"><p id="02be" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">包含每个元素的列表，即[x，y，z]。</p></blockquote><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="3e80" class="kj kk hi kf b fi kl km l kn ko">let array_of_numbers = [0, 1, 1, 2, 3, 5, 8];</span></pre><p id="3be9" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在这种情况下我们声明了什么？</p><p id="12f4" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">首先，编译器可以计算出我们的数组中有7个元素，并使用它来设置数组的大小(<em class="ja"> N) </em>。</p><p id="24ed" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">但是<em class="ja"> T </em>呢？<br/> Rust对于数字默认为<em class="ja"> i32 </em>，这意味着我们刚刚声明了一个包含7个元素的数组<em class="ja"> i32s </em>，<em class="ja">【i32；7] </em>。</p><p id="e3d8" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">如果你有一个文本，其中任何元素值超过了一个<em class="ja"> i32 </em>的能力，会发生什么？</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="9239" class="kj kk hi kf b fi kl km l kn ko">let array_of_numbers = [0, 1, 10_000_000_000];</span></pre><p id="8bc7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">编译器会抱怨</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="6bfc" class="kj kk hi kf b fi kl km l kn ko">error: literal out of range for `i32`</span></pre><p id="b5e3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">由此我们可以看出，Rust不会帮助我们自动将类型更改为更合适的类型，比如一个<em class="ja"> i64 </em>。为此，我们需要做以下工作</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="d127" class="kj kk hi kf b fi kl km l kn ko">let array_of_numbers: [i64; 3] = [0, 1, 10_000_000_000];</span></pre><p id="6f4f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们现在有一个包含3个i64个T21元素的数组。</p><p id="dcd5" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">数组文本中的特定值可以用常量以外的值来描述。例如，您可以用表达式设置这些值。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="faef" class="kj kk hi kf b fi kl km l kn ko">fn array_littera(s: String) {<br/>  let array = [s.len(), s.len() + 1, s.len() + 2];<br/>}</span></pre><h2 id="e3dd" class="kj kk hi bd kq lm ln lo ku lp lq lr ky jx ls lt lc jy lu lv lg jz lw lx lk ly bi translated">方法<strong class="ak">两个</strong></h2><blockquote class="iv iw ix"><p id="40f8" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">重复表达式[x；N]，它产生一个包含x的N个副本的数组，x的类型必须是Copy。</p></blockquote><p id="a024" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">将我们的注意力放在数组上，我们只需浏览一下“<em class="ja">必须复制</em>”部分，并理解到——<em class="ja">复制</em>特征只是允许我们复制值的东西。更重要的部分是理解复制功能的用途。</p><p id="5601" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><em class="ja"> N </em>仍然表示数组的大小，但是我们现在有了<em class="ja"> x，</em>这是一个“重复表达式”。换句话说，这将采用<em class="ja"> x </em>并将其用作所有元素的初始值。现在我们看到了为什么它需要被复制，我们给<em class="ja"> x </em>的值需要被重复复制到数组中。<br/> <br/>文档中使用了“表达式”这个词，在Rust中我们可以用一个表达式做很多事情。这意味着我们可以更加动态地创造我们的<em class="ja"> x </em>价值。</p><p id="bec1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">让我们玩一会儿这个:-)</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="b9fb" class="kj kk hi kf b fi kl km l kn ko">fn create_array_with_fn_as_repeatable_expression(string: String) {<br/>  let array = [string.len(); 2];<br/>}</span></pre><p id="cf0d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">或者…你可以这样做(你可能不应该这样做)。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="46ee" class="kj kk hi kf b fi kl km l kn ko">fn create_array_with_repeatable_expression(input: u128) {<br/>  let array_of_number = [{<br/>    let modulus = 10 * input;<br/>    std::time::SystemTime::now()<br/>      .duration_since(std::time::UNIX_EPOCH)<br/>      .map(|d| d.as_millis())<br/>      .map(|n| n % modulus)<br/>      .unwrap_or(10)<br/>   }; 3];<br/>}</span></pre><p id="f6a0" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj">但是为什么？<br/> </strong>为什么这两种方法很好了解？<br/>一个原因是如果一个数组没有初始化，你就不能使用它。</p><p id="e613" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">例如，这将会失败</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="29e2" class="kj kk hi kf b fi kl km l kn ko">let array: [i32; 10];<br/>let length = array.len();</span></pre><p id="6cce" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">并产生编译器错误</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="07e9" class="kj kk hi kf b fi kl km l kn ko">error[E0381]: borrow of possibly-uninitialized variable: `array`</span></pre><p id="22a9" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">所以这两个方法允许你初始化一个数组</p><ul class=""><li id="a9e3" class="lz ma hi jb b jc jd jg jh jx mb jy mc jz md jw me mf mg mh bi translated">显式设置每个值</li><li id="427a" class="lz ma hi jb b jc mi jg mj jx mk jy ml jz mm jw me mf mg mh bi translated">或者通过提供要复制到数组的每个元素中的值</li></ul><p id="e482" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj">结束。</strong></p></div></div>    
</body>
</html>