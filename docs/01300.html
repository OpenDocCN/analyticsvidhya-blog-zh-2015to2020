<html>
<head>
<title>Beginners Guide to Classification in Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习分类初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/beginners-guide-to-classification-in-machine-learning-2957eeeeb488?source=collection_archive---------14-----------------------#2019-10-13">https://medium.com/analytics-vidhya/beginners-guide-to-classification-in-machine-learning-2957eeeeb488?source=collection_archive---------14-----------------------#2019-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/272833b2babb894bb41d177d7baed79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lzGVy3Czupbk2eDeVl9sqg.png"/></div></div></figure><p id="2077" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">分类</strong>接受监督学习。它指定数据元素所属的类，最适合在输出具有有限值和离散值时使用。在本文中，我将比较一些流行的分类模型，如CART、感知器、逻辑回归、神经网络和随机森林。</p><h2 id="7e6e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">资料组</h2><p id="7801" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">为简单起见，我使用了一个包含100多个实例和9个特征的小型生育数据集:</p><ul class=""><li id="1ed2" class="ko kp hi is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated">执行分析的季节</li><li id="63fd" class="ko kp hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">年龄</li><li id="8904" class="ko kp hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">儿童疾病</li><li id="c4ca" class="ko kp hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">事故或严重创伤</li><li id="b9c1" class="ko kp hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">外科手术</li><li id="0951" class="ko kp hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">去年的高烧</li><li id="3fe9" class="ko kp hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">饮酒</li><li id="1e5b" class="ko kp hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">吸烟习惯</li><li id="c4bd" class="ko kp hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">每天坐着的时间</li></ul><p id="0b77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用的数据集可以在<a class="ae lc" href="https://archive.ics.uci.edu/ml/datasets/Fertility" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="6262" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在加载数据之前，我们需要导入这些库:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="170c" class="jo jp hi li b fi lm ln l lo lp">import pandas as pd<br/>import numpy as np<br/>from sklearn import preprocessing <br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import accuracy_score</span></pre><p id="bcfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，我们可以通过运行以下命令来读取数据:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="cec3" class="jo jp hi li b fi lm ln l lo lp">path= '&lt;path-to-file&gt;'<br/>data = pd.read_csv(path)</span></pre><h2 id="965a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">预处理</h2><p id="f2ec" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在现实世界中，您几乎总是需要对数据进行预处理和规范化。然而，我们的数据集已经被规范化了(使用标签编码)。例如，冬季、春季、夏季和秋季表示为-1、-0.33、0.33和1。唯一需要预处理的部分是最后一列，即输出。“N”需要转换为1，“O”需要转换为0。这可以通过运行以下命令来完成:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="e34b" class="jo jp hi li b fi lm ln l lo lp">data.Output.replace(('N', 'O'), (1, 0), inplace=True)</span></pre><p id="011d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们需要初始化X轴和Y轴。“输出”列将是我们的Y轴，其余的功能将构成X轴。在此之后，数据将分为训练和测试。最常见的比例是70:30。这里，X_train和Y_train将包含数据集的70 %, X _ test和Y_test将包含剩余的30%。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="e55d" class="jo jp hi li b fi lm ln l lo lp">Y = data['Output']<br/>X = data.iloc[:,:-1]<br/>X_train, X_test, Y_train, Y_test = train_test_split(X, Y,<br/>test_size=30)</span></pre><h2 id="d902" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">不同模型的分析</h2><p id="50af" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">导入这些库:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="ce8b" class="jo jp hi li b fi lm ln l lo lp">from sklearn.linear_model import Perceptron<br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.tree import DecisionTreeClassifier<br/>from sklearn.ensemble import RandomForestClassifier</span></pre><h2 id="e0f0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">感知器</h2><p id="1029" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">感知器是一个单层神经网络。它是一种线性分类器，即基于将一组权重与特征向量相结合的线性预测函数进行预测的分类算法。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="8d96" class="jo jp hi li b fi lm ln l lo lp">ppn = Perceptron(max_iter=100, eta0=0.5)<br/>ppn.fit(X_train, Y_train)</span><span id="f484" class="jo jp hi li b fi lq ln l lo lp">y_pred = ppn.predict(X_test)<br/>print(accuracy_score(Y_test, y_pred))</span><span id="2a49" class="jo jp hi li b fi lq ln l lo lp">accuracy=accuracy_score(Y_test,y_pred)</span><span id="3856" class="jo jp hi li b fi lq ln l lo lp">print('Accuracy: %.2f'%(accuracy*100))</span></pre><p id="b61b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，<code class="du lr ls lt li b">max_iter</code>指的是对训练数据的最大通过/迭代次数，而<code class="du lr ls lt li b">eta0</code>指的是更新所乘以的常数。该模型的准确率为<strong class="is hj"> 83.33% </strong></p><p id="1835" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注:应用L2和弹性网正则化后，结果保持不变，而L1正则化的精度降低到73.33。您可以通过在代码的第一行添加另一个参数<code class="du lr ls lt li b">penalty='l1/l2/elasticnet'</code>来验证这一点。</p><h2 id="64f8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">逻辑回归</h2><p id="29b1" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">逻辑回归是二元分类问题(具有两个输出值的问题)的常用方法。它用于描述数据，并解释一个因变量与一个或多个标称变量、序数变量、区间变量或比率级自变量之间的关系。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="3e7e" class="jo jp hi li b fi lm ln l lo lp">lg_reg = LogisticRegression()<br/>lg_reg.fit(X_train, Y_train)</span><span id="e207" class="jo jp hi li b fi lq ln l lo lp">y_pred = lg_reg.predict(X_test)</span><span id="733c" class="jo jp hi li b fi lq ln l lo lp">accuracy=accuracy_score(Y_test,y_pred)<br/>print('Accuracy: %.2f'%(accuracy*100))</span></pre><p id="162a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们不需要为这个模型使用任何额外的参数。代码的前两行将调用逻辑回归函数并训练数据。下一行预测X_test的输出。其准确率为<strong class="is hj"> 86.67% </strong></p><p id="9ece" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:L1和L2正则化对模型的准确性没有影响，而elasticnet正则化是不可能的(因为数据集太小)。</p><h2 id="e58c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">购物车决策树</h2><p id="04d5" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">决策树是最强大和最流行的分类和预测工具。决策树是类似树结构的流程图，其中每个内部节点表示对属性的测试，每个分支表示测试的结果，每个叶节点保存一个类标签。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="93f1" class="jo jp hi li b fi lm ln l lo lp">classifier = DecisionTreeClassifier()<br/>classifier.fit(X_train, Y_train)</span><span id="c56b" class="jo jp hi li b fi lq ln l lo lp">y_pred = classifier.predict(X_test)</span><span id="0b7c" class="jo jp hi li b fi lq ln l lo lp">classifier = DecisionTreeClassifier(max_leaf_nodes=60)<br/>classifier.fit(X_train, Y_train)<br/>y_pred = classifier.predict(X_test)</span><span id="bebc" class="jo jp hi li b fi lq ln l lo lp">accuracy=accuracy_score(Y_test,y_pred)<br/>print('Accuracy: %.2f'%(accuracy*100))</span></pre><p id="2f05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的<code class="du lr ls lt li b">max_leaf_nodes</code>指的是以最佳优先的方式种植树木。最佳节点被定义为杂质的相对减少。数字60可以是任何数字，也可以是零。该模型的准确率为<strong class="is hj"> 76.67% </strong></p><h2 id="a0aa" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">随机森林</h2><p id="6d02" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">随机森林的运行方式是在训练时构建大量决策树，并输出作为各个树的类(分类)或均值预测(回归)模式的类。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="a5dc" class="jo jp hi li b fi lm ln l lo lp">classifier= RandomForestClassifier(n_estimators=100, criterion= 'gini') <br/>classifier.fit(X_train,Y_train)</span><span id="d463" class="jo jp hi li b fi lq ln l lo lp">y_pred= classifier.predict(X_test)<br/><br/>accuracy=accuracy_score(Y_test,y_pred)<br/>print('Accuracy: %.2f'%(accuracy*100))</span></pre><p id="536f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lr ls lt li b">n_estimators</code>指的是森林中的树木数量，<code class="du lr ls lt li b">criterion</code>指的是衡量一次分裂质量的函数。这可以是基尼指数或熵(在这种情况下，两者都产生相同的准确性)。该模型的准确率为<strong class="is hj"> 80% </strong></p><h2 id="fe2d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">神经网络</h2><p id="72ad" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">为了创建神经网络，我们将使用TensorFlow后端。为此，我们需要以下库:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="e848" class="jo jp hi li b fi lm ln l lo lp">from keras.models import Sequential<br/>from keras.layers import Dense<br/>from keras.utils import to_categorical</span></pre><p id="d75e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">神经网络是一系列算法，通过模拟人脑运行方式的过程，努力识别一组数据中的潜在关系。他们可以适应不断变化的输入；因此，网络无需重新设计输出标准即可生成最佳结果。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="eb2c" class="jo jp hi li b fi lm ln l lo lp">model= Sequential()<br/>model.add(Dense(9, input_dim=9, activation='relu')) <br/>model.add(Dense(7,activation='relu'))<br/>model.add(Dense(2,activation='softmax')) </span><span id="b047" class="jo jp hi li b fi lq ln l lo lp">model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])</span><span id="3761" class="jo jp hi li b fi lq ln l lo lp">y_test_cat=to_categorical(Y_test)<br/>y_train_cat=to_categorical(Y_train)<br/>model.fit(X_train, y_train_cat,epochs=100,batch_size=10)</span></pre><p id="18a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，数字9指的是数据集特征的数量，数字7指的是神经元的数量，数字2指的是数据集的可能输出，而<code class="du lr ls lt li b">epochs</code>指的是所有训练向量被使用一次来更新权重的次数的度量。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="ff82" class="jo jp hi li b fi lm ln l lo lp">_,accuracy=model.evaluate(X_test,y_test_cat)<br/>print('Accuracy: %.2f'%(accuracy*100))</span></pre><p id="b53a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该模型的准确率为<strong class="is hj"> 86.67% </strong></p><h2 id="f60f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">结论</h2><p id="f7c0" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在通过五种不同的分类模型训练和测试数据集之后，观察到线性回归和神经网络具有最高的准确性(86.67%)，其次是感知器(83.33%)、随机森林(80%)和CART决策树(76.67%)</p></div></div>    
</body>
</html>