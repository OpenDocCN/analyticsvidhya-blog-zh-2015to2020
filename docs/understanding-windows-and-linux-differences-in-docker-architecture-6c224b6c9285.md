# 了解 Windows 和 Linux 在 Docker 架构上的差异

> 原文：<https://medium.com/analytics-vidhya/understanding-windows-and-linux-differences-in-docker-architecture-6c224b6c9285?source=collection_archive---------10----------------------->

Docker 作为一个容器工具实际上是不久前出现的，并且已经成为当今现代软件可用的主要容器工具。在这个机会里，我会试着写下大多数 Docker 相关课程中没有涉及到的所有内容。许多作者在大约 5 分钟内从安装到运行容器(这实际上很酷)，但是实际上，这里缺少了很多内容。

如果您想完全理解 Docker 架构的基础，请加入我的快速讲座。我将重述内核原语、 **Docker 引擎、**和 **Linux** 和 **Windows 操作系统**中的容器场景等等。

我在许多资料中寻找这一点，这很难理解，当然，如果有必要，我会谈谈基本概念。

我们继续吧。

# 码头引擎

**Docker 引擎**是 **Docker 工具箱**的核心，它是一个模块化的 **API** ，实际上带有一个 **CLI 接口**(向用户公开)，在**守护进程**、`containerd`进程和 **OCI** 之间进行通信。

**Docker 引擎**如今是一个巨大的平台，它通过 Docker Swarm、注册表、通用控制平面和一系列第三方集成来处理本机编排。

Docker 不久前开始作为一个名为 **dotCloud** (我想)的小项目，它是一个 Python 工具，作为 LXC 的包装器，容器和 AUFS 的接口。在与 LXC 的关系出现问题后，**码头工人**分道扬镳，想出了成为今天的样子。

今天， **Docker** 套件由一个**客户端**、一个**守护进程**、一个用于执行生命周期的**容器管理器**(`containerd`进程)和一个直接与内核接口的**运行时** (OCI)组成。

## Linux 的 Docker 引擎

1.  **客户端**向守护进程请求一个新容器。
2.  **守护进程**让`containerd`到`start`管理容器。
3.  **OCI 层**上的 **OCI** 运行时执行程序(默认运行时，也称为 **runC** )实际上构建了容器。

## Windows 引擎

1.  **客户端**向**守护进程**请求新的容器。
2.  然后，**守护进程**进入**计算机服务层**(这是一个低级层，使一切与 Linux 进程相同)，这是 Windows 对`containerd`进程的替代。

**计算机服务层**的出现是**操作系统**之间 Docker 实现的差异之一。

我们再深入一点。

## 它是如何工作的？

**Docker 守护进程**是`containerd`和`OCI`运行时的中间件(基于 **API 的**)。Docker 不知道如何创建容器。

因此，整个进程从**守护进程**在**本地 Linux 套接字**上通过 **gRPC** 调用`containerd`开始，`containerd`是**守护进程**，由**启动**,**为每个容器附加**进程，并将容器的创建委托给 RunC 进程，然后退出。

`containerd`工序可以有效地同时管理多个`runC`工序或垫片。

从架构上来说，它非常棒，而且是模块化的，`containerd`和`runC`可与任何其他 OCI 兼容产品进行交换。您可以重新启动 docker 守护进程，而不会导致正在运行的容器崩溃，或者任何其他相关的活动。

`containerd`和`gPRC`是具有 1:1 关系基数的进程，这表示对于您创建的每个容器，一个`runC`进程派生它，然后退出，这使得每个容器都创建了自己的进程并附加到`containerd`守护进程

这两个命令(`containerd`和`runC`)的要点在于它们可以通过高级工具驱动，Docker 客户端**也是如此。**

**gRPC** 是个牛逼的工具，值得一试。

# 容器

其基础概念是**容器**，这个非常特殊的元素可以被定义为一个**操作系统**的一个隔离区域，应用资源使用限制，我们可以同时运行多个。很酷，对吧？。

**容器**是运行 **Docker 图像**所需的最基本的单元。我们已经知道图像是一组图像，在**构建期间**作为一个单独的部分，在**运行期间**，一个临时的可写层被放置在容器的顶部，作为一个独立的结构。

容器运行的**基础映像**对每个需要它的人都可用，为了修改，它生成自己的副本，然后写入它。

因此，从操作系统的角度来看，每个容器都是操作系统中独立的一部分，而从虚拟机的角度来看，容器本身不是虚拟化硬件，而是虚拟化操作系统资源。

容器是关于应用程序的，被认为是微服务架构方案的黄金标准，但实际上也可以应用于一切。

为了构建一个容器，我们需要利用一些底层的内核东西，比如**控制组**和**命名空间**，它们实际上是由 **Docker 引擎**处理的。

整个工作流程可以总结为 4 个步骤:

1.  **CLI** 客户端需要创建新容器的指令。
2.  客户端向 Docker 引擎中的容器/创建 API 端点发出 API 请求
3.  引擎提取所需的内核内容。
4.  在资源内核被拉出来之后，引擎自己创建并弹出容器。

## 控件组和名称空间:内部

事实上，容器在很多年前就已经出现在技术领域，实际上，在 Docker 之前就已经有很多与容器相关的工具了。

Docker implementation for Windows 在内部使用了虚拟化的 Linux 容器，这不是什么秘密。Docker 是一个多平台的容器工具。在这一节中，我将讨论容器中的两个内核基本元素，由于操作系统架构和容器在 Windows 中的具体应用，它们在实现上有所不同。

第一个是**名称空间**。

## 名称空间

**命名空间**组件能够创建虚拟机，这一组件将操作系统转换为多个独立的虚拟机，如**虚拟机管理程序**。它获取您的主机资源，并使用自己的资源(虚拟 CPU、内存、存储等)生成隔离的容器。

在容器世界中，使用**名称空间**将单个主操作系统和所有资源打包到多个独立的容器中，看起来像普通的操作系统，但实际上不是。

容器在主机上共享相同的内核，但是因为是隔离的，所以不能识别周围的其他容器。

就像 a 之前说的。名称空间只是为以后的容器使用创建虚拟机。就是这样。

## 对照组

这个特殊的元素负责在 VM 中对对象进行分组和设置限制。基本上处理一般功能，避免邻居干扰，平衡容器间的系统资源，等等。

所以，这两个结合在一起的层(来自 Docker UnionFS)是现代容器的基本形式。

# Linux 容器

Linux 系统中 Docker 的每个容器运行一个单独的进程，该进程有一个单独的作业，它的功能在它自己的容器中，所有的东西后来都通过 API 粘在一起

## Linux 生态系统:名称空间

这是 Linux Docker 名称空间内核元素的基本结构。

1.  **进程 ID** (PID):每个容器都有自己独立的进程树(不知道其他容器)
2.  **网络** (NET):包含自己隔离的网络堆栈(IP、路由表等等)
3.  **文件系统/挂载** (MNT):独立的根文件系统
4.  **进程间通信** (IPC):单个容器访问共享内存，但停止容器外的所有操作
5.  UTS (UTS):自己的主机名
6.  **用户**(用户):不同的用户集合

每个 docker 容器都是一个独立的、有组织的数据集合，当然，它们都被安全地捆绑在一起。

# Windows 容器

现在，是时候从基于 Windows 操作系统的角度研究容器内核基本元素了。

在介绍**名称空间**和 **CGroups** 部分时，我告诉过你 **Windows** 在将容器实现到他们的生态系统中方面做了大量的工作，这基本上是非常相似的，但是有所不同。实际上，微软在内核中放了很多东西。

我将列出 Windows 生态系统实现中的主要差异。让我们从**名称空间**和**控制组**元素开始，两者都与 Linux 非常相似，并且也生成具有指定资源的容器。

稍微不同的是在图像生成上。他们实际上用 **NTFS** 和**注册表做了很多工作来模拟**图像层，就像用 Linux 上的 **AUFS** ( `DeviceMapper`)和`overlay2`做的一样。

对于 Windows 体验，Docker 也有 Docker 客户端(`docker.exe`)和 Docker 守护进程(`dockerd.exe`)，并使用相同的 Docker API，但引入了一个名为**计算机服务层**的组件(还记得那个吗？)保存命令和容器，而不是使用`containerd` (Linux 守护进程)和硬件。

本机 **Windows** 容器进程的处理方式也不同，在 **Linux** 中，你会看到每个容器都有一个进程。在 **Windows** 中，两个应用程序都需要一些依赖于其他程序的依赖关系，所以如果找不到这个进程，一切都会中断(即使是容器)。

## Hyper-V 呢？

在 Windows 中，我们有两种不同的本机容器:Windows 容器和 Hyper-V 容器。

每一个都有使其不同的特定功能，主要的一个是本机 **Windows 容器**为其容器使用**名称空间隔离**，这些都与主机操作系统内核相关，如果您需要任何其他特定配置，Hyper-V 是您的理想选择。

Hyper-V 容器是后台的轻量级虚拟机，除了主机操作系统之外，它还使用成熟的操作系统。它们内部运行着一个完全隔离的内核，可以在 Windows 和 Linux 上运行。

以下是如何在两种 Windows 风格下运行容器的示例:

Hyper-V: `docker run \ --isolated-hyper`

原生视窗:`docker run \`

## 推荐

为了维护健康和快速的容器，这应该被视为短暂的和不可变的，其中短暂的与容器的短暂生命相关，而不可变的是在需要修复时构建新的映像并将它们附加到其他映像。

很多理论，对吧？如果你看到有什么不对的地方，请不要犹豫，发表意见。

快乐编码:)