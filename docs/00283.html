<html>
<head>
<title>Git Version Control System in 15 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">15分钟后Git版本控制系统</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/git-version-control-system-in-15-minutes-ed60aa9e009a?source=collection_archive---------0-----------------------#2019-03-03">https://medium.com/analytics-vidhya/git-version-control-system-in-15-minutes-ed60aa9e009a?source=collection_archive---------0-----------------------#2019-03-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0e84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将谈论Git，它是一个版本控制工具。现在发生的事情是，我们显然没有理解这个工具的基本原理，从而使git变得复杂。我们所做的就是拉和推。有时这很有效，但大多数时候我们会遇到合并冲突并陷入困境。至少对我来说是这样。所以我最终决定对这个神奇的工具有一个清晰的了解，这澄清了一切。所以让我们开始…</p><p id="355d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在Git和Github是有区别的。Git是一个版本控制工具，而Github是一个托管Git项目的服务，以便开发人员在处理项目时可以轻松协作。</p><p id="fa12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">版本控制系统分为两大类。一种是集中式模型，另一种是分布式模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5e6d9413425b2061e25c17be3ba06d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWOkgFxjpMB-Fd4dMS3j3A.png"/></div></div></figure><p id="7a9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在集中式模型中，有一台强大的中央计算机来管理项目，每个交互都必须通过它。看起来有点像电脑的盒子是开发人员在同一个项目上工作。而在分布式模型中，没有中央计算机，每个开发人员都有项目的完整副本。现在，在这种情况下，他们也可以在项目的某个特定功能上离线工作。</p><p id="61ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Git是一个分布式版本控制系统，这里需要注意的重要一点是，每个开发人员都有一份完整的项目副本。</p><p id="9c07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是Git行话中使用的一些关键术语。因此，在我们逐一讲解时，请继续回顾这些内容。你现在可以浏览一下。</p><p id="a400" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">版本控制系统(VCS)或源代码管理器(SCM):</strong>VCS允许您:将文件恢复到以前的状态，将整个项目恢复到以前的状态，查看一段时间内所做的更改，查看谁最后修改了可能导致问题的内容，谁在何时引入了问题，等等。</p><p id="4409" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提交(快照):</strong> Git认为它的数据就像一组迷你文件系统的快照。每当您提交或者在Git中保存项目状态时，它基本上会拍摄一张当时所有文件的样子，并存储一个对该快照的引用。</p><p id="ef94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Repository(Repo) </strong>:一个目录，包含你的项目工作，以及一些用于与Git通信的文件(在Mac OS X上默认隐藏)。存储库可以位于您的本地计算机上，也可以是另一台计算机上的单独远程副本。</p><p id="ed24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">工作目录:</strong>你在电脑文件系统中看到的文件。当您在代码编辑器中打开项目文件时，您正在处理工作目录中的文件。</p><p id="c502" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这与已保存的文件(提交！)在存储库中。</p><p id="5a3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当使用Git时，工作目录也不同于命令行的当前工作目录的概念，当前工作目录是您的shell现在正在“查看”的目录。</p><p id="bde6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">签出:</strong>当存储库中的内容被复制到工作目录时。从存储库中签出许多东西是可能的；文件、提交、分支等。</p><p id="8a52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Staging Area或Staging Index或Index:</strong>Git目录中的一个文件，它存储了关于下一次提交的内容的信息。您可以将一个临时区域想象成一个准备表，Git将在这里进行下一次提交。暂存索引上的文件已准备好添加到存储库中。</p><p id="ba3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">沙:</strong>基本上是每次提交的ID号。它是一个40个字符的字符串，由字符(0–9和a-f)组成，根据Git中文件或目录结构的内容进行计算。“沙”是“沙哈希”的简称。阿沙可能看起来像这样:</p><p id="2350" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">e 2 ad 8 AE 3 e 2e 4 ed 40 add 75 cc 44 cf 9 d0a 869 afeb 6</p><p id="0893" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分支:分支是当一个新的开发路线从主开发路线中分离出来的时候。这条可供选择的发展路线可以在不改变主线的情况下继续下去。</p><h1 id="b7b0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Git储存库</h1><p id="273f" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Git存储库可以看作有三个主要区域——工作目录、暂存索引和保存所有提交的存储库。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ks"><img src="../Images/0c27bdb6bd8139ddda9b1b66bbda2bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pi7arZ2DbT7woZ1j-HmuCQ.png"/></div></div></figure><p id="b333" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在假设我们在工作目录中创建了三个新文件。HTML，CSS和JS文件。要保存这些文件的当前状态，我们必须首先将它们添加到暂存索引中。从暂存索引中，我们将它们添加到存储库，存储库保存文件的当前状态。我们将很快看到这样做的命令。</p><p id="3bb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们再次更改CSS文件，暂存它并提交给repo。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/42eed97c4e5891cab5e988b7a612d4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8c60JY2PrheqJpKzqjUuQ.png"/></div></div></figure><p id="1a5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到这些变更被记录在存储库中。因此，对于每次提交，git都会获取已更改文件的快照，并将其存储在repo中。它为每个提交提供一个7位数的提交Id，这是40位数SHA的前7个字符。提交id用于标识特定的提交。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ku"><img src="../Images/23687c1be63f42fa5b56f7d3777ece55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6urPKEaemacBoouS4iYZEQ.png"/></div></div></figure><h1 id="2c93" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">创建Git存储库。</h1><p id="8995" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在本节中，我们将介绍三个命令。Git初始化、Git克隆和Git状态。</p><h2 id="ac74" class="kv jq hi bd jr kw kx ky jv kz la lb jz iq lc ld kd iu le lf kh iy lg lh kl li bi translated"><strong class="ak"> 1) Git初始化</strong></h2><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="e47a" class="kv jq hi lk b fi lo lp l lq lr">git init</span></pre><p id="763a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在shell中，在您希望用git跟踪的工作目录中，该命令执行以下操作</p><ol class=""><li id="b286" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">它设置了所有必要的文件和目录，Git将使用它们来跟踪一切。</li><li id="be1e" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">所有这些文件都存储在一个名为<strong class="ih hj">的目录中。饭桶。</strong></li><li id="25b8" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">的。git目录就是我们一直在谈论的“回购”。这是git记录所有提交并跟踪一切的地方。</li></ol><p id="1916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该目录的结构如下图所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mg"><img src="../Images/3d6e7478b85221c6c3b581ad8bc7674c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*Qp2AYncsBWsByKbkAHE0bg.png"/></div></figure><h2 id="1e71" class="kv jq hi bd jr kw kx ky jv kz la lb jz iq lc ld kd iu le lf kh iy lg lh kl li bi translated"><strong class="ak"> 2) Git克隆</strong></h2><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="e725" class="kv jq hi lk b fi lo lp l lq lr">git clone URL</span></pre><p id="4109" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你需要做一些你电脑里没有的项目，或者你想为一个开源项目做贡献，你必须从网上克隆它。现在，当项目被托管在Github或Bitbucket上时，我们可以很容易地获得该项目的URL。然后运行上面的命令，在您的计算机上获得该存储库的完整副本。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mh"><img src="../Images/347fb32b5bdc6d357f053feaf9ae056b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*-mBjLWansGP2jsCOGe9Q4g.png"/></div></figure><p id="fb9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，文件夹的名称是您从中克隆的名称。如果您想更改Git创建的文件夹的名称，您可以运行命令</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="183b" class="kv jq hi lk b fi lo lp l lq lr">git clone URL new-name</span></pre><p id="167a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在git repo已经在项目目录中被这个命令初始化了。我们不需要再次运行“git init”。</p><h2 id="943f" class="kv jq hi bd jr kw kx ky jv kz la lb jz iq lc ld kd iu le lf kh iy lg lh kl li bi translated">3) Git状态</h2><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="86db" class="kv jq hi lk b fi lo lp l lq lr">git status</span></pre><p id="76ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个命令用于检查我们所在的存储库的状态。让我们看看在我们之前克隆的项目上运行这个命令的输出。记住，你必须先用cd进入那个目录。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mi"><img src="../Images/ef63d758002868af8ae410e9157f3542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*zcjDl2z-AyrwM3n7q3Q1-g.png"/></div></figure><p id="8185" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将解释输出中的每一行。</p><p id="7496" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> a)在主分支上— </strong>这告诉我们Git在主分支上(这是默认分支)。我将在本文稍后讨论分支。</p><p id="8bbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> b)您的分支使用‘origin/master’是最新的— </strong>因为git clone用于从另一台计算机复制这个库，这告诉我们它使用我们从中克隆的那个是最新的。</p><p id="741e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> c)没有要提交的内容，工作目录干净— </strong>这告诉我们没有需要提交给本地回购的未决更改。</p><h1 id="d7d4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">查看回购的历史记录。</h1><p id="0ddd" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在本节中，我们将看到两个命令— Git log和Git show。</p><h2 id="2bf9" class="kv jq hi bd jr kw kx ky jv kz la lb jz iq lc ld kd iu le lf kh iy lg lh kl li bi translated">1) Git日志</h2><p id="ed97" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">它显示关于在回购中已进行的现有提交的信息。它显示了提交的40位SHA、提交者、提交日期和时间。它还显示了提交消息。因此，给出有意义的提交消息是一个很好的实践。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mj"><img src="../Images/3c4144a71e0a7cf74e03fa7ee0fb0a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgccjg7oewjM-7FEz0NZlw.png"/></div></div></figure><p id="920c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以通过编写以下命令在一行中获得提交id和消息—</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="c652" class="kv jq hi lk b fi lo lp l lq lr">git log --oneline</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mk"><img src="../Images/4983fd8ff9a3a05ecc5396a99b96f02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YW00K3tKwK6K5z9H3A89Bw.jpeg"/></div></div></figure><p id="3311" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用带有git log的stat标志来查看哪些文件发生了更改。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="50f0" class="kv jq hi lk b fi lo lp l lq lr">git log --stat</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ml"><img src="../Images/1568803543f70dd579591d08a0c465a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lKG90kSaB4rHSRh64hOugA.png"/></div></div></figure><p id="9ee7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加号(+)告诉我们文件中插入的行数，减号(-)告诉我们文件中删除的内容。</p><p id="2c45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些变化到底是什么？使用“p”标志</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="fc31" class="kv jq hi lk b fi lo lp l lq lr">git log -p</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mm"><img src="../Images/ce7b5f71853484e22419ece16b6f230f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*AVarP65UprU1FNeq4di5LQ.png"/></div></figure><p id="5bfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面解释一下上面这几行是什么意思。(由Udacity Git课程提供)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mn"><img src="../Images/5ee8792a55ab089312db52ac99685292.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*b91AWzT_LCw3WlDF6iLGFQ.png"/></div></figure><h1 id="0d5f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">向存储库添加提交。</h1><p id="aea3" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">这里我们将看到三个命令，分别是git add、git commit和git diff。</p><h2 id="b34f" class="kv jq hi bd jr kw kx ky jv kz la lb jz iq lc ld kd iu le lf kh iy lg lh kl li bi translated">1) Git添加</h2><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="3e63" class="kv jq hi lk b fi lo lp l lq lr">git add</span></pre><p id="4d6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该命令将工作目录中的文件添加到临时索引中。我们已经创建了三个新文件，并希望使用版本控制来跟踪它们。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mo"><img src="../Images/3df8d596d3f4d822f16cc4f0d6552254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQoaqm9rqtmtbUchLIURjQ.png"/></div></div></figure><p id="401f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一些新文件想开始追踪。Git要跟踪一个文件，需要将它提交给一个存储库。对于要提交的文件，它需要在暂存索引中。git add命令用于实现这一目的。</p><p id="b55b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在工作目录中，键入命令..</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="4558" class="kv jq hi lk b fi lo lp l lq lr">git add .</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mp"><img src="../Images/30d165811638dffbe0c13c7c2ff13e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*Qk3UfiniPH5Hb6m-D4wdyA.gif"/></div></figure><p id="0c02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">圆点(。)在add命令之后，将每个已更改的文件添加到分段索引中。如果您特别想将文件添加到分段索引中，</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="8280" class="kv jq hi lk b fi lo lp l lq lr">git add &lt;file-name&gt;</span></pre><h2 id="05e7" class="kv jq hi bd jr kw kx ky jv kz la lb jz iq lc ld kd iu le lf kh iy lg lh kl li bi translated">2) Git提交</h2><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="caec" class="kv jq hi lk b fi lo lp l lq lr">git commit -m “Initial commit”</span></pre><p id="b6e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此命令用于将临时索引中的文件添加到存储库本身。请注意，只有在git添加过程中暂存的文件才会被提交到存储库中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mq"><img src="../Images/935edc45c4195797a97fd37c31753a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*yeFpUv15bFmDfUyHHSEEvg.png"/></div></figure><p id="78ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，我们可以看到这个提交被赋予了一个7位数的提交Id。</p><h2 id="96a5" class="kv jq hi bd jr kw kx ky jv kz la lb jz iq lc ld kd iu le lf kh iy lg lh kl li bi translated">3) Git差异</h2><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="9be2" class="kv jq hi lk b fi lo lp l lq lr">git diff</span></pre><p id="9bf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该命令可用于查看已经完成但尚未提交的更改。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mr"><img src="../Images/3d00fe8b7c9ec0ad1fbbf0708e1f1876.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*mch7V5K_J0sbldYJLC7dEw.png"/></div></figure><p id="79ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有一个. gitignore文件，您可以在其中写入不想用git跟踪的文件的名称。</p><h1 id="8066" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">标记、分支和合并。</h1><p id="6901" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在这一节中，我将向您展示如何创建分支以及如何将分支合并在一起。这部分有4个简单的命令，分别是git标签、git分支、git检验和git合并。</p><h2 id="6d21" class="kv jq hi bd jr kw kx ky jv kz la lb jz iq lc ld kd iu le lf kh iy lg lh kl li bi translated">1) Git标签</h2><p id="ce31" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">这个命令让我们向特定的提交添加标记。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="125b" class="kv jq hi lk b fi lo lp l lq lr">git tag -a v1.0</span></pre><p id="243d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的这个命令将允许您向当前提交添加标记。假设在提交之后，您将开始开发应用程序的2.0版本，并且您希望在这里添加一个标记或标签来让您记住它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ms"><img src="../Images/d972f2218add31dc567999ca9ff12ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXqEsa16mg4m9vtPzwFfQg.png"/></div></div></figure><p id="ba91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要向过去提交添加标签，</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="52ad" class="kv jq hi lk b fi lo lp l lq lr">git tag -a v1.0 a87984b </span></pre><p id="7d7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">删除标签，</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="27de" class="kv jq hi lk b fi lo lp l lq lr">git tag -d v1.0</span></pre><h2 id="dbcd" class="kv jq hi bd jr kw kx ky jv kz la lb jz iq lc ld kd iu le lf kh iy lg lh kl li bi translated">分支</h2><p id="4dfc" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">如果你注意到了，到目前为止我们一直在做master branch。那么什么是分支呢？如何创建一个以及如何在分支之间切换？</p><p id="db31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，当我们初始化git repo时，它会为我们创建一个主分支，这是默认的分支名称。现在，您可以将一个分支视为一系列提交的发生。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mt"><img src="../Images/8499860b35bddaf7a4669c25f2e7eb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWsyP_HE74wqrQKMoNUQ0w.png"/></div></div></figure><p id="0613" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，我们有三次提交。您可以在最近一次提交时看到主分支指针。我们还有一个特殊的<strong class="ih hj"> HEAD </strong>指针，它指向我们当前工作的分支。它当前指向主分支指针。一个存储库中可以有n个分支。</p><p id="eec2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建一个名为<strong class="ih hj">测试的分支，</strong>我们可以运行命令—</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="6ddd" class="kv jq hi lk b fi lo lp l lq lr">git branch testing</span></pre><p id="f4ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将在我们当前所在的提交位置创建一个新指针，如下图所示</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mu"><img src="../Images/73c1b31043b6aa0bc525257acfcf01b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXSIhBaPujVaqFvqzl3TCA.png"/></div></div></figure><p id="8ef0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要查看分支指针指向何处，请运行命令。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="729d" class="kv jq hi lk b fi lo lp l lq lr">git log --oneline --decorate</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mv"><img src="../Images/e0953556284a70c176d00208eebc8195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*1S1YtiV8h2OFHz0Gmma68A.png"/></div></figure><p id="c097" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了切换到测试分支，</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="2b09" class="kv jq hi lk b fi lo lp l lq lr">git checkout testing</span></pre><p id="c07e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将指向测试分支。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mw"><img src="../Images/7eb3d9542047b0364e591eac4bf38bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NjUfMa_c040-vGCXHyrggQ.png"/></div></div></figure><p id="cd7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们在这一点上提交，它将只移动测试指针，而主指针将保持在原来的位置。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mx"><img src="../Images/5ecf469958d09099d034c04d9f3955cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3T6nw5q0TGZZ05mtAwy1Eg.png"/></div></div></figure><p id="2398" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们通过键入以下命令再次切换到主模式—</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="2aed" class="kv jq hi lk b fi lo lp l lq lr">git checkout master</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es my"><img src="../Images/d56c389a3d6e63f87dae8e685a6686dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llNoNKg7icYZJndJrJ3gSw.png"/></div></div></figure><p id="a236" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">头</strong>现在已经移到master，我们在master分支。它会做两件事-</p><ol class=""><li id="28c5" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">它将头指针移回，指向主分支。</li><li id="adc6" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">它将工作目录中的文件还原到master指向的快照。也就是说，在测试分支的提交中所做的更改在编辑器中是不可见的。</li></ol><p id="fd2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在主分支上再提交一次。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mo"><img src="../Images/756acf51cdeb2760b57b46bfccd97759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9q_K6hfiNujucpugPCNTUQ.png"/></div></div></figure><p id="949d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就把我们带到了合并的概念。</p><p id="53de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，为了从特定的提交开始一个分支，我们可以运行命令—</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="73ff" class="kv jq hi lk b fi lo lp l lq lr">git branch &lt;name-of-branch&gt; &lt;commit-Id&gt;</span></pre><h1 id="044a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">合并</h1><p id="fffd" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">将分支组合在一起称为合并。合并的原因是—</p><ol class=""><li id="eecd" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">要么你的特征分支的工作已经结束。或者，</li><li id="481e" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">您完全想忽略这些更改，在这种情况下，您删除了分支。</li></ol><p id="796b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">合并有两种类型，<strong class="ih hj">常规合并</strong>和<strong class="ih hj">快进合并。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mz"><img src="../Images/b522b4f1ca177dae5532462cdf5611e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ok5wPsrTHXcrIY3Kne32YQ.png"/></div></div></figure><p id="807b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在主分支上，我们可以将侧栏合并为</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="f614" class="kv jq hi lk b fi lo lp l lq lr">git merge sidebar</span></pre><p id="8225" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这创建了新的提交，并且主指针向前移动到该提交。记住，我们可能会遇到合并冲突，我接下来会谈到这一点。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es na"><img src="../Images/7ed8ee75dc1927f8c974c96f2bf30ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jf8s2aRwk4vhlww5YRmFyQ.png"/></div></div></figure><h2 id="f37e" class="kv jq hi bd jr kw kx ky jv kz la lb jz iq lc ld kd iu le lf kh iy lg lh kl li bi translated">合并后删除分支</h2><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="4730" class="kv jq hi lk b fi lo lp l lq lr">git branch -d sidebar</span></pre><p id="9090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:-不能在一个分支上删除/合并该分支。</p><p id="8b71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经创建了一个新的分支社交链接，提交了一些，然后再次切换到master。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nb"><img src="../Images/420cc75ef109ade534cd5cb991ccf80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MTFLQno7OwgQXJ-I5P5aRw.png"/></div></div></figure><p id="082f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们通过运行命令合并社交链接分支—</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="6e76" class="kv jq hi lk b fi lo lp l lq lr">git merge social-links</span></pre><p id="0f0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它被称为快速前进合并，因为<strong class="ih hj">社交链接</strong>在提交链上直接位于主链接之前。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nc"><img src="../Images/899dfac5d6cb1cd86de6f481b021da26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HW6_vRuE40hn7az4tZJSmw.png"/></div></div></figure><h1 id="0bd2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">合并冲突</h1><p id="0224" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Git跟踪文件中的行。当完全相同的行在不同的分支上被改变并且我们合并它们时，合并冲突就发生了。(图片来自www.udacity.com)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nd"><img src="../Images/0750a49425e26a68002f28f6f67911c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTYRikPM3v46yqjc8Ybjjw.jpeg"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ne"><img src="../Images/0a7e6a09646d4961b0b7a989709a019c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWbalnqeJa5L60phBfQFkw.jpeg"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nf"><img src="../Images/f43ebee612dcc30449eef13868f94493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P_7oHftb-wH24BBfvaTMQ.jpeg"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ng"><img src="../Images/7c3de8604b9445fedfac8c50ecebbe63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85tgFL8ylvHNDcQzs50inw.jpeg"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nh"><img src="../Images/6a14c73321a0920d3aa9479e4e4da619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*f_-CItGhKN_v-fNjUw1E4Q.gif"/></div></div></figure><p id="36a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">消除冲突后，保存、暂存并提交。</p><h1 id="d3e1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">撤消更改</h1><p id="48f8" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在本节中，我们将看到三个命令</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="3379" class="kv jq hi lk b fi lo lp l lq lr">git commit --amend</span></pre><p id="396a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Amend用于改变最近的提交。如果您在上一次提交时忘记添加文件，或者提交消息中有拼写错误，您可以使用它。<a class="ae ni" href="https://www.atlassian.com/git/tutorials/rewriting-history" rel="noopener ugc nofollow" target="_blank">回顾历史</a>。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="b4fa" class="kv jq hi lk b fi lo lp l lq lr">git revert</span></pre><p id="8fdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Git revert用于使用SHA反转提交。它不会删除任何提交，而是创建一个新的提交并撤消更改。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="be38" class="kv jq hi lk b fi lo lp l lq lr">git reset</span></pre><p id="f7b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Git重置实际上是危险的。它从回购中移除提交，并因此移除在这些提交中所做的更改。</p><h1 id="dc8c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用遥控器(欢迎使用github！)</h1><p id="0339" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">现在我们正在讨论我们计算机中的本地存储库。但是在真实的场景中，许多开发人员会同时在不同的分支上工作。这些分支是特定于特定特征的。当这些特征准备好时，它们可以与主分支合并，并且可以被删除。这使得开发人员可以在一个项目上进行协作，远程甚至离线工作。</p><h2 id="77ee" class="kv jq hi bd jr kw kx ky jv kz la lb jz iq lc ld kd iu le lf kh iy lg lh kl li bi translated">添加远程存储库</h2><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="83f0" class="kv jq hi lk b fi lo lp l lq lr">git remote add origin &lt;URL&gt;</span></pre><p id="8eed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们给我们到存储库的远程连接起了一个名字<strong class="ih hj"> origin </strong>。我们可以给它取任何名字。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="8756" class="kv jq hi lk b fi lo lp l lq lr">git remote add origin https://github.com/user/repo.git</span></pre><p id="ddc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过命令检查远程连接—</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="4fc9" class="kv jq hi lk b fi lo lp l lq lr">git remote -v</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nj"><img src="../Images/96dd9fd93a68931475d9333802587a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9PMlaAasyiscTI8SXYtcQ.jpeg"/></div></div></figure><p id="2c51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个远程存储库也将是不同分支上的提交链。</p><p id="7094" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们从远程获取提交到我们的本地存储库时，这是一个<strong class="ih hj">拉。</strong>顺便说一下<strong class="ih hj"> fetch </strong>是另一个git命令，我将很快介绍它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nk"><img src="../Images/289a495525d601268cd0da7870114116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-2UU_Th5CrusiIx-oPaog.png"/></div></div></figure><p id="2fb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们将本地存储库中的提交迁移到我们连接的远程时，这被称为<strong class="ih hj">推送</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nl"><img src="../Images/3c0e2e81bdcb92d55021678eeddd962d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iVpUtsiyzGBe98z2oSkjjA.png"/></div></div></figure><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="f57a" class="kv jq hi lk b fi lo lp l lq lr">git push &lt;remote-shortname&gt; &lt;remote-branch-name&gt;</span></pre><p id="29df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例-</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="0787" class="kv jq hi lk b fi lo lp l lq lr">git push origin master</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nm"><img src="../Images/cd19b6698c55cd512b1c017841c036c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*Rp182xzK9dEcm1l2jjhoQg.jpeg"/></div></figure><p id="79b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们更仔细地看看git clone做什么，因为我们将在下一节中用到它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nn"><img src="../Images/04728617d0cedb4508e91a8d11c63e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXPmCMe1ReQOKIpirOs78g.png"/></div></div></figure><p id="2694" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">git clone所做的是，它将所有提交从repo拉入到我们在克隆时所在的本地主分支。它还创建了一个远程跟踪分支，即<strong class="ih hj"> origin/master </strong>，它指向远程主分支上的最后一次提交。需要注意的重要一点是，尽管它是远程跟踪分支，但它不是远程主分支的实时表示。它只在推、拉和取时更新。现在提交时，只有主指针会移动。此外，如果其他合作者按下遥控器，也不会对我们的远程跟踪分支，即<strong class="ih hj">源/主产生影响。</strong></p><h1 id="464e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">拉取(区别！)</h1><p id="44a4" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">这是一个简单的公式—</p><p id="f1d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">T5】git pull = git fetch+git mergeT7】</strong></p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="4278" class="kv jq hi lk b fi lo lp l lq lr">git fetch origin master</span></pre><p id="ff73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个命令告诉git获取远程上的所有更改，但不要更改工作目录，即不要应用提交。</p><p id="5c27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，合并将只有我们讨论过的两种类型— <strong class="ih hj">常规</strong>和<strong class="ih hj">快速前进合并。</strong></p><p id="fa74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们借助一个简单的例子来理解这一点，因为这是大多数合并冲突发生的地方。</p><p id="8554" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况1) </strong>您已从遥控器中拉出，更改仅存在于遥控器上。也就是说，其他人已经在远程提交了他们的提交，而您没有在本地提交任何提交。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es np"><img src="../Images/56c4a1f05951ff9dcab87ef2aad5183b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3dRh_NqvmF8zM91NywTxA.png"/></div></div></figure><p id="c83f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你运行这个命令时—</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="ea91" class="kv jq hi lk b fi lo lp l lq lr">git pull origin master</span></pre><p id="0c36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，它会进行快进合并，而不会产生任何合并冲突。它执行以下操作:-</p><ol class=""><li id="cc19" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">将提交从远程拉入本地。</li><li id="8220" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">在本地将源/主与主分支合并。</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es np"><img src="../Images/b9e467dbdc35f043ce36a65dd8e90f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91cM6A6hPK1w6_fruVM8SA.png"/></div></div></figure><p id="711f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">案例2) </strong>我们从远程拉数据，在本地提交，而其他人在远程提交</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nq"><img src="../Images/718277a3554a342fe7c93003902bca0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wu84BvgedgqgfHnaCsrhEA.png"/></div></div></figure><p id="a196" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们现在做git pull时，它不起作用，因为两个回购不同步。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="70c9" class="kv jq hi lk b fi lo lp l lq lr">git pull origin master # this wont work </span></pre><p id="3aeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先要做的是—</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="66b2" class="kv jq hi lk b fi lo lp l lq lr">git fetch origin master</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es np"><img src="../Images/7e52181997756cebc647e0a7d5eb5bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3C7giPxLYtMCzHitht5Fw.png"/></div></div></figure><p id="bd07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将从repo中获取远程提交，但不会合并它。它还将远程跟踪分支调整为远程上的最新提交。</p><p id="04d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以通过以下命令执行合并—</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="1774" class="kv jq hi lk b fi lo lp l lq lr">git merge origin/master</span></pre><p id="4a20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，它通过创建新的提交来执行常规合并。请注意，如果我们在commit '7 '和' b '中更改了同一文件中的相同行，这里也会出现冲突。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nr"><img src="../Images/157d9a4b7816bbbfb3e84b4328c00dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IiRce3ZV0IuSwW94BFeYdQ.png"/></div></div></figure><p id="cf1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以简单地将我们的更改推送到远程，假设没有人同时将他们的提交推送到远程。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ns"><img src="../Images/7e99ae5c0e96cfe0b9106804421198b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nH6F_kHAXnO6oaZ0O5anMw.png"/></div></div></figure><p id="3e51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在远程和本地都同步了:-)</p><p id="20e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢你们一直读到最后。分叉、重置基础等。仍然存在。我们下次会见到他们。希望这有所帮助！</p></div></div>    
</body>
</html>