<html>
<head>
<title>Timer, Phase 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">定时器，第2阶段</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/timer-phase-2-d6eaae8bd7c4?source=collection_archive---------21-----------------------#2019-11-14">https://medium.com/analytics-vidhya/timer-phase-2-d6eaae8bd7c4?source=collection_archive---------21-----------------------#2019-11-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a8d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我开始谈论阶段2之前，我需要后退一步，谈谈我在这个项目的第一阶段发现的一个验证问题。我忽略了关于输入新任务名称的验证。我没有办法验证添加到数据库中的内容，虽然我的修复不是特别健壮，但对这个项目来说已经足够了。我已经在Heroku上的第一阶段应用程序中添加了这个修正。现在，进入第二阶段。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="16ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的计时器项目的第二阶段(<a class="ae jk" href="https://timer-phase-ii.herokuapp.com/timer" rel="noopener ugc nofollow" target="_blank"> Heroku </a>，<a class="ae jk" href="https://github.com/john129er/timer_phase_2" rel="noopener ugc nofollow" target="_blank"> Github </a>)关注的是重构和添加新特性。我想把这篇文章的重点放在第二阶段的三个问题上:使用样本数据、重构代码和第二阶段的新内容。</p><p id="1e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我意识到我可能需要同一个项目的至少两个变体，或者至少两个项目状态时，项目最重要的变化就来了。在第1阶段，我用数据填充数据库，这样用户就可以在一些数据被添加到系统后看到项目的样子，而不必自己手动添加这些信息。在第2阶段，我想看看项目在一个干净的状态下会是什么样子，以及在一些数据已经存在的情况下会是什么样子。</p><p id="4fcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想到了几个主意。第一步是将这一阶段分为两个部分。第一部分包括一个干净的应用程序，数据库中没有预先填充的数据。我之所以想这么做，是因为我将来构建的任何生产应用程序都不会附带样本数据，即使附带了样本数据，如果用户删除了所有样本数据，会发生什么情况呢？开箱后，我的应用程序是什么样子的，它是如何工作的？第二部分让用户有机会看到已经存在的数据的应用程序的特性。</p><p id="e5ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想到的另一个想法是简单地添加一些功能来增加或清除数据库。用户只需点击一个按钮，就可以看到任何一种状态。这是对我更有吸引力的选择。这让我想起了枯燥的编程原则，对于两个独立的应用程序，我认为会有相当多的重复。</p><p id="3470" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我考虑的第三个想法是将所有这些带回第一阶段，并将第二个想法应用到第一阶段。我很快拒绝了这个想法。我假设在任何项目中，新的想法都会浮现在脑海中，可能会极大地改进我正在开发的应用程序。我不确定我是否会尝试将项目倒回旧的状态来添加新的功能。似乎更有可能的是，无论应用程序的当前状态如何，我都会尝试加入新的功能。在这个当前的项目中，我还必须回去重做阶段1，在阶段1的帖子中记录我的更改，等等。等。</p><p id="0c76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，解决办法很简单。我创建了两个按钮和几个方法，可以根据当前日期用新的最近数据填充应用程序。如果用户愿意，所有这些数据都可以像被填充时一样轻松地删除。为了简单起见，我只允许在数据库完全为空的情况下创建数据。与阶段1中的示例数据一样，新创建的示例数据的日期是相对于用户访问应用程序的日期而言的。</p><p id="7cf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来我想谈谈重构，我想特别从一段代码开始。我先给你这段代码，我把它变成了一个私有方法:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="1ac7" class="ju jv hi jq b fi jw jx l jy jz">def tuple_to_hash(result)    <br/>    result.map do |tuple|<br/>      {<br/>        task_name: tuple['task_name'],<br/>        start_at: tuple['start_at'],<br/>        end_at: tuple['end_at'],<br/>        total_time: tuple['duration'],<br/>        task_date: tuple['task_date'],<br/>        date_stamp: tuple['date_stamp']<br/>      }<br/>    end<br/>  end</span></pre><p id="93b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码获取SQL查询的结果，并将其转换为一个散列。使我的查询包含相同的列别名是重构代码的良好开端。为了简单起见，我本打算使用相同的列名，但是<code class="du ka kb kc jq b">tuple_to_hash</code>方法确保了我不会无意中弄错列名。但是这段代码实际上带来的问题比它回答的问题要多。我的代码是同构的吗？当然可以。这就允许我创建一个这样的方法，把我的pg对象转换成一个标准化的hash。但是我发现我的大多数查询结果并不需要每一个键/值对。根据当前方法需要的键/值对，有些值可能为零。这是可以接受的吗，尤其是在一个制作app里？权衡似乎是允许一些代码的重复，而如果有人试图访问某个导致一些奇怪输出的单一方法，例如，当调用<code class="du ka kb kc jq b">tuple_to_hash</code>的方法不需要日期戳时，<code class="du ka kb kc jq b">date_stamp</code>键的值。最后，我选择了后者，因为我想不出在什么情况下会出现这样的例子。将SQL查询结果转换为散列的单个方法调用的简单性更有优势。</p><p id="12c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我实现的第二个主要重构与数据库API的返回值有关。最初，我的许多API方法会返回两个值之一，<code class="du ka kb kc jq b">nil</code>或hash。当没有查询结果返回时，我选择<code class="du ka kb kc jq b">nil</code>作为默认值，因为这样很容易实现一系列if语句。如果pg对象的大小(使用<code class="du ka kb kc jq b">ntuples</code>方法)大于零，每个if语句将返回一个值。如果它是零(即没有从数据库返回查询)，那么If语句不会运行包含代码，而只是返回<code class="du ka kb kc jq b">nil</code>。简单…，对吗？事实上，在检查代码时，<code class="du ka kb kc jq b">nil</code>看起来并不像是一个非常直观的返回值。查看下面一行代码可能需要更长时间来理解为什么<code class="du ka kb kc jq b">nil</code>是一个可能的返回值。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="ebe0" class="ju jv hi jq b fi jw jx l jy jz">@total_time = @storage.total_time_last_seven_days unless @tasks_last_seven_days.nil?</span><span id="675c" class="ju jv hi jq b fi kd jx l jy jz">@total_time = @storage.total_time_last_seven_days unless @tasks_last_seven_days.empty?</span></pre><p id="b958" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du ka kb kc jq b">nil?</code>可能没有那么令人困惑，特别是如果你瞥一眼数据库API，但是，在我看来，无论<code class="du ka kb kc jq b">@tasks_last_seven_days</code>返回什么，它很可能是过去七天的任务集合。如果这个集合是空的，为什么不使用一个名字正好暗示了这一点的方法呢？除了一些清晰之外，删除所有的if语句，以及利用上面的<code class="du ka kb kc jq b">tuple_to_hash</code>方法，我能够删除许多不必要的代码，使数据库API文件和包含我的Sinatra路线的文件中的代码更清晰、更可读。</p><p id="ba26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，第2阶段增加了两个新内容。我已经在上面讨论了样本数据的使用，所以让我继续讨论另一个新的内容:查看最近日期的任务。</p><p id="befc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我想在这个项目的第三个也是最后一个阶段添加的一些功能的先驱。过去七天内特定一天的数据显示与查看当天完成的任务相同。人们只需要点击一个日期就可以看到该日期内完成的任何任务。这里没什么特别的。当我添加更多特性时，我为阶段2的这一部分编写的大部分代码将被重用。将这个特性添加到第二阶段给了我一个平台，将来我可以从这个平台开始构建新的erb模板和方法。</p></div></div>    
</body>
</html>