<html>
<head>
<title>DataFrame for beginners using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的初学者的数据框架</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dataframe-for-beginners-using-python-e29a370c1d97?source=collection_archive---------36-----------------------#2020-05-13">https://medium.com/analytics-vidhya/dataframe-for-beginners-using-python-e29a370c1d97?source=collection_archive---------36-----------------------#2020-05-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e8f021259a26627c116d12ea82b21eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fkEOc_PB0zD_qNgT.jpeg"/></div></div></figure><p id="4363" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我知道当我有数千行要管理和实现操作时，我很难处理数据帧和管理时间复杂性，所以这里有一些内容供初学者查看和练习，以建立一些信心。</p><p id="d3d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们先来了解一下数据框，你用过微软excel吗？如果是，那么你可以跳过这一部分。如果为否，则数据帧是一个类似二维数组的结构，其中列包含变量，每行包含一组值。在下图中，col1、col2、col3是列变量。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/7832c7f4cf3dc0532f6db9b354781a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*QypuWKUtDlrPi5nsOnGvLA.jpeg"/></div></figure><p id="8ff2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从创建一个数据帧开始，</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="41a7" class="jy jz hi ju b fi ka kb l kc kd">import pandas as pd<br/>df1 = pd.DataFrame([[1, 4, 3], [4, 5, 6], [7, 8, 9]], columns = [‘col1’, ‘col2’, ‘col3’])</span></pre><p id="2b68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的命令将创建一个数据帧，看起来像这样:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/0200d86f9c4a89c672d1777148ba6547.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*gz1GgKxYZ1H3XG_bU1dKew.png"/></div></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="dd0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们有两个数据帧，</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/0200d86f9c4a89c672d1777148ba6547.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*gz1GgKxYZ1H3XG_bU1dKew.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">数据帧— df1</figcaption></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/b483d3a14dff9306f31bba358f0e8511.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*VtoS3UxBxulDaSkutmyXWA.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">数据帧— df2</figcaption></figure><p id="63ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在向任何数据帧合并或添加行时，首先我们需要忘记循环。不，对于数据帧，O(n)不是一个好方法，我们可以使用O(1)。这就是DFs派上用场并为我们节省大量时间的地方。</p><p id="3c3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们需要<strong class="is hj">合并基于列-1的df1和df2 </strong>，首先出现一个问题，我们需要如何合并-左？对吗？内心？还是外？这些是连接的类型，如果我们没有提到它会自动检测内部连接。下面的命令显示了内部连接。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="1179" class="jy jz hi ju b fi ka kb l kc kd">df1 = df1.merge(df2, left_on = ‘col1’, right_on = ‘col1’, how = ‘left’)</span></pre><p id="6eb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在“左_开”和“右_开”中，我们提到了要考虑连接的列。这里，我们基于列“col1”进行连接，df1与df2合并。现在，数据帧看起来像</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/6bdcd4131a21b287c6bbfbbeddcc1c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_j8Iydz4hjDnJRCF-1Iqqw.png"/></div></div></figure><p id="39a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我们不希望df2的列包含在df1中，那么代码将看起来像-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="fa7f" class="jy jz hi ju b fi ka kb l kc kd">df1 = df1.merge(df2['col1'], left_on = 'col1', right_on = 'col1', how = 'left')</span></pre><p id="e6e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由此，我们只能看到“列1”、“列2”和“列3”。df2['col1']合并时我们只包含了' col1 '。看看下面的图片就知道区别了。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/693beae9554bd8a97ebd0c9e3a991175.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*KsfB-0JzSqZAxfJCEuMowA.png"/></div></figure><p id="299a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有时，您需要知道哪一行出现在df1和/或df2中。为此，我们使用一个指示符，这有助于我们增加一列，说明“仅左”、“仅右”或“两者都有”</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="562c" class="jy jz hi ju b fi ka kb l kc kd">df1 = df1.merge(df2['col1'], left_on = 'col1', right_on = 'col1', how = 'left', indicator = True)</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/6d2dcfdd30d0e2f79612b02db6dfcccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*kMrFI6Wh140JxnnEa-5W7Q.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">带指示器的数据框</figcaption></figure><p id="0bde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我们需要删除行where _merge = 'left_only '，添加一个' query '和drop-merge列。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="4419" class="jy jz hi ju b fi ka kb l kc kd">df1 = df1.merge(df2['col1'], left_on = 'col1', right_on = 'col1', how = 'left', indicator = True).query("_merge == 'left_only'").drop('_merge',axis = 1)</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/1cdf4b12b089a911eaeb799d7b2cad6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*7QdKRvctWnnWBCp7MgxHlw.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">仅用left_only删除合并</figcaption></figure><p id="2e43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我应该告诉你每一行都有一个索引，所以如果你正在使用<strong class="is hj"> anaconda </strong>的话，无论如何你都可以看到它，下面是有索引的图片。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kv"><img src="../Images/5e2a842c962dd3960bd6754184d23789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*a-Web5m27tcc91DyI3s-Hg.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">图1</figcaption></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/f3f630d2b3ed1f17f607572a6754620a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*LotlEDLtmUuWgIp72s1sGw.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">图2</figcaption></figure><p id="8db7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">图2 </strong>是“仅左合并”的图像。但是，索引值是3而不是0。原因是，每一行都有一个唯一的索引值，所以如果删除其他行，索引值不会改变。但是，在每次合并操作后重置索引是一个很好的做法。遵循代码片段。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="60e7" class="jy jz hi ju b fi ka kb l kc kd">df1.reset_index(drop = True, inplace = True)</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kv"><img src="../Images/57a6738bc1e89dff1cc0f93d10d22797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*U1vMO5bAR28-swbG6qaeFg.png"/></div></figure><p id="fa7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是它看起来的样子，为什么我用了<strong class="is hj"> inplace = True </strong>？当我们分配一些任务时，我们必须将它保存到变量中，这里我们使用相同的变量来分配更改，它类似于</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="103a" class="jy jz hi ju b fi ka kb l kc kd">df1 = df1.reset_index(drop = True)</span></pre></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="70d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">将列</strong>添加到DataFrame，让我们考虑原始的df1(第一个图像)。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b409" class="jy jz hi ju b fi ka kb l kc kd">df1['col4'] = ''</span></pre><p id="7dbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建名为“col4”的新列时，所有行值都为空。</p><p id="db75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Drop a column </strong>，当你需要用一个数据框应用几个任务时，这个就派上用场了。在下面的代码片段中，我使用了axis = 1来搜索列中的名称。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="20f1" class="jy jz hi ju b fi ka kb l kc kd">df1.drop('col1', inplace = True, axis = 1)</span></pre><p id="e992" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">删除行中重复的</strong>值，如果我们需要在特定的列中找到重复的值，那么我们使用关键字“子集”，否则不要使用它。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="6735" class="jy jz hi ju b fi ka kb l kc kd">df1.drop_duplicates(subset = 'col1', inplace = True)</span></pre><p id="43ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于特定列的条件返回行的<strong class="is hj">索引值</strong>。有时我们需要索引值，然后再使用它们。这是一个代码片段-</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="86b9" class="jy jz hi ju b fi ka kb l kc kd">index_values = df1[df1['col1'] == 1].index</span></pre><p id="27dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在数据帧中，“and”、“or”不起作用，我们必须使用布尔型，使用“&amp;”和“|”就可以了。同样，当我们需要搜索数组中的值时，我们使用“in ”,但是对于数据帧，我们使用“isin”关键字。请参见代码片段。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="5635" class="jy jz hi ju b fi ka kb l kc kd">array = [1,4,9]<br/>1 in array<br/># This returns True but we cannot use this in DataFrames</span><span id="5578" class="jy jz hi ju b fi kx kb l kc kd">df1['col1'].isin(array)<br/># 'col1' has values [1,4,7]</span><span id="62ad" class="jy jz hi ju b fi kx kb l kc kd">''' <br/>This returns<br/>0     True<br/>1     True<br/>2    False<br/>'''</span></pre><p id="1941" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望，我已经讲了足够的内容，可以让你从数据框架开始，并建立一些信心。</p></div></div>    
</body>
</html>