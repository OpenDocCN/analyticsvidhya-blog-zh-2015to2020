<html>
<head>
<title>BASICS OF DJANGO : Chapter II [Apps, Urls, Views and Templates]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DJANGO基础:第二章[应用、URL、视图和模板]</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/basics-of-django-chapter-ii-apps-urls-views-and-templates-d647eaef69e4?source=collection_archive---------21-----------------------#2020-05-17">https://medium.com/analytics-vidhya/basics-of-django-chapter-ii-apps-urls-views-and-templates-d647eaef69e4?source=collection_archive---------21-----------------------#2020-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/472b15bddba175dcb58dba473fc48b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u6hbCiFiFlVDHlkT"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马库斯·斯皮斯克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="fa2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在我之前的博客中看到了一些基本概念，如果你还没有看过的话，可以看看这里:<br/><a class="ae iu" rel="noopener" href="/@harshkumar700/basics-of-django-23a954959d94"><em class="jt">https://medium . com/@ harshkumar 700/basics-of-django-23a 954959 d94</em></a></p><p id="fb76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续说，姜戈的世界里还有很多值得我们探索的地方。在这篇博客中，我们将详细了解应用程序、URL、视图和模板。所以没有更多的麻烦，</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><h1 id="0229" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">应用程序</h1><p id="43e0" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在前一篇博客中，我们开始了我们的新项目，并让它运行起来。现在，在我们进入其他概念之前，我们必须了解Django中的“应用”以及它们与“项目”的区别。一个app基本上提供了我们正在开发的网站(项目)中的一个功能。它是为一个目的服务的，在网站中做一些特别的事情。<br/>一个项目就是我们正在开发的整个项目或者网站。根据网站所需的不同功能，项目可能包含不同的应用程序。例如，如果我们正在建立一个电子商务网站(这是整个项目)，我们可能会添加各种用于不同目的的应用程序，如服务于用户成功支付的支付网关应用程序，用于现有用户登录的登录应用程序等等。干得好，伙计们！现在我们知道Django中的app是什么，以及它与项目有何不同。</p><p id="79aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续，我们如何开始一个项目已经在之前的博客中解释过了，但只是为了唤起你的记忆，这里是我们如何做的。我们运行以下命令</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="d94c" class="li kb hi le b fi lj lk l ll lm"><strong class="le hj">$</strong> python manage.py startproject &lt;project-name&gt;</span></pre><p id="643f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将创建一个包含多个Python文件的目录。现在，在这个项目中，假设我们需要添加一个新的应用程序来提供特定的功能；我们首先进入项目目录，如下所示:</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="f548" class="li kb hi le b fi lj lk l ll lm"><strong class="le hj">$</strong> cd &lt;project-name&gt;</span></pre><p id="d6c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，运行命令，</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="30e1" class="li kb hi le b fi lj lk l ll lm"><strong class="le hj">$ </strong>python manage.py startapp &lt;app-name&gt;</span></pre><p id="4109" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">快速注意:</em> </strong> <em class="jt">以上命令及以后所有命令，均针对Linux和macOS。如果你在Windows上，你所要做的就是把开始的‘python’替换成‘py’，就像</em> <code class="du ln lo lp le b"><strong class="ix hj">$</strong> py manage.py startapp &lt;app-name&gt;</code></p><p id="b115" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不言而喻，你可以用自己选择的名字替换<app-name>。此命令将根据您的应用程序和文件的名称创建一个目录，其位置结构如下所示:</app-name></p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="a559" class="li kb hi le b fi lj lk l ll lm">&lt;app-name&gt;/<br/>    __init__.py<br/>    admin.py<br/>    apps.py<br/>    migrations/<br/>        __init__.py<br/>    models.py<br/>    tests.py<br/>    views.py</span></pre><p id="f5e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">典型的Django项目结构如下所示:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/f90a092dfe66f96c8cb3b324432f9dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/0*3BFkOsD7LR-YyEra.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://djangobook.com/wp-content/uploads/structure_drawing1.png" rel="noopener ugc nofollow" target="_blank">https://djangobook . com/WP-content/uploads/structure _ drawing 1 . png</a></figcaption></figure><p id="a32b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要在我们的项目中包含该应用程序，我们还需要一个步骤。我们需要将应用程序名称添加到<code class="du ln lo lp le b">settings.py</code>文件中的<code class="du ln lo lp le b">INSTALLED_APPS</code>列表，如下所示:</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="5e5f" class="li kb hi le b fi lj lk l ll lm">INSTALLED_APPS = [<br/>    '&lt;app-name&gt;',<br/>    'django.contrib.admin',<br/>    'django.contrib.auth',<br/>    'django.contrib.contenttypes',<br/>    'django.contrib.sessions',<br/>    'django.contrib.messages',<br/>    'django.contrib.staticfiles',<br/>]</span></pre><p id="1686" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太棒了。至此，我们在理解Django基础知识的旅程上向前迈进了一步，但这还没有结束。现在，是时候让我们通过Django中的<em class="jt">URL</em>的概念来<em class="jt">看看视图</em>和<em class="jt">冲浪</em>了。</p><h1 id="0cc7" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">URL和视图</h1><p id="0282" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们现在将了解什么是URL和视图，以及它们是如何连接的。在这篇博客的后面，我们还将了解与这两者密切相关的另一个组件。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/63c7587b0d276eab35b5a0056b5e00c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gaGvq6cYQ8MOJIDZse9uTg.jpeg"/></div></div></figure><p id="d792" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上图试图解释整个连接，以及工作是如何在幕后完成的。但是让我们更详细地看看。假设，我们请求一个页面，比如“/about_us”页面。该请求指向应用程序的<code class="du ln lo lp le b">urls.py </code>文件，然后该文件决定需要触发<code class="du ln lo lp le b">views.py</code>中的哪个功能。<code class="du ln lo lp le b">urls.py</code>文件查看<code class="du ln lo lp le b">/about_us</code> url，并在那里找到需要触发的函数名。然后启动该函数，无论我们告诉该函数做什么，它都会在用户访问该URL时完成。这样，某种响应被发送到浏览器，比如HTTP响应或HTML模板。好吧，如果你没有完全掌握它，也不要担心。一个实际的例子可以在很大程度上澄清这一点。例如，我们创建了一个名为<code class="du ln lo lp le b">basic_blog</code>的网站(项目)。然后我们创建了一个应用程序，它的名字是，比如说我们项目中的<code class="du ln lo lp le b">blogs_app</code>，<code class="du ln lo lp le b">basic_blog</code>。现在我们需要添加两个视图。一个用于主页，另一个用于“关于我们”页面。因此，在<code class="du ln lo lp le b">blogs_app</code>中的<code class="du ln lo lp le b">views.py</code>文件下，我们编写以下代码。</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="6105" class="li kb hi le b fi lj lk l ll lm">from django.http import HttpResponse</span><span id="e1d9" class="li kb hi le b fi ls lk l ll lm">def home(request):<br/>    return HttpResponse('Home')<br/><br/>def about_us(request):<br/>    return HttpResponse('About Us')</span></pre><blockquote class="lt lu lv"><p id="c331" class="iv iw jt ix b iy iz ja jb jc jd je jf lw jh ji jj lx jl jm jn ly jp jq jr js hb bi translated"><a class="ae iu" href="https://docs.djangoproject.com/en/3.0/ref/request-response/" rel="noopener ugc nofollow" target="_blank">当一个页面被请求时，Django创建一个</a> <code class="du ln lo lp le b"><a class="ae iu" href="https://docs.djangoproject.com/en/3.0/ref/request-response/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">HttpRequest</strong></a></code> <a class="ae iu" href="https://docs.djangoproject.com/en/3.0/ref/request-response/" rel="noopener ugc nofollow" target="_blank">对象，其中包含关于请求的元数据。然后Django加载适当的视图，将</a> <code class="du ln lo lp le b"><a class="ae iu" href="https://docs.djangoproject.com/en/3.0/ref/request-response/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">HttpRequest</strong></a></code> <a class="ae iu" href="https://docs.djangoproject.com/en/3.0/ref/request-response/" rel="noopener ugc nofollow" target="_blank">作为第一个参数传递给视图函数。每个视图负责返回一个</a> <code class="du ln lo lp le b"><a class="ae iu" href="https://docs.djangoproject.com/en/3.0/ref/request-response/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">HttpResponse</strong></a></code> <a class="ae iu" href="https://docs.djangoproject.com/en/3.0/ref/request-response/" rel="noopener ugc nofollow" target="_blank">对象。</a></p><p id="33b9" class="iv iw jt ix b iy iz ja jb jc jd je jf lw jh ji jj lx jl jm jn ly jp jq jr js hb bi translated"><strong class="ix hj">快速注释</strong>:这里有一个关于两种观点的伟大博客，供你补充知识。一定要读一读:<a class="ae iu" rel="noopener" href="/@ksarthak4ever/django-class-based-views-vs-function-based-view-e74b47b2e41b">https://medium . com/@ ksarthak 4 ever/django-class-based-views-vs-function-based-view-e 74 b 47 b 2 e 41 b</a></p></blockquote><p id="f910" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在对于URL部分，首先我们必须在app文件夹中创建一个名为<code class="du ln lo lp le b">urls.py</code>的文件夹，然后向其中添加以下代码:</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="b3ba" class="li kb hi le b fi lj lk l ll lm">from django.contrib import admin<br/>from django.urls import path<br/>from . import views<br/>urlpatterns = [<br/>    path('admin/', admin.site.urls),<br/>    path('about_us/', views.about_us),<br/>    path('', views.homepage)<br/>]</span></pre><ul class=""><li id="233e" class="lz ma hi ix b iy iz jc jd jg mb jk mc jo md js me mf mg mh bi translated"><code class="du ln lo lp le b">path(‘admin/’, admin.site.urls)</code>行意味着对于每个以<code class="du ln lo lp le b">admin/</code>开头的URL，Django都会找到一个相应的视图。在这里，我们包括了许多管理网址。</li><li id="7e38" class="lz ma hi ix b iy mi jc mj jg mk jk ml jo mm js me mf mg mh bi translated">类似地，<code class="du ln lo lp le b">path(‘about_us/’, views.about_us )</code>行意味着对于每个以<code class="du ln lo lp le b">about_us/</code>开头的URL，Django将找到一个相应的视图，这里是<code class="du ln lo lp le b">views.py</code>中的<code class="du ln lo lp le b">about_us</code></li><li id="1d42" class="lz ma hi ix b iy mi jc mj jg mk jk ml jo mm js me mf mg mh bi translated">现在，<code class="du ln lo lp le b">path('', views.home )</code>行告诉<code class="du ln lo lp le b">views.py</code>文件在基本URL前面没有附加任何内容时触发<code class="du ln lo lp le b">homepage</code>视图。</li></ul><p id="cec0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，只发送一个HttpResponse向我们展示了整个设置的工作原理，但是只显示纯文本有点…嗯，有点乏味。如果我们可以通过发送HTML模板而不是仅仅发送纯文本来使它变得有趣，这不是很棒吗？嗯，我们很幸运，因为这是我们之前谈到的第三个组件发挥作用的地方，那就是“模板”</p><blockquote class="lt lu lv"><p id="a09b" class="iv iw jt ix b iy iz ja jb jc jd je jf lw jh ji jj lx jl jm jn ly jp jq jr js hb bi translated"><strong class="ix hj">快速重要提示</strong>:由于在一个给定的项目中可能有许多应用程序，每个应用程序都有自己的一组URLs基础app中有一个基础URL文件<code class="du ln lo lp le b">urls.py</code>，是你启动项目时自动创建的。它用于将所有应用程序路径连接到项目。我们可以用下面的方法来做。</p></blockquote><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="7628" class="li kb hi le b fi lj lk l ll lm">from django.contrib import admin<br/>from django.urls import path, include<br/>from . import views<br/><br/>urlpatterns = [<br/>    path('admin/', admin.site.urls),<br/>    path('blogs_app/', include('blogs_app.urls')),<br/>]</span></pre><h1 id="efe2" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">模板</h1><p id="949a" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">当我们启动Django应用程序时，模板目录不会像其他文件和目录一样自动创建。我们需要在app目录中创建一个名为“templates”的目录。因此，模板基本上包含了所需HTML输出的静态部分。<br/>在上面的<code class="du ln lo lp le b">views.py</code>文件中，我们将HttpResponse返回给了浏览器。我们现在将发回HTML模板，而不是那样做。为此，第一步显然是在上面提到的app目录中创建一个名为“templates”的新目录。在' templates '目录中，我们创建两个HTML文件，一个用于名为say homepage.html的主页，另一个用于名为about_us.html. <br/>的关于我们的页面，在homepage.html，</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="4b02" class="li kb hi le b fi lj lk l ll lm">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;title&gt;Home&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;h1&gt;Home Page&lt;/h1&gt;<br/>    &lt;p style="color:blue;"&gt;Welcome to our site&lt;/p&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="b829" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而在about_us.html中</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="d00c" class="li kb hi le b fi lj lk l ll lm">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;title&gt;About Us&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;h1&gt;About Us&lt;/h1&gt;<br/>    &lt;p style="color:red;"&gt;We Love Django!&lt;/p&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="1cea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是你能遇到的最基本的HTML代码。如果你懂HTML，你知道你可以做得更多，但是为了简单的解释，这里有一个非常基本的代码。如果你还不知道HTML并且想要学习它，你可以从现在开始，也许可以尝试一下:<br/><a class="ae iu" rel="noopener" href="/hackernoon/learn-basic-html-be230361457">https://medium.com/hackernoon/learn-basic-html-be230361457</a></p><p id="ec66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，我们已经准备好了HTML模板，现在我们要做的就是修改我们的<code class="du ln lo lp le b">views.py</code>文件，这样它就可以将这些HTML模板发送到浏览器，而不是像以前那样发送一些纯文本。我们不必做太多；只需进行如下所示的一些更改:</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="5381" class="li kb hi le b fi lj lk l ll lm">#from django.http import HttpResponse<br/>from django.shortcuts import render<br/><br/><br/>def homepage(request):<br/>    return render(request, 'homepage.html')<br/><br/><br/>def about_us(request):<br/>    return render(request, 'about_us.html')</span></pre><blockquote class="lt lu lv"><p id="512a" class="iv iw jt ix b iy iz ja jb jc jd je jf lw jh ji jj lx jl jm jn ly jp jq jr js hb bi translated"><a class="ae iu" href="https://docs.djangoproject.com/en/3.0/topics/http/shortcuts/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">包</em> </a> <code class="du ln lo lp le b"><a class="ae iu" href="https://docs.djangoproject.com/en/3.0/topics/http/shortcuts/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="hi">django.shortcuts</em></strong></a></code> <a class="ae iu" href="https://docs.djangoproject.com/en/3.0/topics/http/shortcuts/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">收集了“跨越”多级MVC的助手函数和类。换句话说，为了方便起见，这些函数/类引入了受控耦合。</em></a><code class="du ln lo lp le b"><a class="ae iu" href="https://docs.djangoproject.com/en/3.0/topics/http/shortcuts/" rel="noopener ugc nofollow" target="_blank"><em class="hi">render</em></a></code><a class="ae iu" href="https://docs.djangoproject.com/en/3.0/topics/http/shortcuts/" rel="noopener ugc nofollow" target="_blank"><em class="hi">(request，template_name，context=None，content_type=None，status=None，using=None)将给定的模板与给定的上下文字典相结合，并返回一个带有渲染文本的</em> </a> <code class="du ln lo lp le b"><a class="ae iu" href="https://docs.djangoproject.com/en/3.0/topics/http/shortcuts/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="hi">HttpResponse</em></strong></a></code> <a class="ae iu" href="https://docs.djangoproject.com/en/3.0/topics/http/shortcuts/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">对象。</em>T25】</a></p></blockquote><p id="7273" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，当用户请求一个带有URL的页面时，比如说<code class="du ln lo lp le b">…/about_us</code>；它被定向到urls.py文件，然后该文件检查此URL。找到后，它会在<code class="du ln lo lp le b">path(‘about_us/’, views.about_us)</code>行中寻找需要触发的视图。它看到需要触发<code class="du ln lo lp le b">views.about_us</code>。在<code class="du ln lo lp le b">views.py</code>文件中，我们看到视图返回一个名为<code class="du ln lo lp le b">about_us.html</code>的HTML模板(存储在templates目录中)，如在<code class="du ln lo lp le b">about_us</code>视图下的行<code class="du ln lo lp le b">return render(request, ‘about_us.html’)</code>所示。这样，响应被发送到显示相应HTML模板的浏览器。</p><p id="8c1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">厉害！在了解Django基础知识的旅程中，我们已经走了很远！但这还没有结束。嗯，</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="d58c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读！我希望你喜欢这篇文章。<br/>欢呼声一如既往..快乐学习。:)</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="6cc8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和我联系:<br/>LinkedIn—<a class="ae iu" href="http://www.linkedin.com/in/harsh-kumar-1a99a0176" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/harsh-kumar-1a99a0176</a>T3】Github—<a class="ae iu" href="https://github.com/harsh-kr" rel="noopener ugc nofollow" target="_blank">www.github.com/harsh-kr</a></p></div></div>    
</body>
</html>