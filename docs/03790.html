<html>
<head>
<title>A treasure map to Twitter Data via Tweepy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Tweepy获取Twitter数据的藏宝图</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-treasure-map-to-twitter-data-via-tweepy-b7e3d624d88d?source=collection_archive---------1-----------------------#2020-02-19">https://medium.com/analytics-vidhya/a-treasure-map-to-twitter-data-via-tweepy-b7e3d624d88d?source=collection_archive---------1-----------------------#2020-02-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9d30af30609004a9984354f6974881b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKAQKg7e-C2GxKWntbXCgA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">安妮·斯普拉特在<a class="ae iu" href="https://unsplash.com/s/photos/map?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ae1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好。对于任何想要开发伟大的东西、进行数据分析、测试SOTA深度学习模型或学习数据科学的人来说，Twitter数据都是一个真正的美味来源。出于上述原因，我使用Twitter API已经有一段时间了。在本文中，我想为那些想从Twitter数据入手的人提供一个全面的指南。你可能会喜欢这篇文章，即使你已经进入twitter API，因为我也将谈论最近的政策申请twitter开发帐户等。</p><p id="0de6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章向读者展示了这些:</p><ol class=""><li id="10eb" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><em class="kc">在Twitter上创建一个开发者账户。</em></li><li id="5211" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">识别现实生活中的问题，并找到解决问题的twitter数据方法。</li><li id="1530" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated"><em class="kc">抓住流背后的逻辑，收集过往数据。</em></li><li id="268b" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated"><em class="kc">使用代码样本从用户时间线获取数据。</em></li></ol><h1 id="6018" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">寻找动机</h1><p id="e9bb" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我们每天都在使用twitter，作为技术人员，我们无法避免自己思考“如果我接触到它的最微小的一部分，会发生什么”，这里的动机是分析日常生活中的一些东西，并将你的技术技能应用到现实生活中的问题。所以让我们激励自己去解决一个问题。本文将解释的问题是，为了分析新闻标题中的名人，纽约时报将获取所有推文。当然，你可能会想出一个更有趣的问题，并产生更好的动机去解决它。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/469fce3441200c0f717001be1db4bb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eR08g2qCJMxyH5U9rSVGbg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">迈克尔·泽兹奇在<a class="ae iu" href="https://unsplash.com/s/photos/treasure-hunt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="83a1" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">创建Twitter API开发帐户</strong></h1><p id="f9ae" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">Twitter提供了几个API。它们中的每一个都是为特定的用例而构建的。简而言之，<a class="ae iu" href="https://developer.twitter.com/en/docs/tweets/search/api-reference/get-search-tweets" rel="noopener ugc nofollow" target="_blank"> standard </a> API是免费的，对于新手、想要测试Twitter的数据爱好者等来说很好。高级API更进了一步，它是为希望进行更多试验的人而设计的，高级API得到了进一步增强，提供了达到30天数据/完整归档数据的选项。高级API的细节可以在<a class="ae iu" href="https://developer.twitter.com/en/docs/tweets/search/api-reference/premium-search" rel="noopener ugc nofollow" target="_blank">这里</a>找到。面向企业和机构的通用企业和广告API高度依赖Twitter数据。作为开发人员，您的访问将介于标准API和高级API之间。</p><p id="c107" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">设置开发者账户的方法。</p><ol class=""><li id="1052" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">使用您的Twitter帐户登录。您的帐户必须拥有有效的电话号码。</li><li id="ff74" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">去Twitter的开发者应用<a class="ae iu" href="https://developer.twitter.com/en/apply-for-access" rel="noopener ugc nofollow" target="_blank">页面</a>。</li><li id="799d" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">点击<strong class="ix hj">申请开发者账号</strong>部分。</li><li id="6b01" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">在下一页选择你的主要原因。Twitter想知道你获取其数据的野心。在这里要公开和具体。在下一部分，twitter将会询问更多关于您的意图。对于我们这里的有趣任务，我选择了<strong class="ix hj">爱好者</strong>部分，假设我们将制作一个机器人并探索twitter API。</li><li id="34e1" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">在下一页，您将看到您帐户的摘要，Twitter只是想确认您是一个真实的人，如果您还没有提供这些具体细节，它可能会问一些问题，如电话号码、国家等。</li><li id="e256" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">下一页是<strong class="ix hj">预期用途</strong>页。你可能会认为这个阶段是签证申请阶段(土耳其国民可以理解)，你需要让当局相信你是一个负责任和正派的人，你获得开发者权限的目的不会违反Twitter条款。在第一个文本框中，解释“你计划如何使用Twitter数据或API ”,在这里尽量明确。你可以告诉他们，你将对某个特定的主题进行特定的分析，为此，你需要访问搜索API，但数据应该是最近1年的，以便计算这个主题的受欢迎程度。请注意，这只是一个虚构，不要抄袭，把你自己的话放进去。</li><li id="7a36" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">在下一个文本框中，他们要求你描述如何分析Twitter数据(如果这是你的计划)，再次尝试具体和开放。你可以告诉他们，对于特定的政治主题，你将使用搜索API，根据推文，你将按小时/天的细分报告推文中确切单词的用法，以查看这些是否与特定的政治事件、演讲、组织等相关。例如，对于单词“<strong class="ix hj">气候变化</strong>”，您可能想分析这个词在Greta在欧洲议会的演讲之后的流行程度。或者这个术语可以是“<strong class="ix hj">你怎么敢</strong>”。</li></ol><p id="6e24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">8.在下一个文本框中，他们会询问您的API范围的用法。写下适当的选项，例如“是的，我将只使用Tweet功能”。</p><p id="1820" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">9.一些个人或组织可能会在其网站上显示其官方账户的推文。如果您计划在您的网站中添加这样的功能，您应该在“<strong class="ix hj">您是否计划在twitter </strong>之外显示或聚集关于Twitter内容的数据”部分详细说明Twitter数据的使用。</p><p id="4e11" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">10.在下一部分，您将被询问是否与政府机构分享您的分析或任何基于Twitter数据获得的成就。用开放的心态回答这个问题。</p><p id="93cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">11.在下一步的申请中，你将审查你的申请并期望阅读和接受使用条款。然后你可以发送你的申请。</p><p id="1eb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你的回答很清楚，足以让人觉得你确实知道该如何处理Twitter数据，或者至少你愿意学习，Twitter通常会在一天内批准开发者账户。如果你遵循了这篇文章中的提示，我想不出有什么理由你不会被批准。</p><p id="6757" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">获得批准后，您将收到一封电子邮件通知，您将能够创建一个应用程序。你将被期望为你通过Twitter执行的每个特定分析和任务创建一个应用程序。该应用程序将有访问令牌，您将使用它们在Twitter API中进行身份验证。在应用程序创建过程中，您将被询问使用意图，因此我建议您将答案复制到申请表中，这样您就不必再一次解释自己了。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/a6bb459159680fdc17140b905aa88a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbyc0c6C5Osj6cfQNml_Hw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@hoseinamiri?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Hosein Amiri </a>在<a class="ae iu" href="https://unsplash.com/s/photos/mountaion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="cae1" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">流式传输和收集过去数据背后的逻辑</strong></h1><p id="6253" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我试图给你一点点使用Twitter数据可以实现的东西，然而，这篇文章只提到了其中的一部分。如果你觉得你可以用更多的想象力来激励自己，我强烈推荐你访问<a class="ae iu" href="https://developer.twitter.com/en.html#/" rel="noopener ugc nofollow" target="_blank"> Twitter文档</a>了解使用案例。API中定义了许多实用程序，您可以关注或搜索用户以及包括特定单词或短语的推文，获取关于用户的信息，如他们的关注者，管理帐户，屏蔽或阻止用户，您可以管理推文集合，从用户时间线获取推文，等等。你可以从<a class="ae iu" href="https://developer.twitter.com/en/docs/api-reference-index" rel="noopener ugc nofollow" target="_blank">这里</a>查看Twitter API的所有功能。实际上，我建议你在等待API批准的时候逛逛。</p><p id="0195" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无论你希望从Twitter数据中获得什么，当处理大量推文时，你有两种选择:要么选择推文的时间线——这意味着你可能需要一些过去的推文，如上面Greta演讲的例子，要么你可以实时测量某个品牌的公众影响力，如<a class="ae iu" href="https://developer.twitter.com/en/use-cases/analyze" rel="noopener ugc nofollow" target="_blank">用例</a>中提到的情绪分析。</p><p id="d15d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">流媒体比搜索过去的推文更容易一些，当然，取决于你的API，会有一些限制。例如，在使用标准API搜索实时推文时，你可能会丢失一些数据。要传输twitter数据，你只需连接一个流媒体端点，你可以把整个过程想象成从一个几乎不关的窗口持续下载。当然，有时流式API不得不停止响应，这可能是一个错误的功能或超出了速率限制。更多详情可以访问<a class="ae iu" href="https://developer.twitter.com/en/docs/tweets/filter-realtime/guides/connecting" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="9d34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，收集过去的数据需要您进行历史功率跟踪或全面的档案搜索。由于power track和archive search是在Enterprise API中提供的，我将把这个<a class="ae iu" href="https://developer.twitter.com/en/docs/tweets/batch-historical/overview" rel="noopener ugc nofollow" target="_blank">链接</a>留给以后阅读。因为在我们的文章中，我们将采用最便宜的方式:从用户时间线获取历史推文。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/51cf9b433db7f6f0f32ce3c06cf7106c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQhfaD2_oX3ZYQXZvYWh_g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">布伦特·德·兰特在<a class="ae iu" href="https://unsplash.com/s/photos/building?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="186e" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">从用户时间线获取推文</h1><p id="bbf5" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">所以最后在这里谈谈这篇文章的主要吸引力。回到我们最初的问题“<strong class="ix hj"> <em class="kc">”根据名人在《纽约时报》上的文章</em> </strong>来估计他们的受欢迎程度让我们想象一下，我们将获取纽约时报官方twitter的时间线推文，为了这样做，我们显然需要的是屏幕名称(帐户如何出现在twitter中)或帐户的twitter id，以及获取属于该特定用户的推文的方法。让我们来一场关于方法论的头脑风暴，我们都认为我们需要一些分页来获取tweets，但是怎么做呢？考虑到Twitter的流性质，页面上总是有新成员。应该怎么执行呢？此外，请注意Twitter的页面结构就像一个堆栈，新推文放在顶部，旧推文放在底部，即<a class="ae iu" href="https://stackoverflow.com/questions/10974922/what-is-the-basic-difference-between-stack-and-queue" rel="noopener ugc nofollow" target="_blank">后进先出</a>。因此，获取推文，无论如何，都是从上到下的阅读。下面是从<a class="ae iu" href="https://developer.twitter.com/en/docs/tweets/timelines/guides/working-with-timelines" rel="noopener ugc nofollow" target="_blank">官方推特文档</a>中截取的一张图片，描绘了整个过程。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/96000a6bf28f12627ba52a98787a6318.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*vOlbuS1i4INxbT-jtbtdQA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">摘自Twitter API <a class="ae iu" href="https://developer.twitter.com/en/docs/tweets/timelines/guides/working-with-timelines" rel="noopener ugc nofollow" target="_blank">文档</a></figcaption></figure><p id="b078" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以每次，我们从用户时间线中获取我们不应该超过的特定推文。这是因为上面的tweets是在我们开始处理之后添加到堆栈中的，我们的处理是向下而不是向上的。在整个小节中，我还将解释如何在上面的行中获取这些tweets。现在，让我们简单地想一想，我们的工作只是能够从用户时间表中获取数据。一种古老的实现方法是创建一个无限的while循环，只有当底部没有成员或者窗口大小达到极限时，这个循环才会退出。这里的窗口大小是一个用户有3200条推文，即使我们将<em class="kc"> include_rts </em>设置为<em class="kc"> False </em>，转发也会被计算在内。欲了解更多关于限制和使用等的信息，请访问<a class="ae iu" href="https://developer.twitter.com/en/docs/tweets/timelines/api-reference/get-statuses-user_timeline" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="c2f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">窗口中的数据可以批量检索，此方法的最大批量为200。因此，这个想法是从上到下获取推文，在一次呼叫中最多获取200条推文，并完成整个过程，直到您达到3200条推文(窗口大小)。请注意，如果您将include_rts参数设置为False，那么在该过程结束时，您的tweets可能会少于3200条，但是API无论如何都会将您丢弃。此外，在每个批次中，您必须保留minimum_id，因为在下一次运行中，上一批次中显示的min_id将是下一批次的最大id。这里:</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/0a08fe5dd5625d856fe9688dd524ea09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6IECgSSwPTsjnYlyUxw8Ng.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">描绘窗口和批次，摘自twitter官方<a class="ae iu" href="https://developer.twitter.com/en/docs/tweets/timelines/guides/working-with-timelines" rel="noopener ugc nofollow" target="_blank"> doc </a></figcaption></figure><p id="b949" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果上面的解释是清楚的，我们可以拿出我们的方法的伪代码，如:</p><pre class="lt lu lv lw fd ma mb mc md aw me bi"><span id="5890" class="mf kj hi mb b fi mg mh l mi mj">tweet_ids_arr = list<br/>flag keep_going=True<br/>min_id_of_previous_batch = dummy_big_int<br/><br/>while keep_going:<br/>    tweets = fetch_user_time_line(max_id=min_id_of_previous_batch, <br/>                                  batch_size=20)<br/>    <br/>    tweet_ids_arr.extend([tweet.id for tweet in tweets])<br/>    min_id_of_previous_batch = min(tweet_ids_arr)<br/>    if len(tweets) == 0:<br/>         keep_going = False</span></pre><p id="748b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，必须有一些额外的东西，如异常处理和设置计时器，以避免速率限制错误。我们很快就会到达那里。现在是时候讨论如何获取上面几行的推文了。</p><p id="1c59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您在2月14日获取了推文，队列中的最大日期是2月14日，因此您需要获取比2月14日更新的推文，但您也必须在每次向Twitter API发送请求时自动完成。因此，我们需要用<strong class="ix hj"> <em class="kc">增强max_id的用法，因为_id </em> </strong>让我们用下面的伪代码来描述逻辑:</p><pre class="lt lu lv lw fd ma mb mc md aw me bi"><span id="5681" class="mf kj hi mb b fi mg mh l mi mj">tweet_ids_arr = list<br/>flag keep_going=True<br/>min_id_of_previous_batch = dummy_big_int<br/># The max id in stored tweets from a previosly fetch-save<br/>max_id_in_db = max_id_in_stored_tweets<br/>while keep_going:<br/>    tweets = fetch_user_time_line(max_id=min_id_of_previous_batch, <br/>                                  since_id= max_id_in_db<br/>                                  batch_size=20)<br/>    <br/>    tweet_ids_arr.extend([tweet.id for tweet in tweets])<br/>    min_id_of_previous_batch = min(tweet_ids_arr)<br/>    if len(tweets) == 0:<br/>         keep_going = False</span></pre><p id="dd8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的图片来自官方Twitter文档<a class="ae iu" href="https://developer.twitter.com/en/docs/tweets/timelines/guides/working-with-timelines" rel="noopener ugc nofollow" target="_blank">希望能描绘出同时使用since_ids和max_ids的原因。</a></p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/d5dae159bf169bd7ac8724897dea5b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQ13-vbCZMidWx6qys8eXw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">摘自Twitter API <a class="ae iu" href="https://developer.twitter.com/en/docs/tweets/timelines/guides/working-with-timelines" rel="noopener ugc nofollow" target="_blank">文档</a></figcaption></figure><p id="ff68" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，您已经处理了从1到10的tweet，当您处理这些新的tweet时，它们被添加到11到18的堆栈中，所以最佳实践是将id_of_tweet_10作为自id，将id_of_tweet_18作为max_id。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/06d3d478c6955af2df2aed412572d471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIVkOUPMMnDTYOr5MuYLYQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">本·怀特在<a class="ae iu" href="https://unsplash.com/s/photos/bookmark?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="ec62" class="mf kj hi bd kk mm mn mo ko mp mq mr ks jg ms mt kw jk mu mv la jo mw mx le my bi translated">拥抱光标实用程序</h2><p id="1c7e" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">尽管为了清晰起见，我解释了所有基于显式参数和无限while循环的获取用户时间轴过程，但实际上有一种更强大的编程方式来实现这一点，那就是<strong class="ix hj"> <em class="kc">光标</em> </strong>。由于tweepy游标，现在您不必编写样板代码来管理循环分页并在每个批处理中发送<strong class="ix hj"> <em class="kc"> max_id </em> </strong>和<strong class="ix hj"> <em class="kc"> since_id </em> </strong>参数，分页将由游标执行。更多详情，请访问<a class="ae iu" href="http://docs.tweepy.org/en/v3.5.0/cursor_tutorial.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="d992" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">光标是这样工作的:</p><pre class="lt lu lv lw fd ma mb mc md aw me bi"><span id="13a2" class="mf kj hi mb b fi mg mh l mi mj">import tweepy</span><span id="b424" class="mf kj hi mb b fi mz mh l mi mj"><em class="kc">timeline_ids = list<br/>for </em>status <em class="kc">in </em>tweepy.Cursor(api.user_timeline, <em class="kc">user_id</em>=<em class="kc">user_id</em>, <em class="kc">since_id</em>=max_id_in_town).items():<br/>    timeline_ids.append(status.id)</span></pre><p id="9479" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看，光标方式更简单，代码行更短。</p><h2 id="13e4" class="mf kj hi bd kk mm mn mo ko mp mq mr ks jg ms mt kw jk mu mv la jo mw mx le my bi translated">说话代码</h2><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/a4164f05d7ae7963176963bf6d39c919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDbPbMDxvf0sMFM-gbkKKg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@goran_ivos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">戈兰·艾沃斯</a>在<a class="ae iu" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><ol class=""><li id="064c" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><strong class="ix hj"> API认证和启用访问令牌</strong></li></ol><p id="73bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每次在Twitter dev账号上创建一个APP，都会给你一个用户访问令牌，比如<em class="kc"> consumer_key </em>、<em class="kc"> consumer_secret_key </em>、<em class="kc"> access_token </em>和<em class="kc"> access_token_secret </em>。这将确保您安全地访问Twitter API。要获取您的凭证，请在Twitter开发者<a class="ae iu" href="https://developer.twitter.com/" rel="noopener ugc nofollow" target="_blank">仪表盘</a>中查看您的应用详情。点击你的应用名称，切换到<strong class="ix hj"> <em class="kc">密钥和令牌</em> </strong>标签。您将在身份验证过程中使用这些凭据，如下所示:</p><pre class="lt lu lv lw fd ma mb mc md aw me bi"><span id="b4c0" class="mf kj hi mb b fi mg mh l mi mj">import tweepy</span><span id="8e43" class="mf kj hi mb b fi mz mh l mi mj"><em class="kc"># Authenticate twitter<br/></em>auth = tweepy.OAuthHandler(consumer_key, consumer_secret)<br/>auth.set_access_token(access_token, access_token_secret)<br/>api = tweepy.API(auth)</span></pre><p id="3159" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是由于我们不能将访问直接放入代码中，我建议创建一个<em class="kc"> credentials.json </em>并创建一个保存它们的字典。这里:</p><pre class="lt lu lv lw fd ma mb mc md aw me bi"><span id="9fa5" class="mf kj hi mb b fi mg mh l mi mj">{<br/>  "consumer_key":  "#",<br/>  "consumer_secret": "#",<br/>  "access_token": "#-#",<br/>  "access_token_secret": "#"<br/>}</span></pre><p id="1f91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建凭据文件后，您可以加载它并在代码中使用它们，而无需公开它们:</p><pre class="lt lu lv lw fd ma mb mc md aw me bi"><span id="c2ca" class="mf kj hi mb b fi mg mh l mi mj">import json</span><span id="b86a" class="mf kj hi mb b fi mz mh l mi mj"><em class="kc"># Define path to the credentials<br/></em>path_to_credentials = os.path.join(os.getcwd(), "credentials.json")<em class="kc"><br/># Load the credentials <br/>with open</em>(path_to_credentials) <em class="kc">as </em>file:<br/>    credentials = json.load(file)</span></pre><p id="26ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，验证并返回API对象</p><pre class="lt lu lv lw fd ma mb mc md aw me bi"><span id="f105" class="mf kj hi mb b fi mg mh l mi mj"><em class="kc">import tweepy</em></span><span id="7692" class="mf kj hi mb b fi mz mh l mi mj"><em class="kc"># Authenticate with Tweepy<br/></em>auth = tweepy.OAuthHandler(<br/>    credentials["consumer_key"], credentials["consumer_secret"])<br/>auth.set_access_token(<br/>    credentials["access_token"], credentials["access_token_secret"])<br/>api = tweepy.API(auth)</span></pre><p id="2905" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.<strong class="ix hj">使用Twitter用户名</strong>获取用户id</p><p id="d745" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了从用户时间线中获取tweets，我们需要定义用户id，虽然您可以使用screen_name作为标识符，但使用twitter_id会更明确。更多详情请参考<a class="ae iu" href="http://docs.tweepy.org/en/v3.5.0/api.html" rel="noopener ugc nofollow" target="_blank"> tweepy文档</a>。</p><pre class="lt lu lv lw fd ma mb mc md aw me bi"><span id="ad99" class="mf kj hi mb b fi mg mh l mi mj"><em class="kc"># Fetch twitter user id of an account you know the screen name<br/></em>user_name = "nytimes"<br/>user_object = api.get_user(<em class="kc">id</em>=user_name)</span><span id="1d98" class="mf kj hi mb b fi mz mh l mi mj"><em class="kc">print</em>("User screen name is: ", user_object.screen_name)<br/><em class="kc">print</em>("Users id in twitter db is: ", user_object.id)<br/><em class="kc">print</em>("Users info shown on twitter is: ", user_object.name)<br/><em class="kc">print</em>("User was created at: ", user_object.created_at)<br/><br/>user_id = user_object.id</span></pre><p id="610c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.<strong class="ix hj">用光标获取时间线id</strong></p><p id="7566" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">非商业的Twitter APIs允许被请求15分钟，在接下来的15分钟里，它希望你表现出一些风度，活出自我。我对礼貌部分很感兴趣，但15分钟部分仍然有效。所以我添加了一些行作为秒表，并添加了一些行让我的代码休眠15分钟。下面你还会看到一些try-except块，以防万一，当出现速率限制超出错误时，避免进程退出。你可以详述/改变整个过程。</p><pre class="lt lu lv lw fd ma mb mc md aw me bi"><span id="e44d" class="mf kj hi mb b fi mg mh l mi mj"><em class="kc">import </em>time <br/><em class="kc">from </em>datetime <em class="kc">import </em>datetime</span><span id="9250" class="mf kj hi mb b fi mz mh l mi mj"><em class="kc"># Fetch tweet ids from a timeline <br/># Use these block if this is there is no saved tweets from <br/># this account or you dont plan to use since_id functionality </em></span><span id="df3a" class="mf kj hi mb b fi mz mh l mi mj"><em class="kc">import </em>time <br/><em class="kc">from </em>datetime <em class="kc">import </em>datetime<br/><br/>counter = 0<br/>timeline_ids = <em class="kc">list</em>()<br/>start_time = datetime.now()<br/><br/><em class="kc">try</em>:<br/>    <em class="kc">for </em>status <em class="kc">in </em>tweepy.Cursor(api.user_timeline, <em class="kc">user_id</em>=user_id).items():<br/>        <em class="kc"># process status here<br/>        </em>timeline_ids.append(status.id)<br/>        end_time = datetime.now()<br/>        <em class="kc">if </em>np.ceil((end_time - start_time).seconds / 60) &gt;= 12:<br/>            <em class="kc">print</em>("Worked for 12 minutes, waiting for 15 minutes now")<br/>            <em class="kc">print</em>(datetime.now())<br/>            time.sleep(60 * 15)<br/>            start_time = datetime.now()<br/>            end_time = datetime.now()<br/><br/>        counter += 1<br/><em class="kc">except </em>tweepy.RateLimitError <em class="kc">as </em>e:<br/>    <em class="kc">print</em>("Rate limit error exceed waiting for 15 secs")<br/>    <em class="kc">print</em>(datetime.now())<br/>    <em class="kc">print</em>("You may want to save the timeline ids over there, to not to lose them during execution")<br/>    time.sleep(60 * 15)<br/>    start_time = datetime.now()<br/>    end_time = datetime.now()<br/><br/><em class="kc">print</em>("You may want to save the timeline ids over there, to not to lose them during execution")</span></pre><p id="a679" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您有上一次运行的id，并且可以利用since_id，请使用此块。</p><pre class="lt lu lv lw fd ma mb mc md aw me bi"><span id="5545" class="mf kj hi mb b fi mg mh l mi mj"><em class="kc">import </em>time <br/><em class="kc">from </em>datetime <em class="kc">import </em>datetime<br/><br/><em class="kc"># Get the max_id that already  resides in db<br/></em>max_id_in_town = some_max_id<br/>counter = 0<br/>timeline_ids = <em class="kc">list</em>()<br/>start_time = datetime.now()</span><span id="363b" class="mf kj hi mb b fi mz mh l mi mj"><em class="kc">try</em>:<br/>    <em class="kc">for </em>status <em class="kc">in </em>tweepy.Cursor(api.user_timeline, <em class="kc">user_id</em>=user_id, <em class="kc">since_id</em>=max_id_in_town).items():<br/>        <em class="kc"># process status here<br/>        </em>timeline_ids.append(status.id)<br/>        end_time = datetime.now()<br/>        <em class="kc">if </em>np.ceil((end_time - start_time).seconds / 60) &gt;= 12:<br/>            <em class="kc">print</em>("Worked for 12 mins, waiting for 15 mins now")<br/>            <em class="kc">print</em>(datetime.now())<br/>            <em class="kc">print</em>("You may want to save the timeline ids over there, to not to lose them during execution")<br/>            time.sleep(60 * 15)<br/>            start_time = datetime.now()<br/>            end_time = datetime.now()<br/><br/>        counter += 1<br/><em class="kc">except </em>tweepy.RateLimitError <em class="kc">as </em>e:<br/>    <em class="kc">print</em>("Rate limit error exceed waiting for 15 secs")<br/>    <em class="kc">print</em>(datetime.now())<br/>    <em class="kc">print</em>("You may want to save the timeline ids over there, to not to lose them during execution")<br/>    time.sleep(60 * 15)<br/>    start_time = datetime.now()<br/>    end_time = datetime.now()<br/><em class="kc">print</em>("You may want to save the timeline ids over there, to not to lose them during execution")</span></pre><p id="fa82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 4。获取与id相关的推文</strong></p><p id="e7f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们有了所有的tweet ids，所以我们终于可以获取扩展的雕像了。这里:</p><pre class="lt lu lv lw fd ma mb mc md aw me bi"><span id="7273" class="mf kj hi mb b fi mg mh l mi mj"><em class="kc"># Set looping params<br/></em>start_time = datetime.now()<br/>raw_tweets = <em class="kc">list</em>()<br/><br/><em class="kc">for </em>id_ <em class="kc">in </em>timeline_ids:<br/>    <em class="kc">try</em>:<br/>        res = api.get_status(<em class="kc">id</em>=id_, <em class="kc">tweet_mode</em>="extended")<br/>        raw_tweets.append({"accident_id": id_,<br/>                           "created_at": res.created_at,<br/>                           "text": res.full_text})<br/>        end_time = datetime.now()<br/>   <br/>        <em class="kc">if </em>np.ceil((end_time - start_time).seconds / 60) &gt;= 12:<br/>            <em class="kc">print</em>("Worked for 12 mins, waiting for 15 mins now")<br/>            <em class="kc">print</em>(datetime.now())<br/>            <em class="kc">print</em>("Save tweets somewhere")<br/>            time.sleep(60 * 15)<br/>            start_time = datetime.now()<br/>            end_time = datetime.now()<br/>        <em class="kc">del </em>res<br/><br/>    <em class="kc">except </em>tweepy.RateLimitError <em class="kc">as </em>e:<br/>        <em class="kc">print</em>("Rate limit error exceed waiting for 15 secs")<br/>        <em class="kc">print</em>(datetime.now())<br/>        <em class="kc">print</em>("Save tweets somewhere")<br/><br/>        time.sleep(60 * 15)<br/>        start_time = datetime.now()<br/>        end_time = datetime.now()<br/><em class="kc">print</em>("Save tweets somewhere")</span></pre></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="342a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文到此结束，如有建议请评论。如果你想了解更多关于如何存储和分析这些推文的信息，请告诉我。</p></div></div>    
</body>
</html>