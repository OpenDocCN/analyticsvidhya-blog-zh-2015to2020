<html>
<head>
<title>Playing Conway’s Game of Life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">玩康威的生活游戏</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/playing-conways-game-of-life-3ee5872d127a?source=collection_archive---------19-----------------------#2020-12-10">https://medium.com/analytics-vidhya/playing-conways-game-of-life-3ee5872d127a?source=collection_archive---------19-----------------------#2020-12-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bab8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卷积神经网络的细胞自主之旅</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/cd5de03b93b71caa05d33a3a7b7bbe5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*Q1jahY6UzwoS1EXNxYobJg.gif"/></div></figure><p id="b9ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">元胞自动机</strong>是计算机早期发展起来的一种离散计算系统。</p><p id="9631" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是<a class="ae jl" href="https://en.wikipedia.org/wiki/Automata_theory" rel="noopener ugc nofollow" target="_blank">自动机理论</a>的一部分，以模拟的形式在物理和生物等不同领域有许多应用<br/>你可以在这里阅读更多关于细胞自动机<a class="ae jl" href="https://en.wikipedia.org/wiki/Cellular_automaton" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="86ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将经历训练不同模型来预测下一代(状态)的过程</p><ul class=""><li id="4e7b" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated"><strong class="ih hj">开发代表元胞自动机的python类</strong></li><li id="97a4" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><strong class="ih hj">训练康威的生活游戏Pytorch模型</strong></li><li id="714c" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><strong class="ih hj">训练神经网络多规则模型，根据预定义的规则</strong>预测下一个状态</li><li id="31df" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><strong class="ih hj">基于两种结果状态对规则类进行分类</strong></li></ul></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="fa8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kh">在这里</em></strong><strong class="ih hj"><em class="kh"><a class="ae jl" href="https://github.com/meirdrago/ml/blob/master/game_of_life.ipynb" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="kh">你可以找到本教程的所有代码源代码。</em> </strong></a></em></strong></p><p id="8c59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> CellAuto </strong>是一个应用规则生成下一代的类。<br/>下一代矩阵是基于每个单元的邻居总和计算的。</p><p id="b1de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该规则基于2个列表参数<strong class="ih hj">活，死</strong>。<br/> <strong class="ih hj">活动</strong>列表—如果当前单元是活动的(例如，其值= 1)并且其8个邻居的总和在列表中，则该单元将继续活动，否则将死亡。<br/></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ki"><img src="../Images/2a8704b066eb7ab004a8c46892626a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*ccgiYX_cUQY7oqbN6A-5mw.png"/></div><figcaption class="kj kk et er es kl km bd b be z dx translated">来自维基百科</figcaption></figure></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="80e3" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">CellAuto类</h1><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="660d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">规则的一个特例是<em class="kh">{活:[2，3]，死:[3]} </em>叫做<a class="ae jl" href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">康威的生活游戏</strong> </a></p><p id="32d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">系统可以汇聚成许多重复的模式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ln"><img src="../Images/02535dc8c5ba6fa35f537418b7b3350a.png" data-original-src="https://miro.medium.com/v2/resize:fit:274/1*g4pcxm4EVtLFWZG5LGSYRg.gif"/></div><figcaption class="kj kk et er es kl km bd b be z dx translated">来自维基百科</figcaption></figure><p id="3717" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里定义了<a class="ae jl" href="https://gist.github.com/meirdrago/4e4870951a7dd2d6ad98c05c2f5672b1" rel="noopener ugc nofollow" target="_blank">动画的实用类</a></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/a01f2f657cf5e07155bee75c9ea58cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*ztMDnNrMz3XUsP0pvJFriQ.gif"/></div></figure><h1 id="c788" class="kn ko hi bd kp kq lo ks kt ku lp kw kx ky lq la lb lc lr le lf lg ls li lj lk bi translated">预测康威下一代生活游戏的卷积模型</h1><p id="ff6d" class="pw-post-body-paragraph if ig hi ih b ii lt ik il im lu io ip iq lv is it iu lw iw ix iy lx ja jb jc hb bi translated">在本节中，我们将训练一个模型来预测下一代。<br/>数据集包含单一规则——<em class="kh">康威的人生游戏。</em></p><p id="1978" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，3个卷积层由获得直接邻居信息的3×3滤波器组成。</p><p id="fa26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，与典型的图像处理CNN不同，我们不需要比直接邻居更多的信息。</p><p id="b080" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这个原因，除了最后一个完全连接的层之外，没有进行下采样，该层返回到<em class="kh">损失函数所需的输入大小。</em></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es ly"><img src="../Images/11b3a1bbcff96ffbf1de4e6d00401e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3EIbciXIX21lpaqlz0_2jg.png"/></div></div></figure><h1 id="a958" class="kn ko hi bd kp kq lo ks kt ku lp kw kx ky lq la lb lc lr le lf lg ls li lj lk bi translated">训练模型</h1><p id="b199" class="pw-post-body-paragraph if ig hi ih b ii lt ik il im lu io ip iq lv is it iu lw iw ix iy lx ja jb jc hb bi translated">在每个时期，我们将随机生成新的数据集。</p><p id="0214" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一个16x16的网格上，出现<strong class="ih hj">数据重复</strong> <br/>的可能性非常小。事实上，由于在每个游戏开始时1和0的初始随机设置是一个<a class="ae jl" href="https://en.wikipedia.org/wiki/Binomial_distribution" rel="noopener ugc nofollow" target="_blank">二项式分布</a>，计算其<a class="ae jl" href="https://en.wikipedia.org/wiki/Cumulative_distribution_function" rel="noopener ugc nofollow" target="_blank"> CDF </a>显示99%的置信度，将会有<strong class="ih hj">至少11个</strong> 1，其中概率为0.5。<br/>在这种情况下，初始数据重复的概率至少为:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es md"><img src="../Images/dff33f4ad9e9bd789baf68c8e8293534.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*MZQuwgH5ckIz2s9nCrNCmA.png"/></div></figure><p id="5226" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">损失函数</strong>是输入(计算下一代)和预测(预测下一代)之间的标准<a class="ae jl" href="https://en.wikipedia.org/wiki/Mean_squared_error" rel="noopener ugc nofollow" target="_blank"> MSE </a></p><p id="0345" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预测的输出是连续浮点型，而计算的是离散的零和一<br/>这个损失函数对于我们的需要来说是<strong class="ih hj">过精确的</strong>，因为我们只需要最小化<strong class="ih hj"> L(计算的—舍入的(预测的)】</strong>，然而在我们的情况下，它确保了更快的收敛</p><p id="2025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj">验证函数</strong>中，我们生成小数据集并计算误差百分比。如果下降到0.5%以下，我们就结束训练。</p><p id="cd25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练后，我们可以使用util Animator类比较我们的预测和实际计算数据:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/f69b568bc6da4c4942b30d26a6ee540c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*Om19rLuqs44M3ki4752PBw.gif"/></div></figure><h1 id="a534" class="kn ko hi bd kp kq lo ks kt ku lp kw kx ky lq la lb lc lr le lf lg ls li lj lk bi translated">多规则训练模型</h1><p id="cfd9" class="pw-post-body-paragraph if ig hi ih b ii lt ik il im lu io ip iq lv is it iu lw iw ix iy lx ja jb jc hb bi translated">在这里，我们将升级模型，以便能够用3个不同的规则预测下一代细胞自动机。</p><p id="9685" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个规则都应用了与模型完全不同的行为</p><p id="444a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型输入将是当前生成矩阵(16x16)和规则鉴别器向量(大小为3)</p><p id="ea11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意规则向量如何将自己合并到第一个卷积层中作为单独的通道，我发现它在准确性和时间收敛方面比任何其他配置(如3个卷积层之间或之后的完全连接)好得多。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es ly"><img src="../Images/799af808007cc6068727c70afc3169e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-9LtsU3JVHnYi2eAiIYnQ.png"/></div></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/8f925f252b653e6823a7fde1e6a94342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*XDOL5u0hE8Yw7nvcIi0MjQ.gif"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/cf6b4986be568f832d0be97c661cef16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*kMCycRXLD6RkVYFLZwU6ng.gif"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/4003f5493c1c091bbc73c4eb6bb9360d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*eGazp4zC0zNH2MO9FrCFKg.gif"/></div></figure><h1 id="4e9f" class="kn ko hi bd kp kq lo ks kt ku lp kw kx ky lq la lb lc lr le lf lg ls li lj lk bi translated">逆向工程细胞自动机</h1><p id="9017" class="pw-post-body-paragraph if ig hi ih b ii lt ik il im lu io ip iq lv is it iu lw iw ix iy lx ja jb jc hb bi translated">在本节中，我们将训练一个模型来对产生2个结果代的确切规则进行分类。<br/>这次输入将是代表2个结果代的2个16×16矩阵，以及代表规则类的大小为3的输出向量。</p><p id="de05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个输入矩阵集合起来分离通道，然后进行上采样和下采样<br/>,最后有2个完全连接的层达到其最终大小</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es ly"><img src="../Images/5626ad0755066452749ee0a5b5534d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imfGkGIpmtovmyQdUUrpSg.png"/></div></div></figure><p id="9054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你喜欢这次Cellula Autonom之旅和它的CNN实现。你可以在这里找到所有的代码源<a class="ae jl" href="https://github.com/meirdrago/ml/blob/master/game_of_life.ipynb" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>