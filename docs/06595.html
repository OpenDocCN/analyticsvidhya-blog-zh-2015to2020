<html>
<head>
<title>Micro-learn: Getting Started with Machine Learning on Arduino</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微学习:在Arduino上开始机器学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/micro-learn-getting-started-with-machine-learning-on-arduino-52167bc34c1d?source=collection_archive---------10-----------------------#2020-05-27">https://medium.com/analytics-vidhya/micro-learn-getting-started-with-machine-learning-on-arduino-52167bc34c1d?source=collection_archive---------10-----------------------#2020-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4babb66574a807fc861235f866bd3e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FA_zIdC_LBRc30U-wb8znA.jpeg"/></div></div></figure><p id="7727" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">机器学习算法通常在训练阶段需要大量的计算和内存资源，远远超过典型的受限微控制器所能提供的。如今，即使是基于传感器的数据集，大小也在几百兆字节到几千兆字节之间。我们不可能在我们的微型微控制器中装入这些kB大小的EEPROMs，忘记在这些数据集上运行算法吧！话虽如此，但并非所有希望都落空了。训练后，许多传统的机器学习算法归结为简单的参数，需要简单的算术和逻辑运算进行推理。这些可以很容易地在微控制器上实时运行。</p><p id="1d4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将学习一个名为<a class="ae jo" href="https://github.com/adarsh1001/micro-learn" rel="noopener ugc nofollow" target="_blank"> <em class="jp">微学习</em> </a> <em class="jp"> </em>的新的基于Python的库的用法，该库简化了为Arduino和其他微控制器生成推理代码的过程，这些微控制器用于使用<em class="jp"> scikit-learn </em>训练的机器学习模型。</p><h1 id="cf37" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">受限设备的最大似然算法分析</h1><p id="e462" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在进入实际内容之前，让我们简单地看一下理论(跳到下一节Arduino教程)。因此，如前所述，在微型微控制器上训练机器学习模型是完全不可能的，本质上也没有必要。如今，大多数实用的ML/DL应用程序都需要GPU盒子来进行训练，但却在常规机器上实时运行推理。我们会做类似的事情。</p><p id="88af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">机器学习算法，如支持向量机(SVM)、线性/二次判别分析(LDA/QDA)、逻辑回归、高斯朴素贝叶斯(GNB)、决策树、线性回归等。在训练阶段需要大量的资源，但是用于推理的算术计算相当简单。让我们来详细看看QDA。其他算法可以参考我的<a class="ae jo" href="https://dl.acm.org/doi/abs/10.1145/3341105.3373967" rel="noopener ugc nofollow" target="_blank"> ACM论文</a>。QDA是一个二次决策边界分类器，它将数据的类别条件分布<em class="jp"> P(X = x|Y = k) </em>假定为多元高斯分布:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/153555f503d9af63eefa4c0c2be8215a.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*-RKFeYxXCfWCw_7KtyaJyw.png"/></div></figure><p id="21f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于新的传感数据矢量<em class="jp"> xₛ </em>，使用贝叶斯规则进行预测:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/af188ba7bfac655965f97c6f7832386c.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*oNIhHL3IKpXduCjFnC1-8Q.png"/></div></figure><p id="3d6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在QDA的训练阶段，从数据集中学习类均值<em class="jp"> μₖ </em>，协方差矩阵<em class="jp">σₖ</em>和类先验<em class="jp"> P(Y = k) </em>。在<em class="jp"> scikit-learn的QDA的</em>实现中，后训练(拟合)，这些训练好的参数可以分别从<em class="jp"> means_ </em>、<em class="jp">协方差_ </em>和<em class="jp"> priors_ </em>属性中访问。求解二进制类数据集的上述等式会产生以下推理规则:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/7a3feb346a4696b068ceb2355e7b284f.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*yToTVlX-HdaYW0SPa-I1-w.png"/></div></figure><p id="af4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，<em class="jp"> c </em>是下面这个看起来很复杂的公式，它简单地归结为一个浮点常数:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es la"><img src="../Images/0f30e79f5a3ffb9e50c2a5ea00f680fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*RTZiQQTML_eAxVXvZGAHKA.png"/></div></figure><p id="775a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">σ</em>⁻=<em class="jp">σ</em>₀⁻-<em class="jp">σ</em>₁⁻是常数<em class="jp"> d </em> × <em class="jp"> d </em>浮点矩阵和<em class="jp">w =</em>2<em class="jp">σ</em>₁⁻<em class="jp">μ</em>₁-2<em class="jp">σ</em>₀⁻<em class="jp">μ</em>₀是常数<em class="jp"> d </em> ×1浮点显然，在训练之后，首先需要通过在上述公式中代入训练的参数来计算这些常数，然后在卸载这些常数的情况下用C/C++编写推理规则。一项艰巨的任务，对吗？如果我告诉您，有一种方法可以通过对经过训练的scikit-learn模型的单个函数调用来生成Arduino推理代码，会怎么样？嗯，这就是<em class="jp">微学</em>库的用武之地！</p><h1 id="9225" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">教程:将训练好的ML模型卸载到Arduino</h1><p id="20f8" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">如前所述，<em class="jp"> micro-learn </em>是一个Python库，可以将使用<em class="jp"> scikit-learn </em>训练的ML模型转换成Arduino推理代码。所有的推理算法都针对微控制器进行了优化，并且需要尽可能少的算术计算。除法运算已经转换为乘法运算，因为后者的计算效率要高得多。注意，所有的算法都是精确的，不是近似的。到目前为止，支持六种二进制类ML算法:</p><ol class=""><li id="77e6" class="lb lc hi is b it iu ix iy jb ld jf le jj lf jn lg lh li lj bi translated">感知器</li><li id="b985" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">线性回归</li><li id="96ca" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">高斯朴素贝叶斯(GNB)</li><li id="37be" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">线性判别分析(LDA)</li><li id="676a" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">二次判别分析(QDA)</li><li id="6eee" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">支持向量机(SVM)(线性核)</li></ol><p id="9a35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用一个实际的物联网数据集来做这个教程。这是一个占用检测数据集，通过在一个小房间内部署一个带有四个传感器的Arduino来收集:温度、湿度、光线和CO₂。关于设置的更多细节可以在这篇<a class="ae jo" href="https://www.sciencedirect.com/science/article/abs/pii/S0378778815304357" rel="noopener ugc nofollow" target="_blank">文章</a>中找到。现在，数据集由三个文件组成:<em class="jp">数据训练</em>、<em class="jp">数据测试</em>和<em class="jp">数据测试2 </em>。我们将使用<em class="jp"> datatraining </em>文件来训练一个ML模型，并将其卸载到Arduino，以便我们可以实时进行预测。</p><p id="8c19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，克隆/下载<a class="ae jo" href="https://github.com/adarsh1001/micro-learn" rel="noopener ugc nofollow" target="_blank"> <em class="jp">微学习</em> </a> <em class="jp"> </em>库(记下Python的依赖关系)并确保<em class="jp">微学习</em>目录在你的代码IDE的路径中。对于除了像SVM那样的尺度可变算法之外的所有算法，遵循以下编码过程:</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="50eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将导致一个<em class="jp">。ino </em>文件，其中相应的推理代码填充了所有训练好的常数。当然，数据部分需要按照代码中注释的指示手动编码。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/ede97219e80c95ac762239bc739580ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNOWQVVhRpVhsaJtVYa7iQ.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">在占用检测数据集上训练的QDA模型的推理代码。</figcaption></figure><p id="f8b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">卸载除SVM之外的其他ML算法的过程是相同的。然而，SVM是一种尺度可变的算法，需要一个经过训练的<em class="jp">标准缩放器</em>的实例来进行推理。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/4e112eee45607b0c363bc871e1e0ecf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOlIKDge4OLkpRkPZIjGqg.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">在占用检测数据集上训练的线性SVM模型的推理代码。</figcaption></figure><p id="8191" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就对了。很简单，不是吗？此外，由于Arduino编程语言是C/C++的衍生物，您可以直接编辑这个输出<em class="jp">。ino </em>模板并将其转换成一个通用的。c或者。cpp代码也是。目前，该库仅限于六种算法和二进制分类。对更多算法和多类分类的支持将很快添加！</p><h1 id="62ea" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">参考</h1><p id="5cf6" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">[1]关于受限ML及其实际用例的更多信息，你可以参考我的ACM论文:<a class="ae jo" href="https://dl.acm.org/doi/abs/10.1145/3341105.3373967" rel="noopener ugc nofollow" target="_blank">https://dl.acm.org/doi/abs/10.1145/3341105.3373967</a></p><p id="8f64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[2] Github回购:<a class="ae jo" href="https://github.com/adarsh1001/micro-learn" rel="noopener ugc nofollow" target="_blank">https://github.com/adarsh1001/micro-learn</a></p></div></div>    
</body>
</html>