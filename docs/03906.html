<html>
<head>
<title>Interview Question: Neighbor’s Lights</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试问题:邻居的灯</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/interview-question-neighbors-lights-7b7940dd36f6?source=collection_archive---------27-----------------------#2020-02-24">https://medium.com/analytics-vidhya/interview-question-neighbors-lights-7b7940dd36f6?source=collection_archive---------27-----------------------#2020-02-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a243cc263b3d50176e81a0e777aef15a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kc52iZgj1MKBqpX0E7TLCA.jpeg"/></div></div></figure><p id="2ec5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">软件工程师的技术面试因晦涩难懂的问题而臭名昭著。面试官的目标是观察你如何处理问题，并试图理解你的思维过程。当你想出解决问题的正确方法时，你越能把你的思考过程用语言表达出来，你就越有可能获得后续面试的机会。</p><p id="47f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我最近在一家硅谷公司面试时遇到的一个问题。事情是这样的:</p><blockquote class="jo jp jq"><p id="b711" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">想象一条街上有一排八栋房子。每栋房子的前廊都有一盏灯，主人会在一天开始时打开或关闭。午夜时分，业主们走出家门，决定在接下来的24小时里，他们的灯是亮着还是关着。为了决定灯是开还是关，主人会查看两个邻居家的灯。如果两个邻居的灯不是开着就是关着，主人就会打开他的灯。否则，灯将被关闭。由于街道远端的两栋房子只有一个邻居，所以只有在他们邻居的灯前一天关了的情况下，他们才会开灯。</p><p id="eedb" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">写一个函数，取未来的一天，n，和一个表示第0天家庭灯光状态的数组，返回第n天的灯光状态。</p></blockquote><p id="89c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">乍一看，这听起来有点令人生畏。所有这些谈论灯光和邻居等等。但是，让我们花点时间来分析一下。为了简化问题，让我们忽略整个“第n天的灯光状态”的事情，让我们弄清楚如何根据今天的状态来确定明天的灯光。此外，让我们弄清楚如何最好地模拟这个问题。</p><p id="9380" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，我们知道我们需要一个数组来表示某一天的灯光状态。由于每盏灯要么只能是<em class="jr">开</em>要么是<em class="jr">关</em>，所以我们只使用1和0的数组来表示各自的状态是有意义的。因此，我们的输入数组可能看起来像这样:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="93e9" class="ke kf hi ka b fi kg kh l ki kj">state = [0, 1, 0, 1, 0, 1, 1, 0]</span></pre><p id="acbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个场景中，灯是<em class="jr">关，开，关，开，关，开，开，关。</em>直观上，我们可以看到这一点，并准确地看到第二天应该打开哪些灯。但是我们如何用代码做到这一点呢？</p><p id="fb26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">天真的方法是进行某种循环并确定灯<em class="jr"> i </em>是否应该打开，查看<em class="jr">I-1</em>和<em class="jr"> i + 1 </em>。这种方法可行，但我们需要对第<em class="jr">0</em>和第<em class="jr">7</em>位置进行特殊处理，因为前者没有<em class="jr">I-1</em>，后者也没有<em class="jr"> i + 1 </em>邻居。该代码可能类似于以下内容:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="953c" class="ke kf hi ka b fi kg kh l ki kj">tomorrows_lights = [0, 0, 0, 0, 0, 0, 0, 0] </span><span id="f630" class="ke kf hi ka b fi kk kh l ki kj"># Handle special cases. Only on if neighbor is off tomorrows_lights[0] = int(not state[1]) <br/>tomorrows_lights[1] = int(not state[6]) </span><span id="0893" class="ke kf hi ka b fi kk kh l ki kj">i = 1 <br/>while i &lt; 8: <br/>    tomorrows_lights[i] = int(state[i - 1] == state[i + 1]) <br/>    i += 1</span></pre><p id="55c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这还不算太糟糕。我利用Python falsy值在适当的位置填充1或0。虽然这是可行的，但我认为还有更好的解决方案。</p><p id="bd53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们在这里处理1和0，所以使用按位运算符是一个可以探索的选项。因此，让我们将输入数组转换成按位表示。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="61b4" class="ke kf hi ka b fi kg kh l ki kj">lights = functools.reduce(lambda a, b: (a &lt;&lt; 1) | b, state)</span></pre><p id="d774" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一行有效地将输入数组转换成8位整数。对于状态数组中的每一项，值都向左移动一个位置，并从状态数组中追加0或1。所以，我们的输入数组<code class="du kl km kn ka b">[0, 1, 0, 1, 0, 1, 1, 0]</code>变成了<code class="du kl km kn ka b">86</code>或者<code class="du kl km kn ka b">01010110</code>。</p><p id="c3d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们可以使用按位运算符来确定两个邻居是否都很容易。如果我们执行一次左移和一次右移，然后对这两次移位执行按位“与”运算，只有在两个邻居都亮着灯的情况下，1才会出现。举个例子，</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="9e9e" class="ke kf hi ka b fi kg kh l ki kj">left_shift = lights &lt;&lt; 1                    #10101100 <br/>right_shift = lights &gt;&gt; 1.                  #00101011 <br/>tomorrows_lights = left_shift &amp; right_shift #00101000</span></pre><p id="9350" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这处理了两个邻居在上处于初始状态<em class="jr">的情况。但是我们如何确定两个邻居是否都是<em class="jr"> OFF </em>？实际上很容易。如果两个邻居都<em class="jr">关断</em>，那么左移位和右移位对于相同的位都将具有0。因此，让我们对两者进行按位“或”运算，看看会产生什么结果:</em></p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="477c" class="ke kf hi ka b fi kg kh l ki kj">left_shift | right_shift # 10101111</span></pre><p id="0ac2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意应该在上<em class="jr">出现的灯在两个有零的地方。为了得到正确的状态，我们可以用掩码<code class="du kl km kn ka b">0xFF</code>执行XOR运算</em></p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="d226" class="ke kf hi ka b fi kg kh l ki kj">(left_shift | right_shift) ^ 0xFF # 01010000</span></pre><p id="c5e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过将此与前面的AND运算相结合，我们获得了明日之光的解决方案。我们可以将这些操作合并到一行中，使代码更加简洁。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="f3ba" class="ke kf hi ka b fi kg kh l ki kj">left_shift = lights &lt;&lt; 1   #10101100 <br/>right_shift = lights &gt;&gt; 1  #00101011 <br/>tomorrows_lights = (left_shift &amp; right_shift) | ((left_shift | right_shift) ^ 0xFF) &amp; 0xFF</span></pre><p id="5cbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，为了确保只设置底部的8位，我们用<code class="du kl km kn ka b">0xFF</code>执行了一个AND。</p><p id="406c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，这三行代码完成了所有繁重的工作。为了概括这一点，并定义一个函数，可以找到未来任意一天的光序列，我们将把这个位放在一个循环中，并为每一天执行这个位操作。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="9909" class="ke kf hi ka b fi kg kh l ki kj">def get_light_sequence_on_day_n(n, state): <br/>    lights = functools.reduce(lambda a, b: (a &lt;&lt; 1) | b, state) <br/>    while n &gt; 0: <br/>        left_shift = lights &lt;&lt; 1 <br/>        right_shift = lights &gt;&gt; 1 <br/>        lights = (left_shift &amp; right_shift) | ((left_shift | right_shift) ^ 0xFF) &amp; 0xFF <br/>        n -= 1 return lights</span></pre><p id="84ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的函数即将完成，但是现在的返回值是一个数字，并且需要一个表示灯光状态的数组。为此，我们需要在该函数的第一行创建reduce语句的反向操作。我想到的解决方案是首先使用Python的string format方法将返回值格式化为二进制字符串，使用map遍历该字符串，然后返回结果列表。看起来像这样:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="ab9a" class="ke kf hi ka b fi kg kh l ki kj">list(map(lambda n: int(n), "{0:08b}".format(light_sequence)))</span></pre><p id="43dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，完成的函数看起来只有8行长，相当容易理解，并且比使用for循环和处理边界情况更优雅。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="f875" class="ke kf hi ka b fi kg kh l ki kj">def get_light_sequence_on_day_n(n, state): <br/>    lights = functools.reduce(lambda a, b: (a &lt;&lt; 1) | b, state) <br/>    while n &gt; 0: <br/>        left_shift = lights &lt;&lt; 1 <br/>        right_shift = lights &gt;&gt; 1<br/>        lights = (left_shift &amp; right_shift) | ((left_shift | right_shift) ^ 0xFF) &amp; 0xFF <br/>        n -= 1 <br/>    return list(map(lambda n: int(n), "{0:08b}".format(light_sequence)))</span></pre><p id="49d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查看我的<a class="ae ko" href="https://github.com/jcampos8782/codingz/blob/master/py/lighting_sequence.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的完整源代码。如果你有任何建议，请在评论中留下。感谢阅读，敬请期待更多内容。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="1847" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">原载于2020年2月24日http://blog.jsoncampos.com</em><a class="ae ko" href="http://blog.jsoncampos.com/2020/02/24/interview-question-which-lights/" rel="noopener ugc nofollow" target="_blank"><em class="jr"/></a><em class="jr">。</em></p></div></div>    
</body>
</html>