<html>
<head>
<title>Data Cleaning with Regular Expressions in Amazon Redshift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">亚马逊红移中的正则表达式数据清洗</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-cleaning-with-regular-expressions-in-amazon-redshift-bf991f095e08?source=collection_archive---------2-----------------------#2020-02-26">https://medium.com/analytics-vidhya/data-cleaning-with-regular-expressions-in-amazon-redshift-bf991f095e08?source=collection_archive---------2-----------------------#2020-02-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8781" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都知道数据清理的重要性。你不可能用不正确的数据得到好的结果，即使你有一个花哨的机器学习模型。</p><p id="e423" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，数据清理可能令人望而生畏，尤其是正则表达式。这篇文章是让你开始在Amazon Redshift中清理数据的指南。我将详细介绍我的代码，所以如果您以前从未使用过正则表达式，请不要担心。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/ad6eb3409892e26272e12656ece0f213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MfbjxtbN--3owpNM.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片来自<a class="ae jt" href="https://images.app.goo.gl/Ei1ojaRowCP7pMzW7" rel="noopener ugc nofollow" target="_blank">谷歌图片</a></figcaption></figure><h1 id="b23f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">数据验证</strong></h1><p id="b541" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">数据清理的第一步是知道你的数据中有什么。</p><p id="3ff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数时候，我希望所有的数据都是数字，不夹杂任何单词字符、标点符号(小数点除外)。</p><p id="6cbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在这里使用红移函数— <code class="du kx ky kz la b">REGEXP_COUNT</code>、<code class="du kx ky kz la b">SIMILAR TO</code>或<code class="du kx ky kz la b">LIKE</code>。</p><p id="75e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">REGEXP_COUNT</code>搜索一个模式并返回该模式出现的次数。</p><p id="5835" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">SIMILAR TO</code>也使用正则表达式匹配字符串。但是只有当模式匹配整个字符串时，它才会返回true。此外，<code class="du kx ky kz la b">SIMILAR TO</code>可以支持的模式匹配元字符有限。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lb"><img src="../Images/1060d9397f18c3405a159e571eacb20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LXCp1me7T0xvtPdOQmUAQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">相似源的模式匹配元字符:<a class="ae jt" href="https://docs.aws.amazon.com/redshift/latest/dg/pattern-matching-conditions-similar-to.html" rel="noopener ugc nofollow" target="_blank"> Amazon红移文档</a></figcaption></figure><p id="2b05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，正则表达式匹配的开销很大。<code class="du kx ky kz la b">LIKE</code>没有使用正则表达式，而是使用通配符<code class="du kx ky kz la b">%</code>(百分比)和<code class="du kx ky kz la b">_</code>(下划线)。如果您有一个非常具体的子串要匹配，建议使用<code class="du kx ky kz la b">LIKE</code>操作符。</p><p id="5943" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一些例子。为了分解正则表达式，我们可以把它分成四个部分— <code class="du kx ky kz la b">^</code>、<code class="du kx ky kz la b">[0-9]</code>、<code class="du kx ky kz la b">+</code>和<code class="du kx ky kz la b">$</code>。<code class="du kx ky kz la b">[0-9]</code>匹配0123456789中的一个数字。<code class="du kx ky kz la b">^</code>和<code class="du kx ky kz la b">$</code>定义边界。<code class="du kx ky kz la b">^</code>后跟<code class="du kx ky kz la b">[0-9]</code>表示字符串应该以数字开头。<code class="du kx ky kz la b">[0-9]</code>后的<code class="du kx ky kz la b">$</code>表示字符串应以数字结尾。<code class="du kx ky kz la b">+</code>作为量词，表示该模式应该出现一次或多次，所以<code class="du kx ky kz la b">[0–9]+</code>匹配所有整数。</p><pre class="je jf jg jh fd lc la ld le aw lf bi"><span id="3880" class="lg jv hi la b fi lh li l lj lk"><em class="ll">-- returns 1 when the string is an integer, 0 when it's not</em><br/>select REGEXP_COUNT('41', '^[0-9]+$');</span><span id="738f" class="lg jv hi la b fi lm li l lj lk"><br/><em class="ll">-- will return FALSE because ^ and $ are not supported as matching metacharacters</em><br/>select '^123$' SIMILAR TO '^[0-9]+$'<br/><br/><em class="ll">-- returns TRUE</em><br/>select '123' SIMILAR TO '[0-9]+'<br/></span><span id="fa25" class="lg jv hi la b fi lm li l lj lk">-- match any string that starts with 1</span><span id="d0e4" class="lg jv hi la b fi lm li l lj lk">select '123' LIKE '1%';</span><span id="e53d" class="lg jv hi la b fi lm li l lj lk">select '1a' LIKE '1%';</span></pre><p id="e2d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，如果我们想包括十进制数。<code class="du kx ky kz la b">{0,}</code>是另一个与前一项匹配0次或更多次的量词。一般情况下，<code class="du kx ky kz la b">{m,n}</code>匹配前一项m到n次。<code class="du kx ky kz la b">{1, }</code>的工作与<code class="du kx ky kz la b">+</code>相同。</p><p id="250f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">()</code>用于包含一个捕获组。<code class="du kx ky kz la b">(.[0–9]+)</code>捕捉小数中的派系部分。<code class="du kx ky kz la b">()</code>常与量词连用，指明该模式的出现。</p><p id="ef4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意和<code class="du kx ky kz la b">[]</code>不一样。<code class="du kx ky kz la b">[]</code>表示范围，所以<code class="du kx ky kz la b">[0–9]</code>匹配从0到9的任何数字。然而，<code class="du kx ky kz la b">(0–9)</code>将匹配精确的字符串“0–9”</p><pre class="je jf jg jh fd lc la ld le aw lf bi"><span id="fe6c" class="lg jv hi la b fi lh li l lj lk"><em class="ll">-- to include decimal numbers</em><br/>select REGEXP_COUNT('1.233' , '^[0-9]+(.[0-9]+){0,}$');</span></pre><p id="42b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时十进制数会像<code class="du kx ky kz la b">.11</code>一样出现，小数点前没有任何数字。为了捕捉到这一点，我们可以使用<code class="du kx ky kz la b">|</code>，OR操作数。</p><pre class="je jf jg jh fd lc la ld le aw lf bi"><span id="c132" class="lg jv hi la b fi lh li l lj lk"><em class="ll">-- to include decimal numbers like .11</em><br/>select REGEXP_COUNT('.11' , '^[0-9]+(.[0-9]+){0,}$|^([0-9]+){0,}.[0-9]+$');</span></pre><p id="b7f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时任务会更复杂。我们希望接受数据，即使它是字母数字的。例如，对于高度，我们希望取“5英尺4英寸”。考虑到“ft”和“in ”,我们需要在模式中包含它们。</p><p id="7c85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里<code class="du kx ky kz la b">\\s</code>匹配一个空格。注意，在亚马逊红移中，需要使用两个<a class="ae jt" href="https://docs.aws.amazon.com/redshift/latest/dg/pattern-matching-conditions-posix.html" rel="noopener ugc nofollow" target="_blank">反斜杠</a>对运算符进行转义。</p><pre class="je jf jg jh fd lc la ld le aw lf bi"><span id="8182" class="lg jv hi la b fi lh li l lj lk"><em class="ll">-- returns 1</em><br/>select REGEXP_COUNT('5 ft 1 in', '^[0-9]+\\sft(\\s[0-9]+\\sin)?$');<br/><br/><em class="ll">-- returns 1</em><br/>select REGEXP_COUNT('5 ft', '^[0-9]+\\sft(\\s[0-9]+\\sin)?$');<br/><br/><em class="ll">-- returns True</em><br/>select '5 ft' SIMILAR TO '[0-9]+\\sft(\\s[0-9]+\\sin)?';<br/><br/><em class="ll">-- returns True</em><br/>select '5 ft 1 in' SIMILAR TO '[0-9]+\\sft(\\s[0-9]+\\sin)?';</span></pre><h1 id="8f86" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">数据提取</strong></h1><p id="3c38" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">数据抽取帮助我们从数据中获取想要的信息，关注重要部分，避免不必要的数据清洗。</p><p id="b049" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们以血糖水平为例。通常，葡萄糖数据以测量单位来表示，例如“98毫克/分升”、“101毫克/分升”、“89毫克/分升”或者甚至是“100毫克”。/dl。</p><p id="5de5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，我们只关心数字部分。单位部分再脏也没关系。</p><p id="be18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用<code class="du kx ky kz la b">SPIT_PART</code>分割空白并获得数字读数。</p><pre class="je jf jg jh fd lc la ld le aw lf bi"><span id="6a8d" class="lg jv hi la b fi lh li l lj lk"><em class="ll">-- returns 98</em><br/>select SPLIT_PART('98 mg/dl', ' ', 1)</span></pre><p id="a5cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据是“98mg/dl”怎么办？我们需要转向另一个函数<code class="du kx ky kz la b">REGEXP_SUBSTR</code>。</p><p id="ce2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">REGEXP_SUBSTR</code>搜索正则表达式模式并返回它。<code class="du kx ky kz la b">[0–9]+</code>匹配“98”，不管它后面是什么。</p><pre class="je jf jg jh fd lc la ld le aw lf bi"><span id="08df" class="lg jv hi la b fi lh li l lj lk"><em class="ll">-- returns 98mg/dl, not working</em><br/>select SPLIT_PART('98mg/dl', ' ', 1)</span><span id="26f7" class="lg jv hi la b fi lm li l lj lk"><em class="ll">-- returns 98</em><br/>select REGEXP_SUBSTR('98mg/dl', '[0-9]+')</span></pre><h1 id="3282" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">数据转换&amp;校正</strong></h1><p id="714d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">虽然这篇文章是关于如何使用正则表达式的，但是知道什么时候没有必要使用它们也同样重要。</p><p id="c0f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于大小写转换(上下颠倒)，<code class="du kx ky kz la b">LOWER</code>，<code class="du kx ky kz la b">UPPER</code>都能轻松搞定。</p><pre class="je jf jg jh fd lc la ld le aw lf bi"><span id="27f6" class="lg jv hi la b fi lh li l lj lk"><em class="ll">-- returns 100 mg/dl</em><br/>select LOWER('100 MG/DL')</span></pre><p id="8dc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于在SQL中映射值，<code class="du kx ky kz la b">CASE WHEN</code>是一个很好的选项。</p><pre class="je jf jg jh fd lc la ld le aw lf bi"><span id="488f" class="lg jv hi la b fi lh li l lj lk">select CASE WHEN value='60 min' THEN '1 hour'<br/> WHEN value='120 min' THEN '2 hours'<br/> WHEN value='180 min' THEN '3 hours'<br/> ELSE value END AS mapped_value <br/>from ...</span></pre><p id="d3c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于更复杂的任务，比如用一个空格替换多个空格，我们可以使用<code class="du kx ky kz la b">REGEXP_REPLACE</code>。请注意，正则表达式用于指定匹配模式，但不能用于替换字符串。</p><pre class="je jf jg jh fd lc la ld le aw lf bi"><span id="a987" class="lg jv hi la b fi lh li l lj lk"><em class="ll">-- returns 5 ft 8 in</em><br/>select REGEXP_REPLACE('5 ft     8     in', '\\s+', ' ');<br/><br/><em class="ll">-- returns 5sfts8sin</em><br/>select REGEXP_REPLACE('5 ft     8     in', '\\s+', '\\s');</span></pre></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="9381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">综上所述，在Redshift中我们可以执行从数据验证、数据提取到数据转换和修正的大量数据清理任务。可以使用几个函数来完成这些任务。有时我们可以不用正则表达式，但是随着数据变得更加混乱，正则表达式通过为我们提供更多的灵活性而脱颖而出。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/68ff3beec61d22047a7a30095fda228b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9GYIv5Y-cceYdxymB1QCBA.png"/></div></div></figure><p id="e321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ll">感谢阅读。希望这篇文章对你有用！如果您有任何建议，请随时发表评论！</em></p><p id="ef5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ll">也可以通过</em><a class="ae jt" href="https://www.linkedin.com/in/ling-hong-498971149/" rel="noopener ugc nofollow" target="_blank"><em class="ll">LinkedIn</em></a><em class="ll">联系我。</em></p></div></div>    
</body>
</html>