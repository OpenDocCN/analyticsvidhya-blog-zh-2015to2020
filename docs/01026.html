<html>
<head>
<title>Association Analysis in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的关联分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/association-analysis-in-python-2b955d0180c?source=collection_archive---------0-----------------------#2019-09-26">https://medium.com/analytics-vidhya/association-analysis-in-python-2b955d0180c?source=collection_archive---------0-----------------------#2019-09-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d6bc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Python中基于Apriori算法的频繁项集挖掘</h2></div><p id="05c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个文档是为那些对先验知识及其工作原理有所了解的人编写的。</p><p id="cc5a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">直接从维基百科更新先验知识:</p><blockquote class="jt ju jv"><p id="4f35" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="iz hj"> <em class="hi">先验</em> </strong> <em class="hi">是一种</em> <a class="ae ka" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="hi">算法</em> </a> <em class="hi">用于频繁项集挖掘和</em> <a class="ae ka" href="https://en.wikipedia.org/wiki/Association_rule_learning" rel="noopener ugc nofollow" target="_blank"> <em class="hi">关联规则学习</em> </a> <em class="hi">超过关系数据库</em><a class="ae ka" href="https://en.wikipedia.org/wiki/Databases" rel="noopener ugc nofollow" target="_blank"><em class="hi"/></a><em class="hi">。它通过识别数据库中频繁出现的单个项目，并将其扩展到越来越大的项目集，只要这些项目集在数据库中出现得足够频繁。由先验确定的频繁项集可以用来确定</em> <a class="ae ka" href="https://en.wikipedia.org/wiki/Association_rules" rel="noopener ugc nofollow" target="_blank"> <em class="hi">关联规则</em> </a> <em class="hi">，这些关联规则突出了</em> <a class="ae ka" href="https://en.wikipedia.org/wiki/Database" rel="noopener ugc nofollow" target="_blank"> <em class="hi">数据库</em> </a> <em class="hi">中的一般趋势:这在</em> <a class="ae ka" href="https://en.wikipedia.org/wiki/Market_basket_analysis" rel="noopener ugc nofollow" target="_blank"> <em class="hi">购物篮分析</em> </a> <em class="hi">等领域都有应用。</em></p><p id="886c" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><em class="hi"> -Apriori算法</em>，<em class="hi">维基百科2019。</em></p></blockquote><p id="3bd3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Apriori算法是从关联分析开始的完美算法，因为它不仅易于理解和解释，而且易于实现。</p><p id="772e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python有许多用于先验实现的库。也可以从头开始实现算法。但是等一下，还有mlxtend的救援。这个库拥有apriori的漂亮实现，它还允许从结果中提取关联规则。</p><p id="6364" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么我们还在等什么呢？开始编码吧！！</p><p id="4ffe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将利用下面的python库<br/> 1。还记得可爱的熊猫和熊猫吗？<br/> 2。mlxtend或ML extended将用于先验实现和提取关联规则。<br/> 3。然后还有一个:matplotlib，用于可视化结果</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="84e4" class="kk kl hi kg b fi km kn l ko kp">import pandas as pd<br/>import numpy as np<br/>from mlxtend.frequent_patterns import apriori, association_rules<br/>import matplotlib.pyplot as plt</span></pre><blockquote class="jt ju jv"><p id="c3f2" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">我为此选择的数据集是我创建的自定义数据集。如果你想玩数据集，你可以在这里找到它<a class="ae ka" href="https://gist.github.com/Harsh-Git-Hub/2979ec48043928ad9033d8469928e751" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><figure class="kb kc kd ke fd kq"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">retail_dataset.csv</figcaption></figure><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="a8c5" class="kk kl hi kg b fi km kn l ko kp">## Use this to read data directly from github<br/>df = pd.read_csv('<a class="ae ka" href="https://gist.githubusercontent.com/Harsh-Git-Hub/2979ec48043928ad9033d8469928e751/raw/72de943e040b8bd0d087624b154d41b2ba9d9b60/retail_dataset.csv'" rel="noopener ugc nofollow" target="_blank">https://gist.githubusercontent.com/Harsh-Git-Hub/2979ec48043928ad9033d8469928e751/raw/72de943e040b8bd0d087624b154d41b2ba9d9b60/retail_dataset.csv'</a>, sep=',')</span><span id="6859" class="kk kl hi kg b fi kx kn l ko kp">## Use this to read data from the csv file on local system.<br/>df = pd.read_csv('./data/retail_data.csv', sep=',') </span><span id="4526" class="kk kl hi kg b fi kx kn l ko kp">## Print first 10 rows <br/>df.head(10)</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ky"><img src="../Images/8ebc3e9a5f9559a13385e1149170ed02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gNksc7JYVXB2n6pIZzG8Eg.png"/></div></div></figure><p id="6ae9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据集的每一行代表同一天在同一家商店一起购买的商品。数据集是一个<strong class="iz hj">稀疏数据集</strong>，因为相对较高百分比的数据是NA或NaN或等效数据。</p><p id="d390" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些NaNs让人很难读懂表格。让我们看看表中实际上有多少独特的项目。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="d025" class="kk kl hi kg b fi km kn l ko kp">items = set()<br/>for col in df:<br/>    items.update(df[col].unique())</span><span id="87dc" class="kk kl hi kg b fi kx kn l ko kp">print(items)</span><span id="5ca5" class="kk kl hi kg b fi kx kn l ko kp">Out:<br/>{'Bread', 'Cheese', 'Meat', 'Eggs', 'Wine', 'Bagel', 'Pencil',<br/>       'Diaper', 'Milk']}</span></pre><p id="5d56" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总共只有9个项目组成了整个数据集。很好，更容易找到频繁项集或者你认为是这样！！</p><h1 id="83b2" class="lf kl hi bd lg lh li lj lk ll lm ln lo io lp ip lq ir lr is ls iu lt iv lu lv bi translated">数据预处理</h1><p id="d291" class="pw-post-body-paragraph ix iy hi iz b ja lw ij jc jd lx im jf jg ly ji jj jk lz jm jn jo ma jq jr js hb bi translated">为了使用mlxtend库提供的apriori模块，我们需要根据数据集的喜好对其进行转换。apriori模块要求数据帧包含0和1或True和False作为数据。我们拥有的数据都是字符串(项目名称)，我们需要<strong class="iz hj">一个热编码</strong>数据。</p><p id="f2e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自定义一个热编码</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="3cd0" class="kk kl hi kg b fi km kn l ko kp">itemset = set(items)<br/>encoded_vals = []<br/>for index, row in df.iterrows():<br/>    rowset = set(row) <br/>    labels = {}<br/>    uncommons = list(itemset - rowset)<br/>    commons = list(itemset.intersection(rowset))<br/>    for uc in uncommons:<br/>        labels[uc] = 0<br/>    for com in commons:<br/>        labels[com] = 1<br/>    encoded_vals.append(labels)<br/>encoded_vals[0]</span><span id="1685" class="kk kl hi kg b fi kx kn l ko kp">ohe_df = pd.DataFrame(encoded_vals)</span></pre><h1 id="2126" class="lf kl hi bd lg lh li lj lk ll lm ln lo io lp ip lq ir lr is ls iu lt iv lu lv bi translated">应用先验知识</h1><p id="abf0" class="pw-post-body-paragraph ix iy hi iz b ja lw ij jc jd lx im jf jg ly ji jj jk lz jm jn jo ma jq jr js hb bi translated">mlxtend库中的apriori模块提供了快速有效的apriori实现。</p><blockquote class="jt ju jv"><p id="2bfb" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="iz hj"> <em class="hi">先验(df，min_support=0.5，use_colnames=False，max_len=None，verbose=0，low_memory=False) </em> </strong></p></blockquote><p id="f921" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因素</p><ul class=""><li id="6c6f" class="mb mc hi iz b ja jb jd je jg md jk me jo mf js mg mh mi mj bi translated"><code class="du mk ml mm kg b">df</code>:一位热编码数据帧或值为0和1或真和假的数据帧</li><li id="f778" class="mb mc hi iz b ja mn jd mo jg mp jk mq jo mr js mg mh mi mj bi translated"><code class="du mk ml mm kg b">min_support</code>:介于0和1之间的浮点值，表示要选择的项目集所需的最小支持度。<br/>【带项观察数/总观察数】</li><li id="c462" class="mb mc hi iz b ja mn jd mo jg mp jk mq jo mr js mg mh mi mj bi translated"><code class="du mk ml mm kg b">use_colnames</code>:这允许保留项目集的列名，使其更具可读性。</li><li id="653b" class="mb mc hi iz b ja mn jd mo jg mp jk mq jo mr js mg mh mi mj bi translated"><code class="du mk ml mm kg b">max_len</code>:生成的项目集的最大长度。如果未设置，则评估所有可能的长度。</li><li id="941e" class="mb mc hi iz b ja mn jd mo jg mp jk mq jo mr js mg mh mi mj bi translated"><code class="du mk ml mm kg b">verbose</code>:显示&gt; = 1且low_memory为真时的迭代次数。如果=1且low_memory为False，则显示组合的数量。</li><li id="3abb" class="mb mc hi iz b ja mn jd mo jg mp jk mq jo mr js mg mh mi mj bi translated"><code class="du mk ml mm kg b">low_memory</code>:</li><li id="4233" class="mb mc hi iz b ja mn jd mo jg mp jk mq jo mr js mg mh mi mj bi translated">如果为True，则使用迭代器搜索min_support以上的组合。请注意，虽然low_memory=True应该只用于内存资源有限的大型数据集，因为这种实现大约。比默认速度慢3-6倍。</li></ul><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="1343" class="kk kl hi kg b fi km kn l ko kp">freq_items = apriori(ohe_df, min_support=0.2, use_colnames=True, verbose=1)<br/>freq_items.head(7)</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ms"><img src="../Images/99a6fdf681470acdfdeacd13c340b377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTwIS1NQ8FoFXYGH6oq_UA.png"/></div></div></figure><p id="87b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出是支持每个项目集的数据框。</p><h1 id="c026" class="lf kl hi bd lg lh li lj lk ll lm ln lo io lp ip lq ir lr is ls iu lt iv lu lv bi translated">挖掘关联规则</h1><p id="1c6f" class="pw-post-body-paragraph ix iy hi iz b ja lw ij jc jd lx im jf jg ly ji jj jk lz jm jn jo ma jq jr js hb bi translated">频繁的if-then <strong class="iz hj">关联</strong>称为<strong class="iz hj">关联规则</strong>，由一个前因(if)和一个后果(then)组成。</p><blockquote class="jt ju jv"><p id="c439" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="iz hj"> <em class="hi">【关联_规则(df，metric= '置信度'，min_threshold=0.8，support_only=False) </em> </strong></p></blockquote><p id="cf6a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">指标可以设置为信心、提升、支持、杠杆和信念。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="98b7" class="kk kl hi kg b fi km kn l ko kp">rules = association_rules(freq_items, metric="confidence", min_threshold=0.6)<br/>rules.head()</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mt"><img src="../Images/b8e3c8a8b0d9d637a4a9e0c804879224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhKQHhTkyAhVy1XxKFJMbw.png"/></div></div></figure><p id="19c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关联分析的结果显示了哪个项目经常与其他项目一起被购买。</p><h1 id="366b" class="lf kl hi bd lg lh li lj lk ll lm ln lo io lp ip lq ir lr is ls iu lt iv lu lv bi translated">可视化结果</h1><ol class=""><li id="edfb" class="mb mc hi iz b ja lw jd lx jg mu jk mv jo mw js mx mh mi mj bi translated"><strong class="iz hj">支持vs信心</strong></li></ol><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="aca9" class="kk kl hi kg b fi km kn l ko kp">plt.scatter(rules['support'], rules['confidence'], alpha=0.5)<br/>plt.xlabel('support')<br/>plt.ylabel('confidence')<br/>plt.title('Support vs Confidence')<br/>plt.show()</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es my"><img src="../Images/a6d7696034ad84f4044761856f9a71c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*o-uDGp3IqxW1BTV4Etnz7A.png"/></div></figure><p id="1f07" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.<strong class="iz hj">支撑vs升降</strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="f5a8" class="kk kl hi kg b fi km kn l ko kp">plt.scatter(rules[‘support’], rules[‘lift’], alpha=0.5)<br/>plt.xlabel(‘support’)<br/>plt.ylabel(‘lift’)<br/>plt.title(‘Support vs Lift’)<br/>plt.show()</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es mz"><img src="../Images/0396eda1664ba79d8ba361d28b79056f.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*mZEVDMIXmtZEJRKYc-YpSw.png"/></div></figure><p id="b9e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">提升vs信心</strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="57fd" class="kk kl hi kg b fi km kn l ko kp">fit = np.polyfit(rules[‘lift’], rules[‘confidence’], 1)<br/>fit_fn = np.poly1d(fit)<br/>plt.plot(rules[‘lift’], rules[‘confidence’], ‘yo’, rules[‘lift’], <br/> fit_fn(rules[‘lift’]))</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es na"><img src="../Images/cc62a5f4d61b7ed220fe9df7907c72fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*vRaM0i1FQDrOAndoITW9rw.png"/></div></figure></div></div>    
</body>
</html>