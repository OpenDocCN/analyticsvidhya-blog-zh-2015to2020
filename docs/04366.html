<html>
<head>
<title>How to Build your First Real-Time Streaming(CDC) system(Kafka Steams and Aggregation-Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建你的第一个实时流(CDC)系统</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-build-your-first-real-time-streaming-cdc-system-kafka-steams-and-aggregation-part-3-8a331e98961d?source=collection_archive---------9-----------------------#2020-03-16">https://medium.com/analytics-vidhya/how-to-build-your-first-real-time-streaming-cdc-system-kafka-steams-and-aggregation-part-3-8a331e98961d?source=collection_archive---------9-----------------------#2020-03-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4c8a7ab53471883efd86263dc33f2dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v01c22vPlwJp_oeJ2CrneQ.png"/></div></div></figure><p id="870e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本概念验证的第<a class="ae jo" rel="noopener" href="/@rohan.mudaliar/how-to-build-your-first-real-time-streaming-cdc-system-introduction-part-1-5d61b2d9d511">篇文章第1 </a>中，我们了解了构建实时流系统所需的关键概念，在第<a class="ae jo" rel="noopener" href="/@rohan.mudaliar/how-to-build-your-first-real-time-streaming-cdc-system-setup-part-2-bac2c5397d5e">篇文章第2 </a>中，我们了解了MySql设置和本地基础设施设置。在本文中，我们将查看使用<strong class="is hj"> Kafka streams获取的<strong class="is hj">实时数据</strong>，</strong>对其执行一些<strong class="is hj">聚合</strong>，并在弹性搜索中创建<strong class="is hj">索引。我们将像往常一样从一些基本概念开始，然后看看我们的技术任务，然后是系统的最终实现。</strong></p><p id="3c2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注:</strong>如果您需要更好地理解整个问题，请阅读文章的第<a class="ae jo" rel="noopener" href="/@rohan.mudaliar/how-to-build-your-first-real-time-streaming-cdc-system-introduction-part-1-5d61b2d9d511">部分</a>和第<a class="ae jo" rel="noopener" href="/@rohan.mudaliar/how-to-build-your-first-real-time-streaming-cdc-system-setup-part-2-bac2c5397d5e">部分</a>，其中包含了关于问题陈述、架构、基础设施和MySQL设置的详细信息。</p><h1 id="bc71" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">卡夫卡流的基本概念:</h1><p id="8b96" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">因此，在我们深入问题的实现之前，让我们了解一些Kafka streams的基础知识:-</p><p id="e292" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是卡夫卡溪流？</strong></p><p id="e668" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kafka Streams是一个用于构建应用程序和微服务的客户端库，其中的输入和输出数据存储在Kafka集群中。</p><p id="797e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">卡夫卡流DSL </strong></p><p id="b063" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在Java中与流进行交互，Kafka提供了Kafka Streams DSL(领域特定语言)。</p><p id="cf3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们从streams DSL中使用的两个主要抽象如下</p><h2 id="11c1" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated"><a class="ae jo" href="https://kafka.apache.org/24/documentation/streams/developer-guide/dsl-api.html#streams_concepts_kstream" rel="noopener ugc nofollow" target="_blank"> KStream </a></h2><p id="9094" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我将引用apache官方文档中提供的例子来说明以上两个问题。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/5fd846b6130e3470304be695d0c0bba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qp903PSWUg2AdzaWvY4Aqg.png"/></div></div></figure><h2 id="1c64" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated"><a class="ae jo" href="https://kafka.apache.org/24/documentation/streams/developer-guide/dsl-api.html#streams_concepts_ktable" rel="noopener ugc nofollow" target="_blank">k表</a></h2><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/28362b3760c0aa29ddb03efce236d706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AT67Yt1RnXed5KDEGMvpGw.png"/></div></div></figure><h1 id="19d2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">总体技术任务:</h1><p id="b6c9" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">就总体技术任务而言，我们的任务如下</p><ol class=""><li id="01a9" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn lr ls lt lu bi translated">使用docker建立本地基础设施。</li><li id="b3f9" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated"><strong class="is hj">使用Kafka connect将数据从MySQL数据库摄取到Kafka。</strong></li><li id="285b" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">在Java后端使用Kafka流读取数据。</li><li id="a8b3" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">为聚集视图创建弹性搜索索引。</li><li id="8847" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">实时收听事件并更新事件。</li><li id="ae8f" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">设置本地并运行java代码</li></ol><p id="78b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经完成了本系列第一篇文章中的任务1和任务2，并详细了解了解决该问题所需的不同概念。现在让我们跳到其余的任务:-</p><h1 id="ca84" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.在Java后端使用Kafka流读取数据，用于第一次创建索引。</h1><p id="13a4" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在我们已经创建了Kafka主题，下一步是读取流数据，根据需要使用Kafka流执行一些聚合，并将其存储在弹性搜索中。</p><p id="4f96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在继续编写任何代码之前，让我们看看我们希望最终的索引包含什么及其来源。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/2695fc46f6ebefbaca8bd2bcd064af10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Zj2qI-I1LND5nJvRIG1WA.png"/></div></div></figure><p id="ead6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了达到以上目的，让我把它分成几个步骤</p><ol class=""><li id="3da6" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn lr ls lt lu bi translated"><strong class="is hj">决定</strong>你想听的话题，这些将被用来创建聚合视图。</li><li id="db2f" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated"><strong class="is hj">决定</strong>您必须对表(主题)执行的<strong class="is hj">连接或转换</strong>以获得最终的聚合表。</li><li id="68f9" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">一旦构建了<strong class="is hj">最终聚合视图</strong>，调用弹性搜索来创建索引。</li></ol><p id="047a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们通过代码来看看第1点和第2点。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="2e42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们从logisticsTopic、orderTopic和wmsTopic开始。</p><p id="61af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们正在初始化一个新的streambuilder，并根据相应的主题创建一个orderKtable、logisticsKtable和wmsKtable。到目前为止，我们没有对流式数据做任何事情。</p><p id="754d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，为了构建最终的聚合视图，我们需要创建一些中间聚合。</p><p id="fa79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先处理orderKTable和wmsKTable，首先将orderId设置为键。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="md me et er es mf mg bd b be z dx translated">订单流</figcaption></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="md me et er es mf mg bd b be z dx translated">WmsStream</figcaption></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="md me et er es mf mg bd b be z dx translated">船运流</figcaption></figure><p id="9a9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经准备好了单个的表，下一步是创建中间的聚合表。我们首先用orderId 连接order和wms表，以创建一个以shipmentId为关键字的聚合视图。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="f055" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> createOrderWmsStream </strong>方法采用合并后的流，并将shipmentId设置为key。流的合并在<strong class="is hj">赋值</strong>方法中完成。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="md me et er es mf mg bd b be z dx translated"><strong class="ak"> createOrderWmsStream </strong></figcaption></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="md me et er es mf mg bd b be z dx translated"><strong class="ak">赋值</strong></figcaption></figure><p id="e5ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">AssignValues接受两个输入流，从它们中提取JSON，我们用它来创建结果DTO对象。</p><p id="7feb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们的下一步是将这个表合并到shipmentKtable中，以得到最终的聚合流。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="04a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的apendValues方法用于构造最终的聚合视图</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="md me et er es mf mg bd b be z dx translated">apendvalue</figcaption></figure><p id="c21c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> assignValues </strong>和<strong class="is hj"> apendValue </strong>方法纯粹用于为聚合视图设置值。</p><p id="339b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，我们就有了最终的汇总表。</p><h1 id="5d63" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">4.为聚集视图创建弹性搜索索引。</h1><p id="b0f3" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们看看控制器类方法</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="3364" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们读取最终的聚合流，并根据它在控制器中创建一个映射，映射的键是DTO的列，值是DTO值。在Elasticsearch中存储数据需要此地图。</p><p id="34e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦我们创建了一个地图，我们就调用服务类并提供我们想要创建的索引。这是在下面的行中完成的。</p><pre class="lh li lj lk fd mh mi mj mk aw ml bi"><span id="5c7d" class="ks jq hi mi b fi mm mn l mo mp">elasticSearchService.pushToEs(ElasticSearchTopics.OURBOUND_REPORT_TOPIC, inputMap);</span></pre><p id="b4ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看服务和DAO类，它用于将数据持久化到弹性搜索中。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="md me et er es mf mg bd b be z dx translated">ElasticsearchService创建索引</figcaption></figure><p id="5796" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们检查索引是否已经存在，如果存在，我们不创建文档。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="md me et er es mf mg bd b be z dx translated">OrderReportDAO.insertindex</figcaption></figure><p id="3e86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Elastic search有一个java高级rest API，可用于操作以与elastic search协同工作。这里我们使用IndexRequest在弹性搜索中创建新的索引。</p><pre class="lh li lj lk fd mh mi mj mk aw ml bi"><span id="6e8b" class="ks jq hi mi b fi mm mn l mo mp">IndexRequest indexRequest = new IndexRequest(tableName + "_es")<br/>     .id(payloadMap.get("id").toString())<br/>    .type("_doc").id(id).source(payloadMap);</span></pre><p id="c4cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上语句用于创建一个新的请求，以创建一个elasticsearch索引。如前所述，我们创建了一个RestHighLevelClient的实例来与来自java的弹性搜索进行交互。</p><pre class="lh li lj lk fd mh mi mj mk aw ml bi"><span id="6961" class="ks jq hi mi b fi mm mn l mo mp">restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT);</span></pre><p id="e480" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的语句基本上是在弹性搜索中创建索引。</p><h1 id="5f4a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">5.对系统进行基于事件的实时更新</h1><p id="4a49" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">既然我们已经编写了创建业务所需的聚合视图的代码，下一步就是根据单个事件的实时更新来更新创建的索引。让我们来看看我们该怎么做。让我们来看看我们是如何为wms系统中的一个事件执行此操作的。我们也可以为其他系统复制同样的方法。</p><p id="7983" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先监听wmstopic并从中创建一个流。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="bc6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦我们有了这个流，我们需要检查这个流是更新还是插入，我们通过检查这个流在对象之前是否有一个来解决这个问题。before对象的存在意味着当前记录是一个更新。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="58f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在遍历每个记录，并调用服务类来进行更新。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="fb48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在上面这段代码中做了3件事，</p><ul class=""><li id="4ae2" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn mq ls lt lu bi translated">收听wms事件，</li><li id="1cf8" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn mq ls lt lu bi translated">一旦我们有了事件，我们就用来自事件的新信息更新现有文档</li><li id="f2ca" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn mq ls lt lu bi translated">更新Elasticsearch中的特定文档。</li></ul><p id="0106" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上是处理更新的控制器。让我们看看刀的相同之处。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="md me et er es mf mg bd b be z dx translated">更新索引DAO</figcaption></figure><p id="88cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我在这里使用的是UpdateRequest，这是一个java高级客户端类，用于更新Elasticsearch索引。我们再次使用<strong class="is hj"> RestHighLevelClient </strong>来更新索引。</p><h1 id="33a0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">让我们想象一下</strong></h1><p id="28cb" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们现在已经从流中读取了数据，执行了一些聚合，创建了一个索引，并执行了一些更新。现在让我们想象一下整个事情。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/1af422449211d7e4b5fbfe2fd697ac8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYr0lojco4r_F9GFsS184g.png"/></div></div></figure><h1 id="c248" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">总结:</strong></h1><p id="f0a2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj">现在我们已经到了最后一步，让我们回顾一下我们在本练习中所做的一切:- </strong></p><ul class=""><li id="8464" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn mq ls lt lu bi translated">我们首先在MySQL数据库上启用了Binlogs。</li><li id="a560" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn mq ls lt lu bi translated">我们使用docker在本地为应用程序创建了所需的服务。</li><li id="b47d" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn mq ls lt lu bi translated">接下来，我们使用Debezium-Kafka connect创建了一个连接器，它将监听MySQL数据库中的创建/更新，并将更改推送到Kafka。</li><li id="8c2a" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn mq ls lt lu bi translated">我们编写了一个Kafka streams应用程序，它可以实时监听Kafka事件并创建聚合视图。</li><li id="e8e2" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn mq ls lt lu bi translated">我们使用RestHighLevelClient在Elasticsearch上创建了一个索引。</li><li id="fafc" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn mq ls lt lu bi translated">我们使用Kafka流编写了另一个监听器，监听单个Kafka事件并推送更新。</li></ul><p id="808a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的最后一步是在Elasticsearch中验证代码。我还包括代码设置在我们的本地为那些想尝试这一点。</p><blockquote class="ms"><p id="97f6" class="mt mu hi bd mv mw mx my mz na nb jn dx translated">如果您确实喜欢这篇文章，请务必阅读后续文章并分享您的反馈。在LinkedIn上找到我，地址是<a class="ae jo" href="https://www.linkedin.com/in/rohanganesh0506/" rel="noopener ugc nofollow" target="_blank"> rohan_linkedIn </a>。</p></blockquote></div></div>    
</body>
</html>