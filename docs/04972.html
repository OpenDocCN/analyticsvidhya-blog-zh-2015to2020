<html>
<head>
<title>Calling Function from Input</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从输入调用函数</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/calling-function-from-input-5f2982ca1df5?source=collection_archive---------40-----------------------#2020-04-06">https://medium.com/analytics-vidhya/calling-function-from-input-5f2982ca1df5?source=collection_archive---------40-----------------------#2020-04-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="92dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗨，距离我上次发帖已经很久了。借此机会，我想解释一下如何从用户输入中调用函数。是的，这将是技术性的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3151a3337e7f4b02fe87337b37dfed7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YLD0Md3dx78Fokd3"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@sxy_selia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sangga Rima Roman Selia </a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="ebd1" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">情况</h1><p id="f0a5" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated"><em class="le">为了说明的目的，这里使用的情况被简化。</em></p><p id="c4b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象你在一个非常特殊的实验室工作，专注于脱氧核糖核酸或DNA。除此之外，现在您必须创建一个定制的队列系统。</p><p id="fecc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该系统需要接受以腺嘌呤(符号为A)、鸟嘌呤(符号为G)、胞嘧啶(符号为C)和胸腺嘧啶(符号为T)形式进入的化学碱基。在接受一个输入时，它有一个<strong class="ih hj">高级算法来判断</strong>该输入是否将形成一个<em class="le">正常</em>序列并应该被存储或者是否应该被丢弃。</p><p id="a435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它还应该能够通过类似出列的机制丢弃存储的化学物质。如果需要，它还应该能够打印当前存储的化学基础。</p><h1 id="e5e7" class="kb kc hi bd kd ke lf kg kh ki lg kk kl km lh ko kp kq li ks kt ku lj kw kx ky bi translated">例子</h1><p id="9789" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在这篇文章中，我用Python来帮助解释。有些部分我们可以改进，但让我们忽略它，专注于主要问题，从输入中调用一个函数。</p><p id="5ac4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是自定义队列的类的示例:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="9efa" class="lp kc hi ll b fi lq lr l ls lt"><strong class="ll hj">class CustomQueue:<br/>  def __init__(self):<br/>   </strong> self.__queued_base = []<br/>    return</span><span id="44d1" class="lp kc hi ll b fi lu lr l ls lt"><strong class="ll hj">  def queue(self, list_of_base):<br/>    </strong>for base in list_of_base:<br/>      if base in ['a', 'g', 'c', 't']:<br/>        self.__queued_base.append(base)<br/>    return</span><span id="f6b8" class="lp kc hi ll b fi lu lr l ls lt"><strong class="ll hj">  def dequeue(self):<br/>    </strong>if len(self.__queued_base) == 0:<br/>      return<br/>    letter = self.__queued_base[0]<br/>    self.__queued_base = self.__queued_base[1:]<br/>    return letter</span><span id="b629" class="lp kc hi ll b fi lu lr l ls lt">  <strong class="ll hj">def get_queue(self):<br/></strong>    return self.__queued_base</span></pre><ul class=""><li id="8fc0" class="lv lw hi ih b ii ij im in iq lx iu ly iy lz jc ma mb mc md bi translated"><code class="du me mf mg ll b">__init__</code>将准备用于储存碱基的队列列表。</li><li id="6093" class="lv lw hi ih b ii mh im mi iq mj iu mk iy ml jc ma mb mc md bi translated"><code class="du me mf mg ll b">queue</code>将一个传入的输入进行排队。为了简单起见，上面提到的<em class="le">高级算法</em>将只存储值，如果它是‘a’、‘g’、‘c’或‘t’。</li><li id="f1e9" class="lv lw hi ih b ii mh im mi iq mj iu mk iy ml jc ma mb mc md bi translated"><code class="du me mf mg ll b">dequeue</code>将最早出列的输入。</li><li id="8b09" class="lv lw hi ih b ii mh im mi iq mj iu mk iy ml jc ma mb mc md bi translated"><code class="du me mf mg ll b">get_queue</code>会以列表的形式得到所有的化学碱基。</li></ul><p id="73c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是使用上面定义的类的示例:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="88c7" class="lp kc hi ll b fi lq lr l ls lt"><strong class="ll hj">if __name__ == '__main__':</strong><br/>  custom_queue = CustomQueue()<br/>  <strong class="ll hj">while True:</strong><br/>    user_input = input('$ ').split(' ')<br/>    command, param = user_input[0], user_input[1:]</span><span id="8a46" class="lp kc hi ll b fi lu lr l ls lt">   <strong class="ll hj"> try:</strong><br/>      msg = custom_queue.__getattribute__(command)(param)<br/>    <strong class="ll hj">except TypeError:</strong><br/>      msg = custom_queue.__getattribute__(command)()<br/>    <strong class="ll hj">except Exception as e:</strong><br/>      msg = e</span><span id="b22c" class="lp kc hi ll b fi lu lr l ls lt"><strong class="ll hj">    if msg != None:</strong><br/>      print(msg)</span></pre><p id="d87a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的实现将提示用户输入由<code class="du me mf mg ll b">command</code>和<code class="du me mf mg ll b">param</code>(空格分隔)组成的输入。<code class="du me mf mg ll b">command</code>将与<code class="du me mf mg ll b">CustomQueue</code>中的方法相同。</p><p id="8c9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面将更详细地解释提示给用户的输入。(<code class="du me mf mg ll b">$</code>后的行是供用户发送输入的。)</p><ul class=""><li id="9d5b" class="lv lw hi ih b ii ij im in iq lx iu ly iy lz jc ma mb mc md bi translated"><code class="du me mf mg ll b">$ queue f t a g k c</code>将调用<code class="du me mf mg ll b">queue</code>方法，并将<code class="du me mf mg ll b">f t a g k c</code>作为参数传递。但是由于我们的<em class="le">“高级算法”</em>，队列中只会保存<code class="du me mf mg ll b">t a g c</code>。</li><li id="a654" class="lv lw hi ih b ii mh im mi iq mj iu mk iy ml jc ma mb mc md bi translated"><code class="du me mf mg ll b">$ dequeue</code>将调用<code class="du me mf mg ll b">dequeue</code>方法并忽略任何传递的参数。如果按顺序完成了前一点，它将从列表中取消<code class="du me mf mg ll b">t</code>的队列。</li><li id="e188" class="lv lw hi ih b ii mh im mi iq mj iu mk iy ml jc ma mb mc md bi translated"><code class="du me mf mg ll b">$ get_queue</code>将调用<code class="du me mf mg ll b">get_queue</code>方法，该方法将返回基地列表。</li></ul><h1 id="1c0b" class="kb kc hi bd kd ke lf kg kh ki lg kk kl km lh ko kp kq li ks kt ku lj kw kx ky bi translated">说明</h1><p id="9ff7" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">让我们举一个流程的例子:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="3df5" class="lp kc hi ll b fi lq lr l ls lt">$ queue a f t c g k l<br/>$ get_queue<br/>['a', 't', 'c', 'g']<br/>$ dequeue<br/>a<br/>$ get_queue<br/>['t', 'c', 'g']</span></pre><p id="7e60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乍一看，好像没什么问题。但是，在现实中，它有一个安全问题。简而言之，进入上面的流程后，继续下面的流程:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="8677" class="lp kc hi ll b fi lq lr l ls lt">$ queue a<br/>$ get_queue<br/>['t', 'c', 'g', 'a']<br/>$ __init__<br/>$ get_queue<br/><strong class="ll hj">[]</strong></span></pre><p id="a512" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，你应该得到输出<code class="du me mf mg ll b">[]</code>。罪魁祸首当然是当我们输入<code class="du me mf mg ll b">__init__</code>作为输入时。为什么会是罪魁祸首？因为输入它，系统会调用方法<code class="du me mf mg ll b">__init__</code>。如果调用这个方法会发生什么？你猜对了，它会重新初始化队列列表。(可以尝试输入<code class="du me mf mg ll b">__getattribute__</code>作为命令，看看结果。)</p><h1 id="ebc7" class="kb kc hi bd kd ke lf kg kh ki lg kk kl km lh ko kp kq li ks kt ku lj kw kx ky bi translated">精炼</h1><p id="93e0" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">现在，我们明白允许用户直接从输入中调用函数或方法是危险的。来解决这个问题？很简单。我们只需要限制他们获取信息的方式。</p><p id="a3b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个如何优化我们代码的例子:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="65ec" class="lp kc hi ll b fi lq lr l ls lt">if __name__ == '__main__':<br/>  custom_queue = CustomQueue()<br/>  while True:<br/>    user_input = input('$ ').split(' ')<br/>    command, param = user_input[0], user_input[1:]</span><span id="a3f2" class="lp kc hi ll b fi lu lr l ls lt">    msg = None<br/>    if command == 'queue':<br/>      custom_queue.queue(param)<br/>    elif command == 'dequeue':<br/>      msg = custom_queue.dequeue()<br/>    elif command == 'get_queue':<br/>      msg = custom_queue.get_queue()<br/>    else:<br/>      msg = 'unknown command'</span><span id="590c" class="lp kc hi ll b fi lu lr l ls lt">    if msg != None:<br/>      print(msg)</span></pre><p id="cd6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们试图遵循前面的流程:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="bd78" class="lp kc hi ll b fi lq lr l ls lt">$ queue a f t c g k l<br/>$ get_queue<br/>['a', 't', 'c', 'g']<br/>$ dequeue<br/>a<br/>$ get_queue<br/>['t', 'c', 'g']</span></pre><p id="1c7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并输入附加流，我们将得到:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="5cac" class="lp kc hi ll b fi lq lr l ls lt">$ queue a<br/>$ get_queue<br/>['t', 'c', 'g', 'a']<br/>$ __init__<br/><strong class="ll hj">unknown command</strong><br/>$ get_queue<br/><strong class="ll hj">['t', 'c', 'g', 'a']</strong></span></pre><p id="19c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的例子提供了一种洞察力，通过限制用户可以做什么，我们的系统使用起来更安全。(还是那句话，你可以尝试输入<code class="du me mf mg ll b">__getattribute__</code>作为命令，看看结果。)</p><h1 id="3dd8" class="kb kc hi bd kd ke lf kg kh ki lg kk kl km lh ko kp kq li ks kt ku lj kw kx ky bi translated">结论</h1><p id="7ef4" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">从输入用户直接调用函数或方法可能是危险的。这将允许用户执行不必要的程序。与其这样做，不如使用<code class="du me mf mg ll b">if else</code>语句或类似的语句来限制用户可以做什么。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="7cbc" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">参考</h1><p id="1be9" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated"><a class="ae jt" href="https://ghr.nlm.nih.gov/primer/basics/dna" rel="noopener ugc nofollow" target="_blank">https://ghr.nlm.nih.gov/primer/basics/dna</a></p></div></div>    
</body>
</html>