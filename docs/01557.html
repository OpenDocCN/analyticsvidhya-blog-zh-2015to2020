<html>
<head>
<title>Using OpenCV.js in Browser based environment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在浏览器环境中使用OpenCV.js</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/using-opencv-js-in-browser-based-environment-ef67319eb06b?source=collection_archive---------5-----------------------#2019-10-31">https://medium.com/analytics-vidhya/using-opencv-js-in-browser-based-environment-ef67319eb06b?source=collection_archive---------5-----------------------#2019-10-31</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><figure class="hi hj fa fc hk hl es et paragraph-image"><div class="es et hh"><img src="../Images/8d545c393116baa2455e636684349b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*APbxeMKNvb2YYlkXyHzFyQ.png"/></div></figure><div class=""/><p id="5e99" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">OpenCV是一个功能强大的工具，可以快速操作和处理图像。为了在浏览器中引入OpenCV库，浏览器需要支持几乎所有浏览器都支持的libc++库。</p><p id="d1b1" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated"><a class="ae jl" href="https://caniuse.com/#search=asm.js" rel="noopener ugc nofollow" target="_blank"> Asm.js </a>是用浏览器在其原生环境中使用的C++编写的。这里提供的<a class="ae jl" href="https://raw.githubusercontent.com/aswinvk28/open-cv-js-img-color/master/opencv.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ip hr"> OpenCV.js源码</strong> </a>已经使用Emscripten (EMSDK)编译完成，它利用Asm.js和libc++将c++代码转换成javascript代码。Javascript在单线程环境中运行，但是Emscripten有一个类似于C++ (Openmp)中的任务的东西，叫做Web Workers。借助最新浏览器版本支持的<a class="ae jl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>库，多线程成为可能。WebAssembly常用于WebGL，基准测试结果非常出色。</p><p id="17cc" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">计算机视觉涉及模式识别、人工智能和机器学习。在客户机服务器模型中，服务器不需要拥有给定任务的完整序列图模型。在某些用例中，将序列图分成两个上下文是理想的:客户机和服务器上下文。</p></div><div class="ab cl jm jn gq jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hc hd he hf hg"><p id="e9cb" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated"><strong class="ip hr">依赖于客户端和服务器端的OpenCV项目</strong></p><p id="2edc" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">下表来自<a class="ae jl" href="http://blog.kaggle.com/2016/07/21/approaching-almost-any-machine-learning-problem-abhishek-thakur/" rel="noopener ugc nofollow" target="_blank"> <strong class="ip hr">上的帖子，探讨任何机器学习问题</strong> </a>。它将机器学习的阶段分为:</p><ul class=""><li id="a8fb" class="jt ju hq ip b iq ir iu iv iy jv jc jw jg jx jk jy jz ka kb bi translated">培训和验证分离，</li><li id="ce4b" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">数据转换</li><li id="36d4" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">ML模型选择器</li><li id="25f7" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">ML实体选择器</li><li id="57ae" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">超参数选择器</li><li id="86fd" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">特征抽出</li><li id="5855" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">通过优化产生输出</li></ul><p id="bf8e" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">在训练模型时，可以将数据转换成多种方式。一个简单的方法是通过减去数据的平均值并除以标准偏差来标准化数据。客户端的OpenCV可以转换数据并提取特征，例如在人脸检测中可以提取人脸位置。</p><figure class="ki kj kk kl fe hl es et paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="es et kh"><img src="../Images/0bdd65708d907ad5879913f7dc208567.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*86VSRjcNTswLtmrxNMMq5Q.png"/></div></div><figcaption class="kq kr eu es et ks kt bd b be z dy translated">拍摄使用<a class="ae jl" href="https://aidemos.microsoft.com/face-recognition" rel="noopener ugc nofollow" target="_blank">https://aidemos.microsoft.com/face-recognition</a>，@礼貌<a class="ae jl" href="https://thispersondoesnotexist.com/" rel="noopener ugc nofollow" target="_blank">https://thispersondoesnotexist.com/</a></figcaption></figure><p id="5061" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">OpenCV有很多级联算法，比如Viola Jones，HOG(历史导向梯度)。Viola Jones是一种无监督算法，使用邻近像素提取特征。它对图像进行图像积分，类似于图像卷积，但有一个限制，即需要指定图像大小。Viola Jones是一种无监督学习算法，而卷积神经网络使用监督学习技术，除非是使用CNN进行特征提取的情况。在OpenCV库中，它们通常被归类为哈尔级联。我相信我们需要更好的人工智能、机器学习和计算机视觉服务标准。引领我们走向更高性能模型的标准。</p><p id="1369" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">我对面向对象方法中的契约式设计有一种特殊的亲近感。这是一种技术。如果合同发起者有一定的责任，客户对其也有一定的义务。此外，如果客户有一定的责任，合同发起人对客户有一定的义务。它们记录在下表中:</p><figure class="ki kj kk kl fe hl"><div class="bz dz l di"><div class="ku kv l"/></div></figure><p id="54f1" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">OpenCV.js最适合在客户端设置阈值，如下所示。客户端可以执行的其他任务有:</p><ul class=""><li id="4c79" class="jt ju hq ip b iq ir iu iv iy jv jc jw jg jx jk jy jz ka kb bi translated">侵蚀</li><li id="1e65" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">扩张</li><li id="1cbf" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">盘旋</li><li id="9353" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">拉普拉斯算子的（调和算子）</li><li id="ba95" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">图像渐变</li><li id="092e" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">区域生长</li><li id="e574" class="jt ju hq ip b iq kc iu kd iy ke jc kf jg kg jk jy jz ka kb bi translated">图象分割法</li></ul><p id="1549" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">使用区域生长和阈值化的图像分割尤其是一种粗糙的方法，并且需要我们向模型提供参数以便完成工作。所以这个域在客户端执行非常有用。</p><figure class="ki kj kk kl fe hl es et paragraph-image"><div class="es et kw"><img src="../Images/3b86403fd2bc20f0c3eaf63736bc9353.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*ZCeIF2Nxb-_Z7FkbFVNpPg.png"/></div><figcaption class="kq kr eu es et ks kt bd b be z dy translated">图像阈值结果</figcaption></figure><p id="0b95" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">有许多利用并行计算的库，如Emscripten to transpile JS code、<a class="ae jl" href="https://hacks.mozilla.org/2014/10/introducing-simd-js/" rel="noopener ugc nofollow" target="_blank"> <strong class="ip hr"> SIMD.js </strong> </a>、Asm.js。从开发人员的角度来看，他们通过本地化计算能力，使任务易于执行，甚至做得更多。</p><p id="d77f" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated"><strong class="ip hr">在浏览器中设置opencv . js</strong></p><pre class="ki kj kk kl fe kx ky kz la aw lb bi"><span id="ee37" class="lc ld hq ky b fj le lf l lg lh">&lt;script type=”text/javascript”&gt; <br/>    var DISABLE_EXCEPTION_CATCHING = 2;<br/>&lt;/script&gt;</span></pre><p id="8d08" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated"><strong class="ip hr">在浏览器环境中调用OpenCV方法</strong></p><pre class="ki kj kk kl fe kx ky kz la aw lb bi"><span id="dd99" class="lc ld hq ky b fj le lf l lg lh">let src = cv.imread(document.getElementById("img_tag_id"));<br/>cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);</span><span id="58c5" class="lc ld hq ky b fj li lf l lg lh">let marker = new cv.Mat(rows,cols,cv.CV_8UC1);</span><span id="a66e" class="lc ld hq ky b fj li lf l lg lh">try { <br/>  cv.adaptiveThreshold(src,marker,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,   cv.THRESH_BINARY,11,2);  <br/>} <br/>catch(e) {    <br/>  throw e;  <br/>}</span></pre><p id="9abd" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">在编码时，确保你写的是同一个对象，因为这样可以减少内存消耗。这是ECMAScript，可以在Chrome上运行，但不能在所有浏览器上运行。可以使用<a class="ae jl" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ip hr"> Webpack </strong> </a>将ECMAScript编译成原生JS。</p></div><div class="ab cl jm jn gq jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hc hd he hf hg"><p id="fd09" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated"><strong class="ip hr">数据格式和数据集</strong></p><blockquote class="lj"><p id="63ca" class="lk ll hq bd lm ln lo lp lq lr ls jk dy translated">一个简单的例子是“使用Javascript数组符号编写数组”</p></blockquote><p id="9a9a" class="pw-post-body-paragraph in io hq ip b iq lt is it iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk hc bi translated">任何客户端算法使用的数据格式都必须符合数据集使用的格式。这可以封装数据转换例程、图像的形状和大小、一个图像将映射到的类等等。我喜欢微软的CNTK BrainScript，因为它是一种基于文本的格式，对于从客户端捕获需求非常有用。一个简单的例子是“使用Javascript数组符号编写数组”。我相信CNTK的BrainScript文本阅读器是一种发明艺术，因为它们满足了任何算法想要的最佳需求。主要依赖客户端的机器学习框架必须使用BrainScript产生的数据格式。这种技术类似于React的技术，React使用JSX风格的语法来捕获用户想要的几乎所有功能，并且几乎是本地实现。微软Azure使用基于图表的模型来自动化交付机器学习解决方案的过程，这很好，并为我们提供了设计一些ML任务的灵活性。</p><p id="ee4c" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated"><strong class="ip hr">功能工具</strong></p><p id="1055" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">Featuretools(基于Python)包是一个创建数据属性之间关系的要素合成包。这有点类似于数据仓库，因为它可以生成事实表，甚至是星型模式。数据仓库标准说我们需要将日期分成时间、小时、天、月、年等维度。这对featuretools也非常重要，因为它们经常处理时态数据。对于合成和工作流自动化，时态数据是必需的。</p><p id="c8aa" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated"><strong class="ip hr"> OpenCV和特征工程</strong></p><p id="a4ba" class="pw-post-body-paragraph in io hq ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hc bi translated">这是cascade<strong class="ip hr">haarcascade _ smile . XML的摘录</strong>看看cascade文件中存储了什么元数据。它查看那些Viola Jones邻近像素并进行测量。</p><pre class="ki kj kk kl fe kx ky kz la aw lb bi"><span id="2c81" class="lc ld hq ky b fj le lf l lg lh">&lt;opencv_storage&gt;<br/>&lt;cascade type_id="opencv-cascade-classifier"&gt;&lt;stageType&gt;BOOST&lt;/stageType&gt;<br/>  &lt;featureType&gt;HAAR&lt;/featureType&gt;<br/>  &lt;height&gt;18&lt;/height&gt;<br/>  &lt;width&gt;36&lt;/width&gt;<br/>  &lt;stageParams&gt;<br/>    &lt;maxWeakCount&gt;53&lt;/maxWeakCount&gt;&lt;/stageParams&gt;<br/>  &lt;featureParams&gt;<br/>    &lt;maxCatCount&gt;0&lt;/maxCatCount&gt;&lt;/featureParams&gt;<br/>  &lt;stageNum&gt;20&lt;/stageNum&gt;<br/>  &lt;stages&gt;</span><span id="bf59" class="lc ld hq ky b fj li lf l lg lh">........</span><span id="bd75" class="lc ld hq ky b fj li lf l lg lh">        &lt;_&gt;<br/>          &lt;internalNodes&gt;<br/>            0 -1 105 -5.1861900836229324e-02&lt;/internalNodes&gt;<br/>          &lt;leafValues&gt;<br/>            7.0431172847747803e-01 -2.2143700718879700e-01&lt;/leafValues&gt;&lt;/_&gt;<br/>        &lt;_&gt;<br/>          &lt;internalNodes&gt;<br/>            0 -1 106 -5.0341628491878510e-02&lt;/internalNodes&gt;<br/>          &lt;leafValues&gt;<br/>            -4.6397829055786133e-01 2.8047460317611694e-01&lt;/leafValues&gt;&lt;/_&gt;</span></pre></div><div class="ab cl jm jn gq jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hc hd he hf hg"><h1 id="9611" class="ly ld hq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><strong class="ak">结论</strong></h1><p id="5ee6" class="pw-post-body-paragraph in io hq ip b iq mv is it iu mw iw ix iy mx ja jb jc my je jf jg mz ji jj jk hc bi translated">我必须就这个主题写更多的东西，因为关于合成数据集和前端的主题让我兴奋。试着用C++写一些线程模型，用openmp编译成JS代码。你可以在Javascript中看到接近原生的体验。在基于浏览器的环境中使用ONNX.js模型有很多机会。完成这项工作的一些工具有:- CoreMLTools(来自苹果)，ONNX.js(来自微软)，TensorFlow.js(来自谷歌)。在这些算法中，创建一个张量网格是非常困难的。通过客户端对矢量化数据的处理，有许多解决问题的用例成为可能，并降低了计算能力。</p></div></div>    
</body>
</html>