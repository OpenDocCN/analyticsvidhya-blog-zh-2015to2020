# 使用尝试自动完成

> 原文：<https://medium.com/analytics-vidhya/autocomplete-using-tries-42aadd875d72?source=collection_archive---------7----------------------->

你知道，当你在谷歌上键入一个词，它会给你建议/预测你应该搜索什么。好吧，我们从简单的开始！我们将根据给定的输入预测一个单词，类似于自动完成功能。

我将使用 c++来实现一个 trie 并搜索它。你可以在这里找到代码[。](https://github.com/jinit24/Word-Predictor)

尝试是强有力的结构。您可以将 trie 视为一棵树，其中每个节点存储一个字母表。所以通过遍历特里树，你可以存储，搜索和匹配字符串。

![](img/bef601fa56811c1eb895ac9b9d69be67.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上 [veeterzy](https://unsplash.com/@veeterzy?utm_source=medium&utm_medium=referral) 拍摄的照片

# **节点**

我将只写小写字母。所以，我们总共有 26 个字母。每个节点存储的值由其父节点的路径决定。因此，如果我们采用第 0 条路径，节点存储“a”，第 1 条路径存储“b”，依此类推。每个节点有 26 个子节点，有些可能为空。

我们还使用其他三个值:end、size 和 maxfreq。End 给出了在该节点结束的单词的数量，或者可以认为是单词的频率。Size 给出了以这个节点为根的子树的大小，所以它基本上是使用这个节点的单词的数量。Maxfreq 存储具有最高频率的字的频率，并使用该节点。(您将提前意识到我们为什么需要这个变量)

# **插入文字**

我们可以用数字来引用它们，而不是用字母。我们还添加了一个根节点，它是起点。在向 trie 树插入字符串时，我们从第一个字母开始。我们检查子节点是否不为空，如果不为空，就转移到子节点。如果它是空的，那么我们在那里创建一个新的节点。我们不断重复这个过程，直到到达字符串的末尾。在最后一个节点，我们增加其末端的值。这告诉我们一个词在这里结束了。

这里我们没有更新 maxfreq 变量。我们需要再次遍历相同的路径，更新这个路径中的节点，如果这个词的频率大于原来的 maxfreq。

既然我们已经插入了单词，我们就要开始预测了。你能想到的最简单的方法是预测最接近的方法:BFS(广度优先搜索)让我们从这个开始。

# 下一个最接近的单词

我们现在必须找到下一个最接近的单词。首先，我们输入所有可能的单词。所以基本上整个字典或者类似的东西。然后我们接受一个词，我们必须完成或预测它的结尾。所以，一旦添加，我们就开始搜索。对于下一个最近的单词，我们将不得不使用一些遍历技术。DFS 还是 BFS？但是 DFS 将首先遍历一条路径，然后移动到下一个子路径。这和我们想要的不一样。我们使用 BFS，因为它完全遍历该层，然后移动到下一层。我们只是检查一个单词是否在那里结束，并将其添加到我们的预测中。

例如，输入是“rat”。在遍历了 trie 之后，我们已经到达了表示“t”的节点。我们现在将{this node，rat}推入队列，如果 rat 是一个符合您的 trie 的单词，那么它将被添加到我们的答案列表中。

然后第 17–19 行将所有子节点添加到队列中。因此，这可能会推动 rate、rati、rats 等词的出现。所以这里 rati 不是一个单词，但是如果 rating 存在于 trie 中，则节点‘I’存在，因此它被推到队列中。我们移动到队列中可能被评级的下一个成员，并且重复这个过程，直到我们没有找到 5 个单词或者队列是空的。

您可以在 github 资源库的“initial”分支中找到这段代码。

# 基于频率的预测

上面的算法很简单，但结果并不是最好的。我们希望根据用户对单词的使用来预测单词。所以我们需要一个输入文本，要么给出每个单词的频率，要么只是一篇短文。然后，我们可以将这些单词添加到我们的 trie 中，根据用法，每个单词的频率将存储在节点中。

现在我们有了所有单词的频率，我们如何使用它。我们想预测频率最高的那个，对吗？这就是 maxfreq 变量有用的地方。

同样，对于给定的输入，我们通过遍历到达标记其结束的节点(node* temp)。我们现在维护一个优先级队列，只是为了让事情更简单。对于它的每个孩子，我们添加{maxfreq，input + 'character'}，这里的字符可以是从 a 到 z，这取决于你考虑的是哪个孩子。

然后，我们挑选优先级队列的前 5 个元素。但是我们仍然需要找到代表 maxfreq 的单词。我们如何做到这一点？

第 7–12 行，我们知道 maxfreq 是当前节点的子节点。因此，我们检查它的每个孩子是否有相同的 maxfreq 值。如果是的话，我们正朝着正确的方向前进，走向世界的尽头。如果节点的端点/频率等于 maxfreq，那么我们找到了我们的字。

举个同样的例子，input 是 rat。现在，对于每个孩子，如果它存在，我们将 maxfreq 添加到优先级队列中。因此队列可以是 rats、ratd、rata 等形式。优先级队列按其 maxfreq 值排序。所以如果你仔细观察，你会发现我们从 26 个可能的孩子中挑选了 5 个。因此，如果与其他单词相比，偶数评级和比率都具有非常高的频率，则只会从两个单词中选出一个。我们可以通过从 676 个可能的案例中挑选 5 个来增加复杂性。你肯定会有更准确的结果。

**随机点思考**

1.  现在我们假设输入是一个精确的前缀。我们可以尝试合并有一个错误和/或额外字符的案例。主遍历算法保持不变，但是我们提供的字符串发生了变化。想想你将如何合并所有这些预测，基于什么？
2.  除了长度和频率之外，还有其他标准需要考虑吗？上下文绝对可以使用。但问题是量化它，也许把相似的词组合在一起。我们需要不同的数据结构吗？听起来很有趣。
3.  我们能推断出树的概念来预测下一个单词，从而预测句子吗？那么现在节点代表什么呢？

这是自动完成的一个非常基本的版本，假设输入是一个精确的前缀。如果你在任何地方卡住了，你可以参考我写的代码。github 资源库也有类似 UI 的命令行，一定要去看看！

```
>> predict kin -v
Input is an exact prefix : kind king kinsman kinky kine 
After assuming exactly one mistake: mind line lingered min kong 
After assuming exactly one extra character: in into know knew kind 
Time taken for query : 347 microseconds
Predictions are : kind king in into know
```

有任何问题或建议，随时打电话给我！:D