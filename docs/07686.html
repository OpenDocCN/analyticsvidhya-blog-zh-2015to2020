<html>
<head>
<title>Partitional Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分割聚类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/partitional-clustering-181d42049670?source=collection_archive---------0-----------------------#2020-07-04">https://medium.com/analytics-vidhya/partitional-clustering-181d42049670?source=collection_archive---------0-----------------------#2020-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/291467138e3671fe2715d7d90ea8692a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pX0ixk2x9VAaK8-a.jpeg"/></div></div></figure><p id="132b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还想知道集群是怎么回事吗？让我们举一个例子来理解集群的概念。假设你是一个店主，你希望了解你的顾客的偏好，以扩大你的业务。你有没有可能观察每一个顾客的细节，并为他们中的每一个人设计一个独特的商业策略？肯定不是。但是，你可以做的是根据顾客的购买习惯将他们分成5组，并对这5组中的每一组使用不同的策略，这样你就可以有效而恰当地向每一组推销你的产品。这就是我们所说的<strong class="is hj">集群</strong>。这是识别不满意的客户需求的有力手段。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/63df99a45bcfdc50fd7c00d9fa9de941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*16DJFIlETL-jdAlg.png"/></div></div></figure><p id="906f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">聚类</strong>的任务是将一组客户分组，使得同一组(称为<strong class="is hj">聚类</strong>)中的客户彼此之间比其他组(聚类)中的客户更加相似(在某种意义上)。聚类分析使用数学模型，根据每个组中客户之间的最小差异来发现相似的客户组。聚类算法试图在某种相似性的基础上分析自然的数据组。它定位数据点组的质心。为了执行有效的聚类，该算法评估每个点与聚类质心之间的距离。聚类的目标是确定一组未标记数据(即没有任何因变量的数据)中的内在分组。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/7792ea254db47dae0e959ab928fa075e.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/0*2XAlDliNOBdXpy6j.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">使聚集</figcaption></figure><p id="ecd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">聚类是将数据点划分为同类或同类:</p><ul class=""><li id="caae" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">同一组中的点尽可能相似</li><li id="6417" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">不同组中的点尽可能不同</li></ul><h1 id="72c1" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">聚类的应用-</h1><ul class=""><li id="4e7a" class="jy jz hi is b it lk ix ll jb lm jf ln jj lo jn kd ke kf kg bi translated">聚类有助于营销人员改善他们的客户群，并在目标领域开展工作。它帮助人们分组(根据不同的标准，如意愿，购买力等。)基于它们在许多方面与所考虑的产品的相似性。</li><li id="d7cd" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">聚类有助于根据房屋的价值、类型和地理位置来识别房屋组。</li><li id="7c2c" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">聚类被用来研究地震。基于一个地区中受地震袭击的区域，聚类可以帮助分析下一个可能发生地震的位置。</li></ul><h1 id="9c1d" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">集群中的分区是什么？</h1><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/9b58bafc479631f3631cd209a0c60453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/0*q1uMVNFuuKO2Cjm1.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">分割聚类</figcaption></figure><p id="8e8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们拥有的最流行的一类聚类算法是迭代重定位算法。这些算法通过在聚类之间迭代地重新定位数据点来最小化给定的聚类标准，直到获得(局部)最优分区。划分方法有很多算法，其中比较流行的有K-Means、PAM(k-Medoid)、CLARA算法(大型应用聚类)等。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="05ae" class="km kn hi bd ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf mb lh li lj bi translated">聚类中使用的分区算法-</h1><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/9de24dd2ec681c44a85af450dbf6bfd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*EkVHmsUShFTV1qOe.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">分割聚类的类型</figcaption></figure><p id="a13b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> K-Means算法(一种基于质心的技术):</strong>这是一种最常用的算法，用于将给定数据集划分为一组K个组(即<em class="md"> k个簇</em>)，其中K代表组的数量。它将对象分类为多个组(即聚类)，使得同一聚类内的对象尽可能相似(即高<em class="md">类内相似度</em>)，而来自不同聚类的对象尽可能不相似(即低<em class="md">类间相似度</em>)。在k均值聚类中，每个聚类由其中心(即<em class="md">质心</em>)表示，该中心对应于分配给该聚类的点的均值。k-means聚类的基本思想包括定义聚类，以使总的类内变化(称为总的类内变化)最小化。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es me"><img src="../Images/f906f58d964603a5e26692fede8e6d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*Y8A_PtK1ObhNIlVX3j8aTw.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">K-means算法的过程</figcaption></figure><p id="4ead" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">K均值聚类中涉及的步骤:</p><ol class=""><li id="35ec" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn mf ke kf kg bi translated">使用k-均值聚类的第一步是指出最终解决方案中将生成的聚类数(k)。</li><li id="9822" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">该算法首先从数据集中随机选择k个对象作为聚类的初始中心。选定的对象也称为聚类方法或质心。</li><li id="b0a5" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">接下来，将剩余的每个对象分配给其最近的质心，其中最近的使用对象和聚类平均值之间的<a class="ae mg" href="https://www.datanovia.com/en/lessons/clustering-distance-measures/" rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>来定义。这个步骤被称为“集群分配步骤”。</li><li id="36ec" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">在分配步骤之后，该算法计算每个聚类的新平均值。术语“质心更新”用于设计这一步骤。现在中心已经被重新计算过了，每一次观察都被再次检查，看它是否可能更接近不同的聚类。使用更新的聚类方法再次重新分配所有对象。</li><li id="dc3c" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">重复聚类分配和质心更新步骤，直到聚类分配停止变化(即，直到实现<em class="md">收敛</em>)。也就是说，在当前迭代中形成的聚类与在前一次迭代中获得的聚类相同。</li></ol><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/d8c23cdde907c77fc91bebf731adfe68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*2ANlweIsmlzlxyn6NlDnvQ.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/1e336177e3f281880d7ec3e6b5523064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*7NFCEZQ7--9L6tE5FaAZeA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">K均值聚类示例</figcaption></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/1e336177e3f281880d7ec3e6b5523064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*7NFCEZQ7--9L6tE5FaAZeA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">K均值聚类示例</figcaption></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/859d4374ab5ffb32f60e42a65da0e41e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*cMO6dJe9Bg_NlPcgTf809w.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">K-均值聚类的绘制</figcaption></figure><p id="4519" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> K-Medoids算法(围绕Medoids进行分区):</strong></p><ol class=""><li id="d1b2" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn mf ke kf kg bi translated">可以将medoid定义为聚类中的点，其与该聚类中所有其他点的相似性是最大的。</li><li id="245d" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">在k-medoids聚类中，每个聚类由该聚类中的一个数据点表示。这些点被命名为星团。术语medoid是指一个簇中的一个对象，对于该对象，它与该簇中所有其他成员之间的平均相异度是最小的。它对应于群集中位于最中心的点。</li><li id="1aae" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">这些对象(每个集群一个)可以被视为该集群成员的代表性示例，这在某些情况下可能是有用的。回想一下，在k均值聚类中，给定聚类的中心是作为该聚类中所有数据点的平均值来计算的。</li><li id="ab1a" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">K-medoid是k-means聚类的一种健壮的替代方法。这意味着，与k-means相比，该算法对噪声和异常值不太敏感，因为它使用medoids作为聚类中心，而不是means(在k-means中使用)。</li></ol><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/5a2a0017e6d20726ac5fafa4f6746ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/0*3pS4WfjuzHYHYiOr.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">K-Medoid聚类中涉及的步骤</figcaption></figure><p id="863c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">K-Medoids聚类中涉及的步骤:</p><ol class=""><li id="ddc7" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn mf ke kf kg bi translated">PAM算法是基于在数据集的观测值中搜索k个代表对象或medoids。</li><li id="503d" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">在找到一组k个中面之后，通过将每个观察值分配给最近的中面来构建聚类。</li><li id="be02" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">接下来，交换每个选定的medoid m和每个非medoid数据点，并计算目标函数。目标函数对应于所有对象与其最近的中面的相异度的总和。</li><li id="7137" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">交换步骤试图通过交换选定的对象和未选定的对象来提高聚类的质量。如果目标函数可以通过将一个选定的对象与一个未选定的对象互换来减少，则进行交换。这一直持续到目标函数不能再降低为止。目标是找到k个代表对象，其最小化对其最近的代表对象的观察的相异度的总和。</li></ol></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="58c5" class="km kn hi bd ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf mb lh li lj bi translated"><strong class="ak">K-均值之间的差异&amp;K-均值聚类- </strong></h1><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es et"><img src="../Images/de6ea129b6166c720fed990486ffc2fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tzjBb8kfVQu8tLp5"/></div></div></figure><ol class=""><li id="5147" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn mf ke kf kg bi translated"><em class="md">K</em>-意味着尝试最小化总的<a class="ae mg" href="http://en.wikipedia.org/wiki/Mean_square_error" rel="noopener ugc nofollow" target="_blank">平方误差</a>，而<em class="md"> k </em> -medoids最小化被标记为在一个聚类中的点和被指定为该聚类的中心的点之间的不相似性的总和。与k-means算法相反，k-medoids选择数据点作为中心(<a class="ae mg" href="http://en.wikipedia.org/wiki/Medoids" rel="noopener ugc nofollow" target="_blank"> medoids </a>或样本)。</li><li id="574c" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">与K-means相比，K-medoid对噪声和异常值更鲁棒，因为它最小化一般成对相异度的和，而不是平方欧几里得距离的和。</li><li id="dd70" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn mf ke kf kg bi translated">K-medoids的优势在于处理<strong class="is hj">距离而不是数值</strong>距离，并且非常适合分析包含数值和分类特征的混合型数据。</li></ol><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/0411fc0a3fc1de197d74db590eab152b.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*gxi68ZiYE-YEDtCQyRhy7Q.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">k-均值和k-中胚之间的区别</figcaption></figure><h1 id="60fa" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论-</h1><p id="cc64" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb ml jd je jf mm jh ji jj mn jl jm jn hb bi translated">在这篇文章中，我们讨论了什么是集群，以及如何将集群应用到他们的业务决策中。然后，我们讨论了聚类中使用的基于划分的算法，以及两种主要的划分技术，即K-means和K-medoids，并了解了这两种算法之间的差异，可以根据业务问题选择其中一种算法。</p></div></div>    
</body>
</html>