<html>
<head>
<title>Creating a custom Convolutional Neural Network in Tensor-flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在张量流中创建自定义卷积神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-a-custom-convolutional-neural-network-in-tensor-flow-a9b29ae9fcf9?source=collection_archive---------7-----------------------#2019-10-14">https://medium.com/analytics-vidhya/creating-a-custom-convolutional-neural-network-in-tensor-flow-a9b29ae9fcf9?source=collection_archive---------7-----------------------#2019-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b056b539c5c41f6778b30dbe54a4a94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSWsFuippumURrKwnaeG2w.jpeg"/></div></div></figure><p id="6cbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们将了解如何使用低级张量流来创建卷积神经网络(Conv网)模型，而无需Keras之类的高级API。在这方面，我们知道深层神经网络的背景过程，以及如何使用张量流来创建自定义代码。</p><p id="a4c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更好地理解，我们采取了MNIST手写数字数据集。</p><p id="553c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一点上我们看到</p><ol class=""><li id="891c" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">MNIST数据集</li><li id="c80d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">ConvNet模型</li><li id="c0a5" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">卷积层</li><li id="1434" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">模型图</li><li id="e762" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">构建ConvNet图</li><li id="fdb6" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">损失和优化</li><li id="b2cc" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">训练和测试模型</li><li id="ef0b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">保存模型</li><li id="6bb9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj"> MNIST数据集</strong></li></ol><p id="b96e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它是60，000个0到9之间的手写单个数字的小正方形28×28像素灰度图像的数据集。任务是将一个给定的手写数字图像分成10类，代表从0到9的整数值。</p><p id="56e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">加载MNIST数据集并查看样本图像。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/ead564c1aa1a4fc5ec14b297fa48db07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMIJVFjtHho9P3Vym0Cblw.png"/></div></div></figure><p id="c257" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">标签是整数值(如0，1，2)，但标签是分类值，因此需要对它们进行一次性编码(如[1，0，0]，[0，1，0]，[0，0，1])，以便进行训练。Keras有一个编码器to _ categorical，我将用它来转换标签。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/ab6393d50c42d6b3b4f8dd3db395af7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xmQzAqFHZOkCa05NV2EEFg.png"/></div></div></figure><p id="44c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。ConvNet型号</strong></p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/24c41194d42ca3538130a62986c17456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1I7V2fTlocbx2xB6aHz1LQ.png"/></div></div></figure><p id="e437" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该架构有四个卷积层。前两层有16个滤镜，后两层有32个滤镜，所有滤镜的尺寸都是<strong class="is hj"> 3x3 </strong>。四个卷积层中的每一层都添加了偏差和relu激活。最后两层是全连接(密集)层。</p><p id="749d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。权重和偏差</strong></p><p id="6f2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ConvNet中的初始权重需要是对称破缺的随机值，以便网络能够学习。xavier_initializer“旨在保持所有层中梯度的比例大致相同”，通常用于初始化模型的权重。</p><p id="6580" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过使用带有tf.get_variable的初始化器来创建层的权重。每个卷积层都有形状为[filter_height，filter_width，in_channels，out_channels]的过滤器。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/0e8bc12d33c2a2d4f49cbd26ae1686aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ujz5dbG5TNEqGwJZWNL_kg.png"/></div></div></figure><p id="09d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 4。卷积层</strong></p><p id="874e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了简化卷积层，我将创建一个函数，它采用输入数据<strong class="is hj"> x </strong>并应用权重为<strong class="is hj"> w </strong>的2D卷积，添加一个偏差<strong class="is hj"> b </strong>，并使用relu激活。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/5dfcb0c97535e939fde4952dd2902fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMG72kffuoL7lYPPLlsv_w.png"/></div></div></figure><p id="edc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 5。模型图</strong></p><p id="4c19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个函数可以用来制作模型图。这将把MNIST图像作为<strong class="is hj">数据</strong>接收，并使用不同层中的权重和偏差。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/c3e89e5e76b946dc171b6005dfe28d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6zr4qcd1En5ozgnkoCWmmA.png"/></div></div></figure><p id="2d77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6。构建ConvNet图</p><p id="142e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们可以构建将用于训练模型的数据流图。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/78cb9a9230b0a6539e50279b98840501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_P0aZTktk5QQqKfHbFZ0Mw.png"/></div></div></figure><p id="7c1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7。损失&amp;优化器</p><p id="df69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">损失可以通过softmax的交叉熵来计算。这些都可以使用TensorFlow的softmax交叉熵一步完成。由于我们正在测量一批图像的损失，我们可以使用<strong class="is hj"> tf.reduce_mean </strong>来获得该批图像的平均损失。</p><p id="fd34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我使用的是学习率为<strong class="is hj"> 1e-4 </strong>的<strong class="is hj">亚当</strong>优化器。然后计算梯度，并通过运行minimize方法来更新权重。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/c39d0104650a2652c62203de8c6edc74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISctC8jdB0e_gnylQON5Aw.png"/></div></div></figure><p id="dfdb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 8。培训和测试模型</strong></p><p id="918a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过在会话中调用<strong class="is hj"> train_op </strong>，图表中的所有步骤都将如上所述运行。我将使用<strong class="is hj"> tqdm </strong>查看每个时期的训练进度。在每个历元之后，测量精度并打印出来。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/05429b44c24be06ff3ed419756d4e3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Sk0c6eY4WGSiIw1nY83Jw.png"/></div></div></figure><p id="5740" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 9。保存模型</strong></p><p id="9db9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以使用tf.train.Saver将会话和模型图以及经过训练的权重和偏差保存为检查点。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/0c8fe5a74c038cecbc82eea958679272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKIXxzyTasiDXN025cItrQ.png"/></div></div></figure></div></div>    
</body>
</html>