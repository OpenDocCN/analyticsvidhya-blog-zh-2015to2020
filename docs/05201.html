<html>
<head>
<title>Analyzing Linear and Binary Search Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析线性和二分搜索法算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/analyzing-linear-and-binary-search-algorithms-e20f0113089f?source=collection_archive---------40-----------------------#2020-04-13">https://medium.com/analytics-vidhya/analyzing-linear-and-binary-search-algorithms-e20f0113089f?source=collection_archive---------40-----------------------#2020-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d034d8f62e503007caceebb1e027a00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MMVn3WpXeEJnx1c6K8yoWQ.jpeg"/></div></div></figure><p id="a17a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">搜索可以被认为是一个软件产品拥有良好用户体验的最重要的特征之一。例如，每当我们登录亚马逊，我们可以直接进入搜索栏，输入我们希望购买的产品，而不是一个接一个地浏览所有产品！</p><p id="b251" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着数据量的增加，搜索算法可能会变得非常复杂，编写高效算法的关键是首先理解基础知识。今天，我们将研究两个简单的搜索算法，它们都适用于数组数据结构。这将让您了解如何执行搜索操作，以及当输入数据增加时对效率的影响。</p><p id="09a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">线性搜索</strong></p><p id="34ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">顾名思义，线性搜索一个接一个地遍历数组中的所有元素，直到找到想要的元素。</p><p id="2fb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有以下数组，它存储了添加到在线杂货购物车中的产品列表:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/45bba6d757b18b60e90bfcb1be46194e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gq7DsgjkNp9BYV8h"/></div></div></figure><p id="2afe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结账时，我们决定把苏打水从单子上去掉。为了做到这一点，我们首先需要在列表中找到“苏打水”的确切位置。</p><p id="a2ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">线性搜索将如下进行:</p><p id="6418" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第一步:</strong>从索引0开始。物品是“汽水”吗？</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/f5f0860b4c6840598ea5a939531eb168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_YeGwcMaNlb0gHxz"/></div></div></figure><p id="92f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不，这不是苏打水。继续下一个元素</p><p id="cbc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第二步:</strong>索引1处的项目是“苏打水”吗？</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/d2078dfae1b804c926c4017ce8b41961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*97WXEq2uAg00mYVy"/></div></div></figure><p id="7bf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有。继续下一个元素</p><p id="0cf4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第三步:</strong>索引2处的物品是“汽水”吗？</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jv"><img src="../Images/546fd57a1b668101094491df149136aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tQNTRUW4fr9SC3jj"/></div></div></figure><p id="0633" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有。继续下一个元素</p><p id="9c34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第四步:</strong>索引3处的物品是“汽水”吗？</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jw"><img src="../Images/c2531dd28589604d5021d146d99acec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wqcuGb3JA3GVOrIE"/></div></div></figure><p id="b6fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有。继续下一个元素</p><p id="d78f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第五步:</strong>索引4处的物品是“汽水”吗？</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/0a2dcd79bd26377a96fe143911f5641e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sPsB7YzuSvZWxVeS"/></div></div></figure><p id="fee6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有。继续下一个元素</p><p id="b4ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第六步:</strong>索引5的物品是“汽水”吗？</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/f50539f02411b577cf5d96e81904470c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WQLKYSdRqRywhQaq"/></div></div></figure><p id="0798" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是啊！终于！唷！</p><p id="9783" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过我们的线性搜索算法，在数组中的索引5(或位置6)找到了项目soda。为了在第6个位置找到一个项目，算法采取了6个步骤。如果Soda出现在位置7，那么算法将采取7个步骤。因此，我们可以说线性搜索将花费n步来寻找第n个位置的元素。换句话说，算法的复杂度是O(n)或n阶。</p><p id="d6bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用C#实现</strong></p><p id="ebc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是线性搜索算法在C#中的实现:</p><pre class="jp jq jr js fd jy jz ka kb aw kc bi"><span id="b816" class="kd ke hi jz b fi kf kg l kh ki">public void LinearSearchProduct()<br/>        {<br/>            string[] cart = new string[] { "Apples", "Eggs", "Bread", <br/>                             "Milk", "Yogurt", "Soda", "Cheese", "Rice", <br/>                             "Beans" };<br/>            string item = "Soda";<br/>            bool found = false;</span><span id="1309" class="kd ke hi jz b fi kj kg l kh ki">            //For loop will go over each element of the array<br/>            for(int i=0; i &lt; cart.Length; i++)<br/>            {<br/>                if(cart[i] == item)<br/>                {<br/>                    found = true;<br/>                    Console.WriteLine("Product found at index: " + i);<br/>                    break;<br/>                }<br/>            }</span><span id="f370" class="kd ke hi jz b fi kj kg l kh ki">            if(found == false)<br/>            {<br/>                Console.WriteLine("Product not found");<br/>            }<br/>        }</span></pre><p id="aef7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">增长分析</strong></p><p id="a0e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，我们只有一个包含九个元素的数组。想象一下，如果数组包含数千个元素。更糟糕的是，想象一下如果我们感兴趣的项在数组的最后一个位置！因为线性搜索算法需要遍历整个数组，所以当我们有大量数据时，它可能不是一个很好的选择。</p><p id="f04e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们在下表中看到的，对于添加到数组中的每个新元素，线性搜索将需要一个额外的步骤来查找一个项目，其增长复杂度为O(n):</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/d2d2c4f1e0698e1034cff0c1814ef3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6ZxiV0eTTK-lncS9wNfYQ.png"/></div></div></figure><p id="f512" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">二分搜索法</strong></p><p id="3594" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">二分搜索法算法比线性搜索快得多。唯一需要注意的是，二分搜索法希望我们的数组中的数据是有序的。换句话说，二分搜索法算法作用于<em class="kl">有序数组。一旦我们理解了算法的工作原理，这将变得更有意义。</em></p><p id="da37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该算法通过每步消除或忽略数组中的一半元素来工作，直到我们找到所需的元素。</p><p id="18a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，它从查看数组的<em class="kl">中间元素</em>开始。如果要搜索的项目等于中间的元素，我们得到我们的结果。</p><p id="cfe6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">否则，它检查要搜索的项目是小于还是大于中间元素。</p><p id="a512" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果该项小于中间的元素，那么它考虑数组的前半部分用于下一步，而忽略后半部分。</p><p id="2ab1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果该项大于中间的元素，那么它考虑数组的后半部分，忽略前半部分。</p><p id="c297" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论选择哪一半，它都会通过检查中间的元素并将其与要搜索的项目进行比较，再次重复上述所有步骤。</p><p id="3ab5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们这样做，直到我们得到想要的元素。</p><p id="da20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们回到我们的例子来直观地看看它是如何工作的:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/3f584c9200f86617e9fe873b8c1ba96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x4DMIRlZavKr5Eka"/></div></div></figure><p id="20ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们希望在上面的数组中搜索“Soda”项。</p><p id="a608" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kl">第一步是按照自然顺序对这个数组</em>进行排序(如果是字符串，按升序或字母顺序)。所以下面是我们的输入数组。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/4d59506c614f1dfa89c67afdf0db5f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kHECeUxquHDXFoYM"/></div></div></figure><p id="3f50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第一步:</strong>找到上面数组的中间元素。如果数组的长度是n，那么如果n是偶数，中间的元素将是n/2，如果n是奇数，中间的元素将是(n+1)/2。</p><p id="aa3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，数组的长度是9。所以我们的中间元素应该在位置(9+1)/2 = 5。(这将是索引4，因为数组从索引0开始)</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/b69fa3469b4ba92980ceca979c732023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AUClCYh1U4y1WcN-"/></div></div></figure><p id="4cc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">中间元素是不是=“苏打”？没有。</p><p id="fab4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“苏打”是小于还是大于中元素？大于(按字母顺序，苏打水在鸡蛋之后)</p><p id="753e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤2: </strong>选择数组的后半部分，找到新的中间元素:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/c0a4ae38f209684d26beaa2c027d7a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*Bik2Z70OrG3BQjL2"/></div></figure><p id="ec79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个新数组的长度是4，所以中间的元素应该在第二个位置(4/2)——这里是索引6</p><p id="74fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">中间元素是不是=“苏打”？没有。</p><p id="a3de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“苏打”是小于还是大于中元素？大于(按字母顺序，汽水排在米饭之后)</p><p id="ac15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤3: </strong>选择数组的后半部分，找到新的中间元素:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/5a881fea926ec034087e9240fc7e4441.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/0*zNqL8sOQbU5tXezb"/></div></figure><p id="5154" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个新数组的长度是2，所以中间的元素应该在第一个位置(2/2)——这里是索引7。</p><p id="ecfc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">中间元素是不是=“苏打”？是啊！返回元素。</p><p id="cbd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们可以看到，二分搜索法算法只用了3个步骤就找到了想要的商品。</p><p id="587c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">增长分析</strong></p><p id="7b65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">需要注意的一点是，每走一步，我们要研究的元素数量就会减少一半。让我们从另一个角度来看这个问题，也就是说，二分搜索法会为多少新的元素采取额外的步骤？</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/eed7ff3bb38b0345940e376df7d13b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*bkMU9P_vPtGlufAs2Q27MQ.png"/></div></figure><p id="f398" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们可以看到，每当数组中的元素增加一倍时，二分搜索法就会多走一步来查找该项。这就是二分搜索法时间复杂度的增长。由于这种增长可以用对数表示，所以二分搜索法的复杂度是O(logn)或log(n)的阶。</p><p id="e763" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">实施</strong></p><p id="7b93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">二分搜索法在C#中的实现如下:</p><pre class="jp jq jr js fd jy jz ka kb aw kc bi"><span id="ba60" class="kd ke hi jz b fi kf kg l kh ki">public void BinarySearchProduct()<br/>        {<br/>            string[] cart = new string[] { "Apples", "Eggs",      "Bread", <br/>                            "Milk", "Yogurt", "Soda", "Cheese", "Rice", <br/>                             "Beans" };<br/>            string item = "Soda";<br/>            bool found = false;</span><span id="70f0" class="kd ke hi jz b fi kj kg l kh ki">            //we need to sort cart to implement binary search<br/>            Array.Sort(cart);</span><span id="9567" class="kd ke hi jz b fi kj kg l kh ki">            int start = 0;<br/>            int end = cart.Length - 1;</span><span id="6a51" class="kd ke hi jz b fi kj kg l kh ki">            while(start &lt;= end)<br/>            {<br/>                int len = end - start + 1;<br/>                int mid = start + (len / 2);</span><span id="0f98" class="kd ke hi jz b fi kj kg l kh ki">                if (item == cart[mid])<br/>                {<br/>                    Console.WriteLine("Element found at index: " + mid);<br/>                    found = true;<br/>                    break;<br/>                }<br/>                else if (item.CompareTo(cart[mid]) &gt; 0)<br/>                {<br/>                    start = mid + 1;<br/>                }<br/>                else<br/>                {<br/>                    end = mid - 1;<br/>                }<br/>            }</span><span id="9575" class="kd ke hi jz b fi kj kg l kh ki">            if(found == false)<br/>            {<br/>                Console.WriteLine("Element not found in array");<br/>            }</span></pre><p id="9cc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">总结</strong></p><ol class=""><li id="0143" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz bi translated">线性搜索遍历整个数组，一次一个元素，直到找到所需的项</li><li id="5d52" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">线性搜索的时间复杂度为O(n)</li><li id="4924" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">二分搜索法处理一个排序的数组</li><li id="9197" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">二分搜索法每走一步就消除一半的元素，从而加快搜索速度。</li><li id="6617" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">二分搜索法的时间复杂度为O(logn)</li></ol><p id="eff7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">【https://www.pexels.com/@pixabay】特征图片来源:<a class="ae lf" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank"><em class="kl"/></a></p></div></div>    
</body>
</html>