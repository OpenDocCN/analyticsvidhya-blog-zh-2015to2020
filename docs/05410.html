<html>
<head>
<title>Client rate limiter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">客户费率限制器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/async-python-client-rate-limiter-911d7982526b?source=collection_archive---------3-----------------------#2020-04-20">https://medium.com/analytics-vidhya/async-python-client-rate-limiter-911d7982526b?source=collection_archive---------3-----------------------#2020-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ae43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用基于队列的<strong class="ih hj">令牌桶算法</strong>实现异步python客户端速率限制器</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c2f8d91e5842e02509241ceb0d624854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGEpCVkc8bDXi4Mr1vpdQQ.png"/></div></div></figure><p id="c47c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们为什么要限制我们的优秀软件每秒发出大量的请求呢？</p><p id="340f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，有时候我们别无选择。<br/>大多数可用的数据提供商不能不对他们的客户通过他们的API消费的数量和速率加以限制。<br/>对服务使用进行限制不仅有助于控制资源分配，最终转化为花费的金钱，<br/>而且也是应对DDoS攻击的工具。</p><p id="1963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，我们知道数据提供商需要设置费率限制，但是我们为什么要这样做呢？我们如何做到这一点？</p><p id="6939" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回答为什么很简单，<strong class="ih hj">我们只需要以某种方式处理它！</strong></p><p id="5ab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如何做的问题有多种答案。<br/>我们将通过实现其中一个解决方案来回答这个问题，<br/>它被称为<strong class="ih hj">令牌桶。</strong></p><h1 id="8f0b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">令牌桶算法</strong></h1><h2 id="6cc6" class="kn jq hi bd jr ko kp kq jv kr ks kt jz iq ku kv kd iu kw kx kh iy ky kz kl la bi translated"><strong class="ak">第一，最初的想法！</strong></h2><p id="72d2" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">想象一个可以容纳n个代币的桶。<br/>新令牌以恒定速率添加到桶中。<br/>就在发送请求之前，必须从桶中取出令牌。<br/>在桶为空的情况下，请求需要等待，直到新的令牌被添加到桶中并且可以被取出。<br/>如果桶已满，不再添加代币，直到取出代币</p><h2 id="d418" class="kn jq hi bd jr ko kp kq jv kr ks kt jz iq ku kv kd iu kw kx kh iy ky kz kl la bi translated">我们要做的恰恰相反！</h2><p id="e3f5" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">试图发送请求的一方必须首先向桶中添加一个令牌(像缴税一样)，同时以恒定的速率从桶中取出一个令牌。<br/>在这种情况下，当桶已满时，请求需要等待，直到可以添加新令牌，当桶为空时，不取出令牌(dah！！！)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lg"><img src="../Images/1132a0fbb4344c2274e4a44eaaafaf7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*5rR7bfGyxbDziX_-Z8klYQ.png"/></div></figure><p id="843c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来制定计划。我们需要一个队列来保存在任何给定时间允许的请求的令牌总量。令牌的最大数量是速率限制。如果我们想要创建一个请求，我们首先尝试向队列中添加一个令牌。如果队列已满，我们阻塞请求，直到队列中有一个空闲位置。在添加令牌时，我们需要一个以恒定速率消耗令牌并从队列中释放插槽的任务，这将确保我们永远不会超过允许的速率。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lh"><img src="../Images/98f72315643ec3481195652910ae9736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*r5yKK7X8WBtzOsK0ko1X1Q.png"/></div></figure><p id="3cfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在让我们实施吧！</strong></p><p id="c7da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们根据计划为一个<strong class="ih hj"> RateLimiter </strong>类建立一个框架</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="0d9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用一个<strong class="ih hj"> rate_limit </strong>参数初始化该类，该参数是每秒的<strong class="ih hj">个请求</strong>或<strong class="ih hj">个RPS </strong>简而言之，<br/>个<strong class="ih hj">令牌_队列</strong>队列，最大大小为<strong class="ih hj"> rate_limit、</strong> <br/>和<strong class="ih hj">令牌_consumer_task </strong>，以相当恒定的速率消耗队列中的令牌。</p><p id="1c5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们需要实现两个函数，即<br/> add_token和consume _ token</strong></p><h2 id="9016" class="kn jq hi bd jr ko kp kq jv kr ks kt jz iq ku kv kd iu kw kx kh iy ky kz kl la bi translated"><strong class="ak">添加_令牌</strong></h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="bcd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">add_token 相当简单，因为这里所有的繁重工作都由asyncio完成。队列  <strong class="ih hj">的</strong> put函数:</p><blockquote class="ll lm ln"><p id="b2f5" class="if ig lo ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">将一个项目放入队列。如果队列已满，请等到有空闲位置时再添加项目。</p></blockquote><p id="548e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们将<strong class="ih hj"> 1 </strong>放入<strong class="ih hj"> tokens_queue，</strong>如果队列已满，它将阻塞请求，直到队列中的令牌用完。</p><h2 id="6b07" class="kn jq hi bd jr ko kp kq jv kr ks kt jz iq ku kv kd iu kw kx kh iy ky kz kl la bi translated"><strong class="ak">消费_代币</strong></h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="fea3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这就是全部逻辑所在！</strong></p><p id="cc51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先设置一个<strong class="ih hj">消耗_速率</strong>为<strong class="ih hj">1/速率_限制</strong>。</p><p id="1097" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lo">例如，如果我们有一个</em><strong class="ih hj"><em class="lo">rate _ limit</em></strong><strong class="ih hj"><em class="lo">每秒100个</em> </strong> <em class="lo">请求，<br/>它的意思是速率是</em><strong class="ih hj"><em class="lo"/></strong><em class="lo">请求每秒0.01个</em><strong class="ih hj"><em class="lo"/></strong><em class="lo"/>T74】</p><p id="94a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们开始一个无限循环，不断消耗队列中的令牌并释放队列中的槽。</p><p id="986f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果队列是空的，我们除了休眠<strong class="ih hj"> consumption_rate </strong>秒(或几分之一秒)并再次尝试之外什么也不做。</p><p id="2951" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们只需要确保以恒定的速度进行。问题是我们无法控制协程的调度。因此，我们需要做的是找出自上次迭代以来已经过了多长时间，并将其转化为我们需要消耗的令牌数。</p><p id="8697" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们实现函数<strong class="ih hj">get _ tokens _ amount _ to _ consume</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="4d5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">time _ from _ last _ consumption</strong>是迭代之间的时间。<br/><strong class="ih hj">calculated _ tokens _ to _ consumption</strong>基本上是找出如果汇率是<strong class="ih hj"> consumption_rate，到目前为止应该消费了多少代币。<br/> </strong>我们需要“<em class="lo"> floor </em>”这个值，因为我们不能从队列中消耗3.5个代币。<br/>最后，<strong class="ih hj">token _ to _ consume</strong>是<strong class="ih hj">total _ token</strong>和<strong class="ih hj">token _ to _ consume</strong>之间的最小值，因为我们不能消耗比队列中更多的令牌。</p><p id="4458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lo">例如，如果</em><strong class="ih hj"><em class="lo"/></strong><em class="lo">的消耗率上限是</em><strong class="ih hj"><em class="lo">20 RPS</em></strong><em class="lo">那么</em> <strong class="ih hj"> <em class="lo">消耗率</em> </strong> <em class="lo">就是</em> <strong class="ih hj"> <em class="lo"> 0.05。</em> </strong> <em class="lo"> <br/>现在让我们说</em><strong class="ih hj"><em class="lo"/></strong><em class="lo">距离我们上次消耗代币已经过去了0.2秒。我们现在最多需要消耗</em> <strong class="ih hj"> <em class="lo"> 4个代币来弥补。<br/> 0.2/0.05 = 4表示0.05的多少个单位构成一个0.2。<br/> </em> </strong> <em class="lo">但是姑且说只有</em> <strong class="ih hj"> <em class="lo"> 3 </em> </strong> <em class="lo">令牌被放入队列的那段时间，<br/>那么本例中的</em> <strong class="ih hj"> <em class="lo">令牌_to_consume </em> </strong> <em class="lo">就是</em> <strong class="ih hj"> <em class="lo"> 3 </em> </strong></p><p id="1b6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好，现在我们可以一次消费一个或多个代币。我们同步进行，因为这是我们跟上步伐的机会。我们知道事件循环调度不考虑我们的速率。</p><p id="0170" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们实际上已经完成了速率限制的实施。但是还有一个我们没有谈到的问题需要处理。</p><h1 id="1594" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">并发限制</strong></h1><p id="e5fd" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">有时，数据提供者还会限制一个客户端可以并发发送的请求数量。这是我们创造的限速器无法解决的问题。</p><p id="1872" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lo">为了论证速率限制器不充分的原因，<br/>我们假设有一个</em> <strong class="ih hj"> <em class="lo">速率限制</em></strong><em class="lo"/><strong class="ih hj"><em class="lo">20 RPS</em></strong><em class="lo"/><strong class="ih hj"><em class="lo">并发限制</em></strong><em class="lo"/><strong class="ih hj"><em class="lo">10</em></strong><em class="lo"><br/>我们可以误、 同时启动</em> <strong class="ih hj"> <em class="lo"> 20个请求</em> </strong> <em class="lo">，我们的速率限制器将允许这样的请求突发，因为它在允许的限制范围内，但是我们将被服务拒绝，因为我们超过了允许的并发连接数。 <br/>另一个问题出现了，并发限制器还不够充分吗？<br/>嗯，没有！假设我们的并发限制是一次1个请求，<br/>服务速率限制是每秒2个请求，一个请求需要0.25秒才能完成，那么我们可能每秒发送4个请求</em></p><p id="c38d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，asyncio给了我们一个工具来处理这个问题，它叫做<a class="ae lk" href="https://docs.python.org/3/library/asyncio-sync.html#semaphore" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">信号量</strong> </a> <strong class="ih hj">！<br/> </strong>信号量其实是一个古老的同步概念。<br/>它限制了在任何给定时间可以访问共享资源的进程的数量，所以它也是一种限制，但对于进程的并发性来说。</p><p id="b227" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们升级我们的限速器吧。 <br/>我们将用一个额外的参数<strong class="ih hj"> concurrency_limit </strong>初始化这个类，并创建一个<strong class="ih hj">信号量。<br/> </strong>我们还将创建一个名为<strong class="ih hj"> throttle </strong>的函数，用户可以使用它来限制并发性和速率。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><h2 id="2017" class="kn jq hi bd jr ko kp kq jv kr ks kt jz iq ku kv kd iu kw kx kh iy ky kz kl la bi translated"><strong class="ak">油门</strong></h2><p id="4018" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">在实施throttle之前，我们需要了解我们需要做什么来以安全的方式实施限制。<br/>流程应按以下顺序进行:</p><ol class=""><li id="e210" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">获取信号量</li><li id="2c52" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">向速率限制器队列添加令牌</li><li id="0580" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">发送一个请求(或任何其他我们想要控制其速率的异步操作)</li><li id="84e6" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">释放信号量</li></ol><p id="37ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们需要以某种方式确保在阶段<strong class="ih hj"> 3 </strong>执行完毕后释放信号量。我们不介意在那个阶段运行什么，我们只需要某种方式在我们的上下文中运行它。<br/>幸运的是，我们可以用<a class="ae lk" href="https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager" rel="noopener ugc nofollow" target="_blank">异步生成器上下文管理器</a>来实现</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="84db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在生成令牌之前，我们将尝试获取信号量。<br/>如果超过<strong class="ih hj">个concurrency_limit </strong>个协程正在尝试添加令牌，那么我们会一直阻塞，直到一个完成为止，<br/>记住，生成令牌也可能会阻塞。</p><p id="4d7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">太好了，我们完成了！</strong> <br/>我们仍然需要做一些成人软件的事情，比如<br/>清理和安全游戏。<br/>我们还可以添加一个上下文管理器，这是一个很好的实践。<br/>但由于这不是重点，我们将直接跳到完整的代码。让我们把所有的东西都加起来，然后结束这堂课</p><h2 id="b211" class="kn jq hi bd jr ko kp kq jv kr ks kt jz iq ku kv kd iu kw kx kh iy ky kz kl la bi translated"><strong class="ak">速率限制器</strong></h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="1968" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">用例</h1><p id="f7ad" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">让我们看看如何使用它</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="a35b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">笔记</h1><h2 id="436d" class="kn jq hi bd jr ko kp kq jv kr ks kt jz iq ku kv kd iu kw kx kh iy ky kz kl la bi translated">这个类不是线程安全的！T15】</h2><p id="105b" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">它只能在“异步世界”中使用。<br/>因为它意味着在多个协程中被用作共享资源，所以它在多线程/多进程领域中实际上是无用的。</p><h2 id="684c" class="kn jq hi bd jr ko kp kq jv kr ks kt jz iq ku kv kd iu kw kx kh iy ky kz kl la bi translated"><strong class="ak"> <em class="mg">还有其他方案</em> </strong></h2><p id="702d" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">队列基础令牌桶很棒！但是也有其他的解决方案。<br/>还有<strong class="ih hj">滑动窗口日志</strong>、<strong class="ih hj">滑动窗口计数器</strong>、<strong class="ih hj">漏桶</strong>、<strong class="ih hj">等</strong>……<br/>还有<strong class="ih hj"> HTTP协议</strong>方式，它响应状态码为<strong class="ih hj"> 429、</strong>的响应，这表明您已经超过了速率限制，等待一个名为<code class="du mh mi mj mk b"><strong class="ih hj">Retry-After</strong></code>的头中给定的时间间隔，然后重新发送请求。<br/>关于<strong class="ih hj"> 429 </strong>状态码的事情是，并不是所有的API都足够好来使用HTTP约定，并使用头<code class="du mh mi mj mk b"><strong class="ih hj">Retry-After</strong></code>(如果有的话)来让你知道在重新发送之前应该等待多长时间。<br/>即使API运行良好，<code class="du mh mi mj mk b"><strong class="ih hj">Retry-After</strong></code>值也可能是日期、秒、毫秒……所以你必须逐个实现重试机制。同样，如果你不知道要等多长时间，你只需要等一段固定的时间，这是非常低效的。<br/>速率限制器为速率限制提供了一个很好的抽象，你所需要做的就是从服务的API文档或实验中获得限制以获得估计值，但是你永远无法预测外部服务行为，所以你至少应该捕捉一个<strong class="ih hj"> 429 </strong>错误并重试</p><h2 id="b468" class="kn jq hi bd jr ko kp kq jv kr ks kt jz iq ku kv kd iu kw kx kh iy ky kz kl la bi translated">服务器速率限制器</h2><p id="fcb7" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">服务器实现比客户端实现更加细致和复杂。<br/>例如，当试图限制请求以防止DDoS攻击时，<br/>服务可能希望过滤掉攻击者，让真正的用户仍然可以访问。此外，在分布式系统中，解决方案从来没有那么简单。</p><h2 id="0966" class="kn jq hi bd jr ko kp kq jv kr ks kt jz iq ku kv kd iu kw kx kh iy ky kz kl la bi translated">AioHTTP</h2><p id="ebcc" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">aiohttp是一个非常好的值得推荐的异步HTTP python库。<br/>它在内部管理一个连接池，你可以利用它来获益。<br/>可以通过设置连接池的大小来控制并发连接数，甚至可以做到每台主机一个，酷吧？</p></div></div>    
</body>
</html>