# A*算法:如何求两点间的最短路径？

> 原文：<https://medium.com/analytics-vidhya/a-algorithm-how-to-find-the-shortest-path-between-two-points-767c8a76376?source=collection_archive---------4----------------------->

![](img/22a4f7858ace521d3b13b8822eef38cc.png)

你知道机器人或 NPC(非玩家角色)如何在最短的时间内找到他们的目标，即使有很多障碍？

你会解基本算法吗？你认为你能解决在障碍中找到到达目标的最短路径的问题吗？如果你像大多数土耳其高中的学生一样，你可能做不到！一个很好的方法是找一个知道如何做并且喜欢教你这个解决方案的人，或者按照这个指导单元文档来做。

寻找从源到目标的最短路径，我们将使用 **A *算法**(发音为星号)来帮助任何学生完成复杂的算法。你也将有关于人工智能的基本信息，以及这样的系统是如何工作的。在计算机程序设计领域，A*由于其良好的性能和工作精度而得到了广泛的应用。虽然，在实际的旅行路线系统中，在某些情况下，算法的性能通常优于算法，但是，许多人发现 A*优于其他方法。本单元将指导你按照 A*的步骤，找到两点之间的最短路径。

在这一单元，你将更好地理解找到你的目标需要什么样的过程，如何计算和使用所需的变量。最后，你会到达目标而不感到疲倦。

无论您对哪种编程语言感兴趣，您都会发现这个教学单元非常有用，因为它以文本格式详细解释了算法。对于使用任何编程语言的人来说，在阅读并应用这个步骤后，他们可以使用这个算法，并使他们的字符天才！

![](img/223d4f3536c611674622a1cb51b5f1e7.png)

所以，让我们找到最短的路径，就像我们在晚上睡觉时找到冰箱并打开它的门一样。开始吧！

**猫会找到自己的路**

假设我们有一张大桌子，一只叫 Pakize 的猫想要得到骨头。在现实世界中，你可能会想“为什么猫想要骨头？”。在我们的游戏中，我们的 Pakize 有点精明，想把骨头藏起来，这样狗就找不到了，然后就走了。

我们随机放置了一些骨头。她会找到通往骨头的最短路径。

![](img/d7d5f48a0d3ef87450b0f0ff2e6eac9d.png)

不幸的是，Pakize 无法从她目前的位置直接进入骨头，因为有一个障碍挡住了她，显然，她不是一个幽灵！J

帕克兹就像加菲猫一样，她懒到绕着桌子跑来跑去找骨头，她寻找找到骨头的最短路径。

让我们想想，我们如何为她写一个算法，找到她想要的最短路径。

**创建搜索区域**

寻路的第一步是生成一个区域，把它分成在我们的游戏中容易管理的东西。最好的方法是想想我们的游戏。有一只猫，她想得到骨头，所以，瓷砖(正方形)适合我们的游戏。我们也可以准备长方形或其他类似的形状；然而，方形是最适合我们游戏的。

现在我们可以划分搜索区域了。我们的搜索区域可以用一个二维数组来表示。所以，假设关卡是一张 40*40 的地图，我们的搜索区域将是一个 1600 个正方形的数组。让我们看一张准备好的简单例子的图片，总共有 7x6 个瓷砖= 42 个瓷砖，把我们的猫放在某个地方。

![](img/429f3fdd1cc118d758109c2927ee692f.png)

**开放和封闭列表**

好了，我们已经创建了一个搜索区域，让我们来详细看看 **A*算法**以及它是如何工作的。

顺便问一下，我们告诉过你我们的猫记性不好吗？如果我们没有，让我们记住它，因为我们的小猫需要记住两个列表:

> 我们检查的方块找到最近的路径**(开放列表)**
> 
> 我们已经决定的名单，不会再改变**(封闭名单)**

Pakize 将从添加那个瞬间起始点开始，我们称之为“A”到封闭列表中。然后，她将在当前位置周围添加 8 个显然是她的**邻居**的方块到开放列表中。这里有一个猫结束后的样子的例子(绿色代表开放列表):— — — —

![](img/3e31fb5e9f2da82bdb100d61d70345dd.png)

现在 Pakize 必须确定这些选项中哪一个是最短的路，她该如何选择？

在 **A *路径算法**中进行一些计算，这是通过给每个图块一个点来完成的，这被称为路径分数。看看效果如何！

**平铺计分**

我们将计算每个方块的得分 **G、H 和 F** ，其中:

> **G** 是从起点 A 到当前方块的移动成本。因此，对于起点 A 的正方形邻居，这将是 1，但随着我们远离起始瓦片，这将增加。
> 
> **H** 是从当前方块到目标点的启发式估计移动成本(我们将此图块命名为 B)。我们必须记住这只是一个估计。
> 
> **F** 等于 **G** + **H.** 当我们在瓷砖之间移动时，我们将检查 **F** 的值。

你可能想知道我们所说的“运动成本”是什么意思。如果我们简单地说，这只是引导我们到达 B 点的瓷砖数量，B 点就是我们的目标。

**多谈谈 G**

我们讨论了 G，它是从起点 A 到当前方块的移动成本(在这个游戏中以瓷砖的数量表示)。

要计算 G，我们需要取父代的 G(我们来自的帧)并加 1。因此，每个图块的 G 将表示从起始路径，即从点 A 到当前方块的总成本。

例如，此示例显示了两种转到两个单幅图块的方法:每个单幅图块中的 g 点都列在单幅图块中:

![](img/ed25addade0b6a4838b89671785eec97.png)

**多说说 H**

请记住，H 是移动到 B 点的估计成本(根据游戏中的牌数)。

移动的估计成本越接近实际成本，最终路线就越准确。如果预测关闭，生成的路径将不是最短的(但很可能很近)。这个话题很复杂，你要跟着这篇文章走。

换句话说，我们将只计算目标点 B 剩余的水平和垂直瓷砖的数量，而不考虑任何障碍。

例如，下图显示了从各种起点和终点对 H 的估计。

![](img/ab34a6077415bda0bc0cd1b3d1a894c9.png)

**遍历 A*算法**

现在，您是计算每个瓷砖价值的专家。让我们看看 A*算法是如何工作的。

Pakize 将通过重复以下步骤找到最短路径:

> 确定邻居，并在计算其分数后将它们全部添加到开放列表中。
> 
> 获得开放列表中得分最低的瓷砖 **F** 。我们把这个正方形叫做 W.
> 把 W 从开放列表中去掉，把 W 加到封闭列表中。
> 
> 对于 W 的可走邻居瓷砖中的每个方块 T:
> o .**如果 T 在闭列表**中:忽略它。
> o. **如果 T 不在开放列表中**:将其添加到开放列表中并计算其分数。
> o. **如果 T 已经在开放列表**中:检查当我们使用当前生成的路径到达那里时 **F** 得分是否较低。如果是，更新它的分数并更新它的父节点。

我知道你对这是如何工作的仍然有点困惑。不要担心，请高兴，我们将通过一个例子，让您可以看到它的工作步骤！

**帕克泽的路径**

让我们玩我们的游戏，带着 Pakize 走在通往骨头的路上。

在下图中，值 **F = G + H** 如下所示:

> **F(方格得分):**左上角
> 
> **G(从 A 到格子的成本):**左下角
> 
> **H(从检查方块到 B 的估计成本):**右下角

此外，箭头显示了去那个方块的可能移动方向。

最后，在每个步骤中，红色方块表示封闭列表，绿色方块表示开放列表。

现在我们很兴奋！

**第一步**

在第一步中，Pakize 确定其起始位置 A 的可行走邻居方块，计算它们的 F 分数，并将它们添加到其开放列表中:

![](img/cc02e75b8c035059ad5a59c71e005fde.png)

您可以看到列出了每个图块的 H 值(两个图块的 H 值为 6，一个图块的 H 值为 4)。我建议数出每段距离的瓦片数，以确保你理解那部分是如何工作的。

**还有，注意 F 值(左上)正好是 G+H(左下和右下)之和。**

**第二步**

在下一步中，Pakize 选择 F 值最低的方块，将该节点添加到封闭列表中，并检索其相邻方块。

![](img/28515069d2da3e88b3a87fef5dad2cc5.png)

所以，你会在这里看到，成本最低的方块是 F 为 4 的方块。它试图将任何相邻的瓷砖添加到这个开放列表中(并计算它们的分数)，但注意到它不能添加 Pakize 所在的瓷砖(因为它已经在封闭列表中)或墙砖(因为它不可用)。

请注意，对于添加到开放列表中的两个新图块，G 值增加 1，因为它们距离起点有 2 个图块。您可能还想计算出距离，以确保您了解每个新瓷砖的 H 值。

**第三步**

同样，我们选择该区域中具有最低 F 值(5)的图块，并继续迭代:

![](img/6f757e808f0a2576906342618d978638.png)

在这种情况下，只有一个可能的图块添加到开放列表中，因为另一个(向上)已经在封闭列表中，两个是块(左和右)。

**第四步**

现在我们有了一个有趣的案例。正如您在前面的图片中看到的，开放列表中有 4 个具有相同 **F = 7** 分数的牌

我们该怎么办！

在这种情况下，我们可以使用多种解决方案，但我们将应用一种最好的解决方案:选择最近添加到开放列表中的图块。那么，继续我们最近的图块:

![](img/211c6a1d1e8dae80559f69010115b686.png)

这一次，两块瓷砖是相邻且可用的，我们像往常一样计算它们的分数。

**第五步**

同样，我们选择分数最低的图块，此处为 7，如果出现混淆，则选择开放列表中添加的最近邻居:

![](img/9a1e4f0282148e0334a675184ca93565.png)

这一次，只有一种可能性被添加到封闭列表中，我们将其标记为红色。我们的猫变得兴奋起来；因为，她就要找到骨头了！

**第六步**

你太棒了！我敢打赌，你可以很容易地找出如下的下一步:

![](img/b39923a918c724ec74db7bf5d1956745.png)

Pakize 就快到了，但这次你可以看到，她遇到了两条相似的最短路径，她可以选择:

![](img/d20142fc98d911da51bc545944b9de03.png)

在我们的游戏中，我们找到了两条不同的最短路径:

> 1–2–3–4–5–6
> 1–2–3–4–5–7

我们选择哪块瓷砖并不重要。

**第七步**

让我们再重复一次该步骤，选择其中一个图块:

![](img/e36df779c761b8e0fbcb408dc28dbfaf.png)

Pakize 选择左边的一个并检查它的邻居，把它们都放在开放列表中。

在每次邻居被添加到开放列表中时，Pakize 应该检查邻居，以便哪一个有骨头。

啊哈，骨头在开放列表里！

**第 8 步**

当我们在开放列表中检测到目标图块时，我们应该将其添加到封闭列表中:

![](img/b664d61053628a385c886c593cfdee36.png)

最后，当我们将骨骼嵌入到封闭列表中时，会将封闭列表中的图块标记为距离目标最近的路径。

![](img/0f15433868b3077d2d119839cab9875d.png)

**一只聪明的猫**

在我们的例子中，我们看到我们的猫找到了最短的路径；然而，她可以选择其他 **F** 变量相同的牌。我开始认为 Pakize 很聪明，因为她能找到最接近骨头的瓷砖！

如果她选择了其他瓷砖，下面是一个例子:

![](img/0575d0eba777185a3c34a9406b1d200d.png)

在这里，我们会遇到一个不同的场景，红色方块不代表最短路径。它们只是代表在某个时候被选为“W”牌的牌。

即使我们找到了骨头，封闭列表中的瓷砖也不符合最佳和最短的方式；然而，如果你沿着这条线走，你最终会到达目标。

总而言之，跟随错误的瓷砖不是一个错误的决定，你会以最短的路径结束，除非你错误地计算了变量，即使这需要更多的时间。

最后一次，让我们检查我们的优秀算法！

> 相邻图块将按以下顺序返回:顶部/左侧/右侧/底部。
> 
> 一个方块将被添加到开放列表中具有相同分数的所有方块之后(因此第一个添加的方块将是 Pakize 第一个选择的方块)。

这里有一个图表:

![](img/464360a33920b138de7bcc1bd06937a9.png)

通过检查最接近最终点的 **F** 变量，从起点到目标点逐步构建最短路径。

**评估**

> *1。* *解释如何计算 G 变量？
> 2。* *解释如何计算 H 变量？
> 3。* *如何计算 F 变量？
> 4。* *你如何确定应该放在开放列表中的瓷砖？
> 5。* *你会如何确定应该放入封闭列表的瓷砖？*