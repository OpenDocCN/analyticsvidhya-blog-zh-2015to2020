<html>
<head>
<title>Sitri = Vault+Pydantic: configuration with clear structure and validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sitri = Vault+Pydantic:具有清晰结构和验证的配置</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/configuring-the-service-using-vault-and-pydantic-ad66bd8dfeac?source=collection_archive---------18-----------------------#2020-12-10">https://medium.com/analytics-vidhya/configuring-the-service-using-vault-and-pydantic-ad66bd8dfeac?source=collection_archive---------18-----------------------#2020-12-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/713ad66260c91a1516e4e6d078db3c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TV17qiY3sKCyCVzbzsmDQ.jpeg"/></div></div></figure><h1 id="a864" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="4b85" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">继续，立即，以防万一</p><p id="d7ab" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在这篇文章中，我将讨论在<a class="ae km" href="https://github.com/LemegetonX/sitri" rel="noopener ugc nofollow" target="_blank"> Sitri </a>的赞助下，使用 Vault (KV 和到目前为止只有第一个版本，即没有版本秘密)和 Pydantic(设置)为您的服务进行配置。</p><p id="ea4b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">因此，假设我们有一个<em class="ks"> superapp </em>服务，在 Vault 中设置了配置，并使用 AppRole 进行身份验证，我们将像这样设置它(我将把访问秘密引擎和秘密本身的策略设置留在幕后，因为这非常简单，本文不涉及这一点):</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="b02c" class="lc ir hi ky b fi ld le l lf lg">Key                        Value<br/>---                        -----<br/>bind_secret_id             true<br/>local_secret_ids           false<br/>policies                   [superapp_service]<br/>secret_id_bound_cidrs      &lt;nil&gt;<br/>secret_id_num_uses         0<br/>secret_id_ttl              0s<br/>token_bound_cidrs          []<br/>token_explicit_max_ttl     0s<br/>token_max_ttl              30m<br/>token_no_default_policy    false<br/>token_num_uses             50<br/>token_period               0s<br/>token_policies             [superapp_service]<br/>token_ttl                  20m<br/>token_type                 default</span></pre><p id="0726" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="ks">注意:</em>自然，如果你有机会，应用进入生产模式，那么<em class="ks"> secret_id_ttl </em>最好不要无限，设置 0 秒。</p><p id="2e4c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="ks"> Superapp </em>需要配置数据库连接，连接到 kafka 和<a class="ae km" href="http://faust.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> faust </a>配置集群工人。</p><p id="f0e1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">最后，我们应该有这样的测试项目结构:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="c406" class="lc ir hi ky b fi ld le l lf lg">super_app<br/>├── config<br/>│ ├── __init__.py<br/>│ ├── provider_config.py<br/>│ ├── faust_settings.py<br/>│ ├── app_settings.py<br/>│ ├── kafka_settings.py<br/>│ └── database_settings.py<br/>├── __init__.py<br/>└── main.py</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="2a4f" class="iq ir hi bd is it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn bi translated">烘焙 Sitri 提供商</h1><p id="e706" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">基本库文档中有一个简单的示例，通过 vault provider 进行配置，但是，它没有涵盖所有功能，如果您的应用程序配置足够简单，它可能会很有用。</p><p id="5a6c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">因此，首先，让我们配置存储库提供程序:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="f84e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在此代码中，我们使用系统提供程序从环境中获取变量，以配置与 vault 的连接，即必须首先导出以下变量:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="33f6" class="lc ir hi ky b fi ld le l lf lg">export SUPERAPP_ENV=dev<br/>export SUPERAPP_APP_NAME=superapp<br/>export SUPERAPP_VAULT_API=<a class="ae km" href="https://your-vault-host.domain" rel="noopener ugc nofollow" target="_blank">https://your-vault-host.domain</a><br/>export SUPERAPP_ROLE_ID=&lt;YOUR_ROLE_ID&gt;<br/>export SUPERAPP_SECRET_ID=&lt;YOUR_SECRET_ID&gt;</span></pre><p id="a87b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">该示例假设针对特定环境的 secrets 的 base <em class="ks"> mount_point </em>将包含应用程序名称和环境名称，这就是我们导出<em class="ks"> SUPERAPP_ENV </em>的原因。稍后我们将在设置类中定义应用程序各个部分的秘密路径，因此我们在<em class="ks">secret _ path</em>vault provider 参数中将其留空。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="153a" class="iq ir hi bd is it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn bi translated">设置类别</h1><h2 id="3adf" class="lc ir hi bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh bi translated">数据库设置—数据库连接</h2><p id="eb5f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">要创建设置类，我们必须使用 VaultKVSettings 作为基类。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="4278" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如您所见，数据库连接的配置数据非常简单。默认情况下，这个类会查看秘密<em class="ks"> superapp/dev/db </em>，正如我们在<em class="ks"> Config </em>类中指定的那样。乍一看，这些是简单的<em class="ks">止痛药。字段</em>，但是它们都有一个额外的参数<em class="ks"> vault_secret_key </em> —当 secret 中的密钥与我们类中的 pydantic 字段的名称(别名)不匹配时就需要这个参数，如果没有指定<em class="ks"> vault_secret_key </em>，提供者将通过字段别名来搜索密钥。</p><p id="6478" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">例如，在我们的<em class="ks"> superapp </em>中，假设<em class="ks"> superapp/dev/db </em> secret 具有“password”和“username”密钥，但是为了方便和简洁，我们希望将后者放在“user”字段中。</p><p id="8832" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">让我们把下面的数据放在上面的秘密里:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="863f" class="lc ir hi ky b fi ld le l lf lg">{<br/>  "host": "testhost",<br/>  "password": "testpassword",<br/>  "port": "1234",<br/>  "username": "testuser"<br/>}</span></pre><p id="a395" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，如果我们运行这段代码，我们将使用我们的<em class="ks"> DBSettings </em>类从 vault 中获取我们的秘密:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h2 id="e394" class="lc ir hi bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh bi translated">KafkaSettings —与经纪人的联系</h2><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="95d2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在这种情况下，让我们假设对于我们服务的不同环境有一个 kafka 实例，因此秘密沿着路径<em class="ks"> superapp/common/kafka </em>存储:</p><p id="d7b5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="ks">注</em>:您也可以在字段级设置<em class="ks"> secret_path </em>或/和<em class="ks"> mount_point </em>，以便提供商从不同的 secret 请求特定值(如果需要)。这里引用了<a class="ae km" href="https://sitri.readthedocs.io/en/latest/advanced_usage.html#vault-settings-configurators" rel="noopener ugc nofollow" target="_blank">文档</a>中关于秘密路径和挂载点优先级的内容:</p><blockquote class="mi mj mk"><p id="a937" class="jo jp ks jq b jr kn jt ju jv ko jx jy ml kp kb kc mm kq kf kg mn kr kj kk kl hb bi translated">秘密路径优先级:<br/> 1。保险库 _ 秘密 _ 路径(字段参数)<br/> 2。默认 _ 秘密 _ 路径(配置类字段)<br/> 3。secret_path(提供者初始化可选参数)</p><p id="8657" class="jo jp ks jq b jr kn jt ju jv ko jx jy ml kp kb kc mm kq kf kg mn kr kj kk kl hb bi translated">挂载点优先级:<br/> 1。vault _ mount _ point(Field arg)<br/>2。默认挂载点(配置类字段)<br/> 3。mount_point(提供者初始化可选参数)</p></blockquote><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="e672" class="lc ir hi ky b fi ld le l lf lg">{<br/>  "auth_data": "{\"password\": \"testpassword\", \"username\": \"testuser\"}",<br/>  "auth_mechanism": "SASL_PLAINTEXT",<br/>  "brokers": "kafka://test"<br/>}</span></pre><p id="9540" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">或者</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="28ba" class="lc ir hi ky b fi ld le l lf lg">{<br/>    "auth_data":<br/>    {<br/>        "password": "testpassword",<br/>        "username": "testuser"<br/>    },<br/>    "brokers": "kafka://test",<br/>    "auth_mechanism": "SASL_PLAINTEXT"<br/>}</span></pre><p id="7915" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="ks">注:</em> <em class="ks"> VaultKVSettings </em>既可以理解 json，也可以理解 Dict 本身。</p><p id="9650" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">因此，这类设置将能够像这样从秘密中收集数据:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="f99b" class="lc ir hi ky b fi ld le l lf lg">{<br/>    "auth_data":<br/>    {<br/>        "password": "testpassword",<br/>        "username": "testuser"<br/>    },<br/>    "brokers": "kafka://test",<br/>    "auth_mechanism": "SASL_PLAINTEXT"<br/>}</span></pre><h2 id="e296" class="lc ir hi bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh bi translated">faustSettings —全局配置 Faust 和单个代理</h2><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="2c77" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">秘密<em class="ks"> superapp/dev/faust </em>:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="8c85" class="lc ir hi ky b fi ld le l lf lg">{<br/>  "agent_concurrency": "5",<br/>  "app_name": "superapp-workers",<br/>  "partitions_count": "10"<br/>}</span></pre><p id="43b1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果我们的秘密如上所述编写，那么各个代理将从默认字段中获取关于其主题中的分区数量和并发性的信息。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="1d9a" class="lc ir hi ky b fi ld le l lf lg">{<br/>  "agents": None,<br/>  "app_name": "superapp-workers",<br/>  "default_concurrency": 5,<br/>  "default_partitions_count": 10<br/>}</span></pre><p id="fbaa" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">然而，在<em class="ks"> AgentConfig </em>模型的帮助下，我们可以为特定代理设置单独的值。例如，如果代理<em class="ks"> X </em>有 5 个分区，并发数为 2，那么我们可以更改我们的秘密，这样关于这个代理的信息就在“代理”字段中。</p><p id="0c61" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">秘密<em class="ks"> superapp/dev/faust </em>:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="6c8c" class="lc ir hi ky b fi ld le l lf lg">{<br/>  "agent_concurrency": "5",<br/>  "agents_specification": {<br/>    "X": {<br/>      "concurrency": "2",<br/>      "partitions": "5"<br/>    }<br/>  },<br/>  "app_name": "superapp-workers",<br/>  "partitions_count": "10"<br/>}</span></pre><p id="a390" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果我们现在初始化设置，除了默认字段之外，我们还将收到特定代理的配置:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="9c8e" class="lc ir hi ky b fi ld le l lf lg">{<br/>    "agents":<br/>    {<br/>        "X":<br/>        {<br/>            "concurrency": 2,<br/>            "partitions": 5<br/>        }<br/>    },<br/>    "app_name": "superapp-workers",<br/>    "default_concurrency": 5,<br/>    "default_partitions_count": 10<br/>}</span></pre><h2 id="65e1" class="lc ir hi bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh bi translated">将设置类合并到单个配置模型中</h2><p id="49d9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了使我们的配置更加方便使用，让我们通过应用<em class="ks"> default_factory </em>将所有的设置类合并到一个模型中:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="b484" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，让我们转到<em class="ks"> main.py </em>文件，测试我们的应用程序的完整配置数据的收集:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="1939" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们得到应用程序配置的输出:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="eca9" class="lc ir hi ky b fi ld le l lf lg">db=DBSettings(user='testuser', password='testpassword', host='testhost', port=1234)<br/> <br/>faust=FaustSettings(app_name='superapp-workers', default_partitions_count=10, default_concurrency=5, agents={'X': AgentConfig(partitions=5, concurrency=2)})<br/> <br/>kafka=KafkaSettings(auth_mechanism='SASL_PLAINTEXT', brokers='kafka://test', auth_data={'password': 'testpassword', 'username': 'testuser'})</span><span id="a385" class="lc ir hi ky b fi mo le l lf lg">{<br/>    "db":<br/>    {<br/>        "host": "testhost",<br/>        "password": "testpassword",<br/>        "port": 1234,<br/>        "user": "testuser"<br/>    },<br/>    "faust":<br/>    {<br/>        "agents":<br/>        {<br/>            "X":<br/>            {<br/>                "concurrency": 2,<br/>                "partitions": 5<br/>            }<br/>        },<br/>        "app_name": "superapp-workers",<br/>        "default_concurrency": 5,<br/>        "default_partitions_count": 10<br/>    },<br/>    "kafka":<br/>    {<br/>        "auth_data":<br/>        {<br/>            "password": "testpassword",<br/>            "username": "testuser"<br/>        },<br/>        "brokers": "kafka://test",<br/>        "auth_mechanism": "SASL_PLAINTEXT"<br/>    }<br/>}</span></pre><p id="b998" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> <em class="ks">幸福、快乐、喜悦！</em> </strong></p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="a9db" class="iq ir hi bd is it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn bi translated">编后记</h1><p id="c09b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如您所见，使用<a class="ae km" href="http://sitri.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> Sitri </a>进行配置非常简单，之后我们会得到一个清晰的配置方案，其中包含值所需的数据类型，即使它们默认存储在 vault 中的字符串中。</p><p id="b3d5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">写下关于库、代码或一般印象的评论。我将很高兴得到任何反馈！</p><p id="9bad" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">附注<a class="ae km" href="https://github.com/Egnod/article_sitri_vault_pydantic" rel="noopener ugc nofollow" target="_blank">我已经将文章中的代码上传到 github </a></p></div></div>    
</body>
</html>