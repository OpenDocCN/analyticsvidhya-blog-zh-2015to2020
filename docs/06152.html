<html>
<head>
<title>Solving a System of Two Differential Equations Numerically in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python数值求解两个微分方程组</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/solving-a-system-of-two-differential-equations-numerically-in-python-d31844d4ea28?source=collection_archive---------1-----------------------#2020-05-13">https://medium.com/analytics-vidhya/solving-a-system-of-two-differential-equations-numerically-in-python-d31844d4ea28?source=collection_archive---------1-----------------------#2020-05-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/017a90fe66d53c303403d6c6a8c6e6e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cHP5QC4qLZtQiAV8"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">米卡·鲍梅斯特在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="iv iw ix"><p id="5c9d" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="hi">这个故事是我之前关于</em> <a class="ae iu" rel="noopener" href="/@hugodegroot/how-to-numerically-solve-a-differential-equation-66d07098553e?source=friends_link&amp;sk=ba31fbec04fbcc780fe600710fb942bb"> <em class="hi">使用python </em> </a> <em class="hi">数值求解微分方程的后续。</em></p></blockquote><h2 id="264c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">模型</h2><p id="f1e5" class="pw-post-body-paragraph iy iz hi jb b jc kv je jf jg kw ji jj ki kx jm jn km ky jq jr kq kz ju jv jw hb bi translated">假设我们有以下一组微分方程:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es la"><img src="../Images/a9af15bf7426c596945df0a6e7894baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*fIBPWCarcvlagaPhrDkQvQ.png"/></div></figure><p id="d86b" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ki jl jm jn km jp jq jr kq jt ju jv jw hb bi translated">y和P可能是同一地区的两个动物种群。因此，一个种群的增长依赖于另一个种群中食肉动物的数量。对于每一次计算，都应该给出初始总体。在第一个模型中，两个初始种群都被设置为20。</p><h2 id="70fc" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">代码</h2><p id="79a5" class="pw-post-body-paragraph iy iz hi jb b jc kv je jf jg kw ji jj ki kx jm jn km ky jq jr kq kz ju jv jw hb bi translated">现在我们已经确定了我们的模型，是时候写一个python程序来计算给定时间段后的种群大小了。</p><p id="ef74" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ki jl jm jn km jp jq jr kq jt ju jv jw hb bi translated">首先，我们需要导入<em class="ja"> Numpy </em>和<em class="ja"> Matplotlib </em>库。然后我们可以设置初始值。我们必须确定近似值的时间步长，开始时Y和P的值。我们还需要一个开始和结束时间来计算我们需要计算的步数。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="888c" class="jx jy hi lg b fi lk ll l lm ln">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="94a4" class="jx jy hi lg b fi lo ll l lm ln">Dt = 0.01               # timestep Delta t<br/>Y_start = 20            # initial Y<br/>P_start = 20            # initial P<br/>t_start = 0             # starttime<br/>t_end = 60              # endtime</span><span id="f684" class="jx jy hi lg b fi lo ll l lm ln">n_steps = int(round((t_end-t_start)/Dt))    # number of timesteps</span></pre><p id="f04d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ki jl jm jn km jp jq jr kq jt ju jv jw hb bi translated">然后我们可以随时创建空数组来存储计算出的值。我们应该用指定的初始值填充元素0。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="348e" class="jx jy hi lg b fi lk ll l lm ln">Y_arr = np.zeros(n_steps + 1)   # create an array of zeros for Y<br/>P_arr = np.zeros(n_steps +1)    # create an array of zeros for P<br/>t_arr = np.zeros(n_steps + 1)   # create an array of zeros for t<br/>t_arr[0] = t_start              # add starttime to array<br/>Y_arr[0] = Y_start              # add initial value of Y to array<br/>P_arr[0] = P_start              # add initial value of P to array</span></pre><p id="ed92" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ki jl jm jn km jp jq jr kq jt ju jv jw hb bi translated">现在是时候为循环创建一个<strong class="jb hj">了，它将迭代每一个时间步长，并根据微分方程计算P、Y和t的下一个值。如果你想尝试不同的微分方程，你可以在这里做。</strong></p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="4369" class="jx jy hi lg b fi lk ll l lm ln"># Euler's method<br/>for i in range (1, n_steps + 1):  <br/>   Y = Y_arr[i-1]<br/>   P = P_arr[i-1]<br/>   t = t_arr[i-1]<br/>   dYdt = -0.4*Y +0.02*P*Y          # calculate the derivative of Y<br/>   dPdt = 0.8*P - 0.01*P*P-0.1*P*Y  # calculate the derivative of Y<br/>   Y_arr[i] = Y + Dt*dYdt  # calc. Y at next timestep,add to array<br/>   P_arr[i] = P + Dt*dPdt  # calc. P at next timestep,add to array<br/>   t_arr[i] = t + Dt       # add new value of t to array</span></pre><p id="3009" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ki jl jm jn km jp jq jr kq jt ju jv jw hb bi translated">最后，我们可以画出P和Y随时间的变化。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="fb1e" class="jx jy hi lg b fi lk ll l lm ln"># plotting the result<br/>fig = plt.figure()                                  # create figure<br/>plt.plot(t_arr, Y_arr, linewidth = 4, label = 'Y')    # plot Y to t <br/>plt.plot(t_arr, P_arr, linewidth = 4, label = 'P')    # plot P to t</span><span id="9f15" class="jx jy hi lg b fi lo ll l lm ln">plt.title('Title', fontsize = 12)    # add some title to your plot<br/>plt.xlabel('t (in seconds)', fontsize = 12)<br/>plt.ylabel('Y(t), P(t)', fontsize = 12)<br/>plt.xticks(fontsize = 12)<br/>plt.yticks(fontsize = 12)<br/>plt.grid(True)                        # show grid<br/>plt.axis([t_start, t_end, 0, 50])     # show axes measures<br/>plt.legend()<br/>plt.show()</span></pre><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/00876827cd6ecbeb706e3c159c46c85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*IDMLyOW26ZehV7jBbMkuyQ.png"/></div></figure><p id="581d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ki jl jm jn km jp jq jr kq jt ju jv jw hb bi translated">如你所见，达到了一个平衡。我们现在已经解决了这个微分方程系统。你可以摆弄这些代码，改变一些变量，看看结果如何变化，或者是否达到了平衡点，或者甚至是一个不同的平衡。你仍然应该确保选择一个合适的<em class="ja"> dt </em>时间步长。</p><h2 id="828d" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">相图</h2><p id="763a" class="pw-post-body-paragraph iy iz hi jb b jc kv je jf jg kw ji jj ki kx jm jn km ky jq jr kq kz ju jv jw hb bi translated">如果我们把Y画在P上，而不是t上，我们会得到一个所谓的相图，这对研究平衡很有用。在这种情况下，它并不令人兴奋，但可以创造一个美丽的形象。在这种情况下，所有三个初始组合都汇聚到一个点。这一个叫做<em class="ja">螺旋下沉</em>。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/3a949cd77fa9ec8e008238172c37cc82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ct9pKSxVYb0i9RX5o9GhQQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">具有图例中初始值的微分方程组的相图</figcaption></figure><p id="e0a6" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ki jl jm jn km jp jq jr kq jt ju jv jw hb bi translated">如果你已经理解了这个代码和支持它的理论，你就有了数值求解任何微分方程系统的基础。</p></div></div>    
</body>
</html>