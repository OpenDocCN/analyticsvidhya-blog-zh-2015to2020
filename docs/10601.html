<html>
<head>
<title>Quad-tree in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity中的四叉树</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/quad-tree-in-unity-794382cd74b4?source=collection_archive---------4-----------------------#2020-10-26">https://medium.com/analytics-vidhya/quad-tree-in-unity-794382cd74b4?source=collection_archive---------4-----------------------#2020-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7a03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将分享如何在unity中创建四叉树。这可以用于各种目的。所以让我们开始吧。</p><h1 id="2267" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">为什么？</h1><p id="e999" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">首先，我想分享一下我为什么要创建这样一棵树。我的目标非常简单:根据基于顶点数据的网格密度划分空间。一旦我知道在一个给定的区域中哪些是更密集的区域，我就可以对它有更多的控制。参考下图，该图显示了如何将特定场景划分为基于四边形的结构:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/572ef39add560e6c5912d718b39413ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4NCmMMr5CUel6iZTRHdh4Q.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">基于顶点的密度四叉树</figcaption></figure><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kw kx l"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">展示实时分区的简单视频</figcaption></figure><h1 id="20fa" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">四叉树结构和类</h1><blockquote class="ky kz la"><p id="e7e8" class="if ig lb ih b ii ij ik il im in io ip lc ir is it ld iv iw ix le iz ja jb jc hb bi translated">四叉树:<strong class="ih hj">四叉树</strong>是一种树形数据结构，其中每个内部节点正好有四个子节点。</p></blockquote><p id="f020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了一个起点，我们知道，如果我们从根节点开始，它将正好包含4个子节点。对于每个子节点，也将有4个子节点。</p><blockquote class="ky kz la"><p id="a073" class="if ig lb ih b ii ij ik il im in io ip lc ir is it ld iv iw ix le iz ja jb jc hb bi translated">我<!-- -->n无限节点？如果每个节点有4个子节点，那么是的，节点结构将是无限的。我们将在后面的章节中研究如何控制这种情况。</p></blockquote><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lf"><img src="../Images/994d3bbef287c4229fb1692b8679d563.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*Qblz83K1H-yRwDMTyMOSrg.png"/></div></figure><p id="957d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">四叉树的伪结构可以像你在图像中看到的一样简单。这就是你创建一个有树枝和树叶的树结构所需要的全部。</p><p id="2a1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更容易理解，我使用了类名“Quad”。让我们看看各种属性:</p><p id="8bb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">界限:</strong>四方形组成的区域。将检查每个点是否位于四边形的边界内。</p><p id="b63d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Children : </strong>如果一个特定四边形中的数据数量溢出，将导致该四边形被细分为更小的部分。如前所述，每个节点在“四叉树结构”中有4个子节点。</p><p id="8109" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> MaxPoints : </strong>这是该节点可以保留的最大数据数量。如果超过，四边形将被细分。</p><p id="f74b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Points : </strong>实际数据或者只是一个简单的计数器来对照MaxPoints进行交叉检查。</p><p id="5b2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这是所有的属性，让我们看看方法:</p><p id="1e4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> CreateQuad : </strong>通过将父对象的边界除以4来创建一个Quad对象或节点。对于您创建的每个象限，CreateQuad方法将根据其自身的特定界限被调用。就像你在下图中看到的，最大的正方形被分成4个小正方形，其中3个是空的。1然后被分成越来越小的四边形。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lg"><img src="../Images/1c3beba32e60fde390a32b9b8e15a407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*VK-tHJZXbE94vk2V8ZGRpQ.png"/></div></figure><p id="06c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">插入:</strong>对每个点调用该方法，检查该点是否位于特定的四边形中。如果该点位于四边形中或四边形的边界内，则数据被添加到特定节点。更详细地说，一旦点被添加到“点”属性，就执行检查“点”的数量是否小于“最大点”。基于该结果，四边形被进一步细分。</p><blockquote class="ky kz la"><p id="8bda" class="if ig lb ih b ii ij ik il im in io ip lc ir is it ld iv iw ix le iz ja jb jc hb bi translated">快速优化:总是首先检查点是否在四边形中，如果不是，执行早期返回。这将节省大量计算。</p></blockquote><p id="67a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Quad : </strong>这是类的构造函数。尽可能简单，如果需要，只需初始化类和属性。</p><p id="0a0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">细分:</strong>这是当“点数”超过“最大点数”计数时直接调用的函数。这将调用“CreateQuad”函数4次，通过将当前四边形的面积/边界细分为4个相等的部分来创建4个不同的四边形。</p><h1 id="1125" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">接下来呢？</h1><p id="3c77" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">一旦我们有了类，我们需要实现并开始填充数据。我们知道我们需要一个根节点。这里的用户可以选择用不同的方式来实现它。用户可以在运行时动态创建多个四叉树，或者标记整个区域并进行四叉树分区。为了使这非常简单，我已经采取了一个三维场景和相同的范围。然后我创建了一个“根节点”并提供了它的边界。</p><p id="1f3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在下图中看到的，我已经标记了根节点，并给出了500x500的边界。从我所拥有的3d数据来看，这是一个巨大的数字，但在这篇文章中，它变得更容易理解:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lh"><img src="../Images/77168f9fcf91428250d333372f6cb7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*5WXnx8xpCVHIUkCCS9bSSw.png"/></div></figure><h1 id="f38f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">整理数据</h1><p id="6820" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于本文，数据是网格。因此，对于场景中的每个顶点，我们将调用根节点的“插入”方法。如果根包含顶点位置，那么它将把该点添加到它的数据中，否则将忽略它(这里动态创建四边形将更有效)。</p><p id="a40e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果点的数量超过，根节点将被细分为4个部分，每个部分都将调用相同的“插入”方法。记住每个四边形都有插入功能！下图将帮助您理解所创建的四边形:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es li"><img src="../Images/633fdcda960a9a20303550719439337e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*RBMNTi42FpWa8R6sMUwvLA.png"/></div></figure><p id="5825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我特意留出了很多空闲空间，这样我们就可以看到，在没有数据或数据较少的地方，四边形的边界更大。这证明，如果数据溢出，那么只有在那时，四边形才会被细分。这里，我保持了每个四边形250个顶点的限制。我们可以清楚地看到，蓝色突出显示的区域有更多的顶点，因此它被进一步细分，而另一个区域有更大的四边形:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lj"><img src="../Images/952a0cd08d0ba25fc8a69cc3b5cad7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLsFRVgRU-nculixSJpckQ.png"/></div></div></figure><blockquote class="ky kz la"><p id="774b" class="if ig lb ih b ii ij ik il im in io ip lc ir is it ld iv iw ix le iz ja jb jc hb bi translated">快速提示:在unity中，rectangle类只接受x和y参数。因此，对于一个3d点，我们只能取2个轴。这里我取了X和Z轴。</p></blockquote><h1 id="939f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="ec30" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">所以这里我们以四叉树数据结构的创建和实现来结束。我们也看到了实现和使用。除了我所讨论的，这可以用在很多地方。理想的地形生成是可以给出的最好的例子，基于玩家的距离，四边形被细分以呈现更高的细节。远离用户的那些将显示较少的数据。</p><p id="111d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这个简化版本能帮助你理解和实现你自己的四叉树结构。</p></div></div>    
</body>
</html>