<html>
<head>
<title>Production-ready chatbot in GCP for less than a dollar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不到一美元就能在GCP生产的聊天机器人</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/production-ready-chatbot-in-gcp-for-less-than-a-dollar-a8349283a09b?source=collection_archive---------25-----------------------#2020-07-09">https://medium.com/analytics-vidhya/production-ready-chatbot-in-gcp-for-less-than-a-dollar-a8349283a09b?source=collection_archive---------25-----------------------#2020-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0dde75c7a234a753ef7ead5ee51f404d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2aR18G62BT9VWojK-RmKvw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">可持续生产就绪部署几乎永远免费？</figcaption></figure><p id="0de6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们都有过这样的经历——有一个关于黑客马拉松、爱好或兼职项目的好主意，并且有尽快开始编码的强烈愿望。现在有多少可能性(Heroku，Glitch和其他)来引导你的应用程序并立即部署它。但正如一些歌手所说:</p><blockquote class="js jt ju"><p id="f337" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><strong class="iw hj">到了最后</strong>，<strong class="iw hj">就是没感觉到</strong>，<strong class="iw hj">不对劲</strong>。</p></blockquote><p id="8328" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有时，在过于复杂的结构和没有安全性的过于简单的解决方案之间找到平衡是一项极具挑战性的任务。我认为现代谷歌云平台生态系统为解决这个问题提供了一个很好的工具集，而没有厂商的束缚(几乎没有)😏当然，我们将使用一些特定的服务，但它们很容易迁移)。</p><p id="7a89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">作为一个应用程序的例子，我将使用聊天机器人应用程序。它是开源的，托管在<a class="ae jz" href="https://github.com/Gaikanomer9/mentor-chatbot" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中。</p><h2 id="0441" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">快速演示</h2><p id="447a" class="pw-post-body-paragraph iu iv hi iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr hb bi translated">有什么比现场演示更好的？<strong class="iw hj">可点播的现场演示！前往聊天机器人的脸书页面<a class="ae jz" href="https://www.facebook.com/Raido-Mentor-Bot-109235004160923" rel="noopener ugc nofollow" target="_blank">并添加几行文字。请注意第一个响应是如何花费一些时间的，之后的响应是平稳而快速的。(当然，如果有人在过去15分钟内使用该应用程序，就没有预热时间了)。</a></strong></p><p id="3151" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里刚刚发生了什么？Facebook Messenger平台将你的消息发送到应用程序页面，并点击聊天机器人后端的webhook。我们应用程序中负责后端的云运行服务用我们的应用程序启动了Docker容器的一个新实例，并处理了请求。</p><h1 id="0cf4" class="la kb hi bd kc lb lc ld kg le lf lg kk lh li lj kn lk ll lm kq ln lo lp kt lq bi translated">架构概述</h1><p id="c5c3" class="pw-post-body-paragraph iu iv hi iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr hb bi translated">让我们来看看GCP的整体应用架构，然后浏览一下部署流程。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/cf656158c080e8196be0b88c26149a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0xaru4HxY_xCH1tBpwz4qw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">App架构(GitHub + GCP +脸书API)</figcaption></figure><h2 id="a088" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">应用架构</h2><p id="66f7" class="pw-post-body-paragraph iu iv hi iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr hb bi translated">机器人本身使用Python框架Flask来处理请求。对于存储，使用NoSQL Firestore，因为它非常适合少量的并发请求，并且没有复杂的关系查询。</p><h2 id="2a84" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">基础设施</h2><p id="a452" class="pw-post-body-paragraph iu iv hi iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr hb bi translated">代码被打包在Docker映像中，Docker映像由云构建服务构建，并被推送到GCP容器注册中心。云运行服务基本上是Kubernetes的轻量级版本。它管理面向世界的服务、自动伸缩、版本控制和SSL密钥轮换。部署到云运行的每个已部署服务都会获得一个启用了HTTPS的服务域名，但是您也可以使用自定义域名并启用SSL加密。</p><p id="d64a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">云运行服务负责处理传入的请求。Docker容器中的应用可以是你需要的任何东西(就语言、库或其他内部依赖而言)。你必须记住的唯一一件事是，Cloud Run中的应用应该是无状态的。要附加卷，您需要使用常见的Kubernetes或其他服务。在这种情况下，使用托管SQL或NoSQL服务可以方便地存储数据。</p><h2 id="4e99" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">部署管道</h2><p id="04ea" class="pw-post-body-paragraph iu iv hi iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr hb bi translated">部署是通过推送到主分支自动触发的。之后，云构建程序获取源代码，构建新的映像，并将其存储在GCR中。后来的云构建在云运行中创建了服务的新版本，并将流量切换到它。您还可以在这里配置一个部分交换机，用于实现逐步部署，并在为每个用户提供服务之前检测异常。</p><h1 id="1b8b" class="la kb hi bd kc lb lc ld kg le lf lg kk lh li lj kn lk ll lm kq ln lo lp kt lq bi translated">怎么用？</h1><p id="32fb" class="pw-post-body-paragraph iu iv hi iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr hb bi translated">在本文中，我们将通过派生chatbot应用程序来完成设置类似解决方案的过程。我们将对其进行分支和清理，以便您可以快速开始，但是如果您需要更复杂的示例，请随时返回原始存储库进行参考。</p><ol class=""><li id="ab36" class="lw lx hi iw b ix iy jb jc jf ly jj lz jn ma jr mb mc md me bi translated">将<a class="ae jz" href="https://github.com/Gaikanomer9/mentor-chatbot" rel="noopener ugc nofollow" target="_blank">库</a>与聊天机器人应用程序分支，因为它包含所有必要的文件。</li><li id="df57" class="lw lx hi iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated">在GCP启用Firestore、云构建和云运行API。</li><li id="385c" class="lw lx hi iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated">在https://console.cloud.google.com/cloud-build GCP创建一个新项目，然后去<a class="ae jz" href="https://console.cloud.google.com/cloud-build" rel="noopener ugc nofollow" target="_blank"/></li><li id="a0b0" class="lw lx hi iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated">连接分叉的存储库。</li><li id="a0d8" class="lw lx hi iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated">为该存储库创建一个新的触发器，并指定以下<strong class="iw hj">替换变量:<br/> </strong> _SERVICE_NAME(用于云运行中的服务名称)<br/> _REGION(用于部署服务的区域)<br/> _IMAGE_NAME(用于存储在GCR的映像名称)</li><li id="f96b" class="lw lx hi iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated">克隆分叉的存储库</li><li id="5f58" class="lw lx hi iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated">进入存储库文件夹，删除特定于聊天机器人的文件:<br/><strong class="iw hj">RM config . py FB . py GCP . py logging _ handler . py skills . JSON</strong></li><li id="81f6" class="lw lx hi iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated">用以下要点替换app.py文件的内容:</li></ol><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="d9b6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们为应用程序的持续交付准备了存储库。现在，当您提交更改并将它们推送到分叉的存储库时，云构建服务将构建和部署新的应用程序。</p><ol class=""><li id="8337" class="lw lx hi iw b ix iy jb jc jf ly jj lz jn ma jr mb mc md me bi translated">提交所有更改，并将其推送到远程分叉存储库。</li><li id="ad82" class="lw lx hi iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated">转到<a class="ae jz" href="https://console.cloud.google.com/run" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/run</a>并检索服务的URL。检查它是否正常工作，我们是否收到“Hello Cloud Run”消息。</li><li id="9c43" class="lw lx hi iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated">前往<a class="ae jz" href="https://console.cloud.google.com/cloud-build" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/cloud-build</a>查看关于构建的信息或出现的任何问题。</li></ol><p id="d303" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们来看看这里最有趣的文件:</p><ul class=""><li id="2475" class="lw lx hi iw b ix iy jb jc jf ly jj lz jn ma jr mm mc md me bi translated"><strong class="iw hj"> cloudbuild.yaml </strong>包含了所有的构建和部署步骤。我们指定用于每个构建步骤的docker映像，并为其提供参数。最后一步是用一个新的Docker映像创建一个新的版本，并完成部署。</li><li id="688d" class="lw lx hi iw b ix mf jb mg jf mh jj mi jn mj jr mm mc md me bi translated"><strong class="iw hj"> Dockerfile </strong>包含关于容器如何被执行的信息。在这个例子中，我们使用gunicorn webserver并为我们的Flask应用程序提供服务。</li></ul><h1 id="b82f" class="la kb hi bd kc lb lc ld kg le lf lg kk lh li lj kn lk ll lm kq ln lo lp kt lq bi translated">账单和费用</h1><p id="dc2c" class="pw-post-body-paragraph iu iv hi iw b ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn kz jp jq jr hb bi translated">除了Secrets Manager之外，本演示中的每个服务都有一个自由层。云运行不是24/7全天候运行，而是仅在需要时启动容器实例。这使我们能够节省大量资源，让我们能够更好地控制应用程序(这不是一个无服务器的功能或类似的解决方案)，并授予自动缩放功能。</p><p id="5d93" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在低负载下运行这个项目的总成本(它是一个简单的聊天机器人，并不总是与用户交互)是秘密管理器服务中2个秘密的成本，每月0.12美元。自由层覆盖了所有其他内容。当然，这只适用于应用程序没有用户激增的情况，但即使在这种情况下，它也可以自动扩大和缩小规模，而无需我们的干预。</p><h1 id="67bc" class="la kb hi bd kc lb lc ld kg le lf lg kk lh li lj kn lk ll lm kq ln lo lp kt lq bi translated">何必呢？</h1><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9ad0e0f86d424ab8a30d06eb92b0f7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vgx3NTbezBZZ1op2bMzrFw.png"/></div></div></figure><p id="4519" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">构建有趣的小型应用程序、附带项目或作为黑客马拉松的参赛作品总是一项棘手的任务。我们可能根本没有设置，应用程序甚至永远不会有与用户沟通的变化。我们可能会有一个极其昂贵的设置，依靠来自GCP或其他提供商的试用资金生活，一旦没有更多的信用额度，该设置就会被关闭。我们也可以将其部署为无服务器应用程序或使用PaaS提供商，但这意味着我们将失去对应用程序的主要控制，如果我们希望在未来进行迁移，这将需要一些时间。</p><p id="b94a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本文中的系统架构试图使小项目在更长的时间内可用，同时使它们更加安全，并为潜在的增长做好准备。</p></div></div>    
</body>
</html>