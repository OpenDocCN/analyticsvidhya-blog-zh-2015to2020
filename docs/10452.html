<html>
<head>
<title>Predicting Alzheimer's disease Using U-Net Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用U-Net算法预测阿尔茨海默病</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-alzeheimers-disease-using-u-net-algorithm-6a6bb7267188?source=collection_archive---------7-----------------------#2020-10-19">https://medium.com/analytics-vidhya/predicting-alzeheimers-disease-using-u-net-algorithm-6a6bb7267188?source=collection_archive---------7-----------------------#2020-10-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="90c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">面向初学者的基本Tensorflow和Keras实现</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/fdab9e0fb5580fca73925ad1d600e701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*qqF_XCwUS8zMR7AZphFZrw.jpeg"/></div></figure><h2 id="ec57" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated"><strong class="ak">什么是老年痴呆症？</strong></h2><p id="6078" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">阿尔茨海默病是一种不可逆的大脑退化，会导致记忆、认知、人格和其他功能的中断，最终导致大脑完全衰竭而死亡。</p><p id="6c6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在世界范围内，至少有5000万人被认为患有阿尔茨海默氏病或其他痴呆症。</p><p id="5de6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">65岁及以上的人中有十分之一患有阿尔茨海默氏痴呆。这是美国第六大死亡原因。阿尔茨海默病会导致整个大脑组织的逐渐丧失。</p><p id="bf41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它会导致整个大脑组织的逐渐丧失。特别是，大脑中被称为<strong class="ih hj">海马体</strong>的区域往往在疾病过程的早期表现出最快的组织损失。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kl"><img src="../Images/84f51c0f8e04ac245918da4a868f0839.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*WfP3FuZSGMxo_J7Vqq1GXA.jpeg"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jn">图1:人脑中海马体的定位</strong></figcaption></figure><p id="7bf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">海马体对于形成新的记忆至关重要，比如一个人午餐吃了什么或者最近的一次谈话。海马体的逐渐萎缩是造成短期记忆丧失的原因，而短期记忆丧失是阿尔茨海默氏症的标志性症状。</p><p id="fa06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如视频所示，为了了解更多关于老年痴呆症如何改变大脑以及海马体的作用:<a class="ae kq" href="https://youtu.be/0GXv3mHs9AU" rel="noopener ugc nofollow" target="_blank">https://youtu.be/0GXv3mHs9AU</a></p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h2 id="0f2f" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated"><strong class="ak">老年痴呆症可以预防吗？</strong></h2><p id="ef59" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">参考专家的解读，很难根据最早的症状来判断一个人是否会被诊断为老年痴呆症。然而，可以使用人工智能算法和复杂的基于传感器的工具进行预测。</p><p id="2a7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">研究人员开发了一种基于人工智能(AI)的计算机算法，可以使用脑磁共振成像(MRI)的组合来准确预测风险和诊断阿尔茨海默病。</p><p id="6ba5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于ML的预测阿尔茨海默氏症的策略是可用作可扩展解决方案的解决方案之一，训练的模型将随着更大人群的数据扩展而增长。</p><p id="9244" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">预测阿尔茨海默病</strong>值得建立基于人工智能的系统和设备，以识别受害者，加快诊断程序，并使其尽早进行必要的治疗。</p><h2 id="45ad" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated"><strong class="ak">使用核磁共振扫描</strong></h2><p id="7540" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">研究人员使用了阿尔茨海默病患者以及大脑神经行为正常者的大脑MRI扫描、人口统计数据和临床信息。然后开发了一种新的深度学习模型来预测阿尔茨海默病风险，这表明他们的模型可以准确预测其他独立队列的疾病状态。</p><p id="81d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发现人工智能算法如何处理数据，并训练模型来预测阿尔茨海默病。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h2 id="84c6" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated"><strong class="ak">使用MRI和U-Net架构检测阿尔茨海默病</strong></h2><p id="a592" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">构建一个基于<strong class="ih hj"> U-net架构</strong>的算法，可以帮助我们检测肺部或脑部的肿瘤。</p><p id="f1b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个项目将帮助你更多地了解U-Net的架构，如何建立你的模型，以便可视化<strong class="ih hj">海马</strong>和使用IRM检测老年痴呆症。</p><p id="a287" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">项目内容如下:</strong></p><ul class=""><li id="24a0" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">数据集准备和预处理</li><li id="e758" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">模型结构</li><li id="e9f6" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">模特培训</li><li id="c846" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">模型评估和测试</li><li id="d56a" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">模型预测法</li></ul><p id="d749" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开始开发模型之前，我们必须学习如何准备和操作数据集。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><ol class=""><li id="d984" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc lm le lf lg bi translated"><strong class="ih hj">数据预处理</strong></li></ol><p id="d251" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据预处理是准备(清理和组织)数据以使其适应构建和训练模型。简而言之，数据预处理是一种数据挖掘技术，它将原始数据转换成可理解和可读的格式。它有助于清理、格式化和组织原始数据，从而为模型做好准备。</p><p id="3ada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个项目中，有四个重要的数据预处理步骤来准备我们的数据。</p><p id="26b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1.1获取数据集</strong></p><p id="bbe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据集可以从<strong class="ih hj"> </strong> <a class="ae kq" href="https://academictorrents.com/" rel="noopener ugc nofollow" target="_blank">学术种子</a>网站下载，可以在这里找到:<a class="ae kq" href="https://academictorrents.com/details/274be65156ed14828fb7b30b82407a2417e1924a" rel="noopener ugc nofollow" target="_blank">https://Academic Torrents . com/details/274 be 65156 ed 14828 FB 7b 30 b 82407 a 2417 e 1924 a</a></p><p id="0092" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个项目中，我们将使用NIfTI(神经影像信息学技术倡议)格式；它可以存储具有不同含义的数据。成像数据、统计值和其他数据(任何矢量、矩阵、标签集或网格)可以保存在nifti1 *中。nii或*。hdr/*。img文件。</p><p id="7253" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">磁共振成像:</strong>磁共振成像是一种使用强磁场和无线电波产生身体内部(大脑、乳房、心脏和血管等)详细图像的扫描。</p><p id="877d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1.2导入库</strong></p><p id="44a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要安装整个需求模块；TensorFlow、Keras、os、matplotlib、NumPy以及其他与项目规范相关的库。</p><p id="61e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，为了读取“nifti”格式，最需要的模块之一是“nibabel”。</p><p id="c000" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击此处阅读更多关于Python数据科学库的信息:<a class="ae kq" href="https://www.upgrad.com/blog/python-libraries-for-data-science/" rel="noopener ugc nofollow" target="_blank">https://www . upgrad . com/blog/Python-libraries-for-Data-Science/</a></p><p id="299b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">1.3</strong>T26】加载并读取数据集</p><p id="d7b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此阶段，我们需要:</p><p id="7ab9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用操作系统模块“os”将图像数据集的路径存储到一个变量中。路径。加入"</p><p id="ae2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导入<strong class="ih hj">' ni label '</strong>并加载dataset(注意:“ni label”不加载图像数组，它一直保持到使用get_fdata()方法请求数据数组为止)。</p><p id="67c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1.4 </strong> <strong class="ih hj">标准化图像</strong></p><p id="6b2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算机视觉中一个关键的预处理步骤。原则上，所采用的模型在较小的图像上训练得更快。当图像更大或更复杂时，所需的时间会增加。此外，许多深度学习模型架构需要相同大小的收集图像，尽管对于所获取的大多数数据来说并非如此。</p><p id="977d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为输入到人工智能算法中的所有图像建立一个基本尺寸，会产生一个最小图像尺寸的数据集。</p><p id="bd3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">最小图像尺寸</strong>设置为<strong class="ih hj"> 32，32，1(宽度、高度和通道)。</strong></p><p id="6e08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用许多其他预处理技术来准备数据图像，以便在模型中进行训练。<strong class="ih hj">从图像中移除背景</strong>颜色可降低噪声。其他项目可能需要使图像变亮或变暗。使用<strong class="ih hj">数据扩充技术</strong>扩大数据集，使其具有现有的扰动版本(缩放、旋转、去色、去纹理等)。简而言之，应用数据集所需的任何调整都被视为一种预处理。此外，根据数据集和解决方案选择适当的处理技术，可以直观地了解在处理不同的项目时需要哪些技术。</p><p id="5bea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1.5 </strong> <strong class="ih hj">分割数据集</strong></p><p id="c7f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一步是将数据集分成两个独立的集合:训练集和测试集。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/e708699b9ac2a0feac843403d10bbca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1bCutJQKJW7W_pXg611CHw.jpeg"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jn">图2:数据集分割</strong></figcaption></figure><p id="3c25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“训练集”用于训练模型，“测试集”用于测试和评估模型。</p><p id="453c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，数据集被拆分为<strong class="ih hj"> 70%训练</strong> <strong class="ih hj">集</strong>和<strong class="ih hj"> 30%测试集</strong>或<strong class="ih hj"> 80%训练集</strong>和<strong class="ih hj"> 20%测试集</strong>。</p><p id="fe96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在代码中，使用sk learn“from sk learn . model _ selection import train _ test _ split”拆分数据</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="3358" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。模型构建</strong></p><p id="f85c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用U-net算法建立模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ls"><img src="../Images/3fa157bffd0f9cf9cd698f8d6e7e0226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcHKz-E45oHAqXc1ovk6QQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jn">图3: U-net架构(最低分辨率下32x32像素的示例)。</strong></figcaption></figure><h2 id="58d3" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">U-Net是如何工作的？</h2><p id="2515" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">它由<strong class="ih hj">收缩路径</strong>(左侧)和<strong class="ih hj">扩张路径</strong>(右侧)组成。</p><p id="1792" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">收缩/缩减采样路径</strong></p><p id="570e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">收缩路径遵循卷积网络的典型架构。它由<strong class="ih hj">四个</strong>挡块组成，每个挡块由:</p><p id="be02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3x3卷积层+激活函数(带批量归一化)</p><p id="c07c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3x3卷积层+激活函数(带批量归一化)</p><p id="bcaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2x2最大池</p><blockquote class="lt lu lv"><p id="a119" class="if ig lw ih b ii ij ik il im in io ip lx ir is it ly iv iw ix lz iz ja jb jc hb bi translated">注意:每个池中的特征映射数量会翻倍，第一个块有64个特征映射，第二个块有128个，依此类推。该收缩路径的目的是捕获输入图像的上下文，以便能够进行分割。这个粗略的上下文信息然后将通过跳过连接被传送到上采样路径。</p></blockquote><p id="beba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">瓶颈</strong></p><p id="40ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网络的这一部分位于收缩路径和扩展路径之间。瓶颈是由简单的两个卷积层(带批量归一化)构成的，带有丢失。</p><p id="6f51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">扩展/上采样路径</strong></p><p id="f0b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">扩展路径也由四个块组成。每个模块都包括:</p><p id="2433" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步长为2的反褶积层</p><p id="e645" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与收缩路径中相应的裁剪后的要素地图串联</p><p id="a860" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3x3卷积层+激活函数(带批量归一化)</p><p id="cae5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3x3卷积层+激活函数(带批量归一化)</p><p id="4ef0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最后一层，使用1x1卷积将每个64分量特征向量映射到所需数量的类别。该网络总共有23个卷积层。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ma"><img src="../Images/d0b2fa4de76c7d3a146ef5f49f1494c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*re0XfNJX4qmE0XDw1NA9ZQ.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mb"><img src="../Images/3ed1174d1854935db6f60d317b98e442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcqmJ9tPqPntuvlBefci0g.png"/></div></div></figure><p id="398c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">红框→代表输入图像尺寸</p><p id="6417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">蓝色方框→代表U形网的左侧(收缩路径)</p><p id="7786" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">绿色方框→代表U-Net的右侧(昂贵路径)</p><p id="0f3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">黄色方框→最终瓶颈层</p><p id="f214" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型构建的最后一步是修复模型中使用的<strong class="ih hj">优化器</strong>和<strong class="ih hj">成本函数</strong>。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="0bea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一阶段可以应用不同类型的优化器:</p><p id="dcfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">成本函数</strong></p><p id="c330" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">机器学习和深度学习的目标是减少预测输出和实际输出之间的差异。这也被称为成本函数或损失函数。</p><p id="bb52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们的目标是通过找到权重的优化值来最小化<strong class="ih hj">成本函数</strong>。</p><p id="c1e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实现这一点，我们使用不同的权重运行多次迭代。这有助于找到最小成本。这是<strong class="ih hj">梯度下降。</strong></p><p id="4405" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">梯度下降是一种迭代机器学习优化算法，以降低成本函数。这将有助于模型做出准确的预测。</p><p id="a9ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们计算梯度，∂c/∂ω，它是成本相对于重量的偏导数。</p><p id="cfca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> α是学习率</strong>，帮助调整梯度下降的权重</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/40de998ce64e5b486aa266374ec6010b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*rOoHDqWLfc8obkCZIE96VQ.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jn">图4:梯度下降</strong></figcaption></figure><p id="ea2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> W </strong>是神经元的权重，<strong class="ih hj"> α </strong>是学习率，<strong class="ih hj"> C </strong>是成本，∂c/∂ω是梯度。</p><p id="2389" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">学习率是多少？</strong></p><p id="79e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">学习率可能是梯度下降和其他优化器最重要的方面。</p><p id="302a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它控制权重相对于损耗梯度应该调整多少。学习率是随机初始化的。</p><p id="4704" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一个目标是最小化<strong class="ih hj">成本函数</strong>，通过使用不同的权重运行多次迭代并计算成本以达到最小成本，从而找到权重的优化值，如下所示。</p><p id="0bb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图解释了优化曲线</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ls"><img src="../Images/91e31388935b213dbffcbf72751920c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFCfUnqt7_YqiOH5erRvQA.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jn">图5:优化曲线</strong></figcaption></figure><p id="3d95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同类型的梯度下降有:</p><p id="b8c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">批量梯度下降或普通梯度下降</p><p id="7a18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随机梯度下降</p><p id="8c3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">小批量梯度下降</p><p id="7feb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想了解更多关于渐变体面的内容，建议关注“吴恩达”制作的视频</p><p id="9056" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">链接:【https://www.youtube.com/playlist? T4】list = pllsst 5 z _ DsK-h 9 vyzkqkynwcitqhlrjln</p><p id="e606" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有<strong class="ih hj">优化器</strong>的目标是改变你的模型的属性，如权重和学习率，以减少损失。</p><p id="4ff3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是也使用基于梯度下降的其他类型的优化器，下面是其中的一些:</p><p id="37d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Adagrad </strong>专门针对单个要素调整学习率:这意味着数据集中的一些权重将具有不同于其他权重的学习率。</p><p id="6bad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> RMSprop: </strong>在RMSprop中，学习率自动调整，并为每个参数选择不同的学习率。</p><p id="ca81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Adam: </strong>是一种随机梯度下降法，它基于梯度一阶和二阶矩估计值中每个参数的自适应学习率。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es md"><img src="../Images/be2f2f0711f499733934bf7d7946026c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Bd5dogd_kqkD4Bw30KKzZg.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jn">图6:各种优化器之间的比较</strong></figcaption></figure><p id="f33b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据上面的比较，“亚当”是一个计算效率相当高的优化器，它需要较少的内存空间。</p><p id="5a1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，使用“Adam”作为最流行的梯度下降优化算法之一具有多种优势，包括易于实现的优化模型。</p><pre class="je jf jg jh fd me mf mg mh aw mi bi"><span id="504c" class="jl jm hi mf b fi mj mk l ml mm">model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])</span></pre><p id="b90a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，有必要按如下方式配置规范:</p><p id="9c45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">丢失:</strong>肺炎检测是在最后一步使用乙状结肠激活，结果不是1就是0(痴呆或非痴呆)。因此，<strong class="ih hj">二元交叉熵</strong>是最合适的损失函数</p><p id="01f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">度量</strong>:精度是获得每个历元预测准确率的度量。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="f7fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。模特培训</strong></p><p id="cbd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步，使用数据逐步提高我们的模型预测该人是否患有痴呆症的能力。</p><pre class="je jf jg jh fd me mf mg mh aw mi bi"><span id="b285" class="jl jm hi mf b fi mj mk l ml mm">#Fit the model<br/>history = model.fit(X_train,<br/>                         y_train,<br/>                         batch_size = 8,<br/>                         epochs = 50,<br/>                         validation_split = 0.2)</span></pre><p id="2a2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">型号列车为<strong class="ih hj"> 50个时代</strong>，批量为<strong class="ih hj">8个</strong>。</p><p id="d637" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">批量大小</strong>是模型更新前处理的样本数(样本是单行数据)。</p><p id="3384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">时期</strong>是通过训练数据集的完整次数。</p><p id="4b8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于两个主要参数:<strong class="ih hj"> Epoch &amp; Batch size </strong>，<strong class="ih hj"> Epoch </strong>是指整个数据集只通过神经网络前后传递一次。困难在于如何在应用中选择合适的历元数，以避免<strong class="ih hj">欠拟合</strong>和<strong class="ih hj">过拟合</strong>的问题。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mn"><img src="../Images/0e42af00ce097767387bdb15f362c2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-wxxHbea4Owi73FtgY6yw.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jn">图7:欠配合&amp;过配合问题</strong></figcaption></figure><blockquote class="lt lu lv"><p id="cd0d" class="if ig lw ih b ii ij ik il im in io ip lx ir is it ly iv iw ix lz iz ja jb jc hb bi translated">注意:不可能一次将整个数据集传递到神经网络中。因此，最好将数据集分成多个批次或集合。</p></blockquote><p id="d72d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦模型被完全训练，损失和准确度图的可视化步骤可以导致关于模型效率的解释。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="da59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。模型评估和测试</strong></p><p id="1634" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练结束后，可以看到验证损失和训练损失，以便对模型进行评估。</p><pre class="je jf jg jh fd me mf mg mh aw mi bi"><span id="e8f5" class="jl jm hi mf b fi mj mk l ml mm"># Accuracy calculation<br/>f, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))<br/>t = f.suptitle('U-NET Performance', fontsize=12)<br/>f.subplots_adjust(top=0.85, wspace=0.3)</span><span id="b942" class="jl jm hi mf b fi mo mk l ml mm">max_epoch = len(history.history['accuracy'])+1<br/>epoch_list = list(range(1,max_epoch))<br/>ax1.plot(epoch_list, history.history['accuracy'], label='Train Accuracy')<br/>ax1.plot(epoch_list, history.history['val_accuracy'], label='Validation Accuracy')<br/>ax1.set_xticks(np.arange(1, max_epoch, 5))<br/>ax1.set_ylabel('Accuracy Value')<br/>ax1.set_xlabel('Epoch')<br/>ax1.set_title('Accuracy')<br/>l1 = ax1.legend(loc="best")</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mp"><img src="../Images/5c2754e6b24be36d42430ed268b46cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*YukhwHa-T89GMJjqPuYvGA.png"/></div></figure><p id="492f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如图所示，<strong class="ih hj">验证损失</strong>和<strong class="ih hj">训练损失</strong>都是同步的。它表明该模型没有过度拟合:验证损失正在减少，并且在整个训练阶段，训练和验证损失之间几乎没有任何差距。</p><p id="5218" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练后的模型准确率达到了<strong class="ih hj"> 95.24 % </strong>，如下图所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mq"><img src="../Images/b91061c3e06622d5abf141c53bd9817b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZ5iNuXSsZejCHbavamW2Q.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jn">图10:精度值</strong></figcaption></figure><p id="5642" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，也是最重要的一点，是时候使用Keras的predict()函数重建测试图像了，看看你的模型在测试数据上的重建效果如何。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mr"><img src="../Images/401c85ddd5df5dcbdc217a80b5634800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2NgcvPmGpGEshToVyl5NA.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ms"><img src="../Images/8dccaa0c1f843d9c85bb6e3004cb4954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hGB-DZ8e8gx2WcgL0IlYA.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jn">图11:掩模图像</strong></figcaption></figure><p id="c5eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的图中，您注意到该模型在重建您使用该模型预测的<strong class="ih hj">掩模图像</strong>方面做得很好。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="3eab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 5。保存模型</strong></p><p id="19f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在使用深度学习模型时，保存训练好的模型是关键的一步</p><pre class="je jf jg jh fd me mf mg mh aw mi bi"><span id="232f" class="jl jm hi mf b fi mj mk l ml mm">#save model<br/>model_save_path = os.path.join(path_main,'model')<br/>tf.saved_model.save(model, model_save_path)</span></pre><p id="646b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以加载保存的重量，然后使用下面的代码行继续训练过程:</p><pre class="je jf jg jh fd me mf mg mh aw mi bi"><span id="9c3a" class="jl jm hi mf b fi mj mk l ml mm">#load model<br/>model = keras.models.load_model(model_save_path)</span></pre><p id="62b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 6。模型预测</strong></p><p id="2bd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这一步骤，分类器将数据集标记为痴呆和非痴呆两个类别。建议使用无监督算法(K均值聚类)来补贴我们的标签。</p><p id="18cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">首先，什么是聚类算法？</strong></p><p id="5cc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">聚类算法是无监督算法，但类似于分类算法，但基础不同。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mt"><img src="../Images/e0b1e5268188ae36d7198852aa4a020b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otvBpcs2Xn5NyBJXbiDPHQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jn">图12:痴呆和非痴呆图像</strong></figcaption></figure></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="0e1b" class="mu jm hi bd jn mv mw mx jr my mz na jv nb nc nd jy ne nf ng kb nh ni nj ke nk bi translated">再进一步！</h1><p id="bd3d" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">本教程可以帮助您了解如何阅读MRI nifti格式的图像，分析，预处理并使用大脑MRI数据集将它们输入模型。它展示了一种流行的CNN算法:U-Net算法。</p><p id="941a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以修改架构并尝试从定量和定性两方面改进预测，可以使用数据扩充技术来增加数据集的大小，还可以选择另一个分类器来将数据集划分为两个类。</p><p id="71e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，您可以自由选择任何架构和任何分类器。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="88de" class="mu jm hi bd jn mv mw mx jr my mz na jv nb nc nd jy ne nf ng kb nh ni nj ke nk bi translated">人工智能如何改变医疗保健的未来</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nl"><img src="../Images/557572a7e619a275bc2958ffa75527dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lplkDh6PsFYUB7bPPo1kPg.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><strong class="bd jn">图13:医疗保健领域的人工智能</strong></figcaption></figure><p id="adc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">医学中的AI是指在需要护理的患者的诊断和治疗中使用人工智能技术/自动化流程。虽然诊断和治疗看似简单，但为了使患者得到适当的护理，还必须进行许多其他的后台处理，例如:</p><p id="1256" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过患者访谈和测试收集数据</p><p id="85f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理和分析结果</p><p id="e47e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">利用多种数据来源做出准确的诊断</p><p id="456e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确定适当的处理方法(通常提供选项)</p><p id="4cc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准备和实施所选择的治疗方法</p><p id="7944" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">病人监护等。</p><p id="0974" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总之，</strong>如今，机器不太可能达到50岁经验丰富的医生的即时咨询，尽管如果我们训练模型中使用的数据集包括每个医生的经验，有一天，一个超级计算器可以告诉并预测街上摄像头扫描到的任何人的任何疾病。这就是人工智能的可扩展性。</p><blockquote class="lt lu lv"><p id="391e" class="if ig lw ih b ii ij ik il im in io ip lx ir is it ly iv iw ix lz iz ja jb jc hb bi translated">比尔·盖茨(1996)<em class="hi">我们总是高估未来两年将发生的变化，低估未来十年</em>将发生的变化</p></blockquote></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="f6e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经尽可能保持文章的准确和清晰。</p><p id="a9bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎您的评论、问题和反馈。</p><p id="090c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">联系我:<a class="ae kq" href="https://github.com/besmaGuesmi" rel="noopener ugc nofollow" target="_blank"> Github </a>，<a class="ae kq" rel="noopener" href="/@bessmagsm"> Medium </a>，<a class="ae kq" href="https://www.linkedin.com/in/besma-guesmi-a94201161/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>，<a class="ae kq" href="https://twitter.com/BesmaGuesmi3" rel="noopener ugc nofollow" target="_blank"> Twitter </a>，<a class="ae kq" href="http://bessmagsm@gmail.com" rel="noopener ugc nofollow" target="_blank"> Gmail </a></p><p id="6431" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这将有所帮助！</p><p id="e0bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下期教程再见！</p></div></div>    
</body>
</html>