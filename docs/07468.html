<html>
<head>
<title>Applying Data Science in Manufacturing: Part III — Continuous Process: Methodology and Lessons Learned</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学在制造业中的应用:第三部分——连续过程:方法和经验教训</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/applying-data-science-in-manufacturing-part-iii-continuous-process-methodology-and-lessons-463021c33b05?source=collection_archive---------18-----------------------#2020-06-26">https://medium.com/analytics-vidhya/applying-data-science-in-manufacturing-part-iii-continuous-process-methodology-and-lessons-463021c33b05?source=collection_archive---------18-----------------------#2020-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0fb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章的第二部分(<a class="ae jd" rel="noopener" href="/@ryandmonson/applying-data-science-in-manufacturing-part-ii-batch-process-methodology-and-lessons-learned-d18d360d8953">https://medium . com/@ ryandmonson/applying-data-science-in-manufacturing-Part-II-batch-process-methodology-and-lessons-learned-d18d 360d 8953</a>)中，创建了几个用于从批量制造过程中预测合金等级的模型。在预测训练目标变量方面，分类建模远比回归建模准确。在文章的最后，记录了事后分析，概述了在使建模结果对批处理制造操作有用方面的经验教训和想法。</p><p id="8c75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三部分将分析一个连续的制造过程。该过程与分批过程的不同之处如下:</p><ul class=""><li id="1663" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">处理是连续的，在处理步骤之间有时间滞后</li><li id="de82" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">与一次测量相比，在加工后对产品进行多次测量</li><li id="81ca" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">处理数据是原始的，而不是标准化的t/z统计数据</li><li id="effe" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">数据集包含14K+行，而批处理总共有大约880行。</li></ul><p id="485a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个连续制造过程的数据集可以在Kaggle上找到，网址是<a class="ae jd" href="https://www.kaggle.com/supergus/multistage-continuousflow-manufacturing-process" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/super gus/multi stage-continuous flow-manufacturing-process</a>。在阅读了数据集注释后，我决定将分析局限于通过第一阶段组合器测量引入的原材料。下游流程步骤的数据列将从数据集中删除。将分析以下工艺流程:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es js"><img src="../Images/48267dc019251865d014e6be094723e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*N7d38tD3S9o5C3SBOV84gg.png"/></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">图1-第三部分连续工艺的平行和连续步骤</figcaption></figure><p id="0d9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种分析中，x变量被称为“特征”，y变量被称为“目标”。所有编码都是Python。</p><p id="dc9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阅读和总结数据集</p><p id="d462" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导入Numpy、Pandas和OS的代码与第二部分相同，唯一的变化是数据集的路径(/ka ggle/input/multi stage-continuous flow-manufacturing-process/continuous _ factory _ process . CSV)。检查数据类型发现日期时间戳是一种对象数据类型。它被转换为datetime数据类型。</p><p id="54a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kaggle上提供了dataframe列中的数据直方图。从这些我们了解到:</p><ul class=""><li id="b320" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">除了日期时间列，所有其他数据类型都是数字</li><li id="b781" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">没有丢失的值</li><li id="361c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">列名很长</li><li id="b14b" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">许多温度特征列几乎没有变化</li></ul><p id="b232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来自阶段1组合器测量下游过程的数据列被丢弃。剩余的列重命名如下:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="99f0" class="kj kk hi kf b fi kl km l kn ko"><em class="kp">#replace these column title words...</em><br/>col_list_old =["Actual","AmbientConditions.","AmbientHumidity","AmbientTemperature","Machine","RawMaterial", "Property", "RawMaterialFeederParameter",          "Zone","Temperature","MotorAmperage","MaterialPressure","ExitZoneTemperature",'FirstStage.CombinerOperation.Temperature','Stage1.Output.Measurement','Stage2.Output.Measurement']</span><span id="dc36" class="kj kk hi kf b fi kq km l kn ko"><em class="kp">#...with these</em><br/>col_list_new = <br/>["Act", "Amb", "_Hum", "_Temp", "Mach", "RM", "Prop", "RM_Feed_Param","Zone", "Temp", "Amps", "Mat_Press", "Exit_Zone_Temp","Stage1_Temp",'Stage1_Measure', 'Stage2_Measure']</span><span id="2ea8" class="kj kk hi kf b fi kq km l kn ko"><em class="kp">#function to modify column names</em><br/>def clean_column_names(df):<br/>    df.columns = df.columns.str.strip() <em class="kp">#strip whitespace</em><br/>    <br/>    <em class="kp"># zip the lists as tuples, then into a dictionary</em><br/>    col_dict = dict(zip(col_list_old, col_list_new)) <br/> <br/>    #<em class="kp">items - list of tuple key/value pairs (old,new)</em>   <br/>    for i, j in col_dict.items(): <br/>        new_columns = [column.replace(i, j) for column in        df.columns] <em class="kp"># replace old with new</em><br/>        df.columns = new_columns<br/>    return df</span><span id="7aa2" class="kj kk hi kf b fi kq km l kn ko">df = clean_column_names(df)</span></pre><p id="ae14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，许多温度特性变化很小(范围为2摄氏度或更小)。不管刻度是摄氏度还是华氏度，这个范围都在制造过程中用来测量温度的热电偶、热敏电阻或红外设备的测量误差范围内。观察色谱柱的最小值和最大值表明，对于许多色谱柱来说，温度可变性只是测量误差。这些列对预测目标值和进行工艺调整没有好处(它们实际上是常数)。它们将从分析中删除。</p><p id="5c0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kaggle直方图表明其他特征具有极低的变异系数。这些列也不利于预测目标值(变化太小),也将被删除。</p><p id="f97e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有人可能会认为这是一个糟糕的统计方法，即标准化或规范化将所有特征放在一个关于大小和变化的“水平竞技场”上。这是真的，并且被删除的特征可能在模型中具有预测能力。但是，当参数“非标准化”并可操作时，操作者能够进行模型建议的微小调整吗？这些微小的tweeks会超出测量误差的幅度吗？某些功能的微小变化可能会对输出产生影响，但我将删除以下几列:</p><ul class=""><li id="68c2" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">Amb气温。u .行动</li><li id="dbc5" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach1。第一区临时法案</li><li id="bbb5" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach1。第二区温度C.Act</li><li id="1a0c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach2。建议1室</li><li id="2da9" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach2。建议2室</li><li id="4a58" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach2。建议4</li><li id="e844" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach2。第一区临时法案</li><li id="8ae1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach2。第二区温度C.Act</li><li id="7f9c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach2。安培U.Act</li><li id="58ee" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach2。电机转速C.Act</li><li id="7467" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach2。ExitZoneTemp.C .法案</li><li id="f8e3" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach3。第一区临时法案</li><li id="cd30" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach3。第二区温度C.Act</li><li id="1994" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Mach3。ExitZoneTemp.C .法案</li><li id="362e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">第一阶段。combine operation . temp 3 . c . act</li></ul><p id="1e33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">删除列后，Python列表创建了要素和目标:</p><ul class=""><li id="9e5b" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">特性:原材料列(rm_cols)</li><li id="b803" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">特征:机器1 -3参数列(mpp_cols)</li><li id="730e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">功能:第一级组合器参数列(fspp_cols)</li><li id="6ff7" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">目标实际值:实际测量值(meas_cols)</li><li id="4bab" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">目标:测量设定值(meas_cols_sp)</li></ul><p id="5719" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些列表将对即将进行的分析有用。</p><p id="681f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预处理</p><p id="0390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与数据集所有者的电子邮件交流表明这是一个聚合物挤出过程。过程存在时滞:物料进入1、2或3号机→物料离开1、2、3号机→物料进入一级组合器→物料离开一级组合器→物料被测。</p><p id="e6b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑进入机器1的一段1英寸的材料。这1英寸的材料在移动过程中经历了绝对时间的滞后。数据帧的结构没有考虑这些滞后。日期时间戳在绝对时间的<em class="kp">点索引机器特征、第一阶段组合器特征或测量目标，而不是1英寸材料段所经历的</em>。测量值(目标实际值)是针对一段经历了特定温度、电流、压力等的材料。我们想要一个模型，它能根据所经历的特征值来预测材料目标是什么。</p><p id="10ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果特征/目标相对于它们的采样率变化缓慢，这可能是一个有争议的点。此外，数据集所有者不能/不愿意为此过程提供线速度或设备物理尺寸。</p><p id="6672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们决定继续创建新的数据集，这会带来时间延迟。以下显示了具有时滞和特征的过程:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kr"><img src="../Images/47f3654e8bd98e9928ef0fa341660f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*LYS9Uksex94b9A4vhadvuw.png"/></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">图2 —显示保留功能和时间延迟的流程图</figcaption></figure><p id="10a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如图2所示，将处理工序/机器之间的时移<em class="kp">，而不是</em>机器内的时移<em class="kp">。假设时间偏移是均匀的。将创建具有3秒和5秒位移的数据帧。</em></p><p id="a567" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对我来说，这个分析过程已经有了相当多的“挥手动作”(当我妻子问起这篇文章时，我的回答是模仿电影《马达加斯加》中的企鹅:“你什么也没看见”)。专栏被删除了，因为我认为小的流程图不重要或者不可行(我无法接触到工程师/操作员，所以我不知道这是不是真的)。当我不知道时间滞后是什么的时候，我把时间滞后放入数据列。我确实有在聚合物挤出机周围工作的经验，但是3和5秒的时滞是猜测。此外，我还必须处理测量列中的负值和零值(实际值和设定值)。鉴于数据集注释指出所有测量值都以毫米为单位，负测量值和零测量值没有意义。</p><p id="79f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这个分析是“真实的”，我就不会做出这些假设/猜测。在进行分析之前，我会从操作员/工程师那里找到答案。</p><p id="b0ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为本文旨在提供指导，所以我将继续并完成对这些数据的分析，最终得出一个根据这些特征预测目标的模型。</p><p id="7845" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下代码用于创建反映3秒和5秒时滞的新数据帧:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="7cf2" class="kj kk hi kf b fi kl km l kn ko"><em class="kp">#create 3 sec shift dataframe</em><br/>df_init3 = df_init.copy()<br/>df_init3[fspp_cols] = df_init3[fspp_cols].shift(-3, axis = 0, <br/>                                      fill_value = "shifted") <br/>df_init3[meas_cols] = df_init3[meas_cols].shift(-6, axis = 0, <br/>                                      fill_value = "shifted")<br/>df_init3[meas_cols_sp] = df_init3[meas_cols_sp].shift(-6, axis = 0, <br/>                                      fill_value = "shifted")</span><span id="2ed2" class="kj kk hi kf b fi kq km l kn ko"><em class="kp">#shifted columns dtype changed to 'object'.  Change back to float</em><br/>cols = df_init3.select_dtypes(exclude=['float64', 'int64']<br/>                             ).columns.to_list() cols.remove('time_stamp')<br/>df_init3[cols] = df_init3[cols].apply(pd.to_numeric, <br/>                          downcast='float', errors='coerce')</span><span id="2afd" class="kj kk hi kf b fi kq km l kn ko"><em class="kp">#repeat for 5 sec shift dataframe</em><br/>df_init5 = df_init.copy()<br/>df_init5[fspp_cols] = df_init5[fspp_cols].shift(-5, axis = 0) <br/>df_init5[meas_cols] = df_init5[meas_cols].shift(-10, axis = 0)<br/>df_init5[meas_cols_sp] = df_init5[meas_cols_sp].shift(-10, axis = 0)</span><span id="c03e" class="kj kk hi kf b fi kq km l kn ko">cols = df_init5.select_dtypes(exclude=['float64', 'int64']<br/>                             ).columns.to_list()</span><span id="1841" class="kj kk hi kf b fi kq km l kn ko">cols.remove('time_stamp')<br/>df_init5[cols] = df_init5[cols].apply(pd.to_numeric, <br/>                   downcast='float', errors='coerce')</span></pre><p id="cf9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下代码用于检查3秒时间延迟df的时间延迟偏移是否正确:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="759e" class="kj kk hi kf b fi kl km l kn ko"><em class="kp">#check the shift on df_init3. 1st stage combiner temps shift by 3s,<br/>#1st stage measurements shift by 6s</em></span><span id="557b" class="kj kk hi kf b fi kq km l kn ko">df_test = pd.concat(objs = [df_init.loc[3,:],<br/>                            df_init3.loc[0, : ],<br/>                            df_init.loc[14087,:], <br/>                            df_init3.loc[14081, : ]],<br/>                    axis=1, join='outer', ignore_index= True,<br/>                    keys=None, levels=None, names=None, <br/>                    verify_integrity=False, copy=True)<br/>df_test.columns = ['df_init', 'df_init3(3)', <br/>                   'df_init', 'df_init3(6)']<br/>df_test3 = df_test.loc[fspp_cols, : ]<br/>df_test6 = df_test.loc[meas_cols, :]</span><span id="1674" class="kj kk hi kf b fi kq km l kn ko">print(df_test3)<br/>print(df_test6)</span><span id="c48d" class="kj kk hi kf b fi kq km l kn ko">#checked</span></pre><p id="9387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于这些结果，假设5秒时间滞后数据帧也是正确的。</p><p id="5cf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进一步的数据清理</p><p id="c915" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，测量实际值和设定值中有负值和零值。使用3秒时间滞后数据框，计算每个设定点栏中的零的数量:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="9851" class="kj kk hi kf b fi kl km l kn ko"><em class="kp">#count the number of values == 0 in each setpoint column</em></span><span id="e3d3" class="kj kk hi kf b fi kq km l kn ko">sp_dict_0 = {}<br/>for i in meas_cols_sp:<br/>    value = (df_init3[i] == 0).sum()<br/>    sp_dict_0[i] = value<br/>    <br/>print(sp_dict_0)</span></pre><p id="a3a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个测量设定点列包含56个零。他们是同一排的吗？数据库所有者指出，当测量系统“退出”时，设定点中的行全为零。可以编写代码来验证设置点0是否都来自同一行，但是考虑到数据库所有者的反馈，我将只删除这些行。</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="c77e" class="kj kk hi kf b fi kl km l kn ko"><em class="kp">#drop all zero setpoint rows</em></span><span id="13a2" class="kj kk hi kf b fi kq km l kn ko">df_init3 = df_init3.loc[(df[meas_cols_sp] &gt; 0).all(axis=1)]</span></pre><p id="41d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行<code class="du ks kt ku kf b">shape</code>方法显示数据帧中的行数正好减少了56。所有测量设定点列零点都在同一行。</p><p id="1ce6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于时间延迟偏移，3秒数据帧尾部的某些列包含“偏移”而不是数值。使用了<code class="du ks kt ku kf b">drop</code>和<code class="du ks kt ku kf b">tail</code>方法来删除数据帧的最后6行。</p><p id="f27b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在3秒数据帧上执行<code class="du ks kt ku kf b">describe</code>方法。即使在删除了某些行之后，测量实际列中仍然有负数和零。</p><p id="0e13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分析将简化为单一目标变量。完成分析的下一步是:</p><ol class=""><li id="04bd" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc kv jk jl jm bi translated">选择包含大量非零值的单个目标实际列。</li><li id="0fb6" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">删除剩余的目标实际值和设定值列</li><li id="c5f9" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">将数据帧划分为训练和测试数据集，选择特征，创建模型，拟合并进行目标预测</li></ol><p id="6e29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择一个目标变量</p><p id="7d1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用于以下代码中meas_cols和直方图的<code class="du ks kt ku kf b">describe</code>方法用于选择目标变量:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="d4be" class="kj kk hi kf b fi kl km l kn ko"># Import library and write function for histogram plotting</span><span id="49e7" class="kj kk hi kf b fi kq km l kn ko">import matplotlib.pyplot as plt</span><span id="c908" class="kj kk hi kf b fi kq km l kn ko">def hist_plot(df,columns):<br/>    fig = plt.figure(figsize = (20, 20))<br/>    for counter,sp in enumerate(columns):<br/>        ax = fig.add_subplot(5,3,counter+1)<br/>        ax.set_title(sp, color = 'red')<br/>        ax.tick_params(color = 'red', labelcolor = 'red')<br/>        bins = 10<br/>        plt.hist(df[sp],bins, align = 'left')</span><span id="48a0" class="kj kk hi kf b fi kq km l kn ko">    plt.subplots_adjust(hspace = 0.5)<br/>    plt.show()<br/>    return</span><span id="b903" class="kj kk hi kf b fi kq km l kn ko">hist_plot(df_init3, meas_cols)</span></pre><p id="fd61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">生成了所有15个测量实际值的直方图。下面是测量10的实际直方图:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kw"><img src="../Images/e0599e70f6aa776d421ab675c9b984bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*eq0vzPO3GYZx21bE7581oA.png"/></div></figure><p id="1104" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测量10值&gt; 0的范围从4.2mm到13.1mm，相对少数值≤ 0。测量值10被选为目标变量。所有其他测量列(实际值和设定值)被删除。测量值10 ≤ 0的行也被删除:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="1fad" class="kj kk hi kf b fi kl km l kn ko">#drop measurement columns (Act and Setpoint) != 10<br/>rm_col = meas_cols.copy()<br/>rm_col.remove('Stage1_Measure10.U.Act')<br/>df_init3.drop(rm_col, axis = 1,inplace = True)</span><span id="ec76" class="kj kk hi kf b fi kq km l kn ko">rm_colsp = meas_cols_sp.copy()<br/>rm_colsp.remove('Stage1_Measure10.U.Setpoint')<br/>df_init3.drop(rm_colsp,axis = 1, inplace = True)</span><span id="47af" class="kj kk hi kf b fi kq km l kn ko"># `checked`</span><span id="8ace" class="kj kk hi kf b fi kq km l kn ko">#drop rows where Measure10 &lt;= 0</span><span id="9366" class="kj kk hi kf b fi kq km l kn ko">df_init3 = df_init3[df_init3['Stage1_Measure10.U.Act'] &gt; 0]<br/>df_init3['Stage1_Measure10.U.Act'].describe() </span></pre><p id="37cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从3秒时间滞后DF创建训练、测试数据集</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="992c" class="kj kk hi kf b fi kl km l kn ko">#create train, test datasets<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.preprocessing import MinMaxScaler<br/>from sklearn.linear_model import LinearRegression</span><span id="dc6d" class="kj kk hi kf b fi kq km l kn ko">train3,test3 = train_test_split(df_init3, <br/>                                test_size = 0.25,<br/>                                random_state = 1)<br/>#create min/max scaled train X, also a train y</span><span id="243a" class="kj kk hi kf b fi kq km l kn ko">X_train3df = train3.drop(['Stage1_Measure10.U.Setpoint',<br/>                       'Stage1_Measure10.U.Act',<br/>                       'time_stamp'],<br/>                      axis = 1)<br/>scaler_train = MinMaxScaler()<br/>scaler_train.fit(X_train3df)<br/>X_train3 = scaler_train.transform(X_train3df)# scale<br/>y_train3 = train3.pop('Stage1_Measure10.U.Act')</span><span id="6c16" class="kj kk hi kf b fi kq km l kn ko">#create test X, test y (will scale test X after choosing<br/>#model features)</span><span id="503e" class="kj kk hi kf b fi kq km l kn ko">X_test3 = test3.drop(['Stage1_Measure10.U.Setpoint',<br/>                       'Stage1_Measure10.U.Act',<br/>                       'time_stamp'],<br/>                      axis = 1)<br/>y_test3 = test3.pop('Stage1_Measure10.U.Act')</span></pre><p id="7de8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">建模</p><p id="dc69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遵循以下步骤来创建用于预测测量值10的模型:</p><p id="0212" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-创建递归特征消除函数(RFE) <br/> -创建线性回归函数<br/> -执行RFE函数以选择特征<br/> -使用从训练和测试数据集中选择的RFE特征对3秒时间滞后数据帧执行线性回归函数</p><p id="6bd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是RFE和线性回归函数的代码:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="c935" class="kj kk hi kf b fi kl km l kn ko">from sklearn.feature_selection import RFE<br/>from sklearn.linear_model import LinearRegression</span><span id="4711" class="kj kk hi kf b fi kq km l kn ko">def choose_features(X, y):<br/>    <br/>    lr = LinearRegression()<br/>    grid = RFE(lr, n_features_to_select = 5, step = 1)<br/>    grid.fit(X,y)<br/>    rem_X = grid.transform(X)<br/>    num_features = grid.n_features_<br/>    column_rank = grid.ranking_<br/>    return num_features, column_rank, rem_X</span><span id="071f" class="kj kk hi kf b fi kq km l kn ko">#function for linear regression<br/>def lr_reg(X_train, X_test, y_train, y_test):<br/>    lr = LinearRegression(fit_intercept = False)<br/>    lr.fit(X_train, y_train)<br/>    prediction = lr.predict(X_test)<br/>    Rsq = lr.score(X_test, y_test)<br/>    coefs = lr.coef_<br/>    return Rsq, coefs, prediction</span></pre><p id="9137" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用RFE函数，并使用结果为测试功能创建numpy数组:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="8c39" class="kj kk hi kf b fi kl km l kn ko"># call the RFE function (_rem indicates "remaining")</span><span id="b970" class="kj kk hi kf b fi kq km l kn ko">num_features, column_rank, X_train3_rem = choose_features(X_train3,<br/>                                                          y_train3)</span><span id="16fc" class="kj kk hi kf b fi kq km l kn ko">#Get list of remaining features columns after RFE by<br/>#zipping together column_rank boolean, column names. <br/>#Then sort ascending, put the no. of columns equal to<br/>#number of features into a list</span><span id="86f5" class="kj kk hi kf b fi kq km l kn ko">zipped = dict(zip(X_train3df.columns, column_rank))<br/>sort_zip = sorted(zipped.items(), <br/>                  key=lambda x: x[1], reverse=False)<br/>sort_list =[]<br/>for i in range(0,num_features):<br/>    sort_list.append(sort_zip[i][0])<br/>    <br/>print(sort_list)</span><span id="3f8c" class="kj kk hi kf b fi kq km l kn ko">#Create X_test w/ reduced feature set<br/>X_test3_temp = test3[sort_list]<br/>scaler_test = MinMaxScaler()<br/>scaler_test.fit(X_test3_temp)<br/>X_test3_rem = scaler_test.transform(X_test3_temp)# scale</span><span id="6d2f" class="kj kk hi kf b fi kq km l kn ko"># Now have reduced, scaled train and test feature arrays<br/># for regression and have sort_list giving the feature names</span></pre><p id="add1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用线性回归函数并打印结果:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="0f9a" class="kj kk hi kf b fi kl km l kn ko">#call linear regression function<br/>Rsq, coefs, prediction = lr_reg(X_train3_rem, <br/>                    X_test3_rem, <br/>                    y_train3, <br/>                    y_test3)<br/>print("Number of features (3s lag):", num_features, '\n',<br/>      num_features,"Regression Rsq (3s lag):", Rsq, '\n',<br/>      "Model coefficient names:", sort_list, '\n'<br/>     "Model coefficents (3s lag):", coefs)</span></pre><p id="da10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用所有功能将结果与回归模型进行比较:</p><pre class="jt ju jv jw fd ke kf kg kh aw ki bi"><span id="667a" class="kj kk hi kf b fi kl km l kn ko"># what's the difference in R2 between 5 feature and all<br/># feature model?</span><span id="fabc" class="kj kk hi kf b fi kq km l kn ko">scaler_test_all = MinMaxScaler()<br/>scaler_test_all.fit(X_test3)<br/>X_test3_sall = scaler_test_all.transform(X_test3)# scale all<br/>Rsq, coefs, prediction = lr_reg(X_train3, <br/>                                 X_test3_sall, <br/>                                 y_train3, <br/>                                 y_test3)<br/>print("All features regression Rsq (3s lag):", Rsq, '\n',<br/>     "All features model coefficents (3s lag):", coefs)</span></pre><p id="7f55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">建模的结果:</p><ul class=""><li id="ce74" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">5特征模型，3秒滞后df，给出0.30的R。<em class="kp">‘mach 3。RM.Prop1 '，' Mach3。RM.Prop2 '，' Mach3。RM.Prop3 '，' Mach3。RM.Prop4' </em>系数为1E11，1E12级。其他系数量级1E-01。</li><li id="463a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">26特征模型，3秒滞后df，给出0.52的R。<em class="kp">‘mach 3。RM.Prop1 '，' Mach3。RM.Prop2 '，' Mach3。RM.Prop3 '，' Mach3。RM.Prop4 </em>系数的大小为1E00，1E01。其他系数为magnitude1E-01、1E-02。</li></ul><p id="5163" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">R值较低，表明与总可变性相比，模型解释的可变性比例较小。</p><p id="19c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么4个斜体特征与其他特征相比具有如此大的系数？我不知道。机器1的原材料属性是模型的一部分，其值是数字序数(类似于机器3的原材料属性)，但没有非常大的系数。为什么Machine3与Machine1不同令人费解。</p><p id="d944" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个分析可以在https://www.kaggle.com/ryandmonson/rmonson-multistep-mfg<a class="ae jd" href="https://www.kaggle.com/ryandmonson/rmonson-multistep-mfg" rel="noopener ugc nofollow" target="_blank">的一个笔记本上找到。</a></p><p id="e846" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">后现代——思考，经验教训</p><ul class=""><li id="cf62" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">在目标/特征选择方面可以做更多的工作。可能需要重新考虑在模型中包含原材料属性。Kaggle列显示这些特征是数字序数(它们可能是连续的，但是数据集对于每个原材料属性只有3或4个值)。</li><li id="406c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">初始特征移除包括测量误差解释测量可变性的特征。这个想法有更广泛的应用，将在第四部分进一步讨论。</li><li id="9fbd" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">校准解决了测量数据的有效性问题，但在这种情况下，似乎没有解决校准问题。这个想法有更广泛的应用，将在第四部分进一步讨论。</li><li id="156d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">在评估要包含在模型中的要素时，我完全忽略了检查多重共线性。这在本系列的第二部分(批处理分析)中已经完成，但本部分没有完成。当分析的要素与以前的经验紧密联系时(在我的案例中是测量误差和校准)，其他基本要素可能会被忽略。清单可以帮助避免这种错误。</li><li id="007f" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">除了测量误差和校准之外，制造车间的应用也与我的经验密切相关。根据我的评估，运营商无法做出有效的调整，所以这些功能被取消了。分析结果需要具有可操作性。</li><li id="d0df" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">很多时候，我们只关注R或其他一些准确性分数来判断我们的模型。在这种情况下，系数本身也讲述了一个应该调查的故事。对模型的完整理解将导致对过程变更做出更稳健的决策。</li><li id="6593" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">许多故障排除时间都花在了LinearRegression实例的输出上。最初，StandardScaler用于预处理，LinearRegression的<code class="du ks kt ku kf b">predict</code>方法提供了荒谬的结果。经过相当多的思考、研究和发誓，我意识到当数据呈正态分布时，使用StandardScaler。我切换到MinMaxScalar，得到了合理的结果。这一经历如此令人沮丧，以至于激发了我在本系列完成后撰写并发表的下一篇文章。</li><li id="5782" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">我最初考虑根据特征与目标的相关性来选择特征，这是我在学习数据科学课程时教授的一种方法。这种方法需要对相关截止值进行判断。为了避免判断失误，我走了RFECV路线(带交叉验证的递归特征消除)。RFECV根据交叉验证的最高平均准确度分数选择特征的数量。毫不奇怪，来自RFECV的最精确的模型使用了所有的特性。最后，我选择了RFE路线，对5个特征做出了判断。通过RFE和相关系数确定特征，哪个“更好”？两者都需要判断，计算结果也不同。尽管数据科学是由数字和客观性驱动的，但仍然需要做出判断。</li></ul><p id="569d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">*****</p><p id="f089" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测量误差是测量结果的不确定性。假设热电偶的测量误差为±1℃。热电偶读数为25℃。真实温度在24–26℃范围内(这是一个置信区间，因此真实温度的概率在此范围内是一致的)。对于这个例子，由于测量误差，不能说24℃的温度读数与26℃的不同。根据我在制造业的经验，测量误差经常被忽视(甚至被反对)。</p></div></div>    
</body>
</html>