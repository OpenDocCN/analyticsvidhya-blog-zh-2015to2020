<html>
<head>
<title>Monte Carlo Simulations for Stock Price Predictions [Python]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">股票价格预测的蒙特卡罗模拟[Python]</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/monte-carlo-simulations-for-predicting-stock-prices-python-a64f53585662?source=collection_archive---------0-----------------------#2020-05-19">https://medium.com/analytics-vidhya/monte-carlo-simulations-for-predicting-stock-prices-python-a64f53585662?source=collection_archive---------0-----------------------#2020-05-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="56e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">蒙特卡洛模拟在许多情况下是一种非常强大的工具，包括运筹学、博弈论、物理学、商业和金融等。这是一种技术，用于在决策时理解风险和不确定性的影响。简而言之，蒙特卡洛模拟使用不确定变量的基础分布产生的不同随机数进行足够多的试验。</p><p id="e035" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将深入研究如何使用蒙特卡洛模拟来预测股票价格！</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="4bf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开始之前，我们需要了解什么？</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jk"><img src="../Images/8a7734d7a2a0652952fb375e51c3ce6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o5bV1_qE79ZOKIQTJ8YC8w.png"/></div></div></figure><p id="c289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们想预测今天股票的价格。我们知道昨天股票的价格。那么，少了什么？我们显然不知道股票今天的日收益率。这就是蒙特卡洛的用武之地！但首先…我们如何估算回报？</p><p id="7f4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们如何预测股票的每日回报？布朗运动。</strong></p><p id="7876" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jw" href="https://en.wikipedia.org/wiki/Brownian_motion" rel="noopener ugc nofollow" target="_blank">布朗运动</a>将是估算回报的主要驱动力。这是一个随机过程，用于模拟一段时间内的随机行为。布朗运动有两个主要部分:</p><ol class=""><li id="5893" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated">漂移——过去回报率的方向。也就是股票的预期收益。你可能会问自己:为什么方差要乘以0.5？因为历史价值在未来会被侵蚀。</li><li id="695d" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">波动率——历史波动率乘以一个随机的标准正态变量。</li></ol><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kl"><img src="../Images/3bfe5d14912a78bcb95b9d3a86fc369e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YcTh0gKplFrZTIZRaBgjJQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">布朗运动适用于股票</figcaption></figure><p id="6cce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些一起计算布朗运动——即股票的每日回报！</p><p id="1ee1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这项技术将被用于你想要预测的未来的每一天，无论蒙特卡洛模拟会运行多少次！让我们开始编码吧！</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="f55d" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">蒙特卡罗模拟的Python代码</h1><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="a7f3" class="lt kr hi lp b fi lu lv l lw lx">import numpy as np<br/>import pandas as pd<br/>from pandas_datareader import data as wb<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from scipy.stats import norm</span></pre><p id="c26a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一步</strong>:导入股票数据。我们将以谷歌(Google)为例。</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="d59e" class="lt kr hi lp b fi lu lv l lw lx">ticker = 'GOOG'<br/>data = pd.DataFrame()<br/>data[ticker] = wb.DataReader(ticker, data_source = 'yahoo', start = '2010-1-1')['Adj Close]</span><span id="8d6f" class="lt kr hi lp b fi ly lv l lw lx">#Plot<br/>data.plot(figsize=(15,6))</span></pre><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lz"><img src="../Images/334cfe7ee42e9feedd5d348d57d78e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ir2HqivZJZVbT8xOP9xE9A.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">谷歌股价随时间的变化</figcaption></figure><p id="a825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法简单明了。使用pandas_datareader，您可以免费导入股票数据，无需访问键。非常方便我们的目的！</p><p id="16e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步</strong>:计算谷歌股票的对数回报率</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="c772" class="lt kr hi lp b fi lu lv l lw lx">log_return = np.log(1 + data.pct_change())</span><span id="cb59" class="lt kr hi lp b fi ly lv l lw lx">#Plot<br/>sns.distplot(log_returns.iloc[1:])<br/>plt.xlabel("Daily Return")<br/>plt.ylabel("Frequency")</span></pre><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ma"><img src="../Images/24dcd2618fdb1e612d5612cf0e1317b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27MFw2a348EYJ9knMWZPAw.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">谷歌每日回报直方图</figcaption></figure><p id="5f84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤3 </strong>:计算漂移</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="e6dc" class="lt kr hi lp b fi lu lv l lw lx">u = log_returns.mean()<br/>var = log_returns.var()<br/>drift = u - (0.5*var)</span></pre><p id="c6a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第四步</strong>:计算方差和日收益率</p><p id="8d36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步中，我们必须为预测的每一天以及将要运行的每一次模拟试验生成随机变量。</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="483a" class="lt kr hi lp b fi lu lv l lw lx">stdev = log_returns.std()<br/>days = 50<br/>trials = 10000<br/>Z = norm.ppf(np.random.rand(days, trials)) #days, trials<br/>daily_returns = np.exp(drift.values + stdev.values * Z)</span></pre><p id="d02d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如此接近！现在我们已经在一万次试验中的每一天随机生成了50个随机变量，我们所需要的就是计算每一次试验的价格路径！</p><p id="a34d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤5 </strong>:计算每一次试验的股票价格</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="e76a" class="lt kr hi lp b fi lu lv l lw lx">price_paths = np.zeros_like(daily_returns)<br/>price_paths[0] = data.iloc[-1]<br/>for t in range(1, days):<br/>    price_paths[t] = price_paths[t-1]*daily_returns[t]</span></pre><p id="99bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的循环是不是看起来很眼熟？没错。它就是我们的股票价格方程，我们在这篇文章中看到的第一个方程！</p><div class="jl jm jn jo fd ab cb"><figure class="mb jp mc md me mf mg paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><img src="../Images/d6f854fbd2cd791d908f90c24144ee31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*ihnJV4-Toerqfl_P_MYuOw.png"/></div></figure><figure class="mb jp mh md me mf mg paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><img src="../Images/50ebda620bb290fd11cec9982a000c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*vhDQkvyAQpVj5Az507Oejg.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx mi di mj mk translated">蒙特卡洛模拟的前10次迭代，最后一天价格的直方图</figcaption></figure></div><p id="29d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开始了。我们运行了一个蒙特卡洛模拟，预测谷歌未来50天的股价。</p><p id="a8be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，使用price_paths矩阵，现在您可以计算盈利能力的概率或预期的年回报率。在下一节中，我们将两者都做！</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="395e" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">第2部分:自动化蒙特卡罗模拟和显示CAPM指标</h1><p id="78b6" class="pw-post-body-paragraph if ig hi ih b ii ml ik il im mm io ip iq mn is it iu mo iw ix iy mp ja jb jc hb bi translated">在这一节中，我们简要回顾一下为完成上述过程中的步骤而创建的函数，这样我们就可以根据您的需要自动模拟任意多的股票！我们还将展示资本资产定价模型中的一些指标。</p><p id="bce7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一步</strong>:导入股票数据</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="17ae" class="lt kr hi lp b fi lu lv l lw lx">def import_stock_data(tickers, start = '2010-1-1'):<br/>    data = pd.DataFrame()<br/>    if len([tickers]) ==1:<br/>        data[tickers] = wb.DataReader(tickers, data_source='yahoo', start = start)['Adj Close']<br/>        data = pd.DataFrame(data)<br/>    else:<br/>        for t in tickers:<br/>            data[t] = wb.DataReader(t, data_source='yahoo', start = start)['Adj Close']<br/>    return(data)</span><span id="0b16" class="lt kr hi lp b fi ly lv l lw lx">#Example use<br/>data = import_stock_data(["FB","GOOG","AAPL"], start = '2005-1-1')</span></pre><p id="6568" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步</strong>:计算对数日收益</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="6753" class="lt kr hi lp b fi lu lv l lw lx">def log_returns(data):<br/>    return (np.log(1+data.pct_change()))</span><span id="9552" class="lt kr hi lp b fi ly lv l lw lx">#Example use<br/>log_return = log_returns(data)</span></pre><p id="4721" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第三步</strong>:计算漂移</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="73e1" class="lt kr hi lp b fi lu lv l lw lx">def drift_calc(data):<br/>    lr = log_returns(data)<br/>    u = lr.mean()<br/>    var = lr.var()<br/>    drift = u-(0.5*var)<br/>    try:<br/>        return drift.values<br/>    except:<br/>        return drift</span><span id="eaac" class="lt kr hi lp b fi ly lv l lw lx">#Example use<br/>drift_calc(data)</span></pre><p id="d8f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第四步:计算每日回报</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="5c44" class="lt kr hi lp b fi lu lv l lw lx">def daily_returns(data, days, iterations):<br/>    ft = drift_calc(data, return_type)<br/>    try:<br/>        stv = log_returns(data).std().values<br/>    except:<br/>        stv = log_returns(data).std()</span><span id="6250" class="lt kr hi lp b fi ly lv l lw lx">    dr = np.exp(ft + stv * norm.ppf(np.random.rand(days, iterations)))</span><span id="81f3" class="lt kr hi lp b fi ly lv l lw lx">    return dr</span><span id="c4be" class="lt kr hi lp b fi ly lv l lw lx">#Example use<br/>daily_returns(data, 50, 1000)</span></pre><p id="12b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第五步(CAPM) </strong>:计算每只股票的夏普比率、风险调整后的收益和贝塔系数。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es mq"><img src="../Images/28f6be632a57e0e0430fe2874d43e183.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*65rkNn377FpQPCglL5dT7Q.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">贝塔、风险调整回报和夏普比率方程</figcaption></figure><p id="a311" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从等式中我们可以看出，我们必须将每只股票与市场进行比较。所以我们将导入市场数据(标准普尔500)。我们还需要无风险利率。我们将用10年期美国债券的收益率(2.5%)来估算这个利率。</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="1b6d" class="lt kr hi lp b fi lu lv l lw lx">def beta_sharpe(data, mark_ticker = "^GSPC", start='2010-1-1', riskfree = 0.025):<br/>    # Beta<br/>    dd, mark_ret = market_data_combination(data, mark_ticker, start)<br/>    log_ret = log_returns(dd)<br/>    covar = log_ret.cov()*252  # Annualized<br/>    covar = pd.DataFrame(covar.iloc[:-1,-1])<br/>    mrk_var = log_ret.iloc[:,-1].var()*252 #Annualized<br/>    beta = covar/mrk_var<br/>    <br/>    stdev_ret = pd.DataFrame(((log_ret.std()*250**0.5)[:-1]), columns=['STD'])<br/>    beta = beta.merge(stdev_ret, left_index=True, right_index=True)<br/>    <br/>    # CAPM<br/>    for i, row in beta.iterrows():<br/>        beta.at[i,'CAPM'] = riskfree + (row[mark_ticker] * (mark_ret-riskfree))<br/>    # Sharpe<br/>    for i, row in beta.iterrows():<br/>        beta.at[i,'Sharpe'] = ((row['CAPM']-riskfree)/(row['STD']))<br/>    beta.rename(columns={"^GSPC":"Beta"}, inplace=True)<br/>    <br/>    return beta</span><span id="472a" class="lt kr hi lp b fi ly lv l lw lx">#Example use<br/>#Make sure the start date here is the same as the start day of the original data.<br/>beta_sharpe(data, '2005-1-1') </span></pre><p id="d59b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第七步(概率)</strong>:计算某种结果的概率</p><p id="c62f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们对几只股票进行蒙特卡洛模拟，我们可能想要计算我们的投资获得正回报或25%回报的概率，或者只是股票达到特定价格的概率。因此，我们创建了这个等式来帮你解决这个问题！</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="e65c" class="lt kr hi lp b fi lu lv l lw lx">def probs_find(predicted, higherthan, on = 'value'):<br/>    if on == 'return':<br/>        predicted0 = predicted.iloc[0,0]<br/>        predicted = predicted.iloc[-1]<br/>        predList = list(predicted)<br/>        over = [(i*100)/predicted0 for i in predList if ((i-predicted0)*100)/predicted0 &gt;= higherthan]<br/>        less = [(i*100)/predicted0 for i in predList if ((i-predicted0)*100)/predicted0 &lt; higherthan]<br/>    elif on == 'value':<br/>        predicted = predicted.iloc[-1]<br/>        predList = list(predicted)<br/>        over = [i for i in predList if i &gt;= higherthan]<br/>        less = [i for i in predList if i &lt; higherthan]<br/>    else:<br/>        print("'on' must be either value or return")<br/>    return (len(over)/(len(over)+len(less)))</span><span id="3985" class="lt kr hi lp b fi ly lv l lw lx">#Example use (probability our investment will return at least 20% over the days specified in our prediction<br/>probs_find(predicted, 0.2, on = 'return')</span></pre><p id="e4b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第8步</strong>:对单只股票进行蒙特卡洛模拟</p><p id="945f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个步骤是被动的。我们定义了函数，这样我们就可以在最后一步循环遍历它。</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="34f2" class="lt kr hi lp b fi lu lv l lw lx">def simulate_mc(data, days, iterations, plot=True):</span><span id="1ce9" class="lt kr hi lp b fi ly lv l lw lx">    # Generate daily returns<br/>    returns = daily_returns(data, days, iterations)<br/>    # Create empty matrix<br/>    price_list = np.zeros_like(returns)<br/>    # Put the last actual price in the first row of matrix. <br/>    price_list[0] = data.iloc[-1]<br/>    # Calculate the price of each day<br/>    for t in range(1,days):<br/>        price_list[t] = price_list[t-1]*returns[t]<br/>    <br/>    # Plot Option<br/>    if plot == True:<br/>        x = pd.DataFrame(price_list).iloc[-1]<br/>        fig, ax = plt.subplots(1,2, figsize=(14,4))<br/>        sns.distplot(x, ax=ax[0])<br/>        sns.distplot(x, hist_kws={'cumulative':True},kde_kws={'cumulative':True},ax=ax[1])<br/>        plt.xlabel("Stock Price")<br/>        plt.show()<br/>    <br/>    #CAPM and Sharpe Ratio<br/>    <br/>    # Printing information about stock<br/>    try:<br/>        [print(nam) for nam in data.columns]<br/>    except:<br/>        print(data.name)<br/>    print(f"Days: {days-1}")<br/>    print(f"Expected Value: ${round(pd.DataFrame(price_list).iloc[-1].mean(),2)}")<br/>    print(f"Return: {round(100*(pd.DataFrame(price_list).iloc[-1].mean()-price_list[0,1])/pd.DataFrame(price_list).iloc[-1].mean(),2)}%")<br/>    print(f"Probability of Breakeven: {probs_find(pd.DataFrame(price_list),0, on='return')}")<br/>   <br/>          <br/>    return pd.DataFrame(price_list)</span><span id="14dd" class="lt kr hi lp b fi ly lv l lw lx">#Example use<br/>simulate_mc(data, 252, 1000)</span></pre><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es mr"><img src="../Images/781d74bdf8197b19e7b66dba3deb4ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EeVqO-wWLKZTOthd_b78ZA.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">股票的单一蒙特卡洛模拟的输出示例</figcaption></figure><p id="da39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第9步</strong>:根据需要，对尽可能多的股票进行完整的蒙特卡洛模拟！</p><pre class="jl jm jn jo fd lo lp lq lr aw ls bi"><span id="4327" class="lt kr hi lp b fi lu lv l lw lx">def monte_carlo(tickers, days_forecast, iterations, start_date = '2000-1-1', plotten=False):</span><span id="2563" class="lt kr hi lp b fi ly lv l lw lx">    data = import_stock_data(tickers, start=start_date)</span><span id="b45a" class="lt kr hi lp b fi ly lv l lw lx">    inform = beta_sharpe(data, mark_ticker="^GSPC", start=start_date)</span><span id="af62" class="lt kr hi lp b fi ly lv l lw lx">    simulatedDF = []<br/>    for t in range(len(tickers)):<br/>        y = simulate_mc(data.iloc[:,t], (days_forecast+1), iterations)<br/>        if plotten == True:<br/>            forplot = y.iloc[:,0:10]<br/>            forplot.plot(figsize=(15,4))<br/>        print(f"Beta: {round(inform.iloc[t,inform.columns.get_loc('Beta')],2)}")<br/>        print(f"Sharpe: {round(inform.iloc[t,inform.columns.get_loc('Sharpe')],2)}") <br/>        print(f"CAPM Return: {round(100*inform.iloc[t,inform.columns.get_loc('CAPM')],2)}%")<br/>        y['ticker'] = tickers[t]<br/>        cols = y.columns.tolist()<br/>        cols = cols[-1:] + cols[:-1]<br/>        y = y[cols]<br/>        simulatedDF.append(y)<br/>    simulatedDF = pd.concat(simulatedDF)<br/>    return simulatedDF</span><span id="6b50" class="lt kr hi lp b fi ly lv l lw lx">#Example use<br/>ret_sim_df = monte_carlo(['GOOG','FB','AAPL'], 252, 10000,  start_date='2015-1-1')</span></pre><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ms"><img src="../Images/5f89ec2efc0c3ff8ffd506fedb361026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYAgcfoh9JeJ5mAtvR_-KA.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es mt"><img src="../Images/f99e3a4369dbf8effaffdfccafcd92ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*frTNIhW8Npv1MOuXShWa9g.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es mu"><img src="../Images/16fe726621e9a60993cd7bb7e5665a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Df5qXmg4TZZf3wpYWJqEA.png"/></div></div></figure><p id="50fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行模拟后，我们可以观察到结束日期的值分布，这取决于预测的天数。每只股票的指标，包括平均回报、风险调整回报、盈亏平衡概率、贝塔系数和夏普比率也打印出来。希望，这将帮助你作为一个投资者！</p><p id="dbd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧啊。只需加载/运行步骤1-9中创建的函数，您就可以为您想要的股票运行自己的蒙特卡洛模拟！你只需要安装合适的库。</p><p id="a8c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要注意的是，这里的蒙特卡罗模拟假设了收益的正态分布。然而，历史告诉我们，事实并非如此。虽然相似，但最精确的分布是柯西分布。尽管如此，在大多数情况下，正态分布在数千次试验中已经足够精确。</p><p id="3112" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你喜欢这个蒙特卡罗模拟预测股票价格的介绍！请随意从Github下载并使用Jupyter笔记本，并在LinkedIn和Medium上关注我的其他项目！</p><p id="ed60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">github:<a class="ae jw" href="https://github.com/eliasmelul/finance_portfolio" rel="noopener ugc nofollow" target="_blank">https://github.com/eliasmelul/finance_portfolio</a></p><p id="58eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">领英:【https://www.linkedin.com/in/melulelias/ T2】</p><p id="db05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">中:【https://medium.com/@melulfrescoelias】T4</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es mv"><img src="../Images/d14aa9cb01cf42b27ad2b7f028a4b9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JcmXw-oXcwZEIzWk.jpg"/></div></div></figure></div></div>    
</body>
</html>