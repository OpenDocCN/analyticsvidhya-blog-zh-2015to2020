<html>
<head>
<title>Reactive Echarts Flutter Widget</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应式Echarts颤振小工具</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/reactive-echarts-flutter-widget-fedab7f3c52f?source=collection_archive---------9-----------------------#2019-12-24">https://medium.com/analytics-vidhya/reactive-echarts-flutter-widget-fedab7f3c52f?source=collection_archive---------9-----------------------#2019-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7c9637be285c6fdabb8557bc4c344bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHF2oIqi1WbzbWV9NKsdFg.jpeg"/></div></div></figure><blockquote class="iq ir is"><p id="4f94" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="hi">介绍一个reactive Echarts Flutter Widget的开发工作:</em><a class="ae js" href="https://github.com/entronad/flutter_echarts" rel="noopener ugc nofollow" target="_blank"><em class="hi">Flutter _ Echarts</em></a><em class="hi">。</em></p><p id="3112" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://github.com/entronad/flutter_echarts" rel="noopener ugc nofollow" target="_blank"> <em class="hi">知识库</em> </a></p><p id="4361" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://pub.dev/packages/flutter_echarts" rel="noopener ugc nofollow" target="_blank"> <em class="hi">发布开发</em> </a></p></blockquote><p id="a69b" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">随着其快速发展，Flutter已经被应用到越来越多的大型项目中，复杂的数据可视化图表已经成为一个重要的需求。尽管Flutter有强大的类如Painter或Canvas来完成绘制工作，但不幸的是，在Flutter生态系统中仍然没有杀手级的数据可视化库。</p><p id="e04d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">今年年初，Flutter开发团队发布了一个官方的内嵌WebView小部件:<a class="ae js" href="https://pub.dev/packages/webview_flutter" rel="noopener ugc nofollow" target="_blank"> webview_flutter </a>。它基于新的平台视图，这使得在Flutter中无缝嵌入web内容成为可能，就像其他小部件一样。因此，我们可以将那些成熟的web数据可视化库导入到我们的Flutter应用程序中。</p><p id="bbaf" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">当谈到成熟、强大和易于使用的数据可视化库时，<a class="ae js" href="https://www.echartsjs.com/zh/index.html" rel="noopener ugc nofollow" target="_blank"> Echarts </a>无疑是一个不错的选择。这里我就不再重复它的优点了。如果我们能够在我们的Flutter应用程序中添加Echarts，我们不仅可以实现它支持的丰富的图表类型，还可以重用web的现成图表代码来减少工作量。</p><p id="bfeb" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">于是我们封装了一个Flutter widget:<a class="ae js" href="https://github.com/entronad/flutter_echarts" rel="noopener ugc nofollow" target="_blank">Flutter _ echarts</a>，兼顾扩展性和易用性，帮助Flutter开发者充分发挥e charts的功能。</p><h1 id="c532" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">特征</h1><p id="0103" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je jt kw jh ji ju kx jl jm jv ky jp jq jr hb bi translated">在此之前，我们在React Native中封装了一个<a class="ae js" href="https://github.com/entronad/react-native-echarts-demo" rel="noopener ugc nofollow" target="_blank"> Echarts组件</a>，获得了一些关于如何在一个反应式UI框架中使用数据可视化库的经验，所以在谈到Flutter时，我们为flutter_echarts设计了一些特性:</p><p id="ceca" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">无功更新</strong></p><p id="9f25" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">Flutter最重要的一个特点就是和其他所有反应式UI框架一样，根据数据的变化自动更新视图，给开发带来了很多便利。Echarts独立于任何UI框架，但它是由数据驱动设计的，数据的变化驱动图表的变化。</p><p id="7600" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">所以我们只需要把Echarts的数据驱动方法和Flutter的视图更新连接起来，就可以实现widget的反应式更新。在Echarts中设置动态数据更新非常简单。所有数据更新都是通过<code class="du kz la lb lc b">setOption</code>。你只需要随心所欲的获取数据，将数据填入<code class="du kz la lb lc b">setOption</code>就可以了，不用考虑数据带来的变化，ECharts会找出两组数据之间的差异，并通过适当的动画呈现出来。</p><p id="2aa9" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">同时，在Flutter中，当容器widget更新，传递给子widget的数据属性发生变化时，这个StatefulWidget的<code class="du kz la lb lc b">State.didUpdateWidget</code>就会被触发。因此调用it中的<code class="du kz la lb lc b">setOption</code>将通知Echarts更新图表。这使得flutter_echarts像一个简单的无状态小部件一样易于使用。</p><p id="3f82" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">双向通信</strong></p><p id="bbcb" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">图表和外部程序之间的通信是非常必要的。在flutter_echarts中，JavaScript和Dart的通信原理就像父子小部件一样:“道具向下，事件向上”。</p><p id="5a82" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">所有来自外部的设置和命令都通过<code class="du kz la lb lc b">option</code>和<code class="du kz la lb lc b">extraScript</code>以JavaScript代码串的形式传递给chart。这些代码将由WebView执行；另一方面，WebView内部的事件通过JavascriptChannel发送，并由onMessage函数处理。这是内部JavaScript和外部Dart之间的双向通信。</p><p id="c114" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">可配置扩展</strong></p><p id="55be" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">Echarts有各种<a class="ae js" href="https://echarts.apache.org/en/download-extension.html" rel="noopener ugc nofollow" target="_blank">扩展</a>，包括图表、地图和WebGL。在web上，我们可以将它们作为脚本文件导入，以扩展Echarts的功能。为了开箱即用，flutter_echarts嵌入了最新版本的echarts脚本，无需额外导入。同时，我们为用户公开了一个<code class="du kz la lb lc b">extensions</code>属性，以包含任何需要的脚本。<code class="du kz la lb lc b">extensions</code>是字符串列表，用户可以直接将脚本字符串复制到源代码中，避免了文件读取和复杂的资产目录。</p><h1 id="c690" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">小部件属性</h1><p id="46b2" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je jt kw jh ji ju kx jl jm jv ky jp jq jr hb bi translated">在封装小部件时，易用性通常比完整性更重要。它应该能够让所有级别的开发人员开箱即用。Echarts it self的设计以易用性为原则，尽量把所有配置都放在<code class="du kz la lb lc b">option</code> ( <a class="ae js" href="http://www.cad.zju.edu.cn/home/vagblog/VAG_Work/echarts.pdf" rel="noopener ugc nofollow" target="_blank">细节在本文</a>)。所以flutter_echarts也简化了小部件属性:</p><p id="3c34" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">选项</strong></p><p id="b49c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><em class="iv">字符串</em></p><p id="91b9" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">字符串形式的图表的JavaScript Echarts选项。echarts主要由该属性配置。您可以使用dart:convert中的<code class="du kz la lb lc b">jsonEncode()</code>函数来转换dart对象形式的数据:</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="5960" class="ll jx hi lc b fi lm ln l lo lp">source: ${jsonEncode(_data1)},</span></pre><p id="a6ad" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">因为JavaScript没有<code class="du kz la lb lc b">'''</code>，所以可以使用这个操作符来减少配额的一些转义符:</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="1825" class="ll jx hi lc b fi lm ln l lo lp">Echarts(<br/>  option: '''<br/>  <br/>    // option string<br/>    <br/>  ''',<br/>),</span></pre><p id="a6bb" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">脚本外</strong></p><p id="de69" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><em class="iv">字符串</em></p><p id="9a43" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">将在<code class="du kz la lb lc b">Echarts.init()</code>之后和任何<code class="du kz la lb lc b">chart.setOption()</code>之前执行的JavaScript。这个小部件已经构建了一个名为<code class="du kz la lb lc b">Messager</code>的javascriptChennel，所以您可以使用这个标识符从JavaScript向Flutter发送消息:</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="8b14" class="ll jx hi lc b fi lm ln l lo lp">extraScript: '''<br/>  chart.on('click', (params) =&gt; {<br/>  if(params.componentType === 'series') {<br/>    Messager.postMessage('anything');<br/>  }<br/>  });<br/>''',</span></pre><p id="a2bd" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">on消息</strong></p><p id="e948" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><em class="iv"> void函数(字符串)</em></p><p id="6917" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">处理<code class="du kz la lb lc b">extraScript</code>中<code class="du kz la lb lc b">Messager.postMessage()</code>发送的消息的功能。</p><p id="5b37" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">扩展</strong></p><p id="2137" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><em class="iv">列表&lt;字符串&gt; </em></p><p id="37f6" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">由Echarts扩展产生的字符串列表，如组件、WebGL、语言等。你可以在这里下载它们<a class="ae js" href="https://echarts.apache.org/en/download-extension.html" rel="noopener ugc nofollow" target="_blank"/>。将它们作为原始字符串插入:</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="ce38" class="ll jx hi lc b fi lm ln l lo lp">const liquidPlugin = r'''<br/>​<br/>  // copy from liquid.min.js<br/>​<br/>''';</span></pre><p id="ad20" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这是flutter_echarts的所有4个属性。诸如何时更新图表之类的其他事情是由内部机制决定的。这使得flutter_echarts看起来就像一个简单的表示性无状态小部件。用户只需要熟悉电子海图，不需要额外的学习。</p><p id="16ec" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">完整的例子在这里:<a class="ae js" href="https://github.com/entronad/flutter_echarts/tree/master/example" rel="noopener ugc nofollow" target="_blank">flutter _ e charts _ example</a>。</p><p id="4810" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">当然，如果你有任何建议或要求，请提出。</p><h1 id="18cd" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">源代码分析</h1><p id="3440" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je jt kw jh ji ju kx jl jm jv ky jp jq jr hb bi translated"><strong class="iw hj">加载html </strong></p><p id="d890" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">对于跨平台开发，由于操作系统的文件系统不同，管理资产目录总是有困难。在React Native中，有时你甚至需要手动将html文件复制到Android目录中。Flutter有一个完整的资产系统，但是它也需要额外的依赖和配置。因此，在源代码中加载本地htmls作为文本字符串是一个好主意，webview_flutter团队也在其“官方示例”中推荐了这种方式。</p><p id="1b98" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">因此，我们在小部件的初始化中将所有模板html、Echarts脚本、扩展脚本和初始代码放入一个字符串中，并将其作为uri源加载:</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="abc7" class="ll jx hi lc b fi lm ln l lo lp">@override<br/>  void initState() {<br/>    super.initState();<br/>    _htmlBase64 = 'data:text/html;base64,' + base64Encode(<br/>      const Utf8Encoder().convert(_getHtml(<br/>        echartsScript,<br/>        widget.extensions ?? [],<br/>        widget.extraScript ?? '',<br/>      ))<br/>    );<br/>    _currentOption = widget.option;<br/>  }<br/>  <br/>  ...<br/>  <br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return WebView(<br/>      initialUrl: _htmlBase64,<br/>      <br/>      ...<br/>    );<br/>  }</span></pre><p id="2512" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">注意，在uri字符串中，有一些有限的字符，所以我们将字符串编码为Base64。</p><p id="e0cc" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">有一个提示:JavaScript没有<code class="du kz la lb lc b">'''</code>，所以我们可以用它包装我们的JavaScript字符串，以减少一些逃避的工作。</p><p id="5318" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">更新图表</strong></p><p id="3e18" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">反应式更新的基本机制是调用State.didUpdateWidget钩子中的<code class="du kz la lb lc b">setOption</code>来通知图表更新:</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="e69d" class="ll jx hi lc b fi lm ln l lo lp">void update(String preOption) async {<br/>    _currentOption = widget.option;<br/>    if (_currentOption != preOption) {<br/>      await _controller?.evaluateJavascript('''<br/>        chart &amp;&amp; chart.setOption($_currentOption, true);<br/>      ''');<br/>    }<br/>  }<br/>​<br/>  @override<br/>  void didUpdateWidget(Echarts oldWidget) {<br/>    super.didUpdateWidget(oldWidget);<br/>    update(oldWidget.option);<br/>  }</span></pre><p id="efa1" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">最麻烦的部分是小部件的初始化。</p><p id="ad7a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">我们知道WebView中html的加载和数据的获取都是异步的，我们不知道哪一个会更早完成。WebView初始化的生命周期顺序是:</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="4a8f" class="ll jx hi lc b fi lm ln l lo lp">onWebViewCreated --&gt; loading html --&gt; onPageFinished</span></pre><p id="d000" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">而WebViewController只能在onWebViewCreated中访问。换句话说，当widgetd获得一个WebViewController时，我们无法判断html是否已经被加载，所以在<code class="du kz la lb lc b">didUpdateWidget</code>中，我们无法通过测试WebViewController来判断它是否准备好更新。</p><p id="a757" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">我们的解决方案是将“数据属性改变触发图表更新”分解为两个步骤:“数据属性改变导致_currentOption改变”和“根据_currentOption更新图表”，这确保任何数据都被记录，甚至在加载html之前。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="4c6e" class="ll jx hi lc b fi lm ln l lo lp">String _currentOption;<br/>  <br/>  void init() async {<br/>    await _controller?.evaluateJavascript('''<br/>      chart.setOption($_currentOption, true);<br/>    ''');<br/>  }<br/>​<br/>  void update(String preOption) async {<br/>    _currentOption = widget.option;<br/>    ...<br/>  }<br/>  <br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return WebView(<br/>      ...<br/>      onPageFinished: (String url) {<br/>        init();<br/>      },<br/>      ...<br/>    );<br/>  }</span></pre><p id="2a65" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">消息通道</strong></p><p id="5e02" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">webview_flutter提供了一个javascriptChannels属性来设置多个命名通道。但是考虑到不了解webview_flutter的用户，flutter_echarts并没有暴露这个属性。相反，我们只构建了一个名为“Messager”的通道:</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="df45" class="ll jx hi lc b fi lm ln l lo lp">@override<br/>  Widget build(BuildContext context) {<br/>    return WebView(<br/>      ...<br/>      javascriptChannels: &lt;JavascriptChannel&gt;[<br/>        JavascriptChannel(<br/>          name: 'Messager',<br/>          onMessageReceived: (JavascriptMessage javascriptMessage) {<br/>            widget?.onMessage(javascriptMessage.message);<br/>          }<br/>        ),<br/>      ].toSet(),<br/>    );<br/>  }</span></pre><p id="a933" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">如果需要发送多种类型的事件，用户可以创建类似redux:</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="12bb" class="ll jx hi lc b fi lm ln l lo lp">chart.on('click', (params) =&gt; {<br/>  if(params.componentType === 'series') {<br/>    Messager.postMessage(JSON.stringify({<br/>      type: 'select',<br/>      payload: params.dataIndex,<br/>    }));<br/>  }<br/>});</span></pre></div></div>    
</body>
</html>