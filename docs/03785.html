<html>
<head>
<title>Adding resolver specific auth for GraphQL API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为GraphQL API添加特定于解析程序的授权</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/adding-resolver-specific-auth-for-graphql-api-fbbc348a5ccb?source=collection_archive---------22-----------------------#2020-02-18">https://medium.com/analytics-vidhya/adding-resolver-specific-auth-for-graphql-api-fbbc348a5ccb?source=collection_archive---------22-----------------------#2020-02-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="69eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用Ariadne GraphQL作为FastAPI应用程序的子应用程序，你会在这里找到完整的代码<a class="ae jd" href="https://github.com/zero-shubham/friteup-graphql-api" rel="noopener ugc nofollow" target="_blank">https://github.com/zero-shubham/friteup-graphql-api</a></p><p id="8aab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，使用RestAPI时，我们会限制端点，但是使用GraphQL APIs时，我们只能向一个端点发出请求。现在，限制这个单个端点(在本例中是`/graphql `)很简单，但是如果您不希望这样，而是希望限制特定的解析器(返回对查询和变异的响应的函数)呢？<br/>将尝试回答这个问题，在此之前，让我们先了解一下我们应用程序的当前设置。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/1492e44b23061a6592c1434cf527ee9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/0*KhKWv5TV16_rdLFd"/></div></figure><p id="6f64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在尝试回答我们的问题，下一个合乎逻辑的步骤将是在我们的子应用程序中添加身份验证。我们将在响应cookie中添加一个JWT令牌，这将只保护cookie。</p><p id="0929" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们将添加一个具有类似代码的登录解析器，如下所示—<a class="ae jd" href="https://pastebin.com/UqEhtF1T" rel="noopener ugc nofollow" target="_blank">https://pastebin.com/UqEhtF1T</a><br/>检查是否存在这样的用户，匹配密码，如果密码匹配，通过将令牌作为cookie添加到响应来验证用户。这似乎已经完成，也是一个看似合理的解决方案，但当你尝试这样做时，它将不起作用，我们的GraphQL应用程序将抛出一个错误，指出响应与指定的模式不匹配。</p><p id="ae0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的GraphQL应用程序期望字典的键与定义的模式的键相同，但当我们返回一个响应对象时，却返回了许多键。所有的头文件和cookies都在那里，将它们添加到模式中没有意义。所以，目前的情况似乎是-</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jm"><img src="../Images/b12081ecaff4c73315592de2c5f2e592.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*pecix6EPJQYE7_Kp"/></div></figure><p id="5f07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将cookie添加到响应的唯一方法是，如果它是在GraphQL子应用程序响应之后添加的，那么从技术上讲，FastAPI应用程序会将令牌添加到响应cookie中。</p><p id="1442" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们需要将这一点传达给FastAPI，但是如何传达呢？肯定使用中间件和装饰器(高阶函数)。</p><p id="65ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们在任何时候都在使用ASGI服务器，应用程序实例可能会处理多个请求，所以我们在提出解决方案时必须考虑这一点。我能想到的最佳解决方案是维护一个请求及其对应令牌的字典，稍后在发送回响应时会用到它。</p><p id="a70d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，想象一下现在的场景应该是这样的-</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es jn"><img src="../Images/fa0c879f7162c2581d17ed4ddb1f6822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uhm4qNEkUjNvwua9"/></div></div></figure><p id="7cc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你可以参考<a class="ae jd" href="https://github.com/zero-shubham/friteup-graphql-api/blob/master/friteup/application.py" rel="noopener ugc nofollow" target="_blank"> application.py </a>，我使用了不同的中间件，这样就可以将关注点分开。顾名思义,“cookie_set”中间件做的是后者，即检查请求id(分配给每个请求对象的UUID ),是否有任何令牌，如果有，就将其添加到响应中。另一个中间件“BasicAuthBackend”检查每个请求中是否有带有令牌的cookie标题“Authorization ”,用它来验证请求。还要向请求对象添加请求id，并将这些请求id和令牌添加到为每个请求维护令牌的字典中。</p><p id="0ac1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你不明白为什么我们需要为此维护一个字典，因为我们必须在多个函数调用中使用这个字典。例如，在“登录”解析器中，请求对象中不存在令牌，因此这个解析器函数将使用请求id为该字典分配一个令牌。参考检查<a class="ae jd" href="https://github.com/zero-shubham/friteup-graphql-api/blob/master/friteup/resolvers/user.py" rel="noopener ugc nofollow" target="_blank">解析器/用户. py </a></p><p id="8d10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你仔细观察，我在这里还使用了一个装饰符“authentication_required ”,如果你熟悉Flask应用程序，这类似于jwt_required。参考这个<a class="ae jd" href="https://github.com/zero-shubham/friteup-graphql-api/blob/master/friteup/middlewares/authentication.py" rel="noopener ugc nofollow" target="_blank"> middleware.py </a>文件，你会在那里找到那个高阶函数。因此，每当我们在任何解析器函数之前添加decorator时，就会调用这个函数，如果请求没有通过验证，它就会返回，而不会调用解析器函数。</p><p id="08d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样，我可能无法解释这一切。因此，请随意提出您的疑问，甚至任何建议，这将使整个设置比它更简单。谢谢！</p></div></div>    
</body>
</html>