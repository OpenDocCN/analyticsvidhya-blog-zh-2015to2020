<html>
<head>
<title>How to use NASA open access data to find worldwide populations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用NASA开放存取数据查找全球人口</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-use-nasa-open-access-data-to-find-worldwide-populations-230d19da5763?source=collection_archive---------12-----------------------#2020-01-16">https://medium.com/analytics-vidhya/how-to-use-nasa-open-access-data-to-find-worldwide-populations-230d19da5763?source=collection_archive---------12-----------------------#2020-01-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="2e64" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">许多美国机构(以及私人公司)在互联网上有大量的开放存取数据，通过正确的工具，我们能够探索这些信息。在本文中，我们将重点关注包含人口信息的地理空间数据和光栅图形。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jk"><img src="../Images/589aa94f32802c41e183155585ea3efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJ2xGsRx_Ogr5U6mEP8oTg.jpeg"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">图片来源:美国宇航局</figcaption></figure><p id="e20d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">尽管光栅图像是表示空间数据的一种强有力的方式，但它们经常被误解，主要原因只有一个:它们是3D世界的2D表示。在本文中，我们将使用一个简单的代码示例来指导我们讨论如何处理这些文件。</p><p id="9731" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以在这个GitHub库 中找到我们需要的所有代码。这个repo有一个应用程序，可以获取地图上给定的一个圆圈中的人口(这是一个示例版本，所以它只覆盖了德克萨斯州)。我把它做成了一个网络应用，以利用交互式地图和图像提供商的JavaScript库(我正在使用<a class="ae ka" href="https://leafletjs.com/" rel="noopener ugc nofollow" target="_blank">传单</a>和<a class="ae ka" href="https://www.openstreetmap.org" rel="noopener ugc nofollow" target="_blank">开放街道地图</a>来完成这项工作)。但是所有的数据分析都是在后端使用python完成的。前端发送一个请求，通知圆心及其半径，后端用总人口进行响应。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kb"><img src="../Images/d42643742bb7f791bd1789da4448ec30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uf-xM2SQqkmHG8aclEPvzg.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">应用程序运行:使用交互式地图工具查找人口。</figcaption></figure><p id="7293" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所有的栅格数据都是从<a class="ae ka" href="https://sedac.ciesin.columbia.edu/" rel="noopener ugc nofollow" target="_blank">SEDAC——NASA社会经济数据和应用中心</a>获得的。如果你对这个主题感兴趣，我强烈建议你去他们的网站，探索那里所有可用的数据。他们有许多不同领域的数据，如气候、土地使用、健康、人口、人类足迹等等。他们的大多数数据都可以在GeoTIFF中获得，这是一种以TIFF图像存储地球地理参考信息的特定文件格式。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="ef23" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用地理参考影像</h1><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es la"><img src="../Images/b754a330747966417ae3d04f3f05b16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iH3bUMin-9QErWvU-VRlHA.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">GeoTIFF图片样本(来自<a class="ae ka" href="http://www.wikipedia.com" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="273d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我们必须了解GeoTIFF格式以及如何操作它。基本上，它是一个图像，它的像素映射了一个表面区域，一些元数据描述了它在地球上的位置。每个像素代表一条信息(可能是人口、人口密度、健康保险值等。).它也可以有多层，每层代表一条不同的信息。</p><p id="1b0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">地理空间图书馆有一些非常好的选择，比如<a class="ae ka" href="https://www.osgeo.org/projects/gdal/" rel="noopener ugc nofollow" target="_blank"> GDAL </a>和<a class="ae ka" href="https://rasterio.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> rasterio </a>。你有无数的理由使用它们，主要是为了处理你可能在途中发现的所有<a class="ae ka" href="https://en.wikipedia.org/wiki/Affine_transformation" rel="noopener ugc nofollow" target="_blank">仿射变换</a>。这些转换是将坐标点(纬度和经度)映射到数据图像中所必需的。这里我们将使用rasterio，一个python库来帮助我们进行这类计算。</p><p id="aa63" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以在前面提到的GitHub存储库中找到包含德克萨斯州人口信息的GeoTIFF文件。它是从NASA SEDAC数据库中提取的，并且只包含德克萨斯州的领土，所以它比他们的原始文件要小得多。在进入应用程序代码之前，让我们先玩一会儿rasterio:</p><pre class="jl jm jn jo fd lb lc ld le aw lf bi"><span id="2301" class="lg kd hi lc b fi lh li l lj lk">$ python<br/>&gt;&gt;&gt; import rasterio<br/>&gt;&gt;&gt; dataset = rasterio.open('./texas.tif')<br/>&gt;&gt;&gt; dataset.width<br/>1920<br/>&gt;&gt;&gt; dataset.height<br/>1560</span></pre><p id="704b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这样做，我们打开数据图像并检查文件的大小，它是一个1920列和1560行的矩阵。注意:重要的是要知道这个信息与图像矩阵有关，它不包含映射到图像中的尺寸。要处理图像的大小和位置，我们必须使用仿射:</p><pre class="jl jm jn jo fd lb lc ld le aw lf bi"><span id="d268" class="lg kd hi lc b fi lh li l lj lk">&gt;&gt;&gt; dataset.transform<br/>Affine(0.008333333333333333, 0.0, -108.0,<br/>       0.0, -0.008333333333333333, 37.0)</span></pre><p id="feee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">数据集的<code class="du ll lm ln lc b">transform</code>是一个仿射变换矩阵，它将(行，列)位置中的像素位置映射到(x，y)空间坐标。现在我们知道我们的地图从北纬37度、西经108度开始(减号表示它在地图的左边，也就是西边。我们还可以知道地图的另一个极端点:</p><pre class="jl jm jn jo fd lb lc ld le aw lf bi"><span id="7189" class="lg kd hi lc b fi lh li l lj lk">dataset.transform * (dataset.width, dataset.height)<br/>(-92.0, 24.0)</span></pre><p id="0769" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，它去24N，92W。下图展示了我们正在使用的地图切片:</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lo"><img src="../Images/5d322e38c2c4d23019f13ceceda5bb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bIL8rO2QXTWjxyx8Xs97g.png"/></div></div></figure><p id="9cfd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">简单点说，所有的后端都包含在app.py中，包括<a class="ae ka" href="https://www.palletsprojects.com/p/flask/" rel="noopener ugc nofollow" target="_blank"> Flask </a>微服务和所有的计算。这里我们关注的是地理空间操作，所以我将避免所有关于服务器的讨论。所以，我对从circle_population()函数开始的每一行都进行了注释。</p><pre class="jl jm jn jo fd lb lc ld le aw lf bi"><span id="929d" class="lg kd hi lc b fi lh li l lj lk">#!/usr/bin/env python<br/>from flask import Flask, render_template, make_response, request<br/>from flask_json import FlaskJSON, JsonError, json_response<br/>from flask_cors import CORS<br/>import rasterio<br/>from math import sin, cos, sqrt, atan2, radians, asin, degrees</span><span id="a4bd" class="lg kd hi lc b fi lp li l lj lk">app = Flask(__name__, instance_relative_config=True)<br/>path = 'rasters/texas.tif'<br/>dataset = rasterio.open(path)<br/>band1 = dataset.read(1)<br/>affine = dataset.transform<br/>FlaskJSON(app)<br/>CORS(app)</span><span id="6e01" class="lg kd hi lc b fi lp li l lj lk"><a class="ae ka" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def index():<br/>    return render_template('index.html')</span><span id="c86c" class="lg kd hi lc b fi lp li l lj lk"><a class="ae ka" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/population', methods = ['POST'])<br/>def population():<br/>    if request.method == 'POST':<br/>        try:<br/>            points = str(request.get_json()['data']['points'])<br/>            location = request.get_json()['data']['location']<br/>            longitude = float(location['coordinates'][0])<br/>            latitude = float(location['coordinates'][1])<br/>            radius = float(location['radius'])<br/>            point = (longitude, latitude)<br/>            response = circle_population(point, radius, points)<br/>        except (KeyError, TypeError, ValueError, IndexError):<br/>            return json_response(501)<br/>        return  json_response(data = response, headers_={'X-STATUS': 'ok'})<br/>    else:<br/>        raise JsonError(description='Invalid value.')</span><span id="1312" class="lg kd hi lc b fi lp li l lj lk">def circle_population(point, radius, points):<br/>    # meters to kilometers:<br/>    radius = radius / 1000<br/>    # get the vertices of a square containing the circle:<br/>    vertice1, vertice2 = get_vertices(point, sqrt(2*radius**2))<br/>    # get the population of the circle:<br/>    population, points = get_population(vertice1, vertice2, band1, affine, center = point, radius = radius, points = points)<br/>    # return as a dict (wich will be converted to JSON by Flask):<br/>    response = {<br/>        'population' : population,<br/>        'points' : points,<br/>    }<br/>    return response</span><span id="944c" class="lg kd hi lc b fi lp li l lj lk">def get_vertices(point, distance):<br/>    # get the top left vertice by walking the given distance towards 315 degrees from the center:<br/>    vertice1 = get_destination_point(point, 315, distance)<br/>    # get the bottom right vertice by walking the given distance towards 135 degrees from the center:<br/>    vertice2 = get_destination_point(point, 135, distance)<br/>    # return the vertices:<br/>    return vertice1, vertice2</span><span id="cefb" class="lg kd hi lc b fi lp li l lj lk">def get_destination_point(point, bearing, distance):<br/>    # the earth radius (in km):<br/>    earth_radius = 6373.0<br/>    # transform the angle to radians:<br/>    bearing = radians(bearing)<br/>    # transform the latitude to radians:<br/>    longitude = radians(point[0])<br/>    # transform the longitude to radians:<br/>    latitude = radians(point[1])<br/>    # move the given distance towards the angle in the y axis:<br/>    dest_latitude  = asin(sin(latitude)*cos(distance/earth_radius) +<br/>                    cos(latitude)*sin(distance/earth_radius)*cos(bearing))<br/>    # move the given distance towards the angle in the x axis:<br/>    dest_longitude = longitude + atan2(sin(bearing)*sin(distance/earth_radius)*cos(latitude),<br/>                    cos(distance/earth_radius)-sin(latitude)*sin(dest_latitude))<br/>    # return the vertice in degrees (as they are lat and lgd):<br/>    return (degrees(dest_longitude), degrees(dest_latitude))</span><span id="ba21" class="lg kd hi lc b fi lp li l lj lk">def distance(point1, point2):<br/>    R = 6373.0<br/>    # transform all the angles to radians: <br/>    lat1 = radians(point1[1])<br/>    lon1 = radians(point1[0])<br/>    lat2 = radians(point2[1])<br/>    lon2 = radians(point2[0])<br/>    # calculate the difference between the latitudes:<br/>    dlon = lon2 - lon1<br/>    # calculate the difference between the longitudes:<br/>    dlat = lat2 - lat1<br/>    # using the ‘haversine’ formula:<br/>    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2<br/>    c = 2 * atan2(sqrt(a), sqrt(1 - a))<br/>    return R * c</span><span id="b284" class="lg kd hi lc b fi lp li l lj lk">def get_population(vertice1, vertice2, band, affine, center = False, radius = False, points = False):<br/>    # get the position (x,y) in the image for the first vertice:<br/>    vertice1_xy = rasterio.transform.rowcol(affine, vertice1[0], vertice1[1])<br/>    # get the position (x,y) in the image for the second vertice:<br/>    vertice2_xy = rasterio.transform.rowcol(affine, vertice2[0], vertice2[1])<br/>    # start a counter for the population:<br/>    population = 0<br/>    # create an empty array for the data points <br/>    pointsArray = []<br/>    # for all pixels between those vertices:<br/>    for i in range(vertice1_xy[0], vertice2_xy[0]+1):<br/>        for j in range(vertice1_xy[1], vertice2_xy[1]+1):<br/>            # get the value of the the pixel <br/>            new_point = rasterio.transform.xy(affine , i, j, offset='center')<br/>            # if the the distance is less than the radius:<br/>            if distance(center, new_point) &lt;= radius:<br/>                # increase the population with the value of the pixel:<br/>                population += band[i][j]<br/>                # if the data points were requested:<br/>                if points == 'True':<br/>                    # append them to the array:<br/>                    pointsArray.append(new_point)<br/>    return population, pointsArray</span></pre><p id="234f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码真的很简单，也很容易理解(加上注释就更好了)。此外，我在下面包含了一个. gif动画来说明代码的操作。它确实有直截了当的执行，但如果您有任何疑问或意见，请随时与我联系！</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lq"><img src="../Images/3e3b02d33e0ce422f2233f20d140ca20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0821he6WtiZx6_tcL4_2XQ.gif"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">所用算法的动画。它主要是说明性的，所以它没有如实地表示代码的执行(但是足够接近)。</figcaption></figure><p id="2bba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可能已经注意到了，这种方法并不精确地计算圆圈内居民的数量。下图向我们展示了我使用矩阵中的信息假设的圆形人口。给或拿，这将是一个相当公平的近似值。顺便说一句，即使你改变形状(例如，变成正方形…)，这也只是一个近似值，因为形状的界限在大多数情况下可能与GeoTiff像素不匹配。这里使用的数据是以30角秒(赤道上约1公里)分辨率生成的全球栅格，这是美国宇航局网站上可用的最大分辨率。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lr"><img src="../Images/bf1e69efd2bff7638a78d4fec4a425a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhtKO93kpu22kY7zKyQAKA.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">算法产生的近似值。</figcaption></figure><p id="d98c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是我们能力的一个简单例子。使用强大的工具和正确的数据(都可以在网上找到)，你可以做真正酷的事情。我希望您对这个例子感到兴奋，并尝试这些工具。</p></div></div>    
</body>
</html>