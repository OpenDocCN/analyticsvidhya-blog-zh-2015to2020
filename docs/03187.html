<html>
<head>
<title>Epidemic spreading of information and ideas. Simulation on a Square Grid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">信息和思想的广泛传播。正方形网格上的模拟</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/epidemic-spreading-of-information-and-ideas-simulation-on-a-square-grid-9825a91c37b7?source=collection_archive---------22-----------------------#2020-01-19">https://medium.com/analytics-vidhya/epidemic-spreading-of-information-and-ideas-simulation-on-a-square-grid-9825a91c37b7?source=collection_archive---------22-----------------------#2020-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="53d3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">传播问题的流行病学方法</strong></p><p id="6143" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了推广一个想法、一个产品或一项服务的信息，政府、机构和公司通常需要一个在网络上有效传播的策略；必须根据他们的具体需要、目标和手段来设计和建造。由于信息和流行病传播过程的相似性，大多数关于信息传播的研究(市场营销、广告、科学出版物、政治项目……)都是受流行病模型的启发。</p><p id="a9a2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">常用的流行病模型之一是<em class="jk">感染在正方形网格上的传播。</em>在《数学的艺术》(2006)一书中，béla bollo bas提出并分析了在N×N正方形网格(N=12)上的流行病传播问题。</p><p id="6312" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这种传播概念在几年后变得如此流行，以至于世界上最著名的两家报纸:“纽约时报”(美国)和“卫报”(英国)分别在2013年<a class="ae jl" href="https://wordplay.blogs.nytimes.com/2013/07/08/bollobas/" rel="noopener ugc nofollow" target="_blank">和2017年</a><a class="ae jl" href="https://www.theguardian.com/science/2017/mar/13/did-you-solve-it-pi-day-puzzles-that-will-leave-you-pie-eyed" rel="noopener ugc nofollow" target="_blank">的“谜题版”中提出了解决bollo bas问题的方法。</a></p><p id="2ea8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在一个NxN 2D网格(N=12，见图1)中，一些(黑色)方块，比如n=20，被感染，而(N -n)个方块是健康的(白色)。在每个污染步骤，新的被污染的一代出现，并且只有当一个健康的方块有一个以上被感染的正交邻居(灰色方块)时，它才会被感染。没有对感染免疫的方块，被感染的方块永远被感染。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es jm"><img src="../Images/5fcbd7e041a6bd157c16b6486cdd3df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*dh38OGsKXRQPKkPA7LjlpA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图一。在NxN网格中随机分布n=20个受感染(黑色)方块(N=12)。受污染的(灰色)方块是指有一个以上受感染邻居的方块。</figcaption></figure><p id="d2a0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最初的bollo bas问题问，最初被感染的方块的最小数量x是多少，它能在整个网格上传播感染？在数值模拟的帮助下，我们在这篇文章中讨论了最小数量x，以及如何在网格上分配x个正方形，以确保整个网格的感染。</p><p id="d092" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jk"> 1-随机分布</em></p><p id="d237" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们提出的第一个解决方案是如图1所示的随机分布。从算法的角度来看，这是最便宜的解决方案，因为我们不需要额外的计算来寻找哪些方块有影响，哪些没有。但是，如果感染方格的初始数量是随机的，并且不能保证感染整个格子<em class="jk">。</em></p><p id="795f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jk"> 2-对角线分布</em></p><p id="ca85" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对角线分布代表bollo bas解。如果我们把x=N=12个方块沿主对角线分布(图-2)，那么所有与主对角线相邻的方块沿两条超对角线分布，都有不止一个被感染的邻居，成为全部被污染。他们是第一代被污染的人。就周长/感染面积的比例而言，这种分布可能是最高的。一旦被感染，它们会污染它们健康的邻居，如此类推，直到最后一个方块，之后</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es jm"><img src="../Images/a23885c9535f331a5346c235c79eb0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*_cq6mxSnJSsRw-PzPyydSA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图二。N×N网格(N=12)中n=N个染毒(黑)方块的对角线分布。</figcaption></figure><p id="279a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">N-1步污染。对角线感染是感染整个网格最快的方式。</p><p id="c810" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3- <em class="jk">双边分配</em></p><p id="e7f2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">图3所示的双边分布是另一种分布，x=N =12平方。在2(N-1)-1步污染后，这种分布将感染扩散到整个网格。虽然它的感染区域周长等于对角线感染的周长(22个方块)，但它的传染能力较弱，因为与对角线分布的第一代22个方块相比，它只能污染12个方块(第一代污染)。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es jm"><img src="../Images/b44bc3015ab0a59f76b9c336718a48bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*RrPMeRpu7UUiDse2LM5h0Q.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图三。<em class="jy">NxN网格(N=12)中n=N个感染(黑色)方块的双边</em>分布。</figcaption></figure><p id="cc96" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这三种分布之间的简单比较表明，就“感染速度”而言，对角线分布是最有效的选择，因为它只需要整个网格感染的N-1步污染。</p><p id="91d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">讨论</strong></p><p id="4e74" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从bollo bas问题看来，流行病传播是一种“临界现象”,因为它只有在受感染的方块达到临界浓度时才会发生。在对角线感染的情况下，如果感染方块的初始数目x小于N，那么总传播将是不可达的。</p><p id="f1c1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">似乎感染区域的周长不会随着感染的增长而增加。bollo bas问题的模拟(参见模拟部分)表明，随着感染的增长，感染域的周长会减小，直到达到整个网格感染。网格上的“感染速度”取决于受感染方块的初始数量，但也取决于它们在网格中的几何位置。</p><p id="1e94" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> Python模拟传播</strong></p><p id="dc21" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本节中，我们编写python程序来模拟2D正方形网格上的流行病传播过程。我们在BinderHub的帮助下，把它变成了交互式笔记本(Jupyter notebook)。为此，我们首先在<a class="ae jl" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"><em class="jk">【GitHub】</em></a>中创建<a class="ae jl" href="https://github.com/xsources/Epidemic-Speading-of-Information-and-Ideas" rel="noopener ugc nofollow" target="_blank"> <em class="jk">【传播信息与观念的传播</em> </a>知识库，在上面我们写下“<em class="jk"> full.ipyn </em>”，在一个个方格的网格里，传播过程的互动笔记本。</p><p id="56c1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们首先展示一些jupyter-python代码所依赖的算法元素。我们从导入必要的库和小部件(交互工具)开始(步骤1)</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="jz ka l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">第一步。导入必要的库</figcaption></figure><p id="e19f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过使用python“networkx”库，我们创建(步骤2)与2D正方形网格(边数N=20)相关联的图g。我们将<em class="jk"> nng </em>定义为节点网格列表，将<em class="jk"> ninf </em>定义为受感染节点的数量。我们还定义了<em class="jk">感染</em>，一个定义感染方块分布的函数:随机或对角线。默认情况下，我们的代码显示受感染方块的两边分布。对于随机或对角分布，只需<em class="jk">取消相关程序块的</em>注释即可。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="jz ka l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">第二步。定义一个图g，它与2D网格和受感染节点的“<em class="jy">受感染</em>”分布相关联。</figcaption></figure><p id="5833" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们定义(Step-3) <em class="jk"> spreading() </em>，从第n步到第n+1步传播感染的函数。这个函数创建一个新的图<em class="jk"> Ginf </em>，其中存储了所有被感染的节点。它还计算<em class="jk"> allneighbors </em>函数来查找被感染方块的所有邻居。<em class="jk">neighbor 2 times</em>是另一个新函数，它计算哪些节点不止一次是受感染方块的邻居。我们还需要计算perim函数来计算整个感染区域的周长。在这段代码的最后，我们创建了<em class="jk"> data_saver </em>。<em class="jk"> mat </em>，一个. mat文件，存储与感染区域周边相关的数据。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="jz ka l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">第三步。扩展函数的定义</figcaption></figure><p id="180e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们程序的最后(步骤4)，我们设置了窗口小部件功能:显示新的被污染的方块并重置当前操作。</p><figure class="jn jo jp jq fd jr"><div class="bz dy l di"><div class="jz ka l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">第四步。设置按钮的点击功能:“下一次展开”和“复位”</figcaption></figure><p id="bd7e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">疫情传播过程<a class="ae jl" href="https://github.com/xsources/Epidemic-Speading-of-Information-and-Ideas/blob/master/full.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> full.ipyn </em> </a>的完整jupyter-notebook程序现已准备好在<a class="ae jl" href="http://Docker image" rel="noopener ugc nofollow" target="_blank"> BinderHub </a>平台上运行。要运行它，点击显示在<a class="ae jl" href="https://github.com/xsources/Epidemic-Speading-of-Information-and-Ideas" rel="noopener ugc nofollow" target="_blank">流行病传播信息和想法</a>库的README.md文件上的“启动活页夹标志”(图3)。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es kb"><img src="../Images/b879f1c50536e79db88eded3b1f0f967.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*GEKS9wVWYIwIZSidIligpA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图3</figcaption></figure><p id="9173" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在检查了存储库文件(图4)之后，BinderHub将用户重定向到Jupyter服务器(图5 ),我们的程序将在那里运行。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es kc"><img src="../Images/c47e1b4905615ff95af82ad0c24f2658.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*MM2o4_cdg8C7oQhfTOz-Bg.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图4</figcaption></figure><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es kd"><img src="../Images/89483f07ceddc1c0ecc9f266d5850895.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*TNVS0KZMxU6ZnjP2pD63RQ.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图5</figcaption></figure><p id="1ac6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">点击展开程序之一:<em class="jk"> full.ipynb </em>或<em class="jk">spreading _ algorithm _ and _ code . ipynb</em>运行(图6)展开过程。如果您选择第二个程序，您必须逐个单元格地运行它(通过单击run按钮运行每个单元格，直到程序结束)。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es ke"><img src="../Images/29b93dbdff8ca3dd007def3d55edd096.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*NWxM0VukFhI8gxzAW5PP7g.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图6</figcaption></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="0b18" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">[1]超对角线条目是直接位于主对角线右上方的对角线</p><p id="1035" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">[2] <a class="ae jl" href="http://Docker image" rel="noopener ugc nofollow" target="_blank"> BinderHub </a>从Git存储库中构建并注册Docker映像</p></div></div>    
</body>
</html>