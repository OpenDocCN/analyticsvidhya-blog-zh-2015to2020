# 证明停机问题是不可判定的(对于外行程序员)

> 原文：<https://medium.com/analytics-vidhya/proving-halting-problem-is-undecidable-for-layman-programmers-354bc147c760?source=collection_archive---------7----------------------->

![](img/a3d9684015bcd5b75277a82067580196.png)

马库斯·斯皮斯克在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

有些问题在计算上是不可能的。这些属于不可判定的问题。对于一个不可判定的问题，不管算法的运行时间如何，没有算法可以在每个输入上解决问题。你运行多项式时间，指数时间；没有算法可以解决每一个输入。

1936 年，伟大的阿兰·图灵证明了停机问题是不可判定的。我们现在来看看这个结果的想法。
图灵在 1936 年的这篇论文[引入了我们现在称之为图灵机的概念。图灵证明了停机问题在图灵机上是不可判定的，而图灵机拥有传统计算机的能力。按照惯例，我们排除了量子计算机之类的东西。
后来，许多其他问题被证明是不可判定的，但是停机问题非常好，所以我们将深入证明。](https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf)

## 定义停机问题

**输入** :
停机问题的输入是一个程序 **P** ，该程序 **P** 有一个输入 **I** 。现在这个程序是怎么给你的？嗯，我们可以把它限制在任何我们想要的语言。我们可以说是用伪代码写的，可以说是用 golang，C，Python，或者任何任意语言写的。

**输出:**
现在的输出有什么磕磕绊绊的问题？嗯，想想编译器的基本任务。给定一个程序和一个输入，我们想弄清楚这个程序是终止于这个输入还是有一个无限循环。

这就是停机问题的任务，要弄清楚这个特定输入 **I** 上的程序 **P** 是永远运行，还是永远终止。
所以如果输入 **I** 上的程序 **P** 曾经终止，那么它最终停止，然后我们输出**真值**。
我们并不试图弄清楚它是否正确运行，它是否对这个输入给出了正确的解决方案。
我们只是在问当我们在输入 **I** 上运行程序 **P** 时，它是否曾经停止过。
另一方面，如果输入 **I** 上的程序 **P** 从未终止，我们输出 **false** 。换句话说，它有一个无限循环。

## 例子

让我们看一个暂停问题的例子。

```
func P(x int32) {
 for x%2 == 1 {
   x += 2
 }
}
```

这个简单的程序是用 golang 编写的。程序 **P** 由一个输入变量 **x** 组成，它由一个 while 循环组成(golang 中的 while 循环就是这样)。while 循环检查 **x** 是否为奇数。
如果 **x** 是奇数，那么它会在 **x** 上加 2 并重复。并且一直持续到 **x** 为偶数。

现在让我们看看这个程序在输入 **x=5** 上的 **P** 。对于这个简单的程序，很容易看到会发生什么。
**x** 从 5 开始，然后就是 7，9，11 等等。
**x** 永远是奇数。所以程序永远不会停止，因为这将是一个无限循环。当然，这是假设无限内存的情况下。所以没有溢出之类的东西。

因此，如果我们考虑用这一对输入来暂停，编程 **P** 和这个输入 **x=5** 。那么这个程序在这个特定的输入上有一个无限循环。因此， **halting(P，5)** 为 **false** 。
同样**停止(P，2)** 为**真**。

# 定理:停机问题是不可判定的

## 我们怎么能希望证明这个定理呢？

想出一个没有算法能解决程序停机问题的程序是非常困难的。更容易推理的是，对于每一个算法，都有一个该算法失败的程序。

所以我们证明这个定理的方法是通过矛盾。让我们假设我们有一个算法可以解决每个输入的停顿问题。如果我们可以构建一个输入，这个算法是不正确的，那么这将与我们的假设相矛盾。因此，这将证明定理。

## 定义此算法的签名

现在让我们给这个算法起个名字。因为该算法确定特定输入上的特定程序是否终止。所以我们把这个算法叫做 **doesTerminate** 。

```
func doesTerminate(P, I) bool
```

**doesTerminate** 带一对输入， **P** 和 **I** 。 **P** 是程序， **I** 是程序 **P** 的输入， **doesTerminate** 输出**真**或**假**取决于该程序 **P** 在该特定输入 **I** 上是否最终终止。

如果它最终终止，那么输出为真。
如果它有一个无限循环，那么输出是假的。我们假设**终止**是正确的。它解决了每个程序 **P** 和每个输入 **I** 的暂停问题。

## 这个计划

现在我们要构造一个程序 **Q** 和一个输入 **J** ，并表明当我们在这个输入对 **(Q，J)** 上运行 **doesTerminate** 时，它的输出是不正确的。由于 **doesTerminate** 在这一对输入上是不正确的，因此 **doesTerminate** 并不能解决每一个输入上的停顿问题。
所以这就给了我们矛盾，因此，这就通过矛盾完成了证明。

## 邪恶天才(前方重递归)

现在我们如何希望构建这个程序呢？嗯，重要的一点是我们假设这个程序存在，**不终止**。所以我们可以使用这个算法，在我们的新程序 **Q** 中**不终止**作为一个子程序。
现在我们对**终止**的内部工作方式一无所知，所以我们必须把它当作一个黑盒，因此我们可以把它当作一个子程序。

所以考虑下面这个邪恶的程序，它是邪恶的，因为**并没有终止**算法，我们假设它在这个程序上会失败。我们现在要定义的这个新程序，姑且称之为矛盾的。

```
func Contradictory(J) {
 for doesTerminate(J, J) {}
}
```

**矛盾**有一个输入 **J** 。
矛盾**的第一行**是 while 循环。我们所做的是在这个输入对( **J，J)** 上运行 **doesTerminate** 。因此 **J** 是一个程序，而 **J** 也是程序 **J** 的输入。
所以我们使用**矛盾**程序的这个输入 **J** 作为程序 **P** 和 **doesTerminate** 算法的输入 **I** 。
现在**终止**返回**真**或**假**。所以两种可能性是

1.如果**不终止**返回**真值**，那么程序将进入无限循环。
2。如果**没有终止**返回**假**则程序退出。

让我们再次详细说明这个简单程序中发生了什么。
我们正在运行 **doesTerminate(J，J)** 。那有什么用？
对程序 **J(J)** 求值，如果程序 **J(J)** 终止，则 **doesTerminate** 返回 true。它最终停止。
如果 **J(J)** 没有终止，则返回**假**。即它有一个无限循环。

总结一下

a)如果程序 **J(J)** 终止，那么 **doesTerminate(J，J)** 将返回 **true** 并且程序**矛盾(J)** 永不终止。它进入了一个无限循环。

b)如果程序 **J(J)** 永不终止，那么它有一个无限循环。然后 **doesTerminate(J，J)** 将返回 **false** 并且我们的程序**矛盾(J)** 马上退出，因此它终止。

## 悖论

现在，我们需要推导一个矛盾。我们所做的是我们设置输入 **J** 为这个程序**矛盾**我们刚刚定义的。
所以**矛盾**就是这个短短的一行程序，我们用它作为**矛盾**本身的输入。
即**J =矛盾**

现在的问题是，程序**矛盾(矛盾)**，终止还是不终止？有两种可能，要么它终止，要么它有一个无限循环。让我们考虑这两种可能性。

**1)矛盾(矛盾)终止**
假设程序**矛盾**以自身为输入时确实终止。
我们已经看到，如果 **J(J)** 终止，那么**矛盾(J)** 永远不会终止，因为它进入了这个无限循环。
所以插上**J =矛盾**，
我们就得到了**矛盾**永不终止。

所以如果程序**矛盾(矛盾)**终止，那么**矛盾(矛盾)**永远不会终止。这是一个矛盾。因此，这不可能是事实。

**2)矛盾(interpolative)永不终止** 这种情况下会发生什么？
在这个场景中，当 **J(J)** 永远不会终止时，那么**矛盾(J)** 终止，因为它立即退出程序**矛盾**。
所以插入**J =矛盾**，
如果程序**矛盾**永不终止，那么**矛盾**终止。

还是那句话，我们有矛盾，所以不能这样。

## 结论

由于这两种情况都会导致矛盾，我们最初的假设，即程序**不会终止**来解决每个输入都存在的暂停问题，肯定是不可能的。因此，不存在一个程序可以解决每一个输入的停顿问题。这就完成了定理的证明。