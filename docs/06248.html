<html>
<head>
<title>Dockerizing a REST API in Python Less Than 9 MB and Based on scratch Image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python编写不到9 MB的基于暂存映像的REST API</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dockerizing-a-rest-api-in-python-less-than-9-mb-and-based-on-scratch-image-ef0ee3ad3f0a?source=collection_archive---------3-----------------------#2020-05-16">https://medium.com/analytics-vidhya/dockerizing-a-rest-api-in-python-less-than-9-mb-and-based-on-scratch-image-ef0ee3ad3f0a?source=collection_archive---------3-----------------------#2020-05-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b055d83e14338633ae5ce21b3e382e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GI60nfBj-YQjNmuRtpF0gg.png"/></div></div></figure><p id="892e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为容器图像的包装应用多年来已经相当普遍。在创建容器图像时，例如使用Docker，图像大小在许多情况下变得很重要；由于网络使用，(可能)增加了攻击面、磁盘使用、推拉时间、更长的构建时间……等等。最终图像经常包括许多未使用的组件；比如外壳、操作系统配置文件、库、构建时依赖项。在像Go这样的语言中，很容易创建一个静态链接的可执行文件，并将其包含在一个空映像中，如果可能的话，甚至可以不使用OS。但是当使用Python和在运行时需要虚拟机的语言时，使用一种方法来实现相同的结果并不常见。在本帖中，我们将介绍一种为Python应用程序创建Docker映像的方法，这种方法将小于9 MB，并且基于暂存映像。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/2b18593726b7271984f6b3a1ab75bba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbRy7jLOBgXolKCvT2kuaw.jpeg"/></div></div></figure><p id="99e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">会有更多的优化可能，毋庸置疑。我们正在通过使用一个工具集(我们认为)来达到小于9MB的目标。</p><h1 id="154a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">用Python和Flask为API创建Docker映像</h1><p id="5b3f" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">首先，让我们基于Docker Hub中的Python映像创建一个Docker映像。我们将在上面安装Falcon框架，以及作为应用服务器的Gunicorn。随后，我们将检查图像大小。我们将使用一个带有基本随机整数生成器的回购作为示例。源代码可以从这里获得</p><div class="kw kx ez fb ky kz"><a href="https://github.com/gurayyildirim/rastgelesayi" rel="noopener  ugc nofollow" target="_blank"><div class="la ab dw"><div class="lb ab lc cl cj ld"><h2 class="bd hj fi z dy le ea eb lf ed ef hh bi translated">gurayyildirim/rastgeleSayi</h2><div class="lg l"><h3 class="bd b fi z dy le ea eb lf ed ef dx translated">试用Docker的演示应用程序。通过在…上创建帐户，为gurayyildirim/rastgeleSayi的发展做出贡献</h3></div><div class="lh l"><p class="bd b fp z dy le ea eb lf ed ef dx translated">github.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln io kz"/></div></div></a></div><p id="8403" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，我们将构建的docker文件是(与repo中的版本略有不同):</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="e561" class="lt ju hi lp b fi lu lv l lw lx">FROM python:3</span><span id="8a5b" class="lt ju hi lp b fi ly lv l lw lx">CMD gunicorn -b 0.0.0.0:80 rastgele:api</span><span id="b4a9" class="lt ju hi lp b fi ly lv l lw lx">WORKDIR /code</span><span id="3aa8" class="lt ju hi lp b fi ly lv l lw lx">ADD requirements.txt requirements.txt</span><span id="4ba9" class="lt ju hi lp b fi ly lv l lw lx">RUN pip install -r requirements.txt</span><span id="1651" class="lt ju hi lp b fi ly lv l lw lx">ADD . /code</span></pre><p id="0d8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们构建并查看图像的大小:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="38d8" class="lt ju hi lp b fi lu lv l lw lx">$ git clone <a class="ae lz" href="https://github.com/gurayyildirim/rastgelesayi" rel="noopener ugc nofollow" target="_blank">https://github.com/gurayyildirim/rastgelesayi</a> &amp;&amp; cd rastgelesayi</span><span id="6ade" class="lt ju hi lp b fi ly lv l lw lx"><strong class="lp hj"># edit Dockerfile as above</strong></span><span id="6361" class="lt ju hi lp b fi ly lv l lw lx">$ docker build -t guray/random:0.1 .<br/>... build output is truncated ...</span><span id="6d35" class="lt ju hi lp b fi ly lv l lw lx">$ docker image ls guray/random:0.1</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/cd91979d9bc2332a3212816b1293a878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1LMEYDJfU-L0HPavpJauw.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">Docker中Python容器图像大小的输出</figcaption></figure><p id="a657" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它几乎是1GB，这意味着对于一个小的API，我们有一个成本为1GB的映像，其中包含许多我们甚至一次都没有打开过的文件。</p><p id="51ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这张图片有很多用途。但是对于一个小的API或者很多其他的应用程序；我们希望在不损失功能的情况下缩小图像。</p><h1 id="072f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用Alpine Linux映像</h1><p id="2d0e" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">优化映像大小的第一步是用基于Alpine Linux的映像更改基础映像。这样，我们应该得到更低的图像尺寸。的docker文件在FROM行中有唯一的区别:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="3a2a" class="lt ju hi lp b fi lu lv l lw lx">FROM python:3-alpine</span><span id="a54b" class="lt ju hi lp b fi ly lv l lw lx">CMD gunicorn -b 0.0.0.0:80 rastgele:api</span><span id="14e2" class="lt ju hi lp b fi ly lv l lw lx">WORKDIR /code</span><span id="c143" class="lt ju hi lp b fi ly lv l lw lx">ADD requirements.txt requirements.txt</span><span id="9ba0" class="lt ju hi lp b fi ly lv l lw lx">RUN pip install -r requirements.txt</span><span id="8cf3" class="lt ju hi lp b fi ly lv l lw lx">ADD . /code</span></pre><p id="243d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们再次构建并检查最终的图像大小:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="6a81" class="lt ju hi lp b fi lu lv l lw lx">$ docker build -t guray/random:0.2 .<br/>... build output is truncated ...</span><span id="49b3" class="lt ju hi lp b fi ly lv l lw lx">$ docker image ls guray/random:0.2</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/ad0b576e04ce43f27fbf5b684d84fb9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o12Z6geLVZvhDG455z26Ag.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">基于Alpine Linux的Python Docker图像示例</figcaption></figure><p id="9b15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">人数如预期的那样减少了。现在有用了。但是有一点要记住:Alpine Linux附带的是musl，而不是glibc，后者在许多发行版中都很常见。它有时会导致预构建的二进制文件出现问题，以及其他情况。</p><p id="29be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管如此，它现在已经可以运行了，而且尺寸减小了。我们的应用程序也能够毫无问题地运行，因为Falcon本身是基于纯Python依赖的。</p><h1 id="b56a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">进一步优化</h1><p id="1d9c" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">对我们来说，很明显，沉迷于这种优化可能会导致黑洞，我们很容易发现自己试图获得更多的位。但是，对于我们的应用来说，115MB仍然是一个巨大的数字是可以理解的。</p><p id="c6de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Docker Slim是一个伟大的项目，可以自动查找缩小Docker图像，并试图使其更加安全。让我们在最后一张图片上试试:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="f64e" class="lt ju hi lp b fi lu lv l lw lx">$ docker-slim build --http-probe --expose 80 guray/random:0.2</span><span id="19e6" class="lt ju hi lp b fi ly lv l lw lx">$ docker image ls guray/random.slim</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/f000772168f738c0692b3c8bb3d48fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwoiB7OhsAG3Z_wLB3Kcaw.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">带有用Falcon编写的Python API的精简Docker图像</figcaption></figure><p id="0d08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过Docker Slim的一些魔法，大小已经减少到36MB。这是一个很好的工具，它可以帮你做很多繁重的工作。如果你好奇的话，<a class="ae lz" href="https://github.com/docker-slim/docker-slim#design" rel="noopener ugc nofollow" target="_blank">这里</a>是细节。</p><h1 id="f553" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">进一步优化</h1><p id="a8f6" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">当用户的计算机上可能没有安装Python或任何依赖项时，您可能需要将应用程序分发给用户。在这些时候，我们不能期望每个人都手动安装Python和依赖项，这种情况并不少见。在这些情况下，我们试图为我们的应用程序创建一个包，一个包含Python和其他依赖项的包。</p><p id="f4ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python中有一些工具可以帮助您为应用程序创建可分发的包。本质上，它们将Python二进制文件和依赖项与您的应用程序打包在一起。<strong class="is hj"> Pyinstaller </strong>和Cx_freeze就是其中的两个工具，它们会让我们的生活变得更加轻松。</p><p id="fbc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将坚持使用Pyinstaller。没有什么重要的原因，除了我们发现它比我们经历过的其他东西更容易和直观(我们接受建议)。基本上，你只需向它提供你的应用程序，它就会生成一个目录，其中包含所有需要分发的文件。</p><p id="0bf1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在幕后，它扫描您的应用程序，找到导入的库(从import语句中)并将它们添加到包中，将py文件转换为pyc，等等。它还附带了一些描述特定模块隐式导入的方法(称为<em class="mh">钩子</em>),以免在运行时抛出ImportError错误。还可以创建新的钩子来明确定义应用程序的依赖关系。</p><p id="98e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，Pyinstaller应该为我们的应用程序提供一个更精简的打包版本，因为它没有包含所有的文件/模块，而是只包含过滤/显式使用的文件/模块。关于过程的更多细节，项目的<a class="ae lz" href="https://pyinstaller.readthedocs.io/en/stable/advanced-topics.html" rel="noopener ugc nofollow" target="_blank">文档写得很精彩。</a></p><h2 id="ba0d" class="lt ju hi bd jv mi mj mk jz ml mm mn kd jb mo mp kh jf mq mr kl jj ms mt kp mu bi translated">创建第一个包</h2><p id="f8ae" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">让我们安装Pyinstaller并为我们的示例API创建一个包。因为Pyinstaller从我们的系统中收集模块，所以也应该安装需求(这只是为了戳一下，您应该在最后在一个容器中运行这些):</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="2d10" class="lt ju hi lp b fi lu lv l lw lx">$ pip3 install pyinstaller<br/>... install output is truncated ...</span><span id="984d" class="lt ju hi lp b fi ly lv l lw lx">$ pip3 install -r requirements.txt<br/>... install output is truncated ...</span><span id="25ca" class="lt ju hi lp b fi ly lv l lw lx">$ pyinstaller rastgele.py<br/>... a lot of output describing the process here ...</span></pre><p id="1601" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个过程完成后，<strong class="is hj"> dist </strong>目录将包含我们的文件作为一个目录。我们可以将这个目录包含在一个映像中，然后就可以开始了。让我们看看这个目录的大小:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="3435" class="lt ju hi lp b fi lu lv l lw lx">$ du -sh dist/rastgele/</span><span id="8d55" class="lt ju hi lp b fi ly lv l lw lx">15M dist/rastgele/</span></pre><p id="3d6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们的文件要花15MB。如果需要，我们可以压缩这个目录，使用tar归档并使用gzip进行压缩，结果是66m:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="5032" class="lt ju hi lp b fi lu lv l lw lx">$ tar czf rastgele.tar.gz dist/rastgele/<br/>$ ls -lh rastgele.tar.gz</span><span id="35f7" class="lt ju hi lp b fi ly lv l lw lx">-rw-r--r-- 1 x x 6.6M May 15 11:07 <strong class="lp hj">rastgele.tar.gz</strong></span></pre><p id="7e91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这种方法需要在目标计算机/容器映像上安装tar和gzip，并且我们应该在开始时定义一种清晰的方法来提取它。</p><h2 id="4f27" class="lt ju hi bd jv mi mj mk jz ml mm mn kd jb mo mp kh jf mq mr kl jj ms mt kp mu bi translated">运行应用程序—哎呀！😬修好它。</h2><p id="5a56" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">让我们试着运行我们的应用程序，看看发生了什么。有一个与我们的Python文件同名的可执行二进制文件，我们将直接运行它:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="6f34" class="lt ju hi lp b fi lu lv l lw lx">$ cd dist/rastgele/</span><span id="7d30" class="lt ju hi lp b fi ly lv l lw lx">$ ./rastgele<br/>$</span></pre><p id="7bdd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">什么都没发生。这里的问题不止一个。首先，Pyinstaller只运行Python文件，我们的文件不包含在直接执行时自己运行的结构。换句话说，当我们使用gunicorn时，我们正在用它启动我们的API服务器。但是现在，Pyinstaller不知道它，只是尝试<em class="mh">‘python rastgele . py’</em>。</p><p id="855f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Gunicorn文档中解释了这个问题的解决方案，即添加一个标准的“if _ _ name _ _ = =”_ _ main _ _“条件块，并在应用程序内直接启动guni corn<a class="ae lz" href="https://docs.gunicorn.org/en/latest/custom.html" rel="noopener ugc nofollow" target="_blank">。我们正在像Gunicorn的例子一样实现它。让我们看看它是如何发生的:</a></p><p id="c900" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们应该导入Gunicorn BaseApplication类。所以在程序的导入部分插入这个代码(<strong class="is hj">最后的完整代码被添加到</strong>下面):</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="f624" class="lt ju hi lp b fi lu lv l lw lx">from gunicorn.app.base import BaseApplication</span></pre><p id="f2fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，如果程序直接运行，我们可以定义相同的类并初始化它:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="a21f" class="lt ju hi lp b fi lu lv l lw lx">class StandaloneRandomNumberAPI(BaseApplication):</span><span id="ea42" class="lt ju hi lp b fi ly lv l lw lx">def __init__(self, app, options=None):<br/>        self.options = options or {}<br/>        self.application = app<br/>        super().__init__()</span><span id="4d8c" class="lt ju hi lp b fi ly lv l lw lx">def load_config(self):<br/>        config = {key: value for key, value in self.options.items()<br/>                  if key in self.cfg.settings and value is not None}<br/>        for key, value in config.items():<br/>            self.cfg.set(key.lower(), value)</span><span id="3fd6" class="lt ju hi lp b fi ly lv l lw lx">def load(self):<br/>        return self.application</span><span id="cf98" class="lt ju hi lp b fi ly lv l lw lx">if __name__ == "__main__":<br/>  <br/>    options = {<br/>        'bind': '%s:%s' % ('0.0.0.0', '80'),<br/>        'workers': 4,<br/>    }<br/>    StandaloneRandomNumberAPI(api, options).run()</span></pre><p id="970e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">程序应该是这样的:</p><p id="e2c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lz" href="https://gist.github.com/gurayyildirim/ff2d8e12a3d0faaa29ba802393e23806" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/gurayyildirim/ff 2d 8 e 12a 3d 0 faaa 29 ba 802393 e 23806</a></p><p id="90df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在尝试运行最后的代码:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="c48f" class="lt ju hi lp b fi lu lv l lw lx">$ python3 rastgele.py <br/>[2020-05-15 11:54:47 +0000] [1239] [INFO] Starting gunicorn 19.7.1<br/>[2020-05-15 11:54:47 +0000] [1239] [INFO] Listening at: <a class="ae lz" href="http://0.0.0.0:80" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:80</a> (1239)<br/>[2020-05-15 11:54:47 +0000] [1239] [INFO] Using worker: sync<br/>[2020-05-15 11:54:47 +0000] [1243] [INFO] Booting worker with pid: 1243<br/>[2020-05-15 11:54:47 +0000] [1244] [INFO] Booting worker with pid: 1244<br/>[2020-05-15 11:54:47 +0000] [1245] [INFO] Booting worker with pid: 1245<br/>[2020-05-15 11:54:47 +0000] [1246] [INFO] Booting worker with pid: 1246</span></pre><p id="316f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的应用程序现在正在运行。这意味着我们可以重新包装它:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="8e56" class="lt ju hi lp b fi lu lv l lw lx">$ pyinstaller rastgele.py<br/>... output removed ...</span><span id="89d0" class="lt ju hi lp b fi ly lv l lw lx">$ du -sh dist/rastgele/<br/>15M dist/rastgele/</span></pre><p id="91d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们试着运行我们的应用程序:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="bf3c" class="lt ju hi lp b fi lu lv l lw lx">$ ./dist/rastgele/rastgele</span><span id="aaad" class="lt ju hi lp b fi ly lv l lw lx">Error: class uri 'gunicorn.glogging.Logger' invalid or not found:</span><span id="9cf4" class="lt ju hi lp b fi ly lv l lw lx">[Traceback (most recent call last):<br/>  File "gunicorn/util.py", line 134, in load_class<br/>  File "importlib/__init__.py", line 126, in import_module<br/>  File "&lt;frozen importlib._bootstrap&gt;", line 994, in _gcd_import<br/>  File "&lt;frozen importlib._bootstrap&gt;", line 971, in _find_and_load<br/>  File "&lt;frozen importlib._bootstrap&gt;", line 953, in _find_and_load_unlocked<br/>ModuleNotFoundError: No module named 'gunicorn.glogging'<br/>]</span></pre><p id="df55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">又出错了！我们检查这个错误的原因是，根据您的堆栈，它可能是频繁的或罕见的。但是它们帮助我们理解整个机制是如何工作的。</p><p id="4c5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解决方案是表达隐式依赖(称为<strong class="is hj">隐藏导入</strong>)。有几种方法可以解决这个问题。我们将坚持通过CLI将它们传递给Pyinstaller。从这里我们可以看到<strong class="is hj">guni corn . gloging</strong>是一个缺失的依赖项。而在尝试之前，我还想分享另一个:<strong class="is hj"> gunicorn.workers.sync </strong>。为了让Pyinstaller知道它们，只需传递它们的名称(这只是方法之一):</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="eeb1" class="lt ju hi lp b fi lu lv l lw lx">$ pyinstaller rastgele.py --hidden-import "gunicorn.glogging" --hidden-import "gunicorn.workers.sync"<br/>...<br/><em class="mh">8811 INFO: Analyzing hidden import 'gunicorn.glogging'<br/>9187 INFO: Analyzing hidden import 'gunicorn.workers.sync'</em><br/>...</span></pre><p id="9101" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在尝试运行我们的应用程序。它应该没有任何错误:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="c3fb" class="lt ju hi lp b fi lu lv l lw lx">$ ./dist/rastgele/rastgele <br/>[2020-05-15 12:26:59 +0000] [1897] [INFO] Starting gunicorn 19.7.1<br/>[2020-05-15 12:26:59 +0000] [1897] [INFO] Listening at: <a class="ae lz" href="http://0.0.0.0:80" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:80</a> (1897)<br/>[2020-05-15 12:26:59 +0000] [1897] [INFO] Using worker: sync<br/>[2020-05-15 12:26:59 +0000] [1901] [INFO] Booting worker with pid: 1901<br/>[2020-05-15 12:26:59 +0000] [1902] [INFO] Booting worker with pid: 1902<br/>[2020-05-15 12:26:59 +0000] [1903] [INFO] Booting worker with pid: 1903<br/>[2020-05-15 12:26:59 +0000] [1904] [INFO] Booting worker with pid: 1904</span></pre><p id="ead8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大小会稍微增加，但不会太多(在我们的例子中，使用-h参数甚至不会明显地增加):</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="ed13" class="lt ju hi lp b fi lu lv l lw lx">$ du -sh dist/rastgele/<br/>15M dist/rastgele/</span></pre><h2 id="05ea" class="lt ju hi bd jv mi mj mk jz ml mm mn kd jb mo mp kh jf mq mr kl jj ms mt kp mu bi translated">使它成为一个文件</h2><p id="ff6a" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">最后一部分是将我们的应用程序打包成一个二进制可执行文件。Pyinstaller有一个<strong class="is hj"> -F </strong>参数来完成这项工作。它包括一个引导程序，可以从文件中提取你的文件，然后运行它们。这种打包也负责压缩，因此二进制文件的大小将类似于我们之前压缩的文件:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="336d" class="lt ju hi lp b fi lu lv l lw lx">$ ls -lh ./dist/rastgele<br/>-rwxr-xr-x 1 root root 7.0M May 15 12:32 ./dist/rastgele</span></pre><p id="c473" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有了一个大小为7.0MB的二进制文件，我们可以直接运行它:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="1cf5" class="lt ju hi lp b fi lu lv l lw lx">$ ./dist/rastgele <br/>[2020-05-15 12:33:57 +0000] [2229] [INFO] Starting gunicorn 19.7.1<br/>[2020-05-15 12:33:57 +0000] [2229] [INFO] Listening at: <a class="ae lz" href="http://0.0.0.0:80" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:80</a> (2229)<br/>[2020-05-15 12:33:57 +0000] [2229] [INFO] Using worker: sync<br/>[2020-05-15 12:33:57 +0000] [2233] [INFO] Booting worker with pid: 2233<br/>[2020-05-15 12:33:57 +0000] [2234] [INFO] Booting worker with pid: 2234<br/>[2020-05-15 12:33:57 +0000] [2235] [INFO] Booting worker with pid: 2235<br/>[2020-05-15 12:33:57 +0000] [2236] [INFO] Booting worker with pid: 2236</span></pre><p id="26de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">成功。现在，我们可以将该文件复制到CentOS、Debian、Ubuntu等的映像中，例如在Docker多阶段构建中的一个阶段中生成之后。但不是<strong class="is hj">阿尔卑斯☹️ </strong>如果你以前在一个案例中遭遇过，那就不是用glibc，而是musl。它会导致运行时的链接错误，这对于很多人来说甚至不是一个容易理解的错误。这也是为什么阿尔卑斯山的图像尺寸很小的原因之一，所以不是一件坏事。如果您很好奇，可以尝试在Alpine Linux容器中运行这个二进制文件。</p><h2 id="1c2f" class="lt ju hi bd jv mi mj mk jz ml mm mn kd jb mo mp kh jf mq mr kl jj ms mt kp mu bi translated">与Glibc和其他库打包—静态链接</h2><p id="fb24" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">最后一步是打包我们的应用程序，使其包含所有相关的库。这有点像静态链接，你可能听过或用过。为了创建包含所有库的包，我们将使用<strong class="is hj"> StaticX </strong>。它需要系统上的ldd(可能已经安装了)、binutils、gcc和patchelf(应该从存储库中构建)包作为依赖项。</p><p id="5a4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于基于CentOS的构建系统，下面列出了命令。您可能更喜欢逐个安装，而不是使用“成组安装”来实现相同的功能:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="9743" class="lt ju hi lp b fi lu lv l lw lx">$ yum install binutils wget -y<br/>$ yum group install "Development Tools" -y</span></pre><p id="4dbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下载、编译并安装<a class="ae lz" href="https://github.com/NixOS/patchelf" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> patchelf </strong> </a>(为简洁起见，输出被删除):</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="2f33" class="lt ju hi lp b fi lu lv l lw lx">$ cd / &amp;&amp; wget <a class="ae lz" href="https://github.com/NixOS/patchelf/archive/0.10.tar.gz" rel="noopener ugc nofollow" target="_blank">https://github.com/NixOS/patchelf/archive/0.10.tar.gz</a><br/>$ tar xzf 0.10.tar.gz<br/>$ cd patchelf-0.10/<br/>$ ./bootstrap.sh<br/>$ ./configure<br/>$ make<br/>$ make install</span></pre><p id="9d0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，我们准备安装StaticX:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="d660" class="lt ju hi lp b fi lu lv l lw lx">$ pip3 install staticx</span></pre><p id="ff77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们准备创建包含所有依赖库的二进制文件。转到项目目录，进入其中的<em class="mh"> dist </em>目录:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="b62e" class="lt ju hi lp b fi lu lv l lw lx">$ cd dist/</span></pre><p id="f424" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对其运行StaticX:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="17bb" class="lt ju hi lp b fi lu lv l lw lx">$ staticx rastgele rastgele_app</span></pre><p id="4d22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将需要一段时间，然后我们的最终文件将准备好:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="646b" class="lt ju hi lp b fi lu lv l lw lx">$ ls -lh<br/>total 16M<br/>-rwxr-xr-x 1 root root 7.0M May 15 12:32 rastgele<br/>-rwxr-xr-x 1 root root 8.2M May 15 16:36 rastgele_app</span></pre><p id="acb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有了一个8.2M的文件，其中包含了API应用程序所需的所有对象。我们甚至可以在临时映像中使用该二进制文件。</p><p id="34df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您尝试运行它，staticX会将打包的文件提取到一个临时目录中的<strong class="is hj"> /tmp </strong>，该目录的名称以<strong class="is hj"> staticx- </strong>开头。而且；pyinstaller也将在<strong class="is hj"> /tmp </strong>中创建一个临时目录，像我们在本文开始时使用的目录打包模式一样提取你的应用程序文件。pyinstaller创建的目录名以<strong class="is hj"> _MEI </strong>开头，后面是一些随机字符。当您的应用程序正常关闭时，这些临时目录也会自动删除。</p><h1 id="adc7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">带有最小图像的示例Dockerfile文件</h1><p id="c064" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">为应用程序创建静态文件后，现在我们准备将它打包成Docker映像。我们将使用<strong class="is hj"> scratch </strong>图像作为基础图像，因此它不会包含除我们的应用程序之外的任何文件。您还应该在二进制文件所在的目录中创建一个名为<strong class="is hj"> tmp </strong>的目录，因为scratch image没有/tmp，也没有<em class="mh"> mkdir </em>命令。</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="e0b2" class="lt ju hi lp b fi lu lv l lw lx">$ mkdir tmp</span></pre><p id="a204" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是一个docker文件示例:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="8ae4" class="lt ju hi lp b fi lu lv l lw lx">FROM scratch<br/>ENTRYPOINT ["/rastgele_app"]</span><span id="8301" class="lt ju hi lp b fi ly lv l lw lx">COPY tmp /tmp<br/>COPY rastgele_app /</span></pre><p id="1c57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">保存Dockerfile文件并开始构建:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="c15d" class="lt ju hi lp b fi lu lv l lw lx">$ docker build -t guray/pystatic-tut:1.0 .<br/>...<br/>Successfully tagged guray/pystatic-tut:1.0</span></pre><p id="ad2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们准备尝试一下:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="cd60" class="lt ju hi lp b fi lu lv l lw lx">$ docker run -it --rm guray/pystatic-tut:1.0<br/>[2020-05-15 16:48:29 +0000] [7] [INFO] Starting gunicorn 19.7.1<br/>[2020-05-15 16:48:29 +0000] [7] [INFO] Listening at: <a class="ae lz" href="http://0.0.0.0:80" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:80</a> (7)<br/>[2020-05-15 16:48:29 +0000] [7] [INFO] Using worker: sync<br/>[2020-05-15 16:48:29 +0000] [13] [INFO] Booting worker with pid: 13<br/>[2020-05-15 16:48:29 +0000] [14] [INFO] Booting worker with pid: 14<br/>[2020-05-15 16:48:29 +0000] [15] [INFO] Booting worker with pid: 15<br/>[2020-05-15 16:48:29 +0000] [16] [INFO] Booting worker with pid: 16</span></pre><h1 id="4b56" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">提高安全性—将用户改为无用户</h1><p id="a6db" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">最后一步，我们将把我们的用户改为nobody。因为有很多环境不允许使用<strong class="is hj"> root </strong>或<strong class="is hj"> id 0 </strong>用户运行容器，所以在我们正在帮助的环境中，这经常是必要的。为此，只需将端口更改为大于1024的数字(由于unix系统的特性，即使端口≤1024也需要root访问权限，即使它在容器内部)。因此，编辑代码中的选项行，如下所示:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="1cbb" class="lt ju hi lp b fi lu lv l lw lx">options = {<br/>        'bind': '%s:%s' % ('0.0.0.0', '8000'),<br/>        'workers': 4,<br/>    }</span></pre><p id="9ff2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并再次打包:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="87e7" class="lt ju hi lp b fi lu lv l lw lx">$ pyinstaller -F rastgele.py --hidden-import "gunicorn.glogging" --hidden-import "gunicorn.workers.sync"<br/>$ cd dist/<br/>$ staticx rastgele rastgele_app</span></pre><p id="6c06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，它可以再次打包了，但同时带有一个更新的docker文件:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="482f" class="lt ju hi lp b fi lu lv l lw lx">FROM scratch</span><span id="1750" class="lt ju hi lp b fi ly lv l lw lx">ENTRYPOINT ["/rastgele_app"]<br/>USER 65535</span><span id="6dd2" class="lt ju hi lp b fi ly lv l lw lx">COPY --chown=65535:65535 tmp /tmp<br/>COPY --chown=65535:65535 rastgele_app /</span></pre><p id="cdd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，我们可以构建映像并运行从它创建的容器:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="5454" class="lt ju hi lp b fi lu lv l lw lx">$ docker run -it --rm guray/pystatic-tut:1.1<br/>[2020-05-15 16:58:29 +0000] [8] [INFO] Starting gunicorn 19.7.1<br/>[2020-05-15 16:58:29 +0000] [8] [INFO] Listening at: <a class="ae lz" href="http://0.0.0.0:8000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8000</a> (8)<br/>[2020-05-15 16:58:29 +0000] [8] [INFO] Using worker: sync<br/>[2020-05-15 16:58:29 +0000] [14] [INFO] Booting worker with pid: 14<br/>[2020-05-15 16:58:29 +0000] [15] [INFO] Booting worker with pid: 15<br/>[2020-05-15 16:58:29 +0000] [16] [INFO] Booting worker with pid: 16<br/>[2020-05-15 16:58:29 +0000] [17] [INFO] Booting worker with pid: 17</span></pre><p id="8765" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在检查图像大小:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="e145" class="lt ju hi lp b fi lu lv l lw lx">$ docker image ls guray/pystatic-tut:1.1<br/>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE<br/>guray/pystatic-tut   1.1                 4fc7ab2d0d23        41 seconds ago      8.5MB</span></pre><h1 id="5e60" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">进一步优化</h1><p id="6cc7" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">如果您很好奇，在运行pyinstaller时将-OO传递给Python也将帮助您获得几个字节。就这样跑:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="5982" class="lt ju hi lp b fi lu lv l lw lx">$ python3 -OO -m PyInstaller -F rastgele.py --hidden-import "gunicorn.glogging" --hidden-import "gunicorn.workers.sync"</span></pre><p id="e6f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将删除文档字符串和其他一些东西。更多细节可以在Python手册和PyInstaller手册中找到。</p><p id="03ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以在使用StaticX时<a class="ae lz" href="https://en.wikipedia.org/wiki/Strip_(Unix)" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">剥离</strong> </a>二进制文件。它的参数是:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="8bf3" class="lt ju hi lp b fi lu lv l lw lx">$ cd dist/<br/>$ staticx --strip rastgele rastgele_app</span></pre><p id="88a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您将以前的版本复制为/r1，将当前版本复制为/r2，您可以看到大小差异:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="42de" class="lt ju hi lp b fi lu lv l lw lx">$ ls -l /r1 /r2<br/>-rwxr-xr-x 1 root root 8499512 May 15 17:03 /r1<br/>-rwxr-xr-x 1 root root 8005856 May 15 17:04 /r2</span></pre><p id="a8ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就像0.5MB现在在我们这边，(希望)不会失去任何功能。让我们构建并运行它:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="0787" class="lt ju hi lp b fi lu lv l lw lx">$ docker build -t guray/pystatic-tut:1.2 .<br/>$ docker run -it --rm guray/pystatic-tut:1.2<br/>[2020-05-15 17:06:36 +0000] [7] [INFO] Starting gunicorn 19.7.1<br/>[2020-05-15 17:06:36 +0000] [7] [INFO] Listening at: <a class="ae lz" href="http://0.0.0.0:8000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8000</a> (7)<br/>[2020-05-15 17:06:36 +0000] [7] [INFO] Using worker: sync<br/>[2020-05-15 17:06:36 +0000] [13] [INFO] Booting worker with pid: 13<br/>[2020-05-15 17:06:36 +0000] [14] [INFO] Booting worker with pid: 14<br/>[2020-05-15 17:06:36 +0000] [15] [INFO] Booting worker with pid: 15<br/>[2020-05-15 17:06:37 +0000] [16] [INFO] Booting worker with pid: 16</span></pre><p id="f98f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而现在的图像是<strong class="is hj"> 8.01MB </strong>:</p><pre class="jp jq jr js fd lo lp lq lr aw ls bi"><span id="8712" class="lt ju hi lp b fi lu lv l lw lx">docker image ls guray/pystatic-tut<br/>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE<br/>guray/pystatic-tut   1.2                 58a915bf1a36        40 seconds ago      8.01MB<br/>guray/pystatic-tut   1.1                 4fc7ab2d0d23        8 minutes ago       8.5MB</span></pre><p id="0ca8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果需要进一步优化，可以安装<a class="ae lz" href="https://upx.github.io/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">upx</strong></a>；然后，如果它在路径中或者提供了它的路径，pyinstaller将使用它来进一步压缩您的包。对于我们的例子，使用它没有任何好处，因为我们的包由编译的二进制文件组成。但仍然值得一试。</p><h1 id="6637" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="b949" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">同样，它就像一个黑洞。很明显，有很多其他的可能性，将减少图像的大小。如果你对它们有想法，请在评论中分享。我们将很乐意尝试它们，并根据结果更新故事。</p></div></div>    
</body>
</html>