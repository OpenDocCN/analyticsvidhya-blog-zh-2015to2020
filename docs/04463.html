<html>
<head>
<title>Kotlin, delegating inheritance to save you from refactoring headaches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin，委托继承让你摆脱重构的困扰</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/kotlin-delegating-inheritance-to-save-you-from-refactoring-headaches-114281316379?source=collection_archive---------17-----------------------#2020-03-20">https://medium.com/analytics-vidhya/kotlin-delegating-inheritance-to-save-you-from-refactoring-headaches-114281316379?source=collection_archive---------17-----------------------#2020-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d9ecba9a8404f0bd4080c7289aa4b0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZXavJNzEn6HHfB-H.png"/></div></div></figure><p id="5b34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你好。我希望你身体健康。我猜你听说过科特林代表。这篇文章不是向你展示什么是委托，如何创建委托，也不是一些基本的用法。这个帖子正在解决具体问题，代表们正在提供帮助。</p><p id="2266" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章与库/框架无关。下面的所有实现并不是要展示库/框架是如何工作的，也不是要展示你应该如何查询数据库(例如)。它只是简单地展示问题和解决方案。</p><p id="8e82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">短篇故事。想象一下，你已经加入了这个项目，有些文件不是很好。其中一个文件违反了单一责任原则。这个文件叫做StorageDao，有一些函数可以存储/读取许多不同类型的数据。StorageDao存储/读取用户数据、用户事件(用户已经参加的事件以及未来的事件)以及您在用户登机时保存的一些数据。随着时间的推移，这个文件越来越大，很难找到合适的方法。(这就是我们在这里的原因)许多其他文件依赖于这个。也就是说，如果您更改这个文件，您将需要更改许多其他文件。更糟糕的是，假设这不是接口实现，而只是一个简单的具有公共函数的类。</p><p id="e01a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们想要什么？我们希望将用户数据、事件数据和上车数据存储/读取在单独的文件中。对吗？我们不想改变大量文件(目前，也许是永远)。</p><p id="8d86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们的存储道类:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="5ab4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们想要的文件结构是:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="3922" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们为所有这些接口创建实现，移动特定实现中的相关方法并删除存储，我们将会破坏大量文件。每个依赖于StorageDao的文件(作为构造函数参数接收)都没有编译。解决这个问题的步骤是:</p><p id="99b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步:更改依赖注入框架以提供和接收这些类的类。<br/>第二步:更改接收StorageDao作为构造函数参数的文件，以接收所需的实现(一些文件将只需要UserDao，而其他文件可能需要全部三个)。<br/>第三步:检查所有使用了StorageDao的类并更改调用，以便它们调用正确的Dao (UserDao，EventsDao，OnBoardingDao) - &gt;</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="f90c" class="jz ka hi jv b fi kb kc l kd ke">storageDao.getAllEvents() should be eventsDao.getAllEvents()</span></pre><p id="9eb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很多工作，对吧？</p><p id="9182" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使它变得容易得多，并获得同样的好处。我们要怎么做呢？科特林代表们！</p><p id="177d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步是让StorageDao实现所有这些接口。像这样:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="ca62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二步是为这些接口创建实现。先说UserDao。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="65e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将与用户相关的操作从StorageDao委托给UserDao。怎么会？像这样:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="173f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以注意到我们有了新的构造函数参数，UserDao，userDao实现是“UserDao by userDao”，我们已经删除了用户相关的函数，它仍然可以编译。对StorageDao进行的每个与用户数据相关的调用都将委托给userDao。</p><p id="1905" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们对活动和登机也是如此。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="3394" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们的存储道看起来像这样:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="e0c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有依赖和调用StorageDao的文件仍会按预期编译和工作。我们需要更改的唯一文件是创建StorageDao的文件。假设您正在使用Koin进行依赖注入，这很容易使用和展示。它看起来像这样:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="d3bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！现在一切都编译好了，代码被分开了，你不需要改变成吨的文件。每个人都快乐(你和编译器):D</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="4da8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[1]通用定义:代码模块(文件/类等。)的责任不止一个。更好的定义:代码模块的改变有多个原因。</p></div></div>    
</body>
</html>