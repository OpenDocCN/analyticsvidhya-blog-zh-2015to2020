<html>
<head>
<title>Apache Spark performance recipe — Explicitly cache RDD when branching out from parent RDD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Spark性能方法——当从父RDD分支时，显式缓存RDD</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/apache-spark-performance-recipe-explicitly-cache-rdd-when-branching-out-from-parent-rdd-48e394f82637?source=collection_archive---------13-----------------------#2020-06-09">https://medium.com/analytics-vidhya/apache-spark-performance-recipe-explicitly-cache-rdd-when-branching-out-from-parent-rdd-48e394f82637?source=collection_archive---------13-----------------------#2020-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4da2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">下面的字数统计示例说明了当RDD家族分裂/分支时缓存RDD的重要性。</p><p id="7421" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">案例1:读取输入文件两次</strong></p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="de52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jt"> loremCountCase1 </em>和<em class="jt"> ipsumCountCase1 </em>操作的文件加载可以在日志中验证。根据分区和并行度，您将在日志中显示下面两行两次，指示文件被读取两次。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="d0f9" class="jz ka hi jv b fi kb kc l kd ke">INFO HadoopRDD: Input split: file:/data/lorem_ipsum.txt:1816+1817<br/>INFO HadoopRDD: Input split: file:/data/lorem_ipsum.txt:0+1816</span></pre><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kf"><img src="../Images/9ca17260e508abbba3c624b7e631f1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*xD5tafqcBKCUwhK-za9aUg.png"/></div></div></figure><p id="3c22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的DAG可以看出，对于每个collect()操作，所有操作都执行两次。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><div class="jm jn jo jp fd kt"><a rel="noopener follow" target="_blank" href="/@verditer/understanding-tradeoffs-in-designing-real-time-streaming-analytical-applications-f1ddbc852d77"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hj fi z dy ky ea eb kz ed ef hh bi translated">了解设计实时流分析应用的权衡</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">相反，设计没有好坏之分，会有许多权衡要做，希望这些权衡是好的…</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">medium.com</p></div></div><div class="lc l"><div class="ld l le lf lg lc lh kk kt"/></div></div></a></div></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="0816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况2:使用显式持久化操作仅读取输入文件一次</strong></p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="c2c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jt"> loremCountCase2 </em>和<em class="jt"> ipsumCountCase2 </em>操作的文件加载只发生一次，同样可以在日志中验证。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="545a" class="jz ka hi jv b fi kb kc l kd ke">INFO HadoopRDD: Input split: file:/data/lorem_ipsum.txt:1816+1817<br/>INFO HadoopRDD: Input split: file:/data/lorem_ipsum.txt:0+1816</span></pre><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es li"><img src="../Images/0a585d565b889b324b2ce81830e09d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*ucc2a0VP2Y4Z6RsjoUqwpQ.png"/></div></figure><p id="dd50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RDD周围的绿色斑点和绿色高亮显示表示RDD已缓存，缓存的RDD可以在用户界面的存储选项卡上看到。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><div class="jm jn jo jp fd kt"><a rel="noopener follow" target="_blank" href="/@verditer/a-work-breakdown-structure-wbs-for-big-data-analytics-projects-part-1-db4c2a8179fd"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hj fi z dy ky ea eb kz ed ef hh bi translated">大数据分析项目的工作分解结构(WBS)——第1部分</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">有没有想过大数据项目涉及哪些活动？工作分解结构(WBS)有助于选择…</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">medium.com</p></div></div><div class="lc l"><div class="lj l le lf lg lc lh kk kt"/></div></div></a></div></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="171e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况3:只读取输入文件一次，没有显式持久化操作</strong></p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="jr js l"/></div></figure><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es lk"><img src="../Images/9dafe18392cbbe61b2a93a8f22433cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*4hKZ0s_bmICQYPeCgbg3-w.png"/></div></figure><p id="7964" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jt">阶段2 </em>被跳过，因为默认缓存了<em class="jt">阶段0 </em>的结果，在阶段操作的详细视图中没有绿点指示RDD是否被缓存。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><div class="jm jn jo jp fd kt"><a rel="noopener follow" target="_blank" href="/@verditer/datalake-an-understanding-and-approach-to-extracting-value-569116a82df7"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hj fi z dy ky ea eb kz ed ef hh bi translated">数据湖——理解和提取价值的方法</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">十年大数据&amp; Hadoop和问题差不多，Hadoop能代替RDBMS吗？大数据技术能否取代…</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">medium.com</p></div></div><div class="lc l"><div class="ll l le lf lg lc lh kk kt"/></div></div></a></div></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="01f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">案例4:只读取输入文件一次，使用显式持久化操作</strong></p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="jr js l"/></div></figure><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es lm"><img src="../Images/74339d06993a64360297a3e34e1906c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IrDP7Ed3YGKW3iq2PaWVeA.png"/></div></div></figure><p id="0970" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ShuffleRDD上的绿点表示它已被缓存。</p><p id="45c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来自关于<a class="ae ln" href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#rdd-persistence" rel="noopener ugc nofollow" target="_blank"> RDD持久性</a>的Spark文档</p><blockquote class="lo lp lq"><p id="b24b" class="if ig jt ih b ii ij ik il im in io ip lr ir is it ls iv iw ix lt iz ja jb jc hb bi translated">Spark还会在shuffle操作中自动持久化一些中间数据(比如reduceByKey)，即使没有用户调用persist。这样做是为了避免在洗牌过程中节点失败时重新计算整个输入。如果用户打算重用得到的RDD，我们仍然建议他们调用persist。</p></blockquote><p id="19f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当spark代码在大型数据集上运行时，中间缓存结果往往会由于集群内存的限制而被逐出。正如Spark文档中所建议的，当分支RDD血统并计划以后重用时，持久化操作必须是显式的。</p><p id="b403" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，编写spark代码很容易，但是编写一个高性能的spark代码需要理解Spark是如何工作的。在非分布式本地环境中进行测试不会带来很多性能问题。总是用较大的数据集测试集群。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="c914" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请<a class="ae ln" href="https://datum.substack.com" rel="noopener ugc nofollow" target="_blank">在此注册</a>或在您的收件箱中直接接收所有更新的双月简讯。</p><p id="e167" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jt">免责声明:所有表达的观点都是我个人的独立想法，并不归因于我现在或以前的雇主。</em></p></div></div>    
</body>
</html>