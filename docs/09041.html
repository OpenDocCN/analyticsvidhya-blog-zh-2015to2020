<html>
<head>
<title>Crypto Basics: understand&amp;create your own base64 encoding with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加密基础:了解并使用 Python 创建自己的 base64 编码</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/crypto-basics-understand-create-your-own-base64-encoding-with-python-a1481686a35a?source=collection_archive---------15-----------------------#2020-08-23">https://medium.com/analytics-vidhya/crypto-basics-understand-create-your-own-base64-encoding-with-python-a1481686a35a?source=collection_archive---------15-----------------------#2020-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/cde050b17edf09f3771843a3f250f053.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*sol4tSIMpXTU4KBxt7IgFA.png"/></div></figure><p id="9df7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们在日常生活中会遇到 base64 编码(是的，书呆子)。</p><p id="1acd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，我们使用 base64 编码将图像数据直接嵌入到 HTML 源代码中，或者在通过互联网发送附件时，防止二进制数据以原始形式损坏。</p><p id="0341" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你是一个活跃的 CTF 玩家，你可能已经比你的家人看到更多了。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h1 id="01dd" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">让我们直接进入<strong class="ak">base64 是如何工作的</strong>:</h1><blockquote class="kp"><p id="73b8" class="kq kr hi bd ks kt ku kv kw kx ky jj dx translated">ASCII 编码和 Base64 编码不可互换。不要陷入这种常见的误解。它们用于不同的目的。</p></blockquote><p id="2475" class="pw-post-body-paragraph im in hi io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj hb bi translated">Base64 是一种二进制到文本的编码方案。因此可以加密任何二进制数据或非 ASCII 字符，结果给出<strong class="io hj"> <em class="le"> ASCII 字符</em> </strong>。</p><blockquote class="lf lg lh"><p id="fd8b" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated"><strong class="io hj">步骤 1:</strong>Base64 编码算法接收一个 8 位字节的输入流。</p></blockquote><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="caab" class="lu js hi lq b fi lv lw l lx ly"><strong class="lq hj">input</strong>: <br/><strong class="lq hj">-&gt; </strong>oz9un<br/><strong class="lq hj">Binary Represantation(8-bit sequences)</strong>:<br/><strong class="lq hj">-&gt; </strong>01101111 01111010 00111001 01110101 01101110</span></pre><blockquote class="lf lg lh"><p id="0f4b" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated"><strong class="io hj">第二步:</strong>将输入拆分成 6 位块。在最后一个组的末尾填充“0”位，除非它被分成完整的 6 位组。</p></blockquote><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="9216" class="lu js hi lq b fi lv lw l lx ly"><strong class="lq hj">Binary Represantation(6-bit sequences):<br/>-&gt; </strong>011011 110111 101000 111001 011101 010110 1110<strong class="lq hj">00</strong></span></pre><blockquote class="lf lg lh"><p id="f77f" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated"><strong class="io hj">步骤 3: </strong>现在我们有了 6 位组，我们需要将它们转换成 ASCII 字符。但是怎么做呢？通过将 6 位序列编入 Base64 索引表。</p></blockquote><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="13dc" class="lu js hi lq b fi lv lw l lx ly"><strong class="lq hj">The 6-bit sequences above correspond to:<br/>-&gt; </strong>27 55 40 57 29 22 56</span></pre><p id="c143" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看一下 base64 索引表</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/7900f471366549e2cb9c0c3ad7f390d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWJlXoyZcxMynLFuDMO4TQ.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx translated">这张表摘自<a class="ae mi" href="https://en.wikipedia.org/wiki/Base64" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="5b4c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如您所看到的，6 位序列可以接受的 63 个不同数字都有相应的 ASCII 字符。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h2 id="77a7" class="lu js hi bd jt mj mk ml jx mm mn mo kb ix mp mq kf jb mr ms kj jf mt mu kn mv bi translated">那个<strong class="ak">‘填充’</strong>到底是什么意思？</h2><p id="3926" class="pw-post-body-paragraph im in hi io b ip mw ir is it mx iv iw ix my iz ja jb mz jd je jf na jh ji jj hb bi translated">冷静，这是为了你的健康。正如你可能注意到的，我们将三个 8 位数据块分割成四个 6 位数据块(这很简单，明白了)。</p><p id="b2ef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">记住我们在第二步中做了什么。我们简单地添加了 0 位，使序列可拆分成 6 位的块。当添加“0”位时，我们有两种选择。要么 2，要么 4。并且在将 6 位序列转换成相应的 base64 字符后，我们应该在编码版本的末尾添加<strong class="io hj"> <em class="le">(附加‘0’字节的数量)/2 </em> </strong>填充字符(=)。</p><h2 id="9cce" class="lu js hi bd jt mj mk ml jx mm mn mo kb ix mp mq kf jb mr ms kj jf mt mu kn mv bi translated">好吧…我能问一下我们为什么这么做吗？</h2><p id="a3aa" class="pw-post-body-paragraph im in hi io b ip mw ir is it mx iv iw ix my iz ja jb mz jd je jf na jh ji jj hb bi translated">Imm，我完全同意你的观点。这在今天是不必要的。但是 base64 编码是非常古老的，在它年轻的时候，计算机的 CPU/ram 有限，编写软件并不容易。所以，解码器的人想很容易地将输入分成 4 块，并从每 4 块中提取 3 个字符。填充过程允许他们这样做，而不经过输入的结尾。</p><p id="ed6e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">是啊，那是个悲伤的故事。但是不要担心。我们可以在不需要任何填充字符的情况下进行编码(我们有大于 10mb 的 ram)。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="1b82" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在是时候在 base64 索引表的帮助下将这些数字转换成 ASCII 字符了:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="5652" class="lu js hi lq b fi lv lw l lx ly"><strong class="lq hj">The 6-bit sequences above correspond to:<br/>-&gt; </strong>27 55 40 57 29 22 56<br/><strong class="lq hj">Corresponding ASCII characters:<br/>-&gt; </strong>b3o5dW4=</span></pre><p id="7677" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在你肯定知道这个等号是从哪里来的了。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/a7d4b3efe28ada0364f3fd83d540d41e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*J0CaNhTgI8TiarYbBaRP_A.png"/></div></figure><h2 id="bbd4" class="lu js hi bd jt mj mk ml jx mm mn mo kb ix mp mq kf jb mr ms kj jf mt mu kn mv bi translated">还没有，我们开始吧:</h2><p id="d1eb" class="pw-post-body-paragraph im in hi io b ip mw ir is it mx iv iw ix my iz ja jb mz jd je jf na jh ji jj hb bi translated">首先，我可以肯定地说，我们不需要导入任何模块，因为我们得到了逻辑。这是最酷的部分。</p><blockquote class="lf lg lh"><p id="92cc" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated"><strong class="io hj">代码步骤 1: </strong>我们要初始化一个变量来保存 base64 索引表。</p></blockquote><p id="e906" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">【1】</strong>你可以通过导入<em class="le">字符串</em>模块来实现。但是我们当然不会选择这种方式(没有导入的代码，谢谢)。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="a1e2" class="lu js hi lq b fi lv lw l lx ly"><em class="le">import</em> string</span><span id="0e08" class="lu js hi lq b fi nc lw l lx ly"><strong class="lq hj">base64_table</strong> = (string.ascii_uppercase+string.ascii_lowercase+string.digits+'+/')</span></pre><p id="1cc8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">【2】</strong>容易猜，自己写字母表不会累手指。但我还是留给你抄。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="22e3" class="lu js hi lq b fi lv lw l lx ly"><strong class="lq hj">ascii_lowercase</strong> = 'abcdefghijklmnopqrstuvwxyz'<br/><strong class="lq hj">ascii_uppercase</strong> = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'<br/><strong class="lq hj">digits</strong> = '0123456789'</span><span id="ba44" class="lu js hi lq b fi nc lw l lx ly"><strong class="lq hj">base64_alphabet</strong> = ascii_uppercase + ascii_lowercase + digits + '+/'</span></pre><blockquote class="lf lg lh"><p id="29ec" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated"><strong class="io hj">编码步骤 2: </strong>让我们将输入分解成 8 位块。(但是……我们没有采纳任何意见。好吧，那就拿着吧。)</p></blockquote><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="35c5" class="lu js hi lq b fi lv lw l lx ly"><strong class="lq hj">to_encode</strong> = input("base64 encoder -&gt;  ")</span><span id="60b9" class="lu js hi lq b fi nc lw l lx ly"><strong class="lq hj">chunks_8bit</strong> = ''<strong class="lq hj"><em class="le">.</em></strong>join([format(bits<strong class="lq hj"><em class="le">,</em></strong>'08b') <strong class="lq hj">for</strong> bits <strong class="lq hj">in</strong> to_encode<strong class="lq hj"><em class="le">.</em></strong>encode('utf8')])</span></pre><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es nd"><img src="../Images/0e7612f27ff83ab4735d56591600972d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMw-S06Nlw7PGrpgQKV_Wg.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx translated">如果您在阅读上面的代码片段时有困难</figcaption></figure><p id="8f4e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们使用<em class="le">格式(bits，' 08b') </em>将整数转换为二进制保留前导零。</p><p id="f23e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用<em class="le"> join，</em> <strong class="io hj"> chunks_8bit </strong>输出如下所示:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/3fcdc01fcf04fceae04d8ffc72ea48ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*Ms4XIWPAh7Ti3ecgQfhHmg.png"/></div></figure><blockquote class="lf lg lh"><p id="199e" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated"><strong class="io hj">代码第三步:</strong>是时候把 8 位组块转换成 6 位组块了，如果需要的话在字符串末尾加‘0’位。</p></blockquote><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="0443" class="lu js hi lq b fi lv lw l lx ly"><strong class="lq hj">chunks_6bit</strong> = [chunks_8bit[bits<strong class="lq hj"><em class="le">:</em></strong>bits+6] <strong class="lq hj">for</strong> bits <strong class="lq hj">in</strong> range(0<strong class="lq hj"><em class="le">,</em></strong>len(chunks_8bit)<strong class="lq hj"><em class="le">,</em></strong>6)]</span><span id="e01e" class="lu js hi lq b fi nc lw l lx ly"><strong class="lq hj">padding_amount</strong> = ( 6 - len(chunks_6bit[len(chunks_6bit)-1]) )</span><span id="c4be" class="lu js hi lq b fi nc lw l lx ly"><strong class="lq hj">chunks_6bit[</strong>len(chunks_6bit)-1<strong class="lq hj">]</strong> += padding_amount * '0'</span></pre><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es nd"><img src="../Images/038a977e32e88e08ee4207548ec48c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RGFRyagrPM1V9ImZ3X-c7g.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx translated">如果您在阅读上面的代码片段时有困难</figcaption></figure><p id="564f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果需要的话，这段代码就是将 8 位数据块转换为 6 位数据块所需的全部内容，并使用“0”填充。</p><p id="8aa7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在计算<strong class="io hj"> padding_amount 的帮助下，</strong>我们可以在后面加上' = '。</p><p id="7050" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> chunks_6bit </strong>输出看起来像:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es nf"><img src="../Images/8ddbd3c51bc99d2739ad1895dd12a8fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVQ10WnYeOKZDC8IHu-YwQ.png"/></div></div></figure><blockquote class="lf lg lh"><p id="b3ad" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated"><strong class="io hj">代码第四步:</strong>最后一步。我们所要做的就是将这些 6 位块值映射到我们的 base64 字母表中。</p></blockquote><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="a2f3" class="lu js hi lq b fi lv lw l lx ly"><strong class="lq hj">encoded</strong> = ''<strong class="lq hj"><em class="le">.</em></strong>join([base64_alphabet[int(bits<strong class="lq hj"><em class="le">,</em></strong>2)] <strong class="lq hj">for</strong> bits <strong class="lq hj">in</strong> chunks_6bit])</span><span id="d2d0" class="lu js hi lq b fi nc lw l lx ly"><strong class="lq hj">encoded</strong> += int(padding_amount/2) * '='</span><span id="f87e" class="lu js hi lq b fi nc lw l lx ly">print('Base64 encoded version of <strong class="lq hj">{to_encode}</strong> is: <strong class="lq hj">{result}</strong>'<strong class="lq hj"><em class="le">.</em></strong>format(<strong class="lq hj"><em class="le">to_encode</em></strong> = to_encode<strong class="lq hj"><em class="le">,</em></strong> <strong class="lq hj"><em class="le">result</em></strong> = encoded))</span></pre><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es ng"><img src="../Images/08b17c3c1382a233100b9911743f2605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d13L3LN_oitilcxJBo34WQ.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx translated">如果您在阅读上面的代码片段时有困难</figcaption></figure><p id="1350" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们使用<em class="le"> int(bits，2) </em>将二进制转换为十进制。每两个额外的“0”位对应一个填充字符(“=”)。这就是我们将 padding_amount 除以 2 的原因。</p><p id="8a90" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们就把它打印出来。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nh"><img src="../Images/1c4aefcc8e805cb91b435994be565864.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*gpgDKQdN4UcadY1d9qhBDg.png"/></div></figure><p id="047c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以在这里找到完整的代码。当我写新的作品时，我会在这个库中分享它们的代码。</p><blockquote class="kp"><p id="4cb3" class="kq kr hi bd ks kt ku kv kw kx ky jj dx translated"><a class="ae mi" href="https://github.com/oz9un/crypto_basics/blob/master/base_world/base64_manually.py" rel="noopener ugc nofollow" target="_blank">https://github . com/oz9un/crypto _ basics/blob/master/base _ world/base64 _ manually . py</a></p></blockquote></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h1 id="454b" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结尾:</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es ni"><img src="../Images/ea08fa9fab81c3e9e67266a4134dfa70.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/1*YtGBFphYH6sEtnZ6E5iCmw.gif"/></div></figure><p id="34e4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是我第一篇关于加密基础的文章的结尾。我计划在有时间的时候写更多关于这个主题的东西。如果你能给我一个反馈，我会很高兴。保持联系！</p><h2 id="9c5b" class="lu js hi bd jt mj mk ml jx mm mn mo kb ix mp mq kf jb mr ms kj jf mt mu kn mv bi translated">联系我:</h2><blockquote class="lf lg lh"><p id="0301" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated">ozgunkultekin@gmail.com</p><p id="144d" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated"><strong class="io hj">Github:</strong><a class="ae mi" href="https://github.com/oz9un/crypto_basics" rel="noopener ugc nofollow" target="_blank">https://github.com/oz9un</a></p><p id="1b26" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated"><strong class="io hj">推特:</strong><a class="ae mi" href="https://twitter.com/oz9un" rel="noopener ugc nofollow" target="_blank">https://twitter.com/oz9un</a>(新来的，不过会活跃)。</p><p id="276a" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated">CTFtime:  oz9un</p><p id="8719" class="im in le io b ip iq ir is it iu iv iw li iy iz ja lj jc jd je lk jg jh ji jj hb bi translated"><strong class="io hj">领英:</strong>【https://www.linkedin.com/in/oz9unkultekin】T2</p></blockquote></div></div>    
</body>
</html>