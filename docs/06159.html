<html>
<head>
<title>The Perceptron Algorithm for Binary Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二元分类的感知器算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-perceptron-algorithm-for-binary-classification-ab65aaf237d7?source=collection_archive---------8-----------------------#2020-05-13">https://medium.com/analytics-vidhya/the-perceptron-algorithm-for-binary-classification-ab65aaf237d7?source=collection_archive---------8-----------------------#2020-05-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="5582" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="a65f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">感知器算法</strong>是最早的监督机器学习技术之一，用于将数据点分为两组。该算法由Frank Rosenblatt于1958年发明，用于识别不同类型的形状(例如，三角形、正方形、圆形等)。)当某个形状被带到感知机面前时。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/3f677caf0a9fb14bdf0dea06728a800e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQC7pCLJuP4QLJJ3wzYitA.jpeg"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">弗兰克·罗森布拉特</figcaption></figure><p id="95ff" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">该算法工作的一个主要假设是数据应该是<strong class="jf hj">线性可分的</strong>，即应该存在一个线性分类器，以零训练误差分离数据。数学上，对于两个集合A &amp; B，可线性分离的数据可以定义为，</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kw"><img src="../Images/33570fca89e305798014286a8a984189.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*ZYxk6-3Cu1VpSlKL2JEGHA.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">线性可分数据的定义</figcaption></figure><p id="54fe" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">其中(w，wo)是定义线性分类器的超平面的一些参数。</p><h1 id="4dec" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">算法是如何工作的</h1><p id="1a8a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将具有零训练误差的线性分类器定义为，</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kx"><img src="../Images/26379179e3b46df351d8f7b324f1a629.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*m11M-kedGnYCxtRNEF_T6Q.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">线性分类器</figcaption></figure><p id="f0a5" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">任何算法都是通过<em class="ky">最大化</em>或<em class="ky">最小化</em>一个在特定约束下成立的目标函数来工作的。这里，感知器算法试图最小化目标函数，以便为数据集预测正确的标签。</p><p id="cf43" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">目标函数(L)和约束定义如下，</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kz"><img src="../Images/e7b214bf38c28633d5fd006eb7333682.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*-HT58C1cQoZFIxEfxw4EUQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">算法的目标函数</figcaption></figure><p id="a3bb" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">如果预测值‘f(x；w)’和已知标记‘yi’具有相同的符号(例如+1或-1 ),则点积yi . f(x；w)将&gt; 0。这意味着上面定义的线性分类器f(x；w)对xi数据点的预测是正确的。</p><p id="c052" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">该算法寻求最小化目标函数，该目标函数是定义的线性分类器没有正确预测输出的所有时间的总和。因此，目标函数的范围总是从0到某个正值。由于目标函数中固有的负号，它取正值。</p><p id="2113" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated"><strong class="jf hj">因此，当目标函数值变为0 </strong>时，该算法终止，这意味着没有点被错误分类。</p><p id="db9b" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated"><strong class="jf hj"> <em class="ky">渐变体面:最小化目标函数</em> </strong></p><p id="9158" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">与其他算法不同，不可能对这个目标函数求导来求最小值。因此，我们使用<strong class="jf hj">梯度下降法</strong>来最小化l。</p><p id="8dd4" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">梯度下降的工作逻辑是，即使我们不能解析地求解目标函数(L)的导数，导数仍然给我们关于L在w中增加的方向的信息。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es la"><img src="../Images/39eaf43243d3b3b368b36d0eb02c1c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/1*mCHsC7vu8b4fXp6ri2D1Jg.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">感知器的梯度下降算法</figcaption></figure><p id="81ae" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">因此，对于足够小的正“r”值，我们有L(w1) &lt; L(w)。</p><h1 id="8d71" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">感知器算法的缺点</h1><ol class=""><li id="732d" class="lb lc hi jf b jg jh jk jl jo ld js le jw lf ka lg lh li lj bi translated">数据必须是线性可分的主要假设是这种算法的主要缺点之一。如果数据不是线性可分的，那么算法将永远不会收敛，超平面将继续无限移动。</li><li id="3bc5" class="lb lc hi jf b jg lk jk ll jo lm js ln jw lo ka lg lh li lj bi translated">此外，该算法不考虑超平面的质量，并且收敛到它找到的第一个超平面。因此，失去了定义更好的超平面的机会，该超平面将利用新的测试数据给出更好的精度。</li></ol><p id="a998" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">这两个缺点都可以使用更好的分类算法来解决，例如SVM等。</p><h1 id="6e95" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="ac61" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因此，感知器算法是对数据进行分组分类的首批成果之一，这导致了能够克服感知器缺点的更好的分类器的开发。</p><p id="f9cf" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">谢谢你把这个帖子看完！</p><p id="92dc" class="pw-post-body-paragraph jd je hi jf b jg kr ji jj jk ks jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">注意安全！</p></div></div>    
</body>
</html>