<html>
<head>
<title>Understanding Java Thread Synchronization with methods vs objects vs locks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用方法、对象和锁理解Java线程同步</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-java-thread-synchronization-with-methods-vs-objects-vs-locks-5428e3342fee?source=collection_archive---------3-----------------------#2020-10-10">https://medium.com/analytics-vidhya/understanding-java-thread-synchronization-with-methods-vs-objects-vs-locks-5428e3342fee?source=collection_archive---------3-----------------------#2020-10-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/066c24dd6e6b261985cb1705e3cbd22e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgNTCATIr9_RRYhLPU9_tw.jpeg"/></div></div></figure><p id="cfcc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下我们有两个函数的情况。</p><p id="b168" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个增加计数器字段的值，另一个减少该值。我们希望使用多线程来实现这一点。</p><p id="cf56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">操作系统将尝试抢占并自行调度两个线程进行优化。所以我们不能依赖线程的执行顺序。</em></p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/775ebe4c92695beefcb84805b16b1031.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*8tO5gb0mUWcTOd5-2-iJNw.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">问题</figcaption></figure><p id="db8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">但是上面这段代码有一个问题。</strong></p><p id="5bed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">问题1 : </strong>我们使用两个线程来访问共享内存(common class object = new common class()在堆上分配，因此counter字段是共享的)，<br/>我们在这里面临一个问题，因为我们不确定counter的值。<br/>可能发生的情况是，线程1将值增加了两次，而线程2仅减少了一次。</p><p id="d496" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">。</strong></p><p id="5fbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">问题2 : </strong>我们这里有非原子操作，也就是this.counter++做三件事读取计数器值，增加它，写它。<br/>因此，我们可能会覆盖一个线程完成的工作或读取不一致的值，因为线程上下文切换可能随时发生。</p><p id="565b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">因此，识别可能出现这些问题的代码片段非常重要。我们称之为临界区。</strong></p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/1377c698be36c8c377fc4d1169c6ab43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Na50BebAfX3ug4uOtuAFmg.jpeg"/></div></div></figure><p id="9596" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">解决问题有两种主要方法:</strong></p><h1 id="8120" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">解决方案1:对方法使用synchronized关键字来同步线程。</strong></h1><p id="25b0" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我们知道incrementValue和decrementValue函数是这里的关键部分。它们在共享内存上执行非原子操作。<br/>所以我们可以对函数使用synchronized关键字。当其他线程在其中时，这将阻止一个线程进入临界区(increment value&amp;decrement value)。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/7213b6154de94d1b22c0f6c82a6a960d.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*0OdNr32wCzJjBcyE3p4rZg.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">答案1</figcaption></figure><p id="3636" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是它是如何工作的呢？ <br/> <em class="jo">两种方法确实是同一个对象(object)的一部分，两个同步块(incrementValue和decrementValue) <br/>在同一个对象上同步(</em><strong class="is hj"><em class="jo">‘this’</em></strong><em class="jo">object)。</em></p><p id="7d47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们能做得更好吗？ <br/> <em class="jo">是的，我们可以不同步整个方法，而是使用外部锁只同步关键部分。</em></p><h1 id="e8f4" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi">.</h1><h1 id="e2b1" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">解决方案<strong class="ak"> 2:使用外部锁同步线程</strong></h1><p id="7530" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated"><em class="jo">我们可以创建一个对象(任何对象)并使用它作为外部锁。<br/>这里我们可以使用synchronized关键字进行锁定。<br/>这将阻止一个线程进入临界区(increment value&amp;decrement value ),当其他线程在其中时。</em></p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/e9cec64e4243f488de1a4a4bbda67619.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*ZkqEUVQcnx1YhZzezULB2A.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">答案2</figcaption></figure><p id="1915" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是它是如何工作的呢？ <br/> <em class="jo">两种方法确实是同一个对象(object)的一部分，两个同步块在同一个对象上同步(</em> <strong class="is hj"> <em class="jo">锁</em> </strong> <em class="jo">)。<br/>即使synchronized关键字对于方法来说也不过是一个synchronized on</em><strong class="is hj"><em class="jo">‘this’</em></strong><em class="jo">类的对象。</em></p><p id="2b20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">让我们在下面给出的示例中比较这两种解决方案。</em></p><blockquote class="le lf lg"><p id="ba74" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">。</em> </strong></p></blockquote><p id="2ff1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">。</em> </strong></p><p id="9372" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">。</em> </strong></p><blockquote class="le lf lg"><p id="b14e" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">示例1</em></strong><em class="hi"><br/>public synchronized void increment value(){<br/>this . counter++；<br/> } </em></p><p id="2968" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">示例2</em></strong><em class="hi"><br/>public void increment value(){<br/>synchronized(this){ this . counter++；} <br/> } </em></p></blockquote><h1 id="f542" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">解决方案3:使用不同的锁同步线程</strong></h1><p id="388a" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我们可以使用不同的锁来同步线程。<br/>假设有两个计数器(计数器1和计数器2 ),我们想增加一个，减少另一个。我们可以在这里使用多线程来并发或并行地执行它们。</p><p id="6aae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">我们使用两个线程来访问共享内存(common class object = new common class()在堆上分配)<br/>我们可以为两个部分使用两个锁。</em></p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/b56ccfd2c50779ac1ba7bc5cccc661ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*hZtPUZsI4dpWTvotVFE44A.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">答案3</figcaption></figure><p id="18ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是它是如何工作的呢？ <br/> <em class="jo">这两种方法确实是同一个对象(object)的一部分，但是两个同步的块(incrementvaluecounter 1&amp;decrement value counter 2)、<br/>在不同的对象(</em> <strong class="is hj"> <em class="jo"> lock1和lock2 </em> </strong> <em class="jo">)上同步，因此不会相互影响。</em></p><p id="d5be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，在这种情况下，我们甚至不需要锁或多线程。</p><h1 id="7a2c" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">。</strong></h1><h1 id="3326" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">。</strong></h1><h1 id="05eb" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">解决方案4:同步不同对象的线程</strong></h1><p id="1bdb" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我们使用两个线程来访问堆上的非共享内存。<br/>对象1和对象2独立于堆。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/7f33702a0d455dea01592e01f363c620.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*8ft2hc2DpbA-J4LPO8HVLA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">答案4</figcaption></figure><p id="48e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是它是如何工作的呢？ <br/> <em class="jo">该方法确实是不同对象(object1和object2)的一部分，因此synchronized块(两个对象的incrementValue)，<br/>在不同对象上同步(</em> <strong class="is hj"> <em class="jo">，【object1的this】和【object2的this】</em></strong><em class="jo">)，因此不会相互影响。</em></p><p id="82a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上在这种情况下我们甚至不需要锁。</p><p id="d41c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请关注本系列，阅读更多关于Java多线程、并发和并行编程的文章</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="a06c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里阅读更多关于并发编程的内容</p><p id="a17e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">Java中的锁:</strong><a class="ae lt" rel="noopener" href="/analytics-vidhya/understanding-java-thread-synchronization-with-methods-vs-objects-vs-locks-5428e3342fee">https://medium . com/analytics-vid hya/understanding-Java-thread-synchron ization-with-methods-vs-objects-vs-Locks-5428 e 3342 fee</a></p><p id="c519" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">重入锁:</strong><a class="ae lt" rel="noopener" href="/analytics-vidhya/unlock-the-power-of-reentrant-lock-in-java-d55ae9135443">https://medium . com/analytics-vid hya/unlock-the-power-of-Reentrant-lock-in-Java-d55ae 9135443</a></p></div></div>    
</body>
</html>