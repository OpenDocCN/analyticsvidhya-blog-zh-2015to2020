<html>
<head>
<title>A Step-by-Step NLP Guide to Learn ELMo for Extracting Features from Text</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习ELMo从文本中提取特征的分步NLP指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-step-by-step-nlp-guide-to-learn-elmo-for-extracting-features-from-text-de0d77e32a99?source=collection_archive---------1-----------------------#2019-03-10">https://medium.com/analytics-vidhya/a-step-by-step-nlp-guide-to-learn-elmo-for-extracting-features-from-text-de0d77e32a99?source=collection_archive---------1-----------------------#2019-03-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6f07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我研究不同的自然语言处理(NLP)问题(作为数据科学家的额外津贴！).每个NLP问题都是一个独特的挑战。这反映了人类语言是多么复杂、美丽和奇妙。</p><p id="b2e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但有一件事一直是NLP从业者心中的一根刺，那就是(机器)无法理解句子的真正含义。是的，我说的是语境。当要求执行基本任务时，传统的NLP技术和框架非常有用。当我们试图给情况添加背景时，事情很快就变糟了。</p><p id="923d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在过去的18个月左右的时间里，NLP的前景发生了显著的变化。像谷歌的BERT和Zalando的Flair这样的NLP框架能够解析句子，并掌握句子的上下文。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/06ab4f0c01754dd8c49bf44908301abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*eZxU0lAntq6KmY0B.png"/></div></figure><h1 id="0cc0" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">语言模型嵌入(ELMo)</h1><p id="c41e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">这方面最大的突破之一要归功于ELMo，它是AllenNLP开发的最先进的NLP框架。当你读完这篇文章的时候，你也会像我一样成为一个超级ELMo迷。</p><p id="5013" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将探索ELMo(来自语言模型的嵌入),并使用它在真实世界的数据集上使用Python 构建一个令人兴奋的<a class="ae jd" href="https://courses.analyticsvidhya.com/bundles/nlp-combo?utm_medium=ELMoNLParticle&amp;utm_source=blog" rel="noopener ugc nofollow" target="_blank"> NLP模型。</a></p><p id="f42d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kp">注意:本文假设你熟悉不同类型的单词嵌入和LSTM架构。您可以参考以下文章了解更多主题:</em></p><ul class=""><li id="32c7" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated"><a class="ae jd" href="https://www.analyticsvidhya.com/blog/2017/06/word-embeddings-count-word2veec/?utm_medium=ELMoNLParticle&amp;utm_source=medium" rel="noopener ugc nofollow" target="_blank"> <em class="kp">对单词嵌入的直观理解</em> </a></li><li id="80cf" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated"><a class="ae jd" href="https://www.analyticsvidhya.com/blog/2017/12/fundamentals-of-deep-learning-introduction-to-lstm/?utm_medium=ELMoNLParticle&amp;utm_source=medium" rel="noopener ugc nofollow" target="_blank"> <em class="kp">深度学习精要:长短期记忆入门</em> </a></li></ul><h1 id="38e5" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">目录</h1><ol class=""><li id="111c" class="kq kr hi ih b ii kk im kl iq le iu lf iy lg jc lh kw kx ky bi translated">ELMo是什么？</li><li id="3c96" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc lh kw kx ky bi translated">了解ELMo的工作原理</li><li id="db8b" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc lh kw kx ky bi translated">ELMo与其他单词嵌入有何不同？</li><li id="8e99" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc lh kw kx ky bi translated">实现:用于Python中文本分类的ELMo</li><li id="3596" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc lh kw kx ky bi translated">我们还能拿埃尔莫怎么办？</li></ol><h1 id="7d9e" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">ELMo是什么？</h1><p id="5bb0" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">不，我们所指的ELMo不是芝麻街里的角色！上下文重要性的经典例子。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es li"><img src="../Images/4e642736b71de84bf2868895882a33cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*4B-YOWxF3D_dFUsn.jpg"/></div></figure><p id="031b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ELMo是一种在向量或嵌入中表示单词的新方法。这些单词嵌入有助于在几个NLP任务中实现最先进的(SOTA)结果:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lj"><img src="../Images/2a9e5e960693260ab89e23773f0f99af.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*Wfy0kZ6ow1ROmz8Y6RngJg.png"/></div></figure><p id="9911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">全球的NLP科学家已经开始使用ELMo完成各种NLP任务，无论是在研究领域还是在工业领域。你必须在这里查看埃尔莫的原始研究论文——https://arxiv.org/pdf/1802.05365.pdf。我通常不要求人们阅读研究论文，因为它们经常会显得沉重和复杂，但我为ELMo破例。这是一个非常酷的关于ELMo是如何设计的解释。</p><h1 id="8beb" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">了解ELMo的工作原理</h1><p id="3e38" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">在用Python实现ELMo之前，让我们先直观地了解一下它是如何工作的。为什么这很重要？</p><p id="4639" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下。您已经成功地将ELMo代码从GitHub复制到Python中，并成功地在您的定制文本数据上构建了一个模型。你得到的结果一般，所以你需要改进模型。如果你不了解ELMo的架构，你会怎么做呢？如果你没有研究过，你会调整哪些参数？</p><p id="8f93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个思路适用于所有的机器学习算法。你不需要研究它们的推导过程，但是你应该知道足够多的知识来使用它们并改进你的模型。</p><p id="ba3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们回到ELMo是如何工作的。</p><p id="e8fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我前面提到的，ELMo单词向量是在两层双向语言模型(biLM)之上计算的。这个biLM模型有两层堆叠在一起。每层有两个通道—向前通道和向后通道:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lk"><img src="../Images/4a685e79c83d20e0d5c81ef892fafe87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6HbS42ZeSSiSpWb1.gif"/></div></div></figure><ul class=""><li id="11af" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">上面的架构使用字符级卷积神经网络(CNN)将文本串的单词表示成原始单词向量</li><li id="f576" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">这些原始单词向量充当biLM第一层的输入</li><li id="965b" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">向前传递包含关于某个单词和该单词之前的上下文(其他单词)的信息</li><li id="cb06" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">反向传递包含关于单词及其后的上下文的信息</li><li id="5c07" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">来自向前和向后传递的这一对信息形成了中间单词向量</li><li id="8e0a" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">这些中间字向量被送入biLM的下一层</li><li id="90fd" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">最终表示(ELMo)是原始单词向量和两个中间单词向量的加权和</li></ul><p id="1da2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于biLM的输入是根据字符而不是单词计算的，因此它捕获了单词的内部结构。例如，biLM将能够计算出像<em class="kp">美</em>和<em class="kp">美</em>这样的术语在某种程度上是相关的，甚至不需要查看它们经常出现的上下文。听起来不可思议！</p><h1 id="425c" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">ELMo与其他单词嵌入有何不同？</h1><p id="ace2" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">与传统的单词嵌入不同，如<a class="ae jd" href="https://www.analyticsvidhya.com/blog/2017/06/word-embeddings-count-word2veec/?utm_source=ELMoNLParticle&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> word2vec </a>和<a class="ae jd" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank"> GLoVe </a>，分配给令牌或单词的ELMo向量实际上是包含该单词的整个句子的函数。因此，同一个词在不同的语境下可以有不同的词向量。</p><p id="c0d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我可以想象你会问——知道这一点对我处理NLP问题有什么帮助？让我用一个例子来解释一下。</p><p id="7521" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有几个句子:</p><ol class=""><li id="0dce" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc lh kw kx ky bi translated">我昨天<strong class="ih hj"> <em class="kp">读了</em> </strong>这本书。</li><li id="3344" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc lh kw kx ky bi translated">你现在能读懂这封信吗？</li></ol><p id="9585" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">花点时间思考一下这两者之间的区别。第一句中的动词“read”是过去式。同一个动词在第二句中变成了现在时。这是一个多义词的例子，一个词可能有多个意思。</p><p id="ede8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">语言是如此奇妙复杂的东西。</p><p id="63c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">传统的单词嵌入会为两个句子中的单词“read”提供相同的向量。因此，他们无法区分多义词。</p><p id="99ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ELMo word vectors成功解决了这个问题。ELMo单词表示将整个输入句子带入等式，用于计算单词嵌入。因此，术语“读”在不同的上下文中将具有不同的ELMo向量。</p><h1 id="2afa" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">实现:用于Python中文本分类的ELMo</h1><p id="b901" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">现在，您期待已久的时刻到了——用Python实现ELMo！让我们一步一步来。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lp"><img src="../Images/5ec558b6e4c4aae601df1a3f4bdb9b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zlxOoxYacm5vjp9j.png"/></div></div></figure><h2 id="dec4" class="lq jn hi bd jo lr ls lt js lu lv lw jw iq lx ly ka iu lz ma ke iy mb mc ki md bi translated">1.理解问题陈述</h2><p id="c8e6" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">应对任何<a class="ae jd" href="https://datahack.analyticsvidhya.com/contest/all/?utm_medium=ELMoNLParticle&amp;utm_source=blog" rel="noopener ugc nofollow" target="_blank">数据科学挑战</a>的第一步是定义问题陈述。这是我们未来行动的基础。</p><p id="d3b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于本文，我们已经有了问题陈述:</p><p id="b600" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">情感分析仍然是自然语言处理广泛应用的关键问题之一。这一次，考虑到顾客发来的关于制造和销售手机、电脑、笔记本电脑等各种科技公司的推文。的任务是识别推文是否对这类公司或产品有负面情绪。 </p><p id="919b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这显然是一个二元文本分类任务，我们必须从提取的推文中预测情感。</p><h2 id="6bb3" class="lq jn hi bd jo lr ls lt js lu lv lw jw iq lx ly ka iu lz ma ke iy mb mc ki md bi translated">2.关于数据集</h2><p id="9d4b" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">这是我们拥有的数据集的细分:</p><ul class=""><li id="c1e7" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">火车集合包含7，920条推文</li><li id="b1b3" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">测试集包含1953条推文</li></ul><p id="93f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">你可以从这个</strong> <a class="ae jd" href="https://datahack.analyticsvidhya.com/contest/linguipedia-codefest-natural-language-processing-1/#data_dictionary" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">页面</strong> </a> <strong class="ih hj">下载数据集。<em class="kp"> </em> </strong> <em class="kp">注意，你必须注册或登录才能这样做。</em></p><p id="dab7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>推文中大部分亵渎和低俗的词语已被替换为“$ &amp; @*#”。但是，请注意，数据集可能仍然包含可能被视为亵渎、粗俗或冒犯的文本。</p><p id="9f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，让我们启动我们最喜欢的Python IDE，开始编码吧！</p><h2 id="687d" class="lq jn hi bd jo lr ls lt js lu lv lw jw iq lx ly ka iu lz ma ke iy mb mc ki md bi translated">3.导入库</h2><p id="f08b" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">导入我们将在笔记本中使用的库:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="me mf l"/></div></figure><h2 id="f501" class="lq jn hi bd jo lr ls lt js lu lv lw jw iq lx ly ka iu lz ma ke iy mb mc ki md bi translated">4.阅读并检查数据</h2><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="81c9" class="lq jn hi mh b fi ml mm l mn mo"><em class="kp"># read data</em> <br/>train = pd.read_csv("train_2kmZucJ.csv") <br/>test = pd.read_csv("test_oJQbWVk.csv") <br/>train.shape, test.shape</span></pre><p id="97dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出:</strong> ((7920，3)，(1953，2))</p><p id="f38a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练集有7920条推文，而测试集只有1953条。现在让我们检查训练集中的类分布:</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="540b" class="lq jn hi mh b fi ml mm l mn mo">train['label'].value_counts(normalize = True)</span></pre><p id="c8a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出:</strong></p><p id="88ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 0 </strong> 0.744192</p><p id="9cc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1  0.255808</p><p id="efa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">名称:标签，型号:float64</p><p id="8b51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，1代表负面推文，而0代表非负面推文。</p><p id="ca5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们快速浏览一下列车组的前5排:</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="458d" class="lq jn hi mh b fi ml mm l mn mo">train.head()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mp"><img src="../Images/6d7ff3f738bb81615f188adc7c47887a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OIWMavx-aAl6LOlS.png"/></div></div></figure><p id="e6eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有三个栏目可以使用。列“tweet”是独立变量，而列“label”是目标变量。</p><h2 id="3a51" class="lq jn hi bd jo lr ls lt js lu lv lw jw iq lx ly ka iu lz ma ke iy mb mc ki md bi translated">5.文本清洗和预处理</h2><p id="eb95" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">在理想世界中，我们将拥有一个干净的结构化数据集。但是在NLP中事情并没有那么简单。</p><p id="db56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要花费大量时间清理数据，为模型构建阶段做好准备。从文本中提取特征变得容易，甚至特征包含更多的信息。数据质量越好，您将会看到模型性能的显著提高。</p><p id="a09a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们清理一下给我们的文本，并探索它。</p><p id="e6e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">推文中似乎有不少网址链接。他们没有告诉我们太多(如果有的话)关于推文的情绪，所以让我们删除它们。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="cbbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用正则表达式(或RegEx)来删除URL。</p><p id="fdcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong> <em class="kp">你可以在此</em> <a class="ae jd" href="https://www.analyticsvidhya.com/blog/2015/06/regular-expression-python/" rel="noopener ugc nofollow" target="_blank"> <em class="kp">文章</em> </a> <em class="kp">中了解更多关于Regex的信息。</em></p><p id="ad15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在继续做一些例行的文本清理。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="f349" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还想规范化文本，又名，执行文本规范化。这有助于把一个词简化成它的基本形式。例如，单词“生产”、“生产”和“正在生产”的基本形式是<strong class="ih hj">“产品”</strong>。经常发生的情况是，同一个单词的多种形式并不真的那么重要，我们只需要知道这个单词的基本形式。</p><p id="92c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将利用流行的空间库对文本进行词条化(规范化)。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="2474" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对训练集和测试集中的推文进行分类:</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="c762" class="lq jn hi mh b fi ml mm l mn mo">train['clean_tweet'] = lemmatization(train['clean_tweet']) test['clean_tweet'] = lemmatization(test['clean_tweet'])</span></pre><p id="b8da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们快速浏览一下原始推文和经过清理的推文:</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="aa62" class="lq jn hi mh b fi ml mm l mn mo">train.sample(10)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mq"><img src="../Images/88d83867143025f6121192f88c090fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OA-432kTfkn4D1I7.png"/></div></div></figure><p id="e1fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仔细看看上面的专栏。“clean_tweet”栏中的推文看起来比原始推文清晰得多。</p><p id="8ee5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，我觉得仍然有足够的空间来清理文本。我鼓励你尽可能多地探索数据，在文本中找到更多的见解或不规则之处。</p><h2 id="e6b6" class="lq jn hi bd jo lr ls lt js lu lv lw jw iq lx ly ka iu lz ma ke iy mb mc ki md bi translated">6.TensorFlow中心简介</h2><p id="2429" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">等等，TensorFlow和我们的教程有什么关系？</p><p id="5e88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://www.tensorflow.org/hub" rel="noopener ugc nofollow" target="_blank"> TensorFlow Hub </a>是一个库，它通过允许使用许多机器学习模型来完成不同的任务，从而实现了<a class="ae jd" href="https://www.analyticsvidhya.com/blog/2017/06/transfer-learning-the-art-of-fine-tuning-a-pre-trained-model/?utm_medium=ELMoNLParticle&amp;utm_source=blog" rel="noopener ugc nofollow" target="_blank">迁移学习</a>。ELMo就是这样一个例子。这就是我们在实施中通过TensorFlow Hub访问ELMo的原因。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mr"><img src="../Images/79c41118b5322b0f353bab08776aefa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/0*f_it4dNgwpMJFT51.png"/></div></figure><p id="f478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们做任何事情之前，我们需要安装TensorFlow Hub。要使用TensorFlow Hub，您必须将TensorFlow软件包安装或升级到至少1.7版本:</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="1280" class="lq jn hi mh b fi ml mm l mn mo">$ pip install "tensorflow&gt;=1.7.0" <br/>$ pip install tensorflow-hub</span></pre><h2 id="2957" class="lq jn hi bd jo lr ls lt js lu lv lw jw iq lx ly ka iu lz ma ke iy mb mc ki md bi translated">7.准备ELMo载体</h2><p id="1e47" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们现在将导入预训练的ELMo模型。需要注意的是——这个模型的大小超过了350 mb，所以下载它可能需要一段时间。</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="4d12" class="lq jn hi mh b fi ml mm l mn mo"><strong class="mh hj">import</strong> tensorflow_hub <strong class="mh hj">as</strong> hub <br/><strong class="mh hj">import</strong> tensorflow <strong class="mh hj">as</strong> tf <br/>elmo = hub.Module("https://tfhub.dev/google/elmo/2", trainable=<strong class="mh hj">True</strong>)</span></pre><p id="cb16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将首先向你展示我们如何得到一个句子的ELMo向量。你所要做的就是在对象<strong class="ih hj"> elmo </strong>中传递一个字符串列表。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="7458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出:</strong> TensorShape([Dimension(1)，Dimension(8)，Dimension(1024)]</p><p id="50e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出是形状(1，8，1024)的三维张量:</p><ul class=""><li id="8296" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">这个张量的第一维表示训练样本的数量。在我们的例子中是1</li><li id="e02c" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">第二维表示字符串输入列表中最长字符串的最大长度。因为我们的输入列表中只有一个字符串，所以第二维的大小等于字符串的长度— 8</li><li id="b1d0" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">第三维等于ELMo向量的长度</li></ul><p id="375b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，<strong class="ih hj">输入句子中的每个单词具有大小为1024的ELMo向量。</strong></p><p id="0d21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们继续在训练和测试数据集中提取干净的tweets的ELMo向量。然而，为了获得整个tweet的向量表示，我们将采用tweet的组成术语或令牌的ELMo向量的平均值。</p><p id="c2c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们为此定义一个函数:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="aa06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果使用上面的函数一次性提取tweets的嵌入，可能会耗尽计算资源(内存)。作为一种解决方法，将训练集和测试集分成每批100个样本。然后，将这些批处理依次传递给函数<strong class="ih hj"> elmo_vectors( ) </strong>。</p><p id="6c39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我会将这些批次保存在一个列表中:</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="49dd" class="lq jn hi mh b fi ml mm l mn mo">list_train = [train[i:i+100] <strong class="mh hj">for</strong> i <strong class="mh hj">in</strong> range(0,train.shape[0],100)] list_test = [test[i:i+100] <strong class="mh hj">for</strong> i <strong class="mh hj">in</strong> range(0,test.shape[0],100)]</span></pre><p id="9daa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将遍历这些批次并提取ELMo向量。我警告你，这需要很长时间。</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="cc04" class="lq jn hi mh b fi ml mm l mn mo"><em class="kp"># Extract ELMo embeddings</em> <br/>elmo_train = [elmo_vectors(x['clean_tweet']) <strong class="mh hj">for</strong> x <strong class="mh hj">in</strong> list_train] elmo_test = [elmo_vectors(x['clean_tweet']) <strong class="mh hj">for</strong> x <strong class="mh hj">in</strong> list_test]</span></pre><p id="235d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们有了所有的向量，我们可以将它们连接成一个数组:</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="d1b7" class="lq jn hi mh b fi ml mm l mn mo">elmo_train_new = np.concatenate(elmo_train, axis = 0) <br/>elmo_test_new = np.concatenate(elmo_test, axis = 0)</span></pre><p id="9cff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我会建议你保存这些数组，因为我们花了很长时间来获得它们的ELMo向量。我们将把它们保存为pickle文件:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="b475" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用以下代码将它们加载回来:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="me mf l"/></div></figure><h2 id="01e6" class="lq jn hi bd jo lr ls lt js lu lv lw jw iq lx ly ka iu lz ma ke iy mb mc ki md bi translated">8.模型建立和评估</h2><p id="166e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">让我们用ELMo建立我们的NLP模型！</p><p id="8c73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用训练数据集的ELMo向量来建立分类模型。然后，我们将使用该模型对测试集进行预测。但是在这之前，将<strong class="ih hj"> elmo_train_new </strong>分成训练和验证集，以便在测试阶段之前评估我们的模型。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="ee2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们的目标是设定一个基线分数，我们将使用ELMo向量作为特征建立一个简单的逻辑回归模型:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="55ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预测时间！首先，在验证集上:</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="a6ae" class="lq jn hi mh b fi ml mm l mn mo">preds_valid = lreg.predict(xvalid)</span></pre><p id="0c38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将通过F1评分标准评估我们的模型，因为这是<a class="ae jd" href="https://datahack.analyticsvidhya.com/contest/linguipedia-codefest-natural-language-processing-1/" rel="noopener ugc nofollow" target="_blank">竞赛</a>的官方评估标准。</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="a77b" class="lq jn hi mh b fi ml mm l mn mo">f1_score(yvalid, preds_valid)</span></pre><p id="6081" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出:</strong> 0.789976</p><p id="4f2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">验证集上的F1分数令人印象深刻。现在让我们继续对测试集进行预测:</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="1b65" class="lq jn hi mh b fi ml mm l mn mo"><em class="kp"># make predictions on test set</em> <br/>preds_test = lreg.predict(elmo_test_new)</span></pre><p id="bf54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准备我们将上传到竞赛页面的提交文件:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="bac6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些预测在<a class="ae jd" href="https://datahack.analyticsvidhya.com/contest/linguipedia-codefest-natural-language-processing-1/lb" rel="noopener ugc nofollow" target="_blank">公众排行榜</a>上给了我们<strong class="ih hj"> 0.875672 </strong>的分数。坦白地说，鉴于我们只做了相当基本的文本预处理，并且使用了一个非常简单的模型，这是非常令人印象深刻的。想象一下，如果使用更先进的技术，分数会是多少。在您的终端上试用它们，并让我知道结果！</p><h1 id="cf89" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">我们还能拿埃尔莫怎么办？</h1><p id="4916" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们刚刚亲眼目睹了ELMo对于文本分类的有效性。如果再加上一个更复杂的模型，它肯定会有更好的表现。ELMo的应用不仅限于文本分类的任务。每当需要对文本数据进行矢量化时，都可以使用它。</p><p id="0d13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是几个我们可以利用ELMo的NLP任务:</p><ul class=""><li id="93c6" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">机器翻译</li><li id="923b" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">语言建模</li><li id="c92e" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">文本摘要</li><li id="6cad" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">命名实体识别</li><li id="563a" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">问答系统</li></ul><h1 id="18c3" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">结束注释</h1><p id="9f11" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">毫无疑问，ELMo是NLP的一个重大进步，并将继续存在。鉴于自然语言处理研究的快速进展，其他新的最先进的单词嵌入技术也在过去几个月中出现，如Google BERT和Falando的Flair。NLP从业者的激动人心的时刻即将到来！</p><p id="19f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我强烈建议您在其他数据集上使用ELMo，亲自体验性能提升。如果你有任何问题或者想与我和社区分享你的经验，请在下面的评论区提出。如果你是这个领域的新手，你也应该看看下面的NLP相关资源:</p><ul class=""><li id="65dd" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated"><a class="ae jd" href="https://courses.analyticsvidhya.com/courses/natural-language-processing-nlp?utm_medium=ELMoNLParticle&amp;utm_source=blog" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">自然语言处理课程</strong> </a></li><li id="562d" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated"><a class="ae jd" href="https://courses.analyticsvidhya.com/bundles/nlp-combo?utm_medium=ELMoNLParticle&amp;utm_source=blog" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">认证项目:自然语言处理(NLP)初学者</strong> </a></li></ul></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><p id="5dc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kp">原载于2019年3月10日</em><a class="ae jd" href="https://www.analyticsvidhya.com/blog/2019/03/learn-to-use-elmo-to-extract-features-from-text/" rel="noopener ugc nofollow" target="_blank"><em class="kp">www.analyticsvidhya.com</em></a><em class="kp">。</em></p></div></div>    
</body>
</html>