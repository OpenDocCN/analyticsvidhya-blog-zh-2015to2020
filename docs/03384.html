<html>
<head>
<title>Writing Efficient Codes and Automation for a Data Scientist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为数据科学家编写高效代码和自动化</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/writing-efficient-codes-and-automation-for-a-data-scientist-b24fa30077d?source=collection_archive---------18-----------------------#2020-01-28">https://medium.com/analytics-vidhya/writing-efficient-codes-and-automation-for-a-data-scientist-b24fa30077d?source=collection_archive---------18-----------------------#2020-01-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="fdc5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">需要了解的编程和Python库原则</h1><p id="128a" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">数据科学家用构建模型的知识编写代码，并总结发现。有时，他们共享导致结果的代码或模型。数据科学家来自各种背景，许多人没有计算机科学或编程培训。编写共享的代码时，应该牢记一些容易被忽略的编程技巧。</p><h2 id="ca08" class="kj ig hi bd ih kk kl km il kn ko kp ip jw kq kr it ka ks kt ix ke ku kv jb kw bi translated">干(不要重复自己):编写模块化/可重用代码</h2><p id="25a0" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">DRY是一个简单的编程原则，它基本上意味着您不应该在多个地方编写相同的代码/配置。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div class="er es kx"><img src="../Images/18cb4202764429827f785aa0d59fe68a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*Fh8AV-h5FS1OnSTT.jpg"/></div></figure><p id="fa99" class="pw-post-body-paragraph jl jm hi jn b jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">例如，当试图绘制一个散点图和两个箱线图时，这些单个图的标签、标题和其他可视化参数的设置可能会变成大量重复的代码，如下所示。</p><pre class="ky kz la lb fd lk ll lm ln aw lo bi"><span id="f4da" class="kj ig hi ll b fi lp lq l lr ls">sns.scatterplot(x='x', y='y', data=data, palette='cubehelix')<br/>plt.xlabel('xlabel')<br/>plt.ylabel('ylabel')<br/>plt.xticks(rotation=45)<br/>plt.title('Scatter Plot Title')<br/>plt.legend(title='Legend Title')<br/>ax.spines['left'].set_color('k')<br/>ax.spines['bottom'].set_color('k')</span><span id="f493" class="kj ig hi ll b fi lt lq l lr ls">sns.boxplot(x=x, y=y, hue=hue, data=data, palette='cubehelix')<br/>plt.xlabel('xlabel')<br/>plt.ylabel('ylabel')<br/>plt.xticks(rotation=45)<br/>plt.title('1st Box Plot Title')<br/>plt.legend(title='Legend Title')<br/>ax.spines['left'].set_color('k')<br/>ax.spines['bottom'].set_color('k')</span><span id="500a" class="kj ig hi ll b fi lt lq l lr ls">sns.boxplot(x=x, y=y, hue=hue, data=data, palette='cubehelix')<br/>plt.xlabel('xlabel')<br/>plt.ylabel('ylabel')<br/>plt.xticks(rotation=45)<br/>plt.title('2nd Box Plot Title')<br/>plt.legend(title='Legend Title')<br/>ax.spines['left'].set_color('k')<br/>ax.spines['bottom'].set_color('k')</span></pre><p id="f63e" class="pw-post-body-paragraph jl jm hi jn b jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">当代码被编写为可重用时:</p><pre class="ky kz la lb fd lk ll lm ln aw lo bi"><span id="9b19" class="kj ig hi ll b fi lp lq l lr ls">def ax_params(xlabel, ylabel, plt_title=None, ax=None, legend_title=None, c='k'):<br/>    plt.xlabel(xlabel)<br/>    plt.ylabel(ylabel)<br/>    plt.xticks(rotation=45)<br/>    plt.title(plt_title)<br/>    if legend_title:<br/>        plt.legend(title=legend_title)    <br/>    if ax is None:<br/>        ax = plt.gca()<br/>    ax.spines['right'].set_visible(False)<br/>    ax.spines['top'].set_visible(False)<br/>    ax.spines['left'].set_color(c)<br/>    ax.spines['bottom'].set_color(c)<br/></span><span id="e2e8" class="kj ig hi ll b fi lt lq l lr ls">sns.scatterplot(x='x', y='y', hue='hue', data=data)<br/>ax_params('xlabel', 'ylabel', 'Scatter Plot Title')</span><span id="a6a0" class="kj ig hi ll b fi lt lq l lr ls">sns.boxplot(x='x', y='y', hue='hue', data=data)<br/>ax_params('xlabel', 'ylabel', '1st Box Plot Title')</span><span id="a671" class="kj ig hi ll b fi lt lq l lr ls">sns.boxplot(x='x', y='y', hue='hue', data=data)<br/>ax_params('xlabel', 'ylabel', '2nd Box Plot Title')</span></pre><h2 id="1d97" class="kj ig hi bd ih kk kl km il kn ko kp ip jw kq kr it ka ks kt ix ke ku kv jb kw bi translated">编写动态使用的代码</h2><p id="c7f1" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">正如在前面的示例代码中可以看到的，代码还允许其他用例，例如当您希望轴脊通过传入参数<em class="lu"> c </em>而具有不同的颜色时，或者当您使用<em class="lu"> ax </em>设置子图轴的可视化参数时。</p><p id="66dc" class="pw-post-body-paragraph jl jm hi jn b jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">对定制功能进行小的修改也符合敏捷编程原则和版本控制。如果我要添加一个新的输入参数来控制是否保存图形<em class="lu"> savefig </em>，那么在传入<em class="lu"> 'savefig=True' </em>之前，用于绘图的3行代码的功能是相同的。</p><pre class="ky kz la lb fd lk ll lm ln aw lo bi"><span id="c044" class="kj ig hi ll b fi lp lq l lr ls">def ax_params(xlabel, ylabel, plt_title=None, ax=None, legend_title=None, c='k', savefig=False):<br/>    plt.xlabel(xlabel)<br/>    plt.ylabel(ylabel)<br/>    plt.xticks(rotation=45)<br/>    plt.title(plt_title)<br/>    if legend_title:<br/>        plt.legend(title=legend_title)<br/>    if ax is None:<br/>        ax = plt.gca()<br/>    ax.spines['right'].set_visible(False)<br/>    ax.spines['top'].set_visible(False)<br/>    ax.spines['left'].set_color(c)<br/>    ax.spines['bottom'].set_color(c)<br/>    if savefig:<br/>        plt.gcf().savefig(f'{plt_title}.png',bbox_inches='tight')</span></pre></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h2 id="0eb4" class="kj ig hi bd ih kk kl km il kn ko kp ip jw kq kr it ka ks kt ix ke ku kv jb kw bi translated">Python的“时间”模块</h2><p id="ca48" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了测试和比较代码运行的速度，Python有一个方便的“<em class="lu"> time </em>”模块。</p><p id="20c7" class="pw-post-body-paragraph jl jm hi jn b jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">下面的代码示例<em class="lu"> time.time() </em>展示了一个代码块执行多长时间的测试(来自<a class="ae mc" rel="noopener" href="/better-programming/25-useful-python-snippets-to-help-in-your-day-to-day-work-d59c636ec1b">更好的编程</a></p><pre class="ky kz la lb fd lk ll lm ln aw lo bi"><span id="a116" class="kj ig hi ll b fi lp lq l lr ls">import time<br/>start_time = time.time()<br/>a,b = 5,10<br/>c = a+b<br/>end_time = time.time()<br/>time_taken = (end_time- start_time)*(10**6)<br/>print("Time taken in micro_seconds:", time_taken) <br/><strong class="ll hj"># Time taken in micro_seconds: 39.577484130859375</strong></span><span id="4cb9" class="kj ig hi ll b fi lt lq l lr ls"><br/># Testing random_array of 1000 numbers from random vs numpy.random<br/>import random<br/>def random_array(N):<br/>    num_array = [random.randint(-N,N) for i in range(N)]<br/>    return num_array</span><span id="8f66" class="kj ig hi ll b fi lt lq l lr ls">start = time.time()<br/>random_array(1000)<br/>time_taken_random = (time.time() - start)*(10**3)</span><span id="b132" class="kj ig hi ll b fi lt lq l lr ls">start = time.time()<br/>np_random_array = np.random.randint(1000, size=1000)<br/>time_taken_np_random = (time.time() - start)*(10**3)</span><span id="d17a" class="kj ig hi ll b fi lt lq l lr ls">print("Time taken for random in milli_seconds:", time_taken_random)<br/>print("Time taken in milli_seconds:", time_taken_np_random)<br/><strong class="ll hj"># Time taken for random in milli_seconds: 1.6129016876220703<br/># Time taken for np_random in milli_seconds: 0.1647472381591797</strong></span></pre><p id="5459" class="pw-post-body-paragraph jl jm hi jn b jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated"><em class="lu"> time </em>模块中的<em class="lu"> time.sleep() </em>在您从API获取数据时特别有用，您不仅在一天内可以执行的调用次数有限，而且每分钟或每秒钟可以执行的调用次数也有限。</p><ul class=""><li id="fcc1" class="md me hi jn b jo lf js lg jw mf ka mg ke mh ki mi mj mk ml bi translated">data.gov:“使用你的API密匙，你可以发出的API请求的数量是有限制的。[…]如果您在上午10:15发出500个请求，在上午10:25发出500个请求，那么您的API密匙将会被暂时阻塞。API键的这个临时块将在上午11:15停止，此时您可以发出500个请求。上午11点25分，你可以再提出500个请求。”</li><li id="a04e" class="md me hi jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated">“FoodData Central目前将API请求的数量限制在每个IP地址每小时3，600个请求的默认速率，因为这对大多数应用程序来说已经足够了。超过此限制将导致API密钥被暂时阻止1小时”。</li><li id="39fe" class="md me hi jn b jo mm js mn jw mo ka mp ke mq ki mi mj mk ml bi translated">Foursquare:“默认的每小时限制是每个认证用户每组端点每小时500个请求。”</li></ul><p id="306a" class="pw-post-body-paragraph jl jm hi jn b jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">当有像Shopify API这样的秒速率限制时特别有用:“为了避免被节流，你可以构建你的应用平均每秒两个请求。”</p><p id="0d90" class="pw-post-body-paragraph jl jm hi jn b jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">如下所示，当使用Selenium收集数据时，尤其是在交互式网页中，使用<em class="lu"> time.sleep() </em>特别有用。下面的代码是用日期填充表单的一部分，并自动单击。</p><figure class="ky kz la lb fd lc"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="mt mu et er es mv mw bd b be z dx translated">Selinium中暂停执行的屏幕记录。</figcaption></figure><pre class="ky kz la lb fd lk ll lm ln aw lo bi"><span id="e288" class="kj ig hi ll b fi lp lq l lr ls">for date in ['2/8/2016-2/15/2016', '2/15/2016-2/28/2016']:<br/>    date_input = browser.find_element_by_name('FmFm2_Ctrl3')<br/>    date_input.clear()<br/>    time.sleep(2)<br/>    date_input.send_keys(Keys.DELETE)<br/>    date_input.send_keys(date)<br/>    time.sleep(5)<br/>    no_results = browser.find_element_by_id('m_ucSearchButtons')<br/>    no_results = int(re.search('\d+', no_results.text).group())<br/>    date_input.send_keys(Keys.RETURN)<br/>    time.sleep(2)<br/>    results_pagination(browser, no_results)<br/>    time.sleep(1)<br/>    browser.find_element_by_id('m_lbReviseSearch').click()<br/>    time.sleep(5)</span></pre></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><p id="1849" class="pw-post-body-paragraph jl jm hi jn b jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke lj kg kh ki hb bi translated">其他值得研究的Python库是来自<em class="lu">多处理</em>的并行处理<em class="lu">池</em>，以及Python生成器<em class="lu"> yield </em>，这在拆分大型数据集以进行批量训练时特别有用。</p></div></div>    
</body>
</html>