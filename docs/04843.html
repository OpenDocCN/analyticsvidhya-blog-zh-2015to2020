<html>
<head>
<title>Graph Algorithms — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图形算法—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/graph-algorithms-part-2-3a42512f1745?source=collection_archive---------15-----------------------#2020-04-02">https://medium.com/analytics-vidhya/graph-algorithms-part-2-3a42512f1745?source=collection_archive---------15-----------------------#2020-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7a925e2a26885040b204d6d3c31e9941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5xsg_WXsu-YXq1-G.png"/></div></div></figure><p id="cb10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">上一篇:</em> </strong> <a class="ae jp" rel="noopener" href="/analytics-vidhya/graph-algorithms-1-5d80d022019"> <strong class="is hj"> <em class="jo">图形算法—第一部分</em> </strong> </a></p><h2 id="32f0" class="jq jr hi bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated"><strong class="ak">目录</strong></h2><ul class=""><li id="dd85" class="kl km hi is b it kn ix ko jb kp jf kq jj kr jn ks kt ku kv bi translated">深度优先遍历</li><li id="4018" class="kl km hi is b it kw ix kx jb ky jf kz jj la jn ks kt ku kv bi translated">广度优先遍历</li><li id="248e" class="kl km hi is b it kw ix kx jb ky jf kz jj la jn ks kt ku kv bi translated">拓扑排序</li><li id="bcf5" class="kl km hi is b it kw ix kx jb ky jf kz jj la jn ks kt ku kv bi translated">循环检测</li></ul></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="61e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在树遍历中，我们总是从根节点开始。事实上，树是图的一种，所以树遍历算法也可以应用于图遍历。但是，每棵树都有一个唯一的根节点，从根节点可以到达其他所有节点。在图中，有些节点可能无法从我们的起始节点到达。</p><h1 id="7398" class="li jr hi bd js lj lk ll jw lm ln lo ka lp lq lr kd ls lt lu kg lv lw lx kj ly bi translated">深度优先遍历</h1><p id="5c12" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated"><strong class="is hj">主旨:选择一个节点开始，递归寻找邻居。</strong></p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/f9fd862dc5c3622828b84cc59e8228c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWpfDDdgl_MuXQlda7leiA.jpeg"/></div></div></figure><p id="97aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们从节点A开始，找到A的邻居，分别是B和e，假设我们接下来选择B。最后，当我们到达节点D时，它没有任何邻居，我们的递归返回。</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/4b54128ddf0c95b7f416edd01f37ce0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*DrLGOOjmOPsURd9AcakySQ.jpeg"/></div></figure><p id="30d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，我们回到C，找到C的其他邻居，但是C没有任何其他邻居。然后回到B，B有另一个邻居D，但是我们已经遍历了D，最后我们回到A，到e。</p><p id="6469" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们从B开始呢？我们联系不到急救室。</p><p id="f047" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">实现(递归)</strong></p><pre class="md me mf mg fd mi mj mk ml aw mm bi"><span id="90ce" class="jq jr hi mj b fi mn mo l mp mq">public void traverseDFT(String root) {<br/>    var node = nodes.get(root);<br/>    if (node == null) return;<br/>    traverseDFT(node, new HashSet&lt;&gt;());<br/><br/>}<br/><br/>private void traverseDFT(Node root, Set&lt;Node&gt; visitedNodes) {<br/>    // visit the root node<br/>    System.<em class="jo">out</em>.println(root);<br/>    visitedNodes.add(root);<br/>    <br/>    // find all neighbors of this node<br/>    for (var node : adjacencyList.get(root)) {<br/>        if (!visitedNodes.contains(node)) traverseDFT(node,visitedNodes);<br/>    }</span></pre><p id="7352" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">实现(迭代)</strong></p><pre class="md me mf mg fd mi mj mk ml aw mm bi"><span id="644a" class="jq jr hi mj b fi mn mo l mp mq">public void traverseDFTIter(String root) {<br/>    var node = nodes.get(root);<br/>    if (node == null) return;</span><span id="6521" class="jq jr hi mj b fi mr mo l mp mq">    Stack&lt;Node&gt; nodeStack = new Stack&lt;&gt;();<br/>    Set&lt;Node&gt; nodeVisited = new HashSet&lt;&gt;();</span><span id="30eb" class="jq jr hi mj b fi mr mo l mp mq">    nodeStack.push(node);</span><span id="e2ad" class="jq jr hi mj b fi mr mo l mp mq">    while (!nodeStack.isEmpty()) {<br/>        var current = nodeStack.pop();<br/>        if (nodeVisited.contains(current)) continue;</span><span id="c597" class="jq jr hi mj b fi mr mo l mp mq">        System.<em class="jo">out</em>.println(current);<br/>        nodeVisited.add(current);</span><span id="9993" class="jq jr hi mj b fi mr mo l mp mq">        for (var nei : adjacencyList.get(current)) {<br/>            if (!nodeVisited.contains(nei)) nodeStack.push(nei);<br/>        }<br/>    }<br/>}</span></pre><h1 id="8269" class="li jr hi bd js lj lk ll jw lm ln lo ka lp lq lr kd ls lt lu kg lv lw lx kj ly bi translated">广度优先遍历</h1><p id="f505" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated"><strong class="is hj">大意:在去下一个节点之前，访问一个节点及其所有邻居。</strong></p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/0ffd7d57569b1577d6ac2a6a803fea4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pJxCvxulvtSvLJ6f2dBdg.jpeg"/></div></div></figure><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/9affffc8f9145ed5624c5fa0c36efefb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3P-xioOr4W4UXCiXCVZrcQ.png"/></div></div></figure><p id="dbf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">实施(迭代)</strong></p><pre class="md me mf mg fd mi mj mk ml aw mm bi"><span id="f2be" class="jq jr hi mj b fi mn mo l mp mq">public void travarseBFTIter(String root) {<br/>    var node = nodes.get(root);<br/>    if (node == null) return;</span><span id="3e83" class="jq jr hi mj b fi mr mo l mp mq">    Queue&lt;Node&gt; nodeQueue = new ArrayDeque&lt;&gt;();<br/>    Set&lt;Node&gt; nodeVisited = new HashSet&lt;&gt;();</span><span id="ea5a" class="jq jr hi mj b fi mr mo l mp mq">    nodeQueue.add(node);</span><span id="8f93" class="jq jr hi mj b fi mr mo l mp mq">    while (!nodeQueue.isEmpty()) {<br/>        var current = nodeQueue.remove();<br/>        if (nodeVisited.contains(current)) continue;</span><span id="7f81" class="jq jr hi mj b fi mr mo l mp mq">        System.<em class="jo">out</em>.println(current);<br/>        nodeVisited.add(current);<br/>        <br/>        for (var nei : adjacencyList.get(current)) {<br/>            if (!nodeVisited.contains(nei)) nodeQueue.add(nei);<br/>        }<br/>    }<br/>}</span></pre><h1 id="4824" class="li jr hi bd js lj lk ll jw lm ln lo ka lp lq lr kd ls lt lu kg lv lw lx kj ly bi translated"><strong class="ak">拓扑排序</strong></h1><blockquote class="mu mv mw"><p id="b74b" class="iq ir jo is b it iu iv iw ix iy iz ja mx jc jd je my jg jh ji mz jk jl jm jn hb bi translated"><strong class="is hj">有向无环图(DAG) </strong>的拓扑排序是顶点的线性排序，使得对于每个有向边uv，顶点u在排序中位于v之前。如果图不是DAG，则图的拓扑排序是不可能的。</p></blockquote><p id="584e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于下面的DAG，让我们把每个节点想象成一个项目的过程。我们需要按顺序完成每个过程。拓扑排序的结果不是唯一的，我们可能得到1–2–3–4–5，或者1–3–2–5–4，等等。</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es na"><img src="../Images/d9e2a49ae161e6c00151e4f186eac787.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*fAwwItzhBA1lusM-.png"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">有向无环图</figcaption></figure><p id="93ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要找到最深的节点(4、5或3)并将其添加到堆栈中，该堆栈没有任何边。如何找到最深的节点？DFT！之后，转到前一个节点，如果该节点没有边，则将其添加到堆栈中；否则，转到当前节点连接的节点。最后，我们只需要弹出堆栈中的所有项目。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/30150c5811f3125127dfd0861b73a625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hP6WHyWQHHLbVx1kNJbYtw.jpeg"/></div></div></figure><pre class="md me mf mg fd mi mj mk ml aw mm bi"><span id="c11d" class="jq jr hi mj b fi mn mo l mp mq">public List&lt;String&gt; topologySort() {<br/>    Stack&lt;Node&gt; nodeStack = new Stack&lt;&gt;();<br/>    Set&lt;Node&gt; nodeSet = new HashSet&lt;&gt;();</span><span id="b58b" class="jq jr hi mj b fi mr mo l mp mq">    for (var node : nodes.values()) {<br/>        topologySort(node, nodeStack, nodeSet);<br/>    }</span><span id="8c4c" class="jq jr hi mj b fi mr mo l mp mq">    List&lt;String&gt; sorted = new ArrayList&lt;&gt;();</span><span id="abad" class="jq jr hi mj b fi mr mo l mp mq">    while (!nodeStack.isEmpty()) {<br/>        sorted.add(nodeStack.pop().label);<br/>    }</span><span id="2564" class="jq jr hi mj b fi mr mo l mp mq">    return sorted;<br/>}<br/><br/>private void topologySort(Node node, Stack&lt;Node&gt; nodeStack, Set&lt;Node&gt; visitedNodes) {<br/>    if (visitedNodes.contains(node)) return;<br/><br/>    visitedNodes.add(node);<br/><br/>    for (var nei : adjacencyList.get(node)) {<br/>        topologySort(nei, nodeStack, visitedNodes);<br/>    }<br/><br/>    nodeStack.push(node);<br/>}</span></pre><p id="09fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">提示:当我们的节点已经在层次结构的底部时，我们的程序将跳过下面的循环，并将这个节点添加到我们的堆栈中。</p><pre class="md me mf mg fd mi mj mk ml aw mm bi"><span id="47ba" class="jq jr hi mj b fi mn mo l mp mq">for (var nei : adjacencyList.get(node)) {<br/>        topologySort(nei, nodeStack, visitedNodes);<br/>    }</span></pre><h1 id="5cae" class="li jr hi bd js lj lk ll jw lm ln lo ka lp lq lr kd ls lt lu kg lv lw lx kj ly bi translated">循环检测</h1><p id="e46b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">为了检测一个有向图中的循环，我们需要三组节点——所有的<strong class="is hj">、<strong class="is hj">访问</strong>和<strong class="is hj">访问</strong>。</strong></p><p id="6aae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">All:我们图表中的所有节点。</p><p id="447d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">已访问:我们已经访问了一个节点及其所有子节点。</p><p id="bbb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">访问:我们没有访问一个节点的所有子节点。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/dac1eb145f205fd152faf4d4ba5c87d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uj4FvXjdYfbcuq1Pdx3pDg.jpeg"/></div></div></figure><p id="e8bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们从添加“all”集合中的所有节点开始。然后从这个集合中选择一个节点并开始DFT。因此，我们将它从“所有”集合中移除，并将其放入“访问”集合。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/53bf8c730cae896ebbf2205da775ff04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OiJ8Xe-Hul1tLbUFELAfmw.jpeg"/></div></div></figure><p id="8e30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们去拜访A的孩子，是B和c，我们先从B开始吧。我们应该将B从“所有”集合中移除，并将其放入“访问”集合中。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/1a36f681f2108088a14f6951a8833851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7jEy_cCvSxPM6S_qzagmg.jpeg"/></div></div></figure><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/4d10c1a9c32225fc49648bac6e6110f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3lWdhidh-2Kv2eYM5Q-CQ.jpeg"/></div></div></figure><p id="2813" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">B的孩子是C，但是C没有孩子。所以我们可以把C放在“访问过的”集合中。之后，我们访问了B的所有孩子。因此，我们可以将B放在“已访问”集合中。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/cf26e00a4fc78de915ae90bd53625a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xmnp3gpnrwTecEuaUf9npA.jpeg"/></div></div></figure><p id="5211" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">值得注意的是，当我们访问A的孩子时，我们选择与B一起去。现在，在我们访问B和B的孩子后，我们需要与C一起去。然而，C已经在“已访问”集中。因此，我们可以将A放在“已访问”集合中。</p><p id="4c33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们可以直接将D放入已访问过的集合中，因为D的孩子已经被访问过了。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/f98c1766db1ee058d59a261c12ddceb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWdaM5hdKPQEVpZh7w3mjw.jpeg"/></div></div></figure><p id="4eee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有的节点都在“访问过的”集合中，所以在我们的图中没有循环。</p><p id="c918" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们改变A和C之间的边的方向呢？</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/703bceef37268fbba2d00c8116550adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ziriwoicc05cOEjtHZEVzw.jpeg"/></div></div></figure><p id="974c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在重复了上面的一些步骤后，我们在寻找C的孩子，这里是有趣的部分，因为C的孩子，也就是A，在我们的“访问”集中。因此，从一个子节点到它的父节点一定有一条边，这意味着这个图包含一个圈。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/13859dfb61b9e93f559c115192111146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9PqCujH1YrkL-BOfjCLEw.jpeg"/></div></div></figure><p id="8695" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了判断循环在哪里，我们需要一个散列表来存储每一对父子关系。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/9a62051228de1da5d74777323b6db007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SZluExT7A-KStpB1lsHq1Q.jpeg"/></div></div></figure><pre class="md me mf mg fd mi mj mk ml aw mm bi"><span id="d940" class="jq jr hi mj b fi mn mo l mp mq">public boolean hasCycle() {<br/>    Set&lt;Node&gt; all = new HashSet&lt;&gt;();<br/>    all.addAll(nodes.values());</span><span id="953f" class="jq jr hi mj b fi mr mo l mp mq">    Set&lt;Node&gt; visiting = new HashSet&lt;&gt;();<br/>    Set&lt;Node&gt; visited = new HashSet&lt;&gt;();<br/><br/>    while (!all.isEmpty()) {<br/>        // pick the first node in all set<br/>        var current = all.iterator().next();<br/>        if (hasCycle(current, all, visiting,visited)) return true;<br/>    }<br/>    <br/>    return false;<br/>}<br/><br/>private boolean hasCycle(Node node, Set&lt;Node&gt; all,Set&lt;Node&gt; visiting, Set&lt;Node&gt; visited){<br/>    all.remove(node);<br/>    visiting.add(node);<br/><br/>    for (var nei : adjacencyList.get(node)) {<br/>        if (visited.contains(nei)) continue;<br/>        if (visiting.contains(nei)) return true;<br/>        // if this child node have a cycle, return true. <br/>        if (hasCycle(nei,all,visiting,visited)) return true;<br/>    }<br/>    visiting.remove(node);<br/>    visited.add(node);</span><span id="a937" class="jq jr hi mj b fi mr mo l mp mq">    return false;<br/>}</span></pre></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="a5d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在下面找到所有的代码。<strong class="is hj"> <em class="jo"> </em> </strong>感谢您的阅读。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="nk nl l"/></div></figure><p id="1c96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">上一篇:</em> </strong> <a class="ae jp" rel="noopener" href="/analytics-vidhya/graph-algorithms-1-5d80d022019"> <strong class="is hj"> <em class="jo">图形算法—第一部分</em> </strong> </a></p><p id="b562" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">接下来:图形算法—第三部分</em> </strong></p></div></div>    
</body>
</html>