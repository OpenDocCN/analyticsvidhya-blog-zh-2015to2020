<html>
<head>
<title>Python Data Structure collection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 数据结构集合</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-data-structure-collection-2c2e1ea32fcc?source=collection_archive---------20-----------------------#2020-07-28">https://medium.com/analytics-vidhya/python-data-structure-collection-2c2e1ea32fcc?source=collection_archive---------20-----------------------#2020-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/444689645f8ad1650176256053b45596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fpD-KzJ_TVkVRjJboRC4BA.png"/></div></div></figure><div class=""/><p id="e9f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用 Python 编写的<a class="ae jo" href="https://pypi.org/project/datastructure-collection/" rel="noopener ugc nofollow" target="_blank"> datastructure_collection </a>帮助开发人员和大数据科学家实现快速高效的算法。</p><h1 id="9fb4" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">包裹</h1><p id="8719" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Pypi<a class="ae jo" href="https://pypi.org/project/datastructure-collection/" rel="noopener ugc nofollow" target="_blank">data struct er _ collection</a>包可以在<a class="ae jo" href="https://pypi.org/project/datastructure-collection/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="6463" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">入门指南</h1><p id="eae7" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">datastructure_collection 有三个数据结构类:</p><ol class=""><li id="eabb" class="ks kt ht is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated"><a class="ae jo" href="https://github.com/nyakaz73/datastructure_collection.git" rel="noopener ugc nofollow" target="_blank">二进制搜索树</a></li><li id="b24a" class="ks kt ht is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><a class="ae jo" href="https://github.com/nyakaz73/datastructure_collection.git" rel="noopener ugc nofollow" target="_blank">散列表</a></li><li id="4d0a" class="ks kt ht is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><a class="ae jo" href="https://github.com/nyakaz73/datastructure_collection.git" rel="noopener ugc nofollow" target="_blank">链接列表</a></li></ol><p id="4305" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我期待在未来加入更多的数据结构。</p><h1 id="c6d9" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">装置</h1><p id="4992" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">运行以下命令来安装软件包:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9894" class="lp jq ht ll b fi lq lr l ls lt">pip install datastructure_collection</span></pre><h1 id="ea1f" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用</h1><p id="d438" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><a class="ae jo" href="https://github.com/nyakaz73/datastructure_collection/blob/master/tests/datastructure_example.py" rel="noopener ugc nofollow" target="_blank">示例</a></p><p id="ae3c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使用此软件包:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0deb" class="lp jq ht ll b fi lq lr l ls lt">from datastructure_collection import BinarySearchTree</span><span id="b0f6" class="lp jq ht ll b fi lu lr l ls lt">from datastructure_collection import HashMap</span><span id="9318" class="lp jq ht ll b fi lu lr l ls lt">from datastructure_collection import LinkedList</span></pre><h1 id="c636" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.二叉查找树</h1><p id="c147" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">二叉查找树操作和时间复杂性如下表所示:</p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lv"><img src="../Images/2b87d6c90033eca843f3e73e44988b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LuKnV64qL9MUY4659Z-plw.png"/></div></div></figure><p id="0d8f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上表可以看出，由于其搜索机制，二叉查找树比线性列表有优势。将在节点的左子节点少于右子节点的情况下对树进行排序，并且由于其排序的性质，与 O(N)的列表搜索相比，这给予它 O(logN)的最佳情况运行时间。二叉查找树 O(N)的最坏情况发生在树的元素线性排序时，即(元素以递增的顺序插入)例如 2 -&gt; 3 -&gt;4 -&gt; 5 …</p><ul class=""><li id="2106" class="ks kt ht is b it iu ix iy jb ku jf kv jj kw jn lw ky kz la bi translated"><strong class="is hu">NB</strong>add、remove、minValue、maxValue <strong class="is hu">，contains </strong>和 valueOf 运算符使用搜索机制来定位目标。</li></ul><p id="77ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，二叉查找树的最坏情况可以通过使用类似于<strong class="is hu"> (AVL 树、八字树和红黑树)</strong>的数据结构实现<strong class="is hu">平衡搜索树</strong>来改善，我期待在未来添加这些数据结构。</p><h1 id="9c37" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">示例二进制搜索树</h1><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lx"><img src="../Images/a9357808a8a411e8b2fa23fef980d55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXsMEtJXl0mMzI2YKhFVuQ.png"/></div></div></figure><h1 id="29f2" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.哈希映射</h1><p id="7d20" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><a class="ae jo" href="https://pypi.org/project/datastructure-collection/" rel="noopener ugc nofollow" target="_blank"> HashMap </a>是解决大数据和映射问题最常用的数据结构。在大多数数据结构收集中，搜索是最重要的操作，因此我们需要快速有效地完成它。与搜索目标时基于关键字比较的大多数数据结构(如列表、树)不同，<a class="ae jo" href="https://pypi.org/project/datastructure-collection/" rel="noopener ugc nofollow" target="_blank">散列表</a>使用在搜索时对关键字进行<strong class="is hu">散列</strong>的概念，该概念以恒定时间 O(1)运行，以定位特定关键字的索引。我在实现哈希算法时使用了<strong class="is hu">双重哈希</strong>的概念，在<strong class="is hu">探测</strong>时使用了<strong class="is hu">封闭哈希/开放寻址</strong>。哈希算法如下:</p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ly"><img src="../Images/a3cd1035cb382873628473a0fe0fcefe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wxlceZGA3v3Zw1tVWJLZFw.png"/></div></div></figure><p id="d56a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">双重散列减少了主簇和次簇，从而减少了冲突。</p><p id="ff64" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下表显示了一个<a class="ae jo" href="https://pypi.org/project/datastructure-collection/" rel="noopener ugc nofollow" target="_blank">散列表</a>的操作和时间复杂度</p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lz"><img src="../Images/61a60dc62c06d5f2ab3d4956fa2c2e0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDcox8AY-c_zCoyzpMeSgg.png"/></div></div></figure><p id="6bef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上表可以看出，<a class="ae jo" href="https://pypi.org/project/datastructure-collection/" rel="noopener ugc nofollow" target="_blank"> HashMap </a>是实现 Map 时最强大的数据结构之一，因为它的基本核心操作即 __ <strong class="is hu"> getitem__ </strong>，<strong class="is hu"> __setitem__ </strong>，__ <strong class="is hu"> deltitem__ </strong>，在最佳情况下以常数时间 O(1)运行。哈希映射最坏情况运行时总是可以通过实现<strong class="is hu"> SortedTableMap </strong>来增强，它将最坏情况 O(N)改进为 O(logN)，我希望在将来添加数据结构。</p><h1 id="1749" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">散列表示例</h1><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ma"><img src="../Images/8be4eca4596e80e76caf7b4fdb053adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CF2G_x_zLT8k6HRqVLrXiw.png"/></div></div></figure><h1 id="6073" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.链表</h1><p id="1caf" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">有人可能会问，如果我们在 Python 中已经有了一个列表，为什么还要实现一个链表数据结构。当重新散列集合时，列表中的插入和删除操作需要移动项目。然而，这可能是耗时的，尤其是对于大量的数据集合。链表中的 add 操作符需要 O(1)时间，而 Python 列表需要 O(N)</p><p id="a914" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下表显示了<a class="ae jo" href="https://pypi.org/project/datastructure-collection/" rel="noopener ugc nofollow" target="_blank">链表</a>的操作和时间复杂度</p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mb"><img src="../Images/6af2ee9b373a5ed76c7e61ec7ebadbef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Ieohai1gdeOHL4RD3mIYQ.png"/></div></div></figure><p id="f61f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> NB </strong>。与在常数时间 O(1)运行的 add 操作不同，链表中的 append 操作需要 O(N)时间，因为它必须一直向下导航到尾部。</p><h1 id="8876" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">链接列表示例</h1><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mc"><img src="../Images/1bc7d0bc6fad1b19f7fe87be31c87f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJlh6ppVQjLTTrLQaBpsDw.png"/></div></div></figure><h1 id="be3d" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">拉取请求</h1><p id="f8ee" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我欢迎并鼓励所有拉动式请求。对于重大更改，请首先打开一个问题，讨论您希望更改的内容。</p><p id="4942" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请确保适当更新测试。</p><p id="618b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Github 回购可以在<a class="ae jo" href="https://github.com/nyakaz73/datastructure_collection" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><h1 id="f75c" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">创建和维护者</h1><ul class=""><li id="4315" class="ks kt ht is b it kn ix ko jb md jf me jj mf jn lw ky kz la bi translated">作者:<a class="ae jo" href="https://github.com/nyakaz73" rel="noopener ugc nofollow" target="_blank">塔法兹瓦·拉梅克·尼亚姆卡帕</a>:</li><li id="f4b9" class="ks kt ht is b it lb ix lc jb ld jf le jj lf jn lw ky kz la bi translated">邮箱:【【tafadzwalnyamukapa@gmail.com】T4</li><li id="03b8" class="ks kt ht is b it lb ix lc jb ld jf le jj lf jn lw ky kz la bi translated">对任何协作和远程工作开放！！</li><li id="b5a2" class="ks kt ht is b it lb ix lc jb ld jf le jj lf jn lw ky kz la bi translated">编码快乐！！</li></ul></div></div>    
</body>
</html>