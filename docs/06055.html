<html>
<head>
<title>Leveraging the Performance of Agglomerative Clustering for High-Resolution Satellite Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用高分辨率卫星图像的凝聚聚类性能</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/leveraging-the-performance-of-agglomerative-clustering-for-high-resolution-satellite-images-part-f5d54a816f3d?source=collection_archive---------12-----------------------#2020-05-10">https://medium.com/analytics-vidhya/leveraging-the-performance-of-agglomerative-clustering-for-high-resolution-satellite-images-part-f5d54a816f3d?source=collection_archive---------12-----------------------#2020-05-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fb510ea43119a6407eae6561c1333ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXtPLthexQgOV7xBJPW0_w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图一。卫星图像中水探测的无监督凝聚聚类的例子。Qaraoun湖(黎巴嫩)。</figcaption></figure><h1 id="1a67" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">更新</h1><p id="285b" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">关于课程<strong class="ju hj">科学家Python入门</strong> ( <a class="ae kq" href="https://youtu.be/oQaoj6LE5E4" rel="noopener ugc nofollow" target="_blank">可在YouTube </a> ) <strong class="ju hj"> </strong>和其他类似文章的信息，请访问我的网站<a class="ae kq" href="http://cordmaur.carrd.co/" rel="noopener ugc nofollow" target="_blank">cordmaur.carrd.co</a>。介绍</p><h1 id="29e5" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="93b6" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">聚类分析是一种用于在多维数据空间中识别(即分组)相似样本的非监督技术。在遥感数据的背景下，它主要用于像素分类，其中多维空间表示像素在<strong class="ju hj"><em class="kr"/></strong>不同波长(传感器波段)或任何其他组合下的反射率。</p><p id="1314" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">在我攻读博士学位的第一年，在保罗·萨巴捷大学(图卢兹)，更具体地说是在GET实验室工作期间，我们一直在利用来自Sentinel-2和Landsat-8任务的卫星图像来评估内陆水面。由于水的反射率会因地区、大气条件和成分的不同而有很大差异，因此采用单一的阈值或一套固定的规则来区分水和土地是不可行的。因此，挑战之一是开发一种算法来自动识别场景中的水像素。</p><p id="5803" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">选择的方法是运行无监督聚类算法来识别最接近水体像素光谱的像素。在接下来的两节中，我将简要介绍K-Means和凝聚聚类算法。如果您已经熟悉这些技术，您可以跳到<strong class="ju hj">建议的解决方案</strong>部分。使用waterdetect python包在高分辨率卫星图像中进行水检测的故事<a class="ae kq" href="https://towardsdatascience.com/water-detection-in-high-resolution-satellite-images-using-the-waterdetect-python-package-7c5a031e3d16" rel="noopener" target="_blank">中解释了底层代码以及git存储库。</a></p><h2 id="8552" class="kx iv hi bd iw ky kz la ja lb lc ld je kd le lf ji kh lg lh jm kl li lj jq lk bi translated">k均值和“鼠标”数据集</h2><p id="3140" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">到目前为止，遥感界最常用的聚类算法是K均值聚类。它很快，很容易实现或在软件包中找到，但它的结果对于这种任务来说并不好。</p><p id="6df3" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">K-Means背后的思想是，给定期望数量的聚类来分割数据集，每个样本属于最近的聚类质心。然后，该算法通过重复地将样本分配给聚类，然后重新计算质心，来搜索最小化聚类内方差(从样本到聚类质心的距离的方差)的质心。该方法的快速解释可以在下面的视频中找到。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">视频:<a class="ae kq" href="https://www.youtube.com/watch?v=_aWzGGNrcic" rel="noopener ugc nofollow" target="_blank"> K均值聚类:工作原理</a>。</figcaption></figure><p id="0bcd" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">K-Means在算法的收敛性方面有一些问题，这取决于初始化质心，但有一些替代方法，如Scikit-Learn和其他包中实现的k-means++可以克服这一问题。</p><p id="9a23" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">然而，K-Means有一个固有的缺点。最终的解决方案是Voronoi图，所有聚类共享相同的大小，这可以通过所有样本属于最近的聚类质心的初始假设来容易地解释。因此，对于具有不同聚类大小的数据集(例如“鼠标”数据集)，这可能导致次优解决方案(图2)。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/6dc90453eda94f7fbf51c81fc0c0636a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhPcrUk4LViq0y6DIG3QCw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图二。“mouse”数据集中k-means聚类的结果。</figcaption></figure><p id="2b80" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">考虑到我们的主要目标是将<strong class="ju hj"> <em class="kr">水</em> </strong>的像素与<strong class="ju hj"> <em class="kr">陆地</em> </strong>(所有其他的)的像素分开，您可以想象这些簇的大小会有多么不同(图1)。</p><h2 id="4d29" class="kx iv hi bd iw ky kz la ja lb lc ld je kd le lf ji kh lg lh jm kl li lj jq lk bi translated">另一种选择是:凝聚集群</h2><p id="9181" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">为了克服这个K-Means问题，我们选择使用凝聚聚类。凝聚聚类是层次聚类的一个子类型，遵循自下而上的方法，其中每个观察值从自己的聚类开始，然后迭代合并，直到达到所需的聚类数。</p><p id="e74e" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">该算法决定是否合并两个聚类的关键参数是度量和链接。该度量指定了观察值对之间的距离度量。我们对多维空间使用简单的欧几里德距离:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/e5c670f4832cc9c0a20d4d06082f8d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*lBkC4qSkT2RvEfJjvSOK_Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">公制公式</figcaption></figure><p id="b600" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">在这个公式中<em class="kr"> a </em>和<em class="kr"> b </em>是在一个<em class="kr"> n </em>维空间中的点坐标，而<em class="kr"> i </em>是考虑的尺寸。</p><p id="a62a" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">除了度量之外，链接标准确定了如何根据观测值之间的成对距离来计算聚类之间的距离。本研究中使用的平均关联考虑了每个聚类中所有点的平均距离，可描述为:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/2a53c50580fd6fa22285e9e4b9a3d1d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*hnP4lqYhcAyEWrKMfWvoVA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">链接公式</figcaption></figure><p id="b2af" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">在这个公式中，A和B是n维空间中的坐标，而|A|和|B|是每个聚类中的观测值的总量。</p><p id="7f3f" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">在每次迭代期间，该算法合并所有聚类中的两个聚类，这两个聚类考虑上述标准而彼此更接近。迭代继续，直到达到指定的K数。使用这种算法,“鼠标”数据集看起来会像这样:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/3a38055032a510dd68590beec998e2f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*Xuqg5nSPyGEKh_QR.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3。鼠标数据集的凝聚聚类解决方案。信用:<a class="ae kq" href="https://elki-project.github.io/tutorial/hierarchical_clustering" rel="noopener ugc nofollow" target="_blank">实现层次聚类</a>。</figcaption></figure><p id="1725" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">一切都很好，除了一个细节……一整幅Sentinel-2图像根本不适合这样的算法，原因只有一个，那就是在<a class="ae kq" href="https://towardsdatascience.com/understanding-the-concept-of-hierarchical-clustering-technique-c6e8243758ec" rel="noopener" target="_blank"> <strong class="ju hj">理解层次聚类技术的概念</strong> </a>的故事中解释的:</p><blockquote class="lv lw lx"><p id="8b89" class="js jt kr ju b jv ks jx jy jz kt kb kc ly ku kf kg lz kv kj kk ma kw kn ko kp hb bi translated"><strong class="ju hj">层次聚类技术的空间和时间复杂度:</strong></p><p id="2465" class="js jt kr ju b jv ks jx jy jz kt kb kc ly ku kf kg lz kv kj kk ma kw kn ko kp hb bi translated"><strong class="ju hj">空间复杂度:</strong>当数据点的数量很大时，层次聚类技术所需的空间非常大，因为我们需要将相似性矩阵存储在RAM中。空间复杂度是n的平方的数量级。</p><p id="15c1" class="js jt kr ju b jv ks jx jy jz kt kb kc ly ku kf kg lz kv kj kk ma kw kn ko kp hb bi translated">空间复杂度= O(n)其中n是数据点的数量。</p><p id="24f6" class="js jt kr ju b jv ks jx jy jz kt kb kc ly ku kf kg lz kv kj kk ma kw kn ko kp hb bi translated"><strong class="ju hj">时间复杂度:</strong>由于我们要进行n次迭代，每次迭代都需要更新相似度矩阵和恢复矩阵，时间复杂度也很高。时间复杂度是n的立方的数量级。</p><p id="d6ca" class="js jt kr ju b jv ks jx jy jz kt kb kc ly ku kf kg lz kv kj kk ma kw kn ko kp hb bi translated">时间复杂度= O(n)其中n是数据点的数量。</p></blockquote><h2 id="e135" class="kx iv hi bd iw ky kz la ja lb lc ld je kd le lf ji kh lg lh jm kl li lj jq lk bi translated">提议的解决方案</h2><p id="3c5e" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">正如我们所看到的，层次聚类更适合我们的任务，但由于其时间和空间的复杂性，它是不可伸缩的(这是K-Means在遥感社区中更常见的一个原因)。</p><p id="60b4" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">在我们的算法中，计算聚类的时间和空间可以达到10k，最多50k像素，但Sentinel-2图像有10980x10980…总共有<strong class="ju hj">1 . 2亿像素</strong>。</p><p id="0312" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">解决方案是对图像进行二次采样，提取完全随机的像素。这里唯一关心的是提供一个仍然可以表示整个场景和所有目标的数量。在下一个故事中，我们将证明对于Sentinel-2图像，10k像素(即0.01%)就足够了。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/0fbb541cb4d1eea2c443cda03e0ac7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6XYwCju0pc5_AaDIgFDzg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3。(a)原始图像；(b)所有像素(透明灰色)和选定像素(红色)的散点图；(c)在所选像素中产生凝聚聚类。</figcaption></figure><p id="9d5f" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">图3-a显示了哨兵2的全部场景，图3-b显示了图像中所有像素的散点图，以及用红色表示的子采样像素。由于我们的主要目标是识别水，修正的归一化水指数— MNDWI和波段B12(短波红外)分别用作Y轴和X轴。在此图中，水像素预计位于左上角，具有高MNDWI和低B12反射率。图3c示出了像素子样本的聚类解决方案。</p><p id="6d2e" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">应用聚类后，我们有了所有子采样像素的标签(图3-c ),问题变成了如何推广整个场景的聚类解决方案。</p><p id="d93a" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">这可以通过应用机器学习算法来轻松完成，该算法可以实际“学习”每个簇的特征，然后将其复制到场景中的所有其他像素。对于这个任务，许多机器学习算法是可用的。最常见的是随机森林(RF)，支持向量机(SVM)，多层感知器(MLP)，朴素贝叶斯和许多其他方法。为了实现这一点，我们可以使用像<a class="ae kq" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn </a>这样的机器学习包，这个过程基本上有两个步骤:</p><ol class=""><li id="7ce9" class="mc md hi ju b jv ks jz kt kd me kh mf kl mg kp mh mi mj mk bi translated">将模型与之前标注的数据进行拟合。这与“训练”模型是一样的。</li><li id="14e5" class="mc md hi ju b jv ml jz mm kd mn kh mo kl mp kp mh mi mj mk bi translated">预测值</li></ol><p id="b72c" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">因为我们要预测所有1.2亿像素类，所以所选算法在准确性和速度方面具有良好的性能是非常重要的。在提到的研究中效果最好的是朴素贝叶斯，它在准确性和速度上有很好的关系。</p><p id="820a" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">在Scikit中，这两个步骤可以通过以下代码获得:</p><pre class="ll lm ln lo fd mq mr ms mt aw mu bi"><span id="3bae" class="kx iv hi mr b fi mv mw l mx my"><strong class="mr hj"># train a NB classifier with the data and labels provided</strong></span><span id="faed" class="kx iv hi mr b fi mz mw l mx my">model = GaussianNB()</span><span id="793d" class="kx iv hi mr b fi mz mw l mx my">model.fit(clusters_data, clusters_labels)</span><span id="df02" class="kx iv hi mr b fi mz mw l mx my"><strong class="mr hj"># return the new predicted labels for the whole dataset</strong></span><span id="82d6" class="kx iv hi mr b fi mz mw l mx my">return model.predict(data)</span></pre><p id="aaba" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">其中<code class="du na nb nc mr b">clusters_data </code>和<code class="du na nb nc mr b">clusters_labels</code>是聚类过程中使用的向量，<code class="du na nb nc mr b">data </code>是要预测的整个场景数据。正如已经提到的，将这些步骤应用到卫星图像的代码和api将在下一篇文章中解释(准备中)。该过程的结果如图4所示，并与相同数据的K-Means聚类结果进行了比较。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/790e9cd8168b20178112e77b3602d79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKbn5WKWSgpx2qOUR4jdkw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4。使用建议的解决方案(凝聚+朴素贝叶斯)和对整个数据集使用普通K均值的聚类过程的结果。</figcaption></figure><h2 id="0c98" class="kx iv hi bd iw ky kz la ja lb lc ld je kd le lf ji kh lg lh jm kl li lj jq lk bi translated">结论</h2><p id="194e" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">正如我们所看到的，遥感中无监督分类的结果可以通过使用凝聚层次聚类而不是最常用的K-Means得到极大的改善。时间和空间复杂性的缺点可以通过所提出的对图像进行子采样并随后使用快速机器学习算法(如朴素贝叶斯)对其进行概括的解决方案来解决。这一概括步骤在不到1分钟的时间内完成，否则，用常规的聚集聚类方法将不可能实现完整的数据集。</p><p id="f90e" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">故事<a class="ae kq" href="https://towardsdatascience.com/water-detection-in-high-resolution-satellite-images-using-the-waterdetect-python-package-7c5a031e3d16" rel="noopener" target="_blank">使用waterdetect python包在高分辨率卫星图像中进行水检测</a>提供了一个在waterdetect包中应用该方法的示例。</p><p id="213e" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">图5显示了这种方法在一些法国场景中用于水识别的一些例子。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/e464fca2ecfa6d88742ccfa5f100c246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4bPa3UmtnDf928oknc52BA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图5。法国卫星图像水识别的无监督凝聚聚类。</figcaption></figure><p id="b67e" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">如果你对如何改进这个故事有任何疑问或想法，请随时联系我或在评论中发表。如果你对遥感图像的深度学习感兴趣，可以看看我关于这个主题的其他故事:</p><ul class=""><li id="57f8" class="mc md hi ju b jv ks jz kt kd me kh mf kl mg kp nf mi mj mk bi translated"><a class="ae kq" rel="noopener" href="/analytics-vidhya/a-simple-cloud-detection-walk-through-using-convolutional-neural-network-cnn-and-u-net-and-bc745dda4b04">使用卷积神经网络(CNN和U-Net)和Fast.ai库的简单云检测走查</a></li><li id="74fc" class="mc md hi ju b jv ml jz mm kd mn kh mo kl mp kp nf mi mj mk bi translated"><a class="ae kq" rel="noopener" href="/analytics-vidhya/how-to-create-a-custom-dataset-loader-in-pytorch-from-scratch-for-multi-band-satellite-images-c5924e908edf">如何在PyTorch中为Kaggle的多波段卫星图像数据集从头开始创建自定义数据集/加载器</a></li><li id="c21f" class="mc md hi ju b jv ml jz mm kd mn kh mo kl mp kp nf mi mj mk bi translated"><a class="ae kq" rel="noopener" href="/analytics-vidhya/creating-a-very-simple-u-net-model-with-pytorch-for-semantic-segmentation-of-satellite-images-223aa216e705">用PyTorch创建一个非常简单的U-Net模型，用于卫星图像的语义分割</a></li></ul><p id="c89c" class="pw-post-body-paragraph js jt hi ju b jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl kw kn ko kp hb bi translated">谢谢你。</p></div></div>    
</body>
</html>