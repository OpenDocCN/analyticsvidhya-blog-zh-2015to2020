<html>
<head>
<title>Make a clever bitcoin price chart with React and D3.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React和D3做一个巧妙的比特币价格图。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/make-a-clever-bitcoin-price-chart-with-react-and-d3-e6359d604b54?source=collection_archive---------7-----------------------#2020-01-06">https://medium.com/analytics-vidhya/make-a-clever-bitcoin-price-chart-with-react-and-d3-e6359d604b54?source=collection_archive---------7-----------------------#2020-01-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/33ecb64065294ff332e1be2ff6baf9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yfp4u8BPF39Zj-NRJeqETA.jpeg"/></div></div></figure><p id="d42b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在过去的两年里，我一直在与React和D3合作，在我的远程工作中为世界各地的初创公司和成熟公司构建定制的交互式图表:)。在那段时间里，我真的很享受使用这些工具进行可视化时所获得的灵活性，我将与你分享我的丰富经验。是的，你！</p><p id="e2e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一些人喜欢将数据可视化视为传达故事的有效方式，讲述一些有趣的见解，这些见解是某人在数据中发现的，他们希望与观众分享。人们常说一张图片代表一千个单词，我也喜欢认为数据可视化的工作方式是相同的。</p><p id="2a91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博文中，我们将使用D3(一个几乎完美灵活的JavaScript库)构建一个由coindesk支持的定制30天比特币价格图表，同时利用React(一个用于构建用户界面的JavaScript库)。</p><p id="227c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们要构建的东西，也是我将在本文中向您介绍的内容。如果你想看实际操作，这里有一个现场演示。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jp"><img src="../Images/92066aea76b2946acff4d5014f2fffc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ou1HLkguYsnmw9JTMCYDbA.png"/></div></div></figure><p id="90a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我开始使用D3之前，我必须做一些家庭工作，以确保我对一项像样的技术抱有信心，我在npm和GitHub上的发现给我开了绿灯。</p><p id="1915" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> D3有:</strong></p><ul class=""><li id="4746" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">npm上每周超过474，000次下载。</li><li id="62f0" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">GitHub上超过89，000颗星星。</li><li id="4741" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">迄今已发行228次。</li><li id="6a14" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">超过3000个依赖包。</li><li id="c82b" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">它已经存在了8年了。</li></ul><h1 id="8a24" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">实施比特币价格图表</strong></h1><p id="9200" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">我需要的30天比特币价格图表是:</p><p id="fcbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">根组件</strong></p><ul class=""><li id="627e" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">从免费的coindesk API 获取原始数据。注意，coindesk是一个专门研究比特币和数字货币的新闻网站。</li><li id="0a02" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">管理原始数据的更新</li><li id="838f" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">管理需要重新绘制图表的交互状态(过滤、聚合、排序等)。)</li></ul><p id="aff5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">子组件</strong></p><ul class=""><li id="fea8" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">作为属性传入原始数据。</li><li id="d644" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">将原始数据转换为屏幕空间。</li><li id="f5c7" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">呈现计算的数据。</li><li id="cbf5" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">管理不需要重绘图表的交互状态(悬停、单击)。</li></ul><p id="bda2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在哪里计算数据</strong></p><ul class=""><li id="21a8" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">我们将从<em class="ll">getDerivedStateFromProps</em>方法计算我们的数据，因为它简单明了。你还应该注意到，只要React可以在它的<strong class="is hj"> render </strong>函数中访问它，D3计算就可以在的任何地方进行<em class="ll">(这对你的项目有意义)。</em></li></ul><blockquote class="lm ln lo"><p id="fa47" class="iq ir ll is b it iu iv iw ix iy iz ja lp jc jd je lq jg jh ji lr jk jl jm jn hb bi translated">永远不要让D3和React管理DOM的相同部分!!<br/>还是虫子！！—雪莉·吴</p></blockquote><p id="f97b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> D3轴</strong></p><ul class=""><li id="0765" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">轴对于使数据可读非常重要，D3使得创建它们变得容易。</li><li id="a8eb" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">在React生命周期开始时创建<code class="du ls lt lu lv b">axisLeft()</code>或<code class="du ls lt lu lv b">axisBottom()</code>并设置相应的比例。</li><li id="8230" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">在<em class="ll"> render </em>方法中创建一个<em class="ll"> svg </em> group元素。</li><li id="af0d" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">在<em class="ll"> componentDidUpdate中的组元素上调用轴。</em></li></ul><h1 id="267d" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">下面是我如何做的。</h1><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="07b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了快速开始这个项目，我用create-react-app引导了这个应用程序，这是一个学习react的舒适环境，也可能是在React中开始构建新的单页应用程序的最佳方式。在引擎盖下，它使用了Babel和webpack，但是你不需要了解它们的任何东西。</p><p id="30e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将从我的根组件<code class="du ls lt lu lv b">App.js</code>中的代码开始，它负责从<a class="ae jo" href="https://api.coindesk.com/v1/bpi/historical/close.json" rel="noopener ugc nofollow" target="_blank"> free coindesk AP </a> I获取数据，格式化原始数据并将其作为道具传递给子组件。</p><p id="facc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ls lt lu lv b"><strong class="is hj">App.js</strong></code></p><pre class="jq jr js jt fd ly lv lz ma aw mb bi"><span id="41eb" class="mc kj hi lv b fi md me l mf mg">import React from "react";<br/>import Chart from "./Chart";</span><span id="713d" class="mc kj hi lv b fi mh me l mf mg">class App extends React.Component {<br/>constructor(props) {<br/>  super(props);<br/>  this.state = {<br/>    data: []<br/>  };<br/>}</span><span id="9023" class="mc kj hi lv b fi mh me l mf mg">componentDidMount() {<br/>  fetch(`https://api.coindesk.com/v1/bpi/historical/close.json`)<br/>    .then(response =&gt; response.json())<br/>    .then(data =&gt; {<br/>      this.setState({<br/>       data: Object.keys(data.bpi).map(date =&gt; {<br/>       return {<br/>          date: new Date(date),<br/>          price: data.bpi[date]<br/>         };<br/>      })<br/>    });<br/>  })<br/>   .catch(error =&gt; console.log(error));<br/>}</span><span id="d2fe" class="mc kj hi lv b fi mh me l mf mg">  render() {<br/>  const { data } = this.state;</span><span id="6ea2" class="mc kj hi lv b fi mh me l mf mg">return (<br/>     &lt;div&gt;<br/>       &lt;h2 style={{ textAlign: "center" }}&gt;<br/>         30 day Bitcoin Price Chart<br/>       &lt;/h2&gt;<br/>       &lt;Chart data={data} /&gt;<br/>     &lt;/div&gt;<br/>      );<br/>   }<br/>}<br/>export default App;</span></pre><p id="f629" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，我知道这有点多的代码，但我会试着分解它。你应该关注的是在<em class="ll">componentdimount</em>生命周期方法中的获取浏览器API。当组件被挂载时，在调用<em class="ll"> render </em>方法之前，向coindesk API发出一个获取请求，该API返回一个使用<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> JavaScript promises </a>适当处理的承诺。</p><p id="f26c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">返回的比特币价格指数(bpi)数据在数组中是这种格式<code class="du ls lt lu lv b">"2019-12-05":7404.4033</code>,因此在将它添加到状态之前，需要将日期格式化为实际的日期对象，而不是字符串。这些实际日期对象将有助于在实际图表上创建水平轴的刻度。然后，这些数据作为道具传递给子组件。</p><p id="e1fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ls lt lu lv b"><strong class="is hj">Chart.js</strong></code></p><pre class="jq jr js jt fd ly lv lz ma aw mb bi"><span id="d114" class="mc kj hi lv b fi md me l mf mg">import React from "react";<br/>import * as d3 from "d3";</span><span id="589b" class="mc kj hi lv b fi mh me l mf mg">const width = 650;<br/>const height = 400;<br/>const margin = {<br/>  top: 20,<br/>  right: 5,<br/>  bottom: 50,<br/>  left: 60<br/>};</span><span id="f0f0" class="mc kj hi lv b fi mh me l mf mg">class Chart extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      data: null<br/>    };<br/>  }</span><span id="a0d2" class="mc kj hi lv b fi mh me l mf mg">  xAxis = d3.axisBottom();<br/>  yAxis = d3.axisLeft();</span><span id="e0d5" class="mc kj hi lv b fi mh me l mf mg">  static getDerivedStateFromProps(nextProps, prevState) {</span><span id="80c4" class="mc kj hi lv b fi mh me l mf mg">   const { data } = nextProps;<br/>   if (!data) return {};</span><span id="2f90" class="mc kj hi lv b fi mh me l mf mg">  const xExtent = d3.extent(data, d =&gt; d.date);</span><span id="a8c9" class="mc kj hi lv b fi mh me l mf mg">  const yExtent = d3.extent(data, d =&gt; d.price);</span><span id="f08b" class="mc kj hi lv b fi mh me l mf mg">  const xScale = d3<br/>    .scaleTime()<br/>    .domain(xExtent)<br/>    .range([margin.left, width - margin.right]);</span><span id="415f" class="mc kj hi lv b fi mh me l mf mg">  const yScale = d3<br/>    .scaleLinear()<br/>    .domain(yExtent)<br/>    .range([height - margin.bottom, margin.top]);</span><span id="b2f0" class="mc kj hi lv b fi mh me l mf mg">  const line = d3<br/>    .line()<br/>    .x(d =&gt; xScale(d.date))<br/>    .y(d =&gt; yScale(d.price));</span><span id="b0a0" class="mc kj hi lv b fi mh me l mf mg">  const minY = d3.min(data, d =&gt; d.price);</span><span id="e408" class="mc kj hi lv b fi mh me l mf mg">  const area = d3<br/>    .area()<br/>    .x(d =&gt; xScale(d.date))<br/>    .y0(d =&gt; yScale(minY))<br/>    .y1(d =&gt; yScale(d.price));</span><span id="e45b" class="mc kj hi lv b fi mh me l mf mg">  return { xScale, yScale, data, line, area };</span><span id="5bf8" class="mc kj hi lv b fi mh me l mf mg"> }</span><span id="8b8d" class="mc kj hi lv b fi mh me l mf mg">  componentDidUpdate() {</span><span id="e9cd" class="mc kj hi lv b fi mh me l mf mg">    this.xAxis.scale(this.state.xScale);<br/>    d3.select(this.refs.xAxis).call(this.xAxis);</span><span id="42a6" class="mc kj hi lv b fi mh me l mf mg">    this.yAxis.scale(this.state.yScale);<br/>    d3.select(this.refs.yAxis).call(this.yAxis);</span><span id="f945" class="mc kj hi lv b fi mh me l mf mg">  }</span><span id="730f" class="mc kj hi lv b fi mh me l mf mg">  render() {</span><span id="4b19" class="mc kj hi lv b fi mh me l mf mg">  const styles = {<br/>    container: {<br/>      display: "grid",<br/>      justifyItems: "center"<br/>    }<br/>  };</span><span id="700e" class="mc kj hi lv b fi mh me l mf mg">  const { data, line, area } = this.state;</span><span id="d892" class="mc kj hi lv b fi mh me l mf mg">  return (<br/>    &lt;div style={styles.container}&gt;<br/>      &lt;svg width={width} height={height}&gt;<br/>        &lt;path<br/>          id={"line"}<br/>          d={line(data)}<br/>          stroke="#6788ad"<br/>          fill="transparent"<br/>        /&gt;</span><span id="f587" class="mc kj hi lv b fi mh me l mf mg">        &lt;path<br/>          id={"area"}<br/>          d={area(data)}<br/>          fill="#6788ad"<br/>          style={{ opacity: 0.2 }}<br/>        /&gt;</span><span id="1e4d" class="mc kj hi lv b fi mh me l mf mg">        &lt;text<br/>          transform={`translate(${width / 2 - margin.left -margin.right}, ${height - 10})`}<br/>        &gt;<br/>        Dates for the last 30 days<br/>        &lt;/text&gt;</span><span id="87cd" class="mc kj hi lv b fi mh me l mf mg">        &lt;text<br/>          transform={`translate(15, ${(height - margin.bottom) /1.5}) rotate(270)`}<br/>        &gt;<br/>        Amount in USD<br/>        &lt;/text&gt;</span><span id="1f12" class="mc kj hi lv b fi mh me l mf mg">        &lt;g<br/>          ref="xAxis"<br/>          transform={`translate(0, ${height - margin.bottom})`}<br/>        /&gt;</span><span id="83a2" class="mc kj hi lv b fi mh me l mf mg">        &lt;g ref="yAxis" transform={`translate(${margin.left}, 0)`} /&gt;</span><span id="26ad" class="mc kj hi lv b fi mh me l mf mg">      &lt;/svg&gt;<br/>    &lt;/div&gt;<br/>   );<br/>  }<br/>}</span><span id="ca65" class="mc kj hi lv b fi mh me l mf mg">export default Chart;</span></pre><p id="39b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，我知道这真的有很多代码，因为这是最重要的部分。你不用担心，我会帮你的！让我们开始分解它。</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mi lx l"/></div></figure><p id="2878" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来的步骤没有一个是非常困难的，只是一开始把它们连接在一起有点棘手。</p><p id="2aa4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在做任何事情之前，你需要先从npm或者yarn安装D3。</p><p id="93ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于npm用户，使用命令<code class="du ls lt lu lv b">npm install d3</code>，对于yarn用户，使用命令<code class="du ls lt lu lv b">yarn add d3</code></p><p id="f851" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤1 —接收数据</strong></p><pre class="jq jr js jt fd ly lv lz ma aw mb bi"><span id="5a65" class="mc kj hi lv b fi md me l mf mg">const { data } = nextProps;</span><span id="2b83" class="mc kj hi lv b fi mh me l mf mg">if (!data) return {};</span></pre><p id="0f64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在文件中的重点应该是图表组件中的<em class="ll"> getDerivedStateFromProps </em>方法。它从根组件接收属性并提取数据属性。如果数据不可用，它将什么也不做。</p><p id="b1d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤2——计算水平和垂直比例</strong></p><pre class="jq jr js jt fd ly lv lz ma aw mb bi"><span id="525d" class="mc kj hi lv b fi md me l mf mg">const xExtent = d3.extent(data, d =&gt; d.date);</span><span id="c74b" class="mc kj hi lv b fi mh me l mf mg">const yExtent = d3.extent(data, d =&gt; d.price);</span><span id="1ff6" class="mc kj hi lv b fi mh me l mf mg">const xScale = d3<br/>    .scaleTime()<br/>    .domain(xExtent)<br/>    .range([margin.left, width - margin.right]);</span><span id="ffd9" class="mc kj hi lv b fi mh me l mf mg">const yScale = d3<br/>    .scaleLinear()<br/>    .domain(yExtent)<br/>    .range([height - margin.bottom, margin.top]);</span></pre><p id="3e16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果数据可用，则通过利用D3的<code class="du ls lt lu lv b"><a class="ae jo" href="https://github.com/d3/d3-scale#time-scales" rel="noopener ugc nofollow" target="_blank">scaleTime()</a></code> <code class="du ls lt lu lv b"><a class="ae jo" href="https://github.com/d3/d3-scale#linear-scales" rel="noopener ugc nofollow" target="_blank">scaleLinear()</a></code>方法计算水平和垂直比例。结果分别存储在<em class="ll"> xScale </em>和<em class="ll"> yScale </em>变量中。在这两种情况下，指定范围的数组值时都会考虑边距。</p><p id="59d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤3——计算线和面积</strong></p><pre class="jq jr js jt fd ly lv lz ma aw mb bi"><span id="e2cd" class="mc kj hi lv b fi md me l mf mg">const line = d3<br/>    .line()<br/>    .x(d =&gt; xScale(d.date))<br/>    .y(d =&gt; yScale(d.price));</span><span id="5dac" class="mc kj hi lv b fi mh me l mf mg">const minY = d3.min(data, d =&gt; d.price);</span><span id="dad9" class="mc kj hi lv b fi mh me l mf mg">const area = d3<br/>    .area()<br/>    .x(d =&gt; xScale(d.date))<br/>    .y0(d =&gt; yScale(minY))<br/>    .y1(d =&gt; yScale(d.price));</span><span id="4e40" class="mc kj hi lv b fi mh me l mf mg">return { xScale, yScale, data, line, area };</span></pre><p id="ef77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图表的线条和面积也是利用D3的<code class="du ls lt lu lv b"><a class="ae jo" href="https://github.com/d3/d3-shape#lines" rel="noopener ugc nofollow" target="_blank">line()</a></code>和<code class="du ls lt lu lv b"><a class="ae jo" href="https://github.com/d3/d3-shape#areas" rel="noopener ugc nofollow" target="_blank">area()</a></code>方法计算的，结果分别存储在<em class="ll">线条</em>和<em class="ll">面积</em>变量中。然后，<em class="ll">getDerivedStateFromProps</em>方法将返回<em class="ll"> xScale </em>、<em class="ll"> yScale </em>、<em class="ll"> line </em>和<em class="ll"> area </em>变量以及<em class="ll">数据</em>属性，然后可以从state的<em class="ll"> render </em>方法中访问这些属性。</p><p id="240a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤4——将线条和区域渲染到<em class="ll"> svg。</em> </strong></p><pre class="jq jr js jt fd ly lv lz ma aw mb bi"><span id="8e4b" class="mc kj hi lv b fi md me l mf mg">&lt;path<br/>   id={"line"}<br/>   d={line(data)}<br/>   stroke="#6788ad"<br/>   fill="transparent"<br/> /&gt;</span><span id="156a" class="mc kj hi lv b fi mh me l mf mg">&lt;path<br/>   id={"area"}<br/>   d={area(data)}<br/>   fill="#6788ad"<br/>   style={{ opacity: 0.2 }}<br/> /&gt;</span></pre><p id="c69f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在render方法中，我们返回一个具有宽度和高度属性的<em class="ll"> svg </em>元素。然后，我们为线和区域添加两个路径元素，同时向它们传递来自state的数据。此时，我们应该能够在react应用程序中看到折线图和面积图。</p><p id="5f4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤5——添加轴</strong></p><pre class="jq jr js jt fd ly lv lz ma aw mb bi"><span id="17cb" class="mc kj hi lv b fi md me l mf mg">xAxis = d3.axisBottom();<br/>yAxis = d3.axisLeft();</span></pre><p id="4bb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就在getDerivedStateFromProps方法之上，我们创建了两个轴。通过利用D3的<code class="du ls lt lu lv b"><a class="ae jo" href="https://github.com/d3/d3-axis#axisBottom" rel="noopener ugc nofollow" target="_blank">axisBottom()</a></code>和<code class="du ls lt lu lv b"><a class="ae jo" href="https://github.com/d3/d3-axis#axisLeft" rel="noopener ugc nofollow" target="_blank">axisLeft()</a></code>方法控制x轴和y轴。</p><pre class="jq jr js jt fd ly lv lz ma aw mb bi"><span id="3102" class="mc kj hi lv b fi md me l mf mg">&lt;g<br/>   ref="xAxis"<br/>   transform={`translate(0, ${height - margin.bottom})`}<br/>/&gt;</span><span id="c248" class="mc kj hi lv b fi mh me l mf mg">&lt;g ref="yAxis" transform={`translate(${margin.left}, 0)`} /&gt;</span></pre><p id="ce96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在render方法的<em class="ll"> svg </em>元素中，我们添加了两个group元素，每个元素都有一个对xAxis或yAxis的引用。</p><pre class="jq jr js jt fd ly lv lz ma aw mb bi"><span id="c39b" class="mc kj hi lv b fi md me l mf mg">componentDidUpdate() {</span><span id="c48b" class="mc kj hi lv b fi mh me l mf mg">this.xAxis.scale(this.state.xScale);<br/>d3.select(this.refs.xAxis).call(this.xAxis);</span><span id="dace" class="mc kj hi lv b fi mh me l mf mg">this.yAxis.scale(this.state.yScale);<br/>d3.select(this.refs.yAxis).call(this.yAxis);</span><span id="d483" class="mc kj hi lv b fi mh me l mf mg">}</span></pre><p id="2bef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些引用在<em class="ll"> componentDidUpdate </em>方法中使用，以调用组元素上的轴，但在此之前，我们需要首先向轴添加刻度。</p><p id="b7eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，我现在在最后冲刺阶段:)</p><p id="0ad8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第六步——标记轴</strong></p><pre class="jq jr js jt fd ly lv lz ma aw mb bi"><span id="6c7c" class="mc kj hi lv b fi md me l mf mg">&lt;text<br/>   transform={`translate(${width / 2 - margin.left -margin.right}, ${height - 10})`}<br/>&gt;<br/> Dates for the last 30 days<br/>&lt;/text&gt;</span><span id="3176" class="mc kj hi lv b fi mh me l mf mg">&lt;text<br/>  transform={`translate(15, ${(height - margin.bottom) /1.5}) rotate(270)`}<br/>&gt;<br/> Amount in USD<br/>&lt;/text&gt;</span></pre><p id="3bb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一步是给图表的轴添加标签。想象一个没有标记轴的图表，嗯？！这意味着关于图表的一些信息仍然会丢失。因此，我们在render方法中向<em class="ll"> svg </em>元素添加了两个文本元素。一个文本元素将为x轴添加一个标签，为y轴添加一个标签。</p><p id="4c84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你已经用React和D3成功地可视化了比特币的30天价格图。不太难。</p><p id="2956" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结论</strong></p><p id="5bdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">乍一看，用React和D3可视化比特币数据似乎有点令人生畏。实际上，D3有助于简化主要因素(创建路径和比例)。一旦做到这一点，剩下的就很简单了。</p><p id="f1d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">过几周甚至几天再来看看，我将会写一些关于用React和D3在条形图中添加画笔的内容，这样就可以只检索特定域内的数据，或者关于React和D3的类似内容。</p><p id="ba67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的阅读，我希望这能让您了解React和D3如何一起创建定制的数据可视化。</p><p id="e02c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">我对React和D3的数据可视化非常感兴趣。如果你</strong> <a class="ae jo" href="https://twitter.com/ahebwa49" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">在Twitter上关注我，</strong> </a> <strong class="is hj">我不会浪费你的时间。？</strong></p></div></div>    
</body>
</html>