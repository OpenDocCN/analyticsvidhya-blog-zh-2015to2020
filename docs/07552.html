<html>
<head>
<title>Differentiate between DFS and BFS.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区分DFS和BFS。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/differentiate-between-dfs-and-bfs-ec15f5a0146e?source=collection_archive---------22-----------------------#2020-06-29">https://medium.com/analytics-vidhya/differentiate-between-dfs-and-bfs-ec15f5a0146e?source=collection_archive---------22-----------------------#2020-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="f78a" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak"> BFS </strong></h1><ul class=""><li id="955e" class="jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">BFS代表“<strong class="jm hj">广度优先搜索</strong>”。又名不知情搜索技术，盲目搜索技术，暴力方法。</li><li id="6c71" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">BFS在树中逐层遍历。即<strong class="jm hj">最接近根的每个节点将首先被访问</strong>。节点是从左到右浏览的。</li><li id="3c9a" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">广度优先搜索是使用队列来实现的，该队列是一个FIFO列表。</li><li id="e757" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">这是一个<strong class="jm hj">单步算法</strong>，其中被访问的顶点从队列中删除，然后立即显示。</li><li id="de43" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">我们需要维护一个单独的数据结构来跟踪尚未访问的树/图节点。这很容易通过使用<strong class="jm hj">队列数据结构</strong>迭代完成。</li><li id="7881" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">BFS总是提供<strong class="jm hj">浅路径解决方案</strong>。</li><li id="0d32" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated"><strong class="jm hj">在BFS不需要回溯</strong>。</li><li id="e81f" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">如果分支因子是有限的，BFS是最优的和完全的。</li><li id="5dd2" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">BFS永远不会陷入无限循环。</li></ul><p id="3a93" class="pw-post-body-paragraph kh ki hi jm b jn kj kk kl jp km kn ko jr kp kq kr jt ks kt ku jv kv kw kx jx hb bi translated"><strong class="jm hj">BFS的申请:</strong></p><ul class=""><li id="d108" class="jk jl hi jm b jn kj jp km jr ky jt kz jv la jx jy jz ka kb bi translated">寻找最短路径。</li><li id="0ae9" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">单源和所有线对。</li><li id="ec31" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">在生成树中。</li><li id="1459" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">在连通性方面。</li></ul><h1 id="3dee" class="im in hi bd io ip lb ir is it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj bi translated"><strong class="ak"> DFS </strong></h1><ul class=""><li id="fda0" class="jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">DFS代表“<strong class="jm hj">深度优先搜索</strong>”。</li><li id="63d2" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">DFS沿深度方向遍历树。即，特定分支中的节点被访问直到叶节点，并且搜索从左到右一个分支一个分支地继续<strong class="jm hj">。</strong></li><li id="cefc" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">深度优先搜索是使用堆栈实现的。也就是后进先出法。</li><li id="c9c4" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">这是一个<strong class="jm hj">两步算法</strong>，在第一阶段，访问过的顶点被推送到堆栈上，随后当没有顶点需要访问时，这些顶点被弹出。</li><li id="a516" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">与BFS相比，DFS不需要任何额外的数据结构来存储树/图节点。DFS的递归实现使用<strong class="jm hj">递归调用栈</strong>。</li><li id="b82a" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">DFS不保证最浅路径解决方案。</li><li id="e05e" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated"><strong class="jm hj">回溯在DFS中实现</strong>。</li><li id="ae8a" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">在有限分支因子<strong class="jm hj">的情况下，DFS<strong class="jm hj">既不完全也不是最优的</strong>。</strong></li><li id="72df" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">DFS通常会让<strong class="jm hj">陷入无限循环</strong>。</li></ul><p id="876e" class="pw-post-body-paragraph kh ki hi jm b jn kj kk kl jp km kn ko jr kp kq kr jt ks kt ku jv kv kw kx jx hb bi translated"><strong class="jm hj">DFS的应用:</strong></p><ul class=""><li id="0f71" class="jk jl hi jm b jn kj jp km jr ky jt kz jv la jx jy jz ka kb bi translated">在周期检测中有用。</li><li id="bd0f" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">在连通性测试中。</li><li id="e4ca" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">在图中寻找V和W之间的路径。</li><li id="8255" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">有助于寻找生成树和森林。</li></ul></div></div>    
</body>
</html>