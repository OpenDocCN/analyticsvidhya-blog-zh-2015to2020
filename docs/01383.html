<html>
<head>
<title>Images Processing: Segmentation and Objects Counting with Python and OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像处理:使用Python和OpenCV进行分割和对象计数</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/images-processing-segmentation-and-objects-counting-in-an-image-with-python-and-opencv-216cd38aca8e?source=collection_archive---------0-----------------------#2019-10-19">https://medium.com/analytics-vidhya/images-processing-segmentation-and-objects-counting-in-an-image-with-python-and-opencv-216cd38aca8e?source=collection_archive---------0-----------------------#2019-10-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9b8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像分割是计算机视觉领域中物体识别的重要步骤。在这篇文章中，我们提出了一些分割技术。分割的独创性是基于根据我们必须处理的图像从多种可用技术中选择技术。这里我们不会介绍所有的分割技术，我们将只讨论我们在这项工作中使用的技术。值得注意的是，这些技术并不是在这种情况下必须使用的唯一技术，因此您可以找到一些可以有效解决这个问题的技术。</p><h1 id="e81b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">目标</h1><p id="78be" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">下图概括了我们希望执行的任务。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/57575ea3f87bb635db52bbe673de60c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0YKPVa0Csc63upEuHayRQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated"><strong class="bd jf">图1:原始图像(左)和分割图像(右)</strong></figcaption></figure><h2 id="c3df" class="kw je hi bd jf kx ky kz jj la lb lc jn iq ld le jr iu lf lg jv iy lh li jz lj bi translated"><strong class="ak">使用的工具和资源(图片)</strong></h2><p id="6180" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Python 3.5，opencv 4.1.0</p><p id="6ee3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用的图像位于https://photos.app.goo.gl/CGgNoSyvENRzvLmZ8<a class="ae lk" href="https://photos.app.goo.gl/CGgNoSyvENRzvLmZ8" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="d32f" class="kw je hi bd jf kx ky kz jj la lb lc jn iq ld le jr iu lf lg jv iy lh li jz lj bi translated"><strong class="ak">加工顺序</strong></h2><p id="f347" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">分割过程可以分为3个部分:</p><p id="3138" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1 —预处理，</p><p id="ef96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2 —处理，以及</p><p id="8e9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3 —后分割。</p><p id="a993" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1 —预处理</strong></p><p id="e0a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有4个图像要被相同的处理序列分割，所以我们必须分析所有这些输入图像的特征(亮度，对比度，噪声，..以便选择对应于所有技术的技术。所有这些提高图像质量的处理都属于预处理步骤。让我们看看下面的四幅输入图像</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ll"><img src="../Images/cf0f7ad184bf9efe5645cca0fbf8f5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*TlmsDkhX-762jmBby4ughw.jpeg"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated"><strong class="bd jf">图2:第一张图像</strong></figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ll"><img src="../Images/8cca4ace7c7bdec4ed6845797f25010a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*hfdLBP_MqTr8WXKiMgTWRw.jpeg"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated"><strong class="bd jf">图3:第二幅图像</strong></figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ll"><img src="../Images/e7af5f111512adc44a6fe49b430b2e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*KYy5epJKweSZ0Sm6hi4k1w.jpeg"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated"><strong class="bd jf">图4:第三幅图像</strong></figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ll"><img src="../Images/7d7f48f5f4d3178ab2fe8ef4b7453622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*vVcZhL61ppxcOvZAcFb7-A.jpeg"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated"><strong class="bd jf">图5:第四幅图像</strong></figcaption></figure><p id="3f3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将把我们的彩色图像转换成灰度图像，以便只有一个通道的图像。即使没有转换，我们也可以观察到这些图像特征之间的差异。第一幅图像(图2)包含小物体，并且一些具有与背景相同的像素值(第五幅图像也是如此，图5)。这一方面会导致egdes检测问题。为了防止这种情况，我们考虑图像对比度调整，因此我们必须在所有对比度提高方法中进行选择(直方图均衡化、线性变换、非线性变换，例如伽马校正、分段线性变换等)，让我们比较一下opencv中实现的两种方法的结果:伽马校正和直方图均衡化。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="0a15" class="kw je hi ln b fi lr ls l lt lu"># Convert image in grayscale</span><span id="5c8a" class="kw je hi ln b fi lv ls l lt lu">gray_im = cv.cvtColor(original, cv.COLOR_BGR2GRAY)<br/>plt.subplot(221)<br/>plt.title('Grayscale image')<br/>plt.imshow(gray_im, cmap="gray", vmin=0, vmax=255)<br/><br/># Contrast adjusting with gamma correction y = 1.2<br/><br/>gray_correct = np.array(255 * (gray_im / 255) ** 1.2 , dtype='uint8')<br/>plt.subplot(222)<br/>plt.title('Gamma Correction y= 1.2')<br/>plt.imshow(gray_correct, cmap="gray", vmin=0, vmax=255)</span><span id="1a00" class="kw je hi ln b fi lv ls l lt lu"># Contrast adjusting with histogramm equalization</span><span id="f8e5" class="kw je hi ln b fi lv ls l lt lu">gray_equ = cv.equalizeHist(gray_im)<br/>plt.subplot(223)<br/>plt.title('Histogram equilization')<br/>plt.imshow(gray_correct, cmap="gray", vmin=0, vmax=255)</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lw"><img src="../Images/4832097e8df7b0911d5ad8b04ae7b221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akAlkomfk_fwYpcNAWTIBQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated"><strong class="bd jf">图6:对比方法对比</strong></figcaption></figure><p id="5cc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你认为我们必须选择哪一个？据我们说，我们认为伽马校正给出了更好的结果，所以我们保留这个。在我们的情况下，在这一步，只有这种处理可以解决我们的清晰度问题。但是注意，在某些情况下你必须做多重处理才能解决清晰度问题，所以让我们进入下一步。</p><p id="4a6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2 —处理</strong></p><p id="41eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于前面的处理，这里我们也有不同的分割技术，可以分为两部分:基于边缘的技术和基于区域的技术。</p><p id="4bd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">否则，我们可以使用阈值技术来进行分割，在这种情况下，我们必须遵循其他处理技术，以获得满意的结果。</p><p id="bc12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试验一下这最后一种方法。</p><p id="b465" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们使用自适应局部阈值技术来二值化我们的灰度图像(对比度校正的灰度图像)，请注意，您可以使用其他技术，你认为更好地为您的图像。结果看起来像贝娄。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="baee" class="kw je hi ln b fi lr ls l lt lu"># Local adaptative threshold<br/><br/>thresh = cv.adaptiveThreshold(gray_correct, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 255, 19)<br/>thresh = cv.bitwise_not(thresh)plt.subplot(221)<br/>plt.title('Local adapatative Threshold')<br/>plt.imshow(thresh, cmap="gray", vmin=0, vmax=255)</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lx"><img src="../Images/57e18630d1e8aa08b45ecaa400e1789a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dywqluIwVgmvd1vt7TuHZw.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图7:局部适应阈值</figcaption></figure><p id="cbf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，在前面的图(图7)中，阈值处理后，我们有许多相连的区域，这不能帮助我们计数图像中的对象，因为对象的计数是由于相连区域的数量，所以此外，我们必须在计数图像中的对象数量之前应用一些其他技术。</p><p id="47dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将遵循侵蚀和扩张技术，这将有助于我们连接最近的区域，以便每个对象有一个区域。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="d446" class="kw je hi ln b fi lr ls l lt lu"># Dilatation et erosion<br/>kernel = np.ones((15,15), np.uint8)<br/>img_dilation = cv.dilate(thresh, kernel, iterations=1)<br/>img_erode = cv.erode(img_dilation,kernel, iterations=1)</span><span id="2782" class="kw je hi ln b fi lv ls l lt lu"># clean all noise after dilatation and erosion</span><span id="f658" class="kw je hi ln b fi lv ls l lt lu">img_erode = cv.medianBlur(img_erode, 7)</span><span id="4d62" class="kw je hi ln b fi lv ls l lt lu">plt.subplot(221)<br/>plt.title('Dilatation + erosion')<br/>plt.imshow(img_erode, cmap="gray", vmin=0, vmax=255)</span></pre><p id="2163" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们应用这些技术并欣赏结果。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ly"><img src="../Images/e2bda86c3291c3a69a2608d46a2b2eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*io4iWgZq7_U1_6qj5gmGnA.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图8:侵蚀和扩张</figcaption></figure><p id="27d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们每个连接区域有一个对象，所以我们可以计算图像中对象的数量。但在此之前，让我们先标记连接区域。</p><pre class="kh ki kj kk fd lm ln lo lp aw lq bi"><span id="bf56" class="kw je hi ln b fi lr ls l lt lu"># Labeling<br/><br/>ret, labels = cv.connectedComponents(img_erode)<br/>label_hue = np.uint8(179 * labels / np.max(labels))<br/>blank_ch = 255 * np.ones_like(label_hue)<br/>labeled_img = cv.merge([label_hue, blank_ch, blank_ch])<br/>labeled_img = cv.cvtColor(labeled_img, cv.COLOR_HSV2BGR)<br/>labeled_img[label_hue == 0] = 0<br/><br/>plt.subplot(222)<br/>plt.title('Objects counted:'+ str(ret-1))<br/>plt.imshow(labeled_img)</span><span id="9fd6" class="kw je hi ln b fi lv ls l lt lu">print('objects number is:', ret-1)<br/>plt.show()</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lz"><img src="../Images/5131c9b4c3d73457105cb570c7064416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7TSFXBPQSC7s50yGflcj1g.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图9:标签和物体计数</figcaption></figure><p id="e27d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一篇文章中，我们将在介绍后分割步骤之前介绍其他分割技术。希望这篇文章对你有所帮助，请在下面的评论区分享你的想法和反馈。</p></div></div>    
</body>
</html>