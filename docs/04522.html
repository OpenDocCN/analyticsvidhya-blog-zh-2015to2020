<html>
<head>
<title>Pointers in C Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C语言中的指针</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pointers-in-c-and-c-ecb18cee6e28?source=collection_archive---------27-----------------------#2020-03-22">https://medium.com/analytics-vidhya/pointers-in-c-and-c-ecb18cee6e28?source=collection_archive---------27-----------------------#2020-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/e66435654ab69f5760ff309c6fe5eb25.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*ySD__vx2vmqrYLTtlpK-WA.png"/></div></figure><p id="824b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">啊，古老的好指针。大多数计算机科学课程中的第一个主题，也是大多数学生都很难理解的。我承认。并不是每个人都在日常编程中使用指针。事实上，在几家公司实习期间，我从未使用过指针。然而，在学习了操作系统和几门关键的计算机科学课程后，我意识到它们都有一个共同的敌人或盟友，这取决于你的视角:<strong class="io hj">指针</strong>。它恼人的持续出现在我的教育生涯中，迫使我重新考虑它在开发人员世界中的重要性和相关性。</p><p id="b27d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">尽管大多数开发人员永远不会用到它，但知道它的存在以及它在日常计算生活中的作用还是很有好处的。原因如下。你写的每个应用程序都会消耗内存。这是一个不可否认的事实，你必须接受。任何涉及内存的东西都必然会用到指针。有些人可能会说，即使是最复杂的python程序也没有包含一个指针。实际上，python语言已经为您完成了这项工作，所以您不必这么做。被宠坏的混蛋😙</p><h1 id="959f" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是指针？</h1><p id="3d84" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">指针只是一个给变量的通称，用来保存某个东西的内存地址。这里的类比是，指针是指<strong class="io hj">指向</strong>*没有双关语的意思，你到你想去的地方。</p><p id="9fb3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">声明指针</strong></p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="26ef" class="kw jl hi ks b fi kx ky l kz la">int *int_pointer; <br/>char *char_pointer; <br/>float *float_pointer; <br/>struct Person *person_pointer;</span></pre><p id="caaf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">指针的一般格式是<code class="du lb lc ld ks b">[Data Type] *[Variable Name]</code>。<code class="du lb lc ld ks b">*</code>表示该特定数据类型的变量是指针。</p><p id="daea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">初始化指针</strong></p><p id="f3c0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">指针存储内存地址，但是我们如何得到某个东西的内存地址呢？c有一个特殊的内置操作符<code class="du lb lc ld ks b">&amp;</code>，它返回任意值的地址。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="995b" class="kw jl hi ks b fi kx ky l kz la">int value =2; <br/>int *location_of_value = &amp;value;</span></pre><p id="09b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里变量<code class="du lb lc ld ks b">value</code>包含2，我们使用<code class="du lb lc ld ks b">&amp;value</code>在内存中检索这个“2”的位置，并将其赋给指针<code class="du lb lc ld ks b">*location_of_value</code></p><h2 id="01a2" class="kw jl hi bd jm le lf lg jq lh li lj ju ix lk ll jy jb lm ln kc jf lo lp kg lq bi translated">从指针中检索值</h2><p id="431a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">给定一个指针，要从指针中检索值，我们必须使用<code class="du lb lc ld ks b">*</code>取消对它的引用。换句话说，一旦我们看到街道标志，我们如何前往该位置？</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="fdd7" class="kw jl hi ks b fi kx ky l kz la">int value =2; <br/>int *location_of_value = &amp;value; <br/>int retrieved_value=*location_of_value; // retrieved_value == 2</span></pre><p id="b4df" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们使用<code class="du lb lc ld ks b">*location_of_value</code>从位置中检索值</p><h1 id="d315" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">指针的特殊情况</h1><p id="a40e" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated"><strong class="io hj">数组</strong></p><p id="3a4b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">任何数据类型的数组都是指针用法的特例，其中与数组关联的变量是指向数组第一个元素的指针。听起来很困惑？我也是。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="c9b7" class="kw jl hi ks b fi kx ky l kz la">int arr[3]= {1,2,3};<br/>printf("%p\n", arr);</span></pre><p id="e5fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">printf语句中的<code class="du lb lc ld ks b">%p</code>用来打印指针的地址。这里，当我们打印指针的地址并传递<code class="du lb lc ld ks b">arr</code>时，我们期望<code class="du lb lc ld ks b">arr</code>包含一个地址。这个地址存放着什么？</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="ae12" class="kw jl hi ks b fi kx ky l kz la">int arr[3]= {1,2,3};<br/>printf("%d\n", *arr);// prints 1</span></pre><p id="ba6a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们遵从存储在<code class="du lb lc ld ks b">arr</code>中的这个地址时，我们得到值1，这是数组中的第一个元素。为了得到数组中的下一个值，我们只需要告诉指针移动到下一个地址。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="b682" class="kw jl hi ks b fi kx ky l kz la">int arr[3]= {1,2,3};<br/>printf("%p\n", arr);// prints 1<br/>arr++;<br/>printf("%d\n", *arr); // prints 2</span></pre><p id="7b5e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们增加指针时，我们告诉它移动<code class="du lb lc ld ks b">sizeof(int)</code>字节，这是数组中下一个元素的内存地址。</p><p id="cbdf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">琴弦</strong></p><p id="c057" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">c语言中实际上没有字符串这种东西，字符串只是一个char的数组。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="d950" class="kw jl hi ks b fi kx ky l kz la">char str[10]= "Hi There\0";<br/> printf("%c", *str); // prints "H"</span></pre><p id="896d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里<code class="du lb lc ld ks b">str</code>指向char序列中第一个字符的内存地址。打印整个字符串</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="1f15" class="kw jl hi ks b fi kx ky l kz la">char str[10] = "Hi There \0";<br/>while(str){<br/>    printf("%c", *str);<br/>    str++;<br/>}<br/>// prints "Hi There"</span></pre><p id="1545" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">类和结构</strong></p><p id="2630" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">结构和类在取消隔离的步骤上略有不同</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3f04" class="kw jl hi ks b fi kx ky l kz la">typedef struct person{<br/>    char* first_name;<br/>    int age;<br/><br/>}person;<br/>.<br/>.<br/>.   <br/>char name[10] = "Bob";<br/>person p1 = {name, 21};<br/>person *p1_location = &amp;p1;<br/>printf("First name:%s age:%d \n", p1_location-&gt;first_name, (*p1_location).age);</span></pre><p id="6dd5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">给定一个<code class="du lb lc ld ks b"> struct person *</code>来访问person结构的成员字段，有两种方法。</p><ol class=""><li id="c585" class="lr ls hi io b ip iq it iu ix lt jb lu jf lv jj lw lx ly lz bi translated"><code class="du lb lc ld ks b">p1_location-&gt;firstname</code>-在一个操作符中解除引用和访问</li><li id="9c13" class="lr ls hi io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated"><code class="du lb lc ld ks b">(*p1_location).firstname</code>-先解引用再访问</li></ol><p id="5a86" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">内存分配和指针</strong></p><p id="fe91" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">分配内存块时也使用指针</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="2625" class="kw jl hi ks b fi kx ky l kz la">char *str_ptr = malloc(sizeof(char) * 10)<br/>strcpy(str_ptr, "hello\0");<br/>printf("%s\n", str_ptr) // prints "hello"</span></pre><p id="2171" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们要求<code class="du lb lc ld ks b">malloc</code>给我们一块可以存储10个字符的内存，并返回给我们第一个位置的起始内存地址。</p><h1 id="5529" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">最后一个音符</h1><p id="b65c" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">这个例子列表并不是指针应用方式的详尽列表，但是对于那些不熟悉内存地址和指针的人来说，它是一个很好的起点。和平出去:)</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="8513" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="mm">最初发表于</em><a class="ae mn" href="https://www.devsurvival.com/pointers-with-c/" rel="noopener ugc nofollow" target="_blank">https://www.devsurvival.com/pointers-with-c/</a></p></div></div>    
</body>
</html>