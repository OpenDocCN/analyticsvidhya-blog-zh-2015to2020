<html>
<head>
<title>Detecting The Number Of Pizza Slices Using Image Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用图像处理技术检测比萨饼切片数量</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/detecting-the-number-of-pizza-slices-using-image-processing-5121a23fb672?source=collection_archive---------23-----------------------#2020-09-21">https://medium.com/analytics-vidhya/detecting-the-number-of-pizza-slices-using-image-processing-5121a23fb672?source=collection_archive---------23-----------------------#2020-09-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/9314306cab6091e5e463dc8db9253f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FryBwsoZSOk4CvU7"/></div></div></figure><p id="6fe6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">深度学习技术对于计数和检测图像中的对象数量非常有用。然而，我们可以利用传统的图像处理方法来做同样的事情，这将具有较低的复杂性。这篇博客解释了一步一步计算一个盘子里披萨片数量的过程。</p><h1 id="7dc2" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">程序:</h1><p id="1e81" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">让我们考虑下面这张有四个切片的图像。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es kz"><img src="../Images/d2b7e6d6b269635f8699459a44bd7fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*CyjE8bTQ2sPtt60fKn6MHQ.jpeg"/></div></figure><p id="885f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们的目标是计算切片数，即4。</p><p id="daa1" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">首先，我们需要阅读图像。这可以通过opencv的imread函数来实现。它将图像的路径作为参数。在此之前，我们需要导入执行给定操作所需的库。这些都列在这里。</p><pre class="in io ip iq fd la lb lc ld aw le bi"><span id="b032" class="lf jx hi lb b fi lg lh l li lj">import os</span><span id="8a77" class="lf jx hi lb b fi lk lh l li lj">import cv2</span><span id="022e" class="lf jx hi lb b fi lk lh l li lj">import numpy as np</span><span id="934e" class="lf jx hi lb b fi lk lh l li lj">import matplotlib.pyplot as plt</span></pre><p id="938f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">为了读取图像，我们需要提供图像的路径作为第一个参数。为此，我们可以编写以下代码片段。</p><pre class="in io ip iq fd la lb lc ld aw le bi"><span id="adfc" class="lf jx hi lb b fi lg lh l li lj">path = ‘/home/aditya123/image_processing/pizza/food’</span><span id="c599" class="lf jx hi lb b fi lk lh l li lj">for images in os.listdir(path):</span><span id="380e" class="lf jx hi lb b fi lk lh l li lj">   img = cv2.imread(os.path.join(path,images))</span></pre><p id="0d68" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这里，图像存储在上述路径中。在读取给定变量img中的图像后，我们可以访问图像的各种属性。我们可以使用上述变量访问图像的某些属性。下一步，我们将使用opencv库将图像转换成灰度。下面的代码片段为我们完成了这项工作。</p><pre class="in io ip iq fd la lb lc ld aw le bi"><span id="c3a9" class="lf jx hi lb b fi lg lh l li lj"><br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span></pre><p id="d08c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">将图像转换为灰度的原因是因为我们想检测出最适合灰度图像的边缘。以下代码片段完成了边缘检测的工作。</p><pre class="in io ip iq fd la lb lc ld aw le bi"><span id="a64e" class="lf jx hi lb b fi lg lh l li lj">edge = cv2.Canny(img, 100, 200)</span></pre><p id="78bd" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">让我们明白这里发生了什么。我们应用canny边缘检测器来检测图像中的边缘。这里第一个参数是被读取的图像。第二个和第三个参数是强度梯度的阈值。强度梯度大于第三个参数(<strong class="ja hj"> <em class="ll"> max_val </em> </strong>)的边缘被确认为边缘，而强度梯度小于第二个值的边缘被丢弃。具有最小和最大值内的强度梯度的边缘被认为是基于它们与确认的边缘或丢弃的边缘的连接的边缘。</p><p id="17fc" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在下一步中，我们将应用阈值处理，使得超过某个阈值的像素值将是1，而低于该阈值的像素值将是0。下面的代码片段为我们完成了这项工作。</p><pre class="in io ip iq fd la lb lc ld aw le bi"><span id="907e" class="lf jx hi lb b fi lg lh l li lj">_,thresh = cv2.threshold(edged, 130, 255, cv2.THRESH_BINARY)</span></pre><p id="9252" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这里我们忽略了第一个值，因为它不是必需的。第二个变量存储阈值二进制图像。</p><p id="b750" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">接下来是两个形态学操作，即闭合和打开，这将帮助我们去除噪声并填充图像的孔洞。为此，我们首先要定义一个用于应用形态学的结构化元素。这段代码为我们创建了内核。</p><pre class="in io ip iq fd la lb lc ld aw le bi"><span id="57e1" class="lf jx hi lb b fi lg lh l li lj">def build_kernel(kernel_type, kernel_size):</span><span id="1e4d" class="lf jx hi lb b fi lk lh l li lj">   if kernel_type == cv2.MORPH_ELLIPSE:</span><span id="1c43" class="lf jx hi lb b fi lk lh l li lj">   return cv2.getStructuringElement(cv2.MORPH_ELLIPSE, kernel_size)</span></pre><p id="2736" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">上面的代码创建了一个椭圆形的结构元素。在下面的代码片段中，应用了形态学的打开和关闭操作。</p><pre class="in io ip iq fd la lb lc ld aw le bi"><span id="3d76" class="lf jx hi lb b fi lg lh l li lj">morph = cv2.morphologyEx(thesh, cv2.MORPH_CLOSE, kernel) #Close</span><span id="64f6" class="lf jx hi lb b fi lk lh l li lj">morph = cv2.morphologyEx(morph, cv2.MORPH_OPEN, kernel)</span></pre><p id="e2d2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在是在图像中寻找轮廓的时候了。轮廓基本上是具有相似强度的形状边界。为了得到更好的结果，我们应用了canny边缘检测器和阈值处理。下面的代码片段为我们完成了这项工作。</p><pre class="in io ip iq fd la lb lc ld aw le bi"><span id="6089" class="lf jx hi lb b fi lg lh l li lj">vals,_ = cv2.findContours(morph, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span></pre><p id="350d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">考虑最后一个参数<strong class="ja hj"> <em class="ll"> cv2。CHAIN_APPROX_SIMPLE </em> </strong>通过存储相关点坐标而不是存储所有点来节省内存。另一方面第一个参数<strong class="ja hj"> <em class="ll"> cv2。RETR _外部</em> </strong>只给我们外部轮廓，也就是说它会忽略所有内部轮廓。这对于我们的问题非常重要，因为比萨饼切片之间可能有轮廓。</p><p id="bedd" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在，将被检测的轮廓将具有许多小物体。所以我们需要忽略它们。</p><p id="892d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这里的val是一个包含所有轮廓的边界点的列表。</p><p id="bed0" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">下面的代码片段将在忽略小对象后绘制所有轮廓。</p><pre class="in io ip iq fd la lb lc ld aw le bi"><span id="aec1" class="lf jx hi lb b fi lg lh l li lj">for c in cnts:</span><span id="4e9d" class="lf jx hi lb b fi lk lh l li lj">if cv2.contourArea(c) &gt; 200: # ignore small objects</span><span id="a1a4" class="lf jx hi lb b fi lk lh l li lj">    cv2.drawContours(output, [c], -1,(np.random.randint(0,255),np.random.randint(0,255),np.random.randint(0,255)), 2)</span><span id="489e" class="lf jx hi lb b fi lk lh l li lj">count += 1</span></pre><p id="ada5" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们可以用<strong class="ja hj"> <em class="ll"> cv2.putText </em> </strong>来写关于图像的检测结果。</p><p id="a327" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">下面的代码片段将描述在图像中检测到的切片数量。</p><pre class="in io ip iq fd la lb lc ld aw le bi"><span id="8ed1" class="lf jx hi lb b fi lg lh l li lj">text = “Number of slices detected: {}”.format(count)</span><span id="1bd5" class="lf jx hi lb b fi lk lh l li lj">cv2.putText(img,text,(150,150),cv2.FONT_HERSHEY_SIMPLEX,1,(255,0,0),2,cv2.LINE_AA)</span></pre><p id="1a75" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">运行完上述所有代码后，我们将得到如下输出</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lm"><img src="../Images/9ca4a41ba65243f79811a8eb59ee89b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*aFp0agegP-vnrzcp9uGdVg.png"/></div></figure><p id="fa56" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这是如何使用图像处理技术检测比萨饼切片的概述。<br/>在linkedin上加我<a class="ae ln" href="https://www.linkedin.com/in/aditya-mohanty-7982451a9/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/aditya-mohanty-7982451a9/</a>。</p></div></div>    
</body>
</html>