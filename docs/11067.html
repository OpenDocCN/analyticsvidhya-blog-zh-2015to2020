<html>
<head>
<title>Using large NLP model’s in production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在生产中使用大型 NLP 模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/using-large-nlp-models-in-production-458e0d684278?source=collection_archive---------13-----------------------#2020-11-16">https://medium.com/analytics-vidhya/using-large-nlp-models-in-production-458e0d684278?source=collection_archive---------13-----------------------#2020-11-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e39a3b9b084d578dbc45c9784a1d2ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMxshP65rDR30XNGtEhBHg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:https://www.reshot.com/</figcaption></figure><p id="3354" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来自变压器的双向编码器表示(BERT)是 Google 开发的基于变压器的机器学习技术，用于自然语言处理(NLP)预训练[1]。在大型数据集上训练的 BERT 模型或其他 NLP 模型利用更多的内存。例如，BERT-base 需要大约 450 MB 的内存，而 BERT-large 需要大约 1.2 GB 的内存。</p><p id="2b3d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当使用这些 NLP 模型中的任何一个来微调我们的数据集时，我们保存多个版本的微调数据集。在生产中，我们可能需要在运行时加载任何版本。作为一种惯例，我们可以考虑在每次发出 web 请求时加载 NLP 模型，然而这在低计算生产环境中可能不可行。将一个 BERT 模型从 model mongoDB 加载到本地，然后再将本地模型加载到内存中是非常耗时的。所以在这篇文章中，我想描述一下我在生产中处理大型 NLP 模型的方法。</p><p id="469a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">出于演示目的，我将使用一个简单的 Scikit-learn 模型。</p><p id="6cec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">属地</strong></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="df83" class="kc kd hi jy b fi ke kf l kg kh">scikit-learn<strong class="jy hj"><br/></strong>joblib<br/>PyMongo</span></pre><p id="3bdf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们创建一个简单的 sklearn 模型[2]:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="1ade" class="kc kd hi jy b fi ke kf l kg kh">import joblib<br/>from sklearn import svm<br/>from sklearn import datasets</span><span id="9c92" class="kc kd hi jy b fi ki kf l kg kh">clf = svm.SVC()<br/>X, y = datasets.load_iris(return_X_y=True)<br/>clf.fit(X, y)</span><span id="343f" class="kc kd hi jy b fi ki kf l kg kh">model_name = 'mymodel_v1'<br/>model_fpath = f'{model_name}.joblib'<br/>joblib.dump(clf, model_fpath)</span></pre><p id="6539" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在模型保存在本地，现在我们需要将它保存到 DB，以便我们可以在生产中从 DB 加载。出于演示目的，我将使用 MongoDB。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3d3c" class="kc kd hi jy b fi ke kf l kg kh"># internal<br/>import datetime<br/># external<br/>import gridfs<br/>import pymongo</span><span id="cbf9" class="kc kd hi jy b fi ki kf l kg kh"># create mongo client to communicate with mongoDB<br/>mc = pymongo.MongoClient(host='220.24.52.190',<br/>                         port=27017)<br/># load or create database<br/>mydb = mc.test_database<br/># load / create file system collection<br/>fs = gridfs.GridFS(mydb)<br/># load / create model status collection<br/>mycol = mydb['ModelStatus']<br/># save the local file to mongodb<br/>with open(model_fpath, 'rb') as infile:<br/>    file_id = fs.put(<br/>        infile.read(), <br/>        model_name=model_name<br/>    )<br/># insert the model status info to ModelStatus collection <br/>params = {<br/>    'model_name': model_name,<br/>    'file_id': file_id,<br/>    'inserted_time': datetime.datetime.now()<br/>}<br/>result = mycol.insert_one(params)</span></pre><p id="3b27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在模型保存在 mongoDB 中，可以在生产过程中检索。当从数据库中检索模型时，我们将使用元类遵循单例设计模式。下面是基类的代码:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="730c" class="kc kd hi jy b fi ke kf l kg kh">class ModelSingleton(type):<br/>    """<br/>    Metaclass that creates a Singleton base type when called.<br/>    """<br/>    _mongo_id = {}</span><span id="704a" class="kc kd hi jy b fi ki kf l kg kh">    def __call__(cls, *args, **kwargs):<br/>        mongo_id = kwargs.pop('mongo_id')<br/>        if mongo_id not in cls._mongo_id:<br/>            print('Adding model into ModelSingleton')<br/>            cls._mongo_id[mongo_id] = super(ModelSingleton, cls)\<br/>                .__call__(*args, **kwargs)<br/>        return cls._mongo_id[mongo_id]</span></pre><p id="e710" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">加载模型的代码如下:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="d80e" class="kc kd hi jy b fi ke kf l kg kh">class LoadModel(metaclass=ModelSingleton):<br/>    def __init__(self, *args, **kwargs):<br/>        self.mongo_id = kwargs['mongo_id']<br/>        self.clf = self.load_model()<br/>    <br/>    def load_model(self):<br/>        print('loading model')<br/>        f = fs.find({"_id": ObjectId(self.mongo_id)}).next()<br/>        with open(f'{f.model_name}.joblib', 'wb') as outfile:<br/>            outfile.write(f.read())<br/>        return joblib.load(f'{f.model_name}.joblib')</span></pre><p id="2c05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们只需要检查 mongo <strong class="ix hj"> _id </strong>在模型版本中的任何变化。仅从数据库获取<strong class="ix hj"> _id </strong>的代码如下:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="a4ce" class="kc kd hi jy b fi ke kf l kg kh">result = mycol.find({"filename": model_name}, {'_id': 1})\<br/>    .sort('uploadDate', -1)<br/>if result.count():<br/>    mongo_id = str(result[0]['_id'])</span></pre><p id="ab97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将模型加载到生产环境中的代码如下:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b919" class="kc kd hi jy b fi ke kf l kg kh">model = LoadModel(mongo_id=mongo_id)<br/>clf = model.clf</span></pre><p id="d356" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，只有当数据库中发生变化时，才会从数据库中下载模型，否则将从内存中取出模型。</p><p id="202b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码快乐！！！</p><p id="a444" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参考资料:</p><p id="f0fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[1]<a class="ae iu" href="https://en.wikipedia.org/wiki/BERT_(language_model)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/BERT _(language _ model)</a></p><p id="775e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[2]<a class="ae iu" href="https://scikit-learn.org/stable/modules/model_persistence.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/model _ persistence . html</a></p></div></div>    
</body>
</html>