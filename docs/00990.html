<html>
<head>
<title>Kernel Density Estimation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核密度估计</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/kernel-density-estimation-kernel-construction-and-bandwidth-optimization-using-maximum-b1dfce127073?source=collection_archive---------2-----------------------#2019-09-24">https://medium.com/analytics-vidhya/kernel-density-estimation-kernel-construction-and-bandwidth-optimization-using-maximum-b1dfce127073?source=collection_archive---------2-----------------------#2019-09-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/7f700874aebbebeaf4843d63e3d1399e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqJf9lvS1PrIKVRKECu4ag.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://unsplash.com/@princeabid708?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">王子阿比德</a>在<a class="ae hv" href="https://unsplash.com/s/photos/baby-chicken?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><div class=""><h2 id="3f2d" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">使用最大似然交叉验证的核构造和带宽优化</h2></div><p id="30f9" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">本文通过一个例子详细介绍了核函数的基本原理及其在核密度估计中的应用。高斯核用于密度估计和带宽优化。最大似然交叉验证方法是一步一步解释带宽优化。所有的计算都是用R从头开始编写的，代码在文章的最后一节提供。</p><h1 id="63f5" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated"><strong class="ak">什么是内核？</strong></h1><p id="a1d7" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">内核只是一个满足下面提到的三个特性的函数。核函数用于估计随机变量的密度，在非参数回归中用作权函数。该函数也在机器学习中用作执行分类和聚类的核心方法。</p><ol class=""><li id="8baa" class="lg lh hy jp b jq jr jt ju jw li ka lj ke lk ki ll lm ln lo bi translated">核函数的第一个性质是<strong class="jp hz">它必须是对称的</strong>。这意味着+u和–u的核函数值是相同的，如下图所示。这在数学上可以表示为K (-u) = K (+u)。核函数的对称性质使得函数的最大值(<em class="lp"> max(K(u) </em>)位于曲线的中间。</li></ol><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es lq"><img src="../Images/5f2825ff6dfe96685db39338dcf675e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*9_KLoYjBuJSi1Ay5umg5tQ.png"/></div></figure><p id="b697" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">2.函数曲线下的<strong class="jp hz">面积必须等于一个</strong>。从数学上来说，这种属性表示为</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es lv"><img src="../Images/2ed5f817b98c0f3b4ea5b848bb7768bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*_MpByx9u4ByGCHIKi9C5ZQ.png"/></div></figure><p id="cc7a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">高斯密度函数被用作核函数，因为高斯密度曲线下的面积是1，并且它也是对称的。</p><p id="44fb" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">3.核函数值，也就是密度，<strong class="jp hz">不能为负</strong>，K(u) ≥ 0为all∞&lt;u&lt;∞。</p><h1 id="6a73" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">构造内核</h1><p id="a5f5" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">在这篇笔记中，我将使用高斯核函数来估计核密度，并使用示例数据集来优化带宽。高斯核的等式是:</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es lv"><img src="../Images/a8e8c42808c7177a0318ed8da1840c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*a4KTV98gSWxW1uv4e9wVAw.png"/></div></figure><p id="8463" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">其中<strong class="jp hz"> <em class="lp"> xi </em> </strong>为观察数据点。<strong class="jp hz"> <em class="lp"> x </em> </strong>是计算核函数的值，<strong class="jp hz"> <em class="lp"> h </em> </strong>称为带宽。</p><h2 id="b9d7" class="lw kk hy bd kl lx ly lz kp ma mb mc kt jw md me kv ka mf mg kx ke mh mi kz mj bi translated">例子</h2><p id="40b4" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">比方说，我们有六个学生在某一科目上取得的分数。我将使用高斯核函数在每个数据点构建核。</p><p id="7412" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> <em class="lp"> xi </em> </strong> = {65，75，67，79，81，91}</p><p id="6cf6" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> <em class="lp"> x1 </em> </strong> = 65，<strong class="jp hz"><em class="lp">x2</em></strong>= 75…<em class="lp"/><strong class="jp hz"><em class="lp">X6</em></strong>= 91。</p><p id="cbf2" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">需要三个输入来形成围绕数据点的核心曲线。它们是:</p><p id="5ed0" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一、观察数据点是哪个<strong class="jp hz"><em class="lp">【Xi】</em></strong></p><p id="5a1f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">二。<strong class="jp hz">的值<em class="lp">h</em>T7】</strong></p><p id="fdde" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">三。一系列线性间隔的数据点，包含估计了<em class="lp"> K </em>值的观察数据点。<strong class="jp hz"> <em class="lp"> Xj </em> </strong> = {50，51，52 …99}</p><p id="fb27" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">计算出<strong class="jp hz"> <em class="lp"> K </em> </strong>值为所有<strong class="jp hz"> <em class="lp"> Xj </em> </strong>值为给定值<strong class="jp hz"><em class="lp"/></strong><strong class="jp hz"><em class="lp"/></strong>h如下表所示；其中<strong class="jp hz"> <em class="lp"> xi </em> </strong> = 65而<em class="lp"/><strong class="jp hz"><em class="lp">h</em></strong>= 5.5。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mk"><img src="../Images/8130097d4027e58389b8e707be84a843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NAd468_xG12A7NRLWYaW6g.png"/></div></div></figure><p id="431d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> <em class="lp"> Xj </em> </strong>和<strong class="jp hz"> <em class="lp"> K </em> </strong>绘制如下，以形象化内核。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es ml"><img src="../Images/c8124f0a20de164677faa5a8953e62d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*eipP7m7JStHkFpbKcopNJQ.png"/></div></figure><p id="023a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">类似地，在所有六个观察到的数据点，内核值被估计为如表中所示并绘制在下面。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es mm"><img src="../Images/1cb0d070a1e720ac6dfd24bdc10411c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*2jO4wUKQRAM93oOuK1NOcQ.png"/></div></figure><p id="7169" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从表中可以看出，对于<strong class="jp hz"><em class="lp">【Xj】</em></strong>与<strong class="jp hz"><em class="lp">【Xi】</em></strong>相差甚远的值，核函数值接近0。例如，当<strong class="jp hz"><em class="lp"/></strong>= 65时，<strong class="jp hz"><em class="lp">【Xj】</em></strong><em class="lp"/>= 99处的内核密度值为零。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es mn"><img src="../Images/1fee99307744aadd0b3cf63c13bb95dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*pE1y4rjNTegzh-OoV3Fusg.png"/></div></figure><h2 id="ccad" class="lw kk hy bd kl lx ly lz kp ma mb mc kt jw md me kv ka mf mg kx ke mh mi kz mj bi translated"><strong class="ak">核密度估计(KDE) </strong></h2><p id="b32b" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">到目前为止，我们讨论了计算数据点上的单个内核。现在，计算整个数据集的复合密度值。简单的把所有<strong class="jp hz"> <em class="lp"> Xj </em> </strong>的核值(<em class="lp"> K </em>)相加就可以估算出来。参照上表，将所有行值相加得到整个数据集的<em class="lp"> KDE </em>。然后，通过除以数据点的数量(在本例中为6)对总和进行归一化。归一化是为了使KDE曲线下的面积为1。因此，计算<em class="lp"> KDE </em>的方程式对于每一个<em class="lp"> </em> <strong class="jp hz"> <em class="lp"> Xj </em> </strong>表示为:</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es mo"><img src="../Images/350017956dd85a76ca7aa5268daa6599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*adFQmTmQQ-mwyggcTPWe7A.png"/></div></figure><p id="0848" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">其中<strong class="jp hz"> <em class="lp"> n </em> </strong> <em class="lp"> </em>是数据点的个数。添加所有六个归一化核后的<strong class="jp hz"> <em class="lp"> KDE </em> </strong>如下图所示。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es mp"><img src="../Images/0c63cd1a4170b0321ab07290cd0f03d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*YelmdNHsK4uzePPjIjbiiQ.png"/></div></figure><h1 id="41ad" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated"><strong class="ak">带宽优化</strong></h1><p id="175b" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">内核函数的带宽(<strong class="jp hz"> <em class="lp"> h </em> </strong>)对于恰当地拟合数据起着重要的作用。带宽的低值估计了具有大量方差的密度，而<strong class="jp hz"> <em class="lp"> h </em> </strong>的高值产生大偏差。因此，对最佳值<strong class="jp hz"> <em class="lp"> h </em> </strong>的估计对于构建最有意义和最准确的密度非常重要。如下图所示，三个不同的带宽值会产生三条不同的曲线。黑色的给出了很多密度值的变化，看起来不真实，而紫色的没有通过隐藏信息来解释实际的密度。</p><p id="4664" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">研究人员提出了几种方法来优化核密度估计中的带宽值。其中之一是<strong class="jp hz">最大似然交叉验证</strong>方法。在这篇文章中，更多关于这种方法的解释是清楚的，并应用于一个示例数据集。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es mq"><img src="../Images/6d4cdc0c52250b30fa729be4e4e48f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*-tehOLz_vJ2pVbQVJ4CZ9Q.png"/></div></figure><h2 id="3191" class="lw kk hy bd kl lx ly lz kp ma mb mc kt jw md me kv ka mf mg kx ke mh mi kz mj bi translated"><strong class="ak">最大似然交叉验证(MLCV) </strong></h2><p id="6de5" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">这种方法是由霍贝马、赫尔曼斯和范·登布鲁克(1971年)和杜恩(1976年)提出的。在该方法中，基于<strong class="jp hz">留一交叉验证方法</strong>，在<strong class="jp hz"> <em class="lp"> Xj </em> </strong>的子集上估计核函数。最大化MLCV的目标函数表示为:</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es mo"><img src="../Images/12cd5a7f1f7447fd09cd043df26369b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*7XB7uypOreAvnrdY7Zfjow.png"/></div></figure><p id="6c45" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个等式看起来很复杂，但通过举例详细解释每个术语，它就变得很简单了。</p><p id="f5b1" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">期限1: </strong></p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es mo"><img src="../Images/791d6b96fdb14b5618c775492fd34951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*1LFiRKGRYQyq-y5T6AQOMQ.png"/></div></figure><p id="fa72" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">计算前面部分中讨论的核函数值。这里在<strong class="jp hz"> <em class="lp"> x1 </em> </strong> <em class="lp">，</em> <strong class="jp hz"> <em class="lp"> K </em> </strong>值是在<strong class="jp hz"><em class="lp"/></strong>范围内对某个<strong class="jp hz"> <em class="lp"> h </em> </strong>计算的，其中不包括<strong class="jp hz"><em class="lp"/></strong><strong class="jp hz"><em class="lp">Xj</em></strong>。将<strong class="jp hz"> K </strong>的值相加，最后计算和的对数。</p><h2 id="158b" class="lw kk hy bd kl lx ly lz kp ma mb mc kt jw md me kv ka mf mg kx ke mh mi kz mj bi translated">例子</h2><p id="26b9" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">考虑<strong class="jp hz"><em class="lp">h</em></strong>= 3(<strong class="jp hz"><em class="lp">h</em></strong>得优化。我取了<strong class="jp hz"> <em class="lp"> h </em> </strong> = 3只是为了解释优化函数是如何计算的)。</p><p id="9600" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> <em class="lp"> xi </em> </strong> = {65，75，67，79，75，63，71，83，91，95}</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mr"><img src="../Images/6da6d0044c808d6094184c6fd57d5d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dA7IjLnO_GaoJgh1TWTRdA.png"/></div></div></figure><p id="907d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"><em class="lp">Xj</em></strong>=<strong class="jp hz"><em class="lp">Xi</em></strong>的值<strong class="jp hz"> <em class="lp"> K </em> </strong>被设置为零，以确保它们在求和时被排除在外。</p><p id="74fa" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">期限二:</strong></p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es mo"><img src="../Images/c6293a385eef1ad96a0cb347226bbaca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*QAcqKrfaTttBBRvqHh7xRg.png"/></div></figure><p id="0695" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这个例子中，<strong class="jp hz"> <em class="lp"> n </em> </strong> = 10而<strong class="jp hz"> <em class="lp"> h </em> </strong> = 3。我们可以很容易地将该项估计为:</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es mo"><img src="../Images/fc13bf78f29b0fd834db2b57f577f519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*VlVw1v9VrOnMbUwpfbYLjg.png"/></div></figure><p id="9201" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">目标函数(MLCV)的最终值通过从项1中减去项2所获得的差值的平均值来计算，如下表所示。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ms"><img src="../Images/2fb0cc04a38b4c321d7c6e39791473c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pfF_FECusUqaJXuUj4fECw.png"/></div></div></figure><p id="ae2a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对于带宽，目标函数值即MLCV为-2.3438539，<strong class="jp hz"> <em class="lp"> h </em> </strong> = 3。通过选择不同的<strong class="jp hz"> <em class="lp"> h </em> </strong>的值重复相同的过程，使得MLCV值接近有限的最大值来优化<strong class="jp hz"> <em class="lp"> h </em> </strong>。黄金分割搜索优化算法中的<em class="lp">优化R中的</em>函数用于最大化MLCV函数。</p><p id="6cb9" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">本例中<strong class="jp hz"> <em class="lp"> h </em> </strong>的优化值为<strong class="jp hz"> 6.16 </strong>，目标函数值为<strong class="jp hz"> <em class="lp"> -2.295783 </em> </strong>。</p><p id="ce6d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">使用优化带宽(= 6.16)估计并绘制KDE，并与使用R中的<em class="lp">密度</em>函数获得的KDE进行比较。如下图所示，使用优化的<strong class="jp hz"><em class="lp"/></strong>h的KDE非常接近使用R <em class="lp">密度</em>函数绘制的KDE。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div class="er es lv"><img src="../Images/df4d0770302a45b555f30d9c5a9d46ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*IG-jm1SBBmAfn14IfN9qBg.png"/></div></figure><h1 id="4554" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">r代码</h1><p id="6764" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated"><em class="lp"> KDE </em></p><pre class="lr ls lt lu fd mt mu mv mw aw mx bi"><span id="71cd" class="lw kk hy mu b fi my mz l na nb">#KDE<br/>data &lt;- c(65, 75, 67, 79, 81, 91)<br/>plot(NA,NA,xlim = c(50,120),ylim = c(0,0.04),xlab = 'X',ylab = 'K (= density)')</span><span id="9932" class="lw kk hy mu b fi nc mz l na nb">h = 5.5<br/>kernelpoints &lt;- seq(50,150,1)<br/>kde &lt;- NULL</span><span id="762a" class="lw kk hy mu b fi nc mz l na nb">for(i in 1:length(data)){<br/>  z &lt;- (kernelpoints-data[i])/h<br/>  multi &lt;- 1/(sqrt(2*pi))<br/>  kerneld &lt;- ((multi)*exp(-0.5 * z^2))/(length(data)*h)<br/>  lines(kernelpoints,kerneld, lwd = 3)<br/>  kde &lt;- cbind(kde,kerneld)<br/>}<br/>kde_sum&lt;- rowSums(kde)<br/>lines(kernelpoints,kde_sum, lwd = 3, col = 'red')<br/>grid(20,20)</span></pre><p id="e4a1" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">MLCV —带宽优化</p><pre class="lr ls lt lu fd mt mu mv mw aw mx bi"><span id="b4bd" class="lw kk hy mu b fi my mz l na nb">#MLCV<br/>x &lt;-  c(65, 75, 67, 79, 75, 63, 71, 83, 91, 95)<br/>y &lt;- seq(50,100,1)</span><span id="d517" class="lw kk hy mu b fi nc mz l na nb">x &lt;- sort(x)<br/>n &lt;- length(x)<br/>u = outer(y,x,"-")</span><span id="abe2" class="lw kk hy mu b fi nc mz l na nb">fmlcv &lt;- function(h) {<br/>  D &lt;- (1/sqrt(2*pi))*exp(-0.5 *(u/h)^2)<br/>  colnames(D) &lt;- x<br/>  rownames(D) &lt;- y<br/>for(i in 1:n){<br/>    kk &lt;- which(rownames(D)==colnames(D)[i])<br/>    D[kk,i] &lt;- 0 }<br/>  D1 &lt;- log(colSums(D))<br/>  D2 &lt;- log((n-1)*h)<br/>  Fx &lt;- D1-D2<br/>  mean(Fx)}</span><span id="4dd9" class="lw kk hy mu b fi nc mz l na nb">lower = 1<br/>upper = 10<br/>tol = 0.01</span><span id="ac92" class="lw kk hy mu b fi nc mz l na nb">#Using optimize function in R<br/>obj &lt;- optimize(fmlcv ,c(lower,upper),tol=tol,maximum = TRUE)<br/>print(obj)<br/>plot(density(x), lwd = 4, col = 'purple') #From R library<br/>lines(density(x, bw = obj$maximum), lwd = 2, col = 'red', lty = 1)<br/>legend("topright",legend=c("KDE from R", "KDE from MLCV"),<br/>       col=c("blue","red"),lty=1, cex=0.8, lwd = c(4,2),text.font=4)<br/>print(obj$maximum)</span></pre><h1 id="e0fe" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">参考</h1><p id="cb51" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">密度及其导数的核估计量和带宽选择</p><p id="61e1" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">密度估计:日元-陈驰的直方图和核密度估计器(2018年)</p></div></div>    
</body>
</html>