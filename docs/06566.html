<html>
<head>
<title>Custom User model in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django中的自定义用户模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/custom-user-model-in-django-561884d65540?source=collection_archive---------12-----------------------#2020-05-26">https://medium.com/analytics-vidhya/custom-user-model-in-django-561884d65540?source=collection_archive---------12-----------------------#2020-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="851f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上周六，我阅读了Django用户模型字段的文档。我都不记得我在找什么了。但是，当我阅读了用户名字段的描述后，我意识到我需要重写整个项目。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/44a77f8f180f84597ba42d1c41a4d2ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GHhL0g0pUsl9jbwI"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jt" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>拍摄</figcaption></figure><p id="ef38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所知，Django有一个内置的用户模型，这是默认选择。我在我的项目中使用了它，但该项目需要通过电子邮件进行认证。我们的时间有限，所以我决定将电子邮件保存到用户名字段。丑陋，但迅速和作品。不要这样做。</p><p id="2341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来自Django doc:</p><p id="76c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ju">用户名</em></p><p id="79e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ju">必填。150个字符或更少。用户名可以包含字母数字、</em> <code class="du jv jw jx jy b"><em class="ju">_</em></code> <em class="ju">、</em> <code class="du jv jw jx jy b"><em class="ju">@</em></code> <em class="ju">、</em> <code class="du jv jw jx jy b"><em class="ju">+</em></code> <em class="ju">、</em> <code class="du jv jw jx jy b"><em class="ju">.</em></code> <em class="ju">和</em> <code class="du jv jw jx jy b"><em class="ju">-</em></code> <em class="ju">字符。</em></p><div class="jz ka ez fb kb kc"><a href="https://docs.djangoproject.com/" rel="noopener  ugc nofollow" target="_blank"><div class="kd ab dw"><div class="ke ab kf cl cj kg"><h2 class="bd hj fi z dy kh ea eb ki ed ef hh bi translated">姜戈文件|姜戈文件|姜戈</h2><div class="kj l"><h3 class="bd b fi z dy kh ea eb ki ed ef dx translated">你需要知道的关于姜戈的一切。你是刚接触Django还是编程？这是开始的地方！拥有…</h3></div><div class="kk l"><p class="bd b fp z dy kh ea eb ki ed ef dx translated">docs.djangoproject.com</p></div></div><div class="kl l"><div class="km l kn ko kp kl kq jn kc"/></div></div></a></div><p id="5613" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原来用户名字段只支持有限的字符集，它不包含电子邮件中所有可能的字符。</p><p id="7355" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，有两种解决方案。您可以使用自定义用户模型，也可以重写注册和身份验证后端以使用标准用户模型，并接受电子邮件作为登录。</p><p id="e108" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我决定走第一条路，以便能够在未来对用户模型进行一些更改。</p><p id="cf29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里应该注意的是，在现有项目中迁移到定制用户模型是非常复杂的。我的项目目前还不大。所以我可以生成一个新的。</p><p id="6d84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一件事是用户模型类应该在models.py文件中并且只在那里。如果您将它移动到models文件夹并存储在user.py文件中，您将收到一个错误:</p><pre class="je jf jg jh fd kr jy ks kt aw ku bi"><span id="cf62" class="kv kw hi jy b fi kx ky l kz la">ModuleNotFoundError: No module named 'myappt.CustomUser'</span></pre><p id="bc89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的模型. py:</p><pre class="je jf jg jh fd kr jy ks kt aw ku bi"><span id="d2c4" class="kv kw hi jy b fi kx ky l kz la">from django.db import models<br/>from django.contrib.auth.models import AbstractUser<br/>from django.contrib.auth.models import BaseUserManager<br/><br/><br/>class AppUserManager(BaseUserManager):<br/>    def create_user(self, email, password, username, **extra_fields):<br/>        if not email:<br/>            raise ValueError('The Email must be set')<br/>        if not username:<br/>            raise ValueError('The Username must be set')<br/>        email = self.normalize_email(email)<br/>        user = self.model(email=email, **extra_fields)<br/>        user.set_password(password)<br/>        user.save()<br/>        return user<br/><br/>    def create_superuser(self, email, password, username, **extra_fields):<br/>        extra_fields.setdefault('is_staff', True)<br/>        extra_fields.setdefault('is_superuser', True)<br/>        extra_fields.setdefault('is_active', True)<br/><br/>        if extra_fields.get('is_staff') is not True:<br/>            raise ValueError('Superuser must have is_staff=True.')<br/>        if extra_fields.get('is_superuser') is not True:<br/>            raise ValueError('Superuser must have is_superuser=True.')<br/>        return self.create_user(email, password, username, **extra_fields)<br/><br/><br/>class AppUser(AbstractUser):<br/>    email = models.EmailField(unique=True, blank=False)<br/>    username = models.CharField(max_length=250, blank=True)<br/>    is_staff = models.BooleanField(default=False)<br/>    is_active = models.BooleanField(default=True)<br/>    is_superuser = models.BooleanField(default=False)<br/><br/>    REQUIRED_FIELDS = ['username']<br/>    USERNAME_FIELD = 'email'<br/>    objects = AppUserManager()<br/><br/>    def __str__(self):<br/>        return self.email</span></pre><p id="cc9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要忘记将该字符串添加到settings.py:</p><pre class="je jf jg jh fd kr jy ks kt aw ku bi"><span id="215f" class="kv kw hi jy b fi kx ky l kz la"># Custom User model<br/>AUTH_USER_MODEL = 'app.AppUser'</span></pre><p id="a509" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想从管理面板管理您的用户，您必须向admin.py添加一些代码:</p><pre class="je jf jg jh fd kr jy ks kt aw ku bi"><span id="da59" class="kv kw hi jy b fi kx ky l kz la">from .models import AppUser<br/><br/><br/>class UserCreationForm(forms.ModelForm):<br/>    <em class="ju">"""A form for creating new users. Includes all the required<br/>    fields, plus a repeated password."""<br/>    </em>password1 = forms.CharField(label='Password', widget=forms.PasswordInput)<br/>    password2 = forms.CharField(label='Password confirmation', widget=forms.PasswordInput)<br/><br/>    class Meta:<br/>        model = AppUser<br/>        fields = ('email', 'username')<br/><br/>    def clean_password2(self):<br/>        # Check that the two password entries match<br/>        password1 = self.cleaned_data.get("password1")<br/>        password2 = self.cleaned_data.get("password2")<br/>        if password1 and password2 and password1 != password2:<br/>            raise forms.ValidationError("Passwords don't match")<br/>        return password2<br/><br/>    def save(self, commit=True):<br/>        # Save the provided password in hashed format<br/>        user = super().save(commit=False)<br/>        user.set_password(self.cleaned_data["password1"])<br/>        if commit:<br/>            user.save()<br/>        return user<br/><br/><br/>class UserChangeForm(forms.ModelForm):<br/>    <em class="ju">"""A form for updating users. Includes all the fields on<br/>    the user, but replaces the password field with admin's<br/>    password hash display field.<br/>    """<br/>    </em>password = ReadOnlyPasswordHashField()<br/><br/>    class Meta:<br/>        model = AppUser<br/>        fields = ('email', 'password', 'username', 'is_active', 'is_staff')<br/><br/>    def clean_password(self):<br/>        # Regardless of what the user provides, return the initial value.<br/>        # This is done here, rather than on the field, because the<br/>        # field does not have access to the initial value<br/>        return self.initial["password"]<br/><br/><br/>class UserAdmin(BaseUserAdmin):<br/>    # The forms to add and change user instances<br/>    form = UserChangeForm<br/>    add_form = UserCreationForm<br/><br/>    # The fields to be used in displaying the User model.<br/>    # These override the definitions on the base UserAdmin<br/>    # that reference specific fields on auth.User.<br/>    list_display = ('email', 'username', 'is_staff')<br/>    list_filter = ('is_staff',)<br/>    fieldsets = (<br/>        (None, {'fields': ('email', 'password')}),<br/>        ('Personal info', {'fields': ('username',)}),<br/>        ('Permissions', {'fields': ('is_staff',)}),<br/>    )<br/>    # add_fieldsets is not a standard ModelAdmin attribute. UserAdmin<br/>    # overrides get_fieldsets to use this attribute when creating a user.<br/>    add_fieldsets = (<br/>        (None, {<br/>            'classes': ('wide',),<br/>            'fields': ('email', 'username', 'password1', 'password2'),<br/>        }),<br/>    )<br/>    search_fields = ('email',)<br/>    ordering = ('email',)<br/>    filter_horizontal = ()<br/><br/><br/>admin.site.register(AppUser, UserAdmin)<br/>admin.site.unregister(Group)</span></pre><p id="4c7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这篇文章对你有用。</p></div></div>    
</body>
</html>