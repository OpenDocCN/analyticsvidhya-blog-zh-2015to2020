<html>
<head>
<title>Use Your Data: Automating Email Attachments Downloads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用您的数据:自动下载电子邮件附件</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/part-1-use-your-data-automating-email-attachments-downloads-671279144f62?source=collection_archive---------14-----------------------#2019-10-14">https://medium.com/analytics-vidhya/part-1-use-your-data-automating-email-attachments-downloads-671279144f62?source=collection_archive---------14-----------------------#2019-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/77b8b836c157872aba42fe36d05a60cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9DeVJ8nfx1cFrkT-"/></div></div></figure><div class=""/><div class=""><h2 id="266e" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">第1部分—问题陈述的形成和数据的收集</h2></div><p id="c141" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是展示如何使用你的数据解决问题的两篇文章中的第一篇。我相信，在应用数据科学技能之前，您不需要解决大问题。有些问题就在我们面前，只要仔细关注和自动化，我们就能解决它们。第一部分介绍如何自动下载电子邮件附件，第二部分介绍如何抓取pdf并提取相关数据。请注意，我们不会共享任何数据，因为这些都是财务敏感信息。</p><figure class="kf kg kh ki fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ke"><img src="../Images/bdc47a3990420f271f3a18cd7c640876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ncBAjJrQ_ArB7Xk0"/></div></div></figure><p id="fb37" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">问题概述:最近，我的孩子所在的家庭日托中心的老板通知我，有一笔未付的款项。<em class="kj">杰出？哇！这么多？怎么会这样</em>她解释说，给我孩子的儿童保育补贴一直在波动，她最近刚刚完成了检查。她给了我一张到目前为止所欠的清单，我向她保证我会检查我的记录并整理出来。</p><p id="7b61" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">好了，我们开始工作吧。</p><figure class="kf kg kh ki fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kk"><img src="../Images/2ea9f9b0af4c43a752608f4afbde55d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hupjBinCe_GDs5As"/></div></div></figure><p id="b962" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">问题定义:我欠了多少儿童保育费用？我如何阻止这些付款差异再次发生？</p><p id="4393" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">行动方针:从电子邮件中下载权利声明(这提供了使用小时数、Centrelink支付的儿童保育补贴和父母应支付的未付款项的细目)，并进行一些计算。现在我可以用手来做，通过手动增加和减少数量。但是三个月后会发生什么呢？六个月？我必须重复这个非常手动的过程吗？绝对不方便！！！当然，这必须自动化。</p><p id="45c7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我采用了OSEMN数据科学模型的前三个部分(获取数据、清理数据、探索数据)——【http://www.dataists.com/2010/09/a-taxonomy-of-data-science<a class="ae kl" href="http://www.dataists.com/2010/09/a-taxonomy-of-data-science" rel="noopener ugc nofollow" target="_blank"/>。在本文中，我们将关注第一部分——获取数据。</p><p id="5faf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">第一步——获取数据:权利声明以PDF文件的形式发送到我妻子的收件箱。多方便啊。我不得不设法收集这些PDF文件，将它们合并成一个电子表格，然后进行计算，找出由于儿童保育补贴的波动，我欠了多少欠款。但首先我得拿到pdf文件？怎么会？首先想到的是下载每一个，虽然不是很多，但是不方便。必须有一种简化事情的方法。</p><p id="e2b0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果我找到一种自动下载过程的方法，程序会进入邮箱，筛选主题为“权利声明”的邮件，找到这些特定邮件中的附件，并将它们下载到我的电脑上，会怎么样？</p><p id="81c5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">Python是我研究数据科学的工具之一。这是简单，容易和有效的。下面的脚本展示了整个自动化过程。</p><pre class="kf kg kh ki fd km kn ko kp aw kq bi"><span id="f25f" class="kr ks ht kn b fi kt ku l kv kw"># Import relevant modules<br/>import imaplib<br/>import configparser<br/>import email<br/>from pathlib import Path</span></pre><p id="a8c0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">Imaplib包有助于连接到电子邮件服务器，特别是用于检索。电子邮件包管理电子邮件。在这种情况下，ConfigParser帮助检索存储在单独文件中的邮件用户名和密码——您不希望您的电子邮件详细信息出现在脚本中——这肯定是不安全的！Pathlib有助于文件访问，在我看来，它比OS包更容易使用。</p><p id="8e3b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">好了，模块装载完毕。让我们登录我们的邮箱。首先，我们创建一个包含用户名和密码的文件，并将其保存为<em class="kj">‘something . ini’</em>。然后，我们使用configparser引用该文件，并登录到我们的gmail帐户。同样，将我们的详细信息保存在一个单独的文件中的整个想法是出于安全原因——确保没有人能够通过脚本访问我们的登录详细信息。</p><pre class="kf kg kh ki fd km kn ko kp aw kq bi"><span id="ae36" class="kr ks ht kn b fi kt ku l kv kw">#login details stored in config file and kept separate<br/>config_path = '/home/sam/Everything Python/config_file_childcare.ini'<br/>config = configparser.ConfigParser()<br/>config.read(config_path)<br/>host = 'imap.gmail.com'<br/>user = config.get('gmail','username')<br/>password = config.get('gmail','password')<br/>	</span><span id="d1ac" class="kr ks ht kn b fi kx ku l kv kw"># Connect to the server<br/>print('Connecting to ' + host)<br/>mailBox = imaplib.IMAP4_SSL(host)<br/>	</span><span id="074f" class="kr ks ht kn b fi kx ku l kv kw"># Login to your account<br/> mailBox.login(user, password)</span></pre><p id="085d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">此时，您应该会在屏幕上看到一条确认登录成功的消息。如果失败，您会收到“验证失败”错误，您可以更改gmail上的设置，允许不太安全的应用程序访问。一旦执行了脚本，您可以随时关闭它。邮箱默认为您的收件箱。当然，您可以访问邮件的其他部分，但这里我将重点讨论我们的问题范围。</p><p id="1ceb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">好了，我们进去了，让我们去拿那些附件。我是说，这就是我们在这里的目的。</p><pre class="kf kg kh ki fd km kn ko kp aw kq bi"><span id="36ee" class="kr ks ht kn b fi kt ku l kv kw">mailBox.select()<br/>	searchQuery = '(SUBJECT "Statement of Entitlement")'	</span><span id="40d3" class="kr ks ht kn b fi kx ku l kv kw">	_, data = mailBox.uid('search', None, searchQuery)</span></pre><p id="599d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们在这里搜索我们的邮件。我们很具体，因为我们知道题目。搜索是通过uid唯一标识符完成的。每条消息都有一个UID。建议按UID搜索——这是直接从Python的Imaplib文档中复制的:<em class="kj">“注意，IMAP4的消息编号随着邮箱的变化而变化；特别是，在EXPUNGE命令执行删除操作后，剩余的邮件会重新编号。因此，强烈建议通过UID命令使用UID。https://docs.python.org/3.7/library/imaplib.html</em><a class="ae kl" href="https://docs.python.org/3.7/library/imaplib.html" rel="noopener ugc nofollow" target="_blank"/></p><p id="b56b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">搜索的输出是一个元组—我们只对元组的第二部分感兴趣，它包含相关的消息(以字节为单位)。我们仍然有一些方法去得到我们的附件。来吧，我们走——快到了。</p><pre class="kf kg kh ki fd km kn ko kp aw kq bi"><span id="8d9d" class="kr ks ht kn b fi kt ku l kv kw">for num, latest_email_uid in enumerate(data[0].split()):   <br/>	</span><span id="c70a" class="kr ks ht kn b fi kx ku l kv kw">	    _,box = mailBox.uid('fetch',latest_email_uid,'(RFC822)')<br/>	</span><span id="c744" class="kr ks ht kn b fi kx ku l kv kw">	    c = email.message_from_string(box[0][1].decode('utf-8')) <br/>	</span><span id="6475" class="kr ks ht kn b fi kx ku l kv kw">	    for part in c.walk():<br/>            #only interested in the part of the email that has attachment<br/>	        if part.get_content_disposition()!='attachment': <br/>             <br/>	            continue<br/>	        file_name = f'{num+1}_{part.get_filename()}'<br/>	        print(file_name)<br/>	        attachment = part.get_payload(decode=True)<br/>	</span><span id="0bbb" class="kr ks ht kn b fi kx ku l kv kw">	        file_dir = Path('./Data/Email_Downloads')<br/>	</span><span id="032b" class="kr ks ht kn b fi kx ku l kv kw">	        file_ = file_dir/file_name<br/>	        if not file_.exists():<br/>	            file_.touch()<br/>	            file_.write_bytes(attachment)<br/>	            print('file created!')<br/>	        else:<br/>	            print(f'{file_} already exists!')<br/>	</span><span id="a636" class="kr ks ht kn b fi kx ku l kv kw">mailBox.close()<br/>mailBox.logout()</span></pre><p id="002c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">基本上，该脚本所做的是遍历我们的邮件，只查找带有附件的邮件的子部分，并将它们下载到我的计算机上的特定位置。</p><p id="104e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在你知道了。电子邮件附件可以自动下载到我的电脑上。下面是我的github资源库上完整脚本的链接:<a class="ae kl" href="https://github.com/samukweku/PDF_Extraction/blob/master/attachment_downloads.py" rel="noopener ugc nofollow" target="_blank"><em class="kj">https://github . com/samukweku/PDF _ Extraction/blob/master/attachment _ downloads . py</em></a></p><p id="ad27" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">试一试，调整它，打破它，根据你的需要配置它，让我知道你的想法。欢迎反馈和建议。</p><p id="9b12" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们开始第二部分——提取数据。</p></div></div>    
</body>
</html>