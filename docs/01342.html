<html>
<head>
<title>Brent Oil Prices Forecast with Prophet and ARIMA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预言家和ARIMA预测布伦特原油价格</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/brent-oil-prices-forecast-with-prophet-and-arima-50f5f177da5b?source=collection_archive---------4-----------------------#2019-10-16">https://medium.com/analytics-vidhya/brent-oil-prices-forecast-with-prophet-and-arima-50f5f177da5b?source=collection_archive---------4-----------------------#2019-10-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="36ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原油价格的变动受到多种因素的影响。这些因素中有些是政治因素，有些则与通货膨胀、经济等有关。有可能根据历史数据预测未来的油价吗？本文将就此问题给出答案。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/8e008a55d51445ed0eeee6039d98938f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HOtCB-sVkDA_-UGq39dsw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">石油开采，来源:pixabay</figcaption></figure><p id="1fb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在对该主题的文献回顾中，我能够找到之前由<a class="ae jt" href="https://www.sciencedirect.com/science/article/pii/S1877050917326169" rel="noopener ugc nofollow" target="_blank">陈等人</a>使用深度学习基于长短期记忆预测原油的工作。</p><h1 id="9bc6" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">时间序列</h1><p id="f61e" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">时间序列是按固定时间间隔存储的一系列记录。</p><p id="9eb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据时间间隔的频率，时间序列可以记录每年、每季度、每月、每天、每小时等等。例如每周商店销售额、每日天气预报、每月收入、每小时股票价格、分钟或秒钟网络流量等。</p><p id="8a54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用时间序列来预测未来，例如，我们可以根据前几年的历史来预测下个月的商店销售额。我们可以根据最近几年的物价上涨来预测通货膨胀。时间序列预测有助于预测汽车的未来销售，因此公司可以加强他们的产品线和供应链等。</p><h1 id="0b34" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">资料组</h1><p id="a31d" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">此处提供了数据集的完整示例<a class="ae jt" href="https://www.kaggle.com/mabusalah/brent-oil-prices" rel="noopener ugc nofollow" target="_blank">。数据集的来源是美国能源信息管理局。csv文件包含两列，日期和价格。该数据包含从1987年5月17日到2019年9月30日的每日历史布伦特油价。让我们探索并微调数据集:</a></p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="cf84" class="ld jw hi kz b fi le lf l lg lh">#import the csv file<br/>oilPrices = pd.read_csv('/kaggle/input/brent-oil-prices/BrentOilPrices.csv')<br/>#change column names to more comfortable names<br/>oilPrices.columns=['date', 'price']<br/>#Cast Date Column to type date<br/>oilPrices['date'] = pd.to_datetime(oilPrices['date'])<br/>print("Data Set:"% oilPrices.columns, oilPrices.shape)<br/>print("Data Types:", oilPrices.dtypes)<br/>#Check the top five records<br/>oilPrices.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es li"><img src="../Images/17950e5641037f398c5b5515d1ee88e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*TMtSbqKsCLRVxp6f-gEx3g.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">前五条记录和日期形状</figcaption></figure><p id="5631" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能已经注意到，时间序列数据不包含周六和周日的值，因为市场在周末关闭。因此，必须填充缺失的值。要填充周末，首先将日期作为索引(对于重采样方法)，然后使用forward fill ffill()，该函数将周末值分配给星期五值。重采样法用于时间序列的频率转换和重采样。对象必须具有类似日期时间的索引(DatetimeIndex、PeriodIndex或TimedeltaIndex)，或者将类似日期时间的值传递给on或level关键字。</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="34d2" class="ld jw hi kz b fi le lf l lg lh">oilPrices.set_index('date', inplace=True)<br/>oilPrices = oilPrices.resample('D').ffill().reset_index()</span></pre><p id="b92e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确保我们没有空值:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="a88e" class="ld jw hi kz b fi le lf l lg lh">oilPrices.isnull().values.any()</span></pre><p id="4085" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将日期分为年、月和周来探究油价的趋势:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="05c1" class="ld jw hi kz b fi le lf l lg lh">oilPrices['year']=oilPrices['date'].dt.year<br/>oilPrices['month']=oilPrices['date'].dt.month<br/>oilPrices['week']=oilPrices['date'].dt.week</span></pre><p id="e455" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分成训练和测试来预测2019年的油价。请注意，我对2000年的时间序列进行了训练，因为它证明了更高的准确性:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="ec62" class="ld jw hi kz b fi le lf l lg lh">train = oilPrices[(oilPrices['date' ] &gt; '2000-01-01') &amp; (oilPrices['date' ] &lt;= '2018-12-31')]<br/>test = oilPrices[oilPrices['date' ] &gt;= '2019-01-01']</span></pre><p id="153b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">年度价格可视化:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="ed42" class="ld jw hi kz b fi le lf l lg lh">yearlyPrice=train.groupby(["year"])['price'].mean()<br/>plt.figure(figsize=(16,4))<br/>plt.title('Oil Prices')<br/>plt.xlabel('Year')<br/>plt.ylabel('Price')<br/>yearlyPrice.plot()<br/>plt.show();</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/01dc6f707fb503163b9f544166a030b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6xnmc12Fin8uf20xU4mtnw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">年度价格可视化</figcaption></figure><h1 id="a01d" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">ARIMA模型</h1><p id="9985" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">ARIMA用于建模非季节性时间序列，它代表“自回归综合移动平均”。我将使用ARIMA作为基线模型，对照Prophet模型进行测试，看看哪个模型做出的预测更好。此处提供全部参考资料<a class="ae jt" href="https://www.machinelearningplus.com/time-series/arima-model-time-series-forecasting-python/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="191f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要为ARIMA估计量准备数据:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="3a61" class="ld jw hi kz b fi le lf l lg lh">#Convert to Time Series For ARIMA Estimator<br/>series=pd.Series(data=train['price'].to_numpy(), index=train['date'])</span></pre><p id="db6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要用ARIMA预测时间序列，需要设置三个参数(p，d，q)的值:</p><ul class=""><li id="9882" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><em class="ju"> p </em>:自回归(AR)模型的阶数(即滞后观测值的个数)</li><li id="6d79" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><em class="ju"> d </em>:差异的程度。</li><li id="1e84" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><em class="ju"> q </em>:均线(MA)模型的阶。这实际上是时间序列数据上“窗口”函数的大小。</li></ul><h1 id="9e1c" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">求ARIMA模型中差分(d)的阶</h1><p id="931e" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">差分的目的是使时间序列平稳。要做到这一点，我们需要衡量今天和昨天之间的差异，然后(明天-昨天，等等。直到我们到达<strong class="ih hj">静止数据</strong>。</p><p id="dbe0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个<strong class="ih hj">平稳时间序列</strong>是一个统计特性——如<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/mean/" rel="noopener ugc nofollow" target="_blank">均值</a>和<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/probability-and-statistics/variance/" rel="noopener ugc nofollow" target="_blank">方差</a>——随时间保持不变的时间序列</p><p id="aade" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要平稳数据来进行时间序列预测。正确的差分顺序是获得一个接近平稳的序列所需的最小差分，该序列在一个定义的平均值附近漫游，并且自相关函数(ACF)图相当快地达到零。</p><p id="15d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检验我们是否有平稳的时间序列，可以使用扩展的Dickey-Fuller方法，在存在序列相关性的情况下检验单变量过程中的单位根。如果p值i &gt; 0.05，也就是0.286247，我们继续寻找差分的阶。</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="8593" class="ld jw hi kz b fi le lf l lg lh">from statsmodels.tsa.stattools import adfuller<br/>from numpy import log<br/>result = adfuller(series.dropna())<br/>print('ADF Statistic: %f' % result[0])<br/>print('p-value: %f' % result[1])</span></pre><p id="7b14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但在此之前，让我们绘制时间序列中的前100条记录，看看p值是否可以虚拟演示:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="e179" class="ld jw hi kz b fi le lf l lg lh">plt.plot(series[0:100])<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ly"><img src="../Images/e18a3273e2deb52775cdfacb4427e8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGYJM4eavkBkHgF4jn8Cwg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">很明显，时间序列不是平稳的</figcaption></figure><p id="c2dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于时间序列不是平稳的，我们需要差分，如果时间序列是平稳的<strong class="ih hj"> d值将是0 </strong>。让我们做一天的差分，看看这是否会使数据稳定:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="7af0" class="ld jw hi kz b fi le lf l lg lh">daily_series_diff1 = series.diff(periods=1).dropna()<br/>daily_series_diff2 = daily_series_diff1.diff(periods=1).dropna()<br/>fig, ax = plt.subplots()<br/>ax.plot(daily_series_diff1[0:100], label='1st Order Differencing')<br/>ax.plot(daily_series_diff2[0:100], label='2nd Order Differencing')<br/>plt.ylim([-3,3])<br/>legend = ax.legend(loc='upper center', shadow=True)<br/>plt.title('Time Series')<br/>plt.xlabel('Date')<br/>plt.ylabel('Diff')<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/93385dff53ce2586abb5ce9dd9b9e665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tN27FLffmzstA_27gal1_w.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">差分后的平稳时间序列</figcaption></figure><p id="ddec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在上面看到的示例仅针对时间序列的前100条记录，如果我们查看18年的原始时间序列，我们会发现下面的示例:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ma"><img src="../Images/b08ece2740f14eeb195b111dfefbda1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--ARuBE0ZGNQspArYK-kjA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">18年时间序列</figcaption></figure><p id="1fe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，时间序列听起来并不稳定，但是在测试过程中，<strong class="ih hj"> d的最佳值为零</strong>。</p><p id="aa69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ju">如果时间的移动不会引起分布形状的变化，则时间序列具有平稳性</em>；单位根是非平稳性的一个原因，我们注意到在第一次差分后，分布的形状没有变化。</p><p id="7a81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果显示，d的最佳值为1，但让我们通过下式进行最终测试:</p><ul class=""><li id="3273" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><strong class="ih hj">增广迪基富勒检验</strong> ( <a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/adf-augmented-dickey-fuller-test/" rel="noopener ugc nofollow" target="_blank"> ADF </a>):是对<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/stationarity/" rel="noopener ugc nofollow" target="_blank">平稳性</a>的<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/unit-root/" rel="noopener ugc nofollow" target="_blank">单位根</a>检验。单位根会在您的<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/timeplot/" rel="noopener ugc nofollow" target="_blank">时间序列</a>分析中导致不可预测的结果。</li><li id="015f" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj">科维亚特科夫斯基-菲利普斯-施密特-申</strong> ( <a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/kpss-test/" rel="noopener ugc nofollow" target="_blank"> KPSS </a>):测试判断一个<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/timeplot/" rel="noopener ugc nofollow" target="_blank">时间序列</a>围绕一个<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/mean/" rel="noopener ugc nofollow" target="_blank">均值</a>或线性<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/trend-analysis/" rel="noopener ugc nofollow" target="_blank">趋势</a>是否为<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/stationarity/" rel="noopener ugc nofollow" target="_blank">平稳</a>，或者由于一个<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/unit-root/" rel="noopener ugc nofollow" target="_blank">单位根</a>而非平稳。</li><li id="90b6" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj">菲利普斯-佩伦检验</strong> ( <a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/unit-root/" rel="noopener ugc nofollow" target="_blank"> PP </a> ) <strong class="ih hj"> : </strong>是一种单位根检验，它是迪基-富勒检验的一种改进，修正了误差中的<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/serial-correlation-autocorrelation/" rel="noopener ugc nofollow" target="_blank">自相关</a>和<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/heteroscedasticity-simple-definition-examples/" rel="noopener ugc nofollow" target="_blank">异方差</a></li></ul><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="0b41" class="ld jw hi kz b fi le lf l lg lh">#Number of differences required for a stationary series<br/>from pmdarima.arima.utils import ndiffs<br/>y=series<br/># augmented Dickey–Fuller test (adf test)<br/>print("ADF Test: ",ndiffs(y, test='adf'))<br/># Kwiatkowski–Phillips–Schmidt–Shin (KPSS) test<br/>print("KPSS Test: ",ndiffs(y, test='kpss'))<br/># Phillips–Perron (PP) test:<br/>print("PP Test: ",ndiffs(y, test='pp'))</span></pre><p id="93a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">三个测试输出为1，这只是为了确保选择差值<strong class="ih hj"> d=1 </strong>的顺序的决定是最正确的。</p><h1 id="4ed0" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">自回归项P的阶</h1><p id="9b9c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">下一步是确定模型是否需要AR术语。为了找出所需的AR项数，我们需要检查偏自相关(PACF)图:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="c157" class="ld jw hi kz b fi le lf l lg lh">plt.rcParams.update({'figure.figsize':(12,3), 'figure.dpi':120})<br/>from statsmodels.graphics.tsaplots import plot_pacf<br/>fig, axes = plt.subplots(1, 2, sharex=True)<br/>plot_pacf(daily_series_diff1, lags=10, ax=axes[0], title="Partial Autocorrelation 1st Order Differencing")<br/>plot_pacf(daily_series_diff2, lags=10, ax=axes[1], title="Partial Autocorrelation 2nd Order Differencing")<br/>plt.xlabel('Lag')<br/>plt.ylabel('PACF')<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/3b3eb1dd73bf123f22987ce4eca5adb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HyS_OFUdjdu3bLSxXmV8A.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">一阶和二阶差分自相关</figcaption></figure><p id="b2bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PACF是序列与其滞后之间的相关性，在排除中间滞后的贡献之后。所以，PACF在某种程度上传达了滞后和系列之间的纯粹相关性。这样，我们就能知道AR项目中是否需要这种滞后。如果我们考虑一阶差分p=0 <strong class="ih hj"> </strong>或二阶差分后的PACF，那么<strong class="ih hj"> p=1 </strong>。</p><h1 id="6d86" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">求移动平均项q的阶</h1><p id="fd93" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">就像我们看PACF图中AR项的数量一样，我们也可以看ACF图中MA项的数量。MA术语在技术上是滞后预测的误差。</p><p id="33c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ACF告诉我们需要多少MA项来消除平稳序列中的任何自相关。</p><p id="09d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果自相关对于许多滞后(10或更多)是正的，那么序列需要进一步差分。另一方面，如果滞后1自相关本身太负，那么序列可能是过差的。我做了两个区别，让我们看看下面的自相关性:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="3db9" class="ld jw hi kz b fi le lf l lg lh">plt.rcParams.update({'figure.figsize':(12,3), 'figure.dpi':120})<br/>from statsmodels.graphics.tsaplots import plot_acf<br/>fig, axes = plt.subplots(1, 2, sharex=True)<br/>plot_acf(daily_series_diff1, lags=20, ax=axes[0], title="Autocorrelation 1st Order Differencing")<br/>plot_acf(daily_series_diff2, lags=20, ax=axes[1], title="Autocorrelation 1st Order Differencing")<br/>plt.xlabel('Lag')<br/>plt.ylabel('ACF')<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/146db4a09aacaca3f4e6dea0ed647ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWI1IeWHs1tgQBhYQGVDXQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">自相关一阶和二阶差分</figcaption></figure><p id="1579" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于一阶差分，q=0。在第二次差分中，只有一个滞后远远高于显著性线。所以，让我们把<strong class="ih hj"> q设为1 </strong>。这是测试后决定的。所以三个参数(p，d，q)是(1，0，1)</p><p id="08a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也可以通过测量评估每个模型质量的赤池信息标准(<strong class="ih hj"> AIC </strong>)来随机拟合模型的不同参数值，以查看最佳拟合值:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="c064" class="ld jw hi kz b fi le lf l lg lh">import pmdarima as pm<br/>model = pm.auto_arima(series, start_p=1, start_q=1,<br/>                      test='adf',       # use adftest to find optimal 'd'<br/>                      max_p=3, max_q=3, # maximum p and q<br/>                      m=1,              # frequency of series<br/>                      d=None,           # let model determine 'd'<br/>                      seasonal=False,   # No Seasonality<br/>                      start_P=0, <br/>                      D=0, <br/>                      trace=True,<br/>                      error_action='ignore',  <br/>                      suppress_warnings=True, <br/>                      stepwise=True)</span><span id="3cbd" class="ld jw hi kz b fi mc lf l lg lh">print(model.summary())</span></pre><p id="1b01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以模型的最终形状是:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="3842" class="ld jw hi kz b fi le lf l lg lh">from statsmodels.tsa.arima_model import ARIMA<br/>model = ARIMA(series, order=(1, 0, 1)).fit(transparams=False)<br/>print(model.summary())</span></pre><p id="cf57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们注意到P&gt;|z|合理地小于0.05。现在，让我们预测布伦特原油价格开始= ' 2019年1月1日'，结束= ' 2019年9月30日'</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="a685" class="ld jw hi kz b fi le lf l lg lh">ARIMA_Predict = model.predict(start='1/1/2019', end='9/30/2019')</span></pre><h1 id="73b9" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">先知模型</h1><p id="4310" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">Prophet是脸书开发的一种工具，用于对具有线性或非线性增长的多重季节性的时间序列数据进行高质量的预测。</p><h1 id="11fd" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">Prophet如何工作的简要概述</h1><p id="0e1a" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">就其核心而言，Prophet是一个附加模型，包含以下组件:</p><p id="f94f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">T9)y(<em class="ju">t</em>)=<em class="ju">g</em>(<em class="ju">t</em>)+<em class="ju">s</em>(<em class="ju">t</em>)+<em class="ju">h</em>(<em class="ju">t</em>)+<em class="ju">ϵₜ</em></strong></p><ul class=""><li id="e538" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><em class="ju"> g </em> ( <em class="ju"> t </em>)模型趋势，描述数据的长期增减。Prophet结合了两个趋势模型，一个饱和增长模型和一个分段线性模型，这取决于预测问题的类型。</li><li id="e14d" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><em class="ju"> s </em></li><li id="85e8" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><em class="ju"> h </em> ( <em class="ju"> t </em>)对影响商业时间序列的节假日或大型事件(例如新产品发布、黑色星期五、超级碗等)的影响进行建模。)</li><li id="875a" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><em class="ju"> ϵₜ </em>代表不可约的误差项</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es md"><img src="../Images/b1a970c02f71f1eb7f3e15f08500e5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ERtY2Y_4qRGoNNd9.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">脸书先知模型</figcaption></figure><p id="a702" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">全面的预言家细节可以在论文<a class="ae jt" href="https://peerj.com/preprints/3190/" rel="noopener ugc nofollow" target="_blank">中以比例</a>预测。现在让我们导入并训练prophet模型:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="5901" class="ld jw hi kz b fi le lf l lg lh">from fbprophet import Prophet<br/>d={'ds':train['date'],'y':train['price']}<br/>df_pred=pd.DataFrame(data=d)<br/>model = Prophet(daily_seasonality=False)<br/>model.fit(df_pred)</span></pre><p id="6050" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们预测一下从2019年1月1日到2019年9月30日，273天的未来油价。</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="21fe" class="ld jw hi kz b fi le lf l lg lh">future = model.make_future_dataframe(periods=273)<br/>forecast = model.predict(future)<br/>plt.figure(figsize=(18, 6))<br/>model.plot(forecast, xlabel = 'Date', ylabel = 'Price')<br/>plt.title('Brent Oil Price Prediction');</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es me"><img src="../Images/691db692b2285793d0ffbecaf98fe373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmSD3uKI8SJ6cF0Hx0E0ag.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">使用Prophet模型训练和预测时间序列</figcaption></figure><p id="41c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们仅以2019年为例:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="ffbc" class="ld jw hi kz b fi le lf l lg lh">forecast2019 = forecast[(forecast['ds' ] &gt;= '2019-01-01') &amp; (forecast['ds' ] &lt;= '2019-09-30')]</span></pre><h1 id="4c25" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">估价</h1><p id="24e7" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">由于我们已经使用了ARIMA模型和预言家模型来预测未来的石油价格，所以让我们研究一下这两个模型的预测价格和实际价格，然后评估结果:</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="9edc" class="ld jw hi kz b fi le lf l lg lh">fig, ax = plt.subplots()<br/>ax.plot(forecast2019['ds'], ARIMA_Predict, label='Predicted Prices')<br/>ax.plot(test['date'], test['price'], label='Original Prices')<br/>plt.ylim([0,100])<br/>legend = ax.legend(loc='upper center', shadow=True)<br/>plt.title('ARIMA Model Brent Oil Prices Forecast 2019')<br/>plt.xlabel('Month')<br/>plt.ylabel('Price')<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/dae2b73c7d0277b0dbd41990334b483e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G750RaH0Cx6OGuWKUbShqQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">2019年ARIMA模型布伦特油价预测</figcaption></figure><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="1ca4" class="ld jw hi kz b fi le lf l lg lh">fig, ax = plt.subplots()<br/>ax.plot(forecast2019['ds'], forecast2019['yhat'], label='Predicted Prices')<br/>ax.plot(test['date'], test['price'], label='Original Prices')<br/>plt.ylim([0,100])<br/>legend = ax.legend(loc='upper center', shadow=True)<br/>plt.title('Prophet Model Brent Oil Prices Forecast 2019')<br/>plt.xlabel('Month')<br/>plt.ylabel('Price')<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/983c9125c73bf1f8b3e982ab06fa3088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bicrBhncnHsEYRe0pfZ3hg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">预言家模型布伦特油价预测2019</figcaption></figure><p id="7826" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">初步观察表明，用Prophet预测的价格比实际价格高一点，而在ARIMA，预测的价格较低，但两个模型预测的价格都与实际价格有些接近，让我们深入研究一下误差度量。</p><p id="1769" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">平均绝对误差(MAE): </strong> MAE测量一组预测中误差的平均大小，不考虑它们的方向。MAE是每个点和身份线之间的平均垂直和水平距离。将预测值和观察值之间的绝对差异相加，然后计算平均值，其中所有个体差异具有相同的权重。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mg"><img src="../Images/e95c2b92b221eeb320817f248f64b687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*oWzA3_CB5bWB0Rb42RX2vA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">MAE:平均绝对误差(n:集合长度，I:计数器)</figcaption></figure><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="edd5" class="ld jw hi kz b fi le lf l lg lh">from sklearn.metrics import mean_absolute_error<br/>maeARIMA=mean_absolute_error(test['price'],ARIMA_Predict)<br/>maeProphet=mean_absolute_error(test['price'],forecast2019['yhat'])<br/>print('Mean Absolute Error ARIMA = {}'.format(round(maeARIMA, 2)))<br/>print('Mean Absolute Error Prophet = {}'.format(round(maeProphet, 2)))</span></pre><p id="ef8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ARIMA的平均绝对误差为【12.23】</strong>；而<strong class="ih hj">预言者的平均绝对误差为【7.24】</strong></p><p id="016e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">均方误差(MSE) </strong> : MSE是一个二次评分规则，也测量误差的平均大小。它是预测值和观测值之间的平均平方差的平方根。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mh"><img src="../Images/8de672b96b3d3f7d64566552dbfd17a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*kTuihHazJDjn8FHpRju4VA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">MSE:均方误差(n:集合的长度，I:计数器)</figcaption></figure><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="86b7" class="ld jw hi kz b fi le lf l lg lh">mseProphet = mean_squared_error(test['price'],forecast2019['yhat'])<br/>mseARIMA = mean_squared_error(test['price'],ARIMA_Predict)<br/>print('The Mean Squared Error of ARIMA forecasts is {}'.format(round(mseARIMA, 2)))<br/>print('The Mean Squared Error of Prophet forecasts is {}'.format(round(mseProphet, 2)))</span></pre><p id="a453" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ARIMA预测的均方误差为【172.32】</strong>，而先知模型的均方误差为<strong class="ih hj">【72.04】。我对MAE和MSE之间的差异的观察是，预测值和观察值之间的差异在平均之前是平方的，因此如果预测值和观察值之间的差异的绝对值大于1，MSE将显示比MAE更高的误差，而如果差异的绝对值小于1，MSE将小于MAE。MSE是一个风险函数，对应于平方误差损失的期望值。在我的演示评估中，我使用了这两种方法。</strong></p><p id="0568" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">均方根误差</strong><a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/rmse/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">(RMSE</strong></a><strong class="ih hj">)</strong>:一种预测误差度量，它取MSE的根，因为它度量的是<a class="ae jt" href="https://www.statisticshowto.datasciencecentral.com/residual/" rel="noopener ugc nofollow" target="_blank">残差的标准偏差</a>(残差是数据点和回归线之间的垂直距离)，更多细节可以在<a class="ae jt" rel="noopener" href="/human-in-a-machine-world/mae-and-rmse-which-metric-is-better-e60ac3bde13d">本文</a>中找到。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mi"><img src="../Images/07da6c9b770bd9e2116a1ceddef05fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*tMH05M6Esyeg05sh4Q3lDQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">RMSE:均方根误差(n:集合的长度，I:计数器)</figcaption></figure><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="60be" class="ld jw hi kz b fi le lf l lg lh">rmseProphet = sqrt(mseProphet)<br/>rmseARIMA = sqrt(mseARIMA)<br/>print('The Root Mean Squared Error of ARIMA forecasts is {}'.format(round(rmseARIMA, 2)))<br/>print('The Root Mean Squared Error of Prophet forecasts is {}'.format(round(rmseProphet, 2)))</span></pre><p id="694f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ARIMA预测的均方根误差为【13.13】</strong>，<strong class="ih hj">预言者的均方根误差为【8.49】</strong></p><h1 id="30a6" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><p id="7d1c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">本文旨在探讨时间序列预测在未来油价预测中的应用。尽管油价因多种因素而波动，但ARIMA模型和预言家模型的预测价格与实际价格相差不远。在这个实验中，Prophet模型比ARIMA模型的精确度略高。</p></div></div>    
</body>
</html>