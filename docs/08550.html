<html>
<head>
<title>Multi-namespace Helm deploy in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes中部署多名称空间Helm</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/multi-namespace-helm-deploy-in-kubernetes-26d1baf1ca5c?source=collection_archive---------11-----------------------#2020-08-03">https://medium.com/analytics-vidhya/multi-namespace-helm-deploy-in-kubernetes-26d1baf1ca5c?source=collection_archive---------11-----------------------#2020-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/2fde948060898c95b48728cd8048bef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*Lz14y_N5ZiEbP3VArRQ9_g.png"/></div></figure><h2 id="332c" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">一些背景</h2><p id="61d1" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated">我在网站可靠性方面的生活可以被描述为建筑自动化、反应式解决问题以及在slack频道上发布“让我为你谷歌一下”链接的完美组合。其中一个主题是弄清楚我们如何根据客户需求进行扩展。目前，在<a class="ae kf" href="http://logicmonitor.com/" rel="noopener ugc nofollow" target="_blank"> LogicMonitor </a>，我们正在运行一个混合环境，在这个环境中，我们的核心应用程序和时序数据库都运行在物理数据中心的服务器上。这些环境与AWS中运行的微服务交互。我们称其中一个混合生产环境为“pod”(事后来看，在我们介绍了<a class="ae kf" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>之后，这是一个糟糕的名称选择)。我们使用亚特兰蒂斯产品竹为CI/CD。</p><p id="77c1" class="pw-post-body-paragraph jk jl hi jm b jn kg jp jq jr kh jt ju ix ki jw jx jb kj jz ka jf kk kc kd ke hb bi translated">在过去的一年半时间里，该团队完成了一项艰巨但令人满意的任务，即将ECS和EC2实例上的所有应用程序转换成Kubernetes中的pod，每个生产“pod”都被视为一个<a class="ae kf" rel="noopener" href="/binbash-inc/when-and-why-use-multiple-k8s-namespaces-237b632bac5">名称空间</a>。</p><h2 id="0ab2" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">部署到k8s </strong></h2><p id="22cc" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated">我们的部署过程是从竹子内部使用头盔。构建的每个应用程序都会产生一个helm chart工件和一个docker图像。部署后，映像被推送到私有docker存储库，并运行helm install命令和相应的图表。然而，由于每个生产环境都被视为一个Kubernetes名称空间，我们需要在每个集群上部署多个名称空间，这是通过为每个名称空间、每个应用程序制定一个<em class="kl">单独的</em> Bamboo部署计划<strong class="jm hj">来设置的。</strong>截至今天，我们有50个不同的生产环境和8个微服务(对于数学天才来说，这是400个单独的部署计划)。有时，仅仅对于一个应用程序点版本，开发人员可能要花一两个小时来部署和验证所有的产品。</p><h2 id="06f7" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">构建新工具</strong></h2><p id="6798" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated">因此，这是无法回避的…如果我们想要有效地扩展基础架构，我们需要找到一种更智能的部署方式。目前，我们使用各种shell脚本来启动部署过程。为了构建新工具，它需要:</p><ul class=""><li id="a8c2" class="km kn hi jm b jn kg jr kh ix ko jb kp jf kq ke kr ks kt ku bi translated">能够查询并列出所有生产命名空间</li><li id="3edb" class="km kn hi jm b jn kv jr kw ix kx jb ky jf kz ke kr ks kt ku bi translated">集成helm/kubernetes库</li><li id="205a" class="km kn hi jm b jn kv jr kw ix kx jb ky jf kz ke kr ks kt ku bi translated">一次部署到多个名称空间。</li><li id="b307" class="km kn hi jm b jn kv jr kw ix kx jb ky jf kz ke kr ks kt ku bi translated">部署进度的集中日志</li></ul><h2 id="3c9d" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">介绍k8s部署</strong></h2><p id="4125" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated"><a class="ae kf" href="https://github.com/pyang55/k8sdeploy" rel="noopener ugc nofollow" target="_blank"> k8sdeploy </a>是一个基于go的工具，目标是创建一个cli，利用helm和kubernetes客户端库一次部署到多个名称空间。</p><p id="ab8f" class="pw-post-body-paragraph jk jl hi jm b jn kg jp jq jr kh jt ju ix ki jw jx jb kj jz ka jf kk kc kd ke hb bi translated"><strong class="jm hj">初始化:<br/> </strong>这样就创建了Helm客户端和Kubernetes客户端<strong class="jm hj">。</strong>下面是helmv2的当前示例。helm3的巨大变化允许helm直接通过kubeconfig与k8s api服务器直接通信。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="467f" class="im in hi lf b fi lj lk l ll lm">// GetKubeClient generates a k8s client based on kubeconfig<br/>func GetKubeClient(kubeconfig string) (*kubernetes.Clientset, error) {<br/> config, err := clientcmd.BuildConfigFromFlags("", kubeconfig) <br/> if err != nil {  <br/>   panic(err.Error()) <br/> }  <br/> return kubernetes.NewForConfig(config)<br/>}</span><span id="0f2a" class="im in hi lf b fi ln lk l ll lm">//GetHelmClientv2 creates helm2 client based on kubeconfig<br/>func GetHelmClientv2(kubeconfig string) *helm.Client {<br/> config, _ := clientcmd.BuildConfigFromFlags(“”, kubeconfig)<br/> client, _ := kubernetes.NewForConfig(config)</span><span id="1d86" class="im in hi lf b fi ln lk l ll lm">// port forward tiller (specific to helm2)<br/> tillerTunnel, _ := portforwarder.New(“kube-system”, client, config)</span><span id="d886" class="im in hi lf b fi ln lk l ll lm">// new helm client<br/> host := fmt.Sprintf(“127.0.0.1:%d”, tillerTunnel.Local)<br/> helmClient := helm.NewClient(helm.Host(host))<br/> return helmClient<br/>}</span></pre><p id="94f4" class="pw-post-body-paragraph jk jl hi jm b jn kg jp jq jr kh jt ju ix ki jw jx jb kj jz ka jf kk kc kd ke hb bi translated"><strong class="jm hj">共享通知器:<br/> </strong>工具创建客户端后，初始化一个部署观察器。这是一个<a class="ae kf" href="https://gianarb.it/blog/kubernetes-shared-informer" rel="noopener ugc nofollow" target="_blank">共享通知器</a>，它监视Kubernetes对象当前状态的变化。在我们的例子中，在部署时，我们将创建一个<a class="ae kf" href="https://tour.golang.org/concurrency/2" rel="noopener ugc nofollow" target="_blank">通道</a>来启动和停止ReplicaSet资源的共享通知程序。这里的目标不仅是记录部署状态(“2个更新副本中的1个可用”)，而且整理一个流中的所有信息，这在一次部署到多个名称空间时是至关重要的。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="9ddf" class="im in hi lf b fi lj lk l ll lm">factory := informers.NewSharedInformerFactory(clientset, 0)<br/>//set informer to listen to pod resources<br/>informer := factory.Core().V1().ReplicaSets().Informer()</span><span id="d407" class="im in hi lf b fi ln lk l ll lm">stopper := make(<strong class="lf hj">chan</strong> <strong class="lf hj">struct</strong>{}) <br/><strong class="lf hj">defer</strong> close(stopper)</span><span id="fc2a" class="im in hi lf b fi ln lk l ll lm">// informer catches events when replicaSets are added or updated<br/>informer.AddEventHandler(cache.ResourceEventHandlerFuncs{<br/>   AddFunc:    <strong class="lf hj">func</strong>(obj <strong class="lf hj">interface</strong>{}) { <br/>     panic("not implemented") <br/>   },<br/>   UpdateFunc: <strong class="lf hj">func</strong>(<strong class="lf hj">interface</strong>{}, <strong class="lf hj">interface</strong>{}) { <br/>     panic("not implemented") <br/>   },<br/>})</span><span id="ad8f" class="im in hi lf b fi ln lk l ll lm"><strong class="lf hj">go</strong> informer.Run(stopper)</span></pre><p id="cd57" class="pw-post-body-paragraph jk jl hi jm b jn kg jp jq jr kh jt ju ix ki jw jx jb kj jz ka jf kk kc kd ke hb bi translated"><strong class="jm hj">使用Helm <br/> </strong>安装图表在初始化我们的deployWatcher之后，该工具使用<a class="ae kf" href="http://helm.sh/helm/v3" rel="noopener ugc nofollow" target="_blank"> helm libraries </a>使用图表初始化安装/更新部署。下面是一个使用helm2更新现有部署的示例。<a class="ae kf" href="https://stackoverflow.com/questions/45692719/samples-on-kubernetes-helm-golang-client" rel="noopener ugc nofollow" target="_blank">这里的</a>是helm3的一个</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="ebbf" class="im in hi lf b fi lj lk l ll lm">resp, _ := helmClient.ReleaseStatus(deployName)<br/>resp.GetInfo().GetStatus().GetCode().String() == "DEPLOYED" {<br/>  fmt.Printf("Found existing deployment for %s...updating\n", deployName)<br/>   helmClient.UpdateReleaseFromChart(deployName, chart)<br/>}</span></pre><p id="8da8" class="pw-post-body-paragraph jk jl hi jm b jn kg jp jq jr kh jt ju ix ki jw jx jb kj jz ka jf kk kc kd ke hb bi translated"><strong class="jm hj">定义成功<br/> </strong>添加了多项检查以确保新部署被视为成功。我们指定我们的舵图表在部署期间更新部署时间，以便告诉通知者只记录新事件。该工具还检查“准备好的副本”和“想要的副本”是否匹配，并确保在多个用户部署不同应用程序的情况下，informer不会拾取其他事件。该工具将所有成功的部署添加到一个表中</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="89e0" class="im in hi lf b fi lj lk l ll lm">build	29-Jul-2020 19:23:20	Starting deployment in namespace=name-space-1 for app=customapp at 2020-07-29 19:23:20 -0700 PDT<br/>build	29-Jul-2020 19:23:20	Waiting for deployment  rollout to finish: 0 of 2 updated replicas are available...<br/>build	29-Jul-2020 19:23:20	Waiting for deployment  rollout to finish: 0 of 2 updated replicas are available...<br/>build	29-Jul-2020 19:23:20	Starting deployment in namespace=name-space-2 for app=customapp at 2020-07-29 19:23:20 -0700 PDT<br/>build	29-Jul-2020 19:23:20	Waiting for deployment  rollout to finish: 0 of 2 updated replicas are available...<br/>build	29-Jul-2020 19:23:35	Waiting for deployment  rollout to finish: 1 of 2 updated replicas are available...<br/>build	29-Jul-2020 19:23:35	Waiting for deployment  rollout to finish: 1 of 2 updated replicas are available...<br/>build	29-Jul-2020 19:23:49	Waiting for deployment  rollout to finish: 1 of 2 updated replicas are available...<br/>build	29-Jul-2020 19:23:56	Waiting for deployment  rollout to finish: 2 of 2 updated replicas are available...<br/>build	29-Jul-2020 19:23:56	Successful Deployment of customapp on name-space-2<br/>build	29-Jul-2020 19:23:58	Waiting for deployment  rollout to finish: 2 of 2 updated replicas are available...<br/>build	29-Jul-2020 19:23:58	Successful Deployment of customapp on name-space-2<br/>build	29-Jul-2020 19:24:10	All deployments finished, sutting down watcher gracefully<br/>build	29-Jul-2020 19:24:10	+----------------+--------------+---------+<br/>build	29-Jul-2020 19:24:10	| APP            | NAMESPACE    | STATUS  |<br/>build	29-Jul-2020 19:24:10	+----------------+--------------+---------+<br/>build	29-Jul-2020 19:24:10	| customapp      | name-space-1 | Success |<br/>build	29-Jul-2020 19:24:10	| customapp      | name-space-2 | Success |<br/>build	29-Jul-2020 19:24:10	+----------------+--------------+---------+</span></pre><p id="ce07" class="pw-post-body-paragraph jk jl hi jm b jn kg jp jq jr kh jt ju ix ki jw jx jb kj jz ka jf kk kc kd ke hb bi translated"><strong class="jm hj">将所有这些放在一起<br/> </strong>此时，该工具已经为一个名称空间创建了片段。使用<a class="ae kf" href="https://gobyexample.com/goroutines" rel="noopener ugc nofollow" target="_blank"> go例程</a>来并行化部署调用可以很快缓解这一问题。我们使用<a class="ae kf" href="https://github.com/spf13/cobra" rel="noopener ugc nofollow" target="_blank"> Cobra </a>创建了一个cli，用户可以在其中输入逗号分隔的名称空间。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="93ed" class="im in hi lf b fi lj lk l ll lm">k8sdeploy deploy kubeconfig --configpath &lt;full-path-to-kubeconfig&gt; --releasename &lt;name-of-release&gt; --namespace &lt;namespace1,namespace2,namespace3&gt; --chartdir &lt;full-path-to-tgz-chart-file&gt; --set &lt;set-string-values&gt;</span></pre><h2 id="0249" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">让我们开源吧</h2><p id="7b93" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated">目前，该工具与helm3兼容。我在这里提供它供使用和公众批评<a class="ae kf" href="https://github.com/pyang55/k8sdeploy" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>