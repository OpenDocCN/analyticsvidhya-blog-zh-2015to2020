<html>
<head>
<title>Class-Based Views in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django中基于类的视图</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/class-based-views-in-django-39f826be2360?source=collection_archive---------22-----------------------#2020-03-08">https://medium.com/analytics-vidhya/class-based-views-in-django-39f826be2360?source=collection_archive---------22-----------------------#2020-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/4fae1207e68de9dc02695cbcd2dc667c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SeFIhVY22UYjgm0HL_q47w.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><a class="ae iq" href="https://www.codementor.io/@jamesezechukwu/working-with-class-based-views-in-django-5zkjnrvwc" rel="noopener ugc nofollow" target="_blank"> Codementor.io </a></figcaption></figure><p id="41d2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在Django中开发一个web应用程序让我们可以使用一个健壮的框架，这个框架具有许多特性，旨在使编程更加高效和直观。其中一个特性是基于类的视图。基于类的视图是从Django框架中的视图类扩展而来的Python对象。这些对象以其灵活性和可重用性而闻名(想想面向对象的编程)。但是，文档警告说，它们不能代替基于函数的视图，但是可以在特定的情况下为您所用。</p><blockquote class="jp jq jr"><p id="ca06" class="ir is js it b iu iv iw ix iy iz ja jb jt jd je jf ju jh ji jj jv jl jm jn jo hb bi translated">其核心是，基于类的视图允许您使用不同的类实例方法来响应不同的HTTP请求方法，而不是在单个视图函数内使用有条件的分支代码—基于类的视图简介</p></blockquote><p id="8834" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">每个Django视图都接受一个HTTP请求并返回一个HTTP响应。基于类的视图的一个主要好处是，您可以轻松地定义如何响应不同的HTTP方法，而无需输入繁琐的条件。看看这个来自<a class="ae iq" href="https://docs.djangoproject.com/en/3.0/topics/class-based-views/intro/" rel="noopener ugc nofollow" target="_blank">的基于类的视图介绍</a>的例子。</p><p id="b871" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这段代码利用基于函数的视图在返回正确的HTTP响应之前检查HTTP方法是否是“GET”。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="1e87" class="kf kg hi kb b fi kh ki l kj kk"><strong class="kb hj">from</strong> <strong class="kb hj">django.http</strong> <strong class="kb hj">import</strong> HttpResponse<br/><br/><strong class="kb hj">def</strong> my_view(request):<br/>    <strong class="kb hj">if</strong> request.method == 'GET':<br/>        <em class="js"># &lt;view logic&gt;</em><br/>        <strong class="kb hj">return</strong> HttpResponse('result')</span></pre><p id="1ceb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">当我们用基于类的视图替换上面的函数时，我们可以直接使用get作为to类中的方法来接受请求并返回正确的响应，而不必使用任何条件语句。这是Django如何解决基于函数的视图的一些缺点的一个例子。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="b529" class="kf kg hi kb b fi kh ki l kj kk"><strong class="kb hj">from</strong> <strong class="kb hj">django.http</strong> <strong class="kb hj">import</strong> HttpResponse<br/><strong class="kb hj">from</strong> <strong class="kb hj">django.views</strong> <strong class="kb hj">import</strong> View<br/><br/><strong class="kb hj">class</strong> <strong class="kb hj">MyView</strong>(View):<br/>    <strong class="kb hj">def</strong> get(self, request):<br/>        <em class="js"># &lt;view logic&gt;</em><br/>        <strong class="kb hj">return</strong> HttpResponse('result')</span></pre><p id="d507" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">基于类的视图的另一个重要好处是类继承。我们可以创建子类来访问父类的属性和方法。当我们扩展我们的web应用程序时，这促进了干代码和可重用性。</p><p id="9bfc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">学习Django中基于类的视图的一个真正有趣的部分是利用<em class="js">通用的基于类的视图</em> <strong class="it hj"> <em class="js">。</em> </strong>通用的基于类的视图被构建到通用用例的框架中，例如查看对象列表或该对象的特定实例。不同的通用视图从父类继承了很多功能，所以解释发生了什么的代码行更少。程序员发现这个警告既方便又令人困惑，所以在实现一个通用的基于类的视图时参考文档是一个好习惯。<a class="ae iq" href="https://ccbv.co.uk/" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个小备忘单，以防文档难以理解。</p><p id="89cd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">要访问通用的基于类的视图，您必须首先从Django导入模块，如下所示。例如，假设我们想要创建一种管理医院记录的方法，并且需要显示病人就诊的列表。我们可以导入通用的ListView类，并根据我们的模型轻松地使用它来请求和返回单个患者记录的列表。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="5312" class="kf kg hi kb b fi kh ki l kj kk">from django.shortcuts import render<br/>from django.views.generic.list import ListView</span><span id="4658" class="kf kg hi kb b fi kl ki l kj kk">class RecordsListView(ListView):    <br/>""" Renders a list of all Pages. """    <br/>  model = Record</span><span id="ea5e" class="kf kg hi kb b fi kl ki l kj kk">  def get(self, request):        <br/>""" GET a list of Pages. """        <br/>    records = self.get_queryset().all()        <br/>    return render(request, 'records/records_list.html', <br/>    {'records': records})</span></pre><p id="8248" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果我们需要查看每个患者记录中包含的信息，该怎么办？Django还提供了一个通用的DetailView类，可以轻松地访问模型的各个实例。您可以指定要呈现的字段以及要使用的唯一标识符。举一个基本的例子，我通过主键返回了单个记录，并且只用了<strong class="it hj">两行</strong>代码！</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="5580" class="kf kg hi kb b fi kh ki l kj kk">from django.views.generic.detail import DetailView</span><span id="97e5" class="kf kg hi kb b fi kl ki l kj kk">class RecordsDetailView(DetailView):    <br/>""" Renders a specific page based on it's pk."""    <br/>  model = Record</span></pre><p id="7ab2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">决定是使用基于类的视图还是传统的基于函数的视图最终取决于您的个人用例。使用基于类的视图的一些优点是可重用性、可扩展性、干代码和没有条件语句的HTTP请求。更难阅读和需要额外输入的事实是一些缺点。选择最能满足您需求的方法。</p><p id="d849" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">感谢您阅读这篇文章。如果你喜欢，给它一些掌声。👏查看下面的链接，了解Django中基于类的视图的更多信息！</p><h1 id="f46d" class="km kg hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">资源</h1><ul class=""><li id="3cba" class="lj lk hi it b iu ll iy lm jc ln jg lo jk lp jo lq lr ls lt bi translated"><a class="ae iq" href="https://make-school-courses.github.io/BEW-1.2-Authentication-and-Associations/#/Lessons/04-ViewsURLs" rel="noopener ugc nofollow" target="_blank">让学校BEW 1.2 </a></li><li id="d9b8" class="lj lk hi it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt bi translated"><a class="ae iq" rel="noopener" href="/@ksarthak4ever/django-class-based-views-vs-function-based-view-e74b47b2e41b"> Django:基于类的视图vs基于函数的视图</a></li><li id="c6b0" class="lj lk hi it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt bi translated"><a class="ae iq" href="https://django-advanced-training.readthedocs.io/en/latest/features/class-based-views/" rel="noopener ugc nofollow" target="_blank">基于类的视图</a></li><li id="3fd5" class="lj lk hi it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt bi translated">Django初学者完全指南—第6部分</li><li id="0fff" class="lj lk hi it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt bi translated"><a class="ae iq" href="https://docs.djangoproject.com/en/3.0/topics/class-based-views/intro/" rel="noopener ugc nofollow" target="_blank">基于类的视图介绍</a></li></ul></div></div>    
</body>
</html>