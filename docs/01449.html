<html>
<head>
<title>Building a Basic Vehicle Monitoring System using Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习构建基本的车辆监控系统</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-basic-vehicle-monitoring-system-using-machine-learning-and-computer-vision-d55ef2dd9893?source=collection_archive---------8-----------------------#2019-10-23">https://medium.com/analytics-vidhya/building-a-basic-vehicle-monitoring-system-using-machine-learning-and-computer-vision-d55ef2dd9893?source=collection_archive---------8-----------------------#2019-10-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a51149e85849bb839ce29ffa720989ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HNmNawdFoqpzgk6b"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@5tep5?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历山大·波波夫</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="0012" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">介绍</h1><p id="96ab" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">监控内部遥测数据和外部交通数据并叠加到单一系统中的建议系统。这更倾向于智能汽车的概念，该系统可以根据用途或需求有多个附加功能。该系统有两个主要组件:</p><p id="ba1a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">1.利用CAN总线进行遥测数据采集</p><p id="57bb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">2.从dash-cam feed监控和捕捉外部信息</p><p id="c250" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">然后将上述组件叠加到单个数据帧中，然后本地存储。一旦与云建立了连接，数据就会被转储。第一点是使用CAN总线和后台进程定期发布数据来解决的。该系统的第二部分包括在其核心的物体识别系统，其主要目的是检测以下内容。</p><p id="9e44" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">1.道路上的交通密度</p><p id="1d34" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">2.车辆行驶的道路类型</p><p id="b433" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">以上两个参数都是使用在IDD数据集上实现的对象识别来获得的。</p><p id="983e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">最终的主节点将这两段数据组合起来，并将其保存在本地。只有当互联网连接建立后，数据才会发布到云中。在本文中，我们将找出如何处理上述用例的每一部分。</p><h1 id="28d3" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">视觉处理系统(VPS):</h1><p id="e2bb" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">VPS负责核心的视频处理工作。VPS的核心是英特尔发布的OpenVINO toolkit，它可以进行推理。但是在推断之前，我们必须在特定的数据集上训练一个模型。</p><p id="3f4e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">VPS的总体流程如下所示。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/43bc97a4d025433627f912bed3365183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*edT13-aiu7xpW3CW.png"/></div></figure><p id="edb6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">VPS的流程</p><p id="d606" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">让我们来看看VPS的培训前景。</p><p id="f76f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">培训和测试(一次性流程):</strong></p><p id="fada" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">印度驾驶数据集用于训练主要有两个原因。</p><p id="7615" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">1.它完全基于印度的路况</p><p id="8ab8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">2.它具有可驱动和不可驱动对象的一些特征</p><p id="60e0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">数据集可在中的<a class="ae iu" href="https://idd.insaan.iiit.ac.in/" rel="noopener ugc nofollow" target="_blank"> https://idd.insaan.iiit.ac .上获得</a></p><p id="dd01" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们的应用程序依赖于移动车辆上的实时推理。这意味着我们需要速度而不是准确性。这就是为什么mobilenet ssd被用作我们的对象识别架构。作为训练和评估的管道，Tensorflow对象识别API也用于此目的。让我们来看一下所有相关的步骤。</p><p id="a088" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">预处理:</strong>基于可用的api，第一步是为整个数据集生成tfrecord文件。为了使示例代码适合我们的目录结构，我们做了一些修改来生成csv和tfrecord文件。</p><p id="fa20" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">训练:</strong>训练执行了大约50000个周期，最终的对数损失值在1.0-3.0之间振荡。然后从最终的检查点文件中获得冻结的推理图。</p><p id="58a8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">注意:本文不会深入讨论相关培训的技术细节。示例培训代码被更新到Github repo中。</strong></p><p id="61cb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">训练的结果是冻结的推理图文件、检查点文件、元数据文件和pipeline.config文件。</p><p id="3080" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">使用TensorFlow进行测试和推理:</strong></p><p id="0d3a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">使用TensorFlow对最终的冻结推理图进行推理，一些示例图像如下所示。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/e23b2ced760a8b0089fefb5299084b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*-dNklMxFtS9Mqslw.png"/></div></figure><p id="1d0d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">基于样本图像的张量流推理</p><p id="84b9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">一旦培训完成，使用Tensorflow完成测试，我们就可以使用英特尔发布的open vino toolkit进行优化和推理。</p><p id="53ca" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">从前面的过程中，我们获得了存储模型文件的标准文件夹。现在，我们必须使用英特尔发布的open vino toolkit优化模型，然后进行最终推断。优化将是一次性过程，而最终推理将是实时过程。</p><p id="6ffc" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">使用英特尔发布的open vino toolkit进行优化</strong></p><p id="432c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">模型优化是整个项目中重要的一步。英特尔发布的open vino toolkit具有一些内置功能来优化tensorflow模型。让我们来看看涉及的步骤。</p><p id="8567" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">先决条件:</strong></p><p id="a681" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">1.假设您的电脑上安装了英特尔发布的open vino toolkit。如果没有，请参考此处的<a class="ae iu" href="https://software.intel.com/en-us/openvino-toolkit" rel="noopener ugc nofollow" target="_blank">了解整个安装过程。</a></p><p id="8874" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">2.冻结的推理图以及pipeline.config文件。这是在训练和冻结你的模型后获得的。</p><p id="a28e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">安装open vino toolkit的英特尔发行版后，浏览到以下位置。</p><p id="779c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">注意:我在整个过程中使用的是Ubuntu系统</strong></p><p id="eb48" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">/opt/Intel/open vino/deployement _ tools/model _ optimizer</p><p id="e750" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在这个位置，我们有一个名为<strong class="jv hj"> mo_tf.py的python脚本。</strong>这个脚本将用于优化模型。为此，我们需要传递某些参数。</p><p id="207b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> 1。</strong><strong class="jv hj">–输入_模型:</strong>输入模型的路径。这里我们需要冻结的推理图。</p><p id="d893" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> 2。</strong><strong class="jv hj">–tensor flow _ use _ custom _ operations _ config:</strong>定制模型所需的配置文件。它附带了OpenVINO工具包，位于以下目录下。<br/>/opt/Intel/open vino/deployement _ tools/model _ optimizer/extensions/front/TF</p><p id="648a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> 3。</strong><strong class="jv hj">–tensor flow _ object _ detection _ API _ pipeline _ config:</strong>自定义模型冻结后生成的pip line . config文件。</p><p id="1037" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> 4。</strong> <strong class="jv hj"> -o: </strong>输出文件所在位置的路径。xml和。bin文件将被保存。</p><p id="7f4e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">优化过程完成后，我们得到了两个文件。。xml和。我们定制模型的框。这将用于推理过程。对于推理，我们将使用推理机。</p><p id="5300" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们将坚持使用python来实现推理引擎。在开始编写代码之前，让我们看一下我们将要使用的不同组件</p><p id="1577" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">推理引擎文档可在此处获得。推理引擎文档可在此处获得。</p><p id="5b5e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://docs.openvinotoolkit.org/latest/_docs_IE_DG_Deep_Learning_Inference_Engine_DevGuide.html?source=post_page-----a873a8bd38b9----------------------" rel="noopener ugc nofollow" target="_blank">https://docs . openvinotoolkit . org/latest/_ docs _ IE _ DG _ Deep _ Learning _ Inference _ Engine _ dev guide . html</a></p><h2 id="7e4c" class="lb iw hi bd ix lc ld le jb lf lg lh jf ke li lj jj ki lk ll jn km lm ln jr lo bi translated">使用英特尔发布的open vino toolkit和Python实现推理引擎</h2><p id="b9e0" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这一部分将集中在两个主要方面:</p><p id="02e9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">1.IE引擎的实现</p><p id="cc34" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">2.从VPS向主节点发送数据</p><p id="5e4c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">推理引擎是一个统一的API，允许在许多硬件类型上进行高性能推理，包括英特尔CPU、英特尔处理器显卡、英特尔FPGA、英特尔m ovidius Neural Compute Stick和英特尔Neural Compute Stick 2。</p><p id="79f1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">IE引擎的常见工作流程如下所述。</p><p id="515f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> 1。</strong> <strong class="jv hj">读取中间表示:</strong>这将加载IR文件(。xml和。bin ),它是在对象的优化阶段早期生成的。</p><p id="d975" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> 2。</strong> <strong class="jv hj">准备输入和输出格式:</strong>一旦加载，我们必须指定网络的输入和输出配置。</p><p id="bc29" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> 3。</strong> <strong class="jv hj">创建IE核心对象:</strong>这将创建一个IE核心对象，可用于不同的设备。插件将使用这个进行内部管理。</p><p id="48d8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> 4。</strong> <strong class="jv hj">编译并加载网络到设备:</strong>这一步就是简单的将网络加载到指定的设备。</p><p id="09ad" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> 5。</strong> <strong class="jv hj">设置输入数据:</strong>网络加载后，我们需要通知输入缓冲器加载输入和输出。</p><p id="6d59" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> 6。</strong> <strong class="jv hj">执行网络:</strong>网络现在需要执行。做这件事有两种方法。</p><p id="8bb5" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> a. </strong> <strong class="jv hj">同步:</strong>在单个时间点执行一个推理。</p><p id="59fa" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> b. </strong> <strong class="jv hj">异步:</strong>异步执行，检查状态，等待或指定完成回调。</p><p id="887d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> 7。</strong> <strong class="jv hj">获得输出:</strong>获得网络的输出</p><p id="855b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">注意:</strong>更多细节和API文档可从这里获得。</p><p id="bf65" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://docs.openvinotoolkit.org/latest/_docs_IE_DG_inference_engine_intro.html" rel="noopener ugc nofollow" target="_blank">https://docs . openvinotoolkit . org/latest/_ docs _ IE _ DG _ inference _ engine _ intro . html</a></p><p id="c150" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们来看看这到底是怎么实现的。</p><p id="749a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在下面的函数initialise _ inference()中，我们简单地用上面讨论的所有参数设置了推理引擎。</p><p id="37c0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">基于网络拓扑，我们必须定义输入和输出blobs。最后，我们调用处理器类，它确切地执行网络，如下所示。</p><p id="be98" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在上面的类中，最初我们执行网络，然后根据输出放置边界框。</p><p id="000f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">处理/执行发生在processframe函数上，而带有边界框和文本的图像叠加发生在placeBoxes函数上。</p><p id="cdda" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">总结整个类，github上的代码是detect.py文件。</p><p id="f4fa" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">接下来，我们需要一个驱动python脚本来驱动它，并处理摄像机输入和消息传输机制。让我们看一下回购中的脚本camera.py来了解一下同样的情况。</p><p id="3cb8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">名为VideoCamera的类是用非参数化的构造函数定义的。我们还使用配置文件config.json来初始化参数。</p><p id="0f4c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">包括提供摄像机输入或视频文件的选项，可以使用config.json文件进行修改。在构造函数中，我们还初始化了检测器类来初始化推理机。</p><p id="21dd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在函数get_frame()中，我们获取叠加的图像，并将生成的最终帧返回给app.py</p><p id="f048" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">总结一下脚本<strong class="jv hj"> camera.py </strong>，我们调用<strong class="jv hj"> detect.py </strong>用<strong class="jv hj"> config.json </strong>中定义的所有参数初始化并执行<strong class="jv hj">推理机</strong>，最终得到合成的叠加帧返回给<strong class="jv hj"> app.py. </strong></p><p id="c65f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">到目前为止，我们一直专注于视觉数据的处理，其中没有物联网组件。</p><p id="5039" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">有点混乱吧！放松和冷静，因为这是进入物联网的地方。</p><p id="3658" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">下面的视频展示了推理后的一些结果:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="c3ae" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">IE使用在IDD数据集上训练的Tensorflow对象检测API实现英特尔发布的OpenVINO工具包</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="c675" class="iv iw hi bd ix iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js bi translated">获取车辆遥测数据:</h1><p id="b253" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">车辆遥测数据可以通过一个称为OBD-2端口的特殊端口进行访问。OBD-2端口使用的协议是控制局域网或CAN。我们将使用一个微型硬件设备来访问数据。理想情况下，有两种类型的硬件。<br/> 1。BLE接口<br/> 2。USB接口<br/>在这种情况下，我们将使用BLE接口。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es md"><img src="../Images/312fca0976f04addb78157e870054f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/0*42x_pJfTL4ugAMxJ.png"/></div></figure><p id="9e4c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">图3: OBD-2设备ELM 327 IC</p><p id="508d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">该设备插入OBD-2端口。端口的位置因车辆而异。它通常位于方向盘下方2英尺以内。使用CAN协议进行数据交换。</p><p id="2e42" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们使用python脚本来获取数据。我们使用python-obd模块进行通信。</p><p id="d956" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://python-obd.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://python-obd.readthedocs.io/en/latest/</a></p><p id="5733" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在这种情况下，我们要考虑3个参数。<br/> 1。发动机转速<br/> 2。车速<br/> 3。发动机冷却液温度</p><p id="0503" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">然后，这些参数被发布到MQTT主题。让我们再次看看我们已经实现的MQTT架构。</p><p id="5df3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们使用本地托管的MQTT代理。在这种情况下，使用VerneMQ，</p><p id="5f4e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://docs.vernemq.com/?source=post_page-----a873a8bd38b9----------------------" rel="noopener ugc nofollow" target="_blank">https://docs.vernemq.com/</a></p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/db10b5a4846e259986c5ae613f45dcd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*V6xq2kdQGQsc57qI.png"/></div></figure><p id="05dd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">图4:实现的MQTT架构——数据流</p><p id="0288" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在上面的例子中，我们的python脚本getdata.py是第一个块，VerneMQ broker是第二个块，主节点是app.py python脚本。</p><p id="1d14" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在，让我们看看数据是如何获得的。</p><p id="1ebc" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://gist.github.com/avirup171/f9e3685b5a869f232929655782d94b3c" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/avirup 171/f9e 3685 b5 a 869 f 232929655782d 94 B3 c</a></p><p id="5d40" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们使用obd模块通过蓝牙和paho mqtt客户机与设备进行交互，以便与本地mqtt代理进行通信。另外，json用于形成json对象。</p><p id="3ff1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">最初，我们定义所有与MQTT和OBD相关的回调和方法。</p><p id="f3d3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在main函数中，我们声明回调并从mqtt_config.json文件中获取配置数据。</p><p id="27cf" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在上面的代码中，当连接成功时，on_connect被触发。如前所述，我们可以订阅MQTT主题，因此作为推荐过程，在on_connect方法中订阅是安全的，因为这将允许我们在连接重新建立时进行订阅。</p><p id="b61d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">以上，是OBD回调的实现。请注意，client.publish是如何插入其中一个方法的。这一行将数据传输到主节点或该节点，无论哪个节点订阅了主题。</p><p id="4b72" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">要执行上面的代码，你需要一辆实体车，插入OBD-2端口，并添加你的蓝牙设备作为RFCOMM。该地址需要输入到mqtt_config.json文件中。</p><p id="871b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">到目前为止，我们已经完成了以下任务。</p><p id="ad82" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">1.训练IDD数据集</p><p id="9413" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">2.已训练模型的优化</p><p id="f6d1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">3.实现推理引擎</p><p id="4539" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">4.实施物联网部分(OBD和MQTT)</p><p id="3ef0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在，我们将在主节点上工作，这是一个python flask应用程序，将所有内容放在一个框架下。让我们看看下面的图表来看看流程。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es me"><img src="../Images/0becbcf621fa0539cdf97b1da2751e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:60/0*-Vo4lQM_OegYq6sV"/></div></figure><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/edd9dfb6c36ca5c3e633ac7b62e22879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*I2UW7ahk6imYI1jr.png"/></div></figure><p id="9f17" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">图5:描述整个流程的流程图</p><p id="bf36" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">主节点只是将web应用程序中接收到的两组数据进行组合。我们不会详细讨论如何编写web应用程序的代码，但是下图显示了它是如何发生的。这里要注意的一点是，我们已经将代码库分成了多个子模块。这允许我们触发任何需要的节点。此外，这种技术可以用于几乎任何计算机视觉网络应用。只要确保正确处理所有参数。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/4779621b313daac93d408ac89e96ef47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*0-ccRx3RX2kwH8Bx.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图6:数据流</figcaption></figure><p id="68e9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">基于上面的图像，让我们看看代码，让事情更容易理解。</p><p id="a08b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们首先导入所有需要的依赖项。mqtt通信需要Flask_mqtt。实时更新数据需要Flask_socketio。</p><p id="7d3e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们从mqtt_config.json获取所有MQTT参数</p><p id="8f44" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这里，我们初始化不同的类。请注意参数。</p><p id="5617" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">上面定义了MQTT的回调。</p><p id="3791" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这里我们定义了应用程序的路径，在方法def gen(camera)中，我们从前面创建的camera对象中调用get_frame方法。这将在web应用程序上显示摄像机画面。我们还有一个html文件，在本例中是在index方法中调用的。html文件位于templates文件夹下。</p><p id="030b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">它是纯基本的html，带有使用jquery和javascript实现的socket.io。<strong class="jv hj"> app.py </strong>是主节点，我们只需运行这个脚本来获取可视提要。然而，负责从车辆获取遥测数据的getdata.py是完全独立的，它自己运行，需要事先触发。虽然可以从这个web应用程序调用它，但这不是本文的范围。运行代码后，我们得到了一个很好的raw，其中几乎没有显示视频馈送以及RPM和速度值的设计元素。</p><h1 id="c7ae" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论:</h1><p id="a7ae" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如果你已经通读了整篇文章，那太好了！！</p><p id="fb7e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们确实有一篇非常长的文章，展示了我们如何将包括计算机视觉和物联网在内的多个模块结合到一个平台中。</p><p id="26eb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">让我们回顾一下我们在这篇文章中学到了什么。</p><p id="f285" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">1.使用Tensorflow和英特尔发布的open vino toolkit进行训练和推理</p><p id="afd9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">a.训练IDD数据集</p><p id="54a9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">b.冻结模型文件</p><p id="52c0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">c.优化模型</p><p id="3ac9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">d.推理机的实现</p><p id="cb3f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">2.从车辆获取数据</p><p id="3da2" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">a.从车辆获取遥测数据</p><p id="ef4f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">b.使用本地托管的MQTT将数据作为json传递</p><p id="476d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">3.主网点</p><p id="0a51" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">a.获取图像帧</p><p id="8f07" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">b.通过订阅MQTT主题获取可用的遥测信息</p><p id="0ade" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">c.使用html页面显示所有内容</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">VAMS —第一次道路测试</figcaption></figure><p id="220d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">对背景音乐好奇的人，可以在这里找到。这很糟糕，但确实有用。</p><p id="f8fe" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://soundcloud.com/avirup-basu-833490551" rel="noopener ugc nofollow" target="_blank">https://soundcloud.com/avirup-basu-833490551</a></p><h1 id="91a4" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">未来工作:</h1><p id="88ea" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这个项目最重要的方面是让它尽可能地对消费者友好。理想情况下，只需轻触一个UI元素，整个应用程序就应该启动和配置，所有这些都应该使用移动应用程序来完成。正在努力使其更加方便用户。这里感兴趣的第二点是使用更多的数据点重新训练数据集。因为我没有时间进行更多的训练，但这肯定会提高成绩。最后的改进范围是执行一些真正的分析，以找出车辆是如何驾驶的。也就是说，另一篇关于在此基础上实现云的文章即将发表。</p><p id="91df" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个项目的一个更高级的版本正在制作中，被称为VAMS</p><p id="6f81" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">英特尔软件特色项目</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure></div></div>    
</body>
</html>