<html>
<head>
<title>Using Multiple Object Detection Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用多个对象检测模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/using-multiple-object-detection-models-e310c70e3a99?source=collection_archive---------15-----------------------#2020-03-04">https://medium.com/analytics-vidhya/using-multiple-object-detection-models-e310c70e3a99?source=collection_archive---------15-----------------------#2020-03-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4124" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在always AI中使用多个对象检测模型的快速指南</h2></div><p id="8c41" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我将演示如何轻松地修改alwaysAI提供的现有应用程序，以同时使用两个对象检测模型，并在并排的框架中显示输出。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/6375b8969134935a97cc51d34d3eb910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItYpo7uc3SocbIM9BPgPYA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">预期输出的示例:在这种情况下，两个检测模型都识别出两个瓶子，您可以在顶部图像框中看到第一个检测模型的绿色输出，在底部图像框中看到第二个检测模型的红色输出。</figcaption></figure><p id="97b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们开始之前，您需要:</p><ol class=""><li id="1545" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">一个<a class="ae ks" href="https://alwaysai.co/auth?register=true&amp;utm_campaign=Open%20Beta&amp;utm_source=medium&amp;utm_content=multiple-object-detectors" rel="noopener ugc nofollow" target="_blank"> alwaysAI账号</a>(免费！)</li><li id="789a" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ko kp kq kr bi translated">在您的机器上设置alwaysAI<a class="ae ks" href="https://alwaysai.co/docs/getting_started/development_computer_setup.html?&amp;utm_campaign=Open%20Beta&amp;utm_source=medium&amp;utm_content=multiple-object-detectors" rel="noopener ugc nofollow" target="_blank"/></li><li id="1a00" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ko kp kq kr bi translated">像<a class="ae ks" href="https://www.sublimetext.com/" rel="noopener ugc nofollow" target="_blank">这样的文本编辑器sublime </a>或者像<a class="ae ks" href="https://www.jetbrains.com/pycharm/" rel="noopener ugc nofollow" target="_blank"> PyCharm </a>这样的IDE，两者都提供免费版本，或者任何你喜欢的代码</li></ol><p id="03d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请参见alwaysAI <a class="ae ks" href="https://learn.alwaysai.co/?&amp;utm_campaign=Open%20Beta&amp;utm_source=medium&amp;utm_content=multiple-object-detectors" rel="noopener ugc nofollow" target="_blank">博客</a>了解更多关于<a class="ae ks" href="https://learn.alwaysai.co/computer-vision-101?&amp;utm_campaign=Open%20Beta&amp;utm_source=medium&amp;utm_content=multiple-object-detectors" rel="noopener ugc nofollow" target="_blank">计算机视觉</a>、<a class="ae ks" href="https://learn.alwaysai.co/blog/computer-vision-application-lifecycles-explained-0?&amp;utm_campaign=Open%20Beta&amp;utm_source=medium&amp;utm_content=multiple-object-detectors" rel="noopener ugc nofollow" target="_blank">开发模型</a>、如何<a class="ae ks" href="https://learn.alwaysai.co/blog/change-computer-vision-models-alwaysai-platform-0?&amp;utm_campaign=Open%20Beta&amp;utm_source=medium&amp;utm_content=multiple-object-detectors" rel="noopener ugc nofollow" target="_blank">改变模型</a>等的背景知识。</p><p id="e5d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么同时使用多个对象检测模型？</p><p id="00b9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要澄清的是，我指的不是<a class="ae ks" href="https://towardsdatascience.com/two-is-better-than-one-ensembling-models-611ee4fa9bd8" rel="noopener" target="_blank">整合</a>，即整合多个<a class="ae ks" href="https://towardsdatascience.com/a-guide-to-ensemble-learning-d3686c9bed9a" rel="noopener" target="_blank">性能较低的模型以产生一个更健壮的模型</a>，而是同时结合两个具有不同输出的模型。这在以下情况下会很有用</p><ul class=""><li id="d770" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ky kp kq kr bi translated">需要检测一组不同的对象，但是在组合时只能找到覆盖整个期望组的模型，</li><li id="c89b" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ky kp kq kr bi translated">想要确定哪个模型最适合检测特定的对象类型，</li><li id="66e6" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ky kp kq kr bi translated">想要在不同的相机深度或角度检测一种对象类型，而单个模型可能无法训练成这样</li><li id="776b" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ky kp kq kr bi translated">等等…</li></ul><p id="1f0e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尤其是在构建原型的时候，这种类型的模型组合可以节省很多时间。</p><p id="16ab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本教程的所有代码都可以在<a class="ae ks" href="https://github.com/alwaysai/multiple-object-detectors" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="101b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们开始吧！</p><p id="2213" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当你有了你的免费账户并建立了你的开发者环境后，你需要下载入门应用；在继续本教程的其余部分之前，使用此链接完成<a class="ae ks" href="https://www.alwaysai.co/docs/reference/starter_applications.html?&amp;utm_campaign=Open%20Beta&amp;utm_source=medium&amp;utm_content=multiple-object-detectors" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="12db" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下载starter应用程序后，您可以开始修改现有的starter应用程序，以使用两种对象检测模型。针对本教程修改的应用程序是“对象检测器”应用程序，因此cd进入starter apps文件夹和“realtime_object_detector”文件夹。</p><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="40b9" class="le lf hi la b fi lg lh l li lj">cd ./alwaysai-starter-apps/realtime_object_detector</span></pre><p id="f7fc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“realtime_object_detector”入门应用程序中默认使用的对象检测模型是“alwaysai/mobilenet_ssd”。我们准备增加第二个模型，‘alwaysai/SSD _ inception _ v2 _ coco _ 2018 _ 01 _ 28’。原始模型“alwaysai/mobilenet_ssd”识别20个对象类别，包括人类、动物、一些家具、自行车、火车、平原、盆栽植物等..新模型“alwaysai/SSD _ inception _ v2 _ coco _ 2018 _ 01 _ 28”识别了“alwaysai/mobilenet_ssd”所识别的许多对象，但不是全部，例如，它不是在飞机上训练的。通过使用相似的库，我们还可以看出一个库是否比另一个库更擅长检测某些类型的对象。然而，您可以使用一个检测人脸的模型(“alwaysai/mobilenet_ssd_face”)和另一个检测手的模型(“alwaysai/hand_detection”)作为不同的用例，或者通过浏览<a class="ae ks" href="https://alwaysai.co/model-catalog/models?&amp;utm_campaign=Open%20Beta&amp;utm_source=medium&amp;utm_content=multiple-object-detectors" rel="noopener ugc nofollow" target="_blank">模型目录</a>找到可能更适合您的特定应用的其他模型。</p><p id="28db" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我们向应用程序添加了一个新模型，因此我们需要通过在命令行中键入以下内容来将该模型添加到我们的应用程序环境中:</p><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="2066" class="le lf hi la b fi lg lh l li lj">aai app models add alwaysai/ssd_inception_v2_coco_2018_01_28</span></pre><p id="4d40" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lk">注意:您可以通过遵循“</em> <a class="ae ks" href="https://www.alwaysai.co/docs/application_development/changing_the_model.html?&amp;utm_campaign=Open%20Beta&amp;utm_source=medium&amp;utm_content=multiple-object-detectors" rel="noopener ugc nofollow" target="_blank"> <em class="lk">改变计算机视觉模型</em> </a> <em class="lk">”文档来改变任何模型。</em></p><p id="5447" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然您已经将您的模型添加到您的应用程序环境中，那么您可以开始修改starter应用程序代码了。我们将通过以下步骤来实现这一点:</p><ol class=""><li id="3e2a" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">为所有正在使用的模型初始化检测对象。原始应用程序中的代码在第16–18行。这段代码初始化一个新的对象检测器并加载引擎。不是简单地复制这段代码来创建第二个不可扩展的对象，一个更好的解决方案是跟踪您想要在一个数组中使用的所有模型，并在一个循环中对所有模型执行相同的启动过程。</li></ol><ul class=""><li id="a2d0" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ky kp kq kr bi translated">在main中，创建一个列表来存储您的所有模型；在完成的代码中，我称这个列表为“模型”。这比简单地复制原始代码更具可扩展性。</li><li id="7e6b" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ky kp kq kr bi translated">我们将把' alwaysai/mobilenet_ssd '作为'模型'中的第一个元素，把' alwaysai/SSD _ inception _ v2 _ coco _ 2018 _ 01 _ 28 '作为'模型'中的第二个元素。您的代码现在应该如下所示:</li></ul><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="05ee" class="le lf hi la b fi lg lh l li lj">models = ["alwaysai/mobilenet_ssd","alwaysai/ssd_inception_v2_coco_2018_01_28"]</span></pre><p id="0cb6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.为您使用的每个模型存储颜色。<em class="lk">注意:存储每个型号的颜色是可选的，但这将使不同型号的检测更容易识别。如果您忽略了这一点，那么新代码中还有一行也应该忽略。如果您不想让每个型号都有唯一的颜色，请跳到步骤3。</em></p><ul class=""><li id="add8" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ky kp kq kr bi translated">初始化一个名为“颜色”的列表</li><li id="fc8a" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ky kp kq kr bi translated">为每个元素添加两个[(B，G，R)]格式的条目。您的代码现在应该包含以下几行:</li></ul><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="9c1f" class="le lf hi la b fi lg lh l li lj">colors = [[(66, 68, 179)], [(50, 227, 62)]]</span></pre><p id="0b9e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.初始化和维护所有模型的检测对象，其中每个检测器对象都相当于starter应用程序代码中的“obj_detect”。</p><ul class=""><li id="8aa3" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ky kp kq kr bi translated">因为我们使用多个模型，所以我们需要多个检测器。创建检测器列表。将以下代码行添加到您的应用程序中:</li></ul><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="a349" class="le lf hi la b fi lg lh l li lj">detectors = []</span></pre><ul class=""><li id="fe01" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ky kp kq kr bi translated">现在使用for循环遍历模型，如下所示:</li></ul><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="41e4" class="le lf hi la b fi lg lh l li lj">for model in models:</span></pre><ul class=""><li id="2f0c" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ky kp kq kr bi translated">在循环中，为每个模型初始化一个新的对象检测器:</li></ul><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="10f8" class="le lf hi la b fi lg lh l li lj">obj_detect = edgeiq.ObjectDetection(model)</span><span id="5a12" class="le lf hi la b fi ll lh l li lj">obj_detect.load(engine=edgeiq.Engine.DNN)</span></pre><p id="afd3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lk">注意:这与最初的starter应用程序的代码几乎相同，但现在我们不是使用“alwaysai/mobilenet_ssd ”,而是使用“model”从列表中取出下一个模型。</em></p><ul class=""><li id="cef3" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ky kp kq kr bi translated">现在，将新创建的检测器对象追加到您在上一步中创建的列表中，以便我们可以跟踪所有的检测器对象:</li></ul><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="d85c" class="le lf hi la b fi lg lh l li lj">detectors.append(obj_detect)</span></pre><ul class=""><li id="98f6" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ky kp kq kr bi translated">打印出对象检测器的详细信息:您可以将原始代码中第20–23行的原始代码复制到您的循环中来完成这项工作。</li></ul><p id="61cd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，型号列表的索引I将对应于颜色列表的索引I，以及新代码中检测器列表的索引I。</p><p id="3c72" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重述:原始代码:</p><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="fc36" class="le lf hi la b fi lg lh l li lj">def main():<br/>    obj_detect = edgeiq.ObjectDetection(<br/>            "alwaysai/mobilenet_ssd")<br/>    obj_detect.load(engine=edgeiq.Engine.DNN)</span><span id="51b0" class="le lf hi la b fi ll lh l li lj">print("Loaded model:\n{}\n".format(obj_detect.model_id))<br/>    print("Engine: {}".format(obj_detect.engine))<br/>    print("Accelerator: {}\n".format(obj_detect.accelerator))<br/>    print("Labels:\n{}\n".format(obj_detect.labels))</span><span id="fd75" class="le lf hi la b fi ll lh l li lj">fps = edgeiq.FPS()</span></pre><p id="4142" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">新代码:</p><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="5859" class="le lf hi la b fi lg lh l li lj">def main():</span><span id="f3e0" class="le lf hi la b fi ll lh l li lj"># if you would like to test an additional model, add one to the list below:<br/>    models = ["alwaysai/mobilenet_ssd", "alwaysai/ssd_inception_v2_coco_2018_01_28"]</span><span id="c983" class="le lf hi la b fi ll lh l li lj"># if you've added a model, add a new color in as a list of tuples in BGR format<br/>    # to make visualization easier (e.g. [(B, G, R)]).<br/>    colors = [[(66, 68, 179)], [(50, 227, 62)]]</span><span id="b56c" class="le lf hi la b fi ll lh l li lj">detectors = []</span><span id="225c" class="le lf hi la b fi ll lh l li lj"># load all the models (creates a new object detector for each model)<br/>    for model in models:</span><span id="57c8" class="le lf hi la b fi ll lh l li lj"># start up a first object detection model<br/>        obj_detect = edgeiq.ObjectDetection(model)<br/>        obj_detect.load(engine=edgeiq.Engine.DNN)</span><span id="bf7f" class="le lf hi la b fi ll lh l li lj"># track the generated object detection items by storing them in detectors<br/>        detectors.append(obj_detect)</span><span id="7904" class="le lf hi la b fi ll lh l li lj"># print the details of each model to the console<br/>        print("Model:\n{}\n".format(obj_detect.model_id))<br/>        print("Engine: {}".format(obj_detect.engine))<br/>        print("Accelerator: {}\n".format(obj_detect.accelerator))<br/>        print("Labels:\n{}\n".format(obj_detect.labels))</span><span id="aca0" class="le lf hi la b fi ll lh l li lj">fps = edgeiq.FPS()</span></pre><p id="4938" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了现在的代码，我们可以将一个模型添加到“模型”列表中，每个模型都将完成相同的初始化过程。“探测器”列表将存储物体探测器。<em class="lk">注意:颜色列表是BGR格式的(不是RGB！)</em></p><p id="a5a6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，在“while循环”中添加一个“for循环”,循环遍历检测器中的每个检测器。这将涉及以下步骤:</p><p id="7fa3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.为每个模型生成一个新的图像(参见下面的代码)</p><ul class=""><li id="9251" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ky kp kq kr bi translated">将第38行中的变量“帧”改为“对象_帧”</li><li id="3221" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ky kp kq kr bi translated">将同一行中对“markup_image”的调用的“colors”属性更改为，使用colors[i]作为值。这将覆盖现有的颜色选项，使给定模型的所有颜色都相同。<em class="lk">注意:如果你不想这样做，或者你没有创建一个‘颜色’列表，省略这个改变。否则，您的代码应该如下所示:</em></li></ul><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="0fb8" class="le lf hi la b fi lg lh l li lj">object_frame = edgeiq.markup_image(<br/>                        frame, results.predictions, show_labels=False, colors=colors[i])</span></pre><p id="bff7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.在此之下，创建一个if/else语句，用检测到的第一个模型覆盖输入提要。这并不是绝对必要的，如果没有这个步骤，图像上总是会出现没有检测帧的普通视频流。</p><ul class=""><li id="ffb7" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ky kp kq kr bi translated">我们将创建一个新的框架，并将其命名为“display_frame”。</li><li id="952b" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ky kp kq kr bi translated">如果我们在第一次迭代中，i == 0，设置‘display _ frame’为‘object _ frame’；否则，将两个帧连接在一起。添加以下代码:</li></ul><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="fbc1" class="le lf hi la b fi lg lh l li lj"># for the first frame, overwrite the input feed<br/>if i == 0:<br/>    display_frame = object_frame<br/>else:<br/>    # append newly marked-up frame to the previous frame<br/>    display_frame = numpy.concatenate((object_frame, display_frame))</span></pre><p id="c4a1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">7.重新格式化输出图像的文本。</p><ul class=""><li id="fc3f" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ky kp kq kr bi translated">删除第41–45行，它将模型和推理时间附加到屏幕上。这是一个以上的模型太忙了。</li><li id="6305" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ky kp kq kr bi translated">现在，将模型和推理时间添加到最内层for循环中每个预测的文本中，该循环将预测文本追加到每个图像中。您的代码应该如下所示:</li></ul><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="4e8f" class="le lf hi la b fi lg lh l li lj"># append each prediction<br/>for prediction in results.predictions:<br/>    text.append("Model {} detects {}: {:2.2f}% (inference time: {:1.2f})".format(detectors[i].model_id,prediction.label, prediction.confidence * 100, results.duration))</span></pre><p id="cfb9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将更容易知道哪个模型在输出屏幕上做出哪个预测。</p><p id="abc9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终的while循环代码将如下所示:</p><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="ee84" class="le lf hi la b fi lg lh l li lj"># loop detection<br/>while True:<br/>    frame = video_stream.read()<br/>    text = [""]<br/>   <br/>    # gather data from the all the detectors <br/>    for i in range(0, len(detectors)):<br/>        results = detectors[i].detect_objects(frame, confidence_level=.5)<br/>        object_frame = edgeiq.markup_image(frame, results.predictions, show_labels=False, colors=colors[i])</span><span id="064d" class="le lf hi la b fi ll lh l li lj">    # for the first frame, overwrite the input feed<br/>    if i == 0:<br/>        display_frame = object_frame<br/>    else:<br/>        # otherwise, append newly marked-up frame to previous frame<br/>        display_frame = numpy.concatenate((object_frame, display_frame))</span><span id="d25a" class="le lf hi la b fi ll lh l li lj">    # append each prediction<br/>    for prediction in results.predictions:<br/>        text.append("Model {} detects {}: {:2.2f}% (inference time: {:1.2f})".format(detectors[i].model_id,prediction.label, prediction.confidence * 100, results.duration))</span><span id="2f06" class="le lf hi la b fi ll lh l li lj">    # send the image frame and the predictions for both <br/>    # prediction models to the output stream<br/>    streamer.send_data(display_frame, text)</span><span id="d4d6" class="le lf hi la b fi ll lh l li lj">    fps.update()</span><span id="1858" class="le lf hi la b fi ll lh l li lj">    if streamer.check_exit():<br/>        break</span></pre><p id="b5d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！现在，您可以构建并启动您的应用程序来查看它的运行情况。您可能需要先配置应用程序，尤其是在您更改了边缘设备或从头开始创建新文件夹的情况下。使用以下命令并在出现提示时输入所需的配置输入:</p><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="2a8c" class="le lf hi la b fi lg lh l li lj">aai app configure</span></pre><p id="2c65" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，要查看您的应用程序的运行情况，首先通过在命令行中键入以下内容来构建应用程序:</p><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="dd37" class="le lf hi la b fi lg lh l li lj">aai app deploy</span></pre><p id="d96c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">构建完成后，使用以下命令启动应用程序:</p><pre class="ju jv jw jx fd kz la lb lc aw ld bi"><span id="b3cf" class="le lf hi la b fi lg lh l li lj">aai app start</span></pre><p id="1ee5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在打开任何一个浏览器到“localhost:5000 ”,您应该会看到文章开头所示的输出！</p></div></div>    
</body>
</html>