<html>
<head>
<title>Do All Hollywood Actors Know Each Other? Breadth-First Search in “Action”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">好莱坞的演员都互相认识吗？“行动”中的广度优先搜索</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/do-all-hollywood-actors-know-each-other-breadth-first-search-in-action-1b37df515928?source=collection_archive---------19-----------------------#2020-12-13">https://medium.com/analytics-vidhya/do-all-hollywood-actors-know-each-other-breadth-first-search-in-action-1b37df515928?source=collection_archive---------19-----------------------#2020-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c016b3de4ce390b4b044091b57956f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tz6Wb3-51ot5op1zUenDQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@vincentas_" rel="noopener ugc nofollow" target="_blank"> Vincentas Liskauskas </a>在<a class="ae iu" href="https://unsplash.com/photos/ErMkvcFla74" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="edf9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">任务很简单:给定两个演员的名字，通过他们的电影角色找到他们之间的联系。比如艾玛·沃森通过丹尼尔·雷德克里夫(哈利·波特)认识了詹妮弗·劳伦斯，认识了詹姆斯·麦卡沃伊(维克多·弗兰肯斯坦)，最终认识了詹妮弗·劳伦斯(黑凤凰)。<a class="ae iu" href="https://github.com/dtemir/harvard-CS50AI" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="0eec" class="kc kd hi jy b fi ke kf l kg kh">$ python degrees.py large<br/>Loading data...<br/>Data loaded.<br/>Name: Emma Watson<br/>Name: Jennifer Lawrence<br/>3 degrees of separation.<br/>1: Emma Watson and Daniel Radcliffe starred in Harry Potter and the Chamber of Secrets<br/>2: Daniel Radcliffe and James McAvoy starred in Victor Frankenstein<br/>3: James McAvoy and Jennifer Lawrence starred in Dark Phoenix</span></pre><p id="6b62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个任务是关于解决一个搜索问题，比如一个迷宫，其中我们被给定一个<strong class="ix hj">初始状态</strong>(艾玛·沃森)和一个<strong class="ix hj">目标状态</strong>(詹妮弗·劳伦斯)。我们需要找到初始状态和目标状态之间的<strong class="ix hj"> <em class="ki">最短</em> </strong>路径，这意味着我们应该利用基于使用<strong class="ix hj">队列边界</strong>的<strong class="ix hj">广度优先搜索</strong>。通过使用队列边界，我们可以从初始状态开始逐渐检查所有可用的<strong class="ix hj">相邻节点</strong>，这意味着我们将总是到达最短路径，因为我们将穷尽所有状态，直到我们到达最短解。</p><p id="41e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们需要了解我们可以获得哪些数据。数据由IMDb提供，包括三个表格:<em class="ki"> movies.csv </em>，带有<em class="ki">片名、年份、</em>和<em class="ki">id列表；</em> <em class="ki"> stars.csv </em>带列表的<em class="ki">person _ id</em>和他们的<em class="ki">movie _ id；</em>和<em class="ki"> people.csv </em>与<em class="ki">id、姓名、</em>和<em class="ki">出生年份</em>的列表。</p><p id="f454" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其次，我们需要确定<strong class="ix hj">节点</strong>将存储什么。在我们的例子中，节点类是一个具有<code class="du kj kk kl jy b">state</code>、<code class="du kj kk kl jy b">parent</code>和<code class="du kj kk kl jy b">action</code>属性的对象。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="0a07" class="kc kd hi jy b fi ke kf l kg kh">class Node():<br/>    def __init__(self, state, parent, action):<br/>        self.state = state    # the current actors id<br/>        self.parent = parent  # the previous actors id<br/>        self.action = action  # the current movie id</span></pre><p id="099c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们<strong class="ix hj">到达最终状态</strong>并且<strong class="ix hj">需要跟踪我们所做的路径</strong>，存储<code class="du kj kk kl jy b">parent</code>将会非常方便。把它看作一个<strong class="ix hj">单链表</strong>，指针指向下一个节点(尽管在我们的例子中，它指向前一个节点)。</p><p id="18c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以当谈到<strong class="ix hj">广度优先搜索</strong>时，我们应该使用一个<strong class="ix hj">队列</strong>来存储我们需要访问的所有节点。使用队列对于BFS来说是必不可少的，因为我们需要依次遍历同一层上的所有节点来找到最短路径。有一篇关于BFS的不错的媒体文章。</p><p id="a1f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">说到这里，现在我们可以开始我们的<code class="du kj kk kl jy b">shortest_path </code>函数了，它接受source_id和target_id作为属性。我们首先初始化<code class="du kj kk kl jy b">frontier</code>，然后添加存储状态的<code class="du kj kk kl jy b">source_id</code>和父动作的<code class="du kj kk kl jy b">None</code>的第一个节点。因此，保持<code class="du kj kk kl jy b">explored</code>设定以避免检查相同的人和他们的电影是很重要的。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b1ed" class="kc kd hi jy b fi ke kf l kg kh">frontier = QueueFrontier()<br/>frontier.add(Node(state=source_id, parent=None, action=None))<br/>explored = set()</span></pre><p id="cd6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们遍历，直到我们找到解决方案或用尽所有可能的边界节点。如果边界是空的，我们可以说没有联系。如果<strong class="ix hj">不为空</strong>，我们从队列中提取节点，特别是我们先放在那里的那个。<strong class="ix hj">如果节点的状态等于</strong> <code class="du kj kk kl jy b"><strong class="ix hj">target_id</strong></code>，说明我们已经到了解，需要确定我们做的路径。这就是节点的父节点派上用场的地方(耶！).我们使用节点进行遍历，并保存我们在<code class="du kj kk kl jy b">path</code>中找到的所有节点。一旦我们把所有的节点放在列表中，我们反转它，并返回它。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="416e" class="kc kd hi jy b fi ke kf l kg kh">while True:<br/>    if frontier.empty():  # No more available nodes to check against target_id<br/>        raise Exception("No solution")<br/>    node = frontier.remove()  # Take out the first element from the queue<br/>    if node.state == target_id:  # We found the final state!<br/>        path = []<br/>        while node.parent is not None:<br/>            path.append((node.action, node.state))<br/>            node = node.parent<br/>        # Don't forget to reverse it because we were moving from the final state to the initial<br/>        path.reverse()<br/>        return path</span></pre><p id="9dcc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这还没有结束。请原谅我。<strong class="ix hj">如果节点的状态不等于</strong> <code class="du kj kk kl jy b"><strong class="ix hj">target_id</strong></code>，那么我们将它添加到探索集，并将它的所有邻居添加到边界。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="4648" class="kc kd hi jy b fi ke kf l kg kh">explored.add((node.action, node.state))  # Record that we've already seen this actor and movie<br/>for action, state in neighbors_for_person(node.state):<br/>    if not frontier.contains_state(state) and (action, state) not in explored:<br/>        # New node for the next actor and movie<br/>        child = Node(state=state, parent=node, action=action)<br/>        frontier.add(child)  # By adding to the frontier, we put it in the end of the queue</span></pre><p id="785f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能想知道<code class="du kj kk kl jy b">neighbors_for_person </code>函数在做什么？嗯，它只是返回所有主演过同一部电影的邻近演员。例如，假设Emma Watson是初始状态，我们提取她所有电影(可能是所有哈利波特电影)的id，然后检查它们以及参与这些电影的人。我们最终返回所有这些人的id和电影id的集合。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5e78" class="kc kd hi jy b fi ke kf l kg kh">movie_ids = people[person_id]["movies"]<br/>neighbors = set()<br/>for movie_id in movie_ids:<br/>    for person_id in movies[movie_id]["stars"]:<br/>        neighbors.add((movie_id, person_id))<br/>return neighbors</span></pre><p id="99d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一般来说，这个算法肯定是相当慢的。<code class="du kj kk kl jy b">shortest_path</code>函数的运行时复杂度约为O(n⁴，这非常糟糕，但该项目的重点是在真实世界的数据中应用BFS。我希望你喜欢阅读这篇文章。请注意，这个项目是我哈佛CS50人工智能课程的一部分；你可以在这里找到更多关于它的信息。也请查看我的<a class="ae iu" href="https://github.com/dtemir/harvard-CS50AI" rel="noopener ugc nofollow" target="_blank"> GitHub </a>库。</p><p id="293a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个例子:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="e45d" class="kc kd hi jy b fi ke kf l kg kh">python degrees.py large<br/>Loading data...<br/>Data loaded.<br/>Name: Eddie Murphy<br/>Name: Bill Clinton<br/>3 degrees of separation.<br/>1: Eddie Murphy and Halle Berry starred in Boomerang<br/>2: Halle Berry and Robert Downey Jr. starred in Gothika<br/>3: Robert Downey Jr. and Bill Clinton starred in The Last Party</span></pre></div></div>    
</body>
</html>