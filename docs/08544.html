<html>
<head>
<title>A thorough Understanding of Numpy Strides and Its Application in Data Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入理解Numpy步长及其在数据处理中的应用</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-thorough-understanding-of-numpy-strides-and-its-application-in-data-processing-e40eab1c82fe?source=collection_archive---------5-----------------------#2020-08-03">https://medium.com/analytics-vidhya/a-thorough-understanding-of-numpy-strides-and-its-application-in-data-processing-e40eab1c82fe?source=collection_archive---------5-----------------------#2020-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cd3f91a8982cd4d520e0af708d94cb8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3k5qB5_ObQa1lrtrKzR17A.png"/></div></div></figure><p id="d18a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">大步走</strong>就像在数据中以给定的窗口大小迈步。这是一种非常常见的技术，你会在各种数据处理任务中看到。本教程将介绍Stride的最基本概念，以及如何在Numpy中使用它，最后以一个Pandas dataframe数据处理用例结束。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="1a51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单地说，你将被介绍:</p><ol class=""><li id="25f3" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated"><strong class="is hj">什么</strong>是跨步？</li><li id="64f3" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated"><strong class="is hj">一个Numpy 2D数组的数据结构</strong>，就其内存分配而言</li><li id="e0ae" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated"><strong class="is hj">如何在Numpy数组上</strong>跨步:<br/>“Numpy . lib . stride _ tricks . as _ strided()”的用法</li><li id="799e" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">数据处理中一个有用的<strong class="is hj">用例</strong>:<br/><em class="kj">如何在一个序列中匹配一个模式，并使用Striding返回起始和结束索引？</em></li></ol></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="cc3b" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">什么是Stride？</h1><p id="7b5f" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">打个简单的比方，大步走就像在固定大小的窗口中在数据中迈步。考虑8个数的1D数组(即[10，8，6，2，5，1，4，9])，红框每次看2个数(<strong class="is hj"> window = 2 </strong>)，然后从当前开始位置<strong class="is hj"> <em class="kj"> i </em> </strong>滑动到<strong class="is hj"> <em class="kj"> i+3 </em> </strong>位置(<strong class="is hj"> step = 3 </strong>)。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fd8a0843c07f0ab331cad892fb565599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edxvLIO45rDlSIi35R2K_Q.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图一。步长和窗口的基本概念</figcaption></figure><p id="33ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于数组中的N个元素，给定窗口大小(W)和步长(S)，它将滑动多次:(<strong class="is hj"> (N-W) // S) + 1 <br/> </strong>在我们的示例中，它是((8–2)//3)+1 = 3次。</p><p id="7a9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(注意:这里的符号“//”是一个Python除法符号，用于将商向下舍入为整数。比如4 // 2是2，5 // 2也是2。)</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="5d51" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">Numpy 2D数组的数据结构</h1><p id="46ab" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">作为人类，我们有2D数组的概念——我们想把2D数组想象成一个表状结构，它有<strong class="is hj"> <em class="kj"> i </em> </strong> <em class="kj"> </em>列和<strong class="is hj"> <em class="kj"> j </em> </strong>行。然而，内存中的2D数组是一个连续的块，就像一维数组一样。它会一行接一行地存储，一列接一列地存储，如图所示:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/2841a62b98daab53d549d802ab9a9bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VerstzHpzhEBPucGOe45tw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图二。如何计算步幅的字节数</figcaption></figure><p id="2207" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图中每一个'<strong class="is hj"> <em class="kj">方块'</em> </strong>都是<strong class="is hj"><em class="kj"/></strong>中<strong class="is hj"> <em class="kj"> 1号</em> </strong>元素所需的内存空间，其所需空间取决于你为数组初始化的数据类型。因此，对于“int32”数据类型，内存块中的平方等于4个字节，对于“float”数据类型，内存块中的平方等于8个字节，这个“单位块”将告诉机器在内存空间中为“下一个数字”(下一列)前进多少。</p><p id="6957" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看数字1D阵列:</p><pre class="ln lo lp lq fd lw lx ly lz aw ma bi"><span id="8fc1" class="mb kl hi lx b fi mc md l me mf">import numpy as np</span><span id="aa06" class="mb kl hi lx b fi mg md l me mf">x = np.array([10, 8, 2, 5, 4, 9], dtype='int32')<br/>x.shape<br/>&gt;&gt; (6,)<br/>x.strides<br/>&gt;&gt; (4,)</span><span id="502b" class="mb kl hi lx b fi mg md l me mf">x = np.array([10, 8, 2, 5, 4, 9], dtype='float')<br/>x.shape<br/>&gt;&gt; (6,)<br/>x.strides<br/>&gt;&gt; (8,)</span></pre><p id="4435" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于<strong class="is hj"> <em class="kj"> x </em> </strong>是一个1D数组，其形状为<strong class="is hj"> <em class="kj"> (i，)</em> </strong>其中<em class="kj"> i </em>是数组中元素的个数，即我们例子中的6个元素，所以形状显示为(6，)。但是，请注意，当数组以不同的数据类型初始化时，即从“int32”到“float”，步长从(4)变为(8)，因为“int32”占用4个字节，而“float”占用8个字节。它表示对于这个数组，从内存中的第一个位置开始，它需要消耗多少字节才能到达下一个数字，所以这就是我们介绍的<strong class="is hj">大步</strong>和<strong class="is hj">窗口</strong>概念——其中<strong class="is hj"> <em class="kj">窗口</em> </strong>是一个数字的N字节<strong class="is hj"><em class="kj"/></strong>，每<strong class="is hj"> <em class="kj">步</em> </strong>它需要跳<strong class="is hj"> <em class="kj"> N</em></strong></p><p id="9e61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们来看看Numpy数组:</p><pre class="ln lo lp lq fd lw lx ly lz aw ma bi"><span id="d350" class="mb kl hi lx b fi mc md l me mf">x = np.array([[10, 8],[2, 5],[4, 9]], dtype='int32')</span><span id="6337" class="mb kl hi lx b fi mg md l me mf">x<br/>&gt;&gt; array([[10,  8],<br/>          [ 2,  5],<br/>          [ 4,  9]])</span><span id="5caa" class="mb kl hi lx b fi mg md l me mf">x.shape    # shape: (Num of row, Num of column)<br/>&gt;&gt; (3, 2)</span><span id="f06c" class="mb kl hi lx b fi mg md l me mf">x.strides  # stride: (Bytes per row, Bytes per column)<br/>&gt;&gt; (8, 4)</span></pre><p id="21bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们初始化了一个int32数据类型的2D数组，它有<strong class="is hj"> 3行</strong>和<strong class="is hj">两列</strong>，即形状为(3，2)。</p><p id="63c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="kj">注:</em></strong><strong class="is hj"><em class="kj">形状元组中的第一个数字</em> </strong>，<strong class="is hj"> <em class="kj"> (i，j) </em> </strong>，指的是<strong class="is hj"> <em class="kj">数组第一层</em> </strong>中的元素数。因此，在这个2D阵列中，该阵列在第一层中具有3个元素(即，子括号)，并且对于第二层的每个子括号，其中有2个元素。这样，这个2D阵列的<strong class="is hj">形状</strong>就可以理解为<strong class="is hj">(#行，#列)</strong>。然而，将2D数组可视化为类似表格的结构实际上只是为了便于人类理解。在计算机中，它作为一个<strong class="is hj"> <em class="kj">顺序块</em> </strong>存储在内存中，所以数组的维数可以嵌套，继续扩展。这样，你就可以随心所欲地拥有N维的N维数组<strong class="is hj"><em class="kj"/></strong>。</p><p id="4f0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，现在我们打印<code class="du mh mi mj lx b">x.strides</code>，你会发现是<strong class="is hj"> <em class="kj"> (8，4) </em> </strong>，这是意料之中的，因为:</p><ul class=""><li id="c47f" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn mk kb kc kd bi translated"><strong class="is hj">形状</strong>读作<em class="kj">(</em><strong class="is hj"><em class="kj">行</em> </strong> <em class="kj">，</em> <strong class="is hj"> <em class="kj">列</em> </strong> <em class="kj"> ) </em></li><li id="be11" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn mk kb kc kd bi translated"><strong class="is hj">大踏步</strong>读作(#大踏步一列<strong class="is hj"> <em class="kj">行</em> </strong>，#大踏步一列<strong class="is hj"><em class="kj"/></strong>)</li></ul><p id="d312" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步幅<strong class="is hj"> <em class="kj">步</em> </strong>由<strong class="is hj"> <em class="kj">字节</em> </strong>测量。因此，要跳转到下一个<strong class="is hj"> <em class="kj">行</em> </strong>，就需要跳转<strong class="is hj"> 1整数(4字节)x 2 = 8 </strong> <strong class="is hj">字节</strong>，而要跳转到下一个<strong class="is hj"> <em class="kj">列</em> </strong>，就正好是<strong class="is hj"> 1整数= 4字节</strong>，这样我们就得到了(8，4)。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="5cc6" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">如何在数字阵列中大步前进</h1><p id="ce27" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">好了，现在我们已经介绍了“什么是跨距”以及“数组实际上是如何在内存空间中跨越字节的”。现在我们想知道如何在Numpy数组中实现这一点。如果给我们一个1-D数组，并希望大步走向某个窗口和步骤，然后像这样构造一个新的2-D数组:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0f64c5ba7a9a065718934c7242000638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gV0vX2NPaTge4vfuYvxBRw.png"/></div></div></figure><p id="6b52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我们将使用一个Numpy <a class="ae ml" href="https://numpy.org/doc/stable/reference/generated/numpy.lib.stride_tricks.as_strided.html#numpy-lib-stride-tricks-as-strided" rel="noopener ugc nofollow" target="_blank">函数</a>，它将允许您访问内存块中的数组(就像一个指针)，然后允许您在内存空间中大步前进:</p><blockquote class="mm mn mo"><p id="918a" class="iq ir kj is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated"><strong class="is hj">numpy . lib . Stride _ tricks . as _ strided(Arr，New_arr_shape，Stride_steps ) </strong></p></blockquote><p id="7c9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该函数有3个主要参数:</p><ul class=""><li id="947d" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn mk kb kc kd bi translated"><strong class="is hj">数组:</strong>这是你要跨步的原始数组。在我们的例子中，它是一个包含8个整数的一维数组。</li><li id="6d83" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn mk kb kc kd bi translated"><strong class="is hj">新数组形状:</strong>这是输出数组的预期形状(跨步后)。在我们的示例中，它是新的二维数组的形状，该数组应该有3行2列，因此shape应该是(3，2)。<br/>(回到<strong class="is hj"> <em class="kj">“什么是跨步”一节图1 </em> </strong>进行图解。)</li><li id="7ff0" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn mk kb kc kd bi translated"><strong class="is hj">步幅步数:</strong>这是以字节计量的步幅大小。在我们的例子中，我们想跳过数组中的3个索引，每个索引都是一个整数(4个字节)，因此对于第<strong class="is hj">行</strong>的步幅步长来说<strong class="is hj"> 3*4 = 12 </strong>个字节。对于该列，下一个整数距离<strong class="is hj"> 4个字节</strong>，因此<strong class="is hj">列的步幅为</strong>。因此，在我们的例子中，步长是(12，4)。<br/>(回到<strong class="is hj"> <em class="kj">“什么是跨步”一节图2 </em> </strong>进行图解。)</li></ul><pre class="ln lo lp lq fd lw lx ly lz aw ma bi"><span id="8212" class="mb kl hi lx b fi mc md l me mf">x = np.array([10,8,6,2,5,1,4,9], dtype='int32')</span><span id="e582" class="mb kl hi lx b fi mg md l me mf">x.shape        # The shape is a 1D array of 8 'int32' numbers<br/>&gt;&gt; (8,)</span><span id="8650" class="mb kl hi lx b fi mg md l me mf">x[0].nbytes    # Each 'int32' occupied 4 bytes   (32 bits/8=4 bytes)<br/>&gt;&gt; 4</span><span id="9b5c" class="mb kl hi lx b fi mg md l me mf">y = np.lib.stride_tricks.as_strided(x,((8-2)//3+1,2),(3*4,4))</span><span id="6d67" class="mb kl hi lx b fi mg md l me mf">y<br/>&gt;&gt; array([[10,  8],<br/>          [ 2,  5],<br/>          [ 4,  9]])</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/3ba6d8b197ef0250ed09be403fffe8f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxOFZ-5d2irOE9M5BiPBxA.png"/></div></div></figure><p id="4620" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">！重要！</strong>需要注意的一点是:当使用这个函数时，你需要准确地知道“你每一步跨了多少字节”，因为这个函数不检查数组的边界。因此，如果你打乱了大步走的窗口或步骤，你最终会从你的记忆中获得随机数据。举个例子，让我在windows=2的情况下跨越<strong class="is hj"> 7 </strong>个整数，而我的数组只有8个整数。</p><pre class="ln lo lp lq fd lw lx ly lz aw ma bi"><span id="defa" class="mb kl hi lx b fi mc md l me mf">x = np.array([10,8,6,2,5,1,4,9], dtype='int32')<br/>y = np.lib.stride_tricks.as_strided(x,(8-2)//3+1,2),(<strong class="lx hj">7</strong>*4,4))</span><span id="67e0" class="mb kl hi lx b fi mg md l me mf">y<br/>&gt;&gt; array([[10, 8],<br/>          [9,  <strong class="lx hj">0</strong>],                   # The last 3 numbers are the<br/>          [<strong class="lx hj">1599227219</strong>, <strong class="lx hj">1380275029</strong>])  # random data in the memory</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/3ba6d8b197ef0250ed09be403fffe8f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxOFZ-5d2irOE9M5BiPBxA.png"/></div></div></figure><p id="8cd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，你也不希望硬编码这些字节，一步一步地走。这只是为了演示的目的。您可以使代码更加通用。</p><pre class="ln lo lp lq fd lw lx ly lz aw ma bi"><span id="f8a9" class="mb kl hi lx b fi mc md l me mf">x = np.array([10,8,6,2,5,1,4,9], dtype='int32')</span><span id="1f71" class="mb kl hi lx b fi mg md l me mf">total_len_x = x.shape[-1]<br/>window = 2       # The red box only looks for 2 numbers<br/>steps = 3        # The red box jump over 3 numbers each time<br/>new_shape_row = (total_len_x - window)//steps + 1<br/>new_shape_col = window<br/>new_shape = (new_shape_row, new_shape_col)</span><span id="ec83" class="mb kl hi lx b fi mg md l me mf">n_bytes = x.strides[-1]    # Since x.strides tells you how many<br/>                           # bytes Numpy array travels to get the  <br/>                           # next number in the array, so it equals <br/>                           # to x[0].nbytes.</span><span id="edf4" class="mb kl hi lx b fi mg md l me mf">stride_steps_row = n_bytes * steps<br/>stride_steps_col = n_bytes<br/>stride_steps = (stride_steps_row, stride_steps_col)</span><span id="ef2e" class="mb kl hi lx b fi mg md l me mf">y = np.lib.stride_tricks.as_strided(x, new_shape, stride_steps)</span></pre></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="abac" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">Stride在数组模式匹配中的应用</h1><p id="8d0a" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">假设我们有一个这样的问题要解决:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/274ee0282a5338d17fc904627069b3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJcpt_TawyxNLdcVUcB9uw.png"/></div></div></figure><p id="5836" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解决这个问题的一个方法是使用<code class="du mh mi mj lx b">np.lib.stride_tricks.as_stride()</code>在步骤1中前进，窗口为3(即模式的长度)，然后将每个数据块与模式进行比较。例如，stride将返回[[1，2，1]，[2，1，2]，[1，2，3]，[2，3，1]，…]，然后我们可以将这些长度为3的数据单元大小与我们的目标模式进行比较。首先，让我们将上面提到的代码打包成一个函数:</p><pre class="ln lo lp lq fd lw lx ly lz aw ma bi"><span id="a210" class="mb kl hi lx b fi mc md l me mf">def <strong class="lx hj">return_striding_content</strong>(arr, window, stride):<br/>    new_shape_row = (arr.shape[-1] - window)//stride + 1<br/>    new_shape_col = window<br/>    new_shape = (new_shape_row, new_shape_col)</span><span id="97a1" class="mb kl hi lx b fi mg md l me mf">    n_bytes = x.strides[-1]<br/>    stride_steps_row = n_bytes * stride<br/>    stride_step_col = n_bytes<br/>    stride_steps = (stride_steps_row, stride_step_col)</span><span id="2389" class="mb kl hi lx b fi mg md l me mf">    return np.lib.stride_tricks.as_strided(arr, new_shape, stride_steps)</span><span id="addb" class="mb kl hi lx b fi mg md l me mf"># Construct the array<br/>x = np.array([1,2,1,2,3,1,1,2,3], dtype='int32')</span><span id="acad" class="mb kl hi lx b fi mg md l me mf"># Construct the sliding content<br/>return_striding_content(x, 3, 1)<br/>&gt;&gt; array([[1, 2, 1],<br/>          [2, 1, 2],<br/>          [1, 2, 3],<br/>          [2, 3, 1],<br/>          [3, 1, 1],<br/>          [1, 1, 2],<br/>          [1, 2, 3]])</span></pre><p id="b99d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们将由<code class="du mh mi mj lx b">return_striding_content(x,3,1)</code>返回的每个跨步内容与模式<code class="du mh mi mj lx b">y</code>进行比较。</p><pre class="ln lo lp lq fd lw lx ly lz aw ma bi"><span id="6f5c" class="mb kl hi lx b fi mc md l me mf">p = [1,2,3]</span><span id="273c" class="mb kl hi lx b fi mg md l me mf">compare = (return_striding_content(x,3,1) == p).all(axis=1)</span><span id="2553" class="mb kl hi lx b fi mg md l me mf">compare<br/>&gt;&gt; array([False, False,  True, False, False, False,  True])</span></pre><p id="0390" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，我们需要<code class="du mh mi mj lx b">.all()</code>函数来对整个数组进行比较，因此显然来自<code class="du mh mi mj lx b">return_striding_content()</code>的整个数组与<code class="du mh mi mj lx b">p</code>数组不同，也就是说，毕竟它们甚至没有相同的维度。所以，这就是为什么我们需要指定<code class="du mh mi mj lx b">axis</code>。如果axis=0，它将比较垂直元素，如果axis=1，它将比较水平元素[参见这个有用的<a class="ae ml" href="https://www.sharpsightlabs.com/blog/numpy-axes-explained/#:~:text=NumPy%20axes%20are%20the%20directions,along%20the%20rows%20and%20columns." rel="noopener ugc nofollow" target="_blank">博客</a> ]。您可以看到，结果显示第3和第7个元素是我们要查找的模式，这对应于原始数组<code class="du mh mi mj lx b">x</code>中模式开始位置的起始索引。因此，给定模式的固定窗口，模式结束的结束索引将简单地是“开始索引+ 2”。</p><pre class="ln lo lp lq fd lw lx ly lz aw ma bi"><span id="4b1b" class="mb kl hi lx b fi mc md l me mf">[([i, i+2]) for i in np.where(compare==True)[-1]]<br/>&gt;&gt; [[2,4], [6,8]]</span></pre><p id="f4b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:在<code class="du mh mi mj lx b">np.where()</code>之后应用的[-1]实际上只是从返回结果的元组结构中提取数据。你可以试着打印出<code class="du mh mi mj lx b">np.where(compare==True)</code>来看看返回的结果是什么。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="8eb5" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">参考</h1><p id="fad2" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">[1]IPython Interactive Computing and Visualization Cookbook，第二版(2018)，作者<a class="ae ml" href="http://cyrille.rossant.net/" rel="noopener ugc nofollow" target="_blank">Cyrille Rossant</a>:<br/><a class="ae ml" href="https://ipython-books.github.io/46-using-stride-tricks-with-numpy/" rel="noopener ugc nofollow" target="_blank">https://IPython-books . github . io/46-using-stride-tricks-with-numpy/</a></p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="15a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！希望你喜欢这篇关于如何使用striding的介绍以及如何使用Numpy的教程。如果你觉得这个帖子有用，请给这个帖子留个“拍手”吧！也欢迎你留下你的想法、评论或反馈！感谢您的阅读！</p></div></div>    
</body>
</html>