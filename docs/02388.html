<html>
<head>
<title>Meta Machine Learning aggregator packages in R: The 2nd generation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R中的元机器学习聚合器包:第二代</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/meta-machine-learning-aggregator-packages-in-r-round-ii-71ee1ff68642?source=collection_archive---------11-----------------------#2019-12-14">https://medium.com/analytics-vidhya/meta-machine-learning-aggregator-packages-in-r-round-ii-71ee1ff68642?source=collection_archive---------11-----------------------#2019-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3c27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">写于2019年12月。</p><p id="ad72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在2018年年中的<a class="ae jd" href="https://towardsdatascience.com/meta-machine-learning-packages-in-r-c3e869b53ed6" rel="noopener" target="_blank">上一篇帖子</a>描述了我对‘meta’机器学习聚合器包的R包的学习体验:mlr、caret和SuperLerner。这些包在多个独立的单个多元模型/包上统一了机器学习框架，并围绕它们为常见任务(如重采样、调整、基准测试、集成等)提供了“元”机器学习框架。</p><p id="b9a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从那以后，R生态系统中的几个主要开发已经发展和成熟，取代了不推荐使用的包，这些包，咳咳，咳咳，承认起来不舒服，已经开始遭受… <a class="ae jd" rel="noopener" href="/free-code-camp/scope-creep-and-other-software-design-lessons-learned-the-hard-way-edacf021965b">范围蔓延</a>。</p><p id="54f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在这里讨论的当前重构包有:</p><ol class=""><li id="50ec" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><a class="ae jd" href="https://mlr.mlr-org.com/" rel="noopener ugc nofollow" target="_blank"> mlr </a> - &gt; mlr3 ( <a class="ae jd" href="https://mlr3.mlr-org.com/" rel="noopener ugc nofollow" target="_blank">页</a>，<a class="ae jd" href="https://mlr3book.mlr-org.com/" rel="noopener ugc nofollow" target="_blank">手动</a>)</li><li id="4983" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="http://topepo.github.io/caret/index.html" rel="noopener ugc nofollow" target="_blank">插入符号</a>-&gt;tidyModels(<a class="ae jd" href="https://github.com/tidymodels/tidymodels" rel="noopener ugc nofollow" target="_blank">github</a>)</li></ol><p id="4ceb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章将试图描述这两个包的下一代之间的主要区别，重点是每个包使用的软件设计和对象体系结构/结构，以及它如何影响用户/从业者/开发人员的体验，不仅是对于基本的使用，而且是在为了更具体的使用而对其进行定制和修改时。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/f922f96e6df51ffbaa22be25ded1a8c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KnfchXiQ0XBxQPhglCE6TQ.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated"><a class="ae jd" href="https://leankit.com/wp-content/uploads/2013/11/Screen-Shot-2013-11-25-at-4.25.52-PM.png" rel="noopener ugc nofollow" target="_blank">https://lean kit . com/WP-content/uploads/2013/11/Screen-Shot-2013-11-25-at-4 . 25 . 52-pm . png</a></figcaption></figure><h1 id="c5f7" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><em class="lg">范围蠕变…你是在告诉我你的‘昨天的最先进的包实际上是垃圾吗？</em></h1><p id="2f2a" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">当我第一次接触mlr时，我心想，哇，这个软件包投入了多么大的精力，更不用说大量的文档，它可能会永远存在下去。在回顾中，我发现它绝对值得我花时间去学习，尽管它有不平凡的“方言”，这不同于我已经习惯的老朋友“caret”包。</p><p id="cf71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，在一个阳光灿烂的日子，我惊讶地发现，mlr的开发人员实际上不再满足于他们当前的mlr版本，并且已经在开发一个新的包mlr3，它主要由R6组成，这是一个面向对象类的高级系统，远远超出了我的舒适区。</p><p id="c35d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最初的担忧是:我和mlr的恋情就此结束了吗？我不仅要应对机器学习本身的复杂性挑战，还要在其上添加一个我一无所知的复杂的R6类结构，我该如何应对呢？</p><p id="9704" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是在处理了一段时间这个可怕的消息后，一个新的认识出现了…如果R6值得mlr3的开发者以如此激烈的方式学习曲线，以至于他们将放弃他们以前在mlr上的全部努力，并且永远不回头，它一定有一些功能给它一些优势…也许是时候我也从它的优势中受益了。</p><p id="e9ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要理解错了！我一直想学习和使用R6，尽管我已经是面向对象类的S4系统的超级粉丝。然而，也许它太方便了，无法无缝地受益于它运行在许多复杂的软件包(tidyverse和许多其他软件包)的背面，这使我无法潜入一个新的未知的R6世界。</p><p id="b3cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然mlr3仍在开发中，但我认为至少我可以赢得一些时间，直到它正式成熟为稳定版本，这样我就不必经历痛苦的成长时间，如果mlr不再被维护，我可以随时回到caret。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lm"><img src="../Images/668486a84faed9d58aa60fda43566c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uyBDtjO6G6KJHKma4bh_GA.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">拍摄者:雅各布·里克特<a class="ae jd" href="https://twitter.com/jak0br/status/1281711302340227072" rel="noopener ugc nofollow" target="_blank">https://twitter.com/jak0br/status/1281711302340227072</a></figcaption></figure><p id="db70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是mlr并不是唯一被其开发者抛弃的……caret正经历类似的<a class="ae jd" rel="noopener" href="/free-code-camp/scope-creep-and-other-software-design-lessons-learned-the-hard-way-edacf021965b">范围蔓延</a>问题。但是，在caret的案例中，它的开发人员已经与<a class="ae jd" href="https://rstudio.com/" rel="noopener ugc nofollow" target="_blank"> RStudio </a>的专家联手，完成了<a class="ae jd" href="https://www.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> tidyverse </a>框架中缺失的环节，并发布了以“<a class="ae jd" href="https://github.com/tidymodels/tidymodels" rel="noopener ugc nofollow" target="_blank"> tidymodels </a>为总括术语的软件包集合，包括:</p><ul class=""><li id="6220" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ln jk jl jm bi translated"><a class="ae jd" href="https://tidymodels.github.io/rsample/" rel="noopener ugc nofollow" target="_blank"> rsample </a>和数据预处理方法(转换、保持采样等)。</li><li id="dcc3" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ln jk jl jm bi translated"><a class="ae jd" href="https://tidymodels.github.io/parsnip/" rel="noopener ugc nofollow" target="_blank">欧洲防风草</a>，用于模型创建</li><li id="1b5a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ln jk jl jm bi translated"><a class="ae jd" href="https://tidymodels.github.io/yardstick/" rel="noopener ugc nofollow" target="_blank">标尺</a>，用于测量模型性能</li></ul><p id="3e62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Tidymodels的设计利用了tidyverse方法，一种成熟流行的直观方法，以及大量有用的文档和插图。作为tidyverse的狂热用户，我不能期望更多。</p><h1 id="d7ff" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><em class="lg">关于内聚机… </em></h1><p id="b700" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">我的<a class="ae jd" href="https://towardsdatascience.com/meta-machine-learning-packages-in-r-c3e869b53ed6" rel="noopener" target="_blank">上一篇文章</a>讨论了设计这种‘元’工具的主要挑战，其中，也许最具挑战性的是整个系统的内聚性，也就是说，当你在处理特定的功能时，如何处理它而不意外地伤害其他微妙的组件，这些组件期望修补组件具有非常特定的行为/结构。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es lo"><img src="../Images/0b1892af8853ddf3980ea88c427e685c.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/1*ohexducQF5QpmK718j-CAA.gif"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated"><a class="ae jd" href="https://oip.manual.canon/" rel="noopener ugc nofollow" target="_blank">https://oip.manual.canon/</a></figcaption></figure><p id="e9af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你有没有尝试过修理或排除大型复印机的故障，这种复印机可以做任何事情，从双面打印、装订，甚至可能是一杯奶昔，但要加两勺糖？在这样一个紧密的系统中有这么多微妙的部分？去想想。然而，当发生意外卡纸时，您下一步要做什么？你怎么能找出故障的确切位置呢？在诊断出问题的根源之前，您是否希望取出每一部分？</p><p id="5f46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">唉，不用担心！请放心，您甚至不需要呼叫技术人员！复印机是如此智能，它会自动告诉你在哪里寻找可能的问题，所以你不需要把它一部分一部分地拆开。详细的说明仔细地告诉你按哪个门/夹子，打开另一个可能卡纸的隐藏抽屉。瞧。修好了。剩下要做的就是关门了。机器自动运行快速自检，并为下一项任务做好准备。</p><p id="b553" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多么神奇优雅的机器。我们不需要担心凌乱的墨水，破坏性的激光束射遍。相反，所有的魔法都是在复印机内部完成的。机器里发生的事情只能留在机器里。所有用户关心的是得到有组织的，干净的，装箱的打印输出。</p><h1 id="4edf" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><em class="lg">那么为什么要面向对象呢？物体中发生的事，留在物体中！</em></h1><p id="77bb" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">对我来说，面向对象的系统是一个受约束的受限类，它把其他东西(属性、函数/方法)包装在里面，所以东西只放在它们应该放的地方，而不是全部。是的，处理这样的约束是很痛苦的，但是从软件设计的角度来看，它们被故意设计成恼人的“不可打破的”,唯一的目的是把我们从自己的混乱中拯救出来！</p><p id="8316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">S3和S4是面向对象类的通用系统，而S4是一个更受限制的系统，支持多重调度。在我之前的<a class="ae jd" rel="noopener" href="/@drorberel/bioconductor-s4-classes-for-high-throughput-omic-data-fd6c304d569b">系列文章</a>中，我<a class="ae jd" rel="noopener" href="/@drorberel/meta-analysis-of-multiple-multi-omic-oy-vey-a45a9533e68d">描述了</a>生物导体开发人员如何利用S4系统，通过先进的统计方法，满足他们分析大型数据集的复杂需求。虽然caret和mlr不支持Bioconductor流行的S4基因组分析数据汇总实验类的非扁平结构，但有Bioconductor软件包尝试做与caret和mlr类似的事情，即围绕汇总实验对象统一多变量模型。另一种方法是由<a class="ae jd" href="https://drorberel.github.io/Bioc2mlr/" rel="noopener ugc nofollow" target="_blank">的Bioc2mlr包</a>，走另一条路，将S4对象展平成mlr和caret期望的标准宽数据帧格式，但代价是失去/打破了将多个插槽相互捆绑在一起的紧密结。</p><h1 id="cf03" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><em class="lg">为什么是R6？自我分配、目标节俭法:</em></h1><p id="9844" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">在我自己的经验中，我学到了一个艰难的方法，即一个人在代码中管理的对象越少，需要处理的混乱和认知负担就越少，或者更简单地说，当事情不按预期进行时，寻找bug的地方就越少。</p><p id="ff07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照这种节约对象的方法，我非常喜欢使用管道操作符%&gt;%，我发现这有助于减少对象的代码。然而%&lt;&gt;%‘self-assignment’操作符甚至做得更多，它为我们节省了两次使用对象的冗余:第一次作为起始类，第二次作为目的类，分配新修改的内容。</p><p id="17c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">R6系统支持对象状态改变和引用语义的优雅方式。这意味着，你甚至不需要一个任务。你需要做的就是调用对象上的方法(函数)。它将自动用函数创建的新内容更新对象中的指定槽。瞧。这可能需要一段时间来适应，但是一旦你习惯了，传统的带有赋值的代码会突然变得冗余、重复、混乱和不优雅。</p><p id="3d1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优雅当然是个人的品味，但对我来说，它意味着更强大，更“脆弱”的代码。它可能仍然会中断，但是因为一开始就非常严格，所以您将确切地知道从哪里开始在对象的机制中探索问题的原因，并且一旦找到，如何以安全的方式在本地修复它，而不会意外地损坏代码的其他相关部分。</p><p id="ebcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在你已经知道我是面向对象类的狂热爱好者，所以我在下面的部分可能会有严重的偏见:)，所以回到ML…</p><h1 id="d6b8" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><em class="lg">优秀的老式汽油发动机vs奇特的电动发动机……</em></h1><p id="3723" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">你开电动车吗？我还不知道，但我所知道的是它更可靠，当它坏了时，传统的机械师可能没有工具打开它并修理它。他们可能会得到故障代码的非常详细的日志信息，但他们甚至没有工具来打开电动发动机罩。相反，你可能需要把它送到专门从事这种新的先进技术的专门商店，他们将有工具来快速诊断它，找到问题，并修复它。</p><p id="fbf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，我的朋友，这可能也是比较这两种重构ML方法的情况。</p><h1 id="426c" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">相似之处:</strong></h1><p id="4367" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">一方面，mlr3和tidymodels共享相同的多变量模型、重采样等算法，并且可能实现非常相似的模型性能(精度)。在可伸缩性方面也可能存在差异，这超出了本文的范围。</p><h1 id="af19" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">不同点:</strong></h1><p id="729c" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">对我来说，有3个主要的关键区别，前两个直接来源于R6类的架构:</p><ol class=""><li id="721b" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj">有一个隔离的、紧凑的、分离的“空间”,用于ML分析(mlr3)和传统的R函数，它们做一些事情，并在这个结构或另一个结构中返回一个结果(tidymodels)。</strong></li></ol><p id="562f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我只是发现，当专门的任务在指定的空间中完成时，它会更优雅(即稳定、一致、不那么脆弱)，它会仔细监控并只关心什么会进入，什么会被排出。仅此而已。</p><p id="832a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于许多用户来说，mlr3 R6可能不是微不足道的，但对于欣赏这种严格分类的人来说，它就是天堂。tidymodels将让许多其他人对传统的R S3系统感到满意，该系统也受益于简单运行函数的灵活性，而不必太担心边缘场景，只有当您一直调整它到其边界时，它才会意外中断函数。对于许多用户来说，他们可能永远不会接近这些界限，所以为什么要担心呢。</p><p id="b2a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。当我需要以最安全的方式为新的特定需求进行定制时，自己连接电线。</strong></p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lp"><img src="../Images/0af34c0068a10456b18451ae92e5032d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dm-kGiNQR-6dG05q10fh3w.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated"><a class="ae jd" href="https://www.syfy.com/" rel="noopener ugc nofollow" target="_blank">https://www.syfy.com/</a></figcaption></figure><p id="90d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经久耐用的好包装设计范围非常广。足够让开发人员演示如何定制软件包的主要功能。在ML环境中，定制和添加新的多元模型(学习者)、新的性能指标、新的转换等。mlr3和tidymodels在文档(向您展示如何从头添加新方法的教程)和严格约束(在某种程度上)方面都做得很好。</p><p id="7030" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，mlr3的R6约束可能比tidymodels实施的约束更严格，当您将它与ML方法的其他部分结合在一起时，tidy models会扩展。换句话说，在这样一个集成了重采样+调优+基准测试+的强大多功能管道中，即使是一点点锡(例如，预测向量中不应该出现的NAs)以某种方式卡在轮子中，也可能导致副作用，从而损坏整个机器。这种情况发生的可能性有多大？也许它永远不会发生，但是最小化这种可能性的最佳实践是使用一个更受限制的系统。</p><p id="424d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就我的运气而言，(嗯，我确实喜欢将这种方法发挥到极限)，它确实偶尔会发生，当它发生时，花费宝贵的时间去寻找错误的原因一点也不好玩。你可能根本不在乎，但有些人在乎。</p><p id="1081" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。预处理:定制新的可组合(monad)转换</strong></p><p id="a910" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我在<a class="ae jd" href="https://towardsdatascience.com/meta-machine-learning-packages-in-r-c3e869b53ed6" rel="noopener" target="_blank">的上一篇文章</a>中提到的，预处理的棘手部分是保证无论在训练数据集上应用哪种变换，都应该在测试数据集上应用。当需要传递保存转换细节的参数时，这不是一个简单的任务。这两个包都支持monad编程，这意味着允许以任何顺序组合不同的转换，同时保证“管道”之间的兼容性。</p><p id="3976" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更重要的任务是编写您自己定制的预处理转换。尽管'<a class="ae jd" href="https://tidymodels.github.io/recipes/articles/Custom_Steps.html" rel="noopener ugc nofollow" target="_blank">配方</a> s '和'<a class="ae jd" href="https://mlr3book.mlr-org.com/extending-mlr3pipelines.html" rel="noopener ugc nofollow" target="_blank">MLR 3管道</a>都有大量的文档，但这一点并不简单。总的来说，这两种方法具有相似的功能，但是，每种方法都有自己的术语和行话，可能需要一些时间来适应。</p><p id="85a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。生存和无监督模型</strong></p><p id="0aee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前由mlr3支持，但似乎tidymodels开发人员也计划添加它。</p><p id="cb3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 5。你能给我看看代码吗？</strong></p><p id="2171" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://mlr3pipelines.mlr-org.com/articles/comparison_mlr3pipelines_mlr_sklearn.html" rel="noopener ugc nofollow" target="_blank">https://mlr3 pipelines . MLR-org . com/articles/comparison _ MLR 3 pipelines _ MLR _ sk learn . html</a>在MLR 3和tidymodels(以及其他)之间有很好的代码对比。</p><h1 id="de84" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><em class="lg">视觉:</em></h1><p id="7631" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">与我在上一篇文章中的观点相似，真正重要的是让用户对文档感到舒服，并能获得可靠的支持渠道。我还设想开发从一个包到另一个包的“转换器”功能，至少是为了转换。不管上面的差异，丰富的转换库集合是两种方法的共同兴趣。</p><p id="a1f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于某种原因，我并不完全清楚，这两种方法都没有为'<a class="ae jd" href="https://christophm.github.io/interpretable-ml-book/" rel="noopener ugc nofollow" target="_blank">可解释的模型不可知的</a>工具提供指定的包/功能，例如<a class="ae jd" href="https://lime.data-imaginist.com/" rel="noopener ugc nofollow" target="_blank"> LIME </a>、<a class="ae jd" href="https://modeloriented.github.io/DALEX/" rel="noopener ugc nofollow" target="_blank"> DALEX </a>和<a class="ae jd" href="https://cran.r-project.org/web/packages/iml/vignettes/intro.html" rel="noopener ugc nofollow" target="_blank"> iml </a>(等等)。对我来说，这些后ML工具似乎是对通用ML框架的补充，尽管提到的一些包可能已经支持它们了</p><h1 id="5950" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><em class="lg">底线</em>:</h1><ol class=""><li id="1fcc" class="je jf hi ih b ii lh im li iq lq iu lr iy ls jc jj jk jl jm bi translated"><strong class="ih hj">尊重好的老的弃用包。在你掌握它们之前，不要跳到下一级！</strong></li></ol><p id="2c62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我首先鼓励新的ML从业者使用caret和mlr的废弃版本，这样您就可以熟悉常见机器学习组件的基本术语、范围和功能。</p><p id="f25e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只有这样，当你对分类、回归、特征工程、模型参数调整、交叉验证、集成、基准测试和其他术语感到舒适时，才可以逐步前进，进入下一个阶段。</p><p id="c5ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。如果你不必把它变得复杂，简单就好。</strong></p><p id="4108" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很多从业者大概连我上面说的区别都不会在意。在这种情况下，tidymodels可能是首选。它简单、直截了当、有良好的文档记录并且受到支持。</p><p id="df10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。你不是一直想学习R6，但从来没有足够的动力这样做吗？</strong></p><p id="2d4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要错过这个机会，否则就留下来。</p><p id="c291" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。当事情发生时… </strong></p><p id="d43e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于其他喜欢修补和扩展工具范围的人来说，对包对象结构和后端发生的实际机制的关注可能更重要。</p><p id="3e50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一天结束时，即使今天最先进的工具也是明天被弃用的废弃包，但活在当下，在目前，一个人应该赌上最稳定的解决方案，那是不太可能打破的。</p><p id="9d74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么会破？如果它不会破裂，就根本没有必要写这个帖子。</p><h1 id="1bca" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">免责声明</strong>:</h1><p id="da41" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">除了软件包<a class="ae jd" href="https://drorberel.github.io/Bioc2mlr/" rel="noopener ugc nofollow" target="_blank"> Bioc2mlr </a>之外，作者不属于开发上述软件包的任何团体。</p><p id="10c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重构为<a class="ae jd" href="https://tlverse.org/" rel="noopener ugc nofollow" target="_blank">的超级学习者呢？</a>顺便说一下，R6也是这样做的。我不知道。也许在未来的博客里。然而，我想说的是，它背后的开发团队的学术兴趣主要是受激励的，并倾向于基于目标最大似然/最小损失的估计(TMLE)，这是一种参数估计的统计方法，而不是其他两个可能更面向“工程”的软件包。最近有一个关于它的很棒的文档<a class="ae jd" href="https://tlverse.org/tlverse-handbook/" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="d8af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有趣的事实:mlr3从不提及p值。甚至不确定那是不是故意的。</p><p id="97b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我是不是忘了这篇(半偏)评论中的一个关键人物？如果是这样，请告诉我。如果我没有好的理由排除它，我不介意添加它。</p><p id="6ec4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看我的<a class="ae jd" rel="noopener" href="/@drorberel">博客</a>和<a class="ae jd" href="https://drorberel.github.io/" rel="noopener ugc nofollow" target="_blank"> github页面</a>了解更多有趣的东西。</p><p id="2ebf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="http://Dror.Berel@gmail.com" rel="noopener ugc nofollow" target="_blank">Dror.Berel@gmail.com</a></p><p id="f377" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://www.linkedin.com/in/dror-berel-1848496/" rel="noopener ugc nofollow" target="_blank"> LinkedIn个人资料</a></p></div></div>    
</body>
</html>