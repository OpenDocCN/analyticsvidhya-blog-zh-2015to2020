<html>
<head>
<title>Artificial Neural Networks, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工神经网络，第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/artificial-neural-networks-part-1-d36fb7bce6bb?source=collection_archive---------34-----------------------#2020-05-17">https://medium.com/analytics-vidhya/artificial-neural-networks-part-1-d36fb7bce6bb?source=collection_archive---------34-----------------------#2020-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4242978a4afa6ddf318c600e060ab91d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X5KOXlLAdT9FmA5W"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@hikeshaw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> H肖</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="6a5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章是一系列文章中的第一篇，我将试着解释ann或人工神经网络背后的概念。</p><p id="910f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将从一个简单的感知器模型开始，在不涉及大量数学知识的情况下，尝试理解其背后的直觉。</p><p id="d688" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当我们听到或读到人工神经网络或人工神经网络时，脑海中出现的最恰当的类比就是我们大脑中的神经元。神经元由大量进出执行所需操作的中央节点的连接组成。参考下图中来自<a class="ae iu" href="https://en.wikipedia.org/wiki/Neuron" rel="noopener ugc nofollow" target="_blank">维基百科</a>的一个神经元。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/a57e987161c5b764b161954d6250ea60.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/0*oP6ol14f0HVW1cxJ"/></div></div></figure><p id="165d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上图中，我们可以看到细胞核的许多输入源，它执行大多数信号处理，并将输出传递给下一个神经元或最终目的地。</p><p id="3d63" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">单层感知器</strong></p><p id="4c72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似地，在人工神经网络中，我们有输入，执行计算和输出的核心或节点。为了以最简单的形式表示人工神经网络，请考虑下图。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/9c41923c8ff64d06bfd6183c746c2630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/0*P5oiq3L7-VaaqbPc"/></div></figure><p id="881a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在图中，我们可以看到有两个输入进入节点。<strong class="ix hj">节点</strong>是处理过程发生的地方，很像神经元的细胞核。这个模型在这里被称为简单感知器，我们只有一层处理。这里<em class="jz"> f(X) </em>是应用于输入以获得期望输出的函数。</p><p id="477d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了神经网络，据说应用范围很广，真的很会学习。为了实现这一点，需要调整各种各样的参数，直到找到解决方案。该参数称为<strong class="ix hj">重量(w) </strong>。</p><p id="3f01" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">权重定义了输入的重要性以及它对总输出的贡献。如果权重很低，这意味着输入不重要，而如果权重很高，则输入对处理的影响很大。可能会有这样的情况，权重变成0，在这种情况下，无论输入的值是多少，都没有关系。它将永远被忽视。为了缓解这个问题，我们添加了一个<strong class="ix hj">偏差项(b) </strong>，它可以是正值，也可以是负值。这使得权重值和输入有意义，并且反过来，只有当它们高于偏差项时，节点才有意义。</p><p id="6e21" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该节点接收带有偏置项的输入的加权和，并应用函数<em class="jz"> f </em>来获得期望的结果。重要的是要记住，计算是两个向量W和x的乘法。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/5b7c685c9ac51bebb63b6462bd3a8575.png" data-original-src="https://miro.medium.com/v2/resize:fit:214/format:webp/0*60UgNqKIz_2x4jC8.png"/></div></figure><p id="ead6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，I是输入数，X是输入值，W是与输入相关的权重，b是在节点处添加的偏差。</p><p id="dc97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">多层感知器</strong></p><p id="0569" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多层感知器由多个单层感知器连接在一起形成网络。这里，一个节点的输出成为下一层节点的输入。所有节点执行计算，并将输出发送到输出层。</p><p id="4a83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑下图</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kb"><img src="../Images/733882c3af6afc5e861082722408d01d.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/0*b4QmJqx1CIhiZQwC"/></div></figure><p id="fce7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里第一层被称为输入层，数据点在这里传递。在这一层中，不执行任何计算。分别具有四个、四个和三个节点的第二、第三和第四层被称为隐藏层，因为其复杂性使得它们难以解释。</p><p id="6470" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一层称为输出层。在上面的例子中，我们只有一个输出节点，然而，它可以是两个或更多，这取决于我们试图使用网络解决的问题的类型。</p><p id="1a89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据我们正在解决的问题的类型，对我们在网络中的每个节点上使用的函数的输出进行约束是很重要的。例如，在一个分类问题中，我们希望得到0和1之间的输出，这样它就可以被解释为一个概率。这些约束通过使用<strong class="ix hj">激活功能</strong>来应用。这里的激活指的是下一层中节点的开/关或重要性。它根据我们正在解决的问题类型，在所需的限制内转换输出。</p><p id="3d48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们无需任何数学知识就能理解一个简单的多层神经网络意味着什么和如何操作。不同的组件，如节点、权重、偏置、输入和输出层，以及为什么需要激活函数。</p><p id="7112" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有相当多的激活功能可以使用。在我们进一步讨论之前，让我们重温一下这个等式，用字母z表示。因此，</p><p id="a094" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Z = w*X + b</p><p id="c4ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们来看看最常用的-</p><ul class=""><li id="7f2a" class="kc kd hi ix b iy iz jc jd jg ke jk kf jo kg js kh ki kj kk bi translated"><strong class="ix hj">阶跃函数</strong> —这是可以使用的最简单的函数。它以0或1的形式给出值。如果Z &gt;为0，则1否则为0。这样做的问题是，它是一个非常强大的函数，输出不能用于概率，它不能帮助多值输出。</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/3f69c06d5605adae9108bf88e68994ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/0*Yn7yJu8J3HpbQ8Fx"/></div></figure><ul class=""><li id="575d" class="kc kd hi ix b iy iz jc jd jg ke jk kf jo kg js kh ki kj kk bi translated"><strong class="ix hj"> Sigmoid函数</strong> —如果你了解逻辑回归，这是相对熟悉的。输出介于0和1之间，可用作一个类别在分类方面优于其他类别的概率。Sigmoid函数的问题是，当X的值变得很高或很低，并且预测没有变化时，它会导致网络停止学习或变得非常慢。这就是所谓的渐变消失问题。</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es km"><img src="../Images/be31df133cd6250b86f1a698b97e715d.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*SwmuWz8C_iZwa6lK.png"/></div></figure><ul class=""><li id="022e" class="kc kd hi ix b iy iz jc jd jg ke jk kf jo kg js kh ki kj kk bi translated"><strong class="ix hj"> tanh()或双曲正切</strong> —使用sigmoid函数的问题是，当我们传递一个负值时，输出接近零，这对于计算其他参数来说不是很好。为了克服这个问题，我们可以利用tanh()函数返回-1和1之间的值。当向tanh()提供负值时，它将输出返回负值，只有接近零的值被映射为零。Tanh也遭受类似sigmoid函数的消失梯度的相同问题。</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="ab fe cl kn"><img src="../Images/e6d1ac3208807075e228e031a17644b8.png" data-original-src="https://miro.medium.com/v2/0*bTlWeQpoc3LiWx-i"/></div></figure><ul class=""><li id="cb36" class="kc kd hi ix b iy iz jc jd jg ke jk kf jo kg js kh ki kj kk bi translated"><strong class="ix hj"> ReLu或整流线性单元</strong> —这通常是默认激活功能。如果输出大于0，则返回Z值，否则返回0。所以基本上就是max(0，Z)。这是最常用的，因为它允许网络更快地收敛，也允许反向传播。从下图可以明显看出，当值为0或负值时，输出变为0，网络无法进一步学习。</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/cbb1b5e00c7b305d7efde86a511c100f.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/0*zVy_CtSX0oy7j7Te"/></div></figure><ul class=""><li id="e61a" class="kc kd hi ix b iy iz jc jd jg ke jk kf jo kg js kh ki kj kk bi translated"><strong class="ix hj"> Softmax( ) </strong> —这是我们在处理多类分类问题时广泛使用的函数，其中每个数据点有一个类。这也称为互斥类。它计算一个类相对于所有其他类的概率。所有概率之和总是1。例如，如果我们有5个输出类，这5个类中的每一个都有一个概率输出，我们选择概率最高的一个作为结果。</li></ul><p id="d6c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们简要介绍了神经网络和相关组件，如节点、权重、偏置、激活函数，并简单解释了为什么需要它们。在本系列的下一部分，我们将回顾梯度下降的概念。</p><p id="c48b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" rel="noopener" href="/@saketchaturvedi13/understanding-gradient-descent-without-the-math-bc31a4781c88">第2部分——了解梯度下降(不含数学知识)</a></p></div></div>    
</body>
</html>