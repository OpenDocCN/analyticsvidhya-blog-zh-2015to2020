<html>
<head>
<title>A Practical Guide to Azure Durable Functions — Part 3: Configurations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure持久功能实用指南——第3部分:配置</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-practical-guide-to-azure-durable-functions-part-3-configurations-6baa1b49f532?source=collection_archive---------2-----------------------#2020-06-05">https://medium.com/analytics-vidhya/a-practical-guide-to-azure-durable-functions-part-3-configurations-6baa1b49f532?source=collection_archive---------2-----------------------#2020-06-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/5853bc51e5a94bb5e51a06ed3432c91b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALS6Yowowy9FmOQXnYrTcA.png"/></div></div></figure><div class=""/><div class=""><h2 id="7c05" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">通过Azure Durable Functions创建生产就绪功能应用程序所需的一切。</h2></div><p id="8e07" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果你不熟悉Azure，或者你想探索Azure持久函数的DI选项，你可能想先阅读该系列的前一个故事。</p><div class="hh hi ez fb hj ke"><a rel="noopener follow" target="_blank" href="/@allen.zhang1983713/a-practical-guide-to-azure-durable-functions-part-2-dependency-injection-facadc8238af"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hu fi z dy kj ea eb kk ed ef hs bi translated">Azure持久函数实用指南—第2部分:依赖注入</h2><div class="kl l"><h3 class="bd b fi z dy kj ea eb kk ed ef dx translated">通过Azure Durable Functions创建生产就绪功能应用程序所需的一切。</h3></div><div class="km l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">medium.com</p></div></div><div class="kn l"><div class="ko l kp kq kr kn ks hp ke"/></div></div></a></div><p id="afcf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在这个故事中，我们将逐步改进我们的应用程序，以演示设置Azure Function应用程序配置的各种方法。</p><p id="16a3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最后，我们的目标是配置我们的功能应用程序，以便从完全托管的配置存储中检索应用程序设置，并保护所有敏感信息。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="96ac" class="la lb ht bd lc ld le lf lg lh li lj lk iz ll ja lm jc ln jd lo jf lp jg lq lr bi translated">配置管理器</h1><p id="f405" class="pw-post-body-paragraph ji jj ht jk b jl ls iu jn jo lt ix jq jr lu jt ju jv lv jx jy jz lw kb kc kd hb bi translated">首先，我想将配置管理器添加到项目中，以便它不再直接从环境变量中读取配置。这个想法是配置消费者类不需要知道配置值来自哪里。</p><p id="576e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在前面的故事中，我们已经将自己的Startup.cs文件添加到Azure Function项目中，以注册依赖注入。现在我们也可以在启动类中设置配置。</p><figure class="lx ly lz ma fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="d18f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">重要的一行是AddEnvironmentVariables()。它添加一个环境变量配置提供程序。我们现在可以将IConfiguration的一个实例注入到任何类中，并轻松地获得配置项。</p><p id="89bc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这也为我们提供了一个坚实的基础。随着应用的发展，我们可能会引入其他配置提供者。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="f0f1" class="la lb ht bd lc ld le lf lg lh li lj lk iz ll ja lm jc ln jd lo jf lp jg lq lr bi translated">强类型配置</h1><p id="cdbf" class="pw-post-body-paragraph ji jj ht jk b jl ls iu jn jo lt ix jq jr lu jt ju jv lv jx jy jz lw kb kc kd hb bi translated">我真正想解决的另一个小问题是硬编码的基本URL。让我们把它也移到配置中。但是三行“GitHubXXX”就是看起来很可怕。</p><p id="05a6" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">那很好。我们只需要将GitHub API相关的配置组合在一起。这应该很容易，因为C#支持强类型配置对象。</p><h2 id="1eff" class="md lb ht bd lc me mf mg lg mh mi mj lk jr mk ml lm jv mm mn lo jz mo mp lq mq bi translated">配置文件</h2><p id="0202" class="pw-post-body-paragraph ji jj ht jk b jl ls iu jn jo lt ix jq jr lu jt ju jv lv jx jy jz lw kb kc kd hb bi translated">在. NET核心web应用程序中，有appsettings。{环境}。json文件。从json对象加载强类型配置部分非常容易。我能在local.settings.json文件中做同样的事情吗？</p><p id="41ba" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们甚至不必试一试——如果你愿意，你可以试一试。我们知道这是行不通的，因为local.settings.json文件中的“Values”部分模拟了环境变量。它真的应该只包含键值对。</p><p id="705c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我不是很想带appsettings。{环境}。json文件到函数应用程序中(尽管这是可能的)。因为local.settings.json涵盖了本地开发。管道的工作是为不同的环境设置正确的应用程序设置。我不想在配置文件中管理它。</p><p id="7778" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我还有其他选择吗？</p><h2 id="03b2" class="md lb ht bd lc me mf mg lg mh mi mj lk jr mk ml lm jv mm mn lo jz mo mp lq mq bi translated">Azure应用配置服务</h2><p id="6e22" class="pw-post-body-paragraph ji jj ht jk b jl ls iu jn jo lt ix jq jr lu jt ju jv lv jx jy jz lw kb kc kd hb bi translated">微软在2020年初推出了云完全托管配置存储<strong class="jk hu">应用配置</strong>服务。</p><p id="2e3c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">有了这项服务，您可以轻松地在所有云服务之间配置和共享配置项目。它支持在函数应用程序中使用强类型配置对象。</p><blockquote class="mr ms mt"><p id="c0e7" class="ji jj mu jk b jl jm iu jn jo jp ix jq mv js jt ju mw jw jx jy mx ka kb kc kd hb bi translated">一石二鸟。</p></blockquote><p id="0077" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在浏览器选项卡上打开Azure门户，创建一个新的<strong class="jk hu">应用配置</strong>资源。按照用户界面上的步骤操作。唯一需要注意的是，你可能想要选择<strong class="jk hu">免费</strong>价格等级。</p><p id="9d4e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">创建好服务后，直接转到服务。点击<strong class="jk hu">访问键</strong>并将<strong class="jk hu">连接字符串</strong>值保存在某处。然后点击<strong class="jk hu">配置浏览器</strong>并创建一些键值配置项。您需要为<strong class="jk hu">您的用户名</strong>和<strong class="jk hu">您的个人访问令牌</strong>输入您的真实值。</p><ul class=""><li id="9add" class="my mz ht jk b jl jm jo jp jr na jv nb jz nc kd nd ne nf ng bi translated">" GitHub:base URL ":" https://API . GitHub . com "</li><li id="a02f" class="my mz ht jk b jl nh jo ni jr nj jv nk jz nl kd nd ne nf ng bi translated">" GitHub:用户名":"您的用户名"</li><li id="0b2f" class="my mz ht jk b jl nh jo ni jr nj jv nk jz nl kd nd ne nf ng bi translated">" GitHub:密码":"您的个人访问令牌"</li></ul><figure class="lx ly lz ma fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nm"><img src="../Images/ab4f225cd3a27b43b3251d5cadf6c244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qEgD1y3ucJMYW7AsEfCxlA.png"/></div></div></figure><p id="0836" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是扁平化的json格式。复杂json对象格式中的上述设置如下所示:</p><pre class="lx ly lz ma fd nn no np nq aw nr bi"><span id="b283" class="md lb ht no b fi ns nt l nu nv">{<br/>  "GitHub": {<br/>    "BaseUrl": "https://api.github.com",<br/>    "Username": "YourUsername",<br/>    "Password": "YourPersonalAccessToken"<br/>  }<br/>}</span></pre><p id="930e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">更新local.settings.json文件。我们现在需要的唯一配置是应用配置服务连接字符串。如果您想在本地运行应用程序，请使用您之前保存的实际值。</p><figure class="lx ly lz ma fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="7c5d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">添加<strong class="jk hu">微软。extensions . configuration . azureappconfiguration</strong>将包获取到项目中。我们将在启动类中添加应用配置服务作为配置提供程序。</p><figure class="lx ly lz ma fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="b39d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="mu">对启动类中现有配置提供程序的额外处理并不理想。但它可以让你在本地运行功能应用程序。你不需要在一个普通的。NET核心项目。</em></p><p id="cc63" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="mu">目前(2020年6月5日),对ConfigurationBuilder的任何更改都会导致已部署功能应用程序出现运行时问题。但是微软正在解决这个问题(跟踪投票请求</em> <a class="ae nw" href="https://github.com/Azure/azure-functions-host/pull/5991" rel="noopener ugc nofollow" target="_blank"> <em class="mu">这里</em> </a> <em class="mu">)。一旦补丁发布，我将再次讨论这个问题。</em></p><p id="4a30" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">通过options模式更新服务类的构造函数以使用强类型配置。</p><figure class="lx ly lz ma fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="3878" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">有了正确的应用程序配置服务连接字符串，当我在本地运行这个函数应用程序时，GitHub API相关的配置值被填充了我之前在Azure门户上设置的值。</p><figure class="lx ly lz ma fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nx"><img src="../Images/f6831c15c4a44662845c820d6d7efa34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRaPANASkogpB5HboSztyw.png"/></div></div></figure><p id="a885" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在我们可以更新管道，只将<strong class="jk hu">AppConfigurationConnectionString</strong>变量传递给Azure Function App。不要忘记更新AzureFunctionApp任务。</p><pre class="lx ly lz ma fd nn no np nq aw nr bi"><span id="c3c2" class="md lb ht no b fi ns nt l nu nv"><strong class="no hu">Note</strong>: in a real app, you want to make sure an appropriate connection string value is set in the pipeline for different environments: dev, test, prod, etc. But it beyonds the scope of this story.</span></pre></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="b454" class="la lb ht bd lc ld le lf lg lh li lj lk iz ll ja lm jc ln jd lo jf lp jg lq lr bi translated">保护敏感配置</h1><p id="1d4d" class="pw-post-body-paragraph ji jj ht jk b jl ls iu jn jo lt ix jq jr lu jt ju jv lv jx jy jz lw kb kc kd hb bi translated">功能app的配置解决方案改进了很多。但是还有一个问题。将所有敏感数据(包括所有密码、证书和数据库连接字符串)存储在秘密存储中以保护它们是一种良好的安全做法。</p><p id="c9eb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">Azure <strong class="jk hu"> Key Vault </strong>服务是一个完全托管的基于云的秘密存储服务。</p><p id="5be4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我知道。NET Core有一个密钥库配置提供程序。事实上，如果你不想使用托管应用配置服务，因为它不是免费的。直接在项目中添加密钥库配置提供程序是一个不错的选择。</p><p id="c589" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">但是，当我们之前在应用配置服务上创建配置时，您可能已经注意到有一个添加密钥存储库引用的选项。</p><figure class="lx ly lz ma fd hk er es paragraph-image"><div class="er es ny"><img src="../Images/f04c5a228f1592776bde4a597e733e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*scumAQgUNv62kZmz1W5S0g.png"/></div></figure><p id="2a28" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们试一试。</p><p id="0550" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">首先，在Azure门户上创建一个<strong class="jk hu">密钥库</strong>服务。标准价格层就足够了。</p><p id="10eb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">创建资源后，转到该资源并点击<strong class="jk hu">访问策略</strong>。应该只有一个访问策略显示您的Azure用户拥有对所有机密的完全访问权限。</p><p id="b09d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">点击<strong class="jk hu">秘密</strong>并生成一个新的秘密<strong class="jk hu"> GitPassword </strong>。你可以在这里输入你的真实价值。您的个人访问令牌在密钥库中是安全的。</p><figure class="lx ly lz ma fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nz"><img src="../Images/769ab87edb4972674bd482334db2893a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iqcWl62LytZEJJHvRDZxA.png"/></div></div></figure><p id="93e1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">导航到应用程序配置服务并点击<strong class="jk hu">配置浏览器</strong>。删除之前创建的<strong class="jk hu"> GitHub:Password </strong>配置项，并将其重新创建为密钥库引用。把它和之前在密钥库中创建的秘密联系起来。</p><figure class="lx ly lz ma fd hk er es paragraph-image"><div class="er es oa"><img src="../Images/d36778e60f479b8dff5eb0ad93f5a63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*Bj9MjTQOXtF8eS3bJWapdw.png"/></div></figure><p id="3fad" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们还需要修改代码来连接到密钥库。安装<strong class="jk hu"> Azure。identity</strong>n将包获取到项目中。在撰写本文时，1.2.0-preview.3是一个不错的选择，因为它支持通过Visual Studio登录用户进行身份验证。并在我们配置App配置服务时，在启动类中添加几行代码。</p><figure class="lx ly lz ma fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="9274" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果我们在本地运行代码，它应该还能工作。现在密码来自Azure key vault。</p><p id="0093" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">但是等等，这怎么安全？和只在App配置服务中设置密码有什么不同？</p><p id="8451" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">别担心。应用程序配置服务<strong class="jk hu">没有</strong>访问您的密钥库的权限。它在本地工作，因为<strong class="jk hu"> DefaultAzureCredential </strong>使用您的Visual Studio的<strong class="jk hu"> Azure服务验证</strong>帐户来验证密钥库服务(您可以通过在Visual Studio中转至Tools = &gt; Azure服务验证= &gt;帐户选择来查看)。如果该帐户与您的Azure登录用户帐户相同，则该帐户有权获取机密。</p><p id="4d58" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">要验证这一点，请从您的用户的密钥库访问策略中删除<strong class="jk hu">列表</strong>和<strong class="jk hu">获取</strong>权限，然后重试。</p><p id="79a3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">或者使用管道将代码更改部署到Azure。部署的功能应用程序将无法工作，因为我们尚未配置其访问策略。让我们现在就做吧。</p><p id="c245" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在Azure门户上找到功能app。点击<strong class="jk hu">识别</strong>并打开<strong class="jk hu">系统分配的</strong>身份，然后保存更改。</p><p id="24fe" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">创建身份后，找到密钥库服务，并为功能应用程序的系统分配身份添加访问策略。您可以通过功能应用程序的名称或对象id找到它。给它<strong class="jk hu">列表</strong>和<strong class="jk hu">获取</strong>权限的秘密。</p><p id="5125" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在再试试部署的功能app。现在应该可以了。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="1abb" class="la lb ht bd lc ld le lf lg lh li lj lk iz ll ja lm jc ln jd lo jf lp jg lq lr bi translated">摘要</h1><p id="2d83" class="pw-post-body-paragraph ji jj ht jk b jl ls iu jn jo lt ix jq jr lu jt ju jv lv jx jy jz lw kb kc kd hb bi translated">在这个故事的开始，我们的函数应用程序只能从环境变量中读取配置。我们必须在local.settings.json文件和具有明文的管道中将它们都设置为键值对。</p><p id="3dce" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在，它演变为在函数app本身中只有一个配置项，即app配置服务连接字符串。所有其他配置都存储在完全托管的配置存储中，敏感配置由Azure key vault保护。</p><p id="3cff" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最重要的是，它不需要存储任何凭证来访问密钥库，无论是在本地还是部署。nuget包隐藏了复杂性。</p><blockquote class="mr ms mt"><p id="35af" class="ji jj mu jk b jl jm iu jn jo jp ix jq mv js jt ju mw jw jx jy mx ka kb kc kd hb bi translated">这太棒了。向微软致敬。</p></blockquote><p id="6b51" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个故事的代码可以在我的<a class="ae nw" href="https://github.com/allenzhang83/DurableFunctionDemoConfig" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。</p><p id="4169" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在接下来的故事中，我将谈论Azure持久功能的三种不同的重试机制。其中两个是持久功能专用的。敬请期待！</p><p id="e9a3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">第4部分在此发布。</p><div class="hh hi ez fb hj ke"><a href="https://levelup.gitconnected.com/a-practical-guide-to-azure-durable-functions-part-4-retry-3b60c46067fa" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hu fi z dy kj ea eb kk ed ef hs bi translated">Azure持久功能实用指南—第4部分:重试</h2><div class="kl l"><h3 class="bd b fi z dy kj ea eb kk ed ef dx translated">通过Azure Durable Functions创建生产就绪功能应用程序所需的一切。</h3></div><div class="km l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">levelup.gitconnected.com</p></div></div><div class="kn l"><div class="ko l kp kq kr kn ks hp ke"/></div></div></a></div></div></div>    
</body>
</html>