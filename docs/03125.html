<html>
<head>
<title>Reading multiple files in Tensorflow 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Tensorflow 2中读取多个文件</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/reading-multiple-files-in-tensorflow-2-ec75c7d7c46c?source=collection_archive---------4-----------------------#2020-01-17">https://medium.com/analytics-vidhya/reading-multiple-files-in-tensorflow-2-ec75c7d7c46c?source=collection_archive---------4-----------------------#2020-01-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d041d11b1da19b34a80b79470df4df00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nGjv3VblrT5-j_oI"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">维克多·塔拉舒克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3016" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(<a class="ae iu" href="https://github.com/biswajitsahoo1111/cbm_codes_open/blob/master/notebooks/Reading_multiple_files_in_Tensorflow_2.ipynb" rel="noopener ugc nofollow" target="_blank">关于这篇文章的Jupyter笔记本可以在这里找到</a></p><p id="0b7c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本帖中，我们将使用生成器将多个<code class="du jt ju jv jw b">.csv</code>文件读入Tensorflow。但是我们将要讨论的方法足够通用，也适用于其他文件格式。我们将使用500个<code class="du jt ju jv jw b">.csv</code>文件演示该过程。这些文件是用随机数创建的。每个文件在一列中只包含1024个数字。这种方法可以很容易地扩展到包含数千个<code class="du jt ju jv jw b">.csv</code>文件的大型数据集。随着文件数量变大，我们无法将全部数据加载到内存中。所以我们必须处理大量的数据。发电机帮助我们方便地做到这一点。在这篇文章中，我们将使用自定义生成器读取多个文件。</p><p id="1b4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从读者不必从任何地方下载任何数据的意义上来说，这篇文章是自给自足的。只需按顺序运行以下代码。首先，在当前工作目录下创建一个名为“random_data”的文件夹，并在其中保存<code class="du jt ju jv jw b">.csv</code>文件。随后，将从该文件夹中读取文件并进行处理。只要确保你当前的工作目录没有一个名为“random_data”的旧文件夹。然后运行下面的代码。这个帖子的Jupyter笔记本可以在<a class="ae iu" href="https://github.com/biswajitsahoo1111/cbm_codes_open/blob/master/notebooks/Reading_multiple_files_in_Tensorflow_2.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="a114" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用<code class="du jt ju jv jw b">Tensorflow 2</code>来运行我们的深度学习模型。<code class="du jt ju jv jw b">Tensorflow</code>非常灵活。给定的任务可以用不同的方式来完成。我们将使用的方法不是唯一的。鼓励读者探索做同样事情的其他方法。下面是这篇文章中考虑的三个不同任务的概要。</p><h1 id="5add" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">大纲:</h1><ol class=""><li id="95fc" class="kv kw hi ix b iy kx jc ky jg kz jk la jo lb js lc ld le lf bi translated">创建500个<code class="du jt ju jv jw b">".csv"</code>文件，保存在当前目录下的“random_data”文件夹中。</li><li id="565d" class="kv kw hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">编写一个生成器，从文件夹中读取数据并对其进行预处理。</li><li id="0739" class="kv kw hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">将大块数据输入CNN模型，并对其进行几个时期的训练。</li></ol><h1 id="cfaf" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">1.创建500个<code class="du jt ju jv jw b">.csv</code>随机数据文件</h1><p id="e576" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">由于我们打算使用我们的数据训练CNN模型进行分类，我们将为5个不同的类别生成数据。以下是我们将遵循的流程。</p><ul class=""><li id="5980" class="kv kw hi ix b iy iz jc jd jg lo jk lp jo lq js lr ld le lf bi translated">每个<code class="du jt ju jv jw b">.csv</code>文件将有一列包含1024个条目的数据。</li><li id="20c6" class="kv kw hi ix b iy lg jc lh jg li jk lj jo lk js lr ld le lf bi translated">每个文件将使用以下名称之一保存(故障1、故障2、故障3、故障4、故障5)。数据集是平衡的，也就是说，对于每个类别，我们有大约相同数量的观察值。“故障1”类别中的数据文件的名称为“故障1_001.csv”、“故障1_002.csv”、“故障1_003.csv”、“故障1_100.csv”。其他班级也是如此。</li></ul><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="3136" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先创建一个将生成随机文件的函数。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="fb45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在使用该函数为五种故障类型创建100个文件。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/ae10398a63927cacf25d90ba6e959529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*B-pFPmMekJawogDxTqRBZg.png"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/a3b8b745bb7ee3f6f4efc51a9aac8412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*SzSSnNzw-c4IP3G7nWZjFw.png"/></div></figure><p id="5bdb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要从文件名中提取标签，请提取文件名中与故障类型相对应的部分。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/6a0704631550f1bdcd68f66963a10c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*Jr8cgQ4PIZh3d5gbkcUc7Q.png"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/820f9ec0ec5d9e0db8d76971166fa29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*DtJIbgaNOBoQNbZ9lFGpsQ.png"/></div></figure><p id="ce16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然已经创建了数据，我们将进入下一步。也就是说，定义一个生成器，将类似时间序列的数据预处理成类似矩阵的形状，以便二维CNN可以摄取它。</p><h1 id="8cf6" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">2.编写一个生成器来读取数据块并对其进行预处理</h1><p id="ac1d" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">生成器类似于函数，但有一个重要区别。函数一次产生所有的输出，而生成器一个接一个地产生输出，当被要求时也是如此。<code class="du jt ju jv jw b">yield</code>关键字将函数转换成生成器。根据内部使用的循环结构，生成器可以运行固定次数或无限期运行。对于我们的应用程序，我们将使用一个无限运行的生成器。</p><p id="7064" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的生成器将文件名列表作为第一个输入。第二个论点是<code class="du jt ju jv jw b">batch_size</code>。<code class="du jt ju jv jw b">batch_size</code>决定我们一次要处理多少文件。这是由我们有多少内存决定的。如果所有数据都可以加载到内存中，就不需要生成器了。如果我们的数据量很大，我们可以处理大块的数据。</p><p id="3556" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我们将解决一个分类问题，我们必须给每个原始数据分配标签。为了方便起见，我们将使用以下标签。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/a2fcd9f607317c88d9f636c3f2cf458e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*0mf2ilJBL8U5MpLr8oFvJQ.png"/></div></figure><p id="4f33" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">生成器将同时<code class="du jt ju jv jw b">yield</code>数据和标签。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="3b73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要读取任何其他文件格式，在生成器内部更改读取文件的行。这将使我们能够读取不同的文件格式，无论是<code class="du jt ju jv jw b">.txt</code>或<code class="du jt ju jv jw b">.npz</code>或任何其他格式。</p><p id="1630" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们将检查发电机是否按预期工作。我们将设置<code class="du jt ju jv jw b">batch_size</code>为10。这意味着将读取和处理以10个为一组的文件。从中选择10个文件的文件列表可以是有序文件列表或混排列表。如果文件没有随机播放，使用<code class="du jt ju jv jw b">np.random.shuffle(file_list)</code>随机播放文件。</p><p id="3ff3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在演示中，我们将从有序列表中读取文件。这将帮助我们检查代码中的任何错误。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es md"><img src="../Images/668d82a0890643fac5a1925c7efaf7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*rfepfeQyCejDU2KBqFyB3Q.png"/></div></figure><p id="da6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多次运行上面的代码单元格，观察不同的标签。只有当所有对应于“Fault_1”的文件都已被读取时，标签1才会出现。“Fault_1”有100个文件，我们将batch_size设置为10。在上面的单元格中，我们只对生成器迭代了6次。当迭代次数大于10时，我们会看到标签1，然后是其他标签。这只有在我们的初始文件列表没有被打乱的情况下才会发生。如果原始列表被打乱，我们将获得随机标签。</p><p id="0fe6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们将使用生成器创建一个<code class="du jt ju jv jw b">tensorflow dataset</code>。<code class="du jt ju jv jw b">Tensorflow</code>数据集可以方便地用于训练<code class="du jt ju jv jw b">tensorflow</code>模型。</p><p id="fff4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以从numpy数组或生成器中创建一个<code class="du jt ju jv jw b">tensorflow dataset</code>。这里，我们将使用一个生成器来创建它。在<code class="du jt ju jv jw b">tensorflow datasets</code>中使用之前创建的生成器不起作用(读者可以验证这一点)。这是因为正则表达式无法将“字符串”与“字节字符串”进行比较。tensorflow中默认生成“字节串”。作为变通，我们将对早期的生成器进行修改，并将其用于tensorflow数据集。注意，我们将只修改三行。修改过的行旁边都附有注释文本。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="f660" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">测试改造后的发电机是否工作。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es me"><img src="../Images/2f1b4a0e6ea70b5ae2611ead1fc976ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*uamhyCYigI-TN_V6dHG-6w.png"/></div></figure><p id="3554" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，使用几个<code class="du jt ju jv jw b">tensorflow</code>命令创建的新生成器与我们之前的生成器一样工作良好。这种新型发电机现在可以与<code class="du jt ju jv jw b">tensorflow dataset</code>集成。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="0254" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">检查<code class="du jt ju jv jw b">dataset</code>是否工作。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/06dbbffab91c116e30a1e6be8d4ea9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u4iJnRex1AAswL_GgAIzuQ.png"/></div></div></figure><p id="f594" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这也很好。现在，我们将使用生成器训练一个完整的CNN模型。正如在每个模型中所做的那样，我们将首先打乱数据文件。将文件分为训练集、验证集和测试集。使用<code class="du jt ju jv jw b">tf_data_generator</code>创建三个tensorflow数据集，分别对应于训练、验证和测试数据。最后，我们将创建一个简单的CNN模型。使用训练数据集对其进行训练，查看其在验证数据集上的性能，并使用测试数据集获得预测。请记住，我们的目标不是提高模型的性能。由于数据是随机的，所以不要期望看到良好的性能。目的只是创建一个管道。</p><h1 id="69e8" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">3.建立数据管道和训练CNN模型</h1><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/0a01754ea971ed0bd8a60d3271fe3688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*lK9B_XFL46epb6kg_zQNVw.png"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="fa87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在创建模型。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/326c8f2453d4e12353754ac9dab4de9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tuEOU7n4zEu_JdmKaQRgvA.png"/></div></div></figure><p id="fd46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编译模型。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="4f18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们拟合模型之前，我们必须做一个重要的计算。记住我们的生成器是无限循环的。因此，如果没有给出停止条件，它将无限期运行。但是我们希望我们的模型运行10个时期。所以我们的生成器应该只对数据文件循环10次，不要超过10次。这是通过在<code class="du jt ju jv jw b">model.fit()</code>中将参数<code class="du jt ju jv jw b">steps_per_epoch</code>和<code class="du jt ju jv jw b">validation_steps</code>设置为期望的数值来实现的。类似地，在评估模型时，我们需要在<code class="du jt ju jv jw b">model.evaluate()</code>中将参数<code class="du jt ju jv jw b">steps</code>设置为所需的数值。</p><p id="98d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">训练集中有340个文件。Batch_size为10。因此，如果发电机运行34次，它将对应于一个纪元。因此，我们应该将<code class="du jt ju jv jw b">steps_per_epoch</code>设置为34。同理，<code class="du jt ju jv jw b">validation_steps = 6</code>和<code class="du jt ju jv jw b">model.evaluate()</code>、<code class="du jt ju jv jw b">steps = 10</code>中。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/d67d2428f57d360e621a3bd992934832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fk0beKOde_XuTSA8_vEthA.png"/></div></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/7c565da27c499f8aeef02fdee7849806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUwA5e6UGrfy2hiQtYecqw.png"/></div></div></figure><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/511ef37bddb833c07bc5a74a37443e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*qNT83kRLw-L40LmN4tdu6g.png"/></div></figure><p id="6c06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不出所料，模特表现很差。这就把我们带到了博客的结尾。正如我们在开始时所计划的，我们已经创建了随机数据文件、一个生成器，并使用该生成器训练了一个模型。上面的代码可以稍微调整一下来读取除了<code class="du jt ju jv jw b">.csv</code>之外的任何类型的文件。现在我们可以训练我们的模型，而不用担心数据的大小。无论数据大小是10GB还是750GB，我们的方法都适用。</p><p id="a884" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我想强调的是，这不是完成任务的唯一方法。正如我之前提到的，在<code class="du jt ju jv jw b">Tensorflow</code>中，你可以用几种不同的方式做同样的事情。我选择的方法对我来说似乎很自然。我既没有追求效率，也没有追求优雅。如果读者有更好的想法，我很乐意知道。</p><p id="1243" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望，这篇博客能对读者有所帮助。请把任何错误或遗漏告诉我。</p><p id="6517" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">更新</strong>:如果在读取的同时，必须对提取的数据进行复杂的转换(比如，对每段数据进行频谱分析等)。)，这篇博客中提出的天真的方法可能会很慢。但是有办法让这些计算更快。作者自己在一个应用程序中实现了10倍的加速比。如果您遇到此问题并且无法解决，请联系作者。讨论这种加速技术的博客将在稍后发布。</p></div></div>    
</body>
</html>