<html>
<head>
<title>Basics of TensorFlow 2.0 and Training a Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow 2.0基础知识和训练模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/basics-of-tensorflow-2-0-and-training-a-model-bf33cf4dff5a?source=collection_archive---------25-----------------------#2020-04-13">https://medium.com/analytics-vidhya/basics-of-tensorflow-2-0-and-training-a-model-bf33cf4dff5a?source=collection_archive---------25-----------------------#2020-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/3f31ccabd528a3060c544227b22543ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*j-zxwspaN1fZ6PrIlts6vA.png"/></div></figure><h1 id="74d7" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">TensorFlow 2.0简介</h1><p id="21b2" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated"><strong class="jm hj"> TensorFlow </strong>是一个数值处理库，最初由谷歌开发，供研究人员和机器学习从业者用于进行机器学习研究。您可以使用TensorFlow执行任何数值运算，它主要用于训练和运行深度神经网络。</p><p id="8f85" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">TensorFlow主要提供简化机器学习和深度学习解决方案在各种平台上的部署——计算机CPU、GPU、移动设备，以及最近在浏览器中的部署。最重要的是，TensorFlow为创建机器学习模型和大规模运行它们提供了许多有用的功能。<em class="kn">2019年，TensorFlow 2发布，重点关注易用性，同时保持良好的性能。</em></p><p id="454e" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">TensorFlow 2.0允许新手从简单的API开始，而专家可以同时创建非常复杂的模型。让我们探索这些不同的层次。</p><h2 id="d3f3" class="ko in hi bd io kp kq kr is ks kt ku iw jv kv kw ja jz kx ky je kd kz la ji lb bi translated">TensorFlow 2.0主架构</h2><p id="90c7" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">TensorFlow 2架构有几个抽象层次。让我们首先介绍最底层，然后找到通向最高层的路:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/22451225e39ba41df66a325894cceb61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*dw-oe1YEiJ4CohAk-pEahA.png"/></div></figure><p id="071f" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">解释建筑的层次:</strong></p><p id="d8a8" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> <em class="kn"> C++层</em> </strong></p><p id="0f45" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">大多数深度学习计算都是用C++编写的。为了在GPU上运行操作，TensorFlow使用了由NVIDIA开发的名为CUDA的库。这就是为什么如果您想利用GPU功能，您需要安装CUDA，以及为什么您不能使用其他硬件制造商的GPU。</p><p id="b3df" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> <em class="kn">低级API </em> </strong></p><p id="cd78" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">Python <strong class="jm hj">低级</strong> <strong class="jm hj"> API </strong>然后包装C++源代码。当您在TensorFlow中调用Python方法时，它通常会在后台调用C++代码。这个包装层允许用户更快地工作，因为Python被认为比C++更容易使用，并且不需要编译。这个Python包装器使得执行非常基本的操作成为可能，比如矩阵乘法和加法。</p><p id="c764" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> <em class="kn">高级API </em> </strong></p><p id="8b9c" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">位于顶部的是高层API，由两个组件组成——Keras和Estimator API。Keras是一个用户友好的、模块化的、可扩展的TensorFlow包装器。<strong class="jm hj"> Estimator API </strong>包含几个预制组件，可以让你轻松构建你的机器学习模型。您可以将它们视为构建块或模板。预制组件只需对代码进行最少的修改，就可以让您尝试不同的模型架构。</p><h1 id="9d0a" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">介绍Keras</h1><p id="da15" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Keras于2015年首次发布，旨在作为一个接口，实现神经网络的快速实验。有几个深度学习框架可以帮助建立深度神经网络。TensorFlow、Theano、CNTK(微软)是行业和研究中使用的一些主要框架。Keras充当这些框架的包装器。它以用户友好著称，是开发者的首选库和终极深度学习工具。</p><p id="b9f6" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">Keras API的架构</strong></p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/8919ebd5241962f0b115136fdc309aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRZHwJgZcRG3Evq9mJSfJA.png"/></div></div></figure><h2 id="b4ce" class="ko in hi bd io kp kq kr is ks kt ku iw jv kv kw ja jz kx ky je kd kz la ji lb bi translated">为什么是Keras？</h2><ul class=""><li id="fce5" class="lm ln hi jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">它支持美国有线电视新闻网，RNN和两者的结合</li><li id="3037" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">快速原型制作</li><li id="4c54" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">深度足以建立严肃的模型</li><li id="689b" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">写得很好的文件——参见<a class="ae ma" href="http://keras.io/" rel="noopener ugc nofollow" target="_blank"/></li></ul><p id="d068" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">基本上，Keras车型通过以下渠道。</strong></p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mb"><img src="../Images/bd5b4350c7d94f459bddebc410d60370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KcGflIY5X1vCg2GtdLJUXA.jpeg"/></div></div></figure><h1 id="4447" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">使用Keras的简单计算机视觉模型</h1><p id="cd9d" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">让我们从计算机视觉的一个经典例子开始——用<strong class="jm hj">改进的国家标准与技术研究所</strong> ( <strong class="jm hj"> MNIST </strong>)数据集进行数字识别。</p><p id="197b" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">用于安装TensorFlow 2.x版本。</p><pre class="ld le lf lg fd mc md me mf aw mg bi"><span id="d972" class="ko in hi md b fi mh mi l mj mk">#!pip install tensorflow==2.0.0alpha0 #Tensorflow alpha version<br/>#!pip install tensorflow==2.0.0-beta1 #Tensorflow beta version</span><span id="9854" class="ko in hi md b fi ml mi l mj mk">#print(tf.__version__) # Check the version</span></pre><h2 id="566b" class="ko in hi bd io kp kq kr is ks kt ku iw jv kv kw ja jz kx ky je kd kz la ji lb bi translated">准备数据</h2><p id="a218" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">首先，我们导入数据。它由训练集的60，000幅图像和测试集的10，000幅图像组成:</p><pre class="ld le lf lg fd mc md me mf aw mg bi"><span id="cf85" class="ko in hi md b fi mh mi l mj mk"><strong class="md hj">import tensorflow as tf # import tensorflow as tf for faster typing <br/>import numpy as np      # import numerical python as np </strong></span><span id="01fd" class="ko in hi md b fi ml mi l mj mk"><strong class="md hj">num_classes = 10<br/>img_rows, img_cols = 28, 28<br/>num_channels = 1<br/>input_shape = (img_rows, img_cols, num_channels)</strong></span><span id="eb93" class="ko in hi md b fi ml mi l mj mk"><strong class="md hj">(x_train, y_train),(x_test, y_test) =  tf.keras.datasets.mnist.load_data()     #load the datasets</strong></span><span id="ae3c" class="ko in hi md b fi ml mi l mj mk"><strong class="md hj">x_train, x_test = x_train / 255.0, x_test / 255.0 #DataNormalization</strong></span></pre><p id="5523" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> tf.keras.datasets </strong>模块提供了下载和实例化大量经典数据集的快速访问。在使用<strong class="jm hj"> load_data </strong>导入数据后，我们将数组除以255.0，得到一个在[ <em class="kn"> 0，1 </em>范围内的数，而不是[ <em class="kn"> 0，255 </em> ]范围内的数。通常的做法是归一化数据，要么在[ <em class="kn"> 0，1 </em>范围内，要么在[ <em class="kn"> -1，1 </em>范围内。</p><h2 id="c580" class="ko in hi bd io kp kq kr is ks kt ku iw jv kv kw ja jz kx ky je kd kz la ji lb bi translated">构建模型</h2><p id="0d01" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">转到构建实际模型。我们将使用一个非常简单的架构，由两个完全连接的层组成，称为密集层。现在，让我们看一下代码。可以看到，<strong class="jm hj"> <em class="kn"> </em> </strong> Keras代码非常<strong class="jm hj"> <em class="kn"> </em> </strong>简洁明了地写着。</p><pre class="ld le lf lg fd mc md me mf aw mg bi"><span id="10da" class="ko in hi md b fi mh mi l mj mk"><strong class="md hj">model = tf.keras.models.Sequential()<br/>model.add(tf.keras.layers.Flatten())<br/>model.add(tf.keras.layers.Dense(128, activation='relu'))<br/>model.add(tf.keras.layers.Dense(num_classes, activation='softmax'))</strong></span></pre><p id="0baf" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">由于我们的模型是层的线性堆栈，我们从调用顺序函数开始。然后我们一层接一层地添加每一层。我们的模型由两个完全连接的层组成。我们一层一层地建造它:</p><ul class=""><li id="6fa4" class="lm ln hi jm b jn ki jr kj jv mm jz mn kd mo kh lr ls lt lu bi translated"><strong class="jm hj">展平:</strong>这将把代表图像像素的2D矩阵转换成1D数组。我们需要在添加完全连接的层之前这样做。<em class="kn"> 28 </em> × <em class="kn"> 28 </em>图像被转换成大小为<em class="kn"> 784 </em>的矢量。</li><li id="fc06" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated"><strong class="jm hj">密度</strong>大小<em class="kn"> 128 </em> <strong class="jm hj"> : </strong>这将使用大小<em class="kn"> 128 </em> × <em class="kn"> 784 </em>的权重矩阵和大小<em class="kn"> 128 </em>的偏差矩阵将<em class="kn"> 784 </em>像素值转化为128个激活。总的来说，这意味着<em class="kn"> 100，480个</em>参数。</li><li id="5309" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated"><strong class="jm hj">密集</strong>大小<em class="kn">10</em>T20】:这将把<em class="kn"> 128 </em>激活变成我们的最终预测。注意，因为我们希望概率总和为<em class="kn"> 1 </em>，我们将使用softmax激活函数。softmax函数获取图层的输出，并返回总和为1的概率。它是分类模型最后一层的选择激活。</li></ul><p id="f113" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">您可以获得模型、输出及其权重的描述。</p><pre class="ld le lf lg fd mc md me mf aw mg bi"><span id="3bd1" class="ko in hi md b fi mh mi l mj mk"><strong class="md hj">model.summary()</strong></span></pre><p id="7d81" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">以下是输出:</p><pre class="ld le lf lg fd mc md me mf aw mg bi"><span id="952c" class="ko in hi md b fi mh mi l mj mk"><strong class="md hj">Model: "sequential"</strong><br/><strong class="md hj">_________________________________________________________________</strong><br/><strong class="md hj">Layer (type) Output Shape Param # </strong><br/><strong class="md hj">=================================================================</strong><br/><strong class="md hj">flatten_1 (Flatten) (None, 784) 0 </strong><br/><strong class="md hj">_________________________________________________________________</strong><br/><strong class="md hj">dense_1 (Dense) (None, 128) 100480 </strong><br/><strong class="md hj">_________________________________________________________________</strong><br/><strong class="md hj">dense_2 (Dense) (None, 10) 1290 </strong><br/><strong class="md hj">=================================================================</strong><br/><strong class="md hj">Total params: 101,770</strong><br/><strong class="md hj">Trainable params: 101,770</strong><br/><strong class="md hj">Non-trainable params: 0</strong></span></pre><h2 id="0863" class="ko in hi bd io kp kq kr is ks kt ku iw jv kv kw ja jz kx ky je kd kz la ji lb bi translated">训练模型</h2><p id="d8c2" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Keras让培训变得极其简单:</p><pre class="ld le lf lg fd mc md me mf aw mg bi"><span id="ef62" class="ko in hi md b fi mh mi l mj mk"><strong class="md hj">model.compile(optimizer='sgd',loss='sparse_categorical_crossentropy, metrics=['accuracy'])</strong></span></pre><p id="f750" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">呼叫<strong class="jm hj">。对于我们刚刚创建的模型，compile() </strong>是一个强制步骤。必须指定几个参数:</p><ul class=""><li id="cd5b" class="lm ln hi jm b jn ki jr kj jv mm jz mn kd mo kh lr ls lt lu bi translated"><strong class="jm hj">优化器:</strong>这是将执行梯度下降的组件。</li><li id="2017" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated"><strong class="jm hj">损失:</strong>这是我们将优化的指标。在我们的例子中，我们选择交叉熵，就像上一章一样。</li><li id="2189" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated"><strong class="jm hj">度量:</strong>这些是在训练期间评估的附加度量函数，以提供模型性能的进一步可见性(与loss不同，它们不用于优化过程)。</li></ul><pre class="ld le lf lg fd mc md me mf aw mg bi"><span id="4e07" class="ko in hi md b fi mh mi l mj mk"><strong class="md hj">model.fit(x_train, y_train, epochs=5, verbose=1, validation_data=(x_test, y_test))</strong></span></pre><p id="bc42" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">然后我们调用。fit()方法。我们将训练五个<strong class="jm hj">时期</strong>，这意味着我们将在整个训练数据集上迭代五次。注意，我们将<strong class="jm hj"> verbose </strong>设置为1。这将允许我们得到一个进度条，上面有我们之前选择的指标、损耗和<strong class="jm hj">预计到达时间</strong> ( <strong class="jm hj"> ETA </strong>)。ETA是对该时期结束前剩余时间的估计。下面是进度条的样子:</p><p id="4719" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">评估模型:</strong></p><pre class="ld le lf lg fd mc md me mf aw mg bi"><span id="f821" class="ko in hi md b fi mh mi l mj mk"><strong class="md hj">model.evaluate(x_test,y_test)</strong></span></pre><p id="5748" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">我们遵循三个主要步骤:</p><ol class=""><li id="db22" class="lm ln hi jm b jn ki jr kj jv mm jz mn kd mo kh mp ls lt lu bi translated"><strong class="jm hj">加载数据</strong>:在这种情况下，数据集已经可用。在未来的项目中，您可能需要额外的步骤来收集和清理数据。</li><li id="1eb3" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh mp ls lt lu bi translated"><strong class="jm hj">创建模型</strong>:通过使用Keras，这一步变得很简单——我们通过添加连续的层来定义模型的架构。然后，我们选择了一个损失、一个优化器和一个要监控的指标。</li><li id="42b4" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh mp ls lt lu bi translated">培训模型:我们的模型第一次运行得很好。对于更复杂的数据集，您通常需要在训练期间微调参数。</li></ol><p id="0bb9" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">由于TensorFlow的高级API Keras，整个过程非常简单。在这个简单的API背后，这个库隐藏了很多复杂性。</p><p id="f3a8" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><em class="kn">参考文献:</em></p><ul class=""><li id="dea1" class="lm ln hi jm b jn ki jr kj jv mm jz mn kd mo kh lr ls lt lu bi translated"><a class="ae ma" href="https://www.tensorflow.org/guide/keras/overview" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/guide/keras/overview</a></li><li id="30e4" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated"><a class="ae ma" href="https://web.stanford.edu/class/cs20si/lectures/march9guestlecture.pdf" rel="noopener ugc nofollow" target="_blank">https://web . Stanford . edu/class/cs20si/lectures/March 9 guest lecture . pdf</a></li><li id="6146" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated"><a class="ae ma" href="https://blog.tensorflow.org/2020/03/recap-of-2020-tensorflow-dev-summit.html" rel="noopener ugc nofollow" target="_blank">https://blog . tensor flow . org/2020/03/recap-of-2020-tensor flow-dev-summit . html</a></li><li id="b25e" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated"><a class="ae ma" href="http://keras.io/" rel="noopener ugc nofollow" target="_blank"> http://keras.io </a></li><li id="2991" class="lm ln hi jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated"><a class="ae ma" href="https://www.deeplearning.ai/tensorflow-in-practice/" rel="noopener ugc nofollow" target="_blank">https://www.deeplearning.ai/tensorflow-in-practice/</a></li></ul></div></div>    
</body>
</html>