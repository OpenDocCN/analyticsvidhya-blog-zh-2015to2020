<html>
<head>
<title>How does a Single Neural Net work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单个神经网络是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-does-a-single-neural-net-works-163cdd7740f8?source=collection_archive---------13-----------------------#2019-11-07">https://medium.com/analytics-vidhya/how-does-a-single-neural-net-works-163cdd7740f8?source=collection_archive---------13-----------------------#2019-11-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/1487ce2cfe746139bef8ede1a80f271e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9Wgd_X58Ije_Ml94Qs-P_Q.gif"/></div></div></figure><p id="d375" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们都知道人工智能领域的热门话题，</p><p id="2828" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">但是你是不是和许多人一样，认为这是一个奇特的领域，很难理解。</p><h1 id="2ecd" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">嗯，这不是100%真实的。</h1><p id="fd8a" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">如果你对数学感兴趣并且已经有了一些基本的理解，并且愿意学习新的东西，你可以很快攻克它。</p><p id="d69a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">让我解释一下它到底是什么。</p><p id="e0c0" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">人工智能是许多学科的结合，深度学习是其所有组成部分的主干。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es kz"><img src="../Images/cce7d75e3a2b3053f5a6e69a84a52277.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*izIhIA2J2lsh4gIDKIbgnA.gif"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">手写数字预测器(深度学习模型)</figcaption></figure><p id="89f7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">深度学习只不过是建立一个有效且高效的模型的艺术，该模型由多层神经网络组成，旨在执行特定的任务。</p><p id="e523" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">为了更好地理解深度学习，我们首先需要理解，</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es le"><img src="../Images/52144e249c430009e4bf77b3217119e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*1ymmT2t5m9Ik49JlfXcOtQ.gif"/></div></figure><p id="798c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> <em class="lf">这是什么人工神经网络？</em>T3】</strong></p><p id="736f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">人工神经网络非常类似于我们大脑中实际神经元的运作方式。它基本上是设计来模仿我们自己的神经元。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lg"><img src="../Images/6d0dd2a39ab2253a5238f27e9fc6572e.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/1*eszGzz0lNeSi0u2-9SDVlQ.gif"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">神经元放电</figcaption></figure><p id="5264" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">一个生物神经元细胞与成千上万的其他神经元相连，形成一个网络。<br/>我们大脑不同部分的每一个神经元网络都控制着我们日常运作的困难方面。</p><p id="5a3b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">同样，作为深度学习的一部分，我们正试图建立一个具有多层神经网络的人工神经网络，以执行更具体的任务，如分类问题，玩雅达利游戏，语言翻译等</p><h2 id="777f" class="lh jx hi bd jy li lj lk kc ll lm ln kg jj lo lp kk jn lq lr ko jr ls lt ks lu bi translated">为了理解这些人工神经网络是什么，我们需要知道单个神经网络是如何工作的。</h2><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lv"><img src="../Images/3d5ea3fe9a3246d13f26692b74fe5d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*XSmLudmjyyAHHhpxkotm2w.gif"/></div></figure><p id="b0eb" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">有大量的文章解释了神经网络在互联网中的作用。<br/>但这是我对单个神经网络功能的理解，并试图用一个非常简单的工作程序来解释它。</p><p id="6b1d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在开始之前，如果对线性代数和python编程有基本的了解，就很容易理解了。尽管你没有以上的理解，我还是会试着解释一下。</p><p id="fa12" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们可以把这个分成两部分。</p><ol class=""><li id="f530" class="lw lx hi ja b jb jc jf jg jj ly jn lz jr ma jv mb mc md me bi translated"><strong class="ja hj">神经网络的理论解释</strong></li><li id="9f19" class="lw lx hi ja b jb mf jf mg jj mh jn mi jr mj jv mb mc md me bi translated"><strong class="ja hj">使用python程序的实际实现。</strong></li></ol><p id="bc74" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">神经网络的理论解释</strong></p><p id="4b7e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">神经网络应被视为一个函数或系数矩阵，它将输入转换为所需的输出。</p><blockquote class="mk ml mm"><p id="334b" class="iy iz lf ja b jb jc jd je jf jg jh ji mn jk jl jm mo jo jp jq mp js jt ju jv hb bi translated">从现在起我们看到的每一个变量，都将是一个数字阵列或一个矩阵</p></blockquote><p id="f698" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">可以表示如下。</p><h2 id="3d45" class="lh jx hi bd jy li lj lk kc ll lm ln kg jj lo lp kk jn lq lr ko jr ls lt ks lu bi translated"><strong class="ak"> Y = A X </strong></h2><p id="b746" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">其中<strong class="ja hj"> Y </strong>是输出，</p><p id="d3bb" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> X </strong>是输入和</p><p id="2e2e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> A </strong>是作用于输入以给出输出的函数或一组系数。</p><p id="1147" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在传统的计算机编程中，我们将知道输入<strong class="ja hj"> X </strong>，并且我们将通过计算机程序创建具有逻辑组合的函数<strong class="ja hj"> A </strong>，以获得期望的输出<strong class="ja hj"> Y </strong>。</p><p id="bbc2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">但是在这里，我们不是用逻辑组合来创建函数<strong class="ja hj"> A </strong>，而是通过让它用已经可用的输入<strong class="ja hj"> X </strong>和输出<strong class="ja hj"> Y </strong>作为数据集来训练，来教导模型学习什么是函数<strong class="ja hj"> A </strong>。</p><p id="6a90" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">如果你想知道这种学习是如何发生的？</p><p id="db9b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这实际上是每个人学习的方式</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es mq"><img src="../Images/e7d66617fdf15a0cfe133f89081edba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*d5usOvuVfk_rPFSoOpjGJw.gif"/></div></figure><h1 id="d513" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">通过犯错！</h1><p id="8402" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">最初，我们的模型将随机分配一组系数<strong class="ja hj"> A </strong>，这组系数将作用于输入以给出输出(预测输出)，</p><p id="25d5" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">然后我们将它与训练阶段的实际输出进行比较。<br/>并计算误差值(实际输出和预测输出之差)。</p><h1 id="f627" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> E = Y轴</strong></h1><p id="e35c" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">其中<strong class="ja hj"> E </strong>为误差值</p><p id="42b3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">Y</strong>——是实际产量</p><p id="412a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> AX </strong> —是我们之前看到的预测输出。</p><p id="2383" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">基于该误差值，模型确定需要改变多少系数组，<br/>以使预测输出接近实际输出。</p><p id="9d2e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这个更新系数的过程是通过称为<strong class="ja hj">梯度下降法或反向传播的过程来完成的。</strong></p><p id="1d08" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这使得模型通过回顾误差值并调整函数<strong class="ja hj"> A </strong>的系数来从其错误中学习。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es mq"><img src="../Images/c69b73093d193bdb08caba393b251201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*7CJRMAomDwc8HBtaD6LqlQ.gif"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">反向传播过程。</figcaption></figure><p id="3ba2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这个<strong class="ja hj">反向传播</strong>可以通过对误差方程应用微分来完成。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es mr"><img src="../Images/2cdd458a65c1c5d25b6e1c1ab1d40279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*eguTLWLI9bcaRhPn1zME3w.gif"/></div></figure><p id="c00c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">但是为什么我们需要应用微分呢？</strong></p><p id="908c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">一般来说，任何方程的微分都会给出输入值微小变化时方程变化的速率。</p><p id="29c3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">如果我们绘制出一个的<strong class="ja hj">系数的所有值，并观察误差方程相对于其值如何变化。我们将得到一个下面凸形的图形。</strong></p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ms"><img src="../Images/5bee737e7b9a3230eb52c7876cb90e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*yxDwb8W_Bma1Otr3edjS7w.jpeg"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">误差函数与系数。</figcaption></figure><blockquote class="mk ml mm"><p id="360a" class="iy iz lf ja b jb jc jd je jf jg jh ji mn jk jl jm mo jo jp jq mp js jt ju jv hb bi translated">从现在起，我们将把这个系数函数称为节点权重。</p></blockquote><h1 id="b604" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> dE = d (Y轴)</strong></h1><p id="3247" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">根据节点重量对这个误差方程进行微分，我们会得到一个值。</p><p id="869c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">如果我们用节点权重加上/减去这个值，误差值将开始向凸形图的最小点移动。这个极小点叫做<strong class="ja hj">全局极小点</strong>。</p><p id="dcdb" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这是误差几乎变得最小(有时接近于零)的点</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es mt"><img src="../Images/27f47a93433b6c683e51cc3609a5eecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*e88JKNWAFok3vpjeuPfHig.gif"/></div></figure><p id="3375" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">所以我们的目标是迭代运行这个更新节点权重的过程，直到它达到全局最小值。</p><p id="4448" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在让我们进入实现部分</p><h1 id="62a3" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">使用python程序的实际实现</strong></h1><p id="6002" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">这个python程序有两个主要部分，</p><ol class=""><li id="92c7" class="lw lx hi ja b jb jc jf jg jj ly jn lz jr ma jv mb mc md me bi translated"><strong class="ja hj">神经网络类</strong>(该类将包含如下神经网络所需的所有必要组件)</li></ol><p id="7790" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="lf"> a .节点重量</em></p><p id="3bb2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="lf"> b .激活功能</em></p><p id="6177" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="lf"> c .预测功能</em></p><p id="cc35" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="lf"> d .训练功能</em></p><p id="720a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> 2。主函数</strong>(该函数将调用带有输入的神经网络，并返回预测输出)</p><p id="6b3c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">随着代码的进展，我们将了解每一个单独的组件。</p><p id="2c09" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">首先，我们需要导入这个程序所需的依赖项。</p><p id="df71" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这里需要的重要依赖项是<strong class="ja hj"> Numpy </strong>库，</p><p id="8e7a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这个库主要包含所有需要的数学运算和辅助函数。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es mu"><img src="../Images/9a7eba8c1dfe98601cac54acd7df4d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*vU8tEK-FxSUtRIUQ506FFA.png"/></div></figure><p id="34c2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在我们用__init__函数为神经网络创建我们的类，如下所示</p><h1 id="efa5" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> 1。神经网络类</strong></h1><h2 id="b08d" class="lh jx hi bd jy li lj lk kc ll lm ln kg jj lo lp kk jn lq lr ko jr ls lt ks lu bi translated"><em class="mv"> a .节点重量</em></h2><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mw"><img src="../Images/e27e01cb3684016ea4f64683aa213cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c62gTRJ3JB28PJDoIIj8Nw.png"/></div></div></figure><p id="f4cb" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在python中，类中变量/函数的初始化发生在它的__init__函数中，该函数初始化与整个类相关联的类变量。</p><p id="4bc5" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">对于没有任何python经验的人来说，可以认为这个函数用一些随机值初始化了节点权重。</p><p id="c06f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">要进一步了解__init__函数，请参考下面的链接。</p><p id="81af" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae mx" href="https://micropyramid.com/blog/understand-self-and-__init__-method-in-python-class/" rel="noopener ugc nofollow" target="_blank">https://micropyramid . com/blog/understand-self-and-_ _ init _ _-method-in-python-class/</a></p><p id="a5ba" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们将节点权重创建为3×1(3行1列)矩阵，因为我们的输入有3个二进制变量，这些变量与节点权重相乘，以提供单个二进制变量输出。</p><p id="07ae" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们将使用梯度下降法微调该节点权重，试图减少预测输出和实际输出之间的计算误差值。</p><h2 id="d590" class="lh jx hi bd jy li lj lk kc ll lm ln kg jj lo lp kk jn lq lr ko jr ls lt ks lu bi translated">b.<em class="mv">激活功能</em></h2><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es my"><img src="../Images/47e0784606d90157940e7339fd5b55a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*wOk8A8n9ID25iFF3S66LFw.png"/></div></figure><p id="d0bd" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">上述功能被称为激活功能，顾名思义，它激活我们试图产生的神经元。</p><p id="5fab" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们应该将这种激活功能视为神经元的功能特征，就像我们大脑中的神经元细胞一样，神经元细胞由细胞核、细胞体等组成，构成了神经元的特征。</p><p id="60c3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">类似地，这里的激活函数决定了神经网络的特征，我们可以根据我们试图解决的问题来改变这个激活函数。</p><p id="24a2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">而我们这里使用的激活函数是<strong class="ja hj"> Sigmoid </strong>激活函数，输出t在0到1之间的所有输入值。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mz"><img src="../Images/68b93cedb6be43725966f99ebbdca4e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NloTSPs4pCMYDZ8G1kxhoQ.png"/></div></div></figure><p id="e36f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">从而将输入转换成更加规范化的形式，这有助于我们更好地理解输入和输出之间的关系。</p><p id="aa71" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这个sigmoid在输出为0或1的二进制分类问题中很有帮助。在这个程序中，我们也试图执行一个二进制分类问题，因为我们的输出不是0就是1。</p><p id="5116" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">要了解更多关于sigmoid激活功能和所有其他类型的可用激活功能，请查看以下链接</p><div class="na nb ez fb nc nd"><a href="https://missinglink.ai/guides/neural-network-concepts/7-types-neural-network-activation-functions-right/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">神经网络中的7类激活函数:如何选择？</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">神经网络激活功能是深度学习的重要组成部分。激活功能决定输出…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">missinglink.ai</p></div></div><div class="nm l"><div class="nn l no np nq nm nr iw nd"/></div></div></a></div><p id="29fd" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在我们需要对激活函数进行求导或微分，正如我们已经在<strong class="ja hj">反向传播</strong>过程中看到的。</p><p id="9936" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在这种情况下，只需要激活函数的导数，因为除了乘以节点权重之外，没有对输入执行其他操作，因为它是一个常数值，所以没有导数。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ns"><img src="../Images/0c567d4823b3b06458e0531ca501b16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*00fbwFExrfuSXmi11wKOkg.png"/></div></figure><blockquote class="mk ml mm"><p id="1b88" class="iy iz lf ja b jb jc jd je jf jg jh ji mn jk jl jm mo jo jp jq mp js jt ju jv hb bi translated">但是在更复杂的神经网络中，会涉及到许多这样的激活函数，所以需要这些函数的导数。</p></blockquote><h2 id="c742" class="lh jx hi bd jy li lj lk kc ll lm ln kg jj lo lp kk jn lq lr ko jr ls lt ks lu bi translated"><em class="mv"> c .预测功能</em></h2><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nt"><img src="../Images/1be8a01a81da92091808cafbd6b0e90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRRkR9i-7mApD0fCVeqz0g.png"/></div></div></figure><p id="512d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">大脑功能之上是重要和有趣的事情发生的地方。</p><p id="7d39" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这是输入和节点权重结合并通过sigmoid激活的地方。因此，输出函数如下所示</p><p id="1de9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">输出= 1/(1+实验(-(输入。)nodel_weights)) </strong></p><p id="4307" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">其中<strong class="ja hj">(。)</strong>表示点积</p><h2 id="83af" class="lh jx hi bd jy li lj lk kc ll lm ln kg jj lo lp kk jn lq lr ko jr ls lt ks lu bi translated">d.培训功能</h2><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nu"><img src="../Images/2f421f59a71008794d1b5f55103aa071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1TOAi-UQ4rov2586210eg.png"/></div></div></figure><p id="6ef6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这个训练函数就是让神经网络学习的东西。</p><blockquote class="mk ml mm"><p id="60a2" class="iy iz lf ja b jb jc jd je jf jg jh ji mn jk jl jm mo jo jp jq mp js jt ju jv hb bi translated">因为我们已经知道神经网络如何学习，所以让我们只关注实现部分。</p></blockquote><p id="876c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这个训练函数背后的基本直觉是，通过在迭代中调用大脑函数(预测函数),神经网络进行如下操作</p><ol class=""><li id="5cba" class="lw lx hi ja b jb jc jf jg jj ly jn lz jr ma jv mb mc md me bi translated">预测产量</li><li id="b2ad" class="lw lx hi ja b jb mf jf mg jj mh jn mi jr mj jv mb mc md me bi translated">将预测输出与实际输出进行比较，并计算误差值</li><li id="4fb2" class="lw lx hi ja b jb mf jf mg jj mh jn mi jr mj jv mb mc md me bi translated">基于误差值，使用梯度下降更新节点权重。</li></ol><p id="3db8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">以上3个过程一直持续到迭代结束。</p><h1 id="c391" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">2.主要功能</h1><p id="69c8" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">现在我们已经万事俱备，只需要用下面的数据集训练模型。</p><h2 id="6a41" class="lh jx hi bd jy li lj lk kc ll lm ln kg jj lo lp kk jn lq lr ko jr ls lt ks lu bi translated">输入— [0 0 1]，[1 1 1]，[1 0 1]，[0 1 1]</h2><h2 id="03fb" class="lh jx hi bd jy li lj lk kc ll lm ln kg jj lo lp kk jn lq lr ko jr ls lt ks lu bi translated">输出— [0]、[1]、[1]、[0]</h2><p id="2286" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">因此，该模型接受3个输入，给出1个输出。</p><p id="21bb" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">下面是使用数据集训练模型并预测不在训练集中的测试输入的输出的主函数。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nv"><img src="../Images/9803cabc1ef713a3964612897dbaa112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTKaapqsrESJKgqpc6u3hQ.png"/></div></div></figure><p id="cf43" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">该模型将预测测试输入数据<strong class="ja hj">【110】。</strong></p><p id="37be" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">让我们看看输出是什么，训练的节点权重是什么</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nw"><img src="../Images/913ba41f058de06604f6b3ecf493267c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8kTrFpEZxZocR8pB2icCA.png"/></div></div></figure><p id="b0a3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">和viola，我们的模型计算了新的节点权重，并预测了新测试输入的值为1(大约)。</p><p id="a161" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">有趣的是，如果我们仔细观察输入的训练数据集。我们可以看到输入矩阵的第一列与输出矩阵的第一列相同。</p><p id="6e68" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在，如果我们可以看到新更新的节点权重，只有第一行将有一个正值，其余的行将有一个负值。</p><p id="0d00" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">因此，通过训练，我们的<strong class="ja hj">神经网络已经了解到，输入的第一列单独对输出</strong>有贡献。因此，它得到了一个巨大的正值，而其他2列得到了负值。</p><p id="fd1f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">当它传递到如下的sigmoid函数中时，</p><h2 id="8559" class="lh jx hi bd jy li lj lk kc ll lm ln kg jj lo lp kk jn lq lr ko jr ls lt ks lu bi translated">乙状结肠(输入(。)自我.节点_权重)</h2><p id="2f95" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">输入的第一列将乘以正值，其余的输入列乘以节点权重的相应负值。</p><p id="4781" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">sigmoid函数会将任何大于1的值转换为1，将任何小于0的值转换为0。</p><p id="a10f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">因此，如果输入的第一列是1，输出也将近似等于1。我们不需要关心函数的其余部分，因为它们乘以接近零的值。</p><h2 id="960c" class="lh jx hi bd jy li lj lk kc ll lm ln kg jj lo lp kk jn lq lr ko jr ls lt ks lu bi translated">就是这样！！！</h2><p id="4d8b" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">我们有简单的全功能单一神经网络。</p><p id="a47a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">python代码的灵感来自米洛·斯潘塞的<a class="ae mx" rel="noopener" href="/technology-invention-and-more/how-to-build-a-simple-neural-network-in-9-lines-of-python-code-cc8f23647ca1#.l51z38s7f">博客。</a></p><p id="a743" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我发现他的程序和数据集非常简单易懂，但有几个基本问题我必须在别处搜索才能完全理解基本概念，所以我认为将所有东西放在一个地方对初学者会有帮助。</p><p id="476e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">希望你喜欢学习神经网络。</p></div></div>    
</body>
</html>