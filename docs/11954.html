<html>
<head>
<title>Building Image Classifier using Keras and TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Keras和TensorFlow构建图像分类器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-image-classifier-using-keras-and-tensorflow-fef21c54732a?source=collection_archive---------8-----------------------#2020-12-25">https://medium.com/analytics-vidhya/building-image-classifier-using-keras-and-tensorflow-fef21c54732a?source=collection_archive---------8-----------------------#2020-12-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e8b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谷歌的机器学习库TensorFlow最简单的入门方法之一是从头开始构建图像分类器。TensorFlow主要用于神经网络，它是一个开源库。由于tensorflow是一个低级库，它为用户(尤其是开发者)开发自己的功能和服务提供了更大的灵活性。此外，它们支持很多编程语言，包括Python。TensorFlow最近更新到TensorFlow 2.x，特别是在它的integration Keras方面，这是一个高级深度学习API，有助于轻松构建、训练、验证和执行神经网络。介绍完毕。让我们去建立我们的图像分类器:)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/63fa95819ca518d6e4ec6aa8a4df62d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G6NPkj9DDAW5Qdm7"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@danielcgold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹金</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="8be6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">导入库</h2><p id="aeb2" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我正在使用Google Colab，下面是导入tensorflow和keras库的代码。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="a9c7" class="ju jv hi kv b fi kz la l lb lc">import tensorflow as tf<br/>from tensorflow import keras<br/>tf.__version__</span></pre><h2 id="912c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">加载数据集</h2><p id="fbde" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">Keras有一些实用函数来获取公共数据集。这包括加州MNIST的数据集等。出于我们的目的，我们将加载时尚MNIST数据。我们将把数据分成训练集和测试集。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="dd1a" class="ju jv hi kv b fi kz la l lb lc">fashion_mnist=keras.datasets.fashion_mnist<br/>(train_X,train_Y),(test_X,test_Y)=fashion_mnist.load_data()<br/>print("train_X has shape of: ",train_X.shape)<br/>print("train_Y has shape of: ",train_Y.shape)<br/>print("test_X has shape of: ",train_X.shape)<br/>print("test_Y has shape of: ",train_Y.shape)</span></pre><p id="1219" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="3635" class="ju jv hi kv b fi kz la l lb lc"><em class="ld">train_X has shape of: (60000, 28, 28)<br/>train_Y has shape of: (60000,) <br/>test_X has shape of: (60000, 28, 28) <br/>test_Y has shape of: (60000,)</em></span></pre><p id="0d0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们必须将像素强度除以255，缩小到0-1的范围。通过将我们的输入标准化到标准尺度，我们允许网络更快地学习每个输入节点的最佳参数。此外，如果您的输入和目标输出处于完全不同的范围，那么您的神经网络的默认参数(例如学习率)可能不适合您的数据。我们还将从训练数据中提取一些数据到验证集。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="4334" class="ju jv hi kv b fi kz la l lb lc">// taking first 5000 records for validation set<br/>valid_X,train_X=train_X[:5000]/255.0,train_X[5000:]/255.0<br/>valid_Y,train_Y=train_Y[:5000]/255.0,train_Y[5000:]/255.0</span></pre><p id="0165" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据集中的图像示例:</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="0b50" class="ju jv hi kv b fi kz la l lb lc">class_names = ["T-shirt/top", "Trouser", "Pullover", "Dress","Coat",<br/>               "Sandal", "Shirt", "Sneaker", "Bag", "Ankle boot"]<br/>n_rows = 4<br/>n_cols = 10<br/>plt.figure(figsize=(n_cols * 1.2, n_rows * 1.2))<br/><strong class="kv hj">for</strong> row <strong class="kv hj">in</strong> range(n_rows):<br/>    <strong class="kv hj">for</strong> col <strong class="kv hj">in</strong> range(n_cols):<br/>        index = n_cols * row + col<br/>        plt.subplot(n_rows, n_cols, index + 1)<br/>        plt.imshow(X_train[index], cmap="binary", interpolation="nearest")<br/>        plt.axis('off')<br/>        plt.title(class_names[y_train[index]], fontsize=12)<br/>plt.subplots_adjust(wspace=0.2, hspace=0.5)<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es le"><img src="../Images/73e0f4c8441f6ec955f0e5d5b97fd86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VPrljHyiMh-PN_5LLkHm1Q.png"/></div></div></figure><h2 id="d07d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">顺序API</h2><p id="67a7" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们将建立一个具有两个隐藏层的神经网络。一个隐藏层有300个神经元，另一个有100个神经元。使用顺序连接的神经元层创建神经网络。因此，顺序API有助于将神经元层连接在一起。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="a26b" class="ju jv hi kv b fi kz la l lb lc">model=keras.models.Sequential()</span></pre><p id="8ba2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在加载数据时，您可能已经注意到了输入数据的维度。<em class="ld"> </em> (60000，28，28)表示有60000张尺寸为28 x 28的图片。因此，我们的下一步是拉平我们现有的数据。然后，输入数据通过展平层，然后将图像转换为1D阵列。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="17ac" class="ju jv hi kv b fi kz la l lb lc">model.add(keras.layers.Flatten(input_shape=[28,28]))</span></pre><p id="bf6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将创建隐藏层并初始化它们各自的激活功能。</p><blockquote class="lf lg lh"><p id="e9d1" class="if ig ld ih b ii ij ik il im in io ip li ir is it lj iv iw ix lk iz ja jb jc hb bi translated"><strong class="ih hj">激活函数</strong>是添加到人工神经网络中的<strong class="ih hj">函数</strong>，以便帮助网络学习数据中的复杂模式。我们在最后一层使用softmax，因为这是一个多标签分类。</p></blockquote><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="d383" class="ju jv hi kv b fi kz la l lb lc">model.add(keras.layers.Dense(300,activation=”relu”))<br/>model.add(keras.layers.Dense(100,activation=”relu”))<br/>model.add(keras.layers.Dense(10,activation=”softmax”))</span></pre><div class="ll lm ez fb ln lo"><a href="https://towardsdatascience.com/everything-you-need-to-know-about-activation-functions-in-deep-learning-models-84ba9f82c253" rel="noopener follow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">关于深度学习模型中的“激活函数”，你需要知道的一切</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">这篇文章是你的废话一站式解决每个可能的问题，有关激活功能…</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">towardsdatascience.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc jn lo"/></div></div></a></div><p id="0197" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是一篇很好的文章，如果你想了解更多关于激活函数的知识。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="360a" class="ju jv hi kv b fi kz la l lb lc">model.summary()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es md"><img src="../Images/814249af113820e23914996e5105c7b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*r6NQkYInwhT8n907F-dQ0g.png"/></div></figure><p id="3f99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隐藏层中的每个节点将具有与其相关联的权重和偏差。当784输入连接到隐藏层中的每个节点时，它为密集层创建784 * 300+ 300 = 235500个参数。类似地，密度较大的层将有300*100+100=30100个相关参数。dense_2图层将有100*10+10=1010个参数。</p><p id="73e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以通过以下方式访问模型的层列表</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="bfa5" class="ju jv hi kv b fi kz la l lb lc">model.layers<br/>//assigning the values of weights and bias of first hidden layers<br/>hidden1=model.layers[1]<br/>weights,biases=hidden1.get_weights()</span></pre><h2 id="d53a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">编译模型</h2><p id="3544" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">现在我们需要指定我们将使用的损失函数和优化器。以下是TensorFlow对相关损失的记录。</p><div class="ll lm ez fb ln lo"><a href="https://www.tensorflow.org/api_docs/python/tf/keras/losses" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">模块:TF . keras . loss | tensor flow Core v 2 . 4 . 0</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">内置损失函数。</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">www.tensorflow.org</p></div></div></div></a></div><p id="78ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于输出是多类的，我们将使用稀疏分类交叉熵。</p><p id="194c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TensorFlow中可用的熵类型在下面的文档中提供。</p><p id="ff83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在模型创建好了，让我们定义损失函数和优化器。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="18d4" class="ju jv hi kv b fi kz la l lb lc">model.compile(loss=”sparse_categorical_crossentropy”,optimizer=”sgd”,metrics=[“accuracy”])</span></pre><div class="ll lm ez fb ln lo"><a href="https://www.tensorflow.org/api_docs/python/tf/keras/optimizers" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">模块:TF . keras . optimizer | tensor flow Core v 2 . 4 . 0</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">内置优化器类。</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">www.tensorflow.org</p></div></div></div></a></div><h2 id="9927" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">训练和评估模型</h2><p id="6e95" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们将拟合模型，并根据测试数据评估结果。我们正在为训练初始化30个纪元。Epochs表示机器学习<strong class="ih hj"> </strong>算法已经完成的整个训练数据集的通过次数。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="5b4f" class="ju jv hi kv b fi kz la l lb lc">history=model.fit(train_X, train_Y,epochs=30,validation_data=(valid_X,valid_Y))</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es me"><img src="../Images/4033cb5cc0b48bde8af7a65dabbbbc51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdKHGmq69wWrInzOgw-MZQ.png"/></div></div></figure><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="6f79" class="ju jv hi kv b fi kz la l lb lc">model.evaluate(test_X,test_Y)<br/>X_new = X_test[:3]<br/>y_proba = model.predict(X_new)<br/>y_proba.round(2)<br/>y_pred = model.predict_classes(X_new)<br/>y_pred<br/>np.array(class_names)[y_pred]<br/>y_new = y_test[:3]<br/>y_new</span></pre><p id="64a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型评估给了我们87%的准确率，这已经足够了。现在，我们将尝试查看使用数据集中的图像生成的输出。</p><pre class="je jf jg jh fd ku kv kw kx aw ky bi"><span id="2bf2" class="ju jv hi kv b fi kz la l lb lc"><strong class="kv hj">for</strong> index, image <strong class="kv hj">in</strong> enumerate(X_new):<br/>    plt.subplot(1, 3, index + 1)<br/>    plt.imshow(image, cmap="binary", interpolation="nearest")<br/>    plt.axis('off')<br/>    plt.title(class_names[y_test[index]], fontsize=12)<br/>plt.subplots_adjust(wspace=0.2, hspace=0.5)<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mf"><img src="../Images/59f53272ac43711bf6a46261321d1f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*1DWkeegdwq2ZNDEgmB2krA.png"/></div></figure><p id="3a73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建的图像分类器对于数据集来说看起来相当不错。这是图像分类中神经网络的一个非常简单的实现。希望你能从这篇文章中得到一些启示。更多信息请关注:)</p></div></div>    
</body>
</html>