<html>
<head>
<title>Understanding OpenAI baseline source code and making it do self-play! Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解OpenAI基线源代码，让它做自玩！第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-openai-baseline-source-code-and-making-it-do-self-play-part-2-9f8c4fd3e3b5?source=collection_archive---------9-----------------------#2019-12-05">https://medium.com/analytics-vidhya/understanding-openai-baseline-source-code-and-making-it-do-self-play-part-2-9f8c4fd3e3b5?source=collection_archive---------9-----------------------#2019-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/0c4e24ae4dd215d07c5cf52498b2ba0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*BY5NA77e54PDoBWiaKHufw.png"/></div></figure><p id="edc8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上一节中，我们一直到train函数，并在实际构建环境之前停下来。要查看，请点击<a class="ae jk" rel="noopener" href="/analytics-vidhya/understanding-openai-baseline-source-code-and-making-it-do-self-play-part-1-9f30085a8c16">此处</a>！</p><h1 id="d7a2" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">构建_环境</h1><p id="63a9" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">在下一行，我们看到</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c83a" class="kx jm hi kt b fi ky kz l la lb">env = build_env(args)</span></pre><p id="063a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么，让我们来看看build_env函数！</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2514" class="kx jm hi kt b fi ky kz l la lb">def build_env(args):<br/>    ncpu = multiprocessing.cpu_count()<br/>    if sys.platform == 'darwin': ncpu //= 2<br/>    nenv = args.num_env or ncpu<br/>    alg = args.alg<br/>    seed = args.seed</span><span id="fde4" class="kx jm hi kt b fi lc kz l la lb">    env_type, env_id = get_env_type(args)</span><span id="85bd" class="kx jm hi kt b fi lc kz l la lb">    if env_type in {'atari', 'retro'}:<br/>        if alg == 'deepq':<br/>            env = make_env(env_id, env_type, seed=seed,             wrapper_kwargs={'frame_stack': True})<br/>        elif alg == 'trpo_mpi':<br/>            env = make_env(env_id, env_type, seed=seed)<br/>        else:<br/>            frame_stack_size = 4<br/>            env = make_vec_env(env_id, env_type, nenv, seed, gamestate=args.gamestate, reward_scale=args.reward_scale)<br/>            env = VecFrameStack(env, frame_stack_size)</span><span id="9bdd" class="kx jm hi kt b fi lc kz l la lb">    else:<br/>        config = tf.ConfigProto(allow_soft_placement=True,<br/>                               intra_op_parallelism_threads=1,<br/>                               inter_op_parallelism_threads=1)<br/>        config.gpu_options.allow_growth = True<br/>        get_session(config=config)</span><span id="3a43" class="kx jm hi kt b fi lc kz l la lb">        flatten_dict_observations = alg not in {'her'}<br/>        env = make_vec_env(env_id, env_type, args.num_env or 1, seed, reward_scale=args.reward_scale, flatten_dict_observations=flatten_dict_observations)</span><span id="231a" class="kx jm hi kt b fi lc kz l la lb">        if env_type == 'mujoco':<br/>            env = VecNormalize(env, use_tf=True)</span><span id="5c60" class="kx jm hi kt b fi lc kz l la lb">    return env</span></pre><p id="42ec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="863f" class="kx jm hi kt b fi ky kz l la lb">ncpu = multiprocessing.cpu_count()<br/>if sys.platform == 'darwin': ncpu //= 2<br/>nenv = args.num_env or ncpu<br/>alg = args.alg<br/>seed = args.seed</span></pre><p id="8470" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">似乎在初始化参数。这里，一个非常常见但有趣的技巧是使用关键字or来利用nenv变量。一旦你考虑到“或”是做什么的，这是非常直观的。首先，要注意的一个基本事实是，如果其中一个参数为真，or语句将返回true。因此，如果args.num_env不是None，它将被设置为nenvs，否则它将返回ncpu(根据<a class="ae jk" href="https://stackoverflow.com/questions/31344582/python-multiprocessing-cpu-count-returns-1-on-4-core-nvidia-jetson-tk1" rel="noopener ugc nofollow" target="_blank">这里的</a>，它是在线cpu的数量)！这是一个让你的代码更短的巧妙方法！</p><p id="4001" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，我们看到</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="88f7" class="kx jm hi kt b fi ky kz l la lb">env_type, env_id = get_env_type(args)</span><span id="0c71" class="kx jm hi kt b fi lc kz l la lb">if env_type in {'atari', 'retro'}:</span></pre><p id="cfd4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为我们可以从参数中指定env_type，并且因为我们的环境是自定义的，所以我们可以跳过这个if语句的内容，直接进入else部分。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5f68" class="kx jm hi kt b fi ky kz l la lb">else:<br/>        config = tf.ConfigProto(allow_soft_placement=True,<br/>                               intra_op_parallelism_threads=1,<br/>                               inter_op_parallelism_threads=1)<br/>        config.gpu_options.allow_growth = True<br/>        get_session(config=config)</span><span id="1515" class="kx jm hi kt b fi lc kz l la lb">        flatten_dict_observations = alg not in {'her'}<br/>        env = make_vec_env(env_id, env_type, args.num_env or 1,        seed, reward_scale=args.reward_scale, flatten_dict_observations=flatten_dict_observations)</span><span id="4827" class="kx jm hi kt b fi lc kz l la lb">        if env_type == 'mujoco':<br/>            env = VecNormalize(env, use_tf=True)</span></pre><p id="610e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，什么是允许软放置？根据<a class="ae jk" href="https://stackoverflow.com/questions/44873273/what-do-the-options-in-configproto-like-allow-soft-placement-and-log-device-plac" rel="noopener ugc nofollow" target="_blank">这里的</a>，它允许你可以在特定的GPU上运行操作。例如，你可以做</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="69ed" class="kx jm hi kt b fi ky kz l la lb">with tf.device('/gpu:0'):</span></pre><p id="f0a5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">具体分配到第0个gpu哪个有意思。</p><p id="f03f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">突出的下一行是</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ff16" class="kx jm hi kt b fi ky kz l la lb">env = make_vec_env(env_id, env_type, args.num_env or 1,        seed, reward_scale=args.reward_scale, flatten_dict_observations=flatten_dict_observations</span></pre><p id="65f5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们看看make_vec_env是做什么的！</p><h1 id="d599" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">制造_车辆_环境</h1><p id="7301" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">make_vec_env驻留在cmd_utils.py中</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1b27" class="kx jm hi kt b fi ky kz l la lb">def make_vec_env(env_id, env_type, num_env, seed,<br/>                 wrapper_kwargs=None,<br/>                 env_kwargs=None,<br/>                 start_index=0,<br/>                 reward_scale=1.0,<br/>                 flatten_dict_observations=True,<br/>                 gamestate=None,<br/>                 initializer=None,<br/>                 force_dummy=False):<br/>    """<br/>    Create a wrapped, monitored SubprocVecEnv for Atari and MuJoCo.<br/>    """<br/>    wrapper_kwargs = wrapper_kwargs or {}<br/>    env_kwargs = env_kwargs or {}<br/>    mpi_rank = MPI.COMM_WORLD.Get_rank() if MPI else 0<br/>    seed = seed + 10000 * mpi_rank if seed is not None else None<br/>    logger_dir = logger.get_dir()<br/>    def make_thunk(rank, initializer=None):<br/>        return lambda: make_env(<br/>            env_id=env_id,<br/>            env_type=env_type,<br/>            mpi_rank=mpi_rank,<br/>            subrank=rank,<br/>            seed=seed,<br/>            reward_scale=reward_scale,<br/>            gamestate=gamestate,<br/>            flatten_dict_observations=flatten_dict_observations,<br/>            wrapper_kwargs=wrapper_kwargs,<br/>            env_kwargs=env_kwargs,<br/>            logger_dir=logger_dir,<br/>            initializer=initializer<br/>        )</span><span id="c463" class="kx jm hi kt b fi lc kz l la lb">     set_global_seeds(seed)<br/>     if not force_dummy and num_env &gt; 1:<br/>        return SubprocVecEnv([make_thunk(i + start_index, initializer=initializer) for i in range(num_env)])<br/>     else:<br/>        return DummyVecEnv([make_thunk(i + start_index, initializer=None) for i in range(num_env)])</span></pre><p id="9f4b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们在运行时想要多个环境，我就是这种情况！因此，我们将只查看SubprocVecEnv。但我认为公平地说，在对环境的期望方面，它将与DummyVecEnv非常相似。</p><p id="c4ff" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在检查它的作用之前，让我们先检查make_thunk。这是一个有趣的函数，因为它返回一个带有传入参数的函数。它的方式是下面的方法</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5521" class="kx jm hi kt b fi ky kz l la lb">def a(args):<br/>    return lambda : b(args)</span></pre><p id="1362" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我觉得这很酷！无论如何，我们不要分心，看看返回的函数:make_env。</p><h1 id="0378" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">制作_环境</h1><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ead9" class="kx jm hi kt b fi ky kz l la lb">def make_env(env_id, env_type, mpi_rank=0, subrank=0, seed=None, reward_scale=1.0, gamestate=None, flatten_dict_observations=True, wrapper_kwargs=None, env_kwargs=None, logger_dir=None, initializer=None):<br/>    if initializer is not None:<br/>        initializer(mpi_rank=mpi_rank, subrank=subrank)</span><span id="938c" class="kx jm hi kt b fi lc kz l la lb">    wrapper_kwargs = wrapper_kwargs or {}<br/>    env_kwargs = env_kwargs or {}<br/>    if ':' in env_id:<br/>        import re<br/>        import importlib<br/>        module_name = re.sub(':.*','',env_id)<br/>        env_id = re.sub('.*:', '', env_id)<br/>        importlib.import_module(module_name)<br/>    if env_type == 'atari':<br/>        env = make_atari(env_id)<br/>    elif env_type == 'retro':<br/>        import retro<br/>        gamestate = gamestate or retro.State.DEFAULT<br/>        env = retro_wrappers.make_retro(game=env_id,   max_episode_steps=10000,   use_restricted_actions=retro.Actions.DISCRETE, state=gamestate)<br/>    else:<br/>        env = gym.make(env_id, **env_kwargs)</span><span id="f050" class="kx jm hi kt b fi lc kz l la lb">    if flatten_dict_observations and   isinstance(env.observation_space, gym.spaces.Dict):<br/>        keys = env.observation_space.spaces.keys()<br/>        env = gym.wrappers.FlattenDictWrapper(env,  dict_keys=list(keys))</span><span id="3474" class="kx jm hi kt b fi lc kz l la lb">    env.seed(seed + subrank if seed is not None else None)<br/>    env = Monitor(env,<br/>                  logger_dir and os.path.join(logger_dir,       str(mpi_rank) + '.' + str(subrank)),<br/>                  allow_early_resets=True)</span><span id="9600" class="kx jm hi kt b fi lc kz l la lb">    if env_type == 'atari':<br/>        env = wrap_deepmind(env, **wrapper_kwargs)<br/>    elif env_type == 'retro':<br/>        if 'frame_stack' not in wrapper_kwargs:<br/>            wrapper_kwargs['frame_stack'] = 1<br/>        env = retro_wrappers.wrap_deepmind_retro(env, **wrapper_kwargs)</span><span id="fd84" class="kx jm hi kt b fi lc kz l la lb">    if isinstance(env.action_space, gym.spaces.Box):<br/>        env = ClipActionsWrapper(env)</span><span id="39e2" class="kx jm hi kt b fi lc kz l la lb">    if reward_scale != 1:<br/>        env = retro_wrappers.RewardScaler(env, reward_scale)</span><span id="9fc6" class="kx jm hi kt b fi lc kz l la lb">    return env</span></pre><p id="467f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于前两行，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="eacc" class="kx jm hi kt b fi ky kz l la lb">    if initializer is not None:<br/>        initializer(mpi_rank=mpi_rank, subrank=subrank)</span></pre><p id="29b1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我不是特别确定什么是初始化式，但是对于我们之前看过的所有函数，初始化式都被设置为None，所以我们现在跳过它！</p><p id="0419" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下一段有趣的代码是</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b059" class="kx jm hi kt b fi ky kz l la lb">if ':' in env_id:<br/>        import re<br/>        import importlib<br/>        module_name = re.sub(':.*','',env_id)<br/>        env_id = re.sub('.*:', '', env_id)<br/>        importlib.import_module(module_name)</span></pre><p id="f822" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">基本上，这里发生的事情是，我的自定义环境将被加载到这里。这是通过删除env_id中的所有past:并返回before部分来实现的！另一方面，env_id被设置为“:”后面的部分。这是通过添加一个句点来实现的，该句点基本上匹配除换行符之外的所有字符，而*表示它匹配0个或更多前面的标记(。).在这里执行re.sub会将这些模式突出显示的部分替换为第二个参数''，nothing。我发现查看regex很有趣，因为我对它不是特别熟悉，试图找到它做什么就像一个小难题。够了！让我们继续</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9bbe" class="kx jm hi kt b fi ky kz l la lb">if env_type == 'atari':<br/>        env = make_atari(env_id)<br/>elif env_type == 'retro':<br/>        import retro<br/>        gamestate = gamestate or retro.State.DEFAULT<br/>        env = retro_wrappers.make_retro(game=env_id,    max_episode_steps=10000,     use_restricted_actions=retro.Actions.DISCRETE, state=gamestate)<br/>else:<br/>        env = gym.make(env_id, **env_kwargs)</span></pre><p id="c2d8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为我们的环境既不是atari也不是retro，所以运行gym.make功能。这个函数是什么？</p><h1 id="7f0d" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">制造</h1><p id="af51" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">我花了一段时间才找到它，但在gym . make . registration我找到了它！</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2d08" class="kx jm hi kt b fi ky kz l la lb">registry = EnvRegistry()</span><span id="a98a" class="kx jm hi kt b fi lc kz l la lb">def register(id, **kwargs):<br/>    return registry.register(id, **kwargs)</span><span id="dc50" class="kx jm hi kt b fi lc kz l la lb">def make(id, **kwargs):<br/>    return registry.make(id, **kwargs)</span></pre><p id="d8ae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个make函数运行函数</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="cdaf" class="kx jm hi kt b fi ky kz l la lb">def make(self, path, **kwargs):<br/>        if len(kwargs) &gt; 0:<br/>            logger.info('Making new env: %s (%s)', path, kwargs)<br/>        else:<br/>            logger.info('Making new env: %s', path)<br/>        spec = self.spec(path)<br/>        env = spec.make(**kwargs)<br/>        # We used to have people override _reset/_step rather than<br/>        # reset/step. Set _gym_disable_underscore_compat = True on<br/>        # your environment if you use these methods and don't want<br/>        # compatibility code to be invoked.<br/>        if hasattr(env, "_reset") and hasattr(env, "_step") and not       getattr(env, "_gym_disable_underscore_compat", False):<br/>            patch_deprecated_methods(env)<br/>        if (env.spec.max_episode_steps is not None) and not spec.tags.get('vnc'):<br/>            from gym.wrappers.time_limit import TimeLimit<br/>            env = TimeLimit(env, max_episode_steps=env.spec.max_episode_steps)<br/>        return env</span></pre><p id="18c4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第一，什么是kwargs？这是python中比较好的特性之一，如果你在调用一个函数时有一个变量名称=变量形式的参数列表，比如(向极客的极客们致敬)</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="00c2" class="kx jm hi kt b fi ky kz l la lb"><strong class="kt hj">def</strong> <!-- -->myFun(arg1, <strong class="kt hj">**</strong>kwargs):<br/>   <strong class="kt hj">for</strong> <!-- -->key, value <strong class="kt hj">in</strong> <!-- -->kwargs.items():<br/>        print<!-- --> <!-- -->("%s == %s"<!-- --> <strong class="kt hj">%</strong>(key, value))</span><span id="87e0" class="kx jm hi kt b fi lc kz l la lb"># Driver code</span><span id="e340" class="kx jm hi kt b fi lc kz l la lb">myFun("Hi", first <strong class="kt hj">=</strong>'Geeks', mid <strong class="kt hj">=</strong>'for', last<strong class="kt hj">=</strong>'Geeks')</span></pre><p id="c4b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它会打印出来</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f29f" class="kx jm hi kt b fi ky kz l la lb">last == Geeks<br/>mid == for<br/>first == Geeks</span></pre><p id="8d68" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它的名字就是这么来的！关键字参数，kwargs。您可以使用*args来获得通常的参数，但这应该在kwargs之前！</p><p id="3ded" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，这个函数在env文件的路径上运行spec函数。</p><h1 id="6021" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">投机</h1><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0d8c" class="kx jm hi kt b fi ky kz l la lb">def spec(self, path):<br/>        if ':' in path:<br/>            mod_name, _sep, id = path.partition(':')<br/>            try:<br/>                importlib.import_module(mod_name)<br/>            # catch ImportError for python2.7 compatibility<br/>            except ImportError:<br/>                raise error.Error('A module ({}) was specified for the environment but was not found, make sure the package is installed with `pip install` before calling `gym.make()`'.format(mod_name))<br/>        else:<br/>            id = path</span><span id="2206" class="kx jm hi kt b fi lc kz l la lb">match = env_id_re.search(id)<br/>        if not match:<br/>            raise error.Error('Attempted to look up malformed environment ID: {}. (Currently all IDs must be of the form {}.)'.format(id.encode('utf-8'), env_id_re.pattern))</span><span id="c5e2" class="kx jm hi kt b fi lc kz l la lb">try:<br/>            return self.env_specs[id]<br/>        except KeyError:<br/>            # Parse the env name and check to see if it matches the non-version<br/>            # part of a valid env (could also check the exact number here)<br/>            env_name = match.group(1)<br/>            matching_envs = [valid_env_name for valid_env_name, valid_env_spec in self.env_specs.items()<br/>                             if env_name == valid_env_spec._env_name]<br/>            if matching_envs:<br/>                raise error.DeprecatedEnv('Env {} not found (valid versions include {})'.format(id, matching_envs))<br/>            else:<br/>                raise error.UnregisteredEnv('No registered env with id: {}'.format(id))</span></pre><p id="7181" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">规范首先看路径参数。如果它包含一个模块(includes:)，它将尝试导入它并将id部分放入id变量中。否则，它只是将id变量设置为path。</p><p id="802d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="15ee" class="kx jm hi kt b fi ky kz l la lb">match = env_id_re.search(id)</span></pre><p id="5e5b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在哪里</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="263c" class="kx jm hi kt b fi ky kz l la lb">env_id_re = re.compile(r'^(?:[\w:-]+\/)?([\w:.-]+)-v(\d+)$')</span></pre><p id="6ff5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，是时候来点正则表达式了！阅读<a class="ae jk" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">此处</a>跟随前进！^运算符匹配字符串的开头，然后是(？:…)匹配括号内的所有内容。这将匹配多个(+)单词(\w)、冒号和减号。接下来是/。？这表示前面模式的0或1次重复。最后，它将再次匹配单词、冒号和减号，后面跟一个v和最后以$结尾的小数(\d+)。$表示这是该行的结尾..例如，如果id有一个模式</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="070e" class="kx jm hi kt b fi ky kz l la lb">env_name-v0</span></pre><p id="b018" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这将是一场比赛！因此，它必须是环境名和版本的形式</p><p id="ab5d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此我们知道id必须是什么形式。代码中的下一行试图在env_specs变量中搜索id。这应该添加在make函数之前调用的函数中，register函数将通过</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0aa7" class="kx jm hi kt b fi ky kz l la lb">def register(id, **kwargs):<br/>    return registry.register(id, **kwargs)</span></pre><p id="059f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">和</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b3aa" class="kx jm hi kt b fi ky kz l la lb">def register(self, id, **kwargs):<br/>        if id in self.env_specs:<br/>            raise error.Error('Cannot re-register id: {}'.format(id))<br/>        self.env_specs[id] = EnvSpec(id, **kwargs)</span></pre><p id="3bd9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在EnvRegistry类中。因此，返回id的EnvSpec。</p><p id="a039" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">根据注释，EnvSpec类存储“特定环境实例的规范”。使用<br/>登记官方评估的参数在init函数中，我们在EnvSpec的__init__函数中看到了这一点</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="7362" class="kx jm hi kt b fi ky kz l la lb">def __init__(self, id, entry_point=None, reward_threshold=None,    kwargs=None, nondeterministic=False, tags=None, max_episode_steps=None):<br/>        self.id = id<br/>        # Evaluation parameters<br/>        self.reward_threshold = reward_threshold<br/>        # Environment properties<br/>        self.nondeterministic = nondeterministic<br/>        self.entry_point = entry_point</span><span id="7145" class="kx jm hi kt b fi lc kz l la lb">if tags is None:<br/>            tags = {}<br/>        self.tags = tags</span><span id="0422" class="kx jm hi kt b fi lc kz l la lb">tags['wrapper_config.TimeLimit.max_episode_steps'] = max_episode_steps<br/>        <br/>        self.max_episode_steps = max_episode_steps</span><span id="13d6" class="kx jm hi kt b fi lc kz l la lb"># We may make some of these other parameters public if they're<br/>        # useful.<br/>        match = env_id_re.search(id)<br/>        if not match:<br/>            raise error.Error('Attempted to register malformed environment ID: {}. (Currently all IDs must be of the form {}.)'.format(id, env_id_re.pattern))<br/>        self._env_name = match.group(1)<br/>        self._kwargs = {} if kwargs is None else kwargs</span></pre><h1 id="71fa" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">回到注册表make函数</h1><p id="98f4" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">下一行执行</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="89a1" class="kx jm hi kt b fi ky kz l la lb">env = spec.make(**kwargs)</span></pre><p id="1568" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以我们来看看Spec的make函数。</p><h1 id="80c2" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">规格制造功能</h1><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b845" class="kx jm hi kt b fi ky kz l la lb">def make(self, **kwargs):<br/>        """Instantiates an instance of the environment with appropriate kwargs"""<br/>        if self.entry_point is None:<br/>            raise error.Error('Attempting to make deprecated env {}. (HINT: is there a newer registered version of this env?)'.format(self.id))<br/>        _kwargs = self._kwargs.copy()<br/>        _kwargs.update(kwargs)<br/>        if callable(self.entry_point):<br/>            env = self.entry_point(**_kwargs)<br/>        else:<br/>            cls = load(self.entry_point)<br/>            env = cls(**_kwargs)</span><span id="36ce" class="kx jm hi kt b fi lc kz l la lb">        # Make the enviroment aware of which spec it came from.<br/>        env.unwrapped.spec = self</span><span id="9a20" class="kx jm hi kt b fi lc kz l la lb">return env</span></pre><p id="f7ca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，获取入口点并检查它是否是有效的入口点。根据评论，它应该是这样的形式</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="7aa0" class="kx jm hi kt b fi ky kz l la lb">The Python entrypoint of the environment class (e.g. module.name:Class)</span></pre><p id="cb04" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">或者它可以只是模块名</p><p id="6d9f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，它通过调用self.entry_point或者通过调用</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d273" class="kx jm hi kt b fi ky kz l la lb">def load(name):<br/>    mod_name, attr_name = name.split(":")<br/>    mod = importlib.import_module(mod_name)<br/>    fn = getattr(mod, attr_name)<br/>    return fn</span></pre><p id="153d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后调用那个函数！</p><p id="8329" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后用关键字参数运行它。然后它设置self.unwrapped_spec，但我不完全确定这是做什么的。</p><h1 id="e043" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">注册表生成功能</h1><p id="2e60" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">完成后</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d19c" class="kx jm hi kt b fi ky kz l la lb">if hasattr(env, "_reset") and hasattr(env, "_step") and not getattr(env, "_gym_disable_underscore_compat", False):<br/>            patch_deprecated_methods(env)</span></pre><p id="918b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，它检查env是否有方法_reset和_step，我认为这是内置在gym.Env中的。因此，我怀疑getattr(env，" _ gym _ disable _下划线_compat "，False)的默认输出是False。我们可以通过简单地运行</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4d3b" class="kx jm hi kt b fi ky kz l la lb">import gym<br/>getattr(gym.Env, "_gym_disable_underscore_compat", False)</span></pre><p id="cd3d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它确实返回了False！我去健身房了。因为这是我们定制环境的基础。就像我从体育馆继承的一样。通过做来包围</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a1b8" class="kx jm hi kt b fi ky kz l la lb">class Game_Env(gym.Env):<br/>    def __init__<br/>...</span></pre><p id="e224" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，下一行</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a1aa" class="kx jm hi kt b fi ky kz l la lb">patch_deprecated_methods(env)</span></pre><p id="ea36" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">会被挤兑。这基本上将env.reset设置为env。_reset和env.step to env。_step等等。但是等等，那么我们定义的阶跃函数会发生什么呢？为了检查这个函数是否实际执行，我运行了</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e314" class="kx jm hi kt b fi ky kz l la lb">hasattr(gym.Env, "_reset")</span></pre><p id="b22a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">返回False。因此，该语句不会针对我的环境运行！</p><p id="876b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，添加如下时间限制</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5ef2" class="kx jm hi kt b fi ky kz l la lb">if (env.spec.max_episode_steps is not None) and not spec.tags.get('vnc'):<br/>            from gym.wrappers.time_limit import TimeLimit<br/>            env = TimeLimit(env, max_episode_steps=env.spec.max_episode_steps)</span></pre><p id="bdf4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我发现他们这样做的方式非常有趣，因为它有助于抽象环境。当您查看gym.wrappers.time_limit时，TimeLimit classes only函数似乎正在跟踪它处于哪个步骤，同时还执行环境的步骤，如下所示！</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="bbdf" class="kx jm hi kt b fi ky kz l la lb">class TimeLimit(gym.Wrapper):<br/>    def __init__(self, env, max_episode_steps=None):<br/>        super(TimeLimit, self).__init__(env)<br/>        if max_episode_steps is None and self.env.spec is not None:<br/>            max_episode_steps = env.spec.max_episode_steps<br/>        if self.env.spec is not None:<br/>            self.env.spec.max_episode_steps = max_episode_steps<br/>        self._max_episode_steps = max_episode_steps<br/>        self._elapsed_steps = None</span><span id="2ca2" class="kx jm hi kt b fi lc kz l la lb">    def step(self, action):<br/>        assert self._elapsed_steps is not None, "Cannot call env.step() before calling reset()"<br/>        observation, reward, done, info = self.env.step(action)<br/>        self._elapsed_steps += 1<br/>        if self._elapsed_steps &gt;= self._max_episode_steps:<br/>            info['TimeLimit.truncated'] = not done<br/>            done = True<br/>        return observation, reward, done, info</span><span id="4c11" class="kx jm hi kt b fi lc kz l la lb">   def reset(self, **kwargs):<br/>        self._elapsed_steps = 0<br/>        return self.env.reset(**kwargs)</span></pre><p id="5aa0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它特别好，因为每个包装器都增强了步进和重置功能！我想从现在开始我会做这样的事情，因为它看起来很酷。目前，我的环境的代码在1000行的情况下不是特别好，所以我计划使用这种技术使我的代码更整洁。</p><p id="b53b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">反正过了这一关，环境归环境！</p><h1 id="a7b6" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">返回make_env</h1><p id="229f" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">下一行代码是</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ec35" class="kx jm hi kt b fi ky kz l la lb">if flatten_dict_observations and isinstance(env.observation_space, gym.spaces.Dict):</span></pre><p id="1fd8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是既然我的观察空间都是空间。框中，我可以跳过这一行，但由于我有点好奇字典是如何“展平”的，让我们来检查一下！if语句的内容是</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="715e" class="kx jm hi kt b fi ky kz l la lb">env = FlattenObservation(env)</span></pre><p id="2dd9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在体育馆的包装纸里找到的，没错</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f3ae" class="kx jm hi kt b fi ky kz l la lb">import numpy as np<br/>import gym.spaces as spaces<br/>from gym import ObservationWrapper</span><span id="df8e" class="kx jm hi kt b fi lc kz l la lb">class FlattenObservation(ObservationWrapper):<br/>    r"""Observation wrapper that flattens the observation."""<br/>    def __init__(self, env):<br/>        super(FlattenObservation, self).__init__(env)</span><span id="6ec3" class="kx jm hi kt b fi lc kz l la lb">        flatdim = spaces.flatdim(env.observation_space)<br/>        self.observation_space = spaces.Box(low=-float('inf'), high=float('inf'), shape=(flatdim,), dtype=np.float32)</span><span id="3ca6" class="kx jm hi kt b fi lc kz l la lb">    def observation(self, observation):<br/>        return spaces.flatten(self.env.observation_space, observation)</span></pre><p id="cc39" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，基本上，它使用空间中定义的函数将观察空间改变为一个盒子。这个模块导入了utils，我在里面找到了flatten和flatdim</p><p id="e067" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于所有可能的观察空间，flatdim返回单个整数形式的整数，如下所示</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6a45" class="kx jm hi kt b fi ky kz l la lb">def flatdim(space):<br/>    if isinstance(space, Box):<br/>        return int(np.prod(space.shape))<br/>    elif isinstance(space, Discrete):<br/>        return int(space.n)<br/>    elif isinstance(space, Tuple):<br/>        return int(sum([flatdim(s) for s in space.spaces]))<br/>    elif isinstance(space, Dict):<br/>        return int(sum([flatdim(s) for s in space.spaces.values()]))<br/>    elif isinstance(space, MultiBinary):<br/>        return int(space.n)<br/>    elif isinstance(space, MultiDiscrete):<br/>        return int(np.prod(space.shape))<br/>    else:<br/>        raise NotImplementedError</span></pre><p id="f75c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，在应用这个简洁的包装器后，self.observation_space将变成一维空间！我不确定这对卷积神经网络来说是不是一件好事，事实上这是一个图像问题，但无论如何，我觉得这很有趣。</p><p id="37a9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同样，flatten函数也是这样做的，它将观察空间展平为一维数组。</p><p id="1fee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们去下一行！</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="334a" class="kx jm hi kt b fi ky kz l la lb">env.seed(seed + subrank if seed is not None else None)<br/>env = Monitor(env,<br/>                  logger_dir and os.path.join(logger_dir, str(mpi_rank) + '.' + str(subrank)),<br/>                  allow_early_resets=True)</span></pre><p id="850b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就是跑。我怀疑env.seed只是为概率分布等设置了种子。然而，Monitor是做什么的呢？在baselines/bench中查看monitor.py之后，似乎这个包装器所做的就是在每一步，将奖励写入一个csv和json文件，以“monitor.json”和“monitor.csv”结尾！</p><p id="a94a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ce0d" class="kx jm hi kt b fi ky kz l la lb">if isinstance(env.action_space, gym.spaces.Box):<br/>        env = ClipActionsWrapper(env)</span></pre><p id="da36" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就是跑。这个ClipActionsWrapper的动作函数被定义为</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="7e1c" class="kx jm hi kt b fi ky kz l la lb">np.clip(action, self.action_space.low, self.action_space.high)</span></pre><p id="aa32" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，它将动作限制在设定的最大值和最小值。我喜欢他们用包装器来包装像这样的细节。它增强了可理解性，同时使代码更容易调试。</p><p id="4d20" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="15f9" class="kx jm hi kt b fi ky kz l la lb">if reward_scale != 1:<br/>        env = retro_wrappers.RewardScaler(env, reward_scale)</span><span id="773c" class="kx jm hi kt b fi lc kz l la lb">return env</span></pre><p id="b2c8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个包装器所做的只是将奖励乘以reward_scale</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c42e" class="kx jm hi kt b fi ky kz l la lb">def reward(self, reward):<br/>        return reward * self.scale</span></pre><p id="ca87" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，最终，env被返回。</p><p id="3110" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们讨论完make_env之后，让我们休息一下，在下一篇文章中讨论SubprocVecEnv！</p><h1 id="2ae3" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">然后</h1><p id="e76c" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">在下一篇文章中，我们将了解SubprocVecEnv并接触多处理！</p></div></div>    
</body>
</html>