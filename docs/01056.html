<html>
<head>
<title>How to visualize anything in Machine Learning using Yellowbrick and Mlxtend (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Yellowbrick和Mlxtend可视化机器学习中的任何东西(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-visualize-anything-in-machine-learning-using-yellowbrick-and-mlxtend-39c45e1e9e9f?source=collection_archive---------6-----------------------#2019-09-28">https://medium.com/analytics-vidhya/how-to-visualize-anything-in-machine-learning-using-yellowbrick-and-mlxtend-39c45e1e9e9f?source=collection_archive---------6-----------------------#2019-09-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7c37bb8a76c9fe14297c7d01d18e66c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53HIbejFtmd_sBYO3V38bg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">黄砖官方文件上的照片</figcaption></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><p id="d3a6" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated"><em class="jz">这是关于在ML中可视化一切的两部分故事的第一部分，其中我们将可视化数据、ML模型、使用可视化进行超参数调整并可视化结果。在这一部分，我们将把数据和ML模型可视化。</em></p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><p id="f23f" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">最近我正在用机器学习写一篇研究论文，而研究论文中最重要的东西之一就是图表和可视化。我们可以可视化我们的数据，通过各种ML算法获得的预测和最终结果。这也有助于更好地理解我们的数据，帮助我们为我们的工作选择合适的分类器。在这篇文章中，我们调查了使用Yellowbrick和Mlxtend的机器学习的可视化。</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="ec7e" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">什么是黄砖？</strong></h1><p id="e593" class="pw-post-body-paragraph jb jc hi jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hb bi translated">根据其文档，“Yellowbrick扩展了Scikit-Learn API，使模型选择和超参数调整更加容易。在引擎盖下，它使用Matplotlib。”使用Yellowbrick，我们可以执行特征、分类、回归、聚类、模型选择、目标甚至文本可视化。我们甚至可以使用它来可视化超参数调整，从而获得给定任务的最佳超参数。更多信息请参考官方<a class="ae ld" href="https://www.scikit-yb.org/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="e767" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">Yellowbrick需要python 3.4以上和scikit-learn 0.20以上和matplotlib 3 . 0 . 1以上版本才能最好的工作。使用pip安装</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="1863" class="ln kb hi lj b fi lo lp l lq lr">$ pip install yellowbrick</span></pre><p id="1c04" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">为anaconda安装conda</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="809b" class="ln kb hi lj b fi lo lp l lq lr">conda install -c districtdatalabs yellowbrick</span></pre><p id="fabb" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">Yellowbrick的主要接口是一个<strong class="jd hj">可视化器</strong>，它是一个scikit-learn估计器对象，从数据中学习以产生可视化。使用fit()导入、初始化和拟合可视化工具，以开发可视化工具。可视化工具API由三种主要方法组成:</p><ul class=""><li id="61fd" class="ls lt hi jd b je jf ji jj jm lu jq lv ju lw jy lx ly lz ma bi translated">draw():向轴添加可视元素。</li><li id="5cd8" class="ls lt hi jd b je mb ji mc jm md jq me ju mf jy lx ly lz ma bi translated">finalize():添加更精细的细节，如图例、标题、轴、标签等。</li><li id="e3e1" class="ls lt hi jd b je mb ji mc jm md jq me ju mf jy lx ly lz ma bi translated">poof():显示可视化工具或将它保存到磁盘。</li></ul><h1 id="d34b" class="ka kb hi bd kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx bi translated">什么是Mlxtend</h1><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/8f9ff396b7595093d9b2935874daadd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*46kqbbeAnwshUzwhkVeAmA.png"/></div></figure><p id="be00" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">Mlxtend是一个用于数据科学的有用工具的python库，它可以用于绘制不同的机器学习算法和集成学习(集成学习是一种组合各种机器学习算法的方法，以便减少方差和提高预测)。</p><p id="9f96" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">使用pip安装</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="2758" class="ln kb hi lj b fi lo lp l lq lr">pip install mlxtend</span></pre><p id="795b" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">使用conda安装</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="ab65" class="ln kb hi lj b fi lo lp l lq lr">conda <strong class="lj hj">install</strong> mlxtend <em class="jz">--channel conda-forge</em></span></pre></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="e707" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用Yellowbrick的数据可视化</h1><p id="85b2" class="pw-post-body-paragraph jb jc hi jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hb bi translated">数据可视化是获取数据(信息)并将其放入可视化设置(例如，指南或图表)的演示。对于大数据和数据分析项目，数据可视化尤为重要。它们用于可视化数据空间中的实例，以便识别可能影响下游拟合的突出显示。使用Yellowbrick，我们可以执行等级可视化、PCA投影、流形可视化等等。在我的论文中，我使用了PCA和流形可视化，这将在下面讨论</p><ul class=""><li id="0198" class="ls lt hi jd b je jf ji jj jm lu jq lv ju lw jy lx ly lz ma bi translated"><strong class="jd hj"> PCA </strong>利用正交变换将高维数据分解成二维或三维，以散点图的形式绘制每个实例。<a class="ae ld" href="https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c" rel="noopener" target="_blank">这篇</a>是一篇很棒的文章，可以阅读更多相关内容。</li></ul><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="12a4" class="ln kb hi lj b fi lo lp l lq lr">from yellowbrick.features.pca import PCADecomposition<br/>from yellowbrick.draw import manual_legend<br/>import matplotlib.pyplot as plt</span><span id="b3d6" class="ln kb hi lj b fi mm lp l lq lr">def visual_pca(x_train, y_train):<br/>    plt.figure()<br/>    colors = np.array(['b' if yi else 'r' for yi in y_train])<br/>    visualizer = PCADecomposition(scale=True, color=colors)<br/>    visualizer.fit_transform(x_train, y_train)<br/>    manual_legend(visualizer, ('real', 'forged'), ('b', 'r'))<br/>    visualizer.poof(outpath="pca.png")   <br/>    plt.close()</span></pre><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/fb50367591992a323a84fa89c7d16115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*z7MTwwyDVih_Tjcr2mA4HQ.png"/></div></figure><ul class=""><li id="1fd2" class="ls lt hi jd b je jf ji jj jm lu jq lv ju lw jy lx ly lz ma bi translated"><strong class="jd hj">流形</strong>可视化工具利用流形学习将多个维度降维为两个。流形捕捉非线性结构，因为它们使用最近邻方法。许多不同的算法具有不同的属性和时间复杂度，如lle、hessian、isomap、spectral、tsne等。Lle和isomap在本文中使用，将在下面讨论。</li></ul><ol class=""><li id="3d47" class="ls lt hi jd b je jf ji jj jm lu jq lv ju lw jy mo ly lz ma bi translated"><strong class="jd hj">局部线性嵌入(LLE) </strong>对数据进行低维投影，并保持局部邻域内的距离。这类似于一系列局部主成分分析，它们被全局比较以找到最佳非线性嵌入。</li></ol><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="379e" class="ln kb hi lj b fi lo lp l lq lr">from yellowbrick.features.manifold import Manifold<br/>import matplotlib.pyplot as plt</span><span id="63b2" class="ln kb hi lj b fi mm lp l lq lr">def visual_tsne(x_train, y_train):<br/>    plt.figure()<br/>    y = np.array(['real' if yi else 'forged' for yi in y_train])<br/>    visualizer = Manifold(manifold='lle', target='discrete')<br/>    visualizer.fit_transform(x_train, y)<br/>    visualizer.finalize()<br/>    visualizer.poof(outpath="lle.png")<br/>    plt.close()</span></pre><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/0df7789873ad40949385d257a502bcd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*od03sENqJ2Mw1DWpQpJLAw.png"/></div></figure><p id="e468" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">2.<strong class="jd hj"> Isomap </strong>是一种低维嵌入，保持所有点之间的测地线距离。它是内核PCA的扩展。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="872a" class="ln kb hi lj b fi lo lp l lq lr">from yellowbrick.features.manifold import Manifold<br/>import matplotlib.pyplot as plt</span><span id="aa2a" class="ln kb hi lj b fi mm lp l lq lr">def visual_isomap(x_train, y_train):<br/>    plt.figure()<br/>    y = np.array(['real' if yi else 'forged' for yi in y_train])<br/>    visualizer = Manifold(manifold='isomap', target='discrete')<br/>    visualizer.fit(x_train, y)<br/>    visualizer.poof(outpath="isomap.png")<br/>    plt.close()</span></pre><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/77aad8d9843de9e3c759182f88d1f7f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*1O8qcI6oPKg72cjvCJShsg.png"/></div></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="c982" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用Mlxtend可视化ML模型预测</h1><p id="6361" class="pw-post-body-paragraph jb jc hi jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hb bi translated">可视化ML模型有助于我们清楚地看到我们的模型是如何执行的，并且它还可以生成很好的图形😁。深入了解不同的算法如何对边界进行不同的分类是非常重要的，通过充分的练习，我们可以看到数据并了解哪个分类器工作得最好。我们将设想额外的树木，KNN，随机森林和SVM。要阅读更多关于<a class="ae ld" href="https://towardsdatascience.com/support-vector-machine-introduction-to-machine-learning-algorithms-934a444fca47" rel="noopener" target="_blank"> SVM </a>、<a class="ae ld" href="https://towardsdatascience.com/machine-learning-basics-with-the-k-nearest-neighbors-algorithm-6a6e71d01761" rel="noopener" target="_blank"> KNN </a>和<a class="ae ld" href="https://towardsdatascience.com/an-intuitive-explanation-of-random-forest-and-extra-trees-classifiers-8507ac21d54b" rel="noopener" target="_blank">额外的树和随机森林</a>点击这里。我们还将使用mlxtend通过组合所有这些预测来制作集成分类器。</p><p id="099b" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">Mlxtend有一个缺点，我们一次只能绘制任意两个特征之间的关系，其余的特征需要作为填充值传递。这个<a class="ae ld" href="https://stackoverflow.com/questions/52952310/plot-decision-regions-with-error-filler-values-must-be-provided-when-x-has-more/58116303#58116303" rel="noopener ugc nofollow" target="_blank"> stackoverflow问题</a>准确地描述了这一点。但是，在传入mlxtend 'plot_decision_regions '之前，我们可以使用PCA执行维度缩减，将维度缩减为两个，或者您可以传递填充值，如stackoverflow问题的答案中所给。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="921d" class="ln kb hi lj b fi lo lp l lq lr">from mlxtend.classifier import EnsembleVoteClassifier<br/>from mlxtend.plotting import plot_decision_regions<br/>import matplotlib.pyplot as plt<br/>from sklearn.decomposition import PCA</span><span id="f370" class="ln kb hi lj b fi mm lp l lq lr">def visual_ml(clf1, clf2, clf3, clf4, X, y):<br/>    y = np.array(y, dtype = np.uint)<br/>    pca = PCA(n_components = 2)<br/>    X = pca.fit_transform(X)<br/>    eclf = EnsembleVoteClassifier(clfs = [clf1, clf2, clf3, clf4], verbose = 2)<br/>    labels = ['KNN',<br/>          'Extra Trees',<br/>          'SVM',<br/>          'Random Forest',<br/>          'ensemble']<br/>    for clf, lab in zip([clf1, clf2, clf3, clf4, eclf], labels):<br/>        clf.fit(X, y)<br/>        plt.figure()<br/>        fig = plot_decision_regions(X=X, y=y, clf=clf)<br/>        plt.title(lab)<br/>        plt.show()<br/>        plt.close()</span></pre><div class="le lf lg lh fd ab cb"><figure class="mp ij mq mr ms mt mu paragraph-image"><img src="../Images/87a38378dda903f927c72cbe88bf566a.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*-aFJpd-acZIKsBgWtPv5YQ.png"/></figure><figure class="mp ij mq mr ms mt mu paragraph-image"><img src="../Images/4f3db6fa0960aa820ef632beeae23e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*1-sBizGCnQQvIwMX5x8MdQ.png"/></figure></div><div class="ab cb"><figure class="mp ij mq mr ms mt mu paragraph-image"><img src="../Images/6226222898265d8431af1d5228c7e54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*vC7zHcI9tnNJk7nMnDEVUA.png"/></figure><figure class="mp ij mq mr ms mt mu paragraph-image"><img src="../Images/388ed304350c03a17b05b8cdc15202d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*wpkLA6brhJ-JFezagaZuaQ.png"/><figcaption class="iq ir et er es is it bd b be z dx mv di mw mx translated">可视化ML模型</figcaption></figure></div><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es my"><img src="../Images/35e638165b8a53c28f656c61b0ed2b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*KfWE8PixmYrc7oRAxXZ86A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">mlxtend得到的系综模型</figcaption></figure><p id="9c78" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">这是第一部分。在第二部分，我们将可视化超参数调整和结果。</p></div></div>    
</body>
</html>