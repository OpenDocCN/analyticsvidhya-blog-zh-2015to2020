<html>
<head>
<title>Persistence Vs. Broadcast</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">持久性与广播</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/persistence-vs-broadcast-625265320bf9?source=collection_archive---------2-----------------------#2020-01-04">https://medium.com/analytics-vidhya/persistence-vs-broadcast-625265320bf9?source=collection_archive---------2-----------------------#2020-01-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7aaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数人并不清楚保存数据帧和广播数据帧之间的区别。让我为你简化一下。</p><p id="7edb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">持续进程</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/8d6f69a705d94498333d07cec77a890a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_4KR9DpTm4bT4ksbY2pvA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">持续流程</figcaption></figure><p id="425c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑一下，您有一个大小为12 GB的数据帧，6个分区和3个执行器。每个分区将有2 GB的数据在内存中，每个执行器将读取2个分区，因此每个执行器将有4 GB的数据在内存中。</p><blockquote class="jt ju jv"><p id="608e" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">这里需要注意的一个关键点是，每个执行器中的持久化数据将被存储在存储内存<em class="hi">中。</em></p></blockquote><p id="66eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">持久化—序列化</strong></p><p id="bb4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">播出流程</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ka"><img src="../Images/836a8ea1c09419311b64bc5cf5b695c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NusXX_raCbzZnu-FwUJQjg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">广播过程</figcaption></figure><p id="5d2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑一下，我们有相同的设置—大小为12 GB的数据，6个分区和3个执行器。Spark从每个分区读取数据的方式与它在Persist期间读取数据的方式相同。但是它将把执行器中的数据存储在工作内存<em class="jw">中</em>，并且将占用相同的空间量(每个执行器4 GB)。</p><blockquote class="jt ju jv"><p id="5d41" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">每个执行器将有2个分区，总共12 GB</p></blockquote><p id="2565" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，数据从工作存储器通过<em class="jw">收集</em>过程被拉至<em class="jw">驱动器。</em>驱动程序将数据帧转换为可广播对象(<em class="jw"> Hashmap)。</em></p><blockquote class="jt ju jv"><p id="b451" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">这个Hashmap对象的大小为12 GB。</p></blockquote><p id="b4fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，这个对象将被发送到每个执行者。</p><blockquote class="jt ju jv"><p id="aa07" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">每个执行器上的12 GB对象</p></blockquote><p id="312a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">广播期间在执行器上使用的总空间将是数据的实际大小和每个执行器中广播对象的大小，结果是x + n(x)。其中x是数据的大小，n是执行器的数量。</p><p id="1417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，用于广播的总空间将是12 + 3(12) = 48 GB。</p><blockquote class="jt ju jv"><p id="007a" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">需要注意的一点是，所有这些空间都将从工作内存中被利用。</p></blockquote><p id="ded8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在垃圾收集器运行并清除存储在执行器中的数据分区之前，情况一直如此。一旦垃圾收集器清除了数据，您将最终得到36gb——这是每个执行器上广播对象的总大小。</p><p id="f458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果需要了解执行器中的工作记忆和存储记忆，请参考文章—<a class="ae kb" rel="noopener" href="/@tharun026/spark-memory-management-583a16c1253f">https://medium . com/@ thar un 026/spark-Memory-management-583 a16 c 1253 f</a></p><p id="bf3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文是来自Databricks spark summit的Daniel Tomes视频的抄本。</p></div></div>    
</body>
</html>