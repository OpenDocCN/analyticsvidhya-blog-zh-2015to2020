<html>
<head>
<title>Ways To Handle Categorical Column Missing Data &amp; Its Implementations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分类列缺失数据的处理方法及其实现</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/ways-to-handle-categorical-column-missing-data-its-implementations-15dc4a56893?source=collection_archive---------1-----------------------#2020-09-01">https://medium.com/analytics-vidhya/ways-to-handle-categorical-column-missing-data-its-implementations-15dc4a56893?source=collection_archive---------1-----------------------#2020-09-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4f7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的上一篇博客<a class="ae jd" rel="noopener" href="/@g.dhasade16/ways-to-handle-continous-column-missing-data-its-implementations-4704f52ac9c3">链接</a>中，我解释了处理连续列缺失数据的不同方法及其实现。</p><p id="9d17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我将解释如何使用python实现来处理数据集中分类数据列的缺失值。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/8fc83edf0fc01d6f02d7f7b61438f64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EK_W4UpwF5rDKyJF.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片来自:365datascience.com</figcaption></figure><p id="0189" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">离散/分类数据:</strong>离散数据是可以计数的定量数据，具有有限数量的可能值或数据，这些值或数据可以分成组，例如一周中的天数、一年中的月数、性别(男性/女性/其他)、等级(高/中/低)等。</p><p id="d0ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用来解释的数据集是泰坦尼克号(<a class="ae jd" href="https://www.kaggle.com/c/titanic" rel="noopener ugc nofollow" target="_blank"> Kaggle数据集</a>):</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="1a38" class="jz ka hi jv b fi kb kc l kd ke">import pandas as pd<br/>import numpy as np<br/>Data = pd.read_csv("train.csv")<br/>Data.isnull().sum()<br/>Data.dtypes()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kf"><img src="../Images/f3e4d92ced09d9ad581337a5652c2376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*LpabdvRdtfLBS5LwnnFpSw.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">Cabin_Serial、Cabin和loaded分类变量具有NAN值</figcaption></figure><p id="26e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每列中的类别数:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="38c1" class="jz ka hi jv b fi kb kc l kd ke"># Code to get number of categories in missing value columns</span><span id="20ba" class="jz ka hi jv b fi kg kc l kd ke">print("Number of Categories in: ")</span><span id="fc4a" class="jz ka hi jv b fi kg kc l kd ke">for ColName in DataFrame[['Embarked','Cabin_Serial','Cabin']]:<br/>    print("{} = {}".format(ColName,       len(DataFrame[ColName].unique())))</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kh"><img src="../Images/7ea0274ea61f0884d5219881e3475067.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*M1vzT0KRmXd6leNZEKLuYA.png"/></div></figure><ol class=""><li id="a1a4" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated"><strong class="ih hj">频繁分类插补</strong></li></ol><p id="5fee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">假设</em> </strong>:数据随机缺失(MAR)，缺失值看起来占大多数。</p><p id="32c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">说明:</em> </strong>用变量/列中出现频率最高的类别替换NAN值。</p><p id="0b5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">实现:</em> </strong></p><p id="58bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤1:使用mode()查找每个类别中出现次数最多的类别。</p><p id="104a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第2步:将该列中的所有NAN值替换为该类别。</p><p id="9809" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤3:删除原始列，保留新估算的列。</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="d9f9" class="jz ka hi jv b fi kb kc l kd ke">#1. Function to replace NAN values with mode value</span><span id="7836" class="jz ka hi jv b fi kg kc l kd ke">def impute_nan_most_frequent_category(DataFrame,ColName):<br/>    # .mode()[0] - gives first category name<br/>     most_frequent_category=DataFrame[ColName].mode()[0]<br/>    <br/>    # replace nan values with most occured category<br/>     DataFrame[ColName + "_Imputed"] = DataFrame[ColName]<br/>     DataFrame[ColName + "_Imputed"].fillna(most_frequent_category,inplace=True)</span><span id="34c2" class="jz ka hi jv b fi kg kc l kd ke">#2. Call function to impute most occured category</span><span id="4d86" class="jz ka hi jv b fi kg kc l kd ke">for Columns in ['Embarked','Cabin_Serial','Cabin']:<br/>    impute_nan_most_frequent_category(DataFrame,Columns)<br/>    <br/># Display imputed result<br/>DataFrame[['Embarked','Embarked_Imputed','Cabin_Serial','Cabin_Serial_Imputed','Cabin','Cabin_Imputed']].head(10)</span><span id="af6d" class="jz ka hi jv b fi kg kc l kd ke">#3. Drop actual columns</span><span id="20e9" class="jz ka hi jv b fi kg kc l kd ke">DataFrame = DataFrame.drop(['Embarked','Cabin_Serial','Cabin'], axis = 1)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ks"><img src="../Images/287d2af464fbd3b5c12ba1d67a2e1b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Te-d7LIUJ0HFpQIIWctbhA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">估算最常出现的类别以代替NAN值</figcaption></figure><p id="8df0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">优点:</em> </strong>简单，易于实现分类变量/列。</p><p id="0889" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">缺点:</em> </strong></p><ul class=""><li id="a16e" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kt ko kp kq bi translated">如果使用最常出现的类别进行替换，具有最大数量的空值的要素可能会使预测有偏差。</li><li id="1ee5" class="ki kj hi ih b ii ku im kv iq kw iu kx iy ky jc kt ko kp kq bi translated">它扭曲了最频繁标签的关系。</li></ul><p id="7294" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。添加变量以捕获NAN </strong></p><p id="101c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">假设</em> </strong>:无假设，可以处理所有类型的分类列。</p><p id="d982" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"/></p><p id="d20a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">实现:</em> </strong></p><p id="8536" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步。创建一个新列，如果类别是NAN，则替换1，否则替换0。该列是估算类别的重要性列。</p><p id="bee9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步。将NAN值替换为实际列中最常出现的类别。</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="2be7" class="jz ka hi jv b fi kb kc l kd ke"># Function to impute most occured category and add importance vairable</span><span id="f682" class="jz ka hi jv b fi kg kc l kd ke">def impute_nan_add_vairable(DataFrame,ColName):<br/>    #1. add new column and replace if category is null then 1 else 0</span><span id="e940" class="jz ka hi jv b fi kg kc l kd ke">    DataFrame[ColName+"_Imputed"] =   np.where(DataFrame[ColName].isnull(),1,0)<br/>    <br/>    # 2. Take most occured category in that vairable (.mode())<br/>    <br/>    Mode_Category = DataFrame[ColName].mode()[0]<br/>    <br/>    ## 2.1 Replace NAN values with most occured category in actual vairable<br/>    <br/>    DataFrame[ColName].fillna(Mode_Category,inplace=True)</span><span id="35ad" class="jz ka hi jv b fi kg kc l kd ke"># Call function to impute NAN values and add new importance feature</span><span id="9fc0" class="jz ka hi jv b fi kg kc l kd ke">for Columns in ['Embarked','Cabin_Serial','Cabin']:<br/>    impute_nan_add_vairable(DataFrame,Columns)<br/>    <br/># Display top 10 row to see the result of imputation</span><span id="9b0f" class="jz ka hi jv b fi kg kc l kd ke">DataFrame[['Embarked','Embarked_Imputed','Cabin_Serial','Cabin_Serial_Imputed','Cabin','Cabin_Imputed']].head(10)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kz"><img src="../Images/913c5683f141d4b210b3f6e940703be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OmhsalT0Kbij3TN2LIoFYw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">使用最常出现的类别估算NAN，并添加新的重要性变量/列。</figcaption></figure><p id="6eb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">优点:</em> </strong>抓住了思念的重要性。</p><p id="c2fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">缺点:</em> </strong></p><ul class=""><li id="80b0" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kt ko kp kq bi translated">创建附加功能(维数灾难)，例如，如果有10列包含空值，则需要创建10个额外的列。</li><li id="f43f" class="ki kj hi ih b ii ku im kv iq kw iu kx iy ky jc kt ko kp kq bi translated">可能被误解的数据&amp;缺失数据的数量应该足够大。</li></ul><p id="4ffe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。为NAN值创建一个新类别(随机类别)</strong></p><p id="e37f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">假设</em> </strong>:无假设</p><p id="20a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">说明:</em> </strong>为NAN值新建一个类别，即随机类别。</p><p id="3b8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">实现:</em> </strong></p><p id="9079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步。用一个新名称替换NAN值(这里我们创建一个新类别，名为<em class="kr"> Unknown </em>)。</p><p id="a1d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步。显示结果</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="78f7" class="jz ka hi jv b fi kb kc l kd ke">#1. Function to impute null value with new category<br/>def impute_nan_create_category(DataFrame,ColName):<br/>     DataFrame[ColName] = np.where(DataFrame[ColName].isnull(),"Unknown",DataFrame[ColName])</span><span id="cfaa" class="jz ka hi jv b fi kg kc l kd ke">## Call function to create new category for variables<br/>for Columns in ['Embarked','Cabin_Serial','Cabin']:<br/>    impute_nan_create_category(DataFrame,Columns)</span><span id="1f21" class="jz ka hi jv b fi kg kc l kd ke">#2. Display result<br/>DataFrame[['Embarked','Cabin_Serial','Cabin']].head(10)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es la"><img src="../Images/092f05416f2277754ee5534b69d90d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*cRt99dQeHMA7YKJMDkhJNw.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">添加新类别</figcaption></figure><p id="3dfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">优点:</em> </strong>简单，易于实现分类变量/列并保留方差。</p><p id="e797" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">缺点:</em> </strong></p><ul class=""><li id="9ece" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kt ko kp kq bi translated">如果缺失类别较多，可能会产生随机数据。</li><li id="2b9e" class="ki kj hi ih b ii ku im kv iq kw iu kx iy ky jc kt ko kp kq bi translated">当缺失数据占数据的百分比很高时，不会给出好的结果。</li></ul><p id="8e5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论:</strong></p><p id="f5a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的实现是为了解释我们处理缺失分类数据的不同方法。最广泛使用的方法是为NAN值创建一个新类别(随机类别)和最常见的类别插补。</p><p id="4a65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">供参考:</em> </strong> Jupyter笔记本—可在GitHub获得的代码:<a class="ae jd" href="https://github.com/GDhasade/Medium.com_Contents/blob/master/Handle_Categorical_Missing_Data.ipynb" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/GDhasade/medium . com _ Contents/blob/master/Handle _ categorial _ Missing _ data . ipynb</a></p></div></div>    
</body>
</html>