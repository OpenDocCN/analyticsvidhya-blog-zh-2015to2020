<html>
<head>
<title>PyTorch -A Framework for Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">py torch——深度学习框架</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pytorch-a-framework-for-deep-learning-4abc10c88db8?source=collection_archive---------10-----------------------#2020-10-08">https://medium.com/analytics-vidhya/pytorch-a-framework-for-deep-learning-4abc10c88db8?source=collection_archive---------10-----------------------#2020-10-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e45a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">深度学习</strong>是机器学习的一个子集，人工<strong class="ih hj">神经网络</strong>，受人脑启发的算法，从大量数据中学习。每隔一段时间，就会有一个库或框架为我们提供深度学习领域的新见解，从而实现显著的进步。</p><h2 id="21ae" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">PyTorch 是什么？🤔</h2><p id="abfc" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">PyTorch 是由脸书开发的人工智能框架。这是一个基于 Python 的包，用于替代 Numpy，以利用 GPU 的能力，并作为深度学习开发平台提供灵活性。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/05558b3cf012e86af02117ba4f95750c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXWlDDU8d-XzukdBURMWUw.jpeg"/></div></div></figure><p id="f472" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这无疑是一个值得学习的框架。在这里，我讨论它的一些属性来开始。</p><h2 id="35b6" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">如何安装 PyTorch？</h2><p id="4108" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">最初安装 python 和所有基本库来使用 PyTorch。</p><p id="2fc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，你必须去 https://pytorch.org/的<a class="ae kp" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank">才能得到 PyTorch 的安装命令。</a></p><p id="0226" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，您必须选择您喜欢的 PyTorch 版本、操作系统、包、语言和 CUDA。它为您提供了在 windows 中安装 PyTorch 并在命令提示符下运行该命令的命令。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kq"><img src="../Images/06913a13d66f7d2af92725dc2b91d789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0hw8RqjlAutxCA-gOc_FMg.png"/></div></div></figure><h2 id="ff7f" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">张量</h2><p id="e9ec" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">张量是多维数组。Pytorch 张量类似于 NumPy 数组，另外，张量也可以在 GPU 上使用，以加速计算。</p><pre class="ke kf kg kh fd kr ks kt ku aw kv bi"><span id="1ba2" class="jd je hi ks b fi kw kx l ky kz">#initializing a tensor</span><span id="9381" class="jd je hi ks b fi la kx l ky kz">a = torch.tensor(x,y)</span></pre><p id="f279" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PyTorch 支持像 NumPy 这样的不同操作的各种张量函数。</p><h2 id="7e3f" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">数组和张量的数字桥</h2><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lb"><img src="../Images/ab40c00ff54cd5ec64228f53ef5a870e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*H3Y9ellwTyoE3NdHqSD9xQ.png"/></div></figure><p id="510f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将 torch 张量转换为 NumPy 数组，反之亦然。</p><p id="bedb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将 Numpy 数组转换为张量:</p><pre class="ke kf kg kh fd kr ks kt ku aw kv bi"><span id="3d0e" class="jd je hi ks b fi kw kx l ky kz">import torch<br/>import numpy as np<br/>a = np.ones(5)<br/>b = torch.from_numpy(a)<br/>print(b)</span></pre><p id="02c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">张量到数字:</p><pre class="ke kf kg kh fd kr ks kt ku aw kv bi"><span id="bfce" class="jd je hi ks b fi kw kx l ky kz">a = torch.ones(5)<br/>b = a.numpy()</span></pre><p id="430a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，事情就像你看到的那么简单。</p><h2 id="a495" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">PyTorch 模块</h2><h2 id="03a0" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">自动签名模块</h2><p id="801c" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">PyTorch 提供<strong class="ih hj">亲笔签名的</strong>包，该包为张量上的所有操作提供<strong class="ih hj">自动微分</strong>。它是一个由运行定义的框架，这意味着你的背景是由你的代码如何运行来定义的，并且每一次迭代都可能是不同的。它的工作原理是记录我们执行的所有操作，并回放以计算梯度。</p><pre class="ke kf kg kh fd kr ks kt ku aw kv bi"><span id="e820" class="jd je hi ks b fi kw kx l ky kz">x = torch.tensor([5],dtype=torch.float32,requires_grad=True)<br/>y = torch.tensor([6],dtype=torch.float32,requires_grad=True)<br/>z = ((x**2)*y) + (x*y)</span><span id="35b9" class="jd je hi ks b fi la kx l ky kz"><em class="lc">#Using autograd</em></span><span id="e694" class="jd je hi ks b fi la kx l ky kz">total = torch.sum(z)<br/>print(x.grad,y.grad)<br/>total.backward()</span></pre><h2 id="cf05" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Optim 模块</h2><p id="ffbe" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">我们没有像以前那样手动更新模型的权重，而是使用<strong class="ih hj"> optim </strong>包来定义一个<strong class="ih hj">优化器</strong>，它将为我们更新权重。</p><pre class="ke kf kg kh fd kr ks kt ku aw kv bi"><span id="0a7d" class="jd je hi ks b fi kw kx l ky kz">from torch import optim</span><span id="21ea" class="jd je hi ks b fi la kx l ky kz">#adam optimizer</span><span id="48a5" class="jd je hi ks b fi la kx l ky kz">optimizer_adam = optim.Adam(model.parameters(),lr = learning_rate)</span><span id="369c" class="jd je hi ks b fi la kx l ky kz">#SGD</span><span id="7b43" class="jd je hi ks b fi la kx l ky kz">optimizer_sgd = optim.SGD(model.parameters(),lr = learning_rate)</span></pre><p id="8963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是使用 adam 和 sgd 优化器的例子。PyTorch 有许多常用的优化器，减少了我们从头开始编写它们的时间。</p><p id="4894" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些优化器是，</p><ul class=""><li id="6fb7" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">签名于</li><li id="3762" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">圣经》和《古兰经》传统中）亚当（人类第一人的名字</li><li id="232a" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">阿达格拉德</li><li id="c88a" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">阿达姆</li><li id="b094" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">阿达马克斯</li><li id="adb3" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">阿达德尔塔</li><li id="cdf3" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">ASGD 等。</li></ul><h2 id="614f" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">神经网络模块-定义网络</h2><p id="bb51" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">上述模块帮助我们在使用模型网络时定义计算图。为了开发复杂的神经网络，使用了 nn 模块。</p><p id="1d56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PyTorch 有一个标准的方法让你创建自己的模型。整个定义应该留在一个对象中，这个对象是类<strong class="ih hj"> nn 的子对象。模块</strong> <em class="lc">。在这个类中，只有两个方法必须实现。这些方法分别是<strong class="ih hj"> <em class="lc"> __init__ </em> </strong>和<strong class="ih hj"> <em class="lc"> forward。</em>T11】</strong></em></p><pre class="ke kf kg kh fd kr ks kt ku aw kv bi"><span id="bd3c" class="jd je hi ks b fi kw kx l ky kz">class nnet(nn.Module):</span><span id="9605" class="jd je hi ks b fi la kx l ky kz">     def __init__(self):</span><span id="0567" class="jd je hi ks b fi la kx l ky kz">          super(nnet, self).__init__()</span><span id="2625" class="jd je hi ks b fi la kx l ky kz">          self.net = nn.Sequential(</span><span id="c041" class="jd je hi ks b fi la kx l ky kz">                    nn.Flatten(),</span><span id="c64f" class="jd je hi ks b fi la kx l ky kz">                    nn.Linear(10, 32),</span><span id="028e" class="jd je hi ks b fi la kx l ky kz">                    nn.ReLU(),</span><span id="15e5" class="jd je hi ks b fi la kx l ky kz">                    nn.Linear(32, 64),</span><span id="ea1f" class="jd je hi ks b fi la kx l ky kz">                    nn.ReLU(),</span><span id="684e" class="jd je hi ks b fi la kx l ky kz">                    nn.Linear(64,32),</span><span id="3f58" class="jd je hi ks b fi la kx l ky kz">                    nn.ReLU(),</span><span id="a3da" class="jd je hi ks b fi la kx l ky kz">                    nn.Linear(64,2),</span><span id="a64e" class="jd je hi ks b fi la kx l ky kz">                    nn.LogSoftmax(1)</span><span id="50d0" class="jd je hi ks b fi la kx l ky kz">                 )</span><span id="4f02" class="jd je hi ks b fi la kx l ky kz">     def forward(self, X):</span><span id="79e9" class="jd je hi ks b fi la kx l ky kz">         outs = self.net(X)</span><span id="b0b8" class="jd je hi ks b fi la kx l ky kz">         return outs</span></pre><ul class=""><li id="02ea" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">与其他 python 类一样，<strong class="ih hj"> __init__ </strong>方法用于定义类属性，并在实例化时填充您想要的任何值。并且在 PyTorch 上下文中，您应该总是调用<strong class="ih hj"> super() </strong>方法来初始化父类。</li><li id="e7f0" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated"><strong class="ih hj"> forward </strong>函数根据输入张量计算输出张量。然后，我们可以通过构造一个实例并像调用函数一样调用它，传递包含输入数据的张量，来使用我们新的自动签名的操作符。</li></ul><p id="cea6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，torchvision 包中有预先训练好的模型，可以直接导入并使用。</p><h2 id="779f" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">在 PyTorch 中加载数据</h2><p id="1c56" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated"><strong class="ih hj">数据集</strong>和<strong class="ih hj">数据加载器</strong>是 PyTorch 中可以定义如何访问数据的工具。</p><pre class="ke kf kg kh fd kr ks kt ku aw kv bi"><span id="0835" class="jd je hi ks b fi kw kx l ky kz">from torch.utils.data import Dataset, DataLoader</span></pre><p id="cd79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Torchvision 包由流行的数据集、模型架构和计算机视觉的通用图像转换组成。要安装火炬视觉，</p><pre class="ke kf kg kh fd kr ks kt ku aw kv bi"><span id="62c5" class="jd je hi ks b fi kw kx l ky kz">pip install torchvision</span></pre><ul class=""><li id="eeb2" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">torchvision.datasets 由许多数据集组成，如 MNIST、CIFAR10 等。</li><li id="36dc" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">torchvision.models 由许多可以导入和使用的预训练模型组成。</li><li id="a57c" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">torchvision.transforms 包含许多函数来构建更复杂的转换管道。</li></ul><p id="b8b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们已经看到了 PyTorch 中函数的基础知识。我建议您在任何数据集上使用任何 PyTorch，并实践它以更好地理解它的功能。</p></div></div>    
</body>
</html>