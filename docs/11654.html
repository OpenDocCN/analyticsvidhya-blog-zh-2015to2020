<html>
<head>
<title>Deploying a NLP model with Docker and FastAPI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker和FastAPI部署NLP模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deploying-a-nlp-model-with-docker-and-fastapi-d972779d8008?source=collection_archive---------5-----------------------#2020-12-13">https://medium.com/analytics-vidhya/deploying-a-nlp-model-with-docker-and-fastapi-d972779d8008?source=collection_archive---------5-----------------------#2020-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/c3ee1f32f2b61f9c881b595649591a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HGJUrjU7bfrODmRy"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">格伦·卡斯滕斯-彼得斯在<a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7e7e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">作为一名数据科学家，我的工作通常包括为大量不同的任务开发机器学习或深度学习模型。我经常从Jupyter笔记本开始，对数据进行探索和实验。当我清楚我将要使用的模型时，我创建一些部署脚本。通常，这些脚本由API和Docker映像组成，以允许在云中或本地系统中快速部署。</p><p id="83b6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本文中，我将提供一种简单的方法来为NLP任务开发和部署API。在这种情况下，我将为Kaggle竞赛创建一个模型:【https://www.kaggle.com/uciml/sms-spam-collection-dataset/<a class="ae jc" href="https://www.kaggle.com/uciml/sms-spam-collection-dataset/" rel="noopener ugc nofollow" target="_blank">。该任务包括将一系列SMS消息分类为垃圾消息或非垃圾消息(ham)。这个数据集的主要问题是样本很不平衡。我们有4825个样本不是垃圾邮件，747个样本是垃圾邮件。</a></p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="5c9e" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">建立⚒模型</h1><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es kz"><img src="../Images/6cb41db84155399e42f39834b74def88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*clH8PSTMRmTOjYenXAgPEA.png"/></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">垃圾邮件或垃圾邮件检测管道</figcaption></figure><p id="1fce" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了构建这个模型，我将在scikit中创建一个简单的管道——学习在哪里使用<a class="ae jc" href="https://www.nltk.org" rel="noopener ugc nofollow" target="_blank"> NLTK </a>首先标记文本，然后我将创建一个<a class="ae jc" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html" rel="noopener ugc nofollow" target="_blank"> TF-IDF矢量器</a>来表示文本信息。最后我会用TF-IDF加权的一袋单词训练一个<a class="ae jc" href="https://scikit-learn.org/stable/modules/svm.html" rel="noopener ugc nofollow" target="_blank">支持向量机</a>。对于每一步，我将使用<a class="ae jc" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html" rel="noopener ugc nofollow" target="_blank">网格搜索</a>方法和10倍交叉验证评估来探索一些超参数。由于类别不平衡，我将使用F1宏来评估模型。带探索的笔记本在<a class="ae jc" href="https://github.com/marescas/spam_ml/blob/main/notebooks/spam.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/mares cas/spam _ ml/blob/main/notebooks/spam . ipynb</a>中。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es la"><img src="../Images/6236b6d10c85bdea69be241e0e7f085b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ulDxFb2CNr6fXKG3XZZaYA.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">网格搜索寻找最佳模型</figcaption></figure><p id="fa39" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当模型被训练、评估并且结果良好时(测试集中98%的F1-宏),下一步是保存模型以允许您的生产脚本使用它。为此，我们可以使用joblib库。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lb"><img src="../Images/7130503c943f29701f48d9b942a6920c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ETPMrkOqkwAXtG6Kjl02fg.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">保存最佳模型以用于生产</figcaption></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="de29" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">构建API ⚙️</h1><p id="20cf" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">现在我们已经训练并保存了模型。是时候构建我们的API来为生产服务了。为此，我将使用<a class="ae jc" href="https://fastapi.tiangolo.com" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>。FastAPI是一个构建在<a class="ae jc" href="https://pydantic-docs.helpmanual.io" rel="noopener ugc nofollow" target="_blank"> Pydantic </a>、<a class="ae jc" href="https://www.starlette.io" rel="noopener ugc nofollow" target="_blank"> Starlette </a>和<a class="ae jc" href="https://swagger.io" rel="noopener ugc nofollow" target="_blank"> Swagger </a>之上的库，允许开发者用Python构建快速而健壮的API。多亏了Pydantic，现在检查数据类型比不检查更容易了。此外，由于Swagger，为API构建自动交互文档成为可能。</p><p id="8976" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我开发的API只有一个端点，用于预测给定新短信的假设类。正如我们在下面的代码片段中看到的，它非常简单😁。</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="5657" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">基本上，您需要加载模型，然后用推理逻辑定义端点。在本例中，我想用一个名为“data”的参数作为字符串来定义一个POST方法。由于强大的类型化，Pydantic可以检查输入数据是否是字符串，如果不是，它可以返回一个异常。</p><p id="b990" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">此外，正如我所说的，由于fastAPI和Swagger之间的集成，我们可以自动生成交互式文档。当你需要向其他人解释你的API是如何工作的时候，这是非常有用的。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lj"><img src="../Images/2e4de532577557367f0ed3f1aea17e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQ7c-FroV4AndRtr6a2ong.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">用Swagger生成的简单交互式文档</figcaption></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="4b3e" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">使用Docker部署🏎</h1><p id="0ca0" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">现在，我们有了一个训练有素的模型，可以很好地检测短信是否是垃圾短信。此外，我们有一个用FastAPI开发的API，允许我们为这个模型服务。我们还需要一样东西，一种封装代码并将应用程序移植到不同平台的方法。为此，我将使用<a class="ae jc" href="https://www.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae jc" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker-compose </a>。基本上，Docker允许将代码封装在容器中，并以一种简单的方式移植应用程序。</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">Dockerfile文件</figcaption></figure><p id="fde2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">正如我们在前面的脚本中看到的，我们的API使用<a class="ae jc" href="https://www.uvicorn.org" rel="noopener ugc nofollow" target="_blank">uvicon</a>运行。Uvicorn是一个ASGI服务器实现，使用<a class="ae jc" href="https://github.com/MagicStack/uvloop" rel="noopener ugc nofollow" target="_blank"> uvloop </a>和<a class="ae jc" href="https://github.com/MagicStack/httptools" rel="noopener ugc nofollow" target="_blank"> httptools </a>。多亏了uvicorn，我们可以为同一个API加载4个工人。</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">docker-compose.yml</figcaption></figure><p id="df9b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">此外，由于Docker-compose，我们可以用声明的方式定义我们的应用程序如何运行。对于本例，定义非常简单，我们只将主机端口8080映射到docker端口80。使用<strong class="jf hj"> docker-compose up </strong>我们可以启动API😁。这个API将在端口8080上运行…</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lk"><img src="../Images/423a7344e7bc47cb9a3a1b8928837169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqX3X8IcC6fKyQQChU066A.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">使用docker-compose部署模型</figcaption></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="e2a5" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论📚</h1><p id="f7de" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">在这篇文章中，我们学习了如何构建和部署一个简单的API来预测一条短信是否是垃圾短信。为了构建这个API，我们使用一些工具，如Scikit-Learn、FastAPI和Docker。正如我所说的，这只是一个原型，使用其他技术如MLflow也是可能的，但这将是另一篇文章…我希望你发现这篇文章是有帮助的，感谢阅读。该代码可从以下链接获得:</p><div class="ll lm ez fb ln lo"><a href="https://github.com/marescas/spam_ml" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">marescas/spam_ml</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">为垃圾邮件检测构建一个功能性的应用程序GitHub是5000多万开发者的家园，他们共同努力…</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">github.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc iw lo"/></div></div></a></div></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="2594" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">关于作者</h1><p id="1f76" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">Marcos Esteve是SolverIA的机器学习工程师。马科斯在工作中为各种各样的任务开发机器和深度学习模型。他对多模态任务和构建数据科学应用非常感兴趣。在<a class="ae jc" href="https://www.linkedin.com/in/marescas/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>或<a class="ae jc" href="https://twitter.com/mecprojects" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上联系他</p></div></div>    
</body>
</html>