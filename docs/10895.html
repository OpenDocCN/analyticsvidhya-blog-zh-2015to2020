<html>
<head>
<title>Python’s cool tricks for programming.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 的编程妙招。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pythons-cool-tricks-for-programming-e0940c555747?source=collection_archive---------9-----------------------#2020-11-07">https://medium.com/analytics-vidhya/pythons-cool-tricks-for-programming-e0940c555747?source=collection_archive---------9-----------------------#2020-11-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8d4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单是 Python 解决问题的方式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/83ddc62d9c5487a9ac4aa5152e04ecc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yldcbpzLEgL2rUJeqFl80Q.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://imgflip.com/i/4lesva" rel="noopener ugc nofollow" target="_blank">在 memegenerator 上创建</a></figcaption></figure><ol class=""><li id="8492" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><strong class="ih hj">反转字符串、列表或元组→ </strong></li></ol><p id="cd97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当我发现自己处于需要执行反向操作的情况时，我通常会使用一个<strong class="ih hj"> for 循环</strong>或者求助于一些类似于<strong class="ih hj"> reverse() </strong>的函数来完成这项工作。</p><p id="cb94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是后来，令我震惊的是，我发现 python 有另一个锦囊妙计来解决这个问题——切片操作你可以使用切片语法来反转字符串、元组或列表</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="1abf" class="km kn hi kh b fi ko kp l kq kr">string = 'John Wick'<br/>print(string[::-1]) # logs: 'kciW nhoJ'</span><span id="732d" class="km kn hi kh b fi ks kp l kq kr">tup = (23, 45, 12, 56)<br/>print(tup[::-1]) # logs: (56, 12, 45, 23)</span><span id="b141" class="km kn hi kh b fi ks kp l kq kr">l = ['john', 'baba', 'yaga', 'wick']<br/>print(l[::-1]) # logs: ['wick', 'yaga', 'baba', 'john']</span></pre><p id="cc36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">检查给定的字符串是否是回文→ </strong></p><p id="bebf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kd">很简单，对吧？当我们想到解决这个问题的方法时，我们想到了很多不同的方法。但是猜猜看，解决这个问题的最简单的方法之一可能还是<strong class="ih hj">切片操作</strong>。</em></p><p id="f2bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用上面讨论的反转技巧，一行代码就足以检查给定的字符串是否是回文。首先，我们使用<code class="du ke kf kg kh b">string[::-1]</code>来反转字符串，然后我们简单地比较我们的原始字符串和反转的字符串<code class="du ke kf kg kh b">string == string[::-1] </code>来得到结果。</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="1725" class="km kn hi kh b fi ko kp l kq kr">string = 'aibohphobia'<br/>print('Palindrome' if string == string[::-1] else 'No Plaindrome')<br/># print: Palindrome</span><span id="6f78" class="km kn hi kh b fi ks kp l kq kr">string = 'johnwick'<br/>print('Palindrome' if string == string[::-1] else 'No Plaindrome')<br/># print: No Plaindrome</span></pre><p id="010c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj">从列表中获取“n”个最大或最小的元素→ </strong></p><p id="8752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kd">今天</em>，我们将使用 python 的标准库<strong class="ih hj"> heapify </strong>来将我们的列表转换成堆，然后使用<code class="du ke kf kg kh b">nlargest(n, iterable)</code>和<code class="du ke kf kg kh b">nsmallest(n, iterable)</code>方法来从我们的堆中找到“<strong class="ih hj"> n </strong>个最大和最小的元素。</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="8241" class="km kn hi kh b fi ko kp l kq kr">lis = [23, 9, 34, 22, 43, 21, 5, 40]</span><span id="0732" class="km kn hi kh b fi ks kp l kq kr">import heapq<br/>heapq.heapify(lis) # Convert list into min heap</span><span id="1b2d" class="km kn hi kh b fi ks kp l kq kr">print(heapq.nlargest(4, lis)) # will print 4 largest elements<br/># print: [43, 40, 34, 23]</span><span id="6ff9" class="km kn hi kh b fi ks kp l kq kr">print(heapq.nsmallest(4, lis)) # will print 4 smallest element<br/># print: [5, 9, 21, 22]</span></pre><p id="d0b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.<strong class="ih hj">交换 2 个元素，不使用第三个变量→ </strong></p><p id="fb3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题会在工作面试中频繁出现，当我使用这个技巧时，面试官<em class="kd">(如果不是 python 背景)</em>会变得不耐烦。但是作为一个 python 爱好者/开发者，当你知道这些技巧时，你总是会发现自己处于更有利的位置。</p><p id="095e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只需使用<code class="du ke kf kg kh b">a,b = b,a</code>交换两个变量的值。如果你有兴趣知道这内部是如何工作的，参考这个<a class="ae jt" href="https://stackoverflow.com/questions/21047524/how-does-swapping-of-members-in-tuples-a-b-b-a-work-internally" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">解释</strong> </a>。</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="4757" class="km kn hi kh b fi ko kp l kq kr">a = 10<br/>b = 25<br/>print(f'a: {a}, b: {b}') # print: a: 10, b: 25</span><span id="9c09" class="km kn hi kh b fi ks kp l kq kr">a,b = b,a # swapping variable <br/>print(f'a: {a}, b: {b}') # print: a: 25, b: 10</span></pre><p id="3075" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kd">在</em>的采访中，你总是可以用老办法来回答→</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="640e" class="km kn hi kh b fi ko kp l kq kr">a,b = 10, 25<br/>a = a ^ b<br/>b = a ^ b <br/>a = a ^ b<br/>print(f'a: {a}, b: {b}') # print: a: 25, b: 10</span></pre><p id="9ae0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.<strong class="ih hj">统计字符串、元组和列表中每个元素的出现次数→ </strong></p><p id="23b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python 有一个惊人的<strong class="ih hj">集合</strong>模块，其中包含许多有用的实用程序。<em class="kd">对于我们的任务，我们将使用集合模块中的</em> <strong class="ih hj"> <em class="kd">计数器</em> </strong> <em class="kd">。</em></p><p id="6279" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们使用 split()函数分割字符串，默认情况下，该函数返回一个按空格分割的字符串列表→</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="6b59" class="km kn hi kh b fi ko kp l kq kr">quoteFromGeeta = '''senses exists beyond body<br/>           mind exists beyond senses<br/>           intelligence exists beyond mind<br/>           and knowing yourself exists beyond intelligence'''</span><span id="395a" class="km kn hi kh b fi ks kp l kq kr">word_list = quoteFromGeeta.split()<br/>print(word_list)</span><span id="0c52" class="km kn hi kh b fi ks kp l kq kr">#print: ['senses', 'exists', 'beyond', 'body', 'mind', 'exists', 'beyond', 'senses', 'intelligence', 'exists', 'beyond', 'mind', 'and', 'knowing', 'yourself', 'exists', 'beyond', 'intelligence']</span></pre><p id="d567" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在使用<strong class="ih hj"> <em class="kd">计数器，</em> </strong>让我们找出<strong class="ih hj">单词列表中每个单词的计数→ </strong></p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="bb4c" class="km kn hi kh b fi ko kp l kq kr">from collections import Counter</span><span id="d082" class="km kn hi kh b fi ks kp l kq kr">c = Counter(word_list) # pass your list to Counter</span><span id="29f0" class="km kn hi kh b fi ks kp l kq kr">[print(f'Word: {word}, Count: {count}') for word,count in c.items()]</span><span id="8f88" class="km kn hi kh b fi ks kp l kq kr"># prints<br/>Word: senses, Count: 2<br/>Word: exists, Count: 4<br/>Word: beyond, Count: 4<br/>Word: body, Count: 1<br/>Word: mind, Count: 2<br/>Word: intelligence, Count: 2<br/>Word: and, Count: 1<br/>Word: knowing, Count: 1<br/>Word: yourself, Count: 1</span></pre><p id="cc32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很简单，不是吗？</p><p id="ce04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你也可以使用<code class="du ke kf kg kh b">most_common(n)</code>方法找到最常见的单词</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="54c0" class="km kn hi kh b fi ko kp l kq kr">common_words = c.most_common(3)<br/>[print(word, count) for word,count in common_words]</span><span id="d3eb" class="km kn hi kh b fi ks kp l kq kr"># print<br/>Word: exists, Count: 4<br/>Word: beyond, Count: 4<br/>Word: senses, Count: 2</span></pre><p id="45a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.<strong class="ih hj">检查两个字符串是否是变位词→ </strong></p><blockquote class="kt ku kv"><p id="d591" class="if ig kd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">你一定想知道，什么是变位词，对吗？ <br/>一个<strong class="ih hj">串</strong>的一个<strong class="ih hj">变位词</strong>是一个<strong class="ih hj">串</strong>包含相同的字符，只是字符的顺序可以不同。例如，“abcd”和“dabc”是彼此的一个<strong class="ih hj">变位词</strong>。</p></blockquote><p id="ab9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<strong class="ih hj"> <em class="kd">计数器</em> </strong> <em class="kd">从</em> <strong class="ih hj"> <em class="kd"> </em>集合<em class="kd">，</em> </strong>我们可以很容易地检查两个字符串是否是变位词→</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="a0a8" class="km kn hi kh b fi ko kp l kq kr">from collections import Counter<br/>str1 = 'abcd'<br/>str2 = 'dabc'</span><span id="e448" class="km kn hi kh b fi ks kp l kq kr">c1 = Counter(name1)<br/>c2 = Counter(name2)<br/>print(c1 == c2) # print True</span></pre><p id="cb37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7.<strong class="ih hj">使用运算符链接检查两个以上的条件→ </strong></p><p id="ed97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检查多个条件的值是我们每天都要执行的任务，让我们考虑一个需要检查<code class="du ke kf kg kh b"><strong class="ih hj">5 &lt; a &lt; 20</strong></code>的例子</p><p id="27f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kd">在其他编程语言</em>中，你会这样检查它→</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="603e" class="km kn hi kh b fi ko kp l kq kr">if <strong class="kh hj">a &gt; 5 and a &lt; 20</strong>:<br/>    pass</span></pre><p id="0df1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kd">在 python 中，</em>你可以简单地使用<strong class="ih hj">操作符链接→ </strong></p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="19f3" class="km kn hi kh b fi ko kp l kq kr">if <strong class="kh hj">5 &lt; a &lt; 20</strong>:<br/>    pass</span></pre><p id="1e5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">8.<strong class="ih hj">从列表中取值并分配给变量→ </strong></p><p id="2483" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们将使用一个对许多开发人员来说仍然难以理解的概念— <strong class="ih hj">解包</strong></p><p id="5e5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我们大多数人可能在某个时候用过它，但是这个概念本身会引起你的兴趣。如果你是这个概念的新手，那么你今天肯定会学到一些很棒的东西。</p><blockquote class="kt ku kv"><p id="44b8" class="if ig kd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><strong class="ih hj">Python 中的解包</strong>指的是在一个赋值语句中将一个可迭代的值赋给一个变量元组(或列表)的操作。你会喜欢 Python 中的<strong class="ih hj">解包</strong>特性。</p></blockquote><p id="633b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">举例说明的时间到了→</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="5fc5" class="km kn hi kh b fi ko kp l kq kr">l = ['john', '40', 'assassin']<br/>#with out unpacking feature<br/>name = l[0]<br/>age = age[1]<br/>profession = l[2]</span><span id="7774" class="km kn hi kh b fi ks kp l kq kr">#with unpacking feature<br/>name, age, profession = l  </span></pre><p id="8ef3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要深入探索它的工作原理，请参考这篇来自 Stackabuse 的<a class="ae jt" href="https://stackabuse.com/unpacking-in-python-beyond-parallel-assignment/#:~:text=Unpacking%20in%20Python%20refers%20to,the%20iterable%20unpacking%20operator%2C%20*%20." rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">文章</strong> </a>以获得惊人的解释。</p><p id="8c30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">9.<strong class="ih hj">获取列表、字符串和元组的最后一个元素→ </strong></p><p id="91ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看一个解决方案，它将使解决这个问题看起来像是小菜一碟。<em class="kd">使用</em> <code class="du ke kf kg kh b"><em class="kd">iterable[-1]</em></code> <em class="kd">查找最后一个元素。</em></p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="468d" class="km kn hi kh b fi ko kp l kq kr">l = ['john', '40', 'assassin']<br/>print(l[-1]) # 'assassin'</span></pre><p id="7585" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">10.<strong class="ih hj">检查列表或元组是否为空</strong></p><p id="4f5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kd">如果你一直觉得检查一个列表是否为空很麻烦。</em>如果你一直在使用如下所示的这种繁琐而又混乱的方法，那么我们将会见证一些让我们的生活变得更加轻松的事情。首先，让我们看看更常用的方法→</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="27d8" class="km kn hi kh b fi ko kp l kq kr">temp = []<br/>if len(temp) == 0:<br/>   pass</span><span id="42cf" class="km kn hi kh b fi ks kp l kq kr">if len(temp):<br/>   pass</span></pre><p id="c463" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kd">在 python 中，空列表被认为是错误的，所以你可以像下面这样直接检查它→ </em></p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="894f" class="km kn hi kh b fi ko kp l kq kr">if temp:<br/>   pass</span></pre><p id="c263" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">11.<strong class="ih hj">连接两个列表，元组→ </strong></p><p id="7493" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用<code class="du ke kf kg kh b"><strong class="ih hj">+</strong></code>操作符来连接元组和列表，在执行连接后，它将返回新的元组或列表。</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="b1d1" class="km kn hi kh b fi ko kp l kq kr"># On list<br/>list1 = [1,2,3,4,5]<br/>list2 = [6,7,8,9,10]<br/>list_new = list1 + list2<br/>print(list_new) # print [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><span id="51d4" class="km kn hi kh b fi ks kp l kq kr"># On tuple<br/>tuple1 = (1,2,3,4,5)<br/>tuple2 = (6,7,8,9,10)<br/>tuple3 = (11,12,13,14,15)<br/>tuple_new = tuple1 + tuple2 + tuple3<br/>print(tuple_new)</span></pre><p id="fda5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">12.<strong class="ih hj">从现有列表创建新列表→ </strong></p><p id="abf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用一个例子来理解我们的问题陈述。</p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="cc9b" class="km kn hi kh b fi ko kp l kq kr">l = ['John Wick', 45, 'assassin']</span><span id="6209" class="km kn hi kh b fi ks kp l kq kr">new_l =  l # this will copy the reference of l in new_l</span><span id="a522" class="km kn hi kh b fi ks kp l kq kr">print(new_l) # print  ['John Wick', 45, 'assassin']</span><span id="ebeb" class="km kn hi kh b fi ks kp l kq kr">l[0] = 'Baba Yaga' # any change in l will reflect to new_l also</span><span id="0a81" class="km kn hi kh b fi ks kp l kq kr">print(new_l) # print ['Baba Yaga', 45, 'assassin']</span></pre><p id="cc72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kd">从上面的快照</em>可以看出，新的列表变量只存储了现有列表的引用地址，现在指向它，但是根据我们的要求，没有创建新的列表。</p><p id="2ab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要创建一个全新的列表<em class="kd">，您只需在现有列表上使用</em><code class="du ke kf kg kh b"><strong class="ih hj"><em class="kd">list[:]</em></strong></code><strong class="ih hj"><em class="kd"/></strong><em class="kd">，通过一个简单的操作您将拥有一个新的列表。</em></p><pre class="je jf jg jh fd ki kh kj kk aw kl bi"><span id="a335" class="km kn hi kh b fi ko kp l kq kr">l = ['John Wick', 45, 'assassin']</span><span id="d962" class="km kn hi kh b fi ks kp l kq kr">new_l =  l[:] # this will create the new list</span><span id="e367" class="km kn hi kh b fi ks kp l kq kr">print(new_l) # print  ['John Wick', 45, 'assassin']</span><span id="ddb0" class="km kn hi kh b fi ks kp l kq kr">l[0] = 'Baba Yaga' # any change in l will reflect to new_l also</span><span id="4412" class="km kn hi kh b fi ks kp l kq kr">print(new_l) # print ['John Wick', 45, 'assassin']</span></pre><blockquote class="kt ku kv"><p id="99c2" class="if ig kd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">注意:list[:]将创建一个 list 的浅层副本，要创建深层副本，可以使用<code class="du ke kf kg kh b">copy</code>模块中的<code class="du ke kf kg kh b">deepcopy</code>方法</p></blockquote><h1 id="b570" class="kz kn hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">未完待续…</h1><p id="d2ad" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">python 中有更多很酷的库，如<strong class="ih hj"> functools </strong>、<strong class="ih hj"> itertools </strong>、<strong class="ih hj"> pandas </strong>，我们将在后续文章中探讨。</p><p id="4db8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你喜欢这篇文章。请在评论中告诉我，你最喜欢哪个技巧。</p><p id="ea32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">祝你好运，编码愉快😃</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mb mc l"/></div></figure></div></div>    
</body>
</html>