<html>
<head>
<title>[Shader]: kNearest Neighbors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[着色器]: kNearest邻居</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/shader-knearest-neighbors-5700cc16d52d?source=collection_archive---------15-----------------------#2019-10-31">https://medium.com/analytics-vidhya/shader-knearest-neighbors-5700cc16d52d?source=collection_archive---------15-----------------------#2019-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="67af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这篇文章，我想分享我最近在寻找最近邻居方面所做的研究。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a2a0b93dff3cca8fedc25cb324980b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEyFcamHilIay130gFSR-g.png"/></div></div></figure><h2 id="c88c" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">问题陈述:</h2><p id="ef25" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">给定一个2d网格，输入为2D坐标X和Y，找出离它最近或相邻的网格单元。范围从0到n。</p><h2 id="1046" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">输入:</h2><p id="f155" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">从解决方案开始，我们需要以下输入:</p><p id="850b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网格大小-&gt; X*Y或行*列</p><p id="bc67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网格单元-&gt;我们需要找到其邻居的网格单元/点的X和Y坐标</p><p id="944c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步长或范围-&gt;我们需要找到邻居的范围</p><h2 id="33bd" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">解决方案:</h2><p id="ac52" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">解决方案以Unity中的着色器形式给出(在方形平面上):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kp"><img src="../Images/ce4cd90673d5c1e0f1f5543d8e9c14a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hi2yccL7Q5MFL-cnByDLdg.png"/></div></div></figure><p id="716d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也称为阴影部分(640x360)图像:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kq"><img src="../Images/4db3c5638b27477b519402847254e368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Hu_wenyrqO0a7yWAkPn4sw.png"/></div></figure><h2 id="4885" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">基础知识:</h2><p id="19a6" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">首先，我们从创建2D网格开始。我将使用ShaderToy进行web演示。下面的代码片段将帮助您从棋盘模式开始:</p><pre class="je jf jg jh fd kr ks kt ku aw kv bi"><span id="5b0a" class="jp jq hi ks b fi kw kx l ky kz">vec2 _GridSize = vec2(16.0, 16.0);</span><span id="7941" class="jp jq hi ks b fi la kx l ky kz">void mainImage( out vec4 fragColor, in vec2 fragCoord )<br/>{<br/> fragCoord.x *= _GridSize.x;<br/> fragCoord.y *= _GridSize.y;<br/> <br/> // Normalized pixel coordinates (from 0 to 1)<br/> vec2 uv = fragCoord/iResolution.xy;</span><span id="151f" class="jp jq hi ks b fi la kx l ky kz">// Time varying pixel color<br/> vec3 col;<br/> vec2 floorVal = vec2(floor(uv.x), floor(uv.y))/2.0;<br/> float checkerVal = fract(floorVal.x+floorVal.y)*2.0;<br/> col.x = checkerVal;<br/> col.y = checkerVal;<br/> col.z = checkerVal;<br/> <br/> // Output to screen<br/> fragColor = vec4(col,1.0);<br/>}</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kq"><img src="../Images/2518fe4e6ad23f6fcd3eef96b83545a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*qpAhJufWD7X-bCaM8iHC3Q.png"/></div></figure><h2 id="03fa" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">最近的邻居:</h2><p id="1b40" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">一旦你有了2D网格，我们需要接受其他的输入，开始写算法。</p><p id="d2df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在计算2D网格时，我们知道它是行数*列数的简单数据集合。因此，当我们取一个位置2D网格时，它会有两个坐标X和Y作为行和列。</p><p id="e3bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用这些术语思考会使计算最近邻变得非常简单。我们需要做的就是改变行号和列号来得到相邻的网格单元。我们现在用单位(1)来改变它，得到下面的坐标:</p><p id="eef7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">StartPos : [X，Y]</p><p id="0e41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">邻居:[X-1，Y]，[X+1，Y]，[X，Y-1]和[X，Y+1]；可以更进一步用[X+1，Y+1]，[X-1，Y-1]，[X-1，Y+1]和[X+1，Y-1] …</p><p id="041c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，使用for循环从minValue迭代到maxValue来覆盖我们想要选择的邻域范围更有意义。下面的代码片段将帮助您找到正在迭代的位置是否靠近输入:</p><pre class="je jf jg jh fd kr ks kt ku aw kv bi"><span id="f30b" class="jp jq hi ks b fi kw kx l ky kz">float isNearest(vec2 pt)<br/>{<br/>    bool val = false;<br/>    for (float x = (-0.5*float(_Step)); x &lt;= (0.5*float(_Step)); x+=0.5)<br/>    {<br/>        for (float y = (-0.5*float(_Step)); y &lt;= (0.5*float(_Step)); y+=0.5)<br/>        {<br/>            if (pt.x == _InputPos.x+x &amp;&amp; pt.y == _InputPos.y+y)<br/>            {<br/>                if(_Step == 0)<br/>                    return 1.0/(float(_Step)+1.0);<br/>                else<br/>                    return float(_Step)/(float(_Step) + abs(x)+abs(y));<br/>            }<br/>        }<br/>    }<br/>    return 0.0;<br/>}</span></pre><h2 id="c250" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">示例:</h2><p id="5313" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">网格:16x16_InputPos : [2.0，4.0]；步骤:0</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kq"><img src="../Images/3e8b9a23e472d9616a33c931fccb5f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*52EECISIh5qCz8SJ8eNNvA.png"/></div></figure><p id="2746" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网格:16x16_InputPos : [2.0，4.0]；第一步</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kq"><img src="../Images/d8cff3e196ac257e99226539e7479272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*qHgse63HmCwe5Z6WpVJXSw.png"/></div></figure><p id="a1c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网格:16x16_InputPos : [2.0，4.0]；第二步</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kq"><img src="../Images/b33aee07d4d911437b128ed56bd0b031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*5eAxKNCik1tYpX1EAnzOag.png"/></div></figure><p id="91b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网格:16x16_InputPos : [2.0，4.0]；第三步</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kq"><img src="../Images/4db3c5638b27477b519402847254e368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Hu_wenyrqO0a7yWAkPn4sw.png"/></div></figure><h2 id="2cc3" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">源代码:</h2><p id="5131" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">https://www.shadertoy.com/view/tscXRf</p><p id="2479" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Unity着色器:</p><pre class="je jf jg jh fd kr ks kt ku aw kv bi"><span id="d83a" class="jp jq hi ks b fi kw kx l ky kz">Shader "Unlit/CheckerNeighbours"<br/>{<br/>    Properties<br/>    {<br/>        _Density("Density", Range(2,50)) = 30<br/>        _PosX("X", Float) = 1<br/>        _PosY("Y", Float) = 1<br/>        _Step("Step", Int) = 1<br/>    }<br/>    SubShader<br/>    {<br/>        Tags { "RenderType"="Opaque" }<br/>        LOD 100<br/><br/>        Pass<br/>        {<br/>            CGPROGRAM<br/>            #pragma vertex vert<br/>            #pragma fragment frag<br/>            #include "UnityCG.cginc"<br/><br/>            struct v2f<br/>            {<br/>                float2 uv : TEXCOORD0;<br/>                float4 vertex : SV_POSITION;<br/>            };<br/><br/>            float _Density;<br/>            float _PosX;<br/>            float _PosY;<br/>            int _Step;<br/><br/>            v2f vert(float4 pos : POSITION, float2 uv : TEXCOORD0)<br/>            {<br/>                v2f o;<br/>                o.vertex = UnityObjectToClipPos(pos);<br/>                o.uv = uv * _Density;<br/>                return o;<br/>            }<br/>            <br/>            bool isOnMap(float x, float y, float2 pt)<br/>            {<br/>                return x == pt.x &amp;&amp; y == pt.y;<br/>            }<br/><br/>            float isNearest(float2 pt)<br/>            {<br/>                bool val = false;<br/>                for (float x = (-0.5*_Step); x &lt;= (0.5*_Step); x+=0.5)<br/>                {<br/>                    for (float y = (-0.5*_Step); y &lt;= (0.5*_Step); y+=0.5)<br/>                    {<br/>                        if (pt.x == _PosX+x &amp;&amp; pt.y == _PosY+y)<br/>                        {<br/>                            if(_Step == 0)<br/>                                return 1.0/(_Step+1.0);<br/>                            else<br/>                                return _Step/(_Step + abs(x)+abs(y));<br/>                        }<br/>                    }<br/>                }<br/>                return 0;<br/>            }<br/><br/>            fixed4 frag(v2f i) : SV_Target<br/>            {<br/>                float rows = _Density;<br/>                float cols = _Density;<br/><br/>                float2 c = i.uv;<br/>                c = floor(c) / 2;<br/>                float checker = frac(c.x + c.y) * 2;<br/>                if (isNearest(c))<br/>                {<br/>                    return float4(0.0, isNearest(c), 0.0, 1.0);<br/>                }<br/>                return checker;<br/>            }<br/>            ENDCG<br/>        }<br/>    }<br/>}</span></pre></div></div>    
</body>
</html>