<html>
<head>
<title>Linked Lists for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的链表</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/linked-lists-for-beginners-77a1b8e5c9a5?source=collection_archive---------18-----------------------#2020-07-14">https://medium.com/analytics-vidhya/linked-lists-for-beginners-77a1b8e5c9a5?source=collection_archive---------18-----------------------#2020-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5d53" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">什么是链表？</h2></div><p id="936e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">链表只是一个数据节点序列，其中每个节点指向另一个节点。链表的起始节点称为头节点。每个节点都有一个数据值和一个指向它旁边节点的指针。所以基本上，我们只需要知道链表的头节点就可以访问它的任何元素。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/57062d0c38d074649a19b6d75e061d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ulj0lGx8gq76Whexu2K8PA.png"/></div></div></figure><h2 id="4282" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">链表和数组有什么不同？</h2><p id="e4d5" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">数组是存储在连续内存位置的元素的集合，而链表中的节点可以存储在不同的内存位置，如上图所示。我们可以通过索引直接访问数组中的任何元素，相反，链表必须从头节点开始遍历才能访问特定的节点。话虽如此，在链表中插入/删除新元素要容易得多，因为在数组中，插入或删除元素会导致数组的一部分移位。数组是静态的，也就是说，创建一个数组意味着你保留了计算机内存的某个固定部分，这个部分有时可能不够用，有时可能会闲置。链表本质上是动态的，这意味着节点可以在随机的内存位置、任何地方和任何时间从我们计算机的未使用内存池中创建。然而，链表中的节点需要额外的内存空间来保存指向下一个节点的指针值。因此，链表可以更好地利用内存，但是在访问特定节点时代价更高。</p><h2 id="29c1" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated"><strong class="ak">遍历链表:</strong></h2><p id="8d0a" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">链表的特征仅仅在于它的头节点。我们可以遍历链表，访问每个节点的<em class="lf"> next </em>指针，从头节点开始，不断循环，直到找到不指向任何内容的节点，即其<em class="lf"> next= NULL </em>。这就像通过几个车站到达一个地址，每个车站都有到另一个车站的地址，这个过程最终会把你带到你的最终目的地。</p><h2 id="cb62" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated"><strong class="ak">在链表中插入/删除:</strong></h2><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/34284062dfaee6b086ca1faf06a64901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUujskcYrZKl37w3mOehQA.png"/></div></div></figure><p id="b2e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们在第二个和第三个节点之间插入一个节点。</p><ul class=""><li id="c727" class="lg lh hi iz b ja jb jd je jg li jk lj jo lk js ll lm ln lo bi translated">找到第二个节点，即遍历列表，直到找到第二个节点。</li><li id="522e" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">创建一个新节点。这里，一个新的节点是在一个随机的内存位置动态创建的，比如说40020。</li><li id="20c0" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">最初，第二个节点的next指向第三个节点。现在，第二个节点的next应该指向新创建的内存位置，即40020。</li><li id="fac4" class="lg lh hi iz b ja lp jd lq jg lr jk ls jo lt js ll lm ln lo bi translated">新创建的下一个节点应该指向第三个节点，即300010。</li></ul><p id="4f91" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">删除节点可以用类似的方式完成。</p><h2 id="819a" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">使用Python实现链表:</h2><pre class="ju jv jw jx fd lu lv lw lx aw ly bi"><span id="1c9f" class="kf kg hi lv b fi lz ma l mb mc">class node : <br/> def __init__(self, value=None):<br/>  self.value=value <br/>  self.next=None</span><span id="a272" class="kf kg hi lv b fi md ma l mb mc">#lets make our own linked list <br/>class MyLinkedList:<br/> def __init__(self):<br/>  self.head=None</span><span id="69f6" class="kf kg hi lv b fi md ma l mb mc"> #This is to check if the linked list is empty.<br/> def is_Empty(self):<br/>  if self.head==None:<br/>   return True<br/> else:<br/>   return False</span><span id="c6ed" class="kf kg hi lv b fi md ma l mb mc">#This is to add a new nodes to our linked list<br/> def add_node(self,data): <br/>  new_node= node(data) <br/>  if self.is_Empty():<br/>   self.head=new_node <br/>  else:<br/>   tmp_node=self.head <br/>   while (tmp_node.next): <br/>    tmp_node=tmp_node.next<br/>   tmp_node.next=new_node </span><span id="d727" class="kf kg hi lv b fi md ma l mb mc">  def add_begining(self,data):<br/>   new_node=node(data)<br/>   if self.is_Empty():<br/>    self.head=new_node<br/>   else:<br/>    start_node=self.head<br/>    self.head=new_node<br/>    new_node.next=start_node</span><span id="744b" class="kf kg hi lv b fi md ma l mb mc">  def show_list(self):<br/>   start=self.head <br/>   while start is not None:<br/>    print(start.value)<br/>    start=start.next</span><span id="f44f" class="kf kg hi lv b fi md ma l mb mc">my_list = MyLinkedList() <br/>my_list.add_node(4)<br/>my_list.add_node(3)<br/>my_list.add_begining(1)<br/>my_list.add_begining(2)<br/>my_list.show_list()</span></pre><p id="da94" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用python实现链表也会帮助你更好地理解OOP的概念。您将了解我们如何创建自己的类，创建自己的对象，以及这些对象如何调用类函数。为了方便起见，我将解释代码的每一部分。</p><p id="b8c5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们开始…</p><pre class="ju jv jw jx fd lu lv lw lx aw ly bi"><span id="f097" class="kf kg hi lv b fi lz ma l mb mc">class node :<br/> def __init__(self, value=None):<br/>  self.value=value<br/>  self.next=None</span></pre><p id="b1c5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类<em class="lf">节点</em>被定义为具有两个属性:一个<em class="lf">值</em>，保存节点的实际值；一个<em class="lf">下一个</em>，保存指向其下一个节点的引用/指针。<em class="lf"> __init__() </em>函数被称为构造函数，当类<em class="lf">节点</em>的任何对象被创建时自动调用。该函数初始化所创建节点的属性。无论何时创建任何节点，它都是独立的，直到我们将它添加到一个列表中，这就是为什么我们将它的<em class="lf"> next </em>初始化为null。函数中的<em class="lf"> self </em>参数是调用该函数的对象的指针。</p><pre class="ju jv jw jx fd lu lv lw lx aw ly bi"><span id="9c31" class="kf kg hi lv b fi lz ma l mb mc">class MyLinkedList:<br/> def __init__(self):<br/>  self.head=None</span><span id="146a" class="kf kg hi lv b fi md ma l mb mc">#This is to check if the linked list is empty.<br/> def is_Empty(self):<br/>  if self.head==None:<br/>   return True<br/> else:<br/>   return False</span><span id="2507" class="kf kg hi lv b fi md ma l mb mc">#This is to add a new nodes to our linked list<br/> def add_node(self,data): <br/>  new_node= node(data) <br/>  if self.is_Empty():<br/>   self.head=new_node <br/>  else:<br/>   tmp_node=self.head <br/>   while (tmp_node.next): <br/>    tmp_node=tmp_node.next<br/>   tmp_node.next=new_node</span><span id="5f34" class="kf kg hi lv b fi md ma l mb mc">def add_begining(self,data):<br/>   new_node=node(data)<br/>   if self.is_Empty():<br/>    self.head=new_node<br/>   else:<br/>    start_node=self.head<br/>    self.head=new_node<br/>    new_node.next=start_node</span><span id="2729" class="kf kg hi lv b fi md ma l mb mc">def show_list(self):<br/>   start=self.head <br/>   while start is not None:<br/>    print(start.value)<br/>    start=start.next</span></pre><p id="0270" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当创建类<em class="lf"> MyLinkedList </em>的任何对象时，调用<em class="lf"> __init__() </em>函数。我们上面定义的类，即<em class="lf">节点</em>用于创建节点，而类<em class="lf"> MyLinkedList </em>用于创建一个链表，其中<em class="lf">节点</em>对象可以被添加以形成一个列表。如前所述，对于一个链表来说，仅仅一个头就足以表征其自身，这意味着如果我们知道头节点，那么列表中的所有节点都可以被访问。每当<em class="lf"> MyLinkedList </em>的对象被创建时(每当<em class="lf"> __init__() </em>被调用时)，就会创建一个空列表，其<em class="lf">头</em>指向null。</p><p id="639c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果列表为空，函数<em class="lf"> is_Empty() </em>返回True，否则返回False。当列表被初始化时，它的<em class="lf">头</em>被设置为空，这意味着<em class="lf">头</em>不是<em class="lf">节点</em>而是空的。如果没有节点被添加到列表中，那么<em class="lf">头</em>必须为空。</p><p id="8cdf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数<em class="lf"> add_node() </em>用于在列表末尾添加一个新节点。可能有两种情况:要么我们添加一个空节点，要么我们在一个非空列表的末尾添加一个新节点。如果列表为空，那么我们必须将新节点作为列表的<em class="lf">头</em>。如果列表不为空，那么我们必须遍历列表的结束节点，然后将新节点添加到列表中。</p><pre class="ju jv jw jx fd lu lv lw lx aw ly bi"><span id="38ed" class="kf kg hi lv b fi lz ma l mb mc">my_list = MyLinkedList() <br/>my_list.add_node(4)<br/>my_list.add_node(3)<br/>my_list.add_begining(1)<br/>my_list.add_begining(2)<br/>my_list.show_list()</span></pre><p id="1850" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，<em class="lf"> my_list </em>是类<em class="lf"> MyLinkedList，</em>的对象，它调用该类的__init__()函数，并将其头初始化为null。类似地，对象<em class="lf"> my_list </em>调用<em class="lf"> add_node() </em>函数，一个节点被添加到列表中。使用<em class="lf"> show_list() </em>功能可以将列表打印出来。</p><p id="6ea8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>