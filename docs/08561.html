<html>
<head>
<title>Python decorator: How it changes behavior of other classes and functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python decorator:它如何改变其他类和函数的行为</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-decorator-how-it-changes-behaviour-of-other-classes-and-functions-a5cac813f79d?source=collection_archive---------22-----------------------#2020-08-03">https://medium.com/analytics-vidhya/python-decorator-how-it-changes-behaviour-of-other-classes-and-functions-a5cac813f79d?source=collection_archive---------22-----------------------#2020-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="fd4b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">本指南通过描述性示例提供了关于 Python decorator 的简单易懂的知识</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/1aacbf358c34741f7f4e52f6595dfc2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*wigcg2cOMdiqq3y2Qrgk2w.png"/></div></figure><p id="3178" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如今，Python 已经成为世界上最流行的编程语言之一。它不仅简单易学，而且提供了许多有趣和有用的功能。Decorator ( <strong class="jh hj"> @ </strong>)，它允许我们修改其他函数和类的行为，必须是其中之一。它的主要目的是封装复杂的实现，但仍然让您的代码清晰美观。对于初学者来说，Decorator 可能有点混乱，但是本文将证明它比您想象的要简单得多。</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><h1 id="514e" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated"><strong class="ak">语法</strong></h1><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="428e" class="lf kj hi lb b fi lg lh l li lj">@my_decorator<br/>def hello_world():<br/>    print('Hello world!')</span></pre><p id="7202" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在上面的例子中，我们可以看到一个非常简单的函数，它打印字符串"<em class="lk"> Hello world </em>！"。但是不同的是，它是用装饰器定义的，这导致了函数的一些变化。但是如果我们不知道<strong class="jh hj"> @ </strong>，不使用这个特性怎么重写上面的代码呢？这是答案:</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="7fba" class="lf kj hi lb b fi lg lh l li lj">def hello_world():<br/>    print('Hello world!')<br/></span><span id="a10c" class="lf kj hi lb b fi ll lh l li lj">hello_world = my_decorator(hello_world)</span></pre><p id="2629" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du lm ln lo lb b">my_decorator</code> <strong class="jh hj"> </strong>是一个可调用函数。在这个函数中，有另一个函数执行一些操作，包括调用作为参数传递的函数，在本例中是<code class="du lm ln lo lb b">hello_world</code>。如果这对于你来说仍然难以理解，让我们转到文章的下一部分。</p><h1 id="3c9f" class="ki kj hi bd kk kl lp kn ko kp lq kr ks io lr ip ku ir ls is kw iu lt iv ky kz bi translated">创建您自己的装饰</h1><p id="6ec8" class="pw-post-body-paragraph jf jg hi jh b ji lu ij jk jl lv im jn jo lw jq jr js lx ju jv jw ly jy jz ka hb bi translated">现在我们定义上面提到的<code class="du lm ln lo lb b">my_decorator</code>函数:</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="3ef2" class="lf kj hi lb b fi lg lh l li lj">def my_decorator(func):<br/>    def add_star():<br/>        print('***')<br/>        func()<br/>        print('***')<br/>    return add_star<br/></span><span id="5573" class="lf kj hi lb b fi ll lh l li lj">@my_decorator<br/>def hello_world():<br/>    print('Hello world!')<br/></span><span id="2635" class="lf kj hi lb b fi ll lh l li lj">hello_world()</span></pre><p id="7f7b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当像上面这样添加装饰器时，<code class="du lm ln lo lb b">hello_world</code>被传递给可调用的<code class="du lm ln lo lb b">my_decorator</code>。在内部，<code class="du lm ln lo lb b">add_star</code>被定义为在调用作为参数传递的<code class="du lm ln lo lb b">hello_world</code>之前和之后打印星形线的动作。最后，<code class="du lm ln lo lb b">add_star</code>被返回并赋给<code class="du lm ln lo lb b">hello_world</code>。从这一点来说，<code class="du lm ln lo lb b">hello_world</code>不再是原来的功能，而是一个新装饰的功能。毕竟，输出将是:</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="422b" class="lf kj hi lb b fi lg lh l li lj">***<br/>Hello world!<br/>***</span></pre><h1 id="5a73" class="ki kj hi bd kk kl lp kn ko kp lq kr ks io lr ip ku ir ls is kw iu lt iv ky kz bi translated">装饰函数包含参数</h1><p id="39f7" class="pw-post-body-paragraph jf jg hi jh b ji lu ij jk jl lv im jn jo lw jq jr js lx ju jv jw ly jy jz ka hb bi translated">上面的例子是一段简单的代码，它只是将一些字符串输出到控制台。如果定义一个函数需要一些参数，为了接受它们，我们只需在定义装饰器返回的函数时添加<code class="du lm ln lo lb b">*args</code>和<code class="du lm ln lo lb b">**kwargs</code>。</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="488c" class="lf kj hi lb b fi lg lh l li lj">def print_result_decorator(func):<br/>    def print_result(*args, **kwargs):<br/>        result = func(*args, **kwargs)<br/>        print(f'Your result is {result}')<br/>        return result<br/>    return print_result<br/></span><span id="ff00" class="lf kj hi lb b fi ll lh l li lj">@print_result_decorator<br/>def square(a):<br/>    return a * a<br/></span><span id="62c6" class="lf kj hi lb b fi ll lh l li lj">square(2)</span></pre><p id="ddd0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="0799" class="lf kj hi lb b fi lg lh l li lj">Your result is 4</span></pre><h1 id="c294" class="ki kj hi bd kk kl lp kn ko kp lq kr ks io lr ip ku ir ls is kw iu lt iv ky kz bi translated">作为装饰者的类</h1><p id="a9bd" class="pw-post-body-paragraph jf jg hi jh b ji lu ij jk jl lv im jn jo lw jq jr js lx ju jv jw ly jy jz ka hb bi translated">本文展示了一些 function decorator 的例子，但是我们可以使用 class 来提供相同的功能。现在我将使用类风格重写<code class="du lm ln lo lb b">print_result_decorator</code>函数。</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="8cfa" class="lf kj hi lb b fi lg lh l li lj">class ClassResultDecorator:<br/>    def __init__(self, func):<br/>        self.func = func</span><span id="f5ef" class="lf kj hi lb b fi ll lh l li lj">    def __call__(self, *args, **kwargs):<br/>        result = self.func(*args, **kwargs)<br/>        print(f'Your result is {result}')<br/>        return result</span><span id="f279" class="lf kj hi lb b fi ll lh l li lj"><br/>@ClassResultDecorator<br/>def square(a):<br/>    return a * a</span><span id="0990" class="lf kj hi lb b fi ll lh l li lj"><br/>square(4)</span></pre><p id="918d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="d467" class="lf kj hi lb b fi lg lh l li lj">Your result is 16</span></pre><p id="b0ae" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如上定义函数时，首先调用<code class="du lm ln lo lb b">__init__</code>方法初始化实例，其中<code class="du lm ln lo lb b">square</code>被传递并设置为实例的属性。然后实例被返回并分配给<code class="du lm ln lo lb b">square</code>。当调用<code class="du lm ln lo lb b">square(4)</code>时，意味着我们正在调用<code class="du lm ln lo lb b">ClassResultDecorator</code>实例和方法<code class="du lm ln lo lb b">__call__</code>被调用并执行其行为。</p><h1 id="ae5c" class="ki kj hi bd kk kl lp kn ko kp lq kr ks io lr ip ku ir ls is kw iu lt iv ky kz bi translated">装饰器作为回调</h1><p id="1b8f" class="pw-post-body-paragraph jf jg hi jh b ji lu ij jk jl lv im jn jo lw jq jr js lx ju jv jw ly jy jz ka hb bi translated">Decorator 不仅仅是用来修改行为，它还有一个重要的应用，使得一个函数成为类中其他函数的回调函数。马上开始研究样品。</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="4127" class="lf kj hi lb b fi lg lh l li lj">class Calculator:<br/>    def connect(self, func):<br/>        self.printer = func</span><span id="7b3e" class="lf kj hi lb b fi ll lh l li lj">    def sum(self, a, b):<br/>        result = a + b<br/>        if hasattr(self, 'printer') and self.printer is not None:<br/>            self.printer(result)<br/>        return result</span><span id="0b20" class="lf kj hi lb b fi ll lh l li lj"><br/>cal = Calculator()</span><span id="9ee3" class="lf kj hi lb b fi ll lh l li lj"><br/>@cal.connect<br/>def print_result(result):<br/>    print(f'Your result is {result}')<br/></span><span id="b33a" class="lf kj hi lb b fi ll lh l li lj">cal.sum(1, 2)<br/>cal.sum(10, 10)</span></pre><p id="f2d8" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="6910" class="lf kj hi lb b fi lg lh l li lj">Your result is 3<br/>Your result is 20</span></pre><p id="724d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了传递一个要被回调的函数，我们需要定义一个要被装饰的类函数，其目的是将传递的函数保存为类实例的一个属性。在这种情况下，<code class="du lm ln lo lb b">connect</code>就是那个，它将<code class="du lm ln lo lb b">print_result</code>保存为计算器实例<code class="du lm ln lo lb b">cal</code>的属性<code class="du lm ln lo lb b">printer</code>。每次我们调用<code class="du lm ln lo lb b">cal.sum()</code>，在这个方法里面，<code class="du lm ln lo lb b">printer()</code>会被调用，并把汇总结果打印到控制台。</p><h1 id="960c" class="ki kj hi bd kk kl lp kn ko kp lq kr ks io lr ip ku ir ls is kw iu lt iv ky kz bi translated">结论</h1><p id="ed98" class="pw-post-body-paragraph jf jg hi jh b ji lu ij jk jl lv im jn jo lw jq jr js lx ju jv jw ly jy jz ka hb bi translated">Python decorator 非常棒，是保持代码整洁和可读性的一个非常有用的特性。虽然开始可能会有些混乱，但我希望你读完这篇文章后能有一个清晰的理解。</p><p id="f51d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最重要的是，感谢您抽出时间。</p></div></div>    
</body>
</html>