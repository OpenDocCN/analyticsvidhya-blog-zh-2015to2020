<html>
<head>
<title>Dissecting the Master Theorem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">剖析主定理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dissecting-the-master-theorem-part-2-proof-993b47b643b2?source=collection_archive---------27-----------------------#2020-01-02">https://medium.com/analytics-vidhya/dissecting-the-master-theorem-part-2-proof-993b47b643b2?source=collection_archive---------27-----------------------#2020-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5494" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第2部分:证据</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/accc5703a0021f74cca5b65cce265535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*0mFRbgTLCL1IZEKKRXgWEA.jpeg"/></div></figure><p id="9a35" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">所以正如我们在<a class="ae kb" rel="noopener" href="/analytics-vidhya/dissecting-the-master-theorem-part-1-recurrence-relation-4c3deb36097e?source=your_stories_page---------------------------">第1部分</a>中所看到的，理解了递归关系的概念。我们现在可以理解主定理是如何工作的了。回想一下，在上一篇文章中，我们将“a”定义为循环的次数，“b”定义为输入的除数，“d”定义为循环之外的工作的复杂程度，“n”定义为输入的大小。我们还定义了通常在递归树的j层有<strong class="jh hj"> aʲ </strong>子问题的数量和每个子问题的大小<strong class="jh hj"> n/bʲ </strong>(如果你不记得递归树是什么意思，请参考第1部分)。</p><p id="9289" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，我们想计算在j级完成了多少工作。假设我们有一个由4个问题组成的作业，我们想计算出我们需要多少时间/工作。我们可以把每个问题乘以它所花费的时间/工作，对吗？这和我们的案子有什么关系？我们想计算递归树中所做的总功。所以我们用问题的大小乘以问题的数量。用我们得到的定义替换英语:<strong class="jh hj"> aʲ。cnᵈ </strong>。回想一下<strong class="jh hj"> cnᵈ </strong>是递归关系定义中递归之外所做的工作。但实际上输入在j级<strong class="jh hj">的大小并不是“n”，它的<strong class="jh hj">是n/bʲ.所以我们得到了aʲ。c[n/bʲ]ᵈ </strong>这是有意义的，当我们深入递归时，输入的大小除以我们将问题除以幂的因子。</strong></p><p id="e6a7" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">不过，这是针对某个级别的<strong class="jh hj"> j </strong>。我们想计算所做的全部工作。因此，首先让我们重新安排我们的方程，通过分离依赖于水平的项和独立项，我们得到cnᵈ.【a/bᵈ]ʲ 。所以对所有能级所做的功将是所有j的总和。由于n是b的幂，所以树的长度为<strong class="jh hj"> logb(n)。</strong>所以我们求和∑从0到树的长度<strong class="jh hj"> logb(n) </strong>。最后我们有了<strong class="jh hj"> cnᵈ.∑ⱼ[a/bᵈ]ʲ </strong>其中j = 0到logb(n)。</p><p id="02f4" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">根据递归关系解释一般情况:</p><p id="2a5d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj"><em class="kc">【t(n)≤a t(n/b)+cnᵈ</em></strong></p><p id="e18a" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">无论是bᵈ、bᵈ还是bᵈ.让我们分别攻克每一项，然后理解每一项的真正含义。对于<strong class="jh hj"> a = bᵈ，</strong>让我们用<strong class="jh hj"> cnᵈ.代替∑ⱼ[a/bᵈ]ʲ </strong>在这里我们发现,<strong class="jh hj">项,</strong>将等于1，1的任何次方等于1。因此，总和将是1⁰和求和的其余部分，直到<strong class="jh hj"> logb(n) </strong>。我们以<strong class="jh hj"> [logb(n) +1]结束。因此，我们最终选择了cnᵈ。[logb(n)+1]即O(nlogn)。</strong>回想一下，这是合并排序中的情况，其中a = 2，bᵈ = 2。</p><p id="53cb" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">其次，对于一个&lt; bᵈ and a &gt; bᵈ，这些情况分别表明a/bᵈ是小于还是大于1。让我们用一个很好的证明来说明任何求和1 + a + a + a ……..aᵏ = aᵏ⁺ -1 / a-1。我们可以用归纳法迅速而容易地证明这一点。如果你不记得什么是归纳证明，请访问这个<a class="ae kb" href="https://www.youtube.com/watch?v=z8HKWUWS-lA" rel="noopener ugc nofollow" target="_blank"> youtube讲座</a>。</p><p id="6fe0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">归纳证明由两部分组成:证明</p><ol class=""><li id="df67" class="kd ke hi jh b ji jj jl jm jo kf js kg jw kh ka ki kj kk kl bi translated">基本情况是真实的</li><li id="a4ee" class="kd ke hi jh b ji km jl kn jo ko js kp jw kq ka ki kj kk kl bi translated">归纳步骤是正确的，我们将看到如何。</li></ol><p id="c412" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">基本情况我们归纳为0，并检查我们的要求的正确性。</p><p id="29a0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">a⁰ -1 / a-1 = 1，所以对于基本情况是正确的。</p><p id="7921" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然后，归纳步骤是假设对于k个数字，要求为真，然后检查k+1是否也为真。因此，我们将替换每个k，并把k+1: 1 + a + a + a ……..aᵏ + aᵏ⁺和aᵏ⁺ -1 / a-1。</p><p id="ec1e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">用这个求和就是1 + a + a + a ……..aᵏ = aᵏ⁺ -1 / a-1，我们得到aᵏ⁺ -1 / a-1 + aᵏ⁺。</p><p id="d6e6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然后，我们将独立项aᵏ⁺乘以a-1/a-1，得到:</p><p id="fb29" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">aᵏ⁺。a- aᵏ⁺ / a-1等于aᵏ⁺ -aᵏ⁺ /a-1。</p><p id="0b78" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">加上我们得到的条件:</p><p id="dd7c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">aᵏ⁺ -aᵏ⁺ +-aᵏ⁺ -1/a-1得到aᵏ⁺ -1/a-1。</p><p id="c9c1" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">所以归纳是真的。在使用归纳法时，一个非常宝贵的建议是，总是使用F(k)来证明F(k+1 ),如果你不使用它，你就是在用错误的方法做事情。</p><p id="289e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">回到我们的主要定理:对于a/bᵈ小于1的情况，我们发现aᵏ⁺ -1/a-1被1/1-a所有界，1/1-a是一个常数，与我们有多少项无关。所以<strong class="jh hj"> cnᵈ.∑ⱼ[a/bᵈ]ʲ </strong>将等于<strong class="jh hj"> cnᵈ.(1/1-a) </strong>哪个是<strong class="jh hj"> O(nᵈ).这是我们的第二个案例。最后我们只剩下比1大的a/bᵈ。</strong>回到我们的求和，这个求和会被最大项所支配，最大项等于logb(n ),所以我们以<strong class="jh hj"> cnᵈ.结束(a/bᵈ)ˡᵒᵍᵇⁿ.</strong></p><p id="626e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了简化这个可怕的术语，我们首先取<strong class="jh hj"> (b⁻ᵈ)ˡᵒᵍᵇⁿ </strong>，用<strong class="jh hj"> logb(n) </strong>代替d，得到<strong class="jh hj"> (bˡᵒᵍᵇⁿ)⁻ᵈ </strong>，用logb取消b的幂，得到<strong class="jh hj"> n⁻ᵈ.</strong>然后我们用<strong class="jh hj"> n⁻ᵈ </strong>取消<strong class="jh hj"> nᵈ </strong>并留下<strong class="jh hj"> aˡᵒᵍᵇⁿ(也可以公式化为nˡᵒᵍᵇᵃ </strong>其中<strong class="jh hj"> </strong>事实上是递归树的叶子数，递归调用的次数幂最后一级是树中的最后几个节点，这些节点是叶子。</p><p id="d32f" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这三种情况是:</p><ol class=""><li id="e1aa" class="kd ke hi jh b ji jj jl jm jo kf js kg jw kh ka ki kj kk kl bi translated">O(nlogn)</li><li id="9d48" class="kd ke hi jh b ji km jl kn jo ko js kp jw kq ka ki kj kk kl bi translated">O(nᵈ)</li><li id="7dbb" class="kd ke hi jh b ji km jl kn jo ko js kp jw kq ka ki kj kk kl bi translated">O(nˡᵒᵍᵇᵃ).</li></ol><p id="7030" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们分别总结一下各自的含义。在第一种情况下，进行的递归调用等于输入的划分，这表明每一级都做了相同的工作。在第二种情况下，递归调用少于输入的划分，这意味着我们在树中越深入，我们做的工作就越少，可以想象我们有两个递归调用，将输入分成两半，但我们在递归调用之外做二次工作。这意味着递归每一级只节省我们25%的工作。所以递归之外的工作支配着big-O符号。对于最后一种情况，递归调用比我们对问题的划分多，所以大O符号被树叶支配。</p><p id="f1d8" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你不需要记住这些价值观，只要理解这个<strong class="jh hj"> cnᵈ.就行了∑ⱼ[a/bᵈ]ʲ </strong>你将在几秒钟内得到公式。我试过了，100%有效。</p><p id="2ec3" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">希望这篇文章对你有用。非常感谢您的反馈。</p></div></div>    
</body>
</html>