<html>
<head>
<title>Tensorflow 2 for DeepLearning - Artificial Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于深度学习的 tensor flow 2-人工神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/tensorflow-2-for-deeplearning-artificial-neural-networks-8ec72b36f493?source=collection_archive---------14-----------------------#2020-12-23">https://medium.com/analytics-vidhya/tensorflow-2-for-deeplearning-artificial-neural-networks-8ec72b36f493?source=collection_archive---------14-----------------------#2020-12-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e45249e47145b62bd2a27c4f1ce817d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A-qJCGjKpW01cUQcnFdqiQ.jpeg"/></div></div></figure><p id="b5e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">注:代码文件将在:</em><a class="ae jp" href="https://github.com/ashwinhprasad/Tensorflow-2.0/blob/master/TF2-(4)-ANN/TF2-ANNs.ipynb" rel="noopener ugc nofollow" target="_blank"><em class="jo">https://github . com/ashwinhprasad/tensor flow-2.0/blob/master/TF2-(4)-安/TF2-安斯. ipynb </em> </a>获得</p><h1 id="78de" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="ac31" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">人工神经网络是传统的神经网络，这意味着在输入和输出层之间有多于或等于一层。这允许模型适应非线性并形成复杂的函数，这使得它在现实生活中有用。</p><p id="6fb5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇博文不仅仅涉及 tensorflow 2 的前馈或人工神经网络的实现，也不涉及人工神经网络的理论部分。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/03e93374f980eae00096ec6c34bec87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PQOnabj78avPB2Mikk5GQ.jpeg"/></div></div></figure><h1 id="d027" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">跳到代码</h1><p id="3108" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">最好看看人工神经网络在现实生活中是如何使用的，以便更好地理解它</p><h2 id="ef43" class="ky jr hi bd js kz la lb jw lc ld le ka jb lf lg ke jf lh li ki jj lj lk km ll bi translated">1.准备数据集</h2><blockquote class="lm ln lo"><p id="daaf" class="iq ir jo is b it iu iv iw ix iy iz ja lp jc jd je lq jg jh ji lr jk jl jm jn hb bi translated">我们将使用来自 sklearn 的波士顿房价数据集。导入数据集后，我将它转换为 pandas 数据框架，并删除一些似乎不必要的列，以创建一个能很好地概括该数据的模型。我删除了 Tax 和 Dis 专栏，因为我已经做了一些数据分析，这对于这篇博文是不必要的</p></blockquote><pre class="ku kv kw kx fd ls lt lu lv aw lw bi"><span id="fd23" class="ky jr hi lt b fi lx ly l lz ma"><em class="jo">#importing the libraries<br/></em><strong class="lt hj">import</strong> <strong class="lt hj">tensorflow</strong> <strong class="lt hj">as</strong> <strong class="lt hj">tf<br/>import</strong> <strong class="lt hj">numpy</strong> <strong class="lt hj">as</strong> <strong class="lt hj">np<br/>import</strong> <strong class="lt hj">pandas</strong> <strong class="lt hj">as</strong> <strong class="lt hj">pd<br/>import</strong> <strong class="lt hj">seaborn</strong> <strong class="lt hj">as</strong> <strong class="lt hj">sns<br/>import</strong> <strong class="lt hj">matplotlib.pyplot</strong> <strong class="lt hj">as</strong> <strong class="lt hj">plt</strong></span><span id="349c" class="ky jr hi lt b fi mb ly l lz ma"><em class="jo">#importing the dataset </em><br/><strong class="lt hj">from</strong> <strong class="lt hj">sklearn.datasets</strong> <strong class="lt hj">import</strong> load_boston<br/>dataset = load_boston()</span><span id="0463" class="ky jr hi lt b fi mb ly l lz ma"># Converting to Pandas DataFrame<br/>data = pd.DataFrame(dataset['data'],columns=['CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE', 'DIS', 'RAD',<br/>        'TAX', 'PTRATIO', 'B', 'LSTAT'])<br/>target = pd.Series(dataset['target'],name='price')<br/>data = pd.concat([data,target],axis=1)<br/>data.head()</span><span id="a6b0" class="ky jr hi lt b fi mb ly l lz ma"># dropping unnecessary values<br/><em class="jo">#removing unwanted columns</em><br/>data.drop(['TAX','DIS'],axis=1,inplace=<strong class="lt hj">True</strong>)</span></pre><h2 id="7b09" class="ky jr hi bd js kz la lb jw lc ld le ka jb lf lg ke jf lh li ki jj lj lk km ll bi translated">2.列车测试分离</h2><blockquote class="lm ln lo"><p id="9519" class="iq ir jo is b it iu iv iw ix iy iz ja lp jc jd je lq jg jh ji lr jk jl jm jn hb bi translated">将数据集分成训练集和测试集总是有用的，以便在新的不熟悉的数据上测试模型的性能。<br/></p></blockquote><pre class="ku kv kw kx fd ls lt lu lv aw lw bi"><span id="c166" class="ky jr hi lt b fi lx ly l lz ma"><em class="jo">#splitting into training and test set<br/></em><strong class="lt hj">from</strong> <strong class="lt hj">sklearn.model_selection</strong> <strong class="lt hj">import</strong> train_test_split<br/>x_train, x_test, y_train, y_test = train_test_split(data.drop(['price'],axis=1),data['price'],test_size=0.15)</span><span id="4252" class="ky jr hi lt b fi mb ly l lz ma"><em class="jo">#converting to numpy </em><br/>x_train = np.array(x_train)<br/>y_train = np.array(y_train)<br/>x_test = np.array(x_test)<br/>y_test = np.array(y_test)</span><span id="ff8a" class="ky jr hi lt b fi mb ly l lz ma"><em class="jo">#normlizing the inputs</em><br/><strong class="lt hj">from</strong> <strong class="lt hj">sklearn.preprocessing</strong> <strong class="lt hj">import</strong> StandardScaler<br/>sc = StandardScaler()<br/>x_train = sc.fit_transform(x_train)<br/>x_test = sc.transform(x_test</span></pre><h2 id="65db" class="ky jr hi bd js kz la lb jw lc ld le ka jb lf lg ke jf lh li ki jj lj lk km ll bi translated">3.Keras 功能 API</h2><blockquote class="lm ln lo"><p id="ede6" class="iq ir jo is b it iu iv iw ix iy iz ja lp jc jd je lq jg jh ji lr jk jl jm jn hb bi translated">在线性回归笔记本中，我使用了功能有限的顺序层，实际上我绝不会将它用于大多数事情，而是始终坚持使用 keras Functional API，它允许定义复杂的模型</p></blockquote><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/56b948a73c67292e9ce796ca9eb581de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*Xs31AY9jnmoAw3F0o6Jv1w.png"/></div></figure><blockquote class="lm ln lo"><p id="4fcf" class="iq ir jo is b it iu iv iw ix iy iz ja lp jc jd je lq jg jh ji lr jk jl jm jn hb bi translated">以下是如何使用 Keras Functional API 创建模型。<br/>在这里，我们基本上定义了所需层的类型，并且我们定义了每一层用“()”括起来的层的输入。这个模型有 3 个隐藏层。<br/> <strong class="is hj">密集</strong>是指普通的一层，有一堆神经元。您可以在 Dense 中指定该层的神经元数量和激活函数。</p></blockquote><pre class="ku kv kw kx fd ls lt lu lv aw lw bi"><span id="c0f7" class="ky jr hi lt b fi lx ly l lz ma"><em class="jo">#creating the model</em><br/>i = tf.keras.layers.Input(shape=(x_train.shape[1]))<br/>fc1 = tf.keras.layers.Dense(10,activation=tf.keras.activations.relu)(i)<br/>fc2 = tf.keras.layers.Dense(12,activation=tf.keras.activations.relu)(fc1)<br/>fc3 = tf.keras.layers.Dense(20,activation=tf.keras.activations.relu)(fc2)<br/>out = tf.keras.layers.Dense(1)(fc3)<br/><br/>model = tf.keras.models.Model(i,out)</span></pre><h2 id="e51b" class="ky jr hi bd js kz la lb jw lc ld le ka jb lf lg ke jf lh li ki jj lj lk km ll bi translated">4.训练神经网络</h2><blockquote class="lm ln lo"><p id="a529" class="iq ir jo is b it iu iv iw ix iy iz ja lp jc jd je lq jg jh ji lr jk jl jm jn hb bi translated">由于这是一个回归问题，我将适当的损失函数定义为均方误差，将优化器定义为 ADAM 和 AM 在训练集上训练模型，并通过测试集作为验证数据。</p></blockquote><pre class="ku kv kw kx fd ls lt lu lv aw lw bi"><span id="45aa" class="ky jr hi lt b fi lx ly l lz ma"><em class="jo">#optimizers and loss function</em><br/>model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),loss=tf.keras.losses.mse)</span><span id="4f69" class="ky jr hi lt b fi mb ly l lz ma"><em class="jo">#fitting the model to the data</em> train = model.fit(x_train,y_train,validation_data=(x_test,y_test),epochs=100,batch_size=128)</span></pre><h2 id="ea2a" class="ky jr hi bd js kz la lb jw lc ld le ka jb lf lg ke jf lh li ki jj lj lk km ll bi translated">5.模型分析</h2><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es md"><img src="../Images/8780b601c0e3b7fe48188bb967c8d55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*HinQr45RyAOkHn9uZniPeQ.png"/></div></figure><blockquote class="lm ln lo"><p id="df7b" class="iq ir jo is b it iu iv iw ix iy iz ja lp jc jd je lq jg jh ji lr jk jl jm jn hb bi translated">绘制训练集损失和测试集损失，以检查模型是否有任何偏差或差异</p></blockquote><pre class="ku kv kw kx fd ls lt lu lv aw lw bi"><span id="cd1c" class="ky jr hi lt b fi lx ly l lz ma"><em class="jo">#loss over epochs</em><br/>plt.figure(figsize=(10,8))<br/>plt.plot(train.history['loss'],label="Training set loss")<br/>plt.plot(train.history['val_loss'],label="Validation set loss")<br/>plt.xlabel('epochs')<br/>plt.ylabel('loss')<br/>plt.legend()</span><span id="954a" class="ky jr hi lt b fi mb ly l lz ma"><em class="jo">#predictions vs actual</em><br/>plt.figure(figsize=(10,8))<br/>plt.plot(y_test,label="original targets")<br/>plt.plot(y_pred,label="predicted targets")<br/>plt.legend()<br/>plt.xlabel('examples')<br/>plt.ylabel('predictions')</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es me"><img src="../Images/079c208ba7a3c001524b184909be56bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*fZHs6xUkXGiBQUV2PdbjgQ.png"/></div></figure><h1 id="919a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="d43b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">从上面的图中可以明显看出，该模型很好地适应了训练集，并且具有很好的泛化能力。这就是你如何用 tensorflow 2 实现一个常规的人工神经网络。</p><h2 id="342a" class="ky jr hi bd js kz la lb jw lc ld le ka jb lf lg ke jf lh li ki jj lj lk km ll bi translated">谢谢你</h2></div></div>    
</body>
</html>