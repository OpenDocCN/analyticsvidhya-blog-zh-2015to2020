<html>
<head>
<title>Simple Convolutional Neural Network Using Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keras的简单卷积神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/simple-convolutional-neural-network-using-keras-f2edcefc8f7c?source=collection_archive---------12-----------------------#2020-05-19">https://medium.com/analytics-vidhya/simple-convolutional-neural-network-using-keras-f2edcefc8f7c?source=collection_archive---------12-----------------------#2020-05-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1a76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">旋转神经网络是一类深度神经网络。之所以称之为深度，是因为它的架构上有很多层。CNN通常用于分析视觉图像。</p><p id="d60b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CNN由输入层、隐含层和输出层组成。隐藏层通常由一系列卷积层、汇集层、规范化层等组成。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/24a75e693771898534585358f77515ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z2OVr3BICT8bwAIa.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">CNN建筑(https://mc.ai/how-does-convolutional-neural-network-work/)</figcaption></figure><p id="5687" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将使用Keras来创建架构和运行计算。Keras是一个python库，它帮助我们非常简单容易地构建神经网络。</p><p id="0634" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将尝试建立用于分类MNIST数据集(28x28图像)的模型，该数据集由从0到9的70，000张手写图像组成。</p><h2 id="913e" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated"><strong class="ak">准备数据</strong></h2><p id="7b22" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">Keras图书馆准备了MNIST数据集供我们使用。</p><pre class="jn jo jp jq fd lc ld le lf aw lg bi"><span id="eeb6" class="kc kd hi ld b fi lh li l lj lk">from keras.datasets import mnist</span></pre><p id="4cd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导入数据集后，我们需要将数据集加载到训练数据集和测试数据集。MNIST的数据为我们提供了60，000个训练数据和10，000个测试数据</p><pre class="jn jo jp jq fd lc ld le lf aw lg bi"><span id="fd53" class="kc kd hi ld b fi lh li l lj lk">(x_train, y_train), (x_test, y_test) = mnist.load_data()<br/>print('Training data count: {}'.format(x_train.shape[0]))<br/>print('Testing data count: {}'.format(x_test.shape[0]))</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ll"><img src="../Images/a5105b9e80f96fb0aa9258bf481df7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ie9SdFLI9FhJ7P6BgAiH5Q.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">培训和测试数据计数</figcaption></figure><p id="2d95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MNIST的数据如下所示:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es lm"><img src="../Images/c105bd7b4fc59dd1540e2095cf525042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bkpoePi4hUQ_bWPq3fPVg.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">MNIST数据示例</figcaption></figure><h2 id="43c6" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated"><strong class="ak">数据预处理</strong></h2><p id="cca4" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">加载数据后，我们需要在将数据输入网络之前对数据进行预处理。我们知道，MNIST数据是28x28的图像，该模型将期待与形状(数据计数，重量，高度，通道)的输入。因此，我们需要重塑我们的数据，代码将如下所示:</p><pre class="jn jo jp jq fd lc ld le lf aw lg bi"><span id="cee3" class="kc kd hi ld b fi lh li l lj lk">x_train = x_train.reshape(60000,28,28,1)<br/>x_test = x_test.reshape(10000,28,28,1)</span></pre><p id="64cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们应该使用一键编码器对每个数据的标签进行预处理。这将为每个类别创建一个二进制列，并返回一个稀疏矩阵或密集数组。</p><p id="5bd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多方法可以对标签进行编码，这段代码使用的是sklearn库:</p><pre class="jn jo jp jq fd lc ld le lf aw lg bi"><span id="a647" class="kc kd hi ld b fi lh li l lj lk">from sklearn.preprocessing import OneHotEncoder</span><span id="2b48" class="kc kd hi ld b fi ln li l lj lk">encoder = OneHotEncoder(sparse=False)<br/>y_train = y_train.reshape(-1, 1)<br/>y_train = encoder.fit_transform(y_train)</span><span id="428d" class="kc kd hi ld b fi ln li l lj lk">y_test= y_train.reshape(-1, 1)<br/>y_test = encoder.fit_transform(y_test)</span></pre><p id="3ce3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个用的是Keras</p><pre class="jn jo jp jq fd lc ld le lf aw lg bi"><span id="6613" class="kc kd hi ld b fi lh li l lj lk">from keras.utils import to_categorical</span><span id="8862" class="kc kd hi ld b fi ln li l lj lk">y_train = to_categorical(y_train)<br/>y_test = to_categorical(y_test)</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lo"><img src="../Images/407ece5a3769a76ca34618b444c5e938.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*fhMrRkshj4ZaGpOf7j2ZHg.png"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">一键编码器输出</figcaption></figure><h2 id="59be" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">构建模型</h2><p id="1104" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们已经准备好了数据，现在我们用Keras建立一个序列模型。为什么是顺序的？因为，顺序模型用于将模型构建为简单的层堆栈。</p><pre class="jn jo jp jq fd lc ld le lf aw lg bi"><span id="4e62" class="kc kd hi ld b fi lh li l lj lk">from keras.models import Sequential<br/>from keras.layers import Dense, Conv2D, Flatten</span><span id="da3d" class="kc kd hi ld b fi ln li l lj lk">model = Sequential()<br/>model.add(Conv2D(16, kernel_size=3, activation='relu', input_shape=(28,28,1)))<br/>model.add(Conv2D(8, kernel_size=3, activation='relu'))<br/>model.add(Flatten())<br/>model.add(Dense(10, activation='softmax'))</span></pre><p id="6b65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一卷积层中的16和第二卷积层中的8是该层中的节点数(可以调整)，kernel_size是卷积窗口的大小。</p><p id="bb51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在卷积层之后，有一个展平层。它将最后一个卷积层的输出转换成一维数组。</p><p id="9841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">密集层是在许多情况下用于神经网络的经典层。我们可以添加另一个密集层，使我们的网络更智能(不总是这样！).</p><h2 id="a6fc" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">编译模型</h2><p id="8205" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">创建模型后，我们需要编译模型。它需要优化器、损失函数和一系列指标。</p><pre class="jn jo jp jq fd lc ld le lf aw lg bi"><span id="337b" class="kc kd hi ld b fi lh li l lj lk">model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])</span></pre><p id="7163" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用“adam”优化器，因为它非常好(你也可以尝试另一个优化器)。</p><p id="8f82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用的损失函数是<em class="lp">categorial _ cross entropy</em>，我们在最后一层使用softmax，因为我们的数据是多类的，我们正在制作单标签分类模型。你可以参考这篇<a class="ae lq" href="https://www.dlology.com/blog/how-to-choose-last-layer-activation-and-loss-function/" rel="noopener ugc nofollow" target="_blank">文章</a>找到关于损失函数和最后一层激活的细节。</p><h2 id="0752" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">训练模型</h2><pre class="jn jo jp jq fd lc ld le lf aw lg bi"><span id="3e43" class="kc kd hi ld b fi lh li l lj lk">history = model.fit(x_train, y_train, validation_data=(x_test, y_test), epochs=5)</span></pre><p id="8a96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们只需从模型中调用fit函数，Keras就会自动运行计算来训练我们的数据。正如你在上面的代码中看到的，fit方法需要以下参数:x_data，y_data，epoch的数量。验证数据是一个可选参数。我们使用验证数据来检查我们的模型是否足够好，或者是否过拟合。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es lr"><img src="../Images/75e9cb797cef0fcd09f2b6ad2a4db2f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgIV1mbbr-r10662E4i2sQ.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">5个时期后的结果</figcaption></figure><p id="3130" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的验证(测试)数据集中，我们得到了97.06%。这对我们的模型来说已经足够好了。我们可以调整<a class="ae lq" href="https://en.wikipedia.org/wiki/Hyperparameter_(machine_learning)" rel="noopener ugc nofollow" target="_blank">超参数</a>来使我们的模型更大。</p><h2 id="f6d8" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">使用模型进行预测</h2><p id="1c37" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们可以简单地将一些输入数组传递给预测方法</p><pre class="jn jo jp jq fd lc ld le lf aw lg bi"><span id="fb59" class="kc kd hi ld b fi lh li l lj lk">prediction = model.predict(x_test[:3]) #first 3 data of test data</span></pre><p id="ca9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它将返回一个输出数组，如下所示:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es ls"><img src="../Images/4d8bc10effa0af8a077cdfb8f97fda51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOAbM5RPe2MSj9asYUeN3Q.png"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">模型输出</figcaption></figure><p id="66a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用numpy的argmax函数获得实际的数字。下面的代码绘制了带有标签的测试图像:</p><pre class="jn jo jp jq fd lc ld le lf aw lg bi"><span id="89d9" class="kc kd hi ld b fi lh li l lj lk">import numpy as np</span><span id="2ece" class="kc kd hi ld b fi ln li l lj lk">prediction = model.predict(x_test[:3])<br/>print(prediction)</span><span id="1f88" class="kc kd hi ld b fi ln li l lj lk">w=60<br/>h=40</span><span id="0b54" class="kc kd hi ld b fi ln li l lj lk">fig=plt.figure(figsize=(15, 15))<br/>columns = 3<br/>rows = 1<br/>for i in range(1, columns*rows +1):<br/>    ax = fig.add_subplot(rows, columns, i)<br/>    plt.xticks([], [])<br/>    plt.yticks([], [])actual_label = np.argmax(y_test[i-1])<br/>    prediction_label = np.argmax(prediction[i-1])</span><span id="b526" class="kc kd hi ld b fi ln li l lj lk">    ax.title.set_text('Prediction: {} - Actual:  {}'.format(prediction_label, actual_label))</span><span id="4bb4" class="kc kd hi ld b fi ln li l lj lk">    image = x_test[i-1].reshape((28,28))</span><span id="329e" class="kc kd hi ld b fi ln li l lj lk">    plt.imshow(image, cmap='gray')</span><span id="b0e5" class="kc kd hi ld b fi ln li l lj lk">plt.show()</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es lt"><img src="../Images/073a5430798f7781b4bdeff1ddf59d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiNpl6ZZTOl72oCuyToBTQ.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">结果</figcaption></figure><p id="8550" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，您创建了自己的模型来对MNIST数据进行分类。恭喜你。！👏👏👏</p><p id="a871" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我会在google colab或github上提供完整的源代码供你参考。</p><blockquote class="lu lv lw"><p id="6ad4" class="if ig lp ih b ii ij ik il im in io ip lx ir is it ly iv iw ix lz iz ja jb jc hb bi translated"><a class="ae lq" href="https://colab.research.google.com/drive/1Gha17Akie8gBk6rJUP0dEhzUZit3fZtl?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/1 gha 17 akie 8 gbk 6 r jup 0 dehzuzit 3 fztl？usp =分享</a></p><p id="4346" class="if ig lp ih b ii ij ik il im in io ip lx ir is it ly iv iw ix lz iz ja jb jc hb bi translated"><a class="ae lq" href="https://github.com/ardiantutomo/simple-cnn-mnist/blob/master/Simple_CNN_for_MNIST.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/ardiantutomo/Simple-CNN-Mn ist/blob/master/Simple _ CNN _ for _ Mn ist . ipynb</a></p></blockquote><p id="c728" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读。希望你喜欢它！🙏</p></div></div>    
</body>
</html>