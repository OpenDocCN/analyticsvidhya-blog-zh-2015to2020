<html>
<head>
<title>Dijkstra’s Algorithm Visualizer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dijkstra算法可视化器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dijkstras-algorithm-visualizer-fe5332a1980a?source=collection_archive---------6-----------------------#2020-12-24">https://medium.com/analytics-vidhya/dijkstras-algorithm-visualizer-fe5332a1980a?source=collection_archive---------6-----------------------#2020-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="772c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">—所有路径查找算法之母</p><h1 id="9917" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Dijkstra的算法是什么？</h1><p id="7b26" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">首先让我们弄清楚什么是Dijkstra算法。是的，这个名字听起来很奇怪。这是一种图形数据结构中的路径查找算法。对图到底是什么感到困惑？图是存储两个节点之间关系的数据结构(节点可以是保存数据的任何东西),例如:考虑脸书——你可以有多个朋友，你的朋友也可以有相同的朋友。有没有想过脸书是如何存储用户之间的联系的——是的，他们使用图形数据结构</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/50472050fa8a65fe3165ec0c1493778c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbV6VeCRFwxZRN2pbiPAgA.jpeg"/></div></div></figure><h1 id="d6c4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">它是如何工作的？</h1><p id="671e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在让我们讨论算法是如何工作的。考虑一个带有加权边(连接两个节点的线是边)的图，如下所示</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ks"><img src="../Images/10fe494d2d48fbf19475e0eb4b05fd6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YC5N4b4r_5XkB8RgmNEzew.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">图表示例</figcaption></figure><p id="fe11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你在位置0，你想去位置4。您可以很容易地找到从位置0到位置4的最短路径。但是电脑就像孩子一样，我们需要给他们提供一切。让我们绘制一个表格来理解算法中涉及的步骤。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kx"><img src="../Images/3be71025b0adcb6b8dc07d8db6b20034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mCAYiY5BP4V9BZJEOCklg.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">表1</figcaption></figure><p id="2308" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将第0个位置视为起始节点，我们将距离设为0(当然，从x到x的距离总是为零)。对于算法的情况，我们使所有其他距离为无穷大。</p><p id="6dd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们要选择当前节点的一个相邻节点(节点0)。顺序不是问题。</p><p id="820f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当前节点= 0，考虑节点= 1</p><blockquote class="ky kz la"><p id="9331" class="if ig lb ih b ii ij ik il im in io ip lc ir is it ld iv iw ix le iz ja jb jc hb bi translated">距离(考虑节点)=距离(当前节点)+重量</p></blockquote><p id="426d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里权重是当前节点和考虑节点之间的边上的数。在计算了所考虑的节点的距离之后，如果该距离小于表中该特定节点的现有距离，则我们替换该值(这就是为什么我们使用无穷大作为默认距离的原因，这样任何距离在开始时都将小于无穷大)。现在考虑当前节点的第二个邻居，并做同样的事情。</p><p id="8b89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(注意:我们需要将访问过的节点存储在某个地方，这样我们就不会迭代已经访问过的同一个节点)</p><p id="5e0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新当前节点的每个相邻节点的距离值后，将当前节点添加为所有相邻节点的from列。遍历第一个节点后，该表应该如下所示:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kx"><img src="../Images/35ea012504c2fca9e49bf4670085475d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LI1F4Hi7-84Q-o7Lz6GKHw.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">表2</figcaption></figure><p id="4814" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑尚未访问的节点，并在表中选择距离最短的节点。在这个例子中，节点1在所有未被访问的节点中具有最低的距离(注意，节点0被访问)。所以拿起那个，做同样的过程，直到图中没有未访问的节点。现在桌子会像这样:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kx"><img src="../Images/5605e0716cbf12debe413ccd4595c1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEg4AXm-O4z2S0fKsQbuVA.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">表3</figcaption></figure><p id="7596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是算法，是的，你没看错。算法到此为止。您可以使用此表来查找从节点0到任何其他节点的最短距离。例如:假设我们需要从节点0访问节点4，为了找到最短路径，我们需要从节点4回溯。参考节点4所在的行。它来自5，现在看看5，它来自6，重复这个过程，直到到达节点0(源)。因此，路径将是:</p><blockquote class="ky kz la"><p id="23f3" class="if ig lb ih b ii ij ik il im in io ip lc ir is it ld iv iw ix le iz ja jb jc hb bi">4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 0</p></blockquote></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h1 id="149c" class="jd je hi bd jf jg lm ji jj jk ln jm jn jo lo jq jr js lp ju jv jw lq jy jz ka bi translated">可视化:</h1><p id="5e61" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们将使用python游戏模块pygame来可视化算法。我的实现只是一个实践，包含一些错误，但只是为了可视化，这没什么。我不打算介绍python的基础知识。如果你不知道python，请从这里停止阅读。</p><p id="b449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个目录(可以随意命名)，在该目录中创建一个名为main.py的文件，并在其中插入以下代码:</p><pre class="kh ki kj kk fd lr ls lt lu aw lv bi"><span id="555a" class="lw je hi ls b fi lx ly l lz ma">import pygame<br/>from constants import *<br/>from components import *<br/>from helper import *<br/>from algorithm import find_shortest_path</span><span id="9fc6" class="lw je hi ls b fi mb ly l lz ma">pygame.init()<br/>pygame.display.set_caption("Dijkstra's Algorithm")<br/>screen = pygame.display.set_mode([ WIDTH, WIDTH ])<br/>screen.fill(BLACK)</span><span id="445f" class="lw je hi ls b fi mb ly l lz ma">def main():<br/> running = True<br/> dragging = False<br/> disabled = False</span><span id="f534" class="lw je hi ls b fi mb ly l lz ma">board = Board(screen)<br/> grid = board.grid</span><span id="e205" class="lw je hi ls b fi mb ly l lz ma">while running:<br/>  board.draw()</span><span id="9fdc" class="lw je hi ls b fi mb ly l lz ma">for event in pygame.event.get():<br/>   if event.type == pygame.QUIT:<br/>    running = False</span><span id="e7ae" class="lw je hi ls b fi mb ly l lz ma">if disabled and (event.type == pygame.KEYDOWN or event.type == pygame.MOUSEBUTTONDOWN):<br/>    disabled = False<br/>    board = Board(screen)<br/>    grid = board.grid</span><span id="033e" class="lw je hi ls b fi mb ly l lz ma">elif event.type == pygame.MOUSEBUTTONDOWN:<br/>    if event.button == 1:<br/>     dragging = True<br/>     handle_mouse_event(board)</span><span id="edce" class="lw je hi ls b fi mb ly l lz ma">elif event.type == pygame.MOUSEMOTION and dragging:<br/>    handle_mouse_event(board)</span><span id="b163" class="lw je hi ls b fi mb ly l lz ma">elif event.type == pygame.MOUSEBUTTONUP:<br/>    dragging = False</span><span id="c340" class="lw je hi ls b fi mb ly l lz ma">elif event.type == pygame.KEYDOWN:<br/>    if event.key == pygame.K_SPACE:<br/>     find_shortest_path(board)<br/>     board.start.set_start()<br/>     board.end.set_end()<br/>     disabled = True</span><span id="6c5e" class="lw je hi ls b fi mb ly l lz ma">pygame.quit()</span><span id="b54b" class="lw je hi ls b fi mb ly l lz ma">if __name__ == '__main__':<br/> main()</span></pre><p id="5f90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在创建另一个名为components.py的文件，并粘贴以下内容:</p><pre class="kh ki kj kk fd lr ls lt lu aw lv bi"><span id="af98" class="lw je hi ls b fi lx ly l lz ma">import pygame<br/>from constants import *<br/>from helper import *</span><span id="0006" class="lw je hi ls b fi mb ly l lz ma">class Item():<br/> ITEM_WIDTH = WIDTH // ROWS</span><span id="a824" class="lw je hi ls b fi mb ly l lz ma">def __init__(self, screen, row, col):<br/>  self.screen = screen<br/>  self.row = row<br/>  self.col = col<br/>  self.color = WHITE<br/>  self.neighbours = []</span><span id="eb1e" class="lw je hi ls b fi mb ly l lz ma">self.x = self.row * self.ITEM_WIDTH<br/>  self.y = self.col * self.ITEM_WIDTH</span><span id="0e29" class="lw je hi ls b fi mb ly l lz ma">def set_start(self):<br/>  self.color = GREEN</span><span id="4724" class="lw je hi ls b fi mb ly l lz ma">def set_end(self):<br/>  self.color = RED</span><span id="9d0c" class="lw je hi ls b fi mb ly l lz ma">def set_wall(self):<br/>  self.color = BLACK</span><span id="e4c4" class="lw je hi ls b fi mb ly l lz ma">def set_visited(self):<br/>  self.color = BLUE</span><span id="d2c7" class="lw je hi ls b fi mb ly l lz ma">def set_path(self):<br/>  self.color = GREY</span><span id="1c5e" class="lw je hi ls b fi mb ly l lz ma">def get_neighbours(self, grid):<br/>  neighbours = []</span><span id="2dc7" class="lw je hi ls b fi mb ly l lz ma">if self.row &gt; 0 and grid[self.row - 1][self.col].color != BLACK:<br/>   neighbours.append(grid[self.row - 1][self.col])</span><span id="dc98" class="lw je hi ls b fi mb ly l lz ma">if self.row &lt; ROWS - 1 and grid[self.row + 1][self.col].color != BLACK:<br/>   neighbours.append(grid[self.row + 1][self.col])</span><span id="3598" class="lw je hi ls b fi mb ly l lz ma">if self.col &gt; 0 and grid[self.row][self.col - 1].color != BLACK:<br/>   neighbours.append(grid[self.row][self.col - 1])</span><span id="b519" class="lw je hi ls b fi mb ly l lz ma">if self.col &lt; ROWS - 1 and grid[self.row][self.col + 1].color != BLACK:<br/>   neighbours.append(grid[self.row][self.col + 1])</span><span id="6193" class="lw je hi ls b fi mb ly l lz ma">return neighbours</span><span id="8cae" class="lw je hi ls b fi mb ly l lz ma">def draw(self):<br/>  pygame.draw.rect(<br/>   self.screen, <br/>   self.color, <br/>   (self.x, self.y, self.ITEM_WIDTH, self.ITEM_WIDTH)<br/>  )</span><span id="24a5" class="lw je hi ls b fi mb ly l lz ma">def get_pos(self):<br/>  return self.x, self.y</span><span id="d033" class="lw je hi ls b fi mb ly l lz ma">def __str__(self):<br/>  return f"{self.row}, {self.col}"</span><span id="b859" class="lw je hi ls b fi mb ly l lz ma">class Board():<br/> def __init__(self, screen):<br/>  self.screen = screen<br/>  self.grid = generate_grid(screen, ROWS, ROWS, Item)<br/>  self.start = None<br/>  self.end = None</span><span id="6a37" class="lw je hi ls b fi mb ly l lz ma">def _draw_lines(self):<br/>  for row in self.grid:<br/>   for col in row:<br/>    x, y = col.get_pos()<br/>    pygame.draw.rect(<br/>     self.screen, <br/>     BLACK, <br/>     pygame.Rect(x, y, col.ITEM_WIDTH, col.ITEM_WIDTH),<br/>     1<br/>    )<br/>  pygame.display.flip()</span><span id="f575" class="lw je hi ls b fi mb ly l lz ma">def draw(self):<br/>  for row in self.grid:<br/>   for col in row:<br/>    col.draw()<br/>    <br/>  self._draw_lines()<br/>  pygame.display.update()</span></pre><p id="db42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在常量文件:</p><pre class="kh ki kj kk fd lr ls lt lu aw lv bi"><span id="8d70" class="lw je hi ls b fi lx ly l lz ma">WIDTH = 800<br/>ROWS = 40</span><span id="2c3a" class="lw je hi ls b fi mb ly l lz ma">BLACK = (0, 0, 0)<br/>WHITE = (255, 255, 255)<br/>GREEN = (0, 255, 0)<br/>RED = (255, 0, 0)<br/>BLUE = (0, 0, 255)<br/>GREY = (66, 66, 66)</span></pre><p id="8298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以调整宽度和行数来改变游戏的用户界面。确保行是宽度的一个因素。</p><p id="5b50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如下所示创建helper.py文件</p><pre class="kh ki kj kk fd lr ls lt lu aw lv bi"><span id="eb83" class="lw je hi ls b fi lx ly l lz ma">import pygame<br/>from constants import *</span><span id="b889" class="lw je hi ls b fi mb ly l lz ma">def generate_grid(screen, rows, cols, Item):<br/> grid = []<br/> for row in range(rows):<br/>  grid.append([])<br/>  for col in range(cols):<br/>   grid[row].append(Item(screen, row, col))</span><span id="83f1" class="lw je hi ls b fi mb ly l lz ma">return grid</span><span id="0753" class="lw je hi ls b fi mb ly l lz ma">def get_pos(x, y):<br/> return x // (WIDTH // ROWS), y // (WIDTH // ROWS)</span><span id="6dcf" class="lw je hi ls b fi mb ly l lz ma">def handle_mouse_event(board):<br/> grid = board.grid<br/> start = board.start<br/> end = board.end</span><span id="97b9" class="lw je hi ls b fi mb ly l lz ma">x, y = pygame.mouse.get_pos()<br/> row, col = get_pos(x, y)</span><span id="2f21" class="lw je hi ls b fi mb ly l lz ma">if not start:<br/>  grid[row][col].set_start()<br/>  board.start = grid[row][col]</span><span id="3f66" class="lw je hi ls b fi mb ly l lz ma">elif not end and grid[row][col] != start:<br/>  grid[row][col].set_end()<br/>  board.end = grid[row][col]</span><span id="f6cf" class="lw je hi ls b fi mb ly l lz ma">elif grid[row][col] != start and grid[row][col] != end:<br/>  grid[row][col].set_wall()</span></pre><p id="5e58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些文件都是为了游戏。现在到了重要的部分，是的，算法实现，如下所示:</p><pre class="kh ki kj kk fd lr ls lt lu aw lv bi"><span id="8323" class="lw je hi ls b fi lx ly l lz ma">def get_min_distance(distance, unvisited):<br/> minimum = next(iter(distance))</span><span id="41c9" class="lw je hi ls b fi mb ly l lz ma">for item in distance:<br/>  if distance[item] &lt; distance[minimum] and not unvisited[item]:<br/>   minimum = item</span><span id="974f" class="lw je hi ls b fi mb ly l lz ma">return minimum</span><span id="4856" class="lw je hi ls b fi mb ly l lz ma">def draw_path(from_list, start, end):<br/> if end == start:<br/>  return<br/> end.set_path()<br/> draw_path(from_list, start, from_list[end])</span><span id="203f" class="lw je hi ls b fi mb ly l lz ma">def find_shortest_path(board):<br/> grid = board.grid<br/> start = board.start<br/> end = board.end</span><span id="87f5" class="lw je hi ls b fi mb ly l lz ma">unvisited = {col: False for row in grid for col in row}</span><span id="fb77" class="lw je hi ls b fi mb ly l lz ma">distance = {col: float("inf") for row in grid for col in row}<br/> distance[start] = 0</span><span id="8949" class="lw je hi ls b fi mb ly l lz ma">from_list = {}</span><span id="2d39" class="lw je hi ls b fi mb ly l lz ma">while any(unvisited):<br/>  current = get_min_distance(distance, unvisited)</span><span id="1018" class="lw je hi ls b fi mb ly l lz ma">if current == end:<br/>   draw_path(from_list, start, end)<br/>   return True</span><span id="c5c9" class="lw je hi ls b fi mb ly l lz ma">for neighbour in current.get_neighbours(grid):<br/>   temp_dist = distance[current] + 1<br/>   if temp_dist &lt; distance[neighbour]:<br/>    distance[neighbour] = temp_dist<br/>   <br/>    from_list[neighbour] = current</span><span id="f506" class="lw je hi ls b fi mb ly l lz ma">current.set_visited()<br/>  unvisited[current] = True</span><span id="87c6" class="lw je hi ls b fi mb ly l lz ma">return False</span></pre><p id="de41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">推荐大家自己编算法，请不要只是复制粘贴我做的代码(里面有几个bug，我只是做着玩的)。</p><p id="0c59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是<a class="ae mc" href="https://github.com/GanapathyPT/Short-Path-Finder" rel="noopener ugc nofollow" target="_blank">回购</a>链接，以供参考</p><blockquote class="md"><p id="6d49" class="me mf hi bd mg mh mi mj mk ml mm jc dx translated">感谢阅读</p></blockquote></div></div>    
</body>
</html>