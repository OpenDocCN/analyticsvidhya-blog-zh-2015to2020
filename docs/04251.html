<html>
<head>
<title>Get Started with NumPy now!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">立即开始使用NumPy！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/get-started-with-numpy-now-d2e637aecdef?source=collection_archive---------15-----------------------#2020-03-11">https://medium.com/analytics-vidhya/get-started-with-numpy-now-d2e637aecdef?source=collection_archive---------15-----------------------#2020-03-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7b9910b082e234d668f4c84783667302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6_b3TeY-DLbMrNm2lLj1w.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">简·劳格森在<a class="ae iu" href="https://unsplash.com/search/photos/numbers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="eaa8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">NumPy是在大数据集中进行数值计算的一个非常强大的工具。这是一个python库，它有许多用于执行快速矢量化数组操作的内置方法。NumPy可以用来在整个数组上执行复杂的计算，而不需要Python for循环，并且它在内存使用方面比纯Python更有效。在这篇文章中，我将讨论一些创建numpy数组的基本方法，然后是一些常见的操作，以及我们如何使用它们来提高性能。你可以在我的github库<a class="ae iu" href="https://github.com/AhsanShihab/Hello-World-to-Data-Science/blob/master/Basics%20to%20get%20started%20with%20NumPy.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到所有代码，我在一个jupyter笔记本上有几乎相同的博客。您可以下载它，运行代码，试验它们以获得更好的理解。</p><h1 id="182c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">导入数字</h1><p id="39d4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果您的计算机上安装了numpy，那么您只需键入下面的代码行，就可以将该库导入到您的代码文件中。这里我们给它起了一个昵称“np ”,这样我们就可以用这个短名字来指代它，而不是每次使用时都要输入完整的长名字。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6f90" class="lf ju hi lb b fi lg lh l li lj">import numpy as np</span></pre><p id="17a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我使用包含numpy库的Anaconda发行版安装python。如果您没有安装它，只需在命令提示符下运行以下命令来安装它。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8954" class="lf ju hi lb b fi lg lh l li lj">pip install numpy</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/ec9ba46f75928c6f3fc6aba2f9ee944c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPrsUPjmyZDqrHnK_YQcwA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">安德斯·吉尔登在<a class="ae iu" href="https://unsplash.com/s/photos/fast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="1f86" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">有多快？</h1><p id="4621" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在进入细节之前，我们先通过一点点测试说服自己，numpy其实是一个非常有效的大数据数值计算的库。我们将以两种方式执行相同的任务，一种是使用numpy数组，另一种是借助loop的纯python计数器部分。我们将比较两个操作完成所需的计算时间。</p><p id="7ca3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我可以使用jupyter笔记本的神奇功能%time来测量每次操作所需的时间，你可以在github的我的笔记本中找到。但是在其他ide中，神奇的函数就不起作用了。所以，这里有一个替代的方法。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="dd83" class="lf ju hi lb b fi lg lh l li lj">import time</span></pre><p id="e6fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们将创建一个数组和一个python等价列表。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="255c" class="lf ju hi lb b fi lg lh l li lj">array = np.arange(10000000)<br/>list_1 = [x for x in range(10000000)]</span></pre><p id="d3a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们将做一个简单的操作，平方所有的元素，从1到10000000，首先以矢量化的方式，然后使用循环。我们将测量两个操作的时间。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="476f" class="lf ju hi lb b fi lg lh l li lj">tick = time.time()<br/>array = array ** 2<br/>tock = time.time()<br/>print(tock - tick)</span></pre><blockquote class="ll lm ln"><p id="28ae" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>0.000036868686</p></blockquote><p id="358c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的例子中，它花了0.0449秒(根据硬件的不同会有所不同)。现在让我们检查循环操作。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c5cc" class="lf ju hi lb b fi lg lh l li lj">tick = time.time()<br/>list_2 = [x ** 2 for x in list_1]<br/>tock = time.time()<br/>print(tock - tick)</span></pre><blockquote class="ll lm ln"><p id="7b54" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>6.000636368667</p></blockquote><p id="a779" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我这种情况，用了6.0544s！几乎慢了130倍！因此，与循环操作相比，矢量化操作的速度有多快是显而易见的。既然您已经确信numpy实际上非常高效，那么让我们熟悉一下它。</p><h1 id="94ef" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建NumPy数组</h1><p id="cb83" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">NumPy数组可以是一维或多维的。让我们首先看看如何从python列表中创建numpy数组。我们可以通过numpy内置的array()函数轻松做到这一点。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5bbb" class="lf ju hi lb b fi lg lh l li lj"># Creating one dimensional NP array<br/>list_1 = [1,2,3]<br/>array_1 = np.array(list_1)<br/>print(array_1)</span><span id="4d41" class="lf ju hi lb b fi ls lh l li lj"># Creating multi dimensional NP array<br/>list_2 = [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]<br/>array_2 = np.array(list_2)<br/>print(array_2)</span></pre><blockquote class="ll lm ln"><p id="22ef" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:</p><p id="6865" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">数组([1，2，3])</p><p id="0455" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">数组([[ 1，2，3]，<br/>，<br/>，【7，8，9】，<br/>，【10，11，12】))</p></blockquote><p id="7d76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个array()函数接受任何类似序列的对象(包括其他数组)。在从包含其他列表的列表创建多维数组的情况下，这些列表的长度需要彼此相等。否则只会创建一个数据类型为“object”的一维数组。为了更好地理解，你可以自己尝试一下。</p><p id="8b7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们想通过自动生成序列中的数据来创建数组，我们可以通过NP的“arange()”函数来实现。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ce88" class="lf ju hi lb b fi lg lh l li lj"># arange([start,optional] stop[, step, optional], dtype=None)</span><span id="1e8f" class="lf ju hi lb b fi ls lh l li lj">array_3 = np.arange(5) # One dimensional<br/>print("array 3: \n{0}".format(array_3)) # Printing the array</span><span id="15df" class="lf ju hi lb b fi ls lh l li lj">array_4 = np.arange(2,5) # One dimensional with specified start<br/>print("\narray 4: \n{0}".format(array_4)) # Printing the array</span><span id="e41d" class="lf ju hi lb b fi ls lh l li lj">array_5 = np.arange(2,10,2) # One dimensional with specified start and steps, starts at 2, ends at 10, steps 2<br/>print("\narray 5: \n{0}".format(array_5)) # Printing the array</span></pre><blockquote class="ll lm ln"><p id="b977" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:</p><p id="fdc1" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">数组3: <br/> [0 1 2 3 4]</p><p id="19fa" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">阵列4:<br/>【2 3 4】</p><p id="3f72" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">数组5:<br/>【2 4 6 8】</p></blockquote><p id="14bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">numpy中有两个内置函数，用于创建只有1或0的数组。它们在某些情况下可能会有用。所以有内置函数给它就好了。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="dcee" class="lf ju hi lb b fi lg lh l li lj">some_array_6 = np.zeros((2,3)) # Dimension is set to be 2x3<br/>some_array_7 = np.ones((2,3))</span></pre><p id="a29e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，这些值将是浮点值。如果需要整数值，也可以指定。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="febf" class="lf ju hi lb b fi lg lh l li lj">array_6 = np.zeros((2,3),’int’)<br/>array_7 = np.ones((2,3),'int')</span></pre><p id="867d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还有一个创建单位矩阵的函数(矩阵对角线上只有1，其他位置只有0)。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ea44" class="lf ju hi lb b fi lg lh l li lj">identity = np.identity(3)<br/>identity</span></pre><blockquote class="ll lm ln"><p id="4e4f" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[1。, 0., 0.]，<br/>【0。, 1., 0.]，<br/>【0。, 0., 1.]])</p></blockquote><p id="54b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用numpy的“random.randn()”(用于获取浮点数)或“random.randint()”(用于获取整数)函数用随机生成的数据创建数组。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c9f5" class="lf ju hi lb b fi lg lh l li lj"># Float data type, 2x3 dimension<br/>array_8 = np.random.randn(2,3)</span><span id="9fa0" class="lf ju hi lb b fi ls lh l li lj"># Int data type, 3x3<br/>array_9 = np.random.randint(low = 1, high = 10, size = (3,3)) </span></pre><p id="82b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，数组的数据类型不仅限于浮点数或整数。它们可以是复数、布尔对象、字符串和其他python对象。如果数据类型是可转换的，我们可以很容易地转换它们。请参见下面的示例。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f279" class="lf ju hi lb b fi lg lh l li lj"># Creating an array with strings as data type<br/>string_array = np.array(['1','2','2.5','3.5'])</span><span id="4a9a" class="lf ju hi lb b fi ls lh l li lj"># Now converting its data type to float numbers <br/>numeric_array = string_array.astype('float')</span></pre><h1 id="2517" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">属性</h1><p id="c172" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在我们知道了如何创建NP数组，让我们看看如何找到数组的不同属性。“形状”是维度的大小，即行数和列数。Dimension是数组的轴数。“大小”表示数组包含的元素数量。要获得数组的形状，我们可以使用“shape”属性。为了找到尺寸，我们可以使用“ndim”。为了找到数据类型，我们使用“dtype”属性。为了找到数组中元素的总数，即它的大小，我们使用“size”属性。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="40c1" class="lf ju hi lb b fi lg lh l li lj">print(array_2.shape)<br/>print(array_2.ndim)<br/>print(array_2.dtype)<br/>print(array_2.size)</span></pre><blockquote class="ll lm ln"><p id="9321" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/> (4，3) <br/> 2 <br/> int32 <br/> 12</p></blockquote><p id="c83b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以重塑数组。为此，您可以使用内置的调整大小功能。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2107" class="lf ju hi lb b fi lg lh l li lj">array_2.resize(2,6)<br/>array_2.shape</span></pre><blockquote class="ll lm ln"><p id="d839" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/> (2，6)</p></blockquote><h1 id="ebdf" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">索引和切片</h1><h2 id="fd05" class="lf ju hi bd jv lt lu lv jz lw lx ly kd jg lz ma kh jk mb mc kl jo md me kp mf bi translated">1D阵列</h2><p id="9875" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">一维数组的索引和切片很简单。这就像在python列表中索引元素一样。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8ef9" class="lf ju hi lb b fi lg lh l li lj"># Creating a new array first for demonstration<br/>base_array = np.arange(10)<br/>base_array</span></pre><blockquote class="ll lm ln"><p id="6769" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([0，1，2，3，4，5，6，7，8，9])</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2d8d" class="lf ju hi lb b fi lg lh l li lj">base_array[5] <br/># Indexing in python starts at 0, so index 5 is the 6th element</span></pre><blockquote class="ll lm ln"><p id="4f65" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/> 5</p></blockquote><p id="77f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果需要选择数组的一部分，可以像python列表一样使用切片。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3d97" class="lf ju hi lb b fi lg lh l li lj">sliced_array = base_array[2:6] # The upper bound is excluded<br/>sliced_array</span></pre><blockquote class="ll lm ln"><p id="bb74" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([2，3，4，5])</p></blockquote><p id="db6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个切片数组只是一个视图，不是新的副本。所以如果你改变了什么，它会反映在主数组上。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a404" class="lf ju hi lb b fi lg lh l li lj">sliced_array[0] = 20<br/>sliced_array[1] = 30<br/>sliced_array</span></pre><blockquote class="ll lm ln"><p id="5449" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([20，30，4，5])</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="00ae" class="lf ju hi lb b fi lg lh l li lj">base_array</span></pre><blockquote class="ll lm ln"><p id="e64f" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([ 0，1，20，30，4，5，6，7，8，9])</p></blockquote><p id="290d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要创建一个副本，以便切片数组中的更改不会更改主数组，请使用<em class="lo"> copy() </em>函数。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d66e" class="lf ju hi lb b fi lg lh l li lj">base_array = np.arange(5)<br/>copied_array = base_array.copy()</span></pre><h2 id="29a7" class="lf ju hi bd jv lt lu lv jz lw lx ly kd jg lz ma kh jk mb mc kl jo md me kp mf bi translated">多维数组</h2><p id="134f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">多维数组的索引有选项。你可以通过递归调用得到一个单独的元素，就像你在列表列表中所做的那样，或者你可以只传递一个逗号分隔的索引列表。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="edb7" class="lf ju hi lb b fi lg lh l li lj"># Creating a 2D array first<br/>base_array = np.array([[1,2,3],[4,5,6],[7,8,9]])<br/>base_array</span></pre><blockquote class="ll lm ln"><p id="9a65" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[1，2，3]，<br/>，【4，5，6】，<br/>，【7，8，9]])</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f5e1" class="lf ju hi lb b fi lg lh l li lj"># Getting the first row<br/>base_array[0]</span></pre><blockquote class="ll lm ln"><p id="0aea" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([1，2，3])</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1e7a" class="lf ju hi lb b fi lg lh l li lj"># Getting the element of the first column of the first row<br/>base_array[0][0]</span></pre><blockquote class="ll lm ln"><p id="71f9" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/> 1</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3959" class="lf ju hi lb b fi lg lh l li lj"># or we can pass the indices separated by comma<br/>base_array[0,0]</span></pre><blockquote class="ll lm ln"><p id="3eae" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/> 1</p></blockquote><p id="b83c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能已经猜到了如何分割多维数组。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5717" class="lf ju hi lb b fi lg lh l li lj">base_array[:2] # selecting every row upto the 2nd row</span></pre><blockquote class="ll lm ln"><p id="bce9" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[1，2，3]，<br/> [4，5，6]])</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ee57" class="lf ju hi lb b fi lg lh l li lj">base_array[1:] #selecting every row after the first one</span></pre><blockquote class="ll lm ln"><p id="a6c2" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[4，5，6]，<br/>，[7，8，9]])</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3382" class="lf ju hi lb b fi lg lh l li lj">base_array[:,:2]<br/>#selecting every column upto the 2nd one, had to put an empty ':' to indicate 'take all rows'</span></pre><blockquote class="ll lm ln"><p id="0dac" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[1，2]，<br/>，【4，5】，<br/>，【7，8]])</p></blockquote><p id="5b6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你会在我的github repo中提供的jupyter笔记本中找到更多的例子。</p><h2 id="8990" class="lf ju hi bd jv lt lu lv jz lw lx ly kd jg lz ma kh jk mb mc kl jo md me kp mf bi translated">布尔索引</h2><p id="fe63" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">还有另一种非常有趣的索引类型，叫做布尔索引。我们可以传递一个布尔值数组作为索引，它将只给出布尔值为' True '的行。让我们看看下面的例子。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d9a4" class="lf ju hi lb b fi lg lh l li lj"># Creating a boolean array first<br/>boolean_array = np.array([True, False, True])</span><span id="ce06" class="lf ju hi lb b fi ls lh l li lj"># Using boolean indexing<br/>base_array[boolean_array]</span></pre><blockquote class="ll lm ln"><p id="0a33" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[1，2，3]，<br/>，[7，8，9]])</p></blockquote><p id="d5fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">布尔索引非常有用，可以用非常有创造性的方式使用。让我们看一个简单的例子。</p><p id="2387" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们有四种不同的东西要混合(糖、盐、香料、水或其他)。我们尝试了10种不同的组合。有些被证明是好的组合，有些被证明是坏的组合。我们将组合存储在一个数组中。每一列代表成分，每一行是不同的混合。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="fb8c" class="lf ju hi lb b fi lg lh l li lj">combinations = np.random.randint(low = 1, high = 10, size = (10,4)) # Randomly creating an array for demonstration</span><span id="4f3f" class="lf ju hi lb b fi ls lh l li lj">combinations<br/>#output will change every time the code is run, as they are random data</span></pre><blockquote class="ll lm ln"><p id="530a" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[6，6，8，3]，<br/>，【9，8，2，7】，<br/>，【3，5，4，2】，<br/>，<br/>，【9，2，6，4】，<br/>，【7，7，7，8】，<br/>，【7，9，3，7】，<br/>，【4，7，5，6】，<br/>，【8，6</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e1f4" class="lf ju hi lb b fi lg lh l li lj">results = np.array(['g','g','vg','g','b','b','b','vg','b','b']) <br/># Randomly created the result, assume g = good, vg = very good, b = bad</span></pre><p id="0510" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们希望找到非常好或仅仅好(在结果中用‘g’表示)的组合，或者除了坏组合之外的任何组合。下面是我们如何使用布尔索引来做到这一点。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2edc" class="lf ju hi lb b fi lg lh l li lj">very_good = results == 'vg'<br/>combinations[very_good]</span></pre><blockquote class="ll lm ln"><p id="adda" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[3，5，4，2]，<br/> [4，7，5，6]])</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f9ce" class="lf ju hi lb b fi lg lh l li lj">condition = results=='b'<br/>combinations[~condition] <br/># using ~ before a condination will yield every other results except the given condition</span></pre><blockquote class="ll lm ln"><p id="2e79" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[6，6，8，3]，<br/>，【9，8，2，7】，<br/>，【3，5，4，2】，<br/>，【6，7，6，2】，<br/>，【4，7，5，6】))</p></blockquote><p id="f7ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在布尔索引中，我们必须确保布尔索引的长度与其索引轴的长度相匹配。</p><h1 id="4248" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">操作</h1><h2 id="858a" class="lf ju hi bd jv lt lu lv jz lw lx ly kd jg lz ma kh jk mb mc kl jo md me kp mf bi translated">简单的算术运算</h2><p id="84f9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">两个数组的简单加法或减法将执行逐元素的加法或减法。您也可以用标准方式将每个元素乘以或除以一个标量值。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="66b5" class="lf ju hi lb b fi lg lh l li lj">print(base_array)</span></pre><blockquote class="ll lm ln"><p id="8021" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>[[1 2 3]<br/>【4 5 6】<br/>【7 8 9】]</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3d67" class="lf ju hi lb b fi lg lh l li lj">base_array + base_array</span></pre><blockquote class="ll lm ln"><p id="b68d" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[ 2，4，6]，<br/>，【8，10，12】，<br/>，【14，16，18])</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="85cf" class="lf ju hi lb b fi lg lh l li lj">base_array * 10</span></pre><blockquote class="ll lm ln"><p id="b213" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[10，20，30]，<br/>，【40，50，60】，<br/>，【70，80，90]])</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8fc3" class="lf ju hi lb b fi lg lh l li lj">base_array + 10</span></pre><blockquote class="ll lm ln"><p id="0db8" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[11，12，13]，<br/>，【14，15，16】，<br/>，【17，18，19]])</p></blockquote><h2 id="dedb" class="lf ju hi bd jv lt lu lv jz lw lx ly kd jg lz ma kh jk mb mc kl jo md me kp mf bi translated">数组乘法</h2><p id="4bd4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">数组相乘有两种方法。一个是两个数组之间简单的元素乘法。简单地将两个数组加上乘法符号，就像在普通乘法运算中一样，就可以实现这一点。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7b18" class="lf ju hi lb b fi lg lh l li lj">base_array * base_array</span></pre><blockquote class="ll lm ln"><p id="a83a" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[ 1，4，9]，<br/>，【16，25，36】，<br/>，【49，64，81]])</p></blockquote><p id="704d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果要进行矩阵乘法，可以使用numpy的“<em class="lo">dot()”</em>函数。(对于不熟悉矩阵乘法的人来说，有点复杂。查看此<a class="ae iu" href="https://www.mathsisfun.com/algebra/matrix-multiplying.html" rel="noopener ugc nofollow" target="_blank">链接</a>了解矩阵乘法在数学上是如何完成的。)</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ef26" class="lf ju hi lb b fi lg lh l li lj">base_array.dot(base_array)<br/># np.dot(array, array), alternate syntax</span></pre><blockquote class="ll lm ln"><p id="6f87" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[ 30，36，42]，<br/>，【66，81，96】，<br/>，【102，126，150]])</p></blockquote><h2 id="d14e" class="lf ju hi bd jv lt lu lv jz lw lx ly kd jg lz ma kh jk mb mc kl jo md me kp mf bi translated">公制转置</h2><p id="354b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们可以通过使用<em class="lo">”来转置一个数组(交换它的行和列)。</em>师后阵。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ead7" class="lf ju hi lb b fi lg lh l li lj">base_array.T</span></pre><blockquote class="ll lm ln"><p id="7872" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[1，4，7]，<br/>，【2，5，8】，<br/>，【3，6，9]])</p></blockquote><p id="0d27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于更复杂的多维数组，我们可以使用“transpose()”函数，并按照我们想要的顺序传递轴元组作为参数。例如，array.transpose((1，2，0))将使第二个轴优先，第三个轴其次，第一个轴最后。(记住python索引，第一个轴的索引是0，第二个是1，第三个是2。)</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="920a" class="lf ju hi lb b fi lg lh l li lj">array = np.arange(16).reshape((2, 2, 4))<br/>array</span></pre><blockquote class="ll lm ln"><p id="ad2a" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[[ 0，1，2，3]，<br/> [ 4，5，6，7]]，</p><p id="dd0e" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">[[ 8，9，10，11]，T29，[12，13，14，15]])</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f336" class="lf ju hi lb b fi lg lh l li lj">array.transpose((1, 2, 0))</span></pre><blockquote class="ll lm ln"><p id="ae00" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[[ 0，8]，<br/>，【1，9】，<br/>，【2，10】，<br/>，【3，11])，</p><p id="705a" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">[[ 4，12]，<br/>，【5，13】，<br/>，【6，14】，<br/>，【7，15]]])</p></blockquote><h1 id="bbbd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">应用函数</h1><p id="3cc3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">有一些通用函数可以帮助我们执行快速的元素操作。例如，np.sqrt()对数组的每个元素执行平方根运算，np.exp()函数返回一个数组，其中包含每个元素的指数值。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d4dd" class="lf ju hi lb b fi lg lh l li lj">np.sqrt(base_array)</span></pre><blockquote class="ll lm ln"><p id="6bda" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[1。，1.41421356，1.73205081]，<br/>【2。，2.23606798，2.44948974]，<br/>【2.64575131，2.82842712，3。]])</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f141" class="lf ju hi lb b fi lg lh l li lj">np.exp(base_array)</span></pre><blockquote class="ll lm ln"><p id="3612" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/>数组([[2.71828183e+00，7.38905610e+00，2.00855369e+01]，<br/>，【5.45981500e+01，1.48413159e+02，4.03428793e+02]，<br/>，【1.0966316 e+03，2.988</p></blockquote><p id="4859" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在numpy中有很多这样的函数，帮助执行不同的数学计算，如求对数、平方、正弦、余弦、正切等。以一种快速的方式。在我的笔记本中，我提到了一些你可能经常会发现有用的功能。</p><p id="42b0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一些数学函数可以计算数组的统计值。例如，np.mean()返回给定数组的平均值，max()给出最大值，std()给出数据的标准差。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4c87" class="lf ju hi lb b fi lg lh l li lj">array.mean()<br/># np.mean(array), alternate syntax</span></pre><blockquote class="ll lm ln"><p id="6e69" class="iv iw lo ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">输出:<br/> 5.0</p></blockquote><h1 id="0456" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="ce12" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我希望这篇文章能让你对numpy有一个基本的了解，并为你开始做好准备。我建议你从我在这本笔记本中提供的基础知识开始使用numpy。在初始阶段，当你需要做一些事情的时候，你可能总是首先想到在你的数组中应用一个for循环，至少我是这么做的。但是请记住，如果你这样做，你就失去了使用矢量化运算的优势。但是不用担心。如果你坚持练习，你会养成使用矢量化运算的习惯。当你遇到一个问题，或者你需要执行一个没有在这个笔记本上列出的操作时，只需简单地进行谷歌搜索或者在stackoverflow中搜索。numpy有一个很好的机会来执行你的操作，而不需要for循环，你知道，这将是一个更好的性能选择。</p></div></div>    
</body>
</html>