<html>
<head>
<title>77x faster than RustPython</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比RustPython快77倍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/77x-faster-than-rustpython-f8331c46aea1?source=collection_archive---------7-----------------------#2020-01-23">https://medium.com/analytics-vidhya/77x-faster-than-rustpython-f8331c46aea1?source=collection_archive---------7-----------------------#2020-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b37e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在搜索Richards基准测试的纯Rust版本时，我只能找到，“早在2010年4月，Russ Cox就慷慨地提出，只有<em class="jd">fann kuch-redux、fasta、k-nucleotide、mandlebrot、nbody、reverse-complement和spectral-norm接近于<em class="jd">fair</em>comparisons<a class="ae je" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust.html" rel="noopener ugc nofollow" target="_blank">【1】</a>。请注意，Richards基准测试没有出现在这个列表中，Rust开发人员害怕什么？</em></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/70ca7d2b222485ccc69122cfda534c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjneGnPj93BwG2I_3boHsw.png"/></div></div></figure><p id="0266" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RustPython，或者Rust，或者两者都有根本的问题吗？Google最初使用Richards基准优化了V8 JIT，因为这是一个很好的测试多态性和类如何被经常使用的测试。在Python版本中，基类<code class="du jr js jt ju b">Task</code>包含由<code class="du jr js jt ju b">runTask</code>方法调用的抽象方法<code class="du jr js jt ju b">fn</code>，子类必须重载<code class="du jr js jt ju b">fn</code>方法。由于这种抽象，解释器将不得不更加努力地分派方法调用，并且在试图生成有效的字节码时不能提前假定太多。让我们来看看内存使用情况。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/9b16f053e1891f33ca51055c2f7a84b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZP7VH6t5_4n9Yq1hoOKRw.png"/></div></div></figure><p id="e2fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">内存使用是我们所期望的，NodeJS和PyPy，重型JIT，消耗更多的内存。RustPython的缓慢并不是因为内存不足的瓶颈，它应该能够高效地使用CPU缓存。快速看一下RustPython的源代码，我可以看到部分问题是<a class="ae je" href="https://github.com/RustPython/RustPython/blob/master/vm/src/pyobject.rs" rel="noopener ugc nofollow" target="_blank">太多的抽象层</a>，大部分代码涉及<a class="ae je" href="https://github.com/RustPython/RustPython/blob/master/vm/src/vm.rs" rel="noopener ugc nofollow" target="_blank">繁重的面向对象设计</a>，而不是优化。它们在大多数函数之间传递的主要对象类型是“PyObjectRef ”,它只是一个引用计数容器。这与TPython中的主要类型非常不同，TPython中的主要类型是<code class="du jr js jt ju b">tp_obj</code>一个经典的<a class="ae je" href="https://en.wikipedia.org/wiki/Union_type" rel="noopener ugc nofollow" target="_blank">联合</a>，它是16个字节，总是使用堆栈内存传递，并保存6位类型数据和2位魔术数据。有了这种高效的<a class="ae je" href="https://stackoverflow.com/questions/14481469/where-to-use-union-class-and-struct/14482478" rel="noopener ugc nofollow" target="_blank">联合</a>，TPython通常可以避免堆分配，可以使用堆栈内存来代替；这也允许垃圾收集器避免小的字符串、数字和其他适合16个字节的类型。</p><h1 id="5169" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">比Python快2倍</h1><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/f016c9077eb32af4af864d6d298767de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0XjKb6OiGNo99--TtxjKA.png"/></div></div></figure><p id="67e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有几个原因可以解释为什么<a class="ae je" href="https://gitlab.com/hartsantler/tpythonpp" rel="noopener ugc nofollow" target="_blank"> TPython </a>比Python3快2倍。一个主要因素是TPython是Python语言的一个子集，不是动态的。Phil Hassey最初的TinyPy解释器非常动态，但是我更喜欢严格的规则和更简单的语言，所以我去掉了大部分动态特性。这允许生成更优化的字节码，因为字节码编译器可以在编译时做出更多假设。更专门化的字节码直接加速了VM，它基本上只是一个巨大的<code class="du jr js jt ju b">switch/case </code>块集合，将尽可能多的逻辑内联到主解释器循环中。Clang with <a class="ae je" href="https://en.wikipedia.org/wiki/Profile-guided_optimization" rel="noopener ugc nofollow" target="_blank"> PGO </a>特别擅长于优化switch/case语句，当它看到你的脚本如何执行时，实际上——部分提前编译你的脚本。</p></div></div>    
</body>
</html>