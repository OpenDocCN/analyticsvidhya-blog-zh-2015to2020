<html>
<head>
<title>Eh-F Tests: Run ANOVA Easier with *args</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Eh-F测试:使用*args更容易运行ANOVA</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/eh-f-tests-run-anova-easier-with-args-e4a55f3be21d?source=collection_archive---------10-----------------------#2019-10-15">https://medium.com/analytics-vidhya/eh-f-tests-run-anova-easier-with-args-e4a55f3be21d?source=collection_archive---------10-----------------------#2019-10-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/8373acdd4b76eb8dff01c6dc96ed89fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*liqWAxzk0gp-0aVU2Ptn1g.gif"/></div></figure><p id="9585" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您必须运行ANOVA测试来比较多个组的平均值，您可能会想知道是否有一种方法可以做到这一点，而无需手动输入每个组的数据。我将通过一个简单的例子向您展示这样做的方法。</p><p id="520b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们凭空创建一个数据框架:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="fa95" class="jt ju hi jp b fi jv jw l jx jy">import pandas as pd<br/>import numpy as np</span><span id="a1d6" class="jt ju hi jp b fi jz jw l jx jy">data = pd.DataFrame(data=[['A', 'B', 'C', 'D']*3]).T<br/>data.columns=['Group']<br/>data['Value'] = np.random.randint(1,10,size=len(data))</span></pre><figure class="jk jl jm jn fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/84154055bd1c86679ee72855b1e989c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*7UdyOdZlTZn6qXobq8n_dQ.png"/></div></figure><p id="231e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如你所见，我们有4组。如果您在<em class="kb">值</em>列中有不同的数字，请不要担心。稍后重要的是，你从我比较的两种方法中得到相同的测试结果。我们想测试每个<em class="kb">组</em>的<em class="kb">值</em>的平均值是否相同，或者是否至少有一个组的平均值在统计上有显著差异。很自然，我们会进行f检验，并可能会编写Python代码，如下所示:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="db6b" class="jt ju hi jp b fi jv jw l jx jy">import scipy.stats as stats<br/>stats.f_oneway(<br/>                data.loc[data['Group']=="A", 'Value']<br/>                , data.loc[data['Group']=="B", 'Value']<br/>                , data.loc[data['Group']=="C", 'Value']<br/>                , data.loc[data['Group']=="D", 'Value']              <br/>            )<br/>F_onewayResult(statistic=0.27946127946127947, pvalue=0.8388488338536153)</span></pre><p id="a883" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，这段代码看起来并没有那么难写。但是想象一下，如果你的数据中有更多的组(我曾经为NBA的所有30支球队做过f检验)。你必须为每组写一行(就像我上面对4组所做的那样)。如果有一种方法可以写出更容易适应更多群体的测试，那会怎么样？</p><p id="b192" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">回答</strong>:可以使用*args，让生活更轻松。你可能在函数描述中看到过*args或者**kwargs。两者的目的相同:传入可变数量的<strong class="io hj"> arg </strong>文件或<strong class="io hj">k</strong>ey<strong class="io hj">w</strong>ord<strong class="io hj">arg</strong>文件。让我们通过简单的例子快速地看看它们的用法。我不会在我们的F-test应用程序中使用**kwargs，但是，由于它们都提供相似的功能，我想为什么不包含一个例子呢。</p><p id="23eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们创建一个函数，在这个函数中，我们用*args制作一道菜:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="329b" class="jt ju hi jp b fi jv jw l jx jy">def make_a_dish(dish_name, ingredient_1, *ingredients):  <br/>    print(f"I will make {dish_name}")<br/>    print(f"Start with {ingredient_1}")<br/>    for ingredient in ingredients:<br/>        print(f"Add {ingredient}")</span><span id="79ef" class="jt ju hi jp b fi jz jw l jx jy">make_a_dish("ice cream", "ice", "cream", "sprinkles", "whipped cream", "cherry")</span><span id="d00c" class="jt ju hi jp b fi jz jw l jx jy">I will make ice cream<br/>Start with ice<br/>Add cream<br/>Add sprinkles<br/>Add whipped cream<br/>Add cherry</span></pre><p id="e028" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该函数将<em class="kb"> dish_name </em>和<em class="kb"> ingredient_1 </em>作为必需参数，以及您想要使用的任何附加可选配料(<em class="kb">*配料</em>，您甚至可以输入0个附加配料)。这些额外的成分被解释为一个元组，通过它我们可以遍历每个元素。然后，您可以再次使用该功能来制作不同的菜肴，并指定不同数量的配料。使用*args的好处在于，您不必重新创建函数来处理不同数量的参数，因此您可以不使用原始函数。</p><p id="79df" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们快速查看一下**kwargs在一个函数中的使用情况，我可以用它来创建一个约会档案:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="80be" class="jt ju hi jp b fi jv jw l jx jy">def introduce_yourself(name, **facts):  <br/>    print(f"My name is {name}")<br/>    for key, value in facts.items(): <br/>        print(f"My {key} is {value}")</span><span id="6b55" class="jt ju hi jp b fi jz jw l jx jy">introduce_yourself(name="Aneesh", sign="Aquarius", age=27, height="6 ft")</span><span id="8ea2" class="jt ju hi jp b fi jz jw l jx jy">My name is Aneesh<br/>My sign is Aquarius<br/>My age is 27<br/>My height is 6 ft</span></pre><p id="b2e6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如我所说，**kwargs的行为类似于*args，除了您指定变量和它们相应的值。我输入一个<em class="kb"> name </em>参数，后跟我想要的任意数量的变量值对。这些对将被解释为字典的键值对，因此我使用<em class="kb">遍历它们。物品()</em>。我可以指定尽可能多或尽可能少(甚至0)的变量值对。</p><p id="d585" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，回到我们的f检验。我们可以使用*args的概念在一行中按需创建我们的值组。见下文:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b36a" class="jt ju hi jp b fi jv jw l jx jy">import scipy.stats as stats<br/>stats.f_oneway(<br/> *(data.loc[data[‘Group’]==group, ‘Value’] <br/> for group in data[‘Group’].unique())<br/> )</span><span id="bb73" class="jt ju hi jp b fi jz jw l jx jy">F_onewayResult(statistic=0.27946127946127947, pvalue=0.8388488338536153)</span></pre><p id="f6c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可以这么想:<em class="kb"> stats.f_oneway(*args) </em>等价于<em class="kb"> stats.f_oneway(arg1，arg2，…，argN) </em>。在这种情况下，每个参数都是对应于每个组的数据的子集。</p><p id="f39d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="kb"> Stats.f_oneway() </em>和其他任何函数一样；它需要一定数量的参数，其中每个参数是对应于每个组的数据的子集。F-test函数中的代码返回一个元组(类似于上面的arg示例)，其中元组中的每个元素都是每个组的一组<em class="kb">值</em>值。因此，不管你有4个、30个还是100个组，代码都可以处理任意数量的组，并将每个组作为一个“参数”传递给F-test函数。</p></div></div>    
</body>
</html>