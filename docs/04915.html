<html>
<head>
<title>Extracting information from Catalog files in Salesforce Commerce Cloud using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python从Salesforce Commerce Cloud中的目录文件提取信息</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/extracting-information-from-catalog-files-in-salesforce-commerce-cloud-using-python-dd7537d29205?source=collection_archive---------16-----------------------#2020-04-05">https://medium.com/analytics-vidhya/extracting-information-from-catalog-files-in-salesforce-commerce-cloud-using-python-dd7537d29205?source=collection_archive---------16-----------------------#2020-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e8ddc1ec0e4e8882a4300acf543d23e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9NTDAdacRGcKk10PJ908g.png"/></div></div></figure><p id="d944" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你使用过Salesforce Commerce Cloud (SFCC)，你就会知道通过文件管理目录的痛苦。当然，系统的设计是为了减少人工干预，您可能在目录上看到的任何信息都应该可以在您的产品信息管理系统中找到。然而，有时你会冒险尝试直接使用SFCC目录(主目录和导航目录),可能是为了使用你的报告工具，也可能只是为了加深对目录的理解。</p><p id="0f78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:我写这个是为了快速知道哪些产品有图片，哪些没有。在SFCC没有直接的方法知道。这需要3-4分钟，具体取决于目录的大小。此外，我与您分享的脚本可以用于任何XML文件。玩得开心！</p><h1 id="06bc" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">XML文件</h1><p id="ca6b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">XML文件格式是这样的:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/ce64d542e1cc54140c08a94123530af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JuoH2wVgRxE_LZ9nCssCng.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">SFCC目录格式</figcaption></figure><p id="769c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它还以类别定义和分配结束:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/ab6639b69f9d9a5a112f6d52c1a9e633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ImuHTXxQ3ZJIbHsPgeWyw.png"/></div></div></figure><p id="46ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以编写复杂的代码来删除它，但只需在Sublime Text中打开文件(它可以在4-5秒内轻松通过200 mb的文件)。修剪文件以删除文件末尾的类别分配和顶部条目，如下所示:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/4de18c3eba129f0fcca61e9228a5a3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jo4uF_aiSWa9Zcdy_BKgLg.png"/></div></div></figure><h1 id="1bf6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">代码</h1><p id="48e8" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">非常简单，下面是提取产品id和相关图像名称/位置作为CSV的代码。</p><pre class="kt ku kv kw fd lc ld le lf aw lg bi"><span id="8b40" class="lh jq hi ld b fi li lj l lk ll">import xml.etree.ElementTree as ET</span><span id="bcf2" class="lh jq hi ld b fi lm lj l lk ll">tree = ET.parse('file.xml')<br/>root = tree.getroot()</span><span id="37f4" class="lh jq hi ld b fi lm lj l lk ll">#print root.attrib ### establish where the root is...</span><span id="4469" class="lh jq hi ld b fi lm lj l lk ll">catalog = ""  ## needed for printing out the string<br/></span><span id="7c11" class="lh jq hi ld b fi lm lj l lk ll">for child in root:  ## can be replaced with root.iter("node")<br/>                    ## where node is the XML node you want to <br/>                    ## iterate through</span><span id="7a01" class="lh jq hi ld b fi lm lj l lk ll">catalog += child.attrib["product-id"]<br/></span><span id="cbfd" class="lh jq hi ld b fi lm lj l lk ll"> try: ### if some nodes do not have the thing you're looking for<br/>  for node in child.iter("image"):<br/>   catalog += "," + node.attrib["path"]<br/>  catalog += "\n"<br/></span><span id="6d46" class="lh jq hi ld b fi lm lj l lk ll"> except:<br/>  catalog += "\n"</span><span id="efef" class="lh jq hi ld b fi lm lj l lk ll">print catalog</span></pre><p id="f987" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将该文件另存为<em class="jo"> parse.py </em></p><p id="012b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">打开终端并键入:</p><pre class="kt ku kv kw fd lc ld le lf aw lg bi"><span id="c9de" class="lh jq hi ld b fi li lj l lk ll">python parse.py | tee file.csv </span><span id="d81c" class="lh jq hi ld b fi lm lj l lk ll">(where file.csv is the output file)</span></pre><p id="c6b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望您已经安装了Python。如果没有，在这里下载<a class="ae ln" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="afea" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解释</h1><p id="fef5" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><em class="jo">注意:我绝不是Python编码专家。我只知道在工作中利用它。有100种不同的方法可以做得更好。</em></p><pre class="kt ku kv kw fd lc ld le lf aw lg bi"><span id="e80a" class="lh jq hi ld b fi li lj l lk ll">import xml.etree.ElementTree as ET</span><span id="c594" class="lh jq hi ld b fi lm lj l lk ll">tree = ET.parse('file.xml')<br/>root = tree.getroot()</span></pre><p id="c309" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单解释:获取文件，设置根目录。因为这个文件包含一个根(“Catalog”)，所以我们可以从现在开始处理这个文件。</p><pre class="kt ku kv kw fd lc ld le lf aw lg bi"><span id="10e0" class="lh jq hi ld b fi li lj l lk ll">#print root.attrib ### establish where the root is...</span><span id="eaec" class="lh jq hi ld b fi lm lj l lk ll">catalog = ""  ## needed for printing out the string<br/></span></pre><p id="dc0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">#为我们提供Python中的注释。您可以要求打印根属性，它应该返回一个对象:<br/> {catalog-id: &lt;您的目录的名称&gt;</p><p id="3cb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于我们正在提取一个CSV文件，我们将创建一个字符串变量<em class="jo"> catalog </em>来捕获值<em class="jo">。</em></p><pre class="kt ku kv kw fd lc ld le lf aw lg bi"><span id="a68e" class="lh jq hi ld b fi li lj l lk ll">for child in root:  ## can be replaced with root.iter("node")<br/>                    ## where node is the XML node you want to <br/>                    ## iterate through</span><span id="f934" class="lh jq hi ld b fi lm lj l lk ll">catalog += child.attrib["product-id"]<br/></span></pre><p id="5709" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们沿着根子节点迭代——它们是产品节点。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/bfff6e78a3b31a5b12ed952e0a06857f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ix_CPVoFORY4P_yD_-5YCQ.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">XML文件的各个部分</figcaption></figure><p id="e3a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还用<em class="jo">child . attrib[" product-id "]</em>设置了CSV变量的第一列——在上面的示例中，它将返回20126936。</p><pre class="kt ku kv kw fd lc ld le lf aw lg bi"><span id="69be" class="lh jq hi ld b fi li lj l lk ll">try: ### if some nodes do not have the thing you're looking for<br/>  for node in child.iter("image"):<br/>   catalog += "," + node.attrib["path"]<br/>  catalog += "\n"<br/></span><span id="9fb1" class="lh jq hi ld b fi lm lj l lk ll">except:<br/>  catalog += "\n"<br/></span></pre><p id="239c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">引入Try-Except块是为了避免节点不存在的错误。请记住，我们正在尝试寻找没有图片的产品。try节点将评估它正在评估的块中是否有错误。如果出错，它将执行Except块。</p><p id="d47b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个块中，我们使用iter方法进行迭代，该方法接受一个节点。请注意，我们可以在XML树中迭代到我们想要的深度——但是，最好尽可能靠近非扩展分支，以获得性能增益(我们不是在图像节点的整个根节点上迭代，而是在产品节点内迭代，它通常有3-7个图像节点。</p><p id="b696" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果需要更深入(获取图像组，然后进一步迭代)，可以对循环执行嵌套的<em class="jo">。</em></p><p id="638f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅此而已。为了结束它，我们在最后打印变量:</p><pre class="kt ku kv kw fd lc ld le lf aw lg bi"><span id="a797" class="lh jq hi ld b fi li lj l lk ll">print catalog</span></pre><p id="dcf3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，在终端中，我们用命令<em class="jo"> tee </em>做了几件事——我们将输出推送到<em class="jo"> stdout </em>(你在终端中看到的)，并将输出通过管道传输到你指定的文件<em class="jo">。</em></p><h1 id="7f4b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><em class="lp">主要考虑事项</em></h1><p id="0798" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Python是管理SFCC复杂性的最简单的方法。在过去的3年里，我一直这样做(我用node.js/C/bash文件生成器将CSV文件转换成SFCC XML文件，用于定价/库存/目录)，我发现Python为管理复杂性提供了无与伦比的简单性。但是，有以下注意事项:</p><ol class=""><li id="7f47" class="lq lr hi is b it iu ix iy jb ls jf lt jj lu jn lv lw lx ly bi translated">Python是一种强类型语言(阅读更多关于<a class="ae ln" href="https://android.jlelse.eu/magic-lies-here-statically-typed-vs-dynamically-typed-languages-d151c7f95e2b" rel="noopener ugc nofollow" target="_blank">比较</a>)。对于一个门外汉来说——如果你很容易漏掉一个缩进或者一个冒号，保持你的代码简短。很容易在30行代码中发现缺失的缩进，然后在200行代码中发现。</li><li id="30d9" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated">有些语法和概念有点疯狂，尤其是来自其他松散的语言，如JS。但是，如果你能掌握它们，你就会成为一名巫师，哈利。</li></ol><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es me"><img src="../Images/75909b6ddafa87e2d89e0da39e32a13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*0SLsytQx1IBA1QfT.gif"/></div><figcaption class="kx ky et er es kz la bd b be z dx translated">你在掌握了基本的Python之后。Python是无法真正掌握的。</figcaption></figure><p id="74d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.第一次运行时，您的代码会运行得很顺畅。这是Python唯一的让步。之后发生的事情取决于你的运气和血统。Python不会原谅也不会忘记。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="9836" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我相信具备基本的Python/脚本语言技能是产品经理必备的。这让生活变得更加轻松，并且可以带来有趣的数据发现。此外，这让您对开发人员的工作量有了一个有趣的了解。如果你没有花两个小时在Node.js的30行代码中纠结Async-Await/Callback promise hell，你永远不会知道一个程序员的挣扎。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="9f5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的阅读。如果您想阅读有关Salesforce相关文章和快捷方式的更多信息，请发表评论！我很乐意写更多关于Salesforce和相关技术的文章！</p></div></div>    
</body>
</html>