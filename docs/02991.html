<html>
<head>
<title>Custom keras generator fetching images from S3 to train Neural Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义keras生成器从S3获取图像以训练神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/custom-keras-generator-fetching-images-from-s3-to-train-neural-network-4e98694de8ee?source=collection_archive---------6-----------------------#2020-01-11">https://medium.com/analytics-vidhya/custom-keras-generator-fetching-images-from-s3-to-train-neural-network-4e98694de8ee?source=collection_archive---------6-----------------------#2020-01-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d9a4fc564992aeabd994ccdedba66221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vs-4Q7aObUOdk4B-"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">赫克托·j·里瓦斯在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="57bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">AWS中的训练模型可以通过许多不同的方式完成，使用任意数量的服务。今天，我想重点谈谈机器学习管道的一部分，你可以在你的模型上训练或预测。</p><p id="4374" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我一直在开发一个概念验证模型，一旦我对最初的结果感到满意，下一步就是在云中扩展它，做一个更大规模的模型。我用keras框架中的模型进行了迁移学习，并训练了一个基于图像的模型。一个关键的keras函数是predict_generator，它接受一个生成器作为输入。</p><p id="1e65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">长话短说，我一直使用flow_from_directory来读取图像，我认为它可能有可能改为在S3现场读取图像。一种方法是编写一个定制的keras生成器来读取图像并进行预处理。</p><p id="aa21" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在浪费您的时间之前，我应该正确地指出，从S3读取的延迟很高，即使对于小文件，每个文件的延迟也高达0.5秒，这被证明是一个大规模的瓶颈，可能会使解决方案变得毫无用处。在某些情况下，您可能能够忍受这种延迟。或者，压缩/捆绑文件也是一种解决方案。</p><p id="de13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是生成器的一些片段。让我们从第一个函数开始，它实际上是从S3获取数据。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f79f" class="kc kd hi jy b fi ke kf l kg kh">from keras.preprocessing.image import load_img<br/>import io</span><span id="99b0" class="kc kd hi jy b fi ki kf l kg kh">def fectch_input(path,s3):</span><span id="fce4" class="kc kd hi jy b fi ki kf l kg kh">     object = s3.Object(bucket_name,path)<br/>     img = load_img(io.BytesIO(object.get()['Body'].read()))<br/>     return(img)</span></pre><p id="35ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">s3客户机作为输入传递。我使用的是keras加载模块，但是也可以使用通用的PIL包。接下来是一些简单的调整大小的例子，我再次使用keras处理:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7ef2" class="kc kd hi jy b fi ke kf l kg kh">from keras.preprocessing.image import img_to_array</span><span id="8c67" class="kc kd hi jy b fi ki kf l kg kh">def preprocess_input(img):</span><span id="dcdb" class="kc kd hi jy b fi ki kf l kg kh">     image = img.resize((128,128))<br/>     array = img_to_array(image)<br/>     return(array)</span></pre><p id="7597" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里需要注意的一点是观察图像张量的格式，以确保你使用的是正确的格式。在这个项目中，我做的是迁移学习，匹配输入格式当然很重要。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="daf1" class="kc kd hi jy b fi ke kf l kg kh">def s3_image_generator(files, batch_size = 16):<br/>     s3 = boto3.resource('s3')</span><span id="f468" class="kc kd hi jy b fi ki kf l kg kh">     while True:<br/>          #batch_paths = np.random.choice(a = files,<br/>          #                               size = batch_size)</span><span id="f52a" class="kc kd hi jy b fi ki kf l kg kh">          batch_paths = np.array(files)<br/>          batch_input = []<br/>          batch_output = [0] * len(files)</span><span id="a2cd" class="kc kd hi jy b fi ki kf l kg kh">          for input_path in batch_paths:<br/>                input = fectch_input(input_path, s3)</span><span id="edb3" class="kc kd hi jy b fi ki kf l kg kh">                input = preprocess_input(input)<br/>                batch_input += [ input ]</span><span id="ace5" class="kc kd hi jy b fi ki kf l kg kh">          batch_x = np.array( batch_input )<br/>          batch_y = np.array( batch_output )<br/>          yield( batch_x, batch_y )</span></pre><p id="bf5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我正计划进行无监督学习，所以我不需要标签，因此响应中有0。如果您计划将此用于训练，可以使用np.random.choice进行随机采样。</p><p id="0306" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以基本上就是这样！下面是一个片段，用于实际传递S3路径，并使用生成器进行预测。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f634" class="kc kd hi jy b fi ke kf l kg kh">import pandas as pd<br/>import boto3<br/>from time import time</span><span id="adb2" class="kc kd hi jy b fi ki kf l kg kh">bucket_name =''</span><span id="a568" class="kc kd hi jy b fi ki kf l kg kh">client = boto3.client('s3')<br/># Create a reusable Paginator<br/>paginator = client.get_paginator('list_objects_v2')</span><span id="dba0" class="kc kd hi jy b fi ki kf l kg kh"># Create a PageIterator from the Paginator<br/>page_iterator = paginator.paginate(Bucket=bucket_name,Prefix =’’)</span><span id="e4c7" class="kc kd hi jy b fi ki kf l kg kh">g = pd.Series()</span><span id="5812" class="kc kd hi jy b fi ki kf l kg kh">a=time()<br/>for page in page_iterator:<br/>     m=pd.Series(list(map(lambda d: d['Key'], page['Contents'])))<br/>     g = g.append(m)<br/>     print(len(g))<br/>     if len(g) == 10000:<br/>          break<br/>print(time() - a)</span><span id="a53c" class="kc kd hi jy b fi ki kf l kg kh">g = g.reset_index(drop=True)</span><span id="d33c" class="kc kd hi jy b fi ki kf l kg kh">preds = model_updated.predict_generator(s3_image_generator(g[0:512]), steps = 1, verbose = 1)</span></pre><p id="9c67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后要注意的是，如果你只想做预测，这个流程可能有点过于复杂。没有生成器的替代方案是简单地加载和预测而没有生成器:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="403b" class="kc kd hi jy b fi ke kf l kg kh">first = 1<br/>a = time()<br/>s3 = boto3.resource('s3')<br/>for path in g[0:1000]:<br/>    x_batch=[]</span><span id="f96f" class="kc kd hi jy b fi ki kf l kg kh">    object = s3.Object(bucket_name,path)<br/>    img = load_img(io.BytesIO(object.get()['Body'].read()))<br/>    image = img.resize((128,128))<br/>    array = img_to_array(image)<br/></span><span id="a674" class="kc kd hi jy b fi ki kf l kg kh">    preds=(model.predict_on_batch(array))<br/>    if first==1:<br/>        predsA=preds.copy()<br/>        first=0<br/>     else:<br/>        predsA=np.append(predsA,preds,axis=0)</span><span id="2832" class="kc kd hi jy b fi ki kf l kg kh">time()-a</span></pre><p id="a8a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读。</p></div></div>    
</body>
</html>