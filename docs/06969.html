<html>
<head>
<title>Testing Python decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试Python装饰器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/testing-python-decorators-3c5777e4524d?source=collection_archive---------1-----------------------#2020-06-09">https://medium.com/analytics-vidhya/testing-python-decorators-3c5777e4524d?source=collection_archive---------1-----------------------#2020-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="27bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章的灵感来自我的同事，他最近问了我一个关于如何为装饰者编写测试的问题。目的是为刚接触装饰、测试或两者兼有的人提供一个温和的推动力来掌握这个主题。</p><p id="5a82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对装饰者不熟悉——在<a class="ae jd" href="https://realpython.com/" rel="noopener ugc nofollow" target="_blank"> <em class="je">的人们，realpython </em> </a>有一个很好的开始指南:<a class="ae jd" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank">Python装饰者入门</a></p><p id="2778" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您完全不熟悉编写测试(并且有大约1小时的空闲时间)，我强烈建议您首先阅读这些精彩的文章:</p><ol class=""><li id="1d5a" class="jf jg hi ih b ii ij im in iq jh iu ji iy jj jc jk jl jm jn bi translated"><a class="ae jd" href="https://realpython.com/python-testing/" rel="noopener ugc nofollow" target="_blank">Python测试入门</a></li><li id="a398" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated"><a class="ae jd" href="https://realpython.com/pytest-python-testing/#what-makes-pytest-so-useful" rel="noopener ugc nofollow" target="_blank">使用Pytest进行有效的Python测试</a></li></ol><p id="60f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在我的<a class="ae jd" href="https://github.com/captain-fox/testing_python_decorators_sample_code" rel="noopener ugc nofollow" target="_blank"> github </a>中找到本文没有提到的所有代码样本和额外的测试用例。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="2d74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当我们为一个常规函数编写一个测试场景时,(通常)对于如何做没有困惑:取决于我们如何调用一个函数(参数、上下文、应用程序的状态等)。)其活动的产物被认为是成功或失败。</p><p id="839e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试装饰者有一点点不同。您需要将<strong class="ih hj"> <em class="je">修饰的</em> </strong>函数排除在等式之外，而是验证<strong class="ih hj"> <em class="je">修饰器</em> </strong>是否做了它应该做的事情。</p><p id="e431" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">巧合的是，我有<em class="je">刚刚</em>的例子(我过度简化了)来演示你应该如何以及为什么用测试用例覆盖装饰者。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="b94b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们正在开发一个有两类用户的应用程序:</p><ol class=""><li id="2c1c" class="jf jg hi ih b ii ij im in iq jh iu ji iy jj jc jk jl jm jn bi translated">经理</li><li id="7bf5" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated">普通用户</li></ol><p id="024c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时，作为对某种触发的反应，应用程序会向他们发送电子邮件。类型为<strong class="ih hj"> <em class="je">经理</em> </strong> <em class="je"> </em>的用户从地址<strong class="ih hj"> management@ecorp接收电子邮件。<em class="je"> com </em> </strong> <em class="je">，</em>所有其他用户都会收到来自<strong class="ih hj">internal@ecorp.com</strong>的邮件。地址规则适用于所有发出的电子邮件。</p><p id="0d97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将苹果和橙子分开是一个经验法则，这就是为什么我们希望有一个函数负责建立与电子邮件服务器的连接并发送消息，另一个函数根据用户类型确定发送电子邮件的地址。</p><p id="7097" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ka kb kc kd b">notify_by_email</code> <strong class="ih hj"> </strong>函数负责与邮件服务器建立连接并发送消息(我们一会儿会讲到<code class="du ka kb kc kd b">using_email_address</code>装饰器)。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="84db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，<code class="du ka kb kc kd b">notify_by_email</code>接受两个参数:<code class="du ka kb kc kd b"><strong class="ih hj">user</strong></code> <strong class="ih hj"> </strong>(应该接收消息的人)和<code class="du ka kb kc kd b"><strong class="ih hj">from_email</strong></code>(应该发送消息的地址)。让我们跳过<code class="du ka kb kc kd b"><strong class="ih hj">html_message</strong></code> <strong class="ih hj"> </strong>的内容及其如何到达那里，以及与邮件服务器建立连接的过程，因为它们与我们的主题无关。注意<code class="du ka kb kc kd b">notify_by_email</code>不返回值。这样的函数通常从异步进程内部调用。如果在执行这样的函数时发生了不可预知的事情，它会被添加到日志文件中，不会导致应用程序崩溃。</p><p id="ce08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">装饰者的工作是决定从哪个电子邮件地址发送信息(记住:苹果和橘子！):</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="78c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">装饰器根据用户的类型决定使用哪个电子邮件地址，并将其与<code class="du ka kb kc kd b">user</code>一起作为<code class="du ka kb kc kd b">from_email</code>参数传递给<strong class="ih hj"> <em class="je">装饰的</em> </strong>函数。</p><p id="3f81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这允许我们在代码中的任何地方调用<code class="du ka kb kc kd b">notify_by_email</code>，只提供<code class="du ka kb kc kd b">user</code>参数:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="79bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ka kb kc kd b">@using_email_address</code> decorator将负责从哪个电子邮件地址发送消息。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="43af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快进几百行代码，我们很高兴让我们的应用程序做一些有用的技巧，包括给用户发送电子邮件。我们甚至创建了一个模拟来避免发送实际的电子邮件:我们的测试用例检查<code class="du ka kb kc kd b">notify_by_email</code>是否试图使用正确的凭证与电子邮件服务器建立连接。</p><p id="75e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">突然，我们的应用程序开始使用错误的地址向一类或两类用户发送电子邮件。为<code class="du ka kb kc kd b">notify_by_email</code>函数编写测试用例意味着我们在每个函数调用中都隐式地调用<code class="du ka kb kc kd b">using_email_address</code>，但是并不真正检查装饰器内部发生了什么。</p><p id="29b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试着为decorator编写一个测试用例，就像我们为常规函数编写测试一样:我们需要用某些输入来调用<code class="du ka kb kc kd b">using_email_address</code>,并断言在它内部发生的任何事情都会产生预期的输出/结果。这种编写测试的技术被称为“黑盒测试”。</p><p id="3a43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ka kb kc kd b">using_email_address</code>接受一个参数:一个函数。它还有一个返回值:一个函数。因此，要测试一个装饰器，我们需要向它传递一个函数，并期待一个函数作为返回值。记住这一点，让我们开始为<code class="du ka kb kc kd b">using_email_address</code>编写测试用例。因为我们必须将函数作为参数传递，所以让我们创建一个函数，并将其命名为<code class="du ka kb kc kd b">to_be_decorated</code>:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="4f4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你所看到的还没有让你想起什么——我给你一点提示:我们刚刚做了decorator对语法糖所做的事情，以<code class="du ka kb kc kd b">@</code>的形式应用于函数。这给了我们理解如何测试decorators的第一个技巧——像通常一样，用函数包装它，只是这次使用可以“玻璃盒子”的函数，这意味着您可以完全控制函数内部的事件流。</p><p id="d2a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们以更pythonic化的方式重新编写测试并运行它(尽管到目前为止我们还没有任何<code class="du ka kb kc kd b">assert</code>语句):</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="3cfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们收到一个错误:</p><p id="5adc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ka kb kc kd b">TypeError: wrapper() missing 1 required positional argument: ‘user’</code></p><p id="18de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着尽管我们已经重新创建了装饰函数关系，用<code class="du ka kb kc kd b">to_be_decorated</code>函数替换了<code class="du ka kb kc kd b">notify_by_email</code>，我们仍然缺少几个参数和至少一个返回语句。我们快到了！让我们修复这个错误:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="c86e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你已经注意到的，我们已经为我们的测试用例提供了<code class="du ka kb kc kd b">user</code> fixture。<code class="du ka kb kc kd b">to_be_decorated</code>函数现在需要<code class="du ka kb kc kd b">user</code>、<code class="du ka kb kc kd b">from_email</code>和<code class="du ka kb kc kd b">**kwargs</code>作为参数。最后我们调用<code class="du ka kb kc kd b">to_be_decorated</code>，用<code class="du ka kb kc kd b">using_email_address</code>包装，除了这次我们可以直接从<code class="du ka kb kc kd b">to_be_decorated</code>函数中访问它的活动结果。</p><p id="c242" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们现在运行测试用例，它应该会通过。我们没有任何<code class="du ka kb kc kd b">assert</code>语句，因此这仅仅意味着没有任何东西抛出异常，并且所有的参数都就位了。</p><p id="d7cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们再一次更新我们的测试用例，但是这次我们让<code class="du ka kb kc kd b">using_email_address</code>负责根据它接收的用户类型选择正确的电子邮件地址。我们将要测试的类型是<code class="du ka kb kc kd b">manager</code>，所以在用<code class="du ka kb kc kd b">using_email_address</code> <code class="du ka kb kc kd b">to_be_decorated</code>函数包装之后，应该会收到:</p><ol class=""><li id="151f" class="jf jg hi ih b ii ij im in iq jh iu ji iy jj jc jk jl jm jn bi translated"><code class="du ka kb kc kd b">user</code>与第6行调用的<code class="du ka kb kc kd b">manager</code>对象相同的参数</li><li id="33d5" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated"><code class="du ka kb kc kd b">from_email</code>带有值<code class="du ka kb kc kd b">management@ecorp.com</code>的参数</li></ol><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="3867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧啊。现在你知道了如何从测试的角度接近装饰者。</p><p id="680c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我鼓励你看看这篇文章的<a class="ae jd" href="https://github.com/captain-fox/testing_python_decorators_sample_code" rel="noopener ugc nofollow" target="_blank">样本代码</a>。您会发现更多的测试示例，我在这里没有提到。示例代码是自包含的，所以除了<code class="du ka kb kc kd b">Python</code>和<code class="du ka kb kc kd b">PyTest</code>之外，您不需要任何额外的库来运行它，并使用您自己的实现。</p></div></div>    
</body>
</html>