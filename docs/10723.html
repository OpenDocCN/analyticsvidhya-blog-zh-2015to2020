<html>
<head>
<title>Some notes on Python dictionaries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Python字典的一些注释</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/some-notes-on-python-dictionaries-b4a0c1f21473?source=collection_archive---------18-----------------------#2020-10-31">https://medium.com/analytics-vidhya/some-notes-on-python-dictionaries-b4a0c1f21473?source=collection_archive---------18-----------------------#2020-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6022" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">更好地利用python字典的几点建议</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0ea432dde24ebfcf2df658087188d884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ieaO65ml6edU5EufdwwfAw.jpeg"/></div></div></figure><h1 id="86f5" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">介绍</h1><p id="f4ef" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">Python <a class="ae kx" href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="noopener ugc nofollow" target="_blank">字典</a>是将键映射到值的灵活容器。知道如何使用字典是任何一个pythonist爱好者的必备技能。</p><p id="50ba" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">这个博客涵盖了Python字典上的一些注释，这些注释帮助我改进了我的<code class="du le lf lg lh b">dict</code>游戏。如果您是一名(&gt; =)中级python程序员，那么其中的大部分内容您可能已经很熟悉了。但是我仍然希望你会喜欢这篇文章，也许能从中受益。</p><p id="0103" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">我试图让这个博客对初学者友好，但是如果你不太熟悉<code class="du le lf lg lh b">dict</code>，你可能会发现<a class="ae kx" href="https://realpython.com/python-dicts/" rel="noopener ugc nofollow" target="_blank">复习</a>很有用。</p><p id="7c61" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">我们开始吧。</p><h1 id="beb1" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">注1:使用字典的一个基本例子</h1><p id="8c65" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">对于<code class="du le lf lg lh b">dict</code>如何工作的基本演示，让我们计算列表中项目的频率。这是一个非常明显的<code class="du le lf lg lh b">dict</code>用例。<br/>我们将以尽可能最基本的方式实现这一点开始，并随着我们的进展改进我们的代码。稍后，我们将使用一个专门的容器来做这件事。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="b8b2" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">注意2: `setdefault '优雅地处理丢失的键</h1><p id="f644" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我们可以在上面的代码中避免使用<code class="du le lf lg lh b">if-else</code>子句，并使用<code class="du le lf lg lh b">setdefault</code>方法处理丢失的键。<br/>如果项目/关键字在字典中，<code class="du le lf lg lh b">setdefault</code>返回其值。否则，它插入具有给定值的项并返回它。<br/>在<code class="du le lf lg lh b">setdefault</code>的<a class="ae kx" href="https://docs.python.org/3.8/library/stdtypes.html#dict.setdefault" rel="noopener ugc nofollow" target="_blank">文档</a>中的解释非常直接，如下所示:</p><blockquote class="lk ll lm"><p id="a807" class="kb kc ky kd b ke kz ij kg kh la im kj ln lb km kn lo lc kq kr lp ld ku kv kw hb bi translated"><code class="du le lf lg lh b">setdefault(key[,default])</code> <br/>如果键在字典中，返回其值。如果不是，插入值为default的键并返回default。默认为“无”。</p></blockquote><p id="dfa8" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">这不仅减少了代码的行数，而且使代码更具可读性和pythonic性。<br/>让我们使用<code class="du le lf lg lh b">setdefault</code>来改进注释1中的示例。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><h2 id="ed87" class="lq jk hi bd jl lr ls lt jp lu lv lw jt kk lx ly jv ko lz ma jx ks mb mc jz md bi translated">这里有另一个“setdefault”的例子来使它更清楚，因为这是一个重要的方法。</h2><p id="4c41" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">下面的代码从一个列表中分离出所有的奇数和偶数，并将其放入自己的列表/桶中。<br/>一个桶包含所有奇数，而另一个桶包含所有奇数。我们将使用<code class="du le lf lg lh b">num%2</code> ( <a class="ae kx" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">一个散列函数</a>)来创建密钥，因为<code class="du le lf lg lh b">odd_num%2 == 1</code>和<code class="du le lf lg lh b">even_num%2 == 0</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="b8fc" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">当然，你可以争辩说，在上面的代码中，我们可以简单地将<code class="du le lf lg lh b">buckets</code>初始化为<code class="du le lf lg lh b">bucket={'odd':[],'even':[]}</code>。但是想想那些您事先不知道键的非平凡用例，例如，读取一个包含县及其城市的<code class="du le lf lg lh b">.csv</code>文件，每行是<code class="du le lf lg lh b">&lt;country_name&gt;,&lt;city_name&gt;</code>，您需要将所有的国家及其城市分组；具有任意数量桶的复杂散列函数等。如果您愿意，可以使代码更短。</p><pre class="iy iz ja jb fd me lh mf mg aw mh bi"><span id="36c3" class="lq jk hi lh b fi mi mj l mk ml">for num in num_list:<br/>    buckets.setdefault(num%2,[]).append(num)</span></pre><p id="1a79" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">为了便于比较，下面是同一个例子中没有使用<code class="du le lf lg lh b">setdefault</code>的两个(故意难看的)替代方案。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="3ebf" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">注3:使用“collections.Counter()”对对象进行计数</h1><p id="8f8e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">回到我们之前计算频率的例子，这是一个重复的任务，python在<code class="du le lf lg lh b">collections</code>模块中有一个内置的<code class="du le lf lg lh b">Counter</code>。<code class="du le lf lg lh b">Counter</code>附带了一些有用的方法，比如<code class="du le lf lg lh b">most_common(n)</code>来快速找出最频繁出现的n个条目，非常类似于<code class="du le lf lg lh b">dict</code> ( <a class="ae kx" href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="noopener ugc nofollow" target="_blank"> docs </a>)。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="9bc6" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">注4:词典释义</h1><p id="39c7" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><a class="ae kx" href="https://docs.python.org/3/tutorial/datastructures.html?highlight=comprehension#list-comprehensions" rel="noopener ugc nofollow" target="_blank">理解</a>是Python中最有用的工具之一，当然，它也受到字典的支持。语法与list comprehensions的<br/>基本相同，不同之处在于使用了<code class="du le lf lg lh b">{..}</code>而不是<code class="du le lf lg lh b">(..)</code>，并且要求您定义一个<code class="du le lf lg lh b">key: value</code>对。从下面的代码示例中应该很明显。</p><p id="45ae" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">请注意，字典理解不应该用于任何副作用，如增加变量或打印等。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="fb02" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">注5:注python字典和“OrderedDict”中的插入顺序</h1><p id="022f" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">从Python 3.7+开始，字典保持插入顺序。但是，不建议依赖它。许多流行的库(和程序员)认为<code class="du le lf lg lh b">dict</code>中的顺序并不重要，因为它通常并不重要。</p><p id="9cba" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">如果您想保持插入顺序，您应该使用<code class="du le lf lg lh b">OrderedDict</code> ( <a class="ae kx" href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="noopener ugc nofollow" target="_blank"> docs </a>)，它会记住默认情况下插入项目的顺序。除了清楚地传达你的意图之外，它还有一个额外的好处，就是不必太担心向后兼容性。</p><p id="ae12" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">如果你想了解更多这方面的知识，我强烈推荐格雷格·甘登伯格的文章。</p><h1 id="2abe" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">注意6:字典键需要是可散列的，并且事物也是可散列的。</h1><p id="2db6" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">对于作为字典中的键的对象，它需要是可哈希的。可散列对象的例子有<code class="du le lf lg lh b">int</code>、<code class="du le lf lg lh b">str</code>、<code class="du le lf lg lh b">float</code>等。具体来说，它需要满足以下三个要求。</p><ol class=""><li id="5d8b" class="mm mn hi kd b ke kz kh la kk mo ko mp ks mq kw mr ms mt mu bi translated">它应该通过一个<code class="du le lf lg lh b">__hash__()</code> dunder方法支持<code class="du le lf lg lh b">hash()</code>函数，该方法的值在对象的生命周期内不会改变。</li><li id="1a83" class="mm mn hi kd b ke mv kh mw kk mx ko my ks mz kw mr ms mt mu bi translated">它通过<code class="du le lf lg lh b">__eq__()</code>方法支持相等比较。</li><li id="3bfa" class="mm mn hi kd b ke mv kh mw kk mx ko my ks mz kw mr ms mt mu bi translated">如果<code class="du le lf lg lh b">a == b</code>是<code class="du le lf lg lh b">True</code>，那么<code class="du le lf lg lh b">hash(a) == hash(b)</code>也必须是<code class="du le lf lg lh b">True</code>。</li></ol><p id="1e0f" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">基于同样的原因，一个<code class="du le lf lg lh b">tuple</code>可以成为<code class="du le lf lg lh b">dict</code>中的一个键，而一个<code class="du le lf lg lh b">list</code>则不能。(<a class="ae kx" href="https://stackoverflow.com/questions/7257588/why-cant-i-use-a-list-as-a-dict-key-in-python" rel="noopener ugc nofollow" target="_blank">参考</a></p><p id="1fdc" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">关于这一点，默认情况下，用户定义的类型是可哈希的。这是因为它们的哈希值是它们的<code class="du le lf lg lh b">id()</code>并且它们都不相等。<br/>需要注意的一点是，<code class="du le lf lg lh b">__hash__()</code>、<br/> <code class="du le lf lg lh b">__eq__()</code>的定制实现应该只考虑那些在对象生命周期内不会改变的对象属性。(<a class="ae kx" href="https://stackoverflow.com/questions/4901815/object-of-custom-type-as-dictionary-key" rel="noopener ugc nofollow" target="_blank">进一步信息</a>)</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="2621" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">注7:字典速度快，但用空间换时间</h1><p id="5cb0" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在内部，<code class="du le lf lg lh b">dict</code>使用散列表。通过设计，这些哈希表是稀疏的，这意味着它们不是非常节省空间。对于大量的记录，将它们存储在紧凑的对象中可能更节省空间，比如<code class="du le lf lg lh b">tuples</code>。</p><p id="bb9b" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">即使<code class="du le lf lg lh b">dict</code>有很大的内存开销，只要它适合内存，就允许快速访问。(<a class="ae kx" href="https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented" rel="noopener ugc nofollow" target="_blank">参考</a>)</p><h1 id="34b8" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">注8:如果唯一性是您所需要的，请使用“集合”</h1><p id="68b9" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">从一个收藏中找出所有独特的物品是常有的事。使用带有虚拟值的<code class="du le lf lg lh b">dict</code>可能很有诱惑力，因为dict中的所有键在默认情况下都是惟一的。</p><p id="2a78" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">在这种情况下，最好使用<code class="du le lf lg lh b">set</code>来代替。Python <code class="du le lf lg lh b">set</code>保证唯一性。它也有很好的性质，类似于数学中的集合，如并和交。与<code class="du le lf lg lh b">dict</code>类似，<code class="du le lf lg lh b">set</code>中的元素必须是可散列的。</p><p id="dbfc" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">但是如果情况需要一个可散列的<code class="du le lf lg lh b">set</code>，你将不得不用<code class="du le lf lg lh b">frozenset</code>来代替，因为<code class="du le lf lg lh b">set</code>是不可散列的。<code class="du le lf lg lh b">frozenset</code>是<code class="du le lf lg lh b">set</code>的哈希版本，所以可以放在<code class="du le lf lg lh b">set</code>里面。</p><p id="f6a6" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">因为这项工作是关于字典的，所以我会给你留一个到文档的<a class="ae kx" href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="noopener ugc nofollow" target="_blank">链接</a>来学习更多关于集合的知识。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="e350" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">摘要</h1><ol class=""><li id="8ab0" class="mm mn hi kd b ke kf kh ki kk na ko nb ks nc kw mr ms mt mu bi translated">通过计算列表中项目的频率来基本演示<code class="du le lf lg lh b">dict</code>如何工作。</li><li id="f4f0" class="mm mn hi kd b ke mv kh mw kk mx ko my ks mz kw mr ms mt mu bi translated">丢失的钥匙可以通过<code class="du le lf lg lh b">setdefault</code>优雅的处理。</li><li id="c05c" class="mm mn hi kd b ke mv kh mw kk mx ko my ks mz kw mr ms mt mu bi translated"><code class="du le lf lg lh b">collections.Counter</code>是用于计数易腐烂物品的专用容器</li><li id="79e0" class="mm mn hi kd b ke mv kh mw kk mx ko my ks mz kw mr ms mt mu bi translated">创建词典时支持理解。</li><li id="9fae" class="mm mn hi kd b ke mv kh mw kk mx ko my ks mz kw mr ms mt mu bi translated">虽然<code class="du le lf lg lh b">dict</code>维持了秩序，但这不是应该依赖的东西。同样最好使用<code class="du le lf lg lh b">OrderedDict</code>。</li><li id="7152" class="mm mn hi kd b ke mv kh mw kk mx ko my ks mz kw mr ms mt mu bi translated">字典键需要是可哈希的。默认情况下，用户定义的对象是可哈希的。</li><li id="8aff" class="mm mn hi kd b ke mv kh mw kk mx ko my ks mz kw mr ms mt mu bi translated">字典速度快，但空间效率低，因为它使用稀疏哈希表。</li><li id="6e79" class="mm mn hi kd b ke mv kh mw kk mx ko my ks mz kw mr ms mt mu bi translated">当您只需要查找唯一值时，请使用集合而不是字典。</li></ol><h1 id="df8b" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">结论</h1><p id="8d48" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">这篇博客介绍了一些使用Python字典的注意事项。我希望这对你来说是一个知识性和愉快的阅读。如果你发现任何错误，请留下评论，以便我可以纠正它。也欢迎任何反馈和建议。</p><p id="3bb4" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">你可以在我的Github中找到这个博客的Jupyter笔记本版本。</p><p id="b7ad" class="pw-post-body-paragraph kb kc hi kd b ke kz ij kg kh la im kj kk lb km kn ko lc kq kr ks ld ku kv kw hb bi translated">感谢您的阅读。</p><h1 id="d21f" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">进一步阅读</h1><p id="7c8b" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我强烈推荐卢西亚诺·拉马尔霍写的《流畅的Python》这本书，它非常深入地涵盖了这个博客中的所有主题。<br/>这个博客也很大程度上受到了他的精彩著作的启发。</p></div></div>    
</body>
</html>