<html>
<head>
<title>UPLOAD IMAGE IN CLOUDINARY USING MERN STACK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MERN堆栈在云中上传图像</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/upload-image-in-cloudinary-using-mern-stack-39fcb4ed9d9e?source=collection_archive---------3-----------------------#2020-11-03">https://medium.com/analytics-vidhya/upload-image-in-cloudinary-using-mern-stack-39fcb4ed9d9e?source=collection_archive---------3-----------------------#2020-11-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7e27d38a9e8d529204d55ce7e375e9a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R-uO7K8JgWeuKzBy"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">雷诺·莱蒂安在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9153" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一名开发人员，您可能遇到过将图像上传到任何云资源以及允许您的客户将图像上传到您的数据库的挑战。</p><p id="1331" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将带领我们通过使用MERN堆栈轻松实现这一目标。</p><p id="c9bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用以下方法来实现这一目标:</p><ul class=""><li id="545a" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">反应堆</li><li id="6fdb" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">Nodejs</li><li id="cd55" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">云雾缭绕</li><li id="f3f4" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">MongoDB</li></ul><p id="b3e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用Reactjs作为前端，Nodejs作为后端，Cloudinary作为客户端图像的云存储，MongoDB作为我们的数据库，返回的图像路径将保存在这里。</p><p id="8671" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">T5】先决条件T7】</strong></p><ul class=""><li id="6267" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">了解反应的基础</li><li id="73c6" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">安装npm</li><li id="b36e" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">了解Nodejs的基础</li><li id="1400" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">安装节点</li><li id="1e14" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">设置并安装MongoDB compass</li><li id="33ed" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">了解MongoDB的基础</li><li id="afc2" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">有模糊的叙述</li></ul><p id="9e4b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，让我们创建一个名为CLOUDINARY_UPLOAD的react项目，在这里按照<a class="ae iu" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="kh"/></strong></a><strong class="ix hj"><em class="kh"/></strong>创建一个react项目</p><p id="efc1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经创建了一个新项目，让我们快速创建将处理客户端上传的组件；</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8660" class="kr ks hi kn b fi kt ku l kv kw">cd src</span><span id="a471" class="kr ks hi kn b fi kx ku l kv kw">touch imageUpload.js</span></pre><p id="3b77" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们刚刚创建的新的<strong class="ix hj"><em class="kh">image upload . js</em></strong>文件中，添加以下内容:</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/ab3aa88e94d5f53b4fb8b660f75ef035.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*pcQLDpHUipRs_nYm4xiKWg.png"/></div></figure><p id="a6b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个返回表单元素的组件，该元素包含一个输入(自定义输入)元素，该元素具有道具类型<strong class="ix hj"> <em class="kh">文件</em> </strong>并接受<strong class="ix hj"> <em class="kh">图像/* </em> </strong></p><p id="0add" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">文件</em> </strong>值使得输入可以接受任何<strong class="ix hj"> <em class="kh">文件</em> </strong>类型，<strong class="ix hj"> <em class="kh">接受</em> </strong>属性是指定我们将上传哪个<strong class="ix hj"> <em class="kh">文件</em> </strong>类型。onChange函数中的handleFileChange是文件处理函数，它将在输入字段中寻找onChange事件。</p><p id="8922" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们为图像字段创建handleFileChange处理程序；</p><p id="9d0d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先<strong class="ix hj"> <em class="kh">，</em> </strong>让我们设置一个管理文件值和解码图像文件的状态。在此之前，确保您已经在react导入参数中包含了useState挂钩，如下所示；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/bf2b5c31636fffef81f456f52ddae17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*p6GMKjw-qA-fLljawsd5Aw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用状态挂钩</figcaption></figure><p id="42bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">添加了以上内容后，让我们添加状态的初始值；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es la"><img src="../Images/89a5a26be1435cc3a8537d1cc305acb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*GPtwhacHLkbeDg0D5zLbOA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">国家</figcaption></figure><p id="f7f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们将创建handleFileChange处理程序，如下所示；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/5454f66ddf152020a95da5e43202cde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*WBO0hVVftJ1MtZ9JhubJhw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像处理器</figcaption></figure><p id="b2fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经创建了一个函数来处理文件更改。我们从输入字段中析构了目标对象，并将解码后的图像对象设置为文件输入每次改变时的状态。</p><p id="2065" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们打印<strong class="ix hj"> target.files[0] </strong>，我们应该在控制台上看到以下内容；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/6cba9d255aef0d17f160449d10de9098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SYKZ8xei1vPIF5nggYg6Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像原型</figcaption></figure><p id="3ddd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们所看到的，文件[0]保存了上传图像的全部信息，甚至还有附加信息，如<strong class="ix hj"><em class="kh"/></strong>等等。这正是我们在输入字段的每一次变化中所得到的状态。</p><p id="cc09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，我们看不到所选图像的路径，因为我们必须创建另一个状态，在每次更改时读取图像路径，并将其设置为文件输入字段值。让我们毫不拖延地为此创造条件；</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="a219" class="kr ks hi kn b fi kt ku l kv kw">const [images, setFile] = useState("");</span></pre><p id="4aa3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在handleFileChange函数内部将<strong class="ix hj"> <em class="kh"> target.value </em> </strong>设置为<strong class="ix hj"> <em class="kh">图像</em> </strong>的值；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/cd6577917f5356b555355de1b99cb663.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*g_K7xClsyGc-sMWCUjUrtg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">设置图像值</figcaption></figure><p id="5ac4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">文件</em> </strong>输入字段现在看起来是这样的；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es le"><img src="../Images/3dbdec4c6dfa5568b22bf1b69a054c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*dq_24xJlXZrErIy88l7IJg.png"/></div></figure><p id="2a0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"><em class="kh"/></strong>画面是现在输入字段的值。</p><p id="bd7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">渐渐地，我们已经能够使用刚刚创建的处理程序从本地机器上传图像。让我们继续创建一个将图像发送到服务器端的处理程序。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/52a61bb96313b934f5ed2c8cef254f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*Vk-C61PzAJmFzFYWzDwPmA.png"/></div></figure><p id="afba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们创建了一个submit函数，我们使用<strong class="ix hj"><em class="kh">e . prevent default</em></strong>函数防止它在提交到端点时返回void。</p><p id="ace7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将添加一个名为FormData的web API。它是一个构造函数，用于创建一个新的formData实例/存储数据等等。查看链接了解更多<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="kh">formData</em></strong></a><strong class="ix hj"><em class="kh">。</em> </strong></p><p id="d352" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用名为<strong class="ix hj"> <em class="kh"> append </em> </strong>的FormData构造函数属性来添加解码后的文件对象，并将其发送到端点以供使用。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/883755fafe02e9ae85fd3756173aad95.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*i4pPw4cs4fN9B-DL3g1CuQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">提交功能</figcaption></figure><p id="4591" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面我们创建了一个formData对象并附加了一个键(image)、值(fileData)，最后将数据发送到端点。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="fe33" class="kr ks hi kn b fi kt ku l kv kw">Note: make sure you have Axios installed in the project and import it to the uploadImage.js component as well.</span></pre><p id="3593" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">转到app.js文件，导入ImageUpload组件，如下图所示；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/735ded7b4841ff282737f3e313e2a707.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*anm7dVu-6C7AljeKnSMaig.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">app.js</figcaption></figure><p id="0a19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们解释的所有这些都是我们上传图像并将上传的图像发送到服务器端所需的。</p><p id="8d27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从今以后，我们将在服务器上处理客户端的请求，并将图像发送到我们的Cloudinary帐户。</p><p id="066b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在终端中，运行</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="dcae" class="kr ks hi kn b fi kt ku l kv kw">cd ~</span><span id="93aa" class="kr ks hi kn b fi kx ku l kv kw">cd Desktop</span><span id="d327" class="kr ks hi kn b fi kx ku l kv kw">mkdir cloudinaryImage_server_side</span><span id="5f8c" class="kr ks hi kn b fi kx ku l kv kw">cd cloudinaryImage_server_side</span><span id="8216" class="kr ks hi kn b fi kx ku l kv kw">touch index.js </span><span id="0ba5" class="kr ks hi kn b fi kx ku l kv kw">mkdir model controller route </span><span id="41b0" class="kr ks hi kn b fi kx ku l kv kw">code .</span></pre><p id="f96b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们返回到根文件夹，导航到桌面文件夹，创建一个名为cloudinaryImage_server_side的文件夹，创建一个包含其他三个文件夹的索引文件，最后打开一个新的Vscode编辑器。<strong class="ix hj"> <em class="kh">代码。</em> </strong>只针对那些使用Vscode作为开发工具的人。</p><p id="19ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将通过运行以下命令来添加package.json文件</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b15c" class="kr ks hi kn b fi kt ku l kv kw">npm init -y</span></pre><p id="3b37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将为这个项目安装所有必要的依赖项，如下所示</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c2fe" class="kr ks hi kn b fi kt ku l kv kw">npm install express multer mongoose cors nodemon cloudinary multer-storage-cloudinary --save</span></pre><p id="9545" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经创建了package.json文件，让我们设置服务器。在index.js文件中，添加以下代码</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es li"><img src="../Images/23d622e786842a75b377839dca239ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*IaECzJ8c-JeXYPn4sR6uIw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">index.js文件</figcaption></figure><p id="ead4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">转到package.json文件并修改脚本属性。将以下内容添加到脚本对象中；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/da828797000682f82b2f288dd6620aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*lvtCqqMJO4l_TbcvQ_okng.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">脚本对象</figcaption></figure><p id="687e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">修改后，让我们用以下命令启动我们的服务器:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9287" class="kr ks hi kn b fi kt ku l kv kw">npm run dev</span></pre><p id="0731" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您在Vscode终端中看到以下内容，那么您已经成功启动了一个节点服务器。<code class="du lk ll lm kn b"><br/>Server has started!</code></p><p id="d2cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">打开我们创建的模型文件夹，创建一个名为fileUpload.js的文件，并在其中添加以下内容；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/57ad65a4ff905b058fef40bffda95f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*IypTatxi4ESRZdoyhjcFcQ.png"/></div></figure><p id="5874" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们导入了mongose，将mongose的Schema属性传递给了Schema变量。</p><p id="bc64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们为请求文件上传创建了一个模式，并将其导出以等待控制器文件中的导入。</p><p id="b0d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成后，我们将在控制器文件夹中创建一个文件，用于处理服务器端的图像上传</p><p id="4648" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在您的终端中，导航到控制器文件夹并运行</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="a94e" class="kr ks hi kn b fi kt ku l kv kw">Touch uploadImage.js</span></pre><p id="d70d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在其中添加以下内容:</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/258abee7bb4dd7cb6d245b5c3b9c3342.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*9CkhuJUTZ3FYsoFcHp5jYg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">上传控制器</figcaption></figure><p id="3cf7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这保存了<strong class="ix hj"> <em class="kh">请求</em> </strong>文件的上传控制器。图像值设置为req.file.path，req.file是设置Cloudinary返回的图像属性以供使用的地方。</p><p id="79ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在根目录中创建一个名为middleware的新文件夹，该文件夹将包含一个名为cloudinary.config.js的文件。我们将在该文件中添加与我们的cloudinary帐户进行通信的功能。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/440a987769af70681ce4c4e29b05473d.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*2ed0FpNnKp9Dv6UsmucUiw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">云二进制配置文件</figcaption></figure><p id="a63e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们导入了在other中需要的必要依赖项，以便成功地将图像上传到我们的Cloudinary帐户。我们从即将创建的process.env文件中析构了用于上传的Cloudinary标准。我们使用Cloudinary.config方法输入Cloudinary所需的所有检查。</p><p id="158b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们使用Cloudinary仪表盘，复制上传图片所需的标准。以下是我们需要从仪表板中复制的内容；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/27fb9e4de5d08eced27eecbf1f393eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*HU5TUuTTHexxKk1Yl_Bm5Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">cloudinary通行证详细信息</figcaption></figure><p id="9451" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经获得了所有这些细节，我们将在我们的根路径中创建一个. env文件，并在其中添加您的帐户细节以达到安全目的。</p><p id="49d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们已经完成了上面的工作，让我们继续并通过添加以下内容来完成我们的Cloudinary配置上传处理程序。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/a216d36763518651a63ca7ae7ca978f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*tMU7CKVEAtqWIIyQFyLoLw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">云储存</figcaption></figure><p id="6290" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用CloudinaryStorage API来添加我们想要集成的所有选项。params字段包含一个对象，它将让我们处理和管理上传格式、上传图像的文件夹，以及最后一个惟一的公共ID，您可以使用它来访问和执行其他CRUD操作。</p><p id="19c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们使用Multer API将这个预期的上传存储到它的存储属性中，并导出它以用作我们即将创建的post route中的中间件。</p><p id="dce7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，让我们在前面创建的Route文件夹中创建一个名为uploadImageRoute.js的文件。在其中添加以下内容:</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/69f5f77cc9b5f8ababd313072f12698c.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*GL2lIRb1wmpmGkkdEdILaw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">路由文件</figcaption></figure><p id="3ba0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们导入了express的<strong class="ix hj"> <em class="kh">路由器方法</em> </strong>，处理Cloudinary上传的中间件，以及处理将返回的图像路径保存到数据库的控制器(UploadImage)。</p><p id="69e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用imageUploadRouter的post方法将客户端对中间件的请求发送到控制器。这里，如果客户机请求映像不满足Cloudinary要求的标准，它不会将请求传递给控制器。之后，我们导出了ImageUploadRouter，这样我们就可以在index.js中使用它了</p><p id="6c8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在index.js文件中，我们将导入imageUploadRouter，并将其作为中间件添加到app.use方法的express方法中，如下所示。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/940f37d4190c08f4f4f5ce6e98db3336.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*RdmJv5IOlNAfcCCVJAorqg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">导入图像上传路由器</figcaption></figure><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/8ebdf2831901e5e29195be5678417a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*iBU3NG0q22IJnN6_qnx8Jg.png"/></div></figure><p id="a0a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们试着打印req.file并了解我们对Cloudinary的期望。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/f0ea4b7c547eeb6d52dc9298656eabde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmCs_8C9DUuJw2mM_b3WIg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">req.file</figcaption></figure><p id="2dad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想这太神奇了，现在我们不仅成功地将一张图片上传到了我们的Cloudinary帐户，还上传到了我们的数据库。</p><p id="f762" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">req.file.path保存了上传图像的在线链接，这个URL是我们发送到数据库的内容，因此可以在任何浏览器中访问它。</p><p id="18e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果这篇文章是有帮助的，为什么不点击拍手图标50次。对于react代码，你可以在这里找到<a class="ae iu" href="https://github.com/chibuike07/cloudinary_upload" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="kh"/></strong></a>而对于服务器，跟着<a class="ae iu" href="https://github.com/chibuike07/cloudinaryImage_server" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="kh">me</em></strong></a><strong class="ix hj"><em class="kh">。</em>T19】</strong></p><p id="f1ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的<a class="ae iu" href="https://www.linkedin.com/in/chime-princewill-3a2b1b192/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="kh"> LinkedIn账号</em> </strong> </a>和<a class="ae iu" rel="noopener" href="/@princewillchime43"> <strong class="ix hj"> <em class="kh">中关注我的账号</em> </strong> </a>查看更多我的牛逼文章。</p></div></div>    
</body>
</html>