<html>
<head>
<title>Autonomous Navigation of a Mobile Robot: RRT Path Planning Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">移动机器人的自主导航:RRT路径规划算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/autonomous-navigation-of-a-mobile-robot-rrt-path-planning-algorithm-a8f780adef9d?source=collection_archive---------18-----------------------#2020-09-27">https://medium.com/analytics-vidhya/autonomous-navigation-of-a-mobile-robot-rrt-path-planning-algorithm-a8f780adef9d?source=collection_archive---------18-----------------------#2020-09-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a143d967cf7d9e3bb25d54cb0f7835d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85gwSlsrLabMx169CcY30Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片(1)，取自https://imgbin.com/download-png/HJWCJqwy，仅用于个人目的。</figcaption></figure><p id="db73" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用土耳其文/Bu makaleyi türke ol arak oku yun阅读这篇文章:<a class="ae js" rel="noopener" href="/@kucar17/bir-mobil-robotun-otonom-şekilde-yol-bulması-rrt-algoritması-57a8c51dfab4">https://medium . com/@ kucar 17/Bir-Mobil-robot un-oton om-% C5 % 9 fekilde-yol-bulmas % C4 % B1-RRT-algorit MAS % C4 % B1-57 A8 C51 dfab 4</a></p><p id="6ef3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">机器人学中的运动规划是一个术语，指的是找到一组可行的配置，将机器人从初始位置带到期望的位置。基本的RRT路径规划算法通过创建连接起点和终点(目标)的节点树来实现。</p><p id="0ab7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在每一步中，该算法选择一个随机点，然后将该点连接到已经计算并插入到节点/点树中的最近点。因此，在这两点之间创建了一条边/路径。然后检查连接两点的路径，看它是否与任何障碍物发生碰撞。如果没有与障碍物碰撞，该节点被添加到节点树中。然而，如果路径与任何障碍物发生碰撞，则确定移动是不可行的，并且使用新选取的点再次执行相同的计算。这些操作反复执行，直到达到目标点或公差范围。</p><p id="ab74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该算法广泛应用于机器人领域，因为它可以应用于有障碍物的环境。即使它使机器人到达它的目标点，由基本RRT算法计算的路径通常不是最优的，因为它使用随机选取的点。尽管有改进的算法，如RRT*算法，用于优化路径，我们将检查基本的RRT算法，它很少有小的改动。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/c62fa2c5cb1e5593b113099d79496dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*KzT8JeQjz7HxEw3eGHA7AA.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像(2)，RRT算法的动画，它有10000次迭代。图片属于贾韦德·侯赛因，取自wikipedia.org(https://en . Wikipedia . org/wiki/rapid-exploring _ random _ tree)。</figcaption></figure><p id="30bb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下面，我们将讲述在不撞上任何障碍物的情况下将机器人移动到目标位置的过程。RRT算法将被运行多次，以便为特定的路径规划问题创建不同的解决方案。</p><p id="2f45" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们检查一下我们的机器人将要找到路的环境(C空间):</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/40932e280316778f827bf2f149062e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*lAHr3uouume0z5nFD_e_dg.png"/></div></figure><p id="d9f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的起点位于(-0.5，-0.5)，期望点位于(0.5，0.5)点。</p><p id="d3c3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于我们的环境相对简单，我们可以期望我们的算法给出一个非常接近最优的结果。</p><p id="af0b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以在下面看到我们算法的MATLAB编码版本。首先，我们的代码将一个“barriers . CSV”文件作为输入，然后用它创建一个障碍矩阵。然后，我们将开始(startNode)和目标/结束(endNode)节点分配给两个不同的变量，并将我们的算法限制为50个点。因此，我们的算法将试图通过最多计算50个不同的点来将我们的机器人传输到其最终配置。如果在计算了50个不同的点之后，机器人还没有到达它的目标位置，算法会告诉我们它失败了。</p><p id="3d15" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在代码中，有一些事情可能会引起您的注意。其中之一是X轴和Y轴上的样本空间在每一步中分别变窄。例如，如果我们的机器人到达点<br/> (-0.15，0。20)在没有任何冲突的情况下，我们告诉我们的算法，它的新样本空间在X轴和Y轴上分别是(-0.15，0.50)和(0.20，0.50)。这样，我们的算法在选择新的随机点时，将使用这些间隔。尽管这种方法有可能在某些环境中导致问题，但它有助于创建一条非常接近我们实例中最佳路径的路径。另一件事是，使用直线是为了将两点相互连接起来。在具有运动约束的系统中，使用不同的运动规划器来代替直线。为了便于理解，我们假设我们的机器人没有运动约束。</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="1cda" class="ke kf hi ka b fi kg kh l ki kj">%% Clearing the command window and workspace<br/>clc<br/>clear</span><span id="5baf" class="ke kf hi ka b fi kk kh l ki kj">tic</span><span id="3a61" class="ke kf hi ka b fi kk kh l ki kj">%% Defining obstacles<br/>obstacles = readmatrix('obstacles.csv');<br/>centerX = obstacles(:,1);<br/>centerY = obstacles(:,2);<br/>radius = obstacles(:,3)/2;</span><span id="4868" class="ke kf hi ka b fi kk kh l ki kj">obstacleCenterX = zeros(1, length(obstacles));<br/>obstacleCenterY = zeros(1, length(obstacles));<br/>obstacleRadius = zeros(1, length(obstacles));</span><span id="0e06" class="ke kf hi ka b fi kk kh l ki kj">for i = 1 : length(obstacles)<br/>    obstacleCenterX(i) = centerX(i);<br/>    obstacleCenterY(i) = centerY(i);<br/>    obstacleRadius(i) = radius(i);<br/>end</span><span id="5476" class="ke kf hi ka b fi kk kh l ki kj">%% Setting up the RRT Aims and Parameters:<br/>startNode = [-0.5 -0.5];<br/>endNode = [0.5 0.5];<br/>maxTreeSize = 50;</span><span id="0eec" class="ke kf hi ka b fi kk kh l ki kj">T{1} = startNode;<br/>rangeX = startNode(1) : 0.01 : endNode(1);<br/>rangeY = startNode(2) : 0.01 : endNode(2);<br/>nodeNumber = 1;<br/>edge = [];</span><span id="d62f" class="ke kf hi ka b fi kk kh l ki kj">%% Starting the RRT Algorithm:<br/>while length(T) &lt; maxTreeSize<br/>    <br/>    if(length(rangeX) ~= 0)<br/>    xAxis = randsample(rangeX*0.1, 1);<br/>    end<br/>    <br/>    if(length(rangeY) ~= 0)<br/>    yAxis = randsample(rangeY*0.1, 1);   <br/>    end<br/>    <br/>    xSamp = [xAxis yAxis];<br/>    <br/>    for i = 1 : length(T)<br/>        distances = sqrt((T{1}(1) - xAxis)^2 + (T{1}(2) - yAxis)^2);<br/>        index = find(distances == min(distances));<br/>        xNearest = T{i};<br/>    end<br/>    <br/>    dRange = 0 : 0.005: 0.1;<br/>    distanceX = randsample(dRange, 1);<br/>    distanceY = randsample(dRange, 1);<br/>    <br/>    xNewAxisX = xNearest(1) + distanceX;<br/>    xNewAxisY = xNearest(2) + distanceY;<br/>    xNew = [xNewAxisX xNewAxisY];<br/>    <br/>    if (xNew(1) - xNearest(1) == 0)<br/>        continue<br/>    end<br/>    <br/>    lineCoeffs = polyfit([xNearest(1) xNew(1)], [xNearest(2) xNew(2)], 1);<br/>    slope = lineCoeffs(1);<br/>    yIntercept = lineCoeffs(2);<br/>    <br/>    % Checking if the line intersects any of the obstacles:<br/>    for i = 1 : length(obstacles)<br/>        a = linecirc(slope,yIntercept,obstacleCenterX(i),obstacleCenterY(i),obstacleRadius(i));<br/>        % If a is not a NaN array (1 by 2), this means collision and loop<br/>        % is terminated:<br/>        if (~isnan(a))<br/>            addCondition = 0;<br/>            break<br/>        else<br/>            addCondition = 1;<br/>        end<br/>    <br/>    end<br/>    <br/>    if xNew(1)&gt; 0.5<br/>        xNew(1) = 0.5;<br/>    end<br/>    <br/>    if xNew(2)&gt; 0.5<br/>        xNew(2) = 0.5;<br/>    end<br/>    <br/>    % If the line does not intersect the obstacles, xNew is added to the<br/>    % tree and vertex/edge is created between xNearest and xNew:<br/>    if (addCondition ~= 0)<br/>        T{length(T) + 1} = xNew;<br/>        nodeDistance = sqrt((xNearest(1) - xNew(1))^2 + (xNearest(2) - xNew(2))^2);<br/>        edge{length(edge) + 1} = [nodeNumber nodeNumber+1 nodeDistance];<br/>        nodeNumber = nodeNumber + 1;<br/>        % Narrowing down the range of sample in order to get closer to the<br/>        % goal node:<br/>        narrowRangeX = rangeX &lt; xNew(1);<br/>        narrowRangeY = rangeY &lt; xNew(2);<br/>        rangeX(narrowRangeX) = [];<br/>        rangeY(narrowRangeY) = [];<br/>        <br/>        if xNew == endNode<br/>            disp('RRT is completed successfully!')<br/>            for j = 1 : length(T)<br/>                nodes(j, :) = [j T{j}];<br/>            end<br/>            <br/>            for j = 1 : length(edge)<br/>                edges(j, :) = edge{j};<br/>            end           <br/>            <br/>            writematrix(edges, 'edges.csv');<br/>            writematrix(nodes, 'nodes.csv');<br/>            writematrix(nodes(:,1)', 'path.csv')<br/>            toc<br/>            return<br/>        end<br/>    end<br/>    <br/>end<br/>disp('RRT is not completed successfully!')    <br/>toc</span></pre><p id="8853" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们期望得到的结果是“RRT成功完成！”每次我们运行代码的时候。原因是，我们在代码开始时设置了50个最大点数的限制。这个50分的限制对于我们的算法来说并不是一个很硬的条件。我运行代码大约15次，算法计算的最大点数是29。然而，如果我们将这个限制设置为25或使用不同的环境，我们可以预期我们的算法偶尔会失败。</p><p id="19a0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以看到两个不同的路径，我们的算法计算如下(路径的模拟是在CoppeliaSim模拟软件中进行的):</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/1c211c0e83caf81cd8811d55b219061e.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*e0n8y5kd0OJgwXuCASmwhw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">算法计算出的第一条路径(26分)。</figcaption></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es km"><img src="../Images/75da74506fb075acf0b1f1c04316104a.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*_mUgOd1Tj0wGZ0FXGAyF3A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">算法计算出的第二条路径(29分)。</figcaption></figure><p id="521b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如两个不同的结果所示，算法每次可能产生不同的结果，因为它使用随机选取的点。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kn"><img src="../Images/cab0dd443943df2fd5d00f6eff9f9d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*S6WOPG-wdxt6CRJzZUYMWA.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">机器人的无碰撞导航。</figcaption></figure><p id="7b74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可以找到代码。csv文件，包含障碍物信息以及<a class="ae js" href="https://github.com/kucar17" rel="noopener ugc nofollow" target="_blank">我的GitHub页面</a>上的其他模拟文件。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="8bed" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我在本文中使用的模拟环境是MOOC系列提供的模拟环境包的一部分，该系列名为“现代机器人:力学、规划和控制专门化”，可以在Coursera上找到。此外，这个项目的灵感来自同一MOOC系列第四门课程的第二周作业。</p></div></div>    
</body>
</html>