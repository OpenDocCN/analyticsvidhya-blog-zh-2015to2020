<html>
<head>
<title>How to Create a Thread-Safe Singleton Class in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Python 创建线程安全的单例类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-create-a-thread-safe-singleton-class-in-python-822e1170a7f6?source=collection_archive---------0-----------------------#2020-12-18">https://medium.com/analytics-vidhya/how-to-create-a-thread-safe-singleton-class-in-python-822e1170a7f6?source=collection_archive---------0-----------------------#2020-12-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/951488aef26623e232455f53c7a74bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6C42GH1rkSyhajUqGoMfpQ.jpeg"/></div></div></figure><p id="c98f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jo">2022 年 12 月 22 日更新</em> </strong> <em class="jo">:我最初是用 Python 3.9 写的这篇文章。我刚刚检查了 3.11 版本，一切正常。我还添加了一个示例单元测试。</em></p><p id="b58d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将向您展示如何用 Python 创建线程安全的单例类。我写这篇文章是因为网上大多数关于 Python 中单例的例子要么<a class="ae jp" href="https://www.geeksforgeeks.org/singleton-method-python-design-patterns/" rel="noopener ugc nofollow" target="_blank">糟糕透顶</a>要么<a class="ae jp" href="https://www.tutorialspoint.com/python_design_patterns/python_design_patterns_singleton.htm" rel="noopener ugc nofollow" target="_blank">不是线程安全的</a>。这是最后的代码，因为您可能是为了快速回答问题，以便解决当前的任务:</p><pre class="jq jr js jt fd ju jv jw bn jx jy bi"><span id="4901" class="jz ka hi jv b be kb kc l kd ke">class Singleton:<br/>    _instance = None<br/>    _lock = threading.Lock()<br/><br/>    def __new__(cls):<br/>        if cls._instance is None: <br/>            with cls._lock:<br/>                # Another thread could have created the instance<br/>                # before we acquired the lock. So check that the<br/>                # instance is still nonexistent.<br/>                if not cls._instance:<br/>                    cls._instance = super().__new__(cls)<br/>        return cls._instance</span></pre><h1 id="24d1" class="kf ka hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">说明</h1><p id="e7b0" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">什么是对付巨蟒的</em> </strong> <code class="du lh li lj jv b"><strong class="is hj"><em class="jo">__new__</em></strong></code> <strong class="is hj"> <em class="jo">盾德法？</em> </strong></p><p id="7328" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每当 Python 实例化一个类的新对象时，就会调用<code class="du lh li lj jv b">__new__</code>。通常，<code class="du lh li lj jv b">__new__</code>会转到该类的超类，即<code class="du lh li lj jv b">Object</code>，并实例化一个新对象，然后将该对象传递给<code class="du lh li lj jv b">__init__</code>，并带有传递给<code class="du lh li lj jv b">__new__</code>的任何参数。我们截取这个方法，并告诉它创建一个且只有一个类实例(即 Singleton)。然后这个类对象像往常一样被传递给<code class="du lh li lj jv b">__init__</code>方法。</p><p id="2f61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jo"/></strong><code class="du lh li lj jv b"><strong class="is hj"><em class="jo">Lock</em></strong></code><strong class="is hj"><em class="jo">怎么回事？</em> </strong></p><p id="bddb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个好问题。<code class="du lh li lj jv b">threading.Lock</code>是一个实现原始锁对象的类。它允许运行我们代码的线程成为访问锁的<a class="ae jp" href="https://book.pythontips.com/en/latest/context_managers.html" rel="noopener ugc nofollow" target="_blank">上下文管理器</a>中代码的唯一线程，只要它持有锁。这意味着没有其他线程可以与拥有锁的线程同时运行<code class="du lh li lj jv b">with cls._lock</code>块中的代码。</p><p id="c8ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">这两个</em> </strong> <code class="du lh li lj jv b"><strong class="is hj"><em class="jo">cls._instance</em></strong></code> <strong class="is hj"> <em class="jo">检查有什么关系？</em>T46】</strong></p><p id="0553" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在获取锁之前，我们检查<code class="du lh li lj jv b">cls._instance</code>是否为<code class="du lh li lj jv b">None</code>。有一种边缘情况，在这个线程中<code class="du lh li lj jv b">cls._instance</code>是<code class="du lh li lj jv b">None</code>，而另一个线程将要调用<code class="du lh li lj jv b">cls._instance = super(Singleton, cls).__new__(cls)</code>。在这个例子中，创建了两个类对象，从而破坏了我们类的 Singleton 属性。</p><p id="6f25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">为什么不把整个</em> </strong> <code class="du lh li lj jv b"><strong class="is hj"><em class="jo">__new__</em></strong></code> <strong class="is hj"> <em class="jo">方法放在</em> </strong> <code class="du lh li lj jv b"><strong class="is hj"><em class="jo">Lock</em></strong></code> <strong class="is hj"> <em class="jo">上下文管理器中并避免第二个</em> </strong> <code class="du lh li lj jv b"><strong class="is hj"><em class="jo">if not cls._instance</em></strong></code> <strong class="is hj"> <em class="jo">检查，这样呢？</em> </strong></p><pre class="jq jr js jt fd ju jv jw bn jx jy bi"><span id="bf7e" class="jz ka hi jv b be kb kc l kd ke">class Singleton:<br/>    _instance = None<br/>    _lock = threading.Lock()<br/><br/>    def __new__(cls, *args, **kwargs):<br/>        with cls._lock:<br/>            if not cls._instance:<br/>                cls._instance = super().__new__(cls)<br/>        return cls._instance</span></pre><p id="7fd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是可行的，乍看之下，<em class="jo">似乎比</em>更好，因为代码行减少了。然而，问题是获取锁是一个昂贵的操作。拥有一个在不需要的时候获取锁的类/方法会导致代码运行缓慢，很难确定。仅在必要时获取锁。</p><p id="d21a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我怎么知道这真的有效？ </p><p id="52aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很棒的问题！我们可以通过单元测试断言正确的单体行为。下面的例子是用<a class="ae jp" href="https://docs.pytest.org/" rel="noopener ugc nofollow" target="_blank"> pytest </a>编写的通过单元测试:</p><pre class="jq jr js jt fd ju jv jw bn jx jy bi"><span id="1ad6" class="jz ka hi jv b be kb kc l kd ke">def test_singleton_is_always_same_object():<br/>    assert Singleton() is Singleton()<br/><br/>    # Sanity check - a non-singleton class should create two separate<br/>    #  instances<br/>    class NonSingleton:<br/>        pass<br/>    assert NonSingleton() is not NonSingleton()</span></pre><p id="dfc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">更新</strong>:如果用<code class="du lh li lj jv b">if not cls._instance</code>代替<code class="du lh li lj jv b">if cls._instance is None</code>时，该代码以前使用过。像这样:</p><pre class="jq jr js jt fd ju jv jw bn jx jy bi"><span id="3919" class="jz ka hi jv b be kb kc l kd ke">class Singleton:<br/>    _instance = None<br/>    _lock = threading.Lock()<br/><br/>    def __new__(cls):<br/>        if not cls._instance:  # This is the only difference<br/>            with cls._lock:<br/>                if not cls._instance:<br/>                    cls._instance = super().__new__(cls)<br/>        return cls._instance</span></pre><p id="2522" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如 pawewiszniewski 在评论中指出的，如果你的单例重载了 T10，你可能会遇到奇怪的行为。所以显式检查<code class="du lh li lj jv b">if _instance is None</code>更安全，而不是依赖<code class="du lh li lj jv b">_instance</code>是<a class="ae jp" href="https://www.pythonmorsels.com/truthiness/" rel="noopener ugc nofollow" target="_blank">假的</a>。希望您的测试套件能够在第一时间捕捉到任何此类潜入软件的问题。</p></div></div>    
</body>
</html>