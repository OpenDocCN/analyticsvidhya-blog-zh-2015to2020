<html>
<head>
<title>Understanding Collections.sort() in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Java中的Collections.sort()</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-collections-sort-in-java-8f2521b87a9b?source=collection_archive---------5-----------------------#2020-12-07">https://medium.com/analytics-vidhya/understanding-collections-sort-in-java-8f2521b87a9b?source=collection_archive---------5-----------------------#2020-12-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ab6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾名思义，java的Collections类提供了一个名为sort()的静态方法，用于按照特定的顺序对项目集合进行排序。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="7bed" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">public static </strong>&lt;T&gt; <strong class="ji hj">void </strong>sort(List&lt;T&gt; list, Comparator&lt;? <strong class="ji hj">super </strong>T&gt; c) {<br/>    list.sort(c);<br/>}</span></pre><p id="1442" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来看看这个方法的定义。正如我们所见，它有两个参数，一个是T类型的对象列表，另一个是比较器，它接受T类型的对象并返回列表排序的顺序。在这个函数定义中，我们给出了一个比较器来明确定义排序顺序。</p><p id="bb03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Collections.sort()方法还有一个定义。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="94a6" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">public static </strong>&lt;T <strong class="ji hj">extends </strong>Comparable&lt;? <strong class="ji hj">super </strong>T&gt;&gt; <strong class="ji hj">void </strong>sort(List&lt;T&gt; list) {<br/>    list.sort((Comparator)<strong class="ji hj">null</strong>);<br/>}</span></pre><p id="ab13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个定义中，静态排序方法只接受T类型的对象列表，并以默认顺序对它们进行排序。这里我们可以看到，为了以某种默认顺序对T进行排序，T必须实现Comparable接口。</p><p id="1ff4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重要的是要注意到，</p><blockquote class="js jt ju"><p id="e8cc" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><strong class="ih hj">所有包装类</strong>和字符串<strong class="ih hj">类</strong>用Java实现<strong class="ih hj">可比</strong>接口。<strong class="ih hj">包装类按照它们的值进行比较</strong>，字符串<strong class="ih hj">按照字典顺序进行比较</strong>。默认情况下，它们按升序对元素进行排序。</p></blockquote><p id="21b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用Collections.sort()方法对T类型的剩余对象进行排序，可以:</p><ol class=""><li id="9740" class="jz ka hi ih b ii ij im in iq kb iu kc iy kd jc ke kf kg kh bi translated">该对象应实现类似的接口，或者，</li><li id="39d3" class="jz ka hi ih b ii ki im kj iq kk iu kl iy km jc ke kf kg kh bi translated">我们应该定义一个自定义的比较器，它可以对T类型的对象进行排序，并将其作为第二个参数传递给我们的排序函数。</li></ol><h2 id="6fc0" class="jm jn hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">可比接口</h2><p id="40d3" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">以整数包装类为例。整数类实现可比较的接口。Comparable接口有一个称为compareTo()的方法。在Integer类中，它覆盖compareTo方法。它将当前对象与排序函数中传递的对象进行比较，我们称之为var1，当当前对象小于var1，当前对象等于var1，当前对象大于var1时，它分别返回-1，0，1。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="174b" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">Comparable Interface:<br/>public interface </strong>Comparable&lt;T&gt; {<br/>    <strong class="ji hj">int </strong>compareTo(T var1);<br/>}<br/>____________________________________________________________________</span><span id="756d" class="jm jn hi ji b fi ll jp l jq jr"><strong class="ji hj">Integer class:<br/>public int </strong>compareTo(Integer anotherInteger) {<br/>    <strong class="ji hj">return </strong>compare(<strong class="ji hj">this</strong>.value, anotherInteger.value);<br/>}<br/><br/><strong class="ji hj">public static int </strong>compare(<strong class="ji hj">int </strong>x, <strong class="ji hj">int </strong>y) {<br/>    <strong class="ji hj">return </strong>x &lt; y ? -1 : (x == y ? 0 : 1);<br/>}</span></pre><p id="cb83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，这意味着每当一个类实现Comparable接口时，它可以在compareTo函数中添加自己的逻辑，因此可以有自己的逻辑进行排序。</p><p id="300b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们想以不同于默认顺序的其他顺序对T类型的对象进行排序呢？为了解决这个问题，比较器应运而生。</p><h2 id="9161" class="jm jn hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">比较器接口</h2><p id="0fa3" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">当我们想要定义一个排序T类型的对象的顺序时，我们可以创建一个自定义的比较器，在排序List <t> list时，我们可以将它作为第二个参数传入Collections.sort()方法。</t></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="baa5" class="jm jn hi ji b fi jo jp l jq jr">@<strong class="ji hj">FunctionalInterface</strong><br/><strong class="ji hj">public interface </strong>Comparator&lt;T&gt; {<br/>    <strong class="ji hj">int </strong>compare(T var1, T var2);<br/>    ...<br/>}</span></pre><p id="ab26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比较器是一个功能接口。<br/><em class="jv">Java中的一个</em> <strong class="ih hj"> <em class="jv">函数接口</em> </strong> <em class="jv">是一个</em> <strong class="ih hj"> <em class="jv">接口</em> </strong> <em class="jv">只包含一个抽象(未实现)方法。一个</em> <strong class="ih hj"> <em class="jv">函数接口</em> </strong> <em class="jv">除了单个未实现的方法之外，还可以包含有实现的默认和静态方法。</em></p><p id="2a64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Comparator接口有一个名为compare()的抽象方法。它比较两个对象T1和T2，在大多数实现中，当T1 <t2 when="" t1="=T2" and=""> T2时，通常分别返回-1，0，1。</t2></p><p id="dc71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例说明了在按升序对T类型的对象进行排序时使用比较器接口。</p><p id="1f01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设对象T有以下两个属性:dataLimit和dataUsed，两者都是整数类型。</p><h2 id="2b49" class="jm jn hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">在函数参数中定义比较器</h2><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="f893" class="jm jn hi ji b fi jo jp l jq jr">Collections.<em class="jv">sort</em>(list, <strong class="ji hj">new </strong>Comparator&lt;T&gt;() {<br/>    <em class="jv">//Sort based on ascending order of dataLimit<br/>    </em>@Override<br/>    <strong class="ji hj">public int </strong>compare(T obj1, T obj2) {<br/>        <strong class="ji hj">return obj1.getDataLimit()-obj2.getDataLimit();</strong><br/>    }<br/>});</span></pre><h2 id="0bda" class="jm jn hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">在外部定义比较器，并在函数的参数中传递它的对象</h2><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e91e" class="jm jn hi ji b fi jo jp l jq jr">Comparator&lt;T&gt; CustomComparator= <strong class="ji hj">new </strong>Comparator&lt;T&gt;() {<br/>    @Override<br/>    <strong class="ji hj">public int </strong>compare(T o1, T o2) {<br/>        return <strong class="ji hj">o1.getDataLimit()-o2.getDataLimit();</strong><br/>    }<br/>};<br/>Collections.<em class="jv">sort</em>(list, CustomComparator);</span></pre><h2 id="a8ae" class="jm jn hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">将lambda表达式与构造函数一起使用</h2><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="2b96" class="jm jn hi ji b fi jo jp l jq jr">list.sort((T o1, T o2) -&gt; <!-- -->o1.getDataLimit()-o2.getDataLimit()<!-- -->);</span><span id="b552" class="jm jn hi ji b fi ll jp l jq jr">or</span><span id="7858" class="jm jn hi ji b fi ll jp l jq jr">Comparator&lt;T&gt; <!-- -->CustomComparator<!-- --> = (o1, o2)-&gt; <!-- -->o1.getDataLimit()-o2.getDataLimit()<!-- -->;<br/>list.sort(<!-- -->CustomComparator<!-- -->);</span></pre><p id="ab35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按降序排序:此函数<strong class="ih hj"> reversed() </strong>可通过函数链接与任何比较器一起使用，以将排序逻辑改为逆序。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="3e51" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">default </strong>Comparator&lt;T&gt; reversed() {<br/>    <strong class="ji hj">return </strong>Collections.reverseOrder(<strong class="ji hj">this</strong>);<br/>}<br/></span><span id="5e9e" class="jm jn hi ji b fi ll jp l jq jr">Comparator&lt;T&gt; <!-- -->CustomComparator<!-- --> = (o1, o2)-&gt; <!-- -->o1.getDataLimit()-o2.getDataLimit()<!-- -->;<br/>list.sort(<!-- -->CustomComparator<!-- -->.reversed());</span></pre><p id="913d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以探索comparable和Comparator接口的更多方法，并通过深入研究包装类来理解它的工作原理。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="7d1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">伙计们，我真的希望你觉得这篇文章有价值！如果你还有任何疑问，你可以在下面的评论区讨论。</p><p id="37ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非常感谢你花时间写这个博客。</p><p id="86e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请分享给你的同事，并鼓掌表示赞赏！:)</p></div></div>    
</body>
</html>