<html>
<head>
<title>Basic Neural Network using PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTorch的基本神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/basic-ann-using-pytorch-d4443f1c936c?source=collection_archive---------14-----------------------#2020-06-21">https://medium.com/analytics-vidhya/basic-ann-using-pytorch-d4443f1c936c?source=collection_archive---------14-----------------------#2020-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5fd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PyTorch作为一个框架有很多可以提供的，用最少的代码行我们可以实现很多。你可以建立任何你喜欢的神经网络。如果你知道前向传播和后向传播背后的理论，你可以理解从头开始写它将是一个相当的体验。但肯定不是用PyTorch，只需几行代码就可以了。</p><p id="150c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于正向传播[我将详细介绍并解释]</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/bfb70a838a4ba4dbc2c6712d924929b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rW2s5oVWasj03LJ6RcXkpA.png"/></div></div></figure><p id="5661" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用于反向传播</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jp"><img src="../Images/5289ede87014112119ee5658bb72fc2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxxk-vMal3YxhiOdrfWpBQ.png"/></div></div></figure><p id="a7c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从机器学习的hello world示例开始，即虹膜数据集。数据可以从下面的链接下载。</p><div class="jq jr ez fb js jt"><a href="https://www.kaggle.com/uciml/iris" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">鸢尾属物种</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">在这个经典数据集中，将鸢尾属植物分为三个种类</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">www.kaggle.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh jn jt"/></div></div></a></div><p id="b241" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为第一步，我们将借助matplotlib以图形格式分析数据。我已经提到了用于绘制图形的代码。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/87dc53510ade6ebfceca65abdffa2483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fpMok11wW10Hm_-Mh2E7mg.png"/></div></div></figure><p id="b954" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从图表中可以很容易地将它与其他两个类别区分开来。</p><p id="7624" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">绘制图形的代码可以从这里下载</p><div class="jq jr ez fb js jt"><a href="https://github.com/nirmal1067/PyTorchExamples/blob/master/DrawInputDataGraph" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">nirmal 1067/pytorchesamples</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">Permalink GitHub是5000多万开发人员的家园，他们一起工作来托管和审查代码、管理项目以及…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">github.com</p></div></div><div class="kc l"><div class="kj l ke kf kg kc kh jn jt"/></div></div></a></div><p id="5803" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是神经网络的代码。我将系统地详细介绍它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kk"><img src="../Images/9ad4f59a5181a8036ceec1725ad46972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8l-XdBikURO9wzIaYknGGQ.png"/></div></div></figure><p id="e0c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码可以在下面的链接中查看。</p><div class="jq jr ez fb js jt"><a href="https://github.com/nirmal1067/PyTorchExamples/blob/master/FFNeuralNetwork.py" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">nirmal 1067/pytorchesamples</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">在GitHub上创建一个帐户，为nirmal 1067/pytorchesamples的开发做出贡献。</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">github.com</p></div></div><div class="kc l"><div class="kl l ke kf kg kc kh jn jt"/></div></div></a></div><p id="3bea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先定义类扩展神经网络。模块。在构造函数中，我传递输入特征的数量，在iris的情况下可能的输出是3，hiddenlayer1中的神经元数量和hiddenlayer2中的神经元数量。你可以在hiddenlayer中选择不同数量的神经元。通常，该参数是基于超参数优化来选择的。我选择了ADAM优化器和交叉熵作为损失函数。请检查下面的代码，它不言自明，一切都是由PyTorch提供的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es km"><img src="../Images/dc4432ae3bd1ac514b869a1d4c49430c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GpQM4fM9Zb35OibpOOk6IA.png"/></div></div></figure><p id="0b58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前向传播中，我只是使用Relu作为激活函数，将一层的输出传递到另一层，直到它到达输出层，这是预测值。由于PyTorch，看起来很简单。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kn"><img src="../Images/f740efbb68475b90877cabf9de8f0d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVY9XF0LVgtghKMfayeypQ.png"/></div></div></figure><p id="3dad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在训练方法中，我使用内置特性进行反向传播。默认情况下，这里使用的历元数是100。这就是神奇发生的地方向后()利用微分链法则求梯度。step()方法根据学习率调整神经元的权重，记住学习率0.01已经用于初始化构造函数中的优化器。zero_grad()将在每次迭代中停止复合。drawGD方法简单地绘制了epoch与loss的关系。如果你想知道你的模型损失相对于每个时期是如何改善的，这是很有帮助的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ko"><img src="../Images/bc11c1c8c7502af0f8b81d80efe8b766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bdYL9hW-nT9hjiKCkWjXsw.png"/></div></div></figure><p id="bc36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了打印模型的偏差和权重，使用下面的方法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kp"><img src="../Images/33ba5aa36b768f9cfd6bf9c9aa749a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ic_n_PzFRpNz-hDcLExFyw.png"/></div></div></figure><p id="81b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您最初调用此方法时，它显示默认值。如下图所示，</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kq"><img src="../Images/f94f5f80ae5ac7a711fd054d449cf85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIZgWjznHWd8Kwt5tdgxvA.png"/></div></div></figure><p id="4c20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是使用数据训练模型的时候了。如下图所示，我首先使用pandas加载数据，然后执行数据清理以区分输入和输出[请参考代码中的注释]。然后，我使用scikitlearn的测试训练分割方法分割数据，并为其提供我们模型的训练方法。因为我们已经通过了训练方法。它封装了反向传播并绘制了损耗与时间关系图。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kr"><img src="../Images/34ea359f779b106c109ef568a2800101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuBHeqc_06NPnlsey8UYRg.png"/></div></div></figure><p id="6624" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完整的代码在下面的链接。</p><div class="jq jr ez fb js jt"><a href="https://github.com/nirmal1067/PyTorchExamples" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">nirmal 1067/pytorchesamples</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">在GitHub上创建一个帐户，为nirmal 1067/pytorchesamples的开发做出贡献。</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">github.com</p></div></div><div class="kc l"><div class="ks l ke kf kg kc kh jn jt"/></div></div></a></div></div></div>    
</body>
</html>