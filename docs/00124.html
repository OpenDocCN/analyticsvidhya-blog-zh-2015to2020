<html>
<head>
<title>A Multivariate Time Series Guide to Forecasting and Modeling (with Python codes)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测和建模的多元时间序列指南(带Python代码)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-multivariate-time-series-guide-to-forecasting-and-modeling-with-python-codes-8733b5fd1a56?source=collection_archive---------0-----------------------#2018-09-27">https://medium.com/analytics-vidhya/a-multivariate-time-series-guide-to-forecasting-and-modeling-with-python-codes-8733b5fd1a56?source=collection_archive---------0-----------------------#2018-09-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="56f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">时间是决定一个企业兴衰的最关键因素。这就是为什么我们看到商店和电子商务平台的销售与节日保持一致。这些企业分析多年的支出数据，以了解打开大门的最佳时机，并看到消费者支出的增加。</p><p id="29d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，作为一名数据科学家，您如何执行这种分析呢？别担心，你不需要建造时间机器！时间序列建模是一种强大的技术，可以作为理解和预测趋势和模式的途径。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a0e11c2719c59b867f2254f79c8cb72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vFyUo3ypczKNkXbY.jpg"/></div></div></figure><p id="abca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是即使是时间序列模型也有不同的方面。我们在网上看到的大多数例子都是关于单变量时间序列的。不幸的是，现实世界的用例并不是这样工作的。有多个变量在起作用，同时处理所有这些变量是数据科学家的价值所在。</p><p id="5cca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将了解什么是多元时间序列，以及如何处理它。我们还将进行一个案例研究，并用Python实现它，让您对这个主题有一个实际的理解。</p><h1 id="89df" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">目录</h1><ol class=""><li id="da81" class="kn ko hi ih b ii kp im kq iq kr iu ks iy kt jc ku kv kw kx bi translated">单变量与多变量时间序列<br/> 1.1单变量时间序列<br/> 1.2多变量时间序列</li><li id="01e8" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">处理多元时间序列——向量自回归(VAR)</li><li id="524d" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">我们为什么需要VAR？</li><li id="eb8e" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">多元时间序列的平稳性</li><li id="108a" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">训练-验证分割</li><li id="d3ee" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">Python实现</li></ol><h1 id="55c7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.单变量与多变量时间序列</h1><p id="2880" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">本文假设读者对单变量时间序列、它的性质和用于预测的各种技术有一定的了解。由于本文将重点关注多变量时间序列，我建议您浏览以下文章，它们是对单变量时间序列的很好介绍:</p><ul class=""><li id="0b2e" class="kn ko hi ih b ii ij im in iq lg iu lh iy li jc lj kv kw kx bi translated"><a class="ae lk" href="https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/" rel="noopener ugc nofollow" target="_blank">创建时间序列预测综合指南</a></li><li id="6f98" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc lj kv kw kx bi translated"><a class="ae lk" href="https://www.analyticsvidhya.com/blog/2018/08/auto-arima-time-series-modeling-python-r/" rel="noopener ugc nofollow" target="_blank">使用Auto Arima </a>构建高性能时间序列模型</li></ul><p id="0369" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，在详细讨论多变量时间序列之前，我将快速回顾一下什么是单变量时间序列。让我们一个一个来看，了解其中的区别。</p><h1 id="2d79" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.1单变量时间序列</h1><p id="9ea2" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">单变量时间序列，顾名思义，就是有单一时间相关变量的序列。</p><p id="ef70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，看看下面的样本数据集，它包含过去两年的温度值(每小时)。这里，温度是因变量(依赖于时间)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ll"><img src="../Images/4fb605c4f5b20cc595cceda99a0d1e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/0*fOD-q4qPsXylwYOI.png"/></div></figure><p id="f53d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们被要求预测未来几天的温度，我们将查看过去的值，并尝试测量和提取一个模式。我们会注意到温度在早上和晚上较低，而在下午达到峰值。此外，如果你有过去几年的数据，你会发现11月至1月期间天气较冷，而4月至6月相对较热。</p><p id="fe1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样的观察将有助于我们预测未来的价值。你是否注意到我们只使用了一个变量(过去两年的温度)？因此，这被称为单变量时间序列分析/预测。</p><h1 id="8951" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.2多元时间序列</h1><p id="ff0e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">多元时间序列有多个时间相关变量。每个变量不仅依赖于它过去的值，还依赖于其他变量。这种相关性用于预测未来值。听起来很复杂？让我解释一下。</p><p id="9d72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑上面的例子。现在假设我们的数据集包括排汗百分比、露点、风速、云量百分比等。以及过去两年的温度值。在这种情况下，需要考虑多个变量来优化温度预测。像这样的序列属于多元时间序列的范畴。下面是对此的说明:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lm"><img src="../Images/bf04434e98db6df894c2c6aeaaeac9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/0*64ePPjtd02FCx3ej.png"/></div></figure><p id="1049" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们已经了解了多元时间序列是什么样的，那么让我们来了解如何使用它来建立预测。</p><h1 id="9022" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.处理多元时间序列——VAR</h1><p id="12a7" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">在本节中，我将向您介绍多元时间序列预测最常用的方法之一— <strong class="ih hj">向量自回归(VAR) </strong>。</p><p id="ce9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在VAR模型中，每个变量都是其自身和所有其他变量的过去值的线性函数。为了更好地解释这一点，我将使用一个简单的可视化示例:</p><p id="9b56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有两个变量，y1和y2。我们需要根据过去n个值的给定数据，预测这两个变量在时间t的值。为简单起见，我认为滞后值为1。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ln"><img src="../Images/67af474c9f30cfb43d0d053b6863d906.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/0*gi6bRNwmdeelsr69.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lo"><img src="../Images/26ffa384f474fdce859e03f9d0936f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/format:webp/0*YrRnPdtgGMqM4xx-.png"/></div></figure><p id="0102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了计算y1(t)，我们将使用y1和y2的过去值。类似地，为了计算y2(t ),将使用y1和y2的过去值。下面是表示这种关系的简单数学方法:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lp"><img src="../Images/ba92b2564224b13f860ea23a5f9946c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/0*cbgBlBfbFmV7Ebs9.gif"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lp"><img src="../Images/846ed5acbe37358fefe6b9a1c670d026.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/0*cVjnGJd73x11DfQD.gif"/></div></figure><p id="8404" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，</p><ul class=""><li id="79d6" class="kn ko hi ih b ii ij im in iq lg iu lh iy li jc lj kv kw kx bi translated">a1和a2是常数项，</li><li id="4d65" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc lj kv kw kx bi translated">w11、w12、w21和w22是系数，</li><li id="cd3d" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc lj kv kw kx bi translated">e1和e2是误差项</li></ul><p id="3d8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些方程类似于ar过程的方程。由于AR过程用于单变量时间序列数据，因此未来值只是其过去值的线性组合。考虑AR(1)过程:</p><p id="945a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lq"> y(t) = a + w*y(t-1) +e </em></p><p id="9faa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们只有一个变量——y、一个常数项——a、一个误差项——e和一个系数——w，为了在VAR的每个方程中包含多个变量项，我们将使用向量。我们可以将等式(1)和(2)写成以下形式:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lr"><img src="../Images/8d9bbb8d22b6d14a93c157d39262a318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/0*gFH5ywQF8ethFrtT.png"/></div></figure><p id="bf99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个变量是y1和y2，后面是常数、系数度量、滞后值和误差度量。这是VAR(1)过程的向量方程。对于VAR(2)过程，另一个时间向量项(t-2)将被添加到等式中，以推广p滞后:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ls"><img src="../Images/9a5c40a461edf75e5641ddbe31237474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*efEgMOCEdnorkW42.png"/></div></div></figure><p id="6684" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的等式表示变量为y1，y2 …yk的VAR(p)过程。同样可以写成:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lt"><img src="../Images/6fd70a57e5f74ad07c6a8012005040f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/0*hCoYM0-mbSmwybO_.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/206913327a30eb9e51332917e3670940.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/0*PUZOqjYeeh4R-KoB.gif"/></div></figure><p id="1fa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">方程中的εt项代表多元矢量白噪声。对于多元时间序列，εt应该是满足以下条件的连续随机向量:</p><ol class=""><li id="deff" class="kn ko hi ih b ii ij im in iq lg iu lh iy li jc ku kv kw kx bi translated">E(εt) = 0 <br/>误差向量的期望值为0</li><li id="b161" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">E(εt1，εT2 ')=σ12<br/>εt的期望值，εt '是数列的标准差</li></ol><h1 id="9559" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.我们为什么需要VAR？</h1><p id="4fe3" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">回想一下我们之前看到的气温预测的例子。可以提出一个论点，把它当作一个多单变量序列。我们可以使用AR等简单的单变量预测方法来解决这个问题。由于目标是预测温度，我们可以简单地移除其他变量(除了温度)并在剩余的单变量序列上拟合一个模型。</p><p id="8e7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个简单的想法是使用我们已知的技术分别预测每个序列的值。这将使工作变得非常简单！那你为什么要学习另一种预测技术呢？这个话题还不够复杂吗？</p><p id="081f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的等式(1)和(2)可以清楚地看出，每个变量都在使用每个变量的过去值来进行预测。与AR不同，<strong class="ih hj"> VAR能够理解和利用几个变量之间的关系</strong>。这有助于描述数据的动态行为，并提供更好的预测结果。此外，实现VAR与使用任何其他单变量技术一样简单(您将在最后一节中看到)。</p><h1 id="0717" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">4.多元时间序列的平稳性</h1><p id="8e48" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">通过研究单变量概念，我们知道平稳的时间序列通常会给我们一个更好的预测集。如果你不熟悉平稳性的概念，请先通读这篇文章:<a class="ae lk" href="https://www.analyticsvidhya.com/blog/2018/09/non-stationary-time-series-python/" rel="noopener ugc nofollow" target="_blank">处理非平稳时间序列的温和介绍</a>。</p><p id="900d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总而言之，对于给定的单变量时间序列:</p><p id="18d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lq"> y(t) = c*y(t-1) + ε t </em></p><p id="dc79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">若|c| &lt; 1. Now, recall the equation of our VAR process:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lv"><img src="../Images/fe90d1bee62de4a63eb2059d2933d2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/0*moPQTR3b2fvtblkb.gif"/></div></figure><p id="64c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lq">的值为，则称该数列为平稳数列注:I为单位矩阵。</em></p><p id="1c56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用<a class="ae lk" href="https://ocw.mit.edu/courses/economics/14-384-time-series-analysis-fall-2013/lecture-notes/MIT14_384F13_lec1.pdf" rel="noopener ugc nofollow" target="_blank">滞后算子</a>表示方程，我们有:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lw"><img src="../Images/199f707ff99b11b9d997e6416e49321a.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/0*eEViLO-5Vdvx4Gvm.gif"/></div></figure><p id="fe03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">取左侧的所有y(t)项:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lx"><img src="../Images/e1399990ff7727d8409af34898fae4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/0*kozPaNjCrv8sk9yy.gif"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/ac1ae1d17faeb8df62aa0d5f146aef51.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/0*Qa0Viq34-ZF6SSyD.gif"/></div></figure><p id="d31c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">y(t)的系数称为滞后多项式。</strong>让我们将此表示为φ(L):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ly"><img src="../Images/9e0f26b7f8f78527638618d249a6cf50.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/0*2Avl_gaBAKkUb2DK.gif"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lz"><img src="../Images/82726cbb343073ef687682aa4d2e25c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/0*ycsa12GWLed90D6P.gif"/></div></figure><p id="1b8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于平稳的级数，|φ(L)-1 |的特征值在模中应小于1。考虑到推导过程中变量的数量，这可能看起来很复杂。在下面的视频中，我们用一个简单的数字例子解释了这个想法。我强烈建议观看它来巩固你的理解:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="9093" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似于单变量序列的增强Dickey-Fuller检验，我们有Johansen检验来检查任何多变量时间序列数据的平稳性。我们将在本文的最后一节看到如何执行测试。</p><h1 id="770c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">5.训练-验证分割</h1><p id="9db6" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">如果您以前处理过单变量时间序列数据，您会知道训练验证集。创建验证集的目的是在使用模型进行预测之前分析模型的性能。</p><p id="9298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为时间序列问题创建一个验证集是很棘手的，因为我们必须考虑时间因素。不能直接使用<em class="lq"> train_test_split </em>或<em class="lq"> k倍</em>验证，因为这将破坏系列中的模式。创建验证集时应考虑日期和时间值。</p><p id="c58b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们必须预测气温、露点、云量等。在接下来的两个月里使用过去两年的数据。一种可能的方法是将最后两个月的数据放在一边，并在剩余的22个月中训练模型。</p><p id="67a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦模型经过训练，我们就可以用它来对验证集进行预测。基于这些预测和实际值，我们可以检查模型的表现如何，以及模型表现不佳的变量。为了进行最终预测，请使用完整的数据集(组合训练集和验证集)。</p><h1 id="d108" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">6.Python实现</h1><p id="cba0" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">在本节中，我们将在玩具数据集上实现向量AR模型。我为此使用了空气质量数据集，你可以从<a class="ae lk" href="https://archive.ics.uci.edu/ml/datasets/Air+Quality" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="110e" class="mh jq hi md b fi mi mj l mk ml">#import required packages<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/><br/>#read the data<br/>df = pd.read_csv("AirQualityUCI.csv", parse_dates=[['Date', 'Time']])<br/><br/>#check the dtypes<br/>df.dtypes</span><span id="5b58" class="mh jq hi md b fi mm mj l mk ml">Date_Time        object<br/>CO(GT)            int64<br/>PT08.S1(CO)       int64<br/>NMHC(GT)          int64<br/>C6H6(GT)          int64<br/>PT08.S2(NMHC)     int64<br/>NOx(GT)           int64<br/>PT08.S3(NOx)      int64<br/>NO2(GT)           int64<br/>PT08.S4(NO2)      int64<br/>PT08.S5(O3)       int64<br/>T                 int64<br/>RH                int64<br/>AH                int64<br/>dtype: object</span></pre><p id="0847" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lq">日期时间</em>列的数据类型是<em class="lq">对象</em>，我们需要将其更改为<em class="lq">日期时间</em>。此外，为了准备数据，我们需要索引具有<em class="lq">日期时间</em>。遵循以下命令:</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="3f79" class="mh jq hi md b fi mi mj l mk ml">df['Date_Time'] = pd.to_datetime(df.Date_Time , format = '%d/%m/%Y %H.%M.%S')<br/>data = df.drop(['Date_Time'], axis=1)<br/>data.index = df.Date_Time</span></pre><p id="9524" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是处理丢失的值。由于数据中缺失的值被替换为值-200，我们将不得不用一个更好的数字来估算缺失的值。考虑到这一点——如果当前露点值缺失，我们可以有把握地假设它将接近前一小时的值。有道理，对吧？在这里，我将用以前的值估算-200。</p><p id="7430" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以选择使用之前几个值的平均值替换该值，或者使用前一天同一时间的值(您可以在下面的评论部分分享您对输入缺失值的想法)。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="2bb0" class="mh jq hi md b fi mi mj l mk ml">#missing value treatment<br/>cols = data.columns<br/>for j in cols:<br/>    for i in range(0,len(data)):<br/>       if data[j][i] == -200:<br/>           data[j][i] = data[j][i-1]<br/><br/>#checking stationarity<br/>from statsmodels.tsa.vector_ar.vecm import coint_johansen<br/>#since the test works for only 12 variables, I have randomly dropped<br/>#in the next iteration, I would drop another and check the eigenvalues<br/>johan_test_temp = data.drop([ 'CO(GT)'], axis=1)<br/>coint_johansen(johan_test_temp,-1,1).eig</span></pre><p id="1fcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是测试的结果:</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="7810" class="mh jq hi md b fi mi mj l mk ml">array([ 0.17806667,  0.1552133 ,  0.1274826 ,  0.12277888,  0.09554265,<br/>        0.08383711,  0.07246919,  0.06337852,  0.04051374,  0.02652395,<br/>        0.01467492,  0.00051835])</span></pre><p id="03da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以继续创建适合模型的验证集，并测试模型的性能:</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="52c9" class="mh jq hi md b fi mi mj l mk ml">#creating the train and validation set<br/>train = data[:int(0.8*(len(data)))]<br/>valid = data[int(0.8*(len(data))):]<br/><br/>#fit the model<br/>from statsmodels.tsa.vector_ar.var_model import VAR<br/><br/>model = VAR(endog=train)<br/>model_fit = model.fit()<br/><br/># make prediction on validation<br/>prediction = model_fit.forecast(model_fit.y, steps=len(valid))</span></pre><p id="8603" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预测以数组的形式出现，其中每个列表代表该行的预测。我们将把它转换成一种更好看的格式。</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="fd31" class="mh jq hi md b fi mi mj l mk ml">#converting predictions to dataframe<br/>pred = pd.DataFrame(index=range(0,len(prediction)),columns=[cols])<br/>for j in range(0,13):<br/>    for i in range(0, len(prediction)):<br/>       pred.iloc[i][j] = prediction[i][j]<br/><br/>#check rmse<br/>for i in cols:<br/>    print('rmse value for', i, 'is : ', sqrt(mean_squared_error(pred[i], valid[i])))</span></pre><p id="aa41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面代码的输出:</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="a545" class="mh jq hi md b fi mi mj l mk ml">rmse value for CO(GT) is :  1.4200393103392812<br/>rmse value for PT08.S1(CO) is :  303.3909208229375<br/>rmse value for NMHC(GT) is :  204.0662895081472<br/>rmse value for C6H6(GT) is :  28.153391799471244<br/>rmse value for PT08.S2(NMHC) is :  6.538063846286176<br/>rmse value for NOx(GT) is :  265.04913993413805<br/>rmse value for PT08.S3(NOx) is :  250.7673347152554<br/>rmse value for NO2(GT) is :  238.92642219826683<br/>rmse value for PT08.S4(NO2) is :  247.50612831072633<br/>rmse value for PT08.S5(O3) is :  392.3129907890131<br/>rmse value for T is :  383.1344361254454<br/>rmse value for RH is :  506.5847387424092<br/>rmse value for AH is :  8.139735443605728</span></pre><p id="916b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在对验证集进行测试之后，让我们在完整的数据集上拟合模型</p><pre class="je jf jg jh fd mc md me mf aw mg bi"><span id="cf67" class="mh jq hi md b fi mi mj l mk ml">#make final predictions<br/>model = VAR(endog=data)<br/>model_fit = model.fit()<br/>yhat = model_fit.forecast(model_fit.y, steps=1)<br/>print(yhat)</span></pre><h1 id="3fee" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结束注释</h1><p id="f03d" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">在我开始这篇文章之前，处理多变量时间序列的想法在其范围内似乎令人生畏。这是一个复杂的话题，所以要花时间了解细节。最好的学习方法是实践，所以我希望上面的Python实现对你有用。</p><p id="f2f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我建议你在自己选择的数据集上使用这种方法。这将进一步巩固你对这个复杂却非常有用的话题的理解。如果你有任何建议或疑问，请在评论区分享。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="8325" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lq">原载于2018年9月27日</em><a class="ae lk" href="https://www.analyticsvidhya.com/blog/2018/09/multivariate-time-series-guide-forecasting-modeling-python-codes/" rel="noopener ugc nofollow" target="_blank"><em class="lq">【www.analyticsvidhya.com】</em></a><em class="lq">。</em></p></div></div>    
</body>
</html>