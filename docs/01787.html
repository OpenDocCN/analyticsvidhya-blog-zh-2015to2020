<html>
<head>
<title>Ruby Enumerables: The 8th Wonder of the World</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">红宝石计数:世界第八大奇迹</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/ruby-enumerables-8th-wonder-of-the-world-c266960bd178?source=collection_archive---------14-----------------------#2019-11-13">https://medium.com/analytics-vidhya/ruby-enumerables-8th-wonder-of-the-world-c266960bd178?source=collection_archive---------14-----------------------#2019-11-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/0cb8ab33fdab74074d7e1f6efd23bb34.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*kogME9jE7YblUd9ArGvQQA.jpeg"/></div></figure><p id="af91" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我第一次学习Ruby的时候，没有什么比辨别使用哪个枚举更让我焦虑的了。就在我以为自己掌握了窍门的时候，可数的神扇了我一巴掌，当着我的面笑了。</p><p id="90a0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了平息我的不安并弄清这个难以捉摸的话题，我决定把事情分解开来，从实际的单词本身开始。据<a class="ae jk" href="https://www.merriam-webster.com/dictionary/enumerate" rel="noopener ugc nofollow" target="_blank">韦氏词典</a>:</p><blockquote class="jl jm jn"><p id="b88b" class="im in jo io b ip iq ir is it iu iv iw jp iy iz ja jq jc jd je jr jg jh ji jj hb bi translated"><strong class="io hj">列举:</strong>①确定数量，或计数；(2)依次指定，或列出</p></blockquote><p id="307b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最简单的方法是，枚举器检查数组或散列中的每个元素，以确定<em class="jo"> </em>是否满足代码块中指定的标准。如果该元素满足标准，则该元素是输出的目标。但是，输出由所使用的特定可枚举数决定，因为它们的行为各不相同。</p><p id="4161" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来的内容是初学者试图解释一些常见的方法——每个方法、映射方法、查找方法和选择方法——是如何作为可枚举的方法来分析和输出数组中的元素的(为了简单起见，我在本文中主要关注数组)。</p><h1 id="86c7" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">#每个</strong></h1><p id="ca4f" class="pw-post-body-paragraph im in hi io b ip kq ir is it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj hb bi translated">本质上，#each是一个泛型方法，它将代码块应用于数组中的每个元素。让我们看一个例子:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="d848" class="le jt hi la b fi lf lg l lh li">numbers = [100, 200, 300]<br/>numbers.each do |n|<br/>text = "I want #{n} pieces of chocolate!"<br/>puts text<br/>end</span></pre><p id="d268" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们有一组数字:[100，200，300]。在下一行，我使用#each遍历数组中的所有三个元素，一次一个。我使用“n”作为我的代码块变量，当它被传递到输出的句子中时，通过它对每个数字进行插值。结果是:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="e702" class="le jt hi la b fi lf lg l lh li">I want 100 pieces of chocolate!<br/>I want 200 pieces of chocolate!<br/>I want 300 pieces of chocolate!</span></pre><p id="cd90" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与其他枚举不同，#each不收集通过代码块运行数组项的结果。在上面的例子中，除了在输出语句中包含插入的数字之外，没有指示enumerable的工作结果是什么。</p><p id="28c4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同样，#each是这些方法中最简单的。想来点更刺激的吗？请继续阅读…</p><h1 id="c0df" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">#地图</strong></h1><p id="7ca0" class="pw-post-body-paragraph im in hi io b ip kq ir is it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj hb bi translated">我花了一点时间才完全理解这个，因为这个名字，至少在我看来，并没有反映出它的功能。当应用于一个数组时，#map返回一个新数组，该数组包含与原始数组中相同数量的元素，但是原始元素在作为参数通过代码块后以某种方式被改变了。换句话说，#map以一对一的转换方式更改原始数组—数组长度相同，但每个元素都进行了转换。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="1bde" class="le jt hi la b fi lf lg l lh li">numbers = [10, 20, 30]<br/>numbers.map do |n|<br/>n * 10<br/>end</span></pre><p id="6176" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们从一组数字开始。使用#map迭代数组，数组中的每个元素都作为参数通过代码块传递。所以在每次迭代中，这段代码首先运行10 * 10，然后20 * 10，然后30 * 10。#map收集每次迭代的输出，并将它们放入一个新数组中:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="c559" class="le jt hi la b fi lf lg l lh li">=&gt; [100, 200, 300]</span></pre><p id="b00b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">原始数组有3个数字，输出数组也是如此。让我们试试另一个例子。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3f2e" class="le jt hi la b fi lf lg l lh li">fruits = ["apple", "banana", "strawberry"]<br/>fruits.map do |fruit|<br/>fruit.upcase<br/>end</span></pre><p id="03b4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这里，我希望#map返回一个数组，该数组包含原始数组中的相同元素，但返回的元素都是大写的。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="ea4d" class="le jt hi la b fi lf lg l lh li">=&gt; ["APPLE", "BANANA", "STRAWBERRY"]</span></pre><h1 id="73cb" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">#找到</strong></h1><p id="8be4" class="pw-post-body-paragraph im in hi io b ip kq ir is it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj hb bi translated">对我来说，#find仅仅根据它的名字就很容易理解。<a class="ae jk" href="https://ruby-doc.org/core-2.4.2/Enumerable.html#method-i-find" rel="noopener ugc nofollow" target="_blank"> Ruby文档</a>表明这个方法评估原始数组…等待它…<em class="jo">找到</em>代码块不为假的第一个实例。换句话说(为了避免双重否定)，它返回第一个在代码块中运行后证明为真的数组元素。这里有一个例子:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="2ad4" class="le jt hi la b fi lf lg l lh li">numbers = [1, 2, 3, 4, 5]<br/>numbers.find do |n|<br/>n.even?<br/>end</span><span id="4cc2" class="le jt hi la b fi lj lg l lh li">=&gt; 2</span></pre><p id="fd01" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">事情是这样的:从一个数字数组开始，我想找到第一个偶数。#find在numbers数组中一次搜索一个元素，以确定哪个元素是使代码块为真的第一个元素。它返回“2”并停在那里，因为#find只返回我们要求它查找的第一个匹配项。</p><p id="f64a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一个例子:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="30ca" class="le jt hi la b fi lf lg l lh li">fruits = ["apple", "banana", "orange", "raspberry", "strawberry"]<br/>fruits.find do |fruit|<br/>fruit.include?("berry")<br/>end</span></pre><p id="0384" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，我希望#find返回名称中包含“berry”的第一个元素(注意，该数组包含两个元素)。它以“苹果”开始，并继续前进，因为它是假的。“香蕉”也被折腾，因为它不含“浆果”。然而，一旦到达“raspberry ”,代码块就证明是真的。迭代器获取数组元素，得到如下结果:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="b858" class="le jt hi la b fi lf lg l lh li">=&gt; "raspberry"</span></pre><p id="7793" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为#find只返回第一个实例，所以我们的结果是有意义的。</p><h1 id="a13c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">#选择</strong></h1><p id="b2b4" class="pw-post-body-paragraph im in hi io b ip kq ir is it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj hb bi translated">最后，在这个简短但有意义的枚举之旅中，我们有#select。对一个初学者(也就是我)来说，#select和#find是另一组我无法搞清楚的枚举。毕竟，这些名字听起来非常相似。当我知道#select和#find_all是同义词时，我灵光一现。</p><p id="4ac1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我刚刚讨论了#find，它只查找并返回满足代码块的第一个单一实例。#select返回满足代码块的所有实例。使用上面的示例，但换入#select:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="89f6" class="le jt hi la b fi lf lg l lh li">numbers = [1, 2, 3, 4, 5]<br/>numbers.select do |n|<br/>n.even?<br/>end</span><span id="efc3" class="le jt hi la b fi lj lg l lh li">=&gt; [2, 4]</span></pre><p id="500d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用上面的第二个例子:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="d503" class="le jt hi la b fi lf lg l lh li">fruits = ["apple", "banana", "orange", "raspberry", "strawberry"]<br/>fruits.select do |fruit|<br/>fruit.include?("berry")<br/>end</span></pre><p id="12da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我想得到一份名字中含有“浆果”的水果清单。就像上面的#find一样，#select方法遍历水果数组，查看是否有任何数组元素包含“berry”。这一次，因为#select选取代码块为真的所有数组元素，所以结果数组包含“raspberry”和“strawberry”:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="eefe" class="le jt hi la b fi lf lg l lh li">=&gt; ["raspberry", "strawberry"]</span></pre><p id="c709" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我可以使用#find_all而不是#select，并且会得到相同的结果。</p><h1 id="efb6" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">最后</h1><p id="27d2" class="pw-post-body-paragraph im in hi io b ip kq ir is it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj hb bi translated">我从没想过我会这么说，但事实证明，可枚举数真的很有趣，可以做一些非常酷的事情。虽然本文只介绍了一些基本的枚举，但是还有很多其他的需要了解和掌握。</p></div></div>    
</body>
</html>