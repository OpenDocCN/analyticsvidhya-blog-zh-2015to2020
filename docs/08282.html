<html>
<head>
<title>fastai MultiLabel Classification using Kfold Cross Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kfold交叉验证的fastai多标签分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/fastai-multilabel-classification-using-kfold-cross-validation-706b5948e138?source=collection_archive---------20-----------------------#2020-07-23">https://medium.com/analytics-vidhya/fastai-multilabel-classification-using-kfold-cross-validation-706b5948e138?source=collection_archive---------20-----------------------#2020-07-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bbb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2020年7月18日</p><p id="95d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"># <strong class="ih hj"> Blog18 </strong></p><p id="604e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有任何反馈意见，我已经以Kaggle Public <a class="ae jd" href="https://www.kaggle.com/kirankamat/fastai-multilabel-classification-using-kfold-cv" rel="noopener ugc nofollow" target="_blank">笔记本</a>的身份写了这篇文章。</p><p id="03f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我考虑的问题是多标签分类。除了在每个图像中有多个标签之外，这个问题中的另一个挑战是存在罕见的类和不同类的组合。因此，在这种情况下，正常分割或随机分割不起作用，因为您可能最终会将罕见的案例放入验证集中，而您的模型将永远不会了解它们。scikit-learn中存在的分层也不具备处理多标记目标的能力。</p><p id="fe10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我特别选择了这个问题，因为我们可能会在途中学到一些技术，否则我们不会想到。</p><p id="c5bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">可能有更好或更简单的方法来进行kfold交叉验证，但我已经记住了如何使用fastai </strong>来实现它，所以如果你知道一些更好的方法，请发邮件或发推特给我，我会尝试实现并给你学分。</p><h1 id="dc80" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">安装所有必需的库</h1><p id="8250" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我正在使用fastai2，所以导入它。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="74b0" class="kq jf hi km b fi kr ks l kt ku">! pip install -q fastai2</span></pre><h1 id="4d1c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">交互效度分析</h1><p id="0210" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在我看来，交叉验证是通过n次折叠来最小化一次分裂的随机性的想法，每个折叠包含训练和验证分裂。你在每个折叠上训练模型，所以你有n个模型。然后你从所有模型中取平均预测值，这应该会给我们结果更多的信心。这些我们将在下面的代码中看到。我发现了迭代分层包，它为scikit-learn兼容的交叉验证器提供了多标签数据的分层。</p><p id="43a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我的看法</strong>:</p><p id="4438" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我看来，做一次右劈更重要，尤其是因为CV需要n倍的时间来训练。那我为什么要这么做？？</p><p id="5678" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想使用fastai的交叉验证来探索分类，我没有找到太多的资源来学习。所以如果我写这个博客，它可能会帮助人们。</p><p id="9d49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">fastai在他们的库中没有交叉验证分割，就像他们提供的其他函数一样工作。可能是因为交叉验证需要时间，所以可能没那么有用。</p><p id="bad2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是在这种情况下，我觉得使用fastai还是值得一试的。</p><p id="dcaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么什么是<strong class="ih hj">分层</strong>？？</p><p id="c78e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将数据分割成多个折叠可以由标准来控制，例如确保每个折叠具有相同比例的具有给定分类值(例如类结果值)的观察值。这被称为分层交叉验证</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4816" class="kq jf hi km b fi kr ks l kt ku">! pip install -q iterative-stratification</span><span id="d913" class="kq jf hi km b fi kv ks l kt ku">from fastai2.vision.all import * <br/>from iterstrat.ml_stratifiers import MultilabelStratifiedKFold</span></pre><p id="022e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的数据集对GANs来说是零——人类蛋白质分类在class jovian.ml主办的竞赛中</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="620f" class="kq jf hi km b fi kr ks l kt ku">path = Path('../input/jovian-pytorch-z2g/Human protein atlas')<br/><br/>train_df = pd.read_csv(path/'train.csv')<br/><br/>train_df['Image'] = train_df['Image'].apply(str) + ".png"<br/><br/>train_df['Image'] = "../input/jovian-pytorch-z2g/Human protein atlas/train/" + train_df['Image']<br/><br/>train_df.head()</span></pre><p id="57bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里使用的方法是，如果我们有一个名为fold的列，使用fold number来拆分数据会很有帮助。</p><p id="d1f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">fastai在数据块api中有IndexSplitter，所以这将是有帮助的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="561e" class="kq jf hi km b fi kr ks l kt ku">strat_kfold = MultilabelStratifiedKFold(n_splits=3, random_state=42, shuffle=True)<br/>train_df['fold'] = -1<br/>for i, (_, test_index) in enumerate(strat_kfold.split(train_df.Image.values, train_df.iloc[:,1:].values)):<br/>    train_df.iloc[test_index, -1] = i<br/>train_df.head()</span><span id="4772" class="kq jf hi km b fi kv ks l kt ku">train_df.fold.value_counts().plot.bar() ;</span></pre><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es kw"><img src="../Images/1729f12855f972bb600958e7c8dbafce.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/0*bBNBLIWCxADWczxv.png"/></div></figure><h1 id="19a1" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">数据块</h1><p id="7238" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在数据在dataframe中，并且也为交叉验证定义了折叠，我们将构建数据加载器，为此我们将使用datablock。</p><p id="7bb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想了解fastai数据块是如何实现的，请看我的博客系列<a class="ae jd" href="https://kirankamath.netlify.app/blog/fastais-datablock-api/" rel="noopener ugc nofollow" target="_blank">用数据块api </a>简化代码</p><p id="92ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建一个函数get_data来创建dataloader。</p><p id="3e15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">get_data使用fold来拆分数据，以便使用IndexSplitter进行交叉验证。对于多标签问题，与单标签相比，唯一要做的额外的事情是在块中添加多类别块，这就是fastai如何使它变得容易工作。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="39cd" class="kq jf hi km b fi kr ks l kt ku">def get_data(fold=0, size=224,bs=32):<br/>    return DataBlock(blocks=(ImageBlock,MultiCategoryBlock),<br/>                       get_x=ColReader(0),<br/>                       get_y=ColReader(1, label_delim=' '),<br/>                       splitter=IndexSplitter(train_df[train_df.fold == fold].index),<br/>                       item_tfms=[FlipItem(p=0.5),Resize(512,method='pad')],<br/>                   batch_tfms=[*aug_transforms(size=size,do_flip=True, flip_vert=True, max_rotate=180.0, max_lighting=0.6,max_warp=0.1, p_affine=0.75, p_lighting=0.75,xtra_tfms=[RandomErasing(p=0.5,sh=0.1, min_aspect=0.2,max_count=2)]),Normalize],<br/>                      ).dataloaders(train_df, bs=bs)</span></pre><h1 id="2f58" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">韵律学</h1><p id="cfff" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">由于这是一个多标签问题，普通的精度函数不起作用，所以我们有了accuracy_multi。fastai有这个，我们可以直接在指标中使用，但我想知道它是如何工作的，所以需要代码。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="ce64" class="kq jf hi km b fi kr ks l kt ku">def accuracy_multi(inp, targ, thresh=0.5, sigmoid=True):<br/>    "Compute accuracy when `inp` and `targ` are the same size."<br/>    if sigmoid: inp = inp.sigmoid()<br/>    return ((inp&gt;thresh)==targ.bool()).float().mean()</span></pre><p id="47ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">F_score是这次比赛的评估方式，所以用这个。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="63f8" class="kq jf hi km b fi kr ks l kt ku">def F_score(output, label, threshold=0.2, beta=1):<br/>    prob = output &gt; threshold<br/>    label = label &gt; threshold<br/><br/>    TP = (prob &amp; label).sum(1).float()<br/>    TN = ((~prob) &amp; (~label)).sum(1).float()<br/>    FP = (prob &amp; (~label)).sum(1).float()<br/>    FN = ((~prob) &amp; label).sum(1).float()<br/><br/>    precision = torch.mean(TP / (TP + FP + 1e-12))<br/>    recall = torch.mean(TP / (TP + FN + 1e-12))<br/>    F2 = (1 + beta**2) * precision * recall / (beta**2 * precision + recall + 1e-12)<br/>    return F2.mean(0)</span></pre><h1 id="39e8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">收集测试集</h1><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="ccd8" class="kq jf hi km b fi kr ks l kt ku">test_df = pd.read_csv('../input/jovian-pytorch-z2g/submission.csv')<br/>tstpng = test_df.copy()<br/>tstpng['Image'] = tstpng['Image'].apply(str) + ".png"<br/>tstpng['Image'] = "../input/jovian-pytorch-z2g/Human protein atlas/test/" + tstpng['Image']<br/>tstpng.head()</span></pre><h1 id="4425" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">培养</h1><p id="f229" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我使用了一种叫做mixup的技术，这是一种数据扩充技术。</p><p id="9005" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在fastai中，Mixup是回调，这个回调用于将MixUp数据增强应用到您的训练中。欲知详情，请阅读<a class="ae jd" href="http://dev.fast.ai/callback.mixup" rel="noopener ugc nofollow" target="_blank">本</a></p><p id="07dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我第一次尝试了这种方法，但是这种方法并没有改善我在这个问题上的结果。它通常在80个周期后提高准确度，但我已经训练了20个周期。所以没有它在准确性上没有区别。所以你可以忽略这个。</p><p id="e9c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是为了了解mixup是如何工作的，我将在博客上单独讨论这个问题，所以请关注我的twitter以获取更新。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="372f" class="kq jf hi km b fi kr ks l kt ku">mixup = MixUp(0.3)</span></pre><p id="c501" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">gc是垃圾收集</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2491" class="kq jf hi km b fi kr ks l kt ku">import gc</span></pre><p id="d7b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经创建了3个文件夹，我只是从一个特定的文件夹中获取数据，创建一个模型，添加指标，我使用了resnet34。这就是整个训练过程。我只是在每个褶皱上训练模型，并保存测试集的预测。</p><p id="a67b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用了一种叫做渐进调整大小的技术。</p><p id="aa16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很简单:用小图开始训练，用大图结束训练。使用小图像进行大部分epochs训练有助于训练更快完成。使用大图像完成训练使得最终的准确度高得多。这种方法被称为渐进式调整大小。</p><p id="ff1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们应该在调整图像大小后使用<code class="du la lb lc km b">fine_tune</code>方法，让我们的模型学会做一些与它以前学过的略有不同的事情。</p><p id="3f4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经使用了<code class="du la lb lc km b">cbs=EarlyStoppingCallback(monitor='valid_loss')</code>,这样模型就不会过度拟合。</p><p id="efd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将所有预测附加到列表中，以便我们以后使用。</p><p id="615d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经运行模型很少的时期来查看代码工作和显示结果，或者在中间停止模型(这花费了很多时间)</p><p id="c76b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个方法给了我<code class="du la lb lc km b">.77</code>的F_score和<code class="du la lb lc km b">&gt;91%</code>的精度，所以你可以试试。</p><p id="b398" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里的目的是写博客，并解释如何方法和代码如何工作。</p><p id="439d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果GPU内存不足，删除学习者并清空最后一行代码中的cuda缓存。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d4d9" class="kq jf hi km b fi kr ks l kt ku">all_preds = []<br/><br/>for i in range(3):<br/>    dls = get_data(i,256,64)<br/>    learn = cnn_learner(dls, resnet34, metrics=[partial(accuracy_multi, thresh=0.2),partial(F_score, threshold=0.2)],cbs=mixup).to_fp16()<br/>    learn.fit_one_cycle(10, cbs=EarlyStoppingCallback(monitor='valid_loss'))<br/>    learn.dls = get_data(i,512,32)<br/>    learn.fine_tune(10,cbs=EarlyStoppingCallback(monitor='valid_loss'))<br/>    tst_dl = learn.dls.test_dl(tstpng)<br/>    preds, _ = learn.get_preds(dl=tst_dl)<br/>    all_preds.append(preds)<br/>    del learn<br/>    torch.cuda.empty_cache()<br/>    gc.collect()</span></pre><p id="9379" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将存储在列表中的所有预测值进行堆叠，并对这些值进行平均。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0663" class="kq jf hi km b fi kr ks l kt ku">subm = pd.read_csv("../input/jovian-pytorch-z2g/submission.csv")<br/>preds = np.mean(np.stack(all_preds), axis=0)</span></pre><p id="805f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你应该有我们用vocab得到的标签列表。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="acd1" class="kq jf hi km b fi kr ks l kt ku">k = dls.vocab</span><span id="9e31" class="kq jf hi km b fi kv ks l kt ku">preds[0]</span></pre><p id="0935" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我发现阈值为0.2对我的代码很好。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0cc8" class="kq jf hi km b fi kr ks l kt ku">thresh=0.2<br/>labelled_preds = [' '.join([k[i] for i,p in enumerate(pred) if p &gt; thresh]) for pred in preds]</span></pre><p id="96f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么所有预测高于0.2的标签都是使用vocab的那个图像的标签。</p><p id="cd58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将它们放在标签栏中</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="6f88" class="kq jf hi km b fi kr ks l kt ku">test_df['Label']=labelled_preds</span></pre><p id="9956" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一步是向kaggle提交结果。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7e5f" class="kq jf hi km b fi kr ks l kt ku">test_df.to_csv( 'submission.csv' , index = False )</span></pre><p id="d454" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经写了Kaggle Public <a class="ae jd" href="https://www.kaggle.com/kirankamat/fastai-multilabel-classification-using-kfold-cv" rel="noopener ugc nofollow" target="_blank"> Notebook </a>如果你喜欢请投上一票。</p><p id="1173" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读:)</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="9cb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lk">原载于</em><a class="ae jd" href="https://kirankamath.netlify.app/blog/fastai-multilabel-classification-using-kfold-cross-validation/" rel="noopener ugc nofollow" target="_blank"><em class="lk">https://kirankamath . netlify . app</em></a><em class="lk">。</em></p></div></div>    
</body>
</html>