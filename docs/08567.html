<html>
<head>
<title>ML Refactoring Pt. 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ML 重构角。一</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/ml-refactoring-pt-1-fafcd482fff?source=collection_archive---------28-----------------------#2020-08-03">https://medium.com/analytics-vidhya/ml-refactoring-pt-1-fafcd482fff?source=collection_archive---------28-----------------------#2020-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="d469" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">我被 GPT 3 号的宣传所吸引，决定了解它。</p></blockquote><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/480d13add4e711e557cb7276d9de521c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ssrxwdv095nkE3wJhaLagg.png"/></div></div></figure><p id="40a5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi jw translated">他的第一步是联系我的一个好朋友 Haryo Akbarianto Wibowo，他对 NLP 很了解(去看看他的<a class="ae kf" rel="noopener" href="/@haryoaw"> medium </a>、<a class="ae kf" href="https://www.linkedin.com/in/haryoaw/" rel="noopener ugc nofollow" target="_blank"> linkedin </a>和<a class="ae kf" href="https://github.com/haryoa" rel="noopener ugc nofollow" target="_blank"> github </a> page，我不是开玩笑)去了解 GPT 3 号，他马上说</p><blockquote class="kg"><p id="8289" class="kh ki hi bd kj kk kl km kn ko kp jg dx translated">不要着急。了解如何先解决简单的问题，然后逐步解决。试着完成 pytorch nlp 教程。</p></blockquote><p id="d429" class="pw-post-body-paragraph ii ij hi il b im kq io ip iq kr is it jt ks iw ix ju kt ja jb jv ku je jf jg hb bi translated">老实说，整个对话比那要长得多，因为每次提到关于 nlp 的事情，他都显得过于热情。但无论如何，我同意他的观点，因为 pytorch 教程无疑是我计算机视觉之旅中最有影响力的教程。</p><p id="1ef1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">我选择的第一个教程是《从头开始的自然语言处理:用字符级的 RNN 对名字进行分类》,因为这是所有教程中最简单的</p><div class="kv kw ez fb kx ky"><a href="https://pytorch.org/tutorials/intermediate/char_rnn_classification_tutorial.html" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hj fi z dy ld ea eb le ed ef hh bi translated">从零开始的自然语言处理:用字符级的 RNN 分类名字</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">编辑描述</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">pytorch.org</p></div></div></div></a></div><p id="36cc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">但是在快速浏览之后，我的工程师感觉很兴奋，发现了一些可以改进的地方。是的，我完全意识到最初的教程是为特定的目的服务的，那就是展示如何为分类目的创建基本的 RNN 网络，但是这篇文章是为另一个目的服务的，那就是分享我关于重构 ML 代码的知识。坦率地说，我没有发现很多人谈论这个，但这有点好笑，因为这是我在工作中主要做的事情。</p><p id="05a8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">那么我们为什么要重构呢？</p><ol class=""><li id="239b" class="lh li hi il b im in iq ir jt lj ju lk jv ll jg lm ln lo lp bi translated">以获得更好的结果。这是重构的核心。在 ml 代码中，这意味着我们希望有更好的评估/基准性能或资源效率。</li><li id="7c30" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">在代码上做实验是很痛苦的。经验法则是，更改数据集、模型和/或参数会有多痛苦？如果改变数据集或模型能像灭霸的快照一样简单，那该有多好</li><li id="9ef2" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">繁殖是痛苦的。这是个大问题。去你最喜欢的搜索引擎上搜索一下</li><li id="8cf8" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">效率</li><li id="3819" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">代码很难看</li></ol><p id="584c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">还有很多很多其他的原因，但是我认为总的来说我们重构是因为我们想要得到更好的结果。</p><p id="eec7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">所以我写这篇文章的原因如下:</p><ol class=""><li id="1ce4" class="lh li hi il b im in iq ir jt lj ju lk jv ll jg lm ln lo lp bi translated">我想了解 nlp</li><li id="1864" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">我想得到比最初实现更好的结果</li><li id="cdc8" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">我好久没写信了</li></ol><p id="6f04" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">更多免责声明:强烈建议您首先理解原始教程，因为我的目标是讨论重构，而不是 RNN 模型和预处理步骤，因为原始作者已经完美地解释了。</p><p id="e985" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">事不宜迟，我们来看看代码，制定策略。您可以从这里派生或克隆</p><div class="kv kw ez fb kx ky"><a href="https://github.com/spro/practical-pytorch/tree/master/char-rnn-classification" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hj fi z dy ld ea eb le ed ef hh bi translated">spro/实用-pytorch</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">github.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma jr ky"/></div></div></a></div><p id="2188" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">这是教程的报告</p><p id="e81a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">这是我的策略</p><ol class=""><li id="ed7d" class="lh li hi il b im in iq ir jt lj ju lk jv ll jg lm ln lo lp bi translated">派生/克隆原始回购</li><li id="5c10" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">探索代码</li><li id="cacd" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">尝试重现结果</li><li id="1034" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">添加新分支</li><li id="8aa3" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">改进代码，训练，然后再次评估</li></ol><h2 id="28ac" class="mb mc hi bd md me mf mg mh mi mj mk ml jt mm mn mo ju mp mq mr jv ms mt mu mv bi translated">探索代码</h2><p id="81c5" class="pw-post-body-paragraph ii ij hi il b im mw io ip iq mx is it jt my iw ix ju mz ja jb jv na je jf jg hb bi translated">所以在快速浏览代码后，我发现了几个可以改进的地方</p><ol class=""><li id="6560" class="lh li hi il b im in iq ir jt lj ju lk jv ll jg lm ln lo lp bi translated">没有评估功能。这意味着我们不知道模型的表现有多好。它也不包含任何验证数据集，因此我们必须将数据从完整的数据集中分割成训练集和值集</li><li id="0b42" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">python 迭代器中没有包装数据预处理。这是有问题的，因为当检查和使用不同格式的新数据集时，这会带来很多麻烦</li><li id="6484" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">对于每个时期，训练者代码采取随机样本进行训练。据我所知，一个时期的定义是在一个训练循环中使用所有训练样本。</li></ol><p id="500b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">老实说，在这一点上，第二点和第三点并不重要。我们现在想要的是评估这个模型有多好，所以我们应该先解决第一个问题</p><p id="6e44" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">在此之前，让我们创建一个名为 devel 的新分支，并从那里开始工作</p><h2 id="96d4" class="mb mc hi bd md me mf mg mh mi mj mk ml jt mm mn mo ju mp mq mr jv ms mt mu mv bi translated">#splitter.py</h2><p id="82b3" class="pw-post-body-paragraph ii ij hi il b im mw io ip iq mx is it jt my iw ix ju mz ja jb jv na je jf jg hb bi translated">这是数据集的亮点</p><ol class=""><li id="06b5" class="lh li hi il b im in iq ir jt lj ju lk jv ll jg lm ln lo lp bi translated">txt 文件中存储了 18 种语言</li><li id="9148" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">txt 文件中的每一行都包含这些人的名字</li><li id="4bc6" class="lh li hi il b im lq iq lr jt ls ju lt jv lu jg lm ln lo lp bi translated">不同的语言有不同数量的样本</li></ol><p id="88d5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">所以基本策略是随机抽取 80%用于训练，20%用于验证。这完全取决于你，但为了简单起见，我们改为这样做。在真实的场景中，我会再添加一个集合，称为测试集。我通常亲自挑选。这确保了我们纳入了与我们相关的案例。最后，我们希望分割是一致的，所以让我们使用随机种子。</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="f6fa" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">注意在第 31 行我们有一些断言。理想情况下，我们可以对此创建一个函数，并创建测试用例来确保我们所做的在某种程度上是正确的，但现在太多了，所以让我们使用简单的技巧来检查训练集中的最后一个值是否不同于 val 集中的第 0 个值。</p><p id="7e9b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">因此，让我们使用正确的参数运行脚本，您将在输出参数下获得<em class="ik"> train/ </em>和<em class="ik"> val/ </em>文件夹</p><p id="7c60" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">目前就这些。我希望你们喜欢它。不要犹豫给我任何形式的反馈！</p><p id="b00b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">PS:你可以在这个<a class="ae kf" href="https://github.com/amajidsinar/nclsr" rel="noopener ugc nofollow" target="_blank">仓库</a>上看到当前的进度</p><h1 id="56df" class="nd mc hi bd md ne nf ng mh nh ni nj ml nk nl nm mo nn no np mr nq nr ns mu nt bi translated">然后</h1><p id="9b82" class="pw-post-body-paragraph ii ij hi il b im mw io ip iq mx is it jt my iw ix ju mz ja jb jv na je jf jg hb bi translated">我们将尝试评估原始模型的性能。如果您了解分类器的度量标准，如精确度、召回率、准确度和混淆矩阵，您就可以开始了。如果没有，就刷一下。我强烈推荐<a class="ae kf" href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_precision_recall.html" rel="noopener ugc nofollow" target="_blank">这个</a>，因为 scikit 团队已经很好地解释了它。下次见！！！</p></div></div>    
</body>
</html>