<html>
<head>
<title>Taxi Demand Prediction on Time Series Data with Holt Winter forecasting (loss 0.02)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Holt冬季预测的时间序列数据的出租车需求预测(损失0.02)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/taxi-demand-prediction-on-time-series-data-with-holt-winter-forecasting-loss-0-02-2bcdeec48499?source=collection_archive---------4-----------------------#2019-09-11">https://medium.com/analytics-vidhya/taxi-demand-prediction-on-time-series-data-with-holt-winter-forecasting-loss-0-02-2bcdeec48499?source=collection_archive---------4-----------------------#2019-09-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/978c86db7e1aa6280ab11b5b6bc040d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULP2C_OUPit2zd1GKPGmWw.png"/></div></div></figure><h1 id="60b7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="3488" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">今天我们要了解一个有趣的案例，纽约出租车需求预测。简而言之，司机在城市的任何角落等待乘客，我们可以预测未来10分钟这些特定区域的接客数量。所以司机会知道10分钟后会有多少人来接他。在这种情况下，我将<strong class="jq hj"> MAPE </strong>(平均绝对百分比误差)降低到了<strong class="jq hj"> 0.02 </strong>。我使用了<strong class="jq hj">三重指数平滑</strong>、<strong class="jq hj"> </strong>，这是处理时间序列数据时非常有效的特性。</p><p id="ff40" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在这个案例研究中，我们借用了纽约出租车和豪华轿车委员会的数据。实际数据可以在<a class="ae kr" href="https://www1.nyc.gov/site/tlc/about/tlc-trip-record-data.page" rel="noopener ugc nofollow" target="_blank">这里</a>找到。纽约出租车和豪华轿车已经收集了如此多的数据，所有的出租车乘坐的城市。</p><p id="5e40" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">您可以在这里找到这个案例研究<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">的源代码。</a></p><h1 id="be18" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">1.出租车信息:</h1><p id="d2c5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj">黄色出租车:黄色牌照出租车</strong></p><p id="2f1c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这些是著名的纽约市黄色出租车，专门通过街边招呼站提供运输服务。出租车的数量受到TLC颁发的牌照数量的限制。你站在街上，用手招呼一辆出租车，就可以使用这种交通方式。皮卡不是预先安排好的。</p><p id="7715" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">对于出租车辆(fhv)</strong></p><p id="62db" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">FHV交通是通过与调度员或豪华轿车公司预先安排。这些fhv不允许通过街边呼叫搭载乘客，因为这些乘坐不被视为预先安排。</p><p id="bde4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">绿色出租车:街道出租汽车(SHL) </strong></p><p id="321a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">SHL计划将允许车辆所有者许可并为他们的车辆配备绿区出租车品牌、计价器、信用卡机，最终除了预先安排的乘坐之外，还有权接受街头招呼。</p><p id="3b6a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">鸣谢:Quora</p><p id="15fe" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">对于本案例研究，我只考虑2015年1月至3月和2016年1月至3月期间的黄色出租车</p><h1 id="98f6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">2.业务/现实世界问题概述</h1><p id="54a9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这种情况的最终目标是预测在十分钟的时间间隔内在给定位置的拾取数量。我们需要将整个纽约市分成几个小区域，并预测这些区域的接客数量。</p><h1 id="190c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">3.映射到ML问题:</h1><p id="a577" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">很明显是时间序列数据上的回归问题。我们面临以下挑战:</p><ol class=""><li id="6d8a" class="ks kt hi jq b jr km jv kn jz ku kd kv kh kw kl kx ky kz la bi translated">如何将纽约分成几个区域？</li><li id="1028" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">纽约市的每个地区都必须分成10分钟的间隔。</li></ol><h1 id="3d48" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">4.性能指标</h1><ol class=""><li id="5028" class="ks kt hi jq b jr js jv jw jz lg kd lh kh li kl kx ky kz la bi translated">平均绝对百分比误差。</li><li id="a481" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">均方差。</li></ol><h1 id="91c2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">5.数据信息</h1><p id="9666" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们应该花更多的时间来理解这些数据。了解数据可以给我们一个清晰的思路来解决问题。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/fa6408b2e64ef4d8fc829bb33162aa91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8X_gEm4ylTuPfLhNSBaeQ.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图01 .数据集中有19个要素。数据集中的每一行都是纽约的一次出行</figcaption></figure><p id="0730" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以看到，在图01中有19个不同的特征，如下降经度、下降纬度、拾取日期时间、拾取纬度经度等。注意数据集中的每一行都是一次旅行。</p><h1 id="6fc3" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">5.1数据清理</h1><p id="6670" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">数据清洗是ML中最重要的步骤。很明显，数据可能有异常值和误差。我们将进行单边分析。</p><h2 id="8cdc" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">5.1.1.收件纬度和收件经度</h2><p id="99a1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在本案例研究中，我们将只考虑纽约市，纽约的边界是位置坐标(纬度，经度)— (40.5774，-74.15) &amp; (40.9176，-73.7004)，因此这些坐标之外的任何坐标都将被丢弃。我们只关心来自纽约的皮卡。源代码这里是<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/bfd5e521064921b37f392a7040c2a70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5jyk2fQwgaJVhrGuXLCqA.png"/></div></div></figure><p id="a8ea" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以注意到，有一些点，这些点指向海洋中的出租车搭载位置，这显然是异常点，所以我将删除这些点。我只考虑坐标(lat，long)——(40.5774，-74.15)，(40.9176，-73.7004)。</p><h2 id="beb2" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">5.1.2.衰减纬度和衰减经度</h2><p id="e4ce" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">类似于拾取lat，long，我们需要过滤不在我们定义的边界内的数据点，如果我们发现任何数据点，我将简单地丢弃它。源代码是<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h2 id="1ba7" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">5.1.3.行程持续时间</h2><p id="c23c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在我们的数据集中发现一些点是负的，很明显行程持续时间应该是正的。而有些点显示50k分钟行程。使用<strong class="jq hj"> box cox </strong>图，我们可以可视化出行持续时间特征的异常值并将其移除。源代码这里是<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><h2 id="b66e" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">5.1.4.速度</h2><p id="9287" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">类似地，我们使用box cox图进行数据可视化。某个点有192857142英里/小时的速度，这显然是错误的点。我会删除这些点。纽约速度中的平均速度是12.45英里/小时，源代码是<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><h2 id="5077" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">5.1.5.出行距离</h2><p id="292d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">同样，使用百分位数显示的最大行程距离是258.9英里。我们可以说这是一个离群点。所以会去掉这样的点。源代码这里是<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><h2 id="aa68" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">5.1.6.总票价</h2><p id="fb96" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">同样，这里也显示最高总票价为3950612美元，这实际上是不可能的值，所以我将删除这些点。</p><p id="26ba" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">移除所有异常值和错误点后，过滤数据大小如下:</p><pre class="lk ll lm ln fd mh mi mj mk aw ml bi"><span id="d868" class="ls ir hi mi b fi mm mn l mo mp">Removing outliers in the month of Jan-2015<br/>----<br/>Number of pickup records =  12748986<br/>Number of outlier coordinates lying outside NY boundaries: 293919<br/>Number of outliers from trip times analysis: 23889<br/>Number of outliers from trip distance analysis: 92597<br/>Number of outliers from speed analysis: 24473<br/>Number of outliers from fare analysis: 5275<br/>Total outliers removed 377910<br/>---<br/>fraction of data points that remain after removing outliers in % 97.03576425607495</span></pre><h1 id="6cfb" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">6.数据准备</h1><p id="96b3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在去除异常值和错误点后，我们的下一个任务是将整个纽约分成几个部分，并将整个时间跨度分成10分钟的时间段。</p><h2 id="8057" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">6.1聚类/细分</h2><p id="d2cc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这里我将使用K-Means算法将一个城市分成几个区域。Kmeans算法有一个特性，它将创建相同大小的簇。在分段时，我们需要注意簇的大小不能太小或太大。所以有两个条件可以帮助我们，它们是:</p><ol class=""><li id="9760" class="ks kt hi jq b jr km jv kn jz ku kd kv kh kw kl kx ky kz la bi translated">两个集群之间的集群间最大距离应该为&lt;2 miles</li><li id="b784" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">Inter cluster minimum distance between two cluster should &gt; 0.5英里</li></ol><p id="7d0c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">另一件事是我们需要担心，我们需要找到Kmean算法中最佳的K数。显然，我们必须进行超参数调整，并找到最佳的最小K值。这里的<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">是</a>的源代码。</p><pre class="lk ll lm ln fd mh mi mj mk aw ml bi"><span id="0c4f" class="ls ir hi mi b fi mm mn l mo mp"><em class="mq">#trying different cluster sizes to choose the right K in K-means</em><br/>coords = frame_with_durations_outliers_removed[['pickup_latitude', 'pickup_longitude']].values<br/>neighbours=[]<br/><br/><strong class="mi hj">def</strong> find_min_distance(cluster_centers, cluster_len):<br/>    nice_points = 0<br/>    wrong_points = 0<br/>    less2 = []<br/>    more2 = []<br/>    min_dist=1000<br/>    <strong class="mi hj">for</strong> i <strong class="mi hj">in</strong> range(0, cluster_len):<br/>        nice_points = 0<br/>        wrong_points = 0<br/>        <strong class="mi hj">for</strong> j <strong class="mi hj">in</strong> range(0, cluster_len):<br/>            <strong class="mi hj">if</strong> j!=i:<br/>                distance = gpxpy.geo.haversine_distance(cluster_centers[i][0], cluster_centers[i][1],cluster_centers[j][0], cluster_centers[j][1])<br/>                min_dist = min(min_dist,distance/(1.60934*1000))<br/>                <strong class="mi hj">if</strong> (distance/(1.60934*1000)) &lt;= 2:<br/>                    nice_points +=1<br/>                <strong class="mi hj">else</strong>:<br/>                    wrong_points += 1<br/>        less2.append(nice_points)<br/>        more2.append(wrong_points)<br/>    neighbours.append(less2)<br/>    print ("On choosing a cluster size of ",cluster_len,"<strong class="mi hj">\n</strong>Avg. Number of Clusters within the vicinity (i.e. intercluster-distance &lt; 2):",<br/>           np.ceil(sum(less2)/len(less2)), "<strong class="mi hj">\n</strong>Avg. Number of Clusters outside the vicinity (i.e. intercluster-distance &gt; 2):", np.ceil(sum(more2)/len(more2)),<br/>           "<strong class="mi hj">\n</strong>Min inter-cluster distance = ",min_dist,"<strong class="mi hj">\n</strong>---")<br/><br/><strong class="mi hj">def</strong> find_clusters(increment):<br/>    kmeans = MiniBatchKMeans(n_clusters=increment, batch_size=10000,random_state=42).fit(coords)<br/>    frame_with_durations_outliers_removed['pickup_cluster'] = kmeans.predict(frame_with_durations_outliers_removed[['pickup_latitude', 'pickup_longitude']])<br/>    cluster_centers = kmeans.cluster_centers_<br/>    cluster_len = len(cluster_centers)<br/>    <strong class="mi hj">return</strong> cluster_centers, cluster_len<br/><br/><em class="mq"># we need to choose number of clusters so that, there are more number of cluster regions </em><br/><em class="mq">#that are close to any cluster center</em><br/><em class="mq"># and make sure that the minimum inter cluster should not be very less</em><br/><strong class="mi hj">for</strong> increment <strong class="mi hj">in</strong> range(10, 100, 10):<br/>    cluster_centers, cluster_len = find_clusters(increment)<br/>    find_min_distance(cluster_centers, cluster_len)</span></pre><p id="7df4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">上面的代码从(10到100)中寻找超参数，运行后我们可以看到K = 40效果更好。所以我们会选择K =40。所以简单来说，我们可以把NYC分成40个区域。所以我们可以有40个质心。在纽约图上画出这些质心。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/501cec9e65c79d534e5ee51605181f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5__H2Oh84b3Pbew8n5ZyIw.jpeg"/></div></div></figure><p id="7e5e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以看到，大部分质心分布在曼哈顿地区，而纽约市和其他地区的拥挤区域是稀疏的。</p><h2 id="e0db" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">6.2时间-宁滨</h2><p id="f045" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们已经分割了区域，现在我们需要将时间分割成“时间仓”。我们知道，我们将时间分割成10分钟的时间间隔。10分钟= 600秒。我们将把所有日期时间格式转换成<a class="ae kr" href="https://www.unixtimestamp.com/" rel="noopener ugc nofollow" target="_blank"> Unix </a>时间戳格式。然后除以600。所以如果考虑2016年1月，有24小时31天60秒(24 * 31 * 60/10 = 4464 bin)。类似地，2015年2月= 4176箱(<em class="mq"> 24*29*60/10 </em>)。</p><p id="87ba" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，根据2016年1月的数据，现在我们有两个部分，40个集群和4464个箱。对于二月，40个簇和4176个箱。对于三月，40个集群和4464个箱。源代码这里是<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><h1 id="d3d5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 7。平滑</strong></h1><p id="386e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">有一些垃圾桶没有拾音器。在午夜时间，几乎所有的时间仓都将显示零拾取。不是必须的，但是大部分拾音器将预测0值。这个0在我们做计算部分的时候会很头疼，它可能会产生被零除的误差。相反，我们可以用相邻的值来解决所有的零值。假设t，t1，t2是时间仓。t=50次拾取，t1=0次拾取，t2 = 100次拾取，因此我们将平滑为(100+50+0)/3=50，因此t=50，t1=50，t2=50。源代码这里是<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="2740" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，我们有4464个时间箱，每40个区域中有多个拾音器。我们把所有的时间仓放在一个队列中。然后我们必须处理边界以下的情况，</p><pre class="lk ll lm ln fd mh mi mj mk aw ml bi"><span id="88c5" class="ls ir hi mi b fi mm mn l mo mp"><em class="mq">Case 1: When we have the last/last few values are found to be missing,hence we have no right-limit here<br/>Case 2: When we have the missing values between two known values<br/>Case 3: When we have the first/first few values are found to be missing,hence we have no left-limit here.</em></span></pre><p id="0d21" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">情况1:考虑4个时间元，t1、t2、t3、t4，其中拾取值为10，2，0，0。<strong class="jq hj">右值缺失</strong>。即在t1、t2有10.2次拾音，而在t3、t4零次拾音。所以我们取平均值(10+2+0+0)/4=3，平滑拾音后(3，3，3，3)。</p><p id="2e01" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">情况2:相似的t1、t2、t3、t4时间仓，其中拾取值为10，0，0，2。<strong class="jq hj">中间值缺失</strong>。即t1=10，t2=0，3=0，t4=2个拾音器。类似地，平滑数据后，我们可以得到(3，3，3，3)。</p><p id="afae" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">情况3:相同的t1，t2，t3，t4时间跨度和0，0，2，10。<strong class="jq hj">左值缺失</strong>。类似地，平滑数据后，我们可以得到(3，3，3，3)。</p><blockquote class="ms mt mu"><p id="b23b" class="jo jp mq jq b jr km jt ju jv kn jx jy mv ko kb kc mw kp kf kg mx kq kj kk kl hb bi translated"><strong class="jq hj">因此，我们对2015年1月的数据进行了平滑处理，因为它充当了我们的训练数据，并且我们用零填充了2016年1月数据的缺失值。</strong></p></blockquote><h1 id="4bc1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 8。时间序列和傅立叶变换</strong></h1><p id="1a2c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">到目前为止，我们一直在讨论数据是时间序列，让我们将数据绘制在图表上，其中X轴是时间轴，Y轴是拾音器的振幅。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/74fc6f329fe872188e36f59d5e78f0dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFCNTBGSCMgumQBJ9rIDDg.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图02</figcaption></figure><p id="8c26" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果你对傅立叶变换一无所知，那么请查看这里的<a class="ae kr" href="http://www.thefouriertransform.com/" rel="noopener ugc nofollow" target="_blank"/>。但是换句话说，傅立叶变换可以用来分解波形/信号。从现在起，我将交替使用波、波形和信号词。看上面重复的自然波形，它实际上是由多个不同频率和振幅的波组成的。假设正弦波s1具有一定的振幅和频率，正弦波s2具有一定的振幅和频率，而s3波也具有一定的振幅和频率，那么将组合所有的s1、s2和s3，这将由正弦波或所有3个波的相加组成。姑且称之为‘S’。</p><p id="7b41" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当我们在“S”波上应用傅立叶变换时，它将被分解，我们可以得到s1、s2和s3。合成s1、s2和s3将在“频域”中。<strong class="jq hj">在时间序列问题中傅立叶变换可以返回最有价值的特征</strong>。记住，在“频域”中，我们可以非常有效地分析信号。我们对信号进行了傅立叶变换。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/5034ef0995e791c5f8267f5734c556d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*iPpyLAt4f1LYzb9TdBIVVg.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图03。傅里叶变换</figcaption></figure><p id="b707" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以在图02中观察到，我们有一个重复的时间序列数据。一天中，我们有1440分钟。(24小时*60分钟=1440分钟)。我们把它分成10分钟的间隔，所以图02波重复144个单位后。(1440分钟/10分钟= 144分钟)。图03是24小时数据的傅立叶变换。</p><p id="b200" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">图03中。第一个最高的峰值是傅立叶变换的DC分量。我们将忽略<strong class="jq hj">的DC成分</strong>。第二个峰值是1/144，代表24小时，第三个峰值是1/72，代表一天中的12小时。第四个峰值是1/36，代表一天中的6个小时。诸如此类。</p><h1 id="cb78" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">9.基线模型</h1><p id="c59c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于基线模型，我们有两种策略。</p><ol class=""><li id="dcaf" class="ks kt hi jq b jr km jv kn jz ku kd kv kh kw kl kx ky kz la bi translated">比率特征</li><li id="1152" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">先前值特征</li></ol><p id="ddfd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设现在是2016年1月15日，下午5:40，就说是当前时间戳，我想预测接下来10分钟的出租车需求。那么2016年1月15日<strong class="jq hj"/>，下午5:40我们就称之为<strong class="jq hj"> P_t 2016 </strong>。</p><p id="d435" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">同时<strong class="jq hj"> P_t 2015 </strong>不过是2015年1月15日<strong class="jq hj">下午5点40分。从现在起我将使用相同的符号。</strong></p><p id="c2b1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">另外，注意P_t或R_t代表<strong class="jq hj">电流</strong>值。</p><p id="d01d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">P_t-1或R_t-1代表<strong class="jq hj">过去的</strong>值。</p><p id="a6c8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">P_t+1或R_t+1代表<strong class="jq hj">未来</strong>值。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/df0cce0a617bbede8000bfc2b3d54faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZmL_-sSQhvNRpqJP2a7HA.jpeg"/></div></div></figure><p id="068d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以看到公式，对于<strong class="jq hj">比率特征</strong>，假设当前时间戳为t，那么R_t= P_t 2016 / P_t 2015。说未来时间戳是t+1，公式变化如下，R_t+1 = P_t+1 2016/ P_t +1 2015。其中P_t+1 2016为(预测值)，P_t+1 2015为实际值/可用值。</p><p id="23de" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">P_t+1 2016 = R_t+1 * P_t+1 2015。其中P_t+1 2015将被知道。</p><p id="6eac" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">以前的特性</strong>它最简单的方法，它会考虑过去的时间戳值。假设当前时间戳是t，那么它将使用t-1，t-2，t-3，…数据。</p><h2 id="2a4f" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">9.1.1.简单移动平均线</h2><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/b8016e6c6cc7755b07fb8340c46c2b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzaUamPOrfrsVhL4YPJ9Dg.jpeg"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">简单移动平均线</figcaption></figure><p id="adac" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">真的很简单的公式化，就是“比率特征”的前n个值的简单平均。n的最佳值是“3”。我对n值做了一些超参数调整，我发现‘3’是我们情况下的最佳值。源代码这里是<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="bbc0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">同样，对于“前一个值特性”，我们取前n个值的平均值，在调整参数后，我发现n =1的性能更好。</p><p id="7ac8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">注</strong>在简单移动平均线中，我们给t-1、t-2、t-3等权重，是否可以尝试不同的权重方案？</p><h2 id="17aa" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">9.1.2.加权移动平均</h2><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/344cb1669ff13a427809c86297dd4475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vIM1CYfx1n2E5hFQLuAXeg.jpeg"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图05加权移动平均线</figcaption></figure><p id="562c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">“比例特征”，我们可以在图05中观察到公式。最近的时间戳具有较高的权重，较旧的时间戳具有较低的权重。它非常类似于简单移动平均线，除了在简单移动平均线中，我们给所有阶段相同的权重，这里分配不同的权重。源代码这里是<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><h2 id="687c" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">9.1.3.指数加权移动平均</h2><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/7ff0b43171b8c52aa2dc3e7caa21865d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKOqnTi6ygDNkuum0Tn9Nw.jpeg"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图06指数加权移动平均线</figcaption></figure><p id="93b8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设我想预测当前时间戳的R'_t值和R_t-1(过去的实际值)和R'_t-1(过去的预测值)。所以我可以用这两个值来预测未来。在上述公式(图06)中，我们观察到了α值。</p><p id="2a14" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设α= = 0，那么R'_t = R'_t-1…(我们忽略实际值)</p><p id="97aa" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设α= = 1，那么R'_t = R_t-1…(我们忽略预测值)</p><p id="9ac5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这里我们必须考虑“实际”和“预测”值，所以我们需要很好地调整“alpha值”并相应地使用。源代码是<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><p id="da72" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设α= 0.8，</p><p id="bfdf" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">R′t =α∫R′_ t1+(1α)∫R _ t-1</strong></p><p id="df55" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">R′t =(0.8∫R′_ t1)+(0.2∫R _ t-1)</p><h1 id="5515" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">10。基础模型结果</h1><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/8bf859e41e1776d4d7f43eb7d317220f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_KReBzcu815mSRsfBhqvnA.png"/></div></div></figure><p id="9a18" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以清楚地看到以前的值功能工作得更好。</p><h1 id="e745" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">11.应用ML回归模型</h1><p id="14db" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">到目前为止，我们使用一个简单的基线模型，现在是时候应用回归模型了。我们将使用线性回归、随机森林回归和XGboost回归模型。</p><h2 id="b3f1" class="ls ir hi bd is lt lu lv iw lw lx ly ja jz lz ma je kd mb mc ji kh md me jm mf bi translated">11.1.数据准备</h2><p id="29b1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们将把数据分成70-30份。70%的数据用于训练，30%用于测试。我们有首字母</p><pre class="lk ll lm ln fd mh mi mj mk aw ml bi"><span id="e185" class="ls ir hi mi b fi mm mn l mo mp"><em class="mq"># Now we computed 18 features for every data point <br/><br/># 1. cluster center latitude</em><br/><em class="mq"># 2. cluster center longitude</em><br/><em class="mq"># 3. day of the week </em><br/><em class="mq"># 4. f_t_1: number of pickups that are occurred previous t-1th 10min interval</em><br/><em class="mq"># 5. f_t_2: number of pickups that are occurred previous t-2th 10min interval</em><br/><em class="mq"># 6. f_t_3: number of pickups that are occurred previous t-3th 10min interval</em><br/><em class="mq"># 7. f_t_4: number of pickups that are occurred previous t-4th 10min interval</em><br/><em class="mq"># 8. f_t_5: number of pickups that are occurred previous t-5th 10min interval<br/># 9. Exponential Weighted Moving Avg</em></span><span id="098e" class="ls ir hi mi b fi nf mn l mo mp"><em class="mq"># --------------------Fourier Features --------------------------</em></span><span id="92db" class="ls ir hi mi b fi nf mn l mo mp"><em class="mq"># 10. a_1 : amplitude corresponding to 1st highest fourier transform value<br/># 11. f_2 : frequency corresponding to 2nd highest fourier transform value<br/># 12. a_2 : amplitude corresponding to 2nd highest fourier transform value<br/># 13. f_3 : frequency corresponding to 3rd highest fourier transform value<br/># 14. a_3 : amplitude corresponding to 3rd highest fourier transform value<br/># 15. f_4 : frequency corresponding to 4th highest fourier transform value<br/># 16. a_4 : amplitude corresponding to 4th highest fourier transform value<br/># 17. f_5 : frequency corresponding to 5th highest fourier transform value<br/># 18. a_5 : amplitude corresponding to 5th highest fourier transform value</em></span></pre><p id="8dab" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">注</strong>:上述<strong class="jq hj">第8节</strong>中提到的傅立叶特征。此外，请注意，我们忽略了f1分量，这是傅里叶变换中的DC分量，如前面第8节所述。</p><h1 id="9724" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 12。结果</strong></h1><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/5b73bd7e115612d2831733827efaf552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWzEXNfXp71Cir2kJF1pAQ.png"/></div></div></figure><p id="704c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以观察到，像“指数WMA”这样简单模型比随机森林和XGboost这样的复杂模型工作得更好。我们希望MAPE值尽可能小。</p><h1 id="a0d9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">13.霍尔特冬季预报</h1><p id="51cf" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">从上面的分析可以很清楚地看出，“前值”特征是简单且最有效的特征，如果数据是时间序列，那么我们应该尝试霍尔特冬季预测，这可能会改善我们的结果。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/e6852234bce7ac70874de17c6bc73ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NGWF8-p4sP8njRvdJF4PA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图07。三重指数移动平均值</figcaption></figure><p id="81cb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在上述公式中，<strong class="jq hj">水平</strong>可以表示为期望值或预测值。<strong class="jq hj">趋势可以说</strong>，假设有XY图，X相对于y的变化率称为<em class="mq">趋势</em>。可以是上升趋势，也可以是下降趋势。序列中递增或递减的值。如果价值增加，则呈上升趋势，价值减少，则呈下降趋势。季节性的如果时间序列在固定的时间间隔内重复出现，那么我们可以说数据是季节性的。</p><p id="8e0a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">三重指数平滑背后的思想是，除了水平和趋势之外，还将指数平滑应用于季节性成分。平滑跨季节应用，例如，进入季节的第三点的季节分量将与来自上个季节的第三点、两个季节前的第三点的分量指数平滑，等等。</p><p id="e138" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">以下代码用于霍尔特冬季预测(三重指数加权移动平均)。</p><pre class="lk ll lm ln fd mh mi mj mk aw ml bi"><span id="d1bf" class="ls ir hi mi b fi mm mn l mo mp"><strong class="mi hj">def</strong> initial_trend(series, slen):<br/>    sum = 0.0<br/>    <strong class="mi hj">for</strong> i <strong class="mi hj">in</strong> range(slen):<br/>        sum += float(series[i+slen] - series[i]) / slen<br/>    <strong class="mi hj">return</strong> sum / slen<br/><br/><strong class="mi hj">def</strong> initial_seasonal_components(series, slen):<br/>    seasonals = {}<br/>    season_averages = []<br/>    n_seasons = int(len(series)/slen)<br/>    <em class="mq"># compute season averages</em><br/>    <strong class="mi hj">for</strong> j <strong class="mi hj">in</strong> range(n_seasons):<br/>        season_averages.append(sum(series[slen*j:slen*j+slen])/float(slen))<br/>    <em class="mq"># compute initial values</em><br/>    <strong class="mi hj">for</strong> i <strong class="mi hj">in</strong> range(slen):<br/>        sum_of_vals_over_avg = 0.0<br/>        <strong class="mi hj">for</strong> j <strong class="mi hj">in</strong> range(n_seasons):<br/>            sum_of_vals_over_avg += series[slen*j+i]-season_averages[j]<br/>        seasonals[i] = sum_of_vals_over_avg/n_seasons<br/>    <strong class="mi hj">return</strong> seasonals<br/><br/><br/><strong class="mi hj">def</strong> triple_exponential_smoothing(series, slen, alpha, beta, gamma, n_preds):<br/>    result = []<br/>    seasonals = initial_seasonal_components(series, slen)<br/>    <strong class="mi hj">for</strong> i <strong class="mi hj">in</strong> range(len(series)+n_preds):<br/>        <strong class="mi hj">if</strong> i == 0: <em class="mq"># initial values</em><br/>            smooth = series[0]<br/>            trend = initial_trend(series, slen)<br/>            result.append(series[0])<br/>            <strong class="mi hj">continue</strong><br/>        <strong class="mi hj">if</strong> i &gt;= len(series): <em class="mq"># we are forecasting</em><br/>            m = i - len(series) + 1<br/>            result.append((smooth + m*trend) + seasonals[i%slen])<br/>        <strong class="mi hj">else</strong>:<br/>            val = series[i]<br/>            last_smooth, smooth = smooth, alpha*(val-seasonals[i%slen]) + (1-alpha)*(smooth+trend)<br/>            trend = beta * (smooth-last_smooth) + (1-beta)*trend<br/>            seasonals[i%slen] = gamma*(val-smooth) + (1-gamma)*seasonals[i%slen]<br/>            result.append(smooth+trend+seasonals[i%slen])<br/>    <strong class="mi hj">return</strong> result</span></pre><p id="cdf5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">改善结果的关键部分是微调alpha、beta和gamma值</strong>。我有微调阿尔法，贝塔和伽马值在下面的规模。</p><pre class="lk ll lm ln fd mh mi mj mk aw ml bi"><span id="ff5a" class="ls ir hi mi b fi mm mn l mo mp">alpha = [0.1,0.2,0.3,0.4]<br/>beta = [0.1,0.15,0.20,0.25]<br/>gamma = [0.1,0.3,0.4,0.5,0.65,0.75,0.85,0.95]</span><span id="6885" class="ls ir hi mi b fi nf mn l mo mp">Best value I found for our problems is :</span><span id="d28f" class="ls ir hi mi b fi nf mn l mo mp">alpha=0.1<br/>beta=0.1<br/>gamma = 0.95</span></pre><p id="fdb7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">使用上面的值，我在列表中增加了一个特性。我添加了“第19个特征”作为命名的“三重指数”特征。然后将“19特征”模型应用于<strong class="jq hj">随机森林</strong>和<strong class="jq hj"> XGboost。</strong></p><h1 id="a72d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">14.决赛成绩</h1><pre class="lk ll lm ln fd mh mi mj mk aw ml bi"><span id="22af" class="ls ir hi mi b fi mm mn l mo mp">+-------------+---------------+---------+<br/>|    Metric   | Random Forest | XgBoost |<br/>+-------------+---------------+---------+<br/>| Train MAPE  |    0.04707    | 0.03034 |<br/>|  Test MAPE  |    0.04657    | 0.02932 |<br/>+-------------+---------------+---------+</span></pre><p id="c9ae" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这太棒了。我们在很大程度上提高了模型性能。我们预计损失为0.12，我们将损失减少到0.02，这很棒。</p><p id="e116" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">到目前为止，我们最好的模型是XGboost回归器，测试MAPE: 0.02932</p><h1 id="160e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">15.结论</h1><p id="c46a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在时间序列数据中，最好使用“移动平均”、“加权移动平均”、“指数WMA”、“三重EWMA”作为特征。“傅立叶变换”也可以给出更好的特征，但是在我们的例子中，它没有像预期的那样工作。</p><p id="97ce" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">微调是提高模型性能的关键部分。</strong></p><p id="808f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">此案例研究的源代码可以在<a class="ae kr" href="https://github.com/pranaysawant/New-York-Taxi-Demand-Prediction/blob/master/NYC_Final.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="c05c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">16.参考</h1><ol class=""><li id="da38" class="ks kt hi jq b jr js jv jw jz lg kd lh kh li kl kx ky kz la bi translated"><a class="ae kr" href="https://grisha.org/blog/2016/02/17/triple-exponential-smoothing-forecasting-part-iii/" rel="noopener ugc nofollow" target="_blank">https://grisha . org/blog/2016/02/17/三重指数平滑-预测-第三部分/ </a></li><li id="19dd" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated"><a class="ae kr" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.MiniBatchKMeans.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . cluster . minibatchkmeans . html</a></li><li id="9761" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated"><a class="ae kr" href="https://www.youtube.com/watch?v=DUyZl-abnNM" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=DUyZl-abnNM</a></li><li id="44eb" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated"><a class="ae kr" href="https://xgboost.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://xgboost.readthedocs.io/en/latest/</a></li><li id="8741" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated"><a class="ae kr" href="https://www.appliedaicourse.com/" rel="noopener ugc nofollow" target="_blank">https://www.appliedaicourse.com/</a></li></ol><p id="c3a7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">你可以在这里查看类似的有趣博客:</p><p id="fc4d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><a class="ae kr" rel="noopener" href="/@pranaysawant22/memes-detection-android-app-using-deep-learning-d2c65347e6f3">利用深度学习的模因检测App</a>。</p><p id="cb38" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><a class="ae kr" rel="noopener" href="/@pranaysawant22/zomato-restaurant-rate-prediction-2093cb685430">佐马托率预测博客</a>。</p></div></div>    
</body>
</html>