<html>
<head>
<title>Object Localization using Keras — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keras的对象定位—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/object-localization-using-keras-part-2-207e7ccba6ed?source=collection_archive---------13-----------------------#2020-07-26">https://medium.com/analytics-vidhya/object-localization-using-keras-part-2-207e7ccba6ed?source=collection_archive---------13-----------------------#2020-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="edd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的上一篇文章“使用Keras的目标定位”中，我解释了什么是计算机视觉中的目标定位，并分享了我的代码，它解决了这个任务的一个简化版本——通过提供一个包围它的边界框来定位一个目标(一只猫)。</p><p id="ec68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将把它扩展为多类版本。也就是说，检测物体是否出现，对其进行分类，并找到其位置。</p><p id="ec74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">资源</strong> : <br/>代码—<a class="ae jd" href="https://colab.research.google.com/drive/169pJ-xECBWDW9Q92naaNE3oRyBr7D-uh?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/169 pj-xecbwdw 9 q 92 na ane 3 ory br 7d-uh？usp =分享</a> <br/>图片—<a class="ae jd" href="https://drive.google.com/drive/folders/1YsxDywjUZi-l_YgzXt__9__eUU-I_6EH?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://drive . Google . com/drive/folders/1 ysxdywjuzi-l _ YgzXt _ _ 9 _ _ eUU-I _ 6EH？usp =分享</a></p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="0a9b" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">议程</h1><ol class=""><li id="55b1" class="kj kk hi ih b ii kl im km iq kn iu ko iy kp jc kq kr ks kt bi translated">什么是多类分类？</li><li id="6e71" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">前一篇文章的实现需要什么变化？</li><li id="b356" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">代码部分</li><li id="a98d" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">结果</li></ol></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="6def" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">多类分类</h1><p id="7ce3" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">根据维基百科，“<strong class="ih hj">多类</strong>或<strong class="ih hj">多项分类</strong>是<a class="ae jd" href="https://en.wikipedia.org/wiki/Statistical_classification" rel="noopener ugc nofollow" target="_blank">将</a>实例分类为三个或更多类中的一个(将实例分类为两个类中的一个称为<a class="ae jd" href="https://en.wikipedia.org/wiki/Binary_classification" rel="noopener ugc nofollow" target="_blank">二元分类</a>)的问题”。</p><p id="855e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在计算机视觉领域，一个实例可以是一幅图像，任务是从一组至少大小为3的给定标签中对其进行标记。例如，CIFAR10数据集由大小为32*32*3的RGB图像组成，每个图像都被标记为以下之一:飞机、汽车、鸟、猫、鹿、狗、青蛙、马、船和卡车。</p><p id="df18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，类集由一只猫、一只狗和一个无对象组成。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="24cd" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">与前一篇文章相比的变化</h1><p id="f97f" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在上一篇文章中，我分享了一个能够在带有自然背景的图像中定位物体(一只猫)的架构。现在，我们的目标是一项更艰巨的任务，原因如下:</p><p id="0412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-可能根本没有对象<br/> -有不止一个类</p><p id="4008" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这些变化，我们需要适当地修改我们的架构和损失函数。此外，还需要一个新的图像生成器。</p><p id="1fe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">架构</strong> : <br/>我们要预测对象的类别——猫/狗/无对象。此外，我们必须提供边界框的坐标— (x，y)坐标和大小(假设边界框是正方形)。<br/>因此，模型的输出应该是一个大小为6的向量，它将包含:<br/> - (x，y)坐标<br/> -边界框大小<br/> -大小为3的向量，它表示类别-猫/狗/无对象</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lc"><img src="../Images/775f668dcd531fe9ef2da43eb740865d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3uNy0Xn2XlHcKVk8QWGuiA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">建议的架构</figcaption></figure><p id="15f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">损失函数</strong> : <br/>在之前的文章中，我已经使用了二值交叉熵损失，但是现在，这是不可能的，原因主要有两个:</p><p id="cda9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)当完全没有物体时，我们根本不想预测包围盒。在这种情况下，没有地面真实边界框，我们不想因为边界框而受到惩罚。所以，我们需要定义一个更智能的损失函数。</p><p id="6a25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)因为我们正在处理多类分类，我们应该在类上使用分类交叉熵(每个实例正好一个类)。</p><p id="4d7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们需要一个自定义的损失函数，当且仅当类不是“无对象”时，它才检查边界框预测。此外，我们希望类损失是分类交叉熵。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es ls"><img src="../Images/93ee9a34e306bee8c80be1f1ce1a5fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_F8dsQbgShlHKG4VMogkuQ.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">建议的自定义损失函数</figcaption></figure><p id="0dd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">图像生成器</strong> : <br/>我们需要实现一个新的生成器，它能够生成所需类型的图像:<br/> -具有自然背景<br/> -包含一只猫/狗/无对象(随机化)<br/> -随机化的对象大小和位置</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lt"><img src="../Images/1e8b06919374737315f1909ccded457f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YJBpJRB9S4K4VzCI44XAw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图像生成器生成的样本</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="9d7f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">密码</h1><p id="58a3" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated"><strong class="ih hj">图像生成器<br/> </strong>下面这段代码加载了图像类，并创建了一个具有所需属性的图像生成器:</p><figure class="ld le lf lg fd lh"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="5884" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">架构<br/> </strong>如上所述定义架构</p><figure class="ld le lf lg fd lh"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="ea1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">损失与训练<br/> </strong>定义我们自定义的损失，训练模型，可视化结果。</p><figure class="ld le lf lg fd lh"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="a5c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是一些结果:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lw"><img src="../Images/16d5f24e6b12b3d1afe978af31ca0324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HL2_JJbU0RFVHNDqkxKAjA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">结果</figcaption></figure><p id="1fbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，该模型成功地检测到了对象的外观，正确地对它们进行了分类，并准确地找到了位置。</p></div></div>    
</body>
</html>