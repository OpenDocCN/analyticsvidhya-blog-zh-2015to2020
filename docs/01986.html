<html>
<head>
<title>Protocol buffer through Kafka Python Producer and Java Consumer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Kafka Python生产者和Java消费者的协议缓冲</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/protocol-buffer-python-kafka-producer-and-java-kafka-consumer-1168869ae0a2?source=collection_archive---------4-----------------------#2019-11-25">https://medium.com/analytics-vidhya/protocol-buffer-python-kafka-producer-and-java-kafka-consumer-1168869ae0a2?source=collection_archive---------4-----------------------#2019-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0faf183986cbe1f12c8540c64fa561e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhxXTUdUrLhWB2kW6EeH7A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">通过混合卡夫卡生产者和消费者</figcaption></figure><p id="9b89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过Kafka消息传递的JAVA和Python GRPC微服务通信:</p><p id="e0fe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本帖中，我们将讨论在grpc和协议缓冲区上使用python和java构建微服务架构时面临的最常见问题之一。</p><p id="c601" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于JAVA和python中的字节差异，从Python客户端传递协议缓冲区并在基于grpc JAVA的微服务中使用是有问题的。</p><p id="82de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">只是为了批量处理消息，我们还将在中间放置Kafka消息队列。</p><p id="0105" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">看看下面的通用架构，我们将看到如何编码。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es js"><img src="../Images/d05de47cf78a3e9983c382bc09aa71d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eqQxWOEIQSgXMsTE0-rng.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">通过kafka传递Python和Java协议缓冲消息</figcaption></figure><p id="9a2d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">版本:</p><ul class=""><li id="2c40" class="jx jy hi iw b ix iy jb jc jf jz jj ka jn kb jr kc kd ke kf bi translated">Java — 1.8</li><li id="b74e" class="jx jy hi iw b ix kg jb kh jf ki jj kj jn kk jr kc kd ke kf bi translated">python 3.6</li><li id="8017" class="jx jy hi iw b ix kg jb kh jf ki jj kj jn kk jr kc kd ke kf bi translated">议定书3.10.1</li><li id="a839" class="jx jy hi iw b ix kg jb kh jf ki jj kj jn kk jr kc kd ke kf bi translated">pykafka</li></ul><p id="1fe1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><groupId> org.apache.kafka </groupId></p><p id="0679" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><artifactId>卡夫卡-客户</artifactId></p><p id="4197" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><version> 2.0.0 </version></p><blockquote class="kl km kn"><p id="4eab" class="iu iv ko iw b ix iy iz ja jb jc jd je kp jg jh ji kq jk jl jm kr jo jp jq jr hb bi translated">让我们为通信定义一个简单的<strong class="iw hj">协议缓冲区</strong>消息</p></blockquote><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="0aa7" class="kx ky hi kt b fi kz la l lb lc">syntax = "proto3";<br/><br/>//import "google/protobuf/empty.proto";<br/>//import "google/protobuf/timestamp.proto";<br/><br/>option java_package = "com.kafka.simple.genproto";<br/>import "google/protobuf/empty.proto";<br/><br/><br/>message Simple {<br/>    string label = 1;<br/>    string description = 2;<br/>    int32 version = 3;<br/>}</span></pre><blockquote class="kl km kn"><p id="2186" class="iu iv ko iw b ix iy iz ja jb jc jd je kp jg jh ji kq jk jl jm kr jo jp jq jr hb bi translated">对于grpc微服务，只需实现如下Grpc服务</p></blockquote><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="9b87" class="kx ky hi kt b fi kz la l lb lc">service SimpleMessageService {<br/>    rpc pushSimpleMessage(Simple) returns (google.protobuf.Empty);<br/>}</span></pre><blockquote class="kl km kn"><p id="69e8" class="iu iv ko iw b ix iy iz ja jb jc jd je kp jg jh ji kq jk jl jm kr jo jp jq jr hb bi translated">Python Kafka客户端来填充我们的简单消息(pykafka)</p></blockquote><p id="facc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Base64编码在这里非常重要，因为简单的SerilizeToString在Java消费者端无法工作。</p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="5891" class="kx ky hi kt b fi kz la l lb lc">client = KafkaClient(hosts="127.0.0.1:9092")<br/><br/>topic = client.topics["simpletopic"]<br/><br/>msg = simple_pb2.Simple()<br/>msg.label = 'simple message'<br/>msg.description = 'this is a simple message'<br/>msg.version = 1<br/>print(msg)<br/><br/>with topic.get_sync_producer(max_retries=5, required_acks=1, ack_timeout_ms=5000) as producer:<br/>    #this is importontant to base64 encode the message<br/>    #just using SerilizeToString wont work on the other end java consumer<br/><strong class="kt hj">    b64encoded = base64.b64encode(msg.SerializeToString())</strong><br/>    res = producer.produce(b64encoded)<br/>    print(res)</span></pre><blockquote class="kl km kn"><p id="51ef" class="iu iv ko iw b ix iy iz ja jb jc jd je kp jg jh ji kq jk jl jm kr jo jp jq jr hb bi translated">卡夫卡-控制台-消费者它看起来怎么样</p></blockquote><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="6f26" class="kx ky hi kt b fi kz la l lb lc">kafka-console-consumer.sh - bootstrap-server 127.0.0.1:9092 - topic "simpletopic"<br/>Cg5zaW1wbGUgbWVzc2FnZRIYdGhpcyBpcyBhIHNpbXBsZSBtZXNzYWdlGAE=</span><span id="b5a5" class="kx ky hi kt b fi ld la l lb lc"><strong class="kt hj">Base64 Encoded protocol buffer</strong></span></pre><blockquote class="kl km kn"><p id="48c4" class="iu iv ko iw b ix iy iz ja jb jc jd je kp jg jh ji kq jk jl jm kr jo jp jq jr hb bi translated">Java Kafka消费线程(仅重要的解码部分)</p></blockquote><p id="15e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">检查代码的Base64解码部分。</p><pre class="jt ju jv jw fd ks kt ku kv aw kw bi"><span id="0fc9" class="kx ky hi kt b fi kz la l lb lc">public void run()<br/>{<br/>    logger.info("consumer thread [" + this.id + "] starting up");<br/>try {<br/>consumer.subscribe(topics);<br/><br/>while (true) {<br/>ConsumerRecords &lt; String, String &gt; records = consumer.poll(Duration.ofMillis(100));<br/>for (ConsumerRecord &lt; String, String &gt; record: records) {<br/>try {<br/>logger.info("consumer thread [" + this.id + "] received \n" + record);<br/>Simple msg = <strong class="kt hj">SimpleOuterClass.Simple.parseFrom(Base64.getDecoder().decode(record.value()));<br/><br/></strong>logger.info("consumer thread [" + this.id + "] received \n" + msg.toString());<br/>// Push to KGIngestionService MicroService<br/><br/>consumer.commitAsync(new OffsetCommitCallback() {<br/>public void onComplete(Map &lt; TopicPartition, OffsetAndMetadata &gt; offsets, Exception exception) {<br/>if (exception != null)<br/>logger.info("Commit failed for offsets {" + offsets + "  }" + " exception " +<br/>exception);<br/>else<br/>logger.info("Commit for offsets {" + offsets + "  } successful");<br/>}<br/>});<br/><br/>}</span></pre><p id="880e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">希望您已经了解了如何通过python Kafka客户端和java Kafka消费者传递协议缓冲区消息。</p><p id="5f8c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这两种方式都可行，只是Base64编码和解码部分需要更改。</p><p id="8293" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">希望这将帮助您使用Grpc、协议缓冲区和Kafka构建可扩展的微服务架构。</p><p id="c2ba" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">谢谢你。</p><p id="fae8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">参考资料:</p><p id="b9ef" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">[1]<a class="ae le" href="https://pykafka.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://pykafka.readthedocs.io/en/latest/</a></p><p id="15c2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae le" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/protocol-buffers</a></p><p id="0be3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">[3]<a class="ae le" href="https://kafka.apache.org/10/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html" rel="noopener ugc nofollow" target="_blank">https://kafka.apache.org/10/javadoc/index.html?org/Apache/Kafka/clients/consumer/kafkaconsumer . html</a></p></div></div>    
</body>
</html>