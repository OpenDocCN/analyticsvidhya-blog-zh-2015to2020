<html>
<head>
<title>Available Now: Open-Source Implementation of Hinton’s “Matrix Capsules with EM Routing”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现在可用:Hinton的“带EM路由的矩阵胶囊”的开源实现</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/available-now-open-source-implementation-of-hintons-matrix-capsules-with-em-routing-e5601825ee2a?source=collection_archive---------6-----------------------#2019-08-26">https://medium.com/analytics-vidhya/available-now-open-source-implementation-of-hintons-matrix-capsules-with-em-routing-e5601825ee2a?source=collection_archive---------6-----------------------#2019-08-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3cef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Geoffrey_Hinton" rel="noopener ugc nofollow" target="_blank"> Geoffrey Hinton </a>谈论“胶囊网络”已经很长时间了(当他说话时，我们会听)，所以当他的团队在2017年底发表了两篇关于这个主题的论文时，自然在机器学习社区引起了不小的轰动。</p><p id="d2bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一篇论文名为<a class="ae jd" href="https://papers.nips.cc/paper/6975-dynamic-routing-between-capsules.pdf" rel="noopener ugc nofollow" target="_blank">“胶囊之间的动态路由”</a>展示了一个胶囊网络架构，其特点是动态协议路由，在MNIST上达到了最先进的性能，并在识别重叠数字方面击败了CNN。感激地🙏，这篇论文的<a class="ae jd" href="https://github.com/IBM/matrix-capsules-with-em-routing" rel="noopener ugc nofollow" target="_blank">代码</a>可以在GitHub上获得。第二篇论文名为<a class="ae jd" href="https://openreview.net/pdf?id=HJWLfGWRb" rel="noopener ugc nofollow" target="_blank">“带EM路由的矩阵胶囊”</a>解决了第一篇论文的一些缺陷，与最先进的技术相比，将<a class="ae jd" href="https://cs.nyu.edu/~ylclab/data/norb-v1.0-small/" rel="noopener ugc nofollow" target="_blank"> smallNORB </a>的测试误差减少了45%。不幸的是，这一次研究界没有这么幸运，没有可用的代码(Booo…👎).这给感兴趣的研究人员留下了令人沮丧的任务，他们试图自己实现这篇论文并重现基准。</p><p id="c3ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在编写我们自己的实现时，我们注意到了我们遇到的其他开源实现中的几个常见错误。在本帖中，我们分享了一些经验，特别关注三个实施陷阱以及如何避免它们。虽然我们的实现相对于当前可用的实现有了相当大的改进，但它仍然略低于Hinton <em class="je">等人</em>所报告的性能。但是我们很乐意在GitHub上提供这个实现的完整源代码(掌声👏👏👏).</p><p id="76bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">小心🚧</strong>:我们即将深入细节，所以如果你不熟悉辛顿的论文，那么我们建议你从<a class="ae jd" href="https://jhui.github.io/2017/11/14/Matrix-Capsules-with-EM-routing-Capsule-Network/" rel="noopener ugc nofollow" target="_blank">乔纳森·许的博客</a>开始，然后阅读<a class="ae jd" href="https://openreview.net/pdf?id=HJWLfGWRb" rel="noopener ugc nofollow" target="_blank">的论文</a>本身，再往下看👇。如果你是一个勤奋的人，渴望看到代码，那么请随意跳过下面的细节，前往<a class="ae jd" href="https://github.com/IBM/matrix-capsules-with-em-routing" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p><h1 id="0024" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">陷阱1:独生子女有什么不好？</h1><p id="40a4" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated"><em class="je">又名:母胶囊只有一个子胶囊的问题</em></p><p id="1e5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">EM路由算法是聚类发现的一种形式，其迭代地调整子胶囊和父胶囊之间的分配概率。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/97849dfc4f07caa505f6080c2df25a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3eiDy9LNmD4uO-rFnGEBw.jpeg"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">当EM路由开始时，所有子封装在父封装之间平均共享。但是随着路由的进行，父母胶囊争夺孩子，直到他们有单独的监护权。</figcaption></figure><p id="6801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在EM路由开始时，每个子胶囊的输出在所有父胶囊之间平均共享。随着EM路由的进行，父胶囊对于特定子胶囊的亲和力增加，并且最终父胶囊可能具有子胶囊的“唯一监护权”。只要子胶囊具有兄弟，这就不会引起问题，但是“唯一的孩子”的情况会引起问题，即，如果父胶囊只从一个子胶囊接收输入。这种情况类似于一个集群只有一个数据点的情况。</p><p id="b251" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于EM路由符合每个父胶囊的高斯分布，我们需要计算每个父胶囊的平均值和方差。在<em class="je">独生子女</em>场景中，父胶囊只有一个子女，因此方差为0。这导致计算激活成本<em class="je"> log(σ)，</em>时数值不稳定，在<em class="je"> σ=0 </em>时未定义。此外，如果方差为0，那么平均概率密度为无穷大∞，其他地方为零，这又会导致数值问题。</p><p id="a6f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">独生子女问题的普遍程度取决于孩子胶囊与父母胶囊的比例。如果该比率很高(例如100:1 ),这意味着许多子胶囊供给较少的父胶囊，则该问题仅发生在较高的路由迭代中。然而，如果该比率较低并且接近1:1，或者甚至更低(即，父胶囊多于子胶囊)，则<em class="je">唯一子</em>问题开始在较低数量的路由迭代中出现。</p><p id="d2dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们理解了这个问题，解决🥳.实际上是非常简单的我们只需通过添加<em class="je"> ε=10⁻ </em> ⁴对方差施加一个下限，就可以了。</p><h1 id="cdc3" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">陷阱2:对父母公平</h1><p id="b2ea" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated"><em class="je">又名:标准化分配给父胶囊的路由数据量</em></p><p id="fc54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当确定激活父胶囊的成本时，我们计算<em class="je"> ∑ </em> ᵢ <em class="je"> R_ij，</em>，这是从所有子胶囊<em class="je"> i </em>分配给父胶囊<em class="je"> j </em>的数据总量。这然后通过<em class="je">逻辑</em>功能实现，因此如果<em class="je">成本</em>高，则父胶囊将不被激活，但是如果<em class="je">成本</em>低，则父胶囊将被激活。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ky"><img src="../Images/6d54edaabd218cc0f20e29e9a9024f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAUU4E_97-0UL8tBX3rUYA.png"/></div></div></figure><p id="c582" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们思考下面这个问题:所有的母胶囊被激活的机会相等吗？🤔</p><p id="0d08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个很好的起点是尝试弄清楚是否所有的父胶囊期望接收相同数量的路由数据<em class="je"> ∑ </em> ᵢ <em class="je"> R_ij。</em>为了进一步研究这个问题，我们将考虑<a class="ae jd" href="https://openreview.net/pdf?id=HJWLfGWRb" rel="noopener ugc nofollow" target="_blank">论文</a>中的“更小的”胶囊网络配置(<em class="je"> A=64，B=8，C=D=16 </em>)。</p><p id="033b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下表显示了<em class="je">小</em>胶囊网络中各层的总结。我们使用以下术语:<em class="je"> K </em>是内核大小，<em class="je"> S </em>是步距，<em class="je"> Ch </em>是常规卷积中的通道数，<em class="je"> I </em>是输入胶囊类型数，<em class="je"> O </em>是输出胶囊类型数，<em class="je"> W &amp; H </em>是空间宽度和高度。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es kz"><img src="../Images/fed4fbe5aef1bf2b091bf501153d75c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7MLkt8QV6p97CEE_0uenA.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">“较小”胶囊网络架构中的层。请注意class_caps图层中的父胶囊如何接收比conv_caps1和conv_caps2图层更多的路径数据。</figcaption></figure><p id="dd74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了了解特定层中的父胶囊可以期望多少路由数据<em class="je"> ∑ </em> ᵢ <em class="je"> R_ij </em>，我们计算层<em class="je">、</em>的<em class="je"> mean_data </em>，这就是子胶囊的总数除以父胶囊的总数。(注:我们在这里假设所有的子胶囊都是活动的，这不太可能，但我们随它滚动，因为结论仍然有效。)</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es la"><img src="../Images/6decb4d7e90db9846275d8d5cc549027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWBoR62GCnitw8_OUrsMow.png"/></div></div></figure><p id="93dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于最后的<em class="je"> class_caps </em>层，子张量的空间维度被展平，因此子胶囊完全连接到类胶囊。</p><p id="c069" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看了一下表格，我们看到<em class="je"> class_caps </em>层的<em class="je"> mean_data </em>为<em class="je"> 80.0 </em>，大致比两个<em class="je"> conv_caps </em>层大<em class="je"> 30× </em>。因此，<em class="je"> class_caps </em>层中的父胶囊比其他层接收更多的路由数据。</p><p id="73ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，这到底为什么是一个问题呢？</p><p id="9f9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，回头看看<em class="je">成本</em>的等式，我们看到路由数据量<em class="je"> ∑ </em> ᵢ <em class="je"> R_ij </em>充当比例因子。如果路由数据太小，那么对于所有的父胶囊,<em class="je">成本</em>将接近于零；但是如果路线数据太大，那么<em class="je">成本</em>将变化很大，并且我们将在<em class="je">逻辑</em>函数的饱和区域中操作(并且梯度将为<br/>≈0😱).我们实际上想要的是将输入到<em class="je">逻辑</em>功能的数据很好地分布在一个合理的范围内，比如说<em class="je"> [-5，5] </em>。但是现在我们被卡住了，如果我们在一个合理的范围内，对于<em class="je"> class_caps </em>层，那么少了<em class="je"> 30× </em>路由数据的<em class="je"> conv_caps </em>层就会出现问题，反之亦然。</p><p id="1261" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那我们怎么解决这个问题呢？</p><p id="0c76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，一旦我们理解了这个问题，解决方法也很简单🎉。我们只是通过该层的<em class="je"> mean_data </em>来归一化路由数据<em class="je"> ∑ </em> ᵢ <em class="je"> R_ij </em>的数量，这实际上提高了训练的速度以及准确性。</p><h1 id="9eaa" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">陷阱3:争夺孩子</h1><p id="e051" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated"><em class="je">又名:不同位置的母胶囊争夺子胶囊</em></p><p id="a3bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑1D卷积胶囊层的情况，其内核大小为3，步幅为1，并且子层和父层都只包含1种胶囊类型。很简单。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es lb"><img src="../Images/a617767adc379f31f8f6eb120b4d1319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WV42N4HYnPkTyfTUKfDudQ.jpeg"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">每个父胶囊接收来自3个子胶囊的投票，但是竞争每个子胶囊的父胶囊的数量根据空间位置而不同。</figcaption></figure><p id="eaae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在M步骤中，内核在子胶囊上滑动，这样每个父母从3个子胶囊接收投票。在e步中，位于边缘的子胶囊每个仅接收来自1个父胶囊的反馈，而位于中心的子胶囊<em class="je"> C₃ </em>接收来自3个父胶囊的反馈(最大值等于内核大小<em class="je"> K </em>)。</p><p id="0362" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们看这个简单的例子时，很明显子胶囊在不同的空间位置接收来自父胶囊的反馈，因此这些父胶囊必须竞争子胶囊的投票。竞争发生在E步骤的分配概率的更新中，其中我们对竞争特定子胶囊的所有父胶囊进行归一化。辛顿公司在<a class="ae jd" href="https://openreview.net/ forum?id=HJWLfGWRb&amp;noteId=BJgX7Iy04m" rel="noopener ugc nofollow" target="_blank">回答</a>一个关于OpenReview.net的问题时进一步澄清了这一点。</p><p id="7637" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是当我们查看GitHub上的几个实现时，我们发现E-step中不正确的规范化是一个常见的错误。特别是，它们仅在母胶囊类型间标准化，而不在母胶囊位置间标准化。这样可以防止不同位置的父胶囊争夺子胶囊。正确的方法是对从特定子胶囊接收输入的所有父胶囊进行归一化，这将包括对父胶囊类型和父胶囊位置进行归一化。</p><p id="2385" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">唉😞，这一次的解决方案不是那么容易实现的，所以跟我在一起，我们慢慢来…</p><p id="7579" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步是查看内核大小和步幅，以确定哪些子胶囊属于每个父胶囊的感受野。然后，我们相应地平铺这些子胶囊，以便我们可以乘以<em class="je"> K </em>转换矩阵来得到“投票”。这里的技巧是，我们需要跟踪这些子胶囊中的每一个来自哪里(我们稍后将需要这一点)，所以我们将子胶囊和父胶囊之间的映射存储在一个2D二进制矩阵中，称为<em class="je">空间路由映射</em>。</p><p id="ff3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，通过相应的分配概率<em class="je"> R_ij </em>对<em class="je">投票</em>进行缩放，并在M步骤中用于计算每个父胶囊的平均值μ、标准偏差σ和激活度<em class="je"> a </em>。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es lc"><img src="../Images/37c15f4b4a45211b8695584bcc04bb36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8iyBpgjzpPJEkC0ZziGIw.jpeg"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">我们的M-step实现，其中我们在<em class="ld">空间路由图中跟踪子胶囊和父胶囊之间的连接。</em></figcaption></figure><p id="f67e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转到E步。</p><p id="490c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们查看对母胶囊有贡献的每个<em class="je">投票</em>，并计算它与该母胶囊的平均值μ相差多少。这给了我们选票<em class="je"> v_ij </em>的概率密度<em class="je"> p_ij </em>。</p><p id="abc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是大赛的时候了…🏆我们需要重新组织事情，以便我们可以看到哪些父胶囊正在竞争每个子胶囊。为了做到这一点，我们需要记住每个概率<em class="je"> p_ij </em>来自哪里。啊啊，还好我们在<em class="je">空间路线图中记录了这个确切的东西，</em>擦掉灰尘，是时候让它发挥作用了。我们使用<em class="je">空间路由图</em>将特定子胶囊的所有概率排列在一列中。这创建了概率密度的稀疏表示，然后我们将其乘以父胶囊的激活<em class="je"> a_j. </em>剩下的就是对竞争子胶囊的所有父胶囊进行归一化，这只是除以列总数，我们就完成了！🎉</p><p id="4566" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上我们已经完成了第一次迭代。但是我们只是更新分配概率<em class="je"> R_ij </em>，然后清洗并重复下一次，下一次，下一次迭代。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es le"><img src="../Images/1f7b4bb80940f20c2258a45bc4ad9af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TllguTB3uHaWxFPN04_pWg.jpeg"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">我们的E-step实现，其中我们使用<em class="ld">空间路由图来对齐一列中特定</em>子胶囊的竞争父胶囊。</figcaption></figure><h1 id="c7fa" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">结果</h1><p id="ccd3" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated"><em class="je">又名:结果</em></p><p id="2c34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了在EM路由的1-3次迭代的每个训练时段之后，我们的实现的测试精度。我们用2次路由迭代达到了我们的最佳精度<strong class="ih hj"> 95.4% </strong>，用3次迭代我们得到了93.7%。该表显示了我们的结果与GitHub上可用的其他开源实现的对比情况:<a class="ae jd" href="https://github.com/yl- 1993/ Matrix- Capsules- EM- PyTorch" rel="noopener ugc nofollow" target="_blank"> yl-1993 </a>、<a class="ae jd" href="https://github.com/www0wwwjs1/ Matrix- Capsules- EM-Tensorflow" rel="noopener ugc nofollow" target="_blank"> www0wwwjs1 </a>、<a class="ae jd" href="https://github.com/Officium/Capsules" rel="noopener ugc nofollow" target="_blank"> Officium </a>(记录于2019年5月28日)。我们实现的准确率为95.4%，比之前最好的开源实现的91.8%提高了3.8个百分点，但仍略低于Hinton &amp; Co .的97.8%。据我们所知，我们的实现是目前最好的开源实现。</p><div class="kj kk kl km fd ab cb"><figure class="lf kn lg lh li lj lk paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/d30da0cfba73ce64a52c820a0ec78345.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*MRCldJnzneOXI6xRA2EidQ.jpeg"/></div></figure><figure class="lf kn ll lh li lj lk paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/b8f4058e1d9b81769f578c10a8add900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*PVZOxKXctQFZ0D5F-LySUw.png"/></div></figure></div><h1 id="fab8" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">承认</h1><ol class=""><li id="07f3" class="lm ln hi ih b ii kd im ke iq lo iu lp iy lq jc lr ls lt lu bi translated">Jonathan Hui的博客，“<a class="ae jd" href="https://jhui.github.io/2017/11/14/Matrix-Capsules-with-EM-routing-Capsule-Network/" rel="noopener ugc nofollow" target="_blank">了解EM路由矩阵胶囊<br/>(基于Hinton的胶囊网络</a>)”</li><li id="1110" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">OpenReview上的问题和答案，“带EM路由的<a class="ae jd" href="https://openreview.net/forum?id=HJWLfGWRb" rel="noopener ugc nofollow" target="_blank">矩阵胶囊</a></li><li id="3dd1" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">索非张在GitHub上的实现，"<a class="ae jd" href="https://github.com/www0wwwjs1/Matrix-Capsules-EM-Tensorflow" rel="noopener ugc nofollow" target="_blank">Matrix-Capsules-EM-tensor flow</a>"</li><li id="8356" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">杨光在GitHub上的实现，“<a class="ae jd" href="https://github.com/gyang274/capsulesEM" rel="noopener ugc nofollow" target="_blank">封装EM </a></li></ol><h1 id="9e61" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">代码和论文的链接</h1><p id="ad0d" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">点击<a class="ae jd" href="https://github.com/IBM/matrix-capsules-with-em-routing" rel="noopener ugc nofollow" target="_blank">此处</a>获取包含代码的GitHub回购协议，点击<a class="ae jd" href="https://arxiv.org/pdf/1907.00652.pdf" rel="noopener ugc nofollow" target="_blank">此处</a>获取arXiv文件。</p><p id="4ecd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们欢迎投稿，所以如果你有关于如何进一步提高准确性的想法，请在GitHub上提交请求。</p><h1 id="2b83" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">如何引用这部作品</h1><p id="d2c8" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">如果你觉得这篇文章或代码对你的学术工作有用，请引用如下:</p><p id="dd19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.Gritzman，“Hinton <em class="je">等人</em>在<em class="je">2019澳门ij Cai’19人类大脑与人工智能(HBAI)联合研讨会上提出的“避免矩阵胶囊与EM路由的实施陷阱”。</em></p><p id="7859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你觉得这篇文章有帮助，请继续给我们一些掌声，这样这篇文章会排名更高，其他人会看到它👏👏👏。不要害羞，你可以随心所欲地点击拍手按钮(实际上我认为最多是50次拍手，但我们会在你到达那里时担心这个问题😜).</p></div></div>    
</body>
</html>