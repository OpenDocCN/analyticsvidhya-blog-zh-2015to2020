<html>
<head>
<title>Python decorator to parallelize any IO heavy function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python decorator 可以并行处理任何 IO 密集型函数</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-decorator-to-parallelize-any-function-23e5036fb6a?source=collection_archive---------4-----------------------#2020-10-06">https://medium.com/analytics-vidhya/python-decorator-to-parallelize-any-function-23e5036fb6a?source=collection_archive---------4-----------------------#2020-10-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d5998ba1e898574cd587aef8f0c13981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okCGUrYHvcCte8IJCQgC6w.jpeg"/></div></div></figure><p id="8863" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果只需在函数中添加一个装饰器就可以加快程序的速度，这不是很酷吗？如果您不必担心以并行方式运行列表中的数据，这不是很酷吗？</p><p id="5a3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天我们要写一个 python 装饰器，它会自动为你做这些，这样你就可以更专注于代码的逻辑，而不是担心多线程问题。</p><p id="a23e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们开始之前，关于 python 多线程的一些基础知识。</p><ol class=""><li id="0720" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">实现它的最佳位置是我们试图并行化的函数是<strong class="is hj"> IO 繁重的</strong>(睡眠时间对线程来说非常重要)。一些例子是<strong class="is hj"> API 调用、数据库调用、打开文件、等待数据流、从互联网下载文件</strong>。</li><li id="2679" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">通常的做法是保持产生的线程的<strong class="is hj">数量等于系统中可用的 CPU</strong>数量。(<strong class="is hj">重要</strong>:只是标准，<strong class="is hj">不是强制</strong>。将解释我们如何能够获得比同等数量的线程更多的线程，并从我们的系统中提取更多的线程)</li></ol></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="2666" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，我们将从装饰者的代码开始。如果你不能理解或者你不知道也不想理解编写装饰器的逻辑，你可以直接复制粘贴装饰器代码。在这个<a class="ae kj" href="https://github.com/varungv/MultiThreadingSample" rel="noopener ugc nofollow" target="_blank"> git repo </a>中有一个示例项目。</p><p id="951b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是我们将要使用的装饰代码。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="8d72" class="kt ku hi kp b fi kv kw l kx ky">import concurrent.futures<br/>import os<br/>from functools import wraps<br/><br/>def make_parallel(func):<br/>    <em class="kz">"""<br/>        Decorator used to decorate any function which needs to be parallized.<br/>        After the input of the function should be a list in which each element is a instance of input fot the normal function.<br/>        You can also pass in keyword arguements seperatley.<br/>        </em><strong class="kp hj"><em class="kz">:param</em></strong><em class="kz"> func: function<br/>            The instance of the function that needs to be parallelized.<br/>        </em><strong class="kp hj"><em class="kz">:return</em></strong><em class="kz">: function<br/>    """<br/><br/>    </em>@wraps(func)<br/>    def wrapper(lst):<br/>        <em class="kz">"""<br/><br/>        </em><strong class="kp hj"><em class="kz">:param</em></strong><em class="kz"> lst:<br/>            The inputs of the function in a list.<br/>        </em><strong class="kp hj"><em class="kz">:return</em></strong><em class="kz">:<br/>        """<br/>        </em># the number of threads that can be max-spawned.<br/>        # If the number of threads are too high, then the overhead of creating the threads will be significant.<br/>        # Here we are choosing the number of CPUs available in the system and then multiplying it with a constant.<br/>        # In my system, i have a total of 8 CPUs so i will be generating a maximum of 16 threads in my system.<br/>        number_of_threads_multiple = 2 # You can change this multiple according to you requirement<br/>        number_of_workers = int(os.cpu_count() * number_of_threads_multiple)<br/>        if len(lst) &lt; number_of_workers:<br/>            # If the length of the list is low, we would only require those many number of threads.<br/>            # Here we are avoiding creating unnecessary threads<br/>            number_of_workers = len(lst)<br/><br/>        if number_of_workers:<br/>            if number_of_workers == 1:<br/>                # If the length of the list that needs to be parallelized is 1, there is no point in<br/>                # parallelizing the function.<br/>                # So we run it serially.<br/>                result = [func(lst[0])]<br/>            else:<br/>                # Core Code, where we are creating max number of threads and running the decorated function in parallel.<br/>                result = []<br/>                with concurrent.futures.ThreadPoolExecutor(max_workers=number_of_workers) as executer:<br/>                    bag = {executer.submit(func, i): i for i in lst}<br/>                    for future in concurrent.futures.as_completed(bag):<br/>                        result.append(future.result())<br/>        else:<br/>            result = []<br/>        return result<br/>    return wrapper</span></pre><p id="7e4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们构建了一个样本虚拟函数，它将对 JSON 占位符 API 进行 HTTPS 调用。下面是示例代码，请注意，这只是为了演示 IO 密集型调用是什么样子，您可以用您想要并行化的任何函数来替换这个函数。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="bfff" class="kt ku hi kp b fi kv kw l kx ky">import requests<br/>def sample_function(post_id):<br/>    <em class="kz">"""<br/>        Just a sample function which would make dummy API calls<br/>    """<br/><br/>    </em>url = f"https://jsonplaceholder.typicode.com/comments?postId={post_id}"<br/>    response = requests.get(url)<br/>    if response.status_code == 200:<br/>        return response.json()<br/>    return {}</span></pre><p id="8cb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们尝试对此函数进行串行调用时，我们的代码看起来会像这样:</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="dddb" class="kt ku hi kp b fi kv kw l kx ky">list_of_post_ids = list(range(1, 20))<br/><br/># Serial way of calling the function<br/>results = []<br/>for post_id in list_of_post_ids:<br/>    res = sample_function(post_id)<br/>    results.append(res)</span></pre><p id="15fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，当我们使用装饰器时，代码简化为:</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="95d7" class="kt ku hi kp b fi kv kw l kx ky"># Paralleized way of calling the function<br/>results = make_parallel(sample_function)(list_of_post_ids)</span></pre><p id="74a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以观察调用函数的这两种方法之间的时间差，亲自看看多线程如何帮助我们加快 IO 繁重的调用。</p><p id="c430" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你不喜欢本文中的代码分割，你可以去我的<a class="ae kj" href="https://github.com/varungv/MultiThreadingSample" rel="noopener ugc nofollow" target="_blank"> git 库</a>那里，我已经托管了一个完整的演示项目。</p><p id="5152" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另外，注意这个装饰器只对有一个输入参数的函数有效。我将在下一篇文章中改进这个装饰器，并添加基于函数运行时自动选择线程数量的功能。</p></div></div>    
</body>
</html>