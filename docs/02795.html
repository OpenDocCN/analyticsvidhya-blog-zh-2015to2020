<html>
<head>
<title>Clean Matching with FuzzyWuzzy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与FuzzyWuzzy的干净搭配</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/clean-matching-with-fuzzywuzzy-c19bb8a9f197?source=collection_archive---------14-----------------------#2020-01-02">https://medium.com/analytics-vidhya/clean-matching-with-fuzzywuzzy-c19bb8a9f197?source=collection_archive---------14-----------------------#2020-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0d1b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Python中使用Levenshtein距离的字符串匹配</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/8792bea600eae138f368ad9474f104d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*1fSaIw1shl2nLvQI.jpeg"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">很接近，但是没有雪茄</figcaption></figure><p id="a1c4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Python配备了多种方法来处理字符串和整体语言(cue自然语言处理)中的不一致，以将单词矢量化并转换为可用的格式进行分析。使用诸如。upper()，。title()，。strip()，。替换()等。可用于格式化文本，匹配两个相似的字符串变得非常简单。然而，Python一次又一次地向我证明，几乎总有一种更简单的方法可以解决这种疯狂——或者接收错误消息。</p><p id="a242" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是我发现这个模糊不清的包裹的地方。当试图合并两个具有不同名称的数据帧时，这些数据帧大多相关但不完全相关，我最终耗尽了不同类型的连接和串联，以及数小时的头脑清醒，只是试图不丢失大多数不能直接匹配的行。与熊猫的结合比与FuzzyWuzzy的结合更具气质，FuzzyWuzzy允许你设置你想要匹配的两条弦之间的最小距离的阈值。</p><p id="2aae" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个距离以数学家Vladimir Levenshtein的名字命名，它计算将一个字符串直接更改为另一个字符串所需的字符编辑次数。两个字符串之间的距离由索引位置和从一个索引移动到另一个索引所需的计算成本来量化。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kf"><img src="../Images/068d8c55e6728a81770b44d45dddb910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aEs3vp-dR2s1n8zg.jpg"/></div></div></figure><p id="527d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要理解Levenshtein距离算法的实现:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="2dda" class="kp kq hi kl b fi kr ks l kt ku">import numpy as np</span><span id="baf2" class="kp kq hi kl b fi kv ks l kt ku">def levenshtein_ratio_and_distance(s, t, ratio_calc = False):</span><span id="3f02" class="kp kq hi kl b fi kv ks l kt ku"> “”” levenshtein_ratio_and_distance:<br/> Calculates levenshtein distance between two strings.<br/> If ratio_calc = True, the function computes the<br/> levenshtein distance ratio of similarity between two strings<br/> For all i and j, distance[i,j] will contain the Levenshtein<br/> distance between the first i characters of s and the<br/> first j characters of t<br/> “””</span><span id="e5db" class="kp kq hi kl b fi kv ks l kt ku"> # Initialize matrix of zeros <br/> rows = len(s)+1<br/> cols = len(t)+1<br/> distance = np.zeros((rows,cols),dtype = int)</span><span id="e475" class="kp kq hi kl b fi kv ks l kt ku"># Populate matrix of zeros with the indices of each character of both strings<br/> for i in range(1, rows):<br/> for k in range(1,cols):<br/> distance[i][0] = i<br/> distance[0][k] = k</span><span id="b10b" class="kp kq hi kl b fi kv ks l kt ku"># Iterate over the matrix to compute the cost of deletions, insertions and/or substitutions <br/> for col in range(1, cols):<br/> for row in range(1, rows):<br/> if s[row-1] == t[col-1]:<br/> cost = 0 <br/># If the characters are the same in the two strings in a given position [i,j] then the cost is 0</span><span id="ef73" class="kp kq hi kl b fi kv ks l kt ku"> else:<br/> # In order to align the results with those of the Python Levenshtein package, if we choose to calculate the ratio<br/> # the cost of a substitution is 2. If we calculate just distance, then the cost of a substitution is 1.<br/> if ratio_calc == True:<br/> cost = 2<br/> else:<br/> cost = 1<br/> distance[row][col] = min(distance[row-1][col] + 1, # Cost of deletions<br/> distance[row][col-1] + 1, # Cost of insertions<br/> distance[row-1][col-1] + cost) # Cost of substitutions<br/> if ratio_calc == True:<br/> # Computation of the Levenshtein Distance Ratio<br/> Ratio = ((len(s)+len(t)) — distance[row][col]) / (len(s)+len(t))<br/> return Ratio<br/> else:<br/> # print(distance) </span><span id="b402" class="kp kq hi kl b fi kv ks l kt ku"># Uncomment print(distance) if you want to see the matrix showing how the algorithm computes the cost of deletions, insertions and/or substitutions</span><span id="0760" class="kp kq hi kl b fi kv ks l kt ku"># This is the minimum number of edits needed to convert string a to string b<br/> return “The strings are {} edits away”.format(distance[row][col])</span></pre><p id="840d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用这个函数时，我们可以确定与两个字符串之间的Levenshtein距离相关的值，以及进行直接匹配所需的编辑次数。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="9037" class="kp kq hi kl b fi kr ks l kt ku">print(levenshtein_ratio_and_distance('3 Bears OG','Three Bears og'))<br/>print(levenshtein_ratio_and_distance('3 Bears OG','Three Bears og', ratio_calc=True))</span><span id="7aee" class="kp kq hi kl b fi kv ks l kt ku">The strings are 7 edits away<br/>0.5833333333333334</span></pre><p id="e65d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">取消对上述函数的<strong class="jl hj"> <em class="kw"> print </em> </strong> <em class="kw">(距离)</em>部分的注释会返回一个矩阵，该矩阵直观地解释了匹配字符串的计算成本。右下角的数字表示匹配字符串所需的编辑次数，每个水平和垂直相邻的值分别表示插入和删除。如果行/列中的两个字符不匹配，对角相邻值的代价可以是1，如果匹配，代价可以是0。每个单元旨在最小化计算差异的本地成本。下面，我们有字符串“3 Bears OG”和“3 Bears OG”之间的字符差异矩阵。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="cb04" class="kp kq hi kl b fi kr ks l kt ku">[[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]<br/> [ 1  1  2  3  4  5  6  7  8  9 10 11 12 13 14]<br/> [ 2  2  2  3  4  5  5  6  7  8  9 10 11 12 13]<br/> [ 3  3  3  3  4  5  6  5  6  7  8  9 10 11 12]<br/> [ 4  4  4  4  3  4  5  6  5  6  7  8  9 10 11]<br/> [ 5  5  5  5  4  4  5  6  6  5  6  7  8  9 10]<br/> [ 6  6  6  5  5  5  5  6  7  6  5  6  7  8  9]<br/> [ 7  7  7  6  6  6  6  6  7  7  6  5  6  7  8]<br/> [ 8  8  8  7  7  7  6  7  7  8  7  6  5  6  7]<br/> [ 9  9  9  8  8  8  7  7  8  8  8  7  6  6  7]<br/> [10 10 10  9  9  9  8  8  8  9  9  8  7  7  <strong class="kl hj">7</strong>]]</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kx"><img src="../Images/d5d5b0979307f34fabcb3a4aa1d8630c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dNbZHP9iAeFFRcBL"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">红色的1表示需要1次操作来将M变成空字符串</figcaption></figure><p id="090f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">漂亮但冗长，所以让我们通过安装和导入Levenshtein包来使它变得更加简单。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="f91d" class="kp kq hi kl b fi kr ks l kt ku">pip install python-Levenshtein==0.12.0</span><span id="a7dc" class="kp kq hi kl b fi kv ks l kt ku">import Levenshtein as lev</span><span id="8499" class="kp kq hi kl b fi kv ks l kt ku">lev.distance('3 Bears OG','Three Bears og') = 7</span></pre><p id="5632" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Levenshtein包返回匹配字符串所需的编辑次数，而不是调用距离函数时两者之间的实际距离。为了将从距离中获得的值投入使用，我们将fuzzywuzzy应用于我们的字符串或字符串列表，以收集相关的术语。Fuzzywuzzy通过其ratio函数利用Levenshtein距离来计算两个字符串之间的字符差异。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="85c4" class="kp kq hi kl b fi kr ks l kt ku">pip install fuzzywuzzy</span><span id="faf3" class="kp kq hi kl b fi kv ks l kt ku">from fuzzywuzzy import fuzz<br/></span><span id="ce2d" class="kp kq hi kl b fi kv ks l kt ku"># Create a function that takes two lists of strings for matching<br/>def match_name(name, list_names, min_score=0):<br/>    # -1 score incase we don't get any matches<br/>    max_score = -1<br/>    # Returning empty name for no match as well<br/>    max_name = ""<br/>    # Iterating over all names in the second list<br/>    for name2 in list_names:<br/>        #Finding fuzzy match score<br/>        score = fuzz.ratio(name, name2)<br/>        # Checking if we are above our threshold and have a better score<br/>        if (score &gt; min_score) &amp; (score &gt; max_score):<br/>            max_name = name2<br/>            max_score = score<br/>    return (max_name, max_score)</span></pre><p id="c976" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上述函数旨在从不同的数据帧中获取各种名称，以便基于相似性合并到一个数据帧中。对于我的特殊用途，我输入各种大麻品种的名称，以匹配不同网站文本中的偏差。例如，如上所述，菌株3 Bears Og出现在我参与的项目的所有三个数据框架中，但在不同的数据库中被写成“3 Bears OG”和“3 Bears Og ”,由于大写和拼写的差异，这在合并时产生了错误。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="4035" class="kp kq hi kl b fi kr ks l kt ku"># List for dicts for easy DataFrame creation<br/>dict_list = []<br/># iterating over df with more strains<br/>for name in df1.strain:<br/>    # Use our method to find best match, we can set a threshold here<br/>    match = match_name(name, df3.name, 80)<br/>    <br/>    # New dict for storing data<br/>    dict_ = {}<br/>    dict_.update({"strain" : name})<br/>    dict_.update({"name" : match[0]})<br/>    dict_list.append(dict_)<br/>    <br/>merge_table = pd.DataFrame(dict_list)</span></pre><p id="4460" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面的代码不包括两个字符串之间的距离得分，但这可以通过更新用匹配值创建的字典很容易地显示出来，这将在DataFrame中显示为一个新列。仅显示第一个匹配，如<em class="kw"> match[0]所示。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/52bd64d4820cb61c2fb402adc9bafa4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*GXdQiXFhDPfM1MKDB4Qbog.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">匹配字符串的示例</figcaption></figure><p id="2f0d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，我们可以看到具有小写值的菌株与标题案例中的菌株相匹配，而没有进行任何文本预处理。类似地，在计算蓝色的梦是否和蓝色的梦最相似时，撇号也被赋予了一个权重。</p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="4931" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">FuzzyWuzzy可以与NLP一起使用，以改进分类变量在数据科学和分析的各个方面的使用。在它最简单的形式中，这只是一种有趣的方式，看看需要做多少工作才能使两个字符串相同。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lg"><img src="../Images/d56ab49b1d3903247bcf654c996a7538.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/0*fN2ixCSM5HPRwdJX"/></div></figure></div></div>    
</body>
</html>