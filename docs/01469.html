<html>
<head>
<title>The Infinite Monkey Theorem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无限猴子定理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-infinite-monkey-theorem-4a56dd0015e3?source=collection_archive---------3-----------------------#2019-10-24">https://medium.com/analytics-vidhya/the-infinite-monkey-theorem-4a56dd0015e3?source=collection_archive---------3-----------------------#2019-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/e5417e5cd9292aceba3beeed9cbb6e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*cKoivj5iORfZ0Yn9qHtoxw.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><a class="ae iq" href="https://en.wikipedia.org/wiki/Infinite_monkey_theorem_in_popular_culture" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Infinite _ monkey _ theory _ in _ popular _ culture</a></figcaption></figure><p id="7377" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">几天前，我从朋友那里知道了什么是“无限猴子定理”。</p><p id="ce9c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">互联网上是怎么说的:</p><blockquote class="jp"><p id="560a" class="jq jr hi bd js jt ju jv jw jx jy jo dx translated">无限猴子定理指出，一只猴子在打字机键盘上随机敲击键盘无限长时间，几乎肯定会打出给定的文本，如威廉·莎士比亚全集。</p></blockquote><p id="332a" class="pw-post-body-paragraph ir is hi it b iu jz iw ix iy ka ja jb jc kb je jf jg kc ji jj jk kd jm jn jo hb bi translated">我很好奇。在我一头扎进万维网和它成千上万的观点之前，我想在某种程度上测试一下。</p><h2 id="15a2" class="ke kf hi bd kg kh ki kj kk kl km kn ko jc kp kq kr jg ks kt ku jk kv kw kx ky bi translated">数学</h2><p id="9df6" class="pw-post-body-paragraph ir is hi it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hb bi translated">好吧，让我们来谈谈最基本的。说猴子在英文键盘上打字。暂时忽略标点符号键或数字键(但不要忽略空格键)。</p><p id="04e8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现代英语字母表中有26个字母。这些不同长度的字母组成了英语单词。根据我在这个测试中使用的单词列表，有7186个四个字母的单词。如果打字的猴子随机敲击键盘上的四个键，那么它是这个列表中匹配的四个字母单词的概率是多少？</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es le"><img src="../Images/892af16ca3176e108fc2d8ca86ce2391.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*xJ3RFauErB-zukMhMdTBqg.png"/></div></figure><p id="439d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">它是单词表中4个字母单词的总数除以从26个字母中抽取的4个字母排列的总数。</p><p id="7882" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这个概率结果是7186/(26！/22!) = 0.02.如果猴子随机敲击四个键，它有2%的机会造出一个有意义的四个字母的单词。</p><h2 id="148f" class="ke kf hi bd kg kh ki kj kk kl km kn ko jc kp kq kr jg ks kt ku jk kv kw kx ky bi translated">探索和编写脚本</h2><p id="7e83" class="pw-post-body-paragraph ir is hi it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hb bi translated">我在<a class="ae iq" href="https://github.com/dwyl/english-words" rel="noopener ugc nofollow" target="_blank">这里</a>的一个文本文件里找到了一个英文单词列表。我不确定它是否和英语词典中的单词列表一样好，但是它符合这个测试的目的。要用的文件是<em class="lj"> words_alpha.txt </em>。在将所有的单词加载到一个列表中后，我根据每个单词的字母数将它们分开。</p><pre class="lf lg lh li fd lk ll lm ln aw lo bi"><span id="baf6" class="ke kf hi ll b fi lp lq l lr ls">word_counts = {}<br/>for i in range(1,max_len+1):<br/>    word_counts[i] = []<br/>for i in range(len(words)):<br/>    for key in word_counts.keys():<br/>    if len(words[i]) == key:<br/>        word_counts[key].append(words[i])</span></pre><p id="dea3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">你有没有想过不同字母数的单词分布？它看起来是这样的:</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lt"><img src="../Images/9e28b79a1bbb357d7623977c33744157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXov--kaejCLBkPCN9-DqA.png"/></div></div></figure><p id="fb82" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">下一步是随机生成给定字符长度的字母序列。你说用4个字符生成一个序列，你得到4个字符的输出。一个函数会一直从字母表中随机选择字母，直到达到字符限制(输入)。</p><pre class="lf lg lh li fd lk ll lm ln aw lo bi"><span id="b142" class="ke kf hi ll b fi lp lq l lr ls">def generate_string(n, max_len=max_len):<br/>    word = []<br/>    if n &lt;= max_len:<br/>        for i in range(n):<br/>            word.append(word_counts[1][np.random.randint(0, len(word_counts[1]))])<br/>            #word_counts[1] holds the alphabet<br/>    else:<br/>        print("Letter count exceeds")<br/>    return ''.join(word)</span></pre><ul class=""><li id="4af7" class="ly lz hi it b iu iv iy iz jc ma jg mb jk mc jo md me mf mg bi translated"><strong class="it hj">上面的max_len </strong>是从网上取来的单词列表中一个单词的最多字符数。是31！</li><li id="56f6" class="ly lz hi it b iu mh iy mi jc mj jg mk jk ml jo md me mf mg bi translated">有31个字母的单词是:<em class="lj">二氯二苯三氯乙烷</em></li></ul><p id="62e4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如你所见，生成的随机序列不是一个单词。要找到匹配的单词需要一些试验。为了实现这一点，我一直在生成字符串，直到找到匹配为止。</p><pre class="lf lg lh li fd lk ll lm ln aw lo bi"><span id="2bf9" class="ke kf hi ll b fi lp lq l lr ls">def generate_word(word_list, n):<br/>    gen_word = ''<br/>    count = 0<br/>    while gen_word not in word_list:<br/>        gen_word = generate_string(n)<br/>        count += 1<br/>    return gen_word, count</span></pre><p id="96c1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这是一个有趣的练习。两个、三个或四个字母的单词似乎很容易预测。上面的直方图指出，字数随着字符长度的增加而增加，直到9个字符，然后下降。这种下降并没有真正增加匹配随机字符串的概率；一个词的字符越多，概率越低。</p><p id="bf8e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里有一个例子:</p><pre class="lf lg lh li fd lk ll lm ln aw lo bi"><span id="ada2" class="ke kf hi ll b fi lp lq l lr ls">In [11]:<br/>s = generate_word(four_letter_words, 4)<br/>print(s[0])<br/>print("Number of attempts: {}".format(s[1]))</span><span id="379d" class="ke kf hi ll b fi mm lq l lr ls">Out [11]:<br/>girl<br/>Number of attempts: 23</span></pre><p id="9d0f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这里，我试图记录寻找第一个匹配的尝试次数。我想这有点像网上约会。我对2、3、4、5和6个字母单词分别做了1000次，并记录了第一次成功匹配的尝试次数。</p><pre class="lf lg lh li fd lk ll lm ln aw lo bi"><span id="df94" class="ke kf hi ll b fi lp lq l lr ls">%%time<br/>attempts = {}<br/>for i in range(2,7):<br/>    start = timeit.default_timer()<br/>    attempts[i] = []<br/>    for j in range(1000):<br/>        s = generate_word(word_counts[i], i)<br/>        attempts[i].append(s[1])<br/>    stop = timeit.default_timer()<br/>    print("Iterations for letter count of {} complete and loop time elapsed is {}s".format(i, round((stop-start),3)))</span></pre><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mn"><img src="../Images/50ce293559ee8a05c66dce5a4b881dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TPUklc1RMPcLlu4PpGMkQ.png"/></div></div></figure><p id="0a04" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">看看计算时间(对于我能负担的计算能力)。<strong class="it hj">您可以看到，生成第一个匹配的时间随着字符长度呈指数增长。</strong></p><p id="ddf4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对于不同的字符长度，平均需要尝试多少次才能找到成功的单词匹配？“尝试次数”轴是对数轴。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mo"><img src="../Images/62b391d00b8f70d250f5b614fa3f16aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQ6RLw9MJAzrFnXW1btOdQ.png"/></div></div></figure><p id="e6b9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">随着字符长度的增加，尝试生成匹配单词的次数也会增加。</strong></p><p id="0bf5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">猴子可以用RNN，对不对？现在是2019年，但它仍然是一只猴子，因此继续以随机键盘敲击的蛮力创作莎士比亚的作品。</p><p id="023c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">既然我们已经看到了部分迭代的作用，那么是时候将更多的数学知识带入图片中了。我们知道成功的概率，但为了准确，我们必须考虑达到成功匹配所需的迭代次数。</p><p id="e732" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">为此，我们使用几何概率分布。假设本周每天下雨的可能性为20%。从现在起整整三天后可能下雨的概率是0.8 * 0.8 * 0.2。这就是原则。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/4cda19456009f0e691517ab48a269202.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*1W2wv7hsADw4_QeeSUzO9Q.png"/></div></figure><p id="a4af" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在scipy.stats.geom的帮助下实现它。在这里，成功确实意味着找到匹配的单词，因此最终的概率只是总和，而不是从1中减去。</p><pre class="lf lg lh li fd lk ll lm ln aw lo bi"><span id="a263" class="ke kf hi ll b fi lp lq l lr ls">def calc_permutations(l, n=26):<br/>    return factorial(n)/factorial(n-l)</span><span id="71be" class="ke kf hi ll b fi mm lq l lr ls">def calc_probability(nl, npl):<br/>    return nl/npl</span><span id="2ab7" class="ke kf hi ll b fi mm lq l lr ls">def prob_success(k, l):<br/>    p = calc_probability(len(word_counts[l]), calc_permutations(l))<br/>    total = 0<br/>    for i in range(k):<br/>        total += geom.pmf(k, p)<br/>    return total</span></pre><h2 id="b20c" class="ke kf hi bd kg kh ki kj kk kl km kn ko jc kp kq kr jg ks kt ku jk kv kw kx ky bi translated">存在还是毁灭</h2><p id="715c" class="pw-post-body-paragraph ir is hi it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hb bi translated">现在，为了将所有这些联系在一起，我将尝试估计生成与这一小节的标题完全相同的序列的概率:<em class="lj">“生存还是毁灭”</em>下面的函数将完成这一任务。</p><pre class="lf lg lh li fd lk ll lm ln aw lo bi"><span id="38f0" class="ke kf hi ll b fi lp lq l lr ls">def generate_sentence_by_word(string):<br/>    sentence = string.split()<br/>    print("Sentence array: {}".format(sentence))<br/>    letter_count = [len(w) for w in sentence]<br/>    print("Letter count array: {}".format(letter_count))<br/>    generated_sentence = []<br/>    sentence_attempts = []<br/>    success_probs = []<br/>    for i in range(len(letter_count)):<br/>        s = generate_word([sentence[i]], letter_count[i])<br/>        if s[0] == sentence[i]:<br/>            generated_sentence.append(s[0])<br/>            sentence_attempts.append(s[1])<br/>            success_probs.append(prob_success(s[1], letter_count[i]))<br/>            print("Generated word {} in {} attempts".format(s[0], s[1]))<br/>    print("Generation complete: {}".format(" ".join(generated_sentence)))<br/>    return generated_sentence, sentence_attempts, success_probs</span></pre><p id="9dad" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">假设运行这个只需要5秒钟，想象一下一只半机械人猴子每秒钟可以打8000个单词。你可能已经发现了——上面的函数有点小问题。它得到一个单词匹配，然后继续下一个。这个定理没有说明这一点。为了遵守这个定理，生成的字母序列(带空格)必须按照这个顺序与莎士比亚的作品完全匹配。</p><p id="c354" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">即使对于上面生成的序列，让我们假设您给猴子一个逐字匹配的机会。即使这样，得到正确序列的概率也只有10^-12量级。那真的很小。这么小。</p><pre class="lf lg lh li fd lk ll lm ln aw lo bi"><span id="cc58" class="ke kf hi ll b fi lp lq l lr ls">Generated word "to" in 314 attempts.<br/>Generated word "be" in 170 attempts.<br/>Generated word "or" in 2215 attempts.<br/>Generated word "not" in 9605 attempts.<br/>Generated word "to" in 125 attempts.<br/>Generated word "be" in 494 attempts.</span></pre><p id="6cbe" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">那好吧。</p><pre class="lf lg lh li fd lk ll lm ln aw lo bi"><span id="7434" class="ke kf hi ll b fi lp lq l lr ls">def generate_full_sentence(string):<br/>    letter_count = [len(w) for w in string.split()]<br/>    print("Letter count array: {}".format(letter_count))<br/>    generated_sentence = []<br/>    count = 0<br/>    while " ".join(generated_sentence) != string:<br/>        for i in range(len(letter_count)):<br/>            generated_sentence.append(generate_string(letter_count[i]))<br/>        count += 1<br/>        if count%10000 == 0:<br/>            print("Trial no {}".format(count))<br/>    return generated_sentence, count</span></pre><p id="609a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这让我的电脑死机了好几次！所以我从Google Cloud剥离了一个增强的虚拟机，有8个CPU和52GB内存。</p><pre class="lf lg lh li fd lk ll lm ln aw lo bi"><span id="d14f" class="ke kf hi ll b fi lp lq l lr ls">Sentence array: ['to', 'be', 'or', 'not', 'to', 'be']<br/>Letter count array: [2, 2, 2, 3, 2, 2]<br/>Trial no 10000<br/>Trial no 20000<br/>Trial no 30000<br/>.<br/>.<br/>.<br/>Trial no 710000<br/>Trial no 720000<br/>.<br/>.<br/>Trial no 1000000</span></pre><p id="d548" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这一点上，它已经运行了大约两天，我杀了它。在一百万次尝试后，没有运气产生完全相同的序列，“<em class="lj">成为或不成为</em>”。</p><p id="4cf1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以我认为，一只猴子真的需要无限长的时间才能创作出一幅莎士比亚的作品。似乎有争议的是复制完全相同的作品的想法——这很难理解，但数学是成立的！</p></div></div>    
</body>
</html>