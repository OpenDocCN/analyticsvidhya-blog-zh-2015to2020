<html>
<head>
<title>Explore your SQL Query Execution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索您的SQL查询执行</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/explore-your-recursive-sql-query-f15b120e518e?source=collection_archive---------7-----------------------#2019-11-29">https://medium.com/analytics-vidhya/explore-your-recursive-sql-query-f15b120e518e?source=collection_archive---------7-----------------------#2019-11-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/ea6c2cb819ae0bae4a332093e830351e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*uCiOT1ZSwE9NnNuZOjdTYA.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">西蒙·米加吉在<a class="ae iq" href="https://unsplash.com/s/photos/plan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0962" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">有了从<a class="ae iq" rel="noopener" href="/@isharamadhavi1/sql-recursive-queries-2aa670906ec1">以前写的关于递归cte的文章</a>中获得的基本理解，是时候探索这些查询背后的执行世界了。尽管递归查询的概念相对较新，但执行计划通过识别查询中可能存在的缺陷，在优化查询性能方面发挥了重要作用。</p><p id="e1fb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对优化如何发生的基本理解是有价值的。MySQL使用客户端-服务器协议。下面简要列出了该方案的步骤。</p><ol class=""><li id="dca2" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx bi translated">一旦客户端点击查询的<em class="jy">执行</em>，服务器首先分析查询的语法。<em class="jy">语法</em> <em class="jy">分析</em>验证语言成分是否正确形成以构建有效语句。</li><li id="e640" class="jp jq hi it b iu jz iy ka jc kb jg kc jk kd jo ju jv jw jx bi translated">接下来，评估语法上合法的查询的含义，这被称为<em class="jy">语义</em> <em class="jy">分析</em>。在此阶段，将检查所有引用数据库对象和主机变量的准确用法。</li><li id="0b74" class="jp jq hi it b iu jz iy ka jc kb jg kc jk kd jo ju jv jw jx bi translated">一旦编写的SQL查询通过了这两项检查，它将被服务器授予一个SQL ID和(MD5)散列值。哈希值基于语句的几百个字符，所以可能会发生哈希冲突，尤其是对于长语句。</li><li id="fe00" class="jp jq hi it b iu jz iy ka jc kb jg kc jk kd jo ju jv jw jx bi translated">下一步是将查询解析成解析树。记住这个目标，查询被暴露给一个共享内存区域(<em class="jy">共享池</em>)，其中包含我们已经执行的SQL查询的解析树和执行计划。每个唯一的SQL查询将拥有一个唯一的共享SQL区域。之后，解析可以通过两种主要方式进行。</li></ol><p id="3874" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我<em class="jy">。软解析</em></p><p id="f1be" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果从共享池中为SQL查询生成的哈希值找到匹配的哈希值，将使用相同的解析树和执行计划。</p><p id="bcda" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">二。<em class="jy">硬解析</em></p><p id="b975" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果没有找到匹配的哈希值，查询将被交给<em class="jy">查询优化器</em>来选择最佳执行计划和解析树。MySQL使用一个<em class="jy">基于成本的优化器</em>，这意味着它试图预测各种执行计划的成本，并选择最便宜的。</p><h2 id="7a1b" class="ke kf hi bd kg kh ki kj kk kl km kn ko jc kp kq kr jg ks kt ku jk kv kw kx ky bi translated">执行计划</h2><p id="b115" class="pw-post-body-paragraph ir is hi it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hb bi translated">MySQL不像许多其他数据库产品那样生成字节码来执行查询。相反，查询执行计划充当查询执行引擎为了产生查询结果而必须遵循的指令树。执行计划中最重要的优化之一是连接优化。下面的概念图说明了多表查询是如何以4个表的连接形式在我们的脑海中形成的。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es le"><img src="../Images/38db775cdacde4321a6d25252c0250c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*Ss3AnYF5ZFZuvp5ycWgJ5w.png"/></div></figure><p id="948c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">然而，MySQL查询执行计划总是以<em class="jy">左深树</em>的形式完成这项工作，如下所示。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/6adce91087be4c908981ebbfa069d964.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*8GJj0HbYMs9pp77ipqXbOg.png"/></div></figure><p id="7ca8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">5.下一个阶段是查询执行阶段。与优化阶段相比，执行阶段通常没有那么复杂:MySQL只是遵循查询执行计划中给出的指令。</p><p id="6510" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">6.查询执行的最后一个阶段是将结果集发送到客户端，即出现空结果集时的事件。</p><p id="9583" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">下图简要说明了查询的执行阶段。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/35c66b473aec5e72d9939ac15ce88896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*fPpDHpkJpbkHx7uG-UxL9g.png"/></div></figure></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="e615" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">记住这个简单的概念，让我们用<a class="ae iq" rel="noopener" href="/@isharamadhavi1/sql-recursive-queries-2aa670906ec1">上一篇关于递归查询的文章</a>中的一个例子来阐明查询执行计划的想法。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/e442186c355e4783de1b082e6918a7de.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*ApBjjaFOx_Wl6XqV.png"/></div></figure><p id="6fae" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们创建了一个具有父子关系的皇室成员示例表，并提高了我们编写简单递归查询的技能。现在，我们可以通过从SQL编辑器执行我们的查询，然后在MySQL Workbench的<strong class="it hj">查询</strong>结果选项卡中选择<strong class="it hj">执行计划</strong>选项卡，来检查服务器是如何创建其执行计划的。默认计划以<strong class="it hj">可视</strong>格式显示，我们也可以将其更改为<strong class="it hj">表格</strong>。或者，如果我们只需要表格解释，在任何查询的最开始使用<strong class="it hj"> EXPLAIN </strong>关键字。下面的递归查询将按照数据库表输出伊丽莎白女王的后代(包括她自己)。</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="aae1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">查询的执行计划如下。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/861b3f1300e6f55bcd2da50e9172d457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*DeJM_j4TYZwv-WvJAPkrAw.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">来自MySQL工作台的查询执行计划</figcaption></figure><h2 id="c52e" class="ke kf hi bd kg kh ki kj kk kl km kn ko jc kp kq kr jg ks kt ku jk kv kw kx ky bi translated"><strong class="ak">需要快速浏览的内容:</strong></h2><ul class=""><li id="6875" class="jp jq hi it b iu kz iy la jc lw jg lx jk ly jo lz jv jw jx bi translated">这个执行计划也采用了<em class="jy">左深树</em>的形式。</li><li id="3381" class="jp jq hi it b iu jz iy ka jc kb jg kc jk kd jo lz jv jw jx bi translated">每个<strong class="it hj"> query_block# </strong>表示查询中的一个SELECT语句。</li></ul><p id="4f5a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">query_block#1:最外层的SELECT语句</p><p id="c0f0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">query _ block # 2:UNION操作的一个输入(定位点成员)</p><p id="af9d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">query _ block # 3:UNION操作的下一个输入。(递归成员)</p><ul class=""><li id="e268" class="jp jq hi it b iu iv iy iz jc jr jg js jk jt jo lz jv jw jx bi translated">自底向上的执行树逐步构造最终的结果集。</li><li id="bf74" class="jp jq hi it b iu jz iy ka jc kb jg kc jk kd jo lz jv jw jx bi translated">框右上角的数字:过滤后表中预期使用的行数</li><li id="6b67" class="jp jq hi it b iu jz iy ka jc kb jg kc jk kd jo lz jv jw jx bi translated">方框左上角的数字:访问该表的相对成本</li><li id="4c2e" class="jp jq hi it b iu jz iy ka jc kb jg kc jk kd jo lz jv jw jx bi translated">代表查询的锚部分的query_block#2被估计为全表扫描的结果。即使我们要执行查询，我们也必须遍历整个表，以便找出包含姓名“ELIZABETH”的行。因此，我们可以观察到服务器做出了正确的选择。区块用红框表示，表示运营成本相对较高。紧靠块下方的文本是所使用的<em class="jy">表/别名</em>。</li><li id="5a95" class="jp jq hi it b iu jz iy ka jc kb jg kc jk kd jo lz jv jw jx bi translated">左边的菱形操作符代表一个嵌套循环，换句话说，是表上的一个<strong class="it hj">连接</strong>。名称<em class="jy">嵌套循环</em>暗示嵌套循环的<em class="jy">。原因是，在执行连接操作时，我们从一个表中获取一条记录，并从下一个表中检索所有匹配的记录，就像执行嵌套的for循环一样。这里嵌套循环的一个输入是用红框表示的<em class="jy"> top_down_cte </em>(递归查询本身)记录。匹配成员表中的记录是另一个输入。为了从成员表中获取匹配结果，需要<em class="jy"> </em>读取<em class="jy"> top_down_cte </em>的所有记录。因此，<em class="jy"> top_down_cte </em>在查询执行计划中也被标记为<strong class="it hj">全表扫描</strong>，在<em class="jy">红色</em>框内。嵌套循环的另一个输入，在<em class="jy">绿色</em>框中，使用非唯一键查找，并指示开销为中低。如果行数很多，操作成本可能会很高。突出显示的文本行给出了用于连接操作的外键约束或任何使用的索引的名称。PARENT_ID列不是唯一的，但是它通过外键约束引用ID列，该列是同一表的主键。由于这个原因，给定一个来自<em class="jy"> top_down_cte，</em>的ID，查找其PARENT_ID与来自MEMBERS表的给定ID相似并不困难。因此，该块显示为绿色。</em></li></ul><p id="9681" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这些信息集合一起给出了改进我们的查询的可能方法。已经看到query_block#2是红色的，并且相对来说包含一个开销很大的操作，也许我们可以尝试索引表中的NAME列，这样它就不会完全扫描表。相反，它可以使用NAME列上的索引来筛选出名称为“ELIZABETH”的行。下面的执行计划证明了这一点，如我们所料，用绿色表示query_block#2。另外，块#2的查询成本减少了三分之一。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/66e61cdff608d06e9751986d4a64077e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*11w9tZwmkapuV91zZG8TgA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">在成员表中索引名称列之后，从MySQL Workbench执行查询计划</figcaption></figure><p id="0b40" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我希望您喜欢学习SQL执行背后的真实世界。从这篇文章中得到的启示是，<em class="jy">永远不要在没有优化的情况下实现查询！</em></p><p id="8fcf" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">参考文献</strong></p><div class="mb mc ez fb md me"><a href="https://oracle.readthedocs.io/en/latest/sql/plans/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hj fi z dy mj ea eb mk ed ef hh bi translated">执行计划-面向开发人员的Oracle SQL &amp; PL/SQL优化2.3.1文档</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">当您点击执行时，您的SQL语句会发生什么变化？首先，Oracle检查您的语句是否有明显的错误。的…</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">oracle.readthedocs.io</p></div></div></div></a></div></div></div>    
</body>
</html>