<html>
<head>
<title>webG: Visualization of DOM Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">webG:DOM树的可视化</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/webg-visualization-of-dom-tree-96f15bc81aa2?source=collection_archive---------5-----------------------#2020-11-06">https://medium.com/analytics-vidhya/webg-visualization-of-dom-tree-96f15bc81aa2?source=collection_archive---------5-----------------------#2020-11-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="4db8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">网络数据分析的新视角</h1><p id="e052" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">随着强大的机器学习算法的出现，越来越多的应用程序变得由数据驱动。人类积累的最大信息来源是互联网。当我们认为互联网是有用数据的来源时，我们会想到从网页中抓取文本、图像和其他有价值的信息。获取的数据将被整理、清理并转换成适合进一步分析和预测建模的格式。特征工程过程的很大一部分已经被深度学习淘汰了。</p><p id="3ab9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">互联网上充斥着结构化数据。当我们抓取网页时，我们试图摆脱这种结构信息。想象使用这些信息作为数据分析的一部分。让我们更大胆一点，想象建立一个预测模型，可以直接对网页上的结构化内容进行训练。确实是一个雄心勃勃的想法。</p><p id="29d9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">网页由文本内容组成，这些文本内容在空间上以一种能让读者集中注意力的方式分布。查看页面的另一种方式是使用开发人员工具检查页面。它将网页中的元素显示为一棵树。我们称之为DOM(文档对象模型)树。在本文中，我将展示我为可视化网页的DOM树而构建的工具——webG。我将一步一步地介绍项目的开发过程。</p><p id="7e6a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，你为什么想要可视化DOM树呢？这不是应该对用户隐藏的吗？</p><blockquote class="kg kh ki"><p id="97a3" class="jd je kj jf b jg kb ji jj jk kc jm jn kk kd jq jr kl ke ju jv km kf jy jz ka hb bi translated">视角的改变值80智商分。</p></blockquote><p id="2640" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将DOM树可视化为图形揭示了关于网页的不太明显、有趣且潜在有用的信息。webG为你提供了一套看待互联网的新镜头。你想怎么处理就怎么处理吧！任何人都可以在github 上使用和贡献webG。</p><p id="b4ea" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">看看我们的<a class="ae kn" href="https://webg.pythonanywhere.com/" rel="noopener ugc nofollow" target="_blank">演示</a>。</p><p id="6503" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kj">请注意，演示是使用免费帐户托管的。大多数网站将被屏蔽。试试谷歌的页面，维基百科等。</em></p><h2 id="9b78" class="ko ig hi bd ih kp kq kr il ks kt ku ip jo kv kw it js kx ky ix jw kz la jb lb bi translated">目录</h2><ul class=""><li id="5f1a" class="lc ld hi jf b jg jh jk jl jo le js lf jw lg ka lh li lj lk bi translated"><a class="ae kn" href="#9132" rel="noopener ugc nofollow">什么是图形？</a></li><li id="cc07" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><a class="ae kn" href="#24da" rel="noopener ugc nofollow">网络X </a></li><li id="c8c2" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><a class="ae kn" href="#d41e" rel="noopener ugc nofollow">为什么选择webG？</a></li><li id="5c8c" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><a class="ae kn" href="#6723" rel="noopener ugc nofollow">功能</a></li><li id="378a" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><a class="ae kn" href="#f2c4" rel="noopener ugc nofollow">为什么是烧瓶</a>？</li><li id="f390" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><a class="ae kn" href="#cca7" rel="noopener ugc nofollow">你好烧瓶</a>！</li><li id="7519" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><a class="ae kn" href="#cc82" rel="noopener ugc nofollow"> El Glorioso Grapho </a></li><li id="3b61" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><a class="ae kn" href="#35ec" rel="noopener ugc nofollow">程序流程</a></li><li id="4708" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><a class="ae kn" href="#0115" rel="noopener ugc nofollow">应用</a></li><li id="d12b" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><a class="ae kn" href="#2ec5" rel="noopener ugc nofollow">案例研究</a></li><li id="1bea" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><a class="ae kn" href="#67ce" rel="noopener ugc nofollow">如何投稿</a></li></ul><p id="de8c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们从一些基础开始。</p><h1 id="9132" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是图？</h1><p id="7b17" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">图表是一组数据的图解说明。它是由节点和边组成的非线性数据结构。节点有时也称为顶点，边是连接图中任意两个节点的线或弧。下面给出了一个简单的图形结构:</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div class="er es lq"><img src="../Images/8302ecfe6f2bb3157cf8ac15952d2ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Spl6FJi_pDuAy_y3ZYZmxg.png"/></div></figure><h1 id="24da" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">网络x</h1><p id="6536" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们有一个叫做<em class="kj"> NetworkX </em>的python包，用于创建、操作和研究复杂网络的结构、动态和功能。<em class="kj"> NetworkX </em>提供了一个易于使用的框架来处理中小规模的图形。</p><p id="f360" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以用几行代码生成图表。在下面找到一个使用<em class="kj"> NetworkX </em>生成的简单图形</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es ma"><img src="../Images/48de9bf3031714b7f8ff5df484589037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*naNjGP8V8BHQct1FC6llDQ.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">光谱|圆形|随机</figcaption></figure><p id="ba04" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">NetworkX是一个强大的网络工具。但是它不适合这个项目的需要，原因如下:</p><ul class=""><li id="d22f" class="lc ld hi jf b jg kb jk kc jo mj js mk jw ml ka lh li lj lk bi translated">当图形太大时(例如，图形有10k个节点),渲染图形会花费很多时间</li><li id="aa13" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated">渲染输出质量低</li><li id="b1b0" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated">静态的，因此我们无法与之互动</li></ul><h1 id="d41e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">为什么世界需要webG？</h1><p id="7d45" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们没有任何工具将网页可视化为图形，因为这是一个相对较新的想法。webG允许您将任何网页的DOM树可视化为图形。它目前支持4种类型的图形可视化。</p><ul class=""><li id="7291" class="lc ld hi jf b jg kb jk kc jo mj js mk jw ml ka lh li lj lk bi translated">力定向</li><li id="64b9" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated">随机树</li><li id="a657" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated">放射树</li><li id="8120" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated">串</li></ul><p id="5d63" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">给定一个网页的URL，webG的python后端抓取页面，将DOM树转换成一个<em class="kj"> networkx </em>图，并使用<em class="kj"> El Grapho将其作为JSON字符串传递给前端进行渲染。</em></p><h1 id="6723" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">特征</h1><p id="1d71" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">webG特性的快速浏览。</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h1 id="f2c4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">为什么是烧瓶？</h1><figure class="lr ls lt lu fd lv er es paragraph-image"><div class="er es mm"><img src="../Images/6c1244b74057d61649cd7b1dfc996a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*K5teGZsxHzreleIAWNRJSg.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">图片:<a class="ae kn" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank">https://flask.palletsprojects.com/en/1.1.x/</a></figcaption></figure><p id="7d05" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们使用了<em class="kj"> Flask </em>，这是一个用于快速构建web应用程序的python web框架。在研究细节之前，让我解释一下为什么我们使用flask。为什么我们不构建一个简单的基于javascript的网页，在客户端的浏览器上运行呢？</p><p id="dee2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">浏览器安全性防止网页向不同的域发出请求。这种限制被称为<em class="kj">同源政策</em>。同源策略防止该站点从另一个站点读取敏感数据。所以，在客户端浏览器上运行的同时，构建一个抓取其他网站的网页(几乎)是不可能的。为了克服这个限制，我们选择使用<em class="kj"> Flask </em>构建一个web应用。<em class="kj">跨域资源共享</em> ( <strong class="jf hj"> CORS </strong>)是一种允许网页上的受限资源被域外的另一个域请求的机制。存在一个用于处理跨源资源共享(CORS)的Flask扩展，使得跨源AJAX成为可能。</p><h1 id="cca7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">你好烧瓶！</h1><p id="767c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们先看一个使用<em class="kj">烧瓶</em>的简单<em class="kj"> Hello World </em>应用程序。</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="b101" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在上面的例子中，当应用程序在<a class="ae kn" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5000/ </a>运行和访问时，用户将获得<em class="kj"> Hello World！</em>作为回应。</p><p id="ebef" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">动态web应用程序需要静态资源(CSS和JavaScript文件)来编写它们的动态行为。只需在您的包中创建一个名为<em class="kj"> static </em>的文件夹，它将在应用程序的<em class="kj"> /static </em>中可用。</p><p id="7b6b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">要为静态文件生成URL，请使用特殊的<em class="kj">静态</em>端点名称:</p><pre class="lr ls lt lu fd mn mo mp mq aw mr bi"><span id="6872" class="ko ig hi mo b fi ms mt l mu mv">url_for(‘static’, filename=’style.css’)</span></pre><p id="dd1f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">该文件必须以<em class="kj"> static/style.css的形式存储在文件系统上</em></p><p id="32d5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了渲染一个模板，我们必须使用<em class="kj"> render_template() </em>方法:</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="3d5f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上面的代码呈现了放置在<em class="kj">模板/ </em>文件夹下的文件<em class="kj">hello.html</em>。</p><h1 id="cc82" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">El Glorioso Grapho</h1><figure class="lr ls lt lu fd lv er es paragraph-image"><div class="er es mw"><img src="../Images/bf953b3ddd7ba1eeb2298bfe9449cf7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHaMny2eDGCmtjXOVPs3Qg.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">图片:<a class="ae kn" href="https://www.elgrapho.com/" rel="noopener ugc nofollow" target="_blank">https://www.elgrapho.com/</a></figcaption></figure><p id="d27a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">那么，webG如何在浏览器中渲染图形呢？对El Grapho 说你好，这是一个强大的javascript库，用于可视化大型图形。我们为什么选择埃尔·格拉福？El Grapho 是可扩展的——支持数百万个交互式节点和边，高性能且易于使用。</p><h1 id="4cd3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">关于我的开发环境的说明</h1><p id="7e70" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最初，我使用<em class="kj"> codepen.io </em>进行项目工作。它简单易用。它有一个javascript窗口，一个CSS窗口和一个HTML窗口。它有一个呈现HTML的输出窗格。它还有一个帮助调试的控制台。Codepen非常适合快速原型化微小的项目想法。但是为了构建一个完整的项目，我们需要处理不止一个javascript、HTML和CSS文件。随着项目想法自然地演变成越来越大的东西，我不得不转向VSCode，一个成熟的项目开发IDE。</p><h1 id="35ec" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">程序流程</h1><p id="a707" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们已经涵盖了所有的基础知识。让我们看看代码是如何工作的。</p><p id="121c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一切从这里开始。我们有一个用于输入URL的文本框。当我们输入URL并提交时，触发了<em class="kj"> graph.js </em>中名副其实的回调函数<em class="kj"> button_callback() </em>。</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="72ea" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kj"> button_callback() </em>函数中的ajax调用向<em class="kj"> localhost:5000/json </em>发出GET请求。Flask通过调用<em class="kj"> get_json() </em>方法来响应GET请求。注意函数<em class="kj"> app.route('/json '，methods=['GET']) </em>顶部的装饰器，它是一个特殊的flask构造，将对<em class="kj"> /json </em>的HTTP请求重定向到<em class="kj"> get_json() </em>函数。</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="5455" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">转到代码的python部分的内部。我们有一个来自客户端的GET请求，其中包含一个URL作为参数。我们应该用URL的DOM图来响应。<em class="kj"> webg.py </em>处理这部分。<em class="kj"> get_json() </em>调用<em class="kj">w2json()</em>webg . py的方法。</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="62c0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kj"> w2json() </em>方法遍历给定URL的HTML soup中的DOM元素，创建一个<em class="kj"> networkx </em>图，传递给<em class="kj"> g2json() </em>将其转换为json格式。JSON字符串最终被返回。</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="229a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Flask服务器用JSON格式的DOM图响应客户机。</p><p id="3876" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为什么是JSON格式？JSON (Javascript Object Notation)是一种被普遍接受的文本格式，用于在浏览器和服务器之间传输数据。JSON是人类可读的，很容易转换成javascript对象，javascript对象也很容易转换成JSON，不需要复杂的解析。</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="682b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，客户机拥有了应该以图形形式呈现在浏览器页面的空容器中的数据。使用<em class="kj">manipulated data()</em>操作图形数据并将其转换成与<em class="kj"> El grapho </em>兼容的格式。</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="c640" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">模型被全局存储。<em class="kj"> render_graph() </em>将其渲染为一个<em class="kj"> El Grapho </em>图形。</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="c446" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kj"> toolTipFn() </em>是一个回调函数，当用户将光标放在节点上时触发。下面的函数在一个小弹出窗口中呈现所选节点的元数据。</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h1 id="0115" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">应用程序</h1><p id="1bf5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个工具对任何从事网页分析、网页抓取、机器学习等工作的人都很有用。将网页可视化为图形提供了关于DOM元素组织的直觉。这些直觉可以作为特征构建到预测模型中，或者它们可以产生更大、更强大、更有影响力的想法。重要的是要注意到，通过将网页表示为图形，我们会丢失任何类型的空间信息，比如浏览器中DOM元素的位置。DOM元素的位置和大小是构建预测模型时不应该忽视的重要特性。</p><h1 id="2ec5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">个案研究</h1><h2 id="020a" class="ko ig hi bd ih kp kq kr il ks kt ku ip jo kv kw it js kx ky ix jw kz la jb lb bi translated">1.亚马逊vs Flipkart</h2><p id="f45e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通过比较亚马逊和Flipkart的聚类图，我们得出这样的结论:与Flipkart相比，亚马逊在一个产品页面上宣传了更多(其他)产品。</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mx"><img src="../Images/85c67fee85ebff95531f903d44713d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nAA-zISoOSAyq5t_HwkTyQ.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">亚马逊与Flipkart —聚类图</figcaption></figure><h2 id="dfff" class="ko ig hi bd ih kp kq kr il ks kt ku ip jo kv kw it js kx ky ix jw kz la jb lb bi translated">2.电子商务vs维基百科</h2><p id="0aa8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下面是亚马逊两种不同产品的聚类图，后面是维基百科两个不同页面的图表。比较亚马逊和维基百科的图表，我们可以观察到亚马逊在产品页面上宣传了或多或少相同数量的其他产品，因此图表几乎相似。但是在维基百科中，根据文章主题的重要性，每篇文章的图表大小都会发生变化。</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es my"><img src="../Images/7ef02415aa431a18ada7f9e200890157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYHM_lGSkHWwiNlwBgg0xQ.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">比较亚马逊的两个产品页面</figcaption></figure><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mz"><img src="../Images/7b558a90a143b51c804bb7ad1eeeabd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oer4ogQp0TwZ0-ZhOn_IVw.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">泰米尔语和Idli的维基页面比较</figcaption></figure><h2 id="111f" class="ko ig hi bd ih kp kq kr il ks kt ku ip jo kv kw it js kx ky ix jw kz la jb lb bi translated"><strong class="ak"> 3。Gitlab vs Github </strong></h2><p id="9ae3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">作为练习，试着用webG指出<a class="ae kn" href="https://gitlab.com/" rel="noopener ugc nofollow" target="_blank"> gitlab </a>和<a class="ae kn" href="https://github.com" rel="noopener ugc nofollow" target="_blank"> github </a>在UI设计上的差异。</p><h1 id="67ce" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">如何投稿</h1><p id="da33" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这里还有很多事情要做。您可以通过以下方式为该项目做出贡献:</p><ol class=""><li id="bcf9" class="lc ld hi jf b jg kb jk kc jo mj js mk jw ml ka na li lj lk bi translated">每种图表都提供了网页上的独特视角。你可以通过添加更多种类的可视化来做出贡献。</li><li id="c46e" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka na li lj lk bi translated">目前，节点的大小是全局设置的。根据节点的特性(传入边的数量)动态调整节点大小可能是一个不错的特性。</li><li id="1d9c" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka na li lj lk bi translated">添加和比较多个网页</li><li id="eb43" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka na li lj lk bi translated">渲染图形之间的差异。参见<a class="ae kn" href="https://github.com/trailofbits/graphtage" rel="noopener ugc nofollow" target="_blank"> graphtage </a></li><li id="892b" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka na li lj lk bi translated">呈现JSON文件中的任何图形数据，而不仅仅是网页</li><li id="3cf5" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka na li lj lk bi translated">渲染方向图</li><li id="a535" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka na li lj lk bi translated">以png和/或svg格式下载图形</li><li id="1cdf" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka na li lj lk bi translated">在工具提示容器中呈现图像和超链接</li><li id="1383" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka na li lj lk bi translated">由于将网站可视化为图表是一个相对较新的想法，我还没有弄清楚它在数据分析之外的应用。如果你有任何有趣的想法，请随时联系我。</li></ol><p id="8028" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你觉得怎么样？请在下面留言，我会很乐意回复。</p></div></div>    
</body>
</html>