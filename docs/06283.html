<html>
<head>
<title>Email Spam Classifier Using Naive Bayes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于朴素贝叶斯的垃圾邮件分类器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/email-spam-classifier-using-naive-bayes-a51b8c6290d4?source=collection_archive---------6-----------------------#2020-05-17">https://medium.com/analytics-vidhya/email-spam-classifier-using-naive-bayes-a51b8c6290d4?source=collection_archive---------6-----------------------#2020-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2d0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你们想了解机器学习的基础知识。我已经用一种非常简单的语言写了一篇关于这个话题的文章，用真实世界的例子，并且简单的解释了所有的术语和分类。看完我的帖子后，你可以回答任何关于机器学习基础的问题。</p><p id="b6b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是链接:-</p><p id="fd5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" rel="noopener" href="/@143jshubham/machine-learning-and-its-impact-on-our-generation-4c0dbc201c1a">https://medium . com/@ 143 jshubham/机器学习及其对我们这一代的影响-4c0dbc201c1a </a></p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jl"><img src="../Images/6c6ae5eff987967872af7a54622e8712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CS-OYdiRLCBMBiOpEURy0g.png"/></div></div></figure><h1 id="8131" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">项目简介:-</h1><p id="bb48" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">这些信息是从不同的来源收集的</p><p id="1fb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">垃圾邮件，成为互联网上的一大麻烦。垃圾邮件浪费时间、存储空间和通信带宽。垃圾邮件的问题多年来一直在增加。在最近的统计中，40%的电子邮件是垃圾邮件，每天大约有154亿封电子邮件，每年花费互联网用户大约3.55亿美元。知识工程和机器学习是电子邮件过滤中常用的两种方法。在知识工程方法中，必须指定一组规则，根据这些规则将电子邮件分类为垃圾邮件或ham。</p><p id="3e35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">机器学习方法比知识工程方法更有效；它不需要指定任何规则。取而代之的是一组训练样本，这些样本是一组预先分类的电子邮件消息。然后使用特定的算法从这些电子邮件中学习分类规则。机器学习方法已经得到了广泛的研究，有很多算法可以用于邮件过滤。它们包括朴素贝叶斯、支持向量机、神经网络、K近邻、粗糙集和人工免疫系统。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="96b3" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">为什么我们使用朴素贝叶斯作为过滤电子邮件的算法</h2><p id="8768" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">朴素贝叶斯研究的是<strong class="ih hj">相关事件</strong>和未来发生的事件的概率，该概率可以从同一事件的先前发生中检测出来。这种技术可以用来分类垃圾邮件，<strong class="ih hj">单词概率在这里起主要作用</strong>。如果一些单词经常出现在垃圾邮件中，但不出现在ham中，那么这封传入的电子邮件很可能是垃圾邮件。朴素贝叶斯分类技术已经成为邮件过滤中一种非常流行的方法。每个单词在其数据库中都有一定的概率出现在垃圾邮件中。如果单词概率的总和超过某个限制，过滤器会将该电子邮件标记为任一类别。这里，只需要两个类别:垃圾邮件或火腿。</p><p id="fae0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一些计算帮助你理解它是如何工作。T9】</p><p id="1072" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对令牌T最感兴趣的统计数据是其垃圾邮件程度(垃圾邮件等级)，计算如下</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es lp"><img src="../Images/09feaacde58779daba09f6bbc401cc37.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*i884XBtVjjQ3EPM-DqbqVg.png"/></div></figure><p id="eab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中，CSpam(T)和CHam(T)分别是包含令牌T的垃圾邮件或Ham消息的数量。为了计算具有标记{T1，…，TN}的消息M的可能性，需要结合单个标记的垃圾信息来评估整个消息的垃圾信息。进行分类的一种简单方法是计算单个令牌的垃圾邮件度的乘积，并将其与单个令牌的垃圾邮件度的乘积进行比较</p><p id="2b3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(H[M]=π(1-S[T]))</p><p id="992c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果总垃圾邮件度乘积S[M]大于汉明度乘积H[M]，则该消息被认为是垃圾邮件。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="36dd" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">所有的机器学习算法都在两个阶段上工作</h2><ol class=""><li id="0954" class="lq lr hi ih b ii kv im kw iq ls iu lt iy lu jc lv lw lx ly bi translated">训练阶段。</li><li id="fd93" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">测试阶段。</li></ol><p id="c766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在训练阶段，朴素贝叶斯创建了一个查找表，其中存储了我们将在预测结果的算法中使用的所有概率可能性。</p><p id="1c5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在测试阶段，假设你给了算法一个测试点来预测结果，他们从存储了所有可能性的查找表中获取值，并使用该值来预测结果。</p><h2 id="c8fe" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">现在我们对垃圾邮件分类器的主要工作开始了</h2><p id="81b7" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">首先，我想让你明白，我们有一个名为“电子邮件”的文件夹，其中有大约5172个文件，每个文件都是电子邮件中的一个，在每个电子邮件中，他们都提到特定的电子邮件是垃圾邮件或垃圾邮件。</p><p id="26dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的第一个目标是列出5172电子邮件中使用的所有单词。为此我们有一些步骤:</p><ol class=""><li id="864f" class="lq lr hi ih b ii ij im in iq me iu mf iy mg jc lv lw lx ly bi translated">在操作系统的帮助下，在Jupiter笔记本中加载“电子邮件”文件夹，其中每个文件都是一封电子邮件。</li></ol><pre class="jm jn jo jp fd mh mi mj mk aw ml bi"><span id="0535" class="la jy hi mi b fi mm mn l mo mp">import os<br/>folder='Desktop/e-mail/'<br/>files=os.listdir(folder)<br/>emails=[folder+file for file in files]</span></pre><ol class=""><li id="d91f" class="lq lr hi ih b ii ij im in iq me iu mf iy mg jc lv lw lx ly bi translated">借助<strong class="ih hj"> f=open(e-mail) <br/>打开每个文件，如果你已经在f=open()中给了一个文件，它打开那个文件进行阅读。</strong></li><li id="9571" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">阅读文件。<br/> <strong class="ih hj"> <em class="lo"> f.read()它读取那个邮件文件的所有内容并以字符串格式存储。</em> </strong></li><li id="c312" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">用空格(" ")分割文件并追加到列表中。</li></ol><pre class="jm jn jo jp fd mh mi mj mk aw ml bi"><span id="8a0e" class="la jy hi mi b fi mm mn l mo mp">words=[]<br/>for e-mail in e-mails:<br/> f=open(e-mail,encoding='latin-1')<br/> blob=f.read()<br/> words+=blob.split(" ")</span></pre><p id="c90f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们有一个单词列表，其中存储了5172电子邮件中使用的所有单词。但是我们不知道哪个单词出现了多少次，为了找到这个，我们将从集合中<em class="lo">导入计数器，这个计数器将给出哪个单词出现了多少次的结果<br/> <strong class="ih hj">从集合中导入计数器<br/> </strong>并在计数器中传递单词列表，它形成一个字典，显示哪个单词出现了多少次<br/><strong class="ih hj"><br/>word _ dict = Counter(words)</strong></em></p><p id="ed89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有一个Word_dict，其中存储了哪个单词出现了多少次，但我们不使用所有这些单词，因为这可能会降低我们算法的准确性，所以我们使用最常见的3000个单词，你可以选择任何数字，如2500个单词或任何东西，但这里我将选择前3000个单词。我们有一个从字典中找到最常见单词的方法<br/><strong class="ih hj">word _ dict = word _ dict . most _ common(3000)</strong></p><p id="ac42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">word_dict是这样的:- <br/> <strong class="ih hj">这里的键是单词，值是它出现的时间。</strong></p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es mq"><img src="../Images/aef8a8010556208b2a7a7d2328f57bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*HUTQhCciy11_F6VmhWpCRA.png"/></div></figure><p id="279d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是垃圾邮件分类器中非常重要的一部分</p><p id="42ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都知道，为了训练数据，我们必须以行和列的形式制作数据，所以我们将制作一个表格数据，其中有一些行和列，其中每行是一封电子邮件，每列是一个在word_dict中出现的单词，值是一个整数，它显示word_dict中的特定单词在特定电子邮件中出现的次数。因此，它形成了(5172 x 3000)的形状，其中5172封电子邮件和所有3000个最常用的单词都存储在word_dict中。</p><p id="c2ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们制作了一个我们想要制作的表格</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es mr"><img src="../Images/e06f5a76c5e914731932b413c98720f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*Tb7M4J48h1Bc4rH4xosvdw.png"/></div></figure><p id="5641" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Email-1中，你可以看到行是Email，列是word_dict中的单词。在第一封邮件中，你会看到单词“the”出现了2次，“To”出现了3次，就像这样，你会看到最后一列是结果，其中有两个值0和1，这表明给定的电子邮件是垃圾邮件还是非垃圾邮件。0表示垃圾邮件，1表示非垃圾邮件。</p><p id="02be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是在代码的帮助下制作这个表格的时候了，只要看看并试着理解:-</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es ms"><img src="../Images/f38969f9289cba7e86782649e4fc149c.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*XdF7ne90av3ohgGTs93hyw.png"/></div></figure><p id="243d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我试着让你清楚这段代码如何帮助形成一个表格格式:- </strong> <br/>首先我们取两个空的标签和特性列表。然后，我们逐个接收电子邮件，在f=open(email，encoding='latin-1 ')的帮助下，我们打开该文件，然后我们读取该文件，并根据空格(" ")进行分割，然后存储在blob中，现在我们从word_dict (the，to，etc，for....)并检查blob中的出现并存储在数据列表中，因此内部for循环运行3000次，有3000个元素附加在数据列表中(data=[]),最后该数据列表附加在特征列表中(feature=[]),这意味着在特征列表中存在5172个数据列表，对于每封电子邮件都有一个数据列表。最后，我们检查单词“spam”是否在电子邮件标签中，如果单词“ham”在电子邮件标签中(label=[])，则添加0</p><p id="e86b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在在这种情况下，我们有长度为(5172 ) <br/>的<strong class="ih hj">特征列表和长度为(5172，)</strong>的标签</p><p id="a6bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，要素和标注都是训练数据的列表格式，我们知道我们给了一个Numpy数组，因此我们将该列表更改为Numpy数组。</p><p id="9f8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">features = NP . array(features)<br/>label = NP . array(label)<br/>shape(feature)必须是(5172 x3000) <br/> shape(label)必须是(5172，)</strong></p><p id="b034" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们在sklearn.model_selection的帮助下对数据进行训练测试分割</p><pre class="jm jn jo jp fd mh mi mj mk aw ml bi"><span id="77ff" class="la jy hi mi b fi mm mn l mo mp">from sklearn.model_selection import train_test_split<br/>X_train, X_test,y_train,y_test=train_test_split(features,label,test_size=0.2)</span></pre><p id="e0ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，您可以看到test_size =0.2，这意味着我们将80%的数据提供给算法来学习或训练模型，其余的20%用于测试。</p><p id="0289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了训练模型，我们使用朴素贝叶斯算法</p><pre class="jm jn jo jp fd mh mi mj mk aw ml bi"><span id="810a" class="la jy hi mi b fi mm mn l mo mp">from sklearn.naive_bayes import MultinomialNB<br/><br/>Creating a object for this called clf<br/><strong class="mi hj">clf=MultinomialNB()</strong></span></pre><p id="3d60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们把数据交给算法来训练模型</p><pre class="jm jn jo jp fd mh mi mj mk aw ml bi"><span id="6370" class="la jy hi mi b fi mm mn l mo mp">clf.fit(X_train,y_train)</span></pre><p id="5f40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你的模型已经训练好了，你也可以在accuracy_score的帮助下检查你的模型是如何工作的。</p><pre class="jm jn jo jp fd mh mi mj mk aw ml bi"><span id="845a" class="la jy hi mi b fi mm mn l mo mp">from sklearn.metrics import accuracy_score<br/>accuracy_score(y_pred,y_test)</span></pre><p id="51e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个准确度分数帮助我们预测您的算法的准确度。</p><p id="eda3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的模型已经可以预测了，所以我们将接收一封输入电子邮件，然后检查我们的模型预测是否正确。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es mt"><img src="../Images/3c4dcc81da3a3e1272af356d2986ce7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7rSvh07S_PAHi9npKfrAoA.png"/></div></div></figure><p id="4b5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们用一个变量new_email来表示一封邮件。在那之后，我们分开了整封邮件。然后，我们将统计这封输入邮件中存储在word_dict中最常见的单词。接下来，我们将该列表转换成一个numpy数组，并将其整形为(1，3000)。最后，我们使用clf对象中的模型预测结果，因为所有垃圾邮件或Ham的逻辑都存在于我们模型的clf对象中。这里1代表垃圾邮件，0代表火腿。</p><p id="3be7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果你想从头看到干净清晰的代码，你可以访问我的Github源代码。下面是链接:- </strong></p><div class="mu mv ez fb mw mx"><a href="https://github.com/143jshubham/Email-Spam-Classifier-jupiter_file/blob/master/Email%20spam%20classifer.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">143 jshubham/电子邮件-垃圾邮件-分类器-jupiter_file</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">permalink dissolve GitHub是4000多万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl jv mx"/></div></div></a></div></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="f9b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果任何一个人想在网站上转换这个垃圾邮件分类器，你想从用户那里得到一封输入的邮件，在垃圾邮件分类器算法的帮助下，你想预测输入的邮件是垃圾邮件还是垃圾邮件。为了这个你。可以访问我在Medium上的下一个博客。<br/> <strong class="ih hj">以下是链接:——即将推出…..</strong></p><h1 id="7dc0" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">结论:-</h1><p id="ff11" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">垃圾邮件分类器是机器学习领域中最好的项目之一。过滤垃圾邮件真的很有帮助，因为它已经成为互联网上的一大麻烦。机器学习是过滤垃圾邮件的最佳方式。在这个过滤过程中，我们可以使用多种算法，但我们正在研究朴素贝叶斯，因为这种算法的性能或准确性比其他算法更好。</p></div></div>    
</body>
</html>