<html>
<head>
<title>A Seemingly Impossible Way of Resizing An Image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种看似不可能的调整图像大小的方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/seam-carving-algorithm-a-seemingly-impossible-way-of-resizing-an-image-b3a57469d33e?source=collection_archive---------23-----------------------#2020-09-15">https://medium.com/analytics-vidhya/seam-carving-algorithm-a-seemingly-impossible-way-of-resizing-an-image-b3a57469d33e?source=collection_archive---------23-----------------------#2020-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="1a3b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="bf5b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这篇文章中，我们将深入研究一种被称为“缝雕”的有趣算法。它完成了一项看似不可能的任务:在不裁剪或扭曲图像内容的情况下调整图像大小。我们将建立我们的方法，从头开始实现seam carving算法，同时看看它背后的一些有趣的数学。</p><p id="95e4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Tad微积分知识将有助于理解，但不是必需的。让我们开始吧。<br/> <em class="kg">(本文灵感来自麻省理工学院格兰特·桑德森的一次讲座。)</em></p><h1 id="c7e7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题是:</h1><p id="3829" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们来看看这张图片。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/f9484c0c1f76b53bb6dc01e9ebdd275c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gL2Cbn3uxxHRYOsk0yofUw.jpeg"/></div></div></figure><p id="65a2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这幅画是萨尔瓦多·达利的作品，名为“记忆的延续”。比起艺术价值，我们对这幅画的内容更感兴趣。我们想通过减小图片的宽度来调整图片的大小。我们能想到的两个有效的方法是裁剪图片或挤压宽度。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kt"><img src="../Images/a20ae0f2dd4df6c750d72e4cadfc3d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-_tjLHpp7thQqcpm0Molw.png"/></div></div></figure><p id="c2c2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">但是正如我们所看到的，裁剪移除了许多对象，挤压扭曲了图片。我们希望两者兼得，即在减少宽度的同时，不需要裁剪任何对象，也不需要扭曲对象。</p><p id="790c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">正如我们所看到的，除了物体，图片中还有大量的空白。我们想在这里完成的是以某种方式移除物体之间的空白区域，这样在扔掉不必要的空间的同时，图片中有趣的部分仍然保留。</p><p id="a496" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这确实是个棘手的问题，而且很容易迷路。因此，将问题分成更小更容易处理的部分总是一个好主意。我们可以把这个问题分成两部分。</p><ol class=""><li id="693f" class="ku kv hi jf b jg kb jk kc jo kw js kx jw ky ka kz la lb lc bi translated">识别图片中感兴趣的部分(即物体)。</li><li id="3a25" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">识别可以在不扭曲图像的情况下移除的像素路径。</li></ol><h1 id="7f61" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">识别对象:</h1><p id="3290" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在前进之前，我们想把我们的图片转换成灰度。这将有助于我们以后的行动。下面是一个将RGB像素转换为灰度值的简单公式。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es li"><img src="../Images/0f2ee799f73ee11a14902a45d6961586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*KFSs8rnTNo2VFrzxOgxfjg.png"/></div></figure><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ll"><img src="../Images/410b84d824f4aa8305e61f2ba7a94824.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*f3moI7CSLIcsLa8MtlX3Fw.png"/></div></figure><p id="4f5d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了识别对象，我们可以制定一个策略。如果我们能以某种方式识别图片中的所有边缘呢？然后，我们可以要求seam carving算法采用不穿过边缘的像素路径，因此，通过扩展，任何由边缘封闭的区域都不会被触及。</p><p id="7893" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">但是接下来，我们如何识别边缘呢？我们可以观察到，每当两个相邻像素之间的颜色发生急剧变化时，它很可能是物体的边缘。我们可以将这种颜色的立即变化解释为一个新的物体从该像素开始。</p><p id="b0eb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们要解决的下一个问题是如何识别像素值的急剧变化。现在，让我们考虑一个简单的例子，一行像素。假设我们将这个数组的值表示为<em class="kg"> x </em>。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lm"><img src="../Images/b9a90654f36ddacdfa40a06c4ecf89b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*Pw-vmpENhiHZaABA0a7jtg.png"/></div></figure><p id="a4ac" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以取像素<em class="kg"> x[i+1]，x[i] </em>之间的差。它将显示我们当前的像素与右侧有多大差异。或者我们也可以取<em class="kg"> x[i] </em>和<em class="kg"> x[i-1] </em>的差，这将在左侧给出变化。为了表示总的变化，我们可能要取两者的平均值，这样得出:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ln"><img src="../Images/422ecccaa609062644b713ef7cc133c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*k5yxe6RUVyT6IV5InYM-fQ.png"/></div></figure><p id="0dd1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">任何熟悉微积分的人都能很快识别出这个表达式就是导数的定义。没错。我们需要计算<em class="kg"> x </em>值的急剧变化，因此我们正在计算它的导数。我们可以得到的另一个热切的观察结果是，如果我们定义一个滤波器，比如[<em class="kg">-0.5，0，0.5</em>，用数组[<em class="kg">x[I-1]，x[i]，x[I+1]</em>按元素相乘，然后求和，就会得到x[i]处的导数。由于我们的图片是二维的，我们需要一个二维过滤器。我不会深入细节，但我们的过滤器的2d版本看起来像这样，</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lo"><img src="../Images/5e4fcdad35779f2746f4a576035e62c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*iW1CesAuBF-DWHEEEbZuAA.png"/></div></figure><p id="8d2d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当我们的过滤器计算每个像素沿x轴的导数时，它将给出垂直边缘。类似地，如果我们计算沿y轴的导数，我们将得到水平边。它的过滤器如下。(它与转置时x轴的滤波器相同。)</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lp"><img src="../Images/006080f0ae4ec058568bd6c494f8b8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/0*IuLxIocdp009HfUn.png"/></div></div></figure><p id="538b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这些滤波器也被称为<strong class="jf hj">索贝尔滤波器</strong>。</p><p id="0d29" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，我们有两个滤波器需要穿过图像。对于每个像素，与其周围的(3×3)个子矩阵进行逐元素乘法，然后取其和。这种运算称为卷积。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lq"><img src="../Images/792fc3e8d46d66ed41fa336af4a1a979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/1*-ak0_0P_DIQvwRPxcIrieg.gif"/></div></figure><h1 id="a8cb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">卷积:</h1><p id="fc72" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">数学上，卷积运算被定义为，</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lr"><img src="../Images/e481f4dcb9ad800551d7526abe9151df.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*-GEY4sMxebhltCwwP5p-Mw.png"/></div></figure><p id="dec9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">看看我们如何做两个函数的逐点乘法，然后进行积分。在数值上，它将对应于我们之前所做的，即滤波器和图像的逐元素乘法，然后对其求和。</p><p id="7759" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">注意，对于<em class="kg"> k </em>函数，它是如何写成<em class="kg"> k(t-τ) </em>的。因为对于卷积运算，其中一个信号需要翻转。你可以直观地想象成这样。想象两列火车，在一条笔直的水平轨道上，朝着彼此运行，不可避免地会发生碰撞(不要担心火车不会发生任何事情，因为叠加)。所以火车的车头会相对。现在想象你正在从左到右扫描音轨。然后对于左边的火车，你将从后面扫描到前面。</p><p id="3155" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">同样，计算机需要从右下角(2，2)到左上角(0，0)读取我们的过滤器，而不是从左上角到右下角。所以实际的索贝尔滤波器如下，</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ls"><img src="../Images/b7ec5c433e0725113a747794af3eed65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*qmqkIJHld3vRVKS3GMU50Q.png"/></div></figure><p id="8b96" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在卷积运算之前我们对其进行180度旋转。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lt"><img src="../Images/585734cabc3932d32768afd738090ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/1*zITmaK34r_6WMxpaHC1nvw.gif"/></div></figure><p id="eda3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以继续写一个简单的<strong class="jf hj">朴素的</strong>实现来做卷积运算。大概是这样的，</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="6ab0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这可以很好地工作，但是执行起来会耗费大量的时间，因为它要进行将近9*r*c的乘法和加法运算才能得到结果。但是我们可以聪明地使用更多的数学概念来大大降低时间复杂度。</p><h1 id="369b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">快速卷积:</h1><p id="a74c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">卷积有一个有趣的性质。时域中的卷积对应于频域上的乘法。即</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lu"><img src="../Images/952635da577cd6fe2b239c4f3e8d3629.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*S5fP93NsfFNwzllj5Bo35g.png"/></div></figure><p id="1647" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">，其中<em class="kg"> F(w) </em>表示频域中的函数。</p><p id="0f3d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们知道傅立叶变换将信号从时域转换到频域。我们可以做的是，计算图像和滤波器的傅里叶变换，将它们相乘，然后进行傅里叶逆变换，得到卷积结果。为此，我们可以使用NumPy库。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="46d0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kg">(注意:在某些情况下，值可能与naive方法略有不同，因为fastConvolve函数计算循环卷积。但在实践中，我们可以轻松地使用快速卷积，而不用担心这些微小的数值差异。)</em></p><p id="8046" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">酷！现在我们有一个有效的方法来计算水平边和垂直边，即x和y分量。因此，使用以下公式计算图像中的边缘:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lv"><img src="../Images/5b012482b0caaa6a357b7b5b1ac276cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*9pxSErwKPPe5JkcKJKgFgw.png"/></div></figure><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="9e55" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">太棒了。我们完成了第一部分。边缘是图片中有趣的部分，黑色部分是我们可以不用担心就可以删除的部分。</p><h1 id="73ec" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">识别像素路径:</h1><p id="5dd2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">对于连续路径，我们可以定义一个规则，即每个像素只连接到它下面最近的3个像素。这是为了从上到下有一个连续的像素路径。所以我们的子问题变成了一个基本的寻路问题，我们必须最小化成本。由于边缘具有较高的量级，如果我们继续以最低成本移除像素路径，将会避开边缘。</p><p id="ebab" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们定义一个函数"<em class="kg"> cost" </em>，它取一个像素并计算从那里到图片末端的最小成本像素路径。我们有以下观察结果，</p><ol class=""><li id="d3bd" class="ku kv hi jf b jg kb jk kc jo kw js kx jw ky ka kz la lb lc bi translated">在最底排(即i=r-1)</li></ol><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lw"><img src="../Images/1b98e748cfb1a34a43932bd30167961b.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*r-qnvMYHk1SV5kUKflCwww.png"/></div></figure><p id="ed47" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">2.对于任何中间像素，</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lx"><img src="../Images/0a8cf8ff175415a23e5887014b855a52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ji4HorhNdYoPuzJe.png"/></div></div></figure><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ll"><img src="../Images/ac11e418ce8a5f61c998f82d6ef0d4f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*Y2976eKLLliSjKKTtHS-_A.png"/></div></figure><p id="3471" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以在图中看到三角形。它们表示没有返回的点，也就是说，如果你到达那个像素，没有不通过边缘的路径到达底部。这是我们努力避免的。</p><p id="0672" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">从成本矩阵中找到像素路径可以很容易地用贪婪算法来完成。找到顶行上最小成本的像素，然后向下移动，在所有与之相连的像素中选择成本最低的像素。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="fc2d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了移除由路径定义的接缝，我们只需遍历每一行并删除路径数组提到的列。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="7bf0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">就这样了。在这里，我预先计算了100个缝雕刻操作。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ly"><img src="../Images/637484abb9cc1c2ae0075ab47a647844.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*5bwRymoCds2YtXtv2re0Ag.png"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lz"><img src="../Images/f22a9c8e2b5bfaa92f63c4be4e882e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRK7PFPlz6jxJ40MMwT8AA.png"/></div></div></figure><p id="e63b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以看到照片中的物体是如何相互靠近的。我们已经成功地使用线缝雕刻算法减小了图像的尺寸，而没有对物体造成任何扭曲。我已经附上了完整的代码笔记本的链接。感兴趣的读者可以在这里看一下<a class="ae ma" href="https://github.com/Samarendra109/Seam-Carving.git" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6cdd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">总的来说，缝雕是一个有趣的算法。它有它的警告，因为它会失败，如果提供的图像有太多的细节或太多的边缘。使用算法修改不同的图片，看看最终的结果是什么，这总是很有趣的。如果你有任何疑问或建议，请在回复中留下。谢谢你一直读到最后。</p><p id="73aa" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">相关文章:</strong></p><p id="bfe1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kg">原载于2020年9月15日</em><a class="ae ma" href="https://www.analyticsvidhya.com/blog/2020/09/seam-carving-algorithm-a-seemingly-impossible-way-to-resize-an-image" rel="noopener ugc nofollow" target="_blank"><em class="kg"/></a><em class="kg">。</em></p></div></div>    
</body>
</html>