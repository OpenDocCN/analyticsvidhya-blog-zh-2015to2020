<html>
<head>
<title>Univariate Forecasting for the Volatility of the Stock Data using Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于深度学习的股票数据波动性的单变量预测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/univariate-forecasting-for-the-volatility-of-the-stock-data-using-deep-learning-6c8a4df7edf9?source=collection_archive---------7-----------------------#2020-12-13">https://medium.com/analytics-vidhya/univariate-forecasting-for-the-volatility-of-the-stock-data-using-deep-learning-6c8a4df7edf9?source=collection_archive---------7-----------------------#2020-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a0f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">昨天，我们看到了如何使用基本的回归方法预测特斯拉公司股票的波动性。(<a class="ae jd" href="https://ramji-b.medium.com/predicting-the-volatility-of-stock-data-56f8938ab99d" rel="noopener">链接</a>)。在本文中，将进一步了解如何使用深度学习模型(LSTM)方法作为时间序列方法来预测一段时间内的波动率。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/a77cc3618e4aa0883c896e44721138bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L7YGEFOiRJXStJ_tSmpGPg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">一段时间内的波动性</figcaption></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="c1e0" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">时间数列预测法</h1><p id="b060" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">时间序列预测是一种使用以前的值来预测未来的方法，而在昨天回归方法中，模型不会使用任何以前的波动值来预测目标变量。是不是很混乱？将基于一个简单的例子来尝试理解。假设你有一段时间内特斯拉股票波动的数据，并且只使用特定一天的起始和终止价格来预测波动，那么这被称为回归方法。其中在时间序列分析中，使用前 n 天的波动值来预测特定一天的波动。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="4e5e" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">数据准备</h1><p id="36c0" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">时间序列预测的首要步骤是准备数据。开始之前，我们必须问几个关于数据的问题。</p><ul class=""><li id="a3c0" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">深度学习模型需要一个标准的输入大小，所以你要预测未来多少天的波动？它可以持续 5 天，10 天或任何时间。这将决定您的输入要素大小。</li><li id="9036" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">你的数据稳定吗？—使用<a class="ae jd" href="https://machinelearningmastery.com/time-series-data-stationary-python/" rel="noopener ugc nofollow" target="_blank">增强的迪基-富勒测试</a></li><li id="0181" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">数据是否有偏差？-如果它是倾斜的，您可以对您的数据应用对数变换</li></ul><pre class="jf jg jh ji fd ls lt lu lv aw lw bi"><span id="3630" class="lx kc hi lt b fi ly lz l ma mb">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>window_size=20<br/>#first download data from yahoo<br/>import yfinance as yf<br/>from yahoofinancials import YahooFinancials<br/>df = yf.download(‘TSLA’, start=’2000–01–01', end=’2019–12–31', progress=False)<br/>#compute daily returns and 20 day moving historical volatility<br/>df[‘returns’]=df[‘Close’].pct_change()<br/>df[‘volatility’]=df[‘returns’].rolling(window_size).std()*(252**0.5)<br/>X = df['volatility'].values<br/>plt.figure(figsize=(20,5))<br/>plt.subplot(121)<br/>plt.hist(X)<br/>plt.title('Distribution of Volatility')<br/>plt.subplot(122)<br/>plt.hist(np.log(X))<br/>plt.title('Log Transformation of Volatility')<br/>plt.show()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mc"><img src="../Images/0070a1fed447a2551969279f18e2d589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5ityZX5C20uW95R1mwTIg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">波动性</figcaption></figure><blockquote class="md me mf"><p id="d47e" class="if ig mg ih b ii ij ik il im in io ip mh ir is it mi iv iw ix mj iz ja jb jc hb bi translated">稳定性检查</p></blockquote><pre class="jf jg jh ji fd ls lt lu lv aw lw bi"><span id="8a61" class="lx kc hi lt b fi ly lz l ma mb">from statsmodels.tsa.stattools import adfuller<br/>result = adfuller(X)<br/>print(‘ADF Statistic: %f’ % result[0])<br/>print(‘p-value: %f’ % result[1])<br/>print(‘Critical Values:’)<br/>for key, value in result[4].items():<br/> print(‘\t%s: %.3f’ % (key, value))</span><span id="5716" class="lx kc hi lt b fi mk lz l ma mb">ADF Statistic: -4.915287<br/>p-value: 0.000033<br/>Critical Values:<br/>	1%: -3.433<br/>	5%: -2.863<br/>	10%: -2.567</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ml"><img src="../Images/8b0db8df41ba8f0f9d4a7dcf0bb2023f.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*iMLQLEtPO6rqvfZxlMkY7w.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">稳定性结果</figcaption></figure><p id="fd49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于 p 值小于 5%，数据是稳定的，意味着波动性不依赖于趋势/时间。</p><blockquote class="md me mf"><p id="93c9" class="if ig mg ih b ii ij ik il im in io ip mh ir is it mi iv iw ix mj iz ja jb jc hb bi translated">输入特征</p></blockquote><p id="cfde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将使用过去 10 天的数据来预测波动率。所以我们的输入特征将是(N，10)。</p><pre class="jf jg jh ji fd ls lt lu lv aw lw bi"><span id="0803" class="lx kc hi lt b fi ly lz l ma mb">def convert2matrix(data_arr, look_back):<br/> X, Y =[], []<br/> for i in range(len(data_arr)-look_back):<br/>  d=i+look_back <br/>  X.append(data_arr[i:d])<br/>  Y.append(data_arr[d])<br/> return np.array(X), np.array(Y)</span><span id="43bd" class="lx kc hi lt b fi mk lz l ma mb">x, y = convert2matrix(X,10)<br/>print(x.shape,y.shape)</span></pre></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="e77b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">培训阶段</h1><p id="dfbc" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">我使用 LSTM 模型来训练模型，因为<a class="ae jd" href="https://www.analyticsvidhya.com/blog/2017/12/fundamentals-of-deep-learning-introduction-to-lstm/" rel="noopener ugc nofollow" target="_blank"> LSTM </a>有能力在更长的时间内记住输入特征之间的相互关系。</p><pre class="jf jg jh ji fd ls lt lu lv aw lw bi"><span id="2394" class="lx kc hi lt b fi ly lz l ma mb">from sklearn.model_selection import train_test_split<br/>X,x_valid,y,y_valid = train_test_split(x,y,test_size=0.1,shuffle=False)</span><span id="2b61" class="lx kc hi lt b fi mk lz l ma mb">X = np.expand_dims(X,2)<br/>x_valid = np.expand_dims(x_valid,2)<br/>print(X.shape,y.shape,x_valid.shape,y_valid.shape)</span></pre><blockquote class="md me mf"><p id="de98" class="if ig mg ih b ii ij ik il im in io ip mh ir is it mi iv iw ix mj iz ja jb jc hb bi">(2126,10,1),(2126),(237,10,1),(237)</p></blockquote><pre class="jf jg jh ji fd ls lt lu lv aw lw bi"><span id="8115" class="lx kc hi lt b fi ly lz l ma mb">from keras.models import Sequential<br/>from keras.layers import Dense, LSTM<br/>from keras.optimizers import Adam</span><span id="95a6" class="lx kc hi lt b fi mk lz l ma mb">model = Sequential()<br/>model.add(LSTM(10, input_shape=(X.shape[1],1)))<br/>model.add(Dense(1))<br/>model.summary()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mm"><img src="../Images/63673afbb3d2d4b1f221294d45678e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*Sb7DmuqviVkHYgDfggFHig.png"/></div></figure><pre class="jf jg jh ji fd ls lt lu lv aw lw bi"><span id="ccdf" class="lx kc hi lt b fi ly lz l ma mb">model.compile(loss=’mae’, optimizer=Adam(0.001))<br/>model.fit(X, y, epochs=10, batch_size=32, validation_data=(x_valid, y_valid), verbose=1, shuffle=False)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mn"><img src="../Images/250e8278beb1e6c9267e585029fed76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqqqqG0dCplmi6gRHNRfUA.png"/></div></div></figure><pre class="jf jg jh ji fd ls lt lu lv aw lw bi"><span id="bc2e" class="lx kc hi lt b fi ly lz l ma mb">from sklearn.metrics import mean_absolute_error<br/>pred = model.predict(x_valid)</span><span id="a479" class="lx kc hi lt b fi mk lz l ma mb">plt.figure(figsize=(20,5),dpi=300)<br/>plt.plot(y_valid,label=’True Value’)<br/>plt.plot(pred,linestyle=’ — ‘, label = ‘Predicted’)<br/>plt.legend()<br/>plt.show()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mo"><img src="../Images/965730f912ed3dab0eac0c7c267bf9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgKY4mlYBmaU17YR0r-QdA.png"/></div></div></figure><p id="f2e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哦耶！！LSTM 比回归模型更适合这个数据。这个模型能够捕捉趋势。微调模型会得到更好的结果。</p><p id="6c4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可能增加更多的特征也会提高预测的准确性。明天将尝试将相同的数据转换为多元数据，看看会发生什么。迫不及待地想看到不同之处。</p><p id="2eda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">觉得这个有用就鼓掌分享:-)</p></div></div>    
</body>
</html>