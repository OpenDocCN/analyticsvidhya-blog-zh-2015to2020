<html>
<head>
<title>Kprobes in a nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简而言之</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/kprobes-in-a-nutshell-53de21baa3ed?source=collection_archive---------33-----------------------#2020-01-02">https://medium.com/analytics-vidhya/kprobes-in-a-nutshell-53de21baa3ed?source=collection_archive---------33-----------------------#2020-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="474f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【https://ish-ar.io/kprobes-in-a-nutshell/】原载于<a class="ae je" href="https://ish-ar.io/kprobes-in-a-nutshell/" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="c8a2" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">Kprobes是什么？</h1><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kd"><img src="../Images/63071faf3e0479e2d99ba871ed73f860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*0IAp9otm9mwGkx3c.jpg"/></div></figure><p id="a2c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是来自kernel.org的定义:</p><p id="6c88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> "Kprobes使您能够动态地闯入任何内核例程，并无中断地收集调试和性能信息。您可以在几乎任何内核代码地址[1]进行陷阱，指定一个当断点被命中时调用的处理程序例程… </em></p><p id="b720" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">…当CPU命中断点指令时，会发生一个陷阱，CPU的寄存器被保存，控制通过notifiercallchain机制传递给Kprobes。Kprobes执行与kprobe相关联的“pre_handler ”,将kprobe结构和保存的寄存器的地址传递给处理程序。”</em></p><p id="ed6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">~所以基本上它允许你运行两个函数，pre <em class="jd">处理程序和post </em>处理程序，每次被探测的函数被调用~</p><p id="7300" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说实话，第一次听说Kprobes、Jprobes、Kretprobes等等……对我来说都有点复杂。很高兴地说，经过几个小时的研究，现在开始有意义了。</p><p id="29a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，现在有一种比我今天向您展示的方法更简单的方法来使用Kprobes但是我将在下一篇文章中介绍这种方法。没错，我说的就是bpf()！</p><p id="9485" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">那么我们今天将如何使用Kprobes呢？</strong></p><p id="b952" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">轻松点。通过创建一个简单的内核模块，将它插入我们的内核并测试它。不要害怕，这是一个非常简单的任务，即使听起来很棘手。</p><p id="b3fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">教程目标</strong>:创建一个内核模块，每当函数${function}被使用时，它就使用Kprobes进行计数。</p><p id="b248" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先说第一件事:需求！</p><p id="ecf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你需要一台<strong class="ih hj"> Linux机器</strong>！</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kl"><img src="../Images/9cf1ae13ed244d1c74d984959cd340b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*7u4WpKadjUByeoBs.gif"/></div></figure><p id="af2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意:我只在我的私人服务器(Ubuntu 18.04.2 LTS仿生海狸)上测试了这个过程，所以如果你使用不同的操作系统，你可能需要找到正确的软件包名称，我们将创建的内核模块可能无法在不同的架构上工作。</em></p><ol class=""><li id="f1fd" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">创建工作目录dir并安装所需的软件包。</li></ol><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="4838" class="la jg hi kw b fi lb lc l ld le">mkdir ./ish-ar.io-lab/ &amp;&amp; \<br/>touch ./ish-ar.io-lab/{Makefile,ish.c} &amp;&amp; \<br/>cd ./ish-ar.io-lab/</span><span id="eb1c" class="la jg hi kw b fi lf lc l ld le">apt-get update &amp;&amp; \<br/>apt-get install gcc strace make libelf-dev -y</span></pre><p id="20a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.如下编辑文件<code class="du lg lh li kw b">Makefile</code>:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="fa42" class="la jg hi kw b fi lb lc l ld le">obj-m +=ish.o<br/>KDIR= /lib/modules/$(shell uname -r)/build<br/>all:<br/>		$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules<br/>clean:<br/>		rm -rf *.o *.ko *.mod.* .c* .t*</span></pre><p id="bd4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意:当你需要在</em> <code class="du lg lh li kw b"><em class="jd">Makefile</em></code> <em class="jd">中调用</em> <code class="du lg lh li kw b"><em class="jd">make</em></code> <em class="jd">时，最好使用变量</em> <code class="du lg lh li kw b"><em class="jd">$(MAKE)</em></code> <em class="jd">而不是命令。</em></p><p id="af5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重要提示:确保你在Makefile中使用的是制表符而不是空格，否则你会得到一个错误提示:</strong></p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="57b3" class="la jg hi kw b fi lb lc l ld le">Makefile:N: *** missing separator (did you mean TAB instead of 4 spaces?).  Stop.</span></pre><p id="79cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.我们需要找出我们想要计数/截取的函数。</p><p id="c66b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我想计算每次程序执行的次数。所以我搜索了我想要的函数，就像这样:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="aead" class="la jg hi kw b fi lb lc l ld le">strace ls 2&gt;&amp;1 | less</span></pre><p id="f111" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在顶部，您应该会看到类似这样的内容:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="a05f" class="la jg hi kw b fi lb lc l ld le">execve("/bin/ls", ["ls"], 0x7fff38f23780 /* 21 vars */) = 0</span></pre><p id="f8ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看起来<code class="du lg lh li kw b">execve</code>就是我们要拦截的函数！我们现在需要它的内存地址来探测它。所以让我们搜索一下:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="4f34" class="la jg hi kw b fi lb lc l ld le">root@ip-172-31-3-95:~/lab# grep sys_execve /proc/kallsyms<br/>ffffffffbcc7f010 T sys_execve<br/>ffffffffbcc7f050 T sys_execveat<br/>ffffffffbcc7f0b0 T compat_sys_execve<br/>ffffffffbcc7f100 T compat_sys_execveat</span></pre><p id="f1bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">如果你不知道这个文件</em> <code class="du lg lh li kw b"><em class="jd">/proc/kallsyms</em></code> <em class="jd">是什么，你可以看看这个页面-&gt;</em><a class="ae je" href="https://onebitbug.me/2011/03/04/introducing-linux-kernel-symbols/" rel="noopener ugc nofollow" target="_blank"><em class="jd">https://onebitbug . me/2011/03/04/introducing-Linux-kernel-symbols/</em></a></p><p id="7105" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们有一个名为sys_execve的函数，它的地址是ffffffffbcc7f010。</p><p id="cd8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.现在编辑文件<code class="du lg lh li kw b">ish.c</code>:</p><p id="d4c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要包含所需的库，所以在C程序的顶部键入:</p><p id="ef86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意:这个库# include&lt;Linux/kprobes . h&gt;正如你从它的名字可以注意到的，它是使用k probes的基础。</em></p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="5009" class="la jg hi kw b fi lb lc l ld le">#include&lt;linux/module.h&gt;<br/>#include&lt;linux/version.h&gt;<br/>#include&lt;linux/kernel.h&gt;<br/>#include&lt;linux/init.h&gt;<br/>#include&lt;linux/kprobes.h&gt;</span></pre><p id="e25a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在includes之后，创建两个简单的结构。我们以后会需要它们。</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="ff81" class="la jg hi kw b fi lb lc l ld le">static unsigned int counter = 0;<br/>static struct kprobe kp;</span></pre><p id="4356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你还记得我曾经写过前置<em class="jd">处理程序和后置</em>处理程序的功能吗？让我们先创建它们。</p><p id="0384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">提醒一下:prehandler函数在我们截取的函数之前执行，posthandler函数在它之后执行。</em></p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="0809" class="la jg hi kw b fi lb lc l ld le">int kpb_pre(struct kprobe *p, struct pt_regs *regs){<br/> printk("ish-ar.io pre_handler: counter=%u\n",counter++);<br/> return 0;<br/>}</span><span id="14d4" class="la jg hi kw b fi lf lc l ld le">void kpb_post(struct kprobe *p, struct pt_regs *regs, unsigned long flags){<br/> printk("ish-ar.io post_handler: counter=%u\n",counter++);<br/>}</span></pre><p id="2028" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这两个函数之后，让我们创建我们的模块入口点和出口点。</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="351e" class="la jg hi kw b fi lb lc l ld le">int minit(void)<br/>{<br/> printk("Module inserted\n ");<br/> kp.pre_handler = kpb_pre;<br/> kp.post_handler = kpb_post;<br/> kp.addr = (kprobe_opcode_t *)0xffffffff8d67f010;<br/> register_kprobe(&amp;kp);<br/> return 0;<br/>}</span><span id="95b6" class="la jg hi kw b fi lf lc l ld le">void mexit(void)<br/>{<br/> unregister_kprobe(&amp;kp);<br/> printk("Module removed\n ");<br/>}<br/>module_init(minit);<br/>module_exit(mexit);<br/>MODULE_AUTHOR("Isham J. Araia");<br/>MODULE_DESCRIPTION("<a class="ae je" href="https://ish-ar.io/" rel="noopener ugc nofollow" target="_blank">https://ish-ar.io/</a>");<br/>MODULE_LICENSE("GPL");<!-- -->int minit(void) {  printk("Module inserted\n ");  kp.pre_handler = kpb_pre;  kp.post_handler = kpb_post;  kp.addr = (kprobe_opcode_t *)0xffffffff8d67f010;  register_kprobe(&amp;kp);  return 0; }  void mexit(void) {  unregister_kprobe(&amp;kp);  printk("Module removed\n "); } module_init(minit); module_exit(mexit); MODULE_AUTHOR("Isham J. Araia"); MODULE_DESCRIPTION("https://ish-ar.io/"); MODULE_LICENSE("GPL");</span></pre><p id="5639" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次你插入这个模块时，函数minit将被触发，如果你移除内核模块，函数mexit将被调用。</p><p id="bc8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重要</strong>:将<code class="du lg lh li kw b">kp.addr = (kprobe_opcode_t *)0xffffffff8d67f010;</code>替换为您在第3步发现的函数内存地址— &gt; <code class="du lg lh li kw b">kp.addr = (kprobe_opcode_t *)0xFUNCTION_MEMORY_ADDRESS;</code>。</p><p id="420d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.您早期创建的内核模块应该如下所示:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="5980" class="la jg hi kw b fi lb lc l ld le">#include&lt;linux/module.h&gt;<br/>#include&lt;linux/version.h&gt;<br/>#include&lt;linux/kernel.h&gt;<br/>#include&lt;linux/init.h&gt;<br/>#include&lt;linux/kprobes.h&gt;</span><span id="a6b1" class="la jg hi kw b fi lf lc l ld le">static unsigned int counter = 0;</span><span id="b1da" class="la jg hi kw b fi lf lc l ld le">static struct kprobe kp;</span><span id="b169" class="la jg hi kw b fi lf lc l ld le">int kpb_pre(struct kprobe *p, struct pt_regs *regs){<br/>    printk("ish-ar.io pre_handler: counter=%u\n",counter++);<br/>    return 0;<br/>}</span><span id="f4db" class="la jg hi kw b fi lf lc l ld le">void kpb_post(struct kprobe *p, struct pt_regs *regs, unsigned long flags){<br/>    printk("ish-ar.io post_handler: counter=%u\n",counter++);<br/>}</span><span id="836f" class="la jg hi kw b fi lf lc l ld le">int minit(void)<br/>{<br/>    printk("Module inserted\n ");<br/>    kp.pre_handler = kpb_pre;<br/>    kp.post_handler = kpb_post;<br/>    kp.addr = (kprobe_opcode_t *)0xFUNCTION_MEMORY_ADDRESS;<br/>    register_kprobe(&amp;kp);<br/>    return 0;<br/>}</span><span id="ef72" class="la jg hi kw b fi lf lc l ld le">void mexit(void)<br/>{<br/>    unregister_kprobe(&amp;kp);<br/>    printk("Module removed\n ");<br/>}</span><span id="64c4" class="la jg hi kw b fi lf lc l ld le">module_init(minit);<br/>module_exit(mexit);<br/>MODULE_AUTHOR("Isham J. Araia");<br/>MODULE_DESCRIPTION("<a class="ae je" href="https://ish-ar.io/" rel="noopener ugc nofollow" target="_blank">https://ish-ar.io/</a>");<br/>MODULE_LICENSE("GPL");</span></pre><p id="ef6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.现在让我们构建并插入我们的模块。</p><p id="256c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您的工作目录中键入:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="a521" class="la jg hi kw b fi lb lc l ld le">make</span></pre><p id="38e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该得到如下输出:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="0b76" class="la jg hi kw b fi lb lc l ld le">make -C /lib/modules/4.15.0-1044-aws/build SUBDIRS=/root/ish-ar.io-lab modules<br/>make[1]: Entering directory '/usr/src/linux-headers-4.15.0-1044-aws'<br/>CC [M]  /root/ish-ar.io-lab/ish.o<br/>Building modules, stage 2.<br/>MODPOST 1 modules<br/>CC      /root/ish-ar.io-lab/ish.mod.o<br/>LD [M]  /root/ish-ar.io-lab/ish.ko<br/>make[1]: Leaving directory '/usr/src/linux-headers-4.15.0-1044-aws'</span></pre><p id="ca89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要插入模块类型:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="907f" class="la jg hi kw b fi lb lc l ld le">insmod ish.ko</span></pre><p id="3840" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要查看模块是否已加载，请键入:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="8bf2" class="la jg hi kw b fi lb lc l ld le">root@ip-172-31-3-95:~/ish-ar.io-lab# lsmod | grep ish ish                    16384  0</span></pre><p id="8593" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有用吗？来测试一下吧！<br/>我们需要执行一些东西，所以让我们键入<code class="du lg lh li kw b">ls</code>，然后看到dmesg:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="ec35" class="la jg hi kw b fi lb lc l ld le">root@ip-172-31-3-95:~/ish-ar.io-lab# dmesg </span><span id="a3aa" class="la jg hi kw b fi lf lc l ld le">[ 4813.434548] Module inserted <br/>[ 4815.142934] ish-ar.io pre_handler: counter=0<br/>[ 4815.142935] ish-ar.io post_handler: counter=1</span></pre><p id="51b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以如果你有这样的输出…是的！有用！</p><p id="f5e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要删除该模块，只需键入:</p><pre class="ke kf kg kh fd kv kw kx ky aw kz bi"><span id="9fbb" class="la jg hi kw b fi lb lc l ld le">rmmod ish</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="cfc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重述:</strong></p><p id="f802" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们学到了什么？</p><p id="d274" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何使用内核模块使用Kprobes，pre <em class="jd">和post </em>处理程序是什么，如何使用它们在每次调用函数时进行计数(例如:sys_execve) </strong></p></div></div>    
</body>
</html>