<html>
<head>
<title>Text Blocks (JEP 368)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">文本块(JEP 368)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/text-blocks-jep-368-56c1625f97cf?source=collection_archive---------16-----------------------#2020-02-03">https://medium.com/analytics-vidhya/text-blocks-jep-368-56c1625f97cf?source=collection_archive---------16-----------------------#2020-02-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/123f8a20998bb966380b2674713b5170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nXYTE031_rRlTixyGNM4g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">日航·马哈尔</figcaption></figure><p id="a754" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在Java中编写多行字符串不是一件有趣的事情，你必须编写代码，要求把HTML、JSON、XML或SQL查询作为字符串放入你的代码中。</p><p id="5e7c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请看下面的例子，我们试图把JSON作为字符串</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="542f" class="kb kc hi jx b fi kd ke l kf kg">String sampleJson = "{\"name\":\"josh\",\"salary\":\"8000$\",\"age\":27,\"isMarried\":\"True\"}";</span></pre><p id="289c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里我们有一个非常简单的JSON，有很多转义序列，很难读懂。</p><p id="d2ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以做得更好，使其可读，见下文</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="c16b" class="kb kc hi jx b fi kd ke l kf kg">String sampleJsonReadableABit = "{" +<br/>        "\"name\":\"josh\"," +<br/>        "\"salary\":\"8000$\"," +<br/>        "\"age\":27," +<br/>        "\"isMarried\":\"True\""+<br/>        "}";</span></pre><p id="4345" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它比早期的要好，但是仍然难以阅读(大量的连接和转义序列)并且容易出错。添加或删除另一个属性对任何开发人员来说都不容易。</p><p id="66b7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">引入文本块的主要目的是</p><ul class=""><li id="a1f9" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated">易于编写多行字符串</li><li id="8b0e" class="kh ki hi iw b ix kq jb kr jf ks jj kt jn ku jr km kn ko kp bi translated">删除转义序列并增强可读性</li><li id="84e2" class="kh ki hi iw b ix kq jb kr jf ks jj kt jn ku jr km kn ko kp bi translated">智能地处理空白和缩进</li></ul><h2 id="ccd0" class="kb kc hi bd kv kw kx ky kz la lb lc ld jf le lf lg jj lh li lj jn lk ll lm ln bi translated">什么是文本块？</h2><p id="b399" class="pw-post-body-paragraph iu iv hi iw b ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn ls jp jq jr hb bi translated">文本块作为预览功能在2019年6月与JDK 13一起发布，基于反馈，这将作为JEP 368与JDK 14再次预览。</p><p id="24cd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个特性被开发人员忽略了很长时间，特别是当有人不得不阅读嵌入了JSON文档或SQL语句的代码时。</p><p id="1748" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如定义"<strong class="iw hj"> <em class="lt">文本块是一个多行字符串文字，它避免了对大多数转义序列的需要，以可预测的方式自动格式化字符串，并在需要时让开发人员控制格式</em> </strong>"。</p><p id="8437" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">文本块用三个双引号<strong class="iw hj">“”</strong>定义，作为开始和结束分隔符。</p><p id="9594" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看看如何通过文本块呈现上述JSON</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="1b38" class="kb kc hi jx b fi kd ke l kf kg">String jsonAsTextBlocks =  """<br/>        {<br/>        "name":"josh",<br/>        "salary":"8000$",<br/>        "age":27,<br/>        "isMarried":"True"<br/>        }<br/>         """;</span></pre><p id="c8e9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">读书不是更好吗？没有转义序列:)</p><p id="beda" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">像Kotlin、Scala或Groovy这样的语言都有这个特性。</p><h2 id="d546" class="kb kc hi bd kv kw kx ky kz la lb lc ld jf le lf lg jj lh li lj jn lk ll lm ln bi translated">要点</h2><ul class=""><li id="3a98" class="kh ki hi iw b ix lo jb lp jf lu jj lv jn lw jr km kn ko kp bi translated">在内容真正开始之前，开始分隔符后面必须跟一个行结束符，尝试编写如下所示的文本块将会出现编译时错误。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="ea60" class="kb kc hi jx b fi kd ke l kf kg">String textBlockSample = """Ashish //Compile time error<br/>        """;</span><span id="5840" class="kb kc hi jx b fi lx ke l kf kg">String textBlockSampleTwo = """Ashish"""; //Compile time error</span><span id="e488" class="kb kc hi jx b fi lx ke l kf kg">String textBlockSampleThree = """"""; //Compile time error</span><span id="acc8" class="kb kc hi jx b fi lx ke l kf kg">String textBlockSampleFour = """ """; //Compile time error</span></pre><p id="afc4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">#在第一个示例中，内容放在没有行结束符的开始分隔符“”之后。这是不允许的，将会是一个编译时错误。</p><p id="8fbe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">#在第二个示例中，内容也直接放置在开始分隔符""和结束分隔符"""下，没有行结束符(通常使用字符串我们喜欢类似于<strong class="iw hj"><em class="lt">String str = " a shish "</em></strong><em class="lt">的样式，但是这种样式不允许用于文本块</em>)。这也是不允许的，将会是一个编译时错误。</p><p id="cc98" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">编译器会忽略开始分隔符和行结束符之间的空格，因为内容只会在行结束符之后开始。</p><ul class=""><li id="eb1f" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated"><strong class="iw hj">结束分隔符</strong>，下面提到的例子中没有这样的规则有效。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="f9cc" class="kb kc hi jx b fi kd ke l kf kg">String textBlockSample = """ //valid syntax<br/>        Ashish""";</span><span id="5c9e" class="kb kc hi jx b fi lx ke l kf kg">String textBlockSampleTwo = """ //valid syntax<br/>        Ashish<br/>        """;</span><span id="0a14" class="kb kc hi jx b fi lx ke l kf kg">String textBlockSampleThree = """ //valid syntax (empty)<br/>        """;</span></pre><ul class=""><li id="0633" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated"><strong class="iw hj">附带空白，</strong>文本块区分巧妙区分附带空白和必要空白。Java编译器会自动去掉附带的空格。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="4771" class="kb kc hi jx b fi kd ke l kf kg">String htmlAsTextBlocks = """<br/>        &lt;html&gt;<br/>           &lt;body&gt;<br/>                &lt;h1&gt;<br/>                Sample Heading<br/>                &lt;/h1&gt;<br/>           &lt;/body&gt;<br/>        &lt;/html&gt;<br/>             """;</span></pre><p id="544a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您运行上面的代码片段，输出将如下所示，标记之前的任何空格都将被视为附带空格，并被编译器简单地删除，但下面标有<strong class="iw hj"><em class="lt">……</em></strong>的空格不是附带空格，此类空格将被视为预期/所需/必要的空格，并被编译器考虑。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="fd60" class="kb kc hi jx b fi kd ke l kf kg">&lt;html&gt;<br/>...&lt;body&gt;<br/>........&lt;h1&gt;<br/>........Sample Heading<br/>........&lt;/h1&gt;<br/>...&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d58d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您想在内容之前显式添加一些空格，可以使用结束分隔符<strong class="iw hj"> """ </strong>来控制内容，请注意下面的代码片段，这里的结束分隔符已被显式向左移动。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="ddb0" class="kb kc hi jx b fi kd ke l kf kg">String htmlAsTextBlocksWithSpace = """<br/>          &lt;html&gt;<br/>              &lt;body&gt;<br/>                  &lt;h1&gt;<br/>                  Sample Heading<br/>                  &lt;/h1&gt;<br/>              &lt;/body&gt;<br/>          &lt;/html&gt;<br/>""";</span></pre><p id="49a8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它将有如下输出:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="9c55" class="kb kc hi jx b fi kd ke l kf kg">          &lt;html&gt;<br/>              &lt;body&gt;<br/>                  &lt;h1&gt;<br/>                  Sample Heading<br/>                  &lt;/h1&gt;<br/>              &lt;/body&gt;<br/>          &lt;/html&gt;</span></pre><p id="dd16" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，前导空格由编译器考虑的结束分隔符标记。注意结束定界符有控制前导空白的作用，但是它不能对尾随空白产生任何影响，例如，如果上面的代码像下面这样改变</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="069c" class="kb kc hi jx b fi kd ke l kf kg">String htmlAsTextBlocksWithSpace = """<br/>        &lt;html&gt;<br/>            &lt;body&gt;<br/>                &lt;h1&gt;<br/>                Sample Heading<br/>                &lt;/h1&gt;<br/>            &lt;/body&gt;<br/>        &lt;/html&gt;<br/>                                          """;</span></pre><p id="d3fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它会有如下输出</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="b9b8" class="kb kc hi jx b fi kd ke l kf kg">&lt;html&gt;<br/>   &lt;body&gt;<br/>       &lt;h1&gt;<br/>       Sample Heading<br/>       &lt;/h1&gt;<br/>   &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="f68b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要特别添加一些尾随空白，您可以这样做:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="8310" class="kb kc hi jx b fi kd ke l kf kg">String textBlockWithTrailingSpace = """<br/>        Ashish    \040""";</span></pre><p id="7a5b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你计算上面的文本块长度，它将是11。</p><h2 id="575c" class="kb kc hi bd kv kw kx ky kz la lb lc ld jf le lf lg jj lh li lj jn lk ll lm ln bi translated">文本块和字符串之间的相似性</h2><ul class=""><li id="cc49" class="kh ki hi iw b ix lo jb lp jf lu jj lv jn lw jr km kn ko kp bi translated">很大程度上，我们可以在任何字符串用法适用的地方使用文本块，例如，如果任何方法定义可以将字符串变量作为参数，我们可以在那里传递文本块。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="28b8" class="kb kc hi jx b fi kd ke l kf kg">private static void textBlocksAsString(String str){<br/>    System.<em class="lt">out</em>.println(str);<br/>}<br/></span></pre><p id="6ff3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以上方法可以调用为"<strong class="iw hj"><em class="lt">textBlocksAsString(" "<br/>我是Fun<br/>" ")；</em> </strong></p><p id="58b1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是完全有效的语法。</p><ul class=""><li id="ed7a" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated">传统的字符串值和文本块都被编译成相同的类型:字符串。字节码类文件不区分字符串值是从传统字符串还是文本块中派生出来的。这意味着文本块值像任何普通字符串一样存储在字符串池中。<strong class="iw hj">如果==和equals引用完全相同的值，它们将返回true </strong>。参见下面的代码片段</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="2776" class="kb kc hi jx b fi kd ke l kf kg">String str = "Ashish";<br/>String textBlock = """<br/>        Ashish""";</span></pre><p id="59b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你运行一些东西</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="ad6d" class="kb kc hi jx b fi kd ke l kf kg">System.<em class="lt">out</em>.println(str==textBlock);<br/>System.<em class="lt">out</em>.println(str.equals(textBlock));</span></pre><p id="767e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这两条语句都将打印出<strong class="iw hj"> true </strong>，但是如果您稍微修改一下上面的代码:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="8f9b" class="kb kc hi jx b fi kd ke l kf kg">String str = "Ashish";<br/>String textBlock = """<br/>        Ashish<br/>        """;</span></pre><p id="7c8f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">==和equals都将返回false。</p><ul class=""><li id="ee20" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated">您可以像连接两个字符串一样连接字符串和文本块，如下所示</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="1b33" class="kb kc hi jx b fi kd ke l kf kg">System.<em class="lt">out</em>.println( """<br/>    Works<br/>    is fun<br/>    """<br/>        +<br/>        "Let's have some");</span></pre><ul class=""><li id="aba1" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated">对于某些业务需求，我们必须编写代码，其中字符串需要根据某些正则表达式进行拆分并转换为列表。这种用例也通过文本块得到了简化</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="4661" class="kb kc hi jx b fi kd ke l kf kg">String fruits = "Apple,Orange,Mango";<br/>List&lt;String&gt; fruitsList = new ArrayList&lt;&gt;();<br/>Collections.<em class="lt">addAll</em>(fruitsList,fruits.split(","));</span><span id="d102" class="kb kc hi jx b fi lx ke l kf kg">//Such operation will be simplified like below<br/>String fruitsTextBlocks = """<br/>        Apple<br/>        Orange<br/>        Banana<br/>        """;<br/>List&lt;String&gt; lisOfFruits = fruitsTextBlocks.lines().collect(Collectors.<em class="lt">toList</em>());</span></pre><h2 id="3847" class="kb kc hi bd kv kw kx ky kz la lb lc ld jf le lf lg jj lh li lj jn lk ll lm ln bi translated">编译步骤</h2><p id="6cda" class="pw-post-body-paragraph iu iv hi iw b ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn ls jp jq jr hb bi translated">编译器分三步处理文本块:</p><ol class=""><li id="7d3f" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr ly kn ko kp bi translated">行结束符— Windows和Linux有不同的行结束符，Windows使用回车和换行符(" \r\n ")，而Linux只使用换行符(" \n ")。为了避免源代码将一个操作系统转移到另一个操作系统时出现任何问题，文本块将行尾规范化为\u000a。规范化期间不解释转义序列\n (LF)、\f (FF)和\r (CR)。转义处理稍后发生。</li><li id="8798" class="kh ki hi iw b ix kq jb kr jf ks jj kt jn ku jr ly kn ko kp bi translated">移除附带的空白-以上步骤进行标准化，在此步骤中，所有附带的空白将被移除，如上所述。算法不解释转义序列\b(退格)和\t (tab );转义处理稍后发生。</li><li id="7966" class="kh ki hi iw b ix kq jb kr jf ks jj kt jn ku jr ly kn ko kp bi translated">解释转义序列—如果您的文本块有任何转义序列，它将被立即解释。文本块支持字符串中支持的所有转义序列，包括\n，\t，\ '，\ "，和\\。</li></ol><h2 id="ae5e" class="kb kc hi bd kv kw kx ky kz la lb lc ld jf le lf lg jj lh li lj jn lk ll lm ln bi translated">换码顺序</h2><ul class=""><li id="7c0a" class="kh ki hi iw b ix lo jb lp jf lu jj lv jn lw jr km kn ko kp bi translated">转义序列<strong class="iw hj"/>的处理</li></ul><p id="c4e7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在文本块中有转义序列是完全有效的，见下文</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="6090" class="kb kc hi jx b fi kd ke l kf kg">String textBlockWithES = """<br/>    When your "work" speaks for yourself don't Interrupt<br/>    """;</span></pre><p id="d07f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是，如果您试图将它放在靠近结束分隔符的位置，如下所示:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="fd1f" class="kb kc hi jx b fi kd ke l kf kg">String textBlockWithESI = """<br/>    When your "work" speaks for yourself don't "Interrupt"""";</span></pre><p id="45a9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这将是一个编译时错误，有两种方法可以解决:</p><p id="e3fe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">-&gt;将结束分隔符带入下一行</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="2538" class="kb kc hi jx b fi kd ke l kf kg">String textBlockWithESI = """<br/>    When your "work" speaks for yourself don't "Interrupt"<br/>    """;</span></pre><p id="edb9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">-&gt;使用转义</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="da87" class="kb kc hi jx b fi kd ke l kf kg">String textBlockWithESI = """<br/>    When your "work" speaks for yourself don't "Interrupt\"""";</span></pre><p id="202f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此转义字符\可以放在上一行的最后四个字符("""")中的任何一个之前。</p><ul class=""><li id="a5f7" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated">文本块嵌入了另一个文本块</li></ul><p id="fbf4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">即使您尝试在文本块中除了开始和结束分隔符之外的任何位置放置三元组""，您也已经放置了转义符，否则将会出现编译时错误:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="d2ff" class="kb kc hi jx b fi kd ke l kf kg">String textBlockWithESII = """<br/>    When your "work" \""" speaks for yourself don't "Interrupt\"""";<br/>//Above is a valid Text Block</span></pre><p id="0522" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在类似行中，如果你需要在一个文本块中嵌入另一个文本块，你必须使用转义符</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="7109" class="kb kc hi jx b fi kd ke l kf kg">String textBlockWithAnotherEmbedded =<br/>        """<br/>        String text = \"""<br/>            A text block inside a text block<br/>        ""\";<br/>        """;</span></pre><p id="d1fc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">新逃脱序列</strong></p><ol class=""><li id="c713" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr ly kn ko kp bi translated">一个很常见的实践/需求是，将一个长字符串分成多个子字符串，用“+”将它们连接起来，以保持代码的可读性，但输出将是单行。为了处理在java中添加的类似需求n <strong class="iw hj"> ew转义序列\ </strong>,这只适用于TextBlocks。</li></ol><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="1015" class="kb kc hi jx b fi kd ke l kf kg">String quoteAsStr = "Fearlessness is like a muscle. " +<br/>        "I know from my own life that the more I exercise it, " +<br/>        "the more natural it becomes to not let my fears run me.";<br/><br/>System.<em class="lt">out</em>.println(quoteAsStr);</span><span id="736f" class="kb kc hi jx b fi lx ke l kf kg">String quoteAsTextBlocks = """<br/>        Fearlessness is like a muscle. \<br/>        I know from my own life that the more I exercise it, \<br/>        the more natural it becomes to not let my fears run me.""";</span><span id="f819" class="kb kc hi jx b fi lx ke l kf kg">System.<em class="lt">out</em>.println(quoteAsTextBlocks);</span></pre><p id="209e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您执行上述代码，两个打印输出将完全相同</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="a46f" class="kb kc hi jx b fi kd ke l kf kg">Fearlessness is like a muscle. I know from my own life that the more I exercise it, the more natural it becomes to not let my fears run me.</span><span id="b90f" class="kb kc hi jx b fi lx ke l kf kg">Fearlessness is like a muscle. I know from my own life that the more I exercise it, the more natural it becomes to not let my fears run me.</span></pre><p id="4967" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.添加了这个JEP的另一个新的转义序列<strong class="iw hj"> \s </strong>，就是简单地翻译成一个空格(\u0020)。转义序列直到事件空格剥离后才被转换，因此<strong class="iw hj"> \s </strong>可以作为栅栏来防止尾部空格的剥离。这个转义序列适用于字符串和文本块。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="c74d" class="kb kc hi jx b fi kd ke l kf kg">String colors = """<br/>        red  \s""";<br/>System.<em class="lt">out</em>.println(colors.length());</span></pre><p id="ef31" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在控制台输出将打印6。</p><h2 id="e9b1" class="kb kc hi bd kv kw kx ky kz la lb lc ld jf le lf lg jj lh li lj jn lk ll lm ln bi translated">新方法</h2><ul class=""><li id="5ab3" class="kh ki hi iw b ix lo jb lp jf lu jj lv jn lw jr km kn ko kp bi translated">string::striping dent()</li></ul><p id="4dda" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如上所述，编译器会从文本块中删除附带空格，这种方法会添加到字符串中，以获得与普通字符串相同结果。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="b5fc" class="kb kc hi jx b fi kd ke l kf kg">String fruitsStr = "red\n   green\n   blue";</span><span id="ba88" class="kb kc hi jx b fi lx ke l kf kg">System.<em class="lt">out</em>.println(fruitsStr);<br/>//<strong class="jx hj">1-</strong> It will print <br/>//red<br/>//   green<br/>//   blue</span><span id="99b1" class="kb kc hi jx b fi lx ke l kf kg">System.<em class="lt">out</em>.println(fruitsStr.replace(" ","."));<br/>//<strong class="jx hj">2</strong>- It will print<br/>//red<br/>//...green<br/>//...blue</span><span id="b20f" class="kb kc hi jx b fi lx ke l kf kg">System.<em class="lt">out</em>.println(fruitsStr.stripIndent());<br/>//<strong class="jx hj">3</strong>- It will print<br/>//red<br/>//   green<br/>//   blue</span></pre><p id="cc61" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的代码片段中，您可以观察到stripIndent()方法没有影响，因为编译器没有发现附带的空白，但是如果您有如下所示的字符串:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="59bf" class="kb kc hi jx b fi kd ke l kf kg">String fruitsStrWithLeadingSpace = "  red\n   green\n   blue";</span><span id="0136" class="kb kc hi jx b fi lx ke l kf kg">System.<em class="lt">out</em>.println(fruitsStrWithLeadingSpace);<br/>//<strong class="jx hj">1</strong>- It will print<br/>//  red<br/>//   green<br/>//   blue</span><span id="6222" class="kb kc hi jx b fi lx ke l kf kg">System.<em class="lt">out</em>.println(fruitsStrWithLeadingSpace.replace(" ","."));<br/>//<strong class="jx hj">2</strong>- It will print<br/>//..red<br/>//...green<br/>//...blue</span><span id="9a8a" class="kb kc hi jx b fi lx ke l kf kg">System.<em class="lt">out</em>.println(fruitsStrWithLeadingSpace.stripIndent());<br/>//<strong class="jx hj">3</strong>- It will print<br/>//red<br/>// green<br/>// blue</span></pre><p id="8b38" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，您可以看到第二个和第三个控制台打印之间的前导空格已从字符串中删除。</p><ul class=""><li id="1c3e" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated">String::translateEscapes()</li></ul><p id="85c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">顾名思义，这将翻译字符串中的转义序列，见下面的例子</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="d39a" class="kb kc hi jx b fi kd ke l kf kg">String fruitsStr = "red\n   green\\n   \"blue\"";<br/>System.<em class="lt">out</em>.println(fruitsStr);<br/>//<strong class="jx hj">1-</strong> It will print<br/>//red<br/>//   green\n   "blue"</span><span id="ba2e" class="kb kc hi jx b fi lx ke l kf kg">System.<em class="lt">out</em>.println(fruitsStr.translateEscapes());<br/>//<strong class="jx hj">2-</strong> And after translateEscape, it will print<br/>//red<br/>//   green<br/>//   "blue"</span></pre><p id="8898" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以在<strong class="iw hj"> 2- </strong>控制台打印中观察到新行字符已被翻译。</p><ul class=""><li id="b9ee" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated">String::格式化(Object… args)</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="7ec1" class="kb kc hi jx b fi kd ke l kf kg">String jsonAsTextBlocks =  """<br/>{<br/>"name":"%s"<br/>}<br/> """.formatted("Ashish");</span><span id="9a26" class="kb kc hi jx b fi lx ke l kf kg">System.<em class="lt">out</em>.println(jsonAsTextBlocks);<br/>//It will print<br/>//{<br/>//"name":"Ashish"<br/>//}</span></pre><p id="18a3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它工作方式非常类似于字符串。</p></div></div>    
</body>
</html>