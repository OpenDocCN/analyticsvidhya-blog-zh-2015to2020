<html>
<head>
<title>Useful Tips for using Python Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python装饰器的有用技巧</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/useful-tips-for-using-python-decorators-fb0d6daec7c9?source=collection_archive---------28-----------------------#2020-06-03">https://medium.com/analytics-vidhya/useful-tips-for-using-python-decorators-fb0d6daec7c9?source=collection_archive---------28-----------------------#2020-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d1c5b82a5e1ba61b160202b734f708e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpYYxKVIkKfamC5O-QKHeQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://www.pexels.com/photo/blur-branches-bright-christmas-decor-283932/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae iu" href="https://www.pexels.com/@inna-lesyk-67454?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Inna Lesyk </a>拍摄</figcaption></figure><p id="e95f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated"><span class="l ju jv jw bm jx jy jz ka kb di"> W </span>当我开始学习python的时候，我曾经对每一个新的概念或技巧感到兴奋，或者你知道python让代码看起来不那么可怕的方式，同时在幕后做了很多事情。然而，在你学过的每一种编程语言中，总有一件事你无法理解。对我来说，那就是“装饰者”,然后，当你意识到这个概念在你的项目中是多么有帮助时，你会感觉更糟。</p><p id="91de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，如果你是python的新手，并对装饰者感到害怕，那你就来对地方了。我将从最基础的地方开始，重点关注我觉得大多数初学者会犯错误的地方。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><figure class="kk kl km kn fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/3969d3d5aef0c1f72fff54ae6b2f11e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9RuNkjnfWvHOlb0p"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@emilymorter?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾米丽·莫特</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="4661" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">为什么装修工是必须的？</h1><p id="45a2" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">例如，假设您正在为一个教育平台开发一个应用程序&amp;您的客户指定他想要所有的学习资料、课程、笔记等。对已验证的用户和未验证的用户都是自由可用的。所以，你开始工作并构建了一个很棒的应用程序，但是正如客户指定的，没有访问过滤器来区分用户。现在，在开发工作流程的某个地方，您的客户意识到了他的业务模型中的一些缺陷&amp;请求对最终的应用程序进行一些修改，以限制未经验证的用户访问任何特定的内容&amp;允许那些已经验证了他们的电子邮件地址的用户——砰！。</p><p id="b171" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像这样，你的客户接受标准一路下滑，原因并不是你的错。</p><p id="4144" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，你有两个选择:</p><ol class=""><li id="6746" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">您继续向您的客户想要访问限制的每个功能单元添加访问协议。</li><li id="038c" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">或者，您聪明地使用类似于python中的decorators的东西来定义一次访问级别功能，并在任何想要升级访问级别的地方使用它。</li></ol><blockquote class="mf"><p id="2356" class="mg mh hi bd mi mj mk ml mm mn mo js dx translated">装饰器就是这样，它给先前定义的函数增加了额外的功能。</p></blockquote><p id="1d96" class="pw-post-body-paragraph iv iw hi ix b iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo mt jq jr js hb bi translated">它属于一个更广泛的类别，称为<strong class="ix hj">元编程，</strong>其中程序的一个组件试图在编译时修改另一个组件的功能。</p><p id="f334" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，这就是你现在需要知道的。让我们开始有趣的部分。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="b596" class="ko kp hi bd kq kr mu kt ku kv mv kx ky kz mw lb lc ld mx lf lg lh my lj lk ll bi translated">初始实施:</h1><p id="6ba7" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">首先，让我们看看我们现在在用户过滤方面的情况:</p><figure class="kk kl km kn fd ij"><div class="bz dy l di"><div class="mz na l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://gist.github.com/pratik-1999/03be1643db401860e7ef11dfc4d5d1ab" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><figure class="kk kl km kn fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/38fd24fa08b225fa0c9fcec02436f3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*-YWrROJ5cxXL0JF6iI1Cxg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="6541" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们可以清楚地看到，没有访问过滤器，因此经过验证和未经验证的用户都可以访问每个资源，执行代码将产生以下输出。注意，这里我们只使用了三个需要访问限制的函数，但是在现实世界中，这个数字可能是几十个或者更多。</p><p id="d040" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想想看，如果我们在我们想要应用访问限制的每个函数中检查用户的<strong class="ix hj">状态</strong>，传统的if-else语句方法会有多乏味。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="4b08" class="ko kp hi bd kq kr mu kt ku kv mv kx ky kz mw lb lc ld mx lf lg lh my lj lk ll bi translated">基于装饰器的实现:</h1><p id="7c45" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">现在让我们看看decorators是如何让添加客户要求的访问限制功能变得如此容易的。</p><figure class="kk kl km kn fd ij"><div class="bz dy l di"><div class="mz na l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://gist.github.com/pratik-1999/55bac55aaa9c724cb7d9b6f866f4a66e" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><figure class="kk kl km kn fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/41f5e8b1f22f05c90fb8414c6c2f3396.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*cpbCfeaZhP3R5jkRgWLDGw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="aab9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">装饰器<code class="du nd ne nf ng b">restrict_access</code>将我们需要应用访问过滤器的函数作为其输入参数，在我们的例子中，函数是<code class="du nd ne nf ng b">get_study_materials</code>和<code class="du nd ne nf ng b">get_study_notes</code>。</p><p id="e328" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，名为<code class="du nd ne nf ng b">check_status</code>的包装函数验证用户的状态，如果用户通过验证，则提供访问。最后，装饰器返回这个包装函数。</p><p id="b258" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了使用装饰器，只需将<code class="du nd ne nf ng b">@decorator_name </code>放在那些我们想要限制未验证用户访问的函数声明的上方，我们就完成了！</p><p id="621a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续，因为客户要求将学习材料和笔记的访问权限仅限于经过验证的用户。你所要做的就是在<code class="du nd ne nf ng b">get_study_materials</code>和<code class="du nd ne nf ng b">get_study_notes</code>函数上面使用<code class="du nd ne nf ng b">restrict_access</code>装饰器。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="978c" class="ko kp hi bd kq kr mu kt ku kv mv kx ky kz mw lb lc ld mx lf lg lh my lj lk ll bi translated">最佳实践和实施:</h1><p id="6aef" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">虽然上面的decorator实现本身完全没问题，但是它可能会导致一些难以跟踪的问题，并且需要一些改进，我希望我在开始使用decorator时就知道这些。</p><h2 id="e07f" class="nh kp hi bd kq ni nj nk ku nl nm nn ky jg no np lc jk nq nr lg jo ns nt lk nu bi translated"><em class="nv">提示1 </em></h2><blockquote class="nw nx ny"><p id="55af" class="iv iw nz ix b iy iz ja jb jc jd je jf oa jh ji jj ob jl jm jn oc jp jq jr js hb bi translated">在装饰器内部的任何包装函数之上总是包含<code class="du nd ne nf ng b">functools.wraps(func)</code>。</p></blockquote><p id="c733" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了了解原因，只需执行以下命令:</p><figure class="kk kl km kn fd ij"><div class="bz dy l di"><div class="mz na l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://gist.github.com/pratik-1999/d827c523395568408cfa2bed8152e7df" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><figure class="kk kl km kn fd ij er es paragraph-image"><div class="er es od"><img src="../Images/96e20f8d7653094efa7a21b8b5117cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*8cOpuzooW7QaOdPTo0aJVw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="a301" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意<code class="du nd ne nf ng b">get_study_materials</code>和<code class="du nd ne nf ng b">get_study_notes</code>函数的名字是如何在装饰器中变成包装函数<code class="du nd ne nf ng b">check_status</code>的名字的。这是一个被忽视的严重问题，当你使用原来的名字时，困难就出现了。</p><p id="4583" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看<code class="du nd ne nf ng b">functools</code>图书馆在这方面有什么帮助:</p><figure class="kk kl km kn fd ij"><div class="bz dy l di"><div class="mz na l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://gist.github.com/e9544b969c192d1f8b8c86ea65307a7a.git" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><figure class="kk kl km kn fd ij er es paragraph-image"><div class="er es oe"><img src="../Images/f9c22baf28303b774b39227d30c7b7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*RFFtKUcQNGVzsk1amCcMeQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="1f8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du nd ne nf ng b">@functools.wraps(func)</code>只是确保<code class="du nd ne nf ng b">check_status</code>只作为一个包装器，不修改被传递函数的名字。输出验证功能正常。</p><h2 id="ed5c" class="nh kp hi bd kq ni nj nk ku nl nm nn ky jg no np lc jk nq nr lg jo ns nt lk nu bi translated">提示#2</h2><blockquote class="nw nx ny"><p id="7143" class="iv iw nz ix b iy iz ja jb jc jd je jf oa jh ji jj ob jl jm jn oc jp jq jr js hb bi translated">在向包装函数传递输入参数时，使用<strong class="ix hj">* args</strong>&amp;<strong class="ix hj">* * kwargs</strong>。</p></blockquote><p id="0d84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">原因是，假设我们在将来定义新的功能或修改当前的功能，以获得不同数量的输入参数，我们的装饰器仍然可以正常工作。</p><figure class="kk kl km kn fd ij"><div class="bz dy l di"><div class="mz na l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://gist.github.com/8156a0310d080b1bd236b1b8dfa170de.git" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><figure class="kk kl km kn fd ij er es paragraph-image"><div class="er es of"><img src="../Images/e60619e4e3c34abb8474d42f0dcb50b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*llXoy-hNWFhLaHSTllEzOg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="9900" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，即使在<code class="du nd ne nf ng b">get_study_notes</code>函数中添加了一个额外的参数，我们的装饰器仍然无缝地适应了变化。这提供了很大的灵活性，同时定义了更多的通用装饰器，就像我们的例子一样。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="c97c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请在下面的评论中分享你的疑惑，我很乐意帮助你。同时，如果您学到了一些有价值的东西，请留下赞/鼓掌，并关注我以获取即将到来的数据科学系列的更新。</p><p id="5be1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想在python里学点别的？这是给你的:</p><div class="og oh ez fb oi oj"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/unit-testing-with-python-101-e3eb0e7c1170"><div class="ok ab dw"><div class="ol ab om cl cj on"><h2 class="bd hj fi z dy oo ea eb op ed ef hh bi translated">用Python 101进行单元测试</h2><div class="oq l"><h3 class="bd b fi z dy oo ea eb op ed ef dx translated">在大多数情况下，数据科学团队和软件工程团队之间经常发生争论。</h3></div><div class="or l"><p class="bd b fp z dy oo ea eb op ed ef dx translated">medium.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox io oj"/></div></div></a></div></div></div>    
</body>
</html>