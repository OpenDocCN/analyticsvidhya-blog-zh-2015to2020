<html>
<head>
<title>EDA Approach of the Spotify Dataset with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现Spotify数据集的EDA方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/analyzing-spotify-dataset-with-python-6ba9cb82a486?source=collection_archive---------8-----------------------#2020-10-19">https://medium.com/analytics-vidhya/analyzing-spotify-dataset-with-python-6ba9cb82a486?source=collection_archive---------8-----------------------#2020-10-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8bb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大家好！以下是我对Spotify数据集的分析。</p><p id="a051" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在使用Python的Spotify数据集的探索性数据分析方法中解释我的分析。在Kaggle上可以获得数据集。对了，我用的是Google Colab。</p><p id="9a3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我在Google Colab中导入csv文件，如下所示。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="ac0b" class="jn jo hi jj b fi jp jq l jr js">from google.colab import files<br/>uploaded = files.upload()</span></pre><p id="5751" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经创建了代表我的数据框的“df”函数。数据框有助于查看按行和列排列的数据集。第一个变量是未命名的，该列只显示行号，然后我删除了它。这些步骤如下所示。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="06d0" class="jn jo hi jj b fi jp jq l jr js">import pandas as pd<br/>import io<br/>import numpy as np</span><span id="b2bf" class="jn jo hi jj b fi jt jq l jr js">df = pd.read_csv(io.BytesIO(uploaded[‘spotify_data.csv’]))<br/>df = df.drop(“Unnamed: 0”, axis=”columns”)<br/>df.head()</span></pre><p id="e3c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的数据集中有2017行x 16列。前5行，如图1所示。你可以在<a class="ae jd" href="https://developer.spotify.com/documentation/web-api/reference/tracks/get-audio-features/" rel="noopener ugc nofollow" target="_blank">这里</a>找到变量的描述。</p><figure class="je jf jg jh fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es ju"><img src="../Images/c3b07e85a9d21d75cc39adecf470dd0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StU7_HX_H5gPfMf-VBJDeQ.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">图1</figcaption></figure><p id="f946" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我做了一个热图，看看哪些变量相关性最高。你可以在下面看到我的代码。图2中的热图显示响度和能量之间的相关性最高。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="378f" class="jn jo hi jj b fi jp jq l jr js">import matplotlib.pyplot as plot<br/>import seaborn as sns<br/>import matplotlib.ticker as ticker</span><span id="6d08" class="jn jo hi jj b fi jt jq l jr js">corr = df.corr()<br/>fig1 = plot.figure(figsize=(16, 8))<br/>sns.heatmap(df.corr(), annot=True, annot_kws={'weight':'bold'},linewidths=.5, cmap='RdPu')</span><span id="1ad0" class="jn jo hi jj b fi jt jq l jr js">sns.lmplot(y='loudness',x='energy',data=df, hue='target',palette='RdPu')</span></pre><figure class="je jf jg jh fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es kg"><img src="../Images/c484dc6648a0c030eb2ac95a3c73b884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1nnNHxdx2jPaOzvYoQF_A.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">图2</figcaption></figure><p id="6a4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据图3中的目标，我创建了一个散点图和趋势线来查看响度和能量之间的关系是最高的。淡粉色线表示目标为0时响度和能量的关系。另一行显示了目标为1时的关系。</p><p id="5941" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PS:如果目标为1，则表明该曲目已命中。如果它是0，这意味着轨道是翻牌的。</p><figure class="je jf jg jh fd jv er es paragraph-image"><div class="er es kh"><img src="../Images/cd13297087fdf81235dc745ed0dac687.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*BBBeKLSCRUbojEWUTcEa9g.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">图3</figcaption></figure><p id="a17d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我创建了一个直方图，显示了可跳舞性变量对目标的影响。粉色的是打，蓝色的是翻。通过查看图4中的直方图，我们可以说，当可跳舞性增加时，被击中的几率很高。可以对其他变量尝试类似的直方图。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="e1b8" class="jn jo hi jj b fi jp jq l jr js">hit_danceability = df[df[‘target’]==1][‘danceability’]<br/>flop_danceability = df[df[‘target’]==0][‘danceability’]<br/>palette = sns.color_palette(“husl”, 2)<br/>fig = plot.figure(figsize=(12,12))<br/>plot.title(“Danceability”)<br/>hit_danceability.hist(alpha = 0.7, bins = 30, label = ‘hit’)<br/>flop_danceability.hist(alpha = 0.7, bins = 30, label = ‘flop’)<br/>plot.legend()</span></pre><figure class="je jf jg jh fd jv er es paragraph-image"><div class="er es ki"><img src="../Images/22af574d31e5b40a03f332d47f0a893a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*dPBp58KIeENwAOZI-XY8GQ.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">图4</figcaption></figure><p id="3687" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这些图表之后，我根据最高水平的工具性对我的数据进行了分类。我限制为10个，然后添加了歌曲标题和艺术家列，如图5所示。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="0d97" class="jn jo hi jj b fi jp jq l jr js">df.sort_values(‘instrumentalness’, axis = 0, ascending = False).head(10)[[“instrumentalness”,”song_title”,”artist;”,]]</span></pre><figure class="je jf jg jh fd jv er es paragraph-image"><div class="er es kj"><img src="../Images/8ae1123d445f946f6b3b9710bd059462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*-oK-QxIU10rgDVoo9uc0QA.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">图5</figcaption></figure><p id="9479" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们找出最常出现的10位艺术家。结果如图6所示。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="439c" class="jn jo hi jj b fi jp jq l jr js">from collections import Counter<br/>c = Counter(df[‘artist;’])<br/>c.most_common(10)</span></pre><figure class="je jf jg jh fd jv er es paragraph-image"><div class="er es kk"><img src="../Images/ca8f43cfdaa5d9c870a9ce713a14da60.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*lvstFSEEH8iCtD05ZLmEDA.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">图6</figcaption></figure><p id="e86b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我把德雷克的歌按节奏分类。正如我们在图7中看到的，我所拥有的最好成绩有着最高的节奏。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="94ba" class="jn jo hi jj b fi jp jq l jr js">df[(df[‘artist;’] == “Drake;”)].sort_values(‘tempo’, axis = 0, ascending=False)</span></pre><figure class="je jf jg jh fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es kl"><img src="../Images/544825a6a10b9a041e5a41691a9aed58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWrBU2ZePwOpL0oTyGmNCw.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">图7</figcaption></figure><p id="1e5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PS:真的建议用Google Colab。首先，我用PyCharm编码，但是它给出了一个错误，因为库和Python不是同一个版本。Google Colab让这个过程变得更加简单。</p></div></div>    
</body>
</html>