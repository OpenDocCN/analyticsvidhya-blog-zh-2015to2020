<html>
<head>
<title>Lowest Common Ancestor of a Binary Tree — Day 10(Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉树的最低共同祖先—第 10 天(Python)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/lowest-common-ancestor-of-a-binary-tree-day-10-python-be7d09791ba2?source=collection_archive---------9-----------------------#2020-10-03">https://medium.com/analytics-vidhya/lowest-common-ancestor-of-a-binary-tree-day-10-python-be7d09791ba2?source=collection_archive---------9-----------------------#2020-10-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b50b201265e76f057cbec6f893f53c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X_sH4d3dBmS9UaRX"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">阿达什·库姆穆尔在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f198" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们今天将研究一个关于树的问题。在进入问题之前，让我们了解二叉树的一些特征。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="eeff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">二叉树是一种数据结构，其中每个节点最多可以有两个子节点。一棵树最顶端的部分称为根节点，末端称为叶子。任何形式的树都不能有循环。二叉树的一个例子如下。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/b124ef9a5b6d34788a48bb2bb32f1e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*_n5wsBduRPx_RRLVlDqt5g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">二叉树的例子。</figcaption></figure><p id="af0c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> 236 </strong> </a> <strong class="ix hj">。二叉树的最低共同祖先</strong></p><p id="a42d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定一棵二叉树，找出树中两个给定节点的最低共同祖先(LCA)。</p><p id="b19e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据维基百科上的<a class="ae iu" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" rel="noopener ugc nofollow" target="_blank">对 LCA 的定义:“最低的共同祖先被定义在两个节点 p 和 q 之间，作为 T 中同时拥有 p 和 q 作为后代的最低节点(这里我们允许<strong class="ix hj">一个节点是其自身的后代</strong>)”</a></p><p id="6717" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定下面的二叉树:root = [3，5，1，6，2，0，8，null，null，7，4]</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kf"><img src="../Images/1def42c9e4d1c1fbea338886faad52aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*jHNReYD_FXbWVUTR.png"/></div></figure><p id="4b5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例 1: </strong></p><pre class="kb kc kd ke fd kg kh ki kj aw kk bi"><span id="e453" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br/><strong class="kh hj">Output:</strong> 3<br/><strong class="kh hj">Explanation: </strong>The LCA of nodes <!-- -->5<!-- --> and <!-- -->1<!-- --> is <!-- -->3.</span></pre><p id="d3a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例 2: </strong></p><pre class="kb kc kd ke fd kg kh ki kj aw kk bi"><span id="596b" class="kl km hi kh b fi kn ko l kp kq"><strong class="kh hj">Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br/><strong class="kh hj">Output:</strong> 5<br/><strong class="kh hj">Explanation: </strong>The LCA of nodes <!-- -->5<!-- --> and <!-- -->4<!-- --> is <!-- -->5<!-- -->, since a node can be a descendant of itself according to the LCA definition.</span></pre><p id="89e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注:</strong></p><ul class=""><li id="bb6d" class="kr ks hi ix b iy iz jc jd jg kt jk ku jo kv js kw kx ky kz bi translated">所有节点的值都是唯一的。</li><li id="7a9d" class="kr ks hi ix b iy la jc lb jg lc jk ld jo le js kw kx ky kz bi translated">p 和 q 是不同的，两个值都存在于二叉树中。</li></ul><p id="4b4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决方案:</p><p id="5434" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.维护一个提供子节点及其父节点信息的字典。</p><p id="5b75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">a.使用保存要访问的节点的堆栈。</p><p id="5d0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">b.使用保存子节点及其父节点信息的字典。用 key 作为根，value 作为 none 初始化它，这意味着根没有任何父节点。</p><p id="34f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">c.运行循环，直到元素出现在堆栈中。</p><p id="364e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">I .从堆栈中弹出节点。</p><p id="4764" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">二。检查该节点是否有任何左子节点。如果是，将节点的左子节点推入堆栈，并在字典中提到 key 为左子节点，value 为当前节点。如果当前节点有正确的子节点，执行相同的操作。</p><p id="34b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">d.一旦完全遍历了树，就创建一个集合来保存从 node1 到根节点的祖先。</p><p id="165f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">e.从 node2 遍历到根节点，检查上面的集合中是否存在任何节点。如果我们找到一个公共节点，返回节点值。</p><p id="eacd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该算法将如下所示。</p><pre class="kb kc kd ke fd kg kh ki kj aw kk bi"><span id="a410" class="kl km hi kh b fi kn ko l kp kq">class LowestCommonAncestorFinder:<br/>    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':<br/>        stack = [root]<br/>        parent = {root: None}<br/>        while stack:<br/>            node = stack.pop()<br/>            if node.left:<br/>                parent[node.left] = node<br/>                stack.append(node.left)<br/>            if node.right:<br/>                parent[node.right] = node<br/>                stack.append(node.right)<br/>        ancestors = set()<br/>        while p:<br/>            ancestors.add(p)<br/>            p = parent[p]<br/>        while q not in ancestors:<br/>            q = parent[q]<br/>        return q</span></pre><p id="c09a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复杂性分析。</p><p id="acb5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="3f1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们遍历整个图来标记父子关系。因此时间复杂度为 O(N)，其中 N 是节点的数量。</p><p id="9843" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度</strong></p><p id="3d36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们正在创建一个字典来标记树中的父子关系。因此，空间复杂度是 O(N)，其中 N 是节点的数量。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="6b48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以用递归来解决上面的问题。</p><ol class=""><li id="e5c6" class="kr ks hi ix b iy iz jc jd jg kt jk ku jo kv js lf kx ky kz bi translated">在开始使用递归解决问题之前，我们需要理解基本条件。当我们到达树的末端或者我们遇到任何一个节点时，基本条件就满足了。</li><li id="a9a1" class="kr ks hi ix b iy la jc lb jg lc jk ld jo le js lf kx ky kz bi translated">直到达到基本条件，向左和向右移动到当前节点，并将值分别存储在左和右变量中。</li><li id="673c" class="kr ks hi ix b iy la jc lb jg lc jk ld jo le js lf kx ky kz bi translated">验证左侧和右侧是否存在。如果是，返回根值，即父值。</li><li id="1c16" class="kr ks hi ix b iy la jc lb jg lc jk ld jo le js lf kx ky kz bi translated">否则返回左右变量中不为空的变量。</li></ol><pre class="kb kc kd ke fd kg kh ki kj aw kk bi"><span id="eeb7" class="kl km hi kh b fi kn ko l kp kq">class LowestCommonAncestorFinder:<br/>    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':<br/><br/>        if  root == None or root == p or root == q :<br/>            return root<br/>        <br/>        left = self.lowestCommonAncestor(root.left, p, q)<br/>        right = self.lowestCommonAncestor(root.right, p, q)<br/>        <br/>        if left and right:<br/>            return root<br/>        print(root.val,left, right)<br/>        return left if left  else right</span></pre><p id="9d80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复杂性分析。</p><p id="76b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="188c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在最坏的情况下，我们可能需要遍历整个图来找到图中的节点。因此时间复杂度是 O(N)。</p><p id="0c0d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度</strong></p><p id="a5c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们递归地遍历图来寻找节点。在最坏的情况下，我们可能需要遍历整个图来找到节点，递归在内部存储为一个堆栈。因此空间复杂度为 O(N)。</p></div></div>    
</body>
</html>