<html>
<head>
<title>Comprehensive Guide to build a Recommendation Engine from scratch (in Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始构建推荐引擎的综合指南(Python语言)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/comprehensive-guide-to-build-a-recommendation-engine-from-scratch-in-python-af7a62b37b0?source=collection_archive---------3-----------------------#2018-06-21">https://medium.com/analytics-vidhya/comprehensive-guide-to-build-a-recommendation-engine-from-scratch-in-python-af7a62b37b0?source=collection_archive---------3-----------------------#2018-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4dae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在当今世界，每个客户都面临着多种选择。例如，如果我想找一本书来读，但不知道我想要什么，我的搜索结果有很多种可能性。我可能会浪费很多时间在网上浏览，浏览各种网站，希望找到金子。我可能会寻求其他人的推荐。</p><p id="891e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果有一个网站或应用程序可以根据我以前读过的内容向我推荐书籍，那将是一个巨大的帮助。与其在各种网站上浪费时间，我可以直接登录，瞧！10本适合我口味的推荐书籍。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/a0cf26df0ad4d9df0c29d7323266b225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*eSxOD9E4m6iipJsg.jpg"/></div></figure><p id="c9bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是推荐引擎所做的事情，如今大多数企业都在利用它们的力量。从亚马逊到网飞，从谷歌到Goodreads，推荐引擎是机器学习技术最广泛使用的应用之一。</p><p id="7bfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将介绍各种类型的推荐引擎算法以及用Python创建它们的基础知识。我们还将看到这些算法背后的数学原理。最后，我们将使用矩阵分解创建我们自己的推荐引擎。</p><h1 id="8ee5" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">目录</h1><ol class=""><li id="5fe3" class="kj kk hi ih b ii kl im km iq kn iu ko iy kp jc kq kr ks kt bi translated">什么是推荐引擎？</li><li id="58fc" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">推荐引擎是如何工作的？<br/> 2.1数据收集<br/> 2.2数据存储<br/> 2.3数据过滤<br/> 2.3.1基于内容的过滤<br/> 2.3.2协同过滤</li><li id="933d" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">使用MovieLens数据集的Python案例研究</li><li id="0070" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">从头开始构建协同过滤模型</li><li id="a8cd" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">使用Turicreate构建简单的流行度和协同过滤模型</li><li id="6d48" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">矩阵分解导论</li><li id="120a" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">使用矩阵分解构建推荐引擎</li><li id="579f" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">推荐引擎的评估指标<br/> 8.1召回率<br/> 8.2精确度<br/> 8.3 RMSE(均方根误差)<br/> 8.4平均倒数排名<br/>8.5k处的MAP(截止k处的平均精确度)<br/> 8.6 NDCG(归一化的折扣累积增益)</li><li id="13a8" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">还有什么可以尝试的？</li></ol><h1 id="2312" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">1.什么是推荐引擎？</h1><p id="2cf7" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">直到最近，人们通常倾向于购买朋友或信任的人推荐给他们的产品。这曾经是对产品有任何疑问时的主要购买方法。但随着数字时代的到来，这个圈子已经扩大到包括利用某种推荐引擎的在线网站。</p><p id="f796" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">推荐引擎使用不同的算法过滤数据，并向用户推荐最相关的项目。它首先捕捉客户过去的行为，并在此基础上推荐用户可能会购买的产品。</strong></p><p id="128e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个全新的用户访问一个电子商务网站，该网站将不会有该用户的任何过去的历史。那么在这种情况下，网站如何向用户推荐产品呢？一种可能的解决方案是推荐最畅销的产品，即需求量大的产品。另一个可能的解决方案是推荐能给企业带来最大利润的产品。</p><p id="64da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们能够根据客户的需求和兴趣向他们推荐一些商品，这将对用户体验产生积极的影响，并导致频繁的访问。因此，现在的企业正在通过研究用户过去的行为来构建智能的推荐引擎。</p><p id="4e66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们对推荐引擎有了一个直觉，现在让我们看看它们是如何工作的。</p><h1 id="e4cb" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">2.推荐引擎是如何工作的？</h1><p id="bd27" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在我们深入探讨这个主题之前，首先我们要考虑如何向用户推荐商品:</p><ul class=""><li id="e5c1" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">我们可以向用户推荐在所有用户中最受欢迎的项目</li><li id="3957" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">我们可以根据用户的偏好(用户特征)将他们分成多个细分市场，并根据他们所属的细分市场向他们推荐商品</li></ul><p id="cb0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上两种方法都有缺点。在第一种情况下，最受欢迎的商品对每个用户来说都是一样的，所以每个人都会看到相同的推荐。而在第二种情况下，随着用户数量的增加，功能的数量也会增加。因此，将用户分为不同的类别将是一项非常困难的任务。</p><p id="35f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的主要问题是，我们无法根据用户的特定兴趣来定制推荐。这就像亚马逊建议你买一台笔记本电脑，仅仅因为它已经被大多数购物者购买了。但谢天谢地，亚马逊(或任何其他大公司)不推荐使用上述方法的产品。他们使用一些个性化的方法，帮助他们更准确地推荐产品。</p><p id="410d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们通过以下步骤来关注推荐引擎是如何工作的。</p><h1 id="f3b0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">2.1数据收集</h1><p id="89dc" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这是构建推荐引擎的第一步，也是最关键的一步。数据可以通过两种方式收集:显式和隐式。显式数据是有意提供的信息，即来自用户的输入，如电影评级。隐含数据是无意提供的信息，而是从搜索历史、点击、订单历史等可用数据流中收集的信息。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lg"><img src="../Images/08a1546a8a48087bb7d76b9420e92729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/0*dL-HzmxIsJXpJvwX.png"/></div></figure><p id="e984" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，网飞以用户给不同电影评分的形式收集数据。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/5b2f047071166c5b239dba65692ae2cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_7cY4rfHs-LfkNrI.jpg"/></div></div></figure><p id="4829" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，用户的订单历史由Amazon记录，这是隐式数据收集模式的一个例子。</p><h1 id="eb84" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">2.2数据存储</h1><p id="aab1" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">数据量决定了模型的推荐结果有多好。例如，在电影推荐系统中，用户给电影的评级越多，其他用户得到的推荐就越好。数据类型在决定必须使用的存储类型时起着重要作用。这种类型的存储可以包括标准SQL数据库、NoSQL数据库或某种对象存储。</p><h1 id="bd22" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">2.3过滤数据</h1><p id="e793" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在收集和存储数据之后，我们必须对其进行过滤，以便提取做出最终建议所需的相关信息。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lm"><img src="../Images/ba9dc3acbcf19920915c4311a97c4917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zeFTZ98pqqGgilKK.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">来源:<em class="lr"> intheshortestrun </em></figcaption></figure><p id="16be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有各种算法可以帮助我们简化过滤过程。在下一节中，我们将详细介绍每个算法。</p><h2 id="64d9" class="ls jm hi bd jn lt lu lv jr lw lx ly jv iq lz ma jz iu mb mc kd iy md me kh mf bi translated">基于内容的过滤</h2><p id="5dee" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">该算法推荐与用户过去喜欢的产品相似的产品。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mg"><img src="../Images/d5bebaa4b7d751e43ab2c61c56d8a95b.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*KQefyiDb5l24iEra.png"/></div></figure><p id="6853" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果一个人喜欢电影“盗梦空间”，那么这个算法将推荐属于同一流派的电影。但是算法如何理解从哪个流派中挑选和推荐电影呢？</p><p id="cfeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">以网飞为例。</strong>他们以向量的形式保存了与每个用户相关的所有信息。该向量包含用户过去的行为，即用户喜欢/不喜欢的电影以及他们给出的评级。这个矢量被称为<em class="mh">轮廓矢量</em>。所有与电影相关的信息都存储在另一个名为<em class="mh">项目向量</em>的向量中。Item vector包含每部电影的详细信息，如流派、演员、导演等。</p><p id="43f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于内容的过滤算法找到轮廓向量和项目向量之间角度的余弦，即<strong class="ih hj">余弦相似度</strong>。假设A是简档向量，B是项目向量，那么它们之间的相似度可以计算为:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mi"><img src="../Images/0d1665d6c5719e36e84cfe94bb978659.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/0*GqeoAXVvNFq9P0NQ.png"/></div></div></figure><p id="c2ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于范围在-1到1之间的余弦值，电影以降序排列，并且使用以下两种方法之一进行推荐:</p><ul class=""><li id="d12f" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated"><strong class="ih hj"> Top-n方法</strong>:推荐前n部电影(这里n可以由企业决定)</li><li id="2110" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated"><strong class="ih hj">分级方法</strong>:设定一个阈值，推荐所有高于该阈值的电影</li></ul><p id="82ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可用于计算相似性的其他方法有:</p><ul class=""><li id="4e91" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated"><strong class="ih hj">欧几里德距离</strong>:如果在n维空间中绘图，相似的项目将彼此非常接近。因此，我们可以计算商品之间的距离，并基于该距离向用户推荐商品。欧几里德距离的公式由下式给出:</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mj"><img src="../Images/085a2e761de8b95babac2580c141a00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*sEHCvkpeAez3oZGR.png"/></div></figure><ul class=""><li id="a5f0" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">皮尔逊相关:它告诉我们两个项目的相关程度。相关性越高，相似性就越大。皮尔逊相关性可以使用以下公式计算:</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mk"><img src="../Images/9647267f92430f6bd6aac79ed920e42c.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/0*tfwCpdIDguzZPnTE.png"/></div></figure><p id="c41b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种算法的一个主要缺点是它仅限于推荐相同类型的项目。它永远不会推荐用户过去没有买过或不喜欢的产品。因此，如果用户过去只看过或喜欢动作片，系统将只推荐动作片。这是一种非常狭隘的制造引擎的方式。</p><p id="c229" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了改进这种类型的系统，我们需要一种算法，不仅可以根据内容推荐项目，还可以根据用户的行为推荐项目。</p><h2 id="b744" class="ls jm hi bd jn lt lu lv jr lw lx ly jv iq lz ma jz iu mb mc kd iy md me kh mf bi translated">协同过滤</h2><p id="69e6" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">让我们用一个例子来理解这一点。如果A喜欢三部电影，比如《星际穿越》、《盗梦空间》和《缘分天注定》，而B喜欢《盗梦空间》、《缘分天注定》和《声望》，那么他们有几乎相似的兴趣。我们可以有把握地说，A应该喜欢声望，B应该喜欢星际。协同过滤算法使用“用户行为”来推荐项目。这是业内最常用的算法之一，因为它不依赖于任何附加信息。有不同类型的协作过滤技术，我们将在下面详细介绍它们。</p><h2 id="6a42" class="ls jm hi bd jn lt lu lv jr lw lx ly jv iq lz ma jz iu mb mc kd iy md me kh mf bi translated">用户-用户协同过滤</h2><p id="094e" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这个算法首先找到用户之间的相似性得分。基于这个相似性得分，它挑选出最相似的用户，并推荐这些相似用户以前喜欢或购买过的产品。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/216db8218a30d2adef496de2dfcadab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R5ibrSicakT4l-rb.png"/></div></div></figure><p id="feba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就我们之前的电影示例而言，该算法根据每个用户之前对不同电影的评分来查找他们之间的相似性。通过计算其他用户对项目<em class="mh"> i </em>给出的用户评分的加权和来计算用户对项目<em class="mh"> u </em>的预测。</p><p id="3996" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预测值<em class="mh"> Pu，i </em>由下式给出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ml"><img src="../Images/da0663e8eb8d4b4c7f5dcdb59082f457.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/0*zXJMyENnlCZPoqbJ.png"/></div></figure><p id="ac49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，</p><ul class=""><li id="45e4" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated"><em class="mh"> Pu，i </em>是对某项的预测</li><li id="1c1d" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated"><em class="mh"> Rv，i </em>是用户<em class="mh"> v </em>对电影<em class="mh"> i </em>的评价</li><li id="c394" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated"><em class="mh">苏，v </em>是用户之间的相似度</li></ul><p id="0b35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们有了用户在profile vector中的评分，基于此，我们必须预测其他用户的评分。为此，遵循以下步骤:</p><ol class=""><li id="4e14" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc kq kr ks kt bi translated">对于预测，我们需要用户u和v之间的相似性。我们可以利用皮尔逊相关。</li><li id="a81f" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">首先，我们找到由用户评级的项目，并且基于评级，计算用户之间的相关性。</li><li id="ffd3" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">可以使用相似性值来计算预测。该算法首先计算每个用户之间的相似性，然后基于每个相似性计算预测。<strong class="ih hj">相关性较高的用户倾向于相似。</strong></li><li id="0343" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">基于这些预测值，提出建议。让我们用一个例子来理解它:</li></ol><p id="b63e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑用户-电影评级矩阵:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mm"><img src="../Images/1d2f9d73149fcae293ec2255c57c6308.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*UrB_nu4gvJINWnEO4sxBQQ.png"/></div></figure><p id="e75d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们有一个用户电影评级矩阵。为了更实际地理解这一点，让我们找出上表中用户(A，C)和(B，C)之间的相似性。由A和C评级的常见电影是电影x2和x4，由B和C评级的常见电影是电影x2、x4和x5。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mn"><img src="../Images/6b87deee92dd7599097c7190b6e0cde6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6Y7tpaLDpRj-H8i8.png"/></div></div></figure><p id="1e26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用户A和C之间的相关性大于用户B和C之间的相关性。因此，用户A和C具有更多的相似性，并且用户A喜欢的电影将被推荐给用户C，反之亦然。</p><p id="0ace" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法非常耗时，因为它涉及计算每个用户的相似性，然后计算每个相似性得分的预测。处理这个问题的一种方式是仅选择几个用户(邻居)而不是所有用户来进行预测，即，不是对所有相似性值进行预测，而是仅选择几个相似性值。选择邻居有多种方式:</p><ul class=""><li id="1022" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">选择一个阈值相似性，并选择高于该值的所有用户</li><li id="3118" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">随机选择用户</li><li id="2acb" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">按照相似性值的降序排列邻居，并选择前N名用户</li><li id="be27" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">使用聚类选择邻居</li></ul><p id="d44d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当用户数量较少时，该算法是有用的。当有大量用户时，这是无效的，因为计算所有用户对之间的相似性将花费大量时间。这就引出了项目-项目协同过滤，当用户数量多于被推荐的项目时，这种方式是有效的。</p><h2 id="c685" class="ls jm hi bd jn lt lu lv jr lw lx ly jv iq lz ma jz iu mb mc kd iy md me kh mf bi translated">项目-项目协同过滤</h2><p id="b1c4" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在这个算法中，我们计算每对项目之间的相似度。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mo"><img src="../Images/8dd2a72632b44c6bd4589691e6dfc6f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JHZRSLPs4EvIMuwX.png"/></div></div></figure><p id="e656" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在我们的例子中，我们将找到每对电影之间的相似性，并基于此，我们将推荐用户过去喜欢的相似电影。这种算法的工作原理类似于用户-用户协同过滤，只是有一点点变化——我们不是采用“用户-邻居”评级的加权和，而是采用“项目-邻居”评级的加权和。预测由下式给出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mp"><img src="../Images/7f4948a48dfd7c0ba9b6b9063bc5719e.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/0*JcBmyn9NUxnpX9Pe.png"/></div></figure><p id="f70c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将找到项目之间的相似性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mq"><img src="../Images/b7f528c8c78ea516e6b6f78647a4a21d.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/0*vIqDCVHkc1vVQpq9.png"/></div></figure><p id="d9bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，因为我们有了每部电影和分级之间的相似性，所以进行预测，并且基于这些预测，推荐相似的电影。让我们用一个例子来理解一下。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mr"><img src="../Images/8c589795b7d61e308e356cf2a3b41106.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*p192Eqx2WFm3oTHbNebRfQ.png"/></div></figure><p id="f2f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，平均项目评分是对特定项目的所有评分的平均值(与我们在用户-用户过滤中看到的表格进行比较)。我们不是像前面看到的那样找到用户之间的相似性，而是找到项目之间的相似性。</p><p id="343c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要做到这一点，首先我们需要找到对这些项目进行评级的用户，并根据评级计算项目之间的相似性。让我们找到电影(x1，x4)和(x1，x5)的相似之处。评价了电影x1和x4的普通用户是A和B，而评价了电影x1和x5的用户也是A和B</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ms"><img src="../Images/a2b490fd16e5beacb15dac26ead89418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/0*-D8c1qnLdICRZrHy.png"/></div></figure><p id="2c52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">电影x1和x4之间的相似性大于电影x1和x5之间的相似性。因此，基于这些相似性值，如果任何用户搜索电影x1，他们将被推荐电影x4，反之亦然。在进一步实施这些概念之前，有一个问题我们必须知道答案——如果在数据集中添加一个新用户或新项目，会发生什么情况？它被称为冷启动。冷启动有两种类型:</p><ol class=""><li id="0b6b" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc kq kr ks kt bi translated">访客冷启动</li><li id="ebeb" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">产品冷启动</li></ol><p id="f883" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">访问者冷启动意味着在数据集中引入了一个新用户。因为没有该用户的历史，所以系统不知道该用户的偏好。向该用户推荐产品变得更加困难。那么，如何才能解决这个问题呢？一个基本的方法可以是应用基于流行度的策略，即推荐最流行的产品。这些可以由最近流行的整体或区域来决定。一旦我们知道了用户的喜好，推荐产品就容易多了。</p><p id="b564" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，产品冷启动意味着一种新产品投放市场或加入系统。用户行为是决定任何产品价值的最重要因素。产品收到的交互越多，我们的模型就越容易向正确的用户推荐该产品。我们可以利用基于内容的过滤来解决这个问题。系统首先使用新产品的内容进行推荐，然后最终用户对该产品采取行动。</p><p id="7044" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们通过Python中的一个案例来巩固我们对这些概念的理解。准备好你的机器，因为这将会很有趣！</p><h1 id="b1e2" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">3.使用MovieLens数据集的Python案例研究</h1><p id="de26" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们将处理MovieLens数据集，并构建一个模型来向最终用户推荐电影。这些数据是由明尼苏达大学的GroupLens研究项目收集的。数据集可以从<a class="ae mt" href="https://grouplens.org/datasets/movielens/100k/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这里</strong> </a>下载。该数据集包括:</p><ul class=""><li id="b19e" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">1682部电影的943位用户给出了100，000个评分(1-5)</li><li id="ff05" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">用户的人口统计信息(年龄、性别、职业等。)</li></ul><p id="c81e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将导入我们的标准库并读取Python中的数据集。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="aff4" class="ls jm hi mv b fi mz na l nb nc">import pandas as pd<br/>%matplotlib inline<br/>import matplotlib<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="80b0" class="ls jm hi mv b fi nd na l nb nc"># pass in column names for each CSV as the column name is not given in the file and read them using pandas.<br/># You can check the column names from the readme file<br/><br/>#Reading users file:<br/>u_cols = ['user_id', 'age', 'sex', 'occupation', 'zip_code']<br/>users = pd.read_csv('ml-100k/u.user', sep='|', names=u_cols,encoding='latin-1')<br/><br/>#Reading ratings file:<br/>r_cols = ['user_id', 'movie_id', 'rating', 'unix_timestamp']<br/>ratings = pd.read_csv('ml-100k/u.data', sep='\t', names=r_cols,encoding='latin-1')<br/><br/>#Reading items file:<br/>i_cols = ['movie id', 'movie title' ,'release date','video release date', 'IMDb URL', 'unknown', 'Action', 'Adventure',<br/>'Animation', 'Children\'s', 'Comedy', 'Crime', 'Documentary', 'Drama', 'Fantasy',<br/>'Film-Noir', 'Horror', 'Musical', 'Mystery', 'Romance', 'Sci-Fi', 'Thriller', 'War', 'Western']<br/>items = pd.read_csv('ml-100k/u.item', sep='|', names=i_cols,<br/>encoding='latin-1')</span></pre><p id="0da2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加载数据集后，我们应该查看每个文件的内容(用户、评分、项目)。</p><p id="a12e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用户</strong></p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="6c25" class="ls jm hi mv b fi mz na l nb nc">print(users.shape) <br/>users.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ne"><img src="../Images/45cfed66b11f280667aa8466744d472a.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*BxTn4YuY9tN0QMQbTqqxZA.png"/></div></figure><p id="e125" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们在数据集中有943个用户，每个用户有5个特征，即用户ID、年龄、性别、职业和邮政编码。现在让我们来看看评级文件。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="2458" class="ls jm hi mv b fi mz na l nb nc">print(ratings.shape)<br/>ratings.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nf"><img src="../Images/b55d9313c3f50bb11bc6a32fd35a6dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*1DYuYEOMKulAsFsIyryYhw.png"/></div></figure><p id="a865" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对不同的用户和电影组合有100k的评分。现在，最后检查项目文件。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="d57c" class="ls jm hi mv b fi mz na l nb nc">print(items.shape) <br/>items.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ng"><img src="../Images/56dd1dcca7175e47c8ee805c9edbc2e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*xolyP-Ok8h9DOdSutCmWiw.png"/></div></figure><p id="df9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该数据集包含1682部电影的属性。有24列，其中最后19列指定特定电影的类型。这些是二进制列，即值1表示电影属于该类型，否则为0。</p><p id="4044" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该数据集已经被GroupLens分成训练和测试，其中测试数据对于每个用户具有10个评级，即总共9，430行。我们将把这两个文件读入我们的Python环境。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="b547" class="ls jm hi mv b fi mz na l nb nc">r_cols = ['user_id', 'movie_id', 'rating', 'unix_timestamp']<br/>ratings_train = pd.read_csv('ml-100k/ua.base', sep='\t', names=r_cols, encoding='latin-1')<br/>ratings_test = pd.read_csv('ml-100k/ua.test', sep='\t', names=r_cols, encoding='latin-1')<br/>ratings_train.shape, ratings_test.shape</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nh"><img src="../Images/66074781e5d54ba63a63bbadcb4b070b.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/0*Xr1nghIWMOvUzw6S.png"/></div></figure><p id="7308" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">终于到了构建我们推荐引擎的时候了！</p><h1 id="4a1a" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">4.从头开始构建协同过滤模型</h1><p id="5564" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们将根据用户-用户相似性和项目-项目相似性来推荐电影。为此，首先我们需要计算独立用户和电影的数量。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="9265" class="ls jm hi mv b fi mz na l nb nc">n_users = ratings.user_id.unique().shape[0] <br/>n_items = ratings.movie_id.unique().shape[0]</span></pre><p id="9add" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将创建一个用户-项目矩阵，它可用于计算用户和项目之间的相似性。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="8bc2" class="ls jm hi mv b fi mz na l nb nc">data_matrix = np.zeros((n_users, n_items)) <br/>for line in ratings.itertuples(): <br/>    data_matrix[line[1]-1, line[2]-1] = line[3]</span></pre><p id="4641" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将计算相似度。我们可以使用来自<em class="mh"> sklearn </em>的<em class="mh"> pairwise_distance </em>函数来计算余弦相似度。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="4f4e" class="ls jm hi mv b fi mz na l nb nc">from sklearn.metrics.pairwise import pairwise_distances user_similarity = pairwise_distances(data_matrix, metric='cosine') item_similarity = pairwise_distances(data_matrix.T, metric='cosine')</span></pre><p id="89cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这为我们提供了一个数组形式的项目-项目和用户-用户相似性。下一步是根据这些相似性进行预测。让我们定义一个函数来做这件事。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="10e2" class="ls jm hi mv b fi mz na l nb nc">def predict(ratings, similarity, type='user'):<br/>    if type == 'user':<br/>        mean_user_rating = ratings.mean(axis=1)<br/>        #We use np.newaxis so that mean_user_rating has same format as ratings<br/>        ratings_diff = (ratings - mean_user_rating[:, np.newaxis])<br/>        pred = mean_user_rating[:, np.newaxis] + similarity.dot(ratings_diff) / np.array([np.abs(similarity).sum(axis=1)]).T<br/>    elif type == 'item':<br/>        pred = ratings.dot(similarity) / np.array([np.abs(similarity).sum(axis=1)])<br/>    return pred</span></pre><p id="78c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们会根据用户相似度和物品相似度进行预测。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="7bd9" class="ls jm hi mv b fi mz na l nb nc">user_prediction = predict(data_matrix, user_similarity, type='user') <br/>item_prediction = predict(data_matrix, item_similarity, type='item')</span></pre><p id="0568" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实证明，我们也有一个自动生成所有这些推荐的库。现在让我们学习如何使用Python中的turicreate创建推荐引擎。要熟悉turicreate并将其安装到您的机器上，请参考此处的<a class="ae mt" href="https://github.com/apple/turicreate/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">。</strong></a></p><h1 id="c798" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">5.使用Turicreate构建一个简单的流行度和协同过滤模型</h1><p id="f313" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">安装turicreate后，首先让我们导入它，并在我们的环境中读取训练和测试数据集。由于我们将使用turicreate，我们将需要在SFrames中转换数据集。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="11c5" class="ls jm hi mv b fi mz na l nb nc">import turicreate <br/>train_data = turicreate.SFrame(ratings_train) <br/>test_data = turicreate.Sframe(ratings_test)</span></pre><p id="baaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有用户行为以及用户和电影的属性，所以我们可以制作基于内容以及协同过滤的算法。我们将从一个简单的流行度模型开始，然后建立一个协同过滤模型。</p><p id="add7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将构建一个基于最受欢迎的选择推荐电影的模型，即，所有用户都收到相同推荐的模型。为此，我们将使用turicreate推荐函数<em class="mh"> popularity_recommender </em>。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="cb13" class="ls jm hi mv b fi mz na l nb nc">popularity_model = turicreate.popularity_recommender.create(train_data, user_id='user_id', item_id='movie_id', target='rating')</span></pre><p id="901e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用的各种论据是:</p><ul class=""><li id="03e1" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated"><strong class="ih hj"> train_data </strong>:包含所需训练数据的SFrame</li><li id="1ac2" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated"><strong class="ih hj"> user_id </strong>:表示每个用户id的列名</li><li id="64ed" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated"><strong class="ih hj"> item_id </strong>:表示每个推荐项目的列名(movie_id)</li><li id="8d0e" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated"><strong class="ih hj">目标:</strong>表示用户给出的分数/评级的列名</li></ul><p id="4dff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预测时间到了！我们将为数据集中的前5个用户推荐前5个项目。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="64d7" class="ls jm hi mv b fi mz na l nb nc">popularity_recomm = popularity_model.recommend(users=[1,2,3,4,5],k=5) popularity_recomm.print_rows(num_rows=25)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ni"><img src="../Images/13ed6b47f2c535e0c159b10408dcfd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*dptkAQNxRs6C9eQo_i9xOQ.png"/></div></figure><p id="6ac1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，对所有用户的建议都是相同的— 1467、1201、1189、1122、814。而且都是一个顺序！这证实了所有推荐的电影具有5的平均评级，即所有观看该电影的用户给了它最高的评级。因此，我们的人气系统如预期的那样工作。</p><p id="18de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在构建了流行度模型之后，我们现在将构建协作过滤模型。我们来训练一下物品相似度模型，给前5个用户做前5个推荐。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="9c37" class="ls jm hi mv b fi mz na l nb nc">#Training the model<br/>item_sim_model = turicreate.item_similarity_recommender.create(train_data, user_id='user_id', item_id='movie_id', target='rating', similarity_type='cosine')<br/><br/>#Making recommendations<br/>item_sim_recomm = item_sim_model.recommend(users=[1,2,3,4,5],k=5)<br/>item_sim_recomm.print_rows(num_rows=25)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nj"><img src="../Images/bdfea7bb092feb992cc73cc8add7cbb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*onFKsgdIiUjmNF9QFrowAg.png"/></div></figure><p id="34fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们可以看到推荐(movie_id)对于每个用户都是不同的。所以个性化是存在的，也就是说，对于不同的用户，我们有不同的建议。</p><p id="1008" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个模型中，我们没有每个用户对每部电影的评级。我们必须找到一种方法来预测所有这些缺失的评级。为此，我们必须找到一套能够定义用户如何评价电影的特征。这些被称为潜在特征。我们需要找到一种方法，从现有的特征中提取出最重要的潜在特征。下一节将介绍矩阵分解，这是一种使用低维密集矩阵的技术，有助于提取重要的潜在特征。</p><h1 id="0af7" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">6.矩阵分解导论</h1><p id="8047" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们用一个例子来理解矩阵分解。考虑不同用户对不同电影给出的用户电影评级矩阵(1-5)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nk"><img src="../Images/ee3d8a374ce4e833f0c94c276c3f7a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/0*5ipmsNAhtqrrPmb4.png"/></div></figure><p id="1579" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里user_id是不同用户的唯一id，并且每个电影也被分配一个唯一ID。0.0的评级表示用户没有对该特定电影进行评级(1是用户可以给出的最低评级)。我们想预测这些缺失的收视率。使用矩阵分解，我们可以找到一些潜在的特征，这些特征可以决定用户如何评价一部电影。我们将矩阵分解成组成部分，使得这些部分的乘积生成原始矩阵。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/096252f01570fd0e3fefd71d970a00be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XPAFw6JsodBNzNc9.png"/></div></div></figure><p id="525b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设我们已经找到了<em class="mh"> k </em>的潜在特征。因此，我们可以将评级矩阵R(MxN)分为P(MxK)和Q(NxK ),从而P x QT(这里QT是Q矩阵的转置)近似于R矩阵:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nl"><img src="../Images/d8f7575edb281466fda936f127cef7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:144/format:webp/0*Yo5tcG8kBD8wNokb.png"/></div></figure><p id="aff2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中:</p><ul class=""><li id="e8e5" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">m是用户总数</li><li id="724d" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">n是电影的总数</li><li id="2626" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">k是总潜在特征</li><li id="0948" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">r是MxN用户-电影分级矩阵</li><li id="5744" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">p是代表用户和特征之间关联的MxK用户-特征亲和矩阵</li><li id="9ccd" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">q是NxK项目-特征相关矩阵，其表示电影和特征之间的关联</li><li id="d327" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">σ是KxK对角特征权重矩阵，它表示特征的本质权重</li></ul><p id="7196" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过矩阵分解选择潜在特征从数据中去除了噪声。怎么会？嗯，它删除了不决定用户如何评价电影的特征。现在，为了获得由用户<em class="mh"> puk </em>在所有潜在特征<em class="mh"> k </em>上对电影<em class="mh"> qik </em>的评级<em class="mh">芮</em>，我们可以计算2个向量的点积，并将它们相加，以获得基于所有潜在特征的评级。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nm"><img src="../Images/9a4877eb8f6e3a74e78b5d78bf3dd1c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/0*BkQmE3FktEM-Mbby.png"/></div></figure><p id="ec8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是矩阵分解如何给我们没有被用户评级的电影的评级。但是，我们如何将新数据添加到我们的用户电影评级矩阵中，即，如果新用户加入并对电影进行评级，我们将如何将这些数据添加到我们预先存在的矩阵中？</p><p id="551d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我通过矩阵分解的方法让你更容易理解。如果新用户加入系统，对角特征权重矩阵σ以及项目-特征相关性矩阵q将没有变化。唯一的变化将发生在用户-特征相关度矩阵p中。我们可以应用一些矩阵乘法方法来做到这一点。</p><p id="2249" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有，</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nl"><img src="../Images/1bcc118de47d2263a454fc65d8a3af34.png" data-original-src="https://miro.medium.com/v2/resize:fit:144/format:webp/0*45eKlXTfB63n13nT.png"/></div></figure><p id="03e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们两边都乘以Q。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nn"><img src="../Images/fd1dd314fbc40909110213e2e70cfa92.png" data-original-src="https://miro.medium.com/v2/resize:fit:186/format:webp/0*cxG5zTswf4Lftxtv.png"/></div></figure><p id="6644" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们有了</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es no"><img src="../Images/71738293fff850a68f88edb6880e660f.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/format:webp/0*BQcoU2YG4X84cV-B.png"/></div></figure><p id="f6cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es no"><img src="../Images/3dee1600b802ffb6af9d83bb0aa547b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/format:webp/0*51B39dAdAkcp1yzO.png"/></div></figure><p id="8b6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进一步简化，我们可以得到P矩阵:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nl"><img src="../Images/6b649bcd791ff3b3b517fd7abf5e5f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:144/format:webp/0*v8cI_cwtc7DSiZrP.png"/></div></figure><p id="20a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是更新的用户特征相似性矩阵。类似地，如果新电影被添加到系统中，我们可以按照类似的步骤来获得更新的项目-特征相关性矩阵q。</p><p id="2606" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住，我们把R矩阵分解成P和Q。但是我们如何决定哪个P和Q矩阵将近似R矩阵呢？为此，我们可以使用梯度下降算法。这里的目标是最小化实际额定值与使用P和q估计的值之间的平方误差，平方误差由下式给出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es np"><img src="../Images/c52e9efcfc03afee6261c9192a85c806.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/0*p-qp7s1NujNQthLv.png"/></div></figure><p id="dbc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，</p><ul class=""><li id="6358" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated"><em class="mh"> eui </em>是误差</li><li id="c614" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated"><em class="mh">锐</em>是用户u对电影I的实际评价</li><li id="6167" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated"><em class="mh"> řui </em>是用户u对电影I的预测评级</li></ul><p id="759c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的目的是确定p和q值，使误差最小。我们需要更新p和q值，以便得到这些矩阵的最佳值，这将给出最小的误差。现在我们将为<em class="mh"> puk </em>和<em class="mh"> qki </em>定义一个更新规则。梯度下降中的更新规则由要最小化的误差的梯度来定义。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nq"><img src="../Images/d5e58a651b3b2e777b8fd51cbfa99e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/0*ek6QGQR1vb8LddqY.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nr"><img src="../Images/5f1579b7da40ee238ae2ca54c8104754.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/0*2wm_9n1B1lSEH6CF.png"/></div></figure><p id="47a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了梯度，我们可以对<em class="mh"> puk </em>和<em class="mh"> qki </em>应用更新规则。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ns"><img src="../Images/560b4f7e8b6e52f58970708eeb323910.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/0*Lu_nd-eJ-58bvE98.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nt"><img src="../Images/9bedad14d557c333de4789494ed9c488.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/0*tGyJ23MA40MrN937.png"/></div></figure><p id="1642" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里α是学习率，它决定每次更新的大小。可以重复上述更新，直到误差最小。一旦完成，我们就可以得到最佳的P和Q矩阵，它可以用来预测收视率。让我们快速回顾一下这个算法是如何工作的，然后我们将构建推荐引擎来预测未分级电影的分级。</p><p id="2f2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是矩阵分解如何预测评分:</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="d18c" class="ls jm hi mv b fi mz na l nb nc"># for f = 1,2,....,k :<br/>    # for rui ε R :<br/>        # predict rui<br/>        # update puk and qki</span></pre><p id="d595" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，基于每个潜在特征，R矩阵中所有缺失的评级将使用预测的<em class="mh"> rui </em>值来填充。然后使用梯度下降更新<em class="mh"> puk </em>和<em class="mh"> qki </em>并获得它们的最优值。如下图所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nu"><img src="../Images/e4cfe337642e1b7a32b53c57952c85d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/0*TiMXtMJN-ogXRUZB.png"/></div></figure><p id="ce87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经理解了这个算法的内部工作原理，我们将举一个例子，看看一个矩阵是如何分解成它的成分的。</p><p id="7961" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑一个2×3的矩阵，一个2×3的T21，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nv"><img src="../Images/1690ff144cbd4656a8ca3e86533d9647.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/0*q_hXppc_VOAUKbsw.png"/></div></figure><p id="d999" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们有2个用户和他们对3部电影的相应评级。现在，我们将把这个矩阵分解成子部分，例如:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nw"><img src="../Images/da46fefdd4e0864c26d972aa8008ffbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/0*ebDIKXA4nWjcBdpq.png"/></div></figure><p id="22f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AAT的特征值将给出P矩阵，而ATA的特征值将给出Q矩阵。σ是AAT或ATA的特征值的平方根。</p><p id="a054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算AAT的特征值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nx"><img src="../Images/425aa4c0765bf01c8a04087c4c9b6a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/0*-uvA0u1YxCjFF_tQ.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ny"><img src="../Images/f6cef6918b9c268d760124127fc1959c.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/0*n_uZLRmPK080yfaK.png"/></div></figure><p id="8ba5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以AAT的特征值是25，9。同样，我们可以计算ATA的特征值。这些值将是25，9，0。现在我们必须计算AAT和ATA对应的特征向量。</p><p id="9cb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于λ = 25，我们有:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nz"><img src="../Images/f2ff9769200e22d05e5678fb8c128b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/0*wLLOkAsVjPFsN3Bt.png"/></div></figure><p id="edb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以将<a class="ae mt" href="http://www.sparknotes.com/math/algebra2/matrices/section4/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">行的</strong>缩减为</a>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es oa"><img src="../Images/04f40cce2b01a4f6d0daec4a26b7f83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/0*IciYZHHHsk_Ed2_8.png"/></div></figure><p id="c1af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该矩阵的核中的单位长度向量为:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nn"><img src="../Images/d7aabe5e1d3e568b8c05236620108570.png" data-original-src="https://miro.medium.com/v2/resize:fit:186/format:webp/0*R-T7P5f70eqOCmsO.png"/></div></figure><p id="e68f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，对于λ = 9，我们有:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ob"><img src="../Images/fea3f3719dac59ce484845100d8e6903.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/0*s3GAdNeHkmugn6ST.png"/></div></figure><p id="2eb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以将行简化为:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es oc"><img src="../Images/70fdc290f168b2cd3692dd4c8b48ed8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:248/format:webp/0*-cKpi8wZD8pRFNjP.png"/></div></figure><p id="d874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该矩阵的核中的单位长度向量为:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es od"><img src="../Images/a54837451963f7e8fed1419fd53f8bab.png" data-original-src="https://miro.medium.com/v2/resize:fit:188/format:webp/0*zXtBvlYjrkvzb0TV.png"/></div></figure><p id="ffb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于最后一个特征向量，我们可以找到一个垂直于q1和q2的单位向量。所以，</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nn"><img src="../Images/66fec4a7e4fa7ceddb3c1c99c3ac0de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:186/format:webp/0*LGIIoTrxBe88HaUJ.png"/></div></figure><p id="148d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">σ</strong>T6】2x 3矩阵是AAT或ATA的特征值的平方根，即25和9。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es oe"><img src="../Images/9697c27852b2ce02750221895b4a40ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/0*xo2RYBnPxJV9c34P.png"/></div></figure><p id="a7aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后我们可以通过公式σpi = Aqi，或者pi = 1/σ(Aqi)来计算P <em class="mh"> 2X2 </em>。这给出了:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es of"><img src="../Images/fcb7d179d07caff701f37bab0f9ea4b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/0*Sx5TZemGypuKcCS1.png"/></div></figure><p id="fd52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，矩阵的分解形式由下式给出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mk"><img src="../Images/356f5fa3df12632d3951988a1b183655.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*xvTRMMY3e5JK-uf-KMWvrw.png"/></div></figure><p id="a689" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们有P和Q矩阵，我们可以使用梯度下降法来获得它们的优化版本。让我们使用矩阵分解来构建我们的推荐引擎。</p><h1 id="ba4a" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">7.使用矩阵分解构建推荐引擎</h1><p id="c8e2" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">让我们定义一个函数来预测用户对他/她没有评级的所有电影给出的评级。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="acef" class="ls jm hi mv b fi mz na l nb nc">class MF():<br/><br/>    # Initializing the user-movie rating matrix, no. of latent features, alpha and beta.<br/>    def __init__(self, R, K, alpha, beta, iterations):<br/>        self.R = R<br/>        self.num_users, self.num_items = R.shape<br/>        self.K = K<br/>        self.alpha = alpha<br/>        self.beta = beta<br/>        self.iterations = iterations<br/><br/>    # Initializing user-feature and movie-feature matrix <br/>    def train(self):<br/>        self.P = np.random.normal(scale=1./self.K, size=(self.num_users, self.K))<br/>        self.Q = np.random.normal(scale=1./self.K, size=(self.num_items, self.K))<br/><br/>        # Initializing the bias terms<br/>        self.b_u = np.zeros(self.num_users)<br/>        self.b_i = np.zeros(self.num_items)<br/>        self.b = np.mean(self.R[np.where(self.R != 0)])<br/><br/>        # List of training samples<br/>        self.samples = [<br/>        (i, j, self.R[i, j])<br/>        for i in range(self.num_users)<br/>        for j in range(self.num_items)<br/>        if self.R[i, j] &gt; 0<br/>        ]<br/><br/>        # Stochastic gradient descent for given number of iterations<br/>        training_process = []<br/>        for i in range(self.iterations):<br/>        np.random.shuffle(self.samples)<br/>        self.sgd()<br/>        mse = self.mse()<br/>        training_process.append((i, mse))<br/>        if (i+1) % 20 == 0:<br/>            print("Iteration: %d ; error = %.4f" % (i+1, mse))<br/><br/>        return training_process<br/><br/>    # Computing total mean squared error<br/>    def mse(self):<br/>        xs, ys = self.R.nonzero()<br/>        predicted = self.full_matrix()<br/>        error = 0<br/>        for x, y in zip(xs, ys):<br/>            error += pow(self.R[x, y] - predicted[x, y], 2)<br/>        return np.sqrt(error)<br/><br/>    # Stochastic gradient descent to get optimized P and Q matrix<br/>    def sgd(self):<br/>        for i, j, r in self.samples:<br/>            prediction = self.get_rating(i, j)<br/>            e = (r - prediction)<br/><br/>            self.b_u[i] += self.alpha * (e - self.beta * self.b_u[i])<br/>            self.b_i[j] += self.alpha * (e - self.beta * self.b_i[j])<br/><br/>            self.P[i, :] += self.alpha * (e * self.Q[j, :] - self.beta * self.P[i,:])<br/>            self.Q[j, :] += self.alpha * (e * self.P[i, :] - self.beta * self.Q[j,:])<br/><br/>    # Ratings for user i and moive j<br/>    def get_rating(self, i, j):<br/>        prediction = self.b + self.b_u[i] + self.b_i[j] + self.P[i, :].dot(self.Q[j, :].T)<br/>        return prediction<br/><br/>    # Full user-movie rating matrix<br/>    def full_matrix(self):<br/>        return mf.b + mf.b_u[:,np.newaxis] + mf.b_i[np.newaxis:,] + mf.P.dot(mf.Q.T)</span></pre><p id="6c10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了一个可以预测收视率的函数。该函数的输入是:</p><ul class=""><li id="f48e" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">r-用户电影评级矩阵</li><li id="e703" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">k个潜在特征</li><li id="8461" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">随机梯度下降的α学习率</li><li id="3578" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">偏差的β正则化参数</li><li id="8889" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">迭代次数-执行随机梯度下降的迭代次数</li></ul><p id="f033" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们必须将用户项目评级转换为矩阵形式。可以使用python中的pivot函数来完成。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="1afe" class="ls jm hi mv b fi mz na l nb nc">R= np.array(ratings.pivot(index = 'user_id', columns ='movie_id', values = 'rating').fillna(0))</span></pre><p id="4eef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">fillna(0)将用0填充所有缺失的评分。现在我们有了R矩阵。我们可以初始化潜在特征的数量，但是这些特征的数量必须小于或等于原始特征的数量。</p><p id="fce4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们预测所有缺失的评级。让我们假设K=20，alpha=0.001，beta=0.01，迭代次数=100。</p><pre class="je jf jg jh fd mu mv mw mx aw my bi"><span id="6349" class="ls jm hi mv b fi mz na l nb nc">mf = MF(R, K=20, alpha=0.001, beta=0.01, iterations=100)<br/>training_process = mf.train()<br/>print()<br/>print("P x Q:")<br/>print(mf.full_matrix())<br/>print()</span></pre><p id="8125" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将给出对应于每20次迭代的误差值，并最终给出完整的用户电影评级矩阵。输出如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es og"><img src="../Images/c773acc4a0cd0bbb396485f77076e9e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/0*64OhPwX_2yaesJxp.png"/></div></figure><p id="be8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经创建了我们的推荐引擎。让我们在下一节重点讨论如何评估一个推荐引擎。</p><h1 id="e081" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">8.推荐引擎的评估指标</h1><p id="3c17" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">为了评估推荐引擎，我们可以使用以下指标</p><p id="d631" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 8.1召回:</strong></p><ul class=""><li id="7cf4" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">用户喜欢的项目中有多少是真正被推荐的</li><li id="7886" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">它由下式给出:</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es oh"><img src="../Images/7fe8a25e9bf0f664d87cb1c8647ee526.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/0*Q2zSVyNZBTx7RJxd.png"/></div></figure><p id="89fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里<em class="mh"> tp </em>表示推荐给用户的他/她喜欢的项目的数量，<em class="mh"> tp </em> + <em class="mh"> fn </em>表示用户喜欢的项目的总数。<br/>如果用户喜欢5个项目，推荐引擎决定显示其中的3个，那么召回率将是0.6 <br/>召回率越大，推荐越好</p><p id="ea2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 8.2精度:</strong></p><ul class=""><li id="b70e" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">在所有推荐的商品中，有多少是用户真正喜欢的？</li><li id="50c6" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">它由下式给出:</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es oi"><img src="../Images/10f1646ce337d8a6caed7c87ab9385ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/0*PkAKBDDxycGdPs-M.png"/></div></div></figure><ul class=""><li id="49c0" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">这里<em class="mh"> tp </em>表示推荐给用户的他/她喜欢的项目的数量，而<em class="mh"> tp </em> + <em class="mh"> fp </em>表示推荐给用户的项目总数</li><li id="55b8" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">如果向用户推荐了5个项目，其中他喜欢4个，那么精度将是0.8</li><li id="2dff" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">精度越高，推荐越好</li><li id="3353" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">但是考虑这种情况:如果我们简单地推荐所有的项目，它们肯定会覆盖用户喜欢的项目。所以我们有100%的召回率！但是考虑一下精确度。如果我们推荐1000个项目，而用户只喜欢其中的10个，那么精度是0.1%。这真的很低。因此，我们的目标应该是最大化精确度和召回率。</li></ul><p id="6e04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 8.3 RMSE(均方根误差):</strong></p><ul class=""><li id="cbfd" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">它测量预测评级的误差:</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es oj"><img src="../Images/5767de2f473b168c967430d319b73324.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/0*tszFiRuz9RZooQ4z.png"/></div></div></figure><ul class=""><li id="3725" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">在这里,“预测”是模型预测的评级,“实际”是原始评级</li><li id="6dc5" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">如果一个用户给一部电影打了5分，而我们预测评分是4分，那么RMSE就是1分</li><li id="cf36" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">RMSE值越小，推荐越好</li></ul><p id="ff40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述指标告诉我们我们的推荐有多准确，但它们并不关注推荐的顺序，也就是说，它们并不关注首先推荐哪个产品，然后是什么。我们需要一些指标，也考虑了推荐产品的订单。那么，让我们来看看一些<strong class="ih hj">排名指标</strong>:</p><p id="790e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 8.4平均倒数排名:</strong></p><ul class=""><li id="e4ce" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">评估建议列表</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ok"><img src="../Images/0edd278b108cc0d53d9c497d92e2c1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/0*ct02NSjCCSgGWxk7.png"/></div></figure><ul class=""><li id="a7f3" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">假设我们已经向用户推荐了3部电影，比如按照给定的顺序推荐A、B、C，但是用户只喜欢电影C。由于电影C的排名是3，所以倒数排名将是1/3</li><li id="6cee" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">平均倒数排名越大，推荐越好</li></ul><p id="a3ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">8.5k处的图(截止点k处的平均精度):</strong></p><ul class=""><li id="63fe" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">精确度和召回率不关心推荐中的排序</li><li id="2ebc" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">截止k处的精度是通过仅考虑等级1到k的建议子集计算的精度</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ol"><img src="../Images/8ba92344c81d9222558795b51978abc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/0*CA2RObZ18tg_qBc7.jpeg"/></div></figure><ul class=""><li id="99c4" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">假设我们做了三个推荐[0，1，1]。这里0表示推荐不正确，1表示推荐正确。那么k处的精度将是[0，1/2，2/3]，平均精度将是(1/3)*(0+1/2+2/3) = 0.38</li><li id="b86a" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">平均精度越大，推荐就越正确</li></ul><p id="170a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 8.6 NDCG(归一化贴现累计收益):</strong></p><ul class=""><li id="cc9c" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated">MAP和NDCG的主要区别在于，MAP假设一个项目是感兴趣的(或不感兴趣的)，而NDCG给出相关性分数</li><li id="269f" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">让我们用一个例子来理解它:假设在10部电影A到J中，我们可以推荐前五部电影，即A、B、C、D和E，而我们不能推荐其他5部电影，即F、G、H、I和J。推荐的是[A、B、C、D]。因此，在这种情况下，NDCG将为1，因为推荐的产品与用户相关</li><li id="90de" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">NDCG值越高，推荐越好</li></ul><h1 id="6521" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">9.还有什么可以尝试的？</h1><p id="4023" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">至此，我们已经了解了什么是推荐引擎，它的不同类型以及它们的工作原理。基于内容的过滤和协同过滤算法各有优缺点。</p><p id="fcbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某些领域，生成有用的内容描述可能非常困难。如果用户以前的行为没有提供证据，基于内容的过滤模型将不会选择项目。必须使用额外的技术，以便系统可以在用户已经表现出兴趣的范围之外提出建议。</p><p id="b522" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">协同过滤模型没有这些缺点。因为不需要对被推荐的项目进行描述，所以该系统可以处理任何种类的信息。此外，它可以推荐用户以前没有表现出兴趣的产品。但是，如果没有用户评级作为预测的基础，协同过滤就不能为新项目提供推荐。即使用户开始对项目进行评级，在项目获得足够的评级以做出准确的推荐之前，也需要一些时间。</p><p id="c401" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个结合了基于内容的过滤和协作过滤的系统可以潜在地利用内容的表示以及用户之间的相似性。一种结合协作和基于内容的过滤的方法是基于基于内容的推荐和协作推荐的加权平均来进行预测。这样做的各种方法有:</p><ul class=""><li id="03ee" class="kj kk hi ih b ii ij im in iq lc iu ld iy le jc lf kr ks kt bi translated"><strong class="ih hj">合并项目得分</strong></li><li id="020d" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">在这种方法中，我们将从两种过滤方法中获得的评级相结合。最简单的方法是取评级的平均值</li><li id="956f" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">假设一种方法建议电影的等级为4，而另一种方法建议同一部电影的等级为5。因此，最终建议将是两个评级的平均值，即4.5</li><li id="35f9" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">我们也可以给不同的方法分配不同的权重</li><li id="5c4e" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated"><strong class="ih hj">结合物品等级:</strong></li><li id="9558" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">假设协同过滤按照以下顺序推荐了5部电影A、B、C、D和E:A、B、C、D、E，而基于内容的过滤按照以下顺序推荐了它们:B、D、A、C、E</li><li id="b8a8" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lf kr ks kt bi translated">电影的排名是:</li></ul><p id="b661" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">协作过滤:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es oc"><img src="../Images/1a90861cb4c700dce880e8815e61d379.png" data-original-src="https://miro.medium.com/v2/resize:fit:248/format:webp/1*3g59kAr4IZrbLr7v4d6r-A.png"/></div></figure><p id="efd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于内容的过滤:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es oc"><img src="../Images/f8927ad43b90447fab6526ac0b3fc7bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:248/format:webp/1*f7il0qWwIIlpo78y_6H3VQ.png"/></div></figure><p id="94cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，<strong class="ih hj">混合推荐引擎将组合这些排名，并基于组合的排名做出最终推荐</strong>。综合排名将为:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es om"><img src="../Images/d8a2e70b07e5b6f8175ad1a1c96cd581.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*_VGDQkcdpu1T-M2DXQVozg.png"/></div></figure><p id="5231" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将根据这些排名做出推荐。所以，最终的推荐会是这样的:B，A，D，C，e。</p><p id="d3fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这种方式，可以将两种或多种技术结合起来构建一个混合推荐引擎，并提高它们的整体推荐准确度和能力。</p><h1 id="fcd9" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">结束注释</h1><p id="1f88" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这是一篇关于推荐引擎的非常全面的文章。本教程应该足以让你开始这个话题。我们不仅讨论了基本的推荐技术，还了解了如何实现当今行业中一些更高级的技术。</p><p id="8941" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还讨论了与每种技术相关的一些关键事实。作为想学习如何制作推荐引擎的人，我建议你学习本教程中讨论的技术，然后在你的模型中实现它们。</p><p id="afd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你觉得这篇文章有用吗？在下面的评论区分享你的观点吧！</p></div><div class="ab cl on oo gp op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="hb hc hd he hf"><p id="6a32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mh">原载于2018年6月21日</em><a class="ae mt" href="https://www.analyticsvidhya.com/blog/2018/06/comprehensive-guide-recommendation-engine-python/" rel="noopener ugc nofollow" target="_blank"><em class="mh">【www.analyticsvidhya.com</em></a><em class="mh">。</em></p></div></div>    
</body>
</html>