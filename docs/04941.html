<html>
<head>
<title>Code Jam 2020 Solutions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码堵塞2020解决方案</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/code-jam-2020-solutions-3d3528fcdd10?source=collection_archive---------9-----------------------#2020-04-06">https://medium.com/analytics-vidhya/code-jam-2020-solutions-3d3528fcdd10?source=collection_archive---------9-----------------------#2020-04-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="79df" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak"> <em class="jk">什么是代码堵塞？</em>T3】</strong></h1><p id="b360" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">谷歌持续时间最长的全球编码竞赛Code Jam号召全世界的程序员分秒必争地解决具有挑战性的算法难题。参赛者通过四轮在线主办的比赛晋级，参加每年在不同的国际谷歌办公室举行的年度Code Jam World总决赛。每一轮都带来新的挑战，最终，25名参赛者将有最终的机会检验他们的技能，在世界总决赛上争夺现金奖励和梦寐以求的冠军头衔。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kj"><img src="../Images/8dd6e5a347c3c23059281bdbaadb5781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALR2kT9Ah999GPwrCRAmKg.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">code jam徽标</figcaption></figure><p id="bf20" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">长达27小时的编码比赛于4月5日上午7:30(IST)结束。总共有5个问题，我成功地解决了3个。在这里，我将用通俗易懂的语言和代码来解释这3个问题。</p><h1 id="8f2f" class="im in hi bd io ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj bi translated"><strong class="ak">残迹(7分)</strong></h1><p id="dc95" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可以在这里阅读问题陈述<a class="ae lj" href="https://codingcompetitions.withgoogle.com/codejam/round/000000000019fd27/000000000020993c" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="93b6" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">C++中的解决方案</p><p id="cd5a" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">问题的第一部分，我们需要计算矩阵的轨迹，这很简单，只需要一个for循环就可以完成。如果你不知道什么是矩阵的迹，那么迹被定义为主对角线上元素的和。如果有3×3矩阵A，那么迹将是主对角线元素的和(即A[1][1]+A[2][2]+A[3][3])。</p><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="9e4b" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">现在下一部分是检查矩阵是否是拉丁方。如果你不知道什么是拉丁方块，那么点击<a class="ae lj" href="https://mathworld.wolfram.com/LatinSquare.html" rel="noopener ugc nofollow" target="_blank">这里</a>。这里使用set数据结构是一个更好的选择，因为我们想检查一行和一列中的所有元素是否都是唯一的，set不能存储重复值。因此，逻辑将以<a class="ae lj" href="https://en.wikipedia.org/wiki/Row-_and_column-major_order" rel="noopener ugc nofollow" target="_blank">行主顺序和</a>列主顺序遍历矩阵，并将它们存储在一个集合中。如果集合的长度小于行或列的大小，则它包含重复值，因此它不是拉丁方。</p><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="ac57" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">现在把所有东西放在一起，最终的代码看起来像这样。</p><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h1 id="bbb2" class="im in hi bd io ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj bi translated"><strong class="ak">嵌套深度(5磅，11磅)</strong></h1><p id="a91a" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可以在这里阅读问题陈述<a class="ae lj" href="https://codingcompetitions.withgoogle.com/codejam/round/000000000019fd27/0000000000209a9f" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="896d" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">Python解决方案</p><p id="0dc8" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">在这个问题中，我们将为括号保留一个计数器。左括号“(”是+1，右括号“)”是-1。我们将这个计数器与遍历输入时遇到的数量进行比较。将有三种情况:</p><ol class=""><li id="b070" class="lm ln hi jn b jo kz js la jw lo ka lp ke lq ki lr ls lt lu bi translated">当计数器的整数值大于指针所在的数字时。所以，我们将在数字前加上右括号，并从计数器中减去1，直到计数器的值和数字不相等。</li><li id="5016" class="lm ln hi jn b jo lv js lw jw lx ka ly ke lz ki lr ls lt lu bi translated">当计数器的整数值小于指针所在的数字时。因此，我们将在数字前添加左括号，并将计数器加1，直到计数器的值和数字相等。</li><li id="e4cb" class="lm ln hi jn b jo lv js lw jw lx ka ly ke lz ki lr ls lt lu bi translated">当计数器的整数值等于指针所在的数字时。我们将跳过这个数字，不添加右括号或左括号。</li></ol><p id="c2e1" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">以下是解决方案</p><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h1 id="f023" class="im in hi bd io ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj bi translated"><strong class="ak">亲子关系回报(7分，12分)</strong></h1><p id="d495" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可以在这里阅读问题声明<a class="ae lj" href="https://codingcompetitions.withgoogle.com/codejam/round/000000000019fd27/000000000020bdf9" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3721" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">Python解决方案</p><p id="9c91" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">我用贪婪算法解决了这个问题(也可以有其他方法)。在这里，我们必须为Cameron和Jamie安排活动，以便其他活动不会在他们的计划中重叠，并将Jamie 'J '和Cameron完成的活动打印为' C '(解决方案看起来类似于' JCCCJCCJ ')，如果不可能，则打印“不可能”。因为每个活动调度问题都按开始时间对数组进行排序。现在，我们必须遍历这个排序后的数组，通过比较Cameron或Jamie最后一次活动的结束时间，开始将活动放在他们的下面。为此，我们将存储他们最后一次活动的索引。在每个测试用例中，我们将把第一个活动交给Cameron。接下来是三种情况:</p><ol class=""><li id="8a6b" class="lm ln hi jn b jo kz js la jw lo ka lp ke lq ki lr ls lt lu bi translated">我们将通过比较上一个活动和当前活动的开始时间和结束时间来检查是否可以为Cameron安排活动。如果可以安排给Cameron，那么我们将更新存储上次安排给Cameron的活动的索引的变量。</li><li id="3672" class="lm ln hi jn b jo lv js lw jw lx ka ly ke lz ki lr ls lt lu bi translated">如果不可能将它安排给Cameron，那么我们将它安排给Jamie，因为Jamie没有安排任何活动，并且更新存储安排给Jamie的最后活动的索引的变量。</li><li id="518f" class="lm ln hi jn b jo lv js lw jw lx ka ly ke lz ki lr ls lt lu bi translated">当杰米安排好一项活动后，我们将开始比较。现在，当下一个活动到来并且无法安排给Cameron时，我们将比较前一个活动的结束时间和该活动的开始时间。如果可以安排给Jamie，那么我们将更新存储安排给Jamie的最后一个活动的索引的变量。如果不能安排给Jamie，那么就不可能安排，然后我们将打印“不可能”并打破循环。</li></ol><p id="df76" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">在打印最终答案时(当答案并非不可能时)，我们必须注意按照活动提供给我们的格式打印。为此，在对所有活动进行排序之前，我对包含这些活动的数组做了一个<a class="ae lj" href="https://stackoverflow.com/questions/184710/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy" rel="noopener ugc nofollow" target="_blank">深度拷贝</a>。现在，当调度活动时，在重复数组中搜索它们，并在重复数组中的索引处添加字符“J”或“C”。</p><p id="e50f" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">这是代码</p><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="lk ll l"/></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="c960" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">这些是我在《代码堵塞2020》中用通俗语言解决的3个问题的答案。</p><p id="5541" class="pw-post-body-paragraph jl jm hi jn b jo kz jq jr js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki hb bi translated">别忘了留下评论！在评论区留下建设性的反馈。</p></div></div>    
</body>
</html>