<html>
<head>
<title>Intricacies of Matrix Multiplication While Programming in Python Using Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用列表在Python中编程时矩阵乘法的复杂性</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/intricacies-of-matrix-multiplication-while-programming-in-python-using-lists-7528d0369375?source=collection_archive---------9-----------------------#2019-12-17">https://medium.com/analytics-vidhya/intricacies-of-matrix-multiplication-while-programming-in-python-using-lists-7528d0369375?source=collection_archive---------9-----------------------#2019-12-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="8626" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">Python编程/矩阵乘法</h2><div class=""/><div class=""><h2 id="5dd7" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">Python编程语言中矩阵乘法的详细分析。</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/2dbc87d008c88ec4d50c03868b4d7c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0YTcM4eo2T3cseD5CofOMw.png"/></div></div></figure><p id="b781" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">矩阵乘法是通过两个矩阵相乘产生一个矩阵的过程。它发生的主要条件是第一个矩阵的列必须等于第二个矩阵的行。矩阵乘法是十二年级学生的必修课。使用C/C+计算矩阵乘法的作业对于计算机科学的大学生来说是普遍存在的。然而，当用Python编写程序时，与矩阵乘法相关的复杂性也经常被忽略。</p><p id="829e" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果你搜索‘矩阵乘法python’这个词，谷歌会给你提供大量指定硬编码矩阵乘法代码的页面。那些网站中列出的几乎每个代码都方便地忽略了单行矩阵和多行矩阵之间发生乘法的情况。让我们更深入地探讨一下。</p><p id="2fba" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">Python中一个简单的矩阵乘法硬编码程序很容易类似于下面的代码:</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="b79c" class="kt ku hi kp b fi kv kw l kx ky">def matrix_mul(MatrixA, MatrixB):<br/>    """<br/>    Function to create a matrix resulting from multiplication of two matrices<br/>    """<br/>    global r1, c1<br/>    global r2, c2<br/>    global MatrixC<br/>    for i in range(r1):<br/>        for j in range(c2):<br/>            for k in range(r2):<br/>                MatrixC[i][j] += MatrixA[i][k] * MatrixB[k][j]</span><span id="1e00" class="kt ku hi kp b fi kz kw l kx ky">MatrixA = [[1, 2], [3, 4]]<br/>MatrixB = [[1, 2, 3, 4, 5], [5, 6, 7, 8, 9]]<br/>r1 = 2<br/>c1 = 2<br/>r2 = 2<br/>c2 = 5<br/>MatrixC = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]<br/>matrix_mul(MatrixA, MatrixB)<br/>aster = '*'<br/>print(aster * 68)<br/>print('The resultant matrix is:')<br/>print(aster * 68)<br/>print(MatrixC)<br/>print(aster * 68)</span></pre><p id="232d" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">当您运行代码时，它将给出以下输出:</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="38b8" class="kt ku hi kp b fi kv kw l kx ky">********************************************************************<br/>The resultant matrix is:<br/>********************************************************************<br/>[[11, 14, 17, 20, 23], [23, 30, 37, 44, 51]]<br/>********************************************************************</span></pre><p id="74fe" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">代码首先初始化matrix a(2 x2阶)和matrix b(2 X5阶)的值。然后使用要相乘的矩阵作为参数来调用matrix_mul函数。该函数通过第一个矩阵的行与第二个矩阵的列的点积来执行矩阵乘法(点积是匹配元素的乘法)。结果矩阵的行等于第一个矩阵的行，列等于第二个矩阵的列。</p><p id="7198" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">当矩阵A(1×3阶)与另一个矩阵B(3×1阶)相乘时，代码的缺陷(很像各种网站上的大多数在线代码)就会显现出来。运行代码时，会发生TypeError。</p><p id="0014" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">type error</strong>:“int”对象是不可订阅的</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="8283" class="kt ku hi kp b fi kv kw l kx ky"><strong class="kp hs">---------------------------------------------------------------------------</strong><br/><strong class="kp hs">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="kp hs">&lt;ipython-input-26-a342be5c878d&gt;</strong> in &lt;module&gt;<strong class="kp hs">()</strong><br/>     16 MatrixB <strong class="kp hs">=</strong> <strong class="kp hs">[[4],</strong> <strong class="kp hs">[5],</strong> <strong class="kp hs">[6]]</strong><br/>     17 MatrixC <strong class="kp hs">=</strong> <strong class="kp hs">[0]</strong><br/><strong class="kp hs">---&gt; 18 </strong>matrix_mul<strong class="kp hs">(</strong>MatrixA<strong class="kp hs">,</strong> MatrixB<strong class="kp hs">)</strong><br/>     19 aster <strong class="kp hs">=</strong> <strong class="kp hs">'*'</strong><br/>     20 print<strong class="kp hs">(</strong>aster <strong class="kp hs">*</strong> <strong class="kp hs">70)</strong></span><span id="448b" class="kt ku hi kp b fi kz kw l kx ky"><strong class="kp hs">&lt;ipython-input-26-a342be5c878d&gt;</strong> in matrix_mul<strong class="kp hs">(MatrixA, MatrixB)</strong><br/>      9         <strong class="kp hs">for</strong> j <strong class="kp hs">in</strong> range<strong class="kp hs">(5):</strong><br/>     10             <strong class="kp hs">for</strong> k <strong class="kp hs">in</strong> range<strong class="kp hs">(2):</strong><br/><strong class="kp hs">---&gt; 11                 </strong>MatrixC<strong class="kp hs">[</strong>i<strong class="kp hs">][</strong>j<strong class="kp hs">]</strong> <strong class="kp hs">+=</strong> MatrixA<strong class="kp hs">[</strong>i<strong class="kp hs">][</strong>k<strong class="kp hs">]</strong> <strong class="kp hs">*</strong> MatrixB<strong class="kp hs">[</strong>k<strong class="kp hs">][</strong>j<strong class="kp hs">]</strong><br/>     12 <br/>     13 </span><span id="fed0" class="kt ku hi kp b fi kz kw l kx ky"><strong class="kp hs">TypeError</strong>: 'int' object is not subscriptable</span></pre><p id="0a8e" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">为了更好地理解这个错误，让我们考虑一个包含三个元素的列表</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="cf01" class="kt ku hi kp b fi kv kw l kx ky">list1 = [1, 2, 3]<br/>print(list1[0][0])</span></pre><p id="bec8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果我们运行这段代码，会出现同样的类型错误。原因是代码试图访问的列表的索引超出了范围。如果list1是一个列表列表(如下面给出的代码所示)，那么输出应该是1。</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="491c" class="kt ku hi kp b fi kv kw l kx ky">list1 = [[1], [2], [3]]<br/>print(list1[0][0])</span></pre><p id="225a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在程序中，函数matrix_mul(MatrixA，MatrixB)在下面几行代码中执行矩阵乘法。</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="4527" class="kt ku hi kp b fi kv kw l kx ky">for i in range(r1):<br/>        for j in range(c2):<br/>            for k in range(r2):<br/>                MatrixC[i][j] += MatrixA[i][k] * MatrixB[k][j]</span></pre><p id="ef65" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">TypeError的根本原因就源于这一行代码。原因是程序员不了解下面两种涉及单行矩阵的情况:</p><p id="3ca0" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">场景1 </strong> : <strong class="ju hs">当第一个矩阵的行和第二个矩阵的列是一个</strong>。1x3阶的MatrixA和3x1阶的MatrixB就是典型的例子。在这种情况下，MatrixA和MatrixC(零矩阵)都是列表(而不是列表的列表)。因此，当计算MatrixC[I][j]+= MatrixA[I][k]* matrix b[k][j]时，matrix c和matrix a的索引超出范围，因为它们是单行矩阵。因此<strong class="ju hs">类型错误</strong>:‘int’对象是不可订阅的。</p><p id="f957" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">场景二</strong> : <strong class="ju hs">当第一个矩阵的行为1，第二个矩阵的列不等于1时。1x2阶的MatrixA和2x2阶的MatrixB就是这种情况。就像前面的例子一样，MatrixA和MatrixC是单行矩阵。因此出现了类型错误。</strong></p><p id="3d7c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">让我们纠正这些问题，并努力创造一个程序，纳入矩阵乘法的所有方面。同时，让我们赋予最终用户(运行代码的人)权力，使他/她能够决定矩阵的顺序并在运行时输入相应的值，从而使代码更加通用。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="cb0f" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">上面的代码在运行时接收用户输入，并验证用户是否输入了正确的数据。该代码检查用户在输入过程中可能犯的所有错误。首先，程序检查接收到的矩阵阶数的输入是否为整数。为此，Python异常处理(try，except)用于引发ValueError。</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="7c4f" class="kt ku hi kp b fi kv kw l kx ky">Enter the no. of rows of Matrix A: 2.5<br/>Please enter a valid integer greater than zero</span></pre><p id="9c30" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果第一个矩阵的列不等于第二个矩阵的行，则会出现错误消息。</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="a6d3" class="kt ku hi kp b fi kv kw l kx ky">Enter the no. of rows of Matrix A: 2<br/>Enter the no. of columns of Matrix A: 3<br/>Enter the no. of rows of Matrix B: 4<br/>Enter the np. of columns of Matrix B: 2<br/>Kindly change the order of matrices. For multiplication of matrices, the no. of columns of first matrix must be equal to no. of rows of second matrix.</span></pre><p id="0a34" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果第一个矩阵的顺序是2x2，并且用户为第一行输入四个元素，则程序显示一条错误消息“请输入等于2的元素—矩阵A的列的大小”。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lc"><img src="../Images/0c3f32b509f8dd84d7973301cc1b16d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DnO9XkV2SghLEKpMecliw.png"/></div></div></figure><p id="da14" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">该程序考虑了前面讨论的单行矩阵的两种场景<strong class="ju hs">。让我们考虑<strong class="ju hs">场景1 </strong>当第一个矩阵的行数和第二个矩阵的列数为1时(例如，matrixA的阶数为1×3，MatrixB的阶数为3×1)，matrixC将是1×1矩阵。和matrixC一样，MatrixA将是一个单行矩阵。在这种情况下，使用以下代码行完成矩阵乘法:</strong></p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="49fc" class="kt ku hi kp b fi kv kw l kx ky">if(r1 == 1)&amp;(c2 == 1):  #(1x3)*(3x1)=(1x1)<br/>        for i in range(r1):<br/>            for j in range(c2):<br/>                for k in range(r2):<br/>                    matrixC[i] += matrixA[k] * matrixB[k][j]</span></pre><p id="2d26" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">场景2 </strong>处理第一个矩阵的行数为1，第二个矩阵的列数不为1的情况(例如，matrixA的阶数为1x2，matrixB的阶数为2x2)。就像场景1一样，matrixA和matrixC都是单行矩阵。区别在于矩阵乘法的值的计算方式。在场景1中，matrixC迭代I的值(matrixA的行)，而在场景2中，matrixC迭代j的值(matrixB的列)。</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="500d" class="kt ku hi kp b fi kv kw l kx ky">elif(r1 == 1)&amp;(c2 != 1): #(1x2)*(2x2)=(1x2)<br/>        for i in range(r1):<br/>            for j in range(c2):<br/>                for k in range(r2):<br/>                    matrixC[j] += matrixA[k] * matrixB[k][j]</span></pre><p id="a970" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在场景1和场景2中，matrixC的计算方式是它将成为单行矩阵。</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="35c6" class="kt ku hi kp b fi kv kw l kx ky">if(r1 == 1)|(r1 == c2 == 1): <br/>        for i in range(r1):<br/>            matrixC = []<br/>            for j in range(c2):<br/>                matrixC.append(0)</span></pre><p id="4662" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在所有其他情况下，矩阵乘法由通常的代码完成:</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="a04c" class="kt ku hi kp b fi kv kw l kx ky">else: #all other cases<br/>        for i in range(r1):<br/>            for j in range(c2):<br/>                for k in range(r2):<br/>                    matrixC[i][j] += matrixA[i][k] * matrixB[k][j]</span></pre><p id="2f36" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">matrixC是一个多行矩阵，计算公式如下:</p><pre class="jh ji jj jk fd ko kp kq kr aw ks bi"><span id="e94d" class="kt ku hi kp b fi kv kw l kx ky">for i in range(r1):<br/>            row_matrixC = []<br/>            for j in range(c2):<br/>                row_matrixC.append(0)            <br/>            matrixC.append(row_matrixC)</span></pre><p id="9ed7" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">所有这些情况在C++中都可以作为一个单独的例子来处理(一个解决方案适合所有的方法)。用C++完成的矩阵乘法:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="36bc" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">Github链接</p><div class="ld le ez fb lf lg"><a href="https://github.com/pbipin/Matrix_Multiplication" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hs fi z dy ll ea eb lm ed ef hr bi translated">pbi pin/矩阵乘法</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">Python程序对所有阶的矩阵执行矩阵乘法。代码在运行时接收用户输入…</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">github.com</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu jq lg"/></div></div></a></div><p id="f2c8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">编码快乐！！！</p></div></div>    
</body>
</html>