<html>
<head>
<title>How to use a trie to rebuild a directory tree in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中使用trie树重建目录树</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/if-youre-given-the-path-to-a-directory-you-can-easily-perform-a-walk-on-it-and-generate-the-bf321a8bdd63?source=collection_archive---------13-----------------------#2020-05-31">https://medium.com/analytics-vidhya/if-youre-given-the-path-to-a-directory-you-can-easily-perform-a-walk-on-it-and-generate-the-bf321a8bdd63?source=collection_archive---------13-----------------------#2020-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/48cbe4444378b5c50ed8a312fab720a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*AafE2DcKGHyO-EnW.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">来源:<a class="ae iq" href="https://www.raywenderlich.com/892-swift-algorithm-club-swift-trie-data-structure" rel="noopener ugc nofollow" target="_blank">https://www . raywenderlich . com/892-swift-algorithm-club-swift-trie-data-structure</a></figcaption></figure><p id="63cd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果给定了一个目录的路径，就可以很容易地对其进行遍历，并将目录树生成为一个列表，使得树中的每个目录后面都跟着它的文件和子目录等等。让我用一个例子展示给你看。</p><p id="58ce" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">下面是我电脑上一个名为<code class="du jp jq jr js b">pcache</code>的目录的<code class="du jp jq jr js b">tree</code>的输出。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es jt"><img src="../Images/76c2dcb37aa447d45e73d6cee128f4a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTF4MUwQCZb5FRkVBolikA.png"/></div></div></figure><p id="242d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们试着用Python来生成这个列表。我们将使用来自<code class="du jp jq jr js b">os</code>标准库中的一个名为<code class="du jp jq jr js b">os.walk()</code>的方法</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="kc kd l"/></div></figure><p id="09b4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">当我用<code class="du jp jq jr js b">./pcache</code>作为参数打印<code class="du jp jq jr js b">generate_directory_tree</code>的结果时，我得到如下结果。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es jt"><img src="../Images/4d80ca5b735d1c06b1166e09c30879b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eeMEWXndBF_i0jhzvvFEZA.png"/></div></div></figure><p id="a343" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果您查看结果，您会注意到在移动到同一级别的下一个目录之前，任何目录后面都跟有它的内容，就像<code class="du jp jq jr js b">tree</code>的输出看起来一样。</p><p id="9a2b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在，问题来了。情况反过来会怎样？您会得到一个随机的文件和目录路径条目列表，您必须在一个目录树型结构中对条目进行排序，其中目录后面紧跟着它的内容。考虑下面这个被打乱的列表。</p><h2 id="31f6" class="ke kf hi bd kg kh ki kj kk kl km kn ko jc kp kq kr jg ks kt ku jk kv kw kx ky bi translated">了解如何帮助我们解决问题</h2><blockquote class="kz la lb"><p id="451f" class="ir is lc it b iu iv iw ix iy iz ja jb ld jd je jf le jh ji jj lf jl jm jn jo hb bi translated">trie(也称为基数树或前缀树)是一种基于树的数据结构，用于存储字符串以便更快地检索trie<strong class="it hj">val。每个节点存储一些字符/单词，并且沿着从根到叶的分支遍历建立整个字符串/文本。</strong></p></blockquote><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lg"><img src="../Images/0aad2d3b962417f7df504ffb7f7574b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rHz4fY4Ru_QWh7cc.jpg"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">来源:<a class="ae iq" href="http://theoryofprogramming.com/2015/01/16/trie-tree-implementation/" rel="noopener ugc nofollow" target="_blank">http://theory of programming . com/2015/01/16/trie-tree-implementation/</a></figcaption></figure><p id="9606" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在，如果我们考虑我们的路径并在<code class="du jp jq jr js b">/</code>路径分隔符上分割它们，我们基本上拥有了可以存储在每个节点中的键。请参考下图。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lh"><img src="../Images/08c048f7154ac65e6b4ab52ee2f0038e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rCbra5eSQsDNOOZPj2DhA.png"/></div></div></figure><p id="4c8a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在，如果我们在这个trie上执行一个前序遍历，并在到达一个叶节点时打印路径，我们实际上将获得一个路径条目列表，它将被安排在一个类似目录树的结构中。让我们用一些Python代码来看看这一点。</p><p id="c42c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">PyPI上有一个很棒的库叫做<a class="ae iq" href="https://github.com/mina86/pygtrie" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj"> pygtrie </strong> </a> <strong class="it hj"> </strong>，它让我们的事情变得更简单。这意味着我们不必担心重新发明轮子，从头开始编写整个trie实现。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="kc kd l"/></div></figure><p id="db76" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">因此，我们有一个路径及其类型的列表，即它是文件还是目录。我们将这个列表提供给我们的trie，它是<code class="du jp jq jr js b">pygtrie.StringTrie</code>的一个实例，有一个很酷的特性，它可以接受一个分隔符来标记字符串，并在trie节点中使用标记。路径存储为键，类型存储为值。我们将类型转换为<code class="du jp jq jr js b">bool</code>的原因是，我们希望在遍历过程中确定我们是到达了一个叶子节点还是一个中间节点。然后，我们调用trie上的traverse方法，该方法执行前序遍历，回调帮助我们在遍历trie时打印路径。一旦我们运行代码，我们会得到下面的输出。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es jt"><img src="../Images/eefb2ba630244b288939d4e67cdcc5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWbkgnQwoWbhTd5xnQo0LA.png"/></div></div></figure><p id="2529" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这正是我们想要的。</p><p id="2533" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">您可以调整实现，不仅在值中存储<code class="du jp jq jr js b">bool</code>，还可以根据您的需求做很多事情。希望这篇文章对你有帮助。</p><p id="4739" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">干杯！</p></div></div>    
</body>
</html>