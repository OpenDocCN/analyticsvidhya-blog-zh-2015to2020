<html>
<head>
<title>Developing Complete Authorization Modules with AWS Lambda &amp; Go &amp; PostgreSQL &amp; Event-Driven SQS Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Lambda &amp; Go &amp; PostgreSQL &amp;事件驱动的SQS队列开发完整的授权模块</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/developing-complete-authorization-modules-with-aws-lambda-go-postgresql-event-driven-sqs-ee641622e890?source=collection_archive---------3-----------------------#2019-10-30">https://medium.com/analytics-vidhya/developing-complete-authorization-modules-with-aws-lambda-go-postgresql-event-driven-sqs-ee641622e890?source=collection_archive---------3-----------------------#2019-10-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cafe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程中，我将分享一个包含注册，登录，授权，电子邮件验证功能的示例项目。这些函数可以用来启动一个新的无服务器项目。我将在文章的最后在GitHub上分享代码，这样人们可以从现有的代码开始。技术堆栈如下:</p><ul class=""><li id="0cc8" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">戈朗</li><li id="1469" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">戈尔姆</li><li id="0611" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">自动气象站λ</li><li id="beda" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">AWS API网关</li><li id="533a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">AWS RDS Postgresql</li><li id="2637" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">AWS SES</li><li id="c58d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">AWS SQS</li></ul><p id="fddd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以用AWS自由层开发这个项目。你不需要向AWS支付任何费用。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/1bc9d63bb59b7a81480d6048f80c0c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WIz5VkrsxGn1rt3r.jpeg"/></div></div></figure><p id="a1a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程的后面，我将给出每个模块的一些提示和技巧。</p><p id="c7e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先用AWS SAM创建一个项目。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="291f" class="ki kj hi ke b fi kk kl l km kn">sam init --runtime go1.x --name serverlessExample</span></pre><p id="0fab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想你对AWS有些了解，SAM。如果你需要寻找一些关于它的信息，你可以在下面找到我以前的文章。</p><div class="ko kp ez fb kq kr"><a rel="noopener follow" target="_blank" href="/@yunskilic/go-aws-development-with-serverless-application-model-sam-to-start-functions-locally-53a1f0fd69c8"><div class="ks ab dw"><div class="kt ab ku cl cj kv"><h2 class="bd hj fi z dy kw ea eb kx ed ef hh bi translated">使用无服务器应用程序模型SAM进行AWS开发，以在本地启动功能</h2><div class="ky l"><h3 class="bd b fi z dy kw ea eb kx ed ef dx translated">这是我用Go语言进行AWS之旅的第三篇文章。</h3></div><div class="kz l"><p class="bd b fp z dy kw ea eb kx ed ef dx translated">medium.com</p></div></div><div class="la l"><div class="lb l lc ld le la lf kb kr"/></div></div></a></div><p id="fa5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Sam为我们创建了初始函数和template.yaml。</p><p id="4262" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从注册功能开始</p><p id="c858" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">签约功能</strong></p><p id="e296" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在functions文件夹中收集所有lambda函数。所以创建下面的文件夹结构。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es lg"><img src="../Images/fa4c62f5813e3a1daa2320b1194c4b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*d_6Q1ovR7CWu8b1_NnTcVg.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx translated">项目结构</figcaption></figure><p id="3cf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注册功能需要数据库连接来创建用户。我用的是亚马逊RDS Postgresql。</p><ul class=""><li id="ead1" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">创建一个数据库实例，然后使其可公开访问，以便从AWS外部连接。</li></ul><p id="1036" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据库连接器代码:</strong></p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="9b23" class="ki kj hi ke b fi kk kl l km kn">package database<br/><br/>import (<br/>   "fmt"<br/>   "github.com/jinzhu/gorm"<br/>   _ "github.com/jinzhu/gorm/dialects/postgres"<br/>   "os"<br/>)<br/><br/>type PostgresConnector struct {<br/>}<br/><br/>func (p *PostgresConnector) GetConnection() (db *gorm.DB, err error) {<br/>   username := os.Getenv("db_user")<br/>   password := os.Getenv("db_pass")<br/>   dbName := os.Getenv("db_name")<br/>   dbHost := os.Getenv("db_host")<br/>   dbURI := fmt.Sprintf("host=%s user=%s dbname=%s sslmode=disable password=%s", dbHost, username, dbName, password)<br/>   fmt.Println(dbURI)<br/>   return gorm.Open("postgres", dbURI)<br/>}</span></pre><p id="a30a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">连接器从环境变量中读取信息，然后打开连接。</p><p id="cca3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用户实体编码:</strong></p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="8dad" class="ki kj hi ke b fi kk kl l km kn">package entity<br/><br/>import "github.com/jinzhu/gorm"<br/><br/>type User struct {<br/>   gorm.Model<br/>   Email         string<br/>   Password      string `json:"-"`<br/>   EmailVerified bool<br/>   LoginTry      int<br/>}</span></pre><p id="c08d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单地说，我的模型非常原始。但是你可以很容易地扩展这个模型。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="20f5" class="ki kj hi ke b fi kk kl l km kn">`json:"-"` means do not show at json</span></pre><p id="846e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的gorm模型和DB连接器已经准备好了，所以我们可以轻松地开始编码。</p><p id="7235" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了一个模型来解析请求体。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ll"><img src="../Images/88b42ef4c34a6cf7538f13e3b81c06ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*XmeipDA8CX50iQatSZ5ktg.png"/></div></figure><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="281e" class="ki kj hi ke b fi kk kl l km kn">package main<br/><br/>type SignupRequest struct {<br/>   Email    string `validate:"required,email"`<br/>   Password string `validate:"required"`<br/>}</span></pre><p id="708f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注册功能的代码</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="c2b2" class="ki kj hi ke b fi kk kl l km kn">package main<br/><br/>import (<br/>   ...<br/>)<br/><br/>func handler(request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {<br/>   ....<br/>}<br/></span><span id="fcaf" class="ki kj hi ke b fi lm kl l km kn">....</span><span id="269a" class="ki kj hi ke b fi lm kl l km kn">func main() {<br/>   lambda.Start(handler)<br/>}</span></pre><p id="2c65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">源代码很长，我想描述一下这些程序块的一些部分。</p><p id="b8ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下部分用于将请求正文解组到我的注册请求。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="5444" class="ki kj hi ke b fi kk kl l km kn">var signupRequest SignupRequest<br/>jsonErr := json.Unmarshal([]byte(request.Body), &amp;signupRequest)<br/>if jsonErr != nil {<br/>   body := model.ResponseBody{}<br/>   body.Message = errormessage.StatusText(errormessage.JsonParseError)<br/>   return events.APIGatewayProxyResponse{<br/>      StatusCode: http.StatusBadRequest,<br/>      Body:       body.ConvertToJson(),<br/>   }, nil<br/>}</span></pre><p id="13c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了一个错误消息文件，将所有错误消息保存在一个特定的文件中。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="a187" class="ki kj hi ke b fi kk kl l km kn">package errormessage<br/><br/>const (<br/>   Ok                      = 99<br/>   DatabaseError           = 100<br/>   JsonParseError          = 101<br/>   UserAlreadyExist        = 102<br/>   UserNameOrPasswordWrong = 103<br/>   CaptchaNeeded           = 104<br/>   TokenIsNotValid         = 105<br/>)<br/><br/>var statusText = map[int]string{<br/>   DatabaseError:           "DATABASE_ERROR",<br/>   JsonParseError:          "JSON_PARSE_ERROR",<br/>   UserAlreadyExist:        "USER_ALREADY_EXIST",<br/>   UserNameOrPasswordWrong: "USERNAME_OR_PASSWORD_WRONG",<br/>   Ok:                      "OK",<br/>   CaptchaNeeded:           "CAPTCHA_NEEDED",<br/>   TokenIsNotValid:         "TOKEN_IS_NOT_VALID",<br/>}<br/><br/>func StatusText(code int) string {<br/>   return statusText[code]<br/>}</span></pre><p id="af1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将请求体解析到我的模型后，我需要验证必填字段。我为Golang使用了一个开源的<a class="ae ln" href="https://github.com/go-playground/validator/tree/v9.30.0" rel="noopener ugc nofollow" target="_blank">验证器</a>。下面的代码块显示了如何验证输入。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="dd13" class="ki kj hi ke b fi kk kl l km kn">v := validator.New()<br/>validateErr := v.Struct(signupRequest)<br/><br/>if validateErr != nil {<br/>   body := model.ResponseBody{}<br/>   body.Message = errormessage.StatusText(errormessage.JsonParseError)<br/>   return events.APIGatewayProxyResponse{<br/>      StatusCode: http.StatusBadRequest,<br/>      Body:       body.ConvertToJson(),<br/>   }, nil<br/>}</span></pre><p id="191d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的注册请求中有一个声明</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="7014" class="ki kj hi ke b fi kk kl l km kn">`validate:"required,email"`</span></pre><p id="6221" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说明该字段是必需的，并且其类型是电子邮件。</p><p id="bc22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">验证输入后，如果没有创建新用户，我们需要检查用户是否存在。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="9d5e" class="ki kj hi ke b fi kk kl l km kn">postgresConnector := database.PostgresConnector{}<br/>dbConn, dbErr := postgresConnector.GetConnection()<br/>defer dbConn.Close()<br/>if dbErr != nil {<br/>   fmt.Print(dbErr)<br/>   return events.APIGatewayProxyResponse{<br/>      StatusCode: http.StatusInternalServerError,<br/>      Body:       "",<br/>   }, nil<br/>}<br/>dbConn.AutoMigrate(&amp;entity.User{})<br/><br/>var users []entity.User<br/>filter := &amp;entity.User{}<br/>filter.Email = signupRequest.Email<br/>dbConn.Where(filter).Find(&amp;users)<br/><br/>if users != nil &amp;&amp; len(users) &gt; 0 {<br/>   body := model.ResponseBody{}<br/>   body.Message = errormessage.StatusText(errormessage.UserAlreadyExist)<br/>   return events.APIGatewayProxyResponse{<br/>      StatusCode: http.StatusBadRequest,<br/>      Body:       body.ConvertToJson(),<br/>   }, nil<br/>}<br/><br/>newUser := &amp;entity.User{}<br/>newUser.Email = signupRequest.Email<br/>newUser.Password = hashAndSalt(signupRequest.Password)<br/>dbConn.Create(&amp;newUser)</span></pre><p id="5fbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于安全原因，您必须保持密码散列。我的哈希函数:</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="f4e7" class="ki kj hi ke b fi kk kl l km kn">func hashAndSalt(pwd string) (hashed string) {<br/>   hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.DefaultCost)<br/>   if err != nil {<br/>      log.Println(err)<br/>   }<br/><br/>   return string(hash)<br/>}</span></pre><p id="a427" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注册的编码部分已经准备好了。让我们转到makefile和template.yaml</p><p id="ac4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Makefile </strong></p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="63ea" class="ki kj hi ke b fi kk kl l km kn">.PHONY: clean build<br/><br/>clean: <br/>   rm -rf ./bin/signup/signupl<br/><br/>build:<br/>   GOOS=linux GOARCH=amd64 go build -o bin/signup/signup ./functions/signup</span></pre><p id="a6ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Template.yaml </strong></p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="41da" class="ki kj hi ke b fi kk kl l km kn">AWSTemplateFormatVersion: '2010-09-09'<br/>Transform: AWS::Serverless-2016-10-31<br/>Description: &gt;<br/>  serverlessExample<br/><br/>  Sample SAM Template for serverlessExample<br/><br/><em class="lo"># More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst<br/></em>Globals:<br/>  Function:<br/>    Timeout: 5<br/><br/>Parameters:<br/>  dbname:<br/>    Type: String<br/>    Default: example<br/>  username:<br/>    Type: String<br/>    Default: postgres<br/>  password:<br/>    Type: String<br/>    Default: password<br/>  host:<br/>    Type: String<br/>    Default: localhost<br/><br/>Resources:<br/>  SignupFunction:<br/>    Type: AWS::Serverless::Function <em class="lo"># More info about Function Resource: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction<br/>    </em>Properties:<br/>      CodeUri: bin/signup<br/>      Handler: signup<br/>      Runtime: go1.x<br/>      Tracing: Active <em class="lo"># https://docs.aws.amazon.com/lambda/latest/dg/lambda-x-ray.html<br/>      </em>Events:<br/>        Signup:<br/>          Type: Api <em class="lo"># More info about API Event Source: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#api<br/>          </em>Properties:<br/>            Path: /signup<br/>            Method: POST<br/>      Environment: <em class="lo"># More info about Env Vars: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#environment-object<br/>        </em>Variables:<br/>          db_user: !Ref username<br/>          db_pass: !Ref password<br/>          db_name: !Ref dbname<br/>          db_host: !Ref host<br/>Outputs:<br/>  ApiURL:<br/>    Description: "API URL"<br/>    Value: !Sub 'https://${ExampleApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/'</span></pre><p id="6046" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的模板自动创建一个lambda函数及其角色，命令如下。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="2989" class="ki kj hi ke b fi kk kl l km kn">$make clean build<br/>$sam package --template-file template.yaml --s3-bucket YOURS3BUCKETNAME --output-template-file packaged.yaml<br/>$aws cloudformation deploy --template-file PATH/packaged.yaml --stack-name serverlessexample --capabilities CAPABILITY_IAM --parameter-overrides dbname=AA username=BB password=CC host=DD</span></pre><p id="db21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">技巧&amp;招数</strong></p><p id="9c51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署期间出现错误，您可以在CloudFormation事件中查看详细信息。</p><p id="07e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在AWS控制台或本地进行测试。</p><p id="3aa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">登录功能</strong></p><p id="cb7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">登录功能将比注册功能更复杂。由于授权的要求，也在一些错误的入口之后，我们的程序需要验证码。为简单起见，验证码目前只与用户id相关。但是你可以改进这个逻辑。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ll"><img src="../Images/37cb9dee95b4fb0989c1e366ec2c3848.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*YDcPrV7HqdiilLfPAQawFw.png"/></div></figure><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="5c38" class="ki kj hi ke b fi kk kl l km kn">package main<br/><br/>type LoginRequest struct {<br/>   Email           string `validate:"required,email"`<br/>   Password        string `validate:"required"`<br/>   CaptchaId       string<br/>   CaptchaResponse string<br/>}</span><span id="57a8" class="ki kj hi ke b fi lm kl l km kn">type LoginResponse struct {<br/>   AccessToken  string<br/>   RefreshToken string<br/>}</span></pre><p id="1f3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与注册功能一样，登录功能也从解析和验证开始。所以我跳过这些部分。然后检查用户名和密码。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="ac9f" class="ki kj hi ke b fi kk kl l km kn">if user.LoginTry &gt;= 5 &amp;&amp; !validateCaptcha(loginRequest) {<br/>   body := model.ResponseBody{}<br/>   body.Message = errormessage.StatusText(errormessage.CaptchaNeeded)<br/>   response := events.APIGatewayProxyResponse{<br/>      StatusCode: http.StatusUnauthorized,<br/>      Body:       body.ConvertToJson(),<br/>   }<br/>   return createApiLoginFailResponse(response, user, dbConn)<br/>}<br/><br/>passwordErr := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(loginRequest.Password))<br/><br/>if passwordErr != nil {<br/>   body := model.ResponseBody{}<br/>   body.Message = errormessage.StatusText(errormessage.UserNameOrPasswordWrong)<br/>   response := events.APIGatewayProxyResponse{<br/>      StatusCode: http.StatusUnauthorized,<br/>      Body:       body.ConvertToJson(),<br/>   }<br/>   return createApiLoginFailResponse(response, user, dbConn)<br/>}</span></pre><p id="f99e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果不成功的登录计数大于等于5，则出现需要验证码的错误。我将在下面描述创建和验证验证码。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="2d13" class="ki kj hi ke b fi kk kl l km kn">func createApiLoginFailResponse(response events.APIGatewayProxyResponse, user entity.User, dbConn *gorm.DB) (events.APIGatewayProxyResponse, error) {<br/>   if user.ID &gt; 0 {<br/>      user.LoginTry = user.LoginTry + 1<br/>      dbConn.Save(user)<br/>      if user.LoginTry &gt;= 5 {<br/>         body := model.ResponseBody{}<br/>         body.Message = errormessage.StatusText(errormessage.CaptchaNeeded)<br/>         return events.APIGatewayProxyResponse{<br/>            StatusCode: http.StatusUnauthorized,<br/>            Body:       body.ConvertToJson(),<br/>         }, nil<br/>      } else {<br/>         return response, nil<br/>      }<br/>   } else {<br/>      return response, nil<br/>   }<br/>}</span></pre><p id="0fff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果用户名和密码正确，将生成访问和刷新令牌。github.com/dgrijalva/jwt-go用于智威汤逊的<a class="ae ln" href="http://github.com/dgrijalva/jwt-go" rel="noopener ugc nofollow" target="_blank">作战。</a></p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="d51e" class="ki kj hi ke b fi kk kl l km kn">func CreateTokens(user entity.User) (model.TokenSet, error) {<br/>   accessTokenExpireAt := time.Now().Add(1 * time.Hour)<br/>   tokenStr, signErr := CreateToken(user, "Access", accessTokenExpireAt)<br/><br/>   if signErr != nil {<br/>      return model.TokenSet{}, signErr<br/>   }<br/><br/>   refreshTokenExpireAt := time.Now().Add(24 * time.Hour)<br/>   refreshTokenStr, signErr := CreateToken(user, "Refresh", refreshTokenExpireAt)<br/><br/>   if signErr != nil {<br/>      return model.TokenSet{}, signErr<br/>   }<br/>   return model.TokenSet{AccessToken: tokenStr, ExpireAt: accessTokenExpireAt, RefreshToken: refreshTokenStr, RefreshExpireAt: refreshTokenExpireAt}, nil<br/>}<br/><br/>func ValidateToken(token string) (*jwt.Token, error) {<br/><br/>   return jwt.ParseWithClaims(token, &amp;model.CustomClaims{}, func(token *jwt.Token) (interface{}, error) {<br/>      return []byte(os.Getenv("jwt_key")), nil<br/>   })<br/>}<br/><br/>func CreateToken(user entity.User, tokenType string, expireTime time.Time) (string, error) {<br/>   var claim model.CustomClaims<br/>   claim.Id = string(user.ID)<br/>   claim.Type = tokenType<br/>   expiresAt := expireTime<br/>   claim.ExpiresAt = expiresAt.Unix()<br/>   token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)<br/>   jwtKey := os.Getenv("jwt_key")<br/>   tokenStr, signErr := token.SignedString([]byte(jwtKey))<br/>   return tokenStr, signErr<br/>}</span></pre><p id="4bc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">访问令牌的有效期为1小时。刷新令牌的有效期为24小时。</p><p id="1908" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在签署jwt令牌时，本库给你一个标准声明。但是我需要一个字段类型来理解token的类型。所以我在下面写了一个自定义令牌。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="f22d" class="ki kj hi ke b fi kk kl l km kn">package model<br/><br/>import "github.com/dgrijalva/jwt-go"<br/><br/>type CustomClaims struct {<br/>   jwt.StandardClaims<br/>   Type string<br/>}</span></pre><p id="d0c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">成功登录后，API向用户返回访问和刷新令牌。</p><p id="f5af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">创建和验证验证码</strong></p><p id="a8af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ln" href="http://github.com/dchest/captcha" rel="noopener ugc nofollow" target="_blank">github.com/dchest/captcha</a>用于验证码操作。</p><p id="961c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们的无服务器函数在执行后会被杀死。所以你需要把验证码放在缓存里。这个库支持自定义存储，但是你需要花一些时间来开发。</p><p id="784e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自定义商店代码:</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="d0e6" class="ki kj hi ke b fi kk kl l km kn">package common<br/><br/>import (<br/>   "fmt"<br/>   "github.com/go-redis/redis"<br/>   "log"<br/>   "os"<br/>   "time"<br/>)<br/><br/>type CustomizeRdsStore struct {<br/>   RedisClient *redis.Client<br/>   ExpireAt    time.Duration<br/>}<br/><br/><br/>func GetStore() *CustomizeRdsStore {<br/>   return NewStore(time.Duration(1 * time.Hour))<br/>}<br/><br/>func NewStore(expireAt time.Duration) *CustomizeRdsStore {<br/>   client := redis.NewClient(&amp;redis.Options{<br/>      Addr:     os.Getenv("redis_url"),<br/>      Password: "", <em class="lo">// no password set<br/>      </em>DB:       0,  <em class="lo">// use default DB<br/>   </em>})<br/><br/>   c := new(CustomizeRdsStore)<br/>   c.RedisClient = client<br/>   c.ExpireAt = expireAt<br/>   return c<br/>}<br/><br/>func (s CustomizeRdsStore) SetWithOverrideExpire(id string, value string, expireAt time.Duration) {<br/>   err := s.RedisClient.Set(id, value, expireAt).Err()<br/>   if err != nil {<br/>      log.Println(err)<br/>   }<br/>}<br/><br/>func (s CustomizeRdsStore) SetWithoutExpire(id string, value string) {<br/>   err := s.RedisClient.Set(id, value, 0).Err()<br/>   if err != nil {<br/>      log.Println(err)<br/>   }<br/>}<br/><br/><em class="lo">// customizeRdsStore implementing Set method of  Store interface<br/></em>func (s CustomizeRdsStore) Set(id string, value []byte) {<br/>   err := s.RedisClient.Set(id, string(value), s.ExpireAt).Err()<br/>   if err != nil {<br/>      log.Println(err)<br/>   }<br/>}<br/><br/><em class="lo">// customizeRdsStore implementing Get method of  Store interface<br/></em>func (s CustomizeRdsStore) Get(id string, clear bool) (value []byte) {<br/>   val, err := s.RedisClient.Get(id).Result()<br/>   if err != nil {<br/>      log.Println(err)<br/>      return []byte{}<br/>   }<br/>   if clear {<br/>      err := s.RedisClient.Del(id).Err()<br/>      if err != nil {<br/>         log.Println(err)<br/>         return []byte{}<br/>      }<br/>   }<br/>   return []byte(val)<br/>}</span></pre><p id="0ccb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">func (s CustomizeRdsStore)集(id字符串，值[]字节)和</p><p id="fa77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">func (s CustomizeRdsStore) Get(id字符串，clear bool)</p><p id="cfd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是为商店接口实现的。其他函数是我的助手函数。</p><p id="aab2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建验证码:</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="fac1" class="ki kj hi ke b fi kk kl l km kn">package main<br/><br/>import (<br/>   "bytes"<br/>   "encoding/base64"<br/>   "github.com/aws/aws-lambda-go/events"<br/>   "github.com/aws/aws-lambda-go/lambda"<br/>   "github.com/dchest/captcha"<br/>   "github.com/yunuskilicdev/serverlessNear/common"<br/>   "github.com/yunuskilicdev/serverlessNear/common/errormessage"<br/>   "github.com/yunuskilicdev/serverlessNear/common/model"<br/>   "net/http"<br/>   "time"<br/>)<br/><br/>func handler(request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {<br/><br/>   store := common.NewStore(time.Duration(5 * time.Minute))<br/>   captcha.SetCustomStore(store)<br/><br/>   captchaResponse := model.CaptchaResponse{}<br/>   captchaId := captcha.New()<br/><br/>   var ImageBuffer bytes.Buffer<br/>   captcha.WriteImage(&amp;ImageBuffer, captchaId, 300, 90)<br/><br/>   captchaResponse.Id = captchaId<br/>   captchaResponse.Image = base64.StdEncoding.EncodeToString(ImageBuffer.Bytes())<br/><br/>   body := model.ResponseBody{}<br/>   body.Message = errormessage.StatusText(errormessage.Ok)<br/>   body.ResponseObject = captchaResponse<br/>   return events.APIGatewayProxyResponse{<br/>      Body:       body.ConvertToJson(),<br/>      StatusCode: http.StatusOK,<br/>   }, nil<br/>}<br/><br/>func main() {<br/>   lambda.Start(handler)<br/>}</span></pre><p id="a2b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">验证码验证将在登录功能内操作。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="2843" class="ki kj hi ke b fi kk kl l km kn">func validateCaptcha(request LoginRequest) bool {<br/>   if request.CaptchaId == "" || request.CaptchaResponse == "" {<br/>      return false<br/>   }<br/>   store := common.GetStore()<br/>   captcha.SetCustomStore(store)<br/>   return captcha.VerifyString(request.CaptchaId, request.CaptchaResponse)<br/>}</span></pre><p id="bf99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在makefile和template.yaml中添加登录功能，与注册相同。</p><p id="b44f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的API返回访问令牌，因此我们可以向我们的API添加授权。</p><p id="8bcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">授权</strong></p><p id="06b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ln" href="https://github.com/aws/aws-lambda-go/blob/master/events/README_ApiGatewayCustomAuthorizer.md" rel="noopener ugc nofollow" target="_blank"> Aws Lambda Go有一个示例自定义auth函数</a>。我重构了这段代码来检查JWT令牌。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="0211" class="ki kj hi ke b fi kk kl l km kn">package main<br/><br/>import (<br/>   "context"<br/>   "errors"<br/>   "github.com/aws/aws-lambda-go/events"<br/>   "github.com/aws/aws-lambda-go/lambda"<br/>   "github.com/yunuskilicdev/serverlessExample/common"<br/>)<br/><br/><em class="lo">// Help function to generate an IAM policy<br/></em>func generatePolicy(principalId, effect, resource string) events.APIGatewayCustomAuthorizerResponse {<br/>   authResponse := events.APIGatewayCustomAuthorizerResponse{PrincipalID: principalId}<br/><br/>   if effect != "" &amp;&amp; resource != "" {<br/>      authResponse.PolicyDocument = events.APIGatewayCustomAuthorizerPolicy{<br/>         Version: "2012-10-17",<br/>         Statement: []events.IAMPolicyStatement{<br/>            {<br/>               Action:   []string{"execute-api:Invoke"},<br/>               Effect:   effect,<br/>               Resource: []string{resource},<br/>            },<br/>         },<br/>      }<br/>   }<br/><br/>   <em class="lo">// Optional output with custom properties of the String, Number or Boolean type.<br/>   </em>authResponse.Context = map[string]interface{}{<br/>      "stringKey":  "stringval",<br/>      "numberKey":  123,<br/>      "booleanKey": true,<br/>   }<br/>   return authResponse<br/>}<br/><br/>func handleRequest(ctx context.Context, event events.APIGatewayCustomAuthorizerRequest) (events.APIGatewayCustomAuthorizerResponse, error) {<br/>   token := event.AuthorizationToken<br/>   parse, e := common.ValidateToken(token)<br/>   if e != nil || !parse.Valid {<br/>      return events.APIGatewayCustomAuthorizerResponse{}, errors.New("Unauthorized")<br/>   }<br/>   return generatePolicy("user", "Allow", event.MethodArn), nil<br/>}<br/><br/>func main() {<br/>   lambda.Start(handleRequest)<br/>}</span></pre><p id="d885" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要在template.yaml中添加一个API和函数</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="8dfd" class="ki kj hi ke b fi kk kl l km kn">ExampleApi:<br/>  Type: AWS::Serverless::Api<br/>  Properties:<br/>    StageName: Prod<br/>    Auth:<br/>      DefaultAuthorizer: MyLambdaTokenAuthorizer<br/>      Authorizers:<br/>        MyLambdaTokenAuthorizer:<br/>          FunctionArn: !GetAtt CustomAuthorizerFunction.Arn<br/>CustomAuthorizerFunction:<br/>  Type: AWS::Serverless::Function<br/>  Properties:<br/>    CodeUri: bin/authorizer<br/>    Handler: authorizer<br/>    Runtime: go1.x<br/>    Environment: <em class="lo"><br/>      </em>Variables:<br/>        db_user: !Ref username<br/>        db_pass: !Ref password<br/>        db_name: !Ref dbname<br/>        db_host: !Ref host<br/>        jwt_key: !Ref jwt<br/>        redis_url: !Ref redisurl</span></pre><p id="49ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注册功能不需要访问令牌。所以你需要声明注册函数没有如下的auth。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="d23e" class="ki kj hi ke b fi kk kl l km kn">SignupFunction:<br/>  Type: AWS::Serverless::Function<em class="lo"><br/>  </em>Properties:<br/>    CodeUri: bin/signup<br/>    Handler: signup<br/>    Runtime: go1.x<br/>    Tracing: Active <em class="lo"><br/>    </em>Events:<br/>      Signup:<br/>        Type: Api <em class="lo"><br/>        </em>Properties:<br/>          <strong class="ke hj">RestApiId: !Ref ExampleApi<br/>          Auth:<br/>            Authorizer: 'NONE'</strong><br/>          Path: /signup<br/>          Method: POST<br/>    Environment: <em class="lo"><br/>      </em>Variables:<br/>        db_user: !Ref username<br/>        db_pass: !Ref password<br/>        db_name: !Ref dbname<br/>        db_host: !Ref host<br/>        jwt_key: !Ref jwt</span></pre><p id="4357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用户信息功能</strong></p><p id="55b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">访问用户信息需要访问令牌。所以我创建了一个userinfo函数来演示auth函数的工作。</p><p id="d35c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">小技巧&amp;绝招</strong></p><p id="58a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您在本地启动您的功能时，Auth不起作用。</p><p id="8293" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用户信息功能</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="c9d7" class="ki kj hi ke b fi kk kl l km kn">package main<br/><br/>import (<br/>   "encoding/binary"<br/>   "github.com/aws/aws-lambda-go/events"<br/>   "github.com/aws/aws-lambda-go/lambda"<br/>   "github.com/yunuskilicdev/serverlessExample/common"<br/>   "github.com/yunuskilicdev/serverlessExample/common/errormessage"<br/>   "github.com/yunuskilicdev/serverlessExample/common/model"<br/>   "github.com/yunuskilicdev/serverlessExample/database"<br/>   "github.com/yunuskilicdev/serverlessExample/database/entity"<br/>   "net/http"<br/>)<br/><br/>func handler(request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {<br/><br/>   token := request.Headers["Authorization"]<br/>   userId := common.GetStore().Get(token, false)<br/><br/>   postgresConnector := database.PostgresConnector{}<br/>   dbConn, dbErr := postgresConnector.GetConnection()<br/>   defer dbConn.Close()<br/>   if dbErr != nil {<br/>      body := model.ResponseBody{}<br/>      body.Message = errormessage.StatusText(errormessage.DatabaseError)<br/>      response := events.APIGatewayProxyResponse{<br/>         StatusCode: http.StatusInternalServerError,<br/>         Body:       body.ConvertToJson(),<br/>      }<br/>      return response, nil<br/>   }<br/><br/>   var userFilter entity.User<br/>   u, _ := binary.Uvarint(userId)<br/>   userFilter.ID = uint(u)<br/>   var user entity.User<br/>   dbConn.Where(userFilter).Find(&amp;user)<br/><br/>   body := model.ResponseBody{}<br/>   body.Message = errormessage.StatusText(errormessage.Ok)<br/>   body.ResponseObject = user<br/>   return events.APIGatewayProxyResponse{<br/>      Body:       body.ConvertToJson(),<br/>      StatusCode: http.StatusOK,<br/>   }, nil<br/>}<br/><br/>func main() {<br/>   lambda.Start(handler)<br/>}</span></pre><p id="caca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">发送验证邮件</strong></p><p id="15d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注册后，我想给用户发送一封电子邮件来验证他们的电子邮件。发送电子邮件可以由异步处理。所以我将使用AWS简单队列服务来编写发送邮件请求。然后另一个lambda函数从队列中读取并完成发送电子邮件。</p><p id="9285" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提示&amp;招数</strong></p><p id="fa97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您第一次将功能部署到AWS时，将触发角色创建。为了写SQS，你需要这个角色的许可。</p><ul class=""><li id="af41" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">接收消息</li><li id="6dfb" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">删除邮件</li><li id="464e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">GetQueueAttributes</li><li id="8991" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">发送消息</li></ul><p id="1920" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码内部注册功能将被添加</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="6af9" class="ki kj hi ke b fi kk kl l km kn">store := common.GetStore()<br/>expireAt := time.Now().Add(1 * time.Hour)<br/>token, jsonErr := common.CreateToken(*newUser, "Mail", expireAt)<br/>store.SetWithOverrideExpire(token, string(newUser.ID), expireAt.Sub(time.Now()))<br/><br/>var mailRequest model.SendVerificationMailRequest<br/>mailRequest.UserId = newUser.ID<br/>mailRequest.Token = token<br/>mailRequest.Email = newUser.Email<br/>emailJsonData, _ := json.Marshal(mailRequest)<br/>s := string(emailJsonData)<br/>u := string(os.Getenv("email_queue_url"))<br/><br/>sess, err := session.NewSession(&amp;aws.Config{<br/>   Region: aws.String("eu-west-1")},<br/>)<br/>if err != nil {<br/>   fmt.Println(err)<br/>}<br/>sqsClient := sqs.New(sess)<br/>sqsClient.ServiceName = os.Getenv("email_queue")<br/>input := sqs.SendMessageInput{<br/>   MessageBody: &amp;s,<br/>   QueueUrl:    &amp;u,<br/>}<br/>_, jsonErr = sqsClient.SendMessage(&amp;input)<br/>if jsonErr != nil {<br/>   fmt.Println(jsonErr)<br/>}</span></pre><p id="86b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">email_queue和email_queue_url参数将用于发送消息。</p><p id="3302" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以您需要将这些添加到template.yaml中</p><p id="b360" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">邮件发送者功能</strong></p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="c58c" class="ki kj hi ke b fi kk kl l km kn">package main<br/><br/>import (<br/>   "context"<br/>   "encoding/json"<br/>   "fmt"<br/>   "github.com/aws/aws-lambda-go/events"<br/>   "github.com/aws/aws-lambda-go/lambda"<br/>   "github.com/yunuskilicdev/serverlessExample/common"<br/>   "github.com/yunuskilicdev/serverlessExample/common/model"<br/>)<br/><br/>const (<br/>   <em class="lo">// Replace sender@example.com with your "From" address.<br/>   // This address must be verified with Amazon SES.<br/>   </em>Sender = "a@gmail.com"<br/><br/>   <em class="lo">// Replace recipient@example.com with a "To" address. If your account<br/>   // is still in the sandbox, this address must be verified.<br/>   </em>Recipient = "b@gmail.com"<br/><br/>   <em class="lo">// Specify a configuration set. To use a configuration<br/>   // set, comment the next line and line 92.<br/>   //ConfigurationSet = "ConfigSet"<br/><br/>   // The subject line for the email.<br/>   </em>Subject = "Amazon SES Test (AWS SDK for Go)"<br/><br/>   <em class="lo">// The HTML body for the email.<br/>   </em>HtmlBody = "&lt;h1&gt;Amazon SES Test Email (AWS SDK for Go)&lt;/h1&gt;&lt;p&gt;This email was sent with " +<br/>      "&lt;a href='https://aws.amazon.com/ses/'&gt;Amazon SES&lt;/a&gt; using the " +<br/>      "&lt;a href='https://aws.amazon.com/sdk-for-go/'&gt;AWS SDK for Go&lt;/a&gt;.&lt;/p&gt;"<br/><br/>   <em class="lo">//The email body for recipients with non-HTML email clients.<br/>   </em>TextBody = "This email was sent with Amazon SES using the AWS SDK for Go."<br/><br/>   <em class="lo">// The character encoding for the email.<br/>   </em>CharSet = "UTF-8"<br/>)<br/><br/>func handler(ctx context.Context, sqsEvent events.SQSEvent) error {<br/>   for _, message := range sqsEvent.Records {<br/>      fmt.Printf("The message %s for event source %s = %s \n", message.MessageId, message.EventSource, message.Body)<br/>      var request model.SendVerificationMailRequest<br/>      json.Unmarshal([]byte(message.Body), &amp;request)<br/>      common.SendMail(request.Token)<br/>   }<br/><br/>   return nil<br/>}<br/><br/>func main() {<br/>   lambda.Start(handler)<br/>}</span></pre><p id="3fe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个功能和其他的不一样。因为这个功能会被SQS触发。所以它的模板yaml配置也不一样。</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="6f17" class="ki kj hi ke b fi kk kl l km kn">SendMailFunction:<br/>  Type: AWS::Serverless::Function <em class="lo"># More info about Function Resource: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction<br/>  </em>Properties:<br/>    CodeUri: bin/sendemail<br/>    Handler: sendemail<br/>    Runtime: go1.x<br/>    Tracing: Active <em class="lo"># https://docs.aws.amazon.com/lambda/latest/dg/lambda-x-ray.html<br/>    </em>Events:<br/>      UserInfo:<br/>        Type: SQS <em class="lo"># More info about API Event Source: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#api<br/>        </em>Properties:<br/>          Queue: !Ref emailQueue <em class="lo"># NOTE: FIFO SQS Queues are not yet supported<br/>          </em>BatchSize: 10<br/>          Enabled: false<br/>    Environment: <em class="lo"># More info about Env Vars: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#environment-object<br/>      </em>Variables:<br/>        db_user: !Ref username<br/>        db_pass: !Ref password<br/>        db_name: !Ref dbname<br/>        db_host: !Ref host<br/>        jwt_key: !Ref jwt<br/>        redis_url: !Ref redisurl<br/>        email_queue: !Ref emailQueue<br/>        email_queue_url: !Ref emailQueueUrl<br/>        prod_link: !Sub 'https://${ExampleApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/'</span></pre><p id="be66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">常用发送邮件功能</p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="7b92" class="ki kj hi ke b fi kk kl l km kn">package common<br/><br/>import (<br/>   "fmt"<br/>   "github.com/aws/aws-sdk-go/aws"<br/>   "github.com/aws/aws-sdk-go/aws/awserr"<br/>   "github.com/aws/aws-sdk-go/aws/session"<br/>   "github.com/aws/aws-sdk-go/service/ses"<br/>   "os"<br/>)<br/><br/>const (<br/>   <em class="lo">// Replace sender@example.com with your "From" address.<br/>   // This address must be verified with Amazon SES.<br/>   </em>Sender = "a@gmail.com"<br/><br/>   <em class="lo">// Replace recipient@example.com with a "To" address. If your account<br/>   // is still in the sandbox, this address must be verified.<br/>   </em>Recipient = "b@gmail.com"<br/><br/>   <em class="lo">// Specify a configuration set. To use a configuration<br/>   // set, comment the next line and line 92.<br/>   //ConfigurationSet = "ConfigSet"<br/><br/>   // The subject line for the email.<br/>   </em>Subject = "Please verify your mail"<br/><br/>   <em class="lo">// The HTML body for the email.<br/>   </em>HtmlBody = "&lt;h1&gt;Email verification mail&lt;/h1&gt;&lt;p&gt;" +<br/>      "&lt;a href='%s'&gt;Amazon SES&lt;/a&gt;"<br/><br/>   <em class="lo">//The email body for recipients with non-HTML email clients.<br/>   </em>TextBody = "This email was sent to verify your mail"<br/><br/>   <em class="lo">// The character encoding for the email.<br/>   </em>CharSet = "UTF-8"<br/>)<br/><br/>func SendMail(token string) {<br/>   sess, err := session.NewSession(&amp;aws.Config{<br/>      Region: aws.String("eu-west-1")},<br/>   )<br/><br/>   if err != nil {<br/>      fmt.Println(err)<br/>   }<br/><br/>   <em class="lo">// Create an SES session.<br/>   </em>svc := ses.New(sess)<br/><br/>   verifyLink := os.Getenv("prod_link") + "verifyemail?token=" + token<br/><br/>   <em class="lo">// Assemble the email.<br/>   </em>input := &amp;ses.SendEmailInput{<br/>      Destination: &amp;ses.Destination{<br/>         CcAddresses: []*string{},<br/>         ToAddresses: []*string{<br/>            aws.String(Recipient),<br/>         },<br/>      },<br/>      Message: &amp;ses.Message{<br/>         Body: &amp;ses.Body{<br/>            Html: &amp;ses.Content{<br/>               Charset: aws.String(CharSet),<br/>               Data:    aws.String(fmt.Sprintf(HtmlBody, verifyLink)),<br/>            },<br/>            Text: &amp;ses.Content{<br/>               Charset: aws.String(CharSet),<br/>               Data:    aws.String(TextBody),<br/>            },<br/>         },<br/>         Subject: &amp;ses.Content{<br/>            Charset: aws.String(CharSet),<br/>            Data:    aws.String(Subject),<br/>         },<br/>      },<br/>      Source: aws.String(Sender),<br/>      <em class="lo">// Uncomment to use a configuration set<br/>      //ConfigurationSetName: aws.String(ConfigurationSet),<br/>   </em>}<br/><br/>   <em class="lo">// Attempt to send the email.<br/>   </em>result, err := svc.SendEmail(input)<br/><br/>   <em class="lo">// Display error messages if they occur.<br/>   </em>if err != nil {<br/>      if aerr, ok := err.(awserr.Error); ok {<br/>         switch aerr.Code() {<br/>         case ses.ErrCodeMessageRejected:<br/>            fmt.Println(ses.ErrCodeMessageRejected, aerr.Error())<br/>         case ses.ErrCodeMailFromDomainNotVerifiedException:<br/>            fmt.Println(ses.ErrCodeMailFromDomainNotVerifiedException, aerr.Error())<br/>         case ses.ErrCodeConfigurationSetDoesNotExistException:<br/>            fmt.Println(ses.ErrCodeConfigurationSetDoesNotExistException, aerr.Error())<br/>         default:<br/>            fmt.Println(aerr.Error())<br/>         }<br/>      } else {<br/>         <em class="lo">// Print the error, cast err to awserr.Error to get the Code and<br/>         // Message from an error.<br/>         </em>fmt.Println(err.Error())<br/>      }<br/><br/>      return<br/>   }<br/><br/>   fmt.Println("Email Sent to address: " + Recipient)<br/>   fmt.Println(result)<br/>}</span></pre><p id="1552" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">招数&amp;招数</strong></p><p id="9eba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您需要添加AmazonSESFullAccess策略来发送电子邮件功能的角色。</p><p id="8bd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">技巧&amp;招数</strong></p><p id="d343" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您需要在AWS控制台验证发件人邮件地址。</p><p id="2cea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">验证邮件功能</strong></p><pre class="js jt ju jv fd kd ke kf kg aw kh bi"><span id="f0db" class="ki kj hi ke b fi kk kl l km kn">package main<br/><br/>import (<br/>   "encoding/binary"<br/>   "fmt"<br/>   "github.com/aws/aws-lambda-go/events"<br/>   "github.com/aws/aws-lambda-go/lambda"<br/>   "github.com/yunuskilicdev/serverlessExample/common"<br/>   "github.com/yunuskilicdev/serverlessExample/common/errormessage"<br/>   "github.com/yunuskilicdev/serverlessExample/common/model"<br/>   "github.com/yunuskilicdev/serverlessExample/database"<br/>   "github.com/yunuskilicdev/serverlessExample/database/entity"<br/>   "net/http"<br/>)<br/><br/>func handler(request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {<br/><br/>   token := request.QueryStringParameters["token"]<br/>   validateToken, err := common.ValidateToken(token)<br/>   if err != nil {<br/>      fmt.Println(err)<br/>   }<br/>   claims := validateToken.Claims.(*model.CustomClaims)<br/>   if validateToken.Valid &amp;&amp; claims.Type == "Mail" {<br/>      store := common.GetStore()<br/>      value := store.Get(token, true)<br/>      var userFilter entity.User<br/>      u, _ := binary.Uvarint(value)<br/>      userFilter.ID = uint(u)<br/>      postgresConnector := database.PostgresConnector{}<br/>      dbConn, dbErr := postgresConnector.GetConnection()<br/>      defer dbConn.Close()<br/>      if dbErr != nil {<br/>         fmt.Print(dbErr)<br/>         return events.APIGatewayProxyResponse{<br/>            StatusCode: http.StatusInternalServerError,<br/>            Body:       "",<br/>         }, nil<br/>      }<br/>      var user entity.User<br/>      dbConn.Where(userFilter).Find(&amp;user)<br/>      user.EmailVerified = true<br/>      dbConn.Save(&amp;user)<br/>      body := model.ResponseBody{}<br/>      body.Message = errormessage.StatusText(errormessage.Ok)<br/>      body.ResponseObject = user<br/>      return events.APIGatewayProxyResponse{<br/>         Body:       body.ConvertToJson(),<br/>         StatusCode: http.StatusOK,<br/>      }, nil<br/>   }<br/><br/>   body := model.ResponseBody{}<br/>   body.Message = errormessage.StatusText(errormessage.TokenIsNotValid)<br/>   body.ResponseObject = nil<br/>   return events.APIGatewayProxyResponse{<br/>      Body:       body.ConvertToJson(),<br/>      StatusCode: http.StatusBadRequest,<br/>   }, nil<br/><br/>}<br/><br/>func main() {<br/>   lambda.Start(handler)<br/>}</span></pre><p id="5bb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以所有功能都准备好了:)</p><p id="21c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">技巧&amp;招数</strong></p><p id="0bfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我使用elastic cache进行缓存时，与elastic cache的连接非常长。所以我更喜欢使用安装在EC2实例上的Redis。如果您的函数和EC2在同一个VPC安全组中，则您的函数可以访问EC2例程。</p><p id="74a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Github </strong></p><p id="07af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ln" href="https://github.com/yunuskilicdev/serverlessExample" rel="noopener ugc nofollow" target="_blank">https://github.com/yunuskilicdev/serverlessExample</a></p></div></div>    
</body>
</html>