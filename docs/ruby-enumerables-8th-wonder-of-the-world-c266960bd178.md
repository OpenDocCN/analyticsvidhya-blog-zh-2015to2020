# 红宝石计数:世界第八大奇迹

> 原文：<https://medium.com/analytics-vidhya/ruby-enumerables-8th-wonder-of-the-world-c266960bd178?source=collection_archive---------14----------------------->

![](img/0cb8ab33fdab74074d7e1f6efd23bb34.png)

当我第一次学习 Ruby 的时候，没有什么比辨别使用哪个枚举更让我焦虑的了。就在我以为自己掌握了窍门的时候，可数的神扇了我一巴掌，当着我的面笑了。

为了平息我的不安并弄清这个难以捉摸的话题，我决定把事情分解开来，从实际的单词本身开始。据[韦氏词典](https://www.merriam-webster.com/dictionary/enumerate):

> **列举:**①确定数量，或计数；(2)依次指定，或列出

最简单的方法是，枚举器检查数组或散列中的每个元素，以确定是否满足代码块中指定的标准。如果该元素满足标准，则该元素是输出的目标。但是，输出由所使用的特定可枚举数决定，因为它们的行为各不相同。

接下来的内容是初学者试图解释一些常见的方法——每个方法、映射方法、查找方法和选择方法——是如何作为可枚举的方法来分析和输出数组中的元素的(为了简单起见，我在本文中主要关注数组)。

# **#每个**

本质上，#each 是一个泛型方法，它将代码块应用于数组中的每个元素。让我们看一个例子:

```
numbers = [100, 200, 300]
numbers.each do |n|
text = "I want #{n} pieces of chocolate!"
puts text
end
```

这里我们有一组数字:[100，200，300]。在下一行，我使用#each 遍历数组中的所有三个元素，一次一个。我使用“n”作为我的代码块变量，当它被传递到输出的句子中时，通过它对每个数字进行插值。结果是:

```
I want 100 pieces of chocolate!
I want 200 pieces of chocolate!
I want 300 pieces of chocolate!
```

与其他枚举不同，#each 不收集通过代码块运行数组项的结果。在上面的例子中，除了在输出语句中包含插入的数字之外，没有指示 enumerable 的工作结果是什么。

同样，#each 是这些方法中最简单的。想来点更刺激的吗？请继续阅读…

# **#地图**

我花了一点时间才完全理解这个，因为这个名字，至少在我看来，并没有反映出它的功能。当应用于一个数组时，#map 返回一个新数组，该数组包含与原始数组中相同数量的元素，但是原始元素在作为参数通过代码块后以某种方式被改变了。换句话说，#map 以一对一的转换方式更改原始数组—数组长度相同，但每个元素都进行了转换。

```
numbers = [10, 20, 30]
numbers.map do |n|
n * 10
end
```

我们从一组数字开始。使用#map 迭代数组，数组中的每个元素都作为参数通过代码块传递。所以在每次迭代中，这段代码首先运行 10 * 10，然后 20 * 10，然后 30 * 10。#map 收集每次迭代的输出，并将它们放入一个新数组中:

```
=> [100, 200, 300]
```

原始数组有 3 个数字，输出数组也是如此。让我们试试另一个例子。

```
fruits = ["apple", "banana", "strawberry"]
fruits.map do |fruit|
fruit.upcase
end
```

在这里，我希望#map 返回一个数组，该数组包含原始数组中的相同元素，但返回的元素都是大写的。

```
=> ["APPLE", "BANANA", "STRAWBERRY"]
```

# **#找到**

对我来说，#find 仅仅根据它的名字就很容易理解。 [Ruby 文档](https://ruby-doc.org/core-2.4.2/Enumerable.html#method-i-find)表明这个方法评估原始数组…等待它…*找到*代码块不为假的第一个实例。换句话说(为了避免双重否定)，它返回第一个在代码块中运行后证明为真的数组元素。这里有一个例子:

```
numbers = [1, 2, 3, 4, 5]
numbers.find do |n|
n.even?
end=> 2
```

事情是这样的:从一个数字数组开始，我想找到第一个偶数。#find 在 numbers 数组中一次搜索一个元素，以确定哪个元素是使代码块为真的第一个元素。它返回“2”并停在那里，因为#find 只返回我们要求它查找的第一个匹配项。

另一个例子:

```
fruits = ["apple", "banana", "orange", "raspberry", "strawberry"]
fruits.find do |fruit|
fruit.include?("berry")
end
```

这里，我希望#find 返回名称中包含“berry”的第一个元素(注意，该数组包含两个元素)。它以“苹果”开始，并继续前进，因为它是假的。“香蕉”也被折腾，因为它不含“浆果”。然而，一旦到达“raspberry ”,代码块就证明是真的。迭代器获取数组元素，得到如下结果:

```
=> "raspberry"
```

因为#find 只返回第一个实例，所以我们的结果是有意义的。

# **#选择**

最后，在这个简短但有意义的枚举之旅中，我们有#select。对一个初学者(也就是我)来说，#select 和#find 是另一组我无法搞清楚的枚举。毕竟，这些名字听起来非常相似。当我知道#select 和#find_all 是同义词时，我灵光一现。

我刚刚讨论了#find，它只查找并返回满足代码块的第一个单一实例。#select 返回满足代码块的所有实例。使用上面的示例，但换入#select:

```
numbers = [1, 2, 3, 4, 5]
numbers.select do |n|
n.even?
end=> [2, 4]
```

使用上面的第二个例子:

```
fruits = ["apple", "banana", "orange", "raspberry", "strawberry"]
fruits.select do |fruit|
fruit.include?("berry")
end
```

我想得到一份名字中含有“浆果”的水果清单。就像上面的#find 一样，#select 方法遍历水果数组，查看是否有任何数组元素包含“berry”。这一次，因为#select 选取代码块为真的所有数组元素，所以结果数组包含“raspberry”和“strawberry”:

```
=> ["raspberry", "strawberry"]
```

我可以使用#find_all 而不是#select，并且会得到相同的结果。

# 最后

我从没想过我会这么说，但事实证明，可枚举数真的很有趣，可以做一些非常酷的事情。虽然本文只介绍了一些基本的枚举，但是还有很多其他的需要了解和掌握。