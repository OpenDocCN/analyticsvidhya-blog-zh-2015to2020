<html>
<head>
<title>Understanding 3D Convolutional Neural Networks using 3D MNIST dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用3D MNIST数据集理解3D卷积神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-3d-convolutional-neural-networks-using-3d-mnist-dataset-5d34e8d8a807?source=collection_archive---------13-----------------------#2019-12-16">https://medium.com/analytics-vidhya/understanding-3d-convolutional-neural-networks-using-3d-mnist-dataset-5d34e8d8a807?source=collection_archive---------13-----------------------#2019-12-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0511" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用3D数据集的机器学习在计算机视觉中非常重要。<em class="jd">自动驾驶’</em>汽车需要大量的3D数据才能高效地工作和操作。在本文中，我使用kaggle上提供的3D版本的MNIST数据集，并展示如何预处理和可视化数据，以及创建一个3D卷积神经网络(CNN)模型来拟合此数据。</p><p id="15ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在进一步创建模型之前，现在是前往<a class="ae je" href="https://www.kaggle.com/daavoo/3d-mnist/data" rel="noopener ugc nofollow" target="_blank"> kaggle下载数据集</a>的好时机。如果你读了kaggle上关于体素化的描述，但不明白发生了什么，不用担心，我会在下面解释，否则你可以跳到数据可视化部分。</p><p id="b995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">体素:</strong>体素可以被认为是3D图像的一部分。如果你取一个2D矩阵，它被分成由两行(宽)和两列(高)相交而成的<em class="jd">单元</em>。在3D空间中，这被称为体素，体素具有宽度和高度以及长度。换句话说，细胞可以表示为(x，y ),而体素表示为(x，y，z)。像细胞如何重复以形成矩阵一样，体素也重复以形成3D图像。分割3D图像的过程被称为<em class="jd">体素化。</em></p><p id="2508" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据可视化</strong></p><p id="84bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于数据可视化，我们将使用<a class="ae je" href="https://plot.ly/javascript/" rel="noopener ugc nofollow" target="_blank"> plotly.j </a> s。我发现它在交互式3D绘图时非常有用。下面是colab中数字9的渲染图(我的整个Google colab代码可以在<a class="ae je" href="https://colab.research.google.com/drive/1ifqo3apVi-I6L6TGE-i6TvUE6QJEviJ0" rel="noopener ugc nofollow" target="_blank">这里</a>找到)。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/ab78f558103993355e018e6215e2fe38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fL2VqkfpbkUVQG1kwiTR4Q.png"/></div></div></figure><p id="b756" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">给我看看代码</strong></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jr"><img src="../Images/07b2eca94a8d3db9be8dd314743d791c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-VqbFQfAIE_SFTvQ3Am-g.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">数据操作</figcaption></figure><p id="1932" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kaggle已经为我们做了所有的清洁工作，所以我们不需要再做了。首先，打开文件，将变量分配给Kaggle提供的测试和训练数据集。现在，由于我们将处理3D数据，并且训练和测试数据是2D，我们必须将2D重塑为3D。我们从<em class="jd"> n*4096*3 </em>转换而来，其中<em class="jd"> n </em>是列号。由于我们是用深度学习做多分类，辅助函数<em class="jd">to _ categorial(y，num_classes) </em> one-hot对代表我们类的y进行编码。</p><p id="1543" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">添加颜色</strong></p><p id="5321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，仅将数据转换为3D无助于我们的分类，因为我们将在三个不同的维度上大步前进，我们需要向数据集添加一个参数，使数据集的维度成为4D。这里的第四维是颜色，辅助函数<em class="jd"> add_color(array) </em>就是这样做的。最终数据集被整形为<em class="jd"> n*3*16*16*16 </em>张量，为我们的3D卷积做准备。</p><p id="a762" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">模型建筑</strong></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jw"><img src="../Images/ccc949bee2443dafa5f2c9771529dace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2yTacwVpAhJArZjDDNlMQ.png"/></div></div></figure><p id="b91b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着模型的建立，我建议你尝试一些卷积，把你自己集中起来，看看你的模型表现如何，如果不行，你可以测试我的模型，看看它是如何工作的，甚至可以尝试迁移学习。无论您做什么，不要在没有试图理解正在发生什么的情况下复制粘贴(这是本文的全部目的)。</p><p id="6fa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">训练和测试</strong></p><p id="90cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们开始训练或测试模型之前，我们需要做这些批处理，因为colab ram不能一次处理所有的数据。因为我们不能在不创建某种数据加载器的情况下直接批量使用它，这正是我们要做的。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jx"><img src="../Images/4a456d7a787c3486da9a182574eef82a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09nokNCEF2hezgyz6jnI8g.png"/></div></div></figure><p id="75e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Pytorch自定义数据加载器需要getitem、init和len方法，所以只需像我在googe colab <a class="ae je" href="https://colab.research.google.com/drive/1ifqo3apVi-I6L6TGE-i6TvUE6QJEviJ0" rel="noopener ugc nofollow" target="_blank">代码</a>中那样添加这些方法，并为训练集和测试集获取相应的数据加载器。我发现的一件重要的事情是，小批量(&lt; 30)对模型性能没有帮助，所以选择≥ 100。您可以随意使用这个参数。如果您的训练损失在一两个时期后趋于平稳，则您的模型可能没有从数据集学习，您可能需要增加数据加载器的批处理大小。</p><p id="d21d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都准备好训练模型了。为此，我会建议你玩玩时代和损失函数或优化器的类型。</p><p id="5a90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果</strong></p><p id="82be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我首先在数据集上运行随机森林，因为我发现它在分类任务方面非常“强大”，它达到了67.85%的准确率。经过35个时期后，3D CNN达到了68.10%的准确率，虽然这与随机森林的差异并不大，但我相信用不同的模型进行实验会对相同的数据集产生更高的准确率(&gt; 75%)。对于纪元，我认为20到30个纪元对于一个简单的模型应该足够了，但是对于更复杂的模型，也可以自由地进行实验。下面是模型第一次运行的训练与测试损失。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es jy"><img src="../Images/9237d29c7a2d4858b90eb5e7b333c29d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*FA4HuUXc4fSpHEgRP7jS9A.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">培训vs测试损失3D CNN</figcaption></figure><p id="0827" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样，如果你发现文章的任何部分令人困惑或难以理解，请在评论中留下。</p><p id="ce8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">链接到我的colab代码<strong class="ih hj"> </strong> <a class="ae je" href="https://colab.research.google.com/drive/1ifqo3apVi-I6L6TGE-i6TvUE6QJEviJ0" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这里</strong> </a></p></div></div>    
</body>
</html>