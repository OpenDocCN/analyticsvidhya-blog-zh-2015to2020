<html>
<head>
<title>Compiling TensorFlow from the source when your compiler is in a non-standard location.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当编译器位于非标准位置时，从源代码编译TensorFlow。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/compiling-tensorflow-from-the-source-when-your-compiler-is-in-a-non-standard-location-194fecc92153?source=collection_archive---------5-----------------------#2019-10-26">https://medium.com/analytics-vidhya/compiling-tensorflow-from-the-source-when-your-compiler-is-in-a-non-standard-location-194fecc92153?source=collection_archive---------5-----------------------#2019-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1fd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从源代码编译TensorFlow是设置针对您的系统优化的TensorFlow的一种很好的方式。如果您小心翼翼地为其提供正确的编译器选项，编译将确保您的TensorFlow构建尽可能充分利用您的系统配置(例如:- CPU特性、NUMA等)。).然而，对于大多数人来说，从源代码编译TensorFlow并不总是那么简单。在这篇文章中，我用例子描述了完整的步骤序列，描述了如何从TensorFlow的源代码编译tensor flow。</p><p id="22e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我继续之前，我想让你看一下我是如何写这篇文章的。我在一个没有root权限的计算集群上工作。系统上默认的系统编译器是GCC 4.8.5，不适合编译TensorFlow 2.0，因为TF2.0 build使用了GCC 4.8.5不支持的<code class="du jd je jf jg b">std=c++14</code>标志进行编译。系统上还有其他可用的编译器，但是它们安装在其他非标准的位置。通过大量的反复试验和社区的帮助，我终于能够理解TensorFlow的编译机制。这篇文章将所有的信息浓缩在一篇文章中，这样其他人就不会遇到我所面临的同样的问题。</p><p id="e83c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在继续这篇文章的其余部分之前，我们做如下假设:</p><blockquote class="jh ji jj"><p id="ad30" class="if ig jk ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated">您使用的是Linux发行版。</p></blockquote></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="a191" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">步骤1:设置独立的Python环境</h1><p id="442c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">有两种基本方法可以设置独立的python环境。</p><ul class=""><li id="78df" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">Virtualenv，</li><li id="24ba" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">蟒蛇环境。</li></ul><p id="99d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择哪一个基本上是你的事，也就是用户的事。如果你想了解更多关于这个话题的信息，我建议你通过<a class="ae lm" href="https://towardsdatascience.com/which-python-package-manager-should-you-use-d0fd0789a250" rel="noopener" target="_blank">这篇文章</a>。我个人使用anaconda环境。</p><p id="c64b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">建立一个专用的环境是有益的，因为不同环境中的包和文件不会互相干扰。这意味着您可以在不同的环境中维护同一个库的多个版本，甚至不同的库。我经常遇到这种情况，因为有些代码是专门为TensorFlow或PyTorch的特定版本编写的。</p><p id="d59d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文的剩余部分，我假设您已经建立了一个名为“<strong class="ih hj"> tensorflow-2.0-master </strong>”的独立python环境。</p><p id="b9cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确保<code class="du jd je jf jg b">numpy,scipy,keras_preprocessing</code>已经在环境中设置。如果没有，请使用<code class="du jd je jf jg b">pip install</code>进行设置。</p><p id="e272" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，我们将从它的主分支构建TensorFlow。然而，这并没有真正的区别，因为您可以按照相同的一组指令来构建TensorFlow的任何其他分支。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="d43f" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">步骤2:克隆TensorFlow源代码</h1><p id="2b27" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">您可以使用以下命令获得TensorFlow源代码</p><p id="f2c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">git clone --recursive <a class="ae lm" href="https://github.com/tensorflow/tensorflow.git" rel="noopener ugc nofollow" target="_blank">https://github.com/tensorflow/tensorflow.git</a></code></p><p id="1df2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将克隆GitHub上的TensorFlow存储库</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ln"><img src="../Images/f27e0c9901f90d36aa8de13f3988398b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCYJB4KLQPHv09M8xLSdJw.png"/></div></div></figure><p id="3fb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:如果你想编译TensorFlow的一个特定分支，你应该检查你想要的分支。这可以使用</strong>来完成</p><p id="cd04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">git checkout &lt;BRANCH_NAME&gt;</code></p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="27eb" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">步骤3:找到编译TensorFlow所需的Bazel版本</h1><p id="5b7f" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">TensorFlow依靠Bazel进行构建。Bazel是一个构建系统。其他构建系统的例子有CMake、Apache Maven(针对Java)、Mason和Make。随着TensorFlow开发的发展，它为其建筑支持一组特定的bazel版本。因此，您需要为您试图构建的分支找到支持的bazel版本。</p><p id="d9af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在克隆的tensorflow文件夹中，打开文件<code class="du jd je jf jg b">configure.py</code>。下面我展示了写这篇文章时这个文件的截图。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lz"><img src="../Images/72e20d08c7801e1fda07717e90e453b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ma2QiQ8jhrEHBw6DcCBP6w.png"/></div></div></figure><p id="8926" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到，有两个变量表示构建张量流所需的bazel的最小和最大版本。请注意，根据您尝试构建的分支以及您尝试构建分支的时间(因为TensorFlow开发在不断发展！！)，这些版本可能会有变化。因此，在构建TensorFlow之前访问这个文件并找出所需的bazel版本是一个很好的做法。</p><p id="161c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">_TF_MIN_BAZEL_VERSION</code>表示支持的最低bazel版本，而<code class="du jd je jf jg b">_TF_MAX_BAZEL_VERSION</code>表示支持的最高bazel版本。您可以在这些版本之间选择任何bazel版本。在这篇文章的剩余部分，我决定用<code class="du jd je jf jg b">_TF_MAX_BAZEL_VERSION</code>，在我的例子中是<code class="du jd je jf jg b">0.29.1</code>。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="0a02" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">第四步:安装Bazel</h1><p id="46db" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">如果您已经有了想要的bazel安装版本，您可以跳过这一步，否则请继续阅读这一步。</p><p id="e30c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以通过<a class="ae lm" href="https://github.com/bazelbuild/bazel/releases" rel="noopener ugc nofollow" target="_blank">这个链接</a>获得bazel所有版本的列表。通过点击它的版本号来选择想要的版本，你将会看到一个选项列表，如下所示。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ma"><img src="../Images/2548a07036981076cd65a95e94757ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4KQnUJvwpv-6tHCz8p2f5Q.png"/></div></div></figure><p id="0953" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在写这篇文章的时候，我想我也应该向您展示如何编译bazel。为了编译bazel，你应该下载它的<code class="du jd je jf jg b">dist</code>包。它将在列表中被命名为<code class="du jd je jf jg b">bazel-&lt;VERSION&gt;-dist.zip</code>。下载<code class="du jd je jf jg b">zip</code>文件并解压(解压时，请务必指定解压到的文件夹，否则zip中的所有文件都会解压到与<code class="du jd je jf jg b">zip</code>文件相同的位置，会很混乱。所以，使用一个命令，比如<code class="du jd je jf jg b">unzip bazel-0.29.1-dist.zip -d bazel-0.29.1</code>。</p><p id="772a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解压缩后，进入文件夹内部(在我的例子中是<code class="du jd je jf jg b">bazel-0.29.1</code>，并键入<code class="du jd je jf jg b">./compile.sh</code>。这将编译bazel并在<code class="du jd je jf jg b">output</code>子文件夹中给你一个二进制文件。将这个<code class="du jd je jf jg b">output</code>子文件夹添加到路径中(使用<code class="du jd je jf jg b">export PATH=&lt;PATH_TO_output_FOLDER&gt;:$PATH</code>)。</p><p id="be05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您已经成功设置了bazel，并准备编译TensorFlow。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="8b33" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">第五步:在编译TensorFlow之前做一些准备</h1><h2 id="b258" class="mb jw hi bd jx mc md me kb mf mg mh kf iq mi mj kj iu mk ml kn iy mm mn kr mo bi translated">导出一些路径</h2><p id="9d83" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">在尝试编译TensorFlow之前，您必须设置两条路径— <code class="du jd je jf jg b">GCC_HOST_COMPILER_PATH</code>和<code class="du jd je jf jg b">GCC_HOST_COMPILER_PREFIX</code>。要确定这些路径，请在终端上键入<code class="du jd je jf jg b">which gcc</code>。假设您得到的输出是<code class="du jd je jf jg b">/a/b/c/d/bin/gcc</code>。然后，</p><p id="cd72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">。<code class="du jd je jf jg b">GCC_HOST_COMPILER_PATH</code>应该是<code class="du jd je jf jg b">/a/b/c/d/bin/gcc</code>。</p><p id="c88b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">。<code class="du jd je jf jg b">GCC_HOST_COMPILER_PREFIX</code>应该是<code class="du jd je jf jg b">/a/b/c/d/bin</code>。</p><p id="f442" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一点你要记住，上面两条路径应该是真正的绝对路径，而不是符号链接。如果它们是符号链接，那就有问题了。事实是，<code class="du jd je jf jg b">bazel</code>能够在包含头文件时将符号路径解析为真正的绝对路径。然而，由于<code class="du jd je jf jg b">GCC_HOST_COMPILER_PATH</code>和<code class="du jd je jf jg b">GCC_HOST_COMPILER_PREFIX</code>是由用户指定的，<code class="du jd je jf jg b">bazel</code>不会尝试解析这些路径。<code class="du jd je jf jg b">bazel</code>要求你的GCC编译器和头文件在同一个父目录下(<strong class="ih hj"> </strong> <a class="ae lm" href="https://github.com/bazelbuild/bazel/issues/10085" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">详见本期github</strong></a>)。由于<code class="du jd je jf jg b">bazel</code>没有试图解析上述两个路径，所以在编译过程中，它会给你一个错误，告诉你无法找到头文件的依赖声明。<strong class="ih hj">因此，在指定</strong> <code class="du jd je jf jg b"><strong class="ih hj">GCC_HOST_COMPILER_PREFIX</strong></code> <strong class="ih hj">和</strong> <code class="du jd je jf jg b"><strong class="ih hj">GCC_HOST_COMPILER_PATH</strong></code> <strong class="ih hj">之前，请自行解析任何符号链接。</strong></p><h2 id="d6f3" class="mb jw hi bd jx mc md me kb mf mg mh kf iq mi mj kj iu mk ml kn iy mm mn kr mo bi translated">指定工具链</h2><p id="dcd5" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">术语“工具链”是指编译器、链接器和其他工具，例如在编译的不同阶段需要的代码覆盖工具。在开始编译之前，Bazel需要知道这些工具的位置。为此，打开文件<code class="du jd je jf jg b">third_party/gpus/crosstool/cc_toolchain_config.bzl.tpl</code>。</p><p id="28cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个很长的文件，但是你只需要<a class="ae lm" href="https://github.com/tensorflow/tensorflow/blob/master/third_party/gpus/crosstool/cc_toolchain_config.bzl.tpl#L1406-L1419" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">修改这个文件</strong> </a>的一小部分。为了清楚起见，我向您展示了这个文件的修改版本(由我为我的编译而修改的)</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mp"><img src="../Images/e48572991ebf2a98519cbda41c329ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCdp2b2Qp8IXgLAeq0940A.png"/></div></div></figure><p id="394f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码中突出显示的部分是被修改的部分。让我们讨论一下我是如何进行这一修改的:</p><p id="d74f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一件事是<code class="du jd je jf jg b">gcc</code>。因为我已经提供了一个<code class="du jd je jf jg b">GCC_HOST_COMPILER_PATH</code>作为环境变量(它将在<code class="du jd je jf jg b">ctx.attr.host_compiler_path</code>中反映出来)，所以我不需要修改上面突出显示的代码中的<code class="du jd je jf jg b">gcc</code>部分。</p><p id="ea5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于其他工具，您可以做的一件简单的事情如下:</p><p id="432a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你想为<code class="du jd je jf jg b">objcopy</code>设置正确的路径。在终端上输入<code class="du jd je jf jg b">which objcopy</code>。如果您得到的输出是<code class="du jd je jf jg b">$GCC_HOST_COMPILER_PREFIX/objcopy</code>，那么您不需要修改那一行，因为它已经被设置为(我向您展示修改后的文件，所以您看不到它，但是如果您看到文件的在线版本，您会看到)<code class="du jd je jf jg b">ctx.attr.host_compiler_prefix + "/objcopy"</code>。请记住，既然您已经指定了<code class="du jd je jf jg b">GCC_HOST_COMPILER_PREFIX</code>，那么它将通过<code class="du jd je jf jg b">bazel</code>反映在<code class="du jd je jf jg b">ctx.attr.host_compiler_prefix</code>中。然而，如果您没有得到作为<code class="du jd je jf jg b">$GCC_HOST_COMPILER_PREFIX/objcopy</code>的<code class="du jd je jf jg b">which objcopy</code>的输出，那么就简单地跳过文件中<code class="du jd je jf jg b">which objcopy</code>的输出，就像我在上面突出显示的文件中所做的那样。</p><p id="634a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个例外是<code class="du jd je jf jg b">ar</code>。新版本的<code class="du jd je jf jg b">gcc</code>带有<code class="du jd je jf jg b">gcc-ar</code>，它只是普通老式<code class="du jd je jf jg b">ar</code>的包装。你可以在这篇stackoverflow文章中读到更多关于这个<a class="ae lm" href="https://stackoverflow.com/questions/48777554/what-is-the-difference-between-ar-nm-and-gcc-ar-gcc-nm" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">的内容。</strong> </a> <strong class="ih hj"> </strong>因此，如果您在<code class="du jd je jf jg b">$GCC_HOST_COMPILER_PREFIX</code>中看到<code class="du jd je jf jg b">gcc-ar</code>和/或<code class="du jd je jf jg b">gcc-nm</code>，那么请指定不是系统安装的<code class="du jd je jf jg b">ar</code>通常出现在<code class="du jd je jf jg b">/usr/bin/ar</code>中，但<code class="du jd je jf jg b">gcc-ar</code>仍会调用它。</p><p id="7e49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于<code class="du jd je jf jg b">gcc-ar</code>的另一件事是，当提供一个参数文件作为参数时，它会给出问题(<a class="ae lm" href="https://github.com/bazelbuild/bazel/issues/3760#issuecomment-444120226" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">详情请见此GitHub问题</strong> </a>)。所以，如果你简单地指定<code class="du jd je jf jg b">gcc-ar</code>，你会在编译过程中收到报错<code class="du jd je jf jg b">/usr/bin/ar: invalid option — ‘@'</code>。在刚刚讨论的GitHub问题中已经讨论了该变通方法。解决方法是围绕<code class="du jd je jf jg b">gcc-ar</code>创建另一个简单的包装器脚本。包装器脚本应该将参数文件中的参数直接提供给<code class="du jd je jf jg b">gcc-ar</code>。下面的例子将使它更清楚:</p><p id="0f45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Bazel在编译期间将尝试运行如下命令:</p><pre class="lo lp lq lr fd mq jg mr ms aw mt bi"><span id="2ca8" class="mb jw hi jg b fi mu mv l mw mx">/gpfs7kro/gpfslocalsup/spack_soft/gcc/8.3.0/gcc-4.8.5-opnwtdjumg2hxo4ljvnx77ugb6afmvj3/bin/gcc-ar <a class="ae lm" href="http://twitter.com/bazel" rel="noopener ugc nofollow" target="_blank">@bazel</a>-out/host/bin/external/libjpeg_turbo/libjpeg.a-2.params</span></pre><p id="09a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，以<code class="du jd je jf jg b">@</code>开始的第二个参数实际上是一个参数文件，应该由<code class="du jd je jf jg b">gcc-ar</code>读取，以便将指令传递给<code class="du jd je jf jg b">ar</code>。但不幸的是，由于某种原因，它没有正确读取它，并给出了一个关于符号<code class="du jd je jf jg b">@</code>的错误。因此，在我们的包装器脚本中，我们只需自己读取参数，并将其直接传递给调用<code class="du jd je jf jg b">ar</code>的<code class="du jd je jf jg b">gcc-ar</code>。以下是我写的包装脚本(<a class="ae lm" href="https://github.com/bazelbuild/bazel/issues/3760" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">向GitHub issue </strong> </a>致谢):</p><pre class="lo lp lq lr fd mq jg mr ms aw mt bi"><span id="67f9" class="mb jw hi jg b fi mu mv l mw mx">#!/usr/bin/env bash</span><span id="4cc7" class="mb jw hi jg b fi my mv l mw mx">GCC_AR_PATH=/gpfs7kro/gpfslocalsup/spack_soft/gcc/8.3.0/gcc-4.8.5-opnwtdjumg2hxo4ljvnx77ugb6afmvj3/bin</span><span id="09b8" class="mb jw hi jg b fi my mv l mw mx">ARGS=$1<br/>FILENAME=”${ARGS:1}”</span><span id="12b6" class="mb jw hi jg b fi my mv l mw mx">$GCC_AR_PATH/gcc-ar $(&lt;$FILENAME)</span></pre><p id="7565" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">必须使用<code class="du jd je jf jg b">chmod +x</code>使该脚本可执行。这个脚本的完整路径是您应该在上面文件中的<code class="du jd je jf jg b">ar</code>处指定的路径。</p><h1 id="2acc" class="jv jw hi bd jx jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks bi translated">第六步:进行编译</h1><p id="65a3" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">现在，您只需在tensorflow文件夹中执行<code class="du jd je jf jg b">./configure</code>并选择呈现给您的选项(如CUDA路径等)。完成后，只需使用以下命令:</p><pre class="lo lp lq lr fd mq jg mr ms aw mt bi"><span id="2172" class="mb jw hi jg b fi mu mv l mw mx">bazel --output_user_root=../ujjwal_bazel_gcc8 build -s --config=opt --config=mkl --config=numa --cxxopt=”-D_GLIBCXX_USE_CXX11_ABI=0" --config=mkl //tensorflow/tools/pip_package:build_pip_package --verbose_failures</span></pre><p id="103b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于上述命令的一些注意事项:</p><p id="2773" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a)我用过<code class="du jd je jf jg b">config=mkl</code>和<code class="du jd je jf jg b">config=numa</code>。您可以选择其他选项集。在这一点上，这是你的决定。</p><p id="e0ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b)默认情况下，bazel将使用您的个人文件夹进行缓存。TensorFlow构建期间的缓存会占用大量空间。因此，如果您的主文件夹中没有太多空间，请指定<code class="du jd je jf jg b">--output_user_root</code>作为缓存的文件夹。</p><p id="10e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c)我用过<code class="du jd je jf jg b">--cxxopt="-D_GLIBCXX_USE_CXX11_ABI=0</code>。我已经在TensorFlow网站上使用了下面的说明，上面说如果你使用GCC 5或更高版本进行构建，你应该使用这个选项。</p><p id="1cf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">d)<code class="du jd je jf jg b">-s</code>选项确保bazel在执行命令前打印完整的命令。当您遇到某个问题并希望向他人提供信息来帮助您调试时，这真的很有帮助。<a class="ae lm" href="https://github.com/bazelbuild/bazel/issues/10085" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">感谢bazel开发者建议我在本期GitHub中使用这个</strong> </a>。</p><p id="5837" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编译完成后，使用<code class="du jd je jf jg b">bazel-bin</code>命令创建<code class="du jd je jf jg b">whl</code>文件，如下所示:</p><pre class="lo lp lq lr fd mq jg mr ms aw mt bi"><span id="58dd" class="mb jw hi jg b fi mu mv l mw mx">./bazel-bin/tensorflow/tools/pip_package/build_pip_package ./tensorflow_pkg</span></pre><p id="ba9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的<code class="du jd je jf jg b">./tensorflow_pkg</code>是将创建<code class="du jd je jf jg b">whl</code>文件的文件夹的路径。</p><p id="0a44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦创建了<code class="du jd je jf jg b">whl</code>文件，通过键入<code class="du jd je jf jg b">pip install --ignore-installed &lt;FULLPATH TO THE WHL FILE</code>来设置它。</p><p id="37dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这篇帖子对试图从TensorFlow的源代码编译tensor flow的人有所帮助。如果您有任何建议和问题，我将不胜感激。</p></div></div>    
</body>
</html>