<html>
<head>
<title>Rotten Oranges — Day 3 (Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">腐烂的橙子—第三天(蟒蛇)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/rotten-oranges-day-3-python-83a313d20f65?source=collection_archive---------3-----------------------#2020-09-24">https://medium.com/analytics-vidhya/rotten-oranges-day-3-python-83a313d20f65?source=collection_archive---------3-----------------------#2020-09-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6c8ac23811f7ea4291d1dd6f68e15595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y_4rb7kRZzNCpPSr"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@briennehong?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Brienne Hong </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4b9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">烂橘子问题是面试中最常被问到的问题之一，尤其是亚马逊。让我们深入探讨这个问题。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="c043" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/rotting-oranges/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> 994 </strong> </a> <strong class="ix hj">。腐烂的橙子</strong></p><p id="a10f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在给定的网格中，每个单元格可以有三个值之一:</p><ul class=""><li id="3256" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">代表空单元格的值<code class="du kj kk kl km b">0</code>；</li><li id="8844" class="ka kb hi ix b iy kn jc ko jg kp jk kq jo kr js kf kg kh ki bi translated">代表新鲜橙子的值<code class="du kj kk kl km b">1</code>;</li><li id="6b9a" class="ka kb hi ix b iy kn jc ko jg kp jk kq jo kr js kf kg kh ki bi translated">代表一个腐烂的橙子的值<code class="du kj kk kl km b">2</code>。</li></ul><p id="d7f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每一分钟，任何与腐烂的橙子相邻的新鲜橙子都会腐烂。</p><p id="5967" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">返回没有单元格呈现新鲜橙色之前必须经过的最少分钟数。如果这是不可能的，返回<code class="du kj kk kl km b">-1</code>代替。</p><p id="30cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例 1: </p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/0c5d9b3d50ec7e8c0a7892b0f4e900db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LNx6inJAzguS6bc1.png"/></div></div></figure><pre class="kt ku kv kw fd kx km ky kz aw la bi"><span id="03e0" class="lb lc hi km b fi ld le l lf lg"><strong class="km hj">Input: </strong>[[2,1,1],[1,1,0],[0,1,1]]<br/><strong class="km hj">Output: </strong>4</span></pre><p id="c8b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例 2: </strong></p><pre class="kt ku kv kw fd kx km ky kz aw la bi"><span id="8c5f" class="lb lc hi km b fi ld le l lf lg"><strong class="km hj">Input: </strong>[[2,1,1],[0,1,1],[1,0,1]]<br/><strong class="km hj">Output: </strong>-1<br/><strong class="km hj">Explanation: </strong> The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.</span></pre><p id="211e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例 3: </strong></p><pre class="kt ku kv kw fd kx km ky kz aw la bi"><span id="ed74" class="lb lc hi km b fi ld le l lf lg"><strong class="km hj">Input: </strong>[[0,2]]<br/><strong class="km hj">Output: </strong>0<br/><strong class="km hj">Explanation: </strong> Since there are already no fresh oranges at minute 0, the answer is just 0.</span></pre><p id="c501" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注:</strong></p><ol class=""><li id="e1e4" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js lh kg kh ki bi translated"><code class="du kj kk kl km b">1 &lt;= grid.length &lt;= 10</code></li><li id="2478" class="ka kb hi ix b iy kn jc ko jg kp jk kq jo kr js lh kg kh ki bi translated"><code class="du kj kk kl km b">1 &lt;= grid[0].length &lt;= 10</code></li><li id="e139" class="ka kb hi ix b iy kn jc ko jg kp jk kq jo kr js lh kg kh ki bi translated"><code class="du kj kk kl km b">grid[i][j]</code>只有<code class="du kj kk kl km b">0</code>、<code class="du kj kk kl km b">1</code>，或者<code class="du kj kk kl km b">2</code>。</li></ol><p id="f696" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经学会了使用广度优先搜索算法，当我们需要找到最短的距离或最短的时间来完成网格或树中的一些任务。</p><p id="5d04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的问题中，我们需要找到所有橙子腐烂所需的最短时间，因此我们将使用 BFS 来解决上面的问题。</p><p id="1ea3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了求解 BFS，我们需要一个堆栈和一个队列。通常，BFS 是用迭代法求解的。使用递归求解 BFS 具有更高的复杂性。</p><p id="4dab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们立即着手解决这个问题。</p><p id="2fc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要一个包含腐烂橙子坐标的队列和一个包含新鲜橙子坐标的集合。</p><pre class="kt ku kv kw fd kx km ky kz aw la bi"><span id="7738" class="lb lc hi km b fi ld le l lf lg"> fresh_set = set()<br/> rotten = []<br/> for row in range(len(grid)):<br/>     for col in range(len(grid[row])):<br/>         if grid[row][col] == 2:<br/>             rotten.append((row, col, 0))<br/>         elif grid[row][col] == 1:<br/>             fresh_set.add((row, col))</span></pre><p id="b5b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个问题中，邻居被认为是在 4 个方向上相邻的块。我们需要计算可能的邻居。</p><pre class="kt ku kv kw fd kx km ky kz aw la bi"><span id="4d68" class="lb lc hi km b fi ld le l lf lg">valid_row = [-1, 0, 0, 1]<br/>valid_col = [0, -1, 1, 0]</span></pre><p id="f274" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">直到我们的队列有元素，我们从队列的前面弹出坐标。也要记录所采取的步骤。检查邻居中是否有新鲜的橙子，如果有，将坐标推入队列，并将其从新鲜组中移除。</p><p id="5546" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果队列是空的，检查是否还有新鲜的橙子。如果是，返回-1(这是问题要求我们做的)。否则返回步骤号。</p><pre class="kt ku kv kw fd kx km ky kz aw la bi"><span id="5be6" class="lb lc hi km b fi ld le l lf lg">while(rotten):<br/>    row, col, time = rotten.pop(0)<br/>    for neigh in range(len(valid_row)):<br/>        new_row = row+valid_row[neigh]<br/>        new_col = col+valid_col[neigh]</span><span id="06b4" class="lb lc hi km b fi li le l lf lg">        # Checks if the orange at this position is fresh and the co-ordinates are not outside the boundary<br/>        if(self.is_safe(new_row, new_col, grid)):<br/>            grid[new_row][new_col] = 2<br/>            rotten.append((new_row, new_col, time+1))<br/>            fresh_set.remove((new_row, new_col))<br/> return -1 if fresh_set else time</span></pre><p id="e9c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完整的解决方案如下。</p><pre class="kt ku kv kw fd kx km ky kz aw la bi"><span id="272d" class="lb lc hi km b fi ld le l lf lg">class Solution:<br/>    def is_safe(self, row, col, grid):<br/>        return(0&lt;= row&lt; len(grid) and<br/>               0&lt;= col&lt; len(grid[0]) and<br/>               grid[row][col] == 1)<br/>    def orangesRotting(self, grid: List[List[int]]) -&gt; int:<br/>        fresh_set = set()<br/>        rotten = []<br/>        for row in range(len(grid)):<br/>            for col in range(len(grid[row])):<br/>                if grid[row][col] == 2:<br/>                    rotten.append((row, col, 0))<br/>                elif grid[row][col] == 1:<br/>                    fresh_set.add((row, col))<br/>        if rotten == [] and not fresh_set:<br/>            return 0<br/>        elif rotten == []:<br/>            return -1<br/>            <br/>        valid_row = [-1, 0, 0, 1]<br/>        valid_col = [0, -1, 1, 0]<br/>        while(rotten):<br/>            row, col, time = rotten.pop(0)<br/>            for neigh in range(len(valid_row)):<br/>                new_row = row+valid_row[neigh]<br/>                new_col = col+valid_col[neigh]<br/>                if(self.is_safe(new_row, new_col, grid)):<br/>                    grid[new_row][new_col] = 2<br/>                    rotten.append((new_row, new_col, time+1))<br/>                    fresh_set.remove((new_row, new_col))<br/>        return -1 if fresh_set else time</span></pre><p id="4d3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复杂性分析</p><p id="86df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="b154" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要扫描网格中的每个区块。扫描每个块需要 O(N*M)，其中 N 是行数，M 是列数。</p><p id="77fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度</strong></p><p id="bebf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在最坏的情况下，我们网格中的所有橙子都腐烂了。然后，我们需要在队列中存储坐标，这需要 O(N * M ),其中 N 是网格的行数，M 是列数。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="6fef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你发现文章中有错误，请告诉我。此外，我想提高我的写作技巧，所以任何建议或批评都非常欢迎。</p></div></div>    
</body>
</html>