<html>
<head>
<title>Dangerous Depositions (GPL 2018)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">危险证词(GPL 2018)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dangerous-depositions-gpl-2018-f11588b0d13f?source=collection_archive---------20-----------------------#2019-11-18">https://medium.com/analytics-vidhya/dangerous-depositions-gpl-2018-f11588b0d13f?source=collection_archive---------20-----------------------#2019-11-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/59c6b451e9c8d412074e6eb7574986ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DvvYioo46nZhQPAa"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@rocknrollmonkey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摇滚猴子</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8207" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">平衡机器人布雷特正在执行废黜其朋友的人类霸主的任务。在N个建筑物的城市中，他们计划Q次攻击，在那里他们偷偷穿过连接建筑物A_i和B_i与危险D_i的M条电缆。他们将从开始的建筑物S_i开始，行进到结束的建筑物E_i。然后他们将潜入目的地建筑物，并以进步的名义将居住在该建筑物中的人类霸主扔出窗外。</p><p id="585a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">路径的危险被定义为沿着该路径的任何电缆的最高危险值。布雷特希望最小化这种相关的危险，所以对于每次攻击，他们希望你，他们唯一信任的人，通过最小化他遇到的最大危险来计划每条路线，并找到他们在每条Q路线上将遇到的最大危险。最后，为了让他们放心，在承担这项危险任务之前，他们希望您输出所有电缆的危险等级总和，您可以承诺不会让他们在任何可能的未来攻击中使用这些电缆。</p><p id="591e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">若要查看或尝试完整问题，<a class="ae iu" href="https://www.hackerrank.com/contests/bennetts-problems" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">在此报名</strong> </a> <strong class="ix hj"> </strong>然后<strong class="ix hj"> </strong> <a class="ae iu" href="https://www.hackerrank.com/contests/bennetts-problems/challenges/dangerous-depositions" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">点击此处</strong> </a> <strong class="ix hj">。</strong></p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="f42f" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决办法</h1><p id="d382" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以从简化问题陈述开始。我们被要求找到一系列危险最小的路径，给出一系列起点和终点。此外，我们需要输出避免的总危险的总和，即永远不会被遍历的边的总和。</p><p id="0372" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要解决第一个问题，怎样才能找到危险度最低的路径？注意，给定从A到B的最大危险X和从B到C的最大危险Y，从A到C的路径的最大危险≤ max(X，Y)。这是因为从A到C的路径可以遵循与A到B，然后B到C相同的路径，并且消除了一些重复的边。如果我们能够创建一个具有最小最大加权边的连通子图，那么我们就可以在该子图中路由所有路径。我们可以通过贪婪地选择连接两个先前不连接的部分的最不危险的边来建立这个子图，继续直到子图被连接。然后，我们可以使用简单的深度优先搜索算法来找到一条危险最小的路径。我们稍后再讨论这个。</p><p id="bc30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了解决第二个问题，我们不可避免地必须识别哪些危险以及哪些边缘是永远不会穿越的。因此，我们也将知道哪些边被遍历。我们的解决方案必须最大化未遍历边的总和，最小化遍历边的总和。为了覆盖所有可能的路径，我们知道表示我们遍历的边的图必须是连通的。因此，我们需要找到一个最小权重的图来遍历代表问题的更大的图。一个大小为N的图需要连接N-1条边，任何有N条或更多条边的图都必然有回路。因此，我们知道这个最小权重图必须有N-1条边，否则我们可以删除一个回路中的一条边来创建一个较低权重的图。因此，后半部分只是要求我们找到一个最小生成树(MST)和不在该MST中的权重之和。</p><p id="733c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有趣的是，前半部分的解实际上会产生一个MST。虽然没有被设定为MST，但用于求解它的算法与用于寻找MST的<a class="ae iu" href="https://en.wikipedia.org/wiki/Kruskal's_algorithm" rel="noopener ugc nofollow" target="_blank"> Kruskal的算法</a>相同。尽管提出了两个问题，但解决这两个问题只需要进行一个主要的计算，即寻找一个MST。虽然Kruskal解决了这个问题，但实现起来可能有点麻烦，因为确定图的哪些部分已经连接起来非常耗时。知道我们的最终目标是找到一个MST，我们可以使用<a class="ae iu" href="https://en.wikipedia.org/wiki/Prim%27s_algorithm" rel="noopener ugc nofollow" target="_blank"> Prim的算法</a>，它通过选择“进行中”图与非连接点之间最便宜的链接，并将这条边添加到图中，直到生成树形成，从而逐步构建MST。</p><p id="9197" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦找到这个MST，您只需要找到被请求路径的最小危险，并输出未使用的总权重。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="a17a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是我用C++的解决方案。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="e436" class="lm kb hi li b fi ln lo l lp lq">// Solution by Bennett Liu<br/>#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;queue&gt;<br/>#include &lt;cstdio&gt;<br/>using namespace std;</span><span id="4971" class="lm kb hi li b fi lr lo l lp lq">int n, m, q, a, b, d, s, e, avoided;<br/>bool vis[1002];<br/>pair&lt;int, pair&lt;int, int&gt; &gt; tmp;<br/>vector&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt; edges[1002];<br/>vector&lt;pair&lt;int, int&gt; &gt; mst[1002];<br/>priority_queue&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt; pq;<br/>int danger[1002][1002];</span><span id="f274" class="lm kb hi li b fi lr lo l lp lq">void dfs(int cur, int origin, int curDanger) {<br/>   danger[cur][origin] = curDanger;<br/>   danger[origin][cur] = curDanger;<br/>   vis[cur] = true;<br/>   for (int i = 0; i &lt; mst[cur].size(); i++) {<br/>      if (!vis[mst[cur][i].second]) {<br/>         dfs(mst[cur][i].second, origin, max(curDanger, mst[cur][i].first));<br/>      }<br/>   }<br/>   return;<br/>}</span><span id="cd5a" class="lm kb hi li b fi lr lo l lp lq">int main() {<br/>   // Get inputs<br/>   cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br/>   for (int i = 0; i &lt; m; i++) {<br/>      cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;<br/>      edges[a].push_back(make_pair(-d, make_pair(a, b)));<br/>      edges[b].push_back(make_pair(-d, make_pair(b, a)));<br/>   }</span><span id="0be2" class="lm kb hi li b fi lr lo l lp lq">// Build MST and calculate sum of avoided dangers<br/>   vis[1] = true;<br/>   for (int i = 0; i &lt; edges[1].size(); i++) pq.push(edges[1][i]);<br/>   while (!pq.empty()) {<br/>      tmp = pq.top();<br/>      pq.pop();<br/>      if (vis[tmp.second.second]) avoided += (-tmp.first);<br/>      else {<br/>         avoided -= (-tmp.first);<br/>         vis[tmp.second.second] = true;<br/>         mst[tmp.second.first].push_back(make_pair((-tmp.first), tmp.second.second));<br/>         mst[tmp.second.second].push_back(make_pair((-tmp.first), tmp.second.first));<br/>         for (int i = 0; i &lt; edges[tmp.second.second].size(); i++) pq.push(edges[tmp.second.second][i]);<br/>      }<br/>   }</span><span id="fe97" class="lm kb hi li b fi lr lo l lp lq">// Precompute  all dangers<br/>   for (int i = 1; i &lt;= n; i++) {<br/>      // Reset vis array<br/>      for (int j = 1; j &lt;= n; j++) vis[j] = false;<br/>      dfs(i, i, 0);<br/>   }</span><span id="823a" class="lm kb hi li b fi lr lo l lp lq">// Return precomputed dangers<br/>   for (int i = 0; i &lt; q; i++) {<br/>      cin &gt;&gt; s &gt;&gt; e;<br/>      cout &lt;&lt; danger[s][e] &lt;&lt; endl;<br/>   }<br/>   cout &lt;&lt; (avoided/2) &lt;&lt; endl;<br/>}</span></pre><p id="94d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我为2018年女生编程联盟大赛写了这个问题，目标是找到一个MST算法的非常规用途。</p></div></div>    
</body>
</html>