<html>
<head>
<title>Programming Paradigms: Declarative</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程范例:声明式</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/programming-paradigms-declarative-a6ee23ca8dc9?source=collection_archive---------10-----------------------#2020-02-12">https://medium.com/analytics-vidhya/programming-paradigms-declarative-a6ee23ca8dc9?source=collection_archive---------10-----------------------#2020-02-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aa9240dddda960e004ad98b3a94838e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KqVIbnlAZIXp2zxO"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马库斯·斯皮斯克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b23e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好，</p><p id="627d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae iu" rel="noopener" href="/@shivam.gosavi340_58315/programming-paradigms-cb560f5125a1">的第一篇博文</a>中，我们讨论了命令式和声明式范例。同样，在第二篇博文中，我们讨论了受命令式范式影响的范式。在这篇博文中，我们将讨论范例，也就是声明性范例的形式。如果你没有读过我以前的关于范例的博客，那么我建议你在深入之前读一读。<br/>以下是受声明性范例影响的范例列表:</p><ol class=""><li id="ffea" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">功能范式</li><li id="612e" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">逻辑范式</li></ol><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/414fa2bc85a098076695c4d35a6860da.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*PZLPS-m1_iGNudZPyfhewA.gif"/></div></figure><h1 id="a761" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">函数式编程:</h1><p id="ba09" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">函数式编程中的模块化和代码重用原则与过程式编程中的相同，因为它们都源于结构化编程。例如，过程类似于函数。两者都允许在程序的不同部分重用相同的代码。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/787adcc0a9f6c574214055df0d685e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BEnvppNHFULOZqHDrTPR8A.png"/></div></div></figure><p id="c046" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这两种风格的主要区别在于，函数式编程语言删除了过程式编程的命令性元素。众所周知，赋值操作符和全局变量是命令式编程的两个主要方面。所以函数式编程不推荐使用赋值操作符和访问函数范围之外的变量。是的，你没看错，没有赋值操作符的编码。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/4bad2a7fd3c817a975cbd44e9e7dea8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/1*5GI845rD5zq_ks_R3VoHLA.gif"/></div></figure><p id="1da1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种方法的好处是，<em class="lr">没有赋值操作符=没有改变变量值=没有副作用</em>。但是我们知道，当我们做一些计算或应用一些逻辑时，我们需要变量来存储这些结果，那么我们如何在函数式编程中实现呢？。我们没有给变量赋值，而是将这些值作为输入参数传递给同一个或其他函数。</p><p id="327f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有副作用意味着函数不会改变任何变量的值，这超出了它的范围。这种方法使系统保持在调用函数之前的状态。</p><p id="b03b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，任何函数的输出只依赖于函数的输入，无论我们使用相同的输入参数调用函数多少次，每次函数都会返回相同的输出。只有当我们不访问/改变变量的状态时，这才是可能的，这超出了函数的范围。</p><p id="f36a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们以一个计算前n个数之和的程序为例。在下面的代码片段中，函数sum()改变了变量total的值，这超出了它的范围。不仅如此，初始值也会对变量total的最终值产生影响。因此，函数sum并不总是产生相同的结果，即使我们向它传递相同的输入。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1.1</figcaption></figure><p id="c2ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看完上面的例子，你可能会想，伙计，你说过没有赋值操作符，对吗？。是的，但那是过程式编程风格，在其中使用赋值操作符是可以的。以下是函数式风格的示例:</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用函数式编程风格。</figcaption></figure><p id="89c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有助理操作员，没有保存状态。不使用循环。很好，不是吗？</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/554870ede98bccfc99fac5258a65128b.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/1*L7Evvi-PcaV_7m5wCrciXQ.gif"/></div></figure><p id="e738" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数式语言的特性是为支持纯函数编写程序而设计的。在函数式编程中，我们使用函数递归而不是循环来遍历值集。大多数函数式编程支持高阶函数、lambda函数、匿名函数、闭包、函数递归等特性。赋予功能更多的权力。</p><h1 id="b72b" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">函数式编程的特点:</h1><p id="d251" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">大多数函数式编程语言支持以下特性:</p><h2 id="38ec" class="lv kn hi bd ko lw lx ly ks lz ma mb kw jg mc md la jk me mf le jo mg mh li mi bi translated">高阶函数:</h2><p id="6d68" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank">高阶函数</a>是既可以接受其他函数作为参数，也可以返回一个函数作为结果的函数。</p><h2 id="dd3f" class="lv kn hi bd ko lw lx ly ks lz ma mb kw jg mc md la jk me mf le jo mg mh li mi bi translated">一流的功能:</h2><p id="04c9" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">函数是函数式编程中的一等公民，这意味着对它们的使用没有限制。它们可以出现在程序中的任何地方，就像数字等其他一级实体一样。例如，我们可以将一个函数赋给一个变量，将其作为参数传递给其他函数，并可以将它们用作函数的返回值。</p><h2 id="4b71" class="lv kn hi bd ko lw lx ly ks lz ma mb kw jg mc md la jk me mf le jo mg mh li mi bi translated">递归:</h2><p id="c857" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">函数式语言中的迭代(循环)通常是通过递归实现的。递归函数调用它们自己，它不断重复，直到到达基本情况。</p><h2 id="87c5" class="lv kn hi bd ko lw lx ly ks lz ma mb kw jg mc md la jk me mf le jo mg mh li mi bi translated">懒评:</h2><p id="f376" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">惰性计算不计算函数参数，除非需要它们的值来计算函数调用本身。</p><h2 id="f697" class="lv kn hi bd ko lw lx ly ks lz ma mb kw jg mc md la jk me mf le jo mg mh li mi bi translated">参考透明度:</h2><p id="aeb5" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">函数式程序是引用透明的，这意味着任何变量都可以用它的实际值替换。这消除了任何副作用的可能性，因为变量的值一旦定义就永远不会改变。</p><p id="7f2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">赋值语句从来都不是引用透明的，这也是函数式编程中不提倡使用赋值语句的原因之一。考虑下面的例子，这里变量total的初始值是0，但是我们不能用它的值替换变量total的所有出现，即0，因为它在每次迭代时都被赋予新的值。因此，我们可以说下面的程序是不透明的。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="11ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，考虑下面的例子，我们可以用它的值代替n的所有出现，因为它在整个程序中不会改变。所以，我们可以把下面的程序称为引用透明的。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h2 id="a5f8" class="lv kn hi bd ko lw lx ly ks lz ma mb kw jg mc md la jk me mf le jo mg mh li mi bi translated"><strong class="ak">函数式编程与程序式编程:</strong></h2><p id="ccf4" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">在过程式编程中，程序的执行是一系列命令性的命令，这些命令可能会隐式地改变共享状态(上例中的变量total(图1.1)是共享的)。</p><p id="8419" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在函数式编程中，程序的执行是对复杂表达式的求值，这些表达式只在输入参数和返回值方面相互依赖。由于这个原因，函数式程序可以有一个自由的代码执行顺序。此外，函数之间没有共享的元素/状态，这意味着它们可以独立使用而不会相互影响。当涉及到并发和多线程编程时，这种方法是有益的。</p><h1 id="ce5c" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">逻辑编程:</h1><p id="dd1d" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">在编程的逻辑风格中，首先，我们定义一些已知的事实和规则，使计算机意识到问题域。然后，当我们向计算机提出查询时，它会根据最初给定的事实和规则进行一些逻辑推理，并返回我们问题的解决方案。逻辑编程语言包括Prolog、answer set programming (ASP)和Datalog。</p><p id="d84c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">逻辑范式采用声明式方法来解决问题。在逻辑编程中，我们有各种各样的逻辑断言，它们的执行是使用一个模型生成器来完成的，它的行为不受程序员的控制。我们可以使用以<em class="lr">子句形式编写的规则创建逻辑断言，在下面的序言示例中，H是head，B是body:</em></p><blockquote class="mj"><p id="ace5" class="mk ml hi bd mm mn mo mp mq mr ms js dx translated">H :- B。</p><p id="5b3a" class="mk ml hi bd mm mn mo mp mq mr ms js dx translated">诗人(X) :-人类(X)。</p></blockquote><p id="8d80" class="pw-post-body-paragraph iv iw hi ix b iy mt ja jb jc mu je jf jg mv ji jj jk mw jm jn jo mx jq jr js hb bi translated">我们这样理解——如果X是人，那么X就是诗人。</p><p id="6073" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事实是没有主体的规则，以简化形式写成:</p><blockquote class="mj"><p id="03b4" class="mk ml hi bd mm mn mo mp mq mr ms js dx translated">H.</p><p id="b7c5" class="mk ml hi bd mm mn mo mp mq mr ms js dx translated">动物(猫)</p></blockquote><p id="0725" class="pw-post-body-paragraph iv iw hi ix b iy mt ja jb jc mu je jf jg mv ji jj jk mw jm jn jo mx jq jr js hb bi translated">我们把这理解为——猫是一种动物。</p><p id="081a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是教计算机山姆喜欢吃什么和不喜欢吃什么的示例规则。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="4486" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像计算机知道山姆的好恶一样，现在我们可以问这样的问题，山姆是否喜欢paneer_tikka？</p><blockquote class="mj"><p id="131b" class="mk ml hi bd mm mn mo mp mq mr ms js dx translated">？-喜欢(sam，paneer_tikka)。</p><p id="0eed" class="mk ml hi bd mm mn mo mp mq mr ms js dx translated">没错。</p></blockquote><p id="61de" class="pw-post-body-paragraph iv iw hi ix b iy mt ja jb jc mu je jf jg mv ji jj jk mw jm jn jo mx jq jr js hb bi translated">我们还可以查询sam喜欢使用的所有菜肴:</p><blockquote class="mj"><p id="ecc6" class="mk ml hi bd mm mn mo mp mq mr ms js dx translated">？-喜欢(山姆，X)。<br/>X = paneer _ ti kka；<br/> X =烙饼；<br/> X =面条；<br/> X =客家_面条；<br/> X =披萨；<br/> X =意大利面；</p></blockquote><p id="7757" class="pw-post-body-paragraph iv iw hi ix b iy mt ja jb jc mu je jf jg mv ji jj jk mw jm jn jo mx jq jr js hb bi translated">看，我们只是让计算机给我们X的值，但是我们没有告诉计算机如何得到X的值，这是一种声明式的编程方式。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es my"><img src="../Images/4a21355086340b9df41d53e4bd72e7ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*fswx-X7Teh6t8Emnq3Aw3Q.gif"/></div></figure><p id="a471" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢你阅读这篇博客。我希望您喜欢这个关于<a class="ae iu" rel="noopener" href="/analytics-vidhya/programming-paradigms-cb560f5125a1">编程范例</a>的系列文章，并且学到了一些新东西。如果你有任何建议或问题，请在下面的评论中添加，快乐学习👏。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es my"><img src="../Images/e0a9e971734cdeb455e4b6d28aaf8546.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*XFYQZLRrE0h8fjDjAxQuhA.gif"/></div></figure><h1 id="dbf4" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">我的更多信息:</h1><div class="mz na ez fb nb nc"><a rel="noopener follow" target="_blank" href="/@shivam.gosavi340_58315/programming-paradigms-cb560f5125a1"><div class="nd ab dw"><div class="ne ab nf cl cj ng"><h2 class="bd hj fi z dy nh ea eb ni ed ef hh bi translated">编程范例</h2><div class="nj l"><h3 class="bd b fi z dy nh ea eb ni ed ef dx translated">什么是编程范式？</h3></div><div class="nk l"><p class="bd b fp z dy nh ea eb ni ed ef dx translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq io nc"/></div></div></a></div><div class="mz na ez fb nb nc"><a rel="noopener follow" target="_blank" href="/@shivam.gosavi340_58315/demystifying-kotlin-data-classes-a806f90368b3"><div class="nd ab dw"><div class="ne ab nf cl cj ng"><h2 class="bd hj fi z dy nh ea eb ni ed ef hh bi translated">揭开Kotlin数据类的神秘面纱</h2><div class="nk l"><p class="bd b fp z dy nh ea eb ni ed ef dx translated">medium.com</p></div></div><div class="nl l"><div class="nr l nn no np nl nq io nc"/></div></div></a></div><div class="mz na ez fb nb nc"><a rel="noopener follow" target="_blank" href="/@shivam.gosavi340_58315/demystifying-the-concept-of-uri-6dcc82fdeef5"><div class="nd ab dw"><div class="ne ab nf cl cj ng"><h2 class="bd hj fi z dy nh ea eb ni ed ef hh bi translated">揭开URI概念的神秘面纱</h2><div class="nj l"><h3 class="bd b fi z dy nh ea eb ni ed ef dx translated">理解统一资源标识符(URI)概念的新系列文章。</h3></div><div class="nk l"><p class="bd b fp z dy nh ea eb ni ed ef dx translated">medium.com</p></div></div><div class="nl l"><div class="ns l nn no np nl nq io nc"/></div></div></a></div><div class="mz na ez fb nb nc"><a rel="noopener follow" target="_blank" href="/@shivam.gosavi340_58315/productivity-hacks-200f235a0acc"><div class="nd ab dw"><div class="ne ab nf cl cj ng"><h2 class="bd hj fi z dy nh ea eb ni ed ef hh bi translated">生产力黑客</h2><div class="nj l"><h3 class="bd b fi z dy nh ea eb ni ed ef dx translated">提高软件工程师生产力的一些技巧和工具。</h3></div><div class="nk l"><p class="bd b fp z dy nh ea eb ni ed ef dx translated">medium.com</p></div></div><div class="nl l"><div class="nt l nn no np nl nq io nc"/></div></div></a></div></div></div>    
</body>
</html>