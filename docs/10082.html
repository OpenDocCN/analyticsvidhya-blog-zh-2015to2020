<html>
<head>
<title>Binary Crossentropy in its core!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核心的二元交叉熵！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/binary-crossentropy-in-its-core-35bcecf27a8a?source=collection_archive---------6-----------------------#2020-10-04">https://medium.com/analytics-vidhya/binary-crossentropy-in-its-core-35bcecf27a8a?source=collection_archive---------6-----------------------#2020-10-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4007" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这是一个在深度学习中广泛使用的损失函数，但可悲的是，每个人都只是告诉了函数的名称&amp;可能是可以使用它的情况，没有人告诉现实中应该使用它的时候这个函数是什么，它内部是如何工作的？这个博客旨在全面深入地解释二元交叉熵的一切，涵盖其中使用的每一个公式和概念。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/11f80fba207e9aaac0f3b7107e3432dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XLObDzN-zj6QagIZrv3tEA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn">来源:</strong><a class="ae jo" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd jn">Unsplash</strong></a><strong class="bd jn">via</strong><a class="ae jo" href="https://unsplash.com/@hishahadat" rel="noopener ugc nofollow" target="_blank"><strong class="bd jn">Shahadat Rahman</strong></a></figcaption></figure><p id="352e" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><strong class="jr hj">二元交叉熵是仅在两个类别之间存在分类问题时使用的损失函数。</strong></p><p id="6f20" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">从名称<em class="kl">二进制来看，它是不言自明的，</em>它意味着 2 个量，这就是为什么它以适合 2 个量的分类问题的方式来构造。</p><p id="4ea8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在开始这个损失/成本/误差函数的内部工作之前，我建议你阅读我写的关于均方误差的重要性的博客(链接就在这一段下面)，它帮助你为这个函数的工作打下更基础。</p><div class="km kn ez fb ko kp"><a rel="noopener follow" target="_blank" href="/@harshitdawar/significance-of-mean-squared-error-in-data-science-4c4c08da3023"><div class="kq ab dw"><div class="kr ab ks cl cj kt"><h2 class="bd hj fi z dy ku ea eb kv ed ef hh bi translated">均方差在数据科学中的意义！</h2><div class="kw l"><h3 class="bd b fi z dy ku ea eb kv ed ef dx translated">本博客旨在解释在机器学习、深度学习或其他领域使用均方差的必要性和逻辑</h3></div><div class="kx l"><p class="bd b fp z dy ku ea eb kv ed ef dx translated">medium.com</p></div></div><div class="ky l"><div class="kz l la lb lc ky ld jh kp"/></div></div></a></div><h1 id="440f" class="le lf hi bd jn lg lh li lj lk ll lm ln io lo ip lp ir lq is lr iu ls iv lt lu bi translated">二元交叉熵的作用！</h1><p id="7120" class="pw-post-body-paragraph jp jq hi jr b js lv ij ju jv lw im jx jy lx ka kb kc ly ke kf kg lz ki kj kk hb bi translated">当问题中有离散输出时，这是一个损失/成本/误差函数，更具体地说，当只有 2 个离散量时，该函数是深度学习中的最佳选择。</p><h1 id="a328" class="le lf hi bd jn lg lh li lj lk ll lm ln io lo ip lp ir lq is lr iu ls iv lt lu bi translated">二元交叉熵的内部工作原理！</h1><p id="e3c6" class="pw-post-body-paragraph jp jq hi jr b js lv ij ju jv lw im jx jy lx ka kb kc ly ke kf kg lz ki kj kk hb bi translated">由于该函数与离散量一起使用，因此在使用均方误差(如上述博客所述)时出现连续值的情况下，在该场景中使用<strong class="jr hj">概率质量函数(PMF)</strong>而不是<strong class="jr hj">概率密度函数(PDF)</strong>。</p><p id="a9e9" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">该函数中使用的 PMF 由下面给出的等式表示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ma"><img src="../Images/1103b2207e0c3b0e47eebeae9d92acd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*AbqViWV4DA4iT8a-2khrDg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn"> PMF 为二进制交叉熵！【作者图片】</strong></figcaption></figure><p id="05b9" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在上面的等式中，x 是常数，因为它已经存在于数据中，μ是变量。</p><p id="54f8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">因此，来自 PMF 的<strong class="jr hj">可能性(我们希望(在这种情况下，记录属于某个类别的可能性)最大化，[更多信息请参考上面提到的博客]) </strong>可以表示为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/c55d445c24acce169f3934c301643adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgD3Mk19SyZ7SEql5iZmBA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn">似然(PMF 所有 x 的乘积)！【作者图片】</strong></figcaption></figure><blockquote class="mc"><p id="d6b1" class="md me hi bd mf mg mh mi mj mk ml kk dx translated">现在，为了进行计算，我们应该取这个函数的对数，因为这样使用导数最小化/最大化就变得容易了。允许在处理之前获取日志的原因是日志是单调递增的函数，因此它用于简化工作。</p></blockquote><p id="5cbd" class="pw-post-body-paragraph jp jq hi jr b js mm ij ju jv mn im jx jy mo ka kb kc mp ke kf kg mq ki kj kk hb bi translated">对数可能性为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/1f788b56f928885a30cc0657f35af6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yuOvRuqI1hEpTZ8RBptbEg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">对数可能性！【作者图片】</figcaption></figure><p id="c8de" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><strong class="jr hj">由于我们希望最大化我们的期望，即每个记录落入特定类别的概率，为了实现这一点，必须在上面的对数似然方程中找出“μ”的值。</strong></p><p id="42f3" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">为了使可能性最大化，我们的老朋友“微积分”会在这方面帮助我们，我相信你们都记得计算最大值的方法是通过求导&amp;将其赋值为 0。因此，在对上述对数似然函数对“mu”取偏导数后，我们继续，输出为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ms"><img src="../Images/40ab08ba7c281e4ed29ad041e8b5bef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*ybJk4TUSDnWZIQhS8DBweg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn">图片作者！</strong></figcaption></figure><blockquote class="mt mu mv"><p id="98a0" class="jp jq kl jr b js jt ij ju jv jw im jx mw jz ka kb mx kd ke kf my kh ki kj kk hb bi translated"><strong class="jr hj">上述等式并不类似于所有 x 值的平均值，实际上，在该函数中，在上述等式中，x(i)的概率值为 1 或 0。例如，在掷硬币游戏中，如果我们在寻找正面，那么如果正面出现，那么 x(i)的值将为 1，否则为 0。</strong></p></blockquote><p id="b455" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这样，上述等式将计算出所有事件中预期结果的实际概率。</p><p id="f033" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在，有一个<strong class="jr hj">非常重要的概念，</strong>如果我们<strong class="jr hj">最大化可能性</strong>，或者我们<strong class="jr hj">最小化负对数可能性(它是预测中的实际误差&amp;实际值)</strong>，这是完全相同的事情。</p><p id="d4e5" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">因此，负对数似然将为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/886fa9eb49736458d8988cee9880f3b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXGJNo89LKsWqeBvncBQTA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn">负对数可能性！【作者图片】</strong></figcaption></figure><blockquote class="mc"><p id="9250" class="md me hi bd mf mg mh mi mj mk ml kk dx translated">为了使上述函数成为二元交叉熵，只需改变 2 个变量，即“mu”将变成 y_pred(对应于 I 的最大概率的类)[y(I)基于最大概率被分类到的类]，这与上面的“mu”等式完全相同。第二个改变的是 x(i)，它将被写成 y(i ),这是数据中的值。这将通过二进制交叉熵来计算，以最小化误差。</p></blockquote><p id="012b" class="pw-post-body-paragraph jp jq hi jr b js mm ij ju jv mn im jx jy mo ka kb kc mp ke kf kg mq ki kj kk hb bi translated">因此，现在我们有:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/d11933a8625bdaef4b8f0c52d62bb939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQmyc7sD4kemZQ8rHhS9BQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn">图片作者！</strong></figcaption></figure><p id="920c" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在现实中，考虑到平均误差，现在在上面的函数中，用它除以样本数，会得到真实的二进制交叉熵代价/误差/损失函数。</p><p id="4daf" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><strong class="jr hj">最后，二元交叉熵函数:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/5b17c59b9eae5498224096bc2dea91c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6cOD3HPY11vw9J1hAAfug.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn">二元交叉熵函数！【作者图片】</strong></figcaption></figure><p id="39f9" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这就结束了深度学习二元交叉熵中非常重要的损失函数的解释和内部工作。</p></div><div class="ab cl nc nd gp ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hb hc hd he hf"><p id="b3ba" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><strong class="jr hj"> <em class="kl">我希望我的文章用所有深刻的概念和解释来解释与话题相关的每一件事。非常感谢你花时间阅读我的博客&amp;，增加你的知识。如果你喜欢我的作品，那么我请求你为这个博客鼓掌！</em>T3】</strong></p></div></div>    
</body>
</html>