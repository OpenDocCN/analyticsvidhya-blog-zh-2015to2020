<html>
<head>
<title>Deploy Your First Docker Container — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部署您的第一个 Docker 容器—第 2 部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deploy-your-first-docker-container-part-2-d101448600bf?source=collection_archive---------20-----------------------#2020-10-05">https://medium.com/analytics-vidhya/deploy-your-first-docker-container-part-2-d101448600bf?source=collection_archive---------20-----------------------#2020-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3c21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上一篇文章中，我们学习了如何搜索和运行特定的部署映像。现在，我们将进一步了解部署您第一个 docker 容器的步骤:</p><p id="0ed6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步:寻找运行中的容器</strong></p><p id="9146" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动的容器在后台运行，docker ps 命令列出了所有正在运行的容器、用于启动容器的映像和正常运行时间。</p><p id="9191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该命令还显示友好的名称和 ID，可用于查找有关各个容器的信息。</p><p id="31e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">命令</p><blockquote class="jd je jf"><p id="f18f" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">码头工人检查<friendly-name/></p></blockquote><p id="5615" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">提供有关正在运行的容器的更多详细信息，如 IP 地址。</p><p id="bd98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">命令</p><blockquote class="jd je jf"><p id="27dd" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">码头日志<friendly-name/></p></blockquote><p id="d027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将显示容器已写入标准错误或标准输出的消息。</p><p id="0abd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第三步:访问 Redis </strong></p><p id="6f0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Jane 很高兴 Redis 正在运行，但是很惊讶她不能访问它。原因是每个容器都是沙箱化的。如果服务需要由不在容器中运行的进程访问，那么端口需要通过主机公开。</p><p id="cbc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦公开，就可以像在主机操作系统本身上运行一样访问该进程。</p><p id="6a86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Jane 知道，默认情况下，<em class="jg"> Redis </em>运行在端口<em class="jg"> 6379 </em>上。她已经了解到，默认情况下，其他应用程序和库期望一个<em class="jg"> Redis </em>实例在端口上侦听。</p><p id="23fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阅读文档后，Jane 发现当使用<em class="jg"> -p &lt;主机端口&gt; : &lt;容器端口&gt; </em>选项启动容器时，端口被绑定。Jane 还发现在启动容器时定义一个名称很有用，这意味着她不必使用 Bash 管道或者在试图访问日志时一直查找名称。</p><p id="2152" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Jane 找到了在后台运行<em class="jg"> Redis </em>的最佳方法，在端口<em class="jg"> 6379 </em>上运行一个名为<em class="jg"> redisHostPort </em>的端口，使用下面的命令<code class="du jk jl jm jn b">docker run -d --name redisHostPort -p 6379:6379 redis:latest</code></p><h2 id="81ad" class="jo jp hi bd jq jr js jt ju jv jw jx jy iq jz ka kb iu kc kd ke iy kf kg kh ki bi translated">步骤 4:端口映射</h2><p id="214e" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">在固定端口上运行进程的问题是，您只能运行一个实例。Jane 更喜欢运行多个 Redis 实例，并根据 Redis 运行的端口来配置应用程序。</p><p id="1e53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过试验，Jane 发现仅仅使用选项<em class="jg"> -p 6379 </em>就能使她暴露<em class="jg"> Redis </em>但是是在一个随机可用的端口上。她决定用<code class="du jk jl jm jn b">docker run -d --name redisDynamic -p 6379 redis:latest</code>来测试她的理论</p><p id="dca8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这种方法有效，但她现在不知道分配了哪个端口。谢天谢地，这是通过<code class="du jk jl jm jn b">docker port redisDynamic 6379</code>发现的</p><p id="5957" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Jane 还发现，列出容器会显示端口映射信息，<code class="du jk jl jm jn b">docker ps</code></p><p id="feb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">下一步，我们将继续第三部分</strong></p></div></div>    
</body>
</html>