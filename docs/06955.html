<html>
<head>
<title>THE STORY OF LOGISTIC REGRESSION…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归的故事…</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-story-of-logistic-regression-3a978fdc4fe2?source=collection_archive---------12-----------------------#2020-06-08">https://medium.com/analytics-vidhya/the-story-of-logistic-regression-3a978fdc4fe2?source=collection_archive---------12-----------------------#2020-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/4d151e22705c427fa045b136413e7c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*eDeJCcodhj72njIo0x5j0A.jpeg"/></div></figure><p id="33af" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">逻辑回归是一种简单而优雅的分类技术，通常用于寻找能最好地分离正负点的超平面(多维)或线(2D ),或者说逻辑回归是二元分类的最好技术之一。</p><p id="9fe5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我将非常直接地解释LR中的所有细节(现在简称为逻辑回归)。</p><h2 id="fc9b" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">这是一个奇妙的算法，只要把算法当成一个故事，把它的方程当成一首诗，你就会自动爱上机器学习。</h2><p id="2673" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">那我们开始吧，</p><p id="7176" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以LR的目标是找到能最好地分离正负点或分离两个不同类的超平面。</p><p id="9705" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本系列文章中，我将尝试通过几何和损失函数来解释LR算法。</p><p id="175f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们从地理开始</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kk"><img src="../Images/18febb9615fdcbec8b9ef3e96eca1dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AB9b-cP4zVJpZdHmEFTRag.jpeg"/></div></div></figure><p id="9872" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上图中，我们可以看到有两个不同的类别，假设橙色是正的，蓝色是负的，现在我们的目标是找到最佳可能的直线(如果2D)或最佳可能的超平面(如果多维)，那么直线的方程是什么</p><p id="7cdf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">y=mx+c，其中c是截距，m是直线的斜率。</p><p id="3e7a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">超平面的方程是什么？</p><p id="1f0b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">w^T *x+b=0，其中t表示转置，等式表示(w转置x+b)，其中w是维数为d的向量，x也是维数为d的向量，b是标量(截距)。</p><p id="2c4e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里的“w”始终垂直于超平面。</p><p id="387b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以如果我对所有的维度进行推广，我可以说在LR中，我们需要找到超平面的方程</p><p id="da5b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">w^T *x+b=0</p><h2 id="8d3f" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">所以基本上任务很简单，我只需要找到w和b。</h2><p id="fbc4" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">这里我们做了一个很大的假设，如果你注意到我们说我们只需要找到一个超平面来分离两个类，如果这两个类不是线性可分离的呢？</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kt"><img src="../Images/e3d5d54a26f3bc5050d2ac831d9da3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJb27vw0946H63N43gcqqw.jpeg"/></div></div></figure><p id="e539" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">比如上图。</p><p id="37ce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="ku">逻辑回归假设——我们假设类是线性可分的</em> </strong></p><p id="dfa9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你读过我的其他文章，我们也看到了朴素贝叶斯和KNN的一些假设</p><p id="e318" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="ku">假设朴素贝叶斯-特征是有条件独立的</em> </strong></p><p id="02f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="ku">KNN假设——一个点的邻域与一个点</em> </strong>相同</p><p id="c373" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们回到逻辑回归，所以我们知道假设，现在我们知道如果类不是线性可分的，我们不能使用逻辑回归。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kv"><img src="../Images/523f00b0631b5bf0f7a31d277302ca4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXpfUoU8xuS-TJp12ZK12g.jpeg"/></div></div></figure><p id="b6a3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">举个例子，我们有两个类，正的和负的，假设有一个正的点时y=+1，有一个负的点时y=-1。现在有人会问，为什么我们在其他算法中取y=0，而在这里取y=-1。我一会儿会谈到这一点。</p><p id="6bf1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以现在我们有了属于{-1，+1}的yi</p><p id="6acf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们知道离超平面的距离是di=w^T*xi/||w||，这里w垂直于超平面和一个单位向量所以||w||是1，那么</p><p id="c0a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">di=w^T*xi(从超平面到所有正点的距离)</p><p id="3508" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如图所示，假设xi是所有的正点，xj是所有的负点。</p><p id="0ba8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后dj=w^T*xj(distance从双曲线到所有的负点)</p><p id="452a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以说</p><p id="99a4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">di=w^T*xi &gt; 0 (w和xi向量在同一侧)</p><p id="2de7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">0然后易=+1</p><p id="af30" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果w^T*xi &lt;0 then yi=-1</p><p id="5b31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ku">现在我想提一个小细节，这个分类器不是完美的，这也会出错，就像对于xq点&gt; 0但是yi=-1所以很明显这个分类器会出错。</em></p><p id="0396" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看一些案例:</p><p id="b54f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">案例1</p><p id="e841" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果易=+1而w^T*xi&gt;0</p><h2 id="7302" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">然后，<strong class="io hj"><em class="ku">&gt;0</em></strong></h2><p id="d241" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">案例2</p><p id="c11b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果易=-1、&lt;0</p><h2 id="d901" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">then, <strong class="io hj"> <em class="ku">、&gt;</em></strong></h2><p id="c91c" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">它仅仅意味着当分类器正确分类时，<strong class="io hj"> <em class="ku"> yi*w^T*xi &gt; 0这个条件满足。</em> </strong></p><p id="d4aa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">案例3</p><p id="8dcd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果易=+1、&lt;0</p><h2 id="b1ab" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">then, <strong class="io hj"> <em class="ku">、&lt; 0、</em> </strong></h2><p id="8701" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">案例4</p><p id="13df" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果易=-1和</p><h2 id="4bee" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">然后，<strong class="io hj"><em class="ku">yi*w^t*xi&lt;0</em></strong></h2><p id="62bd" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">它仅仅意味着每当分类器分类错误时，<strong class="io hj"> <em class="ku"> yi*w^T*xi &lt; 0这个条件满足。</em> </strong></p><p id="ead7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是我们把负点设为y=-1的原因。</p><p id="d29a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么我们的主要目标是什么，得到最少的错误分类点和最多的分类点，所以基本上我们想要的是尽可能多的点</p><p id="ef70" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">yi*w^t*xi 0，所以如果我们找到一个平面，它的w满足上述条件，我们就完成了。 </p><h2 id="3d2d" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">我们有一个优化问题，我们需要找到最大化上述条件的最佳w*</h2><p id="6812" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">优化问题可以在下图中看到。</p><p id="9ce4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如我告诉你的，对我来说，算法是故事，方程是诗歌，所以让我们从这个故事的第二部分开始。 </p><p id="5bef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们有了一个基本的数学问题，我们需要得到“w”或超平面，使其最大化带符号的distance(yi*w^T*xi).的总和</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kw"><img src="../Images/44973eac9b005c63fe3079a280cbdafa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsGf2rwKFYKhaBHkMuiK3w.jpeg"/></div></div></figure><p id="0431" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们看看这个陈述有什么问题，我们如何优化我们的解决方案，让我们举一个简单的例子，我们有一个离群值。所以对于所有的“x”，yi=1(我们假设图中所有的“x”都是正的，所有的“0”都是负的)，所以对于图中所有的“0”，yi=-1。</p><p id="0aa5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看一些案例…</p><p id="65b8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">情况1:现在的任务仍然是找到最佳的“w”或超平面，它使符号距离的和最大化，所以假设算法找到了超平面1(如下图所示)，让我们找到图片的符号距离的和。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kx"><img src="../Images/49091ebeb657dd74415be7752897f7a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3DlwVgu0z6pSUa1r_WzgQ.jpeg"/></div></div></figure><p id="b020" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除了离群点，所有的点到超平面的距离都是1，离群点到超平面1的距离是100。</p><p id="48f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在图中我们可以看到sum结果是-90。</p><p id="e13a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">情况2:现在的任务仍然是找到最佳的“w”或超平面，它使符号距离之和最大化，所以假设算法找到了超平面2(如下图所示)，让我们找到图片的符号距离之和。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es ky"><img src="../Images/bfc32efd2e0e1b85ff621aad97a6dce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6apk4Os6k6kXl1n9vNcMg.jpeg"/></div></div></figure><p id="dd72" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于除离群点之外的所有点，距超平面的距离增加1，离群点距超平面2的距离为1。</p><p id="d66d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这幅图中，我们可以看到总和为1</p><p id="b70f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="ku">现在，如果我们按照陈述“我们想要最大化符号距离的和的超平面，我们将选择超平面2(和是1)而不是超平面1(和是-90°)，但是如果我们直觉地思考，超平面1是最好的分类器，只有一个错误。</em>T3】</strong></p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kz"><img src="../Images/bea915d1769009822e1de1dff63e316d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b2OE57ZuflkQ6eAcTpq5iQ.jpeg"/></div></div></figure><p id="a137" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在该怎么办？</p><p id="de1e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们能不能想出一些东西，可以减少额外的距离，因为我们刚刚从离群值中得到这个问题。</p><h2 id="48a7" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated"><strong class="io hj"> <em class="ku">如果带符号的距离很小——按原样使用带符号的距离</em> </strong></h2><p id="4761" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated"><strong class="io hj"> <em class="ku">如果带符号的距离很大——使用一个可以逐渐减少额外距离的功能</em> </strong></p><p id="cd39" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如下图所示，我绘制了有符号距离vs f(有符号距离)，这个f(有符号距离)必须能够像图中那样逐渐减少额外的距离。</p><p id="d442" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这种逐渐变小的距离被称为“挤压”。</p><p id="e374" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我们可以将优化方程替换为</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es la"><img src="../Images/acd75db5f1248674dd0c305c28a3e8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSyCkGC1pj-YmOjq2Gov-w.jpeg"/></div></div></figure><h2 id="9f2f" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">现在的问题是，使用哪个函数？</h2><p id="98a2" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">有许多函数可以帮助攻丝，但我们更喜欢如图所示的<strong class="io hj"><em class="ku">s形函数</em> </strong>，这有两个主要原因。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es lb"><img src="../Images/63a35bc4a531171cf90c44e659f8e48f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6FfcW3uRBmktRAp3Hen4BA.jpeg"/></div></div></figure><p id="abd9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它有一个很好的概率解释。</p><p id="b566" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">很容易求导，我们希望我们的函数容易求导，否则我们将无法解决优化问题。</p><ol class=""><li id="ff4b" class="lc ld hi io b ip iq it iu ix le jb lf jf lg jj lh li lj lk bi translated">一篇文章就够了，我会在下一篇文章中继续“<strong class="io hj">逻辑回归的故事</strong>”,</li><li id="36e0" class="lc ld hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">感谢您的阅读，请在评论中分享您的想法。</li></ol><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es lq"><img src="../Images/5b8f3186cf519b521baecabb2a86e6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avz7Hy85GDZYpQ4NirudgQ.jpeg"/></div></div></figure><p id="f7d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi">Thats enough for one article, i will continue “<strong class="io hj">The story of Logistic Regression</strong>” in next articles,</p><h2 id="5463" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi">THANKS FOR READING AND PLEASE SHARE YOUR THOUGHTS IN COMMENTS.</h2></div></div>    
</body>
</html>