<html>
<head>
<title>Understanding Genetic Algorithms in the Artificial Intelligence Spectrum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解人工智能领域的遗传算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-genetic-algorithms-in-the-artificial-intelligence-spectrum-7021b7cc25e7?source=collection_archive---------0-----------------------#2018-09-05">https://medium.com/analytics-vidhya/understanding-genetic-algorithms-in-the-artificial-intelligence-spectrum-7021b7cc25e7?source=collection_archive---------0-----------------------#2018-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/ac7a07454f3a4130a8e003c8a297b234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8uOjh_VBbSxiGAeb.jpg"/></div></div></figure><div class=""/><p id="8666" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">近来，遗传学领域在人工智能领域受到了很多关注。我们已经看到最近科学研究中发生的突破，但是大多数人甚至不知道如何开始理解这个领域。</p><p id="cfa4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在这篇文章中，我将向您介绍遗传算法是如何工作的，以及为什么您下次构建神经网络模型时应该考虑它。让我们开始吧！</p><h2 id="2cac" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">目录</h2><ol class=""><li id="8ee0" class="kj kk ht is b it kl ix km jb kn jf ko jj kp jn kq kr ks kt bi translated">无限猴子定理</li><li id="2a20" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt bi translated">理解遗传算法</li><li id="44a9" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt bi translated">这些原则是如何在遗传算法中实现的</li><li id="b4e8" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt bi translated">如何在人工智能项目中使用它</li></ol><p id="9e4a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">无限猴子定理</em> </strong></p><p id="2dda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无限猴子定理指出，如果一只猴子开始在键盘上随机敲击按键无限长的时间，它几乎肯定会键入给定的文本，如威廉·莎士比亚全集。事实上，猴子几乎肯定会将所有可能的有限文本输入无限次。然而，这一事件的概率是如此之小，以至于它将需要比宇宙的估计年龄更长的时间，但这一事件发生的几率不是零。</p><p id="e63f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">证明</em> </strong></p><p id="f259" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设打字机有50个键，要打的字是“<strong class="is hu"> <em class="kz">【香蕉】</em> </strong>。如果按键被随机且独立地按下，则意味着每个按键被按下的机会相等。那么，打出的第一个字母是‘b’的几率是1/50，打出的第二个字母是‘a’的几率也是1/50，以此类推。因此，前六个字母拼成<strong class="is hu"> <em class="kz">【香蕉】</em> </strong>的几率是:</p><p id="7d37" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(1/50)×(1/50)×(1/50)×(1/50)×(1/50)×(1/50)=(1/50)6 = 1/15 625 000 000，即不到150亿分之一。但是仍然不为零，因此结果仍然是可能的。</p><p id="ed76" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，猴子会在15，625，000，000次中输入1次“香蕉”这个词。现在让我们假设猴子每秒敲击一个键，在最坏的情况下，这个事件发生的时间大约是495年。</p><p id="372d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我为上述问题模拟一个计算机程序，并对单词<strong class="is hu"> <em class="kz">【香蕉】</em> </strong>进行强力搜索，所涉及的计算量和时间将是巨大的。</p><p id="c7db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，如果我想键入相同的内容，我只需不到6秒钟就可以完成。为什么？因为我知道字母，我知道香蕉这个词和它的拼写。</p><p id="6372" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，我能使用进化论并显著改进我的程序吗？是的，这要归功于遗传算法的概念。</p><p id="1cd8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">理解遗传算法</em> </strong></p><p id="4160" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是一种受<strong class="is hu"> <em class="kz">达尔文自然选择理论</em> </strong>启发，解决<strong class="is hu"> <em class="kz">优化问题</em> </strong>的算法。这是一个很好的解决方案，尤其是在信息不完整或不完善，甚至计算能力有限的情况下。</p><p id="0cd6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在达尔文的自然选择理论中，进化发生所必需的三个主要原则是:</p><p id="bbc6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1) <strong class="is hu"/></p><p id="9dd4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2) <strong class="is hu"/></p><p id="b9d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3) <strong class="is hu"/></p><h2 id="5d4a" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">这些原则是如何在遗传算法中实现的</h2><p id="2d15" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">遗传算法有五个阶段:</p><p id="b10c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1.创建初始群体</p><p id="e283" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.定义适应度函数</p><p id="584f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.选择父母</p><p id="2703" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.制造交叉</p><p id="31b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.变化</p><p id="a144" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">创建初始种群</em> </strong></p><p id="98c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一步中，我们创建了一组由n个元素组成的群体。群体中的每个元素都是您想要解决的问题的解决方案。</p><p id="a9aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，假设这个群体是:</p><ul class=""><li id="babd" class="kj kk ht is b it iu ix iy jb ld jf le jj lf jn lg kr ks kt bi translated">巴哈马群岛</li><li id="a688" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">abcdef</li><li id="3d10" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">jklmn</li><li id="3c16" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi">….</li><li id="eb8c" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">所有其他6个字符的单词</li><li id="3bbc" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">mnopqr</li><li id="4a1b" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">stuvwx</li><li id="d16a" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">小屋</li></ul><p id="7919" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">定义一个适应度函数</em> </strong></p><p id="46ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">适应度函数决定了一个个体有多大可能适合被选择进行繁殖，这是基于它的适应度分数。让我们假设我们的适应度函数将为匹配我们的目标单词<strong class="is hu"> <em class="kz"> banana的每个字符分配适应度分数或概率百分比给来自群体的每个元素。</em> </strong></p><p id="4d56" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，假设这个群体是:</p><p id="0f91" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">要素，体能得分</em> </strong></p><ul class=""><li id="af87" class="kj kk ht is b it iu ix iy jb ld jf le jj lf jn lg kr ks kt bi translated">banyan，5 #(这个单词中有来自字母‘b’，‘a’，‘n’，‘a’，‘n’，‘a’的5个字符，它们是‘b’，‘a’，‘n’，‘a’，‘n’)</li><li id="d976" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">abcdef，2#(类似地，字母‘b’，‘a’，‘n’，‘a’，‘n’，‘a’中的两个字符出现在这个单词中，它们是‘a’和‘b’)</li><li id="e5ef" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">ijklmn，1 #(按照上面的规则，它只有一个匹配的单词—‘a’)</li><li id="3bda" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi">……, ..</li><li id="801b" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">所有其他6个字符的单词，..</li><li id="12d5" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">mnopqr，1</li><li id="c632" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">stuvwx，0</li><li id="4d0a" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">小屋，5</li><li id="fd83" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">等等…</li></ul><p id="0d2e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">选择双亲</em> </strong></p><p id="cc7c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一步背后的想法是选择最适合的个体，让他们把基因传递给下一代。人口中的两个要素是基于它们的适合度分数来选择的。在我们的案例中，我们选择具有高适应性分数的个体。</p><p id="5c61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，我们选择了这些元素，因为这些词在给定的人群中具有较高的适合度。</p><p id="e92d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">元素，体能得分</em> </strong></p><ul class=""><li id="a9fe" class="kj kk ht is b it iu ix iy jb ld jf le jj lf jn lg kr ks kt bi translated">榕树，5</li><li id="7deb" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">小屋，5</li></ul><p id="55bd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">制作交叉</em> </strong></p><p id="da61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是遗传算法中最重要的阶段。在这一步中，我们从选择的元素中重新生成一个新的<em class="kz"> n </em>元素群体。在这一步中，我们必须从上一步中选择的两个父单词中获得的字符中置换和组合尽可能多的单词。在我们的例子中，父词是'<strong class="is hu"> <em class="kz">榕树</em> </strong>'和'<strong class="is hu"> <em class="kz">小屋</em> </strong>'。</p><p id="6e3d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，我们可以从单词'<strong class="is hu"> <em class="kz">榕树</em> </strong>中挑选最后3个单词，从单词'<strong class="is hu"> <em class="kz">小屋</em> </strong>'中挑选前3个单词，并形成一个新单词作为'<strong class="is hu"> <em class="kz"> cabyan </em> </strong>'，</p><p id="ea4a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在应用来自单词'<strong class="is hu"> <em class="kz"> banyan </em> </strong>'和'<strong class="is hu"> <em class="kz"> cabana </em> </strong>'的所有可能组合之后，我们得到新的群体集合。</p><p id="9708" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，新的再现元素是:</p><p id="cd42" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">转载n个元素</em> </strong></p><ul class=""><li id="fa72" class="kj kk ht is b it iu ix iy jb ld jf le jj lf jn lg kr ks kt bi translated">残烟</li><li id="0ce0" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">卡比安</li><li id="e5a7" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">卡比纳</li><li id="b0ba" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">babyna</li><li id="9038" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi">……</li><li id="8d3a" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">从父词'<strong class="is hu"> <em class="kz">榕树</em> </strong>'和'<strong class="is hu"> <em class="kz">小屋</em> </strong>'的所有其他可能的组合</li><li id="f864" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">香蕉</li><li id="bc1e" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">扬巴克</li><li id="fbc4" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">等等…</li></ul><p id="2881" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">制造变异</em> </strong></p><p id="a124" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从交叉阶段开始，我们可能会得到一个对新的多样化群体的进化没有贡献的群体，并且我们的算法会过早地收敛。因此，我们需要从1%的新创建的人口中改变单词的顺序，以保持这种多样性。我们可以选择任何一种改变。</p><p id="96a1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，假设从1%的先前人口中我们得到像'<strong class="is hu"> <em class="kz"> banyan </em> </strong>'和'<strong class="is hu"> <em class="kz"> yanbac </em> </strong>'这样的词。现在，我们选择这些元素来创建新的群体，因为这些单词分别具有5和4的良好适合度分数，并且因此具有成为双亲的高概率。现在，如果我们从这两个单词中选取最后3个和前3个字母，并将它们组合起来，我们将得到'<strong class="is hu"><em class="kz"/></strong>'并且这个单词不再具有足够的生产力来获得任何新的多样化元素。</p><p id="8b96" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，如果我们对先前人口的1%进行变异，并通过简单地翻转两个单词中的第一个和最后一个字母来改变'<strong class="is hu"> <em class="kz">【榕树】</em> </strong>'和'<strong class="is hu"><em class="kz">【yanbac】</em></strong>'的字母，我们会得到'<strong class="is hu"><em class="kz">【nanyab】</em></strong>'和'<strong class="is hu"><em class="kz">【can bay</em></strong>'。现在，如果我们应用突变元素的最后3个和前3个字母的相同组合，我们得到'<strong class="is hu"><em class="kz"/></strong>'这与'<strong class="is hu"> <em class="kz">【燕燕】</em> </strong>'非常不同。(请注意，在mutation中，您可以随心所欲地改变元素。翻转第一个和最后一个元素只是本例中使用的一种随机方式)。</p><p id="f58e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">这个过程什么时候停止？</em> </strong></p><p id="126a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的人口数量是固定的。随着新元素的形成，具有低适应度分数的旧元素被移除。当群体已经收敛时，即没有与先前群体显著不同的新元素被再生，那么我们可以说遗传算法已经为我们的问题提供了一组解决方案。</p><p id="4280" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，当我们发现所有的人群都有来自单词<strong class="is hu"> <em class="kz"> banana的所有字母的组合时，健康值为6。</em> </strong></p><p id="e8e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">收敛</em> </strong></p><ul class=""><li id="4981" class="kj kk ht is b it iu ix iy jb ld jf le jj lf jn lg kr ks kt bi translated"><em class="kz"> nnbaaa </em></li><li id="998c" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">aaabnn</li><li id="8444" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">aabann</li><li id="d99d" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">阿巴安</li><li id="ac49" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi">……</li><li id="0b35" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated"><strong class="is hu"> <em class="kz">香蕉</em> </strong></li><li id="16f2" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">巴安</li></ul><p id="c448" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一个集合，也就是说，无论我们重复多少次以上的过程，我们都只能得到这些元素的集合。在我们的最终设置中，必须有单词banana，因此我们的模拟<strong class="is hu"> <em class="kz">无限猴子</em> </strong>程序键入单词banana的时间比使用蛮力要少得多。</p><p id="51bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">伪代码</em> </strong></p><ul class=""><li id="1722" class="kj kk ht is b it iu ix iy jb ld jf le jj lf jn lg kr ks kt bi translated">开始<br/> —创建初始种群</li><li id="b020" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">计算适合度</li><li id="b042" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">重复<br/> —选择<br/> —交叉<br/> —变异<br/> —计算适应度</li><li id="b35f" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">直到人口聚集</li><li id="f47c" class="kj kk ht is b it ku ix kv jb kw jf kx jj ky jn lg kr ks kt bi translated">停止</li></ul><p id="18c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">伟大的算法但是为什么要用在人工智能上？</em> </strong></p><p id="b430" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以实现遗传算法来学习神经网络的最佳超参数。为了学习超参数，我们应用如下步骤所述的遗传算法:</p><p id="38ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建多个神经网络的群体</p><p id="6287" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将超参数随机分配给所有神经网络</p><p id="2c3c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重复以下内容</p><p id="7198" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1.训练所有的神经网络。</p><p id="81b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.计算他们的训练成本(训练误差和正则项除外)</p><p id="8ff7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.根据以前的神经网络的成本，从该组超参数中计算适应度分数。最好的神经网络成本最低。因此，它的逆将给出高的适应值</p><p id="3ed3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.根据适合度选择两个最佳神经网络</p><p id="46eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.从中复制出新的神经网络</p><p id="6c9d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6.改变孩子的基因</p><p id="3d85" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7.对群体中的所有神经网络执行步骤5–7。在最新一代的末期，我们有了最佳的超参数</p><p id="a2d7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kz">结论</em> </strong></p><p id="00d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">遗传算法可以用来解决各种类型的优化问题。我们看到了如何用遗传算法处理人工智能中的超参数。这是一个很好的选择，值得你的下一个项目去看看！</p></div></div>    
</body>
</html>