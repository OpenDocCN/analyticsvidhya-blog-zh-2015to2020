<html>
<head>
<title>Updating Non-Primitive Columns Types Using SQLalchemy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQLalchemy更新非基本列类型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/updating-non-primitive-columns-types-using-sqlalchemy-and-postgres-12f8206ba457?source=collection_archive---------19-----------------------#2020-04-26">https://medium.com/analytics-vidhya/updating-non-primitive-columns-types-using-sqlalchemy-and-postgres-12f8206ba457?source=collection_archive---------19-----------------------#2020-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fff19cde7c0baa7f8468b03454e14416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqTiX_5lqRWf-_qw9oxOaA.jpeg"/></div></div></figure><p id="814d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我当时正在做一个简单的python项目——一个两人游戏，名为<a class="ae jo" href="https://en.wikipedia.org/wiki/Mancala" rel="noopener ugc nofollow" target="_blank"> Mancala </a>，我想把游戏保存在数据库中。在做了一点阅读之后，<em class="jp"> postgres </em>看起来像是与<em class="jp"> sqlalchemy </em>的正确决定，因为我想要保存的只是两个简单的表，用于我创建的两个对象，<em class="jp">棋盘</em>和<em class="jp">游戏</em>。</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="b217" class="jz ka hi jv b fi kb kc l kd ke">/***<br/>Mancala, shortly, has a board with 12 pits with 4 stones in each and 2 stores, one for each  player. the goal for player is to fill their store with as many stones as possible<br/>***/</span><span id="5f1e" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">from</strong> sqlalchemy <strong class="jv hj">import </strong>Column, ARRAY, Integer, String<br/><strong class="jv hj">from</strong> sqlalchemy.dialects.postgresql <strong class="jv hj">import</strong> UUID<br/><strong class="jv hj">from</strong> sqlalchemy.ext.declarative <strong class="jv hj">import </strong>declarative_base</span><span id="1f60" class="jz ka hi jv b fi kf kc l kd ke">Base = declarative_base()</span><span id="972f" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">class </strong>Board(Base):<br/>    __tablename__ = 'boards'</span><span id="e48b" class="jz ka hi jv b fi kf kc l kd ke">    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, unique=True, nullable=False)<br/>    pits = Column(ARRAY(Integer))<br/>    stores = Column(ARRAY(Integer))</span><span id="8ec0" class="jz ka hi jv b fi kf kc l kd ke">    game_id = Column(UUID(as_uuid=True), ForeignKey('games.id'))<br/>    game = relationship("Game", back_populates="board")</span><span id="5dd5" class="jz ka hi jv b fi kf kc l kd ke">    <strong class="jv hj">def</strong> <strong class="jv hj">__init__</strong>(self):<br/>        self.pits = [4] * 12 # amount on stones pits<br/>        self.stores = [0] * 2 # amount of stones in stores</span><span id="5c45" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj"><br/>class</strong> Game(Base):<br/>    __tablename__ = 'games'<br/>    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, unique=True, nullable=False)<br/>    player_1 = Column(String)<br/>    player_2 = Column(String)<br/>    turn = Column(String)</span><span id="094e" class="jz ka hi jv b fi kf kc l kd ke">    board = relationship("Board", uselist=False, back_populates="game")<br/>    <br/>    <strong class="jv hj">def</strong> <strong class="jv hj">__init__</strong>(self):<br/>        self.board = Board()<br/>        self.player_1 = player_1<br/>        self.player_2 = player_2</span></pre><p id="fd8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我选择<em class="jp"> postgres </em>的两个主要原因是</p><ol class=""><li id="4700" class="kg kh hi is b it iu ix iy jb ki jf kj jj kk jn kl km kn ko bi translated">Postgres支持数组对象作为列(以及其他对象，如JSON和字典，但在我的例子中，数组就足够了)。</li><li id="377c" class="kg kh hi is b it kp ix kq jb kr jf ks jj kt jn kl km kn ko bi translated">我的数据真的没那么复杂，这里的<a class="ae jo" href="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener ugc nofollow" target="_blank"> <em class="jp">吻</em>规则</a>说得真响亮。</li></ol><p id="5cc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我开始保存游戏，使用<a class="ae jo" href="https://docs.sqlalchemy.org/en/13/orm/session_basics.html" rel="noopener ugc nofollow" target="_blank"> sqlalchemy的会话</a>:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="d5fe" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">from</strong> sqlalchemy <strong class="jv hj">import</strong> create_engine<br/><strong class="jv hj">from</strong> sqlalchemy.orm <strong class="jv hj">import</strong> sessionmaker</span><span id="0f4e" class="jz ka hi jv b fi kf kc l kd ke"># database initialization<br/>engine = create_engine("postgresql://postgres:[pswd]@[host]/[DBname]")</span><span id="7422" class="jz ka hi jv b fi kf kc l kd ke">Base.metadata.create_all(engine)</span><span id="ae8d" class="jz ka hi jv b fi kf kc l kd ke"># tracking the games's objects<br/>Session = sessionmaker(engine, expire_on_commit=False)<br/>session = Session()<br/>session.add(game)<br/>session.commit()</span><span id="ce87" class="jz ka hi jv b fi kf kc l kd ke"># from now on, the game is being played</span></pre><p id="9335" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，请注意。从<em class="jp"> sqlalchemy </em>文档中我并不清楚，所以我想分享一下:当你开始一个会话，一个对象被它跟踪(<em class="jp"> session.add(some_obj) </em>)，<strong class="is hj">对象本身和它的关系也被跟踪</strong>(在我的例子中是<em class="jp"> board </em>)。也就是说，在对其中一个对象进行更改后，就不需要“添加”这些更改了。一个简单的<em class="jp"> session.commit() </em>就足以提交这些更改。</p><p id="bfcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在玩的时候检查了一下牌桌(当时是和我自己对弈)，我注意到了一个主要的错误:尽管<em class="jp">游戏</em>的记录被更新了，但是<em class="jp">棋盘</em>的记录不会更新并停留在初始状态——随着游戏的进行，玩家之间的回合交替被改变了。我还注意到<strong class="is hj">在</strong> <a class="ae jo" href="https://docs.sqlalchemy.org/en/13/orm/session_api.html#sqlalchemy.orm.session.Session.dirty" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="jp">会话</em> </strong>的<strong class="is hj"> <em class="jp">脏</em> </strong> <em class="jp"> </em>列表</a> <em class="jp">，</em>中没有出现棋盘的变化，就好像会话没有跟踪<em class="jp">棋盘</em>中的任何变化，即使对象本身确实发生了变化。</p><p id="5a79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">起初，我认为这与<em class="jp"> boards </em>表不是父表的事实有关，但这是一个错误的假设。我没有看到任何变化的原因与柱子的类型有关。看看<em class="jp">游戏</em>表中的列类型是如何被原语化的——它们只是<em class="jp">字符串</em> ( <em class="jp"> player_1 </em>、<em class="jp"> player_2 </em>和<em class="jp">回合</em>)。在<em class="jp"> boards </em>表中，列类型仅为数组，非原始对象类型，这就是导致“错误”的原因。</p><p id="ab30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果，一个<em class="jp"> sqlalchemy会话</em>通过引用跟踪变更<strong class="is hj">。</strong>在游戏过程中不会创建新的数组，随着游戏的进行，现有数组中的元素只会发生变化(石头从一个坑转移到另一个坑和商店)。<em class="jp">板</em>中修改数据的方法没有使用<a class="ae jo" href="https://github.com/sqlalchemy/sqlalchemy/blob/c61e0265a07e4310e7767fb6f9e0b84d8c89eb71/lib/sqlalchemy/ext/declarative/api.py#L77" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> __setattr__ </em>方法</a>，继承自<em class="jp"> Base </em>，因此<em class="jp">会话</em>没有跟踪任何修改。</p><p id="0551" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当发生变化时，我需要在实例本身的方法中标记属性为‘modified’。幸运的是，这正是<a class="ae jo" href="https://docs.sqlalchemy.org/en/13/orm/session_api.html#sqlalchemy.orm.attributes.flag_modified" rel="noopener ugc nofollow" target="_blank"><em class="jp">flag _ modified</em></a><em class="jp"/>所做的。用法非常简单，仅在更改数据的对象方法中需要:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="fa99" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">from </strong>sqlalchemy.orm.attributes <strong class="jv hj">import</strong> flag_modified</span><span id="fb8b" class="jz ka hi jv b fi kf kc l kd ke"><strong class="jv hj">class </strong>Board(Base):<br/>    ...<br/>    ...<br/>    ...</span><span id="5645" class="jz ka hi jv b fi kf kc l kd ke">    <strong class="jv hj">def </strong>remove_from_pit(self, pit_num):<br/>        in_pit = self.pits[pit_num]<br/>        self.pits[pit_num] = 0<br/>        flag_modified(self, 'pits') <strong class="jv hj"># here</strong><br/>        return in_pit<br/><br/>    <strong class="jv hj">def </strong>add_to_pit(self, pit_num):<br/>        self.pits[pit_num] += 1<br/>        flag_modified(self, 'pits') <strong class="jv hj"># here</strong><br/><br/>    <strong class="jv hj">def </strong>add_to_store(self, player_store):<br/>        self.stores[player_store] += 1<br/>        flag_modified(self, 'stores') <strong class="jv hj"># and here</strong></span></pre><p id="efc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问题解决了！</p><p id="dc5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再深入一点，继承了<em class="jp">游戏</em>和<em class="jp">棋盘</em>的<em class="jp"> declarative_base </em>的设计模式，被称为<strong class="is hj">观察者</strong>模式，在这里做了漂亮的解释<a class="ae jo" href="https://refactoring.guru/design-patterns/observer" rel="noopener ugc nofollow" target="_blank">。我这里的发布者是<em class="jp">板</em>，订阅者是<em class="jp">会话</em>。通过将<em class="jp"> flag_modified() </em>添加到更改数据的方法中，我将更改通知给了委员会的会议。</a></p><p id="6689" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">祝您编码愉快，并保持安全！</p></div></div>    
</body>
</html>