<html>
<head>
<title>Perceptron Learning Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">感知机学习算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/perceptron-learning-algorithm-7ae7c4b90eb2?source=collection_archive---------16-----------------------#2020-09-14">https://medium.com/analytics-vidhya/perceptron-learning-algorithm-7ae7c4b90eb2?source=collection_archive---------16-----------------------#2020-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="71f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上一篇文章中，我们讨论了 M-P 神经元，让我们向前迈进一步。</p><p id="0c56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你没有检查这是正确的时间来学习 M-P 神经元之前，你学习感知器。</p><div class="jd je ez fb jf jg"><a rel="noopener follow" target="_blank" href="/@siddharthshah2601/mcculloch-pitts-neuron-a-computational-model-of-biological-neuron-ce57239a951e"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">生物神经元的计算模型——麦卡洛克-皮茨神经元</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">麦卡洛克(神经科学家)和皮茨(逻辑学家)提出了一个高度简化的神经元计算模型。</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">medium.com</p></div></div><div class="jp l"><div class="jq l jr js jt jp ju jv jg"/></div></div></a></div><p id="7b6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道科学家每天都在发现新的东西。现在让我们来看看</p><h2 id="dd44" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">感知器是什么鬼:</h2><p id="5760" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们知道 M-P 神经元有局限性，所以为了克服 M-P 神经元的局限性，美国心理学家 Frank <strong class="ih hj"> Rosenblatt </strong>在 1958 年提出了经典的<strong class="ih hj">感知器</strong>模型，强大的<em class="kw">人工神经元</em>。</p><p id="efbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是比麦卡洛克-皮茨神经元更一般化的计算模型，其中权重和阈值可以随着时间的推移而学习。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es kx"><img src="../Images/0207effb916d06823b98e6f13b7bac2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AT76e8oZ4NMhX8oirxtSpQ.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">感知器模型</figcaption></figure><p id="d715" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有个问题权重到底是什么，激活函数？</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lm"><img src="../Images/824b6593bd4771bfc63d931fc354b980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BdXxIPd2zrCAf0HN.jpg"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd jy">是 Ruko·捷瑞·萨巴·卡罗！！LOL </strong></figcaption></figure><p id="6e6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍后我们回到这个定义。</p><p id="018f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们知道这比<strong class="ih hj"> M-P 神经元</strong>更好，我们可以在模型图像中看到权重被乘以特征，激活函数被添加。因此输入不再是布尔值。</p><p id="f175" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看感知器模型方程:</p><figure class="ky kz la lb fd lc er es paragraph-image"><div class="er es ln"><img src="../Images/0c816f13dffd20c27c14a16d0d20d392.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*-WdbwQHmKPLx51APJJlRSA.png"/></div></figure><p id="9719" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阅读标题:感知器学习算法</p><p id="b1dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你又多了一个疑问，学习算法意味着什么。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lo"><img src="../Images/08ec4109ee1a5686227ef98d76b2969e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GOMHiB5dAAGiJ-Xh.jpg"/></div></div></figure><p id="8e00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来做班多巴斯特:😁😁😂😂</p><p id="8551" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们举一个故事，如果你是大学生，那么这种事情每次都发生在你身上，如果不是大学生，那么就拿灵感来说😜😜</p><p id="6177" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你在标准 12 年级。董事会。压力很大。日程很紧。</p><p id="2bfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你有月考。在第一个月，你学习很好，虽然你得到了不理想的结果。那你现在做什么？😐😐你改变了你的学习计划。但是怎么做呢？？</p><p id="f9ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你的数学分数低，那么你可以增加数学的学习时间，更加专注于这个科目。所以基本上这意味着你更加重视数学。<strong class="ih hj">所以在深度学习单词中，我们可以说你给了这个输入更多的权重。</strong></p><p id="5079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下个月你又要考试了，但是这次你在物理科目上得到了不理想的结果，所以你再次改变了你的学习计划。你这样做了多少次？直到你得到想要的输出。对！！！</p><p id="0772" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这叫学习算法。</p><p id="1819" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用简单的故事告诉你，让我们来看看定义:</p><h2 id="940b" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">学习算法:它是一种自适应方法，通过改变超参数(权重、偏差等)来自安排网络..)以获得期望/要求的输出。校正步骤的迭代被连续执行，直到网络产生所需/期望的输出。</h2><p id="fd3c" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">让我们进入印度 Bhau 模因的意思是定义部分:😂😂</p><p id="eb52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之前，你会明白权重在任何深度学习网络中的重要性。</p><h2 id="5641" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">那么让我们来看看什么是权重:</h2><p id="1681" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">因为简单的术语权重什么都不是，但是给出更多的功率输入以获得所需的/期望的输出。</p><p id="53a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的上一篇文章中，我举了一个我是否看板球比赛的例子。我们收集了很多信息，比如:</p><ul class=""><li id="e95f" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc lu lv lw lx bi translated"><strong class="ih hj"><em class="kw">x1</em></strong>可能是<em class="kw"> isWorldCup </em></li><li id="f475" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc lu lv lw lx bi translated"><strong class="ih hj"> <em class="kw"> x_2 </em> </strong>可能是<em class="kw"> isItADoOrDieGame </em></li><li id="b51d" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc lu lv lw lx bi translated"><strong class="ih hj"> <em class="kw"> x_3 </em> </strong>可能是<em class="kw">is indiadisplayingor not</em><strong class="ih hj"/>等等…</li></ul><p id="b040" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以对于不同的人，产出对他们来说会不一样。意味着世界上的每个人对每个输入都不给予同等的重视。</p><p id="8f7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个例子:<strong class="ih hj">我到底该不该看世界杯比赛？</strong></p><p id="dd77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于一个 10 年板球迷男孩来说，世界杯是他成熟以来第一次理解什么是板球，板球的规则是什么等等..因为这是他第一次参加世界杯，所以他很好奇，他想看世界杯的每一场比赛。所以在这里一个 10 岁的男孩给了世界杯比赛更多的权重。所以他肯定看过世界杯比赛。</p><p id="1158" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和他的祖父相反。他一生中看了许多场世界杯比赛。所以他不像他孙子那样好奇。所以他不太重视世界杯比赛。所以他更有可能看不到世界杯比赛。</p><p id="d7aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据这个例子，我们可以看到，在深度学习中，权重对于决定输出是非常有用和重要的。</p><h2 id="7233" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">现在时间理解偏差:</h2><p id="e6b4" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">偏差允许分类器从原始位置向右、向左、向上或向下移动决策边界。</p><p id="1cf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">偏差允许更高的质量和更快的模型训练。</p><h2 id="6b85" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">加权求和:</h2><p id="56c7" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">加权和只不过是对应于权重值的每个特征或输入值的乘积之和。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div class="er es md"><img src="../Images/fe7cf735103a8b7834d0dfc38ea5f003.png" data-original-src="https://miro.medium.com/v2/resize:fit:244/format:webp/1*9mxVlPN1vyZ-mgDMsHekgA.png"/></div></figure><h2 id="87d4" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">激活功能:</h2><p id="58c9" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">激活函数用于创建非线性神经网络。有许多激活功能，如<strong class="ih hj"><em class="kw"/></strong><strong class="ih hj"><em class="kw">Tanh、Relu、LeakyRelu </em> </strong>等..这些函数可以将神经网络的值改为 0 或 1。</p><p id="fd87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我想你现在对每个术语都很熟悉了。让我们看看</p><h2 id="e711" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">感知器学习算法；</h2><p id="a2a0" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们在下图中描述了这种算法:</p><figure class="ky kz la lb fd lc er es paragraph-image"><div class="er es me"><img src="../Images/85d29f61f6cdac7db1c829915f27d4e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*VSFQCjm3ppdIy-S2yH-6cA.png"/></div></figure><p id="94ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有两个类<strong class="ih hj"> <em class="kw"> P </em> </strong>和<strong class="ih hj"> <em class="kw"> N </em> </strong>，其中<strong class="ih hj"> <em class="kw"> P </em> </strong>是所有输入都标记为<strong class="ih hj"> <em class="kw"> 1 </em> </strong>和<strong class="ih hj"> <em class="kw"> N </em> </strong>的类。</p><p id="0e94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们必须对输入进行分类，不管它是来自<strong class="ih hj"> <em class="kw"> P </em> </strong>类还是<strong class="ih hj"> <em class="kw"> N </em> </strong>类。</p><p id="3e5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们的目标是找到<strong class="ih hj"> <em class="kw"> w_1，w_2，w_3，…，w_n </em> </strong>表示向量<strong class="ih hj"> <em class="kw"> w </em> </strong>能够完美地将输入分类到<strong class="ih hj"> <em class="kw"> P </em> </strong>或<strong class="ih hj"> <em class="kw"> N </em> </strong>类。</p><p id="0428" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们先随机初始化<strong class="ih hj"> <em class="kw"> w </em> </strong>。然后我们迭代例子，直到我们得到完美的矢量<strong class="ih hj"> <em class="kw"> w </em> </strong>。所以我们随机选取一个输入 x，做<strong class="ih hj"> <em class="kw"> x_i </em> </strong>和对应的<strong class="ih hj"> <em class="kw"> w_i </em> </strong>的点积，检查:</p><p id="9e0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<strong class="ih hj"> <em class="kw"> x </em> </strong>来自正类并且点积为负，那么我们通过<strong class="ih hj"> <em class="kw"> w = w +x </em> </strong>来更新向量<strong class="ih hj"><em class="kw">【w】</em></strong>并且</p><p id="e191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<strong class="ih hj"> <em class="kw"> x </em> </strong>来自负类并且点积为正，那么我们通过<strong class="ih hj"> <em class="kw"> w = w -x </em> </strong>来更新矢量<strong class="ih hj"> <em class="kw"> w </em> </strong>。除了这种情况，我们什么都不做，因为我们得到了想要的输出。</p><h2 id="d767" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">让我们编码这个感知器模型:</h2><p id="4f71" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">这里我提到了我的 github 链接，在那里我用 python 从头开始编写了 basic perceptron:</p><div class="jd je ez fb jf jg"><a href="https://github.com/Sid2601/perceptron-learning/blob/master/perceptron.py" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">sid 2601/感知器学习</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">我用 python-sid 2601/perceptron-learning 编写了基本的感知器学习程序</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">github.com</p></div></div><div class="jp l"><div class="mf l jr js jt jp ju jv jg"/></div></div></a></div><p id="6892" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是 test.py 文件，我们在这里测试数据。</p><div class="jd je ez fb jf jg"><a href="https://github.com/Sid2601/perceptron-learning/blob/master/test.py" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">sid 2601/感知器学习</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">我用 python-sid 2601/perceptron-learning 编写了基本的感知器学习程序</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">github.com</p></div></div><div class="jp l"><div class="mg l jr js jt jp ju jv jg"/></div></div></a></div><p id="4054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这两个文件中，我写出了关于阈值和学习率对权重和偏差影响的结论:</p><div class="jd je ez fb jf jg"><a href="https://github.com/Sid2601/perceptron-learning/blob/master/output.txt" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">sid 2601/感知器学习</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">我用 python-sid 2601/perceptron-learning 编写了基本的感知器学习程序</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">github.com</p></div></div><div class="jp l"><div class="mh l jr js jt jp ju jv jg"/></div></div></a></div><p id="499b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在任何地方获得这些代码，因此，让我们使用 Keras 在真实数据集上进行尝试:</p><figure class="ky kz la lb fd lc er es paragraph-image"><div class="er es mi"><img src="../Images/b3ce39103a22b72db40f902d8e82b61f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*x1IppDG25Xq_hDd3.jpg"/></div></figure><p id="b429" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用了这个数据集:</p><div class="jd je ez fb jf jg"><a href="https://www.kaggle.com/uciml/pima-indians-diabetes-database" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">皮马印第安人糖尿病数据库</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">基于诊断方法预测糖尿病的发病</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">www.kaggle.com</p></div></div><div class="jp l"><div class="mj l jr js jt jp ju jv jg"/></div></div></a></div><p id="b92c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们加载依赖项或库:</p><pre class="ky kz la lb fd mk ml mm mn aw mo bi"><span id="acb5" class="jw jx hi ml b fi mp mq l mr ms"><strong class="ml hj">from</strong> <strong class="ml hj">keras.models</strong> <strong class="ml hj">import</strong> Sequential<br/><strong class="ml hj">from</strong> <strong class="ml hj">keras.layers</strong> <strong class="ml hj">import</strong> Dense<br/><strong class="ml hj">from</strong> <strong class="ml hj">keras.activations</strong> <strong class="ml hj">import</strong> sigmoid<br/><strong class="ml hj">import</strong> <strong class="ml hj">numpy</strong> <strong class="ml hj">as</strong> <strong class="ml hj">np</strong></span></pre><p id="b0c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们从 keras 导入 sigmoid 激活函数。这里我们使用 numpy 来读取 csv 文件。</p><p id="c69c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们加载数据集:</p><pre class="ky kz la lb fd mk ml mm mn aw mo bi"><span id="72bd" class="jw jx hi ml b fi mp mq l mr ms"><em class="kw"># Load data</em><br/>dataset = np.loadtxt('./pima_dataset.csv', delimiter=',')</span></pre><p id="6d21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们分离数据集来训练和测试数据:</p><pre class="ky kz la lb fd mk ml mm mn aw mo bi"><span id="7dbd" class="jw jx hi ml b fi mp mq l mr ms"><em class="kw"># Separate train and test data</em><br/>X = dataset[:, 0:8]<br/>Y = dataset[:, 8]</span></pre><p id="bef2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们制作顺序模型:</p><pre class="ky kz la lb fd mk ml mm mn aw mo bi"><span id="f2ec" class="jw jx hi ml b fi mp mq l mr ms"><em class="kw"># Create the Perceptron</em><br/>model = Sequential()<br/>model.add(Dense(1, input_shape=(8,), activation=sigmoid, kernel_initializer='random_normal'))</span></pre><p id="2254" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们制作单层模型。在该模型中，我们给出输入形状(8)的数据，在该模型中，我们使用 sigmoid 激活，并且我们使用 random_normal 初始化器来初始化内核。</p><p id="3882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们编译模型:</p><pre class="ky kz la lb fd mk ml mm mn aw mo bi"><span id="107b" class="jw jx hi ml b fi mp mq l mr ms">#compile the model<br/>model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])</span></pre><p id="d60a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用 Adam 优化器和二元交叉熵损失函数来编译模型。</p><p id="2188" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们训练我们的感知机模型:</p><pre class="ky kz la lb fd mk ml mm mn aw mo bi"><span id="16b5" class="jw jx hi ml b fi mp mq l mr ms"><em class="kw"># Train the Perceptron</em><br/>model.fit(X, Y, epochs=225, batch_size=25, verbose=1, validation_split=0.2)</span></pre><p id="f808" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在 225 个时期上训练我们的模型，这里时期意味着迭代。</p><p id="296a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用 batch_size=25，因此我们的模型训练速度更快，精度更高。</p><p id="3b36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Keras </strong>可以将你的一部分训练数据分离成一个<strong class="ih hj">验证</strong>数据集，并在每个时期在那个<strong class="ih hj">验证</strong>数据集上评估你的模型的性能。所以这里我们用 validation_split =0.2。</p><p id="0eeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我提到了过去 5 个时期的产量:</p><pre class="ky kz la lb fd mk ml mm mn aw mo bi"><span id="c1ad" class="jw jx hi ml b fi mp mq l mr ms">Epoch 220/225<br/>614/614 [==============================] - 0s 49us/step - loss: 0.5598 - accuracy: 0.7231 - val_loss: 0.5863 - val_accuracy: 0.6623<br/>Epoch 221/225<br/>614/614 [==============================] - 0s 50us/step - loss: 0.5627 - accuracy: 0.7410 - val_loss: 0.5600 - val_accuracy: 0.7143<br/>Epoch 222/225<br/>614/614 [==============================] - 0s 54us/step - loss: 0.5606 - accuracy: 0.7362 - val_loss: 0.5792 - val_accuracy: 0.6688<br/>Epoch 223/225<br/>614/614 [==============================] - 0s 49us/step - loss: 0.5776 - accuracy: 0.7264 - val_loss: 0.6302 - val_accuracy: 0.6558<br/>Epoch 224/225<br/>614/614 [==============================] - 0s 49us/step - loss: 0.5620 - accuracy: 0.7378 - val_loss: 0.5858 - val_accuracy: 0.6753<br/>Epoch 225/225<br/>614/614 [==============================] - 0s 47us/step - loss: 0.5576 - accuracy: 0.7280 - val_loss: 0.5618 - val_accuracy: 0.7143</span></pre><p id="1cd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看完整的代码:</p><pre class="ky kz la lb fd mk ml mm mn aw mo bi"><span id="2c66" class="jw jx hi ml b fi mp mq l mr ms">#Load Libraries</span><span id="33d2" class="jw jx hi ml b fi mt mq l mr ms"><strong class="ml hj">from</strong> <strong class="ml hj">keras.models</strong> <strong class="ml hj">import</strong> Sequential<br/><strong class="ml hj">from</strong> <strong class="ml hj">keras.layers</strong> <strong class="ml hj">import</strong> Dense<br/><strong class="ml hj">from</strong> <strong class="ml hj">keras.activations</strong> <strong class="ml hj">import</strong> sigmoid<br/><strong class="ml hj">import</strong> <strong class="ml hj">numpy</strong> <strong class="ml hj">as</strong> <strong class="ml hj">np</strong><br/><strong class="ml hj">import</strong> <strong class="ml hj">pandas</strong> <strong class="ml hj">as</strong> <strong class="ml hj">pd</strong><br/><br/><em class="kw"># Load data</em><br/>dataset = np.loadtxt('./pima_dataset.csv', delimiter=',')<br/><br/><em class="kw"># Separate train and test data</em><br/>X = dataset[:, 0:8]<br/>Y = dataset[:, 8]<br/><br/><em class="kw"># Create the Perceptron</em><br/>model = Sequential()<br/>model.add(Dense(1, input_shape=(8,), activation=sigmoid, kernel_initializer='random_normal'))<br/>model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])<br/><br/><em class="kw"># Train the Perceptron</em><br/>model.fit(X, Y, epochs=225, batch_size=25, verbose=1, validation_split=0.2)</span></pre><p id="cd5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在轮到您在机器上运行这段代码，更改一些变量并检查输出。</p><p id="efd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我简单解释一下感知器学习算法。</p><p id="a316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢它，请分享并鼓掌。</p><p id="c1f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想联系我，您可以通过以下方式联系我:</p><p id="7ec5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Github:</p><div class="jd je ez fb jf jg"><a href="https://github.com/Sid2601" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">Sid2601 -概述</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">在 GitHub 上注册你自己的个人资料，这是托管代码、管理项目和构建软件的最佳地方…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">github.com</p></div></div><div class="jp l"><div class="mu l jr js jt jp ju jv jg"/></div></div></a></div><p id="b952" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">推特:</p><p id="43db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae mv" href="https://twitter.com/Siddhar05782569" rel="noopener ugc nofollow" target="_blank">https://twitter.com/Siddhar05782569</a></p><p id="83ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">LinkedIn:</p><div class="jd je ez fb jf jg"><a href="https://www.linkedin.com/in/siddharth-shah-622aa2182/" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">印度古吉拉特邦艾哈迈达巴德工程学院西达尔特·沙阿博士| LinkedIn</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">在世界上最大的职业社区 LinkedIn 上查看西达尔特·沙阿的个人资料。西达尔特有一份工作列在…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">www.linkedin.com</p></div></div><div class="jp l"><div class="mw l jr js jt jp ju jv jg"/></div></div></a></div></div></div>    
</body>
</html>