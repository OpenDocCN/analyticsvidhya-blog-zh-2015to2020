<html>
<head>
<title>Sub-classifying Lung Cancer with TensorFlow 2 and Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用张量流2和Keras对肺癌进行亚分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sub-classifying-lung-cancer-with-tensorflow-2-and-keras-616353e59e5e?source=collection_archive---------5-----------------------#2020-01-25">https://medium.com/analytics-vidhya/sub-classifying-lung-cancer-with-tensorflow-2-and-keras-616353e59e5e?source=collection_archive---------5-----------------------#2020-01-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/78d7fe4910f7402f1d1868dbb4c4f181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfud5hLdCxHLJHimCKZnxg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">肺腺癌</figcaption></figure><p id="9ffb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">肺癌仍然是一个重大的卫生保健挑战。它是全球男性癌症死亡的主要原因，也是女性癌症死亡的第二大原因。非小细胞肺癌占所有肺癌病例的85 %。</p><p id="a141" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于最近先进的靶向治疗的可用性，不仅必须检测非小细胞肺癌，而且必须将非小细胞肺癌适当地细分为两个主要的亚型:鳞状细胞癌和腺癌，这有时甚至对于有经验的病理学家来说也是具有挑战性的。</p><p id="35b1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇文章中，我详细介绍了我如何使用TensorFlow 2和Keras训练和测试机器学习(ML)模型，以将非小细胞肺癌图像细分为<strong class="iw hj">鳞状细胞癌</strong>和<strong class="iw hj">腺癌</strong>。2020年，谷歌发布了全面集成Keras API的TensorFlow 2深度学习库，比以往任何时候都更容易使用。如果你是卷积神经网络的新手，你可以在<a class="ae js" href="https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53" rel="noopener" target="_blank">媒体</a>上找到全面的指南，在<a class="ae js" href="https://en.wikipedia.org/wiki/Convolutional_neural_network" rel="noopener ugc nofollow" target="_blank">维基百科</a>上找到深入的描述。</p><p id="6c30" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本教程的部分内容:</p><p id="1ad9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">1.选择Google Colab或本地计算机</p><p id="55f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.准备培训、验证和测试数据目录</p><p id="d6fd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.导入库</p><p id="0498" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">4.指定定型、验证和测试数据集目录的路径</p><p id="a00a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">5.归一化图像并生成用于训练、验证和测试的批量张量图像数据</p><p id="adb3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">6.可视化训练图像的样本(可选)</p><p id="b12e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">7.构建卷积网络模型</p><p id="0b74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">8.编译和训练模型</p><p id="6d8a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">9.评估模型</p><p id="e1cf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">10.在测试数据集上评估训练模型的性能</p><p id="1897" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们开始吧！</p><p id="0b66" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">1.Google Colab或本地计算机。</p><p id="e3ef" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一台配有强大的NVIDIA GPU的计算机最适合这个项目。在这个<a class="ae js" href="https://www.youtube.com/watch?v=qrkEYf-YDyI&amp;t=311s" rel="noopener ugc nofollow" target="_blank"> YouTube视频</a>中提供了关于如何在GPU支持下设置TensorFlow 2的出色说明。</p><p id="5b3b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你没有强大的NVIDIA GPU，那么使用谷歌Colab是一个很好的选择。就像在云端使用Jupyter笔记本一样。谷歌Colab为用户提供了12小时的免费计算时间，并可以访问GPU甚至TPU。关于如何使用Google Colab的很好的指导可以在这个<a class="ae js" href="https://towardsdatascience.com/getting-started-with-google-colab-f2fff97f594c" rel="noopener" target="_blank">中的帖子</a>中找到。</p><p id="1cbb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.准备培训、验证和测试目录。</p><p id="5628" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于这个项目，我使用了一个图像数据集，其中包含来自<a class="ae js" rel="noopener" href="/@tampapath/new-freely-available-lung-and-colon-cancer-image-dataset-for-ml-researchers-94756581ed81"> LC25000数据集</a>的5000幅肺鳞癌彩色图像和5000幅肺腺癌彩色图像，ML研究人员可以免费获得。如果你要使用Google Colab，你需要上传图片到你的Google Drive。</p><p id="9c89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为我使用ImageDataGenerator类中的Keras flow_from_directory方法为我们的模型生成批量张量图像数据，所以我需要将数据集组织到下面列出的特定目录结构中。这是必要的一步。否则，程序无法运行。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/3023f612f350c217d7e02155a63898cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*ReuENxhCOw-2Cei5V-Hb0w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">所需的目录结构</figcaption></figure><p id="2ff8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我的原始数据集文件夹包含两个子文件夹，包含两类图像(肺鳞癌类和肺腺癌类)。我使用一个<a class="ae js" href="https://pypi.org/project/split-folders/" rel="noopener ugc nofollow" target="_blank">分割文件夹python包</a>将我的原始数据集文件夹分成训练、验证和测试数据集文件夹，每个文件夹中有相同的两个类。我将80%的图像用于训练数据集，10%用于验证数据集，10%用于测试数据集。关于训练、验证和测试数据集之间的差异的一个很好的解释可以在<a class="ae js" href="https://machinelearningmastery.com/difference-test-validation-datasets/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。总的来说，我使用训练数据集来训练模型(找到最佳权重)，我使用验证数据集来微调模型(指定隐藏层、时期、丢弃层等的数量)。)，我使用测试数据集来评估完全训练的模型的性能。</p><p id="3fd2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.导入库。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="2f32" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">4.指定定型、验证和测试数据集目录的路径</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="e932" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我用我的本地电脑做这个项目。如果你打算使用Google Colab，你需要先安装你的Google Drive。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="ab74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">5.归一化图像并生成用于训练、验证和测试的批量张量图像数据</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="ff84" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">6.可视化训练图像的样本(可选)</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="8f52" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出应该如下所示:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/3342dfcb7eecde00702b274d81804bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1h0fYbB9Cpc4m2RffLk0fw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">肺鳞癌和腺癌样本训练图像</figcaption></figure><p id="be0e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">7.构建卷积网络模型</p><p id="46f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个关于如何设计卷积神经网络的很棒的教学视频可以在这里找到。我用三组用于特征提取的卷积/池层和两个用于分类的密集层构建了我的模型。我添加了一个单一的辍学层(20%的辍学率)，以防止模型过度拟合。我对卷积层使用3x3内核(过滤器)大小，对池层使用max-pooling，对深层使用relu激活函数，对输出层使用sigmoid激活函数。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="d752" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">模型摘要:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kb"><img src="../Images/fe23d6447ef024834d28964dad511e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*vcBKVmnxd60oEFUDP5g43Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们的模型摘要</figcaption></figure><p id="916e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如你所见，这个模型有将近1500万个可训练参数。</p><p id="43b9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">8.编译和训练模型</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="2b51" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于我是做二元分类的，所以用了binary_crossentropy作为损失函数。我用亚当作为优化器。“亚当优化算法简介”可以在<a class="ae js" href="https://machinelearningmastery.com/adam-optimization-algorithm-for-deep-learning/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。每个时期的步骤数来自图像数除以批量大小。例如，我在训练数据集中有8000个图像，并将ImageDataGenerator训练批次大小设置为40个图像。8000除以40得出每个时期200步。</p><p id="47c6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">9.评估模型</p><p id="fb53" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">20个时期后，该模型显示训练精度为0.99，验证精度为0.95。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/75f5d6feacfb1416f8dba6825c4691e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AEvIS_Y6GfovoJeU_lPeIg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">过去三个时代</figcaption></figure><p id="9d7f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">绘制精度和损失的代码:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="4889" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出如下所示:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/82503d59c63c6a509f7bc31a3a918c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-SUzKPZf_E120n00kbiRA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">训练和验证准确性和损失图</figcaption></figure><p id="7f79" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">10.在测试数据集上评估训练模型的性能</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/2f8efdb81af0a70c0b0ba52669e34a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*dZEfRDJyxidbn8KaiAgW2Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">测试数据集上模型性能的结果</figcaption></figure><p id="635d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">总之，经过训练的模型能够以94 %的准确度将以前未见过的(测试数据集)非小细胞肺癌图像分类为鳞状细胞癌和腺癌。</p><p id="8bb6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可以在我的<a class="ae js" href="https://github.com/tampapath/tf2_cnn_tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上找到Jupyter笔记本文件，里面有本教程的全部代码。我希望你会发现这个教程是有帮助的，我祝你在机器学习的努力中好运。</p></div></div>    
</body>
</html>