<html>
<head>
<title>Python for Transit: Speed by Bus Segment in a map from GTFS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python for Transit:GTFS 地图中公交路段的速度</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-for-gtfs-speed-by-bus-segment-in-a-map-2c0316f71e87?source=collection_archive---------9-----------------------#2020-12-07">https://medium.com/analytics-vidhya/python-for-gtfs-speed-by-bus-segment-in-a-map-2c0316f71e87?source=collection_archive---------9-----------------------#2020-12-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="79dd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">深入研究 gtfs_functions Python 包</h2></div><h2 id="61d0" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">更新 2023 年 3 月！！</h2><p id="9502" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">此包已于 2023 年 3 月更新。这篇文章反映了这个包的最新版本的用法。</p><h1 id="1f11" class="ko iy hi bd iz kp kq kr jd ks kt ku jh io kv ip jl ir kw is jp iu kx iv jt ky bi translated">介绍</h1><p id="8fca" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">在本文中，我们将了解如何使用 Python 包<strong class="jx hj"> gtfs_functions 从 GTFS 中获取公交路段的计划平均速度。</strong>你可以在 GitHub 上找到<a class="ae kz" href="https://github.com/Bondify/gtfs_functions" rel="noopener ugc nofollow" target="_blank">库和官方文档。</a></p><p id="6558" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">如果你正在寻找关于这个包的详细解释，我推荐你首先阅读<a class="ae kz" href="https://santiagoa-toso.medium.com/python-for-transit-get-the-most-out-of-your-gtfs-with-this-python-package-44d0b732f657" rel="noopener">这个介绍</a>。这里，我们将直接深入了解在地图中获取停靠频率的具体用例。</p><p id="7dd3" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated"><em class="lf">友情提醒:请帮我鼓掌(或者很多！)当你读完之后如果觉得这篇文章有帮助。</em></p><h2 id="5be2" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">软件包安装和 GTFS 解析</h2><p id="e803" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">要安装软件包并解析 GTFS，请运行下面的代码。为了这篇文章，我从 SFMTA 下载了<a class="ae kz" href="https://www.sfmta.com/reports/gtfs-transit-data" rel="noopener ugc nofollow" target="_blank"> GTFS。</a></p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="75bf" class="lp iy hi ll b be lq lr l ls lt"># In your terminal run<br/>pip install gtfs_functions<br/><br/># Or in a notebook (or similar)<br/>!pip install gtfs_functions<br/><br/># Import package<br/>from gtfs_functions import Feed, map_gdf<br/><br/>feed = Feed("SFMTA.zip", time_windows=[0, 6, 9, 15, 19, 22, 24])<br/><br/>routes = feed.routes<br/>trips = feed.trips<br/>stops = feed.stops<br/>stop_times = feed.stop_times<br/>shapes = feed.shapes</span></pre><h2 id="5732" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">将形状切割成段</h2><p id="c657" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">有时，在止损点或线级别查看变量并不是最佳解决方案，我们需要在段级别进行查看。我们想知道站 A 和站 B 之间发生了什么，以及它与站 C 和站 d 之间发生的有什么不同。</p><p id="3f36" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">为了能够在路段级别聚合信息，我们首先需要将每条路线的长形状切割成从一个站点到另一个站点的路段。</p><p id="c3ed" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">这正是函数<em class="lf"> cut_gtfs </em>所做的。它从解析的 GTFS 中获取 3 个参数:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="ab8c" class="lp iy hi ll b be lq lr l ls lt">segments_gdf = feed.segments</span></pre><p id="b3b0" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">输出显示:</p><figure class="lg lh li lj fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lu"><img src="../Images/bbbc800a09a035bfb403a19043b876c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tf7a5W50rfsdS-yoFsv8TQ.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">函数 cut_gtfs()的地理数据框架输出。</figcaption></figure><p id="c0a8" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">那就是:</p><ul class=""><li id="c976" class="mg mh hi jx b jy la kb lb ji mi jm mj jq mk kn ml mm mn mo bi translated">段的<strong class="jx hj"> route_id </strong></li><li id="e741" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj">区段的 direction_id </strong>当进入 GTFS 时</li><li id="6458" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj">来自 GTFS 的航段的起点站的 stop_sequence </strong></li><li id="01d3" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj">开始 _ 停止 _ 名称</strong>因为它来自 GTFS</li><li id="44b7" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated">来自 GTFS 的</li><li id="90ba" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated">因为它来自 GTFS</li><li id="8181" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated">因为它来自 GTFS</li><li id="950e" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj"> segment_id </strong>作为<em class="lf"> start_stop_id </em>和<em class="lf"> end_stop_id </em>的串联</li><li id="b81b" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj"> shape_id </strong>该段来自 GTFS</li><li id="6f02" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj">几何图形</strong>作为线串</li><li id="8118" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj"> distance_m </strong>表示线段的长度，单位为米。这将有助于以后计算速度。</li></ul><p id="c680" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">拥有分段本身并不是输出，而是我们最终在分段级别聚合变量所必须采取的中间步骤。让我们在接下来的部分看看如何做到这一点。</p><h2 id="d02e" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">计算分段速度</h2><p id="fc99" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">GTFS 为我们提供每次旅行和停留的时间信息。既然我们也有了每段的米距离，那么计算每次旅行的两个站点之间的速度将是一件微不足道的事情。我们还可以计算出每个时间段内该路段的出行次数。所有这些信息都可以用来计算每条路线、路段、方向和一天中的时间的<strong class="jx hj">加权平均速度。</strong></p><p id="3d8c" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">这正是函数<em class="lf"> speeds_from_gtfs </em>所做的，它有 4 个参数:</p><ul class=""><li id="7cda" class="mg mh hi jx b jy la kb lb ji mi jm mj jq mk kn ml mm mn mo bi translated"><strong class="jx hj">路线</strong>从第一步开始</li><li id="4c40" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj">从步骤 1 开始的停止次数</strong></li><li id="df21" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj">在步骤 4 中计算的 segments_gdf </strong></li><li id="3f85" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj">截止值</strong>如步骤 2 中所定义</li></ul><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="c698" class="lp iy hi ll b be lq lr l ls lt">speeds = feed.avg_speeds</span></pre><p id="9cf6" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">特定区段、方向和时间的输出显示:</p><figure class="lg lh li lj fd lv"><div class="bz dy l di"><div class="mu mv l"/></div></figure><figure class="lg lh li lj fd lv"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="387d" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">输出中有一些不言自明的列，因此我将只解释与速度相关的列:</p><ul class=""><li id="6e51" class="mg mh hi jx b jy la kb lb ji mi jm mj jq mk kn ml mm mn mo bi translated"><strong class="jx hj"> speed_kmh: </strong>该路线、路段、方向和一天中时间的平均速度，单位为千米/小时</li><li id="f691" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj"> max_kmh: </strong>该路线、路段和方向以公里/小时为单位的最大日平均速度。</li><li id="de32" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj"> speed_mph: </strong>该路线、路段、方向和一天中时间的平均速度，单位为英里/小时</li><li id="8d59" class="mg mh hi jx b jy mp kb mq ji mr jm ms jq mt kn ml mm mn mo bi translated"><strong class="jx hj"> max_mph: </strong>该路线、路段和方向的最大平均日速度，单位为英里/小时。</li></ul><p id="144c" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">注意，在上面的例子中，选择的<em class="lf">航段 3114–3144</em>出现了四次:服务于该航段的每条路线出现一次，第四次出现在路线“所有线路”上。该路径由函数创建，它将该路段的加权平均速度进行汇总，并考虑在其起始和终止站点停靠的所有路径。</p><p id="4cc2" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">另外，请注意“所有线”的聚合值考虑了三个线段，忽略了线在 GTFS 的方向。这是有意义的，因为路段总是在相同的站点开始和结束，即使指定的方向在 GTFS 是不同的</p><blockquote class="mw mx my"><p id="a0b6" class="jv jw lf jx b jy la ij ka kb lb im kd mz lc kf kg na ld ki kj nb le kl km kn hb bi translated">路线“所有线路”是由该功能本身创建的，它汇总了该特定路段的加权平均速度，并考虑了所有路线在其起点和终点的停靠点。</p></blockquote><h2 id="1c4a" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">在地图上显示结果</h2><p id="93bd" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">如果您希望在所有行的段级别可视化数据，我建议您使用比我们在以前的文章<em class="lf"> </em>中看到的<em class="lf"> map_gdf() </em>更强大的工具，如<a class="ae kz" href="https://docs.kepler.gl/docs/keplergl-jupyter" rel="noopener ugc nofollow" target="_blank"> kepler.gl </a>(也就是我最喜欢的数据 viz 库)。例如，要检查每个路段的计划速度:</p><figure class="lg lh li lj fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es nc"><img src="../Images/822f5d051be10ccd144346f43981797e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwD-8FUumGCnM8TPgjqqvQ.png"/></div></div></figure><p id="ba51" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">您将需要手动设置颜色和滤镜的样式，但您可以完全控制视觉效果。或者你可以学习用编程的方式来做这件事(我还没有)。</p><p id="b861" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">你觉得这篇文章有帮助吗？请让我知道留下一些掌声！！</p><h1 id="ad49" class="ko iy hi bd iz kp kq kr jd ks kt ku jh io kv ip jl ir kw is jp iu kx iv jt ky bi translated">致谢和参考</h1><p id="5579" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">即使这不是一个企业包，Via 的数据科学纽约团队的一些成员在该包的最后一次更新中进行了合作。特别要感谢<a class="ae kz" href="https://github.com/mattijsdp" rel="noopener ugc nofollow" target="_blank"> Mattijs De Paepe </a>大大改进了分段切割功能，以及<a class="ae kz" href="https://github.com/tobiasbartsch" rel="noopener ugc nofollow" target="_blank"> Tobias Bartsch </a>实现了模式计算。</p><p id="15ea" class="pw-post-body-paragraph jv jw hi jx b jy la ij ka kb lb im kd ji lc kf kg jm ld ki kj jq le kl km kn hb bi translated">就严重依赖其他包而言，<em class="lf"> map_gdf() </em>只是一个<a class="ae kz" href="https://python-visualization.github.io/folium/" rel="noopener ugc nofollow" target="_blank">叶子</a>包装器，它的大部分功劳归于它的创造者。</p></div></div>    
</body>
</html>