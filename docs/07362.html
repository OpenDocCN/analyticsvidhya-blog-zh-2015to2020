<html>
<head>
<title>Canny edge detector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Canny边缘检测器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/canny-edge-detector-7b8037fa0764?source=collection_archive---------5-----------------------#2020-06-23">https://medium.com/analytics-vidhya/canny-edge-detector-7b8037fa0764?source=collection_archive---------5-----------------------#2020-06-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="75c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用Python实现一个canny边缘检测器并移除输入图像的边界。</p><p id="d6d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们直接进入实现，因为我们已经在<a class="ae jd" rel="noopener" href="/analytics-vidhya/introduction-to-computer-vision-5e104ed62ef1">文章</a>中讨论了边缘检测的基础知识。为了更好地理解这一过程，请务必阅读。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="66c0" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated"><strong class="ak">数据可视化</strong></h2><p id="7a8d" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated"><strong class="ih hj">输入图像加载和可视化</strong></p><p id="4fce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用Matplotlib、NumPy、OS和CV2库进行可视化。</p><p id="5d2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定函数接受给定目录的输入，并返回该目录中的图像数组。这里，我们将数组加载到变量“plates”中。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="c845" class="jl jm hi kq b fi ku kv l kw kx"><strong class="kq hj"><br/>def</strong> load_data(dir_name = 'plates'):<br/>    imgs=[]<br/>    <strong class="kq hj">for</strong> root,dirs,files <strong class="kq hj">in</strong> os.walk(dir_name):<br/>        <strong class="kq hj">for</strong> filename <strong class="kq hj">in</strong> files:<br/>            <strong class="kq hj">if</strong> filename.endswith('.png'):<br/>                img=cv2.imread(os.path.join(root,filename),0)<br/>                imgs.append(img)<br/>    <strong class="kq hj">return</strong> np.array(imgs)<br/><br/>plates = load_data()</span></pre><p id="b1ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将可视化加载的图像。辅助函数“visualize()”显示作为参数给出的图像。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="a7aa" class="jl jm hi kq b fi ku kv l kw kx"><strong class="kq hj">def</strong> visualize(imgs, format=<strong class="kq hj">None</strong>):<br/>    plt.figure(figsize=(20, 40))<br/>    <strong class="kq hj">for</strong> i, img <strong class="kq hj">in</strong> enumerate(imgs):<br/>        <strong class="kq hj">if</strong> img.shape[0] == 3:<br/>            img = img.transpose(1,2,0)<br/>        plt_idx = i+1<br/>        plt.subplot(3, 3, plt_idx)    <br/>        plt.imshow(img, cmap=format)<br/>    plt.show()<br/><br/>visualize(plates, 'gray')</span></pre><figure class="kl km kn ko fd kz er es paragraph-image"><div class="er es ky"><img src="../Images/3759c224223c0a2b4b57b113254e75f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*FwIErwX0ZOMh8Oy9HX9J6w.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">“可视化”功能的输出</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="8127" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">Canny检测器实现</h2><p id="3bf9" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated"><strong class="ih hj"> Canny检测算法</strong></p><ol class=""><li id="1a99" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc ll lm ln lo bi translated"><em class="lp">降噪:</em>为了去除噪声，对图像进行高斯模糊平滑，核大小为5×5，sigma = 1.4。由于高斯核中的元素之和等于1，所以在卷积之前应该对核进行归一化。</li><li id="7652" class="lg lh hi ih b ii lq im lr iq ls iu lt iy lu jc ll lm ln lo bi translated"><em class="lp">计算渐变:</em>当图像<em class="lp"> I </em>平滑后，计算导数<em class="lp"> Ix </em>和<em class="lp"> Iy </em> w.r.t <em class="lp"> x </em>和<em class="lp"> y </em>。它们可以通过将图像<em class="lp"> I </em>分别与Sobel核<em class="lp"> Kx </em>和<em class="lp"> Ky </em>进行卷积来实现。然后，计算幅度G和斜率θ。</li><li id="4990" class="lg lh hi ih b ii lq im lr iq ls iu lt iy lu jc ll lm ln lo bi translated"><em class="lp">非最大抑制。</em>对于每个像素，找到两个邻居(在正负梯度方向，假设每个邻居占据<em class="lp"> pi/4 </em>的角度，并且<em class="lp"> 0 </em>是向右的方向)。如果当前像素的幅值大于相邻像素的幅值，则没有任何变化，否则，当前像素的幅值被设置为零。</li><li id="1c1e" class="lg lh hi ih b ii lq im lr iq ls iu lt iy lu jc ll lm ln lo bi translated"><em class="lp">双门槛。</em>将梯度幅度与两个指定的阈值进行比较，第一个小于第二个。小于低阈值的梯度被抑制；高于高阈值的梯度被标记为强梯度，并且相应的像素被包括在最终的边缘图中。所有剩余梯度被标记为弱梯度，并且在下一步中考虑对应于这些梯度的像素。</li><li id="e3b1" class="lg lh hi ih b ii lq im lr iq ls iu lt iy lu jc ll lm ln lo bi translated"><em class="lp">通过滞后进行边缘跟踪。</em>由于由真实边缘引起的弱边缘像素将连接到强边缘像素，所以当且仅当具有弱梯度的像素<em class="lp"> w </em>与具有强梯度的像素<em class="lp"> s </em>包含在相同的斑点(连接成分)中时，具有弱梯度的像素被标记为边缘并包括在最终的边缘图中。换句话说，应该有一个连接<em class="lp"> w </em>和<em class="lp"> s </em>的相邻弱像素链(相邻像素是所考虑像素周围的8个像素)。</li></ol><p id="e0cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用这个算法来定义这个函数。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="c6c7" class="jl jm hi kq b fi ku kv l kw kx"><strong class="kq hj">from</strong>  <strong class="kq hj">skimage.feature</strong> <strong class="kq hj">import</strong> canny<br/><strong class="kq hj">from</strong> <strong class="kq hj">skimage</strong> <strong class="kq hj">import</strong> dtype_limits<br/><strong class="kq hj">from</strong> <strong class="kq hj">scipy</strong> <strong class="kq hj">import</strong> ndimage<br/><strong class="kq hj">from</strong> <strong class="kq hj">scipy.ndimage.filters</strong> <strong class="kq hj">import</strong> convolve, gaussian_filter<br/><br/><br/><strong class="kq hj">def</strong> Canny_detector(img,highThreshold=91,lowThreshold=31):<br/>  img=np.array(img,dtype=float) <em class="lp">#convert to float to prevent clipping values</em><br/><br/>  <em class="lp">#step1: Noise reduction</em><br/>  img=gaussian_filter(img,sigma=1.4,truncate=3.3)<br/><br/>  <em class="lp">#step2: Calculating gradients</em><br/>  Kx=[[-1,0,1],[-2,0,2],[-1,0,1]]  <em class="lp">#Sobel filters</em><br/>  Ky=[[1,2,1],[0,0,0],[-1,-2,-1]]<br/>  Ix=convolve(img,Kx)<br/>  Iy=convolve(img,Ky)<br/>  grad=np.hypot(Ix,Iy) <em class="lp">#magnitude of gradient</em><br/>  theta=np.arctan2(Iy,Ix) <em class="lp">#slope theta of gradient</em><br/><br/>  thetaQ=(np.round(theta*(5.0/np.pi))+5)%5 <em class="lp">#Quantize direction</em><br/><br/>  <em class="lp">#step3: Non-maximum suppression</em><br/>  gradS=grad.copy()<br/>  <strong class="kq hj">for</strong> r <strong class="kq hj">in</strong> range(img.shape[0]):<br/>    <strong class="kq hj">for</strong> c <strong class="kq hj">in</strong> range(img.shape[1]):<br/>      <em class="lp">#suppress pixels at the image edge</em><br/>      <strong class="kq hj">if</strong> r==0 <strong class="kq hj">or</strong> r==img.shape[0]-1 <strong class="kq hj">or</strong> c==0 <strong class="kq hj">or</strong> c==img.shape[1]-1:<br/>        gradS[r,c]=0<br/>        <strong class="kq hj">continue</strong><br/>      tq=thetaQ[r,c] % 4<br/><br/>      <strong class="kq hj">if</strong> tq==0: <em class="lp">#0 is E-W (horizontal)</em><br/>        <strong class="kq hj">if</strong> grad[r,c] &lt;= grad[r,c-1] <strong class="kq hj">or</strong> grad[r,c]&lt;=grad[r,c+1]:<br/>          gradS[r,c]=0<br/>      <strong class="kq hj">if</strong> tq==1: <em class="lp">#1 is NE-SW</em><br/>        <strong class="kq hj">if</strong> grad[r,c] &lt;= grad[r-1,c+1] <strong class="kq hj">or</strong> grad[r,c]&lt;=grad[r+1,c-1]:<br/>          gradS[r,c]=0<br/>      <strong class="kq hj">if</strong> tq==2: <em class="lp">#2 is N-S (vertical)</em><br/>        <strong class="kq hj">if</strong> grad[r,c] &lt;= grad[r-1,c] <strong class="kq hj">or</strong> grad[r,c]&lt;=grad[r+1,c]:<br/>          gradS[r,c]=0<br/>      <strong class="kq hj">if</strong> tq==3: <em class="lp">#3 is NW-SE</em><br/>        <strong class="kq hj">if</strong> grad[r,c] &lt;= grad[r-1,c-1] <strong class="kq hj">or</strong> grad[r,c]&lt;=grad[r+1,c+1]:<br/>          gradS[r,c]=0<br/><br/>    <em class="lp">#step4: Double threshold</em><br/>    strongEdges=(gradS&gt;highThreshold)<br/>    <em class="lp">#strong has value 2, weak has value 1</em><br/>    thresholdEdges=np.array(strongEdges,dtype=np.uint8)+ (gradS&gt;lowThreshold)<br/><br/>    <em class="lp">#step5: Edge tracking by hysterisis</em><br/>    <em class="lp">#Find weak edge pixels near strong edge pixels</em><br/>    finalEdges=strongEdges.copy()<br/>    currentPixels=[]<br/>    <strong class="kq hj">for</strong> r <strong class="kq hj">in</strong> range(1,img.shape[0]-1):<br/>      <strong class="kq hj">for</strong> c <strong class="kq hj">in</strong> range(1,img.shape[1]-1):<br/>        <strong class="kq hj">if</strong> thresholdEdges[r,c]!=1:<br/>          <strong class="kq hj">continue</strong> <em class="lp">#Not a weak pixel</em><br/>          <br/>        <em class="lp">#get a 3X3 patch</em><br/>        localPatch=thresholdEdges[r-1:r+2,c-1:c+2]<br/>        patchMax=localPatch.max()<br/>        <strong class="kq hj">if</strong> patchMax==2:<br/>          currentPixels.append((r,c))<br/>          finalEdges[r,c]=1<br/>        <br/>    <em class="lp">#Extend strong edges based on current pixels</em><br/>    <strong class="kq hj">while</strong> len(currentPixels) &gt; 0:<br/>      newPixels=[]<br/>      <strong class="kq hj">for</strong> r,c <strong class="kq hj">in</strong> currentPixels:<br/>        <strong class="kq hj">for</strong> dr <strong class="kq hj">in</strong> range(-1,2):<br/>            <strong class="kq hj">for</strong> dc <strong class="kq hj">in</strong> range(-1,2):<br/>              <strong class="kq hj">if</strong> dr==0 <strong class="kq hj">and</strong> dc==0:<br/>                <strong class="kq hj">continue</strong><br/>              r2=r+dr<br/>              c2=c+dc<br/>              <strong class="kq hj">if</strong> thresholdEdges[r2,c2]==1 <strong class="kq hj">and</strong> finalEdges[r2,c2]==0:<br/>                <em class="lp">#copy this weak pixel to final result</em><br/>                newPixels.append((r2,c2))<br/>                finalEdges[r2,c2]=1<br/>      currentPixels= newPixels<br/>        <br/>    <strong class="kq hj">return</strong> finalEdges</span></pre><p id="38ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们对输入图像应用这个函数。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="b43a" class="jl jm hi kq b fi ku kv l kw kx">canny_imgs = []<br/><strong class="kq hj">for</strong> img <strong class="kq hj">in</strong> plates:<br/>    canny_img = Canny_detector(img)<br/>    canny_imgs.append(canny_img)<br/>    <br/>visualize(canny_imgs, 'gray')</span></pre><figure class="kl km kn ko fd kz er es paragraph-image"><div class="er es lv"><img src="../Images/1636ae6c3106c8ab7965621467267d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*mQuiXNVQmI446-82vZC3Sg.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">描述canny边缘变换的“可视化”函数的输出</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="c62f" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">边界移除</h2><p id="7ef0" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">值得注意的是，大部分图像都有来自四面八方的取景。这种成帧会明显恶化通道对准的质量。这里，我们使用Canny边缘检测器找到车牌上的边界，并根据这些边缘裁剪图像。</p><p id="0b8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">边框去除算法</strong></p><p id="0df8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以通过以下方式移除边框:</p><ul class=""><li id="e294" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc lw lm ln lo bi translated">将Canny边缘检测器应用于图像(已经应用)。</li><li id="e8d0" class="lg lh hi ih b ii lq im lr iq ls iu lt iy lu jc lw lm ln lo bi translated">找出帧像素的行和列。例如，在上限的情况下，我们将在图像的上边缘的邻域中搜索行(例如，其高度的5%)。</li><li id="3cf6" class="lg lh hi ih b ii lq im lr iq ls iu lt iy lu jc lw lm ln lo bi translated">对于每一行，让我们计算它包含的边缘像素的数量(使用Canny检测器获得)。有了这些数字，让我们找到其中的两个最大值。对应于这些最大值的两行是边缘行。</li><li id="e08c" class="lg lh hi ih b ii lq im lr iq ls iu lt iy lu jc lw lm ln lo bi translated">由于帧中有两种颜色变化(首先，从浅色扫描仪背景到深色磁带，然后从磁带到图像)，我们需要距离图像边界更远的第二个最大值。</li><li id="fa24" class="lg lh hi ih b ii lq im lr iq ls iu lt iy lu jc lw lm ln lo bi translated">对应于该最大值的行是裁剪边界。为了不找到两个相邻的峰值，应该实现非最大值抑制:将第一个最大值旁边的行设置为零，然后搜索第二个最大值。</li></ul><p id="b920" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用这个算法来定义这个函数。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="5b7f" class="jl jm hi kq b fi ku kv l kw kx"><strong class="kq hj">def</strong> remove_borders(img, canny_img):   <br/>    dx = int(img.shape[1] * 0.05) <br/>    <strong class="kq hj">return</strong> img[dx : -dx, dx : -dx]</span></pre><p id="7fd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们将该函数应用于之前获得的canny图像。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="2358" class="jl jm hi kq b fi ku kv l kw kx">cropped_imgs = []<br/><em class="lp">#crop borders</em><br/><strong class="kq hj">for</strong> i, img <strong class="kq hj">in</strong> enumerate(plates):<br/>    cropped_imgs.append(remove_borders(img, canny_imgs[i]))<br/><br/>visualize(cropped_imgs, 'gray')</span></pre><figure class="kl km kn ko fd kz er es paragraph-image"><div class="er es lx"><img src="../Images/8199e7a9af0fe645784ad39411b09833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*b4y7U4BkkcZC_5aKAuTP6g.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">描述边界移除的“可视化”功能的输出</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="6a8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们比较一下所有的图像:</p><div class="kl km kn ko fd ab cb"><figure class="ly kz lz ma mb mc md paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><img src="../Images/350e8225b80649ffe712540f71ce6975.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*FwIErwX0ZOMh8Oy9HX9J6w.png"/></div></figure><figure class="ly kz mi ma mb mc md paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><img src="../Images/f5cbfa48b8c4224e307fc4948c7f3f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*mQuiXNVQmI446-82vZC3Sg.png"/></div></figure><figure class="ly kz mj ma mb mc md paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><img src="../Images/6ec80fe2214e07a31f6b6f63a58d28b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*b4y7U4BkkcZC_5aKAuTP6g.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx mk di ml mm translated">输入图像(左)，Canny边缘检测器转换的图像(中)，从图像中移除的边界(右)</figcaption></figure></div><p id="6cca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读！</p><p id="52bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐学习！</p></div></div>    
</body>
</html>