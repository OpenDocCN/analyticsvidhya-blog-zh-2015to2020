<html>
<head>
<title>10 Powerful Python Tricks for Data Science you Need to Try Today</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您今天需要尝试的10个强大的数据科学Python技巧</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/10-powerful-python-tricks-for-data-science-you-need-to-try-today-d227035db195?source=collection_archive---------7-----------------------#2019-08-20">https://medium.com/analytics-vidhya/10-powerful-python-tricks-for-data-science-you-need-to-try-today-d227035db195?source=collection_archive---------7-----------------------#2019-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0741" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你上一次学习新的Python技巧是什么时候？作为数据科学家，我们习惯于使用熟悉的库，每次都调用相同的函数。是时候打破老套路了！</p><p id="6f5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python不仅仅局限于熊猫、NumPy和scikit-learn(尽管它们在<a class="ae jd" href="https://courses.analyticsvidhya.com/courses/introduction-to-data-science-2/?utm_source=blog&amp;utm_medium=10-powerful-python-tricks-data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>中是绝对必要的)！我们可以使用大量的Python技巧来改进我们的代码，加速我们的数据科学任务，并提高编写代码的效率。</p><p id="29dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更重要的是——学习我们可以用Python做的新东西是一件非常有趣的事情！我喜欢尝试不同的软件包和功能。每隔一段时间，一个新的技巧会吸引我的眼球，我会把它融入到我的日常生活中。</p><p id="badd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我决定把我最喜欢的Python技巧整理到一个地方——这篇文章！这个列表包括从加速基本的数据科学任务，如预处理到在同一个<a class="ae jd" href="https://www.analyticsvidhya.com/blog/2018/05/starters-guide-jupyter-notebook/?utm_source=blog&amp;utm_medium=10-powerful-python-tricks-data-science" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>中获得R和Python代码。有很多知识在等着我们，所以让我们开始吧！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/32891abacfb874981cd2a407f6e749ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PoQAqKyCfCajVmKnlgRNiA.jpeg"/></div></div></figure><h1 id="1a63" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">1.gmplot:在谷歌地图上绘制数据集中的GPS坐标</h1><p id="5843" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我喜欢使用谷歌地图数据。想想看，这是你在任何地方都能找到的最丰富的数据应用之一。这就是为什么我决定从这个Python技巧开始。</p><p id="cc07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们想了解两个变量之间的关系时，散点图是非常好的。但是如果变量是一个位置的经纬度坐标，你会使用它们吗？大概不会。最好将这些点绘制在真实的地图上，以便我们可以轻松地可视化和解决特定的问题(例如优化路线)。</p><p id="d888" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kt"> gmplot </em>提供了一个惊人的界面来生成HTML和JavaScript，以在谷歌地图上呈现我们想要的所有数据。让我们用一个例子来看看如何使用gmplot。</p><h2 id="fd47" class="ku jr hi bd js kv kw kx jw ky kz la ka iq lb lc ke iu ld le ki iy lf lg km lh bi translated">安装gmplot</h2><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="fa4e" class="ku jr hi lj b fi ln lo l lp lq">!pip3 install gmplot</span></pre><h2 id="ca00" class="ku jr hi bd js kv kw kx jw ky kz la ka iq lb lc ke iu ld le ki iy lf lg km lh bi translated">在谷歌地图上标出位置坐标</h2><p id="7695" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">你可以在这里下载这个代码<a class="ae jd" href="https://drive.google.com/file/d/1VS292bhx_caAamNGY1bRrAySABMNSAhH/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">的数据集。让我们导入库并读取数据:</a></p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="0ede" class="ku jr hi lj b fi ln lo l lp lq">import pandas as pd<br/>import gmplotdata = pd.read_csv('3D_spatial_network.csv')<br/>data.head()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lr"><img src="../Images/5289a8296c8d2bb3c8401ea2fcee4a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*y6YLlp20K8ybnbF-gr0qNQ.png"/></div></figure><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="fb77" class="ku jr hi lj b fi ln lo l lp lq"># latitude and longitude list <br/>latitude_list = data['LATITUDE'] <br/>longitude_list = data['LONGITUDE']</span><span id="7c75" class="ku jr hi lj b fi ls lo l lp lq"># center co-ordinates of the map <br/>gmap = gmplot.GoogleMapPlotter( 56.730876,9.349849,9)</span><span id="a7fc" class="ku jr hi lj b fi ls lo l lp lq"># plot the co-ordinates on the google map <br/>gmap.scatter( latitude_list, longitude_list, '# FF0000', size = 40, marker = True)</span><span id="8332" class="ku jr hi lj b fi ls lo l lp lq"># the following code will create the html file view that in your web browser <br/>gmap.heatmap(latitude_list, longitude_list)</span><span id="4a54" class="ku jr hi lj b fi ls lo l lp lq">gmap.draw( "mymap.html" )</span></pre><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="03aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码将生成HTML文件，您可以看到经纬度坐标绘制在Google Maps上。热图以红色显示了点密度较高的区域。很酷，对吧？</p><h1 id="08ab" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">2.zip:在Python中组合多个列表</h1><p id="176e" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们经常会编写复杂的for循环来将多个列表组合在一起。听起来很熟悉？那你一定会喜欢zip功能。这个zip函数的目的是“创建一个迭代器，从每个可迭代对象中聚合元素”。</p><p id="0ea8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过一个简单的例子来看看如何使用zip函数并组合多个列表:</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="5507" class="ku jr hi lj b fi ln lo l lp lq"># Combining multiple lists using zip function</span><span id="0332" class="ku jr hi lj b fi ls lo l lp lq">list1 = ['Analytics', 'Data', 'Data', 'Statistics']</span><span id="7068" class="ku jr hi lj b fi ls lo l lp lq">list2 = ['Vidhya', 'Science', 'Hack', 'and']</span><span id="cac4" class="ku jr hi lj b fi ls lo l lp lq">list3 = ['Community', 'Trend', 'Summit 2019', 'Probability']</span><span id="20d7" class="ku jr hi lj b fi ls lo l lp lq">for w1, w2, w3 in zip(list1,list2,list3) :<br/>    print(w1,w2,w3)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lv"><img src="../Images/1cf0151bab37ac08e7bd9f024d29ff4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*sA8d5JNShK57ijCygOusxA.png"/></div></figure><p id="ed69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！看到合并多个列表有多容易了吧？</p><h1 id="e9ab" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">3.category_encoders:使用15种不同的编码方案对分类变量进行编码</h1><p id="9e2f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们在早期数据科学数据集方面面临的最大障碍之一是——我们到底应该对分类变量做些什么？我们的机器在眨眼之间处理数字，但处理类别是一个完全不同的问题。</p><p id="86a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些机器学习算法可以自己处理分类变量。但是我们需要将它们转换成数字变量，为此，<strong class="ih hj"> category_encoders </strong>是一个了不起的库，它提供了15种不同的编码方案。</p><p id="ab37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看如何利用这个图书馆。</p><h2 id="0ba1" class="ku jr hi bd js kv kw kx jw ky kz la ka iq lb lc ke iu ld le ki iy lf lg km lh bi translated">安装类别编码器</h2><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="4c0f" class="ku jr hi lj b fi ln lo l lp lq">!pip3 install category-encoders</span></pre><h2 id="b286" class="ku jr hi bd js kv kw kx jw ky kz la ka iq lb lc ke iu ld le ki iy lf lg km lh bi translated">将分类数据转换成数字数据</h2><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="e8f8" class="ku jr hi lj b fi ln lo l lp lq">import pandas as pd <br/>import category_encoders as ce</span><span id="f8d8" class="ku jr hi lj b fi ls lo l lp lq"># create a Dataframe <br/>data = pd.DataFrame({ 'gender' : ['Male', 'Female', 'Male', 'Female', 'Female'],<br/>                      'class' : ['A','B','C','D','A'],<br/>                      'city' : ['Delhi','Gurugram','Delhi','Delhi','Gurugram'] }) <br/>                                                                                      <br/>data.head()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lw"><img src="../Images/318b67379c5ecf378ddfa44686d1898c.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/0*aNadiQiTf97L7tn0.png"/></div></figure><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="97fb" class="ku jr hi lj b fi ln lo l lp lq"># One Hot Encoding <br/># create an object of the One Hot Encoder</span><span id="03cb" class="ku jr hi lj b fi ls lo l lp lq">ce_OHE = ce.OneHotEncoder(cols=['gender','city'])</span><span id="c1ea" class="ku jr hi lj b fi ls lo l lp lq"># transform the data <br/>data = ce_OHE.fit_transform(data) <br/>data.head()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/70809b9f4cd66a56575156c1d467d5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/0*bt7nR80O_VhLYIP_.png"/></div></div></figure><p id="7abc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kt"> category_encoders </em>支持大约15种不同的编码方式，例如:</p><ul class=""><li id="5d8c" class="ly lz hi ih b ii ij im in iq ma iu mb iy mc jc md me mf mg bi translated">哈希编码</li><li id="9aba" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated">LeaveOneOut编码</li><li id="12aa" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated">顺序编码</li><li id="1b56" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated">二进制编码</li><li id="7817" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated">目标编码</li></ul><p id="fdff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的编码器都与<em class="kt"> sklearn-transformers </em>完全兼容，所以它们可以很容易地在你现有的脚本中使用。另外，<em class="kt"> category_encoders </em>支持NumPy数组和Pandas数据帧。你可以在这里阅读更多关于<a class="ae jd" href="https://github.com/scikit-learn-contrib/categorical-encoding" rel="noopener ugc nofollow" target="_blank">类别编码器的信息</a>。</p><h1 id="4223" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">4.progress_apply:监控你在数据科学任务上花费的时间</h1><p id="b14d" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">您通常在清理和预处理数据上花费多少时间？数据科学家通常会花60–70%的时间来清理数据，这句话非常正确。追踪这个对我们来说很重要，对吗？</p><p id="039d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不想花很多时间清理数据，而忽略其他数据科学步骤。这就是<strong class="ih hj"><em class="kt">progress _ apply</em></strong>函数让我们的生活变得如此轻松的地方。让我演示一下它是如何工作的。</p><p id="5c4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们计算所有的点离一个特定点的距离，看看这个任务的完成进度。你可以在这里下载这个<a class="ae jd" href="https://drive.google.com/file/d/1VS292bhx_caAamNGY1bRrAySABMNSAhH/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">的数据集。</a></p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="9f66" class="ku jr hi lj b fi ln lo l lp lq">import pandas as pd<br/>from tqdm._tqdm_notebook import tqdm_notebook<br/>from pysal.lib.cg import harcdist<br/>tqdm_notebook.pandas()<br/>data = pd.read_csv('3D_spatial_network.csv')<br/>data.head()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lr"><img src="../Images/569717fd77ac034e24db1b92daabbbac.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/0*hgIss1xOgRw1BYQH.png"/></div></figure><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="dead" class="ku jr hi lj b fi ln lo l lp lq"># calculate the distance of each data point from # (Latitude, Longitude) = (58.4442, 9.3722)</span><span id="9117" class="ku jr hi lj b fi ls lo l lp lq">def calculate_distance(x): <br/>   return harcdist((x['LATITUDE'],x['LONGITUDE']),(58.4442, 9.3722)) <br/>   <br/>data['DISTANCE'] = data.progress_apply(calculate_distance,axis=1)</span></pre><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mm lu l"/></div></figure><p id="0397" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到跟踪我们代码的进度是多么容易。简单、高效、救命稻草。</p><h1 id="df3d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">5.pandas_profiling:生成数据集的详细报告</h1><p id="2801" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们花了大量的时间去理解给我们的数据。这是公平的——我们不想在不了解我们在做什么的情况下直接跳到模型构建。这是任何数据科学项目中必不可少的一步。</p><p id="c9ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> pandas_profiling </strong>是一个Python包，它减少了进行初始数据分析步骤的大量工作。这个包只用一行代码就生成了我们数据的详细报告！</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="8410" class="ku jr hi lj b fi ln lo l lp lq">import pandas as pd <br/>import pandas_profiling</span><span id="4a9e" class="ku jr hi lj b fi ls lo l lp lq"># read the dataset <br/>data = pd.read_csv('add-your-data-here') <br/>pandas_profiling.ProfileReport(data)</span></pre><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="3a79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，只用一行代码，我们就得到了数据集的详细报告:</p><ul class=""><li id="822a" class="ly lz hi ih b ii ij im in iq ma iu mb iy mc jc md me mf mg bi translated"><strong class="ih hj">类似于</strong> <em class="kt">的警告Item_Identifier </em>具有很高的基数:1559个不同值警告</li><li id="431f" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><strong class="ih hj">所有分类变量的频率计数</strong></li><li id="7b5b" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><strong class="ih hj">数字变量的分位数和描述性统计</strong></li><li id="a9fb" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><strong class="ih hj">相关图</strong></li></ul><h1 id="7c1d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">6.分组器:对时间序列数据进行分组</h1><p id="1126" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在这一点上谁不熟悉熊猫？它是目前最流行的Python库之一，广泛用于数据操作和分析。我们知道熊猫有惊人的能力处理和总结数据。</p><p id="d6c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最近在解决一个<a class="ae jd" href="https://courses.analyticsvidhya.com/courses/creating-time-series-forecast-using-python/" rel="noopener ugc nofollow" target="_blank">时间序列问题</a>，注意到熊猫有一个<a class="ae jd" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Grouper.html" rel="noopener ugc nofollow" target="_blank"> Grouper </a>功能，我以前从未用过。我对它的用途变得非常好奇(数据科学家诅咒！).</p><p id="38b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实证明，这个Grouper函数对于时间序列数据分析是一个相当重要的函数。所以，让我们试试这个，看看它是如何工作的。你可以在这里下载这个代码<a class="ae jd" href="https://drive.google.com/file/d/1UXHlP2TcenRFQJi5ZoaFtWpRuSU6AwQk/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">的数据集。</a></p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="61ca" class="ku jr hi lj b fi ln lo l lp lq">import pandas as pd</span><span id="1b03" class="ku jr hi lj b fi ls lo l lp lq">data = pd.read_excel('sales-data.xlsx') <br/>data.head()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mn"><img src="../Images/2bec7b1f96f7ea14cc23f95945bc5002.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/0*gUXMYZ59DRK_AGej.png"/></div></figure><p id="610f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，处理任何时间序列数据的第一步是将日期列转换为日期时间格式:</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="d30e" class="ku jr hi lj b fi ln lo l lp lq">data['date'] = pd.to_datetime(data['date'])</span></pre><p id="8a2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们的目标是查看每个客户的月销售额。我们大多数人试图在这里写一些复杂的东西。但这正是熊猫对我们更有用的地方(开始喜欢熊猫吧！).</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="ee8b" class="ku jr hi lj b fi ln lo l lp lq">data.set_index('date').groupby('name')["ext price"].resample("M").sum()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mo"><img src="../Images/942b1af2baf06c1f96e7404ce0d5542d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9G6xqf-RWfB31JjnvYFFA.png"/></div></div></figure><p id="5aef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过<strong class="ih hj"> <em class="kt"> groupby </em> </strong>语法来使用一种简单的方法，而不必去摆弄重新索引。我们将通过提供更多关于如何对日期列中的数据进行分组的信息，为这个函数添加一些额外的内容。它看起来更干净，工作方式完全相同:</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="71e0" class="ku jr hi lj b fi ln lo l lp lq">data.groupby(['name', pd.Grouper(key='date', freq='M')])['ext price'].sum()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mo"><img src="../Images/942b1af2baf06c1f96e7404ce0d5542d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9G6xqf-RWfB31JjnvYFFA.png"/></div></div></figure><h1 id="cb8f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">7.拆分:将索引转换成数据帧的列</h1><p id="8390" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们刚刚看到了grouper在对时间序列数据进行分组时是如何起作用的。现在，这里有一个挑战—如果我们想将<strong class="ih hj"> <em class="kt">名称</em> </strong>列(在上面的例子中是索引)作为我们的数据框的列，该怎么办？</p><p id="9afe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是<em class="kt">拆垛</em>功能变得至关重要的地方。让我们对上面的代码样本应用<em class="kt"> unstack </em>函数，看看结果。</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="2a06" class="ku jr hi lj b fi ln lo l lp lq">data.groupby(['name', pd.Grouper(key='date', freq='M')])['ext price'].sum().unstack()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mp"><img src="../Images/3387275c5de81ca73f6c6bef2b49b8fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wu1NmALbcvuwjSN-l8w3zw.png"/></div></div></figure><p id="240b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">挺有用的！<em class="kt">注意:如果索引不是多索引，输出将是一个序列。</em></p><h1 id="c4f8" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">8.%matplotlib笔记本:您的<a class="ae jd" href="https://www.analyticsvidhya.com/blog/2018/05/starters-guide-jupyter-notebook/?utm_source=blog&amp;utm_medium=10-powerful-python-tricks-data-science" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>中的互动情节</h1><p id="b297" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我是<strong class="ih hj"> <em class="kt"> matplotlib </em> </strong>库的忠实粉丝。这是我们在<a class="ae jd" href="https://www.analyticsvidhya.com/blog/2018/05/starters-guide-jupyter-notebook/?utm_source=blog&amp;utm_medium=10-powerful-python-tricks-data-science" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>中用来生成各种图形的最常见的可视化库。</p><p id="3c2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了查看这些图，我们通常使用一行代码— <strong class="ih hj"> %matplotlib inline </strong> —同时导入<strong class="ih hj"> <em class="kt"> matplotlib </em> </strong>库。这很好地工作，但是它渲染了Jupyter笔记本中的静态图。</p><p id="8f99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只需把线<strong class="ih hj"> <em class="kt"> %matplotlib内联</em> </strong>换成<strong class="ih hj">% matplotlib笔记本 </strong>就可以看着神奇展开了。您将在笔记本中获得可调整大小和可缩放的绘图！</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="94bb" class="ku jr hi lj b fi ln lo l lp lq">%matplotlib notebook<br/>import matplotlib.pyplot as plt</span><span id="39ee" class="ku jr hi lj b fi ls lo l lp lq"># scatter plot of some data # try this on your dataset<br/>plt.scatter(data['quantity'],data['unit price'])</span></pre><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="886e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太棒了。只需一个单词的变化，我们就可以得到交互式的绘图，允许我们在绘图中调整大小和缩放。</p><h1 id="a502" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">9.%%time:检查特定Python代码块的运行时间</h1><p id="251d" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">解决一个问题可以有多种方法。作为数据科学家，我们非常了解这一点。计算成本在行业中至关重要，尤其是对于中小型组织。您可能希望选择在最短时间内完成任务的最佳方法。</p><p id="7dbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Jupyter笔记本中检查特定代码块的运行时间实际上非常容易。</p><p id="fa08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只需添加<strong class="ih hj">%<em class="kt">%</em>%</strong>命令来检查特定单元的运行时间:</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="96e2" class="ku jr hi lj b fi ln lo l lp lq">%%time <br/>def myfunction(x) : <br/>    for i in range(1,100000,1) : <br/>        i=i+1</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mq"><img src="../Images/376af91121493df560115500c0a1541f.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*wl6-Tsk-Ntb17WPBI9G0xA.png"/></div></figure><p id="e7ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们有<strong class="ih hj"> CPU时间</strong>和<strong class="ih hj">墙壁时间</strong>。CPU时间是CPU专用于某个进程的总执行时间或运行时间。墙时间是指从进程开始到“现在”这段时间内，时钟所测量的时间。</p><h1 id="bc22" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">10: rpy2: R和Python在同一个Jupyter笔记本里！</h1><p id="a6cc" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">r和Python是数据科学世界中最好和最流行的两种开源编程语言。r主要用于统计分析，而Python提供了一个简单的接口来将数学解翻译成代码。</p><p id="cf28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好消息是，我们可以在一个Jupyter笔记本上同时使用这两种功能！我们可以利用这两个生态系统，为此，我们只需要安装<strong class="ih hj"> <em class="kt"> rpy2。</em> </strong></p><p id="de60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们暂时搁置R与Python的争论，在我们的Jupyter笔记本中享受绘制ggplot级别的图表吧。</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="ffee" class="ku jr hi lj b fi ln lo l lp lq">!pip3 install rpy2</span></pre><p id="a377" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以一起使用这两种语言，甚至在它们之间传递变量。</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="499a" class="ku jr hi lj b fi ln lo l lp lq">%load_ext rpy2.ipython<br/>%R require(ggplot2)</span><span id="31c3" class="ku jr hi lj b fi ls lo l lp lq"># create a dataframe<br/>import pandas as pd<br/>df = pd.DataFrame({<br/>        'Class': ['A', 'A', 'A', 'V', 'V', 'A', 'A', 'A'],<br/>        'X': [4, 3, 5, 2, 1, 7, 7, 5],<br/>        'Y': [0, 4, 3, 6, 7, 10, 11, 9],<br/>        'Z': [1, 2, 3, 1, 2, 3, 1, 2]<br/>    })<br/></span><span id="d199" class="ku jr hi lj b fi ls lo l lp lq">%%R -i df<br/>ggplot(data = df) + geom_point(aes(x = X, y= Y, color = Class, size = Z))</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mr"><img src="../Images/ceffd6ca4f4b698f1ccb00e25c2d2b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*TCBUmMkUl9WisV_6DRpxKg.png"/></div></figure><p id="872c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们用Python创建了一个数据框<strong class="ih hj"> df </strong>，并使用R的ggplot2库(函数<strong class="ih hj"> geom_point </strong>)创建了一个散点图。来吧，试试这个——你肯定会喜欢的。</p><h1 id="7eb7" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结束注释</h1><p id="9304" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这是我基本的Python技巧集。我喜欢在日常工作中使用这些包和函数。老实说，我的生产率提高了，这使得用Python工作比以往任何时候都有趣。</p><p id="21a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了这些，还有什么你想让我知道的Python技巧吗？请在下面的评论区告诉我，我们将交换想法！</p><p id="e950" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kt">原载于2019年8月20日</em><a class="ae jd" href="https://www.analyticsvidhya.com/blog/2019/08/10-powerful-python-tricks-data-science/" rel="noopener ugc nofollow" target="_blank"><em class="kt">https://www.analyticsvidhya.com</em></a><em class="kt">。</em></p></div></div>    
</body>
</html>