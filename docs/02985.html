<html>
<head>
<title>SQL Classic Problem: Identifying Gaps and Islands Across Overlapping Date Ranges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL经典问题:识别重叠日期范围内的间隙和孤岛</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sql-classic-problem-identifying-gaps-and-islands-across-overlapping-date-ranges-5681b5fcdb8?source=collection_archive---------0-----------------------#2020-01-11">https://medium.com/analytics-vidhya/sql-classic-problem-identifying-gaps-and-islands-across-overlapping-date-ranges-5681b5fcdb8?source=collection_archive---------0-----------------------#2020-01-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b3ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated"><span class="l je jf jg bm jh ji jj jk jl di"> A </span> lice和Bob在一家服务型公司担任客户支持，每次他们处理客户的询问时，他们采取的任何行动都会被记录在某种数据集中。</p><p id="9020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">他们的经理Charlie必须制定一个人力规划计划，以确定他们每个月需要多少人来回答客户的询问。因此，他需要找出爱丽丝和鲍勃在处理客户询问上花费的<strong class="ih hj">实际时间。但是Charlie的眼睛在数据上发现了一些奇怪的东西，由于该公司拥有的技术，Alice和Bob可以<strong class="ih hj">同时处理3个查询</strong>，导致捕获的数据奇怪:</strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es jm"><img src="../Images/b8e1079de7676df98cc40ccf5b6df6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*hpwkj4Qo-jr3AYZnTHa70g.png"/></div></figure><p id="bd9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果Charlie简单地使用<em class="jy"> ElapsedTimeInMins </em>列中的<code class="du ju jv jw jx b">SUM()</code>来找出Alice和Bob用于解决客户询问的时间，结果将不会反映他们实际花费的时间，因为他们每个人可以同时处理3个询问。因此，为了找出他们的<strong class="ih hj">实际时间</strong>有多少花费在处理客户上，Charlie必须将这个问题视为差距和孤岛问题，以便相应地对数据进行分组。</p><p id="7088" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">间隙和孤岛是SQL中的一个经典问题，它涉及到识别序列中缺失值的范围和现有值的范围。目标是识别连续数据序列组(岛)和序列缺失的数据组(缺口)。</p><p id="b218" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">差距和孤岛问题的实际例子包括可用性报告、不活动期和活动期报告等等。</p><p id="23f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最近在我的数据集中遇到了这个特殊的问题，但是有一个有趣的转折，因为数据中每一行的日期范围可能是完全离散的，完全封闭的，或者它们可能在两端相互重叠，所以:</p><blockquote class="jz ka kb"><p id="3c21" class="if ig jy ih b ii ij ik il im in io ip kc ir is it kd iv iw ix ke iz ja jb jc hb bi translated">Charlie有什么方法可以确定具有重叠日期范围的数据缺口和孤岛吗？</p></blockquote></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="5b6e" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">重叠的日期范围</h1><p id="ceaf" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">首先让我们从之前的样本数据开始，以全面掌握Charlie目前面临的情况。如前所述，该问题的特点是每一行的日期范围可能是完全离散的、完全封闭的，或者它们可能在两端相互重叠:</p><pre class="jn jo jp jq fd lp jx lq lr aw ls bi"><span id="575c" class="lt kn hi jx b fi lu lv l lw lx">DROP TABLE IF EXISTS <strong class="jx hj">OverlappingDateRanges</strong>;</span><span id="9358" class="lt kn hi jx b fi ly lv l lw lx">CREATE TABLE <strong class="jx hj">OverlappingDateRanges </strong><br/>   (<strong class="jx hj">Name   </strong>STRING, <br/>    <strong class="jx hj">StartDate  </strong>DATETIME, <br/>    <strong class="jx hj">EndDate  </strong>DATETIME,<br/>    <strong class="jx hj">ElapsedTimeInMins </strong>INT64);<br/> <br/>INSERT INTO <strong class="jx hj">OverlappingDateRanges</strong><br/>SELECT ('Alice', '2019-10-29 03:26:58', '2019-10-29 03:27:02', '1') UNION ALL<br/>SELECT ('Alice', '2019-10-29 05:42:05', '2019-10-30 10:44:30', '1742') UNION ALL<br/>SELECT ('Alice', '2019-10-29 06:51:08', '2019-10-29 06:51:12', '1') UNION ALL<br/>SELECT ('Alice', '2019-10-29 09:59:48', '2019-10-29 09:59:52', '1') UNION ALL<br/>SELECT ('Alice', '2019-10-30 02:05:49', '2019-10-30 02:05:52', '1') UNION ALL<br/>SELECT ('Bob', '2019-10-01 07:13:02', '2019-10-01 07:21:58', '9') UNION ALL<br/>SELECT ('Bob', '2019-10-01 07:22:39', '2019-10-01 07:25:18', '3') UNION ALL<br/>SELECT ('Bob', '2019-10-01 07:24:17', '2019-10-01 07:24:19', '1') UNION ALL<br/>SELECT ('Bob', '2019-10-01 07:41:03', '2019-10-01 07:42:38', '2') UNION ALL<br/>SELECT ('Bob', '2019-10-01 07:46:35', '2019-10-01 07:50:49', '4') UNION ALL<br/>SELECT ('Bob', '2019-10-01 07:48:44', '2019-10-01 07:55:17', '7') UNION ALL</span><span id="d4e8" class="lt kn hi jx b fi ly lv l lw lx">SELECT * FROM <strong class="jx hj">OverlappingDateRanges</strong>;</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es jm"><img src="../Images/b8e1079de7676df98cc40ccf5b6df6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*hpwkj4Qo-jr3AYZnTHa70g.png"/></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">表格输出</figcaption></figure><p id="d0ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有趣的是，当一些行的结束日期与其他行的开始日期匹配时(例如，行1和2)，其他行的一些行的日期范围要么完全包含在其他行中(例如，行3包含在行2中)，而其他行仅重叠一个边界(例如，行11的<em class="jy">结束日期</em>不与任何其他行重叠，但其<em class="jy">开始日期</em>在行10的<em class="jy">结束日期</em>之前)。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="3ee4" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">解决办法</h1><p id="a0d3" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">虽然有几种方法可以解决间隙和孤岛问题，但这里是使用窗口函数的解决方案，它将满足Charlie的需求。</p><p id="309d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要根据开始和结束日期的顺序创建一个行号列，并将前一行的<em class="jy">结束日期</em>带到当前行:</p><pre class="jn jo jp jq fd lp jx lq lr aw ls bi"><span id="6fc3" class="lt kn hi jx b fi lu lv l lw lx">SELECT<br/>  ROW_NUMBER () OVER (ORDER BY <strong class="jx hj">Name</strong>, <strong class="jx hj">StartDate</strong>, <strong class="jx hj">EndDate</strong>) AS <strong class="jx hj">RN</strong>,<br/>  <strong class="jx hj">Name</strong>,<br/>  <strong class="jx hj">StartDate</strong>,<br/>  <strong class="jx hj">EndDate</strong>,<br/>  MAX(<strong class="jx hj">EndDate</strong>) OVER (PARTITION BY <strong class="jx hj">Name </strong>ORDER BY <strong class="jx hj">StartDate</strong>, <strong class="jx hj">EndDate </strong>ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING) AS <strong class="jx hj">PreviousEndDate</strong>,<br/>FROM<br/>  <strong class="jx hj">OverlappingDateRanges</strong></span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/f23db6e4009ab6afd378cd9859046d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K0skJkbOOJI1V0vRVwg1ig.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">表格输出</figcaption></figure><p id="7b7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们再添加两个字段:</p><ul class=""><li id="f524" class="mi mj hi ih b ii ij im in iq mk iu ml iy mm jc mn mo mp mq bi translated"><strong class="ih hj"> IslandStartInd </strong>:通过查看当前行的<em class="jy"> StartDate </em>是否出现在前一行的<em class="jy"> EndDate </em>之后来指示新孤岛何时开始。我们<em class="jy">并不真的</em>需要这个专栏来举例，但是我发现看看下一个专栏会有什么帮助。</li><li id="4f99" class="mi mj hi ih b ii mr im ms iq mt iu mu iy mv jc mn mo mp mq bi translated"><strong class="ih hj"> IslandId </strong>:表示当前行属于哪个岛号。</li></ul><pre class="jn jo jp jq fd lp jx lq lr aw ls bi"><span id="d6f8" class="lt kn hi jx b fi lu lv l lw lx">SELECT<br/> *,<br/> CASE WHEN <strong class="jx hj">Grouping.PreviousEndDate </strong>&gt;= <strong class="jx hj">StartDate </strong>THEN 0 ELSE 1 END AS <strong class="jx hj">IslandStartInd</strong>,<br/> SUM (CASE WHEN <strong class="jx hj">Grouping.PreviousEndDate</strong> &gt;= <strong class="jx hj">StartDate </strong>THEN 0 ELSE 1 END) OVER (ORDER BY <strong class="jx hj">Grouping.RN</strong>) AS <strong class="jx hj">IslandId</strong><br/>FROM<br/> (SELECT<br/>  ROW_NUMBER () OVER (ORDER BY <strong class="jx hj">Name</strong>, <strong class="jx hj">StartDate</strong>, <strong class="jx hj">EndDate</strong>) AS <strong class="jx hj">RN</strong>,<br/>  <strong class="jx hj">Name</strong>,<br/>  <strong class="jx hj">StartDate</strong>,<br/>  <strong class="jx hj">EndDate</strong>,<br/>  MAX(<strong class="jx hj">EndDate</strong>) OVER (PARTITION BY <strong class="jx hj">Name </strong>ORDER BY <strong class="jx hj">StartDate</strong>, <strong class="jx hj">EndDate </strong>ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING) AS <strong class="jx hj">PreviousEndDate</strong>,<br/> FROM<br/>  <strong class="jx hj">OverlappingDateRanges</strong>) Grouping</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mw"><img src="../Images/0beefaa3b546b241d510e5deb5346f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phV-h7AGtJRop2BF3D1bmg.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">表格输出</figcaption></figure><p id="3126" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jy"> IslandId </em>字段只是<em class="jy"> IslandStartInd </em>的一个<code class="du ju jv jw jx b">SUM()</code>，类似于<a class="ae mx" href="https://bertwagner.com/2017/07/18/heres-a-quick-way-to-generate-a-running-total-in-sql-server/" rel="noopener ugc nofollow" target="_blank">窗口函数运行总和</a>。</p><p id="ba5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的最后一步是使用一个老式的<code class="du ju jv jw jx b">GROUP BY</code>来聚合我们的行，分别返回我们每个岛屿的最小和最大开始和结束日期:</p><pre class="jn jo jp jq fd lp jx lq lr aw ls bi"><span id="cb86" class="lt kn hi jx b fi lu lv l lw lx">SELECT<br/> *,<br/> <strong class="jx hj">IslandStartDate</strong> - <strong class="jx hj">IslandEndDate </strong>AS <strong class="jx hj">ActualTimeSpent</strong><br/>FROM<br/> (SELECT<br/>  <strong class="jx hj">Name</strong>,<br/>  <strong class="jx hj">IslandId</strong>,<br/>  MAX (<strong class="jx hj">StartDate</strong>) AS <strong class="jx hj">IslandStartDate</strong>,<br/>  MIN (<strong class="jx hj">EndDate</strong>) AS <strong class="jx hj">IslandEndDate</strong><br/> FROM<br/>  (SELECT<br/>   *,<br/>   CASE WHEN <strong class="jx hj">Grouping.PreviousEndDate</strong> &gt;= <strong class="jx hj">StartDate </strong>THEN 0 ELSE 1 END AS <strong class="jx hj">IslandStartInd</strong>,<br/>   SUM (CASE WHEN <strong class="jx hj">Grouping.PreviousEndDate</strong> &gt;= <strong class="jx hj">StartDate </strong>THEN 0 ELSE 1 END) OVER (ORDER BY <strong class="jx hj">Grouping.RN</strong>) AS <strong class="jx hj">IslandId</strong><br/>  FROM<br/>   (SELECT<br/>    ROW_NUMBER () OVER (ORDER BY <strong class="jx hj">Name</strong>, <strong class="jx hj">StartDate</strong>, <strong class="jx hj">EndDate</strong>) AS <strong class="jx hj">RN</strong>,<br/>    <strong class="jx hj">Name</strong>,<br/>    <strong class="jx hj">StartDate</strong>,<br/>    <strong class="jx hj">EndDate</strong>,<br/>    MAX(<strong class="jx hj">EndDate</strong>) OVER (PARTITION BY <strong class="jx hj">Name </strong>ORDER BY <strong class="jx hj">StartDate</strong>, <strong class="jx hj">EndDate </strong>ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING) AS <strong class="jx hj">PreviousEndDate</strong>,<br/>   FROM<br/>    <strong class="jx hj">OverlappingDateRanges</strong><br/>   ) <strong class="jx hj">Grouping</strong><br/>  ) <strong class="jx hj">Islands</strong><br/> GROUP BY<br/>  <strong class="jx hj">Name</strong>,<br/>  <strong class="jx hj">IslandId</strong><br/> ORDER BY<br/>  <strong class="jx hj">Name</strong>, <br/>  <strong class="jx hj">IslandStartDate</strong><br/> )<br/>GROUP BY<br/> <strong class="jx hj">Name</strong>,<br/> <strong class="jx hj">IslandId</strong><br/>ORDER BY<br/> <strong class="jx hj">NAME</strong>,<br/> <strong class="jx hj">IslandStartDate</strong></span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es my"><img src="../Images/18e0bde16464d3780e61218817c90f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*EZ6_J0K-OKgaEDZDgXBBMw.png"/></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">表格输出</figcaption></figure><p id="ab48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧啊。Alice和Bob的数据已经相应地分组，现在Charlie可以简单地使用<code class="du ju jv jw jx b">SUM()</code>来查找他们的<strong class="ih hj">实际时间</strong>花在回答客户询问上的时间。</p><p id="846c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看使用这种方法对我们的数据产生的不同:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mz"><img src="../Images/1cc9a33a14293583218b07fbfc1c3b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*Fx-_5E4rMgHzRhFsLp3T1A.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">所述方法的结果差异</figcaption></figure><p id="4d2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">普通总和()与缺口和岛解导致总共8分钟的差异。这可能看起来很小，但是请记住，这个数据集只记录了两个人和他们几天的活动。将其扩大到数千人和数月的活动中，差异可能会激增并影响许多其他计算(例如客户服务中的人力规划计算)，导致每天损失数千美元。</p><h1 id="a965" class="km kn hi bd ko kp na kr ks kt nb kv kw kx nc kz la lb nd ld le lf ne lh li lj bi translated">结论</h1><p id="5e60" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">不管一个岛内的日期范围有多混乱，这种技术都可以清楚地识别数据中的缺口，并返回每个岛的日期范围的开始和结束。这种技术可以用在我们需要聚合一些基于日期的事务数据的场景中，否则这些数据很难单独用聚合函数进行汇总。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="f80e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来源:</p><p id="19fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[1]瓦格纳，伯特。<a class="ae mx" href="https://bertwagner.com/2019/03/12/gaps-and-islands/" rel="noopener ugc nofollow" target="_blank"> <em class="jy">跨越日期范围的缺口和孤岛</em> </a>。2019.访问时间:2019年12月05日。</p><p id="22a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[2]本-甘，伊齐克。<a class="ae mx" href="https://www.itprotoday.com/sql-server/solving-gaps-and-islands-enhanced-window-functions" rel="noopener ugc nofollow" target="_blank"> <em class="jy">用增强的窗口函数</em> </a> <em class="jy">解决缝隙和孤岛。</em> 2012。访问时间:2019年12月05日。</p></div></div>    
</body>
</html>