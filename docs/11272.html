<html>
<head>
<title>SQL Window Functions — Adventure is just outside your window</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 窗口函数—冒险就在你的窗口之外</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sql-window-functions-adventure-is-just-outside-your-window-f59edbd41850?source=collection_archive---------15-----------------------#2020-11-26">https://medium.com/analytics-vidhya/sql-window-functions-adventure-is-just-outside-your-window-f59edbd41850?source=collection_archive---------15-----------------------#2020-11-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/c24f54612247677b4893d1aafcd20a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*FAw8X3_V9zdrMcva_A_w6w.jpeg"/></div></figure><p id="5623" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我最近了解了一些我在编写查询的过程中没有很好使用的 SQL 语句。我想介绍一下 SQL 的窗口功能。最初窗口功能看起来很可怕，但是一旦你习惯了，它也是一个很大的帮助和时间节省者！！</p><h1 id="aa3e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是窗口功能？</h1><p id="13a1" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">窗口函数是具有一组特定行的函数。不要从第一行开始就害怕，前面有很多东西可以帮助你从这个窗口逃出去！！！</p><p id="d5a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这感觉上和传统的聚合函数没什么区别，但是两者之间有很大的区别。</p><blockquote class="kn ko kp"><p id="2591" class="im in kq io b ip iq ir is it iu iv iw kr iy iz ja ks jc jd je kt jg jh ji jj hb bi translated"><strong class="io hj">聚合函数将一组行的计算结果缩短为一个结果</strong>，但 window 函数不会。它保持<strong class="io hj">计算结果中现有的行数。</strong></p></blockquote><p id="cbf7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们用几个例子来看看这一点。有一个八行的表格，存储学生的考试成绩。</p><h2 id="8ed2" class="ku jl hi bd jm kv kw kx jq ky kz la ju ix lb lc jy jb ld le kc jf lf lg kg lh bi translated">学生分数表</h2><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/932deb249375c3800552c807b6dcb75a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xY7VGVMu7jWBde9WJp68AQ.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">在上面的例子中，我们可以看到使用窗口函数的格式。以 OVER (…某物…)的形式，总是涉及 OVER 从句。</figcaption></figure><pre class="lj lk ll lm fd lv lw lx ly aw lz bi"><span id="1a94" class="ku jl hi lw b fi ma mb l mc md">If you average the test score as an aggregate function, the result is one row, but if you use the window function, the result is eight rows.</span></pre><blockquote class="kn ko kp"><p id="e58f" class="im in kq io b ip iq ir is it iu iv iw kr iy iz ja ks jc jd je kt jg jh ji jj hb bi translated">示例 1 —分区依据</p></blockquote><pre class="lj lk ll lm fd lv lw lx ly aw lz bi"><span id="efcd" class="ku jl hi lw b fi ma mb l mc md">Just as you can use group by in an aggregate function, you can use PARTITION BY in a window function to specify the rows in a single partition ( or in other words the partition of rows over which you want to apply the function ) . If there is no partition by clause, the partition is an entire row of the table (as in above example) .</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es li"><img src="../Images/1245c1342db9add505c6731397163fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orBrpohJRdMpKv4SlWryrw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">请注意使用部门作为分区如何只对该部门应用平均函数。还要注意，表中的所有 8 行都存在，这与按部门进行的常规聚合不同，常规聚合会折叠行。</figcaption></figure><blockquote class="kn ko kp"><p id="2fe7" class="im in kq io b ip iq ir is it iu iv iw kr iy iz ja ks jc jd je kt jg jh ji jj hb bi translated">示例 2 —排序依据</p></blockquote><pre class="lj lk ll lm fd lv lw lx ly aw lz bi"><span id="198d" class="ku jl hi lw b fi ma mb l mc md">If the order must be given, the ORDER BY clause can be used.</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es me"><img src="../Images/602d4377a7701ea3b95d2c754db1d712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnQsZHhY7eT_aSLbzY9MMQ.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">请注意如何部门明智的排名是如此容易使用窗口功能。试着不使用窗口函数写同样的东西。还要注意，所有 8 行都是完整的。</figcaption></figure><p id="09f2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上述示例中，只有 FROM 子句出现在 SELECT 之后，但是如果在 WHERE、GROUP BY 和 HAVING 子句之后出现，则 window 函数将应用于通过 WHERE、GROUP BY 和 HAVING 对 FROM 子句中的表(子查询)进行筛选的结果。</p><p id="1b90" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在 PostgreSQL 文档中，窗口函数介绍如下:</p><blockquote class="kn ko kp"><p id="27c3" class="im in kq io b ip iq ir is it iu iv iw kr iy iz ja ks jc jd je kt jg jh ji jj hb bi translated">窗口函数对一组与当前行有某种关系的表行执行计算。</p></blockquote><p id="9b86" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意“以某种方式与当前行相关”在句子的后面。</p><p id="e70b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在窗口函数中，情况并非总是如此，但有时计算是基于当前行的。与此相关的概念是窗口框架。窗口框架是从分区的第一行到当前行的范围。窗口框架也是窗口函数中“窗口”的意思。</p><p id="f8da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与没有 ORDER BY 时不同，ORDER BY 给出行的处理顺序时，当前行的概念是根据顺序创建的。当您有一个 ORDER BY 子句时，您可以看到累积和是基于从每个分区的第一行到当前行的窗口框架计算的。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mf"><img src="../Images/74e2b5ac8fbc0a5dff683f837810e701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0JKX4q0w5Vhg6d_a4nz_g.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">与没有 ORDER BY 时不同，ORDER BY 给出行的处理顺序时，当前行的概念是根据顺序创建的。当您有一个 ORDER BY 子句时，您可以看到累积和是基于从每个分区的第一行到当前行的窗口框架计算的。<br/>这里需要注意的另一点是，具有相同顺序的行被视为相同的对等行，从而导致相同的计算。如果你看看第六行和第七行的累积和，你可以看到 200 和 200 是一样的。</figcaption></figure><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mg"><img src="../Images/b7dee9d578b3448ccbf47695e29464d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SRaDt1m-iS_TGVCwF5Aibw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">对等体具有相同的窗口函数计算结果</figcaption></figure><p id="b049" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为累积和可能计算不正确，所以可以修改 ORDER BY 子句，以便对每一行进行唯一处理，从而获得正确的累积和。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mg"><img src="../Images/ba5844fcf919d3cdde66f99e3935d47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8mHUiKMp-KB6OFswezFrgg.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">现在，在 order by 中引入 student_id 会将每一行视为唯一的，因此累积和是正确的。</figcaption></figure><p id="94c4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下表列出了窗口功能。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/b6700f20b417985be1edfaeebf52d0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6vNmaLSf69FZVbUFgKqr_Q.png"/></div></div></figure><p id="daa8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如我们已经看到的，当与 OVER 子句一起使用时，现有的聚合函数(如 sum()、agv()、…)也可以用作窗口函数</p><p id="7f8e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">谢谢你。</p></div></div>    
</body>
</html>