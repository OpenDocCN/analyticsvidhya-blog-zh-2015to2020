<html>
<head>
<title>Genetic algorithm in unity using C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C#实现unity中的遗传算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/genetic-algorithm-in-unity-using-c-72f0fafb535c?source=collection_archive---------0-----------------------#2019-03-21">https://medium.com/analytics-vidhya/genetic-algorithm-in-unity-using-c-72f0fafb535c?source=collection_archive---------0-----------------------#2019-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="008c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用遗传算法帮助立方体到达目标</h2></div><h2 id="d89f" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">介绍</h2><p id="7bf5" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">在这篇文章中，我将带你在unity中用C#实现一个遗传算法。</p><p id="6e78" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">在这里，我实现了一个非常基本的遗传算法，并加入了unity。</p><p id="4383" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">正如你在下面的视频中看到的，红色方块必须到达黄色方块，最初红色方块向几个错误的方向移动，几代后最终到达黄色方块。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><h2 id="e638" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">什么是遗传算法</h2><p id="949c" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">遗传算法的灵感来自于自然选择的过程，在这一过程中，最适合的个体可以活得足够长，以传递他们的基因，而最弱的个体则很快灭亡。</p><p id="5dbe" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">下图显示了该算法的工作原理。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es la"><img src="../Images/cad1fb195600521376077314ded83dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*mLdGgr8m8bJe5SmdN5lgnA.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">GA流程图</figcaption></figure><p id="f2ed" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">如果你不知道它是什么，那么我建议你浏览这里的<a class="ae lh" href="https://natureofcode.com/book/chapter-9-the-evolution-of-code/" rel="noopener ugc nofollow" target="_blank"/>。这将带你了解什么是遗传算法。如果你已经理解了他是如何实现GA来输入短语“生存还是毁灭”，你就可以开始了。我在这里遵循了类似的方法。</p><h2 id="8453" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">Unity中的游戏环境</h2><p id="c5f1" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">所以让我给你介绍一下unity的游戏环境。这里我们有一个红色的方块，它必须到达黄色的方块而不与白色或绿色的边碰撞。黑色块是边，当红色块与黑色块碰撞时，红色块必须改变其方向，即碰撞后，它必须直行或右转或左转或向后。</p><p id="a5d7" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">这个方向存储在一个数组中。每次红色方块击中一条边时，就会看到方向数组中相应索引处的数字，方块就会朝那个方向移动。例如，如果块与3边碰撞，则看到索引2处的数字(因为C#中的索引是从0开始的)，如果数字是1，则块右转。下图会给你一个简单的概念。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/9535849f33cf51d672a2ff8f9244213a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Y4b0xbuHri0eKo53I9a0w.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">块的方向数组值</figcaption></figure><p id="4a42" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">因为有11条边，所以方向数组必须是{0，1，2，1，0，1，2，1，0，1，2}，这样红色的块就可以到达黄色的块。该数组是目标数组，每个基因的适应度将根据它与该目标数组的接近程度来确定。</p><p id="0a26" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">有4个脚本— newMove.cs、GAobj.cs、population.cs和DNA。铯</p><p id="889b" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">我将带你浏览所有这些，但要确保你对遗传算法有一个简单的了解。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ln"><img src="../Images/aebed456612cf75bf4c95f312e0ad4af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUH5xBYBjXVh0BpnQJ64oQ.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">unity3D中的游戏环境</figcaption></figure><h2 id="f1d7" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><strong class="ak"> DNA类</strong></h2><p id="6c99" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">DNA类有两个主要的实例变量<em class="lo">基因、</em>，初始种群将随机生成，而<em class="lo">适应度</em>将根据它与该目标数组的接近程度来确定。</p><p id="409d" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated"><em class="lo">构造函数</em>接受int no，它是基因的大小，在我们的例子中是11。</p><p id="7dcf" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated"><em class="lo"> fitnessCal() </em>通过比较每个元素，根据基因与目标元素的相似程度计算得分，并将其标准化，以便以后可以使用概率方法创建交配池。</p><p id="5b33" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated"><em class="lo"> DNA杂交(DNA伴侣)</em>首先计算基因中的随机中点，进行杂交或交配。</p><p id="9321" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated"><em class="lo"> Mutate() </em>对孩子的DNA进行突变，这样后代就可以有遗传多样性，不会有和父母一样的基因。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lp kz l"/></div></figure><h2 id="ffbf" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><strong class="ak">人口阶层</strong></h2><p id="4520" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">population类由两个DNA类型的列表组成，其中保存了<em class="lo">matting pool</em>和<em class="lo"> bestgenesholder </em>，这两个列表将被提供给<em class="lo"> GAobj </em>类，GAobj 类使用它们来生成块以显示GA的工作情况。</p><p id="8362" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">构造函数创建初始群体并初始化一切。</p><p id="7a22" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">在while循环中，首先计算所有个体的适应度，然后将最适应的基因附加到<em class="lo"> bestgenesholder </em>之后，我们将检查收敛(在这种情况下，当目标基因被成功预测时，收敛发生)。</p><p id="be53" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">然后用概率方法创建交配池。例如，如果A的标准化分数为0.3，那么交配池的30%应该具有A，因此当随机挑选两个亲本进行交配时，挑选A的概率应该是30%。</p><p id="cbe8" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">在此之后，孩子的DNA发生突变，如果没有达到收敛，那么我们将后代传递回遗传算法，如此反复，直到我们达到收敛。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lp kz l"/></div></figure><h2 id="ac40" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><strong class="ak"> GAobj </strong></h2><p id="932e" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">对于那些想知道的人来说，类名是无关紧要的。这个类基本上是从种群类，即<em class="lo">最佳基因阈值</em>中获取收敛后的输出，并产生从第0代到实现收敛的最佳基因的块。</p><p id="9168" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">在<em class="lo"> start() </em>中，我们创建了一个新的种群，并将<em class="lo"> bestgenesholder </em>放入这个脚本中，并调用startInatantiating()，它实例化具有该特定代中最佳基因的街区或汽车，并继续下去直到最佳。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lp kz l"/></div></figure><h2 id="d0fe" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><strong class="ak">新移动</strong></h2><p id="ecc9" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">当块被实例化后，它首先从该特定代的<em class="lo"> bestgenesholder </em>列表中选择方向并移动。</p><p id="1110" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">如前所述，每当红色方块或汽车与边缘(黑色方块)发生碰撞时，它会检查这是哪条边缘，并选择下一个方向。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lp kz l"/></div></figure><p id="1394" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">这就是它的伙计们——你已经建立了一个非常简单的遗传算法，并加入了unity来帮助街区移动。</p><p id="78d4" class="pw-post-body-paragraph jv jw hi jx b jy ko ij ka kb kp im kd ji kq kf kg jm kr ki kj jq ks kl km kn hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>