<html>
<head>
<title>Understanding Windows and Linux differences in Docker Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Windows和Linux在Docker架构上的差异</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-windows-and-linux-differences-in-docker-architecture-6c224b6c9285?source=collection_archive---------10-----------------------#2020-04-18">https://medium.com/analytics-vidhya/understanding-windows-and-linux-differences-in-docker-architecture-6c224b6c9285?source=collection_archive---------10-----------------------#2020-04-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e127" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker作为一个容器工具实际上是不久前出现的，并且已经成为当今现代软件可用的主要容器工具。在这个机会里，我会试着写下大多数Docker相关课程中没有涉及到的所有内容。许多作者在大约5分钟内从安装到运行容器(这实际上很酷)，但是实际上，这里缺少了很多内容。</p><p id="6e20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想完全理解Docker架构的基础，请加入我的快速讲座。我将重述内核原语、<strong class="ih hj"> Docker引擎、</strong>和<strong class="ih hj"> Linux </strong>和<strong class="ih hj"> Windows操作系统</strong>中的容器场景等等。</p><p id="0c67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在许多资料中寻找这一点，这很难理解，当然，如果有必要，我会谈谈基本概念。</p><p id="0552" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们继续吧。</p><h1 id="f044" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">码头引擎</h1><p id="77e3" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><strong class="ih hj"> Docker引擎</strong>是<strong class="ih hj"> Docker工具箱</strong>的核心，它是一个模块化的<strong class="ih hj"> API </strong>，实际上带有一个<strong class="ih hj"> CLI接口</strong>(向用户公开)，在<strong class="ih hj">守护进程</strong>、<code class="du kg kh ki kj b">containerd</code>进程和<strong class="ih hj"> OCI </strong>之间进行通信。</p><p id="dfa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Docker引擎</strong>如今是一个巨大的平台，它通过Docker Swarm、注册表、通用控制平面和一系列第三方集成来处理本机编排。</p><p id="97e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker 不久前开始作为一个名为<strong class="ih hj"> dotCloud </strong>(我想)的小项目，它是一个Python工具，作为LXC的包装器，容器和AUFS的接口。在与LXC的关系出现问题后，<strong class="ih hj">码头工人</strong>分道扬镳，想出了成为今天的样子。</p><p id="334d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天，<strong class="ih hj"> Docker </strong>套件由一个<strong class="ih hj">客户端</strong>、一个<strong class="ih hj">守护进程</strong>、一个用于执行生命周期的<strong class="ih hj">容器管理器</strong>(<code class="du kg kh ki kj b">containerd</code>进程)和一个直接与内核接口的<strong class="ih hj">运行时</strong> (OCI)组成。</p><h2 id="eafe" class="kk je hi bd jf kl km kn jj ko kp kq jn iq kr ks jr iu kt ku jv iy kv kw jz kx bi translated">Linux的Docker引擎</h2><ol class=""><li id="fe01" class="ky kz hi ih b ii kb im kc iq la iu lb iy lc jc ld le lf lg bi translated"><strong class="ih hj">客户端</strong>向守护进程请求一个新容器。</li><li id="f7ba" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><strong class="ih hj">守护进程</strong>让<code class="du kg kh ki kj b">containerd</code>到<code class="du kg kh ki kj b">start</code>管理容器。</li><li id="23a1" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><strong class="ih hj"> OCI层</strong>上的<strong class="ih hj"> OCI </strong>运行时执行程序(默认运行时，也称为<strong class="ih hj"> runC </strong>)实际上构建了容器。</li></ol><h2 id="0d17" class="kk je hi bd jf kl km kn jj ko kp kq jn iq kr ks jr iu kt ku jv iy kv kw jz kx bi translated">Windows引擎</h2><ol class=""><li id="7d2b" class="ky kz hi ih b ii kb im kc iq la iu lb iy lc jc ld le lf lg bi translated"><strong class="ih hj">客户端</strong>向<strong class="ih hj">守护进程</strong>请求新的容器。</li><li id="df72" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">然后，<strong class="ih hj">守护进程</strong>进入<strong class="ih hj">计算机服务层</strong>(这是一个低级层，使一切与Linux进程相同)，这是Windows对<code class="du kg kh ki kj b">containerd</code>进程的替代。</li></ol><p id="6258" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">计算机服务层</strong>的出现是<strong class="ih hj">操作系统</strong>之间Docker实现的差异之一。</p><p id="54bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们再深入一点。</p><h2 id="2370" class="kk je hi bd jf kl km kn jj ko kp kq jn iq kr ks jr iu kt ku jv iy kv kw jz kx bi translated">它是如何工作的？</h2><p id="ae25" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><strong class="ih hj"> Docker守护进程</strong>是<code class="du kg kh ki kj b">containerd</code>和<code class="du kg kh ki kj b">OCI</code>运行时的中间件(基于<strong class="ih hj"> API的</strong>)。Docker不知道如何创建容器。</p><p id="bbd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，整个进程从<strong class="ih hj">守护进程</strong>在<strong class="ih hj">本地Linux套接字</strong>上通过<strong class="ih hj"> gRPC </strong>调用<code class="du kg kh ki kj b">containerd</code>开始，<code class="du kg kh ki kj b">containerd</code>是<strong class="ih hj">守护进程</strong>，由<strong class="ih hj">启动</strong>,<strong class="ih hj">为每个容器附加</strong>进程，并将容器的创建委托给RunC进程，然后退出。</p><p id="eab8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kg kh ki kj b">containerd</code>工序可以有效地同时管理多个<code class="du kg kh ki kj b">runC</code>工序或垫片。</p><p id="a958" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从架构上来说，它非常棒，而且是模块化的，<code class="du kg kh ki kj b">containerd</code>和<code class="du kg kh ki kj b">runC</code>可与任何其他OCI兼容产品进行交换。您可以重新启动docker守护进程，而不会导致正在运行的容器崩溃，或者任何其他相关的活动。</p><p id="80e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kg kh ki kj b">containerd</code>和<code class="du kg kh ki kj b">gPRC</code>是具有1:1关系基数的进程，这表示对于您创建的每个容器，一个<code class="du kg kh ki kj b">runC</code>进程派生它，然后退出，这使得每个容器都创建了自己的进程并附加到<code class="du kg kh ki kj b">containerd</code>守护进程</p><p id="27ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个命令(<code class="du kg kh ki kj b">containerd</code>和<code class="du kg kh ki kj b">runC</code>)的要点在于它们可以通过高级工具驱动，Docker客户端<strong class="ih hj">也是如此。</strong></p><p id="5d8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> gRPC </strong>是个牛逼的工具，值得一试。</p><h1 id="1dc9" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">容器</h1><p id="08e9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">其基础概念是<strong class="ih hj">容器</strong>，这个非常特殊的元素可以被定义为一个<strong class="ih hj">操作系统</strong>的一个隔离区域，应用资源使用限制，我们可以同时运行多个。很酷，对吧？。</p><p id="a0cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">容器</strong>是运行<strong class="ih hj"> Docker图像</strong>所需的最基本的单元。我们已经知道图像是一组图像，在<strong class="ih hj">构建期间</strong>作为一个单独的部分，在<strong class="ih hj">运行期间</strong>，一个临时的可写层被放置在容器的顶部，作为一个独立的结构。</p><p id="5c9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">容器运行的<strong class="ih hj">基础映像</strong>对每个需要它的人都可用，为了修改，它生成自己的副本，然后写入它。</p><p id="a345" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，从操作系统的角度来看，每个容器都是操作系统中独立的一部分，而从虚拟机的角度来看，容器本身不是虚拟化硬件，而是虚拟化操作系统资源。</p><p id="3cec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">容器是关于应用程序的，被认为是微服务架构方案的黄金标准，但实际上也可以应用于一切。</p><p id="d332" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了构建一个容器，我们需要利用一些底层的内核东西，比如<strong class="ih hj">控制组</strong>和<strong class="ih hj">命名空间</strong>，它们实际上是由<strong class="ih hj"> Docker引擎</strong>处理的。</p><p id="c2ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个工作流程可以总结为4个步骤:</p><ol class=""><li id="6ed5" class="ky kz hi ih b ii ij im in iq lm iu ln iy lo jc ld le lf lg bi translated"><strong class="ih hj"> CLI </strong>客户端需要创建新容器的指令。</li><li id="f243" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">客户端向Docker引擎中的容器/创建API端点发出API请求</li><li id="7197" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">引擎提取所需的内核内容。</li><li id="de4b" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">在资源内核被拉出来之后，引擎自己创建并弹出容器。</li></ol><h2 id="0ae7" class="kk je hi bd jf kl km kn jj ko kp kq jn iq kr ks jr iu kt ku jv iy kv kw jz kx bi translated">控件组和名称空间:内部</h2><p id="a31f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">事实上，容器在很多年前就已经出现在技术领域，实际上，在Docker之前就已经有很多与容器相关的工具了。</p><p id="d442" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker implementation for Windows在内部使用了虚拟化的Linux容器，这不是什么秘密。Docker是一个多平台的容器工具。在这一节中，我将讨论容器中的两个内核基本元素，由于操作系统架构和容器在Windows中的具体应用，它们在实现上有所不同。</p><p id="85d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个是<strong class="ih hj">名称空间</strong>。</p><h2 id="b9c9" class="kk je hi bd jf kl km kn jj ko kp kq jn iq kr ks jr iu kt ku jv iy kv kw jz kx bi translated">名称空间</h2><p id="6b10" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><strong class="ih hj">命名空间</strong>组件能够创建虚拟机，这一组件将操作系统转换为多个独立的虚拟机，如<strong class="ih hj">虚拟机管理程序</strong>。它获取您的主机资源，并使用自己的资源(虚拟CPU、内存、存储等)生成隔离的容器。</p><p id="fcdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在容器世界中，使用<strong class="ih hj">名称空间</strong>将单个主操作系统和所有资源打包到多个独立的容器中，看起来像普通的操作系统，但实际上不是。</p><p id="0366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">容器在主机上共享相同的内核，但是因为是隔离的，所以不能识别周围的其他容器。</p><p id="75fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像a之前说的。名称空间只是为以后的容器使用创建虚拟机。就是这样。</p><h2 id="7871" class="kk je hi bd jf kl km kn jj ko kp kq jn iq kr ks jr iu kt ku jv iy kv kw jz kx bi translated">对照组</h2><p id="7c03" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这个特殊的元素负责在VM中对对象进行分组和设置限制。基本上处理一般功能，避免邻居干扰，平衡容器间的系统资源，等等。</p><p id="8a06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，这两个结合在一起的层(来自Docker UnionFS)是现代容器的基本形式。</p><h1 id="3207" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Linux容器</h1><p id="0e87" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Linux系统中Docker的每个容器运行一个单独的进程，该进程有一个单独的作业，它的功能在它自己的容器中，所有的东西后来都通过API粘在一起</p><h2 id="efbf" class="kk je hi bd jf kl km kn jj ko kp kq jn iq kr ks jr iu kt ku jv iy kv kw jz kx bi translated">Linux生态系统:名称空间</h2><p id="2284" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是Linux Docker名称空间内核元素的基本结构。</p><ol class=""><li id="0b36" class="ky kz hi ih b ii ij im in iq lm iu ln iy lo jc ld le lf lg bi translated"><strong class="ih hj">进程ID </strong> (PID):每个容器都有自己独立的进程树(不知道其他容器)</li><li id="ffab" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><strong class="ih hj">网络</strong> (NET):包含自己隔离的网络堆栈(IP、路由表等等)</li><li id="73cd" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><strong class="ih hj">文件系统/挂载</strong> (MNT):独立的根文件系统</li><li id="a27b" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><strong class="ih hj">进程间通信</strong> (IPC):单个容器访问共享内存，但停止容器外的所有操作</li><li id="8e60" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">UTS  (UTS):自己的主机名</li><li id="8a39" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><strong class="ih hj">用户</strong>(用户):不同的用户集合</li></ol><p id="f739" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个docker容器都是一个独立的、有组织的数据集合，当然，它们都被安全地捆绑在一起。</p><h1 id="2a5e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Windows容器</h1><p id="07d0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在，是时候从基于Windows操作系统的角度研究容器内核基本元素了。</p><p id="0874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在介绍<strong class="ih hj">名称空间</strong>和<strong class="ih hj"> CGroups </strong>部分时，我告诉过你<strong class="ih hj"> Windows </strong>在将容器实现到他们的生态系统中方面做了大量的工作，这基本上是非常相似的，但是有所不同。实际上，微软在内核中放了很多东西。</p><p id="ced3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将列出Windows生态系统实现中的主要差异。让我们从<strong class="ih hj">名称空间</strong>和<strong class="ih hj">控制组</strong>元素开始，两者都与Linux非常相似，并且也生成具有指定资源的容器。</p><p id="c537" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍微不同的是在图像生成上。他们实际上用<strong class="ih hj"> NTFS </strong>和<strong class="ih hj">注册表做了很多工作来模拟</strong>图像层，就像用Linux上的<strong class="ih hj"> AUFS </strong> ( <code class="du kg kh ki kj b">DeviceMapper</code>)和<code class="du kg kh ki kj b">overlay2</code>做的一样。</p><p id="f0e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于Windows体验，Docker也有Docker客户端(<code class="du kg kh ki kj b">docker.exe</code>)和Docker守护进程(<code class="du kg kh ki kj b">dockerd.exe</code>)，并使用相同的Docker API，但引入了一个名为<strong class="ih hj">计算机服务层</strong>的组件(还记得那个吗？)<strong class="ih hj"> </strong>保存命令和容器，而不是使用<code class="du kg kh ki kj b">containerd</code> (Linux守护进程)和硬件。</p><p id="66d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本机<strong class="ih hj"> Windows </strong>容器进程的处理方式也不同，在<strong class="ih hj"> Linux </strong>中，你会看到每个容器都有一个进程。在<strong class="ih hj"> Windows </strong>中，两个应用程序都需要一些依赖于其他程序的依赖关系，所以如果找不到这个进程，一切都会中断(即使是容器)。</p><h2 id="a7cf" class="kk je hi bd jf kl km kn jj ko kp kq jn iq kr ks jr iu kt ku jv iy kv kw jz kx bi translated">Hyper-V呢？</h2><p id="6cf5" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在Windows中，我们有两种不同的本机容器:Windows容器和Hyper-V容器。</p><p id="5192" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每一个都有使其不同的特定功能，主要的一个是本机<strong class="ih hj"> Windows容器</strong>为其容器使用<strong class="ih hj">名称空间隔离</strong>，这些都与主机操作系统内核相关，如果您需要任何其他特定配置，Hyper-V是您的理想选择。</p><p id="e0f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hyper-V容器是后台的轻量级虚拟机，除了主机操作系统之外，它还使用成熟的操作系统。它们内部运行着一个完全隔离的内核，可以在Windows和Linux上运行。</p><p id="acd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是如何在两种Windows风格下运行容器的示例:</p><p id="d6ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hyper-V: <code class="du kg kh ki kj b">docker run \ --isolated-hyper</code></p><p id="2814" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原生视窗:<code class="du kg kh ki kj b">docker run \</code></p><h2 id="9d7a" class="kk je hi bd jf kl km kn jj ko kp kq jn iq kr ks jr iu kt ku jv iy kv kw jz kx bi translated">推荐</h2><p id="b5bb" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为了维护健康和快速的容器，这应该被视为短暂的和不可变的，其中短暂的与容器的短暂生命相关，而不可变的是在需要修复时构建新的映像并将它们附加到其他映像。</p><p id="b2ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很多理论，对吧？如果你看到有什么不对的地方，请不要犹豫，发表意见。</p><p id="aa3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐编码:)</p></div></div>    
</body>
</html>