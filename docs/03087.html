<html>
<head>
<title>Exploring Sherlock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索夏洛克</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/exploring-sherlock-1c2c0d274427?source=collection_archive---------13-----------------------#2020-01-15">https://medium.com/analytics-vidhya/exploring-sherlock-1c2c0d274427?source=collection_archive---------13-----------------------#2020-01-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f9f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个搜索社交网络用户名的工具。</p><p id="52f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是我理解一个开源项目的尝试。项目本身和代码属于作者和合作者。我只是想弄清楚这是如何工作的，以及在这个项目中实际使用了哪些框架和库。夏洛克的Github回购在这里是<a class="ae jd" href="https://github.com/sherlock-project/sherlock" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="70a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，让我们从夏洛克做什么开始。这是一个简单的工具，可以在300多个网站中搜索特定的用户名。我的一个朋友告诉了我这个工具，我们讨论了如何实现它。在阅读了<a class="ae jd" href="https://github.com/sherlock-project/sherlock/wiki/Adding-Sites-To-Sherlock" rel="noopener ugc nofollow" target="_blank">这个</a>维基之后，我开始知道我们最初的猜测是正确的。也就是说，夏洛克依赖于状态代码和来自点击这些不同网站的URL的响应。夏洛克有三种方法可以发现一个网站中是否有注册了特定用户名的用户。</p><ol class=""><li id="519a" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><em class="jn">检查HTTP状态代码</em>:有效的用户名不会在响应中发送404错误。</li><li id="8ea3" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><em class="jn">检查响应URL </em>:响应URL的存在表明没有用户使用所查询的用户名，网站返回一个重定向URL到主网站或注册页面。</li><li id="6d07" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><em class="jn">检查错误消息:</em>检查站点响应中的错误或寻找任何重定向。</li></ol><p id="c5bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于上述方法的详细讨论以及如何存储站点和查询用户名可以在<a class="ae jd" href="https://github.com/sherlock-project/sherlock/wiki/Adding-Sites-To-Sherlock" rel="noopener ugc nofollow" target="_blank">这里</a>找到。此外，该项目的wiki和被扫描网站的列表可以分别在<a class="ae jd" href="https://github.com/sherlock-project/sherlock/wiki" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae jd" href="https://github.com/sherlock-project/sherlock/blob/master/sites.md" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/f6004d80797cf60a36be9061f17c4e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8aWfDVx81KeeVEeL"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">照片由<a class="ae jd" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6c7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">夏洛克项目的Github回购可以在这里找到<a class="ae jd" href="https://github.com/sherlock-project/sherlock" rel="noopener ugc nofollow" target="_blank">。现在，让我们直接进入代码。</a></p><p id="9973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过阅读readme，我们可以很容易地看出它是一个命令行应用程序，需要Python才能运行，并且可以用Docker运行。所以，让我们快速浏览一下<code class="du kj kk kl km b">requirements.txt</code>文件，了解一下是什么在幕后驱动着夏洛克。以下是夏洛克使用的所有软件包的列表。</p><ul class=""><li id="b62e" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc kn jk jl jm bi translated">美丽组4&gt;=4.8.0</li><li id="a4e9" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">bs4&gt;=0.0.1</li><li id="cc6e" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">认证&gt; =2019.6.16</li><li id="7d7e" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">色彩&gt; =0.4.1</li><li id="dbf4" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">lxml&gt;=4.4.0</li><li id="2026" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">比重瓶&gt; =1.7.0</li><li id="7696" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">请求&gt; =2.22.0</li><li id="f11e" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">请求-未来&gt; =1.0.0</li><li id="28af" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">汤筛&gt; =1.9.2</li><li id="dad7" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">茎&gt; =1.8.0</li><li id="a3b3" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">torrequest&gt;=0.1.0</li></ul><p id="3bcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有，我们走个小弯路，深入了解一下这些套餐。</p><ul class=""><li id="628c" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc kn jk jl jm bi translated"><a class="ae jd" href="https://pypi.org/project/beautifulsoup4/" rel="noopener ugc nofollow" target="_blank">Beautiful Soup 4</a>:Beautiful Soup帮助我们解析和修改HTML和XML文件。它允许我们操作页面，就像javascript中的<code class="du kj kk kl km b">document</code>允许我们操作网页一样。它实际上将原始的HTML文件转换成Python对象。这些对象最常见的类型包括<code class="du kj kk kl km b">Tag</code>、<code class="du kj kk kl km b">NavigableString</code>、<code class="du kj kk kl km b">BeautifulSoup</code>和<code class="du kj kk kl km b">Comment</code>。对象允许我们使用HTML或XML标签以及它们的名称和属性。<code class="du kj kk kl km b">NavigableString</code>指HTML标签对象内部的任何文本。<code class="du kj kk kl km b">BeautifulSoup</code>包含整个解析后的文档。我们可以迭代地在文档中找到<code class="du kj kk kl km b">next_</code>或<code class="du kj kk kl km b">previous_</code>元素，或者声明性地找到<code class="du kj kk kl km b">find</code>或<code class="du kj kk kl km b">find_all</code>元素、字符串、带有正则表达式的标签、列表或属性字典。完整的文档可以在<a class="ae jd" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li><li id="73f1" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated"><a class="ae jd" href="https://pypi.org/project/bs4/" rel="noopener ugc nofollow" target="_blank"> bs4 </a>:所以bs4只是一个安装美汤包的哑包。</li><li id="a0af" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated"><a class="ae jd" href="https://pypi.org/project/certifi/" rel="noopener ugc nofollow" target="_blank">certify</a>:certify拥有验证TLS主机身份的根证书。也就是说，它确保所述网站的SSL证书是有效的，并且是由其根证书存在于certificate CA包中的CA之一发布的。</li><li id="7950" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated"><a class="ae jd" href="https://pypi.org/project/colorama/" rel="noopener ugc nofollow" target="_blank"> colorama </a> : <a class="ae jd" href="https://en.wikipedia.org/wiki/ANSI_escape_code" rel="noopener ugc nofollow" target="_blank"> ANSI控制序列</a>用于控制终端上的颜色、光标位置等操作。Colorama使这些控制序列在MS windows中工作。</li><li id="ffac" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated"><a class="ae jd" href="https://pypi.org/project/lxml/" rel="noopener ugc nofollow" target="_blank"> lxml </a>:处理xml和HTML文档的库。它为C库libxml2和libxslt提供Pythonic绑定。它基于<a class="ae jd" href="http://effbot.org/zone/element-index.htm" rel="noopener ugc nofollow" target="_blank"> ElementTree API </a>，将XML文档定义为<a class="ae jd" href="http://effbot.org/zone/element.htm" rel="noopener ugc nofollow" target="_blank">元素</a>对象的树。</li><li id="8b5b" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated"><a class="ae jd" href="https://pypi.org/project/PySocks/" rel="noopener ugc nofollow" target="_blank">py SOCKS</a>:<a class="ae jd" href="https://en.wikipedia.org/wiki/SOCKS" rel="noopener ugc nofollow" target="_blank">SOCKS</a>协议通过代理服务器帮助客户端和服务器之间交换网络数据包。关于SOCKS代理的更多信息可以在<a class="ae jd" href="https://securityintelligence.com/posts/socks-proxy-primer-what-is-socks5-and-why-should-you-use-it/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。PySocks允许创建Socks代理，作为一个隧道，转发流量而不修改它。</li><li id="9828" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated"><a class="ae jd" href="https://pypi.org/project/requests/" rel="noopener ugc nofollow" target="_blank"> requests </a> : Requests是一个完整的Python HTTP库。此处可找到一份易于遵循的文档<a class="ae jd" href="https://2.python-requests.org/en/master/user/quickstart/" rel="noopener ugc nofollow" target="_blank">。请求可用于发出各种HTTP请求、读取响应、在URL中传递参数、处理原始/二进制/JSON内容、传递自定义头或JSON数据、检查响应状态代码、获取或发布cookies等。</a></li><li id="eae3" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">requests-futures:Requests-futures提供了与Requests库完全相同的功能，并增加了异步执行。此外，它返回未来对象而不是响应对象。</li><li id="898a" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated">soupsieve是一个CSS选择器库，使用现代CSS选择器提供选择、匹配和过滤。</li><li id="a593" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated"><a class="ae jd" href="https://stem.torproject.org/index.html" rel="noopener ugc nofollow" target="_blank"> stem </a> : Stem是与Tor对话的Python库。它用于使用Tor控制协议连接到Tor进程。</li><li id="a853" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated"><a class="ae jd" href="https://github.com/erdiaker/torrequest" rel="noopener ugc nofollow" target="_blank"> torrequest </a>:一个包装请求和stem的包装器，用于通过Tor发出HTTP请求。</li></ul><p id="39f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们知道使用了什么库以及用于什么目的之后，我们可以开始查看它们在项目本身中是如何使用的。</p><p id="4e01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们查看项目文件时，我们可以安全地忽略docker、travis、code_of_conduct、contributing文件和tests文件夹。让我们先来看看这两个数据文件:<code class="du kj kk kl km b">data.json</code>和<code class="du kj kk kl km b">data_bad_site.json</code></p><ul class=""><li id="9ebd" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc kn jk jl jm bi translated">在<code class="du kj kk kl km b">data.json </code>文件中，<code class="du kj kk kl km b">errorType</code>指的是出错时在响应中查找的一条信息。因此，状态代码的错误类型将查找HTTP状态代码，而消息的错误类型将在响应中查找特定的错误文本。此外，用于检查用户名的URL格式由作为用户名占位符的<code class="du kj kk kl km b">{}</code>组成。</li><li id="2ae6" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated"><code class="du kj kk kl km b">data_bad_site.json</code>包含夏洛克目前的检测算法不支持的站点。文件<code class="du kj kk kl km b">removed_sites.md</code>包含了网站不被支持的详细原因。</li></ul><p id="0606" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在我们来看最后三档:<code class="du kj kk kl km b">site_list.py</code>、<code class="du kj kk kl km b">sherlock.py</code>和<code class="du kj kk kl km b">load_proxies.py</code>。</p><ul class=""><li id="734d" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc kn jk jl jm bi translated"><code class="du kj kk kl km b">load_proxies.py</code>:所以，这个文件中的函数在代码中有很好的记录。它提供了从CSV文件中提取代理、根据wikipedia.org检查代理以及返回仅工作代理列表的函数。</li><li id="63e9" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc kn jk jl jm bi translated"><code class="du kj kk kl km b">site_list.py</code>:这个脚本使用命令行参数-r来更新<code class="du kj kk kl km b">data.json</code>中出现的站点的Alexa排名。每个请求在单独的线程中运行，结果写入<code class="du kj kk kl km b">sites.md</code>文件。它使用XML ElementTree对象来查找<code class="du kj kk kl km b">REACH</code>标签，并最终从Alexa API返回的响应中提取<code class="du kj kk kl km b">RANK</code>属性。来自Alexa API的典型响应如下所示:</li></ul><pre class="ju jv jw jx fd ko km kp kq aw kr bi"><span id="2c59" class="ks kt hi km b fi ku kv l kw kx">&lt;!-- Need more Alexa data?  Find our APIs here: <a class="ae jd" href="https://aws.amazon.com/alexa/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/alexa/</a> --&gt;<br/>&lt;ALEXA VER="0.9" URL="elwo.ru/" HOME="0" AID="=" IDN="elwo.ru/"&gt;<br/>&lt;SD&gt;&lt;POPULARITY URL="elwo.ru/" TEXT="252350" SOURCE="panel"/&gt;&lt;REACH RANK="235507"/&gt;&lt;RANK DELTA="-115898"/&gt;&lt;COUNTRY CODE="RU" NAME="Russia" RANK="22456"/&gt;&lt;/SD&gt;&lt;/ALEXA&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></pre><ul class=""><li id="5eda" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc kn jk jl jm bi translated"><code class="du kj kk kl km b">sherlock.py</code>:该项目的核心模块。让我们逐一解释这个文件的主要部分。</li></ul><ol class=""><li id="1eb0" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du kj kk kl km b">main</code>功能:初始化colorama，用于在终端打印彩色文本和背景。为tor、代理、打印、按等级排序、颜色、输出文件夹、详细程度等定义命令行选项<a class="ae jd" href="https://docs.python.org/dev/library/argparse.html" rel="noopener ugc nofollow" target="_blank">。在函数内部定义一个要修改的</a><a class="ae jd" href="https://www.geeksforgeeks.org/global-keyword-in-python/" rel="noopener ugc nofollow" target="_blank">全局</a> <code class="du kj kk kl km b">proxy_list</code>。检查和验证传递的各种冲突参数，并设置代理，检查它们，或者是否应该使用tor来发出请求。检查是否提供了用于加载网站列表的URL。从JSON文件中加载站点列表，或者是完整的，或者只是在<code class="du kj kk kl km b">site_list</code>命令行参数中传递的一个子集。检查<code class="du kj kk kl km b">site_list</code>中通过的站点是否受支持。还检查我们是否需要根据网站的排名排序列表。然后，设置文件夹和文件来存储获取的信息。最后，调用夏洛克函数以及所有必需的参数，它执行搜索用户名的任务。如果用户名被实际检测到并写入输出文件，最终的<code class="du kj kk kl km b">results</code>字典将被搜索。此外，如果指定，结果将写入CSV文件。</li><li id="5bbf" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated">用于检查超时有效性、打印有效和无效结果、信息、错误等的实用功能。</li><li id="f0c9" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated">这个类增加了每个请求的总响应时间。<code class="du kj kk kl km b">Future</code>类似于Javascript中的<code class="du kj kk kl km b">Promise</code>，用于异步调用。所以它覆盖了基类的request方法:<code class="du kj kk kl km b">FutureSession</code>，定义了一个被钩子调用的方法<code class="du kj kk kl km b">timing</code>，检查是否有其他带有<code class="du kj kk kl km b">response</code>键的钩子，并将<code class="du kj kk kl km b">timing</code>添加为要执行的第一个函数。</li><li id="4fdb" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><code class="du kj kk kl km b">sherlock</code>功能:如果需要，初始化tor。将会话中的最大线程数设置为20。创建扩展的<code class="du kj kk kl km b">ElapsedFutureSession</code>对象。在发出请求之前，在site_data中添加User-Agent头和额外的头(如果有的话)。如果给定站点的用户名的正则表达式检查失败，则阻止发出请求。检查每个网站的<code class="du kj kk kl km b">errorType</code>,以了解为用户名检测收集信息的范围。是否允许重定向以及是否使用HEAD或GET HTTP方法。最后，使用上面指定的选项、头、超时、URL等发出请求。存储请求调用返回的<code class="du kj kk kl km b">future</code>。使用<code class="du kj kk kl km b">get_response</code>函数提取响应时间、错误类型和响应。从响应中提取状态代码和响应文本。检查状态代码是否为2XX类型，检查响应中的错误消息是否符合data.json文件中的定义，或者是否存在重定向，并相应地更新<code class="du kj kk kl km b">exists</code>状态。最后，将状态、响应文本和经过的时间保存在结果中，并将最终结果作为字典返回。</li><li id="6e63" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><code class="du kj kk kl km b">get_response</code>函数:返回响应、错误类型和总响应时间。处理与连接、代理和重试次数相关的各种错误。</li></ol></div></div>    
</body>
</html>