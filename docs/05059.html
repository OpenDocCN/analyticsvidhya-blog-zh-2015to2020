<html>
<head>
<title>Defining My Prime Number Methods and Compare them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">定义我的素数方法并比较它们</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/defining-my-prime-number-methods-and-compare-them-6777047325bc?source=collection_archive---------18-----------------------#2020-04-09">https://medium.com/analytics-vidhya/defining-my-prime-number-methods-and-compare-them-6777047325bc?source=collection_archive---------18-----------------------#2020-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/68a65fb63d8a6e4c664b328af56ccb86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwx8zMnky3_5RsCiiLSVqA.png"/></div></div></figure><p id="6d6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">质数是一个大于1的整数，它的唯一因子是1和它本身。当我试图完成一个检查一个数是否是质数的方法时，很容易想出尝试用2到(n-1)范围内的数除数n的解法。所以基本思路是在2到(n-1)内，寻找1和数本身以外的因子。是的，这是我能想到的处理这个问题的第一个方法。以下是我的代码:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7f34" class="jx jy hi jt b fi jz ka l kb kc">def prime0?(number)<br/>  if number&lt;2<br/>     false<br/>  else<br/>      i=2<br/>      while i &lt; number<br/>        if number % i == 0<br/>          return false<br/>        end<br/>      i=i+1  <br/>      end<br/>   true<br/> end</span></pre><p id="202a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，它工作得很好！但是后来我看代码的时候，真的觉得不够高效。然后，我想到了下面的想法，如果一个数肯定不是质数，换句话说，不是合数，那么其中一个因子会落在[2，n/2]中，因为因子总是成对出现，一个比n/2小，另一个比n/2大。所以我只需要在[2，n/2]的范围内检查，这减少了我的代码需要做的一半工作。下面是我如何实现我的第二个想法:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="c869" class="jx jy hi jt b fi jz ka l kb kc">def prime1?(number)</span><span id="46b9" class="jx jy hi jt b fi kd ka l kb kc">  if number &lt; 2<br/>     false<br/>  else<br/>     i = 2<br/>     while i &lt; = number/2<br/>       if number % i == 0<br/>         return false<br/>       end<br/>     i=i+1<br/>     end<br/>    true<br/> end</span><span id="967a" class="jx jy hi jt b fi kd ka l kb kc">end</span></pre><p id="68f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，即使它有效，我仍然试图找到一个更好的解决问题的方法。就在那时，我有了一个想法:如果我把计数器I设为2，然后每次递增1，会不会浪费很多时间？想想看，如果数字n能被4整除，那么它肯定能被2整除，对吗？也就是说，如果这个数从一开始就不能被2整除，那么我们可以把I设置为3，然后递增2，这样就省去了检查偶数的麻烦。这是我的代码:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="93cf" class="jx jy hi jt b fi jz ka l kb kc">def prime2?(number)<br/>  if number &lt; 2||number == 4<br/>    false<br/>  elsif number==2<br/>    true<br/>  else<br/>   i=3<br/>   while i &lt;= number/2<br/>     if number % i== 0<br/>       return false<br/>     end<br/>   i=i+2<br/>   end<br/>   true</span><span id="117c" class="jx jy hi jt b fi kd ka l kb kc">end<br/>end</span></pre><p id="92a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，我不确定你是否注意到了，这次我做的不仅仅是把I改成代码。因为我的“while”循环的条件是“i&lt;=number/2 ”,所以对于数字4，它的一半是2，小于I最初设置的值，在数字4到达“if”语句后，它将跳过它并跳到“while”循环的结尾，这是真的。显然，这不是真的。这就是为什么我必须在第一个‘if’语句中硬编码它:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="8420" class="jx jy hi jt b fi jz ka l kb kc">if number&lt;2||number==4<br/>   false</span></pre><p id="9b43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好，我测试了一下，这个方法也没问题。这是我如何测试我对质数2的方法比质数1快，质数1比质数0快。在阅读了Jesse Storimer的这篇文章后，我使用了基准#bm方法来帮助我:</p><p id="7ab6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以基本上，我简单地定义了3种方法来检查[2，10000]内的质数，然后使用#bm方法并排生成报告，向我展示每种方法的速度，从而更容易比较哪种方法更有效。以下是我的代码:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2060" class="jx jy hi jt b fi jz ka l kb kc">def checkprime0<br/>  i=2<br/>  while i&lt;10000<br/>    prime0?(i)<br/>    i=i+1<br/>  end<br/>end<br/></span><span id="8ca3" class="jx jy hi jt b fi kd ka l kb kc">def checkprime1<br/>  i=2<br/>  while i&lt;10000<br/>    prime1?(i)<br/>    i=i+1<br/>  end<br/>end<br/></span><span id="1b79" class="jx jy hi jt b fi kd ka l kb kc">def checkprime2<br/>  i=2<br/>  while i&lt;10000<br/>    prime2?(i)<br/>    i=i+1<br/>  end<br/>end<br/>  Benchmark.bm do |bm|<br/>  bm.report { checkprime0}<br/>  bm.report { checkprime1}<br/>  bm.report { checkprime2}</span><span id="8243" class="jx jy hi jt b fi kd ka l kb kc">end</span></pre><p id="2228" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是结果:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6359" class="jx jy hi jt b fi jz ka l kb kc">user     system      total        real<br/>0.244000   0.004000   0.248000 (  0.246886)<br/>0.164000   0.000000   0.164000 (  0.163082)<br/>0.144000   0.000000   0.144000 (  0.145867)</span></pre><p id="32e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而如果我试着让它看起来更不一样，我可以试着把范围扩大到[2，100000]，结果是:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="df15" class="jx jy hi jt b fi jz ka l kb kc">user     system      total        real<br/>19.628000   0.000000  19.628000 ( 19.635854)<br/>12.876000   0.000000  12.876000 ( 12.875490)<br/>11.240000   0.000000  11.240000 ( 11.241820)</span></pre><p id="344a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，结果，彼此相比，现在有了更大的差异！所以至少现在我确信我对哪一个会更快做出了正确的猜测(即使第二个和第三个没有太大的区别)。我很高兴我已经尝试过了，那很有趣！</p><p id="dce1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以最后，感谢你阅读我的博客。我仍然是编码新手，所以我上面写的并不完美。所以，如果你有更多关于如何更快的查质数的建议(我相信你会的！或者如果你认为这个博客有什么错误，请发邮件给我，我可以在这个博客中纠正它！谢谢！</p></div></div>    
</body>
</html>