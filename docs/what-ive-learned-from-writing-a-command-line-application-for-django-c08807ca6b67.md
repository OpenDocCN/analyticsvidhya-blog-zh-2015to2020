# 我从为 Django 编写命令行应用程序中学到了什么

> 原文：<https://medium.com/analytics-vidhya/what-ive-learned-from-writing-a-command-line-application-for-django-c08807ca6b67?source=collection_archive---------11----------------------->

![](img/5e36d931a46b5bad799731d398effec9.png)

克里斯托夫·高尔在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

首先，*“为什么 Django 需要 CLI？”当我去他的办公室询问如何着手为 Django 构建一个命令行界面时，这是我大学时的前教授兼老板的反应。*

老实说，我当时不知道这个问题的答案，就像我现在知道的一样。我是说，*为什么不呢？真的，我想我只是需要一个副业来让自己忙起来，并提高我的编程技能。我的意思是，我还能怎么练习我在大三时学的那些设计模式呢？*

我在 2017 年左右开始使用 Django 进行我的 web 开发项目。从第一天开始，我就非常喜欢使用它。同年，我开始在大学的 CSCI 23000 课程中担任助教。计算机科学和 Python 编程入门。那门课也是我对 Python 编程语言的介绍。所以，我抓住每一个机会来提高我的语言技能。

在学习 Django 的同时，我还决定学习 Ruby on Rails，这是一个类似于 Django 的 web 开发框架，但是是用 Ruby 编程语言编写的。然而，我确实花了更多的时间学习姜戈。这并不是因为 Rails 本身有什么问题，而是因为我已经花了大部分时间来编写和阅读 Python 代码，所以继续下去是有意义的，因为几乎不需要从学校作业到我的爱好项目进行上下文切换。

正如我所说的，我选择 Django 而不是 Rails 是因为我对 Python 的喜爱。不是因为 Rails 的任何固有问题。因此，尝试 Rails 从来都不是不可能的。因此，一天晚上，当我发现自己在网上看一个 Rails 教程时，我了解到了`[scaffold](https://dzone.com/articles/rails-scaffold-2)`命令。一种在 Rails 应用程序中自动创建模型、视图和控制器(MVC)的方法。我将举例如下:

```
rails generate scaffold Post title:string content:text
```

这个支架创建了一个具有指定属性/特性的`Post`模型。它还将根据 Rails 的约定创建视图和控制器。一个命令可以方便地处理您的初始 MVC。

与 Rails 不同，Django 缺少一个类似的工具。默认情况下，Django 附带了`django-admin` 命令，允许您从命令行创建项目和应用程序:

```
django-admin startproject mysitedjango-admin startapp blog
```

一旦进入 Django 项目，您就可以运行`manage.py`模块来获得更多与 Django 项目相关的功能，但是没有 Rails 的命令行选项那么高级。尤其是当它涉及到生成应用程序文件和其他应用程序级配置时。

那么，*我为什么想要 Django CLI 呢？*因为喜欢 Rails 但是更喜欢用 Django，*哈哈*。我喜欢写 Python，也愿意继续写 Python 代码。但是我也喜欢这样的事实，Rails 更喜欢，并且实际上强制执行了配置之上的约定。我欣赏好的 MVC 框架，即使我不期望每个问题都适合 MVC 架构。但是我喜欢传统。我认为它们可以允许框架处理更多的外围软件逻辑，同时允许程序员更多地关注应用程序的实际业务逻辑。我不相信框架魔法。框架是工具。不是解决方案本身，而是通过软件实现解决方案的手段。

因此，经过一番深思熟虑和大量阅读在线文档后，我确定了 CLI 原型版本的最初目标:

1.  我需要一种标准且安全的方法来从命令行解析参数。
2.  我需要一种方法来区分命令，如果可能的话，将相关的命令分组到一个主命令下。
3.  我还需要一种安全的方法来执行 I/O 操作，而不会搞乱文件系统。
4.  我需要一种方法来确定运行 CLI 的文件系统的上下文。
5.  最后，我需要提出一些约定来帮助 CLI 更好地执行某些任务。

第一个要求似乎是最容易实现的。在花了几个小时在线阅读博客和观看如何构建命令行应用程序的视频后，我决定尝试用`Bash`和`Shellscript`来写这个东西。不开玩笑。我可能没有提到这一点，但我确实有大学时代的`C`和`C++`以及`Bash`(感觉像是`C`的怪异，强调怪异，表亲)的经历。所以，这就是我的目标…不用说，我没有走多远。我在 Github 的某个地方仍然有一些代码，但是我记得我定制/破解了我的实现太多，以至于我基本上让除了我自己之外的任何人都无法使用这个项目。

**第一课:从明星中选择正确的工具**简单来说，选择能让你变得更有效率的工具。不要期望工具为您做所有的工作，但是在决定在什么基础上构建您的解决方案时要理智。

> 工具是用来帮助兄弟的，而不是让兄弟失望的。—你真诚的，2019

在意识到 Bash 和 Shellscript 可能不是我手头任务所需的工具后，我决定探索用 Python 构建的解决方案。这可能允许我直接从 CLI 导入和运行 Django 模块和其他 python 模块。于是，我找到了`[click](https://click.palletsprojects.com)`，一个由[托盘项目](https://palletsprojects.com)打包的 Python 包，`[Flask](https://flask.palletsprojects.com)`和`[Jinja](https://jinja.palletsprojects.com)`背后的人。Click 很容易学。它还帮助我完成了第一个和第二个要求。

`click`中的命令仅仅是用`@click.command`或`@click.group`修饰的 python 函数。这使得您的单个 Python 函数，而不仅仅是它们的封装模块，可以通过名称从命令行调用。例如，在没有装饰器的情况下，您可以通过如下运行来执行模块中的代码:

```
python app.py
```

使用`click`你可以调用一个已经在`app.py`中定义的方法，比如说`generate`。像这样:

```
python app.py generate
```

下面是如何定义命令的示例:

```
import click@click.group
def generate():
    pass@generate.command
def model(name, options):
    pass@generate.command
def template(name, options):
    pass
```

当一个人着手构建其他人希望在他们自己的软件栈中发现有用的软件工具时，重要的是授权给那些用户并帮助他们理解他们如何能帮助自己。最初选择坚持使用`click`，简化了我的大部分工作。从一开始就是正确的工具。例如，这个工具并不正确，因为它似乎在网上很受欢迎。这对我来说是正确的，因为它没有妨碍我的想法。而是让我实现了这样一个想法。我的朋友们，这是编写良好、易于阅读的文档的好处之一。支持[托盘项目](https://palletsproject.com)的人们。

第二课 : **坚持一般的解决方案**。当我开始编写 CLI 时，我疯狂地试图添加各种定制和我认为相关的*酷*功能。用 Bootstrap 设计的自定义页面模板。用于音频回放控制的 Javascript 函数(我一直在做的一个项目中的一个工件)和一些我在自己的项目中发现有用的其他杂项文件。但不是所有人都用 Bootstrap 做造型。并不是每个 Django 项目都从后端呈现 HTML(有些项目只从 API 输出 JSON)，所以即使我发现所有这些文件在我自己的项目中都很有用，这些文件对另一个项目来说也不是不必要的。我的或者别人的。后来，我决定允许 CLI 用户只选择与他们自己的用例相关的特性。

这种认识使我认为 CLI 应用程序类似于通用编程语言。他们有您可能需要的工具，但不一定是他们期望您复制的实现。作为程序员工具箱的一部分，CLI 就是一种工具。它不是解决方案，而是一个让你更接近想要的解决方案的工具。不管解决方案是什么。

第 3 课:给他们写文档。在开始一个新的软件项目之前，我们并不总是奢侈地拥有现成的文档供我们沉迷。但是我们不能把我们一直抱怨别人的事情强加给别人。也许在开发过程中事情变得清晰了。也许实现太简单了，甚至你的祖母也能理解。但是，除非只有你和你的祖母需要使用你的软件，否则就做我们都知道的英雄，教我们如何利用你的知识。否则，你的辛苦也不过如此，*辛苦*。所以，记录你的过程，你的学习，不要忘记记录你的实现。你以后会感谢自己的。

正如我在学到的第一课中提到的，找到关于`click`的相关且结构良好的文档是我成功构建 Django CLI 的一个关键因素。在发现文档对我的成功如此重要之后，我发现记录 CLI 如何工作对我来说更加重要。不仅如此，还要记录我对软件及其使用的假设。也许我的方法或假设已经过时了。也许我的实现被破坏了。无论哪种方式，在你解释你的软件是如何工作的时候，有好的文档可以帮助你解决你自己的设计思想。顺便说一句，如果你发现[文档](https://github.com/oleoneto/django-clite/blob/master/README.md)中有不清楚或遗漏的地方，请提出问题或提交请求，我一定会审核。

**第 4 课:开发您的软件。**我大学期间的另一位教授兼老板是我学校计算机和信息科学系软件工程项目的主任。从他那里，我学到了许多与软件系统的架构、设计和开发相关的技能。在我们的一个项目中，我从他那里得到的一个建议是 ***不要构建，而要开发软件*** 。

简单来说，就是把你的软件分解成功能，把每个功能作为自己的项目来构建。设计、记录、测试、实现、测试和交付每个特性，作为它自己的小项目(如果这听起来像敏捷方法，那是因为它就是)。这种程度的关注有助于确保最终交付品的质量。如果您允许自己一次处理一个特性，您也可以让自己更好地理解设计的含义和实现的权衡。这可以帮助你最终更好地理解和掌握你的整个软件，因为你将会花更多的时间在每一个功能上。当您决定将项目的功能扩展到初始范围之外时，这也将有助于您理解项目的位置和方式。

那么，我是如何着手开发 CLI 的呢？我必须承认，起初我没有很好地坚持教授的建议。就像其他事情一样，我想把我的想法一想到就记下来，这样我几乎一打完代码就可以带着它转一圈。不用说，有一些非常难闻的代码味道，这使得扩展我的命令的特性越来越困难。

我发现自己打破的一个主要设计模式是单一责任模式。我在应该只处理字符串清理的地方编写了处理 I/O 的代码。我有许多重复的代码，当我找到一种更安全、更标准化的方法来处理操作系统及其文件系统时，这使我更难更新我的实现。我记得我把大部分代码复制到了不合适的地方，这样我就可以不止一次地从头开始。看着我的实现是如此的糟糕，就好像我没有从软件设计中学到任何东西一样…

第五课:即使你的学业结束了，学习也是一种选择。如果你还没有从我给本科生和教授的推荐信中了解到，我在大学里学的是计算机科学。我从我的老师那里学到了很多，也许从我的同龄人那里也学到了很多。但我必须承认，几乎每次我坐在电脑前，在白板上袖手旁观，或者开始在笔记本上记下想法时，都会发生同样的事情:我学到了新的东西，或者重新学到了我以前忘记的东西。无论哪种方式，学习都会发生。

正如我所说的，我确实从上大学、学习计算机科学和直接在我最喜欢的两位教授手下工作中学到了很多。但是像这样的附带项目，没有标题，没有解决方案手册，没有分数期望，没有教学大纲要求，比我以前的一些课程对我的学习帮助更大。我的意思并不是说我的课程无关紧要，不合格，或者诸如此类的事情。我的意思是，像这样的项目确实有助于区分软件工程师和计算机科学学生之间的区别，前者需要实际交付一份工作副本*而后者需要得到一个分数才能通过一门课程或保持一定的平均分数。*

期望是不一样的，我越早摆脱学生思维，我就越相信我会更适合软件领域的现实工作:*有用吗？它是否达到了预期的结果？用这些几乎看得见摸得着的指标来代替分数，这使得知道你知道什么和知道你需要知道什么变得更加重要。*

**第六课:迭代改进。愿意重新审视你的工作，让它变得更好。更干净。更简单。重构掉部分代码。返工 hacky 实现。简而言之，随着你的改变和对你的手艺了解得更多，让你的作品展现出来。这也是过程的一部分。**

如果你想看看命令行界面，它在 Github 上的`oleoneto/django-clite`:

 [## 奥莱内托/姜戈-克利特

### 一个处理 Django 项目创建和管理的 CLI 工具。安装…

github.com](https://github.com/oleoneto/django-clite)