<html>
<head>
<title>Exchange Rate Prediction (Part 1): EDA &amp; Data Visualisation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">汇率预测(第一部分):EDA和数据可视化</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/exchange-rate-prediction-part-1-276b6cd5338?source=collection_archive---------2-----------------------#2020-05-25">https://medium.com/analytics-vidhya/exchange-rate-prediction-part-1-276b6cd5338?source=collection_archive---------2-----------------------#2020-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4ba5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这部分是数据科学的开始，使用EDA清理和结构化数据集的可见性，然后是可视化和假设测试。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/605ee8586fff3d8bb80a16f9d25f1353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAhaD8B9dXy4NoD5bqB47g.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源:https://unsplash.com/photos/2VMcpbUR6w8</figcaption></figure><p id="29b9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">只是一些<strong class="jq hj">的免责声明</strong>在潜入之前:</p><p id="12cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">1.这个项目是构建和开发的系列之一，目的是从长远来看提高我的数据科学技能，包括技术和分析。<br/> 2。然而，我没有接受过正式的培训，也没有更高的数据科学学位。这些都是自学，从在线课程、中级阅读到日常练习。</p><p id="0f65" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，非常感谢您的反馈！</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="b23c" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">目录</h1><p id="b79b" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">我们开始吧！这是一个端到端项目，分为3个部分，涵盖以下几个部分:</p><ol class=""><li id="2575" class="lo lp hi jq b jr js ju jv jx lq kb lr kf ls kj lt lu lv lw bi translated"><strong class="jq hj">第一部分</strong>:解释性数据分析(EDA) &amp;数据可视化(奖励:假设检验)</li><li id="f06a" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated"><strong class="jq hj">第二部分:</strong>用4个回归模型进行机器学习</li><li id="72cd" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated">第三部分:机器学习(续)与ARIMA</li></ol><p id="e910" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">作为开始，本文将涵盖项目的第一部分，所以请在接下来的几天里继续关注其他两部分！如果你想看完整的库，向下滚动到末尾，看看我的Github链接；)</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="2bb5" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">介绍</h1><p id="c78e" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">汇率是每个人关注的日常话题之一，尤其是在当前全球经济受到严重影响的新冠肺炎形势下。因此，我对分析过去的汇率模式非常感兴趣，以便能够预测未来的价值。如果你和我一样感兴趣，你可以从Kaggle访问这个数据集<a class="ae jn" href="https://www.kaggle.com/brunotly/foreign-exchange-rates-per-dollar-20002019" rel="noopener ugc nofollow" target="_blank">来进行你自己的探索。</a></p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="1f57" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">A.解释性数据分析(EDA)</h1><p id="a65c" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">首先，让我们导入两个基本的Python库，Pandas和Numpy，并读取数据:</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="1c9e" class="mh ks hi md b fi mi mj l mk ml">import pandas as pd<br/>import numpy as np</span><span id="e5cd" class="mh ks hi md b fi mm mj l mk ml">df = pd.read_csv("Foreign_Exchange_Rates.csv")</span></pre><p id="e8c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了简单地理解我们的数据集，使用<strong class="jq hj"> df.head() </strong>查看前5行，使用<strong class="jq hj"> df.columns </strong>查看变量:</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="2008" class="mh ks hi md b fi mi mj l mk ml">df.head()<br/>print(df.columns)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/83a65194f106db82d03699ad8738ba85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c6-7sBhil4sucSWUOr_KKw.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/51690c6debb4f1460cc8fefd88f9a7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OzceFnIE50QADB2uzd9fQA.png"/></div></div></figure><p id="d7a4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">乍一看，我看到了一个不常见的名为“未命名:0”的变量，应该将其删除。</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="2adc" class="mh ks hi md b fi mi mj l mk ml">df = df.drop(columns=df.columns[0])</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/70c8ec999cc2c291661ce17fe1cd78e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdbas5ytta59rNQR2Ehm5w.png"/></div></div></figure><p id="f998" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，列名似乎太混乱了，以后很难调用，所以我将它们标准化为“国家货币/美元”(例如AUD/USD)。</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="73b6" class="mh ks hi md b fi mi mj l mk ml">new_col_names = ['Time Series', 'aud', 'eur', 'nzd', 'gbp', 'brl', 'cnd', 'cny', 'hkd', 'idr', 'krw', 'mxn', 'zar', 'sgd', 'dkk', 'jpy', 'myr', 'nok', 'sek', 'lkr', 'chf', 'twd', 'thb']</span><span id="a5bb" class="mh ks hi md b fi mm mj l mk ml">df.columns = new_col_names</span><span id="45a1" class="mh ks hi md b fi mm mj l mk ml">df.columns = map(str.upper, df.columns)<br/>df.rename(columns=lambda x:x+'_USD', inplace=True)<br/>df.rename(columns={'TIME SERIES_USD':'Time Series'}, inplace=True)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/1436c6f0da78a76a8ab2a52a5c6cc698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLjC096NdEfXCqa-4KqQfg.png"/></div></div></figure><p id="257a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如您所见，我用新的国家货币代码创建了一个新列表，将它们大写，并在每个列名中添加了“_USD”。这就对了，一个更新鲜的数据集值得一看！</p><p id="6837" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">再次查看整个数据集，有一些名为“ND”的异常值。所以我用<strong class="jq hj"> np.nan </strong>将它们替换为“nan”值，然后一次性删除所有“NaN”值。如果使用<strong class="jq hj"> df.isna()没有找到“NaN”值。sum() </strong>，我们准备好了！</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="9f1e" class="mh ks hi md b fi mi mj l mk ml">df = df.replace('ND', np.nan)<br/>df = df.dropna().reset_index(drop=True)<br/>df.isna().sum()</span></pre></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="d775" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">B.数据可视化</h1><p id="9a63" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">让我们以一种更具视觉吸引力的方式来看看数据集吧！</p><p id="4d2c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，我们需要通过调用<strong class="jq hj"> df.dtypes </strong>和<strong class="jq hj"> pd.to_numeric </strong>进行类型转换来确保值是数值而不是对象。</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="3c28" class="mh ks hi md b fi mi mj l mk ml">df.dtypes</span><span id="33fc" class="mh ks hi md b fi mm mj l mk ml">for col in df.columns[1:]:<br/>    df[col] = pd.to_numeric(df[col], errors='coerce')</span></pre><p id="2957" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用循环的<strong class="jq hj">将更改一次应用到所有列，而不是再次重复该过程。<strong class="jq hj">错误</strong>函数中的参数可以设置为“忽略”(原样返回无效值)或“强制”(以NaN形式返回无效值)。</strong></p><p id="6882" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于目前的日期格式是YYYY-MM-DD，这在图表中相对来说比较拥挤，所以我将添加另一个格式为YYYY-MM的列，并在替换中使用它。</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="8863" class="mh ks hi md b fi mi mj l mk ml">df['Time Series'] = pd.to_datetime(df['Time Series'])<br/>df['month'] = df['Time Series'].dt.month<br/>df['year'] = df['Time Series'].dt.year<br/>df['month_year'] = df['Time Series'].dt.to_period('M')</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/928440b0233d5e4352a4f9c9dae11f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZqpRJUG83KtQ_SPUODLpA.png"/></div></div></figure><p id="1248" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> pd.to_datetime </strong>将值从object转换为datetime，然后我们用<strong class="jq hj"> .dt.month </strong>和<strong class="jq hj"> .dt.year </strong>提取月份和年份。最后，我们使用<strong class="jq hj"> .dt.to_period('M') </strong>创建了一个名为“month_year”的新列。您可以参考此<a class="ae jn" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DatetimeIndex.to_period.html" rel="noopener ugc nofollow" target="_blank">文档</a>了解全部细节。</p><p id="5b37" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了简单起见，让我们先把澳元/美元的汇率形象化。</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="c325" class="mh ks hi md b fi mi mj l mk ml">df['AUD_USD'].count()</span></pre><p id="a9c1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过使用<strong class="jq hj">。count() </strong>，我们知道每一列都有<strong class="jq hj"> 5k+值</strong>。这是一个巨大的数字！因此，我们将取每个月的平均利率，假设平均值代表整个月。Groupby来救援了！</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="1077" class="mh ks hi md b fi mi mj l mk ml">df_groupby_aud = df.groupby('month_year').AUD_USD.mean().reset_index()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ms"><img src="../Images/6e4f7645da79b4e554f24c04204c49a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*cA_TFG_P4YL70c3YhNdt7w.png"/></div></figure><p id="cfc0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们为我们的第一个可视化图表导入Matplotlib库！</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="39ef" class="mh ks hi md b fi mi mj l mk ml">from matplotlib import pyplot as plt</span><span id="08fc" class="mh ks hi md b fi mm mj l mk ml">x = df_groupby_aud['month_year'].astype(str)<br/>y = df_groupby_aud['AUD_USD']</span><span id="77c9" class="mh ks hi md b fi mm mj l mk ml">plt.figure(figsize=(8,4))<br/>plt.plot(x, y)<br/>plt.title("Exchange Rate: AUD/USD")<br/>plt.xlabel("Month")<br/>plt.ylabel("Exchange Rate")<br/>plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/23aa91b45ab8985bf9af622b82f9b683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gT5lFh0EP-1hzDTsfqVfAQ.png"/></div></div></figure><p id="2944" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好的，我们现在可以看到澳元/美元的模式。让我们用不止一种汇率来升级我们的图表。</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="2616" class="mh ks hi md b fi mi mj l mk ml">groupby_all = df.groupby('month_year').apply(lambda x: pd.Series<br/>           ({<br/>              'AUD_mean': x['AUD_USD'].mean(),<br/>              'EUR_mean': x['EUR_USD'].mean(),<br/>              'NZD_mean': x['NZD_USD'].mean(),<br/>              'SGD_mean': x['SGD_USD'].mean(),<br/>              'GBP_mean': x['GBP_USD'].mean(),<br/>              'JPY_mean': x['JPY_USD'].mean(),<br/>              'CHF_mean': x['CHF_USD'].mean()<br/>                                             })).reset_index()</span><span id="058c" class="mh ks hi md b fi mm mj l mk ml">groupby_all = pd.DataFrame(groupby_all)</span><span id="65ca" class="mh ks hi md b fi mm mj l mk ml">groupby_all['USD_mean'] = [1 for i in range(240)]<br/>groupby_all.head()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/49b22cb0b2b0f509493995e7f69b25b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Nz7DnRZeNejKMUAHl5vlA.png"/></div></div></figure><p id="0098" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了对多列进行groupby，我们使用<strong class="jq hj"> lambda </strong>对一系列列应用函数(在本例中为<strong class="jq hj">)。mean() </strong>)，然后转换回DataFrame更方便使用。</p><p id="e4b4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我之所以创建USD_mean这一列并加上值1，是为了直观地说明所有汇率相对于基线的差异。列表理解是创建这种列表最简单的方法。</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="0cf6" class="mh ks hi md b fi mi mj l mk ml">y_all = groupby_all[['AUD_mean', 'EUR_mean', 'NZD_mean', 'SGD_mean', 'GBP_mean', 'CHF_mean','USD_mean']]<br/>labels = ["AUD_mean", "EUR_mean", "NZD_mean", "SGD_mean", "GBP_mean", "CHF_mean", "USD_mean"]<br/>x_ticks = list(range(1, 240, 12))<br/>x_ticklabels = [x for x in range(2000, 2021)]</span><span id="5287" class="mh ks hi md b fi mm mj l mk ml">plt.figure(figsize=(20,10))<br/>ax = plt.subplot()</span><span id="a230" class="mh ks hi md b fi mm mj l mk ml">plt.plot(x, y_all)<br/>ax.set_xticks(x_ticks)<br/>ax.set_xticklabels(x_ticklabels)<br/>plt.legend(labels)<br/>plt.title("Exchange Rate: Top Countries/USD")<br/>plt.xlabel("Year")<br/>plt.ylabel("Exchange Rate")</span><span id="c837" class="mh ks hi md b fi mm mj l mk ml">plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/cc2dec96044979f4affc8ed8606b13f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MvCIIbQrjgBOZ7wbyqZ5Lg.png"/></div></div></figure><p id="9a69" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">给你！！可以看出，所有汇率相对于美元基线的模式都非常相似。这样的峰值出现在2008年到2010年之间，这可以用2008年的大衰退来解释。</p><p id="c6a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">除了Matplotlib，还有其他几个可视化库，如<strong class="jq hj"> Plotly或Bokeh </strong>，它们提供了更多的交互选项。如果您热衷于探索，请查看我的Github的完整代码。下面是一个使用散景的简单图表:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/8fd11913acbbb26fb4178115acf1821a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hMNUw_aIrgXUVw9Uhy_luw.png"/></div></div></figure></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="2c13" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">C.假设检验</h1><p id="acdd" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">老实说，我仍然在与假设检验背后的大量不同元素、理论和功能进行斗争。</p><p id="fb8b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是为什么我决定在这个项目中练习一下，问自己数据集中的这些变量是否彼此不同。</p><p id="e23f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们在这个例子中使用AUD_mean和SGD_mean。我使用这两个变量的原因是，我在上面的图表中看到了<strong class="jq hj">的相对差异。所以这个测试是为了<strong class="jq hj">打消或者反驳</strong>我之前的假设。</strong></p><p id="9d22" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> H0(零假设)</strong>:AUD的均值与SGD的均值相同。<br/><strong class="jq hj">【H1(替代假设)</strong>:AUD的均值与SGD的均值显著不同。</p><p id="3809" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，在进行假设检验之前，我们需要了解一些先决条件和过程:</p><ol class=""><li id="7d1d" class="lo lp hi jq b jr js ju jv jx lq kb lr kf ls kj lt lu lv lw bi translated">从每个群体中取出样本数据集</li><li id="e258" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated">检验每个样本集的正态性和两个样本集的相关性</li><li id="6e75" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated">选择要使用的正确假设检验</li></ol><p id="ec60" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于1。任务，问题是“我们应该从每个群体中提取多少数据？”。如果你记得，我们有超过5k+值(人口)的每个变量。为了确定样本大小，我们可以依靠<strong class="jq hj">功效分析。</strong></p><p id="a079" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但首先，让我们准备本部分的数据集:</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="437a" class="mh ks hi md b fi mi mj l mk ml">aud_sgd = df.loc[:,['AUD_USD', 'SGD_USD']]</span><span id="6e00" class="mh ks hi md b fi mm mj l mk ml">aud = np.array(aud_sgd.iloc[:,0])<br/>sgd = np.array(aud_sgd.iloc[:,1])</span></pre><p id="4abf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我们导入<strong class="jq hj"> statsmodels </strong>库进行功耗分析:</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="bd13" class="mh ks hi md b fi mi mj l mk ml">import statsmodels.stats.power as sms</span><span id="0f32" class="mh ks hi md b fi mm mj l mk ml">n = sms.TTestPower().solve_power(effect_size=0.3, power=0.9, alpha=0.05)</span><span id="219a" class="mh ks hi md b fi mm mj l mk ml">print(n)</span></pre><p id="2043" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有关全部细节，请参考此处的本文档<a class="ae jn" href="https://www.statsmodels.org/stable/generated/statsmodels.stats.power.TTestIndPower.solve_power.html" rel="noopener ugc nofollow" target="_blank">。简而言之，<strong class="jq hj"> TTestPower </strong>是成对样本t检验的统计功效计算。我们知道这些变量是成对的(或在某种程度上有联系)，因为它们被美元汇率所除。<strong class="jq hj">。solve_power() </strong>是一个包含3个核心参数的函数:效果大小、功效和alpha(又名显著性水平):</a></p><ol class=""><li id="207c" class="lo lp hi jq b jr js ju jv jx lq kb lr kf ls kj lt lu lv lw bi translated"><strong class="jq hj">效应大小</strong>:通俗地说，就是指两组的差异(如两组的均值差异)除以其中一组的标准差。如果没有足够的数据进行计算，我们可以在稍后测试正态性时使用0.3到0.8范围内的效应大小，以找到最佳的效应大小。</li><li id="a72a" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated"><strong class="jq hj">功效</strong>:是我们应该拒绝零假设的概率。人们普遍认为，功效应该是0.8或0.9，这取决于你希望自己找到显著差异的几率有多大。</li><li id="03f4" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated"><strong class="jq hj">α:</strong>是我们愿意接受的错误率，往往设定为0.05或0.01。简而言之，阿尔法值为0.05意味着我们愿意接受我们的结果有5%的可能性是由于偶然性/随机性。</li></ol><p id="40d4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我的解释似乎有点难以理解，我建议你看看不同的材料，以真正理解这个概念，其中之一是这个文档<a class="ae jn" href="http://meera.snre.umich.edu/power-analysis-statistical-significance-effect-size" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="7f57" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在运行功效分析之后，我们发现每个变量的样本大小是118。然后，我们使用这个数字从每个总体中随机生成样本集:</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="8317" class="mh ks hi md b fi mi mj l mk ml">aud_sample = np.random.choice(aud, size=118)<br/>sgd_sample = np.random.choice(sgd, size=118)</span></pre><p id="58a4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一步完成！</p><p id="5e38" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">继续第二步，我们需要检验每个样本集的正态性以及两者的相关性。简而言之，要求两个样本集<strong class="jq hj">正态分布</strong>和<strong class="jq hj">互不相关</strong>。</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="c371" class="mh ks hi md b fi mi mj l mk ml">from scipy.stats import shapiro, pearsonr</span><span id="41a4" class="mh ks hi md b fi mm mj l mk ml">stat, p1 = shapiro(aud_sample)<br/>stat, p2 = shapiro(sgd_sample)<br/>print(p1)<br/>print(p2)</span><span id="88d9" class="mh ks hi md b fi mm mj l mk ml">stat, p3 = pearsonr(aud_sample, sgd_sample)<br/>print(p3)</span></pre><p id="d894" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">关于H0和H1每次测试的细节，请参考这个快速<a class="ae jn" href="https://machinelearningmastery.com/statistical-hypothesis-tests-in-python-cheat-sheet/" rel="noopener ugc nofollow" target="_blank">小抄</a>。</p><p id="9109" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">回到我们的例子，如果我们使用0.3的效应大小，结果表明“非正态分布”。由于我增加了效应大小，最终达到0.8(样本大小为18)，样本集呈正态分布，用于假设检验。对于皮尔逊检验，它们是相互独立的。</p><pre class="iy iz ja jb fd mc md me mf aw mg bi"><span id="9943" class="mh ks hi md b fi mi mj l mk ml">from scipy.stats import ttest_ind<br/>tstat, pval = ttest_ind(aud_sample, sgd_sample)<br/>print(pval)</span></pre><p id="4a65" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，让我们导入scipy库进行假设检验。我们寻找的答案是AUD和SGD样本集的均值是否相等。如果pval &lt;0.05, we can reject the null hypothesis saying that they are different.</p><p id="a579" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">However, it turned out that my assumption from the chart that their means are different has been rejected, as the pval &gt; 0.05！</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="ac81" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好了，这是这个项目的第一部分的总结！唷，真的读了很久？！</p><p id="3516" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我希望你喜欢我的第一篇媒体文章，并随时在这里或我的Github上发表评论！请务必关注<strong class="jq hj">我关于<strong class="jq hj">机器学习</strong>的下两个部分</strong>，看看<strong class="jq hj">我是如何计算2020年的预测汇率的！</strong></p><p id="64a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们连线吧！</p><p id="26c0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">github:<a class="ae jn" href="https://github.com/andrewnguyen07" rel="noopener ugc nofollow" target="_blank">https://github.com/andrewnguyen07</a><br/>领英:<a class="ae jn" href="http://www.linkedin.com/in/andrewnguyen07" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/andrewnguyen07</a></p><p id="f6ad" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">谢谢！</p></div></div>    
</body>
</html>