<html>
<head>
<title>Speed up your HTTP Web Requests with the Asyncio Library in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的Asyncio库加速HTTP Web请求</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/summary-74789e47d420?source=collection_archive---------3-----------------------#2019-12-29">https://medium.com/analytics-vidhya/summary-74789e47d420?source=collection_archive---------3-----------------------#2019-12-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/faef5729499d6e65689dd5b01b84cb43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owfeCB59M7jAcW103kY74A.png"/></div></div></figure><div class=""/><h1 id="3fa9" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">摘要</h1><p id="341e" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这是一篇关于使用Asynciolibrary加速使用来自stats.nba.com的数据的Python中的HTTP请求的文章。它面向的是那些不是Python专家，但是遇到了大量HTTP请求的输入/输出(I/O)瓶颈的人(Python代码在文章的末尾，或者可以从<a class="ae km" href="https://github.com/tkpca/Python-Scripts/tree/master/Web%20Requests" rel="noopener ugc nofollow" target="_blank">https://github . com/tkpca/Python-Scripts/tree/master/Web % 20 requests</a>获得)。</p><p id="f3f7" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hu">底线:我使用Asyncio在大约5-6分钟内完成了3690个查询(一个NBA赛季1230场比赛x 3个不同的查询/赛季),而使用标准的requests库需要大约2-4个小时。(它实际上可以运行得更快，但我发现推动它会导致知识产权禁令。)</strong></p><p id="a334" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">下面是一个使用上面的数据构建的散点图的例子(在以后的文章中会详细介绍如何实现交互)。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ks"><img src="../Images/e193a15e3a672aed706bd16f81da9261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ooyF84hsJ09hC3uhFjGMag.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">按游戏比较真实命中率和玩家影响评估</figcaption></figure><h1 id="4400" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">这是给谁的？</h1><p id="d347" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果您是一名业余程序员，并且正在寻找一个可以重新用于API调用的脚本，那么可以根据您的需要对代码(发布在文章末尾)进行提取和编辑。</p><p id="0887" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我用于球员数据的脚本要长得多，所以对于这个例子，我提取了NBA联合收割机信息(【https://stats.nba.com/draft/combine/】T4)。标准和异步版本的代码都在我的Github页面上，<a class="ae km" href="https://github.com/tkpca/Python-Scripts/tree/master/Web%20Requests" rel="noopener ugc nofollow" target="_blank">https://Github . com/tkpca/Python-Scripts/tree/master/Web % 20 requests</a>。</p><h1 id="3e34" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">背景</h1><p id="1fcd" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我一直在寻求提高我的Python技能，这意味着找到一个个人项目。幸运的是，我是NBA的忠实粉丝，NBA碰巧跟踪了大量的数据(弄清楚如何使用API存在一些挑战，但这将在一组单独的帖子中解决)。最终，我想出了如何用Python从stats.nba.com提取JSON数据，但发现这要花很长时间…我可以按赛季提取所有球员的数据(基本和高级方块得分统计)，只是提取一个赛季的数据需要3-4个小时。</p><p id="0715" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在做了一些研究之后，我注意到这在某种程度上是Python请求库的一个限制。有人可以更详细地解释这一点的技术原因(<a class="ae km" href="https://hackernoon.com/are-your-python-programs-running-slow-heres-how-you-can-make-them-7x-faster-3d6758cd3305" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/are-your-python-programs-running-slow-heres-how-you-can-make-them-7x-faster-3d 6758 CD 3305</a>)，但是，简单地说，我在代码中执行了多个web查询，这些查询都必须按顺序发生……因此，查询服务器，等待结果，处理，进入下一个查询，等等。</p><h1 id="2e5a" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么是异步？</h1><p id="43c2" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一个朋友建议设置多线程，但坦白地说，我不了解Python，想要类似的东西。我想做的只是收集数据，这样Asyncio + Aiohttp虽然令人困惑，但似乎更合理。</p><p id="3b94" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">另外，<strong class="jq hu">确保你用的是Python 3.75+ </strong>。我再怎么强调这一点也不为过，因为图书馆似乎变化很大。我也没发现很多解释超级有用，尽管这个很有帮助，【https://realpython.com/async-io-python/<a class="ae km" href="https://realpython.com/async-io-python/" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="7304" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">这在英语中是什么意思？</h1><p id="6219" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Realpython有一个关于异步如何/为什么为I/O绑定的任务工作的很好的类比，但是简单地说，想象一下你正在去杂货店购物，需要从肉店柜台拿水果和一些肉，在那里肉店老板花5分钟切你的肉，10分钟拿你的水果；为了简单起见，假设告诉屠夫你想要什么的时间可以忽略不计。</p><p id="8ab9" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">1)你可以去肉柜台拿水果，然后等着肉做好(反之亦然)。总时间为15分钟(5+10)。这类似于标准的请求方法。</p><p id="0d0b" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">2)你去熟食柜台点了肉，然后去买水果。总时间现在是10分钟。这类似于Ayschio/Aiohttp方法。</p><p id="678d" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">换句话说，你不是停下来等屠夫，而是让他做他的事情，然后去做别的事情。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lb"><img src="../Images/0af723b08092a77bca597a4a10005f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2FybMoM5A0YxKcMr-rCtug.jpeg"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">你不需要等我！</figcaption></figure><h1 id="61d4" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">它是如何工作的？</h1><p id="a28d" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">随附的Juptyer笔记本详细介绍了细节，但在较高层面上，我是这样解释需要做的事情的:</p><p id="ccfc" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">1)您需要创建一个协程。还有更多技术上优雅的解释，但简单地说，我将描述为一个返回值的函数，<em class="lc">除了它以</em> <strong class="jq hu"> <em class="lc"> async </em> </strong> <em class="lc">开始，任何值在被返回之前都需要有</em><strong class="jq hu"><em class="lc">await</em></strong><em class="lc"/>关键字。Async告诉Python它是一个协程，await确保它在返回结果之前等待结果。这里的区别在于，与标准函数不同，协程可以让代码的其余部分在等待值时执行。</p><p id="b796" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">2)一旦你有了一些协程，你需要用那个协程建立一个循环。异步调用这个"<strong class="jq hu">asyn CIO . create _ task</strong>"——基本上像调用普通函数一样调用协程，除了在调用协程之前添加<strong class="jq hu">asyn CIO . create _ task</strong>(&lt;your coroutine这里是&gt;)。这调度协程的执行。(注意:如果你使用的是Python 3.6或者更早的版本，这就叫做<strong class="jq hu">asyncio . assure _ future()</strong>。</p><p id="e980" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">3)然后你需要收集结果。Realpython对此解释得比我更好，但基本上你需要设置一个变量=<strong class="jq hu">await asyncio . gather</strong>(&lt;变量带有来自create_task &gt;的协程结果)。这将所有结果放入一个变量中，您可以将该变量传递回主例程。</p><p id="befd" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">a.最后，在主例程中设置一个变量来运行所有这些。假设您的函数在一个名为main的例程中——这让我迷惑了——如果您使用Jupyter笔记本 ，它将是:<code class="du ld le lf lg b"><strong class="jq hu">variable = await main()</strong></code> <strong class="jq hu"> <em class="lc">。在Jupyter之外，模式是<code class="du ld le lf lg b"> <strong class="jq hu">variable = asyncio.run(main())</strong></code> <strong class="jq hu"> — <em class="lc">大多数文章似乎都引用了这个版本，所以如果你正在使用Jupyter，希望这能帮你减少一些挫折</em>。</strong></em></strong></p><p id="d9e4" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">仅此而已。请参阅嵌入的代码，实际浏览一个实际的示例。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div class="er es lh"><img src="../Images/91e512c38745c8235c7fde44eddb467c.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*bcLWRLN7OJxN3AiwBbRxDQ.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx translated">一个简短的例子拉NBA联合数据。到这里<a class="ae km" href="https://github.com/tkpca/Python-Scripts/tree/master/Web%20Requests" rel="noopener ugc nofollow" target="_blank">https://github . com/tkpca/Python-Scripts/tree/master/Web % 20 requests</a>自己去看看吧！</figcaption></figure></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="kx ky et er es kz la bd b be z dx translated">Jupyter实验室代码</figcaption></figure></div></div>    
</body>
</html>