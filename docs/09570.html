<html>
<head>
<title>Keras &amp; TensorFlow to Predict Market Movements and Backtest using Backtrader</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Keras &amp; TensorFlow使用Backtrader预测市场走势和回测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/keras-tensorflow-to-predict-market-movements-and-backtest-using-backtrader-d51b0b3e9070?source=collection_archive---------1-----------------------#2020-09-11">https://medium.com/analytics-vidhya/keras-tensorflow-to-predict-market-movements-and-backtest-using-backtrader-d51b0b3e9070?source=collection_archive---------1-----------------------#2020-09-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="d998" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我的上一篇文章— <a class="ae jk" rel="noopener" href="/analytics-vidhya/ml-classification-algorithms-to-predict-market-movements-and-backtesting-2382fdaf7a32?source=friends_link&amp;sk=28adc30998b92ce65f5ad14c883a2621">预测市场运动的ML分类算法和回溯测试</a>中，我们使用了多种基于scikit-learn的分类算法来预测股票运动的方向。在本文中，让我们使用Keras &amp; TensorFlow和一些附加功能，看看我们是否可以获得更好或可比的结果。你可以在我的<a class="ae jk" href="https://github.com/sabirjana/blog/tree/master/Deep_Learning" rel="noopener ugc nofollow" target="_blank"> Github </a>页面上找到本文使用的相关Jupyter笔记本。我们的方法如下:</p><ol class=""><li id="4a55" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">收集历史定价数据。</li><li id="eee4" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">特征工程。</li><li id="04a4" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">深度学习模型的建立和应用。</li><li id="a287" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用反向交易者进行策略反向测试。</li></ol></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="ffc0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">收集历史定价数据</strong></p><p id="d41c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将继续使用Nifty-50指数进行分析。我们将借助<code class="du jz ka kb kc b"><a class="ae jk" href="https://github.com/ranaroussi/yfinance" rel="noopener ugc nofollow" target="_blank">yfinance</a></code> python库下载每日收盘价格数据，计算每日日志回报，并在此基础上得出市场方向。我们将可视化收盘价和每日回报，以快速检查我们的数据。由于代码与我上一篇文章中的相同，我们就不在这里重复了。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/3e73700ce021f8ab02bdaffb140519ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyaSoUWZ1RH5xRtcimhoYA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">每日定价和日志回报</figcaption></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="0162" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">特征工程</strong></p><p id="be3f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除了之前使用的五天滞后回报，让我们也使用一些额外的技术指标，如RSI(相对强度指数)，布林线，移动平均线收敛发散(MACD)指标。我已经用python库<a class="ae jk" href="https://github.com/mrjbq7/ta-lib" rel="noopener ugc nofollow" target="_blank"> ta-lib </a>计算过技术指标。这一部分的python代码如下:</p><pre class="ke kf kg kh fd kt kc ku kv aw kw bi"><span id="761f" class="kx ky hi kc b fi kz la l lb lc"># define the number of lags<br/>lags = [1, 2, 3, 4, 5]</span><span id="c985" class="kx ky hi kc b fi ld la l lb lc"># compute lagged log returns<br/>cols = []<br/>for lag in lags:<br/>    col = f'rtn_lag{lag}'<br/>    stock[col] = stock['returns'].shift(lag)<br/>    cols.append(col)<br/>stock.head(2)</span><span id="47c6" class="kx ky hi kc b fi ld la l lb lc"># RSI - Relative Strenght Index<br/>stock['rsi'] = RSI(stock.close)</span><span id="31d6" class="kx ky hi kc b fi ld la l lb lc"># append to feature columns list<br/>cols.append('rsi')<br/>stock.tail(2)</span><span id="5186" class="kx ky hi kc b fi ld la l lb lc"># Compute Bollinger Bands<br/>high, mid, low = BBANDS(stock.close, timeperiod=20)<br/>stock = stock.join(pd.DataFrame({'bb_high': high, 'bb_low': low}, index=stock.index))</span><span id="0813" class="kx ky hi kc b fi ld la l lb lc"># append to feature columns list<br/>cols.append('bb_high')<br/>cols.append('bb_low')</span><span id="efcc" class="kx ky hi kc b fi ld la l lb lc"># Compute Moving Average Convergence/ Divergence<br/>stock['macd'] = MACD(stock.close)[0]</span><span id="dd42" class="kx ky hi kc b fi ld la l lb lc"># append to feature columns list<br/>cols.append('macd')</span></pre><p id="1949" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="5679" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">定义一个函数来计算5天的滞后回报以及一个列表变量- <code class="du jz ka kb kc b">cols</code>。我们使用这个变量来附加将用于模型的所有特性列名。</li><li id="397a" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">计算RSI指数，作为我们的<code class="du jz ka kb kc b">stock</code>数据框架的附加列。</li><li id="92e9" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">同样，添加布林线和MACD指标的列。</li></ol></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="12b4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">深度学习模型的建立和应用</strong></p><p id="9627" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将使用Keras &amp; TensorFlow API的深度神经网络模型。我们的方法是API狩猎，这意味着什么和如何使用API，而不是进入数学解释。有关Keras &amp; TensorFlow的更多信息，请参考{ <a class="ae jk" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank">链接</a> }。这一部分的python代码如下:</p><pre class="ke kf kg kh fd kt kc ku kv aw kw bi"><span id="98d8" class="kx ky hi kc b fi kz la l lb lc"># split the dataset in training and test datasets<br/>train, test = train_test_split(stock.dropna(), test_size=0.4, shuffle=False)</span><span id="d814" class="kx ky hi kc b fi ld la l lb lc"># sort the data on date index<br/>train = train.copy().sort_index()<br/>test = test.copy().sort_index()</span><span id="3cfe" class="kx ky hi kc b fi ld la l lb lc"># define a function to create the deep neural network model<br/>def create_model():<br/>    np.random.seed(100)<br/>    tf.random.set_seed(100)<br/>    model = Sequential()<br/>    model.add(Dense(64, activation='relu', input_dim=len(cols)))<br/>    model.add(Dense(64, activation='relu'))<br/>    model.add(Dense(1, activation='sigmoid'))<br/>    model.compile(loss='binary_crossentropy', optimizer='adam', <br/>                  metrics=['accuracy'])<br/>    return model</span><span id="504b" class="kx ky hi kc b fi ld la l lb lc"># normalized the training dataset<br/>mu, std = train.mean(), train.std()<br/>train_ = (train - mu) / mu.std()</span><span id="dc9b" class="kx ky hi kc b fi ld la l lb lc"># create the model<br/>model = create_model()</span><span id="cb3b" class="kx ky hi kc b fi ld la l lb lc"># map market direction of (1,-1) to (1,0)<br/>train['direction_'] = np.where(train['direction'] &gt; 0, 1, 0)</span><span id="3cfd" class="kx ky hi kc b fi ld la l lb lc">%%time<br/># fit the model for training dataset<br/>r = model.fit(train_[cols], train['direction_'], epochs=50, verbose=False)</span><span id="a65c" class="kx ky hi kc b fi ld la l lb lc"># normalized the test dataset<br/>mu, std = test.mean(), test.std()<br/>test_ = (test - mu) / std</span><span id="e003" class="kx ky hi kc b fi ld la l lb lc"># map market direction of (1,-1) to (1,0)<br/>test['direction_'] = np.where(test['direction'] &gt; 0, 1, 0)</span><span id="eacb" class="kx ky hi kc b fi ld la l lb lc"># evaluate the model with test dataset<br/>model.evaluate(test_[cols], test['direction_'])</span><span id="e8c5" class="kx ky hi kc b fi ld la l lb lc"># predict the direction and map it (1,0)<br/>pred = np.where(model.predict(test_[cols]) &gt; 0.5, 1, 0) <br/>pred[:10].flatten()</span></pre><p id="4520" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="ea79" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">将上一节创建的<code class="du jz ka kb kc b">stock</code>数据帧分割成训练和测试数据集。我保留了参数<code class="du jz ka kb kc b">shuffle=False</code>和参数<code class="du jz ka kb kc b">test_size=0.4</code>。这意味着我们将使用最初的60%数据集进行训练，剩下的40%将用于测试。</li><li id="fd3b" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用日期时间索引对定型和测试数据集进行排序，并定义一个函数来构建模型。参数<code class="du jz ka kb kc b">input_dim=len(cols)</code>是特征列的数量。我使用了<code class="du jz ka kb kc b">activation=’relu’</code>作为输入层和密集层，不过你可以探索其他选项。输出层的激活函数必须是“sigmoid ”,因为我们试图解决一个分类问题。由于这是一个分类问题，损失函数必须是“binary_crossentropy ”,但是对于优化器，您可以进行试验。</li><li id="044c" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">接下来，我们规范化训练数据集，并通过调用上一步中创建的函数来创建模型。</li><li id="3612" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">将定型数据集的市场方向(1，-1)映射到(1，0)，并使用x作为规范化特征列，y作为市场方向来拟合模型。</li><li id="3f93" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">接下来，标准化测试数据集，并将测试数据集的市场方向(1，-1)映射到(1，0)，并使用测试数据集评估模型。</li><li id="3864" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用规范化测试数据集的特征列预测市场方向，并根据预测值是大于还是小于0.5将预测值映射到(1，0)。</li></ol><p id="dff0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，根据我们的预测，我们将计算投资组合头寸和策略回报，并将买入并持有的累积回报与策略回报进行可视化。</p><pre class="ke kf kg kh fd kt kc ku kv aw kw bi"><span id="1c52" class="kx ky hi kc b fi kz la l lb lc"># based on prediction calculate the position for strategy<br/>test['position_strategy'] = np.where(pred &gt; 0, 1, -1)</span><span id="d694" class="kx ky hi kc b fi ld la l lb lc"># calculate daily returns for the strategy<br/>test['strategy_return'] = test['position_strategy'] * test['returns']</span><span id="69ca" class="kx ky hi kc b fi ld la l lb lc"># calculate total return and std. deviation of each strategy<br/>print('\nTotal Returns:')<br/>print(test[['returns', 'strategy_return']].sum().apply(np.exp))<br/>print('\nAnnual Volatility:')<br/>print(test[['returns', 'strategy_return']].std() * 252 ** 0.5)</span><span id="eec2" class="kx ky hi kc b fi ld la l lb lc"># number of trades over time for the strategy<br/>print('Number of trades = ', (test['position_strategy'].diff()!=0).sum())</span><span id="8b45" class="kx ky hi kc b fi ld la l lb lc"># plot cumulative returns<br/>fig, ax = plt.subplots(1, 1, sharex=True, figsize = (14,6))<br/>ax.plot(test.returns.cumsum().apply(np.exp), label = 'Nifty 50 Buy and Hold')<br/>ax.plot(test.strategy_return.cumsum().apply(np.exp), label = 'Strategy')<br/>ax.set(title = 'Nifty 50 Buy and Hold vs. Strategy', ylabel = 'Cumulative Returns')<br/>ax.grid(True)<br/>ax.legend()<br/>plt.savefig('images/chart2');</span></pre><p id="e354" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="f9ab" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">计算投资组合头寸，如果预测大于零，我们做多(1)，否则做空(-1)。</li><li id="c706" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">通过将头寸乘以实际日回报来计算投资组合回报。</li><li id="64a4" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">计算总回报、年标准差和交易者数量。</li><li id="aeee" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">想象Nifty-50的累积策略与买入并持有回报的关系。</li></ol><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es le"><img src="../Images/a0d4b7b6ad400242c6c98253b9ab7d2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*om9GDxxzR2u2tJMephH4UA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">Nifty 50买入并持有与策略</figcaption></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lf"><img src="../Images/1eac1dc431f7e3584c3bcfe5ea9b3e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*j31xplu37_ppaBIXaxBBLw.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">总回报和年度标准差</figcaption></figure><p id="636d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">哇！结果看起来相当令人印象深刻。我们策略的总回报是“买入并持有”策略的数倍。然而，正如我在上一篇文章中所讨论的，这是一个书面的回报，没有考虑任何约束。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="0d9b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">使用Backtrader对策略进行回溯测试</strong></p><p id="c391" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们在<a class="ae jk" href="https://www.backtrader.com/docu/" rel="noopener ugc nofollow" target="_blank">反向交易者</a>的帮助下，给反向测试添加一些约束和现实。我将保持回测策略与上一篇文章中使用的策略相同— <a class="ae jk" rel="noopener" href="/analytics-vidhya/ml-classification-algorithms-to-predict-market-movements-and-backtesting-2382fdaf7a32?source=friends_link&amp;sk=28adc30998b92ce65f5ad14c883a2621"> ML分类算法预测市场走势和回测</a>，因此不会从头再来一遍方法和代码。回顾一下总结:</p><ol class=""><li id="da41" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">我们从100，000英镑的初始资本和0.1%的交易佣金开始。</li><li id="009f" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">当<code class="du jz ka kb kc b">predicted</code>值为+1时，我们买入，当预测值为-1时，我们卖出(仅当持有股票时)。</li><li id="e8bc" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">全进策略——在创建买入订单时，尽可能多地买入股票。</li><li id="edc6" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">不允许卖空。</li></ol><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lg"><img src="../Images/4911039f1669a23aa4aee53f81412d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kEks2FfGN-Y6iiGxEyj_zQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">战略与基准(买入并持有)</figcaption></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lh"><img src="../Images/692de146a822811c90950349fe263bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*2JuwA6CfyA122v-K03wFHg.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">测试数据的策略性能</figcaption></figure><p id="45fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们分析一下我们策略的性能。年回报率为负，累计回报率为-33.26%，相比之下，向量化回测期间观察到的回报率超过16倍。如果我们将其他一些参数可视化，我们可以看到，在“禁止卖空”和交易佣金的限制下，我们的策略表现不佳。总之，在没有限制的情况下，事情在纸面上可能看起来很好，但是当我们考虑到现实市场中的限制和策略可行性时，现实可能完全不同。</p><p id="3d04" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">祝投资愉快，请在文章中留下您的评论！</p><p id="bf5f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="li">请注意:此分析仅用于教育目的，作者不对您的任何投资决策负责。</em></p><p id="3307" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">参考资料:</p><ol class=""><li id="9861" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><a class="ae jk" href="https://www.amazon.in/Python-Finance-2e-Yves-Hilpisch/dp/1492024333" rel="noopener ugc nofollow" target="_blank"> Python for Finance 2e:掌握数据驱动的金融</a>作者Yves Hilpisch</li><li id="da5d" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://www.amazon.in/Python-Finance-Cookbook-libraries-financial-ebook/dp/B083KG9DC7/ref=sr_1_2?dchild=1&amp;keywords=Python+for+Finance+Cookbook&amp;qid=1597938216&amp;s=books&amp;sr=1-2" rel="noopener ugc nofollow" target="_blank"> Python for Finance食谱:将现代Python库应用于金融数据分析的50多个食谱</a>作者Eryk Lewinson</li><li id="1ff2" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">Stefan Jansen的《算法交易的机器学习》</li><li id="783f" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">请在我的<a class="ae jk" href="https://www.linkedin.com/in/sabirjana/detail/recent-activity/shares/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>页面或<a class="ae jk" rel="noopener" href="/@sabirh.jana"> Medium </a>查看我关于量化金融的其他文章/帖子。</li></ol></div></div>    
</body>
</html>