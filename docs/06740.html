<html>
<head>
<title>Social Network Analysis in R part 1: Ego Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R中的社会网络分析第一部分:自我网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/social-network-analysis-in-r-part-1-ego-network-ab6b0d23ebc8?source=collection_archive---------6-----------------------#2020-06-01">https://medium.com/analytics-vidhya/social-network-analysis-in-r-part-1-ego-network-ab6b0d23ebc8?source=collection_archive---------6-----------------------#2020-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4011" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">社会网络分析简介及其在Twitter网络上的实现。第一部分:自我网络</p><p id="22f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我带去办公室内部培训日的第一部分SNA材料。我想说这是我雄心勃勃的作品之一(也是最耗时的)。我们将使用来自R语言的“tidygraph”包(包括“igraph”和“ggraph ”)来学习SNA。我们不仅要学习可视化的东西，还要学习度量标准。我们将使用“rtweet”包分析Twitter网络作为我们的研究案例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/ff718f96573871d07526d770070d5fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbNwtM22vBg-j1-FmM3Fdw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">带思维导图的SNA</figcaption></figure><h2 id="c764" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">什么是社会网络分析</h2><p id="4495" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">社会网络是由一组参与者组成的结构，其中一些参与者由一组一个或多个关系连接。SNA致力于描述社会结构的基本模式，解释这种模式对行为和态度的影响。社交网络分析有4种主要类型的网络指标，即:</p><ul class=""><li id="245c" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">网络模型:描述如何对用户之间的关系建模</li><li id="03e0" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">关键人物:根据不同的背景来识别网络中最有影响力的用户</li><li id="63a9" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">联系强度:衡量用户关系的强度</li><li id="774b" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">网络凝聚力:衡量网络中的凝聚实体对网络行为的影响。</li></ul><h2 id="b297" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">那又怎样？我们为什么需要它们？</h2><p id="ac49" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">人类是群居动物。即使在你睡觉的时候，你仍然可以通过你的智能手机与世界上的每个人保持联系。你的智能手机不断发送和接收信息，如天气信息、收到的WhatsApp消息、深夜的One Piece更新以及来自你最喜欢的偏见的社交媒体通知。我们总是联系在一起，到处都有网络。不知何故，一些在著名的小世界理论背后的聪明人从网络上发现了一些令人兴奋的东西。</p><p id="1b14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你知不知道你和你最爱的人只隔了六步的<a class="ae lh" href="https://en.wikipedia.org/wiki/Six_degrees_of_separation" rel="noopener ugc nofollow" target="_blank">？我们能够量化所谓的网络，并可以在许多领域实施。在本研究中，我们将只关注确定以“关键人物”作为预期输出的网络指标(参见上面的4种主要网络指标)。这里有一些SNA的实现，可以启发你一些关于SNA的知识:</a></p><p id="7c92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">业务:<br/> - <a class="ae lh" href="https://www.researchgate.net/publication/320653694_Social_network_data_analytics_for_market_segmentation_in_Indonesian_telecommunications_industry" rel="noopener ugc nofollow" target="_blank">社交媒体细分</a> <br/> - <a class="ae lh" href="https://ieeexplore.ieee.org/abstract/document/5076278" rel="noopener ugc nofollow" target="_blank">信息通过网络传播(用于营销目的)</a> <br/> - <a class="ae lh" href="https://www.researchgate.net/profile/Walter_Kosters/publication/267711959_Identifying_Prominent_Actors_in_Online_Social_Networks_using_Biased_Random_Walks/links/5550870208ae956a5d24d2c2.pdf" rel="noopener ugc nofollow" target="_blank">识别社会名人(用于识别最佳代言)</a> <br/> - <a class="ae lh" href="http://dl.acm.org/doi/abs/10.1145/1961189.1961194" rel="noopener ugc nofollow" target="_blank">映射潜在客户</a> <br/> - <a class="ae lh" href="https://www.tandfonline.com/doi/abs/10.1080/13683500.2014.990422" rel="noopener ugc nofollow" target="_blank">映射旅游流</a> <br/> <br/>非业务:<br/> -分析某事物如何在社交媒体上传播<br/> - <a class="ae lh" href="https://www.sciencedirect.com/science/article/pii/S0167587703000758" rel="noopener ugc nofollow" target="_blank">识别疾病传播</a> <br/></p><h2 id="c2d1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">我们开始吧</h2><p id="1179" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">必需的库。在您的工作目录中安装并加载这个库。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="af3c" class="jt ju hi lj b fi ln lo l lp lq"># for data wrangling. very helpfull for preparing nodes and edges data<br/>library(tidyverse) <br/>library(lubridate)</span><span id="79c0" class="jt ju hi lj b fi lr lo l lp lq"># for building network and visualization <br/>library(tidygraph)<br/>library(graphlayouts)<br/># already included in tidygraph but just fyi<br/>library(igraph)<br/>library(ggraph)</span><span id="516b" class="jt ju hi lj b fi lr lo l lp lq"># for crawling Twitter data <br/>library(rtweet)</span><span id="8045" class="jt ju hi lj b fi lr lo l lp lq"># for visualizing<br/>library(extrafont)<br/>loadfonts(device = "win")</span></pre><h2 id="0d02" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">先决条件</h2><p id="1cb5" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这项分析使用了Twitter数据。我们可以从开发者账户使用他们的rest API收集Twitter数据。您需要创建开发人员帐户，构建应用程序，并使用他们的令牌进行身份验证</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="53dd" class="jt ju hi lj b fi ln lo l lp lq">apikey &lt;- "A5csjkdrS2xxxxxxxxxxx"<br/>apisecret &lt;- "rNXrBbaRFVRmuHgEM5AMpdxxxxxxxxxxxxxxxxxxxxxxx"<br/>acctoken &lt;- "1149867938477797376-xB3rmjqxxxxxxxxxxxxxxxxxxx"<br/>tokensecret &lt;- "Dyf3VncHDtJZ8FhtnQ5Gxxxxxxxxxxxxxxxxxxxxxx"</span><span id="738c" class="jt ju hi lj b fi lr lo l lp lq">token &lt;- create_token(app = "Automated Twitter SNA",<br/>                      consumer_key = apikey,<br/>                      consumer_secret = apisecret,<br/>                      access_token = acctoken,<br/>                      access_secret = tokensecret)<br/># check the token<br/>get_token()</span></pre><p id="8b4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注</strong> <em class="ls"> : </em>最近更新的‘rtweet’允许你与Twitter API进行交互，而无需创建自己的Twitter开发者账户。你可能想先检查一下。</p><h2 id="2203" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">图论</h2><p id="3568" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在数学中，图论是对图形的研究，图形是用于建模对象之间成对关系的数学结构。本文中的图由通过<strong class="ih hj">边</strong>(也称为链接或线)连接的<strong class="ih hj">顶点</strong>(也称为节点或点)组成。一般来说，节点之间的连接分为两种类型:<a class="ae lh" href="https://www.mathworks.com/help/matlab/math/directed-and-undirected-graphs.html" rel="noopener ugc nofollow" target="_blank">有向和无向</a>。</p><ul class=""><li id="97d2" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">有向是边具有方向(边具有方向)的节点之间的关系。你会认出它是有箭头的边。有向网络也根据其方向分为两种类型，即:入度和出度。入度表示传入顶点/节点的边的数量。在下图中，A的入度是1，D的度是2。出度表示从顶点出来的边的数量。在下图中，A的出度是1，C的出度是3。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lt"><img src="../Images/84c526daa7f05846f4d3458a7764e681.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*h2fnDdhuijwRIbjAnWV2gA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">有向图</figcaption></figure><ul class=""><li id="596e" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">无方向表示双向关系，边是单向的，没有与之相关联的方向。因此，图可以在任一方向上遍历。没有箭头说明这个图是无向的。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/abbf1570eeea1239aa0ca81bfb43934b.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*xnrETfp9EwxP5XTRI4JHwQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">无向图</figcaption></figure><h2 id="8532" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">图表指标(中心性和模块性)</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lv"><img src="../Images/4231efa53ecb64c14a3163fec3a517d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*3c8vydsK4zzs4roaox7SZQ.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">网络中心性</figcaption></figure><p id="ca72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">度中心性</strong></p><p id="75cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中最简单的中心性。只是<strong class="ih hj">一个节点有多少条纽带</strong>。有向和无向的计算有点不同，但它有相同的想法:有多少个节点连接到一个节点。</p><p id="60a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">接近中心性</strong></p><p id="b8e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点的接近中心性是图中该节点与所有其他节点之间的最短路径(测地线)的平均长度。因此，一个节点越中心，它离所有其他节点就越近。具有最高接近中心性的节点被认为是比整个网络中的任何节点更快地传播信息的节点。</p><p id="53e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">中间中心性</strong></p><p id="7935" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">中间中心性量化了节点<strong class="ih hj">作为两个其他节点/组之间的最短路径上的桥的次数。</strong>具有最高介数中心性的节点被认为是传播信息最广泛的节点。</p><p id="b668" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">特征向量中心性</strong></p><p id="6144" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特征向量中心性是网络中节点影响力的度量。分配给网络中节点的相对分数基于这样的概念，即与低分数节点的同等连接相比，与高分数节点的<strong class="ih hj">连接对所讨论节点的分数</strong>贡献更大。这个惊人的<a class="ae lh" href="http://matrixcalc.org/en/vectors.html" rel="noopener ugc nofollow" target="_blank">链接</a>将帮助你进行计算。具有最高特征向量中心性值的节点意味着它们接近在网络中具有高影响力的另一个人。</p><p id="19c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">社区和模块化</strong></p><p id="010e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图论中构建社区与机器学习中的聚类有点不同。“igraph”包实现了许多社区检测方法，社区结构检测算法试图通过优化一些标准并通常使用试探法来在有向或无向图中找到密集子图。像“group_walktrap()”、“group_fast_greedy()”和“group_louvain()”这样的社区检测算法有它们自己的方式来在网络中创建社区。一种常用的社区检测算法是“group_walktrap()”。这个函数试图通过随机行走找到密集连接的子图，也称为图中的社区。这个想法是短距离随机漫步倾向于停留在同一个社区。</p><p id="6c2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，模块性是划分好坏的一种度量，或者不同顶点类型之间的分离程度。综上所述，<strong class="ih hj">模块化程度高的网络在社区内的节点之间具有密集的连接，而在不同社区的节点之间具有稀疏的连接</strong></p><h1 id="0823" class="lw ju hi bd jv lx ly lz jz ma mb mc kd md me mf kg mg mh mi kj mj mk ml km mm bi translated">团队精神自我网络</h1><p id="efbe" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我警告你，这将是一个很长的分析，因为数据收集和争论步骤需要做很多事情。Ego网络是指示ego/节点直接连接到的所有节点的数量的概念，并且包括网络中节点之间的所有联系。你随便找一个你想分析的用户名/公司/个人，收集他们所有的邻居，然后进行分析。在这种情况下，我想分析TeamAlgoritma Twitter帐户ego network。TeamAlgoritma是我最近合作的公司。此分析的目标是:从TeamAlgoritma共同客户中可视化顶级集群，找出哪个客户具有广泛传播信息的潜力，计算中心性，并找出谁是TeamAlgoritma网络中的<strong class="ih hj">关键人物</strong>。</p><h2 id="15db" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">数据收集过程</h2><p id="1f56" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">首先，我们需要收集@ TeamAlgoritma帐户数据及其追随者</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="02aa" class="jt ju hi lj b fi ln lo l lp lq"># gather teamalgoritma data<br/>algo &lt;- lookup_users("teamalgoritma")</span><span id="a451" class="jt ju hi lj b fi lr lo l lp lq"># get TeamAlgoritma followers and its account details<br/>folower &lt;- get_followers("teamalgoritma",n = algo$followers_count,retryonratelimit = T)<br/>detail_folower &lt;- lookup_users(folower$user_id)<br/>detail_folower &lt;- data.frame(lapply(detail_folower,as.character),<br/>stringsAsFactors = F)</span></pre><p id="51e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TeamAlgoritma推特账户有342名关注者(2020年5月15日)。我们需要收集他们所有的追随者和追随者，但Twitter rest API有(有点吝啬)的限制。我们只能收集15个用户(包括跟随者和追随者)和每15分钟检索5k，所以你可以想象如果我们要检索数千人..为了最大限度地减少时间消耗，我们需要只过滤活跃用户。“活跃用户”的标准取决于您的数据。你需要查找你的追随者是哪种类型的用户，并建立自己的标准。在这种情况下，Algoritma的前8名关注者是一个媒体帐户。那个媒体账号只转发自己媒体的链接，从不转发其他账号的推文。因此，如果我们的目标是绘制围绕TeamAlgoritma自我网络传播的潜在信息，出于这个原因，我们需要排除它们。</p><p id="12c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过长时间的检查，我提出了几个过滤活跃账户的标准:` Followers_count` &gt; 100和&lt; 6000, `following_count` &gt; 75，` favourites_count` &gt; 10，并在至少2个月前创建一条`新推文'。我还想排除受保护的帐户，因为我们实际上对此无能为力，我们无法聚集他们的追随者和追随者。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="46ef" class="jt ju hi lj b fi ln lo l lp lq">active_fol &lt;- detail_folower %&gt;% select(user_id,screen_name,created_at,followers_count,friends_count,favourites_count) %&gt;%<br/>  mutate(created_at = ymd_hms(created_at),<br/>         followers_count = as.numeric(followers_count),<br/>         friends_count = as.numeric(friends_count),<br/>         favourites_count = as.numeric(favourites_count)) %&gt;%<br/>  filter((followers_count &gt; 100 &amp; followers_count &lt; 6000), friends_count &gt; 75, favourites_count &gt; 10, <br/>         created_at &gt; "2020-03-15") %&gt;%<br/>  arrange(-followers_count)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mn"><img src="../Images/e88f610ed85906e6318a7217ff85dcea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9VFdy6QSLo6EwK1OqR44Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">TeamAlgoritma活跃追随者</figcaption></figure><h2 id="d942" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">聚集团队葛里玛追随者的追随者</h2><p id="ad28" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在我们有161个用户被认为是活跃用户。接下来，我们将集合他们所有的追随者。但是由于Twitter API有一个非常严格的限制，我也没有太多的时间，所以我们想最小化我们想要检索的总用户数(` n '参数)。我构建了一个简单的函数，如果追随者超过1500，则检索一半的追随者，如果追随者少于1500，则检索75%的追随者。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="a7c1" class="jt ju hi lj b fi ln lo l lp lq">flt_n &lt;- function(x){<br/>  if(x &gt; 1500){<br/>    x*0.5<br/>  }else{x*0.75}<br/>}</span></pre><p id="82da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还希望在收集追随者时避免SSL/TLS错误。有时，当您达到速率限制时，循环往往会崩溃并停止运行。为了避免这种情况，我命令循环每收集5个帐户就休眠一次(这并不总能解决问题，但会好得多)</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="a17c" class="jt ju hi lj b fi ln lo l lp lq"># Create empty list and name it after their screen name<br/>foler &lt;- vector(mode = 'list', length = length(active_fol$screen_name))<br/>names(foler) &lt;- active_fol$screen_name</span><span id="335f" class="jt ju hi lj b fi lr lo l lp lq"># <br/>for (i in seq_along(active_fol$screen_name)) {<br/>  message("Getting followers for user #", i, "/130")<br/>  foler[[i]] &lt;- get_followers(active_fol$screen_name[i], <br/>                                  n = round(flt_n(active_fol$followers_count[i])), <br/>                                retryonratelimit = TRUE)<br/>  <br/>  if(i %% 5 == 0){<br/>    message("sleep for 5 minutes")<br/>    Sys.sleep(5*60)<br/>    } <br/>}</span></pre><p id="8227" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">收集后，将列表绑定到数据帧，通过左连接将用户名从active_fol数据转换为user_id，构建干净的无NA数据帧</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="c15b" class="jt ju hi lj b fi ln lo l lp lq"># convert list to dataframe<br/>folerx &lt;- bind_rows(foler, .id = "screen_name")<br/>active_fol_x &lt;- active_fol %&gt;% select(user_id,screen_name)</span><span id="bb9a" class="jt ju hi lj b fi lr lo l lp lq"># left join to convert screen_name into its user id<br/>foler_join &lt;- left_join(folerx, active_fol_x, by="screen_name")</span><span id="f9b7" class="jt ju hi lj b fi lr lo l lp lq"># subset to new dataframe with new column name and delete NA<br/>algo_follower &lt;- foler_join %&gt;% select(user_id.x,user_id.y) %&gt;%<br/>  setNames(c("follower","active_user")) %&gt;% <br/>  na.omit()</span></pre><p id="79b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">聚集TeamAlgoritma追随者的关注</strong></p><p id="d941" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和以前一样，我们构建一个循环函数来收集以下内容。在“rtweet”包中，以下也称为“朋友”。在我的例子中，朋友数远远高于关注者数。因此，我们需要指定我们想要检索多少用户(` n '参数)。我们想最小化它，我改变' flt_n '函数，只收集40%,如果他们有超过2k的后续，和65%,如果少于2k。然后，我也改变循环函数。我们将数据存储到dataframe，而不是list。` get_friends()`函数给出2列作为它们的输出；好友列表和查询。我们可以很容易地把他们绑起来。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="970f" class="jt ju hi lj b fi ln lo l lp lq">flt_n_2 &lt;- function(x){<br/>  if(x &gt; 2000){<br/>    x*0.4<br/>  }else{x*0.65}<br/>}<br/>friend &lt;- data.frame()</span><span id="6194" class="jt ju hi lj b fi lr lo l lp lq">for (i in seq_along(active_fol$screen_name)) {<br/>  message("Getting followers for user #", i, "/161")<br/>  kk &lt;- get_friends(active_fol$screen_name[i],<br/>                        n = round(flt_n_2(active_fol$friends_count[i])),<br/>                        retryonratelimit = TRUE)<br/>  <br/>  friend &lt;- rbind(friend,kk)<br/>  <br/>  if(i %% 5 == 0){<br/>    message("sleep for 5 minutes")<br/>    Sys.sleep(5*60)<br/>    } <br/>}</span></pre><p id="18b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们使用left join检索活动帐户user-id</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="8fc2" class="jt ju hi lj b fi ln lo l lp lq">all_friend &lt;- friend %&gt;% setNames(c("screen_name","user_id"))<br/>all_friendx &lt;- left_join(all_friend, active_fol_x, by="screen_name")</span><span id="c590" class="jt ju hi lj b fi lr lo l lp lq">algo_friend &lt;- all_friendx %&gt;% select(user_id.x,user_id.y) %&gt;%<br/>  setNames(c("following","active_user"))</span></pre><h2 id="753c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">创建交互数据框架</h2><p id="1951" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在我们有了关注者和追随者的数据。我们需要建立“相互”数据，以确保网络是一个强大的双向连接网络。相互是我对相互追随的人的称呼。我们可以通过以下方式找到:按每个唯一的活跃用户拆分algo_friend数据，然后我们在下一列中找到同时出现在algo_follower$follower中的每个帐户。两列中的存在表明用户正在相互关注。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="f7ed" class="jt ju hi lj b fi ln lo l lp lq"># collect unique user_id in algo_friend df<br/>un_active &lt;- unique(algo_friend_df$active_user) %&gt;% data.frame(stringsAsFactors = F) %&gt;%<br/>  setNames("active_user")</span><span id="36b7" class="jt ju hi lj b fi lr lo l lp lq"># create empty dataframe<br/>algo_mutual &lt;- data.frame()</span><span id="bbec" class="jt ju hi lj b fi lr lo l lp lq"># loop function to filter the df by selected unique user, then find user that presence in both algo_friend$following and algo_follower$follower column set column name, and store it to algo_mutual df</span><span id="7520" class="jt ju hi lj b fi lr lo l lp lq">for (i in seq_along(un_active$active_user)){<br/>  aa &lt;- algo_friend_df %&gt;% filter(active_user == un_active$active_user[i])<br/>  bb &lt;- aa %&gt;% filter(aa$following %in% algo_follower_df$follower) %&gt;%<br/>    setNames(c("mutual","active_user"))<br/>  <br/>  algo_mutual &lt;- rbind(algo_mutual,bb)<br/>}</span></pre><p id="10aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它还没有完成。这是一个TeamAlgoritma帐户的ego网络，我们希望该帐户出现在我们的屏幕上。由于TeamAlgoritma很少跟踪它的追随者，所以如果我们在相互数据报中找不到它也就不足为奇了。所以我们需要手动添加它们。我们已经有了包含活跃用户独特价值的非活跃数据框架。我们可以简单地添加额外包含“TeamAlgoritma”的列，然后用algo_mutual df绑定它们。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="f650" class="jt ju hi lj b fi ln lo l lp lq">un_active &lt;- un_active %&gt;% mutate(mutual = rep("TeamAlgoritma"))<br/># swap column oreder<br/>un_active &lt;- un_active[,c(2,1)]</span><span id="c387" class="jt ju hi lj b fi lr lo l lp lq"># rbind to algo_mutual df<br/>algo_mutual &lt;- rbind(algo_mutual,un_active)</span><span id="0038" class="jt ju hi lj b fi lr lo l lp lq">algo_mutual</span></pre><p id="c356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">唷，我们完成了数据收集步骤！接下来，我们将进入SNA流程</p><h2 id="c509" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">构建节点、边和图形数据框架</h2><p id="26ef" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">网络由节点和边组成。节点(也称为顶点)表示网络中每个唯一的对象，边是节点(对象)之间的关系。我们将从algo_mutual df中的每个唯一帐户构建节点数据框架。和包含帐户对的边数据帧，我们可以使用algo_mutual df。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="dcd9" class="jt ju hi lj b fi ln lo l lp lq"># create nodes data<br/>nodes &lt;- data.frame(V = unique(c(algo_mutual$mutual,algo_mutual$active_user)),<br/>                    stringsAsFactors = F)</span><span id="a33e" class="jt ju hi lj b fi lr lo l lp lq"># create edges data<br/>edges &lt;- algo_mutual %&gt;% setNames(c("from","to"))</span><span id="2c8f" class="jt ju hi lj b fi lr lo l lp lq"># after that, we can simply create graph dataframe using `graph_from_data_frame` function from `igraph` package.</span><span id="10f6" class="jt ju hi lj b fi lr lo l lp lq">network_ego1 &lt;- graph_from_data_frame(d = edges, vertices = nodes, directed = F) %&gt;%<br/>  as_tbl_graph()</span></pre><h2 id="4c39" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">构建社区并计算指标</h2><p id="165d" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我需要提醒你，我们将使用“tidygraph”风格进行分析。有许多不同的代码风格来建立一个网络，但我发现“tidygraph”包是最简单的。“tidygraph”只是“igraph”包的包装。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="8b09" class="jt ju hi lj b fi ln lo l lp lq">set.seed(123)<br/>network_ego1 &lt;- network_ego1 %&gt;% <br/>  mutate(community = as.factor(group_walktrap())) %&gt;%<br/>  mutate(degree_c = centrality_degree()) %&gt;%<br/>  mutate(betweenness_c = centrality_betweenness(directed = F,normalized = T)) %&gt;%<br/>  mutate(closeness_c = centrality_closeness(normalized = T)) %&gt;%<br/>  mutate(eigen = centrality_eigen(directed = F))</span><span id="8ad5" class="jt ju hi lj b fi lr lo l lp lq">network_ego1</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mo"><img src="../Images/21bc6300ba540c70e2098a7f0ca4c565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5H6DZfRNN0zui-coO1QWQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">网络数据，包括节点、边、社区(集群)和中心性</figcaption></figure><p id="3b5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以很容易地使用' as.data.frame()'函数将其转换为dataframe。我们需要这样来确定谁是团队自我网络中的“关键人物”</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="cb9b" class="jt ju hi lj b fi ln lo l lp lq">network_ego_df &lt;- as.data.frame(network_ego1 %&gt;% activate(nodes))<br/>network_ego_df</span></pre><h2 id="336b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">识别网络中的重要用户</h2><p id="c64f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在这一点上，我希望你理解图的概念，节点和边，中心性，社区和模块化，以及如何使用它。我们将回到我们的Twitter网络。我们已经将table_graph转换为数据框。我们需要做的最后一件事是在每个中心找到最重要的客户，并找出关键人物。</p><p id="a3ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关键玩家是基于不同语境对网络中最有影响力的用户的称呼。在这种情况下,“不同的上下文”是不同的中心性度量。每个中心性有不同的用法和解释，出现在最中心性顶部的用户将被认为是整个网络的关键参与者。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="b8f4" class="jt ju hi lj b fi ln lo l lp lq"># take 6 highest user by its centrality<br/>kp_ego &lt;- data.frame(<br/>  network_ego_df %&gt;% arrange(-degree_c) %&gt;% select(name) %&gt;% slice(1:6),<br/>  network_ego_df %&gt;% arrange(-betweenness_c) %&gt;% select(name) %&gt;% slice(1:6),<br/>  network_ego_df %&gt;% arrange(-closeness_c) %&gt;% select(name) %&gt;% slice(1:6),<br/>  network_ego_df %&gt;% arrange(-eigen) %&gt;% select(name) %&gt;% slice(1:6)<br/>) %&gt;% setNames(c("degree","betweenness","closeness","eigen"))</span><span id="e46f" class="jt ju hi lj b fi lr lo l lp lq">kp_ego</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mp"><img src="../Images/8066fabab0d405ea692f9e2bad6c7bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwxWYGtKlNsAW_O4TZQ3CQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">基于其中心性的前6名用户</figcaption></figure><p id="ffd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上表中可以看出，账户“1049333510505xxxxxx”出现在最集中的位置。那个账号在网络中拥有最多的度(高度)但也是被重要人物包围的(高特征向量)。TeamAlgoritma是一个例外，这是我们的自我疑问，因此让它成为自己自我网络中的关键角色是不明智的。我们可以得出结论，用户“1049333510505xxxxxx”是TeamAlgoritma Twitter ego网络的关键玩家。让我们看看他/她是谁</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="ea6a" class="jt ju hi lj b fi ln lo l lp lq">key_player_ego &lt;- lookup_users("1049333510505xxxxxx")</span></pre><blockquote class="mq mr ms"><p id="a38a" class="if ig ls ih b ii ij ik il im in io ip mt ir is it mu iv iw ix mv iz ja jb jc hb bi translated">试想一个个人账号，关注度高，活跃度高。我不能给你看她的账户，因为我没有她的任何许可。</p></blockquote><h2 id="f823" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">可视化网络</h2><p id="156f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">让我们试着把网络形象化。我将按度中心性来缩放节点，并按社区来着色。由于我们的网络太大(大约14k个节点和15k条边)，我将只显示社区1-3。请不要被这些准则吓倒。如果你知道ggplot2的概念，这其实很简单。</p><pre class="je jf jg jh fd li lj lk ll aw lm bi"><span id="8c63" class="jt ju hi lj b fi ln lo l lp lq">plot_ego &lt;- network_ego1 %&gt;%<br/>  filter(community %in% 1:3) %&gt;%<br/>  top_n(1000,degree_c) %&gt;%<br/>  mutate(node_size = ifelse(degree_c &gt;= 20,degree_c,0)) %&gt;%<br/>  mutate(node_label = ifelse(betweenness_c &gt;= 0.06,name,"")) %&gt;%<br/>  ggraph(layout = "stress") +<br/>  geom_edge_fan(alpha = 0.05) +<br/>  geom_node_point(aes(color = as.factor(community),size = node_size)) +<br/>  geom_node_label(aes(label = node_label),repel = T,<br/>                 show.legend = F, fontface = "bold", label.size = 0,<br/>                 segment.colour="slateblue", fill = "#ffffff66") +<br/>  coord_fixed() +<br/>  theme_graph() + theme(legend.position = "none") +<br/>  labs(title = "TeamAlgoritma Mutual Communities",<br/>       subtitle = "Top 3 Community")</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mw"><img src="../Images/982ae9e54329c46dd901a6c842cdce38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLbl70vi8AJjWxptC2mHlQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">前三名社区的团队算法自我网络</figcaption></figure><p id="e05d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们能从这种视觉化中得到什么？</p><p id="c0f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这显然不能说明很多问题(我们需要进一步检查数据，将其与可视化进行匹配)，但它表明“随机漫步”社区检测算法正在采用与“压力”布局算法相同的结构。我们的自我出现在中间，充当连接所有集群的桥梁。我们只显示具有高介数中心值的用户标签。他们身后的蘑菇状节点是他们共同的朋友，他们不关注TeamAlgoritma帐户。如果该用户的“桥梁”转发或提及关于TeamAlgoritma帐户的内容，那么他就是我们的潜在读者。在现实生活中，同一个社区的用户或彼此关系密切的用户可能彼此认识。他们创建自己的社区。关键玩家在社区#1(红色)，这是TeamAlgoritma最重要的社区，因为他们最有潜力快速广泛地传播信息。</p></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><p id="de8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是第一部分的结尾。我将在接下来的部分解释Twitter上的活动网络。敬请期待！</p><h2 id="9732" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">谢谢大家！</h2><p id="5519" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">想讨论请留言评论。我也接受所有的批评，这样我就能不断学习。</p><h2 id="d3c2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">参考</h2><ul class=""><li id="267d" class="kt ku hi ih b ii ko im kp iq ne iu nf iy ng jc ky kz la lb bi translated"><a class="ae lh" href="https://github.com/western11/Social-Network-Analysis-Twitter-Network" rel="noopener ugc nofollow" target="_blank">该项目的Github库</a></li><li id="5125" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae lh" href="https://rtweet.info/" rel="noopener ugc nofollow" target="_blank"> Rtweet主页</a></li><li id="0f0e" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae lh" href="https://www.data-imaginist.com/2017/introducing-tidygraph/" rel="noopener ugc nofollow" target="_blank">潮汐表简介</a></li><li id="d4f1" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae lh" href="https://perrystephenson.me/2018/09/29/the-r-twitter-network/" rel="noopener ugc nofollow" target="_blank">潮流简介2 </a></li><li id="af15" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae lh" href="https://www.jessesadler.com/post/network-analysis-with-r/" rel="noopener ugc nofollow" target="_blank">SNA的各种R包</a></li><li id="f1f0" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae lh" href="https://igraph.org/r/doc/" rel="noopener ugc nofollow" target="_blank"> igraph手册页</a></li><li id="f637" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><a class="ae lh" href="https://www.r-graph-gallery.com/network.html" rel="noopener ugc nofollow" target="_blank">R-图形库</a></li></ul></div></div>    
</body>
</html>