<html>
<head>
<title>Building your First Neural Network on a Structured Dataset (using Keras)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在结构化数据集上构建第一个神经网络(使用Keras)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/build-your-first-neural-network-model-on-a-structured-dataset-using-keras-d9e7de5c6724?source=collection_archive---------0-----------------------#2018-08-20">https://medium.com/analytics-vidhya/build-your-first-neural-network-model-on-a-structured-dataset-using-keras-d9e7de5c6724?source=collection_archive---------0-----------------------#2018-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="5536" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">简介</strong></h1><p id="0f19" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你曾经在结构化数据集上应用过<a class="ae kb" href="https://courses.analyticsvidhya.com/courses/computer-vision-using-deep-learning-version2?utm_source=medium&amp;utm_medium=FirstNeuralNetworkOnStructuredData" rel="noopener ugc nofollow" target="_blank">神经网络</a>模型吗？如果答案是否定的，以下哪些原因适用于您？</p><ol class=""><li id="d343" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">应用起来非常复杂</li><li id="4083" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">神经网络适用于图像、音频和文本等非结构化数据集，但不适用于结构化数据集</li><li id="f724" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">这不像使用scikit-learn/caret构建模型那么简单</li><li id="1d33" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">训练时间太长</li><li id="b527" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">需要高计算能力</li></ol><p id="ff2b" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">在本文中，我将重点介绍前三个原因，并展示如何使用流行的高级库“keras”轻松地将神经网络模型应用于结构化数据集。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/7f4cfd5aa0a9f1d67af860bf0ccc704a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vADxWb9yIYAbfcAQ_oKfiQ.png"/></div></div></figure><h1 id="721b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">理解问题陈述</strong></h1><p id="6bbc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本文中，我们将处理<a class="ae kb" href="https://datahack.analyticsvidhya.com/contest/black-friday/" rel="noopener ugc nofollow" target="_blank">黑色星期五</a>数据集。这是一个回归挑战，我们需要预测客户对各种产品的购买量。我们已经获得了有关客户人口统计(年龄、性别、婚姻状况、城市类型、当前居住城市)和产品详细信息(产品id和产品类别)的各种信息。下面是数据字典:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lh"><img src="../Images/53e02c7d5eadcaacc7f21c0d50a8612d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BU7i3ny6jS44M4MIC7REbQ.png"/></div></div></figure><p id="249d" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">这项挑战的评估标准是均方根误差(RMSE)。</p><h1 id="506a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">先决条件</strong></h1><p id="300a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本文中，我将使用scikit-learn的随机森林(RF)模型和keras的基本神经网络(NN)模型来解决这个黑色星期五挑战。本文的想法是展示我们可以多么容易地在结构化数据集上构建NN模型(它类似于使用scikit-learn库构建RF模型)。本文假设您具有构建机器学习模型、scikit-learn和神经网络基础知识的良好背景。如果您对这些概念不太熟悉，我建议您先阅读下面的文章:</p><ol class=""><li id="8557" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated"><a class="ae kb" href="https://www.analyticsvidhya.com/blog/2016/03/introduction-deep-learning-fundamentals-neural-networks/" rel="noopener ugc nofollow" target="_blank">简介-深度学习-基础-神经网络</a></li><li id="ecf0" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated"><a class="ae kb" rel="noopener" href="/analytics-vidhya/understanding-and-coding-neural-networks-from-scratch-in-python-and-r-b8c760f0ad1c">用python从零开始理解和编码神经网络</a></li><li id="66cf" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated"><a class="ae kb" href="https://www.analyticsvidhya.com/blog/2017/09/common-machine-learning-algorithms/" rel="noopener ugc nofollow" target="_blank">常见的机器学习算法</a></li></ol><h1 id="ba73" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">利用机器(深度)学习解决问题的方法</strong></h1><p id="f168" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我将把我的方法大致分为四个部分:</p><ol class=""><li id="d7fc" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">数据准备</li><li id="3b61" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">模型构建(随机森林和神经网络)</li><li id="3381" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">估价</li><li id="4618" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">预言；预测；预告</li></ol><h2 id="6d21" class="li ig hi bd ih lj lk ll il lm ln lo ip jo lp lq it js lr ls ix jw lt lu jb lv bi translated"><strong class="ak">数据准备</strong></h2><p id="eebd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这一节中，我将重点介绍基本的数据准备步骤，如加载数据集、输入缺失值、处理分类变量、规范化数据和创建验证集。对于随机森林和我们的神经网络模型，我将遵循相同的步骤。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lw"><img src="../Images/daeef435a213161f6da9a306ab523c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXfdWyIAF-nymLFnQEkHNA.png"/></div></div></figure><ul class=""><li id="cfa6" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lx kk kl km bi translated"><strong class="jf hj">加载数据:</strong>在这里，我将导入必要的库来加载数据集，将训练和测试结合在一起执行预处理，并为其创建一个标志。</li></ul><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="4a8c" class="li ig hi lz b fi md me l mf mg">#Importing Libraries for data preparation<br/>import pandas as pd<br/>import numpy as np</span><span id="66e4" class="li ig hi lz b fi mh me l mf mg">#Read Necessary files<br/>train = pd.read_csv("train_black_friday.csv")<br/>test = pd.read_csv("test_black_friday.csv")</span><span id="39e8" class="li ig hi lz b fi mh me l mf mg">#Combined both Train and Test Data set to do preprocessing together # and set flag for both as well<br/>train['Type'] = 'Train' <br/>test['Type'] = 'Test'<br/>fullData = pd.concat([train,test],axis=0)</span></pre><ul class=""><li id="eb6d" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lx kk kl km bi translated"><strong class="jf hj">估算缺失值:</strong>处理分类变量和连续变量缺失值的方法会有所不同。<br/>因此，我们的第一步是识别ID列、目标变量、分类变量和连续自变量。<br/>发布此消息后，我们将为缺失值创建虚拟标志。为什么要这么做？因为有时缺失值本身可以携带大量信息。最后，我们将使用该列的平均值估算连续变量的缺失值，对于分类变量，我们将创建一个新的级别。</li></ul><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="6b12" class="li ig hi lz b fi md me l mf mg">#Identifying ID, Categorical<br/>ID_col = ['User_ID','Product_ID']<br/>flag_col= ['Type']<br/>target_col = ["Purchase"]<br/>cat_cols= ['Gender','Age','City_Category','Stay_In_Current_City_Years']<br/>num_cols= list(set(list(fullData.columns))-set(cat_cols)-set(ID_col)-set(target_col)-set(flag_col))</span><span id="0d89" class="li ig hi lz b fi mh me l mf mg"># Combined numerical and Categorical variables<br/>num_cat_cols = num_cols+cat_cols</span><span id="47fc" class="li ig hi lz b fi mh me l mf mg">#Create a new variable for each variable having missing value with VariableName_NA <br/># and flag missing value with 1 and other with 0</span><span id="2d41" class="li ig hi lz b fi mh me l mf mg">for var in num_cat_cols:<br/>    if fullData[var].isnull().any()==True:<br/>        fullData[var+'_NA']=fullData[var].isnull()*1</span><span id="7182" class="li ig hi lz b fi mh me l mf mg">#Impute numerical missing values with mean<br/>fullData[num_cols] = fullData[num_cols].fillna(fullData[num_cols].mean())</span><span id="ca0a" class="li ig hi lz b fi mh me l mf mg">#Impute categorical missing values with -9999<br/>fullData[cat_cols] = fullData[cat_cols].fillna(value = -9999)</span></pre><ul class=""><li id="8ec7" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lx kk kl km bi translated"><strong class="jf hj">处理分类值:</strong>我们将为分类变量创建一个标签编码器。</li></ul><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="9b84" class="li ig hi lz b fi md me l mf mg">#create label encoders for categorical features<br/>from sklearn.preprocessing import LabelEncoder</span><span id="1480" class="li ig hi lz b fi mh me l mf mg">for var in cat_cols:<br/>    number = LabelEncoder()<br/>    fullData[var] = number.fit_transform(fullData[var].astype('str'))</span></pre><ul class=""><li id="4bc8" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lx kk kl km bi translated"><strong class="jf hj">归一化数据:</strong>在0和1之间缩放(归一化)自变量。这将有助于我们相对更快地收敛。</li></ul><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="276b" class="li ig hi lz b fi md me l mf mg">features = list(set(list(fullData.columns))-set(ID_col)-set(target_col))<br/>fullData[features] = fullData[features]/fullData[features].max()</span></pre><ul class=""><li id="323b" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lx kk kl km bi translated"><strong class="jf hj">创建一个验证集:</strong>这里，我们将从完整的数据集中分离出训练测试，并从特性列表中删除训练测试标志。在构建我们的模型时，我们只有训练数据集的目标值，因此我们将从这个训练数据集创建一个验证集来评估模型的性能。这里，我使用<em class="mi"> train_test_split </em>以70:30的比例划分训练和验证中的训练数据集。</li></ul><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="af87" class="li ig hi lz b fi md me l mf mg">#Creata a validation set<br/>from sklearn.model_selection import train_test_split</span><span id="1022" class="li ig hi lz b fi mh me l mf mg">train=fullData[fullData['Type']==1]<br/>test=fullData[fullData['Type']==0]<br/>features=list(set(list(fullData.columns))-set(ID_col)-set(target_col)-set(flag_col))</span><span id="6a7f" class="li ig hi lz b fi mh me l mf mg">X = train[features].values<br/>y = train[target_col].values</span><span id="db4b" class="li ig hi lz b fi mh me l mf mg">X_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.30, random_state=42)</span></pre><h2 id="5075" class="li ig hi bd ih lj lk ll il lm ln lo ip jo lp lq it js lr ls ix jw lt lu jb lv bi translated"><strong class="ak">使用随机森林建立模型</strong></h2><p id="1078" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这一部分相当简单，我以前也多次写过。如果你还想回顾随机森林算法及其参数，我会推荐你浏览这篇文章:<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2016/04/complete-tutorial-tree-based-modeling-scratch-in-python/" rel="noopener ugc nofollow" target="_blank">基于树的算法教程</a>。</p><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="3f65" class="li ig hi lz b fi md me l mf mg">#import necessary libraries to build model</span><span id="9cd2" class="li ig hi lz b fi mh me l mf mg">import random<br/>from sklearn.ensemble import RandomForestRegressor</span><span id="063c" class="li ig hi lz b fi mh me l mf mg">random.seed(42)<br/>rf = RandomForestRegressor(n_estimators=10)<br/>rf.fit(X_train, y_train)</span></pre><h2 id="a695" class="li ig hi bd ih lj lk ll il lm ln lo ip jo lp lq it js lr ls ix jw lt lu jb lv bi translated">使用深度学习模型(Keras)建立模型</h2><p id="d055" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这里，我将重点介绍构建基本深度学习模型的步骤。这将有助于初学者将来创建自己的模型。做到这一点的步骤是:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mj"><img src="../Images/19556ad930901ccb6add11453242e7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uaE9vcY1M2-RTCpurKr9lg.png"/></div></div></figure><ul class=""><li id="b82b" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lx kk kl km bi translated"><strong class="jf hj">定义模型:</strong>为了建立深度学习模型，我们需要定义层(输入、隐藏和输出)。这里，我们将继续使用顺序模型，这意味着我们将按顺序定义层。此外，我们将继续建设一个完全连接的网络。<br/> <strong class="jf hj"> 1。</strong>首先，我们将关注定义输入层的<strong class="jf hj"/>。这可以在用<em class="mi">输入尺寸</em>参数创建第一层时指定，并将其设置为11个独立变量的11。<br/> <strong class="jf hj"> 2。</strong>接下来，<strong class="jf hj">定义隐藏层的数量</strong>以及神经元和激活函数的数量。通过多次迭代可以获得正确的数字。数字越大，模型越复杂。首先，我简单地使用了两个隐藏层。一个有100个神经元，另一个有50个，具有相同的激活功能——“relu”。<br/> <strong class="jf hj"> 3。</strong>最后我们需要<strong class="jf hj">用1个神经元定义输出层</strong>来预测购买量。手头的问题是回归挑战，因此我们可以在输出层进行线性转换。所以不需要提什么激活函数(默认是线性的)。</li></ul><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="d541" class="li ig hi lz b fi md me l mf mg"># Define model<br/>model = Sequential()<br/>model.add(Dense(100, input_dim=11, activation= "relu"))<br/>model.add(Dense(50, activation= "relu"))<br/>model.add(Dense(1))<br/>model.summary() #Print model Summary</span></pre><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mk"><img src="../Images/db41090ca40577c53a6a837fe05a6a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9-Hmn55Zy3XRVC8dv5SFw.png"/></div></div></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ml"><img src="../Images/82900aa186e438e9dab74e33a5f2ee9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSec3nWjTkspxFwoZL0vgg.png"/></div></div></figure><ul class=""><li id="f777" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lx kk kl km bi translated"><strong class="jf hj">编译模型:</strong>在这个阶段，我们将配置模型进行训练。我们将设置优化器来改变权重和偏差，以及损失函数和度量来评估模型的性能。这里，我们将使用“adam”作为优化器，“均方差”作为损失度量。根据我们正在解决的问题的类型，我们可以改变我们的损失和指标。对于二元分类，我们使用“二元交叉熵”作为损失函数。</li></ul><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="0183" class="li ig hi lz b fi md me l mf mg"># Compile model<br/>model.compile(loss= "mean_squared_error" , optimizer="adam", metrics=["mean_squared_error"])</span></pre><ul class=""><li id="67b6" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lx kk kl km bi translated"><strong class="jf hj">拟合模型:</strong>现在，模型构建的最后一步是在训练数据集(实际上是整个数据集的70%)上拟合模型。我们需要提供自变量和因变量以及训练迭代的次数，即时期。这里，我们取了10个纪元。</li></ul><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="a726" class="li ig hi lz b fi md me l mf mg"># Fit Model<br/>model.fit(X_train, y_train, epochs=10)</span></pre><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mm"><img src="../Images/ac9231f5c87485ae7ab3de94d443143a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KWf4OM-auu3yIiQZCVeHfA.png"/></div></div></figure><h2 id="43cc" class="li ig hi bd ih lj lk ll il lm ln lo ip jo lp lq it js lr ls ix jw lt lu jb lv bi translated"><strong class="ak">评估</strong></h2><p id="18ee" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们已经使用随机森林和神经网络技术构建了模型，下一步是评估这两个模型在验证数据集上的性能。</p><ul class=""><li id="8a62" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lx kk kl km bi translated"><strong class="jf hj">随机森林模型评估:</strong>我们将获得验证数据集的预测，并使用实际目标值(y_valid)进行评估。我们得到均方根误差约为3106。</li></ul><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="034f" class="li ig hi lz b fi md me l mf mg">from sklearn.metrics import mean_squared_error<br/>pred=rf.predict(X_valid)<br/>score = np.sqrt(mean_squared_error(y_valid,pred))<br/>print (score)<br/>3106.5008973291074</span><span id="4f6c" class="li ig hi lz b fi mh me l mf mg"># Evaluation while fitting the model<br/>model.fit(X_train, y_train, epochs=10, validation_data=(X_valid, y_valid))</span></pre><ul class=""><li id="80ca" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lx kk kl km bi translated"><strong class="jf hj">神经网络模型评估:</strong>同样，我们将使用神经网络模型获得验证数据集的预测，并计算均方根误差。RMSE用一个基本的神经网络模型出来是~4214。这是一个相当基本的模型，你可以继续调整超参数，以建立一个更复杂的网络。<em class="mi">在拟合神经网络模型时，您可以将验证数据作为参数传递，也可以在每个时期后查看验证分数。</em></li></ul><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="d006" class="li ig hi lz b fi md me l mf mg">pred= model.predict(X_valid)<br/>score = np.sqrt(mean_squared_error(y_valid,pred))<br/>print (score)<br/>4213.954523194906</span></pre><h2 id="ddf4" class="li ig hi bd ih lj lk ll il lm ln lo ip jo lp lq it js lr ls ix jw lt lu jb lv bi translated">预言；预测；预告</h2><p id="cab7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在评估模型并最终确定模型参数后，我们可以继续对测试数据进行预测。下面是使用随机森林和神经网络模型来实现这一点的代码。</p><pre class="kw kx ky kz fd ly lz ma mb aw mc bi"><span id="2f86" class="li ig hi lz b fi md me l mf mg">#Select the independent variables for test dataset<br/>X_test = test[features].values</span><span id="8915" class="li ig hi lz b fi mh me l mf mg">#Prediction using Random Forest <br/>y_test_rf = rf.predict(X_test)</span><span id="d549" class="li ig hi lz b fi mh me l mf mg">#Prediction using Neural Network<br/>y_test_nn = model.predict(X_test)</span></pre><h1 id="1f98" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">接下来是什么</strong></h1><p id="3955" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">本文的目的是展示在结构化数据集上构建神经网络模型是多么容易，因此我们没有关注改善模型预测的其他方面。下面是我的想法列表，你可以应用它们来构建神经网络:</p><ul class=""><li id="6074" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lx kk kl km bi translated">查看变量与变量的关系后，估算缺失值</li><li id="b809" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lx kk kl km bi translated">特征工程(产品id可能包含一些关于购买金额的信息)</li><li id="9fe0" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lx kk kl km bi translated">选择正确的超参数</li><li id="49f3" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lx kk kl km bi translated">通过添加更多隐藏层来构建更复杂的网络</li><li id="552c" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lx kk kl km bi translated">使用正则化</li><li id="a9a5" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lx kk kl km bi translated">训练更多次数的纪元</li><li id="a8dc" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lx kk kl km bi translated">用神经网络模型对两种RF进行集成</li></ul><p id="15f9" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><strong class="jf hj">总结</strong></p><p id="edd7" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">在本文中，我们讨论了模型构建的不同阶段，如数据准备、模型构建、评估和最终预测。我们还研究了如何使用keras在结构化数据集上应用神经网络模型。</p><p id="7133" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我们进一步了解了keras中模型构建的不同步骤，如定义、编译和拟合模型。一个简单的神经网络模型的性能令人印象深刻，我们可以在将它变成一个更复杂的网络后对其进行改进。在下一篇文章中，我们将看看如何在时间序列挑战中应用RNN模型。</p><p id="4f56" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">如果你有任何问题或建议，请在下面的评论区联系我。</p></div></div>    
</body>
</html>