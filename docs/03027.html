<html>
<head>
<title>Relational model vs Document model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关系模型与文档模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/relational-model-vs-document-model-a71cddd6782d?source=collection_archive---------4-----------------------#2020-01-13">https://medium.com/analytics-vidhya/relational-model-vs-document-model-a71cddd6782d?source=collection_archive---------4-----------------------#2020-01-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/486bd7e20108d438b35db97ced297552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYKwVI81AiZA78NJySgRYQ.png"/></div></div></figure><p id="171f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天最著名的数据模型可能是SQL，它基于Edgar Codd在1970年提出的关系模型。数据被组织成关系(表)，其中每个关系是元组(行)的无序集合。关系模型的目标是将实现细节隐藏在干净的接口后面。今天你在网上看到的很多东西仍然是由关系数据库驱动的(例如:微软SQL服务器、甲骨文数据库、MySQL和IBM DB2)</p><p id="c42f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于数据存储在关系表中，应用程序代码中的对象和数据库模型之间需要一个笨拙的转换层:对象-关系映射。模型(关系与对象)之间的这种脱节被称为阻抗不匹配。为了处理这个问题并减少所需的样板代码，有一些ORM框架，如ActiveRecord和Hibernate。</p><p id="0e9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2000年代中期，NoSQL(即:MongoDB、CouchDB、Cassandra DB和ElasticSearch)因以下需求而诞生:</p><ul class=""><li id="22c2" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">更高的可伸缩性，因为SQL数据库不是为水平伸缩而设计的。</li><li id="60bb" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">更灵活的模式。模式是记录和实施该结构的有用机制，但是如果集合中的项目由于某种原因不具有相同的结构，则读取模式(数据的结构是隐式的，仅在读取数据时解释)方法是有利的；可以在文档中添加任意的键和值。</li><li id="c5db" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">更具动态性和表现力的数据模型。对于像简历这样的数据结构，它通常是一个自包含的文档，JSON表示可能非常合适。</li><li id="97bc" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">比多表模式更好的局部性；所有相关信息都在一个地方，一次查询就足够了。文档通常存储为单个连续的字符串。数据库通常需要加载整个文档，即使您只访问其中的一小部分。整个文档通常都需要重写——只有不改变文档编码大小的修改才可以轻松地就地执行(将相关数据分组以实现局部性的想法并不局限于文档模型)</li></ul><p id="48f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然一对多树结构不需要联接，但是多对一和多对多关系并不适合文档模型:对联接的支持通常很弱，可能您必须通过对数据库进行多次查询来模拟应用程序代码中的联接，将“逻辑”从数据库转移到应用程序代码(在关系数据库中，查询优化器自动决定查询的哪些部分以何种顺序执行，以及使用哪些索引)。由于这个原因，对于高度互联的数据，文档模型是笨拙的。</p><p id="902f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">命令式语言告诉计算机按照一定的顺序执行一定的操作。另一方面，SQL是一种声明式查询语言，因此您只需指定所需数据的模式(而不是如何实现该目标)。声明式查询语言通常更简洁，并且隐藏了实现细节，这让您有更好的机会在并行执行中获得更快的速度。</p><p id="6fed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着时间的推移，关系数据库和文档数据库变得越来越相似。自2000年代中期以来，大多数关系数据库系统(MySQL除外)都支持XML。对JSON文档也有类似级别的支持。在文档数据库端，RethinkDB在其查询语言中支持类似关系的连接，一些MongoDB驱动程序自动解析数据库引用(有效地执行客户端连接)。</p></div></div>    
</body>
</html>