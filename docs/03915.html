<html>
<head>
<title>Image processing to detect curvature of road</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">检测道路曲率的图像处理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/image-processing-to-detect-curvature-of-road-f68014338778?source=collection_archive---------8-----------------------#2020-02-25">https://medium.com/analytics-vidhya/image-processing-to-detect-curvature-of-road-f68014338778?source=collection_archive---------8-----------------------#2020-02-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f2d9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">不使用神经网络的曲率检测</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/84490bd91c8119eb1d86b9e5a6aded39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JgSyUZnJhqdj5c6G"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由<a class="ae jn" href="https://unsplash.com/@raphaelphotoch?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Raphael Schaller </a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="c94e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi kk translated"><span class="l kl km kn bm ko kp kq kr ks di">我们</span>对自动驾驶汽车这个术语很熟悉。其中汽车使用包括“人工神经网络”的复杂管道，在没有人类帮助或干预的情况下，设法从一个地方导航到另一个地方。<em class="kt">然而，没有神经网络这可能吗？</em></p><p id="8eeb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在导航我们的路线时，我们可能会面临不同类型的场景，如弯曲的道路，汽车需要根据其神经网络做出的决定来控制转向和刹车。在这篇文章中，我们将会看到图像处理如何有助于实时确定汽车是应该直行还是转弯。</p><p id="1f64" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将使用python中的OpenCV库进行实时图像处理。</p><pre class="iy iz ja jb fd ku kv kw kx aw ky bi"><span id="be65" class="kz la hi kv b fi lb lc l ld le">import cv2<br/>import numpy as np</span></pre><p id="f2d4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从摄像机中获取视频帧。我正在使用录制的视频。</p><pre class="iy iz ja jb fd ku kv kw kx aw ky bi"><span id="b737" class="kz la hi kv b fi lb lc l ld le">cap=cv2.VideoCapture('curved_road.mp4')<br/>while cap.isOpened():<br/>    ret, frame = cap.read()<br/>    if ret == True:</span></pre><p id="61df" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我们将使用cv2.resize()调整图像的大小。最初，我开始测试不同大小的不同图像，这成了一个问题，为了解决它，我固定了图像的大小，并计算了帧的中心。此外，如果图像尺寸相对较小，计算速度会更快。</p><pre class="iy iz ja jb fd ku kv kw kx aw ky bi"><span id="0d97" class="kz la hi kv b fi lb lc l ld le">height = 500<br/>width = 700<br/>image = cv2.resize(img, (width, height))<br/>img = cv2.line(image, (round(width/2), 0), (round(width/2), height), (255, 255, 255), 2)<br/>cv2.imshow("center of image", img</span></pre><p id="72cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们使用中心线作为参考，直观地监控曲线。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lf"><img src="../Images/be25fdda34b6ca9069cedef8684d2acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LcFFMM8KfbjDiGtsGJ-3JQ.png"/></div></div></figure><p id="a51c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我们将使用一个在线应用程序来选择道路的颜色，该应用程序会为您提供图像中特定像素的RGB值。我用过<a class="ae jn" href="https://imagecolorpicker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">拾色器</strong> </a>。这种“形状遮罩”是一种从RGB图像中提取和分离颜色以进行进一步处理的方法。</p><pre class="iy iz ja jb fd ku kv kw kx aw ky bi"><span id="6fa4" class="kz la hi kv b fi lb lc l ld le">lower = np.array([85, 90, 88])<br/>upper = np.array([160, 177, 190])<br/>shapeMask = cv2.inRange(image, lower, upper)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lf"><img src="../Images/d4b1716c882e4fba440eac5c53c15eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7C28DTEp0p5HCq63NH_1Mw.png"/></div></div></figure><p id="f0da" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我们将图像分成3个部分(即中心、左侧和右侧)。为了确保图像只考虑道路，我们也可以排除顶部。</p><pre class="iy iz ja jb fd ku kv kw kx aw ky bi"><span id="7adc" class="kz la hi kv b fi lb lc l ld le">#----------------------<br/>#crop image from top DELTA = 25%<br/>#----------------------</span><span id="28cf" class="kz la hi kv b fi lg lc l ld le">top = round(height/4)<br/>x = 0<br/>h = height<br/>w = round(height/2)+30<br/>left = shapeMask[top:top + h, x:x + w]<br/>n_white_pix1 = np.sum(left == 255)<br/>w1 = round(n_white_pix1/2)</span><span id="098d" class="kz la hi kv b fi lg lc l ld le">b = round(width / 2) + 70<br/>d = round(height / 2) + 30<br/>right = shapeMask[top:top + h, b:b + d]<br/>n_white_pix2 = np.sum(right == 255)<br/>w2 = round(n_white_pix2/2)</span><span id="4554" class="kz la hi kv b fi lg lc l ld le">#----------------------<br/>#crop the center where delta = 10%<br/>#----------------------</span><span id="e124" class="kz la hi kv b fi lg lc l ld le">m = round(height / 2) + 30<br/>o = round(width / 5)<br/>center = shapeMask[top:top + h, m:m + o]<br/>n_white_pix3 = np.sum(center == 255)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lh"><img src="../Images/a051d9b41d2799e00ba2a3edafb28b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9IeossVnd7I9MGjacYH6A.png"/></div></div></figure><p id="2499" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">计算像素数的逻辑</strong>:中间的像素数总是较少，因为尺寸几乎是两边的一半。</p><pre class="iy iz ja jb fd ku kv kw kx aw ky bi"><span id="8e2f" class="kz la hi kv b fi lb lc l ld le">if n_white_pix3 &gt; w1 and n_white_pix3 &gt; w2:<br/>    img_1 = show_movment("keep straight")<br/>elif n_white_pix1 &gt; n_white_pix2:<br/>    img_1 = show_movment("turn left")<br/>else:<br/>    img_1 = show_movment("turn right")</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es li"><img src="../Images/63e3b85b7bfbfaf13902b4f115033af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*yeZSq4NcTaiJFXglpouXhQ.png"/></div></figure><p id="e86a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以在终端上打印命令。然而，很难对每一帧进行监控，因此我们可以将结果打印在图像本身上。</p><pre class="iy iz ja jb fd ku kv kw kx aw ky bi"><span id="9ea8" class="kz la hi kv b fi lb lc l ld le">def show_movment(text):<br/>    return cv2.putText(image,text,(10,450),cv2.FONT_HERSHEY_TRIPLEX,1, (0, 0, 0), 2)</span></pre><p id="1009" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看看结果——</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lj"><img src="../Images/fcda99754ac434e954309e3f0f0a0109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Fj--fNb3MPh25nVAK-UflA.gif"/></div></figure><p id="2c2b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是运行中的算法—</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk ll l"/></div></figure></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><blockquote class="lt lu lv"><p id="6ab4" class="jo jp kt jq b jr js ij jt ju jv im jw lw jy jz ka lx kc kd ke ly kg kh ki kj hb bi translated">我是一名电子工程师。我发现数据科学很迷人，这就是为什么我决定学习机器学习和大数据分析，最近开始作为人工智能工程师工作。希望能为这个不断成长的数据科学社会做点贡献。可以在<a class="ae jn" href="https://www.linkedin.com/in/anuja-ihare-a5b622b7" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> LinkedIn </strong> </a>上联系我。</p></blockquote></div></div>    
</body>
</html>