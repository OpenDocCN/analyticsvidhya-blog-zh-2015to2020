<html>
<head>
<title>First Dive In Deep Learning or Transfer Learning: Aerial Cactus Identification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习或迁移学习的第一次潜水:空中仙人掌识别</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/first-dive-in-deep-learning-or-transfer-learning-aerial-cactus-identification-e8a809a89dc8?source=collection_archive---------7-----------------------#2019-08-26">https://medium.com/analytics-vidhya/first-dive-in-deep-learning-or-transfer-learning-aerial-cactus-identification-e8a809a89dc8?source=collection_archive---------7-----------------------#2019-08-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="dd74" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">确定图像是否包含柱状仙人掌。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/738079f3a35b2dc0f1238b4f0dea7d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UypKYyvFgNTcOB5tGMlwKA.png"/></div></div></figure><p id="2497" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">表格数据已经够多了，现在是时候处理图像数据了。像往常一样，我在Kaggle上探索过去的一些比赛，但是等等，它们中的大多数主要与图像数据有关。这个怎么解决？答案很简单——我必须掌握深度学习的基础知识！</p><p id="5d4b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，我从Kaggle提供的课程开始，你可以在这里  <em class="kg">获得<a class="ae kf" href="https://www.kaggle.com/learn/deep-learning" rel="noopener ugc nofollow" target="_blank"> <em class="kg">。经过一番头脑风暴后，我准备好了我的第一个任务！但是它必须是简单和基本的，因为我还是一个新手，然后我遇到了这个数据集。</em></a></em></p><p id="c134" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">空中仙人掌识别数据集由17500幅图像组成，其中一个标签描述了图像中是否有仙人掌。那么我们还在等什么，让我们开始编码吧！</p><h1 id="1dc4" class="kh ki hi bd kj kk kl km kn ko kp kq kr io ks ip kt ir ku is kv iu kw iv kx ky bi translated">导入相关库</h1><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="d96d" class="le ki hi la b fi lf lg l lh li">import cv2<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import os<br/>from tqdm import tqdm, tqdm_notebook<br/>from keras.models import Sequential<br/>from keras.layers import Activation, Dropout, Flatten, Dense<br/>from keras.applications import VGG16<br/>from keras.optimizers import Adam</span></pre><p id="7476" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你现在不理解一些术语，不要担心，到本文结束时，我会确保每个主题都被涵盖。</p><h2 id="c5ec" class="le ki hi bd kj lj lk ll kn lm ln lo kr js lp lq kt jw lr ls kv ka lt lu kx lv bi translated">让我们加载数据</h2><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="b56c" class="le ki hi la b fi lf lg l lh li">train_df = pd.read_csv('../input/aerial-cactus-<br/>identification/train.csv')</span></pre><p id="a29d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好了，我们已经将数据加载到我们的数据帧中，让我们看看train_df的结构。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lw"><img src="../Images/01940220872e78e612a5a112cf89a9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*4npsAUYWEbay9O1mGzM_sA.png"/></div></figure><p id="27ff" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这不是我们所期望的，对吗？我们想看一些视觉效果。</p><p id="f4ef" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为什么没有他们，这里是代码:</p><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="6557" class="le ki hi la b fi lf lg l lh li">im = cv2.imread("../input/aerial-cactus-identification/train/train/01e30c0ba6e91343a12d2126fcafc0dd.jpg")<br/>plt.imshow(im)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lx"><img src="../Images/9160adc103e3c490a3269d14fac59945.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*ChLu6Y9lSC1jc6QR_sI3xQ.jpeg"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">我知道这是图像非常模糊，但不得不调整它的大小显示。</figcaption></figure><h1 id="8565" class="kh ki hi bd kj kk kl km kn ko kp kq kr io ks ip kt ir ku is kv iu kw iv kx ky bi translated">有趣的部分开始了！</h1><p id="18d3" class="pw-post-body-paragraph jj jk hi jl b jm mc ij jo jp md im jr js me ju jv jw mf jy jz ka mg kc kd ke hb bi translated">我们已经将数据加载到变量中，现在我们必须创建一个<strong class="jl hj"> CNN(卷积神经网络)</strong>，听起来很复杂，但相信这将是一件轻而易举的事情，一旦你得到它，就像我一样。</p><p id="ee4d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们把CNN这个词分成两部分:卷积和神经网络</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mh"><img src="../Images/83cbfe82e89ce9edab8269ea6747989b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/0*JHJu0d4DhyUunKiz.gif"/></div></figure><p id="fba5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">就是这样！只要看一下图像，你就会明白了。对于像我这样理解稍慢的人来说，这里有一个解释:我们正在做的是将整个5X5矩阵乘以一个3X3矩阵，并将其转换到另一个比上一层维度更低的层中，这样循环下去！这在大型矩阵中非常有用。</p><p id="04be" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在到了我们后面的部分，神经网络，这就是:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/24d8abf90e982a7c50a0f33c995b397d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uEFzh8Ds8yLazmKr.jpeg"/></div></div></figure><p id="6196" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太好了。这只不过是一次又一次地应用卷积，或者用更专业的术语来说，就像一个堆栈一样在其他层之上添加一层，并在不同的节点之间构建一个网络。</p><p id="6662" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">既然我们对CNN这个术语有些熟悉，那我们还等什么呢？让我们创建一个吧！但是你知道吗，我要给你们所有人发奖金。如果除了我们自己制作一个新模型之外，我们还使用一个已经为一个非常大的数据集训练过的“预训练”模型，那会怎么样！</p><p id="f974" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是我在学习深度学习或DL时发现的一个妙处，如果你是一个懒惰的生物(像我一样)，不喜欢到处乱搞，不喜欢在实际制作新模型时遇到麻烦，而是为了自己的目的多少使用别人的模型，这是正确的地方，这个概念被命名为<strong class="jl hj">“迁移学习”</strong></p><p id="639f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我将向您介绍迁移学习的概念，同时编写代码，您会喜欢它的，所以让我们开始编写代码吧！</p><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="5d51" class="le ki hi la b fi lf lg l lh li">vgg16_net = VGG16(weights='imagenet', <br/>                  include_top=False, <br/>                  input_shape=(32, 32, 3))</span></pre><p id="0094" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如前所述，我们的预训练模型的名称是VGG16(听起来像一个电影名称！)它实际上是一个由16层组成的网络。这是它的结构</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/ec41482d6ca645bcfff49f7747b0351b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*BilkB7Z7ssoW-hdy"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">与其手动编码，不如使用一个，对吗？</figcaption></figure><p id="e688" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是，如果这个模型是为了其他目的而创建的，我的意思是，我们希望这个模型能够分类一张图片中是否有仙人掌，但是我们甚至不知道这个模型是做什么的。为了解决这个问题，我们可以做的是<strong class="jl hj"> <em class="kg">将这个预先训练好的模型转移并连接</em> </strong>到我们自制的模型上，这就是为什么它被称为迁移学习！</p><h2 id="9226" class="le ki hi bd kj lj lk ll kn lm ln lo kr js lp lq kt jw lr ls kv ka lt lu kx lv bi translated">我们的预训练模型的语法:</h2><p id="0f8f" class="pw-post-body-paragraph jj jk hi jl b jm mc ij jo jp md im jr js me ju jv jw mf jy jz ka mg kc kd ke hb bi translated">所以在上面提到的代码中，有3个参数(权重、包含、输入形状)。所以让我们按顺序来说清楚:</p><p id="118d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">权重:</strong>它基本上是一个祝福或诅咒，我的意思是它有点像一个偏差值，它将输入乘以某个数字，并将其传递给下一层，因此如果节点比自然情况下更有价值，它的权重就会更高。<br/> <strong class="jl hj"> include_top = False: </strong>如上述理论中所述，我们将在新模型中串联出预训练模型，为此，我们需要移除它的(vgg16)顶层，该层本应预测输出。明白这一点对你来说很重要，所以这里有一个视频<a class="ae kf" href="https://www.youtube.com/watch?v=mPFq5KMxKVw" rel="noopener ugc nofollow" target="_blank"> <em class="kg">链接</em> </a> <em class="kg">。<br/></em><strong class="jl hj">input _ shape:<em class="kg"/></strong>你只要通过命令img.shape就可以知道这一点</p><h2 id="12d9" class="le ki hi bd kj lj lk ll kn lm ln lo kr js lp lq kt jw lr ls kv ka lt lu kx lv bi translated">前进方向:</h2><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="b46f" class="le ki hi la b fi lf lg l lh li">vgg16_net.trainable = True<br/>model = Sequential()     #Starting Point<br/>model.add(vgg16_net)<br/>model.add(Flatten())<br/>model.add(Dense(256))<br/>model.add(Activation('relu'))<br/>model.add(Dropout(0.5))<br/>model.add(Dense(1))<br/>model.add(Activation('sigmoid'))</span></pre><p id="c3c5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这么多新术语，我们一个一个来理解吧。总的来说，这就是我所说的串联，让我们从“起点”开始，我们已经创建了一个将成为Sequential()对象的模型，Sequential只是帮助我们像三明治一样堆叠尽可能多的层！</p><h1 id="6da3" class="kh ki hi bd kj kk kl km kn ko kp kq kr io ks ip kt ir ku is kv iu kw iv kx ky bi translated">我们模型的层次</h1><p id="5861" class="pw-post-body-paragraph jj jk hi jl b jm mc ij jo jp md im jr js me ju jv jw mf jy jz ka mg kc kd ke hb bi translated">现在我们已经准备好了我们的模型，让我们开始添加一些层:<br/> <strong class="jl hj">第一层:</strong>我们的预处理模型<br/> <strong class="jl hj">第二层:</strong> Flatten()，这到底是什么意思？</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mk"><img src="../Images/b6cf3a9b9c1521874891b1578f444d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/0*KF_PDzU9cANJZ6DV.png"/></div></figure><p id="879c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">扁平化()简单地说，对于那些还在这里苦苦挣扎的人来说是官方的定义:</p><p id="97a1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> Flatten </strong>是将汇集的要素地图转换为传递给完全连接图层的单个列的函数。Dense将全连接层添加到<strong class="jl hj">神经网络</strong>中。</p><p id="acaf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">第三层:</strong>密集(256)，一个<strong class="jl hj">密集</strong>层代表一个矩阵向量乘法，换句话说，它实际上意味着在训练过程中，可能会发生矩阵中以前的值不准确，因此可能需要改变它，这个过程也被称为<strong class="jl hj">‘反向传播’。</strong>语法的含义将生成256个节点的输出。</p><p id="0f9b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">第三层(激活功能):</strong></p><p id="56e6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">激活函数的工作:</strong>具体来说，这些函数对输入(<strong class="jl hj"> X </strong>)与其对应的权重(<strong class="jl hj"> W </strong>)的乘积求和，并对其应用激活函数<strong class="jl hj"> f(x) </strong>以获得该层的输出，并将其作为输入馈送给下一层。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ml"><img src="../Images/25f60d1cebd9422ebc1be40a65c43a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*IrgTGR4kzKsfELj4xn65uA.png"/></div></figure><p id="9d2d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">什么是Relu？</strong></p><p id="543f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Relu or(整流线性单元(<strong class="jl hj"> ReLU </strong>))被广泛用于从我们的模型中移除所有受到负面影响的节点。从图中可以看出，如果权重小于0，则返回0，正如我们在上面的理论中所读到的，所有输入都乘以其权重，如果权重为0，则表示输入没有意义。</p><p id="0d53" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">第四层(辍学):</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mm"><img src="../Images/8db81a97b85e8b3bd592e012a36fb1e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/0*MzW7NxXw630CQ9_7.png"/></div></figure><p id="7488" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如图所示，这是一种通过在训练过程中丢弃一些随机节点来减少过拟合和改善正则化的技术。</p><p id="aa9c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> Drop(0.2) </strong>表示当前层将从先前添加的层中随机删除20%的节点。</p><p id="662d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">第四层:</strong>我不会深入到这一层，因为已经提到了密集层的工作，简而言之，这一层将给出输出单个节点，该节点将有我们的答案，现在答案的形式将由我们的<strong class="jl hj">激活函数或sigmoid决定。</strong></p><p id="e769" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">第四层(激活功能):</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mn"><img src="../Images/dc0edba4d3243d94048cf294dd043386.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/0*7jou8sPSSuIWqDUO.png"/></div></figure><p id="4d83" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">按照惯例，除了图解以外，还有sigmoid函数的典型例子。然而，一个更简单和实用的方法是，它会简单地给出你输出的可能性。</p><p id="1930" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">恭喜你，你已经到达了所有层的终点。现在你对所有的层、激活函数、预训练模型或迁移学习都有了一个基本的概念(这对一个初学者来说是相当多的事情，你真棒！).</p><h1 id="ee95" class="kh ki hi bd kj kk kl km kn ko kp kq kr io ks ip kt ir ku is kv iu kw iv kx ky bi translated">编译我们的模型</h1><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="8600" class="le ki hi la b fi lf lg l lh li">model.compile(loss='binary_crossentropy',<br/>              optimizer=Adam(lr=1e-5), <br/>              metrics=['accuracy'])</span></pre><p id="e57c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们准备<strong class="jl hj">编译</strong>我们的模型。这将创建一个Python对象来构建CNN。这是通过基于我们正在使用的Keras后端以正确的格式构建计算图来实现的。</p><p id="b9c3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">编译函数由3个参数组成(损失、优化器和指标)。</p><p id="e2b4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">损失:</strong>顾名思义，这个函数表示我们的算法与实际解的接近程度，如果预测与实际结果偏离太多，损失函数将会产生一个非常大的数字。二进制交叉熵特别用于二进制分类，我们的主要任务是预测是/否。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mo"><img src="../Images/c6086ccc5f8cf1a4c3430870694b12f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/0*pdtKnAETMiytpd_-.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">二元交叉熵数学。ŷ是预测值，y是我们的实际值。</figcaption></figure><p id="d5c2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">优化器:</strong>优化函数主要用于最小化或最大化损失函数，也称为<strong class="jl hj"> E(x)。</strong>这里我们使用了Adam( <strong class="jl hj">自适应矩估计</strong>)。<strong class="jl hj"> Adam </strong>在实践中表现良好，并且与其他自适应学习方法算法相比毫不逊色，因为它收敛速度非常快，并且模型的学习速度非常快和高效。为了更好的理解，我参考了这个<a class="ae kf" href="https://towardsdatascience.com/types-of-optimization-algorithms-used-in-neural-networks-and-ways-to-optimize-gradient-95ae5d39529f" rel="noopener" target="_blank"> <em class="kg">链接</em> </a>。</p><h1 id="2314" class="kh ki hi bd kj kk kl km kn ko kp kq kr io ks ip kt ir ku is kv iu kw iv kx ky bi translated">让我们继续:</h1><p id="b5c3" class="pw-post-body-paragraph jj jk hi jl b jm mc ij jo jp md im jr js me ju jv jw mf jy jz ka mg kc kd ke hb bi translated">现在我们已经创建了模型，让我们来训练它。在此之前，我们需要将<strong class="jl hj">标签</strong>与<strong class="jl hj">特征</strong>分开，换句话说就是图像与它们的标签。这是代码</p><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="e37b" class="le ki hi la b fi lf lg l lh li">X_tr = []<br/>Y_tr = []<br/>imges = train_df['id'].values<br/>for img_id in tqdm_notebook(imges):<br/>    X_tr.append(cv2.imread(train_dir + img_id))    <br/>    Y_tr.append(train_df[train_df['id'] == img_id]['has_cactus'].values[0])  </span><span id="9eef" class="le ki hi la b fi mp lg l lh li">#Cooking our food!<br/>X_tr = np.asarray(X_tr)<br/>X_tr = X_tr.astype('float32')<br/>X_tr /= 255<br/>Y_tr = np.asarray(Y_tr)</span></pre><p id="4584" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">哇哦。这么多胡言乱语。让我们一步一步来理解。</p><p id="8bf5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">从起点理解，我们所做的是在一个名为“imges”的列表中获得所有图像名称的列表。这是输出</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mq"><img src="../Images/d15930e4a37f2a232d8d837b8845be99.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*ezdWNBYRI5xQW3CAUG-_-g.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">模型不能只靠图像名训练对吧？</figcaption></figure><p id="2972" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们需要检索图像，我们该怎么做呢？我们可以简单地遍历名为imges的列表。</p><p id="2ce1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你可能已经注意到了一个新术语叫做<strong class="jl hj"><em class="kg">‘tqdm _ notebook’。</em> </strong>它的主要功能是给出一个漂亮的进度条，指示进程完成了多少，就像这样:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mr"><img src="../Images/443f784f8ec425f4ce3c24ba72b360be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*Bg2IhlMXd8lqAS7VshbKHw.png"/></div></figure><p id="09bd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们在迭代中所做的事情非常简单，只是将我们的图像目录与图像的名称连接起来，并通过cv2.imread()函数存储和读取它。还有，在Y_tr中存储值或者标签(不管一个图片有没有cactus)。</p><p id="e449" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们已经为我们的模型收集了生食，只是我们的模型喜欢熟食，所以让我们烹饪它，使它可以为我们的模型食用。开始了。</p><p id="f801" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，我们需要将图像转换成数组，为此，我们使用了np.asarray()功能。吃完后，我们来吃正餐吧。我的意思是，我们不能只给我们的模型一个随机数列表，我们需要预处理它。</p><p id="b3f4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为此，我们将列表中的元素转换为浮点类型，并除以255，因为所有像素的范围都在0-255之间，所以我们将对列表进行标准化，并准备好接受<strong class="jl hj">服务</strong>！！</p><h1 id="cb4c" class="kh ki hi bd kj kk kl km kn ko kp kq kr io ks ip kt ir ku is kv iu kw iv kx ky bi translated">培训阶段开始:</h1><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="c6e7" class="le ki hi la b fi lf lg l lh li">batch_size = 32<br/>nb_epoch = 10<br/>model.fit(X_tr, Y_tr,<br/>              batch_size=batch_size,<br/>              epochs=nb_epoch,<br/>              validation_split=0.1,<br/>              shuffle=True,<br/>              verbose=2)</span></pre><p id="5c79" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然这是一个单一的命令，但在训练模型时有许多事情需要理解和记住。想象一下我们的大脑每秒钟是如何平稳高效地工作的(不是我的，:D，只是开玩笑！).让我们开始了解这种美。</p><p id="a841" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要理解什么是<strong class="jl hj"> batch_size </strong>和<strong class="jl hj"> epoch，</strong>只要记住它们之间的一个关系就可以了。因此，一个时期的数量就是我们的全部数据将通过网络的次数(正向处理和反向传播也是如此)。自然，这将占用我们大量的CPU或者GPU资源。为此，我们使用batch_size将数据分成几批，然后进一步传递。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ms"><img src="../Images/256c257e53d6e464a9a118d173265290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*o4svtYyoa4u7sCPT0wfzfw.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">训练结束了，我们也获得了相当好的精确度，我希望我们没有过度适应！</figcaption></figure><h1 id="12e5" class="kh ki hi bd kj kk kl km kn ko kp kq kr io ks ip kt ir ku is kv iu kw iv kx ky bi translated">测试阶段，而不是最终阶段！</h1><p id="5611" class="pw-post-body-paragraph jj jk hi jl b jm mc ij jo jp md im jr js me ju jv jw mf jy jz ka mg kc kd ke hb bi translated">所以我们终于到了这篇文章的结尾。我希望你已经理解了我们到目前为止所做的每一步。在这一阶段，我们将重复我们对训练数据集进行预处理的过程(还记得生食和熟食吗？)</p><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="8f34" class="le ki hi la b fi lf lg l lh li">X_tst = []<br/>Test_imgs = []<br/>for img_id in tqdm_notebook(os.listdir(test_dir)):<br/>    X_tst.append(cv2.imread(test_dir + img_id))     <br/>    Test_imgs.append(img_id)<br/>X_tst = np.asarray(X_tst)<br/>X_tst = X_tst.astype('float32')<br/>X_tst /= 255</span></pre><p id="dc04" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们开始吧:</p><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="2f66" class="le ki hi la b fi lf lg l lh li">test_predictions = model.predict(X_tst)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mt"><img src="../Images/2a29c34f04522227d4412e1e23b4bbe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*H9gPvBk5AKuwtyAlKuC-zw.png"/></div></figure><p id="e3f2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是我们得到的预测，但根据竞争，我们需要有一个二元分类。</p><p id="7d25" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">不用担心，我们可以映射它的值，用预测值小于0.75的0和预测值大于0的1替换所有的值！</p><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="361b" class="le ki hi la b fi lf lg l lh li">sub_df = pd.DataFrame(test_predictions, columns=['has_cactus'])<br/>sub_df['has_cactus'] = sub_df['has_cactus'].apply(lambda x: 1 if x &gt; 0.75 else 0)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mu"><img src="../Images/d70833e89a5757c7c0fa93e033960444.png" data-original-src="https://miro.medium.com/v2/resize:fit:244/format:webp/1*-T4cB0jVgCtl0SCusVbEYQ.png"/></div></figure><p id="7843" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">更好对吗？现在，最后一步是用图像名称替换id，并提交它来检查我们的结果！</p><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="f2ce" class="le ki hi la b fi lf lg l lh li">#Preprocessing stuff for valid submission in kaggle<br/>sub_df['id'] = ''<br/>cols = sub_df.columns.tolist()<br/>cols = cols[-1:] + cols[:-1]<br/>sub_df=sub_df[cols]<br/>for i, img in enumerate(Test_imgs):<br/>    sub_df.set_value(i,'id',img)<br/>sub_df.head()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mv"><img src="../Images/c7469679b86d2687d22d27f9b784e47d.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*Ope7sRIGSpisBQ8NKjl7Hg.png"/></div></figure><p id="740d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">交叉手指，让我们检查结果！</p><pre class="iy iz ja jb fd kz la lb lc aw ld bi"><span id="c72f" class="le ki hi la b fi lf lg l lh li">sub_df.to_csv('submission.csv',index=False)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/9c8ab0b85636bfeb3d927b6c5a32ca6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfaht09dA3KYWd2U-NyiJg.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">不过还不错！</figcaption></figure><p id="6c0c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好了，现在就这样，我希望你理解了这段代码的每一行。也感谢Kaggle上一些令人敬畏的内核和笔记本为学习者提供指导。像往常一样，我总是乐于接受建议和改进。</p></div></div>    
</body>
</html>