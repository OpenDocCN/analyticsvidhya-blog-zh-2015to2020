<html>
<head>
<title>Developing, deploying and testing Flask applications on Kubernetes — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上开发、部署和测试Flask应用程序—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/developing-deploying-and-testing-flask-applications-on-kubernetes-part-ii-89438924ed22?source=collection_archive---------21-----------------------#2020-06-05">https://medium.com/analytics-vidhya/developing-deploying-and-testing-flask-applications-on-kubernetes-part-ii-89438924ed22?source=collection_archive---------21-----------------------#2020-06-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/e09f2bc439478143716309a632c4c7da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oaFxGVXhwyJ0EY_Uy8Dz0A.png"/></div></figure><h1 id="a647" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">概观</h1><p id="8224" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在第一篇教程<a class="ae ki" rel="noopener" href="/@asad_5112/developing-deploying-and-testing-flask-applications-on-kubernetes-part-i-64c24c29cfeb">“在Kubernetes上开发、部署和测试Flask应用程序-第一部分”</a>中，我们发现了如何创建本地开发环境。我们已经看到了使用小型集群的利弊。</p><p id="fc3f" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">我们得出了以下结论:Minikube，Microk8s，或者Docker for Mac都是很棒的本地开发工具。但是，对于测试和试运行环境，需要高度可用的集群在类似生产的环境中模拟和测试应用程序。</p><h1 id="1ea8" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">为您的测试/生产环境创建Kubernetes集群</h1><p id="e497" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">虽然为测试目的创建一个真正的Kubernetes集群似乎是许多开发人员问题的解决方案，但它的成本很高。</p><p id="7798" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">降低运行这些环境的成本的一个好主意是实现随需应变的测试环境，一旦您需要部署到测试集群，就可以创建和提供这些环境。每当测试完成后，就可以将环境移走并清理干净。</p><p id="2de2" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">市场上有几种工具可以用来构建、提供和销毁测试环境。以下是您可以考虑的一些工具:</p><ul class=""><li id="7456" class="ko kp hi jm b jn kj jr kk jv kq jz kr kd ks kh kt ku kv kw bi translated"><strong class="jm hj"> Terraform: </strong>是由HashiCorp创建的开源基础设施代码软件工具。它使用户能够以描述性的方式配置基础架构组件。</li><li id="675b" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated"><strong class="jm hj"> Ansible: </strong>是一款开源的配置管理和应用部署工具，可用于管理数据中心节点上的软件包和基础设施状态。</li><li id="92d3" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated"><strong class="jm hj"> Cloudplex: </strong>使用我们的可视化构建器，您可以<a class="ae ki" href="https://app.cloudplex.io/register?planName=developer-free?ref=blog" rel="noopener ugc nofollow" target="_blank">在不到5分钟的时间内将一个集群部署到多个云中</a>。您可以导出您的群集，然后单击一下即可关闭您的群集。要重新创建同一个集群，您可以导入保存的配置。您的集群已经启动并正在运行。</li></ul><h1 id="3084" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">关于Kubernetes API和资源的说明</h1><p id="79f5" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Kubernetes提供了一个在集群上创建资源的API，然后它将确保资源总是可用的，并以用户预定义的状态运行。Kubernetes集群可以创建和管理多种类型的资源，下面是运行我们的应用程序所需的资源列表</p><ul class=""><li id="00bb" class="ko kp hi jm b jn kj jr kk jv kq jz kr kd ks kh kt ku kv kw bi translated"><strong class="jm hj">部署:</strong>是一个资源对象，负责创建、管理和滚动服务更新。该资源还创建和管理另一种资源类型，即副本集。</li><li id="63ad" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated"><strong class="jm hj"> ReplicaSet: </strong>负责维护给定服务的pod的已定义复制。</li><li id="8415" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated"><strong class="jm hj"> Pod: </strong>是Kubernetes中最小的执行单元，为了简单起见，您可以将这个资源看作一个容器(尽管在某些情况下一个Pod可以包含多个容器)</li><li id="5327" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated"><strong class="jm hj">服务:</strong>该资源负责为服务创建接口，并在集群内部或外部公开它们。</li><li id="d779" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated"><strong class="jm hj">入口:</strong>该资源用于定义外部访问集群的规则。</li></ul><p id="51ca" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">您可以使用kubectl命令行检查资源的完整列表:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="fc32" class="ll in hi lh b fi lm ln l lo lp">$&gt; kubectl api-resources</span></pre><h1 id="cd1b" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">创建Kubernetes部署</h1><p id="d650" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">要在Kubernetes集群上部署天气应用程序，我们需要为应用程序所需的每个资源编写资源定义文件。资源定义文件是YAML文件，包括创建资源所需的所有属性。</p><p id="f69f" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">这些文件需要涵盖四个常见的配置部分，如下所示:</p><p id="3420" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj"> apiVersion: </strong>描述用于创建资源的Kubernetes API版本。<br/> <strong class="jm hj">种类:</strong>描述要创建的资源的类型。<br/> <strong class="jm hj">元数据:</strong>附加关于资源的元信息，如名称或标签。<br/> <strong class="jm hj">规格:</strong>描述资源的规格。</p><p id="6f70" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">为了运行我们的应用程序，我们在这里需要的第一个资源是Kubernetes部署，上面的每个部分都有以下值:</p><p id="0b24" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj">API version:</strong>apps/v1<br/>T20】种类:部署<br/>T23】元数据:部署名称和标签。<br/> <strong class="jm hj">规格:</strong>包含<br/> <strong class="jm hj">副本的部署对象的规格:</strong>要创建和管理的Pod的数量<br/> <strong class="jm hj">选择器:</strong>用于选择由部署管理的Pod的条件<br/> <strong class="jm hj">模板:</strong>用于创建Pod容器的模板，该模板定义了容器名称、容器docker图像和其他选项。</p><p id="adf7" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">下面的资源文件可用于为天气应用程序创建Kubernetes部署</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1836" class="ll in hi lh b fi lm ln l lo lp">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: weather-api<br/>  name: weather-api<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      app: weather-api-pod<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: weather-api-pod<br/>    spec:<br/>      containers:<br/>      - name: weather-api<br/>        image: wshihadeh/weather-api-app:latest<br/>        ports:<br/>        - containerPort: 5000<br/>      restartPolicy: Always</span></pre><p id="92ce" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">上述Kubernetes部署资源将为我们的服务创建两个pod，每个都有一个专用的IP。您可以在Pods IP上使用天气API。但是，不建议这样做，原因如下:</p><ul class=""><li id="7e2f" class="ko kp hi jm b jn kj jr kk jv kq jz kr kd ks kh kt ku kv kw bi translated">如果重新创建Pod以进行重新计划，pod IP将会改变。</li><li id="8c13" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">如果您希望在pod之间实现流量负载平衡，您需要使用多个IP。</li></ul><p id="cd52" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">由于这些缺点，建议使用服务资源在Kubernetes中公开应用程序。该资源为我们提供了一个可用于访问应用程序单元的IP地址(它自动对流量进行负载平衡),如果需要，它有助于将应用程序暴露在集群之外。</p><p id="8f17" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">要为我们的应用程序创建服务资源，我们需要创建另一个包含以下部分的定义文件:</p><ul class=""><li id="fd2d" class="ko kp hi jm b jn kj jr kk jv kq jz kr kd ks kh kt ku kv kw bi translated"><strong class="jm hj">API version:</strong>“v1”</li><li id="84d8" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated"><strong class="jm hj">种类:</strong>【服务】</li><li id="15b7" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated"><strong class="jm hj">元数据:</strong>服务名和标签。</li><li id="3d20" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated"><strong class="jm hj">规格:</strong>服务对象的规格，包括:</li></ul><ol class=""><li id="6ec9" class="ko kp hi jm b jn kj jr kk jv kq jz kr kd ks kh lq ku kv kw bi translated"><strong class="jm hj">选择器:</strong>用于选择由Kubernetes部署管理的pod的条件</li><li id="d210" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh lq ku kv kw bi translated"><a class="ae ki" href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types" rel="noopener ugc nofollow" target="_blank"> <strong class="jm hj">服务类型:</strong> </a> Kubernetes支持几种<a class="ae ki" href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types" rel="noopener ugc nofollow" target="_blank">服务类型</a>用于管理内部和外部流量。</li><li id="aa8e" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh lq ku kv kw bi translated"><strong class="jm hj">端口:</strong>服务公开的端口。</li><li id="93bc" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh lq ku kv kw bi translated"><strong class="jm hj">目标端口:</strong>吊舱暴露端口。</li></ol><p id="6d8c" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">下面的YAML文件显示了服务资源的完整实现，正如您所看到的，它将在端口8080上侦听，并将请求转发到端口5000上的应用程序Pods。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="a4f4" class="ll in hi lh b fi lm ln l lo lp">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    app: weather-api<br/>  name: weather-api-service<br/>spec:<br/>  ports:<br/>  - port: 8080<br/>    targetPort: 5000<br/>  selector:<br/>    app: weather-api-pod<br/>  type: ClusterIP</span></pre><p id="26aa" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">请注意，我们使用了ClusterIP服务，这意味着该服务只对集群中的其他应用程序可用。为了对外公开服务，我们需要使用不同的类型，比如LoadBalancer或NodePort。</p><p id="94fa" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">为集群中的每个应用程序使用这些类型的服务会增加服务管理的开销，并增加运行集群的成本。如果您为我们的每个服务创建一个负载平衡器，成本可能会显著增加。即使在托管的Kubernetes中，负载平衡器是由云提供商创建和负责的，但仍然不建议这样做，除非您有一个单独的服务要公开。</p><p id="8b2a" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">另一种方法是在外部公开入口控制器应用程序，并定义管理内部服务流量的入口规则。</p><h1 id="6d47" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">使用Traefik入口</h1><p id="b359" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Kubernetes支持多种入口控制器，可用于管理传入的外部请求。在本帖中，我们将尝试Traefik。</p><p id="315d" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">在Kubernetes上运行Traefik需要创建几个资源，以便按预期工作。第一步是创建授予Traefik对Kubernetes的权限所需的资源。它应该能够收集集群中正在运行的应用程序的信息。下面列出了这些资源</p><ul class=""><li id="b1dc" class="ko kp hi jm b jn kj jr kk jv kq jz kr kd ks kh kt ku kv kw bi translated"><strong class="jm hj"> ServiceAccount: </strong>这个资源为在Pod中运行的进程提供了一个身份。</li><li id="a005" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated"><strong class="jm hj"> ClusterRole: </strong>该资源定义了代表Kubernetes集群的记帐资源权限的规则。</li><li id="dd92" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated"><strong class="jm hj"> ClusterRoleBinding: </strong>它将角色绑定到主题，如组、用户或服务帐户。</li></ul><p id="dae5" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">下面的定义文件包含了上述所有资源。ClusterRole为集群上的一些资源(如服务、端点和机密)定义了get、list和watch。另一方面，ClusterBindingRole将创建的ServiceAccount与ClusterRole链接起来。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="4282" class="ll in hi lh b fi lm ln l lo lp">kind: ClusterRole<br/>apiVersion: rbac.authorization.k8s.io/v1beta1<br/>metadata:<br/>  name: traefik-ingress-controller<br/>rules:<br/>  - apiGroups:<br/>      - ""<br/>    resources:<br/>      - services<br/>      - endpoints<br/>      - secrets<br/>    verbs:<br/>      - get<br/>      - list<br/>      - watch<br/>  - apiGroups:<br/>      - extensions<br/>    resources:<br/>      - ingresses<br/>    verbs:<br/>      - get<br/>      - list<br/>      - watch<br/>  - apiGroups:<br/>      - extensions<br/>    resources:<br/>      - ingresses/status<br/>    verbs:<br/>      - update</span><span id="74ab" class="ll in hi lh b fi lr ln l lo lp">---<br/>apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/>  name: traefik-ingress-controller</span><span id="fcc4" class="ll in hi lh b fi lr ln l lo lp">---<br/>kind: ClusterRoleBinding<br/>apiVersion: rbac.authorization.k8s.io/v1beta1<br/>metadata:<br/>  name: traefik-ingress-controller<br/>roleRef:<br/>  apiGroup: rbac.authorization.k8s.io<br/>  kind: ClusterRole<br/>  name: traefik-ingress-controller<br/>subjects:<br/>  - kind: ServiceAccount<br/>    name: traefik-ingress-controller<br/>    namespace: default</span></pre><p id="e7d8" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">下一步是使用Kubernetes部署来部署Traefik服务本身，如下面的代码片段所示。将Kubernetes Ingress添加到Traefik命令行非常重要，如下所示:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="ad84" class="ll in hi lh b fi lm ln l lo lp">kind: Deployment<br/>apiVersion: apps/v1<br/>metadata:<br/>  name: traefik<br/>  labels:<br/>    app: traefik</span><span id="c45e" class="ll in hi lh b fi lr ln l lo lp">spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: traefik<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: traefik<br/>    spec:<br/>      serviceAccountName: traefik-ingress-controller<br/>      containers:<br/>        - name: traefik<br/>          image: traefik:v2.2<br/>          args:<br/>            - --log.level=DEBUG<br/>            - --api<br/>            - --api.insecure<br/>            - --entrypoints.web.address=:80<br/>            - --providers.kubernetesingress<br/>          ports:<br/>            - name: web<br/>              containerPort: 80<br/>            - name: admin<br/>              containerPort: 8080</span></pre><p id="aa85" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">为了能够从集群外部访问Traefik入口控制器，我们需要为Traefik定义一个服务资源，如下所示。</p><p id="93e2" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">我们使用负载平衡器服务向Kubernetes主机公开该服务。公开了两个端口，一个用于托管服务web请求，另一个用于Traefik管理面板。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5a01" class="ll in hi lh b fi lm ln l lo lp">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: traefik<br/>spec:<br/>  type: LoadBalancer<br/>  selector:<br/>    app: traefik<br/>  ports:<br/>    - protocol: TCP<br/>      port: 80<br/>      name: web<br/>      targetPort: 80<br/>    - protocol: TCP<br/>      port: 8080<br/>      name: admin<br/>      targetPort: 8080</span></pre><p id="2eb6" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">最后一步是定义入口规则，该规则将用于将请求从入口控制器转发到天气服务。下面的入口文件根据请求的主机定义了所需的规则。</p><p id="2037" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">所有带有主机weather.lvh.me的请求都将被转发到天气服务。</p><p id="d855" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">请注意，已定义的注释定义了哪些Traefik入口点将用于服务请求。</p><p id="ef00" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">可以使用以下命令之一来部署上面定义的所有资源:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="d370" class="ll in hi lh b fi lm ln l lo lp">$&gt; kubectl apply -f ${file_name}<br/>$&gt; kubectl create -f ${file_name}</span><span id="0a50" class="ll in hi lh b fi lr ln l lo lp">$&gt; kubectl apply ${k8s_files_directory}<br/>$&gt; kubectl create ${k8s_files_directory}</span></pre><h1 id="bf0b" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">让我们在类似生产的集群上运行一个负载测试</h1><p id="76fd" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">测试web应用程序的性能是软件生命周期中最关键和最重要的阶段之一:它可以为我们提供在真实用例及已知场景下web应用程序性能所需的指标和KPI，所有这些都是在新版本推出或发布之前完成的。</p><p id="a783" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">有几个工具可以用来执行性能测试/用户负载测试，比如LoadRunner、LoadNinja、Apache JMeter等等。执行用户负载测试最简单直接的工具之一是<a class="ae ki" href="http://locust.io/" rel="noopener ugc nofollow" target="_blank"> locust.io. </a>该工具旨在对web应用(或其他资源)进行负载测试，并计算出它可以处理多少并发用户。</p><p id="9366" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">我们将对天气应用程序进行基本的用户负载测试。测试用例将覆盖根和天气端点。下面是测试用例文件:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2773" class="ll in hi lh b fi lm ln l lo lp">from locust import HttpLocust, TaskSet, task, between</span><span id="edf6" class="ll in hi lh b fi lr ln l lo lp">class WebsiteTasks(TaskSet):<br/>    @task<br/>    def index(self):<br/>        self.client.get("/")</span><span id="0c42" class="ll in hi lh b fi lr ln l lo lp">    @task<br/>    def london(self):<br/>        self.client.get("/london/uk/")<br/></span><span id="20f0" class="ll in hi lh b fi lr ln l lo lp">class WebsiteUser(HttpLocust):<br/>    task_set = WebsiteTasks<br/>    wait_time = between(5, 15)</span></pre><p id="7996" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">要开始运行测试，首先，我们需要用下面的命令启动locust</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="f702" class="ll in hi lh b fi lm ln l lo lp">$&gt;  locust -f  test.py</span></pre><p id="f2ff" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">下一步是从Locust UI开始运行负载测试。为此，使用下面的URL<a class="ae ki" href="http://localhost:8089/" rel="noopener ugc nofollow" target="_blank">http://localhost:8089/</a>，并按照屏幕截图所示填写表单。这将启动一个有1000个用户的负载测试，孵化率为每秒2个用户。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ls"><img src="../Images/6f4b76ebcf279823a4fb667018f1b13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FMpl3GxRBMvvZPNO.png"/></div></div></figure><p id="9447" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">一旦所有1000个用户都被加载并并发发送web请求，由于服务的高负载，传入的请求可能会开始失败。</p><p id="166b" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">下面的截图显示了我们第一次试验的统计数据。误差率为5%，这是一个相当大的百分比。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lx"><img src="../Images/41d0a74ddfbf4b4af6d3124e3d919994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2kcIJr_sEwyqje9w.png"/></div></div></figure><p id="ab60" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">将天气服务扩展到4个副本后，我们可以用1000个用户和相同的孵化率执行相同的负载测试。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="54c4" class="ll in hi lh b fi lm ln l lo lp">$&gt; kubectl scale --replicas=4 deployment weather-api</span></pre><p id="372f" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">如图所示，扩展我们的Kubernetes服务极大地提高了应用程序的性能。不仅错误率下降到0，而且请求的中值和平均响应时间也下降了。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lx"><img src="../Images/82d3c07e98574e79bb3cd202f118fb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uPW7aIedmZG7VAQB.png"/></div></div></figure><h1 id="bc11" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">结论</h1><p id="9483" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">本教程中使用的Flask代码可以在这个<a class="ae ki" href="https://github.com/eon01/python-weather-api-example" rel="noopener ugc nofollow" target="_blank">库</a>中找到。在本教程的帮助下，您可以提取相同的存储库，创建Flask应用程序，使用minikube在本地运行它，创建所需的Kubernetes部署和服务，将您的集群部署到Google Cloud、EKS或任何其他公共云提供商。最后，您可以使用Traefik作为入口控制器，并使用Locust对您的集群进行负载测试。</p><p id="332e" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">阿萨德·法伊兹<br/>创始人兼首席执行官<br/> Cloudplex.io</p></div></div>    
</body>
</html>