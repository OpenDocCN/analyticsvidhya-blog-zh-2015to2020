<html>
<head>
<title>Getting started with Data visualization using Matplotlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Matplotlib开始数据可视化</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/getting-started-with-data-visualization-using-matplotlib-f5c6fbb9f421?source=collection_archive---------37-----------------------#2020-04-13">https://medium.com/analytics-vidhya/getting-started-with-data-visualization-using-matplotlib-f5c6fbb9f421?source=collection_archive---------37-----------------------#2020-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a030ebb86e5ff6a5a18b8162169be36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HFgKoKfUxWroGR-8"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@webaroo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Webaroo </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e184" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">探索和分析数据是任何数据科学项目中最重要的部分之一。然而，从统计角度探索数据会给你带来深刻的见解，但是，数据的可视化可以向你展示一些显而易见而你看不到的东西。</p><p id="4176" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Matplotlib是一个用python编写的广泛而健壮的库。在这篇文章中，我只打算触及它的表面。与其说这是一篇文章，不如说是一篇教程。</p><p id="221b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">本教程包含:- </strong></p><ol class=""><li id="0870" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">设置和下载数据</li><li id="0be0" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">线条</li><li id="ef16" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">柱状图</li><li id="93bb" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">酒吧</li><li id="0246" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">馅饼</li><li id="6c51" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">分散</li></ol></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="b372" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">设置并下载数据</strong></p><p id="7069" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本教程的必需软件包是pandas、numpy和matplotlib。您可以使用pip命令从python命令行下载这些包。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d9c9" class="kx ky hi kt b fi kz la l lb lc">pip install matplotlib<br/>pip install pandas<br/>pip install numpy<br/>pip install sklearn<br/>pip install seaborn</span></pre><p id="c37b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从<a class="ae iu" href="https://github.com/mrcaptain28698/Data_visulaization_with_matplotlib_part_1" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">这里</strong> </a> <strong class="ix hj">下载数据。</strong></p><p id="aae7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">打开jupyter笔记本，导入所需的包。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f87f" class="kx ky hi kt b fi kz la l lb lc">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set() # it will make graphs look better. Try without it also, you will see the difference by yourself.<br/>%matplotlib inline # magic command </span></pre><h2 id="369e" class="kx ky hi bd ld le lf lg lh li lj lk ll jg lm ln lo jk lp lq lr jo ls lt lu lv bi translated"><strong class="ak">线</strong></h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="16ce" class="kx ky hi kt b fi kz la l lb lc">data= np.random.randint(0,10,size=5)<br/>plt.plot(data)</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/e10d05219502eddb48765924572abfb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*D8sAqXG3TqnVZeMSQ9vR6Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">简单线图</figcaption></figure><p id="19ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用plot()函数渲染线条。</p><ol class=""><li id="93f7" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">接受单个iterable #必需参数</li><li id="bd16" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">值沿y轴绘制</li><li id="67d3" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">x轴值默认为从零开始的连续整数</li><li id="19f4" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">默认情况下，线条的颜色是蓝色</li></ol><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f135" class="kx ky hi kt b fi kz la l lb lc">data= [50, 60, 39 ,56, 78,80, 48, 29, 89, 38]<br/>labels=['A', 'B','C' ,'D', 'E', 'F', 'G','H', 'I','J']<br/>plt.figure(figsize=(5,3))<br/>plt.plot(data)<br/>plt.xticks(ticks=np.arange(10), labels=labels)# ticks list or ndarray  and labels is list<br/>plt.xlabel("Characters", fontsize=16)<br/>plt.ylabel("Values", fontsize=16);<br/>plt.title("Line Plot", fontsize=20);</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/9c6c50197bee04827ae1c8b48b134df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*s13of3MzXBEwWqOYRD3Rdw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">上述代码片段的输出</figcaption></figure><p id="c2e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“X”和“Y”轴上的刻度可以由matplotlib.pyplot包提供的xticks()和yticks()方法控制。在xticks()和yticks()中，我们还可以提到标签来定制刻度的标签。注意:<strong class="ix hj"><em class="lx"/></strong><em class="lx">ticks中的标签不同于xlabel()和ylabel() </em></p><p id="7392" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">颜色和款式</strong></p><p id="b394" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">styles = ['实线'，'虚线'，'点划线'，'虚线'，'无']</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2af1" class="kx ky hi kt b fi kz la l lb lc">for i, sty in zip(np.arange(10), styles):<br/>    plt.plot(np.arange(10)+i, ls=sty, linewidth=i+5)</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/3ae6334284224710806bc306f2f140b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*kXq09PHezH7S9b8W5krNuQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">上述代码片段的输出</figcaption></figure><ol class=""><li id="7384" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">我们可以通过给“颜色”关键字或“c”赋值来设置线条的颜色。可能的值可以是任何十六进制颜色代码。有8种常用的颜色，我们可以直接用它们的名字来提及:红色、蓝色、洋红色、黑色、黄色、绿色、青色、白色。你可以用缩写代替他们的名字，缩写将是名字的第一个字母，除了black，我们用k来消除blue和black之间的歧义。即使我们不提及线条的颜色，matplotlib也会根据循环将不同的颜色分配给单个图形中的不同线条。我们可以改变色彩循环，也可以定制我们自己的循环。如果你想了解更多关于cycles<strong class="ix hj"/><a class="ae iu" href="https://matplotlib.org/tutorials/colors/colors.html" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">的信息，请点击这里</strong> </a></li><li id="4d2b" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">线型:matplotlib提供了5种不同的线型，如图所示。</li><li id="7750" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">linewidth:可选整数参数，用于自定义线条的宽度。</li></ol><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="94d8" class="kx ky hi kt b fi kz la l lb lc">styles = [':','-.','-','--',' '] #linestyle can also be provided as abbreviations<br/>for i, sty in zip(np.arange(10), styles):<br/>    plt.plot(np.arange(10)+i, ls=sty, linewidth=i+5)</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/f8a53fb670afaf1d434a210e992674b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*3Y-Iaw6H2AKs_ci3IITCEA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">上述代码片段的输出</figcaption></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c980" class="kx ky hi kt b fi kz la l lb lc"># There is one more method to control the line style <br/>plt.plot(np.arange(10), linestyle=(3, (1, 10, 5, 1)), linewidth=5);<br/>plt.plot(np.arange(10)+1, linestyle=(3, (1, 2, 4, 1)));</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/279744672bc4e5eec267ba53688d0d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*kqziOptlLzUjHcxhehHlLQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">上述代码片段的输出</figcaption></figure><p id="4631" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种类型的线称为虚线元组引用。它给程序员更精细的控制。我们需要提供开关序列的偏移量和偶数。linestyle= (3，(1，2，4，1))它的意思是(offset，(1pt on，2pt off，4pt on，1pt off))一个开关序列(1，1)将给出虚线。</p><p id="18d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lx">实际例子</em></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3fb2" class="kx ky hi kt b fi kz la l lb lc">iris_data = pd.read_csv('iris_with_cluster.csv')<br/>plt.figure(figsize=(10,6))</span><span id="63f6" class="kx ky hi kt b fi lz la l lb lc">plt.plot(iris_data['sepal_length'], linestyle="solid", linewidth=2, color='r', solid_joinstyle='miter', label="Sepal length")</span><span id="c57f" class="kx ky hi kt b fi lz la l lb lc">plt.plot(iris_data['sepal_width'], linestyle="-.", linewidth= 2, color= "black", label="Sepal Width")</span><span id="fbf7" class="kx ky hi kt b fi lz la l lb lc">plt.plot(iris_data['petal_length'],linestyle='dashed', linewidth=1, color="green", dash_capstyle= "butt", label="Petal length") <br/>plt.plot(iris_data['petal_width'], linestyle=(0,(1,1,1,1)), linewidth=2, color="magenta", label="Petal Width")<br/>plt.legend(loc="upper left",ncol=2, fontsize=12)<br/>plt.ylabel("In cm", fontsize=16)<br/>plt.title("Iris data line plot", fontsize=20);</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/4c9dc6fd21288fa2bd9025cdb765e776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3WszombXY-v-V29dA3gJQ.png"/></div></div></figure><p id="4903" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">solid_joinstyle:控制每个数据点处线条的接合样式。可用选项有“斜接”、“圆形”和“斜角(切角)”。</p><p id="d72c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">dash_capstyle:适用于虚线。可用选项有“对接”、“圆形”和“突出”。</p><p id="e38c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有比这更多的线阴谋。正如我在开始时所说的，这只是表面，你想了解更多，请访问matplotlib的官方文档。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h2 id="1ed0" class="kx ky hi bd ld le lf lg lh li lj lk ll jg lm ln lo jk lp lq lr jo ls lt lu lv bi translated">柱状图</h2><p id="e34f" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">直方图用于可视化数据的频率分布。这与我们在统计中计算的一样，即有多少数据点落在区间内。</p><p id="c1eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">直方图由<strong class="ix hj"> hist() </strong>函数生成:</p><ol class=""><li id="d729" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">接受数据集</li><li id="6324" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">将数据集分成相等的间隔。将值与每个间隔匹配</li><li id="f7e8" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">在X轴上绘制间隔，在Y轴上绘制频率。</li></ol><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/e2642b4177b23e149bafa14b941f6464.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*cpfb5TLHF0I16hofiKgkLw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e0f0" class="kx ky hi kt b fi kz la l lb lc">data = np.random.randn(1000)<br/>plt.hist(data)</span></pre><p id="fcb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过提供bin参数，我们可以自定义间隔的数量。箱数越多，显示的细节越多。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/9cf2cd785c58fb7e695685ee12e22b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*lSiCBhVGx8sW6V9qw84I8Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="653b" class="kx ky hi kt b fi kz la l lb lc">data = np.random.randn(1000)<br/>plt.hist(data, bins=20)</span></pre><p id="e55d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更多的箱数也会扭曲图形</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="dee6" class="kx ky hi kt b fi kz la l lb lc">data= np.random.randn(10000)<br/>plt.hist(data,bins=70,histtype='step',cumulative=True,label='cdf &lt;')<br/>plt.hist(data,bins=70,histtype='step',cumulative=True,label='cdf &gt;')<br/>plt.legend(loc='upper center', fontsize=16)</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/cb687b89b5ea56e21710ac89aa79025d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUEDKYfWrhFf5hWG7l3ZCA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="3bd7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过提供累积(布尔)参数，我们可以得到数据的累积分布。真值将给出“大于(经验)”值，而-1值将绘制“小于(修正经验)”图。</p><p id="9f55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">histtype:通过提供histtype参数，我们可以控制bin样式。可用选项有“步进”、“步进填充”、“条形(不等箱宽)”。</p><p id="e00a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以提供与线形图相同的颜色参数。</p><p id="58d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lx">实际例子</em></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="bab4" class="kx ky hi kt b fi kz la l lb lc">plt.figure(figsize= (10,6))<br/>plt.hist(iris_data['sepal_length'], bins=25, histtype='step', label='sepal length')<br/>plt.hist(iris_data['sepal_width'], bins=25, histtype='step', label='sepal width')<br/>plt.hist(iris_data['petal_length'], bins=25, histtype='step', label='petal length')<br/>plt.hist(iris_data['petal_width'], bins=25, histtype='step',label='petal width')<br/>plt.legend(loc='upper right', fontsize=16)<br/>plt.title("Iris data Histogram plot", fontsize=20)<br/>plt.xlabel('Measure in cm', fontsize=16)<br/>plt.ylabel('Frequency', fontsize=16)</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/2045c6abd880bd51c3898cd30e453d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvlTAKLEpOMiaUAgG83tmw.png"/></div></div></figure><p id="7e4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们来看条形图。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h2 id="7ace" class="kx ky hi bd ld le lf lg lh li lj lk ll jg lm ln lo jk lp lq lr jo ls lt lu lv bi translated">条形图</h2><p id="00cb" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">条形图也称为柱形图。它的工作原理和折线图一样，但是它不是绘制一个点，而是绘制一个高度等于y坐标的条形。它看起来有点像直方图，但不是。</p><p id="5037" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它用bar()函数绘制:<br/> 1。它需要两个必需的参数。<br/> 2。首先是X坐标值。主要是要绘制的数据的长度。<br/> 3。第二个必需参数是y坐标值。<br/> 4。条形越高，值越大。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/05de5773c4b24aac9c1381686393c355.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*FKoqYjyyepoWY1vL33vv7Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b19c" class="kx ky hi kt b fi kz la l lb lc">plt.bar(np.arange(20), np.random.randint(0,40,20))<br/>plt.xticks(ticks=np.arange(20));</span></pre><p id="6910" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">颜色和刻度都与上述相同。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/24db32926f93a482bbb3e30cb3ca0ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*0Z9hjUOjFMdhvHF6qOOfTA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="fcac" class="kx ky hi kt b fi kz la l lb lc">labels=['A', 'B', 'C', 'D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T']<br/>plt.barh(np.arange(20), np.random.randint(0,20,20))<br/>plt.yticks(ticks=np.arange(20), labels=labels)</span></pre><p id="8c06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用barh()函数，我们可以绘制水平条。注意:我们不需要交换传递的参数。条形的长度代表数值的大小。从这里我将展示一些先进的条形图与实际例子的帮助。</p><p id="1668" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lx">实际例子</em></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c814" class="kx ky hi kt b fi kz la l lb lc">plt.figure(figsize=(14,6))<br/>length= 40<br/>sepal_length=iris_data['sepal_length'][:40]<br/>sepal_width=iris_data['sepal_width'][:40]<br/>petal_length = iris_data['petal_length'][:40]<br/>petal_width=iris_data['petal_width'][:40]<br/>plt.bar(np.arange(length), sepal_length,label='sepal length' )<br/>plt.bar(np.arange(length), sepal_width, label='sepal width', bottom=sepal_length)<br/>plt.bar(np.arange(length), petal_length, label='petal width', bottom=sepal_length+sepal_width)<br/>plt.bar(np.arange(length), petal_width, label='petal length', bottom= sepal_length+sepal_width+petal_length)<br/>plt.legend(loc='best', fontsize=14, ncol=4)<br/>plt.xticks(ticks= np.arange(40))<br/>plt.title('Stacked bar chart', fontsize=20)<br/>plt.ylabel('Measure in cm', fontsize=16)</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/1cdafbf1266fd182d77391ae079d8203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmt3-z1ZA1ZKrNoUnwDy9A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="53c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">堆积条形图</strong>在同一图中用连续的条形()函数绘制。我们可以用它来可视化多个数据集并进行比较。在堆积条形图中，我们绘制了一个数据集相对于另一个数据集的值。x和Y坐标值将与之前相同。通过提供“bottom”关键字参数，您可以确保一个图不会掩盖之前绘制的图。它告诉matplotlib应该从y坐标的什么位置开始计数。“标签”的作用与线条或直方图相同。</p><p id="dad4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以水平绘制同样的柱状图。只需用barh()改变bar()，用left改变bottom参数。使用这种可视化，我们可以比较它们的值的范围。这里绘图显示一个花瓣长度值最小。在使用它来训练模型之前，我们可能必须将它们规范化。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c1be" class="kx ky hi kt b fi kz la l lb lc">data=iris_data.groupby('cluster').mean()<br/>group_width=0.8<br/>x=data.shape[0]<br/>plt.figure(figsize=(10,6))<br/>plt.bar(np.arange(x)- group_width/4, data['sepal_length'], width=group_width/4, label='Sepal length' )<br/>plt.bar(np.arange(x)-group_width/2, data['sepal_width'], width=group_width/4, label='Sepal width')<br/>plt.bar(np.arange(x) , data['petal_length'], width= group_width/4, label='Petal length')<br/>plt.bar(np.arange(x)+group_width/4, data['petal_width'], width=group_width/4, label='Petal width')<br/>plt.legend(loc='upper left', fontsize=14, ncol=2)<br/>plt.ylabel('Mean length/Width(in cm)', fontsize=14)<br/>plt.xlabel('Cluster', fontsize=14)<br/>plt.title('Grouped bar chart', fontsize=18)</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/402658708bc937c3b5847124a5cbe977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fdVtUHLc5rvyme8KkSK1Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="0225" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">组合条形图与堆积条形图几乎相同，但它不是一个一个地显示值，而是显示彼此平行的值。所有bar()函数的x坐标会不同。在第一个图中，X=np.arange(x)- group_width/4将在(0–0.8/4 =)-0.2(-0.2到0)处绘制萼片_长度，即蓝色条。在第二个条形图()中，函数X= np.arange(x)- group_width/2将在(0–0.8/2 =)-0.4(-0.4到-0.2)处绘制橙色条形图(sepal_width)。绿色条(花瓣长度)将从0到0.2，红色条(花瓣宽度)将从0.2到0.4)。下一组的橙色棒线将从(1–0.8/2 =)0.6到0.8开始。两组之间的间距为(1- group_width= ) 0.2。每个图的宽度应为组宽度的1/4，以消除歧义。两个条形图显示花瓣宽度具有最低值范围，萼片长度具有最高值，这是显而易见的。因此我们的数据是正确的。“width”参数控制条形的宽度。</p><p id="ca31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尝试在水平条形图中绘制相同的图。在堆积条形图中，您只需通过barh()更改bar()，通过left参数更改bottom参数。输出应该如下图所示。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/9cbe0f7b5d6b1bbbda3e9360277914ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gExW5IEvwpKx3YIxsYJEJw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">堆积条形图(水平)</figcaption></figure></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h2 id="496a" class="kx ky hi bd ld le lf lg lh li lj lk ll jg lm ln lo jk lp lq lr jo ls lt lu lv bi translated"><strong class="ak">饼状图</strong></h2><ul class=""><li id="53ba" class="jt ju hi ix b iy mb jc mc jg mh jk mi jo mj js mk jz ka kb bi translated">它代表整体的一部分。<br/> -仅显示单个数据集。<br/> -所有数值均显示为与360度圆相关的百分比。<br/> -每个楔形显示为不同的颜色。<br/> -百分比值相加为100%。<br/> -每个值的大小与值的总和成正比。<br/> -每个值被表示为数据集的切片。</li></ul><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/ff186d548690d47db2ab6c6ea754be93.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*Oh06i5X0AIQhtrhRYnni8w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="64b7" class="kx ky hi kt b fi kz la l lb lc">wedges=[38, 45, 56 ,78]<br/>plt.pie(wedges);</span></pre><p id="c1b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">饼图是用Pie()绘制的:一个必需的参数是dataset。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e328" class="kx ky hi kt b fi kz la l lb lc">labels=['Highly unsatisfied', 'unsatisfied','satisfied','Highly satisfied']</span><span id="e8c4" class="kx ky hi kt b fi lz la l lb lc">plt.pie(wedges, labels = labels, rotatelabels=True,           labeldistance=1.2, autopct='%0.2f%%');</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/7f1c52754b253d048729b654b6f9a332.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*uR592YGxJDZh9cW2Cm20Ug.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><ul class=""><li id="914c" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js mk jz ka kb bi translated">“labels”参数接受列表。默认情况下，它以相应的颜色显示标签。</li><li id="51a3" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mk jz ka kb bi translated">rotatelabels的参数接受布尔值。将标签旋转相应的角度。</li><li id="9886" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mk jz ka kb bi translated">“labeldistance”参数接受浮点值。它是半径=1时标签到圆心的距离。</li><li id="dde9" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mk jz ka kb bi translated">“autopct”参数接受格式字符串。它在圆圈内的楔形上显示百分比值。</li></ul><p id="3235" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据这个图，如果有两条没有太大差别的边。肉眼很难识别。为此matplotlib提供了“explode”参数。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9697" class="kx ky hi kt b fi kz la l lb lc">explosion = [0.3, 0, 0, 0]<br/>plt.pie(wedges, labels= labels, autopct="%0.2f%%", explode=explosion, radius=1.2)<br/>plt.savefig('pie3')</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/7ef538efa4306b1e96606c61f42e0786.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*ECAMzdt_2oO_6ckbF_JOZw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="bd65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“explode”参数接受浮点数组。浮点值显示了楔形分解的单位。值0.0不会分解楔形体。“radius”参数也接受浮点值。它控制圆的半径。</p><p id="09eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lx">实际例子</em></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ea9a" class="kx ky hi kt b fi kz la l lb lc">data= iris_data.groupby('cluster').count()<br/>data['count'] = data['sepal_length']<br/>wedges = data['count']<br/>labels= ['cluster 0', 'cluster 1', 'cluster 2', 'cluster 3', 'cluster 4', 'cluster 5', 'cluster 6']<br/>explosion = [0, 0.2, 0, 0,0, 0.2,0]<br/>plt.figure(figsize=(5,6))<br/>plt.pie(wedges, autopct="%0.2f%%", radius=1.5, explode=explosion, startangle=90)<br/>plt.legend(labels, loc=[1.2,0])<br/>plt.title('Percentage of flowers in different clusters',pad=30, fontsize=16)</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/998aa61cedbd37ab4d32afc337f06c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*acJQ0mE_vadOrWlyqOrjPQ.png"/></div></figure><ul class=""><li id="47b3" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js mk jz ka kb bi translated">“startangle”参数提供了绘制第一个楔形区的角度</li></ul><p id="507b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以看到这条直线现在是90度角。</p><ul class=""><li id="0b43" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js mk jz ka kb bi translated">title()函数中的“pad”参数为y轴上方的标题提供填充。它适用于教程中的所有地块。</li></ul></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h2 id="9324" class="kx ky hi bd ld le lf lg lh li lj lk ll jg lm ln lo jk lp lq lr jo ls lt lu lv bi translated">散点图</h2><p id="0001" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">散点图是matplotlib中使用最多的图。它显示各个点。秩序无关紧要。它显示了两个值之间的关系。在回归问题中，通过查看散点图，我们决定哪条曲线可以被拟合。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/e5abbc0896d4134277ed2fb0d36a237a.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*5GBHO0AdUlDSpEFZxAt46Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="f1b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它由scatter()函数绘制:</p><ul class=""><li id="dc2e" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js mk jz ka kb bi translated">两个必需的参数。</li><li id="7a01" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mk jz ka kb bi translated">首先是x轴。</li><li id="086b" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mk jz ka kb bi translated">第二个是y轴。</li></ul><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5bb4" class="kx ky hi kt b fi kz la l lb lc">x= np.linspace(0, 50, 30)<br/>y= np.log(x)<br/>plt.scatter(x, y)</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/e5abbc0896d4134277ed2fb0d36a237a.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*5GBHO0AdUlDSpEFZxAt46Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="cb88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使我们改变了点，这个图还是和上面一样。这表明顺序对于散点图是不重要的。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="cd5f" class="kx ky hi kt b fi kz la l lb lc">import random<br/>points = list(zip(x, y))<br/>random.shuffle(points)<br/>points = np.array(points)<br/>plt.scatter(points[:,0],<br/>points[:,1])</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/0edf166139eacde8f18eb2a28d30ab27.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*5RLcqoejH016WCqRQrKtOQ.png"/></div></figure><p id="49a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个图是用小噪声绘制的。对数曲线表明它能很好地拟合数据点。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ce7b" class="kx ky hi kt b fi kz la l lb lc">x= np.linspace(0, 50, 30)<br/>y= np.log(x)+np.random.randn(30)*0.3<br/>plt.scatter(x, y)<br/>plt.plot(x, np.log(x), c= 'r')</span></pre><p id="963e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lx">实际例子</em></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6308" class="kx ky hi kt b fi kz la l lb lc">iris_data['sepal_area'] = iris_data['sepal_length']*iris_data['sepal_width']<br/>iris_data['petal_area'] = iris_data['petal_length']*iris_data['petal_width']<br/>x= iris_data['sepal_area']<br/>y= iris_data['petal_area']<br/>plt.figure(figsize=(8,6))<br/>plt.scatter(x,y, c=iris_data['cluster'],s=iris_data['cluster']*15, cmap='hsv')<br/>plt.xlabel('Sepal area', fontsize=14)<br/>plt.ylabel('Petal area', fontsize=14)<br/>plt.title('Iris data clusters', fontsize=20)</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/5263ad6814ac642e36931efb405a0a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*o8xQFZmbZoPk_FHLmCV8NQ.png"/></div></figure><p id="6149" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过提供“s”参数，您可以控制每个点的大小。iris_data['cluster']的长度与点数相同。scatter()以迭代方式绘制每个点，因此每个点的大小可能不同。大小为绘图提供了额外的维度。c '参数也接受整数数组，给每个点不同的颜色。“c”参数用字符“c”连接整数，如C0、C1等。cmap的参数提供了C0、C1等的颜色。cmap的其他选项有'彩虹'，'地震'，'黄昏'，'移动_黄昏'，'等离子'这些是我经常使用的。还有更多选项可用，查看<a class="ae iu" href="https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="lx">文档</em> </strong> </a> <strong class="ix hj"> <em class="lx">。</em>T9】</strong></p><p id="e9de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想现在你可以放心地绘制基本的情节了。对于更多的自定义绘图检查matplotlib的文档，这是惊人的。</p></div></div>    
</body>
</html>