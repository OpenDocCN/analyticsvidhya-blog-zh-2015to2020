<html>
<head>
<title>Advanced NumPy for Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学的高级数字</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/advanced-numpy-218584c60c63?source=collection_archive---------3-----------------------#2020-08-16">https://medium.com/analytics-vidhya/advanced-numpy-218584c60c63?source=collection_archive---------3-----------------------#2020-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6785" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">启动您的数据科学之旅</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/6d576bd7f01159133d19f4de4202a1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*l0u9VaJUCE9kNcSqWVbsVA.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">礼貌-<a class="ae jj" href="https://github.com/isabela-pf" rel="noopener ugc nofollow" target="_blank">https://github.com/isabela-pf</a></figcaption></figure><p id="9a97" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们将讨论NumPy的一些高级概念，特别是处理实时数据集所需的函数和方法。这里涵盖的概念足以让您开始数据之旅。</p><p id="4ebd" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">要继续下去，你需要知道NumPy的基本概念，如果没有，我建议你阅读我的文章“<strong class="jm hj">NumPy-非常基础的</strong>！”<strong class="jm hj"> </strong>第一。你可以在本文末尾找到它的链接。</p><h2 id="ad76" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">内容</h2><ol class=""><li id="0999" class="lb lc hi jm b jn ld jq le jt lf jx lg kb lh kf li lj lk ll bi translated"><em class="lm">通用功能</em></li><li id="038b" class="lb lc hi jm b jn ln jq lo jt lp jx lq kb lr kf li lj lk ll bi translated"><em class="lm">聚合</em></li><li id="8143" class="lb lc hi jm b jn ln jq lo jt lp jx lq kb lr kf li lj lk ll bi translated"><em class="lm">广播</em></li><li id="6995" class="lb lc hi jm b jn ln jq lo jt lp jx lq kb lr kf li lj lk ll bi translated"><em class="lm">屏蔽</em></li><li id="3739" class="lb lc hi jm b jn ln jq lo jt lp jx lq kb lr kf li lj lk ll bi translated"><em class="lm">花式索引</em></li><li id="8ed9" class="lb lc hi jm b jn ln jq lo jt lp jx lq kb lr kf li lj lk ll bi translated"><em class="lm">数组排序</em></li></ol><h2 id="d546" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">NumPy中的通用函数有哪些？</h2><p id="d85f" class="pw-post-body-paragraph jk jl hi jm b jn ld ij jp jq le im js jt ls jv jw jx lt jz ka kb lu kd ke kf hb bi translated">大多数情况下，我们必须循环遍历数组，对每个数组元素执行简单的计算，如加、减、除等。由于这些都是重复的操作，计算时间会随着相对较大的数据而增加。幸运的是，NumPy通过使用矢量化运算加快了速度，通常通过<strong class="jm hj"> NumPy的通用函数(ufuncs)来实现。</strong>我们用一个例子来了解一下。</p><p id="cbd7" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">假设我们有一个1到10之间的随机整数数组，并且想要得到数组中每个元素的平方。我们用Python知识做的是:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/0fe0b6885fea629942dfdd420bb8717d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9YNlPR9cCjJA2rgmxtbDGA.png"/></div></div></figure><p id="eef3" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这需要大量的时间来编写和计算，尤其是对于真实数据集中的大型数组。让我们看看ufuncs是如何让这两种方式都变得更简单的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ma"><img src="../Images/4aacb991b2b6e811e047d89816f95d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*aNqYNozEbrbS__qy-gCvQg.png"/></div></figure><p id="bb1a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">只需在数组上执行一个操作，它就会应用到数组中的每个元素。我们注意到<strong class="jm hj">也保留了数据类型</strong>。Ufunc操作极其灵活。我们也可以在两个数组之间执行操作。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mb"><img src="../Images/c272b6be6122ac5f862ca745b12bf888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*ZlnwCnC8GahnB5SmnUa4nw.png"/></div></figure><p id="65e5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">所有这些算术运算都是围绕NumPy内置函数的<strong class="jm hj">包装器</strong>。例如，+运算符是add函数的包装器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mc"><img src="../Images/88ecc2cb3592126dd40054bdcc8a9d40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*NbSqRSe7t8RzR782QMdMBQ.png"/></div></figure><blockquote class="md me mf"><p id="bc86" class="jk jl lm jm b jn jo ij jp jq jr im js mg ju jv jw mh jy jz ka mi kc kd ke kf hb bi translated">下面是NumPy中所有算术运算的汇总表。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mj"><img src="../Images/ff4d628e40dda342482b5eab45f3d2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DosepNnzQbNJ7fKZA5zitg.png"/></div></div></figure><p id="a2ee" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">NumPy提供的一些最有用的函数是三角函数、对数函数和指数函数。作为数据科学家，我们应该意识到这一点。这些将在处理真实数据集时派上用场。</p><div class="iy iz ja jb fd ab cb"><figure class="mk jc ml mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/96b75fc60f39d08aeefe30866c0e2df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*0VrbLaMtcR6oXnr2Tbwxig.png"/></div></figure><figure class="mk jc mq mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/e5b7fbf190cf23d9d3c17a13c43e280b.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*PBlOxHvEnr57ak-kbFsgrA.png"/></div></figure></div><div class="ab cb"><figure class="mk jc mr mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/381a4fcfbbf21a7bc793102494838c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*vbSuzGT7-0SFRARIl-nuCQ.png"/></div></figure><figure class="mk jc ms mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/212ff61eddc0d2be794c613768868508.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*9T5nt7uoKoSmE0zrz_pvEw.png"/></div></figure></div><h2 id="b284" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">聚合</h2><p id="7918" class="pw-post-body-paragraph jk jl hi jm b jn ld ij jp jq le im js jt ls jv jw jx lt jz ka kb lu kd ke kf hb bi translated">作为数据分析师或数据科学家，第一步是探索和理解数据。一种方法是计算汇总统计数据。虽然总结数据最常用的统计方法是<strong class="jm hj">平均值和标准偏差</strong>，但其他总量也是有用的，如总和、乘积、中值、最大值、最小值等。</p><p id="f157" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">让我们通过计算总和、最小值和最大值的例子来理解。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mt"><img src="../Images/c2298dc6eb0b344cbccc2833023a4073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0tgC2Sh276Ue37om1ISkw.png"/></div></div></figure><p id="153d" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">对于大多数NumPy集合，简化的语法是使用数组对象的方法，而不是函数。上述操作也可以如下所示执行，这在计算上没有区别。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mu"><img src="../Images/4b864f323ab1f3c6b6e60c2d17cbcec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rez-Arop87Nwtz6f8ycVRQ.png"/></div></div></figure><blockquote class="md me mf"><p id="59e5" class="jk jl lm jm b jn jo ij jp jq jr im js mg ju jv jw mh jy jz ka mi kc kd ke kf hb bi translated"><strong class="jm hj">重要提示</strong>-Python集合函数和NumPy集合函数的区别</p></blockquote><p id="a3d1" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">您可以提出的一个问题是，当这些函数已经内置在Python中时，为什么还要使用NumPy聚合函数(sum()、min()、max()等)。当然，区别在于NumPy函数要快得多，但更重要的是<strong class="jm hj"> NumPy函数知道维度。</strong> Python函数在多维数组上表现不同。</p><p id="56fe" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">假设我们想得到一个大小为2x5的数组中的所有元素。为了更好地理解，我们将从0到9取一个简单的数字数组。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mv"><img src="../Images/ba85a5dd2fbffe73d11076b858fd243b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*fBfDOu1t4zJd12XmTc45nw.png"/></div></figure><p id="4e5f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们期望输出是45 (0+1+2+3+4+5+6+7+8+9 ),但是结果非常出乎意料。这类结果在汇总数据时会花费很多。因此，在处理数组时，一定要确保使用聚合函数的NumPy版本。</p><blockquote class="md me mf"><p id="430a" class="jk jl lm jm b jn jo ij jp jq jr im js mg ju jv jw mh jy jz ka mi kc kd ke kf hb bi translated">多维聚合体</p></blockquote><p id="2e05" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">一种常见的操作类型是沿行和列聚合。因为NumPy函数知道维度，所以这样做更容易，例如，每行和每列中的最小值。函数接受一个额外的参数，该参数指定我们希望执行聚合的轴。</p><p id="df16" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">假设我们有一个学生分数表，每一列代表一个不同的主题。我们希望找到每个科目的最低和最高分数以及每个学生的总分。<strong class="jm hj">‘axis = 0’指定按列操作，而‘axis = 1’指定按行操作。</strong>结果将是一个一维数组。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mw"><img src="../Images/78d64e4f40897139cd188823c78c581f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVBlY-Svo6QRVD48acr0Vw.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es et"><img src="../Images/767c504a1fe9cb82c595728084a1deed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8_8q_yFkd1jn-HEvbaM7w.png"/></div></div></figure><blockquote class="md me mf"><p id="52ea" class="jk jl lm jm b jn jo ij jp jq jr im js mg ju jv jw mh jy jz ka mi kc kd ke kf hb bi translated">NumPy的其他聚合函数</p></blockquote><p id="cec1" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">np.prod，np.mean，np.std，np.var，np.argmin(查找最小值的索引)，np.argmax(查找最大值的索引)，np.median，np.percentile(计算基于秩的元素统计)。</p><h2 id="6e1b" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">广播</h2><p id="bf2a" class="pw-post-body-paragraph jk jl hi jm b jn ld ij jp jq le im js jt ls jv jw jx lt jz ka kb lu kd ke kf hb bi translated">一开始我们已经看到了NumPy通用函数。广播是应用ufuncs的另一种方式，但是是在不同大小的阵列上。广播只不过是NumPy应用于<strong class="jm hj">在不同大小的数组</strong>上执行unfuncs的一组规则。</p><p id="09aa" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">考虑添加两个3x3和1x3大小的数组。就我们的理解而言，我们可以将这种操作视为拉伸或广播较小的数组以匹配较大数组的大小。这个数组的拉伸实际上并没有发生，这只是为了更好的理解。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mx"><img src="../Images/42639baceae54ebef394f5044b19e2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*RF1b24aI5Wut2tH9HfvQlQ.png"/></div></figure><p id="55a0" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">当两个阵列都需要广播时，混乱和复杂性增加。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es my"><img src="../Images/fa52667d390c2875df6244275a789a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*SaOP3c1psEANEbzvTcTOgg.png"/></div></figure><p id="ddf5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">《Python数据科学手册》一书的作者Jake VanderPlas提供了极好的可视化来解释这一过程。浅色框表示拉伸的值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mz"><img src="../Images/106ac9c8f01cf6c15698968b0185436b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*kwgQUvyF2eKjY6_eMhwsqQ.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">Source-Python for data science手册</figcaption></figure><blockquote class="md me mf"><p id="e552" class="jk jl lm jm b jn jo ij jp jq jr im js mg ju jv jw mh jy jz ka mi kc kd ke kf hb bi translated">3广播规则</p></blockquote><p id="004e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">以上是逻辑想象理解。我们将结合实例探讨理论规律。</p><p id="c570" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">示例1:</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="8c55" class="kg kh hi nb b fi nf ng l nh ni"><em class="lm">m = np.arange(3).reshape((3,1))<br/>n = np.arange(3)<br/>m.shape = (3, 1)<br/>n.shape = (3,)</em></span><span id="5104" class="kg kh hi nb b fi nj ng l nh ni"><strong class="nb hj"><em class="lm">By rule 1, if two arrays differ in their shape the array with lesser shape should be padded with ‘1’ on its left side. Padding is done only of left side</em></strong></span><span id="370e" class="kg kh hi nb b fi nj ng l nh ni"><em class="lm">m.shape =&gt; (3, 1)<br/>n.shape =&gt; (1, 3)</em></span><span id="54b3" class="kg kh hi nb b fi nj ng l nh ni"><strong class="nb hj"><em class="lm">By rule 2, if still the shape of two arrays do not match then each array whose dimension is equal to 1 should be broadcasted to match the shape of other array.</em></strong></span><span id="577f" class="kg kh hi nb b fi nj ng l nh ni"><em class="lm">m.shape =&gt; (3, 3)<br/>n.shape =&gt; (3, 3)</em></span></pre><p id="4f06" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">强调规则2，它说只有当数组的一个维度的值为1时，我们才能拉伸数组。对于1以外的维值，我们不能这样做。让我们看一个例子，在应用规则2的过程中，数组形状的维数将不同于1。</p><p id="3244" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">示例2:</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="596b" class="kg kh hi nb b fi nf ng l nh ni"><em class="lm">m = np.arange(3).reshape((3,2))<br/>n = np.arange(3)<br/>m.shape = (3, 1)<br/>n.shape = (3,)</em></span><span id="1428" class="kg kh hi nb b fi nj ng l nh ni"><strong class="nb hj"><em class="lm">By rule 1,</em></strong></span><span id="52d5" class="kg kh hi nb b fi nj ng l nh ni"><em class="lm">m.shape =&gt; (3, 2)<br/>n.shape =&gt; (1, 3)</em></span><span id="52ed" class="kg kh hi nb b fi nj ng l nh ni"><strong class="nb hj"><em class="lm">By rule 2,</em></strong></span><span id="d598" class="kg kh hi nb b fi nj ng l nh ni"><em class="lm">m.shape =&gt; (3, 2)<br/>n.shape =&gt; (3, 3)<br/></em><strong class="nb hj"><em class="lm">Note: we can streatch only when value is 1.</em></strong></span><span id="0472" class="kg kh hi nb b fi nj ng l nh ni"><strong class="nb hj"><em class="lm">By rule 3, if shapes of both arrays disagree and any dimension of neither array is 1 then an error should be raised.</em></strong></span></pre><h2 id="489d" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">掩饰</h2><p id="ea9a" class="pw-post-body-paragraph jk jl hi jm b jn ld ij jp jq le im js jt ls jv jw jx lt jz ka kb lu kd ke kf hb bi translated">屏蔽是数据处理中广泛使用的一种方法。它允许我们提取，计数，修改或操作基于特定标准的数组中的值，这些标准是使用比较运算符和布尔运算符指定的。</p><p id="93bd" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">假设我们有一个大小为(3，4)的二维数组，我们希望得到数组中值小于5的子集。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mx"><img src="../Images/c1af3b42309c10533331a5567359c8b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*3VzTbKlc53ElwQWY1ymSmQ.png"/></div></figure><blockquote class="md me mf"><p id="47ef" class="jk jl lm jm b jn jo ij jp jq jr im js mg ju jv jw mh jy jz ka mi kc kd ke kf hb bi translated">我们来分解一下</p></blockquote><p id="f63d" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们使用了一个比较运算符'</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es nk"><img src="../Images/9457d4aa0e4a409cd654c769281de82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*t7XSn9qqgfif-VtFXicqzg.png"/></div></div></figure><p id="5fdf" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">When we say x[x&lt;5], the above returned boolean values are applied on original array x resulting to return the elements of the array whose indices are True, eventually values less than 5. Similar way we can use all the comparison or boolean operators available in Python. We can even combine two operations say <strong class="jm hj">x[(x&gt;3)&amp;(x&lt;6)]【T1]来获取3和6之间的值，只是运算的结果应该是布尔型的。注意，这里我们使用了按位运算符'&amp;'，而不是关键字' and '。</strong></p><blockquote class="md me mf"><p id="6035" class="jk jl lm jm b jn jo ij jp jq jr im js mg ju jv jw mh jy jz ka mi kc kd ke kf hb bi translated"><strong class="jm hj">还记得</strong>吗</p><p id="7700" class="jk jl lm jm b jn jo ij jp jq jr im js mg ju jv jw mh jy jz ka mi kc kd ke kf hb bi translated">关键字“and”和“or”对整个数组执行单个布尔运算，而按位“&amp;”和“|”对数组的元素执行多个布尔运算。<strong class="jm hj">屏蔽时始终使用逐位运算符。</strong></p></blockquote><h2 id="5ad7" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">花式索引</h2><p id="4786" class="pw-post-body-paragraph jk jl hi jm b jn ld ij jp jq le im js jt ls jv jw jx lt jz ka kb lu kd ke kf hb bi translated">正如我们已经知道的，花式索引类似于普通索引。唯一的区别是我们在这里传递了一个索引数组。这种高级版本的索引允许快速访问和/或修改数组的复杂子集。</p><p id="e50e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">假设我们想要访问一个数组的索引2、5和9处的元素，旧的方法应该是[x[2]，x[5]，x[9]]。这可以用有趣的索引来简化。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nl"><img src="../Images/f41f0993c0fc8edb8f8ae56b68c85c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*qd3Z7CrN5ea-YsVNU7moow.png"/></div></figure><p id="0ed8" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">同样，我们可以想象索引二维数组。我们来看看花式索引中x[0，2]，x[1，3]和x[2，1]的等价运算。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nm"><img src="../Images/0af3e4aaf8174ae7d15ac322ca5663b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*Br3HY6dy5gqH9U8sr7RquA.png"/></div></figure><p id="2797" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如果行或列值是常数，这可以进一步简化。假设我们想得到索引x[2，1]，x[2，3]和x[2，4]处的值。下面的黄色突出显示用于行值，蓝色用于列值。类似地，我们也可以通过赋值操作符' = '使用花哨的索引来修改值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nn"><img src="../Images/de4690f288150f2ef29a38d2a6551ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*HXWfNsdeZ0RwZkWAAMYPbw.png"/></div></figure><h2 id="b78a" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">数组排序</h2><p id="c5a6" class="pw-post-body-paragraph jk jl hi jm b jn ld ij jp jq le im js jt ls jv jw jx lt jz ka kb lu kd ke kf hb bi translated">np.sort是一个比Python内置排序函数更高效的排序函数。另外，<strong class="jm hj"> np.sort知道维度</strong>。让我们看看NumPy排序函数的几种风格。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es no"><img src="../Images/e20e39d6038bc97d53c4d62111119916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*HjUAwhSUeAsuXbbY3s3RuQ.png"/></div></figure><p id="4211" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">注意，当我们使用sort()方法时，它改变了数组x本身的值。意思是，数组x的原始顺序丢失了。叫做<strong class="jm hj">原地排序</strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es np"><img src="../Images/b2e7f3b350480eb13a04ab59e8468f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vJ1_HZAo5PAaaq6z"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">由<a class="ae jj" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae jj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="07d8" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">虽然这些不是NumPy的唯一概念，但我还是设法涵盖了所有关键的和必须知道的概念。这对于数据科学入门来说显然绰绰有余。由于Python是开源的，许多函数会定期添加和删减。时刻关注<a class="ae jj" href="https://numpy.org/doc/stable/" rel="noopener ugc nofollow" target="_blank"> NumPy的官方文档</a>。我还会确保在需要时不断更新内容。</p></div><div class="ab cl nq nr gp ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="hb hc hd he hf"><p id="ebcc" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如果你在理解这些概念时遇到困难，请先阅读下面的文章。</p><div class="nx ny ez fb nz oa"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/numpy-the-very-basics-6ce19206ee22"><div class="ob ab dw"><div class="oc ab od cl cj oe"><h2 class="bd hj fi z dy of ea eb og ed ef hh bi translated">NumPy -最基本的！</h2><div class="oh l"><h3 class="bd b fi z dy of ea eb og ed ef dx translated">这篇文章是为那些对NumPy一无所知的人写的，这样他们就可以掌握一些入门知识。</h3></div><div class="oi l"><p class="bd b fp z dy of ea eb og ed ef dx translated">medium.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo jd oa"/></div></div></a></div><p id="05fc" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">让我们连接</p><div class="nx ny ez fb nz oa"><a href="https://www.linkedin.com/in/sujan-shirol/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab dw"><div class="oc ab od cl cj oe"><h2 class="bd hj fi z dy of ea eb og ed ef hh bi translated">Sujan Shirol -技术作家- Python开发者| LinkedIn</h2><div class="oh l"><h3 class="bd b fi z dy of ea eb og ed ef dx translated">查看Sujan Shirol在世界上最大的职业社区LinkedIn上的个人资料。Sujan有两个工作列在他们的…</h3></div><div class="oi l"><p class="bd b fp z dy of ea eb og ed ef dx translated">www.linkedin.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo jd oa"/></div></div></a></div></div></div>    
</body>
</html>