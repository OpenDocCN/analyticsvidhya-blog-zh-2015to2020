<html>
<head>
<title>How Google Search Works? Page Rank Algorithm using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌搜索是如何工作的？使用Python的页面排序算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-google-search-works-page-rank-algorithm-using-python-9643d9c9a981?source=collection_archive---------1-----------------------#2020-05-09">https://medium.com/analytics-vidhya/how-google-search-works-page-rank-algorithm-using-python-9643d9c9a981?source=collection_archive---------1-----------------------#2020-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cc3d755af202b692560adc22a2bd6e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TwkhHIIHdLWCuMtA"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">谷歌搜索引擎</figcaption></figure><p id="0639" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">PageRank (PR)是谷歌搜索使用的一种算法，用于在其搜索引擎结果中对网站进行排名。PageRank是以谷歌创始人之一拉里·佩奇的名字命名的。PageRank是衡量网站页面重要性的一种方式。根据谷歌的说法:</p><p id="451d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">PageRank的工作原理是通过计算一个页面的链接数量和质量来粗略估计该网站的重要性。潜在的假设是，更重要的网站可能会从其他网站收到更多的链接。</p><blockquote class="js jt ju"><p id="0711" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">它不是谷歌用来排序搜索引擎结果的唯一算法，但它是该公司使用的第一个算法，也是最知名的算法。</p></blockquote><h1 id="3a2e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使用python的Page Ranker算法:-</h1><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/b691b0825c53bfd3e04d2f194f4ef5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*S8x3TYd5ApMb7CuO.jpg"/></div></figure><ol class=""><li id="b667" class="lc ld hi iw b ix iy jb jc jf le jj lf jn lg jr lh li lj lk bi translated">谷歌的每个网页都被存储为一个图中的一个节点</li><li id="ecbd" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">链接/指向其他节点的每条边都是该网页中的超链接</li><li id="a824" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">基于这一点，图表看起来就像上面说明的图像</li><li id="baba" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">截至目前，活跃网站的数量接近<strong class="iw hj"> 1，769，486，964。</strong>所以会有数十亿个节点与图相连。出于实现的目的，我使用了25个节点。将有数万亿条边连接到谷歌使用的图形。</li><li id="8c63" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">所以首先让我们为这个实现导入必要的库</li></ol><pre class="ky kz la lb fd lq lr ls lt aw lu bi"><span id="6b24" class="lv ka hi lr b fi lw lx l ly lz">import networkx as nx<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import operator<br/>import random as rd</span></pre><p id="c321" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">6.现在使用networkx库生成一个有25个节点的图。这里我们将概率设置为0.6，这是一个图中两个节点之间有边的概率。</p><pre class="ky kz la lb fd lq lr ls lt aw lu bi"><span id="e815" class="lv ka hi lr b fi lw lx l ly lz"># created a directed graph<br/>graph=nx.gnp_random_graph(25,0.6,directed=True)</span><span id="e3c0" class="lv ka hi lr b fi ma lx l ly lz">#draw a graph<br/>nx.draw(graph,with_labels=True,font_color='red',font_size=10,node_color='yellow')</span><span id="9ae0" class="lv ka hi lr b fi ma lx l ly lz">#plot a graph<br/>plt.show()</span></pre><p id="bca5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">生成的输出图如下所示:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/d1ec7a38d9ac872d23fa107e59ce6380.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*-KQGvTjdNsRyCEp4EBCroQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">生成的图形</figcaption></figure><p id="d9a8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">7.现在让我们存储特定节点的节点和邻居的数量，这将是算法的进一步实现所需要的。</p><pre class="ky kz la lb fd lq lr ls lt aw lu bi"><span id="1469" class="lv ka hi lr b fi lw lx l ly lz">#number of nodes for graph</span><span id="6b96" class="lv ka hi lr b fi ma lx l ly lz">count=graph.number_of_nodes()</span><span id="997c" class="lv ka hi lr b fi ma lx l ly lz">#graph neighbours of a node 1</span><span id="2f5b" class="lv ka hi lr b fi ma lx l ly lz">print(<em class="jv">list</em>(graph.neighbors(1)))</span></pre><p id="b363" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上述单元的输出是:</p><pre class="ky kz la lb fd lq lr ls lt aw lu bi"><span id="932f" class="lv ka hi lr b fi lw lx l ly lz">[2, 3, 4, 5, 6, 10, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 23, 24]</span></pre><p id="acaf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">8.现在，我们需要从一个随机节点开始，遍历它的邻居节点并增加分数，从而为每个节点生成一个随机遍历分数。现在为了实现，我重复这个过程500000次。</p><pre class="ky kz la lb fd lq lr ls lt aw lu bi"><span id="33a5" class="lv ka hi lr b fi lw lx l ly lz">#Page Rank Algorithm-Calculating random walk score</span><span id="1c8e" class="lv ka hi lr b fi ma lx l ly lz">#initialising the dictionary which contains key as node and value as random walk score</span><span id="10c1" class="lv ka hi lr b fi ma lx l ly lz">rank_dict={}</span><span id="652e" class="lv ka hi lr b fi ma lx l ly lz"># taking a random node as the starting node:</span><span id="a3a5" class="lv ka hi lr b fi ma lx l ly lz">x=rd.randint(0,25)</span><span id="7753" class="lv ka hi lr b fi ma lx l ly lz">#Setting random walk score of each node to zero</span><span id="2a3c" class="lv ka hi lr b fi ma lx l ly lz">for j in range(0,25):<br/>  rank_dict[j]=0</span><span id="cdaa" class="lv ka hi lr b fi ma lx l ly lz">#Incrementing score of starting node</span><span id="301c" class="lv ka hi lr b fi ma lx l ly lz">rank_dict[x]=rank_dict[x]+1</span><span id="211d" class="lv ka hi lr b fi ma lx l ly lz">#iterating process for 50000 times and updating score</span><span id="4615" class="lv ka hi lr b fi ma lx l ly lz">for i in range(500000):<br/>  #storing list of neighboring nodes in list<br/>  list_n=<em class="jv">list</em>(graph.neighbors(x))<br/>  #if length of list is zero then taking another node and process starts<br/>  if(len(list_n)==0):<br/>    x=rd.randint(0,25)<br/>    rank_dict[x]=rank_dict[x]+1</span><span id="6307" class="lv ka hi lr b fi ma lx l ly lz">  #else choose any node from the list and continue the process by updating score to that node<br/>  else:<br/>    x=rd.choice(list_n)<br/>    rank_dict[x]=rank_dict[x]+1<br/>print("Random Walk Score Updated")</span></pre><p id="2f1d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">8.一旦我们得到了存储在字典中的分数，我们需要通过将随机漫步分数除以迭代次数来标准化分数。</p><pre class="ky kz la lb fd lq lr ls lt aw lu bi"><span id="4a88" class="lv ka hi lr b fi lw lx l ly lz">#normalising values</span><span id="810e" class="lv ka hi lr b fi ma lx l ly lz">for j in range(0,25):<br/>  rank_dict[j]=rank_dict[j]/500000</span></pre><p id="9ff8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">9.现在让我们通过使用networkx库中的内置函数pagerank来获得该图的随机分数，并根据分数对获得的字典进行排序。</p><pre class="ky kz la lb fd lq lr ls lt aw lu bi"><span id="5ecd" class="lv ka hi lr b fi lw lx l ly lz">#Page rank by networkx library<br/>pagerank=nx.pagerank(graph)</span><span id="5bd3" class="lv ka hi lr b fi ma lx l ly lz">#sorting both dictionaries based on items<br/>pagerank_sorted=sorted(pagerank.items(),key=<em class="jv">lambda</em> v:(v[1],v[0]),reverse=True)</span></pre><p id="54c9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">10.现在对我们用算法生成的字典进行排序并存储。</p><pre class="ky kz la lb fd lq lr ls lt aw lu bi"><span id="fc6c" class="lv ka hi lr b fi lw lx l ly lz">#sorting the rank_dict based on values</span><span id="b251" class="lv ka hi lr b fi ma lx l ly lz">rank_dict_sorted=sorted(rank_dict.items(),key=<em class="jv">lambda</em> v:(v[1],v[0]),reverse=True)</span></pre><p id="2a00" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，让我们比较两个结果:-</p><pre class="ky kz la lb fd lq lr ls lt aw lu bi"><span id="1ad8" class="lv ka hi lr b fi lw lx l ly lz">#display the order<br/>print("The order generated by our implementation algorithm is\n")for i in rank_dict_sorted:<br/>  print(i[0],end=" ")<br/>print("\n\nThe order generated by networkx library is\n")<br/>for i in pagerank_sorted:<br/>  print(i[0],end=" ")</span></pre><p id="776d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">11.输出是:-</p><p id="257f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的实现算法生成的顺序是</p><p id="4b37" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi">22 11 23 10 3 6 18 14 5 21 19 15 13 8 0 4 9 17 24 1 12 16 2 7 20</p><p id="1aee" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">networkx库生成的顺序是</p><p id="a5fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi">22 11 23 10 3 6 18 5 14 21 19 15 13 8 4 0 9 17 24 1 12 16 2 7 20</p><p id="2dd8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">几乎是一样的。</p><h1 id="344e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论:-</h1><p id="39ea" class="pw-post-body-paragraph iu iv hi iw b ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn mg jp jq jr hb bi translated">这样，谷歌搜索排名就是靠页面排名算法来工作的。</p><p id="b4f9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你想在源代码方面得到更多的帮助，你可以查看下面的要点</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="dd7e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">谢谢你。</p></div></div>    
</body>
</html>