<html>
<head>
<title>Machine Learning In Node.js With TensorFlow.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TensorFlow.js在Node.js中进行机器学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-in-node-js-with-tensorflow-js-844cf0fd20ae?source=collection_archive---------0-----------------------#2018-08-07">https://medium.com/analytics-vidhya/machine-learning-in-node-js-with-tensorflow-js-844cf0fd20ae?source=collection_archive---------0-----------------------#2018-08-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/104df57b831d1d0d0cddb8664006d337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAiolrEtfiuEq4lMNS6OEA.png"/></div></div></figure><h2 id="dc78" class="hr hs ht bd b fp hu hv hw hx hy hz dx ia translated" aria-label="kicker paragraph">TF-JS</h2><div class=""/><p id="7a78" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">使用Tensorflow.js实现图像分类器的简单示例</p><p id="5ece" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><a class="ae jx" href="https://js.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow.js </a>是流行的开源库的新版本，它为JavaScript带来了深度学习。开发人员现在可以使用<a class="ae jx" href="https://js.tensorflow.org/api/0.12.0/" rel="noopener ugc nofollow" target="_blank">高级库API </a>来定义、训练和运行机器学习模型。</p><p id="d679" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><a class="ae jx" href="https://github.com/tensorflow/tfjs-models/" rel="noopener ugc nofollow" target="_blank">预先训练的模型</a>意味着开发人员现在可以轻松地执行复杂的任务，如<a class="ae jx" href="https://emojiscavengerhunt.withgoogle.com/" rel="noopener ugc nofollow" target="_blank">视觉识别</a>、<a class="ae jx" href="https://magenta.tensorflow.org/demos/performance_rnn/index.html#2%7C2,0,1,0,1,1,0,1,0,1,0,1%7C1,1,1,1,1,1,1,1,1,1,1,1%7C1,1,1,1,1,1,1,1,1,1,1,1%7Cfalse" rel="noopener ugc nofollow" target="_blank">生成音乐</a>或<a class="ae jx" href="https://storage.googleapis.com/tfjs-models/demos/posenet/camera.html" rel="noopener ugc nofollow" target="_blank">检测人类姿势</a>只需几行JavaScript。</p><p id="1b8f" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">作为web浏览器的前端库，最近的更新增加了对Node.js的实验性支持，这使得TensorFlow.js可以在后端JavaScript应用程序中使用，而不必使用Python。</p><p id="20de" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="jy">读到关于这个库的内容，我想用一个简单的任务来测试一下……</em>🧐</p><blockquote class="jz ka kb"><p id="46f0" class="iz ja jy jb b jc jd je jf jg jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv jw hb bi translated"><strong class="jb id"> <em class="ht">使用TensorFlow.js从Node.js </em> </strong>使用JavaScript对图像进行视觉识别</p></blockquote><p id="8c1e" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">不幸的是，提供的大多数<a class="ae jx" href="https://js.tensorflow.org/#getting-started" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae jx" href="https://js.tensorflow.org/tutorials/webcam-transfer-learning.html" rel="noopener ugc nofollow" target="_blank">示例代码</a>都在浏览器中使用这个库。<a class="ae jx" href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet" rel="noopener ugc nofollow" target="_blank">为简化加载和使用预训练模型而提供的项目实用程序</a>尚未扩展Node.js支持。完成这项工作的最终结果是我花了很多时间阅读库的Typescript源文件。👎</p><p id="0f55" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">然而，经过几天的黑客，我设法得到了<a class="ae jx" href="https://gist.github.com/jthomas/145610bdeda2638d94fab9a397eb1f1d" rel="noopener ugc nofollow" target="_blank">这个完成的</a>！万岁！🤩</p><p id="6481" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在深入研究代码之前，让我们先来概述一下不同的TensorFlow库。</p><h1 id="4c71" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">张量流</h1><p id="79c4" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated"><a class="ae jx" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>是一个面向机器学习应用的开源软件库。TensorFlow可用于实现神经网络和其他深度学习算法。</p><p id="557f" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">TensorFlow于2015年11月由谷歌发布，最初是一个<a class="ae jx" href="https://www.tensorflow.org/api_docs/python/" rel="noopener ugc nofollow" target="_blank"> Python库</a>。它使用基于CPU或GPU的计算来训练和评估机器学习模型。该库最初被设计为在具有昂贵GPU的高性能服务器上运行。</p><p id="14bf" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">最近的更新扩展了该软件，使其可以在移动设备和网络浏览器等资源受限的环境中运行。</p><h1 id="da5c" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">TensorFlow Lite</h1><p id="2c04" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated"><a class="ae jx" href="https://www.tensorflow.org/mobile/tflite/" rel="noopener ugc nofollow" target="_blank">面向移动和嵌入式设备的轻量级版本库Tensorflow Lite </a>于2017年5月发布。这伴随着一系列新的预训练深度学习模型，用于视觉识别任务，称为<a class="ae jx" href="https://ai.googleblog.com/2017/06/mobilenets-open-source-models-for.html" rel="noopener ugc nofollow" target="_blank"> MobileNet </a>。MobileNet模型设计用于在资源受限的环境中高效工作，如移动设备。</p><h1 id="ab90" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">TensorFlow.js</h1><p id="b2e7" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated">继Tensorflow Lite之后，<a class="ae jx" rel="noopener" href="/tensorflow/introducing-tensorflow-js-machine-learning-in-javascript-bf3eab376db"> TensorFlow.js </a>于2018年3月公布。这个版本的库被设计为在浏览器中运行，构建在一个名为<a class="ae jx" href="https://twitter.com/deeplearnjs" rel="noopener ugc nofollow" target="_blank"> deeplearn.js </a>的早期项目上。WebGL提供了对库的GPU访问。开发人员使用JavaScript API来训练、加载和运行模型。</p><p id="87a1" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">TensorFlow.js最近被扩展为在Node.js上运行，使用了一个名为<code class="du li lj lk ll b">tfjs-node</code>的<a class="ae jx" href="https://github.com/tensorflow/tfjs-node" rel="noopener ugc nofollow" target="_blank">扩展库</a>。</p><p id="28d3" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">Node.js扩展是一个alpha版本，仍在积极开发中。</p><h2 id="9095" class="lm kg ht bd kh ln lo lp kl lq lr ls kp jk lt lu kt jo lv lw kx js lx ly lb hz bi translated">将现有模型导入TensorFlow.js</h2><p id="58d8" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated">可以使用TensorFlow.js库执行现有的TensorFlow和Keras模型。模型需要在执行前使用此工具转换成新的格式<a class="ae jx" href="https://github.com/tensorflow/tfjs-converter" rel="noopener ugc nofollow" target="_blank">。Github </a>上提供了用于图像分类、姿态检测和k近邻的预训练和转换模型<a class="ae jx" href="https://github.com/tensorflow/tfjs-models" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="81da" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">在Node.js中使用TensorFlow.js</h1><h1 id="0512" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">安装TensorFlow库</h1><p id="cef7" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated">TensorFlow.js可以从<a class="ae jx" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM注册表</a>安装。</p><pre class="lz ma mb mc fd md ll me mf aw mg bi"><span id="c23a" class="lm kg ht ll b fi mh mi l mj mk">npm install @tensorflow/tfjs @tensorflow/tfjs-node // or... npm install @tensorflow/tfjs @tensorflow/tfjs-node-gpu</span></pre><p id="6249" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这两个Node.js扩展都使用将按需编译的本机依赖项。</p><p id="23c3" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">TensorFlow的<a class="ae jx" href="https://js.tensorflow.org/api/0.12.0/" rel="noopener ugc nofollow" target="_blank"> JavaScript API </a>从核心库暴露出来。启用Node.js支持的扩展模块不公开额外的API。</p><p id="7605" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">TensorFlow.js提供了一个<a class="ae jx" href="https://github.com/tensorflow/tfjs-models" rel="noopener ugc nofollow" target="_blank"> NPM库</a> ( <code class="du li lj lk ll b">tfjs-models</code>)，以方便加载预先训练好的&amp;转换模型，用于<a class="ae jx" href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet" rel="noopener ugc nofollow" target="_blank">图像分类</a>、<a class="ae jx" href="https://github.com/tensorflow/tfjs-models/tree/master/posenet" rel="noopener ugc nofollow" target="_blank">姿态检测</a>和<a class="ae jx" href="https://github.com/tensorflow/tfjs-models/tree/master/knn-classifier" rel="noopener ugc nofollow" target="_blank"> k近邻</a>。</p><p id="1978" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">用于图像分类的<a class="ae jx" href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet" rel="noopener ugc nofollow" target="_blank"> MobileNet模型</a>是经过训练的深度神经网络<a class="ae jx" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/imagenet_classes.ts" rel="noopener ugc nofollow" target="_blank">可以识别1000个不同的类别</a>。</p><p id="f1ab" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在项目的自述文件中，下面的<a class="ae jx" href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet#via-npm" rel="noopener ugc nofollow" target="_blank">示例代码</a>用于加载模型。</p><p id="9526" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb id">我遇到的第一个挑战是，这在Node.js上不起作用。</strong></p><pre class="lz ma mb mc fd md ll me mf aw mg bi"><span id="07de" class="lm kg ht ll b fi mh mi l mj mk">Error: browserHTTPRequest is not supported outside the web browser.</span></pre><p id="a357" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">看看<a class="ae jx" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/index.ts#L27" rel="noopener ugc nofollow" target="_blank">源代码</a>,<code class="du li lj lk ll b">mobilenet</code>库是底层<code class="du li lj lk ll b">tf.Model</code>类的包装器。当调用<code class="du li lj lk ll b">load()</code>方法时，它自动从外部HTTP地址下载正确的模型文件，并实例化TensorFlow模型。</p><p id="a707" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">Node.js扩展尚不支持动态检索模型的HTTP请求。相反，必须从文件系统中手动加载模型。</p><p id="fc4e" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="jy">在阅读了库的源代码后，我设法创建了一个解决方案……</em></p><p id="1117" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">如果手工创建了<code class="du li lj lk ll b">MobileNet</code>类，那么包含模型HTTP地址的自动生成的<code class="du li lj lk ll b">path</code>变量可以用本地文件系统路径覆盖，而不是调用模块的<code class="du li lj lk ll b">load</code>方法。完成这些后，调用类实例上的<code class="du li lj lk ll b">load</code>方法将触发<a class="ae jx" href="https://js.tensorflow.org/tutorials/model-save-load.html" rel="noopener ugc nofollow" target="_blank">文件系统加载器类</a>，而不是尝试使用基于浏览器的HTTP加载器。</p><p id="8c89" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb id">厉害，管用！</strong> <em class="jy">但是模型文件是怎么来的呢？</em></p><h1 id="4c52" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">MobileNet型号</h1><p id="294d" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated">TensorFlow.js的模型由两种文件类型组成，一种是存储在JSON中的模型配置文件，另一种是二进制格式的模型权重。模型权重通常被分割成多个文件，以便浏览器更好地缓存。</p><p id="56f5" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">查看MobileNet型号的<a class="ae jx" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/index.ts#L68-L76" rel="noopener ugc nofollow" target="_blank">自动加载代码</a>，型号配置和重量碎片从该地址的公共存储桶中检索。</p><pre class="lz ma mb mc fd md ll me mf aw mg bi"><span id="bd56" class="lm kg ht ll b fi mh mi l mj mk"><a class="ae jx" href="https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v${version}_${alpha}_${size}/" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v${version}_${alpha}_${size}/</a></span></pre><p id="36f0" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">URL中的模板参数指此处列出的<a class="ae jx" href="https://github.com/tensorflow/models/blob/master/research/slim/nets/mobilenet_v1.md#pre-trained-models" rel="noopener ugc nofollow" target="_blank">型号版本。每个版本的分类准确度结果也显示在该页面上。</a></p><p id="822d" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="jy">根据</em> <a class="ae jx" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/index.ts#L36" rel="noopener ugc nofollow" target="_blank"> <em class="jy">源代码</em> </a> <em class="jy">，使用</em> <code class="du li lj lk ll b"><em class="jy">tensorflow-models/mobilenet</em></code> <em class="jy">库只能加载MobileNet v1机型。</em></p><p id="83bd" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">HTTP检索代码从这个位置加载<code class="du li lj lk ll b">model.json</code>文件，然后递归地获取所有引用的模型权重碎片。这些文件的格式是<code class="du li lj lk ll b">groupX-shard1of1</code>。</p><p id="c106" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">通过检索模型配置文件、解析出引用的权重文件并手动下载每个权重文件，可以将所有模型文件保存到文件系统中。</p><p id="1ed0" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我想使用alpha值为1.0、图像大小为224像素的MobileNet V1模块。这给了我模型配置文件的<a class="ae jx" href="https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/model.json" rel="noopener ugc nofollow" target="_blank">以下URL </a>。</p><pre class="lz ma mb mc fd md ll me mf aw mg bi"><span id="e2e1" class="lm kg ht ll b fi mh mi l mj mk"><a class="ae jx" href="https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/model.json" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/model.json</a></span></pre><p id="21c5" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">一旦这个文件被下载到本地，我就可以使用来解析所有的权重文件名。</p><pre class="lz ma mb mc fd md ll me mf aw mg bi"><span id="d6cb" class="lm kg ht ll b fi mh mi l mj mk">$ cat model.json | jq -r ".weightsManifest[].paths[0]" group1-shard1of1 group2-shard1of1 group3-shard1of1 ...</span></pre><p id="344f" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">使用<code class="du li lj lk ll b">sed</code>工具，我可以用HTTP URL作为这些名称的前缀，为每个权重文件生成URL。</p><pre class="lz ma mb mc fd md ll me mf aw mg bi"><span id="fc59" class="lm kg ht ll b fi mh mi l mj mk">$ cat model.json | jq -r ".weightsManifest[].paths[0]" | sed 's/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//' https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group1-shard1of1 https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group2-shard1of1 https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group3-shard1of1 ...</span></pre><p id="6c4d" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">使用<code class="du li lj lk ll b">parallel</code>和<code class="du li lj lk ll b">curl</code>命令，我可以将所有这些文件下载到我的本地目录。</p><pre class="lz ma mb mc fd md ll me mf aw mg bi"><span id="d592" class="lm kg ht ll b fi mh mi l mj mk">cat model.json | jq -r ".weightsManifest[].paths[0]" | sed 's/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//' | parallel curl -O</span></pre><h1 id="9d1d" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">图像分类</h1><p id="1386" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated"><a class="ae jx" href="https://github.com/tensorflow/tfjs-models/tree/master/mobilenet#via-npm" rel="noopener ugc nofollow" target="_blank">本示例代码</a>由TensorFlow.js提供，用于演示返回图像的分类。</p><p id="4b35" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">由于缺少DOM，这在Node.js上不起作用。</p><p id="166c" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><code class="du li lj lk ll b">classify</code> <a class="ae jx" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/index.ts#L143-L155" rel="noopener ugc nofollow" target="_blank">方法</a>接受大量的DOM元素(<code class="du li lj lk ll b">canvas</code>、<code class="du li lj lk ll b">video</code>、<code class="du li lj lk ll b">image</code>)，并将自动从这些元素中检索图像字节并将其转换成一个<code class="du li lj lk ll b"><a class="ae jx" href="https://js.tensorflow.org/api/latest/index.html#tensor3d" rel="noopener ugc nofollow" target="_blank">tf.Tensor3D</a></code> <a class="ae jx" href="https://js.tensorflow.org/api/latest/index.html#tensor3d" rel="noopener ugc nofollow" target="_blank">类</a>，作为模型的输入。或者，可以直接传递<code class="du li lj lk ll b">tf.Tensor3D</code>输入。</p><p id="4300" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb id">我发现手动构造</strong> <code class="du li lj lk ll b"><strong class="jb id">tf.Tensor3D</strong></code> <strong class="jb id">比试图使用外部包来模拟Node.js中的DOM元素更容易。</strong></p><h2 id="7b47" class="lm kg ht bd kh ln lo lp kl lq lr ls kp jk lt lu kt jo lv lw kx js lx ly lb hz bi translated">从图像生成张量3D</h2><p id="79c8" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated">阅读用于将DOM元素转换为Tensor3D类的方法的<a class="ae jx" href="https://github.com/tensorflow/tfjs-core/blob/master/src/kernels/backend_cpu.ts#L126-L140" rel="noopener ugc nofollow" target="_blank">源代码</a>，以下输入参数用于生成Tensor3D类。</p><p id="251c" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><code class="du li lj lk ll b">pixels</code>是(Int32Array)类型的2D数组，包含每个像素的通道值的顺序列表。<code class="du li lj lk ll b">numChannels</code>是每像素通道值的数量。</p><h2 id="059d" class="lm kg ht bd kh ln lo lp kl lq lr ls kp jk lt lu kt jo lv lw kx js lx ly lb hz bi translated">为JPEGs创建输入值</h2><p id="bef0" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated"><code class="du li lj lk ll b"><a class="ae jx" href="https://www.npmjs.com/package/jpeg-js" rel="noopener ugc nofollow" target="_blank">jpeg-js</a></code> <a class="ae jx" href="https://www.npmjs.com/package/jpeg-js" rel="noopener ugc nofollow" target="_blank">库</a>是Node.js的纯javascript JPEG编码器和解码器。使用该库可以提取每个像素的RGB值。</p><p id="00d4" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这将为每个像素(<code class="du li lj lk ll b">width * height</code>)返回一个带有四个通道值(<code class="du li lj lk ll b">RGBA</code>)的<code class="du li lj lk ll b">Uint8Array</code>。MobileNet模型仅使用三个颜色通道(<code class="du li lj lk ll b">RGB</code>)进行分类，忽略alpha通道。此代码将四通道数组转换为正确的三通道版本。</p><h2 id="ce2c" class="lm kg ht bd kh ln lo lp kl lq lr ls kp jk lt lu kt jo lv lw kx js lx ly lb hz bi translated">MobileNet模型输入要求</h2><p id="1e1a" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated">正在使用的<a class="ae jx" href="https://github.com/tensorflow/models/blob/master/research/slim/nets/mobilenet_v1.md#mobilenet_v1" rel="noopener ugc nofollow" target="_blank"> MobileNet模型</a>对宽和高224像素的图像进行分类。对于三个通道的每个像素值，输入张量必须包含介于-1和1之间的浮点值。</p><p id="05ca" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">不同尺寸图像的输入值需要在分类前重新调整大小。此外，来自JPEG解码器的像素值在范围<em class="jy">0–255</em>内，而不是<em class="jy"> -1到1 </em>。这些值也需要在分类前进行转换。</p><p id="8396" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb id"> TensorFlow.js有库方法来使这个过程变得更容易，但是对我们来说幸运的是，</strong> <code class="du li lj lk ll b"><strong class="jb id">tfjs-models/mobilenet</strong></code> <strong class="jb id">库</strong> <a class="ae jx" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/index.ts#L103-L114" rel="noopener ugc nofollow" target="_blank"> <strong class="jb id">自动处理</strong> </a> <strong class="jb id">这个问题！</strong>👍</p><p id="8fd7" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">开发人员可以将类型为<code class="du li lj lk ll b">int32</code>和不同维度的Tensor3D输入传递给<code class="du li lj lk ll b">classify</code>方法，它会在分类之前将输入转换为正确的格式。也就是说没什么可做的...超级🕺🕺🕺.</p><h2 id="01f8" class="lm kg ht bd kh ln lo lp kl lq lr ls kp jk lt lu kt jo lv lw kx js lx ly lb hz bi translated">获得预测</h2><p id="416a" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated">Tensorflow中的MobileNet模型经过训练，可以识别来自<a class="ae jx" href="http://image-net.org/" rel="noopener ugc nofollow" target="_blank"> ImageNet </a>数据集中<a class="ae jx" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/imagenet_classes.ts" rel="noopener ugc nofollow" target="_blank">前1000个类</a>的实体。模型输出这些实体中的每一个在被分类的图像中的概率。</p><p id="955f" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><em class="jy">在</em> <a class="ae jx" href="https://github.com/tensorflow/tfjs-models/blob/master/mobilenet/src/imagenet_classes.ts" rel="noopener ugc nofollow" target="_blank"> <em class="jy">文件</em> </a> <em class="jy">中可以找到正在使用的模型的完整培训类别列表。</em></p><p id="97c7" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><code class="du li lj lk ll b">tfjs-models/mobilenet</code>库在<code class="du li lj lk ll b">MobileNet</code>类上公开了一个<code class="du li lj lk ll b">classify</code>方法，从图像输入中返回概率最高的前X个类。</p><p id="22d6" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><code class="du li lj lk ll b">predictions</code>是X个类别和概率的数组，格式如下。</p><h1 id="3385" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">例子</h1><p id="b27a" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated">学习了如何在Node.js上使用TensorFlow.js库和MobileNet模型之后，<a class="ae jx" href="https://gist.github.com/jthomas/145610bdeda2638d94fab9a397eb1f1d" rel="noopener ugc nofollow" target="_blank">这个脚本</a>将对作为命令行参数给出的图像进行分类。</p><h1 id="757a" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">源代码</h1><h1 id="5f47" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">测试它</h1><pre class="lz ma mb mc fd md ll me mf aw mg bi"><span id="f71b" class="lm kg ht ll b fi mh mi l mj mk">npm install</span><span id="f4fc" class="lm kg ht ll b fi ml mi l mj mk">wget http://bit.ly/2JYSal9 -O panda.jpg</span></pre><figure class="lz ma mb mc fd hk er es paragraph-image"><div class="er es mm"><img src="../Images/b132e9ec1c5f5df5c0834f3386c5f784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/0*niXoA1Ite_IjUIml.JPG"/></div></figure><pre class="lz ma mb mc fd md ll me mf aw mg bi"><span id="0311" class="lm kg ht ll b fi mh mi l mj mk">node script.js mobilenet/model.json panda.jpg</span></pre><p id="9b38" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb id">如果一切正常，下面的输出应该会打印到控制台。</strong></p><p id="b819" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">该图像以99.93%的概率被正确分类为包含熊猫！🐼🐼🐼</p><h1 id="c8d6" class="kf kg ht bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结论</h1><p id="6df1" class="pw-post-body-paragraph iz ja ht jb b jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw hb bi translated">TensorFlow.js为JavaScript开发者带来了深度学习的力量。通过TensorFlow.js库使用预先训练的模型，可以用最少的工作和代码轻松扩展JavaScript应用程序，完成复杂的机器学习任务。</p><p id="2acd" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">TensorFlow.js已经作为基于浏览器的库发布，现在已经扩展到在Node.js上工作，尽管并非所有的工具和实用程序都支持新的运行时。经过几天的研究，我能够使用MobileNet模型库对本地文件中的图像进行视觉识别。</p><p id="f84b" class="pw-post-body-paragraph iz ja ht jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">让它在Node.js运行时工作意味着我现在开始下一个想法……让它在一个无服务器函数中运行！很快回来阅读我与TensorFlow.js的下一次冒险。👋</p></div></div>    
</body>
</html>