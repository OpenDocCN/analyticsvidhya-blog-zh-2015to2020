<html>
<head>
<title>Understanding Transfer Learning &amp; Image Augmentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解迁移学习和图像增强</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-transfer-learning-image-augmentation-8456855eccb9?source=collection_archive---------12-----------------------#2020-10-29">https://medium.com/analytics-vidhya/understanding-transfer-learning-image-augmentation-8456855eccb9?source=collection_archive---------12-----------------------#2020-10-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3ac5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你有没有参加过图像分类比赛，觉得自己的模型不如上面的人？那我觉得这个博客是给你的。</p><h1 id="824b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">目录</h1><ul class=""><li id="c189" class="kb kc hi ih b ii kd im ke iq kf iu kg iy kh jc ki kj kk kl bi translated">什么是迁移学习？</li><li id="6602" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">预处理</li><li id="4b5a" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">图像增强</li><li id="2c75" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">使用ResNet101迁移学习</li><li id="759a" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">估价</li><li id="c4f2" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">结束注释</li></ul><h1 id="0413" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是迁移学习？</h1><p id="0744" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">迁移学习是使用预先训练好的模型来解决新问题或创建新模型。</p><h1 id="179c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">预处理</strong></h1><p id="d643" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在这一步中，我们将创建一个图像目录，并将数据解压缩到其中。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a3cc" class="ld je hi kz b fi le lf l lg lh">!mkdir images<br/>!unzip code_warriors_game_of_data_ai_challenge-dataset.zip -d images/</span></pre><p id="cd4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将导入所有需要的库。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="1d8f" class="ld je hi kz b fi le lf l lg lh">import os, shutil<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>import pandas as pd<br/>from keras.preprocessing import image<br/>from keras.applications.resnet import ResNet101<br/>from keras.layers import Dense<br/>from keras.models import Model, Sequential</span></pre><p id="c780" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一步中，我们将把图像分成训练图像和验证图像。</p><p id="fb9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一步</strong>:创建一个val_images目录来传输图像。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="48de" class="ld je hi kz b fi le lf l lg lh">if not os.path.isdir("val_images"):<br/>  os.mkdir("val_images")</span></pre><p id="ebc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步</strong>:创建数据可以分类的类别列表。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="4c0b" class="ld je hi kz b fi le lf l lg lh">classes = ['Bread','Dairy product','Dessert','Egg','Fried food','Meat','Noodles-Pasta','Rice','Seafood','Soup','Vegetable-Fruit']</span></pre><p id="243b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三步:我们将创建子目录来存储特定类别的图片。下面的代码遍历了列表中的所有元素，如果没有，就为这个类创建一个文件夹。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="23d4" class="ld je hi kz b fi le lf l lg lh">for c in classes:<br/>  if not os.path.isdir("val_images/" + c):<br/>    os.mkdir("val_images/" + c)</span></pre><p id="06b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第四步:这一步可能有点难以理解，请耐心等待。</p><p id="4db2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的代码中，我们将变量split赋值为0.9，因为我们希望以90:10的比率拆分数据(train : validate)。在下一行中，我们遍历train文件夹中的所有子文件夹，并为其创建一个path变量。os.listdir()将返回特定文件夹中的所有文件名。我们可以使用len()函数获得图像的数量，并通过将其乘以分割变量，我们可以获得分割大小，即我们需要的训练图像的数量。</p><p id="218d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的步骤中，我们创建一个变量files_to_move，并提取从split_size开始索引到末尾(即10%的数据)的文件名。最后，我们将使用join()函数创建源路径和目标路径，并使用shutil的move()函数移动它们。</p><p id="8194" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">建议:</strong>如果你感到困惑，在任何步骤使用print(variable)可能会帮助你更好地理解。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="25c6" class="ld je hi kz b fi le lf l lg lh">split = 0.9<br/>for dirc in os.listdir("/content/images/train"):<br/>  path = "/content/images/train/" + dirc<br/>  images = os.listdir(path)<br/>  split_size = int(len(images)*split)</span><span id="530d" class="ld je hi kz b fi li lf l lg lh">  files_to_move = images[split_size:]<br/>  print(files_to_move)<br/>  print()<br/>  for f in files_to_move:<br/>    src = os.path.join(path,f) #path+file<br/>    dest = os.path.join("val_images/",dirc)<br/>    shutil.move(src,dest)</span></pre><p id="6f3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检查我们上面的尝试是否已经完成，我们将检查目录的内容。</p><p id="71b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将循环遍历训练目录中的每个项目，并打印每个类别的图像数量。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0204" class="ld je hi kz b fi le lf l lg lh">for dirc in os.listdir("/content/images/train"):<br/>  path = "/content/images/train/" + dirc<br/>  img = os.listdir(path)<br/>  print(dirc, len(img))</span></pre><p id="6932" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将循环遍历val_images目录中的每一项，并打印每一类别的图像数量。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b374" class="ld je hi kz b fi le lf l lg lh">for dirc in os.listdir("val_images/"):<br/>  path = "val_images/" + dirc\ <br/>  img = os.listdir(path)<br/>  print(dirc, len(img))</span></pre><h1 id="505a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">图像增强</h1><p id="ed3e" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">图像增强是一种通过创建修改版本来增加我们已经拥有的数据的方法。在下图中，你可以从一张猫的图片中看到，我们可以通过改变宽度、高度、缩放、剪切等来创建多张图片。</p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/a8796597f0ede5cdc3c4d60aaa6f593e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0SyKFj_lZQGeh3FE9nPnA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图像增强</figcaption></figure><p id="2b43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，为了实现这一点，我们将为训练数据创建一个ImageDataGenerator对象，并添加属性，基于这些属性将创建新图像，如rotation_range、width_shift_range、height_shift_range、shear_range、zoom_range、horizontal flip。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="db5a" class="ld je hi kz b fi le lf l lg lh">train_gen = image.ImageDataGenerator(rotation_range=25,<br/>                                     width_shift_range = 0.3,<br/>                                     height_shift_range = 0.25,<br/>                                     shear_range = 0.2,<br/>                                     zoom_range = 0.3,<br/>                                     horizontal_flip = True<br/>                                     )</span></pre><p id="8ed1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还将为验证数据创建一个ImageDataGenerator对象，但我们不会传递任何属性，因为我们不想基于它生成图像，因为它只用于验证。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="72ac" class="ld je hi kz b fi le lf l lg lh">val_datagen = image.ImageDataGenerator()</span></pre><p id="4905" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在接下来的步骤中，我们将从刚刚创建的对象创建新的图像。我们正在使用flow_from_directory，您也可以根据需要使用flow_from_dataframe。我们将传递包含训练图像的目录。目标大小被指定为(224，224)，因为我们将使用在相同大小的图像上训练的ResNet模型。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="bc00" class="ld je hi kz b fi le lf l lg lh">train_generator = train_gen.flow_from_directory(<br/>                                      "/content/images/train",                                                                                      <br/>                                      target_size = (224,224), <br/>                                      class_mode = "categorical",<br/>                                      shuffle = True,<br/>                                      batch_size = 32<br/>                                      )</span></pre><p id="1ba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还将使用val_datagen对象根据需要处理图像。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="39ea" class="ld je hi kz b fi le lf l lg lh">val_generator = val_datagen.flow_from_directory("val_images/",<br/>                                         target_size = (224,224),<br/>                                         class_mode = 'categorical',<br/>                                         batch_size=32)</span></pre><h1 id="3eea" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">使用ResNet101迁移学习</h1><p id="4a92" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们现在将创建一个ResNet101对象，include_top为True，因为我们需要最终的密集层，权重参数设置为imagenet，以便我们可以获得预训练的权重。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="13c1" class="ld je hi kz b fi le lf l lg lh">resnet = ResNet101(include_top= True, weights= "imagenet")</span></pre><p id="85a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在接下来的步骤中，我们将提取顶部的n-2个resnet层，并在最后添加一个密集层。激活被设置为softmax，因为我们想要执行分类，并且参数11被指定，因为我们有11个类。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="83d0" class="ld je hi kz b fi le lf l lg lh">#get top n-2 layers<br/>x = resnet.layers[-2].output<br/>fun = Dense(11, activation = "softmax")(x)</span></pre><p id="2a82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将创建我们的模型，它具有resnet模型的输入和我们刚刚创建的输出fun。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="e3e9" class="ld je hi kz b fi le lf l lg lh">model = Model(inputs=resnet.input, outputs = fun)</span></pre><p id="4ba6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一步中，我们将冻结除最后30层之外的所有层，也就是说，我们将使可训练参数为假，以便学习的权重不会改变。我们正在训练最后30层，因为ResNet101模型是在一般数据(即ImageNet)上训练的，而我们有食物数据，因此我们的模型需要相应地学习。</p><p id="3f8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">model.compile方法用于在训练之前编译模型。这里我们使用sgd，即随机梯度下降，您也可以使用Adam优化器或任何其他优化器。我们已经将损失作为分类交叉熵，您可以根据需要采用任何其他损失函数。我们将使用的衡量标准是准确性。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="9959" class="ld je hi kz b fi le lf l lg lh"># Freeze layers<br/>for l in model.layers[:-30]:<br/>  l.trainable = False</span><span id="3fad" class="ld je hi kz b fi li lf l lg lh">model.compile(optimizer="sgd", loss = "categorical_crossentropy",            <br/>  metrics=["accuracy"])</span></pre><p id="71e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">model.summary()方法用于查看所有层。你可以尝试一下，我想能够显示它作为一个图像。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="208b" class="ld je hi kz b fi le lf l lg lh">model.summary()</span></pre><p id="634e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来是训练部分，使用拟合的方法来训练我们的模型。我们将通过train_generator进行训练，steps_per_epoch可以计算为“训练图像的数量/批量大小”, validation_steps可以计算为“验证图像的数量/批量大小”。我们将通过validation_data中的val_generator进行验证。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a07c" class="ld je hi kz b fi le lf l lg lh">hist = model.fit(train_generator,<br/>                 steps_per_epoch=3937//32,<br/>                 epochs=50,<br/>                 validation_data=val_generator,<br/>                 validation_steps=497//32)</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lv"><img src="../Images/bacecbb84396f67e485000ea304808ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llrXJFlnbrxpg5vhGAQbdA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">输出</figcaption></figure><h1 id="e18e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">估价</h1><p id="a290" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们将使用。evaluate()方法来获得我们的模型的准确性。我建议你试试超参数，把准确率提高到90%以上。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="47e3" class="ld je hi kz b fi le lf l lg lh">model.evaluate(val_generator)</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lw"><img src="../Images/0a2f3f802427c529a898a2357a3be95c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjZWM0-6ZMdJTPYv0jxL-A.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">准确(性)</figcaption></figure><h1 id="542c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结束注释</h1><p id="5c49" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在这篇博客中，我们学习了使用ResNet101的迁移学习，我建议你尝试不同的模式，如VGG，DenseNet，Xception，MobileNet，以及许多其他模式。</p><p id="fb53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想了解更多关于机器学习和数据科学的博客，请关注我，并告诉我你想了解的话题。</p><p id="7bbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嘿，读者们，感谢你们的时间。如果你喜欢这个博客，别忘了鼓掌欣赏它👏如果你喜欢❤，你可以给50英镑👏</p><p id="ff13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lx">数据科学爱好者| ML爱好者| TCS CA |编码块CA | Blogger |社区成员|公共演讲者</em></p><p id="e803" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有任何疑问或建议，请随时联系我</p><p id="3f9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">https://twitter.com/shah_naivedh<a class="ae ly" href="https://twitter.com/shah_naivedh" rel="noopener ugc nofollow" target="_blank"/></p><p id="6925" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【https://www.linkedin.com/in/naivedh-shah/ T4】</p></div></div>    
</body>
</html>