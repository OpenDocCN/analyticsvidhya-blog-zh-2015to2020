<html>
<head>
<title>Co-related Sub-queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Co相关的子查询</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/co-related-sub-queries-7d2c872d2341?source=collection_archive---------9-----------------------#2020-07-19">https://medium.com/analytics-vidhya/co-related-sub-queries-7d2c872d2341?source=collection_archive---------9-----------------------#2020-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/087ac16677f21f42f7b86190c6db7df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GimPid9_ufGYQgO-.png"/></div></div></figure><p id="c170" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在SQL中，最令人困惑的话题是—子查询和co相关子查询之间的区别。这是因为在大多数情况下，我们尽量避免使用co-related子查询，因为这种东西太慢，占用内存太多。</p><p id="4fda" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在本文中，我们将了解为什么使用相关子查询，以及它与自连接之间的区别(这通常类似于自连接，但它不是)</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="8e30" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">什么是相关子查询:</p><blockquote class="jw jx jy"><p id="840c" class="iy iz jz ja b jb jc jd je jf jg jh ji ka jk jl jm kb jo jp jq kc js jt ju jv hb bi translated">根据维基百科，相关子查询(也称为同步子查询)是一个子查询(嵌套在另一个查询中的查询)，它使用来自外部查询的值。因为子查询可能对外部查询处理的每一行计算一次，所以它可能会很慢 <a class="ae kd" href="https://en.wikipedia.org/wiki/Correlated_subquery" rel="noopener ugc nofollow" target="_blank"> <em class="hi">。</em> </a></p><p id="d2b1" class="iy iz jz ja b jb jc jd je jf jg jh ji ka jk jl jm kb jo jp jq kc js jt ju jv hb bi translated">根据W3schools，SQL相关子查询用于从外部查询中引用的表中选择数据。子查询被称为相关子查询，因为子查询与外部查询相关。在这种类型的查询中，必须使用表别名(也称为相关名)来指定要使用哪个表引用。</p></blockquote><p id="fa7a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">虽然这看起来像教科书上的东西，但他们在这里说的是——有两个查询内部和外部，内部查询完全依赖于外部查询。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ke"><img src="../Images/041ded308332c61b4b026bd4b6417818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cg5Yy25KBurOccgA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">演职员表:极客的极客</figcaption></figure><p id="4cc0" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">什么是内外查询:</strong></p><ul class=""><li id="d29b" class="kj kk hi ja b jb jc jf jg jj kl jn km jr kn jv ko kp kq kr bi translated">子查询也称为<strong class="ja hj">内部查询或内部选择</strong>，而包含子查询的<strong class="ja hj">语句也称为<strong class="ja hj">外部查询或外部选择</strong>。</strong></li><li id="0e2c" class="kj kk hi ja b jb ks jf kt jj ku jn kv jr kw jv ko kp kq kr bi translated">内部查询在其父查询之前首先执行，以便内部查询的结果可以传递给外部查询</li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="b15e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我将用一个代码来解释这一点:对于这个细节，我们采用雇员模式。</p><p id="fe4d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">查询:我需要找到平均工资的人谁得到低于平均工资的人在自己的部门。</p><p id="f69e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">为此:</strong></p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es kx"><img src="../Images/0ec95e3e44d7b0a3692a39d9decce885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*9JSluEWSTT6eGRFB9OrH_Q.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">抽样资料</figcaption></figure><p id="1910" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们使用以下代码计算平均值:<strong class="ja hj">从雇员中选择平均值(薪金)</strong></p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ky"><img src="../Images/43bbc0da7b125e103c12976dba22ced8.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*Bqo3X2u3D4z8Ygdsfh2ktA.png"/></div></figure><p id="c20f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在这个数据集中，我们得到了平均工资，并按部门进行了分组:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es kz"><img src="../Images/478cb9f115e6749aa953766eb23cc2ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*WuPh0dp0HLFsHofKThuqBQ.png"/></div></figure><blockquote class="jw jx jy"><p id="9521" class="iy iz jz ja b jb jc jd je jf jg jh ji ka jk jl jm kb jo jp jq kc js jt ju jv hb bi translated"><em class="hi">我们已经得到了平均工资，并按照他们各自的部门id进行了分组</em></p></blockquote><p id="c2e2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在，我们必须弄清楚，一个部门的雇员的平均工资是否低于他们自己部门的平均工资。为了执行这个查询，我们使用别名。这是因为如果我们不使用别名，就会产生歧义。</p><p id="0ac2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">我们再回到excel表:</strong></p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es la"><img src="../Images/061bfc7000580872b3ec62dd4b5e10ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*v3c3-nVuSZsIWVMLr3JY-w.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">示例数据</figcaption></figure><p id="3758" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在这里，我检查了工资是否低于他们部门的平均工资。在部门80中，由于没有其他员工，Ravi成为该部门的唯一员工，因此平均值是他的工资。换句话说，他没有同事，因此无法计算他所在部门的平均水平。但在其他情况下，瑞安、纳文在各自部门获得的薪水低于他们的平均薪水。</p><p id="53b9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">如何在MySQL中编写代码:</strong></p><ul class=""><li id="018a" class="kj kk hi ja b jb jc jf jg jj kl jn km jr kn jv ko kp kq kr bi translated">我们需要从雇员表中得到什么—全名、雇员标识、部门标识、薪水。这是外部查询</li><li id="1c33" class="kj kk hi ja b jb ks jf kt jj ku jn kv jr kw jv ko kp kq kr bi translated">我们从内部查询中需要什么—基于他们部门的平均工资。</li><li id="42c4" class="kj kk hi ja b jb ks jf kt jj ku jn kv jr kw jv ko kp kq kr bi translated">我们在where条件中匹配外部查询部门id和内部查询部门id</li></ul><p id="e19d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们经营它。</p><p id="3f7c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">员工表:这个表可以在W3schools下载。</strong></p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lb"><img src="../Images/5be052311f8b3b76562fb4ec4e68d465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9O1Jksxbfpk7CuH0t1hJlA.png"/></div></div></figure><p id="062c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">因此，我们需要内部查询:之前我们看到，我们如何根据平均工资进行分组，现在我们必须编写一个内部查询来查找。</p><blockquote class="jw jx jy"><p id="7d67" class="iy iz jz ja b jb jc jd je jf jg jh ji ka jk jl jm kb jo jp jq kc js jt ju jv hb bi translated"><em class="hi">内部查询:从员工内部—(此处内部是内部查询的别名)</em>中选择avg(薪金)</p><p id="2c7d" class="iy iz jz ja b jb jc jd je jf jg jh ji ka jk jl jm kb jo jp jq kc js jt ju jv hb bi translated"><em class="hi">外部查询:从employees outer(这里Outer是外部查询的别名)中选择employee_id，concat(first_name，' '，last_name)，salary，avg(salary)</em></p></blockquote><p id="67d9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们该如何加入呢？我们将使用where子句将内部查询嵌入到外部查询中:where salary&lt; (select avg(salary) from employees iq where iq.department_id = oq.department_id)</p><blockquote class="jw jx jy"><p id="c54d" class="iy iz jz ja b jb jc jd je jf jg jh ji ka jk jl jm kb jo jp jq kc js jt ju jv hb bi translated">select first_name, last_name, salary, department_id<br/>from employees OQ<br/>where salary&lt;<br/>(select avg(salary)from employees IQ where IQ . department _ id = OQ . department _ id)</p></blockquote><p id="c04a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这个yeilds，</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lc"><img src="../Images/1b71d2071e5bb2f25eccfcaf55d5c285.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*7eNQjK-5sSTHbMxXJmpnNg.png"/></div></div></figure><p id="e301" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这些人的工资低于他们部门的平均工资。</p><p id="cd4e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">说明</strong>:对于每一个外部查询，内部查询都会执行并检查值是否更小。如果该值较小，则打印，否则不打印。它跳过。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ld"><img src="../Images/8c7162c0d73c14e90163f312b5a4f025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/0*lPmcACRIl3T09mER.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">摘自Guru99</figcaption></figure><h2 id="4fcf" class="le lf hi bd lg lh li lj lk ll lm ln lo jj lp lq lr jn ls lt lu jr lv lw lx ly bi translated">易:这些家伙是甲骨文公司的员工。莱克斯·德·汉去世了，他是甲骨文中的一个传奇人物</h2></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="5460" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">面试的一些问答:</strong></p><ol class=""><li id="1b82" class="kj kk hi ja b jb jc jf jg jj kl jn km jr kn jv mh kp kq kr bi translated"><strong class="ja hj">可以嵌套多少层？:</strong></li></ol><ul class=""><li id="716c" class="kj kk hi ja b jb jc jf jg jj kl jn km jr kn jv ko kp kq kr bi translated">它等于表的数量</li><li id="9df5" class="kj kk hi ja b jb ks jf kt jj ku jn kv jr kw jv ko kp kq kr bi translated">从技术上讲，oracle允许您嵌套大约255个级别</li><li id="b456" class="kj kk hi ja b jb ks jf kt jj ku jn kv jr kw jv ko kp kq kr bi translated">使用255级在技术上是不明智的。</li><li id="1e81" class="kj kk hi ja b jb ks jf kt jj ku jn kv jr kw jv ko kp kq kr bi translated">这将占用大量内存。</li></ul><p id="766c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">2.<strong class="ja hj">为什么我们使用子查询而不是连接？</strong></p><ul class=""><li id="5653" class="kj kk hi ja b jb jc jf jg jj kl jn km jr kn jv ko kp kq kr bi translated">因为我们不需要其他表中的列，只需要数据，这就是为什么我们使用子查询而不是连接。</li><li id="8be7" class="kj kk hi ja b jb ks jf kt jj ku jn kv jr kw jv ko kp kq kr bi translated">如果我们需要其他表中的列，我们可以使用join</li></ul><p id="f197" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> 3。子查询的规则？</strong></p><p id="cc21" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="jz">子查询必须遵循一些规则—</em>子查询必须用括号括起来。子查询在SELECT子句中只能有一列，除非主查询中有多列，以便子查询比较其选定的列。返回多行的子查询只能用于多值运算符，如IN运算符。选择列表不能包含对计算结果为BLOB、ARRAY、CLOB或NCLOB的值的任何引用。子查询不能立即包含在集合函数中。BETWEEN运算符不能用于子查询。但是，BETWEEN运算符可以在子查询中使用。</p><p id="3ef9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> 4。我们可以使用orderby吗？</strong></p><p id="ca4b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">尽管主查询可以使用ORDER BY，但ORDER BY命令不能用在子查询中。GROUP BY命令可用于执行与子查询中的ORDER BY相同的功能。</p><p id="205c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> 5。嵌套子查询vs相关子查询？</strong></p><p id="8e45" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">对于普通的嵌套子查询，内部的<strong class="ja hj"> SELECT </strong>查询首先运行并执行一次，返回主查询要使用的值。但是，相关子查询会对外部查询考虑的每个候选行执行一次。换句话说，内部查询由外部查询驱动。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="e97f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">感谢阅读。</p></div></div>    
</body>
</html>