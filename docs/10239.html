<html>
<head>
<title>Algorithms In Context #5: Order Statistics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上下文#5中的算法:顺序统计</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/algorithms-revisited-part-5-order-statistics-e9de74e64c3?source=collection_archive---------11-----------------------#2020-10-10">https://medium.com/analytics-vidhya/algorithms-revisited-part-5-order-statistics-e9de74e64c3?source=collection_archive---------11-----------------------#2020-10-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="0489" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">如果我让你在一组无序的数字中找出第k个最小或最大的元素，你会怎么做？对数字进行排序？天啊，你真无聊…</p></blockquote><p id="e54d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">当被要求寻找第k个最小元素时，大多数程序员立即用排序来回答。这是为什么呢？嗯，<strong class="il hj">因为简单！所有你需要做的就是调用一个<em class="ik">排序</em>函数，然后你就可以开始了。但是我们能做得更好吗？<em class="ik">我想如果我们不能……</em>我就不会写这个了</strong></p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="3ff3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们从寻找集合中最小/最大的元素开始。遍历所有元素一次就足以找到最小的元素。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="2b0a" class="ka kb hi jw b fi kc kd l ke kf">int findSmallest(vector&lt;int&gt; elements) {</span><span id="5826" class="ka kb hi jw b fi kg kd l ke kf">    int smallest = INT_MAX;<br/>    for (int current : elements) {<br/>        if (current &lt; smallest) {<br/>            smallest = current;<br/>        }<br/>    }</span><span id="5eb1" class="ka kb hi jw b fi kg kd l ke kf">    return smallest;<br/>}</span></pre><p id="1a2b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">当然，求第k个最小元素没这么简单。但我写这个是因为找到最小的元素和找到第n个最小的元素是一回事，所以我们试图开发一个通用算法，它将为每个k值工作。</p><blockquote class="if ig ih"><p id="ced4" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">很快，我们就会发现，寻找第k个最小元素也可以在<strong class="il hj"> O(n) </strong>时间复杂度内实现。</p></blockquote><h1 id="dd5d" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">随机选择</h1><p id="a970" class="pw-post-body-paragraph ii ij hi il b im le io ip iq lf is it jh lg iw ix ji lh ja jb jj li je jf jg hb bi translated">在我之前关于<a class="ae lj" rel="noopener" href="/swlh/algorithms-revisited-part-4-randomized-algorithms-f7677e292458?source=friends_link&amp;sk=7e483ec89fee69d49657e3657d1d030f">随机化算法</a>的文章中，我展示了一个改善快速排序最坏情况的策略。在本节中，我们将采用相同的策略，但是我们将编写一个<strong class="il hj">随机选择</strong>算法，而不是编写一个随机快速排序算法。</p><p id="dcce" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在<strong class="il hj">随机化快速排序</strong>中，我们围绕随机选择的枢纽元素对集合中的元素进行分区，这样，左边分区中的每个元素都小于枢纽，而右边分区中的每个元素都大于枢纽。</p><figure class="jr js jt ju fd ll er es paragraph-image"><div class="er es lk"><img src="../Images/b35bfed8602ce0748e724e0399750da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*l-QQ0_BgCznor9EiVdQncA.png"/></div></figure><p id="40bc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果我们对左边和右边的小块不断重复这个操作，我们最终会得到一个有序的集合。随机选择算法遵循非常相似的方法，但是这次我们不需要对整个集合进行排序。注意，我们只需要集合中的第k个元素，所以只要我们能够将正确的元素放入第k个索引中，其余的元素如何在集合中分布就与我们无关了。</p><p id="0e7f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">随机化快速排序在每一步都递归地划分左侧和右侧。但是随机选择只对其中一个进行分区，这取决于枢轴索引是小于还是大于<em class="ik"> k </em>。</p><p id="c1ae" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">下面给出了随机选择的算法，假设我们已经有了分区算法。如果你将它与<a class="ae lj" rel="noopener" href="/swlh/algorithms-revisited-part-4-randomized-algorithms-f7677e292458?source=friends_link&amp;sk=7e483ec89fee69d49657e3657d1d030f">之前的文章</a>进行比较，你会发现我们现在做的是一个递归调用，而不是两个。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="1514" class="ka kb hi jw b fi kc kd l ke kf">int randomizedSelect(vector&lt;int&gt; nums, int left, int right, int k) {</span><span id="1874" class="ka kb hi jw b fi kg kd l ke kf">    if (left == right) {<br/>        return nums[left];<br/>    }</span><span id="bddf" class="ka kb hi jw b fi kg kd l ke kf">    int pivot = randomizedPartition(nums, left, right);<br/>    int size = pivot - left + 1;</span><span id="d303" class="ka kb hi jw b fi kg kd l ke kf">    // count is the number of elements in the left partition<br/>    if (k == size) {<br/>        return nums[size];<br/>    } else if (k &lt; size) {<br/>        return randomizedSelect(nums, left, pivot - 1, k);<br/>    } else {<br/>        return randomizedSelect(nums, pivot + 1, right, k - size);<br/>    }<br/>}</span></pre><p id="e768" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">随机选择算法的<strong class="il hj">预期运行时间为O(n) </strong>。用数学方法证明这一点并不容易，但是如果你感兴趣的话，你可以在<a class="ae lj" href="https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/lectures/09/Small09.pdf" rel="noopener ugc nofollow" target="_blank">斯坦福的幻灯片</a>中找到。请注意，该算法的最坏情况运行时间是指数级的，因为我们可能会非常不走运，并且分区在每一步都需要O(n)。</p><blockquote class="if ig ih"><p id="99e8" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这就是我们试图用随机算法解决的问题，但我想这还不够好。然后让我们检查另一个可以保证在O(n)中运行的选择算法。</p></blockquote><h1 id="f0ce" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">中位数</h1><p id="2c60" class="pw-post-body-paragraph ii ij hi il b im le io ip iq lf is it jh lg iw ix ji lh ja jb jj li je jf jg hb bi translated">现在让我们讨论如果我们选择了<strong class="il hj">中位数</strong>作为枢纽元素会发生什么。Median是中间元素，因此围绕它进行划分将保证将集合均匀地分成两个子集。</p><p id="dcae" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">选择中间值的程序如下。<em class="ik">剧透警告，你不会喜欢这样的。</em></p><ol class=""><li id="f9b3" class="lo lp hi il b im in iq ir jh lq ji lr jj ls jg lt lu lv lw bi translated">将集合分成5个元素的组。</li><li id="ce61" class="lo lp hi il b im lx iq ly jh lz ji ma jj mb jg lt lu lv lw bi translated">通过对组进行排序，找到每个组的中值。</li><li id="4c98" class="lo lp hi il b im lx iq ly jh lz ji ma jj mb jg lt lu lv lw bi translated">递归地找到这些中间值的中间值。</li></ol><figure class="jr js jt ju fd ll er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mc"><img src="../Images/b96e5dfa013ed854f369063664410eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UuA-V2XSErqLrG4RmCBBoQ.jpeg"/></div></div></figure><p id="363d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">请注意，该算法没有找到精确的中值，而是找到了一个近似的中值。还要注意，左上角(蓝色)的每一项都小于中值，右下角(红色)的每一项都大于中值。</p><p id="03cc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">算法的其余部分以相同的方式工作，您围绕中间值的中间值划分输入集，并根据元素k的位置继续进行左或右划分。</p><p id="2718" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">为什么这个算法在O(n)中运行的证明不是很简单，所以我们在这里不打算这样做。如果你想进一步阅读，你可以使用麻省理工学院的幻灯片。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="c73c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在实践中，中值的计算非常重要，即使它是在O(n)中运行的，所以它不是真正的首选。您可能希望使用随机选择算法，它在大多数情况下会优于中位数选择。也有一些技术根据输入集将两种方法结合起来。</p><blockquote class="if ig ih"><p id="74ed" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">所以你是说这不值得努力。你猜怎么着只管对元素进行排序，我都不在乎！</p></blockquote></div></div>    
</body>
</html>