<html>
<head>
<title>Record your internet speeds using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python记录你的网速</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/record-your-internet-speeds-using-python-6a9827f8eec?source=collection_archive---------4-----------------------#2020-01-07">https://medium.com/analytics-vidhya/record-your-internet-speeds-using-python-6a9827f8eec?source=collection_archive---------4-----------------------#2020-01-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/57d95fde5a09450f1777ca29d9d776d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2WqQD8xIaLydScvb"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://www.pexels.com/photo/person-writing-on-notebook-669615/" rel="noopener ugc nofollow" target="_blank">(来源)</a></figcaption></figure><p id="8529" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上周，我写了一篇关于在微软Power BI中可视化数据集有多容易的文章。今天，我想向大家展示我是如何在pandas和speedtest-cli库的帮助下，用Python收集我的网速数据集的。</p><p id="2158" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，您需要在终端上用常用的<code class="du jt ju jv jw b">pip install</code>命令安装两个库:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="3ecc" class="kf kg hi jw b fi kh ki l kj kk">pip install <br/>pip install speedtest-cli</span></pre><p id="7bef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你用的是Windows，别忘了以管理员身份运行。</p><p id="82ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在您已经安装了必要的库，让我简单介绍一下我们将要使用的数据。目标是创建一个包含以下四列的CSV:</p><ul class=""><li id="6755" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated">日期:测试日期</li><li id="307d" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">Ping(毫秒):测试连接的ping，以毫秒为单位</li><li id="38eb" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">下载(Mb/s):记录的下载速度，单位为每秒兆位</li><li id="9f06" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">上传(Mb/s):记录的上传速度，单位为每秒兆位</li></ul><p id="f479" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用speedtest-cli库可以很容易地获得所有这些值，我们只需要转换下载和上传速度，因为它们最初是以比特每秒为单位的。在将值写入CSV文件方面，我们将让pandas及其数据帧帮助我们更新文件，并确保每天只记录一个测试，也就是说，“日期”列将用作索引，因此每个日期只能出现一次。</p><p id="d657" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在您对我们的最终结果有了更好的了解，让我们进入代码。我将首先展示完整的脚本，然后我们将一步一步来。</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="2617" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个脚本有两个主要功能:<code class="du jt ju jv jw b">get_new_speeds()</code>，负责执行互联网速度测试，以及<code class="du jt ju jv jw b">update_csv()</code>，用最新的测试结果更新保存在CSV文件中的数据集。</p><p id="071b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个函数<code class="du jt ju jv jw b">get_new_speeds()</code>中的代码与speedtest-cli库文档中的演示代码非常相似:创建一个<code class="du jt ju jv jw b">Speedtest</code>对象，获得执行测试的最佳服务器，获得连接的ping，然后执行下载和上传速度测试。</p><p id="fb98" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">唯一增加的是下载和上传速度从每秒比特转换为每秒兆比特。对于转换，我们只需将每个值除以一百万(10的6次方)，四舍五入到两位小数。</p><p id="42dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">get_new_speeds()</code>到此为止。最后，我们返回一个三项元组，其中包含ping(毫秒)以及下载和上传速度(都以每秒兆比特为单位)。</p><p id="c978" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du jt ju jv jw b">update_csv()</code>中，我们用新的测试结果更新数据集CSV(它接收前面函数返回的元组作为参数)。但是，正如您在try/except块(第30到39行)中看到的，如果CSV文件不能被加载，则假定该文件不存在，因此数据集是从头开始创建的。如果数据集加载成功，<code class="du jt ju jv jw b">csv_dataset</code>数据帧代表已经存在的数据集；否则它就是一个空的数据帧。</p><p id="333b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后(第42到46行)，我们创建一个新的单行DataFrame，它包含今天的日期作为索引(一个在函数的第一行格式化的字符串)和每个测试速度度量的一列。</p><p id="2b4d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们需要将这个单行数据帧附加到数据集上(<code class="du jt ju jv jw b">csv_dataset</code>)。无论try/except块中出现了什么(加载现有数据集或从头创建数据集)，我们只需将这一行数据添加到<code class="du jt ju jv jw b">csv_dataset</code>数据帧中。</p><p id="c641" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">旧结果和新结果都在同一个数据帧中，我们需要确保没有重复的行。例如，假设您今天已经记录了一个测试，忘记了它并再次运行脚本。这意味着您现在有两行相同日期的数据，我们不能让这种情况发生，之所以选择“date”列作为索引，是因为它不想有重复的值。</p><p id="c376" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是第51行发生的事情，删除重复日期的行，只保留最后一次出现的日期:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="c781" class="kf kg hi jw b fi kh ki l kj kk">updated_df.loc[~updated_df.index.duplicated(keep="last")]</span></pre><p id="2d8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们打破这种界限。</p><p id="5b25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">updated_df.index.duplicated()</code>返回一个Numpy数组，其中包含每个索引值的布尔值。被视为重复的值为True，唯一的值为False。因为我们已经向它传递了值为<code class="du jt ju jv jw b">last</code>的<code class="du jt ju jv jw b">keep</code>参数，这意味着对于每个重复值，除了最后一个之外的所有出现都将被标记为重复(True)。查看官方文档中的示例，如果我们的数据帧具有以下索引值:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="f19f" class="kf kg hi jw b fi kh ki l kj kk">'lama', 'cow', 'lama', 'beetle', 'lama'</span></pre><p id="c1a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当在其上调用<code class="du jt ju jv jw b">updated_df.index.duplicated(keep="last")</code>时，将返回下面的数组:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="9415" class="kf kg hi jw b fi kh ki l kj kk">[ True, False, True, False, False ]</span></pre><p id="4b10" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">lama，重复值，只有前两次出现标记为重复(True)。最后一次出现被标记为unique (False)，因为我们指定要保留最后一次重复出现。</p><p id="0429" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们知道哪些行包含重复的索引，我们需要实际删除它们。为此，我们使用了<code class="du jt ju jv jw b">loc[]</code>方法，它允许我们通过索引来定位行。幸运的是，这个方法接受布尔数组作为参数，这正是我们从调用<code class="du jt ju jv jw b">duplicated()</code>中得到的。</p><p id="10d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，这次行动还有最后一个细节。当遍历布尔数组时，<code class="du jt ju jv jw b">loc[]</code>将返回它接收到True值的行，这与标记为重复的行相对应。换句话说，<code class="du jt ju jv jw b">loc[]</code>将删除我们实际想要保留的行。因此在<code class="du jt ju jv jw b">updated_df.index.duplicated(keep="last")</code>调用前使用了波浪号(<code class="du jt ju jv jw b">~</code>)。我们接收相同的布尔数组，但是波浪号在传递给<code class="du jt ju jv jw b">loc[]</code>之前反转数组中的每个值。换句话说，数组中的每个True都变成False，每个False都变成True。</p><p id="d78b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是为什么这条线</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="7ac4" class="kf kg hi jw b fi kh ki l kj kk">updated_df.loc[~updated_df.index.duplicated(keep="last")]</span></pre><p id="0a93" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅返回具有唯一索引的行以及具有重复索引的行的最后一次出现。<code class="du jt ju jv jw b">duplicated()</code>将索引标记为重复或唯一，然后波浪号反转这些值以确保<code class="du jt ju jv jw b">loc[]</code>只定位我们想要保留的行。</p><p id="ac71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，现在我们有了过滤后的数据帧，我们可以将它写入internet_speeds_dataset CSV文件，将“Date”列标记为索引列(第52行)。如果文件不存在，它被创建；如果它已经存在，它会用新数据更新。</p><p id="250c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已。现在，您可以使用这个脚本来记录您的互联网速度，然后，也许，可视化的数据收集与matplotlib，甚至微软电力BI！</p></div></div>    
</body>
</html>