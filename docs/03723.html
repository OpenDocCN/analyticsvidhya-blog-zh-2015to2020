<html>
<head>
<title>An approach to Create a logging mechanism for real-time object detection using TDD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种使用TDD创建实时对象检测日志机制的方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-a-custom-logging-mechanism-for-real-time-object-detection-using-tdd-4ca2cfcd0a2f?source=collection_archive---------9-----------------------#2020-02-15">https://medium.com/analytics-vidhya/creating-a-custom-logging-mechanism-for-real-time-object-detection-using-tdd-4ca2cfcd0a2f?source=collection_archive---------9-----------------------#2020-02-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a8de53c7985e5ec623c151ea61b243ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bgIXRJYcSegKdVw16lMymQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">原图:<a class="ae iu" href="https://www.architecturaldigest.com/story/david-adjaye-spyscape-spy-museum-opens-in-new-york" rel="noopener ugc nofollow" target="_blank">https://www . architecture digest . com/story/David-adjaye-spy scape-spy-museum-opens-in-new-York</a></figcaption></figure><h2 id="bd58" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">动机</h2><p id="d7d6" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">最近，我有一个关于实时应用程序的项目，它从监控系统获取视频流作为输入，并返回在检测上绘制的边界框，以及将它们记录在json文件中。所以我想作为我在medium上的第一篇文章，这个简单的项目可能是一个好的开始。这样，我使用测试驱动开发来实现代码，所以我真的希望这篇文章对那些想熟悉python中的unittest工具的新手来说能派上用场。你可以查看<a class="ae iu" href="https://github.com/masouduut94/json_logger_for_object_detection" rel="noopener ugc nofollow" target="_blank">这个</a>链接获取源代码。在这个链接中你还可以找到一个物体检测案例的用法代码。物体检测代码属于阿德里安·罗斯布鲁克的<a class="ae iu" href="https://www.pyimagesearch.com/2020/02/10/opencv-dnn-with-nvidia-gpus-1549-faster-yolo-ssd-and-mask-r-cnn/?__s=ojnwchnsdmrtdosojsgp" rel="noopener ugc nofollow" target="_blank">这篇</a>棒极了的帖子，他是我的计算机视觉的伟大推动者之一。</p><h2 id="578a" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">描述系统</h2><p id="91ff" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">为了了解我们将要处理的内容，让我们仔细看看这个示例图像:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/4a38e5f143eba6b336a80b29400b1fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*M4FqBC2SJnHfiZdhCRqTkQ.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1:一帧中带有标签和置信度的检测包围盒。来源:<a class="ae iu" href="https://www.pyimagesearch.com/2017/09/11/object-detection-with-deep-learning-and-opencv/" rel="noopener ugc nofollow" target="_blank">pyimageresearch.com</a></figcaption></figure><p id="6034" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">此图像显示了包含两个边界框的帧，每个边界框都有一个带有特定置信值的标签。因此，我们有一个帧列表，在每个帧中，有多个边界框，每个边界框都有一个带置信度的标签。通常，在任何对象检测中，都存在置信度较低的其他标签。我们可以让包围盒拥有一个标签列表，这些标签具有它们被分配的置信度。我们通过选择一个名为top_k_label的参数来做到这一点，我们希望所有的边界框都有完全相同数量的标签。</p><p id="45d2" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">这是图1中的一个json文件示例，top_k_labels等于2。</p><p id="f2d1" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated"><code class="du ky kz la lb b">{<br/> “video_details”: {<br/> “frame_width”: 1080,<br/> “frame_height”: 720,<br/> “frame_fps”: 20,<br/> “video_name”: “test.avi”<br/> },<br/> “frames”: [<br/> {<br/> “frame_id”: 1,<br/> “bboxes”: [<br/> {<br/> “bbox_id”: “0”,<br/> “labels”: [<br/> {<br/> “category”: “car”,<br/> “confidence”: 99.25<br/> },<br/> { <br/> “category”: “truck”,<br/> “confidence”: 57.14<br/> }<br/> ],<br/> “left”: 5,<br/> “top”: 400,<br/> “width”: 250,<br/> “height”: 145<br/> },<br/> {<br/> “bbox_id”: “1”,<br/> “labels”: [<br/> { <br/> “category”: “car”,<br/> “confidence”: 99.78<br/>},<br/> { <br/> “category”: “bus”,<br/> “confidence”: 65.23<br/> }],<br/> “left”: 650,<br/> “top”: 450,<br/> “width”: 300,<br/> “height”: 150<br/> }]<br/> }]</code></p><p id="0001" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">我考虑了视频细节，它包含了视频文件的宽度、高度、fps和名称等信息，以确保我们可以在必要时再次输入视频文件时重建边界框。</p><h2 id="35c3" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">初始化</h2><p id="e4ff" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">我从3个类开始编写基本代码，这3个类包含了框架、框和标签的基本信息。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">框架的基本组件</figcaption></figure><p id="b0bc" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">为了管理输出，我创建了另一个类，并将其命名为<code class="du ky kz la lb b">JsonParser</code>:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用JsonParser类管理组件</figcaption></figure><h2 id="f5f9" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">第一步:添加框架</h2><p id="eebe" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">好了，现在我们有了初始类，让我们使用TDD软件开发方法。我创建了另一个文件，命名为<code class="du ky kz la lb b">test_json_parser</code>，然后把它放在<code class="du ky kz la lb b">tests</code>文件夹中。</p><p id="86b2" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">现在我们需要一个代码来测试简单地添加框架到<code class="du ky kz la lb b">JsonParser.frames</code>。让我们用下面的代码初始化测试用例:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">json_parser.py上测试的初始化</figcaption></figure><p id="b2a1" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">我使用pycharm工具来测试代码。我添加<code class="du ky kz la lb b">sys.path.append(../..)</code>的原因是，如果您的系统中没有pycharm，我可以使用终端命令来运行测试。这是添加框架的测试:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">测试简单框架插入</figcaption></figure><p id="5457" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">在这项测试中:</p><blockquote class="le lf lg"><p id="5811" class="jt ju lh jv b jw kt jy jz ka ku kc kd li kv kf kg lj kw ki kj lk kx kl km kn hb bi translated">1-我们确保输出json包含输入中给定的帧号。</p><p id="3021" class="jt ju lh jv b jw kt jy jz ka ku kc kd li kv kf kg lj kw ki kj lk kx kl km kn hb bi translated">2-如果插入了重复的帧号，我们预计会出现错误。</p><p id="6eba" class="jt ju lh jv b jw kt jy jz ka ku kc kd li kv kf kg lj kw ki kj lk kx kl km kn hb bi translated">注意<code class="du ky kz la lb b">assertRaisesRegex</code>函数使用正则表达式来检查产生的错误消息。术语<code class="du ky kz la lb b">(.*?)</code>是一个正则表达式，在这里我使用它是为了避免忽略句子<code class="du ky kz la lb b">(Frame id:)</code>和<code class="du ky kz la lb b">already exists</code>之间的任何内容。</p></blockquote><p id="d5b9" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">现在让我们开发代码来通过这个测试。我们从<code class="du ky kz la lb b">JsonParser</code>类开始。我给它增加了三个功能:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">将这些函数添加到JsonParser类将通过测试</figcaption></figure><p id="79ba" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">为了访问python中的每个类属性，通常我使用<code class="du ky kz la lb b">__dict__()</code>函数。但是为了访问对象列表中的属性，比如类<code class="du ky kz la lb b">Bbox</code>中的<code class="du ky kz la lb b">labels</code>属性或者类<code class="du ky kz la lb b">Frame</code>中的<code class="du ky kz la lb b">bboxes</code>属性，我们需要做一些小技巧来使这些参数返回属性字典，而不是返回一堆对象。感谢<a class="ae iu" href="https://stackoverflow.com/a/60126384/6118987" rel="noopener ugc nofollow" target="_blank">对我在stackoverflow(如果这篇文章对你有用，请随意投票支持这个问题)中的问题的这个精彩回答</a>，我创建了一个父类，它为类<code class="du ky kz la lb b">Frame</code>、<code class="du ky kz la lb b">Bbox</code>和<code class="du ky kz la lb b">Label</code>添加了一个额外的属性。我给它取名为<code class="du ky kz la lb b">BaseJsonParser</code>。我们将这个类设置为<code class="du ky kz la lb b">Frame</code>、<code class="du ky kz la lb b">Bbox</code>和<code class="du ky kz la lb b">Label</code>类的父类。：</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">定义BaseJsonParser和' Label '、' Bbox '和' Frame '时，必须将其声明为父级。</figcaption></figure><blockquote class="le lf lg"><p id="ffb0" class="jt ju lh jv b jw kt jy jz ka ku kc kd li kv kf kg lj kw ki kj lk kx kl km kn hb bi translated">当我们将BaseJsonParser设置为父类时，我们为继承该类的类设置了一个属性，即<code class="du ky kz la lb b">dic</code>。这个属性将允许我们返回嵌套类中的属性。</p></blockquote><p id="650c" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">让我们为<code class="du ky kz la lb b">`JsonParser`</code>添加<code class="du ky kz la lb b">output</code>函数并运行测试:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">将此函数添加到“JsonParser”类中</figcaption></figure><p id="268d" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">现在我们运行<code class="du ky kz la lb b">test_add_frame.py</code>功能:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/65417e6bf9c7214448a83e67d0486f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfYtiMGaV6N4JA5eDOCHZg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">测试通过！</figcaption></figure><h2 id="dc99" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">步骤2:添加边界框到每个框架</h2><p id="97c8" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">干得好！现在我们编写第二个测试，将Bbox添加到帧中:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">现在，我们必须通过添加bbox的测试</figcaption></figure><p id="70e2" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">好吧。在这里，我们需要:</p><blockquote class="le lf lg"><p id="bd99" class="jt ju lh jv b jw kt jy jz ka ku kc kd li kv kf kg lj kw ki kj lk kx kl km kn hb bi translated">1-为<code class="du ky kz la lb b">JsonParser </code>创建函数，在插入bbox <br/>之前检查bbox是否存在2-创建函数，将bbox添加到<code class="du ky kz la lb b">Frame </code>和<code class="du ky kz la lb b">JsonParser </code>类的框架中。</p></blockquote><p id="768d" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">现在我们将这些函数添加到<code class="du ky kz la lb b">JsonParser</code>类中:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">将这些添加到“JsonParser”中。</figcaption></figure><p id="1cd0" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">还有这个给<code class="du ky kz la lb b">Frame </code>上课:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">为“框架”类添加bbox函数</figcaption></figure><p id="c6ba" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">现在让我们再次运行这两个测试:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/187491f166f699aefacbaac03f95357f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9r4z2P1pC-jJG_6luuSJg.png"/></div></div></figure><h2 id="b85b" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">步骤3:向边界框添加标签</h2><p id="daaa" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">下一部分我们要测试给bboxes添加标签。我们需要测试的是这些东西:</p><blockquote class="le lf lg"><p id="29c8" class="jt ju lh jv b jw kt jy jz ka ku kc kd li kv kf kg lj kw ki kj lk kx kl km kn hb bi translated">1 —当我们设置<code class="du ky kz la lb b">top_k_labels </code>并向bboxes添加相同数量的标签时，我们希望添加它们时不会出现问题。<br/> 2 —插入标签超过<code class="du ky kz la lb b">top_k_labels </code>将被取消<code class="du ky kz la lb b">ValueError</code>。<br/>3——在输出json的过程中，我们希望程序检查边界框的标签数量是否与<code class="du ky kz la lb b">top_k_labels </code>允许的数量相同。</p></blockquote><p id="426e" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">这是测试:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">向bbox添加标签的测试</figcaption></figure><p id="310f" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">为了通过测试，我们必须:</p><blockquote class="le lf lg"><p id="c580" class="jt ju lh jv b jw kt jy jz ka ku kc kd li kv kf kg lj kw ki kj lk kx kl km kn hb bi translated">1 —创建一个函数，在给定<code class="du ky kz la lb b">frame_id </code>和<code class="du ky kz la lb b">bbox_id</code> <br/>的帧中查找bbox列表中的bbox 2—创建一个函数，为找到的bbox添加一个标签。<br/> 3 —添加到bbox的标签必须和<code class="du ky kz la lb b">top_k_labels </code>一样多。否则会引发错误。我们必须在输出帧时确保这一点。</p></blockquote><p id="6678" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">我们在<code class="du ky kz la lb b">JsonParser </code>函数中增加<code class="du ky kz la lb b">find_bbox </code>函数:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">JsonParser中增加了find_bbox函数</figcaption></figure><p id="0ae0" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">然后我们在这里给<code class="du ky kz la lb b">JsonParser </code>添加<code class="du ky kz la lb b">add_label_to_bbox </code>功能:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">如果bbox已经存在，将标签添加到bbox</figcaption></figure><p id="0d3d" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">如你所见，bbox必须有一个<code class="du ky kz la lb b">add_label</code>函数。我添加了一个函数，如果标签号与top_k相同，该函数返回true。我将其命名为<code class="du ky kz la lb b">labels_full</code>:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们更新了类“Bbox ”,增加了“add_label”和“labels_full”函数</figcaption></figure><p id="e712" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">输入中给定的<code class="du ky kz la lb b">labels_full</code>的值将是<code class="du ky kz la lb b">top_k</code>，我们已经在<code class="du ky kz la lb b">JsonParser</code>中考虑过了。现在我们必须修改<code class="du ky kz la lb b">JsonParser</code>中输出函数的代码:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">修改JsonParser类中的输出函数</figcaption></figure><p id="4063" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">让我们再次运行整个测试:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/88db78ae426db2e72a54507632e8dc51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_d2JqOjpoxMv4MMv-FO3Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">运行所有的测试</figcaption></figure><h2 id="fdf9" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">最后一步:自动化Json输出</h2><p id="2afb" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">酷毙了。我们有我们的JsonParser。现在，我们可以开发一个功能，帮助我们自动化保存json文件的整个过程。我想出的机制是这样的:</p><blockquote class="le lf lg"><p id="c3ce" class="jt ju lh jv b jw kt jy jz ka ku kc kd li kv kf kg lj kw ki kj lk kx kl km kn hb bi translated">1 —我们设置了一个<code class="du ky kz la lb b">interval </code>参数，该参数可能在1秒到5小时之间，它将指示保存json文件的频率。<br/> 2 —我们在第一帧处理开始之前设置了一个开始时间。<br/> 3 —我们在循环中调用调度程序函数，为每一帧执行该过程。然后我们可以测量开始时间和当前时间之间的时间差。每当这个差值大于time_to_save参数时，我们就可以保存json文件。我们按照相应的时间戳保存文件。</p></blockquote><p id="132a" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">让我们在另一个名为<code class="du ky kz la lb b">test_scheduled_output.py</code>的文件中创建测试，并用以下内容初始化测试:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><h2 id="a048" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">为什么是<code class="du ky kz la lb b">mkdtemp</code>？</h2><blockquote class="le lf lg"><p id="25f9" class="jt ju lh jv b jw kt jy jz ka ku kc kd li kv kf kg lj kw ki kj lk kx kl km kn hb bi translated"><code class="du ky kz la lb b">tempfile </code>库中的<code class="du ky kz la lb b">mkdtemp </code>函数使用了系统中的一个临时目录，并创建了一个临时文件夹。我们使用该文件夹来保存jsons，以便进行临时测试。</p></blockquote><p id="023c" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">我需要这个过程花费超过1秒的时间来查看json是否会被自动保存。我不想在我的测试中使用视频，因为在单元测试中，更专业的做法是设计全面且运行更快的测试。所以我用时间库中的睡眠函数来模拟这个动作。</p><p id="2a45" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">然后我们使用下面的代码通过测试:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">添加json_output和schedule_output</figcaption></figure><p id="a30f" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">什么是<code class="du ky kz la lb b">JsonMeta</code>？我使用<code class="du ky kz la lb b">JsonMeta </code>类的原因是我想为schedule_output函数中的所有参数设置限制。(例如，我不希望分钟或秒钟超过59)。</p><p id="e198" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">让我们看看测试是否通过:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/5d0e3c50ed57066703c7eb23b4143824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6Xy74_ng-AxcqtivJDi0A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">所有测试都通过了。万岁！！！！</figcaption></figure><p id="9afd" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">最后，我们可以使用下面的函数向json添加视频细节:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/68bf1ac47fd0e6323be6ae1abe9466ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5Seb67xnJd8dCtlZoHSCw.png"/></div></div></figure><h2 id="1cfe" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">对进一步工作的建议</h2><p id="ecdd" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">好了，现在我们有了一个在实时监控系统中保存jsons的有用工具。实际上，我建议您添加以下功能:</p><p id="30d7" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">1 —创建另一个能够分析json数据并从检测中发现见解的类。例如，找出特定的人通过监视摄像机的频率。</p><p id="28dd" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">2-创建一个函数，该函数能够通过在视频帧上重建bboxes来返回视频中的检测，并显示结果</p><p id="d3b0" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">3-在物体检测代码上使用代码。</p><p id="4281" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">我已经对这篇文章中属于<a class="ae iu" href="https://www.pyimagesearch.com/2020/02/10/opencv-dnn-with-nvidia-gpus-1549-faster-yolo-ssd-and-mask-r-cnn/" rel="noopener ugc nofollow" target="_blank">的代码提出了第三个建议，这是一个由Adrian rosebrock创建的令人敬畏的快速对象检测代码。我在这里</a>上传了<a class="ae iu" href="https://github.com/masouduut94/json_logger_for_object_detection" rel="noopener ugc nofollow" target="_blank">的全部代码</a></p></div></div>    
</body>
</html>