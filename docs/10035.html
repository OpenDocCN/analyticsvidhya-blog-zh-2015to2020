<html>
<head>
<title>Metagenomics gene prediction using NLP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于自然语言处理的宏基因组学基因预测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/metagenomics-gene-prediction-using-nlp-7d843b67ef58?source=collection_archive---------6-----------------------#2020-10-01">https://medium.com/analytics-vidhya/metagenomics-gene-prediction-using-nlp-7d843b67ef58?source=collection_archive---------6-----------------------#2020-10-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5543" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">宏基因组学阅读中基因预测的CNN+嵌入层。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ae56a74c3daddb1dacd6f268c498a596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aC9X4cEpLZT2JcWQrSESxw.png"/></div></div></figure><p id="7829" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这个病变中，我将演示我们如何使用深度学习来预测编码orf和非编码orf。我们将使用在自然语言处理(NLP)框架内开发的方法，并将其应用于orf，将DNA序列视为生物分子文本。</p><p id="5240" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将实现四种不同的算法CNN，RNN，LTSM，GRU，并比较他们的性能，看看哪一个优于另一个。</p><p id="8603" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">算法的预处理是相同的，我们使用这篇文章<strong class="jl hj"/><a class="ae kf" href="https://www.hindawi.com/journals/bmri/2017/4740354/" rel="noopener ugc nofollow" target="_blank"><strong class="jl hj"/></a>提供的数据，其中包含大约400万个orf，我提取了60万个orf进行训练和测试。</p><p id="5e57" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">该数据可在我的<a class="ae kf" href="https://drive.google.com/drive/folders/1_R6Dpyllq3gtu2llVzxVZzEEVYbyIGAv?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hj">驱动器</strong> </a>中获得</p><h1 id="0b61" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">预处理数据</h1><p id="9360" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">第一步是将数据加载到google colab中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="82b7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将数据加载到tmpdata后，我们将这个列表转换成pandas数据帧。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ld le l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lf"><img src="../Images/9ea463363c8ed7f3e9eeb37ace43780d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTVyWJHrB_IbtyOgmLQAoA.png"/></div></div></figure><p id="2e88" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将DNA序列视为“语言”，也称为k-mer计数</p><p id="686d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">DNA和蛋白质序列可以被比喻为生命的语言。这种语言为在所有生命形式中发现的分子编码指令和功能。序列语言类比继续以基因组为书，子序列(基因和基因家族)是句子和章节，k-mers和肽(基序)是单词，核苷酸碱基和氨基酸是字母表。既然这个类比看起来如此贴切，那么自然语言处理领域所做的惊人工作也应该适用于DNA和蛋白质序列的自然语言。</p><p id="0c32" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们要用的方法简单易行。我首先将长的生物序列分解成k-mer长度的重叠“单词”。例如，如果我使用长度为6(六聚体)的“单词”，“ATGCATGCA”就变成了:“ATGCAT”，“TGCATG”，“GCATGC”，“CATGCA”。因此，我们的示例序列被分解为4个六聚体单词。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ld le l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lg"><img src="../Images/8eeface0d1bfa9dad91de3ca977221a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6FerL1jkFs_6YRm9F5UKQw.png"/></div></div></figure><p id="9646" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们现在需要将每个基因的k-mers列表转换成字符串句子</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="964f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以看到我们有一个相当平衡的数据。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lh"><img src="../Images/eeef7b44aa2ac5f5bec6e00fb7bbe283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGbPWw5P475tEMvvPcW3tQ.png"/></div></div></figure><p id="6b19" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里我们将使用Kears的<strong class="jl hj"> Tokenizer </strong>类来将单词/ K-mers转换成整数，然后应用填充来处理标准化输入的长度。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="3712" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">创建模型前的最后一步是将数据分为训练和测试，并定义词汇大小。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ld le l"/></div></figure><h1 id="7ab7" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">CNN +嵌入层</h1><p id="55e4" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">让我们创建模型，看看它表现如何。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ld le l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es li"><img src="../Images/33566e34cf386736ff8128f99cce72c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0xfN1HOphsd5Y4JdC5ffQ.png"/></div></div></figure><p id="098c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦模型准备好了，训练的时间终于到了。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ld le l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/9a0174906192b1d52e5011d5b4974f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c3oN4jDyNur0K13ArbC0aQ.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/bc7dce59845b49d30fd1bbcaa8e7f524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EE4OVfqiuAxN2mttslPurA.png"/></div></div></figure><p id="98ce" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为我们的模型似乎没有很好地学会区分编码orf和非编码orf。</p><p id="555f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们得到的准确率为82.51%，敏感性为80.39%，特异性为79.17%，调和平均值为79.78%</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/061735ddcc3d025a4e656cabda958d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olsurXLI5EEVT0wXuFOBLw.png"/></div></div></figure><h1 id="c6e9" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">摘要</h1><p id="e64b" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">在这一课中，我们探索了NLP在基因预测中的应用，下一篇文章将是基因预测中的最后一篇，我将比较RNN、LSTM和GRU的表现，看看哪个模型给我们的结果最好。</p><p id="a1ac" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<a class="ae kf" href="https://www.linkedin.com/in/rachid-elfermi-75a84b8b/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae kf" href="https://github.com/rachidelfermi" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看我。</p><p id="a462" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下次见</p></div></div>    
</body>
</html>