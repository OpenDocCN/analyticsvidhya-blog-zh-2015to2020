<html>
<head>
<title>Understand sequence to sequence models in a more intuitive way.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以更直观的方式理解模型的顺序。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understand-sequence-to-sequence-models-in-a-more-intuitive-way-1d517d8795bb?source=collection_archive---------0-----------------------#2020-05-01">https://medium.com/analytics-vidhya/understand-sequence-to-sequence-models-in-a-more-intuitive-way-1d517d8795bb?source=collection_archive---------0-----------------------#2020-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="814a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">TensorFlow中带有端到端机器翻译示例的序列到序列模型。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/881746c8c92ba1528e0e41863b5bbac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZS34bTaxoVx_peC31wcnA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">具有样本输入的编码器-解码器模型的详细架构。</figcaption></figure><h2 id="0061" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">先决条件:</h2><p id="4d29" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">对LSTM和张量流有一个基本的了解就足够了。</p><h2 id="4cc1" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">目录:</h2><ol class=""><li id="ced6" class="le lf hi kn b ko kp kr ks jy lg kc lh kg li ld lj lk ll lm bi translated">引言。</li><li id="ecae" class="le lf hi kn b ko ln kr lo jy lp kc lq kg lr ld lj lk ll lm bi translated">高层架构解释。</li><li id="7798" class="le lf hi kn b ko ln kr lo jy lp kc lq kg lr ld lj lk ll lm bi translated">数据预处理。</li><li id="dc5e" class="le lf hi kn b ko ln kr lo jy lp kc lq kg lr ld lj lk ll lm bi translated">训练编码器-解码器模型。</li><li id="1acc" class="le lf hi kn b ko ln kr lo jy lp kc lq kg lr ld lj lk ll lm bi translated">如何写推论？</li><li id="9db5" class="le lf hi kn b ko ln kr lo jy lp kc lq kg lr ld lj lk ll lm bi translated">结果。</li><li id="3da9" class="le lf hi kn b ko ln kr lo jy lp kc lq kg lr ld lj lk ll lm bi translated">编码器-解码器模型的缺点。</li></ol><h2 id="152e" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">1.简介:</h2><p id="aaf2" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">编码器-解码器模型用于机器翻译、对话聊天机器人。它还用于图像字幕(给定一幅图像简要描述该图像)、视频字幕(给定一个视频文件简要描述该视频)、LaTex数学表达式(给定一幅图像的公式生成LaTex格式的数学表达式)。</p><p id="341a" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">在这篇文章中，我将致力于机器翻译。我们的目标是给出一个意大利语句子，将其转换成英语句子。我已经从这个<a class="ae lx" href="http://www.manythings.org/anki/ita-eng.zip" rel="noopener ugc nofollow" target="_blank">源</a>获取了数据。它包含超过33.6万条意大利语到英语的翻译。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/6844442128b1e906279caf0f27022de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EwDP3Di-oMgLa16NENZnFA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">编码器-解码器高级架构</figcaption></figure><h2 id="0659" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">2.高层架构解释:</h2><p id="4424" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">理解架构有助于我们了解应该如何准备数据。我们的模型有两个模块编码器和解码器。每个模块包含一个递归神经网络(RNN)。e₂e₁分别是时间步长1和2的编码器RNN。d₂d₁分别是时间步1和2的解码器RNN。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lz"><img src="../Images/bb4394f75c3695afb86c710e25a6105d.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*u9k5-g2se3NZZwuoPzzNlw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">样本值输入</figcaption></figure><p id="60b3" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">编码器输入是一个意大利句子。解码器输入是在句子前带有开始标记(&lt;<em class="ma"> start </em> &gt;)的英语句子，解码器输出是带有结束标记(&lt; <em class="ma"> end </em> &gt;)的同一句子的一个时移版本。我们将在后面的章节中理解(<em class="ma"> &lt;开始&gt; </em>)和(<em class="ma"> &lt;结束&gt; ) </em>标记的重要性。</p><p id="e3fe" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">样本数据的基本编码器-解码器模型说明:</p><ul class=""><li id="6f2a" class="le lf hi kn b ko ls kr lt jy mb kc mc kg md ld me lk ll lm bi translated">编码器输入将被发送到编码器RNN。它将在两个时间步骤后返回单元格状态和隐藏状态(因为输入的意大利语句子的长度是2)</li></ul><blockquote class="mf"><p id="9e11" class="mg mh hi bd mi mj mk ml mm mn mo ld dx translated">这些状态被传递给解码器，并作为解码器的初始状态。这意味着只有当你听完整个意大利句子，你才能开始把它翻译成英语。</p></blockquote><ul class=""><li id="27cc" class="le lf hi kn b ko mp kr mq jy mr kc ms kg mt ld me lk ll lm bi translated">给定这些初始状态，解码器的第一步'<em class="ma"> &lt; start &gt; </em>'将作为输入发送。我们希望我们的模型预测单词<em class="ma">‘keep’</em>。</li><li id="1376" class="le lf hi kn b ko ln kr lo jy lp kc lq kg lr ld me lk ll lm bi translated">在第二个时间步，<em class="ma">“保持”</em>将作为输入发送，我们希望我们的模型预测<em class="ma">“聚焦”</em>。并且继续进行，如上图所示。</li></ul><blockquote class="mu mv mw"><p id="4d11" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">这种将解码器输入移动一个时间步长并将其用于解码器输出的方法称为教师强制。</p></blockquote></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><h2 id="ad42" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">3.数据预处理。</h2><p id="bbac" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">清理数据，下面的代码将数据转换成小写，规范字符串，删除不需要的字符，并在标点符号前添加一个空格。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">代码:清理输入字符串。</figcaption></figure><p id="a4fb" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">让我们清理样本点的字符串并检查输出。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">代码:清除样本数据点的文本数据。</figcaption></figure><p id="2644" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">现在将这段代码包装在一个函数中，该函数将'<em class="ma"> num_examples </em>'作为输入参数，并返回输入输出对。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">代码:返回特定数量的编码器输入、解码器输入和解码器输出的函数</figcaption></figure><p id="6d6c" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">为了简单起见，只生成20K意大利语-英语序列对。</p><pre class="iy iz ja jb fd nj nk nl nm aw nn bi"><span id="38d0" class="jn jo hi nk b fi no np l nq nr">num_examples=20000<br/>ita_data,eng_in,eng_out,eng_data=makedata(num_examples)</span></pre><p id="556c" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">将文本数据转换成数字形式，一个简单的方法是应用记号化器并将文本数据表示成整数表示。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">代码:初始化意大利语标记器</figcaption></figure><p id="0daa" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">默认情况下，Tokenizer将删除所有标点符号，因为我们已经在预处理中处理了标点符号，所以我们添加了带有空字符串的filters参数。应用<em class="ma">填充</em>，以便每个序列都是相同的形状。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">代码:将意大利文本数据转换为整数序列，然后进行填充。</figcaption></figure><p id="54f3" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">类似地，我们将标记化应用于decoder_input和decoder_output。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">代码:标记解码器输入和输出</figcaption></figure><p id="df42" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">令牌化后的样本输入数据，额外的零是由于填充使得每个输入序列具有相同的长度。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es et"><img src="../Images/93d2ce9b1963e7c2acf6b6c7bd55a88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2e5RFFY2iI9_z_jMhDJK6g.png"/></div></div></figure><p id="48ab" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">Tokenizer还将单词索引对存储在字典word_index中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">生成单词及其索引的查找表，这将有助于推理。</figcaption></figure><p id="7ae4" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">打印字典eng_word_index的前15个值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ns"><img src="../Images/7f60c5a571b35aca7fdaa2e2b78cfe4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j8Betas3rTdw185gXO9Okg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图:eng_word_index的输出(仅前15个值)</figcaption></figure><p id="af11" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">让我们看看输入和输出的形状，以及意大利语和英语在标记化后的词汇量。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="75bb" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">所有意大利语句子的长度都是9，英语句子的长度是7。英语句子中共有2250个独特的单词，意大利语句子中共有5524个独特的单词。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">样本值输入</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es et"><img src="../Images/93d2ce9b1963e7c2acf6b6c7bd55a88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2e5RFFY2iI9_z_jMhDJK6g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">抽样输出</figcaption></figure><p id="1085" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">让我们用样本输入重新绘制编码器-解码器架构。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nt"><img src="../Images/1d6530f2191a4ec78100be5378bb1147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVSV-tvjMkNfDEU2eatPbw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">具有样本输入的编码器-解码器模型的详细架构。</figcaption></figure><h2 id="0315" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">4.训练编码器-解码器模型。</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nu"><img src="../Images/296cdccb153a328092719096fbd0b9e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CqHku5y15xDa5m4wtIC2Ug.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">编码器-解码器模型培训</figcaption></figure><p id="0876" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">这里我们选择LSTM作为我们的RNN层。不过，你也可以选择GRU。</p><p id="e1fc" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">对于我们的编码器RNN，我们将传递我们的输入序列，输入形状将是(批处理大小，输入序列长度)。</p><p id="0e78" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">在将我们的输入发送到LSTM图层之前，LSTM图层需要一个3D输入。我们当前的输入形状是二维的。一个简单的方法是添加一个嵌入层。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">代码:初始化编码器输入并将其传递给嵌入层。</figcaption></figure><p id="b855" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">现在嵌入后的形状是(Batch_size，inp_seq_length，output_dim)，(也就是(Batch_size，9，128))。让我们把嵌入层的输出传递给LSTM层。让我们称这一层为encoder_lstm。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">代码:完整的编码器代码</figcaption></figure><p id="79ca" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">因为我们想要编码器的最终状态，所以我们给return_state =True。这将返回给我三个输出。最后一个时间步长的hidden_state/output(无，256)，最后一个时间步长的hidden_state/ output(无，256)，最后一个时间步长的cell_state(无，256)。</p><p id="8340" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">让我们取最后两个张量hidden_state和cell_state。我们将把编码器的这些最终状态作为初始状态传递给解码器。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">将隐藏状态和单元格状态保存到变量encoder_states</figcaption></figure><p id="1413" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">类似地，我们将把decoder_input传递给一个嵌入层，然后把它传递给一个LSTM。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">代码:完整的解码器代码。</figcaption></figure><p id="a60e" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">如果你仔细观察上面的代码:</p><ol class=""><li id="ecab" class="le lf hi kn b ko ls kr lt jy mb kc mc kg md ld lj lk ll lm bi translated">我们作为输入传递给解码器层的形状不是target_sequence_length(它是7)。在训练期间，我们将传递长度为7的输入，但是在推理期间，我们一次只传递一个输入。因此，如果我们保持<em class="ma">‘None’</em>，它将在两种情况下都有效。我们将在本帖的推理部分更详细地理解它。</li><li id="27d4" class="le lf hi kn b ko ln kr lo jy lp kc lq kg lr ld lj lk ll lm bi translated">decoder_lstm有一个属性初始状态，就是encoder_final状态。</li></ol><p id="07c0" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">decoder_lstm返回三个输出。</p><ul class=""><li id="a2aa" class="le lf hi kn b ko ls kr lt jy mb kc mc kg md ld me lk ll lm bi translated">所有时间步长的隐藏状态/输出。(无，无，256)。</li><li id="c8ec" class="le lf hi kn b ko ln kr lo jy lp kc lq kg lr ld me lk ll lm bi translated">最后一个时间步的隐藏状态/输出。(无，256)</li><li id="6147" class="le lf hi kn b ko ln kr lo jy lp kc lq kg lr ld me lk ll lm bi translated">最后一个时间步长的单元状态。(无，256)</li></ul><p id="6177" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">每个时间步长的输出都是形状(无，256)。但是，在每个时间步，解码器输出应该是eng_vocabulary中的一个单词。通过units=eng_vocab_size向每个解码器输出传递一个密集层，如下所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nv"><img src="../Images/66b126217526d8e6d08fa5129b152b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i3nsGDvw5tTidcXUjDv_SQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在每次解码器输出后传递密集层(units=eng_vocab_size)。</figcaption></figure><p id="f026" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">由于我们希望在每个时间步通过密集层，因此用时间分布层包裹密集层。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Code:密集层到解码器输出的每个时间步。</figcaption></figure><p id="e61c" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">我们的模型有两个输入，编码器输入，解码器输入和一个输出密集输出。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">带编码器和解码器的最终模型</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nw"><img src="../Images/adf57a80b062a466803dc48142939889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zsEtJ1No_2CwCLiB1GDwFw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">模型摘要</figcaption></figure><blockquote class="mu mv mw"><p id="da8c" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">我们在每个时间步的<em class="hi"> dense_output </em>形状的预测值是<em class="hi"> (None，eng _ vocab _ size)soft max probabilities</em>，但是目标即<em class="hi"> tar_lan_out </em>是一个整数序列数据。两个形状不匹配。！！怎么办。</p></blockquote><p id="5181" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">我们可以在训练之前将我们的目标数据转换成<em class="ma"> one_hot_encoded </em>形式，或者使用损失函数作为“<em class="ma">sparse _ category _ cross entropy</em>”。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在开始训练之前编译模型。</figcaption></figure><p id="bc42" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">现在是训练模型的时候了。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">开始训练模型。</figcaption></figure><h2 id="f1d6" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">5.推论:</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nu"><img src="../Images/7cc04826c42c4cccb2d6c8ef91851e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*U1-bdJpn5o4mgq_nrAB7Hw.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用示例说明编码器-解码器模型中的推理</figcaption></figure><p id="b170" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">请继续阅读该部分，以理解我们在推理部分到底在做什么。</p><blockquote class="mu mv mw"><p id="e58c" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">给定一个意大利序列，如果我们使用model.predict(seq)，你会得到一个错误。请记住，我们需要有两个输入编码器_输入和解码器_输入，然后只有你会得到解码器_输出。</p></blockquote><p id="7899" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">该模型将采用两个输入意大利语序列和英语序列，您将获得输入的时移版本，如下所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es et"><img src="../Images/93d2ce9b1963e7c2acf6b6c7bd55a88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2e5RFFY2iI9_z_jMhDJK6g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">标记化后的输入和输出示例</figcaption></figure><blockquote class="mu mv mw"><p id="ea28" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">但是我们的目标是预测一个只有意大利语句子的英语句子。</p></blockquote><p id="7dae" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">因此，很明显，我们不能使用我们已经培训过的相同模型，让我们稍微修改一下这个模型，以便它能为我们的目的服务。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nx"><img src="../Images/189fa720ff7807df73b54a40072c52c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owQsMlTvPujFkF1m7RjcRg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">时间步长1的解码器</figcaption></figure><p id="afa0" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">让我们把它分解成每一个时间步。像往常一样，我们将输入发送到编码器，并获得最终状态。在解码器的第一个时间步，用编码器最终状态初始化，并发送输入<em class="ma"> 1。(</em><em class="ma">的文字索引&lt;开始&gt;)。</em>这有助于解码器理解这是序列的开始。</p><p id="09d4" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">解码器输出形状(无，256)被传递到密集层(无，eng_vocab_size)。为了得到解码器以最大概率预测的字，应用Argmax。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ny"><img src="../Images/d6bdfb13fbc08372ff28f81d51070431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPaiGhbyVZ83RwuW4zv-Xg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">时间步长2的解码器</figcaption></figure><p id="3c86" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">在时间步长-2 D2中，将采用两个输入，先前的状态值和先前的输出。</p><p id="68ad" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">如左图所示，D2采用先前的状态值和输出。</p><p id="cfad" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">像往常一样，我们将在解码器的顶部应用一个密集层，并在顶部应用一个argmax层，以获得单词的token_id表示。</p><p id="5518" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">如下所示，D2州值将用于下一个时间步长。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nz"><img src="../Images/eea5ec9f7187fb789daeecce5c97d9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Xbckvbx5gvf-dCYAE5eMA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">时间步长3和4的解码器。</figcaption></figure><p id="5b72" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">时间步骤3和时间步骤4的流程类似。为了更好的理解，请浏览下面的图片。</p><p id="c262" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">在时间步长-4中，解码器已经预测了<em class="ma"> 2( &lt;停止&gt;)。</em>一旦解码器预测到&lt;停止&gt;表示句子完成，我们将停止解码器。</p><p id="8f05" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">让我们构建一个<em class="ma">编码器_模型</em>，它接受一个输入_序列并给出状态值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">推理编码器模型—在给定输入序列的情况下返回encoder_lstm输出</figcaption></figure><blockquote class="mu mv mw"><p id="1e7f" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">encoder_model给出最终的状态值，然后退出画面。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oa"><img src="../Images/7d5965a72240fb6cea19dfebcd19684e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nl3-hHfYyE24pZPn1j8r4w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">编码器型号摘要</figcaption></figure><p id="4732" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">如左图所示，编码器接受shape(None，9)的输入，9是意大利语序列的max_length。</p><p id="a07d" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">输入被传递到嵌入层，然后传递到编码器_LSTM，返回单元状态值。我已经在前一节讨论了这些形状。</p><blockquote class="mu mv mw"><p id="8e9e" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">创造一个没有经过训练的新模型有什么用，之前做的训练不会变得没用吗？</p></blockquote><p id="c20a" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">如果你观察清楚，我们使用的是相同的图层。为了进一步确认，打印编码器嵌入层的前10个权重。在编码器模型中，嵌入层是第二层，在我们的训练模型中，它是第三层。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">将编码器模型的权重与我们在上一节中训练的模型进行比较。</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ob"><img src="../Images/8dcd90e4986758a98980752cfb1d8e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9hxhwgy2b-sHw4qvOav4EQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">编码器模型和训练中使用的模型的权重</figcaption></figure><p id="93a5" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">我们来定义一下decoder_model。它需要三个输入:输入序列、隐藏状态、单元状态。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">解码器型号的输入。</figcaption></figure><p id="2f21" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">将解码器输入传递到嵌入层。然后传递给decoder_lstm。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">解码器模型的推理</figcaption></figure><p id="a697" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">将解码器输出传递到密集层，以找到解码器预测的每个单词的概率。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">将解码器模型传递到密集层</figcaption></figure><blockquote class="mu mv mw"><p id="6519" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">decoder_embedding_layer、decoder_lstm、decoder_dense是我们在训练时在解码器中使用的相同层。</p></blockquote><p id="005d" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">将所有东西放在一起并定义模型。decoder_model采用两个输入input_sequence和初始状态，并返回两个输出，即每个字的概率输出、单元状态值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">推理的完全解码器模型</figcaption></figure><p id="179f" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">可视化架构:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oc"><img src="../Images/1df6ee6a49d5798c1fb9b0ce15666310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJeZiwh5NLuWDVGInEqXrw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">解码器模型有三个输入，第一个输入被传递到嵌入层，另外两个输入是单元状态和隐藏状态。</figcaption></figure><ol class=""><li id="2f14" class="le lf hi kn b ko ls kr lt jy mb kc mc kg md ld lj lk ll lm bi translated">将输入序列传递给编码器，并获取encoder_final_state值。</li></ol><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">将样本序列传递给编码器模型并获取输出</figcaption></figure><p id="81b2" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">2.用<start>令牌的word_index值初始化一个变量target_variable。</start></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用<start>初始化形状(1，1)的目标字。</start></figcaption></figure><p id="a162" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">在解码器的第一个时间步，将目标变量和编码器最终状态发送到解码器模型，以获得输出和状态。</p><blockquote class="mu mv mw"><p id="6fb1" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">我们只向解码器发送一个形状字(1，1)。但是在训练中，如果我们已经将input_to_decoder的形状声明为(Batch_size，max_len_sentence ),那么我们的推断可能不起作用，因为解码器接受max_len_sentence的input_length。</p><p id="c089" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">因此，为了使input_to_decoder能够接受任何长度的句子，并在训练和推理过程中工作，我们将input_to_decoder的形状声明为(None，None)。</p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">将编码器状态和<start>传递给解码器并获得输出</start></figcaption></figure><p id="73f0" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">将argmax应用于输出，以获得解码器以最高概率预测的单词。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">向解码器输出传递一个argmax，以获取解码器以最大概率预测的单词。</figcaption></figure><p id="575c" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">我们将继续这个过程，直到到达字符串的末尾或句子的最大长度。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">为我们的解码器添加一个终止条件。</figcaption></figure><p id="8bb6" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">将所有内容组合在一起，包装在一个推理函数中，该函数将意大利语序列作为输入，并返回英语句子。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">代码:完整的推理代码</figcaption></figure><h2 id="a857" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">6.结果:</h2><p id="60d8" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">以下是一些结果。如果您想生成以下格式的结果表，请随意查看博客末尾引用的代码库。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es od"><img src="../Images/37e1805ccd41efd73d5511ef0b0e0ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYnvZBt76JS836W5tRgFaQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">训练后获得的输出。</figcaption></figure><p id="28f6" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">是的，如果你仔细观察，有些结果并不太好。我们将在下一节讨论我们能做些什么。但至少有了20k行的训练数据，我们得到的预测词拼写是正确的。</p><blockquote class="mu mv mw"><p id="4539" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">要进一步提高模型性能，请在整个数据上训练模型，使用嵌入层、LSTM大小。</p><p id="d90d" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">为什么你认为我们的模型没有任何拼写错误？</p></blockquote><p id="0e5b" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">请记住，我们对每个单词进行了标记和索引。所以每次我们的解码器预测字典中的任何单词。所以没有机会犯拼写错误。</p><blockquote class="mu mv mw"><p id="de49" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">如何让解码器学习新单词？</p></blockquote><p id="4a19" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">不要在单词级别进行标记，而是在字符级别进行标记。所以每次解码器都会预测一个字符。就代码而言，这是一个小变化。</p><pre class="iy iz ja jb fd nj nk nl nm aw nn bi"><span id="ffbc" class="jn jo hi nk b fi no np l nq nr">Tokenizer(filters='',char_level=True)</span></pre><h2 id="90d2" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">6.模型的缺点:</h2><p id="ef87" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">我已经在<a class="ae lx" href="https://www.kaggle.com/jiriroz/qa-jokes" rel="noopener ugc nofollow" target="_blank">笑话数据集</a>上训练了相同的模型。它包含一个问题(“小鸡为什么要过马路”)、相应的答案(“为了到达另一边”)和一个唯一的id。与我们在帖子中使用的数据集相比，独特单词的数量和句子的长度相对较大。你可以在我的GitHub知识库中找到这个模型的笔记本细节和语言翻译模型。</p><blockquote class="mu mv mw"><p id="802e" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">声明:笑话数据集可能会冒犯一些人。我只是用它来学习。</p></blockquote><p id="9fea" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">经过50个时期的训练，这个模型没有学到很多东西，这是我得到的一些结果。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oe"><img src="../Images/cc5606c6d23a4830443a457ce4c2758c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2MtWTCpmAiSYOzo8rX0HPg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">笑话数据集的输出。</figcaption></figure><p id="85b9" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">问题出在编码器上，给定一个100个单词的句子，编码器给解码器的只是两种状态。编码器不能捕捉句子的本质。</p><blockquote class="mu mv mw"><p id="6bfc" class="kl km ma kn b ko ls ij kq kr lt im kt mx lu kv kw my lv ky kz mz lw lb lc ld hb bi translated">当我们将一段信息从意大利语翻译成英语时，让我们从人类的角度来理解这一点。我们不会读整段，然后逐字翻译。我们所做的是读几行意大利语，然后翻译成英语，读几行，然后翻译回来…直到段落结束。</p></blockquote><p id="efce" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">如果我们可以建立一个系统，在预测之前从所有编码器状态中提取信息，而不是只获取最终状态，那么它就可以很好地工作。同样叫<strong class="kn hj"> <em class="ma">关注</em> </strong>哪个比较受欢迎。注意力是如何工作的超出了这篇文章的范围。</p><p id="7b31" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">我很高兴你已经走到了最后，并在理解序列中迈出了下一步，以更紧密地对模型进行排序。如果你能给我任何形式的反馈，我将非常高兴。</p><p id="8f7a" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">你可以在这个GitHub <a class="ae lx" href="https://github.com/GowthamChowta/Machine-Translation-blog" rel="noopener ugc nofollow" target="_blank">链接</a>中找到完整的代码。也可以在<a class="ae lx" href="https://www.linkedin.com/in/gauthamchowta/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p><h1 id="e720" class="of jo hi bd jp og oh oi jt oj ok ol jx io om ip kb ir on is kf iu oo iv kj op bi translated">参考资料:</h1><ol class=""><li id="4caf" class="le lf hi kn b ko kp kr ks jy lg kc lh kg li ld lj lk ll lm bi translated"><a class="ae lx" href="https://blog.keras.io/a-ten-minute-introduction-to-sequence-to-sequence-learning-in-keras.html" rel="noopener ugc nofollow" target="_blank">https://blog . keras . io/a-ten-minute-introduction-to-sequence-to-sequence-learning-in-keras . html</a></li><li id="3e6f" class="le lf hi kn b ko ln kr lo jy lp kc lq kg lr ld lj lk ll lm bi translated"><a class="ae lx" href="https://www.appliedaicourse.com/" rel="noopener ugc nofollow" target="_blank">应用人工智能课程</a></li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oq"><img src="../Images/4db112baf9c48414b9fd49f1193b9852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CTuBxC9kYwQk2iBN.gif"/></div></div></figure><p id="08bc" class="pw-post-body-paragraph kl km hi kn b ko ls ij kq kr lt im kt jy lu kv kw kc lv ky kz kg lw lb lc ld hb bi translated">如果你觉得这个博客有用，请点击拍手按钮，让我的一天更快乐..:)</p></div></div>    
</body>
</html>