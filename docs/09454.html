<html>
<head>
<title>A Newbie’s Chronicles on Distributed Data Processing — S01E03: Grand Finale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式数据处理新手编年史——第一季第三集:大结局</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-newbies-chronicles-on-distributed-data-processing-s01e03-grand-finale-99b7cc8601cb?source=collection_archive---------30-----------------------#2020-09-06">https://medium.com/analytics-vidhya/a-newbies-chronicles-on-distributed-data-processing-s01e03-grand-finale-99b7cc8601cb?source=collection_archive---------30-----------------------#2020-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="627c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">声明:如果你没有读过这一季的前几集，我建议你先读一下<a class="ae jd" rel="noopener" href="/@athityakumar/a-newbies-chronicles-on-distributed-data-processing-s01e01-pilot-5c76fb052db5">s01e 01</a>&amp;<a class="ae jd" rel="noopener" href="/@athityakumar/a-newbies-chronicles-on-distributed-data-processing-s01e02-optimizations-galore-a91eff7cdb02">s01e 02</a>以获得更多的上下文和更好的阅读流程。</p><p id="6b34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回顾:在前几集，我们针对我们的需求进行了概念验证，将其扩展到1TB，并进行了一些优化。但是由于一个未知的路障，我们仍然无法继续前进。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="1397" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">路障:深深切入的匕首</h1><p id="0d37" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">应用程序日志本身对于调试来说不是很有用，因为我们只能看到任务失败——而不是它们失败的确切情况。例如，我们看到由于JOIN步骤中的内存问题，我们的代码仍然失败。这很奇怪——因为在我们上一集所做的优化改变之后，内存不应该成为问题。</p><p id="a199" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们求助于我们的秘密武器库:Spark Web控制台！</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ko"><img src="../Images/2c3126a642efc17dd7c7c3f6e173e5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tUzQU_NjvBTqA4jEO9Cuw.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">样本Spark Web UI，演职员表:【https://spark.apache.org/docs/3.0.0-preview/web-ui.html T4】</figcaption></figure><p id="470c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，这是一个由Spark提供的仪表板UI，它以一步一步的方式为正在运行的作业抛出许多有用的提示，如阶段、任务、花费的时间、节点状态、内存指标等。</p><p id="0c1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至少可以说，它就像一把调试用的瑞士小刀一样。当我们查看当前应用程序的运行时，我们发现，出于某种原因，在JOIN操作期间，我们之前用于读取增量数据的一个<em class="le">预处理</em>步骤被再次调用，而不是重用我们已经在<em class="le"> count() </em>操作阶段获得的输出。</p><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">重读增量数据的神秘案例</figcaption></figure><p id="e2a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢天谢地，<a class="ae jd" href="https://www.linkedin.com/in/sanketsahu9394/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Sanket </strong> </a>对这个问题很熟悉，因为他自己也曾面对过这个问题，他向我们详细解释了这个问题。</p><blockquote class="lh li lj"><p id="ed45" class="if ig le ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">基本上，Spark根据Catalyst的逻辑计划在DAG(有向非循环图)中保存计算值的版本。现在，根据其下一次操作的内存可用性(或需求),存储在DAG中的最早的值会被一个接一个地清除，直到我们为下一次操作准备了足够的内存。</p></blockquote><p id="b374" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，我们的增量数据帧的一个变体必须从DAG中清除，以适应连接操作，并且它试图再次读取它们并从头开始处理。这就是为什么它遇到了内存问题，并且在失败任务的最大容许重试次数为4次之后，作业开始失败。</p><p id="3b24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里想，如果数据帧在成功执行<em class="le"> count() </em>时在内存中，那么对于后续的连接步骤，它仍然在内存中。事实上，在这两行代码之间，数据帧可能会从DAG中被清除——感觉像是被我自己的代码出卖了。😢</p><blockquote class="lh li lj"><p id="70e1" class="if ig le ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated"><em class="hi">信任问题:“你好，好久不见。”</em></p></blockquote><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ln"><img src="../Images/53ea8ac3e8e68d8ec36c97f55b43c523.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*YzkCzgftPEFmU4CPhYsNaQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">阿纳·戈斯瓦米解释我感受到的背叛</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="4fd4" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">向上，向上，向上！</strong></h1><p id="5d2e" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">现在我们已经锁定了DAG问题，解决方案非常明显。这就是开销:读取2 TB的json数据(再次)效率非常低，因为json没有相关的压缩，嵌套模式需要再次预处理。因此，如果我们将预处理的数据帧存储到压缩的parquet文件中，或者以某种方式将它保存在内存中，我们将能够继续进行实际的<em class="le"> join() </em>操作，而不需要被重定向来再次读取json数据。</p><p id="243d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很直观地，它不够小，不能直接<em class="le">在集群中</em>广播——所以我们不得不使用parquet。我们做了这样的改变，瞧——我们跳到了2TB &amp;,甚至处理4TB的数据也非常有效！🎉</p><p id="2fe4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在8TB的冲击下，出现了最后一个障碍——相对来说，调试和解决IMO都比较容易。又是一个内存问题，但这一次，它在保存最终物化数据时失败了。</p><p id="5e7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，我们正在处理海量的数据，其中的I/O也需要处理。因此，我们必须根据正在处理的增量数据的规模对数据进行分区。我们也加入了这个逻辑:</p><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">为胜利而动态分区！</figcaption></figure><p id="96c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在所有这些累积的变化之后，我们的代码现在可以稳定可靠地运行8TB、16TB甚至24TB！🎉</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lo"><img src="../Images/71b64fd55bf13e4ca5cf483abdd3bf8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/1*EU8AoRR-T-enxEbh50azkQ.gif"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">我们代码的能力从100GB扩展到24TB的真实镜头！</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="15c2" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">排列和组合</h1><p id="7e2a" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">既然我们的代码已经经过了大规模测试，我们必须在结束之前确定基础参数的最佳组合。我们列出了所有实例类型，根据最小内存需求、最小vCPU需求和每小时最大成本对它们进行了筛选。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lp"><img src="../Images/91e74cf0205b4b4db0cc03f4fb6b08dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*2Yeuig2ffEYQmXY2sQfG5A.gif"/></div></figure><p id="7e85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有像c5.9xlarge、m5.8xlarge等好但贵的实例，也有像r5.2xlarge、m4.4xlarge等差但便宜的实例。然而，由于我们的用例需要在I/O(读写)和计算(对于像JOIN这样的操作)之间进行平衡，r5.2xlarge和r5.4xlarge实例显然是赢家！🏅</p><p id="273d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，要么x台r5.4xlarge的机器，要么2台r5.2xlarge的机器——两者性能相当。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="3151" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">还有，场景！</h1><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lq"><img src="../Images/9b6d7a4ccecc484e3bd292ef6ab530ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4P9s7EOCDI6OOJnXsYr-3A.jpeg"/></div></div></figure><p id="9b9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总而言之，我认为这是一次很好的实践学习经历！自然，我们面临的大部分障碍都是由于我们操作的数据规模太大。首先，拥有如此大量的数据进行工作是一件很棒的事情；此外，在此基础上构建功能也是锦上添花！也许在建造它的过程中肯定会经历一次过山车<em class="le">(感谢信任问题，Spark DAG)</em>；但回想起来绝对是一次很棒的经历。</p><p id="62f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于刚刚进入Spark行业的人来说，有几点需要学习:</p><ul class=""><li id="306c" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated">你写的代码是“<em class="le">懒惰</em>，并且直到一个“<em class="le">动作</em>开始才会真正执行</li><li id="2c17" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">请注意所有spark配置/变量、它们的默认值和它们的限制</li><li id="1682" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">充分利用Spark控制台UI——解决问题通常比调试和识别问题更容易</li></ul><p id="d612" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我要向那些没有这种能力的人大声疾呼:</p><ul class=""><li id="3a2b" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated"><a class="ae jd" href="https://www.linkedin.com/in/sanketsahu9394/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">桑吉萨胡</strong> </a> —星火pro。不仅仅是帮我调试，还教会我如何自己调试。还有低调的容忍我所有的质疑。</li></ul><p id="c70a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi mf translated">我给了一个人一条鱼，你喂了他一天；教一个人钓鱼，你可以喂他一辈子</p><ul class=""><li id="0baa" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated"><a class="ae jd" href="https://www.linkedin.com/in/pravin-agrawal-25409329/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">普拉温</strong></a><a class="ae jd" href="https://www.linkedin.com/in/sarangzargar/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">萨朗</strong></a><a class="ae jd" href="https://www.linkedin.com/in/guptagautam/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">高塔姆</strong></a><strong class="ih hj">&amp;co</strong>——客户。要求这种能力。也感谢大家积极参与富有成效的讨论，没有这些讨论，这样的无缝协作是不可能的！</li><li id="f423" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated"><a class="ae jd" href="https://www.linkedin.com/in/ashwinikumar1/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a>—绑定链接。完整地处理了需求的各个方面，并很好地规划了时间表。</li><li id="27a5" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated"><a class="ae jd" href="https://www.linkedin.com/in/desourabh/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a>——产品经理。自信地接受这个挑战性的任务，并有一个舒适的计划时间表。</li><li id="8bb5" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated"><a class="ae jd" href="https://www.linkedin.com/in/kiranashwath/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">基兰A </strong> </a> —经理/总监。把这个有趣的任务放在我的盘子上！</li></ul><p id="95c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">鳍。</strong></p><p id="cb3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想看更多的新手编年史系列吗？Ping我，或者在下面评论——请告诉我！</p></div></div>    
</body>
</html>