<html>
<head>
<title>Generating Fractals using Lindenmayer systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Lindenmayer系统生成分形</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/generating-fractals-using-lindenmayer-systems-6214dddbe223?source=collection_archive---------0-----------------------#2018-11-21">https://medium.com/analytics-vidhya/generating-fractals-using-lindenmayer-systems-6214dddbe223?source=collection_archive---------0-----------------------#2018-11-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b57fa259f17cefa3f732adb2bb853fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZBeBjKVdb-3aPa1m.png"/></div></div></figure><h1 id="006b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">描述</h1><p id="2a2f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">1968年，匈牙利植物学家Aristid Lindenmayer开发了一个基于语法的系统来模拟植物的生长模式。最初，<strong class="jq hj">L-系统</strong>(linden Mayer系统的简称)被设计用来提供简单多细胞有机体发展的正式描述，同时说明植物细胞之间的邻近关系。后来，这个系统被扩展到描述高等植物和复杂的分支结构。</p><p id="3a71" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">植物生长的逼真建模对生物学、物理学以及计算机图形学都有很高的价值(例如，视频游戏正在使用并仍在使用它来改善植物/森林的渲染)。</p><p id="fbe4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们将看到它是如何工作的，并用它们来生成各种递归分形图案。它们非常有趣，因为它们为<strong class="jq hj">跟踪分形结构</strong>提供了一种机制，而分形结构需要复杂和多面的产生规则。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/5729386004dc72721273187bb296abed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I8NDjmz9RrsWZsDX.png"/></div></div></figure><h1 id="bfa1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">如何构建</h1><h1 id="967e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">作文</h1><p id="1c2b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们快速看一下L系统的组成，它涉及四个主要组件:</p><ul class=""><li id="0409" class="kw kx hi jq b jr km jv kn jz ky kd kz kh la kl lb lc ld le bi translated"><strong class="jq hj">字母:</strong>包含可管理的有效符号。例如，我们可以说字母表是{'F '，' X '，' Y'}，这意味着这三个字符<strong class="jq hj">中的任何一个都可以根据规则</strong>进行替换。</li><li id="56ab" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">常量:</strong>不会被替换的符号。大多数时候常量至少包含<strong class="jq hj">！</strong>、<strong class="jq hj">、</strong>、<strong class="jq hj">、</strong>、<strong class="jq hj"> + </strong>、—(参照目视判读)，用于图形指令。</li><li id="5daa" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">公理:</strong>公理描述了系统的<strong class="jq hj">初始状态</strong>(迭代0时)。例如，它可以是“F”、“FX”、“F-F-F”或其他任何值。</li><li id="fe52" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">规则:</strong>规则简单来说就是<strong class="jq hj">一个以符号为参数</strong>的变换。这些规则依次应用于公理的每个符号，然后在每次迭代中反复应用。如果我们采用“A → AB”规则:每当在当前状态中发现一个“A”符号，它就被替换为“AB”。</li></ul><p id="ca70" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们现在已经具备了构建一个简单示例的所有条件；让我们来研究林登迈耶最初用于模拟藻类生长的系统。</p><h1 id="1a86" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">例子</h1><ul class=""><li id="1ec2" class="kw kx hi jq b jr js jv jw jz lk kd ll kh lm kl lb lc ld le bi translated"><strong class="jq hj">字母表:</strong> A，B</li><li id="c507" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">常量:</strong> <em class="ln">无</em></li><li id="ce15" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">公理:</strong> A</li><li id="1f57" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">规则:</strong> (A → AB)，(B → A)</li></ul><p id="8eee" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">系统从公理“A”开始(迭代0 ),有两个结果，一个用于A，一个用于B；看看前五次迭代:</p><ul class=""><li id="d7e7" class="kw kx hi jq b jr km jv kn jz ky kd kz kh la kl lb lc ld le bi translated">迭代0 : A</li><li id="a27b" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">迭代1 : AB</li><li id="84f5" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">迭代2 : AB A</li><li id="74b0" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">迭代3 : AB A AB</li><li id="54cb" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">迭代4 : AB A AB AB A</li></ul><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/424f8164c88ce872279538ccd5a39ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/0*6eB72LmZtpt5Ts2d.png"/></div></figure><p id="c2e0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">对于第一次迭代，我们简单地为A应用第一个规则。在第二次迭代中，我们必须为A和B应用规则，等等。等等。<br/> <strong class="jq hj">导数呈指数增长</strong>因为在每次迭代中，一个字母经常被两个或更多的字母代替。</p><h1 id="c1f1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">伪代码</h1><pre class="ks kt ku kv fd lp lq lr ls aw lt bi"><span id="3996" class="lu ir hi lq b fi lv lw l lx ly">string LSystem(axiom, rules, depth)<br/>{<br/>  string production;</span><span id="f00d" class="lu ir hi lq b fi lz lw l lx ly">  // For each iteration:<br/>  for (auto level = 0; level &lt; depth; ++level)<br/>  {<br/>    // Initialize production to empty string at each iteration<br/>    production = '';</span><span id="d4e9" class="lu ir hi lq b fi lz lw l lx ly">    // Iterate over each symbols/characters of the current axiom<br/>    for (auto symbol = axiom.begin(); symbol &lt; axiom.end(); ++symbol)<br/>    {<br/>      // Transform it if a rule applies<br/>      if (rules.has(symbol))<br/>        production += rules.get(symbol);<br/>      // Add it without change otherwise<br/>      else<br/>        production += symbol;<br/>    }</span><span id="ba8b" class="lu ir hi lq b fi lz lw l lx ly">    // Update the axiom to its new content<br/>    axiom = production<br/>  }</span><span id="85b1" class="lu ir hi lq b fi lz lw l lx ly">  return production;<br/>}</span></pre><p id="838c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">L系统规则的<strong class="jq hj">递归性质</strong>导致<strong class="jq hj">自相似性</strong>，从而<strong class="jq hj">类分形形式</strong>。<br/>现在，让我们看看那些字符串是如何变成曲线的描述的！</p><h1 id="368b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">视觉表现</h1><p id="d977" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">递归L系统，如上所述，经常产生错综复杂的模式，这些模式在多个尺度上是自相似的。</p><blockquote class="ma mb mc"><p id="e22c" class="jo jp ln jq b jr km jt ju jv kn jx jy md ko kb kc me kp kf kg mf kq kj kk kl hb bi translated">人类几乎不可能从一长串符号中直接感知这些图案。与许多类型的数据一样，图形表示可能会暴露它们。</p></blockquote><p id="94ec" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">最常见的表示L系统的图形方式是基于<strong class="jq hj">海龟解释</strong>(作为LOGO编程，一种非常古老的[1967]用海龟教授计算机科学的孩子友好的方式)，通过<strong class="jq hj">在笛卡尔平面</strong>中命令海龟来绘制。</p><blockquote class="ma mb mc"><p id="36ab" class="jo jp ln jq b jr km jt ju jv kn jx jy md ko kb kc me kp kf kg mf kq kj kk kl hb bi translated">想象一只乌龟坐在你的电脑屏幕上，你可以对它发出一系列命令:前进、左转、右转、画线等等。</p></blockquote><p id="57a6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，我们可以<strong class="jq hj">将每个符号关联到一个命令</strong>；以下字典通常用于L系统:</p><ul class=""><li id="9f14" class="kw kx hi jq b jr km jv kn jz ky kd kz kh la kl lb lc ld le bi translated"><strong class="jq hj"> F </strong>:向前划一条线(演示默认方向向东前进)</li><li id="25d7" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj"> G </strong>:向前移动(不划线)</li><li id="db28" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj"> + </strong>:左转(一定角度)</li><li id="e02c" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj"> - </strong>:右转(一定角度)</li><li id="7b0b" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj"> [ </strong>:推送当前位置</li><li id="9996" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">】</strong>:弹出位置</li></ul><h1 id="ff1c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">例子</h1><p id="30e6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们来解读一下<strong class="jq hj">旋转90度</strong>和<strong class="jq hj">开始朝北</strong>的字符串<strong class="jq hj"> F — F — F — F </strong>。虽然你已经可以想象出最后的画了，但这是乌龟画的:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/16c483052b83af11795abb1837d2eb54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rx2AKEgI2ItxnBaJ.png"/></div></div></figure><blockquote class="ma mb mc"><p id="c0fe" class="jo jp ln jq b jr km jt ju jv kn jx jy md ko kb kc me kp kf kg mf kq kj kk kl hb bi translated">！是时候产生一个分形了！</p></blockquote><h1 id="3f05" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">可视化分析</h1><p id="3fbd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们将逐步创建一个<strong class="jq hj">科赫三角形</strong>分形(如上所述)。</p><ul class=""><li id="f5b8" class="kw kx hi jq b jr km jv kn jz ky kd kz kh la kl lb lc ld le bi translated"><strong class="jq hj">字母表:</strong> F</li><li id="0b33" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">角度转:</strong>60°</li><li id="268c" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">常量:</strong>T45】无</li><li id="a28f" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">公理:</strong> F</li><li id="d9b4" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">规则:</strong> F → F+F — F+F</li></ul><div class="ks kt ku kv fd ab cb"><figure class="mh ij mi mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/621e6815269c1ee3cdd429772ef779bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/0*6rL1QXHHSZdr4pVs.png"/></div></figure><figure class="mh ij mn mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/b370e846f0c25789cdd7666c3390ff91.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*InpzkoCV8qUq-Nki.png"/></div></figure><figure class="mh ij mo mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/f885a5c295ba08356a5ce987aff782ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/0*P4wzS7T7tBxW75Oy.png"/></div></figure></div><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/29b66423b626f450cceee8a867ca563e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5g4g5Ykuojk43sPt.png"/></div></div></figure><p id="e896" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">1.第一次迭代是公理‘F’:<br/>-向前画</p><p id="bbb9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ln"> 2。然后线“F”(公理)按照规则<br/>F→F+F—F+F:<br/>--“F”:向前画<br/>-“+”:向左转60°<br/>--“F】:向前画<br/>-“-”:向右转120°(x2)<br/>--“F”:向前画<br/>-“+”:向左转60°<br/>-“F”:向前画</em></p><p id="51c1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">3.再一次:在每一个片段上应用规则。同样的主题以较小的规模重复出现。</p><p id="b67a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">4.深度为4的“科赫三角形”分形，但我们可以继续无限细化分形。</p><p id="b327" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让自己试一试吧！(在线演示)</p><h1 id="cfcc" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">l系统类型</h1><p id="163d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们在这里已经看到了最简单的L-系统来处理；然而，更先进的系统是存在的，并且可能被建造。以下是可能使用的不同类型的列表:</p><ul class=""><li id="e7de" class="kw kx hi jq b jr km jv kn jz ky kd kz kh la kl lb lc ld le bi translated"><strong class="jq hj">确定性上下文无关系统或D0L-系统:</strong>如果每个符号恰好有一个产生式规则，那么称L-系统是确定性的。如果每个产生式规则只涉及一个单独的符号，而不涉及它的邻居，那么L-系统就是上下文无关的。</li><li id="bf1f" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">随机上下文无关系统(context-free System)或S0L-Système </strong>如果一个符号有几个产生式规则以一定概率被选择，那么它就是随机L系统。</li><li id="8357" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">上下文敏感系统，IL-系统，或(k，l)-系统:</strong>上下文敏感语法不仅查看它所修改的符号，还查看它之前和/或之后出现的符号</li><li id="74d0" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated"><strong class="jq hj">参数L-系统:</strong>在参数文法中，字母表中的每个符号都有一个与之相关联的参数列表。一个符号和它的参数列表被称为一个模块，参数语法中的一个字符串是一系列模块。</li></ul></div></div>    
</body>
</html>