<html>
<head>
<title>Simulating a Single Server Queuing System with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python模拟单服务器排队系统</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/simulating-a-single-server-queuing-system-in-python-f8e32578749f?source=collection_archive---------1-----------------------#2020-09-28">https://medium.com/analytics-vidhya/simulating-a-single-server-queuing-system-in-python-f8e32578749f?source=collection_archive---------1-----------------------#2020-09-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="d26e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">定义和目标</strong></h1><p id="e667" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这篇文章中，我将使用python中的numpy和pandas库在单服务器排队系统上展示一个<strong class="jf hj">离散事件模拟。运行模拟的目的是先验地测量系统的性能，并观察它在预定情况下的行为。</strong></p><p id="e3d0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">系统的元素只是客户和服务器，两者都可以是人或物体:</p><ul class=""><li id="e54c" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">客户:接受服务</li><li id="a924" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">服务器:提供服务</li></ul><p id="0cd1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在这个排队系统中，只有一个服务员为到达的顾客服务，这些顾客在得到服务后离开系统。为了简单起见，我们假设顾客到达的时间间隔服从均匀分布，服务员的服务时间也服从均匀分布。</p><p id="39d7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下一个到达时间是在每次客户到达时生成的，这意味着当客户到达时，我们随机抽样到达间隔时间，并计算下一个客户的到达时间。类似地，当顾客去服务器时，我们随机抽样服务时间并计算该顾客的离开时间。有时顾客到达时，仍有顾客在接受服务，所以他们必须排队等候，直到当前顾客离开，服务员有空。下面的flowchar对此进行了更详细的解释。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/9dd4f4b555ae34c91536448dc0477150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpGvAfqzQhZdxl5i7lOYCA.jpeg"/></div></div></figure><h1 id="4a17" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">型号</strong></h1><p id="4f57" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将使用numpy和pandas库来创建这个系统。随机生成的到达间隔时间和服务时间通过numpy.random.uniform()函数获得，该函数将均匀分布的最小值和最大值作为参数。</p><p id="c400" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，我们导入所需的库并定义问题的参数:我们假设到达间隔时间和服务时间遵循均匀分布，最大值分别为5分钟和6分钟。类似地，我们假设到达间隔时间和服务时间的最小值分别为3分钟和2分钟。在本练习中，我们将模拟的事件数量设置为30。</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="0ea0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">然后，系统在虚拟事件零处初始化，这通过<em class="li"> numpy.random.uniform() </em>函数生成第一个到达时间。默认情况下，第一个事件是到达，而服务器在第一个到达时间的状态是<em class="li">空闲</em>，队列是<em class="li">零</em>。事件归零完成，事件计数器增加(到1)。</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="82eb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">每个事件的细节都被添加到数据帧中，因此在最后我们可以用表格的方式来更好地理解这些事件，因此一旦服务器在事件1时的初始状态被确定；我们用之前获得的值创建这个数据框。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lj"><img src="../Images/b92fbea457340d96674a232804a44bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3undhmecjFkac-uLu-cu5A.png"/></div></div></figure><p id="42de" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，每个到达在模拟中生成下一个到达时间，并且根据排队系统(和常识)，如果队列为零，到达的客户将直接进入服务器。因此，这个到达将生成两个事件:这个到达客户的离开时间和下一个客户的到达时间。</p><p id="8d37" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面的代码将运行event one中的其余事件，并根据流程图获取每个客户的到达和离开时间。这段代码相对较慢，过于依赖熊猫，而且有多余的行，但是这样我发现更容易阅读和解释每一部分的功能，尤其是对于像我这样不是程序员的人。</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="fe88" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在所有迭代结束时，生成的数据框如下所示:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lk"><img src="../Images/1a681c99d1b371a7d4a67570e2f2a67b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqAgS_wL9-R2P6SGrnk3kA.png"/></div></div></figure><p id="f2c8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">需要注意的是，循环在n_events处停止，因此当达到所需的事件数时，系统会任意停止。这意味着一个客户可能已经在系统中，但是当模拟停止时，它将不会被服务。例如，下面是运行的最后五个事件，虽然客户16和17预期在运行停止之前到达，但是这些客户将不会被服务。因此，我们可以简单地删除这两行，只保留离开系统的客户。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ll"><img src="../Images/8e14d9517ac092a501857a29cd383ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJrJ3gvrPC6-_vOIC32OyA.jpeg"/></div></div></figure><p id="2044" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">最后，我们创建每个客户的事件时间摘要，并计算他们各自在队列、服务器和系统中花费的时间:从中我们可以计算平均值，等等。如果需要的话。</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">上面的代码删除了模拟停止时没有离开系统的客户</figcaption></figure><p id="d4ed" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面是上述代码生成的数据框的前五行，包含每个客户的时间:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lq"><img src="../Images/52bedc2e4810b8ebf800b353d45fccf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbcYjxVBqEOuvrJ4KfKepA.png"/></div></div></figure><p id="12b7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">到目前为止，我们已经进行了一次模拟运行，但是为了进行正确的分析和做出决策，需要进行多次模拟运行来观察系统的行为。我们需要多次运行上面的代码，并更改伪随机数生成器的种子，这样我们在每次运行时都会获得不同的随机数。为了实现这一点，我们创建了一个函数，它将运行上面解释的代码，并将一个“种子”整数作为参数，然后运行这个函数n次，每次迭代都改变“种子”,以便每次迭代都获得不同的随机样本。</p><p id="0f53" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面代码中的函数run_queue()运行上面解释的排队系统，并返回每个客户在队列、服务器和系统中的平均时间。例如，run_queue(seed = 1)返回以下内容:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lr"><img src="../Images/4e42e387afe0e14f1b7920b20f0de194.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*GyxOv16d4bp7XZ_fYXaoyw.png"/></div></figure><p id="7192" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">然后，我们创建另一个运行run_queue()函数n次的函数，并将每次运行的结果附加到一个数据帧中以查看结果。</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="a70e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="li">如上所述，运行队列的代码相对较慢，每次运行需要一秒多一点的时间，50次运行大约需要50到60秒才能完成。</em></p><p id="79fe" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">生成的数据框如下表所示，从这里我们可以获得实验的汇总统计数据，并根据需要绘制结果。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ls"><img src="../Images/9b13ae24b6e04e3b2d813ac3d9afc032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VOLIS7-DlTEFoiMhEm4FA.png"/></div></div></figure><h1 id="d67c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">模拟不同场景</strong></h1><p id="4d3c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">正如开始时提到的，运行模拟的目的是观察不同场景中的系统行为，并测量其性能。幸运的是，上面的代码允许通过改变分布的最大值和最小值很容易地做到这一点。</p><p id="37a3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面是原始问题的服务时间和到达间隔时间的分布(左图)以及50次运行后各自的平均指标(右图)。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lt"><img src="../Images/a7b4b4cc1e0e1e4395c69f7a73a801ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6nPFceTQgMVA1Pw4mLsnEw.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">平均排队时间= 1.713610 <br/>平均服务器时间= 3.914950 <br/>平均系统时间= 5.628637</figcaption></figure><p id="2e06" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">假设我们无法控制客户的到达间隔时间，但我们可以将最大服务时间从6分钟降低到5分钟，并想看看系统会如何运行。我们只需将变量s <em class="li">中的值service _ time _ max</em>更改为5，并通过函数<em class="li"> run_experiments() </em>运行50次模拟。新的概率分布和结果指标如下:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lt"><img src="../Images/47292694e80e2de66ecb6e05fd108a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhnE-Fi4knoZRBl9JQHZ_A.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">平均排队时间= 0.450533 <br/>平均服务器时间= 3.465720 <br/>平均系统时间= 3.916413</figcaption></figure><p id="e5a2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上面的例子只是说明模拟的用途，我不打算对系统的特性做任何分析。系统可以在多种情况下运行，从改变两种分布的最小值和最大值，到将分布从均匀变为正态或指数分布，并比较变化的幅度。</p><h1 id="03ff" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="7615" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">总之，我们建立了一个只有一个服务器的简单排队系统，到达时间和服务时间服从均匀分布。在现实生活中，排队系统显然比遇到的概率分布更复杂。然而，这个练习是一个很好的例子，说明了一旦我们构建了模型的代码，就可以很容易地重用它来运行实验，这些实验对于做出决策或预见可能阻碍所研究系统的稳定性的潜在场景是有用的。</p><p id="88ee" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">请在评论中随意指出你可能遇到的错误或建议。</p></div></div>    
</body>
</html>