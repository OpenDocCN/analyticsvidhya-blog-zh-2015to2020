# 被认为有害的 CAP 定理:NoSQL 的数据完整性& CAP 的替代方案

> 原文：<https://medium.com/analytics-vidhya/cap-theorem-considered-harmful-data-integrity-in-nosql-alternatives-to-cap-904c24e390d5?source=collection_archive---------12----------------------->

![](img/2197919d44be57c54b57d4c332ed0e3c.png)

米卡·鲍梅斯特在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

“最好避免 CAP”。广受好评的分布式系统畅销书[《设计数据密集型应用软件》](https://smile.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321/ref=sr_1_2?keywords=designing+data+intensive+applications&qid=1572997508&sr=8-2)如是说。为什么？

(所有引文均来自本书，除非另有说明)

我们打个赌:我给你 42 美元，然后你选择你想运行这些数据系统中的哪一个。

系统 1:

客户端浏览器向 web 服务器发送请求，web 服务器将该请求发送到 SQL 数据库:

```
BEGIN TRANSACTION;
UPDATE bank_account SET balance = balance + 40.00 WHERE account_id = 'Me';
UPDATE bank_account SET balance = balance - 40.00 WHERE account_id = 'You';
COMMIT;
```

系统 2:

客户端浏览器向 web 服务器发送请求，web 服务器向分布在全球的高可用性 NoSQL 集群发送请求。在这个集群中，我的帐户存储在分区 A(恰好位于夏威夷)，而您的帐户存储在分区 B(恰好位于南极洲)。每个分区单独(没有协调)运行代码来更新我们的余额。

如果您使用系统#2，您可能会认为，因为系统#2 使用高可用性集群，所以根据 CAP 定理，它在不可避免的网络分区期间无法保持一致。你已经听到人们警告 NoSQL 丢失和损坏数据。你已经听人们说过，“如果你正在执行一个金融交易，那么你最好使用一个 ACID 交易！”换句话说，也许你认为系统#2 不能保证我们的余额转移的一次性处理。也许你希望转账会丢失，这样你就能保留所有的 42 美元。也许你害怕转账会因为多次处理而被破坏，最后你会欠我的。

如果你选择系统 1，你可能会认为系统 1 保证我只拿回 42 美元中的 40 美元，这样你就多了 2 美元。毕竟，系统使用的是 ACID 事务，其中 C 代表一致。

我希望您选择系统#1，因为我知道 ACID 交易不会保护您免于被多次收费。当然，我保留了系统#2 中的一些细节，以保证您只被充电一次，即使该系统是容错的，其性能也是水平扩展的。

系统#2 如何保证你只被收费一次？CAP 定理证明了在网络划分期间不是一致的系统吧？实际上，CAP 定理在这里并不适用:“许多所谓的‘高可用’(容错)系统实际上并不符合 CAP 对可用性的特质定义”，这是其中之一。事实上，只要大多数节点都有响应，您就可以拥有一个在网络分区期间既高度一致又“可用”的系统。我们可以使系统#2 非常一致，但是我们没有。然而，它确实保证了强大的完整性。

嗯……如果我们可以在没有强一致性的情况下保证强完整性，那么强一致性给我们带来了什么额外的好处呢？它赋予了我们*极强的时效性*。

*时效性强*意味着用户阅读最新状态。

*强完整性*意味着没有丢失或损坏的数据。

这两者经常被合并成“一致性”。

有一种常见的误解，认为只有强一致性才能保证强完整性。这是错误的。

理解系统#2 *如何保证你被精确地充电一次，在理解系统# 1*如何不*保证你被精确地充电一次之后，理解系统# 2*如何保证你被精确地充电一次会更容易。**

*因此，让我们首先检查系统#1 的缺陷。*

*系统#1 的问题在于，它是一个分布式系统(web 浏览器、web 服务器和数据库是联网的),只能在数据库级别保证很强的完整性，而不能在系统级别。*

*什么会出错？*

*假设 web 服务器向数据库发送事务请求，但是在 web 服务器收到数据库的响应之前，网络进行了分区。网络服务器不知道交易是否被处理。如果 web 服务器重新连接并重新发送事务，数据库实际上可能会处理两个事务。相反，如果 web 服务器在重新发送交易之前检查 40 美元的转账是否发生，它不知道该转账是否来自其请求。问题是我们在网络连接和事务之间有 1:1 的映射，导致事务不能容忍网络分区。我们可以通过使用 2PC(两阶段提交)来消除这种 1:1 的映射，使 web 服务器-数据库网络分区具有容错性，保证在这一级上只进行一次处理。但是我们仍然有客户端浏览器。*

*客户端浏览器可以向 web 服务器发送事务请求，但是在客户端浏览器收到 web 服务器的响应之前，网络会进行分区。客户端浏览器不知道交易是否被处理，所以它告诉我有一个错误。我发出另一个请求。浏览器警告我:“您确定要重新提交此表单吗？”我说是的，因为我不知道我之前的提交工作，我想要我的钱。对 web 服务器来说，这是一个新的请求，对数据库来说，这是一个新的事务。(是的，在现实生活中，我不会发送提交此表单。如果一定要想象一个现实的场景，可以想象你想把房租钱转给室友。)*

*我们如何保证系统级的一次性处理呢？我们需要一个端到端的操作 id。*

*客户端浏览器可以在隐藏的表单字段中包含一个 UUID，这样它就可以与初始请求和任何重试请求一起发送。web 服务器将这个 UUID 传递给数据库，数据库保证它将只处理每个 UUID 一次。可能通过使用此 SQL 而不是上面的 SQL:*

```
*CREATE TABLE requests (
    request_id uuid PRIMARY KEY,
    from_account varchar(40),
    to_account varchar(40),
    amount decimal(19, 4)
);// The above table was created before our requestBEGIN TRANSACTION;INSERT INTO requests
    (request_id, from_account, to_account, amount)
    VALUES('totally-a-valid-uuid', 'You', 'Me', 40.00);UPDATE accounts SET balance = balance + 40.00 WHERE account_id = 'Me';
UPDATE accounts SET balance = balanced - 40.00 WHERE account_id = 'You';COMMIT;*
```

*有了这些改变，系统#1 现在保证了强大的完整性。如果我们不需要更好的性能或容错，这可能是比系统#2 更好的解决方案。但是它没有更好的完整性保证。*

*既然我们理解了为什么最初的系统#1 不能保证完整性，以及如何修复它，那么让我们看看系统#2 如何保证强完整性。*

*以下是处理步骤的概要:*

1.  *如在固定系统#1 中一样使用操作 id。转移请求根据操作 id 从客户端浏览器发送到 web 服务器，再发送到数据库分区，从而创建新的转移请求记录。*
2.  *这个新的转账请求记录导致 2 个新的转账记录:1 个到我的账户，1 个到你的账户。所有记录都包括操作 id。*
3.  *当我们的任何一个账户被读取时，转账记录被操作 id 删除重复，因此它们被处理*恰好一次*(确切一次的更好的说法是*有效一次，*但不幸的是确切一次更常用)。*

*请注意，任何步骤都可以多次发送消息，因为在最后，操作 id 会被重复删除，从而只进行一次处理。这使得系统具有高度的容错性。因为一切都是分区的，所以系统可以水平扩展。没有多节点提交意味着更高的可用性和更低的延迟，即使我们的数据库集群是全球分布的。*

*考虑到这些好处，我们为什么想要强及时性呢(这里强一致性给我们带来的唯一额外好处)？因为它简化了系统。*

*我们想要简单的系统，所以我们可能会说，“CAP 说我们通过在网络分区期间失去可用性来支付强一致性，但我们不是 Google，所以我们系统中的网络分区是如此罕见和快速，我们可以为此付费”。这可能是真的，但 CAP 并没有警告说，即使没有网络分区，强一致性也会带来更高的延迟。不幸的是，强一致性事务“通常只在单个数据中心工作”，并且它们“限制了规模和容错属性，尤其是在异构存储系统中”。随着多个数据中心、规模和异构存储系统成为越来越常见的业务需求，我们将需要在没有强一致性的情况下保证强完整性，即使我们的系统在网络分区期间可能不可用。*

*同样，为什么最好避免 CAP？*

*“在对 CAP 的讨论中……作为一个定理的形式化与其通常的含义不符。[例如，]许多所谓的“高可用性”(容错)系统实际上不符合 CAP 对可用性的特殊定义。总而言之，围绕 CAP 有很多误解和困惑，它并不能帮助我们更好地理解系统，所以最好避免 CAP。”*

*CAP 定理告诉我们的唯一一件事是，系统可以选择如何处理集群中的网络分区:要么停止处理写操作，要么冒着来自非多数节点的过时读操作的风险。这只是许多权衡中的一个，并不像大多数人认为的那样重要:如果我们有一个 5 节点集群，其中节点 1 无法与其余节点通信，节点 2-5 可以继续处理读/写，同时保持强一致性。此外，“CAP 现在已经被更精确的结果所取代，所以它在今天主要是有历史意义的”。*

*如果 CAP 是最好避免的，那么为什么人们仍然使用它(如果不正确的话)？因为它在历史上很重要，而且因为“CAP”曾经是一个非正式的术语，用来开始讨论各种类型的一致性和可用性之间的权衡。不幸的是，上限定理改变了这个术语的含义，这种混淆以及过载的术语“一致性”和“可用性”导致了误解。*

*因为 CAP 是最好避免的，所以我们应该考虑什么呢？*

*与其“一致性”甚至“强一致性”，不如想想“完整性”和“时效性”:我们需要什么样的数据时效性？我们需要什么样的数据完整性(答案出人意料地往往不是强完整性)？如果是强完整性，那么系统#1 表明我们应该能够在系统级别保证这一点，而不仅仅是在数据库级别。*

*与其考虑 CAP 定理的“总可用性”和集群网络分区，不如考虑系统需要有多高的性能、可伸缩性和容错性。当人们说“高可用性”时，他们通常意味着“容忍网络分区”，但我们通常对网络分区以外的故障更感兴趣，比如节点超时或被关闭，尤其是在云架构中。*

*结论:随着我们的业务需求越来越频繁地使强一致性变得过于昂贵，当设计系统时，我们必须学会在没有强一致性的情况下进行权衡。在这些与自己，尤其是与他人的权衡讨论中，CAP 没有帮助，反而有害。*

*PS:*

*   *强一致性不是 SQL -vs- NoSQL 的特性:强一致性是一些 NoSQL 数据库的缺省值，任何异步复制的数据库(SQL 或 NoSQL)都缺乏强一致性。*