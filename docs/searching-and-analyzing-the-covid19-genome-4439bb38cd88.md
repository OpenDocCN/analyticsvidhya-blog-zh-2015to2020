# 搜索和分析 COVID19 基因组

> 原文：<https://medium.com/analytics-vidhya/searching-and-analyzing-the-covid19-genome-4439bb38cd88?source=collection_archive---------14----------------------->

![](img/0a4074add6f261f5d7aaa26965718cff.png)

技术网络的信用

随着病例和死亡人数的持续上升，问题仍然存在，冠状病毒到底是什么？有许多不同类型的冠状病毒。有些接近无害，而有些甚至比新冠肺炎更致命。但是，这并没有告诉我们是什么让这种病毒与众不同。它感染的人数是 SARS 的 10 倍以上，杀死的人数是它的几倍。然而，没有人知道是什么赋予了这种病毒如此强大的传染能力。

但是我们知道的是它的基因组序列。`nCoV2019`是一种 RNA 病毒。然而，来自中国北京中国疾病预防控制中心的研究人员发表了冠状病毒的反转录 DNA 基因组序列。`nCoV2019`的基因组大约有 29000 个碱基对长。比人类或老鼠这样的复杂生物要短得多。然而，仍然有足够的力量感染全世界成千上万的人。

# 脱氧核糖核酸

在我们开始查看从中国武汉患者身上收获的冠状病毒基因组之前，让我们先了解一下什么是 DNA。脱氧核糖核酸(DNA)是由 4 种不同类型的碱基组成的双链梯形结构。它们是胸腺嘧啶、腺嘌呤、鸟嘌呤和胞嘧啶。在排序上，更常见的分别写成`T`、`A`、`G`、`C`。DNA 序列表示为有限的碱基序列，按照它们在实际 DNA 中出现的顺序排列。在编程语言中，DNA 序列可以表示为仅包含四个可能字符的字符串，`'T', 'A', 'G', 'C'`。

理论上，以下可以代表一串 DNA:

使用`char`类型来表示 DNA 碱基有一些挑战。首先，`char`可以是`-128`和`127`之间的任何值。基因组分析肯定不需要负值，我们只需要四个值来代表四个可能的碱基。第二，使用一个`const char*`文字强制每个基数用它的`ASCII`值来表示。这个值不符合顺序，比如`'A'`是 65，而`'G'`是 71。这防止碱基被用作*索引*，因为它们彼此不相邻。

此外，处理机器字大小的数据比处理比机器字更小的数据更有效。例如，在大多数 C/C++编译器上，小于机器字大小的结构中的字段将被填充:

最后，C 字符串以一个空字符`'\0'`结束。对于 DNA 来说，这是无效的，因为`0`是一个有效的 DNA 序列成员。单个整数不能终止 DNA 序列，

# 类型

*本文中的代码可以在* [*这个资源库*](https://github.com/jweinst1/ncov2019-analyzer) 中找到

为了克服`char`类型的缺点，可以使用包装在`struct`中的枚举类型，用一个案例代表每个基数:

给定这种类型，DNA 序列可以通过以下方式构建:

然而，为了有效地迭代和搜索 DNA 序列，我们需要适当的方法将文本数据转换成 DNA，以及封装`DNA::Base*`的数据结构。

# 转换

接下来，我们需要一种方法将 DNA 文本数据转换成`DNA::Base`类型。假设 DNA 数据是 UTF-8 或 ASCII 编码的，如下函数可以工作:

这种方法假设 DNA 数据可以是大写或小写。大多数`C++`编译器会从包含 5 个或更多案例的 switch 语句中生成一个跳转表。因此，将`const char*`数据转换为`const DNA::Base*`数据的复杂度应该只与文本数据的长度成线性关系。这个新构建的 DNA 序列可以像搜索字符串一样进行迭代和搜索，除了在任何索引处只有四个可能的值。为了更直接，我们需要能够封装 DNA 的数据结构。

# 容器

可用于保存 dna 的最简单的 dna 数据结构是一个*片*。片是一个具有静态大小的对象，拥有一块写入了`Base::DNA`的内存。切片可以表示为:

在上面的方法中，要么可以构造一个空的*`DNASlice`，要么可以从 C 字符串中构造一个切片。空白切片可能有助于表示正在运行的 DNA 搜索中缺少匹配。`DNA::fromCStr()`函数在这里被`const char*`构造函数重用。即使 DNA 数据现在可以被封装，我们也无法将其可视化。为此，需要一种定制的打印方法来处理`DNA::Base*`内存。*

*上述实现通过在`dna1`的任何开始位置检测`dna2`的匹配来工作。它别名`dna2`到`matcher`，这允许`matcher`在只找到部分匹配的情况下被复位。在任何迭代之前，我们知道如果`size2 > size1`为真，那么`dna2`不可能包含在`dna1`中。*

*布尔变量:*

*用于确定函数何时处于匹配的*状态*以及何时处于初始*状态*，仍在寻找匹配的第一个碱基。如果在初始状态，我们只有找到第一个碱基才能过渡到匹配状态。现在，在匹配状态下，以下条件适用:*

*要么我们匹配`dna2`的最后一个碱基，从而找到一个*完全*匹配，然后进一步进行完全匹配，要么我们在到达终点之前未能匹配一个碱基，导致匹配状态重置。*

# *搜索*

*既然已经讨论和演示了 DNA 的转换、迭代和封装，我们可以展示如何搜索 DNA。以前，使用 FSA 显示为一种线性搜索特定 DNA 亚序列的方法。这种方法是有用的，因为它可以计算在一个更大的序列中一些 DNA 亚序列的多次出现。然而，它缺乏能够扫描和识别许多许多 DNA 序列的性能。*

*一种更有效的方法是使用专门针对 dna 的 trie 结构。通常，尽管 trie 具有非常快的查找时间，但是它的缺点是由于需要的每个节点的数量和大小而使用大量的内存。通常，trie 节点可能如下所示。*

*这里，节点有 128 个子节点槽，因为 C 中的`char`类型的最大值通常是*127。然而，这可能会因在`<limits.h>`中定义的`SCHAR_MAX`的值而有所不同。就空间复杂性而言，使用这样定义的节点的 trie 将占用大量内存，并插入相当数量的键。一般来说，trie 使用的空间和内存与其键中支持的字符范围相关。**

## *DNA 测试*

*就 DNA 而言，只有 4 种可能的字符！`A, G, C, T`。因此，DNA trie 节点看起来像这样。*

*对于 DNA 序列中任何给定位置的任何给定碱基，下一个碱基只有四个可能的值。因此，这个原则可以用来使一个`DNA::Base`函数作为一个`DNANode`的子节点中的索引。然后可以像下面这样访问子节点*

*如果一个节点只需要大约 32-40 字节，这使得它比覆盖整个有符号范围的节点更有空间效率。接下来，我们可以选择 trie 将用它的键映射哪些属性和值。搜索 DNA 时有三种重要的数据类型。一个是存在性，比如 dna 的一个子序列是否包含在一个更大的序列中。另一个是计算某个子序列出现的次数。最后，可以在 DNA 中搜索子序列出现最多的区域。*

*核心 trie 类如下所示:*

*为了插入到 trie 中，我们需要递归遍历 trie，并为 trie 中尚不存在的任何基路径创建新节点。一旦到达输入 DNA 的末尾，节点的计数就增加 1。可以选择将输入的 DNA 视为嵌套序列，并对其中包含的所有子序列进行计数。使得如果输入是`ACCG`，我们将增加`A`、`AC`、`ACC`，而不仅仅是`ACCG`。*

*接下来，trie 必须能够查找与插入到 trie 中的每个 DNA 序列相关的计数。方法类似于`insert`，但是返回一个`long`:*

*如果`find`返回`-1`，这意味着 DNA 序列不存在于 trie 中。如果它返回`0`，这意味着序列确实存在于 trie 中，但是没有被插入超过一次。后续返回值指示在 trie 中跟踪的序列的计数。尽管可以直接使用`TrieNode`,但是将它包装在另一个类中更有效，该类管理一个根节点，所有传入的插入和查找都被路由到这个根节点。这样的类看起来可能是这样的:*

*在上面的类中，`_count`跟踪插入到 trie 中的序列的数量，但不是唯一的序列。否则，就没有快速计算字符串数量的方法。`<<`操作符用于插入，使类感觉类似于流类。目的是让 trie 能够插入大量的 DNA 块。*

*DNA Trie 最适合于人们正在寻找的重要序列已知的情况。这样，不同的 DNA 片段可以进入，并且`find()`可以用于特定的、重要的序列。*

# *新冠肺炎基因组*

*最后，我讨论了在高性能环境中分析 DNA 的工具和技术。接下来，我们来谈谈实际的冠状病毒基因组。*

*像大多数冠状病毒一样，这种冠状病毒是 RNA 病毒。然而，DNA 可以从 RNA 转录而来，使分析更加一致。`COVID-19`的基因组在磁盘上大约 8kb。这不代表任何现存的新冠肺炎，这一特殊序列取自中国武汉的患者。病毒可以随着感染的传播而进化。*

**包含基因组的文件可以在* [*这里找到*](https://github.com/jweinst1/ncov2019-analyzer/blob/master/data/COVID-19-genome.txt) *。演职员表中的演职员表由吴、赵、s、于、b、陈、杨明、王、w、宋、郑国光、胡、y、敖、郑国光、田、陈建宏、裴、杨燕、袁、张永林、戴、冯辉、刘、杨、王、秦明、郑、郑建杰、徐、李、霍尔姆斯、陈建华、张永志提供**

*分析基因组的第一步是决定寻找什么样的模式是重要的，以及这些模式有多大。比方说，我们想知道模式`ACGGTTCCAAT`出现了多少次。我们可以读取新冠肺炎的基因组，每隔 11 个碱基对其进行切片，并将其输入到 DNA Trie 的实例中。*

# *规划搜索*

*基于前面讨论的技术，我们现在可以在新冠肺炎基因组中寻找我们想要的东西。理想情况下，最好一次搜索一个或多个序列。需要一个解决方案来接受任意数量的`const char*`字符串，将它们转换成`DNA::Base*`，并插入到一个`DNATrie`中。为了简单起见，可以使用`main()`函数及其变量参数。我们还需要一个可以在`vector<>`中使用的类来保存潜在的许多搜索序列并存储每次搜索的结果，例如:*

**注意:上述结构没有自己的* `*seq*` *字段。它纯粹是设计来接受 argv 数组的成员，或者任何它不拥有的 C 字符串。**

*目标是直接从主`argv`和`argc`填充一个矢量`GenomeArguments`。这些参数对象将用于将新冠肺炎基因组切割成不同大小的块。这些块将被插入到`DNATrie`中。最后，将在 trie 中查找每个基因组参数的计数。*

*此外，新冠肺炎基因组必须从包含转录 DNA 序列的`.txt`文件中读取。这些功能可以组合成一个单一的`main()`功能。*

*第一个命令行参数是基因组文件的路径。剩下的命令行参数是在更大的新冠肺炎基因组中搜索的序列。这段代码假设运行它的任何操作系统都可以使用 C 标准库中的`fopen`函数，并且不使用 UTF-16 路径名。*

*该实现将执行以下操作来运行基因组搜索。*

1.  *检查基因组文件是否可以打开。*
2.  *将命令行参数转换成`GenomeArgument`。*
3.  *对于每个基因组参数，插入到 trie 中进行初始计数(从-1 到 0 递增)。*
4.  *然后，根据同样的论点，得到它的大小，并确保它低于极限。*
5.  *然后，基于同样的理由，检查它的大小是否已经被用来切割基因组。*
6.  *然后，对于同一仪器，逐片读取基因组并插入 trie。*
7.  *最后，对于同一个论点，在 trie 中查找论点并报告它的频率。*

*这是搜索新冠肺炎基因组最直接的方法。包含生成这样一个程序所需的类和函数的单个 C++源文件可以在这里的 repo 中找到。*

# *示例搜索*

*现在，在所有的准备工作之后，让我们试着看看我们能在冠状病毒的基因组中发现什么。*

*提醒一下，这是新冠肺炎的文字表述*

*首先，我们来看一些短长度的序列，比如`ag`、`gg`和`ctag`。*

*即使这些是非常小的目标子序列，也有一个有趣的观察结果。
`a`和`g`比`c`、`t`和`a`以及`g`更有可能同时出现。接下来，让我们看看
特定目标序列的一些变体。*

*如果只搜索`tc`，它在新冠肺炎基因组中出现得非常普遍。然而，如果我们寻找`tctc`，它的订单不太常见。
同样，`tctctc`是订单不太常见。随着时间的推移，重复的模式似乎变得越来越不常见。但如果这是真的，更多的随机模式应该更常见。让我们检查一下。*

*从上面的基因组搜索中，有一些有趣的观察结果:*

*   *`ggg`和`ccc`比`aaa`和`ggg`更不容易出现*
*   *尽管`c`在同质序列中不太常见，但它在混合序列中更常见`tac`。*

*对长度为 3 的同源序列的频率的巨大差异的一个可能的解释是新冠肺炎基因组的末端大部分是`a`:*

> *^结束*

*我们还可以看到在基因组末端附近有更多的`ttt`重复。*

# *结论*

*随着这种病毒在世界范围内传播，目前还没有已知的治疗方法，我们必须对它有更多的了解。您可以通过使用这样的技术从统计和计算的角度来研究病毒，从而获得洞察力。*

*如果您对构建和运行本文中描述的一些示例程序感兴趣，您可以在这里找到它们*