<html>
<head>
<title>Pandas Masterclass — Your Foundation To Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫大师班——你的数据科学基础</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pandas-masterclass-your-foundation-to-data-science-part-4-736a233b0b70?source=collection_archive---------16-----------------------#2020-01-16">https://medium.com/analytics-vidhya/pandas-masterclass-your-foundation-to-data-science-part-4-736a233b0b70?source=collection_archive---------16-----------------------#2020-01-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="264c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第四部分:熊猫的功能</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e83fd8df934251affb9e947083116e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMN7XGhKnNt-eQzS35bRVg.jpeg"/></div></div></figure><p id="fea8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 1。使用chunksize参数处理大型数据<br/> </strong>使用<code class="du kf kg kh ki b">chunksize</code>参数可以处理几个GB大小的大型数据，该参数有助于读取部分数据，根据需要对其应用各种处理，将其存储在临时变量中，然后将所有数据连接在一起。</p><p id="f9e1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将首先利用<code class="du kf kg kh ki b">chunksize</code>参数共享一个代码段，然后逐步解码。我们将实现两个不同的数据帧读取相同的CSV文件，只是为了验证两个数据帧最终是否具有相同的内容。</p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="5474" class="kn ko hi ki b fi kp kq l kr ks">df = pd.read_csv("pokemon_data.csv")<br/>print(len(df))</span><span id="b022" class="kn ko hi ki b fi kt kq l kr ks">newDf = pd.DataFrame(columns = df.columns)<br/>for tempDf in pd.read_csv("pokemon_data.csv", chunksize = 5):<br/>    newDf = pd.concat([newDf, tempDf])<br/> <br/>print(len(newDf))</span><span id="6d66" class="kn ko hi ki b fi kt kq l kr ks">#reading chunks of 5 rows at a time and then process it to do whatever<br/></span></pre><p id="d1bb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">前两行代码非常清楚，我们正在读取<code class="du kf kg kh ki b">pokemon_data.csv</code>文件，然后打印数据帧的长度。</p><p id="b899" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们尝试创建一个新的空数据帧<code class="du kf kg kh ki b">newDf</code>，其列标签类似于第一个数据帧<code class="du kf kg kh ki b">df</code>。在下一个<code class="du kf kg kh ki b">for</code>循环中，我们通过使用Pandas的<code class="du kf kg kh ki b">read_csv</code>函数中的<code class="du kf kg kh ki b">chunksize</code>参数，在每次迭代中仅读取5行<code class="du kf kg kh ki b">pokemon_data.csv</code>文件，然后将<code class="du kf kg kh ki b">newDF</code>连接到我们在每次迭代中读取的5行数据，最终得到与<code class="du kf kg kh ki b">df</code> DataFrame中相同的数据。我们可以通过打印<code class="du kf kg kh ki b">newDf</code>数据帧的长度来验证这一点，该长度将与<code class="du kf kg kh ki b">df</code>数据帧的长度相同。</p><p id="78d2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 2。现场参数<br/> </strong>在各种情况下，我们会对数据帧中某些列进行更改。为了反映数据帧中的变化，我们可以使用下面的代码给它重新分配数据帧。</p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="49e9" class="kn ko hi ki b fi kp kq l kr ks">new_results = new_results.reset_index(drop = True)</span></pre><p id="0393" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">或者，我们可以如下使用<code class="du kf kg kh ki b">inplace</code>变量，而无需将数据帧重新分配给它本身。</p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="ae0a" class="kn ko hi ki b fi kp kq l kr ks">new_results.reset_index(drop = True, inplace = True)</span></pre><p id="0bdb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 3。更改列中的分类数据<br/> </strong>分类数据意味着数据帧的某一列中存在的值。例如，DataFrame的列<code class="du kf kg kh ki b">'Age'</code>可能有像<code class="du kf kg kh ki b">28, 45, 67</code>这样的值。，这是该列的所有分类数据。</p><p id="eecf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可能会遇到多种情况，我们将不得不改变分类数据。这个过程非常简单，可以用下面的例子来解释。</p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="ea79" class="kn ko hi ki b fi kp kq l kr ks">print(pokeData.head())<br/>types = pd.Categorical(pokeData['Type 1'])<br/>print(types.categories)<br/>types.rename_categories([x+'1' for x in types.categories], inplace= True)<br/>print(types)<br/>pokeData['Type 1'] = types<br/>print(pokeData.head())<br/></span></pre><p id="5dcc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们首先打印出<code class="du kf kg kh ki b">pokeData</code>的前5行，以了解数据帧中存储了什么类型的数据。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ku"><img src="../Images/334477b3ef424ca7e50c8d57c9e3360a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*AQrJ1MITRNso1xI46ZWwKQ.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">pokeData数据帧的前5行</figcaption></figure><p id="63cb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，让我们尝试通过在每个类别值的末尾添加一个后缀“1”来更改列<code class="du kf kg kh ki b">'Type 1'</code>的分类数据。我们首先使用<code class="du kf kg kh ki b">pd.Categorical</code>函数将一列的所有分类数据加载到一个临时变量<code class="du kf kg kh ki b">types</code>中。然后我们打印<code class="du kf kg kh ki b">types</code>变量，只是为了检查列<code class="du kf kg kh ki b">'Type 1'</code>中的所有类别。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/b5253d4ce404f6865dec2b7b31caf852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*wd22Q5dC8nKqu5yQO09lbA.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">“类型1”列的分类数据</figcaption></figure><p id="e4c0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后我们使用<code class="du kf kg kh ki b">rename_categories()</code>功能来重命名类别。我们只需要确保新的类别名称作为一个列表提供，并且具有与原来相同数量的类别值。如果分类数据最初有13个不同的值，那么我们必须在<code class="du kf kg kh ki b">rename_categories()</code>函数中再次提供13个值作为列表。在这里，我们只是检索现有的类别名称，并为它们添加一个后缀“1”。</p><p id="4de2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以通过打印新的分类值来验证它们。我们可以再次将这些新值赋给数据帧的<code class="du kf kg kh ki b">'Type 1'</code>列。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ku"><img src="../Images/a8ad657320238b7dd978fd26cf4657f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*Qba_bPtqW8EA9WxraQcfNA.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">显示新的分类数据并应用于数据框架</figcaption></figure><p id="250c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 4。列的数据类型<br/> </strong>我们可以使用<code class="du kf kg kh ki b">dtype</code>操作符找到数据帧列的数据类型，也可以直接使用<code class="du kf kg kh ki b">dtypes</code>函数或使用<code class="du kf kg kh ki b">select_dtypes</code>函数进一步过滤出属于特定数据类型的列。</p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="f194" class="kn ko hi ki b fi kp kq l kr ks">print(titanicData.dtypes)<br/>print("\n\nColumns with object data type")<br/>print(titanicData.dtypes[titanicData.dtypes == "object"])<br/>(or)<br/>print(results.select_dtypes(include= ['float']).head())</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ku"><img src="../Images/c57d92ce946cdd96e1efcb614d107ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*I2CIJxwCyHDN4Qfx3OefGg.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">显示所有列的数据类型并筛选出对象类型列</figcaption></figure><p id="1d41" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 5。对数据帧行数据的算术运算我们可以使用数据帧行中的浮点或整数值，很容易地对数据帧的所有行进行类似的算术运算。虽然我们可以使用简单的语法(如<code class="du kf kg kh ki b">results['AA'] + results['AAPL']</code>)在两列上直接使用操作符来生成<code class="du kf kg kh ki b">results</code>数据帧的所有行上的列<code class="du kf kg kh ki b">'AA'</code>数据和<code class="du kf kg kh ki b">'AAPL'</code>数据的总和，但我们也可以使用简单的函数(如<code class="du kf kg kh ki b">sum()</code>)来添加几列，而不是全部键入。对大型数据集非常有用。</strong></p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="09c3" class="kn ko hi ki b fi kp kq l kr ks">print("Before")<br/>print(results.head())<br/>results['Total'] = results.iloc[:, 1:10].sum(axis=1)<br/>print("\n\nAfter")<br/>print(results.head())</span></pre><p id="fddb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">通过添加列<code class="du kf kg kh ki b">1 to 9</code>将<code class="du kf kg kh ki b">'Total'</code>列添加到现有<code class="du kf kg kh ki b">results</code>数据帧的右侧，并对由<code class="du kf kg kh ki b">axis = 1</code>指示的列求和。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/493fd6c60bcbd8f5ff5b8cb4504836b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*Fnz2TgAb7-GSQqUPddbxOA.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">通过添加列1至9生成“总计”列</figcaption></figure><p id="ccdb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 6。重新排列数据帧列<br/> </strong>考虑一个典型的用例，我们对所有行的某些列的值求和，并将其显示为总数。通常，新添加的总计列出现在数据帧的最右列，但如果我们想将总计列放在要添加的值的开始，我们可以很容易地做到这一点。考虑下面的例子，我们一直在使用的数据股票数据框架。</p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="fb10" class="kn ko hi ki b fi kp kq l kr ks">allCols = list(results.columns.values)<br/>print("All columns", allCols)</span><span id="c1e3" class="kn ko hi ki b fi kt kq l kr ks">colsSummed = list(results.columns.values[1:10])<br/>print("Columns to be summed", colsSummed)</span><span id="c247" class="kn ko hi ki b fi kt kq l kr ks">print("\n\nBefore")<br/>print(results.head())<br/>results = results[[allCols[0]] + [allCols[-1]] + colsSummed]<br/>print(results.head())</span></pre><p id="c79c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以使用数据帧的<code class="du kf kg kh ki b">columns.values</code>属性将数据帧中的所有列名作为一个列表，然后使用列表切片生成<code class="du kf kg kh ki b">colsSummed</code>变量，将已经求和的列分开以获得<code class="du kf kg kh ki b">'Total'</code>列。</p><p id="ca0c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后我们可以做一个简单的重新排列，在数据帧中提到列名的顺序，如上所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/9876cb59e5c6550e45f164eb30da685f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*7U0A-CmrhlGFjKr6fjER9A.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">将“总计”列移动到所需位置</figcaption></figure><p id="cf7c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 7。Describe function<br/></strong>Describe function当在数据帧上执行时，默认情况下会分离出具有整数值或浮点值的列，并为我们提供行数、平均值、标准偏差、最小值、最大值等的快照。对<code class="du kf kg kh ki b">object</code>类型的数据执行<code class="du kf kg kh ki b">describe()</code>函数将会给出不同的细节，比如值的数量、唯一值的数量、最频繁值及其计数。让我们在股票数据上实现几个场景的<code class="du kf kg kh ki b">describe()</code>函数。</p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="63b8" class="kn ko hi ki b fi kp kq l kr ks">print(results.describe())<br/>print(results['Unnamed: 0'].describe())<br/>print(results.describe().loc["count"])</span></pre><p id="bdd8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们首先在整个数据帧上实现该函数，然后在对象数据上实现，然后只检索所有列的<code class="du kf kg kh ki b">'count'</code>值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ku"><img src="../Images/19597917176c0e19f05c095dabcf2c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*CHHf49agv63uMkHZcdTgZA.png"/></div></figure><p id="9e97" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">8。将文件读入数据帧<br/> 时，我们可以使用<code class="du kf kg kh ki b">skiprows</code>属性跳过正在读取的文件的行。</p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="3a0d" class="kn ko hi ki b fi kp kq l kr ks">results = pd.read_csv("stock_px.csv", skiprows = [0,2,3])<br/>results = pd.read_csv("stock_px.csv", skiprows = range(3,30), nrows = 40)</span></pre><p id="bb21" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以使用<code class="du kf kg kh ki b">range()</code>函数提供要跳过的文件的具体行号或一系列行。</p><p id="d127" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du kf kg kh ki b">nrows</code>属性限制读入数据帧的行数。当我们设置<code class="du kf kg kh ki b">nrows = 40</code>时，我们只将<code class="du kf kg kh ki b">skiprows</code>属性中的前40行读入数据帧<code class="du kf kg kh ki b">results</code>。</p><p id="fe3e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">9。找出数据帧<br/> 中的空值我们可以使用<code class="du kf kg kh ki b">isnull()</code>函数找出数据帧的<code class="du kf kg kh ki b">null</code>值。它返回一个布尔表，其中<code class="du kf kg kh ki b">True</code>的值为<code class="du kf kg kh ki b">null</code>，而<code class="du kf kg kh ki b">False</code>的值被填充。</p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="7128" class="kn ko hi ki b fi kp kq l kr ks">print(pd.isnull(results).head())</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/da519491d8160ba7c82b31ba779ce2cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*O2FAxiFc5jBuA3PKwknKKA.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">在数据帧的前5行打印出调用isnull()函数的结果</figcaption></figure><p id="6c22" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 10。数据帧的形状<br/> </strong>我们可以使用<code class="du kf kg kh ki b">shape</code>属性知道数据帧的形状，即行数x列数，该属性返回一个形式为<code class="du kf kg kh ki b">(rows, columns)</code>的元组。</p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="470c" class="kn ko hi ki b fi kp kq l kr ks">results.shape</span></pre><p id="73bb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">调用上述属性将返回值<code class="du kf kg kh ki b">(5472, 10)</code>，指示数据帧<code class="du kf kg kh ki b">results</code>中的<code class="du kf kg kh ki b">5472</code>行和<code class="du kf kg kh ki b">10</code>列。</p><p id="4d12" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 11。查找列的唯一值<br/> </strong>我们可以使用<code class="du kf kg kh ki b">unique()</code>函数来查找一个数组的所有唯一值，该函数返回一个包含所有唯一值的数组。</p><pre class="iy iz ja jb fd kj ki kk kl aw km bi"><span id="7b20" class="kn ko hi ki b fi kp kq l kr ks">print(titanicData['Cabin'].unique())</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/cf6b5bb9be61ed3e6261ff3e1f120df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*bEGc8xsrWMOY53h6F_sOdw.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">“Cabin”列中所有唯一值的数组</figcaption></figure><p id="2153" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">系列各部分:</strong><br/><a class="ae lb" rel="noopener" href="/analytics-vidhya/pandas-masterclass-your-foundation-to-data-science-part-1-136474104d57">Pandas master class——你的数据科学基础(第一部分:基本数据帧操作)</a><br/><a class="ae lb" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-2-e0abda580cc3">Pandas master class——你的数据科学基础(第二部分:特殊文件格式的数据帧操作)</a><br/><a class="ae lb" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-3-220cd683540e">Pandas master class——你的数据科学基础(第三部分:排序、 过滤和分组数据帧数据并写入文件)</a><br/><a class="ae lb" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-4-736a233b0b70">Pandas master class—您的数据科学基础(第4部分:Pandas功能)</a><br/><a class="ae lb" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-5-5e86b812f6c3">Pandas master class—您的数据科学基础(第5部分:多索引数据帧、处理na值和组合数据帧)</a></p></div></div>    
</body>
</html>