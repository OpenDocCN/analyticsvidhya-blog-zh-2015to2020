<html>
<head>
<title>Docker Registries: pull and push in details</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker注册表:详细的拉和推</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/docker-registries-pull-and-push-in-details-410de37d2282?source=collection_archive---------20-----------------------#2020-04-18">https://medium.com/analytics-vidhya/docker-registries-pull-and-push-in-details-410de37d2282?source=collection_archive---------20-----------------------#2020-04-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c11a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker图像是负责Docker容器创建的主要元素。基本上，它们是用于创建应用程序的只读模板，其中有代码和支持文件，用于设置运行应用程序的指令。</p><p id="dcbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在内部，Docker映像是一堆相互堆叠的代码层，在实例化时被视为一个单一的平面映像。</p><p id="157a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有Docker图像，实际上什么也做不了。</p><p id="6e9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我将尝试从Docker Registry的角度总结一些Docker映像的基本动作(命令)。这一课程的整体思想并不是相同的实践课程，而是理解当我们与Docker图像交互时，在引擎盖下发生了什么。</p><p id="7f2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说了这么多，让我们转到Docker registry可以为您做的最基本的命令，即<code class="du jd je jf jg b">pull</code>和<code class="du jd je jf jg b">push</code>命令。</p><p id="4aaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们开始吧。</p><h1 id="fbf4" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">Docker图像到底住在哪里？</h1><p id="a51c" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">当我们<code class="du jd je jf jg b">pull</code>一个图像时，我们从注册表(通常是<strong class="ih hj"> Docker Hub </strong>，一个目录<strong class="ih hj"> Docker图像</strong>的公共存储库)下载它，但是还有更多众所周知的替代方案，如VMWare的VSphere或Google Cloud的Container-Registry。</p><p id="f50c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker还有<strong class="ih hj"> DTR (Docker可信注册中心)</strong>，这个是企业版的私有服务。DTR提供了与安全性和版本管理相关的多个附加功能。是正规Docker社区版的pro版(你免费安装的那个)。</p><p id="5cec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在动手之前，应该说docker可以处理官方和非官方(第三方)图像。当Docker下载图像时，对于Linux操作系统，它被存储在<code class="du jd je jf jg b">/var/lib/docker/&lt;your-storage-driver&gt;</code>目录中，对于基于Windows的操作系统，它被存储在<code class="du jd je jf jg b">C:\ProgramData\docker\windowsfiler</code>目录中。</p><p id="cb33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是一些复习技巧:</p><ol class=""><li id="8e96" class="kk kl hi ih b ii ij im in iq km iu kn iy ko jc kp kq kr ks bi translated">用<code class="du jd je jf jg b">docker image ls</code>我们可以看到我们下载的图像。</li><li id="cfcf" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">Docker图像是只读模板。在创建容器的时候，在只读图像之上创建了一个可写层，因此我们可以毫无问题地向它写入更新。</li><li id="c812" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">每个容器(图像-容器)都有一个1:M关系</li></ol><h2 id="a9aa" class="ky ji hi bd jj kz la lb jn lc ld le jr iq lf lg jv iu lh li jz iy lj lk kd ll bi translated">拉动图像</h2><p id="ebae" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">提取图像非常容易，提取是从Docker注册表下载图像的过程。这里有一个例子:<code class="du jd je jf jg b">docker pull redis:latest</code></p><p id="1f70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们用<code class="du jd je jf jg b">pull</code>命令设置我们想要的<code class="du jd je jf jg b">redis</code>图像带有一个名为<code class="du jd je jf jg b">latest</code>的特定标签。</p><p id="0183" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在内部，每个安装步骤都是一个层，这会产生一个BLOB文件。在封面下，清单文件描述了图像，还包括层列表及其堆叠方式，这是因为层之间没有任何引用，但united创建了工作特征。</p><p id="2b9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">pull</code>做了很多事情，首先，执行对Docker Hub的API请求，这返回包含关于支持的架构列表的所有信息的清单文件，评估您请求的机器架构规格，然后获取映像清单，然后，传递并下载一个层列表。</p><p id="f1ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能会非常令人困惑，但实际上这对最终用户来说是非常清楚的，API会使用名为“FAT manifest”的第一个清单文件，该文件通过列出和评估您的系统架构来执行选择，然后根据您的系统规格抓取包含工作层的清单文件。</p><p id="03ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这太棒了。</p><p id="5259" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以更深入，很容易。</p><p id="a505" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每一层都有一堆代码文件和东西在里面，你可以通过比较哈希码来验证你下载的图片是否合法和有效。一个来自清单文件，另一个来自下载映像的哈希代码。</p><p id="4b82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">层组合从一个基础文件(操作系统文件和对象)开始，该映像将使用任何主机内核，然后，在许多自定义层(应用程序代码、更新等)之上，然后，在构建之后，“层”结构将“消失”，成为看起来像是单一统一的文件系统。</p><p id="267a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在幕后，有一个存储驱动程序将整个分层系统整合在一起(我在另一篇文章中谈到了这一点，请点击这里查看)。</p><p id="f90b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以像这样检查文件系统上表示的每个层:<code class="du jd je jf jg b">ls -l /var/lib/docker/aufs/diff</code>这显示了层的列表。在它们里面是将构成目录的一部分的文件。</p><p id="cd83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在他们的官方文件中有更多的信息，非常有趣。</p><p id="06ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是一些用于检查和获取图像详细信息的有用命令</p><p id="0ed2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">docker history redis</code>这显示了构建<code class="du jd je jf jg b">redis</code>映像的步骤，比如时间、映像ID和大小。</p><p id="8d79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">docker inspect redis</code>这个显示了图像的完整配置设置。</p><p id="9f10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太棒了，拉够了，让我们移到推的一边</p><h2 id="1c92" class="ky ji hi bd jj kz la lb jn lc ld le jr iq lf lg jv iu lh li jz iy lj lk kd ll bi translated">推送图像</h2><p id="3521" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">我们已经有了包含数据的独立层，如何将它存储到我们的注册表中？我们知道我们有docker push命令。但我的目标是谈论内部发生的事情。</p><p id="1894" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，这是怎么做到的？</p><p id="4937" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们推送时，会创建一个定义层信息的清单文件，清单和容器的层实际上是独立推送和压缩的。</p><p id="4d45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是这个过程中最重要的部分。当进行分发哈希的压缩过程时，图层哈希会发生变化，分发哈希基本上是映射压缩图层，而不是原始图层。</p><p id="8911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为区分工作容器的每个可用版本设置一个标签是一个很好的做法。</p><p id="60b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个过程非常简单，因为码头工人登记处会处理之后的所有事情。</p><p id="dce6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你花一分钟时间，你会发现在几秒钟内有很多事情发生。这一切都是由Docker自己处理的，但是如果你认为Docker像我一样是一个迷人的工具，那么，这可能是一个很好的阅读材料，可以了解事情是如何在内部运作的。</p><p id="0dc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请随意分享，如果您发现问题，请纠正。这是根据我的经验写的。</p><p id="9cad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐编码:)</p></div></div>    
</body>
</html>