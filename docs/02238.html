<html>
<head>
<title>SPARK-Join Deep-Dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">火花连接深潜</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/spark-join-deep-dive-2e10395682c4?source=collection_archive---------9-----------------------#2019-12-07">https://medium.com/analytics-vidhya/spark-join-deep-dive-2e10395682c4?source=collection_archive---------9-----------------------#2019-12-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e694" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">连接是ETL管道中常见的步骤之一。这是我在这个系列的第五次</p><div class="jd je ez fb jf jg"><a rel="noopener follow" target="_blank" href="/@somanathsankaran/spark-group-by-and-filter-deep-dive-5326088dec80"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">火花分组和过滤深潜</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">大家好，这是我的火花深度潜水系列的第四篇文章</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">medium.com</p></div></div><div class="jp l"><div class="jq l jr js jt jp ju jv jg"/></div></div></a></div><p id="26a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在今天的文章中看到以下内容</p><ol class=""><li id="bf8b" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">连接的类型</li><li id="992f" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">指定具有相同列名的连接键</li><li id="c751" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">用不同的列名指定连接键</li></ol><p id="1fe4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.在连接条件中应用条件，如“上部”、“修剪”</p><p id="faa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.带有示例的联接类型</p><p id="51ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.指定多个连接条件</p><p id="7b28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7.联接并选择不明确的列</p><p id="df86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一步:创建数据集</strong></p><p id="f87b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用spark创建2个样本数据帧，每个数据帧有3列。创建数据框架</p><p id="0682" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DF_Left:是dept表，有三个字段:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/c8ad3af93e89d938dd099c9c93e20ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRTXN3BABWKuDU1LY3tSEQ.png"/></div></div></figure><p id="9790" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">df_right:由dept、dept_id和student_id组成</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kv"><img src="../Images/79d690757ec4ad23ab33817fbd050250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A88Lwubh7Tfy8iC5OWTD-Q.png"/></div></div></figure><p id="b37a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">加入类型:</strong></p><p id="70a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spark支持以下类型的连接</p><ol class=""><li id="a841" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">内部连接</li><li id="d811" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">左_外连接/右外连接</li><li id="7225" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">完全_外部连接</li><li id="44f7" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">左_半/左_反连接</li><li id="6eeb" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">交叉连接</li></ol><p id="4e22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">内部连接:</strong></p><p id="4c05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<strong class="ih hj"> Inner关键字</strong>内连接将只包含匹配两个表中连接键值的行，并且内连接是spark中的默认连接，我们不需要显式指定“inner ”,如下所示</p><p id="140d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">指定连接键:</strong></p><p id="fe1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">连接键可以使用</p><ol class=""><li id="0f1c" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated"><strong class="ih hj">指定具有相同列名的连接键</strong>:</li></ol><p id="328a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">On子句可用于将连接键作为字符串或字符串列表提供，如果键名称在两个DF中都匹配，就像dep字段的情况一样，如下所示</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kw"><img src="../Images/8fcad2fb591cfbc60173c7cdc7ddd350.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*Xj-TrmzerabBGSZW6KHMcQ.png"/></div></figure><p id="92f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">用diff列名指定连接键</strong>:如果列名不同，我们可以按顺序提供包含左键和右键的列表，如dept id</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kx"><img src="../Images/8f245b7b31857099a089b600f8bd5122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*8CCOkr9Ba2HWm4L5qThEqA.png"/></div></figure><p id="e037" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。在连接条件中应用上切边等条件</strong></p><p id="7b5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们通常需要指定诸如修剪鞋面等条件，即使dept civil是相同的，但由于大小写敏感，它不会被连接。因此，在使用pyspark.sql.functions作为f将dept字段转换为大写字母后，我们将使用upper function进行连接。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ky"><img src="../Images/db16fb18c28d0a2ce461d39302fee272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PqMmGFJpWLx5Aj3qo2b7RQ.png"/></div></div></figure><p id="3ab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">带示例的联接类型</strong></p><p id="edd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Left_Join:它将包含left_table中的所有行，如果找到匹配项，则在右表中有相应的值，否则右df字段将为null</p><p id="6c0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，由于id 3，4在右侧df中缺失，我们将如下所示具有空值，并且在右侧df中存在但在左侧表中缺失的dept_id 5也将不存在。</p><p id="effd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">左连接可以通过使用值为Left或left_outer的关键字<strong class="ih hj">来执行，但是我会推荐left_outer，因为它对读者来说很清楚</strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kz"><img src="../Images/ba834bc92993c30de612c3b64e43e6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDs5Ps4d_jQHZSzq2XLAIg.png"/></div></div></figure><p id="bfe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">右外连接</strong>:</p><p id="d748" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它与左外连接相反，将包含右df和</p><p id="3325" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果找到匹配，则在左侧表中有相应的值，否则左侧df字段将为空</p><p id="86e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，由于左侧表格中缺少dept_id 5，我们将在左侧df字段中填充null，如下所示</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es la"><img src="../Images/7b1fe830feac412ca92d6cded81cce04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqEE9M9F8-r-usKjoJWXEg.png"/></div></div></figure><p id="f794" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完全外部连接:</p><p id="a3a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是左外连接和右外连接的组合，将包含所有行</p><p id="f893" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从两个数据帧中</p><p id="6015" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，在下面的例子中，由于id 3，4在右df中缺失，我们将在右df字段中具有空值，并且由于dept_id 5在左表中缺失，我们将在左df字段中填充空值，如下所示</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lb"><img src="../Images/199010823443a4c84dadd11dc430a5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bIt365whOk67DDd8ltAxqQ.png"/></div></div></figure><p id="9a2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">左半连接</strong>:</p><p id="2b86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它类似于子查询，但经过优化，我更喜欢左半连接</p><p id="2bb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">子查询。因此，我们的输出在左df中只有id，它们出现在右df中，如1和2</p><p id="6899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾名思义，它将包含在右表<strong class="ih hj">中找到匹配键的所有行，左半连接和左外连接的区别在于它将只包含左表中的字段，而不是两个表都包含</strong>。</p><p id="ea53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以比较左外图像和左半连接截图，看看有什么不同</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lc"><img src="../Images/02f2520bf4b1895dcd81750ba9676553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pA80mz3H1hQYvAQnP2hBjQ.png"/></div></div></figure><p id="6c73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">左反加入</strong></p><p id="31da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是左半连接的反义词。它类似于not in子查询</p><p id="3cd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们看到输出，我们将在左侧df中只有id，而在右侧df中没有id，如3和4</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ld"><img src="../Images/6bdd6812bc59c5a52895c4d601685070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2jNkOTjOFlmEB04xIfg1w.png"/></div></div></figure><p id="0bb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">交叉连接</strong>:</p><p id="2543" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">交叉连接就是将右表中的每一行与另一行连接起来</p><p id="9183" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果左df有4行，右df有3行，我们将有4*3 =12行</p><p id="6760" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果我们没有用Join </strong>指定连接条件，则会发生交叉连接</p><p id="c20d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">由于交叉连接会分解数据集，默认情况下spark不允许交叉连接</strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es le"><img src="../Images/31e72b55957a501b9b8bf020a14ed4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_G_QYTUEch-eW_NjlKpm9A.png"/></div></div></figure><p id="17c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们必须使用spark.sql设置spark . SQL . cross join . enabled = true，并执行交叉连接，如下所示</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es lf"><img src="../Images/62f905ed98caeebe500847160119cbc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*Vh6hDn_0X7H7w8IJbogopw.png"/></div></figure><p id="99fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">指定多个连接条件:</strong></p><p id="f887" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以将多个条件与条件元组结合起来，并使用or逻辑运算符，使用&amp;和|符号，如下所示</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lg"><img src="../Images/12de49c973004f91fabee06e5b66bbb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQ08Ej2UKCVFEshRy30FvA.png"/></div></div></figure><p id="d0c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">连接并选择不明确的列</strong></p><p id="f90b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，左和右df将具有相同的列名</p><p id="a607" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像dept的情况一样</p><p id="e71a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个简单的解决方案是使用</p><p id="eb29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">列表理解</p><p id="1579" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在left_df中有相同的列名，我们将在列名前面加上“right_df_ ”,否则保留如下所示的列名，并用这些列创建一个新的df</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lh"><img src="../Images/7f575c92502f9621c789876518f40ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*VAIx1o9LY8FYsoiZ0NpeeQ.png"/></div></div></figure><p id="2b4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用新列创建新的df并选择df</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es li"><img src="../Images/956d1bf46546ee6cf4f7d30823340a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ND5un12xcXmhi1MSlFbMQ.png"/></div></div></figure><p id="f16d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天就到这里吧！！:)</p><p id="5989" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Github链接:<a class="ae lj" href="https://github.com/SomanathSankaran/spark_medium/tree/master/spark_csv" rel="noopener ugc nofollow" target="_blank">https://github . com/SomanathSankaran/spark _ medium/tree/master/spark _ CSV</a></p><p id="7bb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lk">请把我在spark中必须涉及的话题发给我，并给我提供改进写作的建议:)</em> </strong></p><p id="4e7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">学习，也让别人学习！！</strong></p></div></div>    
</body>
</html>