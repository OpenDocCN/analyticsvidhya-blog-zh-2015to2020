<html>
<head>
<title>Neuromancer Blues: Threading vs Multiprocessing — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神经漫游者的忧郁:线程vs多重处理—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/neuromancer-blues-threading-vs-multiprocessing-part-1-60680b03f553?source=collection_archive---------20-----------------------#2019-12-28">https://medium.com/analytics-vidhya/neuromancer-blues-threading-vs-multiprocessing-part-1-60680b03f553?source=collection_archive---------20-----------------------#2019-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b99300750f0aaa4c5093ab276a0a581c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSEGozbKSrPGlBDf4Dl0Zg.jpeg"/></div></div></figure><p id="9b19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“Neuromancer Blues”是一系列帖子，我希望读者在其中找到关于整体数据科学主题的指导，如数据争论、数据库连接、应用数学和编程技巧，以提高代码效率、可读性和速度。我的例子和代码片段将会尽可能的简洁明了，以传达关键思想，而不是提供可读性差的冗长代码，这会损害帖子的目的。</p><p id="d70d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">线程</strong>(又名多线程)<strong class="is hj">多处理</strong>是我想写很久的一个话题。第一篇文章将重点介绍这两个概念，重点是线程，以及为什么线程对于金融领域的开发人员如此重要。未来的Neuromancer系列帖子将在多处理和编程效率问题上花费更多时间，如竞争条件或死锁。</p><p id="e2b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">基础知识</strong> <br/>让我们澄清一下这篇文章中反复出现的关键概念:</p><ul class=""><li id="224d" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">并发</strong>:当两个任务可以在重叠的时间段内开始、运行、完成。</li><li id="01ee" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">并行性</strong>:当任务实际上同时运行时，例如多核处理器</li><li id="4cb1" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> I/O绑定任务:</strong>大部分时间处于I/O(输入/输出)状态的任务，即网络读/写、数据库查询等。</li><li id="34f1" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> CPU-bond任务:</strong>大部分时间花在CPU上的任务，即浏览多个网站、机器algo训练等。</li><li id="6564" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> GIL(全局解释器锁):</strong> GIL是一种锁，它避免单个python进程在任何时间点并行运行线程(使用多个内核)，但它们可以并发运行。虽然对于单线程任务不可见，但在执行多线程代码或CPU受限任务时，GIL会成为一个问题。</li><li id="b761" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">死锁:</strong>两个或两个以上的线程/任务互相等待，不执行并阻塞整个程序时发生的事件。</li><li id="fdb6" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">竞争条件</strong>:当两个或多个线程/任务并行运行，但由于操作顺序不正确而导致结果不正确时发生的事件。</li></ul><p id="6ef2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在编码中，我们需要避免竞争条件和死锁。避免竞争状况的最佳方法是使用<a class="ae kd" href="https://en.wikipedia.org/wiki/Thread_safety" rel="noopener ugc nofollow" target="_blank">避免共享状态的方法或与同步相关的方法</a>来应用线程安全策略。此外，我们还希望通过让进程跨越建立相互依赖来避免死锁，即尽可能减少锁定任何东西的需要。这些主题更高级，值得在未来发布另一系列帖子。</p><p id="c7e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">线程与多处理:简介</strong> <br/>现在我们在同一页上，让我们来回答线程与多处理之间的区别，以及为什么它如此重要。下表提供了各种方法之间的综合比较。</p><p id="6e01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之，线程用于在同一进程中同时运行多个线程/任务，但是如果我们已经使用了100 %的CPU时间，它将不会提高速度。另一方面，多处理允许程序员在给定的CPU上打开多个处理器，每个处理器都有自己的内存，没有GIL限制。</p><p id="a87b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python线程主要用在I/O绑定的任务中，这些任务的执行需要一些等待时间。在金融领域，一个简单的例子是查询外部数据库，因此我们将使用yahoo finance数据模拟一个类似的i/O任务。</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/f23dc3e85141317d0bbfc3fb2a7c3cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CKwn0X-pjZ2OCTQ75lRWQ.jpeg"/></div></div></figure><p id="3daa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我在引言中提到的，我想在这篇文章中集中讨论线程，所以让我们言归正传。</p><p id="abf8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">经典方法:使用线程模块</strong><br/>Python提供的<a class="ae kd" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank">线程模块</a>包括一个易于实现的锁定机制，允许您同步线程。换句话说，这个模块允许您让程序的不同部分同时运行，并提高代码的可读性。</p><p id="d0a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们先来了解一下做线程有什么意义。下面的代码片段显示了一个循环过程，其中我们使用<a class="ae kd" href="https://pypi.org/project/pandas-datareader/" rel="noopener ugc nofollow" target="_blank"> pandas datareader模块</a>执行一个I/O绑定的任务，从yahoo finance读取财务数据。尽管pandas datareader允许批量处理(从一个ticker列表中一次下载数据),但我们将天真地在每个ticker的独立基础上运行每个I/O任务，并遵循顺序执行方法，即只有在前一个调用完成时，新的调用才会开始。</p><p id="79f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意在我们的io_task()函数和t <a class="ae kd" href="https://docs.python.org/3/library/time.html" rel="noopener ugc nofollow" target="_blank"> ime模块</a>中引入了一秒钟的延迟。为了简单起见，我们只下载了不到五年的价格数据，因此这是一个非常快速的查询。这一秒钟延迟的引入模拟了我们的查询花费更多的时间，例如下载诸如+100基本指标之类的数据，这是更真实的模拟。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="cbf8" class="ko kp hi kk b fi kq kr l ks kt"># Modules<br/>import time<br/>import pandas_datareader.data as web<br/>import pandas as pd<br/>import threading</span><span id="a54b" class="ko kp hi kk b fi ku kr l ks kt"># Input and Functions<br/>def io_task(ticker_, dict_): <br/> ‘’’<br/> Download Yahoo Data and store it into dictionary<br/> ‘’’<br/> df = web.get_data_yahoo(ticker_)<br/> time.sleep(1)<br/> dict_[ticker_]=df<br/>t_list = [‘KO’,’XOM’,’AAPL’,’IBM’,’MCD’] # ticker list<br/>df_dict={} # dictionary to store data</span><span id="4766" class="ko kp hi kk b fi ku kr l ks kt"># Database Query:<br/>start = time.perf_counter()<br/>for i in t_list:<br/> io_task(i, df_dict)<br/>finish = time.perf_counter()<br/>print(f’running time: {finish-start} second(s)’)<br/>print(f’dictionary keys are {df_dict.keys()}’)</span></pre><p id="cd0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行代码将产生如下所示的输出:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="906d" class="ko kp hi kk b fi kq kr l ks kt">time: 8.457419800000025 second(s)<br/>dictionary keys are dict_keys([‘KO’, ‘XOM’, ‘AAPL’, ‘IBM’, ‘MCD’])</span></pre><p id="016d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们在上面看到的，顺序执行是非常耗时的。我们有什么方法可以优化和减少等待时间？<strong class="is hj">进入穿线模块:</strong></p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="2974" class="ko kp hi kk b fi kq kr l ks kt">t_list = [‘KO’,’XOM’,’AAPL’,’IBM’,’MCD’]<br/>df_dict={}<br/>threads=[]<br/>start = time.perf_counter()<br/>for i in t_list:<br/> t = threading.Thread(target=io_task, args=[i,df_dict]) # 1<br/> t.start() # 2<br/> threads.append(t)<br/>for thread in threads:<br/> thread.join() # 3<br/>finish = time.perf_counter()<br/>print(f’running time: {finish-start} second(s)’)<br/>print(f’dictionary keys are {df_dict.keys()}’)</span><span id="762f" class="ko kp hi kk b fi ku kr l ks kt">running time: 2.3480712000000494 second(s)<br/>dictionary keys are dict_keys([‘AAPL’, ‘IBM’, ‘XOM’, ‘MCD’, ‘KO’])</span></pre><p id="c1b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，真快。<strong class="is hj">线程显著优于顺序方法，将时间减少了6秒多，相当于等待时间的三分之二以上</strong>。线程模块的新用户可能需要对用数字注释突出显示的行进行进一步描述:</p><ol class=""><li id="a3f2" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kv jv jw jx bi translated">我们为列表中的每个ticker创建了一个线程。这是一个由线程模块创建的新类。</li><li id="1dae" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kv jv jw jx bi translated">线程被启动，任务在单独的线程控制中执行。</li><li id="dc9a" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kv jv jw jx bi translated">让程序等待，直到线程终止。这一行很重要，如果我们忽略它，程序会在所有线程完成之前打印出时间，因此，它会给我们一个错误的时间测量。</li></ol><p id="5303" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">新方法:使用并发的线程池。Futures模块</strong><br/><a class="ae kd" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank">concurrent . futures</a>模块提供了一种更简单易懂的方式来处理线程和多重处理。该模块是Python线程和多处理模块之上的抽象层，简化了它们的使用。尽管如此，应该注意的是，在更高的代码简单性和更低的代码灵活性之间有一个权衡。因此，用户可能对使用线程或并发感兴趣。未来取决于项目的复杂性和要求。</p><p id="343c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，现在让我们使用这个新模块来运行我们的I/O绑定任务:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="bd8a" class="ko kp hi kk b fi kq kr l ks kt"># New module import<br/>import concurrent.futures</span><span id="49d6" class="ko kp hi kk b fi ku kr l ks kt"># Helper Function and Inputs: <br/>def helper(inputs): # 1<br/> io_task(inputs[0], inputs[1])</span><span id="a987" class="ko kp hi kk b fi ku kr l ks kt">t_list = [‘KO’,’XOM’,’AAPL’,’IBM’,’MCD’]<br/>df_dict={}<br/>args = list(zip(t_list,[df_dict for _ in range(len(t_list))])) # 1</span><span id="8d81" class="ko kp hi kk b fi ku kr l ks kt"># I/O Tasks Threading<br/>start = time.perf_counter() <br/>with concurrent.futures.ThreadPoolExecutor() as executor: # 2<br/> executor.map(helper, args) #3<br/>finish = time.perf_counter()<br/>print(f’running time: {finish-start} second(s)’)<br/>print(f’dictionary keys are {df_dict.keys()}’)</span><span id="3d4e" class="ko kp hi kk b fi ku kr l ks kt">running time: 2.44674170000053 second(s)<br/>dictionary keys are dict_keys([‘KO’, ‘AAPL’, ‘MCD’, ‘XOM’, ‘IBM’])</span></pre><p id="f060" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">与简单的顺序方法</strong>相比，池线程化同样显著地节省了时间，并且比我们的线程模块的第一个代码片段具有更好的可读性。同样，您可以在下面找到这些带有数字注释的行的更多解释:</p><ol class=""><li id="319c" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kv jv jw jx bi translated">必须用作嵌入concurrent.futures模块中的映射函数的输入的帮助函数。它只是我们最初的I/O绑定任务函数，但是因为它需要两个参数而不是一个，所以我们不能在3 . 1中定义的executor.map()对象中使用它。</li><li id="66a3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kv jv jw jx bi translated">concurrent.futures模块中的执行者对象。这是一个抽象类，需要用作它的两个子类之一:ThreadPoolExecutor或ProcessPoolExecutor。线程需要前者，而多重处理需要后者，我们将在以后的文章中看到。</li><li id="d348" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kv jv jw jx bi translated">Executor.map()是嵌入到Executor对象中的一个方法，它的工作方式类似于Python的普通map()函数，对指定iterable的所有元素应用一个函数并返回map对象。在这种情况下，该方法异步执行调用，为每个跑马灯创建一个线程。</li></ol><p id="60f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">综上所述，【Threading和Concurrent.futures模块具有相似的性能，尽管前者在牺牲代码可读性的同时为自定义任务提供了更大的灵活性。</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/b5d0d4ba96b71e03d869960d090fcf58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*JfEPlaWulmpwr9lNmuEXYw.jpeg"/></div></div></figure><p id="bf98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是对线程和多处理的简短介绍，用非常简单和简短的代码脚本来传达关键思想。这一次我们为每个线程分配了一个任务，尽管如果需要的话，我们可以为每个线程分配更多的作业/任务。</p><p id="7e89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Neuromancer系列的未来文章中，我的目标是深入研究更多线程细节示例，讨论多处理和其他对投资有用的数据科学主题。</p><p id="67c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">推荐资源:</strong></p><ul class=""><li id="4bcd" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">YouTube最佳线程教程:</strong> <a class="ae kd" href="https://www.youtube.com/watch?v=IEEhzQoKtQU&amp;t=259s" rel="noopener ugc nofollow" target="_blank">科里·斯查费</a></li><li id="b6c0" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> Python冒险</strong> : <a class="ae kd" href="https://pythonadventures.wordpress.com/tag/threadpoolexecutor/" rel="noopener ugc nofollow" target="_blank"> concurrent.futures </a></li><li id="2bb6" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">原文:</strong> <a class="ae kd" href="https://www.lightbringercap.com/blog/neuromancer-blues-threading-vs-multiprocessing-part-1" rel="noopener ugc nofollow" target="_blank">光明使者</a></li></ul></div></div>    
</body>
</html>