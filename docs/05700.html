<html>
<head>
<title>Building a Content Based Movie Recommendation System.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建基于内容的电影推荐系统。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-content-based-movie-recommendation-system-f7585ca35ed0?source=collection_archive---------22-----------------------#2020-04-29">https://medium.com/analytics-vidhya/building-a-content-based-movie-recommendation-system-f7585ca35ed0?source=collection_archive---------22-----------------------#2020-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b192" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">*****完成这个项目后，不要忘记谷歌这个***********</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d22f6a0cad98396b4ef401a273d355bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxwM60fLcDAZkAXvcWCzrg.png"/></div></div></figure><p id="c2c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据Arthur Samuel(1959年):机器学习是<br/>研究中的“<strong class="ih hj">领域，它赋予计算机在没有明确编程的情况下学习的能力”。</strong>我试着用简单的真实世界的例子来解释机器学习的所有基础和分类… <br/>下面是链接:-<br/><a class="ae jp" rel="noopener" href="/@143jshubham/machine-learning-and-its-impact-on-our-generation-4c0dbc201c1a">https://medium . com/@ 143 jshubham/Machine-Learning-and-its-impact-on-our-generation-4c 0 DBC 201 C1 a</a></p><p id="c049" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你想过谷歌是如何推荐一部与你喜欢的电影相似的电影吗？相信我，读完这篇文章后，你将能够理解这背后的逻辑，也能够为用户建立一个这样的推荐系统。</p><p id="ff16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有特定类型的推荐系统，人们找到三四种不同的方法来构建推荐引擎:-</p><ol class=""><li id="daa3" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">基于内容的推荐引擎。</li><li id="a777" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">基于协同过滤的推荐引擎。</li><li id="3ae2" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">基于流行度的推荐引擎。</li><li id="1d6e" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">混合内容协作推荐引擎。</li></ol><p id="8c5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在在你的头脑中有一个问题，我们如何去识别它们。让我来帮你…</p><p id="a116" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基于内容的推荐引擎:- </strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/0ae88a0c973a4e1f0855f3261a078c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*cTAs1QS0UXobO86PZt2EkQ.png"/></div></figure><p id="2092" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种类型的推荐引擎中，首先我们要从用户那里输入一部电影。然后分析里面的内容。假设我们要建立一个电影推荐系统。然后我们分析所有电影的内容，比如-(故事情节:类型:演员:导演)和所有其他有相似内容的电影。然后根据他们的相似性得分对他们进行排名，然后向用户推荐最相似的电影。</p><p id="af18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基于协同过滤的推荐引擎:- </strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kf"><img src="../Images/5a2e17efa75872fd069b5e8b16fe7539.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*A7KSBF6P594tUg9d8jiVFQ.png"/></div></figure><p id="975b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法首先试图根据用户的活动发现用户之间的相似性。为了更好地理解，假设我们举了一个例子(假设我们有一本书的数据和读过这本书的用户的数据。假设用户A阅读了图书X，用户B也阅读了图书X，因此用户A和用户B的品味有一些相似之处。因此，将来如果用户A阅读了图书Y，但用户B没有阅读图书Y，那么我们可以向用户B推荐图书Y。</p><p id="fd00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基于流行度的推荐引擎:- </strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kg"><img src="../Images/6e578d4e6189415fd49394b679e02c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*gx35ZF7W3WPS4mjBcEHX1w.png"/></div></figure><p id="67f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是最简单但有效的算法，跟踪每个领域最流行的东西，并推荐特定的东西。你在YouTube或网飞看到的趋势列表就是基于这种算法。它跟踪每部电影/视频的观看次数，然后根据观看次数按降序列出电影，并向所有用户推荐该电影或歌曲。</p><p id="1da1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">混合内容协作推荐引擎:- </strong></p><p id="2e2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">混合内容-协作型推荐引擎是最准确的，它结合了基于内容和协作算法。在这种类型推荐引擎中，我们首先推荐用户由于他们自己的内容而喜欢的两种类型的东西，其次我们也推荐基于他们与不同用户的品味相似性的东西。</p><p id="0ae9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将使用s <a class="ae jp" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> cikit-learn </a>库实现一个基于<strong class="ih hj">内容的</strong>推荐系统。</p><p id="189e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以为了实现基于内容的推荐系统，我们知道我们感兴趣的是发现内容之间的相似性。逻辑很简单。如果我们有内容的相似性得分。</p><p id="0dae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是等等，我们如何找到两个或更多内容之间的相似性，我们如何知道这个内容-A与内容-B有多少相似性？</p><p id="04d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让你更好地理解，让我从一些简单的例子开始:我从某个地方拿了这个例子，因为这个例子确实帮助我理解这个推荐引擎背后的整个逻辑。我还补充了一些要点，并尝试探索整个逻辑-</p><p id="921b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有两个内容:- <br/> text-A :-印度热爱印度<br/> text-B :-热爱印度</p><p id="42e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们有两个文本。我们怎么知道，文本A和文本B有多少相似之处？</p><p id="5382" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们试图在一个2D平面(X轴是“印度”，Y轴是“爱”)上表现这两个文本，会发生什么？让我们试着这样做。</p><p id="10b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它看起来会像这样-</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kh"><img src="../Images/6a7b21343ce8a11bdcb873cc7d5998ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*ogm-Ja_gExg_yUIUvMW1LA.png"/></div></figure><p id="3d6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们看到顶点为(2，1)的第一行表示文本A，顶点为(1，2)的第二行表示文本b。</p><p id="23b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经用图形表示了这两个文本。那么，现在我们能找出这两篇文章的相似之处吗？</p><p id="013a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个文本被表示为向量。因此，我们可以很容易地说，如果两个向量之间的距离很小或角度(<em class="ki"> θ </em>)很小，则它们是相似的。假设如果它们之间的角度为0(零)，则意味着相同的向量意味着100%相似。因此，随着它们之间的角度增加，它们之间的相似性降低。正如我们所知，单独的<em class="ki"> θ没有意义，但当我们进入机器学习时，Cosθ有意义，并且我们知道Cosθ在0和1之间的第一象限中的值。</em></p><p id="163a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道如何在二维中找到两个向量之间的cos <em class="ki"> θ的值</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kj"><img src="../Images/f2beaf7b91fc0aea9b1fe79365bd17ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*Vf25SB1Lsh-tKfA-4VOS6Q.png"/></div></figure><p id="ed63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们不会计算所有向量的cos <em class="ki"> θ </em>，因为这是不可能的。我们让我们的朋友Scikit学会为我们计算:-</p><p id="3edc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的第一个目标是以向量的形式表示文本。<br/>为此，我们有sk learn . feature _ extraction . text的CountVectorizer()类<br/>我们需要在创建新的<code class="du kk kl km kn b">CountVectorizer()</code>对象之前导入这个库。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="5317" class="ks kt hi kn b fi ku kv l kw kx">text = ['India Love India','Love Love India']</span></pre><p id="1091" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们的目标制作一个文本列表。这样我们就可以将列表传递给CountVectorizer()对象，以获得数组中所有元素(text-A，text-B)向量位置的稀疏矩阵。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="6c38" class="ks kt hi kn b fi ku kv l kw kx">from sklearn.feature_extraction.text import CountVectorizer<br/>cvr = CountVectorizer()<br/>counts_matrix = cvr.fit_transform(text)</span></pre><p id="6feb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们要把它打印出来，看起来像这样:-<br/>print(count _ matrix)<br/>print(count _ matrix . toarray())</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="04ae" class="ks kt hi kn b fi ku kv l kw kx">print(text)<br/>print(count_matrix)</span></pre><p id="2d2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:-</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="4c2f" class="ks kt hi kn b fi ku kv l kw kx">text = ['India Love India','Love Love India']</span><span id="a2b3" class="ks kt hi kn b fi ky kv l kw kx"> <strong class="kn hj"> (<em class="ki">0</em>, 0)   2 <br/>  (<em class="ki">0</em>, 1)   1</strong><br/>  (1, 0)   1<br/>  (1, 1)   2</span></pre><p id="6ec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里特征名称是印度和爱，并且<strong class="ih hj">计数_矩阵</strong>有(0，0)，(0，1)这里这些<strong class="ih hj">深色部分</strong>表示文本中唯一单词的数量-A是“印度”和“爱”，其中2表示文本中出现两次单词“印度”，1表示文本中出现一次“爱”</p><p id="c774" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在为了更好地理解，我们将Count_matrix转换为Array。</strong></p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="710c" class="ks kt hi kn b fi ku kv l kw kx">print(cv.get_feature_names())<br/>print(count_matrix.toarray())</span></pre><p id="0921" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:-</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="ffda" class="ks kt hi kn b fi ku kv l kw kx">['India','Love']<br/>[[2 1]<br/> [1 2]]</span></pre><p id="4c52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里二维数组的每一行也是一个代表一个文本的数组。这里我们知道有两个文本文本-A和文本-B，所以在外部的二维数组中有两个数组。特定一维数组的长度表示唯一单词的数量，这里我们在text-A中看到，或者在第一行中，长度是2，意味着在text-A中有两个唯一的单词，即“India”和“Love ”,而第一个数组或text-A的每个元素或第一行表示该唯一单词在text-A中的出现次数。因此，最后这意味着在text-A中有2个唯一的单词，即“India”和“Love ”,而在text-A中，India出现了2次，而Love出现了1次</p><p id="71cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经把所有的文本转换成一个矢量。所以现在我们的目标是找到所有向量之间的Cos <strong class="ih hj"> θ </strong>..意思是(找出第一个和所有其他文本的Cos <strong class="ih hj"> θ </strong>然后第二个和所有其他文本的Cos……所有其他人也是如此)。而且我们看到在这个count_matrix.toarray()中每一行都是文本的一个向量位置。其中[2 1]是文本A向量，而[1，2]是文本B向量。</p><p id="5a02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的目标是找到这些向量之间的相似性，为此我们有来自<code class="du kk kl km kn b">sklearn.metrics.pairwise</code>库中的<code class="du kk kl km kn b"><a class="ae jp" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.pairwise.cosine_similarity.html" rel="noopener ugc nofollow" target="_blank">cosine_similarity()</a></code>函数。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="1ea9" class="ks kt hi kn b fi ku kv l kw kx">from sklearn.metrics.pairwise import cosine_similarity<br/>similarity_scores = cosine_similarity(count_matrix)<br/>print(similarity_scores)</span></pre><p id="0d88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它给我们的输出是所有向量与所有其他向量的相似性分数，但在我们的例子中有两个向量。因此，我们收到两行，其中第一行表示第一个文本(text-A)与自己和他人相似性得分。类似地，第二行表示第二文本(文本B)与自己和他人的相似性得分。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="ce41" class="ks kt hi kn b fi ku kv l kw kx">[[1.  0.8]<br/> [0.8 1. ]]</span></pre><p id="9a18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对此的解释是，文本A与文本A(本身)相似度为100%(位置[0，0])，文本A与文本B相似度为80%(位置[0，1])。通过观察它给出的输出类型，我们可以很容易地说，它总是会输出一个对称矩阵。因为，如果文本A和文本B有80%的相似度，那么文本B也会和文本A有80%的相似度。</p><p id="d0d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们做一些计算:-</p><p id="36a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正文-A:-[2，1] <br/>正文-B:-[1，2]</p><p id="08d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用1st:-<br/>Cos<strong class="ih hj">θ= vector(text-A)求1st的Cos <strong class="ih hj"> θ </strong>。vector(text-B)/| vector(text-A)|。|vector(text-B)| <br/> cosθ=(2i+j)。(2i+j)/{(2*2+1*1)**1/2。(2 * 2+1 * 1)* * 1/2 }<br/>cosθ= 4+1/5<br/>cosθ= 5/5<br/>T9】cosθ= 1</strong></p><p id="eef7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用第二个求第一个的Cos<strong class="ih hj">θ</strong>:-<br/>Cos<strong class="ih hj">θ= vector(text-A)。vector(text-B)/| vector(text-A)|。| vector(text-B)|<br/>cosθ=(2i+j)。(i+2j)/{(2*2+1*1)**1/2。(1 * 1+2 * 2)* * 1/2 }<br/>cosθ= 2+2/5<br/>cosθ= 4/5<br/><em class="ki">cosθ= 0.8</em></strong></p><p id="878f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用1号求2号的Cos<strong class="ih hj">θ</strong>:-<br/>Cos<strong class="ih hj">θ= vector(text-A)。vector(text-B)/| vector(text-A)|。| vector(text-B)|<br/>cosθ=(2i+j)。(i+2j)/{(2*2+1*1)**1/2。(1 * 1+2 * 2)* * 1/2 }<br/>cosθ= 2+2/5<br/>cosθ= 4/5<br/>T31】cosθ= 0.8T33】</strong></p><p id="5810" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用2nd-<br/>Cos<strong class="ih hj">θ= vector(text-A)求2nd的Cos <strong class="ih hj"> θ </strong>。vector(text-B)/| vector(text-A)|。| vector(text-B)|<br/>cosθ=(I+2j)。(i+2j)/{(1*1+2*2)**1/2。(1 * 1+2 * 2)* * 1/2 }<br/>cosθ= 1+4/5<br/>cosθ= 5/5<br/><em class="ki">cosθ= 1</em></strong></p><p id="4a35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这个表格相似度分数:-</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="a521" class="ks kt hi kn b fi ku kv l kw kx">[[1.  0.8]<br/> [0.8 1. ]]</span></pre><p id="b5ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是时候开始我们的项目了。我们已经看到了算法是如何工作:- </p><p id="e2b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先安装所有的包并导入python文件中的所有包</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="1ce8" class="ks kt hi kn b fi ku kv l kw kx">import pandas as pd<br/>import numpy as np<br/>from sklearn.feature_extraction.text import CountVectorizer<br/>from sklearn.metrics.pairwise import cosine_similarity</span></pre><p id="38ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要这个项目的电影数据集，所以我们从Kaggle下载并读取这个特定文件中的数据集。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="fdee" class="ks kt hi kn b fi ku kv l kw kx">data=pd.read_csv('movie_dataset_github.csv')</span></pre><p id="bb80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之后，我们试图清理我们的数据，所以我们在这里删除那些在训练我们的模型中不重要的列。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="caae" class="ks kt hi kn b fi ku kv l kw kx">data.drop(columns=['budget','homepage','original_language','runtime','spoken_language'  ,'status'],inplace=True)</span></pre><p id="b551" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你看到数据集，你会意识到它有许多关于电影的额外信息。我们不需要全部。因此，我们选择“关键词”、“演员”、“类型”、“导演”、“标语”等栏目作为我们的特色。这就是所谓的电影的“内容”)。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="93cd" class="ks kt hi kn b fi ku kv l kw kx">Movie_features = ['keywords','cast','genres','director','tagline']</span></pre><p id="3550" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的下一个目标是创建一个函数，将这些列的值组合成一个字符串</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="0300" class="ks kt hi kn b fi ku kv l kw kx">def combined_movie_features(row):<br/> return row['keywords']+" "+row['cast']+" "+row['genres']+" "+row['director']+" "+row['tagline']</span></pre><p id="ab60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将为data_Frame的每一行调用该函数，在此之前，我们应该清理数据，我们将用空白字符串替换所有Nan值。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="5da0" class="ks kt hi kn b fi ku kv l kw kx">for feature in Movie_features:<br/>    data[feature] = data[feature].fillna('')</span><span id="0017" class="ks kt hi kn b fi ky kv l kw kx">data['combined_movie_features'] = df.apply(combined_movie_features,axis=1)</span></pre><p id="1e80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们的数据集中有了一个额外的列combined_feature，其中有不同行或不同电影的所有功能列表，因为一行是一部特定的电影。</p><p id="6316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是时候考虑这个<strong class="ih hj">特性栏</strong>类似于<strong class="ih hj">文本列表<em class="ki">了，那时我们只有两个文本(即文本A和文本B ),但是现在我们有一个列表，其中有1000个文本，每个文本都是电影_细节</em>中的一个</strong></p><p id="fbe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在是时候使用CountVectorizer()对象将文本转换为矢量了。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="8e9a" class="ks kt hi kn b fi ku kv l kw kx">cvr = CountVectorizer()<br/>count_matrix = cvr.fit_transform(df['combined_features'])</span></pre><p id="4004" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了一个count_matrix，其中有“combined_features”列中所有文本的向量</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="a58f" class="ks kt hi kn b fi ku kv l kw kx">count_matrix=</span><span id="e6cf" class="ks kt hi kn b fi ky kv l kw kx">[[0 0 0 ... 0 0 0]<br/> [0 0 0 ... 0 0 0]<br/> [0 0 0 ... 0 0 0]<br/> ...<br/> [0 0 0 ... 0 0 0]<br/> [0 0 0 ... 0 0 0]<br/> [0 0 0 ... 0 0 0]]</span></pre><p id="c717" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们感兴趣的是发现所有“组合_特征”的文本或所有计数_矩阵的行与其自身以及与其他人的相似性。为此，我们从<code class="du kk kl km kn b">sklearn.metrics.pairwise</code>库中调用了<code class="du kk kl km kn b"><a class="ae jp" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.pairwise.cosine_similarity.html" rel="noopener ugc nofollow" target="_blank">cosine_similarity()</a></code>函数。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="6cdc" class="ks kt hi kn b fi ku kv l kw kx">cosine_similarity = cosine_similarity(count_matrix)</span></pre><p id="a2f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你能猜出余弦相似度的大小吗？</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="92a2" class="ks kt hi kn b fi ku kv l kw kx"><strong class="kn hj">cosine_similarity</strong> =</span><span id="6254" class="ks kt hi kn b fi ky kv l kw kx">[[1.         0.25692801 0.21021383 ... 0.2306328  0.25391836 0.13543224]<br/> [0.25692801 1.         0.15384615 ... 0.10127394 0.1672484  0.08920516]<br/> [0.21021383 0.15384615 1.         ... 0.10127394 0.13937367 0.0594701 ]<br/> ...<br/> [0.2306328  0.10127394 0.10127394 ... 1.         0.13762047 0.11744404]<br/> [0.25391836 0.1672484  0.13937367 ... 0.13762047 1.         0.09697623]<br/> [0.13543224 0.08920516 0.0594701  ... 0.11744404 0.09697623 1.        ]]</span></pre><p id="400f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">cosine_sim的形状是1000 x 1000意味着有1000行和1000列，因为每1000部电影都找到了与每1000部电影的相似性。因此余弦sim的每一行都是该行与所有其他行的相似性得分。</p><p id="17a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在第一行中看到余弦_sim的第一个元素是1，因为它找到了与自身的相似性得分1，然后是0.25692801，这意味着1个元素与第二个元素的相似性得分，然后是0.21021383，这意味着第一个元素与第三个元素的相似性…… <br/>现在您可以看到余弦_sim的第二行第一个元素是0.25692801，它表示第二个元素与第一个元素的相似性得分。那么1表示第二个与第二个的相似性得分。像怀斯…</p><p id="c769" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们需要制作两个函数，第一个接受标题并返回id，第二个接受id作为输入并返回标题，在用户请求后显示标题。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="31af" class="ks kt hi kn b fi ku kv l kw kx">def get_title_from_index(index):<br/>    return df[df['index'] == index]['title'].values[0]<br/>def get_index_from_movie_title(title):<br/>    return df[df['title'] == title ]['index'].values[0]</span><span id="d652" class="ks kt hi kn b fi ky kv l kw kx">#Here index shows the  index .<br/># And title is the name of the movie title.</span></pre><p id="8398" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在这种情况下，我们有相似性得分，现在如果任何用户输入电影名称，那么在dataFrame的帮助下，我们将找到该特定电影的id，然后如果我们<em class="ki">在余弦_sim中传递该id，就像这样余弦_sem[id] </em>，那么我们将获得该电影与所有其他电影的相似性得分，我们将该列表存储在一个变量name="similar_movie "中。然后我们在枚举函数的帮助下给列表中的所有元素一个id。在我们使用枚举函数之后，列表被转换成字典，其中键是索引，值是该元素与用户输入的元素的相似性分数。如果我们按价值降序排列字典。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="9149" class="ks kt hi kn b fi ku kv l kw kx"><strong class="kn hj">movie_user_likes="X-Men: Apocalypse" </strong><br/>movie_index = get_index_from_movie_title(movie_user_likes)<br/>similar_movies=list(enumerate(cosine_similarity[movie_index]))<br/></span></pre><p id="5bc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们有了一个Similar_movie的字典，因此在这之后，我们将根据值来缩短Similar_movie，我们存储除第一个索引值之外的所有值，因为这是元素与其自身的相似性得分，最大相似性为1。</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="9ae9" class="ks kt hi kn b fi ku kv l kw kx">sorted_similar_movies = sorted(similar_movies,key=lambda x:x[1],reverse=True)[1:]</span></pre><p id="9c5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了用户输入的电影的所有索引和相似性得分，现在我们的目标是从sorted_similar_movie中获取索引，并借助于<strong class="ih hj"> get_title_from_index(Rank)函数获取名称并向用户显示该名称。</strong></p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="a054" class="ks kt hi kn b fi ku kv l kw kx">i=0<br/>print("Top 5 similar movies to "+ movie_user_likes)<br/>for element in sorted_similar_movies:<br/>    print(get_title_from_index(element[0]))<br/>    i=i+1<br/>    if i&gt;4:<br/>        break</span></pre><p id="af08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们运行for循环5次，得到5部最相似的电影。</p><p id="c0dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们按照用户输入打印相似的电影:-</p><pre class="je jf jg jh fd ko kn kp kq aw kr bi"><span id="e6de" class="ks kt hi kn b fi ku kv l kw kx">Top 5 similar movies to <strong class="kn hj">X-Men: Apocalypse</strong><br/>X-Men: Days of Future Past<br/>X-Men: First Class<br/>X-Men<br/>X2<br/>Ant-Man</span></pre><h2 id="db28" class="ks kt hi bd kz la lb lc ld le lf lg lh iq li lj lk iu ll lm ln iy lo lp lq lr bi translated"><strong class="ak">谷歌一下这部{类似《x战警:天启》的电影}。<br/> </strong>你看有80%到82%的准确率。其中四个和谷歌推荐的一样…</h2><p id="6343" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">这里的Github链接，如果你想看完整的代码，你可以访问我的Github repo</p><div class="lx ly ez fb lz ma"><a href="https://github.com/143jshubham/Content_Based-Movie-Recommendation-Engine" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab dw"><div class="mc ab md cl cj me"><h2 class="bd hj fi z dy mf ea eb mg ed ef hh bi translated">143 jshubham/基于内容的电影推荐引擎</h2><div class="mh l"><h3 class="bd b fi z dy mf ea eb mg ed ef dx translated">在这个报告中，我们推出了基于内容的推荐系统的木星文件…</h3></div><div class="mi l"><p class="bd b fp z dy mf ea eb mg ed ef dx translated">github.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo jn ma"/></div></div></a></div><h1 id="9af6" class="mp kt hi bd kz mq mr ms ld mt mu mv lh mw mx my lk mz na nb ln nc nd ne lq nf bi translated">结论:-</h1><p id="22e8" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">在这篇文章中，你可以理解谷歌推荐一部与你喜欢的电影相似的电影的逻辑。所以这里重要的是数据。你可以建立任何推荐引擎，为此你需要数据。没有一个具体的方法来建立或判断一个推荐引擎，无论这是好是坏，重要的是准确性。可能发生的情况是，构建推荐引擎的特定方式在某些情况下是好的(比如85%的准确度)，但在其他一些情况下可能是坏的(40%的准确度)。这是基本的推荐引擎，所以尝试通过实现逻辑来升级它。</p></div></div>    
</body>
</html>