<html>
<head>
<title>How to solve a polynomial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何求解多项式</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-solve-a-polynomial-f8b746b49a1?source=collection_archive---------8-----------------------#2020-10-14">https://medium.com/analytics-vidhya/how-to-solve-a-polynomial-f8b746b49a1?source=collection_archive---------8-----------------------#2020-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="d3bc" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="cccf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这篇文章解释了如何解一个任意次的多项式方程。</p><p id="8cdd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们没有任何预定义的公式来求解次数超过 3 的多项式。数值方法是数学工具，可用于寻找多项式的近似根。</p><p id="065b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，我们基本上实现了一种算法，它结合了数值方法和综合除法来求解多项式方程。点击查看我的代码<a class="ae kg" href="https://github.com/reyscode/SolveAnyPoly" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a395" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们的实现将一个多项式的系数列表作为输入，并给出它的所有根。</p><p id="007d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以利用二分法来求多项式的根。但是这个问题我们还没有用到二分法。在讨论为什么之前，我们先来看看什么是二分法。</p><h1 id="d5e4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">二分法</h1><p id="2088" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个函数 f(x)和两个数字‘a’和‘b’</p><h2 id="4892" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">假设</h2><p id="34ac" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">1.f(x)在区间(a，b) <br/> 2 之间是连续的。和 f(a) * f(b) &lt; 0</p><h2 id="b9fb" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">解决办法</h2><ol class=""><li id="56c4" class="kv kw hi jf b jg jh jk jl jo kx js ky jw kz ka la lb lc ld bi translated">找到 a 和 b 的中点，比如 c</li><li id="8cc9" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka la lb lc ld bi translated">如果 f(c)=0，则 c 是根</li><li id="0583" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka la lb lc ld bi translated">Else: <br/> 1。如果 f(a)*f(c) &lt; 0 那么根位于(a，c)之间。用新的区间(a，c) <br/> 2 重复上述步骤。Else f(b)*f(c) &lt; 0 则根位于(b，c)之间。用新的间隔(b，c)重复这些步骤</li></ol><h2 id="d364" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">优势</h2><p id="5284" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们知道我们离解决方案有多近，因为我们重复这个过程，间隔变得越来越小，使我们离解决方案越来越近。</p><h2 id="86ff" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">不足之处</h2><p id="07ec" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用二分法的缺点是我们不能找到一个多项式的多重根。</p><p id="9e3d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">另一个主要缺点是寻找区间(a，b)。音程必须稍微靠近根音。最重要的是，在这个区间内应该只有一个根。例如，如果我们给定一个大的区间，并且在同一个区间内有不止一个根下落，则算法停止。</p><p id="c871" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，我们需要一个更好的算法来有效地解决这个问题。</p><h1 id="36dd" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">牛顿方法</h1><p id="a0bd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">由于二分法不适合我们，我们利用牛顿法来找出任意给定多项式的一个根。</p><p id="8b50" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">还有其他的数值方法，比如割线法来求多项式的根。但是，牛顿法相对简单，不需要更多的输入。</p><p id="6229" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在让我们讨论什么是牛顿法。</p><p id="d5ca" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">假设我们想要找到函数 f(x)的解(在这种情况下是任意次的多项式函数)，假设我们找到了这个解的初始猜测，比如 x0。这个最初的猜测几乎总是不好的，所以我们想找到一个更好的近似。这可以通过在 x0 处画一条 f(x)的切线来实现。</p><p id="446b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">x0 处切线的方程式为:</p><p id="4b53" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">y = f(x0)+f′(x0)(x x0)</p><p id="3613" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下图显示了切线</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/b13580825eff08fcad96b7d0a05b971a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMrQu287l9AA1Sow0ZZN6g.png"/></div></div></figure><p id="11b1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以看到，在 x0 处的切线更接近解。让我们把这个新的点称为 x1(这是我们新的近似值)。</p><p id="cbf4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在我们知道了新近似的坐标。即(x1，0)。我们将该值代入原始方程，并对 x1 进行如下评估:</p><p id="513e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">0 = f(x0)+f′(x0)(x1 x0)</p><p id="8429" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">x1 x0 = f(x0)/f’(x0)</p><p id="b02d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">x1 = x0f(x0)/f’(x0)</p><p id="bb93" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，我们可以找到解，只要 f'(x0)！= 0.</p><p id="3ada" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，我们再次重复这一过程，以找到 x1 的更好近似值，如下所示。假设下一个近似值是 x2。我们计算 x2 如下</p><p id="6b07" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">x2 = x1f(x1)/f’(x1)</p><p id="8f67" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">牛顿的方法是，给定一个函数 f(x)=0，xn 是 f(x)和 f'(x)的近似值！= 0，则下一个近似值计算如下:</p><p id="5518" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">x { n+1 } = xn f(xn)/f’(xn)</p><p id="cea1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用牛顿的方法，我们找到一个给定方程的一个根。牛顿法本质上是迭代的。它循环运行，一点点接近最优解。</p><p id="b240" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用牛顿法的缺点是</p><p id="8d4f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">1.f'(x)不应为零且<br/>不为 2。我们需要以某种方式找到初始近似值(x0)3。我们需要找到 f(x)对每个近似值的导数</p><p id="ce8c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在让我们看看如何在这个问题中利用牛顿法。</p><ol class=""><li id="a76d" class="kv kw hi jf b jg kb jk kc jo lv js lw jw lx ka la lb lc ld bi translated">使用函数<em class="ly"> symbolic_fn() </em>将输入函数(基本上是系数列表)转换成符号表达式。</li></ol><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="4b75" class="kh ig hi ma b fi me mf l mg mh">def symbolic_fn(coef):<br/>  """<br/>  Generating function using coefficients<br/>  The function takes the list of input coefficients and generate Symbolic function<br/>  """<br/>  sym_fun=0<br/>  x=sym.Symbol('x')<br/>  for i,val in enumerate(coef):<br/>    sym_fun=sym_fun+coef[-1-i]*x**i<br/>  return sym_fun</span></pre><p id="a097" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">2.使用<em class="ly"> evaluate_sym_exp() </em>对符号表达式求值。</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="decc" class="kh ig hi ma b fi me mf l mg mh">def evaluate_sym_exp(exp, value):<br/>  """Evaluating the symbolic function"""<br/>  return exp.subs(list(exp.free_symbols)[0], value)</span></pre><p id="3d0a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">3.<em class="ly"> newtons_method() </em>函数是牛顿方法的实现，它输出符号表达式的根。我们用<em class="ly"> sympy </em>来求 f(x)的一阶导数。</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="5c78" class="kh ig hi ma b fi me mf l mg mh">def newtons_method(fn):<br/>  """<br/>  Newtons Method<br/>  The function takes a symbolic expression as the input and gives one root of the function as output<br/>  """<br/>  n=0<br/>  x=1<br/>  while n &lt; 10:<br/>    fn_val=evaluate_sym_exp(fn, x)<br/>    dif_fn_val=evaluate_sym_exp(sym.diff(fn), x)<br/>    x = x - (fn_val/dif_fn_val)<br/>    n = n + 1<br/>  return round(x)</span><span id="15c0" class="kh ig hi ma b fi mi mf l mg mh">y=symbolic_fn([1,-9,26,-24])<br/>newtons_method(y)</span></pre><p id="9834" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，我们有一个方程和它的一个根。</p><p id="f30d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">4.用牛顿的方法，我们找到 x 的一个根，比如说 x=5。我们正在把这个根转换成一个因子，x-5(做合成除法)。</p><p id="0a36" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">5.使用上一步中的因子，我们可以利用综合除法将 n 次多项式化简为 n-1 次多项式。</p><p id="1790" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">什么是合成除法？</p><h1 id="1d3a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">合成分裂</h1><p id="580c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">综合除法是多项式除法的一种方法。在这种情况下，我们使用合成除法，每次将多项式的次数减少一次，用牛顿法得到的根。</p><p id="e46c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们以一个三次多项式为例来解释合成除法是如何工作的:</p><p id="d9ac" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">x -9x +26x-24=0</p><p id="582f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们假设，我们的牛顿法确定 3 是这个多项式的一个根</p><p id="86dd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">多项式的一般除法如下:</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mj"><img src="../Images/3ca4ecabb88251ed7aa84533990fcce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvmm5zCYKDkV646OKg3n6w.png"/></div></div></figure><p id="8a49" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，让我们看看合成除法是如何对同一个例子起作用的:</p><p id="ce63" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，我们必须将多项式的所有系数写在一个“L”形除法符号内:</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mk"><img src="../Images/1104c7895376dc01cb519cb8949cd5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIoKMBpcCK0UTlLsyPFgIQ.png"/></div></div></figure><p id="ee1d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将因子 3 放在左侧</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ml"><img src="../Images/c2e9075c954046182dbd634b11e17d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAbbOsdGvhPdMG-6ACDPCg.png"/></div></div></figure><p id="abc6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将第一个系数(前导系数)取出不变。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mm"><img src="../Images/c46e0aa141e834fa2822cffb2b701340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqkRhwuSTuLNg_jCmu2sAA.png"/></div></div></figure><p id="19c6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在将这个进位值乘以因子 3，并将结果放入下一列(除法符号内)。现在添加列，并将总和放在除法符号的底部。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mn"><img src="../Images/9fb9d899fd8649f374f976fffabefaa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsRWnE04RKM6Aluvf5tccw.png"/></div></div></figure><p id="7489" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，将前一个进位值乘以因子，得到下一个值。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mo"><img src="../Images/d36c597c20fe92c5be45e3e255260b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6L2NK6JGXLivQD5qa_4JgQ.png"/></div></div></figure><p id="969d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">重复这个过程，直到我们到达最后一个数字。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mp"><img src="../Images/417380ec3cfd96f72facbfbf36c807d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ml8ZHRKMP9SALkH5W2Zvw.png"/></div></div></figure><p id="0e08" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果最后一列的值是 0，那么 x-3 就是这个多项式的一个因子。即 3 实际上是这个多项式的根。</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="2e67" class="kh ig hi ma b fi me mf l mg mh">def synthetic_division(coef,root):<br/>  """<br/>  Synthetic Division<br/>  It takes one of the roots of n-degree polynomial and outputs a polynomial of n-1 degree<br/>  """<br/>  quotient=[]<br/>  val=coef[0]<br/>  for i,j in enumerate(coef):<br/>    if i==0:<br/>      quotient.append(coef[i])<br/>    else:<br/>      val=val*root+coef[i]<br/>      quotient.append(val)<br/>  quotient.pop()<br/>  return (quotient)</span></pre><p id="2a7c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">商的值将是 x -6x+8(比实际多项式小 1 度)</p><p id="9371" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在我们给出这个(n-1=2)二次多项式作为牛顿法的输入，以得到这个方程的一个根。</p><p id="75fe" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们用牛顿法给出的根对新的二次多项式重复综合除法，得到一个低次多项式。</p><p id="0a98" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们重复这个过程，直到得到多项式的所有根。</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="7a61" class="kh ig hi ma b fi me mf l mg mh">def solve_any_poly(coef):<br/>  """<br/>  Solving Polynomial<br/>  The function takes the list of coefficients of the polynomial of any degree<br/>  and outputs list of all roots of the given polynomial<br/>  """<br/>  roots=[]<br/>  for i,j in enumerate(coef):<br/>    while len(coef)&gt;2:<br/>      fn = symbolic_fn(coef)<br/>      root=newtons_method(fn)<br/>      roots.append(root)<br/>      coef=synthetic_division(coef,root)<br/>  return roots + [-coef[-1]]</span></pre><h1 id="9be8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">如何使用我的代码</h1><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="1248" class="kh ig hi ma b fi me mf l mg mh">python3 solve_any_poly.py</span><span id="3309" class="kh ig hi ma b fi mi mf l mg mh"># Enter Coefficients of Equation (comma separated):1,-9,26,-24<br/># [2, 3, 4]<br/></span></pre><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mq"><img src="../Images/71fad04b8afb29a9de97ea59dc7f0ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mu3u1cubZYvk-UfOoRijng.png"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx translated">solve_any_poly.py 的输出</figcaption></figure><h1 id="1149" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">用来解决这个问题的工具</h1><p id="1989" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">1.<strong class="jf hj"> Matplotlib </strong>:用于带有解的多项式的可视化<br/> 2。<strong class="jf hj"> Sympy </strong>:求函数的一阶导数，实现牛顿法。我们可以通过使用<em class="ly">有限差分法</em>来消除对 Sympy 的依赖性。<br/> 3。<strong class="jf hj">Numpy</strong>T10】4。<strong class="jf hj">绘图用克里塔</strong></p><h1 id="209d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">如何投稿</h1><p id="1dbd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通过利用泰勒级数展开，这个项目可以扩展到求解非线性项的方程，如正弦、余弦和指数。</p><p id="dc3a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">欢迎发表评论。</p></div></div>    
</body>
</html>