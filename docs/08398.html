<html>
<head>
<title>Deploying Named Entity Recognition model to production using TorchServe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 TorchServe 将命名实体识别模型部署到生产中</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deploying-named-entity-recognition-model-to-production-using-torchserve-fd8cf5cff02f?source=collection_archive---------6-----------------------#2020-07-28">https://medium.com/analytics-vidhya/deploying-named-entity-recognition-model-to-production-using-torchserve-fd8cf5cff02f?source=collection_archive---------6-----------------------#2020-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d01806690bb1ea07519f2b42292ef838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZFUfr4UVueU_FJo_a_LDlA.jpeg"/></div></div></figure><h1 id="cff7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="c476" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">TorchServe 是一个新的令人敬畏的框架，为生产中的 ptorch 模型提供服务。它使得在生产环境中大规模部署 PyTorch 模型变得容易，并且提供低延迟的轻量级服务，即高性能推理。它有一些强大的特性，比如多模型服务、A/B 测试的模型版本化、监控的指标和应用集成的 RESTful 端点，您可以快速地将您的模型从研究阶段投入生产。按照<a class="ae km" href="https://github.com/pytorch/serve" rel="noopener ugc nofollow" target="_blank"> TorchServe github 页面</a>给出的安装步骤，你可以很容易地在任何机器上安装它。</p><p id="66c0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">虽然 TorchServe 为最常见的应用程序(如对象检测和文本分类)提供了默认的处理程序，因此您不必编写自定义代码来部署您的模型，但您也可以为任何深度学习应用程序编写自己的自定义处理程序。</p><p id="122a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这篇文章将帮助你使用 torchserve 服务你的自定义 NLP 模型。我将带您看一个为命名实体识别(NER)任务训练的令牌分类模型的例子，并使用 TorchServe 为它服务。</p><blockquote class="ks kt ku"><p id="6d21" class="jo jp kv jq b jr kn jt ju jv ko jx jy kw kp kb kc kx kq kf kg ky kr kj kk kl hb bi translated">使用 torchserve 的模型服务所需的组件:<br/> a)模型类定义文件</p><p id="2335" class="jo jp kv jq b jr kn jt ju jv ko jx jy kw kp kb kc kx kq kf kg ky kr kj kk kl hb bi translated">b)可序列化的训练模型文件(对于<strong class="jq hj"> BERT </strong>模型，我们将有一个. bin 文件、一个 vocab 文件和一个配置文件)</p><p id="c244" class="jo jp kv jq b jr kn jt ju jv ko jx jy kw kp kb kc kx kq kf kg ky kr kj kk kl hb bi translated">c)具有预处理、推理和后处理三个主要方法的处理程序文件</p></blockquote><h2 id="5075" class="kz ir hi bd is la lb lc iw ld le lf ja jz lg lh je kd li lj ji kh lk ll jm lm bi translated">NER 模型</h2><p id="0e42" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><a class="ae km" href="https://github.com/huggingface/transformers" rel="noopener ugc nofollow" target="_blank"><em class="kv">hugging face/transformers</em></a><em class="kv">I</em>是文本深度学习的最先进框架，其中集成了大量基于 transformer 的架构。它还提供了在自然语言处理中根据不同类型的数据集微调给定的基于 transformer 的架构的例子。</p><p id="cbd9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在这篇文章中，我将假设我们已经在<a class="ae km" href="https://github.com/allenai/scibert/tree/master/data/ner/JNLPBA" rel="noopener ugc nofollow" target="_blank"> JNLPBA(一个生物医学 ner 数据集，由蛋白质、细胞系、RNA、DNA 和细胞类型等实体组成)数据</a>上为令牌分类模型微调了<strong class="jq hj"> BERT </strong>。用于培训的标签如下所示:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="73da" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果你没有微调过的模型，你可以使用 huggingface 库中给出的<a class="ae km" href="https://github.com/huggingface/transformers" rel="noopener ugc nofollow" target="_blank">例子，或者你可以使用</a><a class="ae km" href="https://github.com/kuldeep7688/BioMedicalBertNer" rel="noopener ugc nofollow" target="_blank"> my github 库在任何给定的 NER 数据</a>上微调 scibert。</p><p id="d6e0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我为令牌分类定制的模型类是这样的(这个模型类可以是任何模型，比如令牌分类的<strong class="jq hj"> BERTCRF </strong>等等。):</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="0849" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了正确保存和加载你微调过的模型，请通过这个<a class="ae km" href="https://huggingface.co/transformers/master/serialization.html" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="19b5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在让我们继续，假设我们有一个<em class="kv"> pytorch_model.bin、</em>一个<em class="kv"> config.json </em>和一个<em class="kv"> vocab.txt </em>来加载我们的模型。正如你在模型类中看到的，还有几个参数<em class="kv">class ification _ layer _ size 和 num_labels </em>，它们将在另一个配置文件中定义。</p><p id="545d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">保存的文件存储在<em class="kv"> model_related_data </em>文件夹中，如下所示:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/1b0dfd3d57df52663f8deca701073b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_SKmMpsi71r10Ssp4jvkNA.png"/></div></div></figure><p id="27d3" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"><em class="kv">BERT _ config . JSON</em></strong>:config 用于初始化模型的<strong class="jq hj"> BERT </strong>层</p><p id="cc77" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"><em class="kv">BERT _ for _ token _ classification _ config . JSON</em></strong>:config 用于初始化模型除<strong class="jq hj"> BERT </strong>层以外的其他参数，如 c<em class="kv">classification _ layer _ sizes</em>。</p><p id="a23c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"><em class="kv">labels _ file . txt</em></strong>:包含训练 ner 模型时使用的标签的文件</p><p id="96da" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"><em class="kv">py torch _ model . bin</em></strong>:训练好的模型权重</p><p id="91ce" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> <em class="kv"> vocab.txt </em> </strong>:用于为模型初始化<strong class="jq hj"> BERT </strong>标记器的文件</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h2 id="1fa4" class="kz ir hi bd is la lb lc iw ld le lf ja jz lg lh je kd li lj ji kh lk ll jm lm bi translated">为火炬之夜定义 NER 处理程序类</h2><p id="9335" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先我将向您展示代码，然后带您了解每个类和方法是做什么的。</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="f978" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这两个类都非常标准，用于将数据准备成一种格式，这种格式可以作为我们的<strong class="jq hj"> BERT </strong> ner 模型的输入。</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="f327" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"><em class="kv">list _ classes _ from _ module</em></strong>:帮助在处理程序脚本中导入模型类定义</p><p id="644a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"><em class="kv">_ is _ white space</em></strong>:帮助将给定文本正确地标记成单词</p><p id="2128" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> <em class="kv"> get_labels </em> </strong>:帮助读取 labels_file.txt 并准备标签列表</p><p id="2546" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，在定义了这些助手函数和类之后，我们可以浏览 ner 模型的主处理程序类。</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="fb45" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">代码有点长，因为我也在 handler 类本身中处理所有的预处理和后处理。让我们来看看这些方法。</p><p id="f6f0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">handler 类的主要方法有:</p><blockquote class="ks kt ku"><p id="8189" class="jo jp kv jq b jr kn jt ju jv ko jx jy kw kp kb kc kx kq kf kg ky kr kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi">初始化</em> </strong>:初始化<em class="hi">模型</em>和其他属性，如<em class="hi"> bert_tokenizer </em>，<em class="hi"> ber_config </em>，<em class="hi"> model_config_dict </em>，<em class="hi"> max_sequence_length </em>和<em class="hi"> num_special_tokens，labels </em>。<em class="hi">注意</em>list _ classes _ from _ module<em class="hi">是如何用于在处理程序</em>中加载模型定义的。<em class="hi">在这里，您可以初始化运行数据模型所需的所有文件名。</em></p><p id="7bba" class="jo jp kv jq b jr kn jt ju jv ko jx jy kw kp kb kc kx kq kf kg ky kr kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi">预处理</em> </strong> : <em class="hi">处理给定句子并为模型准备输入格式的方法。</em></p><p id="f393" class="jo jp kv jq b jr kn jt ju jv ko jx jy kw kp kb kc kx kq kf kg ky kr kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi">推理</em> </strong> : <em class="hi">负责从模型中获取预测的方法。</em></p><p id="6825" class="jo jp kv jq b jr kn jt ju jv ko jx jy kw kp kb kc kx kq kf kg ky kr kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi">后处理</em> </strong> : <em class="hi">模型的输出将只是句子的每个标记的 label_id，所以在这个方法中，我负责通过 bert_tokenizer 拆分单词，并对齐每个单词的标签，然后提取实体。</em></p></blockquote><p id="df97" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">下面是在上面提到的 handler 类的 main 方法中调用的 helper 方法:</p><blockquote class="ks kt ku"><p id="7dc9" class="jo jp kv jq b jr kn jt ju jv ko jx jy kw kp kb kc kx kq kf kg ky kr kj kk kl hb bi translated"><strong class="jq hj"><em class="hi">convert _ sentence _ to _ example</em></strong>:用于将输入的句子转换成范例对象。</p><p id="7c7d" class="jo jp kv jq b jr kn jt ju jv ko jx jy kw kp kb kc kx kq kf kg ky kr kj kk kl hb bi translated"><strong class="jq hj"><em class="hi">【convert _ sentence _ to _ example】</em></strong>:用于从示例对象创建特征对象。</p><p id="1181" class="jo jp kv jq b jr kn jt ju jv ko jx jy kw kp kb kc kx kq kf kg ky kr kj kk kl hb bi translated"><strong class="jq hj"><em class="hi">align _ out _ label _ with _ original _ sentence _ tokens</em></strong>:此方法将 ner 标签与句子中的每个单词对齐。</p><p id="7169" class="jo jp kv jq b jr kn jt ju jv ko jx jy kw kp kb kc kx kq kf kg ky kr kj kk kl hb bi translated"><strong class="jq hj"><em class="hi">【convert _ to _ ents _ dict</em></strong>:该方法获取 ner 标签和单词，并在句子中为每个被识别的实体准备一个带有 start_span 和 end_span 的 dict 对象。</p></blockquote><p id="946e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们将 handler 类和所有辅助函数放在一个脚本中，这将是<strong class="jq hj"><em class="kv">ner _ torch serve _ handler . py</em></strong>脚本，并将在 torch 模型归档器中使用。</p><p id="2117" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">将训练好的关卡转换成火炬服务器 MAR 文件</strong></p><p id="2ab2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">TorchServe 使用一种叫做<a class="ae km" href="https://pytorch.org/serve/model-archiver.html" rel="noopener ugc nofollow" target="_blank"> MAR(模型存档)</a>的格式来打包模型，并在其模型存储中对它们进行版本化。为了从 TorchServe 访问它，我们需要将我们训练过的<strong class="jq hj"> BERT </strong>检查点转换成这种格式，并在上面附加我们的处理程序。</p><p id="2575" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了存储. mar 文件，我们创建了一个名为 model_store 的目录。</p><pre class="ln lo lp lq fd mb mc md me aw mf bi"><span id="243a" class="kz ir hi mc b fi mg mh l mi mj">mkdir model_store</span></pre><p id="d53d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">下面给出了存档 ner 模型的命令:</p><pre class="ln lo lp lq fd mb mc md me aw mf bi"><span id="cb33" class="kz ir hi mc b fi mg mh l mi mj">torch-model-archiver --model-name ner_model --version 1.0 --model-file model.py --serialized-file model_related_data/pytorch_model.bin --export-path model_store/ --extra-files "model_related_data/bert_config.json,model_related_data/bert_for_token_classification_config.json,model_related_data/vocab.txt,model_related_data/labels_file.txt" --handler ner_torchserve_handler.py</span></pre><p id="3861" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">-model-name:您要为您的模型指定的名称，这将在向模式发送请求时使用</p><p id="0015" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">—模型文件:定义模型类的文件的路径</p><p id="f426" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">-序列化文件:模型权重的路径</p><p id="d659" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">—导出路径:要保存的目录。标记文件</p><p id="8bf2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">-额外文件:添加模型初始化所需的所有额外文件</p><p id="f786" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">—处理程序:处理程序脚本的路径</p><p id="d637" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">文件夹内容将如下所示:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/4f1ac43744a6ba49cd97df8c8507a1b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rxQ5VXE2RzGvUFPnQghaWQ.png"/></div></div></figure><p id="3f37" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在归档模型之后，我们运行下面的命令，使用 torch serve 来服务我们的模型。</p><pre class="ln lo lp lq fd mb mc md me aw mf bi"><span id="22d7" class="kz ir hi mc b fi mg mh l mi mj">torchserve --start --ncs --model-store model_store/ --models ner_model.mar</span></pre><p id="f4e2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，您可以通过下面给出的 url 与您的模型进行交互<a class="ae km" href="http://127.0.0.1:8080/predictions/ner_model" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080/predictions/ner _ model</a></p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h2 id="cb2c" class="kz ir hi bd is la lb lc iw ld le lf ja jz lg lh je kd li lj ji kh lk ll jm lm bi translated">显示了一个输出示例</h2><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="259f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">TorchServe 的<a class="ae km" href="https://pytorch.org/serve/management_api.html#list-models" rel="noopener ugc nofollow" target="_blank">管理 API </a>中有许多额外的有趣功能，例如，我们可以轻松获得所有注册模型的列表，注册新模型或新模型版本，并动态切换每个模型的服务模型版本。</p><p id="405a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在接下来的文章中，我将介绍其他特性，比如 torch serve 中的批量推理。</p><p id="b947" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">你可以通过下面给出的 github repo 来查看完整的代码库。</p><div class="ml mm ez fb mn mo"><a href="https://github.com/kuldeep7688/TorchserveNer" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">库尔迪普 7688/火炬服务器</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">使用 TorchServe 部署微调的 NER 模型。通过创建一个……</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc io mo"/></div></div></a></div></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="15ef" class="iq ir hi bd is it nd iv iw ix ne iz ja jb nf jd je jf ng jh ji jj nh jl jm jn bi translated">资源</h1><div class="ml mm ez fb mn mo"><a href="https://aws.amazon.com/blogs/machine-learning/deploying-pytorch-models-for-inference-at-scale-using-torchserve/" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">使用 TorchServe | Amazon Web Services 部署 PyTorch 模型进行大规模推理</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">今天你所交互的许多服务都依赖于机器学习(ML)。从在线搜索和产品推荐到…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">aws.amazon.com</p></div></div><div class="mx l"><div class="ni l mz na nb mx nc io mo"/></div></div></a></div><div class="ml mm ez fb mn mo"><a rel="noopener follow" target="_blank" href="/the-artificial-impostor/deploying-efficientnet-model-using-torchserve-9f5f811aa447"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">使用 TorchServe 部署 EfficientNet 模型</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">案例研究</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">medium.com</p></div></div><div class="mx l"><div class="nj l mz na nb mx nc io mo"/></div></div></a></div><div class="ml mm ez fb mn mo"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/deploy-huggingface-s-bert-to-production-with-pytorch-serve-27b068026d18"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">使用 pytorch/serve 将 huggingface 的 BERT 部署到生产中</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">NLP 模型部署和服务的未来一瞥。</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">medium.com</p></div></div><div class="mx l"><div class="nk l mz na nb mx nc io mo"/></div></div></a></div><div class="ml mm ez fb mn mo"><a href="https://github.com/pytorch/serve" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">py torch/发球</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">TorchServe 是一个灵活易用的工具，用于服务 PyTorch 模型。有关完整的文档，请参见…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">github.com</p></div></div><div class="mx l"><div class="nl l mz na nb mx nc io mo"/></div></div></a></div></div></div>    
</body>
</html>