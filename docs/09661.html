<html>
<head>
<title>Advanced Imputation of Missing Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缺失值的高级插补</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/advanced-imputation-of-missing-values-b7a06538c798?source=collection_archive---------14-----------------------#2020-09-15">https://medium.com/analytics-vidhya/advanced-imputation-of-missing-values-b7a06538c798?source=collection_archive---------14-----------------------#2020-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b5fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从WiDS 2020 竞赛中吸取的关于<strong class="ih hj">不</strong>做什么的教训。</p><h1 id="4b03" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">挑战</h1><p id="b3e8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">挑战在于创建一个模型，利用重症监护最初24小时的数据来预测患者的存活率。麻省理工学院的GOSSIS community initiative拥有哈佛隐私实验室的隐私认证，提供了超过130，000名医院重症监护病房(ICU)患者的数据集，时间跨度为一年。这些数据是一个不断增长的全球努力和联盟的一部分，该联盟涵盖了阿根廷、澳大利亚、新西兰、斯里兰卡、巴西和美国的200多家医院。</p><h1 id="fedf" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">数据</h1><p id="32b6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们得到的数据真的很乱。有9万行，将近190列！</p><p id="cecb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数色谱柱有高达80%的缺失值，这使得开始分析变得非常困难。正如下面可以看到的，大多数列有非正态分布和奇怪的偏斜。除此之外，等级不平衡，只有大约8%的数据是正面等级。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/b7b4b973fa21f9d37c1c62fe7b9100a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oK4hpEmT2Dtv27ePbZv9bw.png"/></div></div></figure><h1 id="f1b2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">电子设计自动化(Electronic Design Automation)</h1><p id="fcad" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们的EDA开始尝试回答以下问题</p><ul class=""><li id="baf5" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">什么特征对患者的生存影响最大？</li><li id="d1c7" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">年龄如何影响患者存活率？</li><li id="0fe6" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">不管病情如何，老年患者的风险更高吗？</li><li id="7b97" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">疾病/状况和死亡人数之间是否有很强的相关性？</li><li id="b339" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">疾病/状况与患者入院和再入院之间是否存在相关性？</li></ul><p id="02be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们试图遵循一种思路，即我们手头有什么类型的数据，谁是患者，人口统计数据是什么，哪些患者住院的主要条件是什么，等等。</p><p id="c370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了了解我们实际上拥有谁的数据，我们试图沿着人口统计学的路线深入研究。</p><p id="c708" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用<strong class="ih hj">种族和年龄</strong>来钻取数据。从种族饼状图中，我们看到数据集中的大多数人是白种人，其次是非裔美国人。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lh"><img src="../Images/668c6cb762c8b53bd5f6510f7523d6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JkS6p3Mb1ZrWOjZ3-rw-tw.png"/></div></div></figure><p id="1d86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们再增加一个维度——年龄，我们会在柱状图中看到一个有趣的模式。我们看到，特别是对于非裔美国人来说，患者的比例随着年龄的增长而下降。我们看到，年轻的非裔美国患者约占年轻患者总数的25–30 %,但随着我们在图表中向上移动到老年人口，我们可以看到该比例平均下降到10%左右。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es li"><img src="../Images/2f5b807d6e77bb491151a17e17d9c035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zu581urgCvkUyh1TtO5ejw.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">招生来源</figcaption></figure><p id="aaa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看到大多数人因为事故或紧急情况而住进重症监护室。我们想知道在重症监护室通常会看到什么样的病例。为此，我们制作了诊断列的树形图。因为大多数病例是心血管疾病——心脏病发作。我们看到，可能来自车祸或其他事故的神经系统病例、呼吸系统和败血症病例也占了病例的很大一部分</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ln"><img src="../Images/08ae28b4443905815af85d317c3500a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6g3NFCM-eCwaGNyQSQhdJA.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">疾病类型</figcaption></figure><p id="ef5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们根据不同的情况进一步分割数据，我们会发现大多数患者患有糖尿病。将致命病例与非致命病例进行比较，我们看到一个有趣的模式——在这两种情况下，疾病的比例不同。尽管糖尿病几乎占非致命病例的80%,但它仅占致命病例的60%。肝功能衰竭的比例几乎翻倍，从5%增加到10%左右，免疫抑制的比例从10%左右增加到15%。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lo"><img src="../Images/3ba12825df378ea7e7b54f48e8495d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*7BYShC-WquzFjyGz3k98dQ.png"/></div></figure><h1 id="da07" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">数据范围</h1><p id="9d27" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj">箱线图</strong></p><p id="9e94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用该图，我们可以比较存活患者(Hospital_death=0)和未存活患者(Hospital_death=1)的各种属性的范围和分布。</p><p id="6746" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> apache_4a_icu_death_prob </strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lp"><img src="../Images/82603c2eaf20823eb3c243d126e51726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/0*uVnyIz4akZOu07US"/></div></figure><p id="c2ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的方框图中，我们可以看到存活和未存活患者的apache_4a_icu_death_prob的中位数不同，这意味着住院死亡可能取决于apache_4a_icu_death_prob</p><p id="0b6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">阿帕奇_ 4a _医院_死亡_问题</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lq"><img src="../Images/c2581c69faf985efc2c9ab4de6c7575f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/0*gnSoKUOtrBCO-bwe"/></div></figure><p id="e647" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的方框图中，我们可以看到存活和未存活患者的apache_4a_hospital_death_prob的中位数不同，这意味着住院死亡可能取决于apache_4a_hospital_death_prob</p><h1 id="e6bd" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">插补</strong></h1><p id="77cf" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">由于大部分缺失值属于初始小时观测值(h1 ),并且这些值可以用d1中的值来解释，因此h1_variables中缺失50%以上的变量被删除。</p><p id="5eeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们尝试了许多输入缺失值的方法</p><p id="66f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">聚类插补</strong></p><p id="2f9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想法是对观察值进行聚类，然后根据属于同一聚类的观察值，使用指定的聚类来计算值。</p><p id="e685" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">clusters = KMeans(n_clusters = 50)。适合(ndf)</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lr"><img src="../Images/9da57ea5a6983d42447335c9503653e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NYoXPykwlc5QXAkb"/></div></div></figure><p id="291c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这段代码失败了，因为Sklearn的Kmeans实现都在内存中，因此它需要13.7 gb的空间，这是禁止的——因此我们尝试了使用Dask(并行化)、Numba(编译)和KD树(近似)的数字定制实现。还有<a class="ae jd" href="https://scikit-learn.org/stable/modules/clustering.html#mini-batch-kmeans" rel="noopener ugc nofollow" target="_blank">小批量方式</a>，我们推迟到以后。相反，我们尝试使用KNN树和KD树进行基于邻居的插补。</p><p id="2420" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基于邻居的插补</strong></p><p id="610d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遵循与集群类似的思路，我们尝试实现K-nn实现，但是使用Dask和Numba</p><p id="e12b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> A. </strong> <a class="ae jd" href="https://docs.dask.org/en/latest/why.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Dask基础</strong> </a></p><p id="d1e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Dask想出了如何分解大型计算，并有效地将其中的一部分传送到分布式硬件上。Dask通常运行在千机集群上，在安全的环境中高效地处理数百万亿字节的数据。但更重要的是，Dask可以让分析师在他们的笔记本电脑上操作100GB以上的数据集，或在工作站上操作1TB以上的数据集，而完全不需要使用集群。Dask可以利用多核CPU在单台机器上实现高效的并行计算，并从磁盘高效地传输数据</p><p id="4769" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Dask使用现有的Python APIs和数据结构，使得在Numpy、Pandas、Scikit-learn和它们基于Dask的对等物之间切换变得容易。</p><p id="1572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的Dask应用程序中，想法是允许Dask处理分区，并对每个块应用pairwise_distance函数。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ls"><img src="../Images/bb6d8f00c3537f3bebbde3c995ff12e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aLdXsLa_f018DCTg"/></div></div></figure><p id="d268" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/numba/numba" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> B. Numba基础</strong>T3】</a></p><p id="a705" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Numba是一个针对Python的实时编译器，最适合使用NumPy数组和函数以及循环的代码。使用Numba最常见的方式是通过它的decoratorss集合，这些decorator可以应用到您的函数中来指示Numba编译它们。当一个Numba修饰函数被调用时，它会被编译成“实时”执行的机器代码，并且你的全部或部分代码可以以本机代码的速度运行！</p><p id="673e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种方法中，我们希望通过使用numba编译来加快每行的计算速度。还尝试使用<a class="ae jd" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KDTree.html" rel="noopener ugc nofollow" target="_blank"> KD树</a>来加速邻居查找，这是近似的，但对于插补来说已经足够好了。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lt"><img src="../Images/d14c8c8d5696e6ec22554ba94dd4c796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1p2zrUESD5jdU9RT"/></div></div></figure><h1 id="0765" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">吸取的教训</h1><p id="3e97" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在尝试使用这里提到的先进方法来改善我们的模型ROC-AUC评分之前，我们从简单的均值估算开始。</p><p id="a58f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说到底，我们只能说这不值得。我就直接引用Sklearn的<a class="ae jd" href="https://scikit-learn.org/stable/developers/performance.html" rel="noopener ugc nofollow" target="_blank">关于性能的页面</a></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lu"><img src="../Images/e21680e5a39b27f7ebe22474ab8ceefb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OslaGwE1rjJm6ifi1oIv1g.png"/></div></div></figure><p id="60ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们尝试的优化并没有真正发挥作用，性能提升也很有限。现在你知道了3种方法来处理丢失的值。</p><p id="8a28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们采用随机森林插补法，并将它们与简单均值和中位数插补法进行对比，总体模型在ROC-AUC方面的表现没有太大差异。</p><p id="eeb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时候简单的事情最终会解决。</p><p id="194b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有任何建议或反馈，请在linkedin上联系我</p></div></div>    
</body>
</html>