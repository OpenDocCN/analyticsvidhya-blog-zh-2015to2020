<html>
<head>
<title>Building a Database REST API with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 构建数据库 REST API</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-database-rest-api-with-python-ab3d8c2354ff?source=collection_archive---------6-----------------------#2020-11-13">https://medium.com/analytics-vidhya/building-a-database-rest-api-with-python-ab3d8c2354ff?source=collection_archive---------6-----------------------#2020-11-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/25d8242c89bbf1fee77d7346779bd8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_UA7tstw_q8ZVZQA6o4Qw.png"/></div></div></figure><p id="a249" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将在尽可能短的时间内为数据库构建一个 REST API。</p><p id="03c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快速构建 API 可能很重要，但 API 的性能也很重要。出于这个原因，将使用<a class="ae jo" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>结合<a class="ae jo" href="https://github.com/encode/uvicorn" rel="noopener ugc nofollow" target="_blank">uvicon</a>、<a class="ae jo" href="https://github.com/codemation/easyrpc" rel="noopener ugc nofollow" target="_blank"> easyrpc </a>和<a class="ae jo" href="https://github.com/codemation/aiopyql" rel="noopener ugc nofollow" target="_blank"> aiopyql </a>来构建 API，用于处理请求、数据库访问和缓存。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="5d9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于本文，可以使用 python 3.7 或更高版本，这是上述包所需的最低版本。</p><p id="57b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建并激活 python 环境。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="2b5e" class="kf kg hi kb b fi kh ki l kj kk">$ virtualenv -p python3.7 db-api<br/>$ source db-api/bin/activate</span></pre><p id="fb76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装我们的依赖</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="a5e3" class="kf kg hi kb b fi kh ki l kj kk">(db-api)$ pip install easyrpc aiopyql</span></pre></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="cb88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">API 将由两层构成:</p><ul class=""><li id="90ac" class="kl km hi is b it iu ix iy jb kn jf ko jj kp jn kq kr ks kt bi translated">数据库访问层:数据库访问和缓存</li><li id="78f7" class="kl km hi is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt bi translated">API 访问层:处理客户端 API 请求</li></ul><p id="166a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这通常会耦合到一个单独的层中，但其好处将在下面解释。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="0563" class="kz kg hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数据库层</h1><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="276c" class="kf kg hi kb b fi kh ki l kj kk">server = FastAPI()</span></pre><p id="ef94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">FastAPI()实例服务器参考是 API 层中用于客户端请求的主要 URL 路由器，也是数据库层中用于 EasyRpcServer 的 Websocket 路由器。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="15d2" class="kf kg hi kb b fi kh ki l kj kk">@server.on_event('startup')</span></pre><p id="9038" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">FastAPI on_event 提供了两个有用的钩子，用于在应用程序启动时执行安装/拆卸。on_event(启动|关闭)</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="4bd7" class="kf kg hi kb b fi kh ki l kj kk"># Rpc Server    <br/>rpc_server = await EasyRpcServer.create(<br/>    server, <br/>    '/ws/database', <br/>    server_secret='abcd1234'<br/>)</span></pre><p id="9031" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">EasyRpcServer.create 是一个类工厂方法，它返回一个 EasyRpcServer()实例:使用我们的 FastAPI 服务器、web-socket 路径(其中 ASGI 服务器将接受 Websocket 协商)、server _ secret(EasyRpcProxy 将用于连接的密码)以及可选的 encryption_enabled=True|False。</p><p id="d4d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">EasyRpcServer 引用 rpc_server 将用于在名称空间中注册我们的数据库函数，该名称空间将与连接的 EasyRpcProxies 共享——稍后将详细介绍。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="bc01" class="kf kg hi kb b fi kh ki l kj kk">db = await Database.create(<br/>    database='easy_db',<br/>    cache_enabled=True<br/>)</span></pre><p id="bb9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Database.create 是一个工厂方法，它使用 database=name，cache_enabled=True|False 返回 Database()实例。默认的数据库类型是 sqlite，因此需要最少的参数。详见<a class="ae jo" href="https://github.com/codemation/aiopyql" rel="noopener ugc nofollow" target="_blank"> aiopyql </a>。</p><p id="a968" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里使用 aiopyql 是因为它的简单性、对 asyncio 的支持以及缓存特性，这些特性在证明 API /数据库层分离时非常有用。使用的模式可以转换成任何共享数据库访问的 ORM。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="f530" class="kf kg hi kb b fi kh ki l kj kk"># Table Creation    <br/>if not 'keystore' in db.tables:        <br/>    await db.create_table(<br/>        'keystore',            <br/>        [<br/>          ('key', str, 'UNIQUE NOT NULL'),<br/>          ('value', str)<br/>        ],<br/>        prim_key='key',            <br/>        cache_enabled=True<br/>     )</span></pre><p id="01ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的数据库()实例“db”自动发现表模式(如果存在的话)并在 db.tables 中创建一个 table()对象。</p><p id="625b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过上面的检查，用一个非常简单的键值 schama 创建了一个名为“keystore”的表。这可以被认为是持久性 python 字典——具有缓存的额外好处。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="5ba6" class="kf kg hi kb b fi kh ki l kj kk">server.data = {'keystore': db}</span></pre><p id="9fab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据库实例引用存储在我们的 FastAPI 路由器中，这是清理步骤所需要的。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="fa95" class="kf kg hi kb b fi kh ki l kj kk"># register each table method in table namespace <br/>for table in db.tables:<br/>    for func in {'select', 'update', 'insert', 'delete'}:<br/>        rpc_server.origin(<br/>            getattr(db.tables[table], func), namespace=table)<br/>server.db_server = db_server</span></pre><p id="2b91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">db.tables 中的每个 Table()实例都包含选择、更新、插入和删除方法。</p><p id="2c2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于每个函数，EasyRpcServer()实例。使用函数引用和 namespace=table_name 调用 origin 方法。</p><p id="e273" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果有不止一个表，上面的例子将在一个与表名匹配的名称空间中注册这些方法。</p><p id="ca43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注册实际上是做什么的？</p><p id="fd07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">register 方法“dictionarifies”函数元数据，并将其存储在名称空间中。所谓元数据，我指的是用于调用方法的所有东西(参数、参数类型、方法名)。</p><p id="3d46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">EasyRpcProxy 实例使用此函数元数据来“镜像”代理函数，并验证正确的输入。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="8438" class="kf kg hi kb b fi kh ki l kj kk"><a class="ae jo" href="http://twitter.com/server" rel="noopener ugc nofollow" target="_blank">@server</a>.on_event('shutdown')<br/>async def shutdown():<br/>    await server.data['keystore'].close()</span></pre><p id="7b3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">内务关闭方法允许我们的实例优雅地清理。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="0463" class="kz kg hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">API 层</h1><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="5b44" class="kf kg hi kb b fi kh ki l kj kk">from fastapi import FastAPI<br/>from easyrpc.proxy import EasyRpcProxy</span></pre><p id="14f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像我们的数据库层一样，FastAPI 路由器将用于客户端 API 请求。用于访问我们的数据库层。</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="b1da" class="kf kg hi kb b fi kh ki l kj kk"><a class="ae jo" href="http://twitter.com/server" rel="noopener ugc nofollow" target="_blank">@server</a>.on_event('startup')<br/>async def setup():<br/>    <br/>    server.data = {}<br/>    server.data['keystore'] = await EasyRpcProxy.create(<br/>        '0.0.0.0', <br/>        8220, <br/>        '/ws/database', <br/>        server_secret='abcd1234',<br/>        namespace='keystore'<br/>    )</span></pre><p id="a80b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 startup on_event 中，在 FastAPI 路由器实例中创建一个数据字典，然后使用主机地址、端口、目标 websocket 路径、密码和与数据库层 EasyRpcServer 对应的名称空间创建一个 EasyRpcProxy()实例。</p><p id="c982" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">启动时，EasyRpcProxy()实例将联系目标 EasyRpcServer，并在指定的名称空间中创建所有已注册函数的代理。</p><p id="9d2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://github.com/codemation/aiopyql" rel="noopener ugc nofollow" target="_blank"> aiopyql </a>表方法接受完全 JSON 可序列化的输入，从而使函数完全符合 EasyRpcProxy-&gt;EasyRpcServer 函数调用约束。</p><h2 id="45b6" class="kf kg hi bd la ly lz ma le mb mc md li jb me mf lm jf mg mh lq jj mi mj lu mk bi translated">插入和更新</h2><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/569d4f718f4718e3046f782d3afc7ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oZJ7cyNiLY7MAnji_Thyw.png"/></div></div></figure><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="abd0" class="kf kg hi kb b fi kh ki l kj kk"><a class="ae jo" href="http://twitter.com/server" rel="noopener ugc nofollow" target="_blank">@server</a>.post("/{table}")<br/>async def insert_or_update_table(table, data: dict):<br/>    for key, value in data.items():<br/>        exists = not (await server.data['keystore']['select']('*', where={'key': key}) == [] )<br/>        if exists:<br/>            await server.data['keystore']['update'](<br/>                value=value,<br/>                where={'key': key}<br/>            )<br/>        else:<br/>            await server.data['keystore']['insert'](<br/>                key=key,<br/>                value=value<br/>            )</span></pre><p id="a341" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="http://twitter.com/server" rel="noopener ugc nofollow" target="_blank">@服务器</a>。post("/{table} ")接受表名的文本输入，以及包含我们的插入或更新的字典。</p><p id="d01f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在决定这是否是插入/更新操作之前，检查主键的存在。</p><p id="7eb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">插入/更新方法的行为就像它们是本地的一样，从语法上验证参数输入</p><h2 id="b19c" class="kf kg hi bd la ly lz ma le mb mc md li jb me mf lm jf mg mh lq jj mi mj lu mk bi translated">选择</h2><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/811a96e945523ea84f3617e643beea5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWd1HN5VPqIJpfM__j_fGQ.png"/></div></div></figure><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="7e25" class="kf kg hi kb b fi kh ki l kj kk"><a class="ae jo" href="http://twitter.com/server" rel="noopener ugc nofollow" target="_blank">@server</a>.get("/{table}")<br/>async def get_table_items(table: str):<br/>    return await server.data['keystore']['select']('*')</span><span id="9848" class="kf kg hi kb b fi mn ki l kj kk"><a class="ae jo" href="http://twitter.com/server" rel="noopener ugc nofollow" target="_blank">@server</a>.get("/{table}/{key}")<br/>async def get_table_item(table: str, key: str):<br/>    return await server.data['keystore']['select'](<br/>        '*', <br/>        where={'key': key}<br/>    )</span></pre><p id="7e45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是访问存储数据的两种实现。get_table_items 发出 select(*)，返回所有键值。get_table_item 发出带有 where 子句的 select(*)命令</p><h2 id="1855" class="kf kg hi bd la ly lz ma le mb mc md li jb me mf lm jf mg mh lq jj mi mj lu mk bi translated">删除</h2><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/ea9a1bf9ad40d50c2c2309ee0ec456c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-9byPeFmszAsLOFRaweFQ.png"/></div></div></figure><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="bc6a" class="kf kg hi kb b fi kh ki l kj kk"><a class="ae jo" href="http://twitter.com/server" rel="noopener ugc nofollow" target="_blank">@server</a>.delete("/{table}")<br/>async def delete_table_item(table: str, where: dict):<br/>    return await server.data['keystore']['delete'](where=where)</span></pre><p id="5f44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该方法接受提供的表名和 where 子句{'col': 'value'}，能够删除一个或多个匹配的表行。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="677c" class="kz kg hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">启动实例</h1><p id="e35b" class="pw-post-body-paragraph iq ir hi is b it mo iv iw ix mp iz ja jb mq jd je jf mr jh ji jj ms jl jm jn hb bi translated">首先启动数据库层实例</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="5de1" class="kf kg hi kb b fi kh ki l kj kk">(db-api)$ uvicorn --host 0.0.0.0 --port 8220 db_api_database:server</span></pre><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/a29ce05ac2023528833efc516134be6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3095f_pVVxXY8mFGda04DA.png"/></div></div></figure><p id="37d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后用可选的 workers 参数启动 API 层实例:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="9cc3" class="kf kg hi kb b fi kh ki l kj kk">(db-api)$ uvicorn --host 0.0.0.0 --port 8221 db_api:server --workers 5</span></pre><figure class="jw jx jy jz fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/150076a0c33401a177ee619327ff9d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*0KguGgQ1NE29EUArDGG8qA.png"/></div></figure><p id="d6f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要进行测试，请在浏览器中打开<a class="ae jo" href="http://0.0.0.0/8221" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">http://0 . 0 . 0 . 0:8221</strong></a><strong class="is hj">/docs/</strong>。</p><p id="7a90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个创建的 uvicorn worker 对应于一个 API 层代码的独立版本。</p><p id="2d6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">uvicorn 工作人员不能够直接相互通信，但是在这种架构中，共享相同的数据库连接、函数和缓存。</p><p id="eab0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当一个工作者通过一个客户机 REST 请求进行修改或访问数据时，就会加载缓存(如果启用的话)，所有的 uvicorn 工作者都会受益。</p><p id="845e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果没有这种分层分离，每个 uvicorn worker 都可以创建自己的数据库连接，但是如果同一个数据库被另一个 worker 访问，就不应该使用缓存。</p><p id="453c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">许多数据库可以支持多个连接，但是如果进程不能传递更改，则很少缓存层是可信的。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="3df3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了<a class="ae jo" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>，开发者可以快速有效地创建同样易于使用的 API。</p><p id="2658" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<a class="ae jo" href="https://github.com/codemation/aiopyql" rel="noopener ugc nofollow" target="_blank"> aiopyql </a>，对数据库的访问是很简单的，而且有了缓存和查询队列，访问速度很快。</p><p id="1e22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://github.com/codemation/easyrpc" rel="noopener ugc nofollow" target="_blank"> EasyRpc </a>允许简单的扩展/共享功能，并且可以有效地允许一个应用的多个子代共享状态、连接等等。</p></div></div>    
</body>
</html>