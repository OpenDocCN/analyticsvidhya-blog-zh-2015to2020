<html>
<head>
<title>Pytorch implementation of Semantic Segmentation for Single class from scratch.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pytorch实现从无到有的单类语义切分。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pytorch-implementation-of-semantic-segmentation-for-single-class-from-scratch-81f96643c98c?source=collection_archive---------1-----------------------#2019-12-14">https://medium.com/analytics-vidhya/pytorch-implementation-of-semantic-segmentation-for-single-class-from-scratch-81f96643c98c?source=collection_archive---------1-----------------------#2019-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3b972051c2af65576646ecb5968a3bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOf6RHuftR9nGMwOYUCn_g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由MIDHUN GEORGE通过unsplash拍摄</figcaption></figure><h2 id="ce39" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">介绍</h2><p id="dada" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">语义分割可以被认为是像素级的分类，更准确地说，它是指将图像中的每个像素链接到类别标签的过程。我们在这里试图回答<strong class="jv hj">什么&amp;图像中的位置</strong>，语义分割不同于实例分割，在实例分割中，相同类别的对象将具有不同的标签，如car1、car2中的不同颜色。</p><p id="09e8" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在语义分割以非常复杂的形式用于多类的情况下，有许多可用的存储库。<strong class="jv hj">通过这个博客，我试图为一个类从头开始实现语义分割，经过一些调整后，同样的方法应该适用于多个类</strong>。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/df00a1fd508a8f5e9433a89b04a63dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipnMqWdP2LiQRNpv4uwKjg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">自动驾驶<a class="ae iu" href="https://www.mapillary.com/dataset/vistas?pKey=-3WWvMk6i1YgKC9ECG2HEA&amp;lat=26.38900088674862&amp;lng=82.67520964428127&amp;z=2.4745541932089794" rel="noopener ugc nofollow" target="_blank">图片来源</a></figcaption></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/116651860acfbe6056133402358f493a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*iWl8fEXppa53jErOsFPjXg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">空中成像<a class="ae iu" href="https://deepsense.ai/deep-learning-for-satellite-imagery-via-image-segmentation/" rel="noopener ugc nofollow" target="_blank">图像</a>来源</figcaption></figure><blockquote class="kz la lb"><p id="2317" class="jt ju lc jv b jw ko jy jz ka kp kc kd ld kq kf kg le kr ki kj lf ks kl km kn hb bi translated">它的一些主要应用是在<strong class="jv hj">自动驾驶</strong>、<strong class="jv hj">医学图像诊断、航空成像</strong>、<strong class="jv hj">照片编辑/创意工具以及更多</strong>。</p></blockquote><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/bc9c46d3dd6058f5b6719cee00000c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0io7ct9WDK-0UlU731Io1w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">脑肿瘤预测<a class="ae iu" href="https://news.developer.nvidia.com/automatically-segmenting-brain-tumors-with-ai/" rel="noopener ugc nofollow" target="_blank">图片</a>来源</figcaption></figure><h2 id="9d3b" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">涵盖主题的路线图</h2><ol class=""><li id="2374" class="lh li hi jv b jw jx ka kb jg lj jk lk jo ll kn lm ln lo lp bi translated"><a class="ae iu" href="#2f8a" rel="noopener ugc nofollow"> <strong class="jv hj"> <em class="lc">概述</em> </strong> </a></li><li id="bcbc" class="lh li hi jv b jw lq ka lr jg ls jk lt jo lu kn lm ln lo lp bi translated"><a class="ae iu" href="#6188" rel="noopener ugc nofollow"> <strong class="jv hj"> <em class="lc">关于我们将要使用的数据和框架的简要描述。</em> </strong> </a></li><li id="0e10" class="lh li hi jv b jw lq ka lr jg ls jk lt jo lu kn lm ln lo lp bi translated"><a class="ae iu" href="#e8e0" rel="noopener ugc nofollow"> <strong class="jv hj"> <em class="lc">代码实现为单个类。</em></strong></a><strong class="jv hj"><em class="lc"><br/>a .</em></strong><a class="ae iu" href="#1a68" rel="noopener ugc nofollow"><strong class="jv hj">数据预处理管道</strong></a><strong class="jv hj"><br/>b .</strong><a class="ae iu" href="#d7c8" rel="noopener ugc nofollow"><strong class="jv hj">Dataloders管道</strong></a><strong class="jv hj"><br/>c .</strong><a class="ae iu" href="#d15b" rel="noopener ugc nofollow"><strong class="jv hj">分数管道</strong></a><strong class="jv hj"><br/>d .</strong><a class="ae iu" href="#652e" rel="noopener ugc nofollow"><strong class="jv hj"><em class="lc">培训</em></strong></a></li><li id="be56" class="lh li hi jv b jw lq ka lr jg ls jk lt jo lu kn lm ln lo lp bi translated"><a class="ae iu" href="#f693" rel="noopener ugc nofollow"> <strong class="jv hj"> <em class="lc">推论</em></strong>T5】</a></li></ol><h2 id="2f8a" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">语义图像分割综述</h2><p id="4b5c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">给定一幅灰度(H，W，1)或RGB(H，W，3)图像，我们希望生成一个与图像维数相同的分割掩码，它由从1到N的分类值组成(N是类的数量)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/774b1396a8a889520c097be75163a80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvNrmh8UWLi4v_JcIjSvIg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">输入图像到分割标签<a class="ae iu" href="http://self" rel="noopener ugc nofollow" target="_blank">信用</a></figcaption></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/049648118715399a948722a4b6ae8247.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*A7UX9Yj5xZSUj8aV7XXMnA.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">分类到一个热编码标签信用</figcaption></figure><p id="b59f" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">由分类值组成的语义标签也可以被热编码，如左图所示。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/754aadd25518ab87b5b935848aed0e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*7Gr1Z8_RiaWNcZxRDIUogA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">原始图像和语义标签的重叠</figcaption></figure><p id="27af" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在取argmax并与原始图像重叠后，我们将在左侧得到一个图像。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h2 id="6188" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">数据集和框架</h2><p id="eb63" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">我们将使用kaggle提供的<a class="ae iu" href="https://www.kaggle.com/c/carvana-image-masking-challenge" rel="noopener ugc nofollow" target="_blank"> carvana </a>数据集，它包含了大量的汽车图像。每辆车正好有16张照片，每张都是从不同的角度拍摄的。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/4295bc8dc3ab7402f4e0980bee246966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*hyRz8mX19cVnqBo8PzRW6w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">单车图像的16个方向</figcaption></figure><blockquote class="kz la lb"><p id="4c2e" class="jt ju lc jv b jw ko jy jz ka kp kc kd ld kq kf kg le kr ki kj lf ks kl km kn hb bi translated"><strong class="jv hj">文件描述</strong></p></blockquote><ul class=""><li id="d24f" class="lh li hi jv b jw ko ka kp jg mg jk mh jo mi kn mj ln lo lp bi translated">train —此文件夹包含训练集图像(。jpg) [1280，1918]</li><li id="e143" class="lh li hi jv b jw lq ka lr jg ls jk lt jo lu kn mj ln lo lp bi translated">测试—该文件夹包含测试集图像(jpg)[1280，1918]</li><li id="7036" class="lh li hi jv b jw lq ka lr jg ls jk lt jo lu kn mj ln lo lp bi translated">train_masks —此文件夹包含训练集掩码(。gif) [1280，1918]</li><li id="394f" class="lh li hi jv b jw lq ka lr jg ls jk lt jo lu kn mj ln lo lp bi translated">train_masks.csv —该文件提供了训练掩码的游程编码版本。</li><li id="d86b" class="lh li hi jv b jw lq ka lr jg ls jk lt jo lu kn mj ln lo lp bi translated">metadata.csv包含所有汽车的基本信息。</li></ul><p id="fde3" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">作为框架，我们将主要使用<strong class="jv hj"> Pytorch和sklearn </strong>(用于train/val分割)。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="e8e0" class="mk iw hi bd ix ml mm mn jb mo mp mq jf mr ms mt jj mu mv mw jn mx my mz jr na bi translated">单个类的实现</h1><p id="7e81" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">实施细分为4个管道</p><ol class=""><li id="4da3" class="lh li hi jv b jw ko ka kp jg mg jk mh jo mi kn lm ln lo lp bi translated"><strong class="jv hj">数据预处理管道- </strong>将train_mask图像从。gif到。png，然后我们将转换列车和列车掩码图像(。png)从它们的原始维度到新维度[128，128]。出于所有培训目的，我们将使用这128，128幅图像。</li><li id="484b" class="lh li hi jv b jw lq ka lr jg ls jk lt jo lu kn lm ln lo lp bi translated"><strong class="jv hj">数据加载器管道- </strong>这里我们将批量获取图像，对其应用变换&amp;，然后返回用于训练和验证阶段的数据加载器。</li><li id="30fc" class="lh li hi jv b jw lq ka lr jg ls jk lt jo lu kn lm ln lo lp bi translated"><strong class="jv hj">分数管道</strong>——计算所需分数的管道(在我们的例子中是kaggle提到的骰子分数)。</li><li id="e3dc" class="lh li hi jv b jw lq ka lr jg ls jk lt jo lu kn lm ln lo lp bi translated"><strong class="jv hj">训练管道</strong> -开始训练的最终管道，计算损失&amp;更新参数。</li></ol><blockquote class="kz la lb"><p id="28d9" class="jt ju lc jv b jw ko jy jz ka kp kc kd ld kq kf kg le kr ki kj lf ks kl km kn hb bi translated"><strong class="jv hj">入门！！！</strong></p></blockquote><p id="5958" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">对于这篇博客中的所有代码片段，我都尽量在需要的地方做了注释。我们将开始导入所有需要的库。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/65932e4c6c31e1bc96c131f006f58be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*vweUtJRhZMvjIMCuBzt4Fg.png"/></div></figure><p id="0519" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">我们将使用Unet架构，因为我们将使用由<a class="ae iu" href="https://github.com/qubvel/segmentation_models.pytorch" rel="noopener ugc nofollow" target="_blank">segmentation _ models . py torch</a>提供的高级API</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/d6f64361bfd4ef3da02b4fbb037662c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04AnDSOpbF3vSHzwHiKuRw.png"/></div></div></figure><p id="1e87" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">对于图像和遮罩增强，我们将使用由<a class="ae iu" href="https://github.com/albumentations-team/albumentations" rel="noopener ugc nofollow" target="_blank">albuminations</a>提供的API。</p><ol class=""><li id="1a68" class="lh li hi jv b jw ko ka kp jg mg jk mh jo mi kn lm ln lo lp bi translated"><strong class="jv hj">数据预处理流水线</strong></li></ol><p id="c7dc" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">首先，我们将转换火车面具从。gif到。png，然后我们将调整火车的大小，并将图像遮罩为[128，128]。这里我们将使用ThreadPoolExecutor进行并行操作。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">数据预处理</figcaption></figure><p id="38e6" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">现在，我们将在dataframe中加载train_masks.csv，以便获取图像名称。我不会使用这个csv中提供的训练掩码的游程编码版本，而是直接使用刚刚生成的掩码图像。</p><pre class="ku kv kw kx fd nf ng nh ni aw nj bi"><span id="1460" class="iv iw hi ng b fi nk nl l nm nn">df=pd.read_csv('/home/arun/Shashank/carvana/train_masks.csv')</span><span id="eec3" class="iv iw hi ng b fi no nl l nm nn"># location of original and mask image<br/>img_fol='/media/shashank/New Volume/carvana/train-128'<br/>mask_fol='/media/shashank/New Volume/carvana/train_masks-128'</span><span id="f537" class="iv iw hi ng b fi no nl l nm nn"># imagenet mean/std will be used as the resnet backbone is trained on imagenet stats<br/>mean, std=(0.485, 0.456, 0.406),(0.229, 0.224, 0.225)</span></pre><p id="b1d6" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">由于我们将使用在imagnet上训练的resnet后端，因此我们将设置imagenet数据的平均值和标准偏差以用于转换目的。</p><p id="d7c8" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">2.<strong class="jv hj">数据加载器管道</strong></p><p id="875d" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在本节中，我们将实现自定义转换、数据集和数据加载器。<br/>从取决于相位的变换开始，如果是“训练”,那么我们将使用水平翻转以及规格化和传感器。如果“val ”,那么我们将只使用Normalize和ToTensor。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">应用变换</figcaption></figure><p id="175d" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在转换之后，我们将创建一个名为CarDataset的自定义数据集类，在这里，我们使用dataloader中的索引id获取原始图像和遮罩，然后在其上应用转换。这个类的输出是形状的图像张量[3，128，128]和遮罩张量[1，128，128]。对于掩模张量，我们只有一个通道，因为我们只训练一个类。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es np"><img src="../Images/3c37efc5e4c891627df6fbdf648b65df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*O-c8FZSgQXKZ7kwbcqPdOw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">屏蔽单通道表示[1，128，128]。</figcaption></figure><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">自定义数据集</figcaption></figure><p id="473e" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">现在使用CarDataloader函数，我们将输入数据帧分成训练数据帧和有效数据帧(仅为了命名)。使用这些数据框架，我们创建用于训练和验证的数据加载器。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">数据加载器</figcaption></figure><p id="d15b" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated"><strong class="jv hj"> 3。分数管道</strong></p><p id="a204" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">为了解决类别不平衡的问题，我们使用<strong class="jv hj">软骰子得分</strong>而不是使用<strong class="jv hj">像素交叉熵损失</strong>。为了计算每个类别的SDS，我们乘以(预测分数*目标分数)并除以(预测分数+目标分数)的总和。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/357efd963a706e198455a4fe6917040d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZnbw2mmdFzBuA8JpDAKRQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://www.jeremyjordan.me/semantic-segmentation/" rel="noopener ugc nofollow" target="_blank">图像</a></figcaption></figure><p id="1585" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在所有批次的每个时期内，我们计算骰子点数并添加到一个空列表中。在时期结束时，我们计算骰子点数的平均值，其代表该特定时期的骰子点数。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="ac36" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在epoch结束时，我们使用epoch_log函数记录骰子值。</p><p id="652e" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated"><strong class="jv hj"> 4。培训渠道</strong></p><p id="1788" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在最后一个管道中，我们通过初始化大多数值来创建一个训练器类。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">培训师课程</figcaption></figure><p id="ca21" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在每个时期的<strong class="jv hj">开始方法</strong>中，我们将首先调用迭代方法进行训练，然后调用迭代方法进行验证&amp;，然后调用<strong class="jv hj">学习速率调度</strong>。如果当前验证损失小于前一个，则我们保存模型参数。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es nr"><img src="../Images/404bfe6b7755ff2f51696a3ffab58e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*5mZSMgGY1VX58k6SjeKK_w.png"/></div></figure><p id="750c" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在<strong class="jv hj">迭代方法</strong>中，我们调用向前方法来计算损耗，然后除以累加步长&amp;加到运行损耗上。同时，我们继续存储损耗梯度，直到loss.grad中的累积步骤。</p><p id="b0b7" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">之后，我们进行优化步骤，一旦达到累积步骤，就将梯度归零。最后，我们将有纪元损失，骰子得分&amp;将清除cuda缓存内存。</p><p id="a3c8" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">在正向方法中，我们将原始图像和目标遮罩发送到GPU，创建一个正向过程来获得预测遮罩。使用损失函数，我们计算损失。</p><h1 id="063a" class="mk iw hi bd ix ml ns mn jb mo nt mq jf mr nu mt jj mu nv mw jn mx nw mz jr na bi translated">从smp加载架构</h1><p id="600a" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">现在是从smp加载UNet架构的时候了，使用resnet18作为主干。对于类的数量，我们使用1作为我们的掩码维数是[1，128，128]。</p><pre class="ku kv kw kx fd nf ng nh ni aw nj bi"><span id="a57c" class="iv iw hi ng b fi nk nl l nm nn">model = smp.Unet("resnet18", encoder_weights="imagenet", classes=1, activation=None)</span></pre><p id="1e71" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">让魔法开始吧！！！！！！！！！！！！！！！</p><pre class="ku kv kw kx fd nf ng nh ni aw nj bi"><span id="f670" class="iv iw hi ng b fi nk nl l nm nn">model_trainer = Trainer(model)<br/>model_trainer.start()</span><span id="7267" class="iv iw hi ng b fi no nl l nm nn">Starting epoch: 0 | phase:train | 🙊':02:02:11<br/>Loss: 0.1084 |dice: 0.9460<br/>Starting epoch: 0 | phase:val | 🙊':02:02:48<br/>Loss: 0.0358 |dice: 0.9783<br/>******** New optimal found, saving state ********<br/><br/>Starting epoch: 1 | phase:train | 🙊':02:02:55<br/>Loss: 0.0288 |dice: 0.9800<br/>Starting epoch: 1 | phase:val | 🙊':02:03:29<br/>Loss: 0.0239 |dice: 0.9815<br/>******** New optimal found, saving state ********<br/><br/>Starting epoch: 2 | phase:train | 🙊':02:03:36<br/>Loss: 0.0205 |dice: 0.9836<br/>Starting epoch: 2 | phase:val | 🙊':02:04:11<br/>Loss: 0.0185 |dice: 0.9844<br/>******** New optimal found, saving state ********<br/><br/>Starting epoch: 3 | phase:train | 🙊':02:04:18<br/>Loss: 0.0172 |dice: 0.9854<br/>Starting epoch: 3 | phase:val | 🙊':02:04:53<br/>Loss: 0.0167 |dice: 0.9853<br/>******** New optimal found, saving state ********<br/><br/>Starting epoch: 4 | phase:train | 🙊':02:04:59<br/>Loss: 0.0155 |dice: 0.9863<br/>Starting epoch: 4 | phase:val | 🙊':02:05:34<br/>Loss: 0.0154 |dice: 0.9860<br/>******** New optimal found, saving state ********<br/><br/>Starting epoch: 5 | phase:train | 🙊':02:05:40<br/>Loss: 0.0149 |dice: 0.9864<br/>Starting epoch: 5 | phase:val | 🙊':02:06:14<br/>Loss: 0.0158 |dice: 0.9850<br/><br/>Starting epoch: 6 | phase:train | 🙊':02:06:20<br/>Loss: 0.0142 |dice: 0.9869<br/>Starting epoch: 6 | phase:val | 🙊':02:06:55<br/>Loss: 0.0158 |dice: 0.9848<br/><br/>Starting epoch: 7 | phase:train | 🙊':02:07:00<br/>Loss: 0.0132 |dice: 0.9877<br/>Starting epoch: 7 | phase:val | 🙊':02:07:35<br/>Loss: 0.0145 |dice: 0.9863<br/>******** New optimal found, saving state ********<br/><br/>Starting epoch: 8 | phase:train | 🙊':02:07:41<br/>Loss: 0.0127 |dice: 0.9881<br/>Starting epoch: 8 | phase:val | 🙊':02:08:15<br/>Loss: 0.0151 |dice: 0.9855<br/><br/>Starting epoch: 9 | phase:train | 🙊':02:08:21<br/>Loss: 0.0125 |dice: 0.9882<br/>Starting epoch: 9 | phase:val | 🙊':02:08:57<br/>Loss: 0.0136 |dice: 0.9869<br/>******** New optimal found, saving state ********</span></pre></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="f693" class="mk iw hi bd ix ml mm mn jb mo mp mq jf mr ms mt jj mu mv mw jn mx my mz jr na bi translated">推理</h1><p id="f6ee" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">在大约6分钟内，我们达到了令人印象深刻的98.7的骰子得分，使用节省下来的权重，我们将使用下面的片段对我们的验证数据进行推断。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es nx"><img src="../Images/8ed6b62efb0ae95ba03e962b82238033.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*YytZkprimk-pObE3bgiNcw.png"/></div></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ny"><img src="../Images/fbf5b32f7d5e6e40f6812818ed2c524e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*ggYZRe7u0sf5X49mlP6SKw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">左为预测遮罩，右为目标遮罩。</figcaption></figure><h1 id="ffa9" class="mk iw hi bd ix ml ns mn jb mo nt mq jf mr nu mt jj mu nv mw jn mx nw mz jr na bi translated"><strong class="ak">结论</strong></h1><p id="8e15" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">这可能不是SOTA的结果，但是通过使用仅仅200行代码，我们清楚地了解了语义分割是如何工作的。通过调整几行代码，可以对多类标签做同样的事情。请<strong class="jv hj">分享，如有评论请</strong>留下。</p></div></div>    
</body>
</html>