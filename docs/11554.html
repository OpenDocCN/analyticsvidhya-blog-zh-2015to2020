<html>
<head>
<title>Timing Morton code on Python on Apple Silicon</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">苹果芯片上Python的计时莫顿码</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/timing-morton-code-on-python-on-apple-silicon-767567094ed6?source=collection_archive---------11-----------------------#2020-12-08">https://medium.com/analytics-vidhya/timing-morton-code-on-python-on-apple-silicon-767567094ed6?source=collection_archive---------11-----------------------#2020-12-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a01ffa27b5e69b63ce8a635521e3a2d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JQXOF3PIc54h8Bifv_s1Zg.jpeg"/></div></div></figure><p id="92a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上周，我得到了我的新苹果硅Macbook Pro M1。我非常兴奋地做了一些非常简单的测试，看看python可以多快地计算出3D情况下的<a class="ae jo" href="https://en.wikipedia.org/wiki/Z-order_curve" rel="noopener ugc nofollow" target="_blank">莫顿代码</a>。我正在做的一个小项目需要这个，我在之前的一次迭代中发现这需要相当多的CPU时间。我之前的MacBook是13英寸，2.7GHz四核i7——2019年13英寸线的顶端；外面的承诺表明M1应该更快。让我们看看。</p><h1 id="b500" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="4e98" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">正如许多其他评论所显示的，M1 macbook是<em class="ks">快</em>。对于这个简单的任务，无论是使用纯python还是使用numpy，M1(本机)的速度至少是我的旧macbook的1.5倍，对于numpy 100的情况，这个数字提高到1.9倍。</p><p id="3d33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">都说了，我对<em class="ks">非常</em>印象深刻。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/cee8b264d6ba606489b6e516547341c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8eRw8TXIFE7Zy8YRHNIWw.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">如果以100、10k和1M为一批，计算1个莫顿码所需的纳秒数。使用Rosetta的速度似乎可以与我的旧英特尔macbook媲美。python和numpy的本机速度要快50%到90%。OpenCL的速度是否公平比较，我不知道……但它快了3倍多！</figcaption></figure></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="905c" class="jp jq hi bd jr js lj ju jv jw lk jy jz ka ll kc kd ke lm kg kh ki ln kk kl km bi translated">设置</h1><h2 id="5990" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">装置</h2><p id="f815" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">首先简单说一下安装的事情。M1机器可以运行ARM代码(本机)和Intel代码(通过Rosetta 2)。我认为苹果实际上在罗塞塔上做得很好；几乎所有的软件运行起来都很顺畅，速度也很快。然而为ARM安装东西要稍微复杂一点(因为许多包需要小的改动)。你已经可以看到在ARM上成功运行的(自制)包的日常改进。我不会在这里深入讨论我如何安装东西的细节(因为这些信息可能在下周就过时了)；然而，在这个实验中，我使用了homebrew的python 3.9.0(适用于M1英特尔和arm ),以及numpy 1.20rc1，它可以通过以下方式安装:</p><pre class="ku kv kw kx fd mc md me mf aw mg bi"><span id="ede3" class="lo jq hi md b fi mh mi l mj mk">pip install cython<br/>pip install --no-binary :all: --no-use-pep517 numpy==1.20rc1</span></pre><p id="3c09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，这将给你一个没有BLAS/LAPACK支持的numpy版本。我还试图在我的pyenv安装的python 3.8.5和numpy上从旧的intel-macbook上的一个轮子(包括BLAS/LAPACK)运行这个。有趣的是，在python 3.9.0安装中，纯python函数实际上要慢一些，而numpy代码则没有什么不同。</p><p id="2375" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装<code class="du ml mm mn md b">pyopencl</code>是从repo中完成的(对于arm ),因为目前只有<code class="du ml mm mn md b">master</code>生成arm兼容的代码。</p><pre class="ku kv kw kx fd mc md me mf aw mg bi"><span id="b769" class="lo jq hi md b fi mh mi l mj mk">pip install git+https://github.com/inducer/pyopencl</span></pre><p id="612d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果OpenCL让我们选择是在硬件上执行还是在虚拟处理器上执行，我们总是选择硬件。</p><h2 id="cd0d" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">莫顿码</h2><p id="00be" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">莫顿码是一个你通过交织比特组合2个(或更多)其他数得到的数。如果你有2个数字，它们的位是<code class="du ml mm mn md b">ABCDEFGH</code>和<code class="du ml mm mn md b">abcdefgh</code>，那么莫顿码就是<code class="du ml mm mn md b">AaBbCcDdEeFfGgHh</code>。对于3个数字，思路是一样的:<code class="du ml mm mn md b">Aa<em class="ks">A</em>Bb<em class="ks">B</em>Cc<em class="ks">C</em>Dd<em class="ks">D</em>Ee<em class="ks">E</em>Ff<em class="ks">F</em>Hh<em class="ks">H</em></code>，如果第三个数字是<code class="du ml mm mn md b"><em class="ks">ABCDEFGH</em></code>。</p><p id="f56a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计算莫顿码显然可以一点一点地完成(如下面的<code class="du ml mm mn md b">python_morton_naive</code>方法中所做的)。然而，有一些更快的方法可以做到这一点；幻数如何工作超出了这篇文章的范围——我认为这篇stackoverflow文章做得很好。然而，应该提到的是，这个计算并不简单。</p><h2 id="fb59" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">代码</h2><p id="29c7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们首先设置一些不同大小的数组，每个元素有3个整数(这3个整数我们将要合并)。(注意:在这篇文章的底部有完整的代码(带高光)</p><pre class="ku kv kw kx fd mc md me mf aw mg bi"><span id="9d17" class="lo jq hi md b fi mh mi l mj mk">import numpy as np</span><span id="eb8a" class="lo jq hi md b fi mo mi l mj mk">def setup(count):<br/>    return np.arange(3 * count, dtype="uint32").reshape((-1, 3)) &amp; 0x3FF</span><span id="aa6d" class="lo jq hi md b fi mo mi l mj mk">np_setup_e2 = setup(100)<br/>np_setup_e4 = setup(10000)<br/>np_setup_e6 = setup(1000000)<br/>np_setup_e7 = setup(10000000)<br/>np_setup_e8 = setup(100000000)</span><span id="45d6" class="lo jq hi md b fi mo mi l mj mk">setup_e2 = np_setup_e2.tolist()<br/>setup_e4 = np_setup_e4.tolist()<br/>setup_e6 = np_setup_e6.tolist()</span></pre><p id="7a3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在pure python中使用了两种方法来得到结果。首先，天真的一个:</p><pre class="ku kv kw kx fd mc md me mf aw mg bi"><span id="316b" class="lo jq hi md b fi mh mi l mj mk">def python_morton_naive(numbers):<br/>    result = []<br/>    for triplet in numbers:<br/>        r = 0<br/>        for i in range(30):<br/>            b, e = divmod(i, 3)<br/>            r |= ((triplet[e] &gt;&gt; b) &amp; 0b1) &lt;&lt; i<br/>        result.append(r)<br/>    return result</span></pre><p id="4f88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有一个是带魔法数字的</p><pre class="ku kv kw kx fd mc md me mf aw mg bi"><span id="2fa2" class="lo jq hi md b fi mh mi l mj mk">def python_morton(numbers):<br/>    result = []<br/>    for (x, y, z) in numbers:<br/>        x = (x | (x &lt;&lt; 16)) &amp; 0x030000FF<br/>        x = (x | (x &lt;&lt;  8)) &amp; 0x0300F00F<br/>        x = (x | (x &lt;&lt;  4)) &amp; 0x030C30C3<br/>        x = (x | (x &lt;&lt;  2)) &amp; 0x09249249<br/>        y = (y | (y &lt;&lt; 16)) &amp; 0x030000FF<br/>        y = (y | (y &lt;&lt;  8)) &amp; 0x0300F00F<br/>        y = (y | (y &lt;&lt;  4)) &amp; 0x030C30C3<br/>        y = (y | (y &lt;&lt;  2)) &amp; 0x09249249<br/>        z = (z | (z &lt;&lt; 16)) &amp; 0x030000FF<br/>        z = (z | (z &lt;&lt;  8)) &amp; 0x0300F00F<br/>        z = (z | (z &lt;&lt;  4)) &amp; 0x030C30C3<br/>        z = (z | (z &lt;&lt;  2)) &amp; 0x09249249<br/>        result.append(x | (y &lt;&lt; 1) | (z &lt;&lt; 2))<br/>    return result</span></pre><p id="1a7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">numpy方法</p><pre class="ku kv kw kx fd mc md me mf aw mg bi"><span id="80a4" class="lo jq hi md b fi mh mi l mj mk">def np_morton(x):<br/>    x = (x | (x &lt;&lt; 16)) &amp; 0x030000FF<br/>    x = (x | (x &lt;&lt;  8)) &amp; 0x0300F00F<br/>    x = (x | (x &lt;&lt;  4)) &amp; 0x030C30C3<br/>    x = (x | (x &lt;&lt;  2)) &amp; 0x09249249<br/>    x = x &lt;&lt; np.arange(3)<br/>    return np.bitwise_or.reduce(x, axis=1)</span></pre><p id="a9b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后是opencl方法</p><pre class="ku kv kw kx fd mc md me mf aw mg bi"><span id="95f4" class="lo jq hi md b fi mh mi l mj mk">ctx = cl.create_some_context()<br/>queue = cl.CommandQueue(ctx)</span><span id="b4f1" class="lo jq hi md b fi mo mi l mj mk">prg = cl.Program(ctx, """<br/>__kernel void sum(<br/>    __global const uint *numbers, __global uint *res_g)<br/>{<br/>  int gid = get_global_id(0);<br/>  uint res = 0;<br/>  for (int i = 0; i &lt; 3; i++) {<br/>    uint x = numbers[3 * gid + i];<br/>    x = (x | (x &lt;&lt; 16)) &amp; 0x030000FF;<br/>    x = (x | (x &lt;&lt;  8)) &amp; 0x0300F00F;<br/>    x = (x | (x &lt;&lt;  4)) &amp; 0x030C30C3;<br/>    x = (x | (x &lt;&lt;  2)) &amp; 0x09249249;<br/>    res |= x &lt;&lt; i;<br/>    }<br/>  res_g[gid] = res;<br/>}<br/>""").build()</span><span id="92b5" class="lo jq hi md b fi mo mi l mj mk">def cl_morton(numbers):<br/>    mf = cl.mem_flags<br/>    cl_numbers = cl.Buffer(ctx, mf.READ_ONLY | mf.COPY_HOST_PTR, hostbuf=numbers)<br/>    res_np = np.empty(numbers.shape[:1], dtype="uint32")<br/>    res_g = cl.Buffer(ctx, mf.WRITE_ONLY, res_np.nbytes)<br/>    prg.sum(queue, res_np.shape, None, cl_numbers, res_g)<br/>    cl.enqueue_copy(queue, res_np, res_g)<br/>    return res_np</span></pre><p id="fc19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，我并没有试图单独地完全优化这些方法——每种方法可能会减少几个百分点(或者更多)。这些方法之间的比较仅适用于“magintude级”。</p><p id="adb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行测试(仅复制一行，完整列表见下文):</p><pre class="ku kv kw kx fd mc md me mf aw mg bi"><span id="b4c0" class="lo jq hi md b fi mh mi l mj mk">print(round(timeit.timeit(lambda: python_morton(setup_e2), number=10000) / 100 / 10000 * 1000000 * 1000, 1))<br/>....</span></pre><p id="188d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，我们每个测试运行两次，并且只查看第二个结果。这是因为我确实看到了第一次和第二次运行之间相当大的差异，我认为这与第二次测试开始时内存被“放置”有关。因此，从第二次测试中获取结果似乎是最公平的。</p><h1 id="d529" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结果</h1><p id="4047" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在计时的时候，我喜欢先了解一下我能期望的理论上的最大值。在这种情况下，让我们看看神奇的数字代码。计算单个莫顿码，这要做3 *(4 *(shift+or+and)+shift+or)= 50次左右的运算。假设我们有一个5GHz的处理器，这意味着我们应该能够在一秒钟内完成100兆次，或每代码10纳秒(注意:这是在做许多假设——处理器在每个时钟周期内不能完成1次操作，但它适用于数量级计算)。显然，一旦python参与进来，事情就会变得慢得多(通常大约是100倍)，让我们达到每个数字1000纳秒(或每秒1米)。</p><p id="a28b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们看看结果。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">所有计时都以纳秒为单位，每1莫顿代码计算一次</figcaption></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/cee8b264d6ba606489b6e516547341c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8eRw8TXIFE7Zy8YRHNIWw.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">计算1个莫顿码所需的纳秒数。</figcaption></figure><p id="81e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们看到结果或多或少是我们所期望的。我们的简单解决方案是最慢的，python magic numbers需要1000到2000纳秒(我们估计大约需要1000纳秒)，而numpy解决方案需要10到40纳秒(事实上，在numpy中更大的批处理实际上需要更长的时间，这可能是因为分配大量内存需要更长的时间——我们可以通过重用内存来加快速度)。</p><p id="5174" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OpenCL的启动成本相对较高(可能是为了复制内存)，但之后会快得多。这很可能是因为OpenCL将工作分布在多个GPU核心上(所以在这种情况下2 <em class="ks"> ns </em>并不意味着计算一个代码需要2ns，只是它每秒可以做500M)。旧的英特尔macbook无法在100M代码上运行OpenCL我猜是因为它们不适合GPU内存。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h2 id="8aaf" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">比较</h2><p id="614b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">至于系统之间的对比。正如之前多次提到的，苹果发布了苹果芯片，做了两件了不起的事情。首先，他们生产了一种速度更快的芯片(使用更少的电力——我的旧macbook在这些测试中经常打开风扇，而M1从来没有)，他们创造了Rosetta 2，允许英特尔程序在这种芯片上无缝运行。</p><p id="a27b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这些测试中，运行x86_64 Python和x86_64 Numpy的M1运行代码的速度通常比我的旧Core i7快0%到50%。当我们将旧的i7与M1的running ARM原生python和numpy进行比较时，加速在50%到90%之间(因此在某些情况下几乎是<em class="ks">的两倍快</em>)。</p><p id="46f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OpenCL的差异更加令人印象深刻。有了罗塞塔，M1的速度是i7的两倍；ARM原生，甚至快三倍。现在，关于OpenCL测试的方式，我们可以说很多——例如，复制内存似乎仍然浪费了很多时间，我们可以调整一些设置，因此加速可能在很大程度上取决于确切的工作负载。这可能是另一篇文章的好主题。</p><p id="f6a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们使用Metal而不是OpenCl，看看事情是否真的变得更快也是很有趣的。这也可能是下一篇文章的主题。</p><h2 id="cffe" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">完整代码</h2><p id="0640" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">下面是我用的全部代码。我很乐意听到别人的结果！</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure></div></div>    
</body>
</html>