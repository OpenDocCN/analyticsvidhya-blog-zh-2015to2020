<html>
<head>
<title>Throttling Requests With Django Rest Framework For Different HTTP Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Django Rest框架为不同的HTTP方法节流请求</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/throttling-requests-with-django-rest-framework-for-different-http-methods-3ab0461044c?source=collection_archive---------2-----------------------#2020-04-25">https://medium.com/analytics-vidhya/throttling-requests-with-django-rest-framework-for-different-http-methods-3ab0461044c?source=collection_archive---------2-----------------------#2020-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/cc9ebe8a7fb564d6ef23c6a2db32a32b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*N5Iep1wJY1iXgMzpHxzE8w.png"/></div></figure><h1 id="f992" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">前言</h1><p id="5349" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">最近我在做一个项目，在这个项目中，我有一个支持<code class="du ki kj kk kl b">Get</code>和<code class="du ki kj kk kl b">POST</code>方法的单一端点来创建和检索数据。我想对<code class="du ki kj kk kl b">GET</code>请求设置一个比<code class="du ki kj kk kl b">POST</code>请求更严格的限制策略，但是没有发现用Django Rest框架的API视图实现这一点的简单方法。在网上寻找简单的解决方案后，我发现没有，因此想在本文中分享我的解决方案。</p><p id="b0d7" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">出于本文的目的，让我们假设我们有一个用实现了<code class="du ki kj kk kl b">GET</code>和<code class="du ki kj kk kl b">POST</code>方法的视图</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="29a3" class="kz in hi kl b fi la lb l lc ld">class Book(APIView):<br/>    def post(self, request):<br/>        ...<br/>    <br/>    def get(self, request):<br/>        ...</span></pre><p id="e7d2" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">您可以通过定义<code class="du ki kj kk kl b">throttle_classes</code>参数来定义<code class="du ki kj kk kl b">Book</code> API视图将使用的节流类(决定何时节流请求的类)</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="ccd7" class="kz in hi kl b fi la lb l lc ld">class Book(APIView):<br/>    throttle_classes = [throttle_class_1, throttle_class_2, ...]</span></pre><p id="3488" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">在其核心，throttle类是一个实现<code class="du ki kj kk kl b">allow_request(self, request, view)</code>方法的类。如果<code class="du ki kj kk kl b">allow_request</code>返回<code class="du ki kj kk kl b">True</code>，则请求被允许。如果<code class="du ki kj kk kl b">False</code>，请求被抑制。</p><p id="c7cb" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">然而，定义<code class="du ki kj kk kl b">throttle_classes</code>参数使得这些throttle类应用于<code class="du ki kj kk kl b">Book</code>视图中的所有 HTTP方法。如果我们想对<code class="du ki kj kk kl b">GET</code>和<code class="du ki kj kk kl b">POST</code>方法以不同的速率限制请求，我们需要定义自定义类。要轻松做到这一点，让我们看看Django Rest框架是如何实现节流的。</p><h1 id="ee35" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">Django Rest框架节流内部</h1><p id="3593" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated"><strong class="jm hj">注意:</strong>这些实现细节适用于除<code class="du ki kj kk kl b">ScopedRateThrottle</code>之外的所有节流类。</p><p id="4d5a" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">要覆盖Django Rest框架节流类，您可以覆盖在<code class="du ki kj kk kl b">rest_framework.throttling</code>中定义的任何类。以匿名节流类的重写为例</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="f6dc" class="kz in hi kl b fi la lb l lc ld"><em class="le">from</em> rest_framework <em class="le">import</em> throttling</span><span id="eff3" class="kz in hi kl b fi lf lb l lc ld"><em class="le">class</em> PostAnonRateThrottle(throttling.AnonRateThrottle):<br/>    scope = 'post_anon'</span></pre><p id="b4fc" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">Django Rest框架节流类做的第一件事是获取节流率。</p><p id="084a" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated"><strong class="jm hj">注意:</strong>这个<em class="le"> Django Rest框架节流内部</em>部分中的其余代码块直接来自Django Rest框架，是您自己做的<strong class="jm hj">而不是</strong>需要自己实现的事情。这里显示它们只是为了解释“引擎盖下”发生了什么</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="1fb6" class="kz in hi kl b fi la lb l lc ld">THROTTLE_RATES = api_settings.DEFAULT_THROTTLE_RATES</span><span id="a2b3" class="kz in hi kl b fi lf lb l lc ld">if not getattr(self, 'rate', None):            <br/>    self.rate = self.get_rate()</span><span id="c3b1" class="kz in hi kl b fi lf lb l lc ld">...   <br/>def get_rate(self):<br/>    ...<br/>    try:            <br/>        return self.THROTTLE_RATES[self.scope]</span></pre><p id="229d" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">上面的代码块首先检查是否在节流类上设置了<code class="du ki kj kk kl b">rate</code>属性。如果是，则将其用作节流率。如果没有，它检查在<code class="du ki kj kk kl b">DEFAULT_THROTTLE_RATES</code>设置中为给定范围设置的默认节流率。</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="d28c" class="kz in hi kl b fi la lb l lc ld">REST_FRAMEWORK = {<br/>    ...<br/>    'DEFAULT_THROTTLE_RATES': {<br/>        '&lt;scope&gt;': '&lt;throttle limit&gt;',<br/>    }<br/>}</span></pre><p id="fca9" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">在Django Rest框架节流<a class="ae lg" href="https://www.django-rest-framework.org/api-guide/throttling/" rel="noopener ugc nofollow" target="_blank">文档</a>中可以看到可能的节流限制。</p><p id="5b08" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">在我们的例子中，我们将范围覆盖为<code class="du ki kj kk kl b">post_anon</code>。<code class="du ki kj kk kl b">AnonRateThrottle</code>和<code class="du ki kj kk kl b">UserRateThrottle</code>类分别带有默认的作用域<code class="du ki kj kk kl b">anon</code>和<code class="du ki kj kk kl b">user</code>。</p><p id="b5b7" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">接下来，我们应该了解Django Rest框架如何实现速率限制。它结合了<code class="du ki kj kk kl b">scope</code>和<code class="du ki kj kk kl b">identification</code>，其中标识要么是匿名用户的IP地址，要么是已验证用户的主要标识符。<code class="du ki kj kk kl b">scope</code>和<code class="du ki kj kk kl b">identification</code>的每个唯一组合被用作一个不同的请求集，被跟踪以进行过滤。</p><p id="a3b2" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">用于<code class="du ki kj kk kl b">AnonRateThrottle</code>类</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="e8f6" class="kz in hi kl b fi la lb l lc ld">def get_cache_key(self, request, view):        <br/>    if request.user.is_authenticated:            <br/>        return None       <br/>    return self.cache_format % { <br/>        'scope': self.scope,                  <br/>        'ident':   self.get_ident(request)        <br/>    }</span></pre><p id="68fa" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">而对于<code class="du ki kj kk kl b">UserRateThrottle</code>类</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="00e0" class="kz in hi kl b fi la lb l lc ld">def get_cache_key(self, request, view):        <br/>    if request.user.is_authenticated:            <br/>        ident = request.user.pk<br/>    else:<br/>        ident = self.get_ident(request) #Getting the IP Address      <br/>    return self.cache_format % { <br/>        'scope': self.scope,                  <br/>        'ident':   self.get_ident(request)        <br/>    }</span></pre><p id="7cc0" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">缓存关键字格式为</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="b88d" class="kz in hi kl b fi la lb l lc ld">cache_format = 'throttle_%(scope)s_%(ident)s'</span></pre><p id="c302" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">因此，我们可以看到缓存键是<code class="du ki kj kk kl b">scope</code>和用户身份的组合。</p><p id="1b86" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">对于<code class="du ki kj kk kl b">throttle_class</code>属性中的每个throttle类，Django rest框架调用<code class="du ki kj kk kl b">allow_request(self, request, view)</code>方法来确定请求是否被允许。如果任何节流类返回<code class="du ki kj kk kl b">False</code>，请求将被节流。</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="10fd" class="kz in hi kl b fi la lb l lc ld">def get_throttles(self):    <br/>    return [throttle() for throttle in self.throttle_classes]</span><span id="8560" class="kz in hi kl b fi lf lb l lc ld">def check_throttles(self, request):<br/>    for throttle in self.get_throttles(): <br/>        if not throttle.allow_request(request, self): <br/>            throttle_durations.append(throttle.wait())</span><span id="1f52" class="kz in hi kl b fi lf lb l lc ld">if throttle_durations:<br/>    ...<br/>    self.throttled(request, duration)</span></pre><p id="a172" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">如果<code class="du ki kj kk kl b">allow_request(self, request, view)</code>为给定的节流类返回<code class="du ki kj kk kl b">True</code>，则一个成功的请求被添加到缓存中。这个请求对象的关键是前面提到的范围和身份的组合，以及成功请求的时间戳数组的值。</p><p id="2530" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated"><code class="du ki kj kk kl b">allow_request</code>使用特定请求的给定速率和高速缓存键，查看高速缓存中记录的给定时间内发生的请求数。回想一下，它能够做到这一点是因为每个成功请求的时间戳都存储在缓存中。如果缓存请求的数量大于速率限制，请求将被抑制。</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="8bc1" class="kz in hi kl b fi la lb l lc ld">if len(self.history) &gt;= self.num_requests:<br/>    return self.throttle_failure()</span></pre><p id="3f35" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">因此，我们可以看到被节流的请求是<code class="du ki kj kk kl b">scope</code>、<code class="du ki kj kk kl b">identity</code>和<code class="du ki kj kk kl b">rate</code>的函数。知道了这一点，我们可以设计定制的节流类来保持我们的端点和不同的HTTP方法的节流分开。</p><h1 id="2c52" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">不同HTTP方法的自定义节流类</h1><p id="0e16" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">假设我们知道独立的节流计数是为用户和范围的每个不同组合创建的，那么我们可以为HTTP方法定义自定义节流类。</p><p id="a326" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">出于本示例的目的，让我们为用户创建不同的节流类，并为<code class="du ki kj kk kl b">GET</code>和<code class="du ki kj kk kl b">POST</code>创建匿名用户。这模拟了全尺寸应用程序的许多用例。</p><p id="ca10" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">为此，我们将覆盖<code class="du ki kj kk kl b">AnonRateThrottle</code>和<code class="du ki kj kk kl b">UserRateThrottle</code>类。只要将这些被覆盖的类导入到视图中，就可以将它们放在任何地方。</p><p id="ffcf" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">在重写类之前不要忘记导入<code class="du ki kj kk kl b">throttling</code></p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="d819" class="kz in hi kl b fi la lb l lc ld">from rest_framework import throttling</span></pre><h2 id="b3e4" class="kz in hi bd io lh li lj is lk ll lm iw jv ln lo ja jz lp lq je kd lr ls ji lt bi translated">匿名<code class="du ki kj kk kl b">POST</code>节流</h2><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="5983" class="kz in hi kl b fi la lb l lc ld"><em class="le">class</em> PostAnononymousRateThrottle(throttling.AnonRateThrottle):<br/>    scope = 'post_anon'<br/>    <em class="le">def</em> allow_request(self, request, view):<br/>        <em class="le">if</em> request.method == "GET":<br/>            <em class="le">return</em> True<br/>        <em class="le">return</em> super().allow_request(request, view)</span></pre><h2 id="0d81" class="kz in hi bd io lh li lj is lk ll lm iw jv ln lo ja jz lp lq je kd lr ls ji lt bi translated">匿名<code class="du ki kj kk kl b">GET</code>节流</h2><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="21b7" class="kz in hi kl b fi la lb l lc ld"><em class="le">class</em> GetAnononymousRateThrottle(throttling.AnonRateThrottle):<br/>    scope='get_anon'<br/>    <em class="le">def</em> allow_request(self, request, view):<br/>        <em class="le">if</em> request.method == "POST":<br/>            <em class="le">return</em> True<br/>        <em class="le">return</em> super().allow_request(request, view)</span></pre><h2 id="cd28" class="kz in hi bd io lh li lj is lk ll lm iw jv ln lo ja jz lp lq je kd lr ls ji lt bi translated">用户<code class="du ki kj kk kl b">POST</code>节流</h2><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="019a" class="kz in hi kl b fi la lb l lc ld"><em class="le">class</em> PostUserRateThrottle(throttling.UserRateThrottle):<br/>    scope = 'post_user'<br/>    <em class="le">def</em> allow_request(self, request, view):<br/>        <em class="le">if</em> request.method == "GET":<br/>            <em class="le">return</em> True<br/>        <em class="le">return</em> super().allow_request(request, view)</span></pre><h2 id="9314" class="kz in hi bd io lh li lj is lk ll lm iw jv ln lo ja jz lp lq je kd lr ls ji lt bi translated">用户<code class="du ki kj kk kl b">GET </code>节流</h2><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="c29b" class="kz in hi kl b fi la lb l lc ld"><em class="le">class</em> GetUserRateThrottle(throttling.UserRateThrottle):<br/>    scope = 'get_user'<br/>    <em class="le">def</em> allow_request(self, request, view):<br/>        <em class="le">if</em> request.method == "POST":<br/>            <em class="le">return</em> True<br/>        <em class="le">return</em> super().allow_request(request, view)</span></pre><p id="babb" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated"><strong class="jm hj">注意:</strong>虽然您可以重构以减少重复，但为了更清楚起见，我将它们留在了这里。</p><p id="f2ff" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">这些类的作用是覆盖这些速率节流阀的<code class="du ki kj kk kl b">allow_request</code>方法并设置一个唯一的<code class="du ki kj kk kl b">scope</code>。如果传入的请求不是该类正在节流的同一类型(例如<code class="du ki kj kk kl b">GET</code>节流器和<code class="du ki kj kk kl b">POST</code>请求)，则允许该请求(返回<code class="du ki kj kk kl b">True</code>)。如果HTTP方法类型匹配，这些方法将返回<code class="du ki kj kk kl b">allow_request(request, view)</code>的超类实现，以允许您利用所有Django Rest框架的节流内部！</p><p id="130f" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">现在，由于这些类中的每一个都有不同的作用域，并且我们知道单个请求是根据对应于作用域和标识组合的缓存键来限制的，我们知道这四个限制类将维护不同数量的传入请求进行限制。</p><p id="2035" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">因此，这些类别将能够以不同的速率独立抑制以下组合:</p><ul class=""><li id="e861" class="lu lv hi jm b jn km jr kn jv lw jz lx kd ly kh lz ma mb mc bi translated"><code class="du ki kj kk kl b">POST</code>认证用户请求</li><li id="598c" class="lu lv hi jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated"><code class="du ki kj kk kl b">POST</code>未认证用户请求</li><li id="3555" class="lu lv hi jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated"><code class="du ki kj kk kl b">GET</code>对经过身份验证的用户的请求</li><li id="26b4" class="lu lv hi jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated"><code class="du ki kj kk kl b">GET</code>对未经认证用户的请求</li></ul><p id="1b7c" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">利用这些限制类很简单，只需在您的<code class="du ki kj kk kl b">settings</code>文件中设置默认速率，并设置所需的速率限制</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="9427" class="kz in hi kl b fi la lb l lc ld">REST_FRAMEWORK = {<br/>    ...<br/>    'DEFAULT_THROTTLE_RATES': {<br/>        'post_anon': '3/minute',<br/>        'get_anon': '100/minute',<br/>        'post_user': '5/minute',<br/>        'get_user': '150/minute'<br/>    }<br/>}</span></pre><p id="78fd" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">并将它们作为节流类包含在您想要使用它们的任何视图中</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="e825" class="kz in hi kl b fi la lb l lc ld">class Book(APIView):</span><span id="27e2" class="kz in hi kl b fi lf lb l lc ld">    throttle_classes = [PostAnononymousRateThrottle,        GetAnononymousRateThrottle, PostUserRateThrottle, GetUserRateThrottle ]</span><span id="55a4" class="kz in hi kl b fi lf lb l lc ld">    def get(self, request):<br/>        ...</span><span id="8c22" class="kz in hi kl b fi lf lb l lc ld">    def post(self, request):<br/>        ...</span></pre><p id="c6b4" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">在您的<code class="du ki kj kk kl b">views.py</code>文件的<code class="du ki kj kk kl b">throttle_classes</code>中使用它们之前，不要忘记从您定义它们的任何文件中导入您的自定义速率限制类。</p><p id="429b" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">注意，您也可以直接在类本身中设置<code class="du ki kj kk kl b">rate</code>参数，以获得相同的效果</p><pre class="kr ks kt ku fd kv kl kw kx aw ky bi"><span id="acf2" class="kz in hi kl b fi la lb l lc ld"><em class="le">class</em> GetUserRateThrottle(throttling.UserRateThrottle):<br/>    scope = 'get_user'<br/>    rate = '150/minute'</span></pre><h1 id="bc19" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">结论</h1><p id="a51d" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">现在，<code class="du ki kj kk kl b">POST</code>和<code class="du ki kj kk kl b">GET</code>对<code class="du ki kj kk kl b">Book</code>资源的请求被独立调节。这允许您遵循标准的API设计，其中一个资源支持多个HTTP方法。在本例中，这意味着对<code class="du ki kj kk kl b">Book</code>端点的<code class="du ki kj kk kl b">GET</code>请求将返回图书，而<code class="du ki kj kk kl b">POST</code>请求将创建一个并保存到数据库中。</p><p id="8702" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">理解Django Rest框架节流的内部机制还允许您扩展这个概念，并为您的应用程序需要的任何用例创建您自己的自定义节流类。限制API的速率是防止资源过载的基础，如果在云基础设施上运行，还可以节省资金。</p><p id="48c9" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">如果你喜欢这篇文章和/或发现它有帮助，请一定要给它一些掌声！这是我写的第一篇，我很乐意回答任何问题。</p><p id="3071" class="pw-post-body-paragraph jk jl hi jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh hb bi translated">快乐大厦！</p><h1 id="b84a" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">有问题吗？想要更多吗？</h1><p id="df59" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">有任何问题或想要更多有趣的技术内容吗？在twitter @TheSeanRich上关注我，我会尽我所能提供帮助！</p></div></div>    
</body>
</html>