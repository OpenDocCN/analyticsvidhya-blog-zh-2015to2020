<html>
<head>
<title>Analyzing Disease Co-occurrence Using NetworkX, Gephi, and Node2Vec</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NetworkX、Gephi和Node2Vec分析疾病共现</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/analyzing-disease-co-occurrence-using-networkx-gephi-and-node2vec-53941da35a0f?source=collection_archive---------5-----------------------#2020-05-05">https://medium.com/analytics-vidhya/analyzing-disease-co-occurrence-using-networkx-gephi-and-node2vec-53941da35a0f?source=collection_archive---------5-----------------------#2020-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="584a" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">研究</h2><div class=""/><div class=""><h2 id="954e" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">分析ICU患者的电子健康记录(EHR)并开发机器学习模型</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es jg"><img src="../Images/967ce20ae24a9522c0d9e74fc9d874a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*a1NFLacLghoeVB4cS5ZdNg.jpeg"/></div></figure><p id="3945" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi kk translated">他的分析是一个项目的一部分，该项目专注于分析ICU患者的电子健康记录(EHR ),并开发用于疾病早期预测的机器学习模型。在本文中，我们展示了如何使用EHR记录创建疾病网络，并使用疾病网络的邻接矩阵或边列表生成网络嵌入。我们使用python、R、Gephi软件，Node2Vec、Networkx、K-means进行分析。我们使用Rstudio、Spyder和Jupyter Notebook作为IDE。</p><p id="e0ce" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kt">(由于node2vec的最新更新，2021年5月4日做了一些小改动)</em></p><h1 id="3e0b" class="ku kv hi bd kw kx ky kz la lb lc ld le ix lf iy lg ja lh jb li jd lj je lk ll bi translated">数据集的预览</h1><p id="fc92" class="pw-post-body-paragraph jo jp hi jq b jr lm is jt ju ln iv jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">原始数据包含2，710，672个患者就诊记录，其中包含3，933个独特的诊断。在这些观察结果中，有2，193，860行标有有效的icd10代码。</p><p id="abfc" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">IC D10(【https://icdcodelookup.com/icd-10/codes】)是国际疾病和相关健康问题统计分类(ICD)的第10版，是世界卫生组织(世卫组织)制定的医学分类清单，指明了疾病、体征和症状、异常发现、主诉、社会环境以及损伤或疾病的外部原因。</p><p id="061f" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这些代码是由医院工作人员、护士和编码员在患者住院期间或之后输入的，并且具有多种用途，例如用于文档编制和医疗保险索赔归档。</p><h1 id="49d4" class="ku kv hi bd kw kx ky kz la lb lc ld le ix lf iy lg ja lh jb li jd lj je lk ll bi translated">代码:</h1><h2 id="9e5e" class="ls kv hi bd kw lt lu lv la lw lx ly le jx lz ma lg kb mb mc li kf md me lk ho bi translated">第一阶段—准备数据:</h2><p id="01d8" class="pw-post-body-paragraph jo jp hi jq b jr lm is jt ju ln iv jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">首先，我们必须清理数据，并将表转换为示例边列表，如下所示(图1):</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mf"><img src="../Images/f72d28587f5e74ed2988320e4547bdcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*OWLccdWxsDqndE2a6DWDVg.png"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">图1 —示例边缘列表</figcaption></figure><p id="c7d2" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">“pid”是包含患者id的列，而“icd10”是包含代表疾病的代码的列。一个病人可能同时患有多种疾病。一名患者可能不止一次患同一种疾病。该表列出了每位患者从入院到再次入院，再到出院的所有疾病或状况。</p><h2 id="0b00" class="ls kv hi bd kw lt lu lv la lw lx ly le jx lz ma lg kb mb mc li kf md me lk ho bi translated">第二阶段—制作邻接矩阵:</h2><p id="43dc" class="pw-post-body-paragraph jo jp hi jq b jr lm is jt ju ln iv jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">邻接矩阵是一个正方形矩阵，用于显示一种疾病和所有其他疾病之间的潜在共存关系(甚至包括其自身)。由于样本边列表中存在821个唯一的icd10代码，我们期望821*821邻接矩阵。</p><p id="d25e" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面提供了这样做的代码:</p><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="fce6" class="ls kv hi ml b fi mp mq l mr ms"><strong class="ml hs"><em class="kt">```<br/>import pandas as pd</em></strong></span><span id="74ab" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">import os</em></strong></span><span id="07e3" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">import numpy as np</em></strong></span><span id="14cb" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">print (os.getcwd())</em></strong></span><span id="db40" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">os.chdir(‘Your File Location’)</em></strong></span><span id="35a9" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">print (os.getcwd())</em></strong></span><span id="e7e4" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">diag = pd.read_csv(‘pid_icd10.csv’)</em></strong></span><span id="114d" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">## create the matrix</em></strong></span><span id="8b70" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">matrix = pd.get_dummies(diag.set_index(‘pid’)[‘icd10’].astype(str)).max(level=0).sort_index()</em></strong></span><span id="7977" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">## transpose the matrix</em></strong></span><span id="b1ed" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">diag_matrix = np.asmatrix(matrix)</em></strong></span><span id="4c6b" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">diag_matrix_transpose = diag_matrix.transpose()</em></strong></span><span id="a3c8" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">## multiply the matrices</em></strong></span><span id="2ad3" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">final_matrix = diag_matrix_transpose.dot(diag_matrix)</em></strong></span><span id="42fc" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">network_table = pd.DataFrame(final_matrix)</em></strong></span><span id="9e40" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">## append index name</em></strong></span><span id="5795" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">icd10 = list(diag.icd10.unique())</em></strong></span><span id="f7f0" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">icd10.sort()</em></strong></span><span id="e80d" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">network_table.index = icd10</em></strong></span><span id="3626" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">network_table.columns = icd10<br/>```</em></strong></span></pre><p id="d270" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">运行代码后，我们得到了一个821*821的邻接矩阵(图2):</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mu"><img src="../Images/64851eb667b721a510373065ebfb03a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*Qq5VqXa51377CPKn3K4prA.png"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">图2 —邻接矩阵的局部视图</figcaption></figure><p id="1840" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此处，对角线元素表示数据集中疾病的流行率，即特定icd10代码被记录了多少次。非对角线元素E_xy表示R_x和C_y的同现，其中R_x是所有患者记录的第x行和第y列。例如，A09(传染性胃肠炎和结肠炎)和A04.7(艰难梭菌引起的小肠结肠炎)在数据集中的29例患者就诊中同时出现。</p><p id="5177" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">关于如何生成这种疾病网络的更多信息在本文中解释:<a class="ae lr" href="https://ieeexplore.ieee.org/document/8194838" rel="noopener ugc nofollow" target="_blank">https://ieeexplore.ieee.org/document/8194838</a>。</p><h2 id="95c9" class="ls kv hi bd kw lt lu lv la lw lx ly le jx lz ma lg kb mb mc li kf md me lk ho bi translated">第三阶段—生成Node2Vec特性:</h2><p id="84af" class="pw-post-body-paragraph jo jp hi jq b jr lm is jt ju ln iv jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">在这一步，我们应用node 2 vec(【https://cs.stanford.edu/~jure/pubs/node2vec-kdd16.pdf】)来生成节点嵌入。网络是使用我们在上一步中生成的邻接矩阵创建的。这个函数将允许我们获得两个重要的输出:一个数据集包含用于绘图目的的随机行走记录，以及一个预测疾病邻居的模型。</p><p id="1b07" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">代码如下所示(确保您安装了Gensim 4.0.0或更高版本):</p><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="6f57" class="ls kv hi ml b fi mp mq l mr ms"><strong class="ml hs"><em class="kt">```<br/>import networkx as nx</em></strong></span><span id="4020" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">from node2vec import Node2Vec<br/></em></strong></span><span id="18b2" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">graph=nx.from_pandas_adjancecy(network_table)</em></strong></span><span id="6d0a" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">node2vec = Node2Vec(graph, dimensions=20, walk_length=5, num_walks=200, workers=4)</em></strong></span><span id="dbde" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">model = node2vec.fit(window=10, min_count=1)<br/>```</em></strong></span></pre><p id="0345" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">数据集的输出如下所示(图3):</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es jg"><img src="../Images/256412d7c7e7eb910efc3c43627db6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*HTrEYxEIqnM9cQHtof0hBg.png"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">图3—node 2 vec的输出</figcaption></figure><p id="0655" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该模型可用于找到特定节点(疾病)的邻居或维度值。它还可以帮助发现节点之间的相似性。下面是它的用法示例(图4、图5):</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es jg"><img src="../Images/94855c0eb434a11744173edde9c2b73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*1w22nJFULXd18gDYqkfOww.png"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">图4 —读取特定节点的值</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es jg"><img src="../Images/0608ddc2cad5c999f81874e0d016c8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*-xgXsAqyCDdooy0tv0DHfw.png"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">图5 —查找节点的相似性</figcaption></figure><p id="c0aa" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要将嵌入保存到CSV文件:</p><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="3510" class="ls kv hi ml b fi mp mq l mr ms"><strong class="ml hs"><em class="kt">```<br/></em></strong>vocab, vectors = model.wv.vocab, model.wv.vectors</span><span id="54b6" class="ls kv hi ml b fi mt mq l mr ms"># get node name and embedding vector index.<br/>#index<br/>name_index = np.array([(v[0], v[1].index) for v in vocab.items()])</span><span id="fa48" class="ls kv hi ml b fi mt mq l mr ms"># init dataframe using embedding vectors and set index as node name<br/>node2vec_output = pd.DataFrame(vectors[name_index[:,1].astype(int)])<br/>node2vec_output.index = name_index[:,0]</span><span id="5150" class="ls kv hi ml b fi mt mq l mr ms"><strong class="ml hs"><em class="kt">```</em></strong></span></pre><p id="ed94" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hs">参数说明:</strong></p><p id="c31b" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kt">“图形”必须是“网络x”图形。节点名必须全部是整数或字符串。</em></p><p id="474f" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kt">正如论文《node2vec:网络的可扩展特征学习》中提到的:“一旦表示的维度达到100左右，性能就会趋于饱和。”尽管维度的默认值是128，我们还是决定使用20。考虑到我们拥有的节点数量，它应该足够大。</em></p><p id="ddb4" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kt">walk _ length的默认值是80，它表示每次遍历中的节点数。num_walks是每个节点的行走次数，默认值为10。根据该论文，这两个参数将随着增加而提高性能。</em></p><h2 id="0dbe" class="ls kv hi bd kw lt lu lv la lw lx ly le jx lz ma lg kb mb mc li kf md me lk ho bi translated">第四阶段——在R中使用K-均值聚类绘制:</h2><p id="79f0" class="pw-post-body-paragraph jo jp hi jq b jr lm is jt ju ln iv jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">由于使用k-means对特征表示进行聚类(Grover &amp; Leskovec，2016)，我们可以使用k-means聚类算法将上一步的输出作为输入，并将结果绘制在r中。</p><p id="941a" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，我运行了一个快速循环，根据平方和(WSS)寻找“k”的选择。图6是输出结果:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mv"><img src="../Images/7f2263d4f80b379a67f0e952b6daefc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*_xpuvCRsF7A1Ns_T9mqTwA.png"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">图6 — WSS随着“k”的增加而减小</figcaption></figure><p id="8284" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看起来“k”越大，模型的表现就越好。然而，肘方法在这种情况下不起作用，因为我在图中看不到明显的肘曲线。大概，“k=8”会是一个好的开始。然而，当我们试图绘制集群时，我们发现输出有点混乱，因为节点的数量很大(图7):</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mw"><img src="../Images/68f1af07667722a6d6cdd811e1646776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*DUOWtlFLfERHJS8wcli4uA.png"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">图7——当“k=8”时的聚类图</figcaption></figure><p id="30fa" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我决定用“k=4”来代替。图8是输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mx"><img src="../Images/d08ae903cf96cf7b19569ba0580812d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*Ko-kU-hrWFeobqvlq83D5Q.png"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">图8——当“k=4”时的聚类图</figcaption></figure><p id="80d0" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于Gephi是绘制网络关系的优秀工具，所以我也用Gephi绘制了结果(图9 ),以供比较:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="er es my"><img src="../Images/ca3fdd0366a2a040567b6ada1d7aabfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zX6sr64bpgeTby0WEx1Alw.jpeg"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">图Gephi中的图</figcaption></figure><p id="52d2" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看起来Gephi自动将节点分配给了三个主要集群，这接近于我在r。</p><p id="2dd5" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">出于分析的目的，这次我将使用K-means聚类，因为该算法将使用组号来标记节点，这样更容易分析。</p><h2 id="f09a" class="ls kv hi bd kw lt lu lv la lw lx ly le jx lz ma lg kb mb mc li kf md me lk ho bi translated">第五阶段—推论:</h2><p id="9c63" class="pw-post-body-paragraph jo jp hi jq b jr lm is jt ju ln iv jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">为了分析结果，我运行了一个循环来对集群进行二次抽样。然后，我得了四组疾病:</p><p id="ff78" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hs">第1组</strong>包括与各种烧伤/外伤、手术导致的呼吸衰竭、神经问题和传染病相关的诊断。(总共40个唯一诊断字符串。)</p><p id="df0a" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hs">第2组</strong>包含与胃肠问题、神经问题和传染病相关的诊断。(总共45个独特的诊断字符串。)</p><p id="f162" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hs">第3组</strong>包含主要与毒理学和神经病学问题相关的诊断。看起来记录中出现了许多药物过量的问题。(总共26个独特的诊断字符串。)</p><p id="9828" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hs">第4组</strong>包含主要与心血管问题、移植情况和手术并发症相关的诊断。(总共16个独特的诊断字符串。)</p><p id="9311" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另外，通过查看图8，我们可以看出组2和组4彼此非常接近。组3和组4也重叠。</p><h1 id="4b48" class="ku kv hi bd kw kx ky kz la lb lc ld le ix lf iy lg ja lh jb li jd lj je lk ll bi translated">总结:</h1><p id="6482" class="pw-post-body-paragraph jo jp hi jq b jr lm is jt ju ln iv jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">使用node2vec包解析数据并使用k-means进行绘图是揭示深藏在具有网络关系的数据中的洞察力的极好方法。该模型有可能帮助我们在入院时发现每种疾病的邻居(可能的共存疾病)。它可以帮助医生和高费用患者在未来节省大量的时间和金钱。</p><p id="0a3c" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这篇博客中，我介绍了如何使用网络科学分析电子医疗记录，特别是为了了解病人就诊时疾病的共现。这种探索性的分析有助于开发初步的推论以及更深入分析的起点。使用我们的分析获得的见解不仅对医疗保健专业人员有用，而且对分析大型EHR数据集感兴趣的数据科学家也可以使用所示的方法。</p><blockquote class="nd ne nf"><p id="8e63" class="jo jp kt jq b jr js is jt ju jv iv jw ng jy jz ka nh kc kd ke ni kg kh ki kj hb bi translated">我在堪萨斯大学商学院商业分析助理教授Karthik Srinivasan博士的指导下完成了这篇博客。</p><p id="5b08" class="jo jp kt jq b jr js is jt ju jv iv jw ng jy jz ka nh kc kd ke ni kg kh ki kj hb bi translated">作为参考，你可以在这里找到所有的Python/R代码<a class="ae lr" href="https://github.com/KarAnalytics/DisNet/" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><p id="7f18" class="pw-post-body-paragraph jo jp hi jq b jr js is jt ju jv iv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hs"> <em class="kt">请随时与我联系</em></strong><a class="ae lr" href="https://www.linkedin.com/in/jinhangjiang/" rel="noopener ugc nofollow" target="_blank"><strong class="jq hs"><em class="kt">LinkedIn</em></strong></a><strong class="jq hs"><em class="kt">。</em> </strong></p></div></div>    
</body>
</html>