<html>
<head>
<title>JavaScript’s ‘this’ keyword ( strict, bind(), call(), apply() )</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的“this”关键字(strict，bind()，call()，apply())</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/javascripts-this-keyword-strict-bind-call-apply-79fc35039832?source=collection_archive---------16-----------------------#2020-11-09">https://medium.com/analytics-vidhya/javascripts-this-keyword-strict-bind-call-apply-79fc35039832?source=collection_archive---------16-----------------------#2020-11-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/88b196a9cb3b4521e0f4468ab87f9bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V4nQrn0jKXjAX5Hm.jpeg"/></div></figure><p id="bd3f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与其他OOP语言不同，<code class="du jk jl jm jn b">this</code>关键字的行为不同。它的<code class="du jk jl jm jn b">strict mode</code>和非严格模式的对应物也有区别。根据MDN上的定义，<code class="du jk jl jm jn b">this</code>在非严格模式下是指一个对象，在<code class="du jk jl jm jn b">strict mode</code>中可以是任意值。例如在Ruby中，每一行都是在对象内部执行的。你可以把Ruby中的<code class="du jk jl jm jn b">self</code>看作当前对象。因此，只要您显式调用另一个对象上的方法，该对象就会变成<code class="du jk jl jm jn b">self</code>。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="d4b2" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">全球:</strong></h1><p id="e1b3" class="pw-post-body-paragraph im in hi io b ip kt ir is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj hb bi translated">当在函数外部(全局上下文)调用<code class="du jk jl jm jn b">this</code>时，无论是在严格模式还是非严格模式下，它都引用全局对象。如下所示，我们在whodis()函数中调用了<code class="du jk jl jm jn b">this</code>，并返回了<code class="du jk jl jm jn b">window</code>对象。对于浏览器来说，全球环境是<code class="du jk jl jm jn b">window</code>。</p><p id="520e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用Node查看浏览器外部的全局上下文，我们可以看到返回的是<code class="du jk jl jm jn b">global</code>对象，而不是<code class="du jk jl jm jn b">window</code>对象。</p><p id="79c2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这与Ruby类似，如果我调出IRB并调用<code class="du jk jl jm jn b">self</code>，将返回关键字<code class="du jk jl jm jn b">main</code>。</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="da12" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">严格模式:</strong></h1><p id="c41d" class="pw-post-body-paragraph im in hi io b ip kt ir is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj hb bi translated">在严格模式下使用<code class="du jk jl jm jn b"><strong class="io hj">this</strong></code>会返回<code class="du jk jl jm jn b">undefined</code>。它提供了更好的安全性和错误检查。关于<code class="du jk jl jm jn b">strict mode</code>的警告是，如果<code class="du jk jl jm jn b">this</code>的值没有在执行上下文中声明，它将总是<code class="du jk jl jm jn b">undefined</code>。要启用<code class="du jk jl jm jn b">strict mode</code>,我们需要做的就是在函数顶部调用<code class="du jk jl jm jn b">'use strict'</code>。</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="a5ee" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">绑定、调用、应用:</h1><p id="bfaf" class="pw-post-body-paragraph im in hi io b ip kt ir is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj hb bi translated">有三种方法可用于显式设置对象上的<code class="du jk jl jm jn b">this</code>的值；<code class="du jk jl jm jn b">.bind()</code>、<code class="du jk jl jm jn b">.call()</code>和<code class="du jk jl jm jn b">.apply()</code>。当使用<code class="du jk jl jm jn b">.bind()</code>时，我们可以分别定义一个函数和一个对象，并告诉函数使用其他对象作为它的<code class="du jk jl jm jn b">this</code>值。这将产生一个新函数，其中<code class="du jk jl jm jn b">this</code>是显式的。然而，当使用<code class="du jk jl jm jn b">.call()</code>或<code class="du jk jl jm jn b">.apply()</code>时，你不需要创建一个全新的函数。这两种方法的工作方式非常相似——区别在于<code class="du jk jl jm jn b">.apply()</code>接受第二个参数(数组),而<code class="du jk jl jm jn b">.call()</code>可以传入任何额外的参数。</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="94fd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们看一下上面的代码，我们可以看到一些东西的声明。我们有一个函数<code class="du jk jl jm jn b">whodis()</code>，一个对象foo，和另一个函数fooBar。为了从我们的<code class="du jk jl jm jn b">whodis()</code>函数中获得这个值，我们必须首先调用whodis并追加<code class="du jk jl jm jn b">.call()</code>或<code class="du jk jl jm jn b">.apply()</code>并传入包含bar方法的对象的值。它保存表情符号的值，如第6行所示。<code class="du jk jl jm jn b">this</code>的值是传递给<code class="du jk jl jm jn b">.call()</code>和/或<code class="du jk jl jm jn b">.apply()</code>方法的第一个参数。一旦我们调用第14行或第15行，我们将返回值<code class="du jk jl jm jn b">this</code> →表情符号。这同样适用于<code class="du jk jl jm jn b">.bind()</code>方法。唯一不同的是我们必须创建一个新的函数对象。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="522c" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">总结:</h1><ul class=""><li id="bfbf" class="le lf hi io b ip kt it ku ix lg jb lh jf li jj lj lk ll lm bi translated">当调用对象上的方法时，<code class="du jk jl jm jn b">this</code>是拥有该方法的对象。</li><li id="8bc5" class="le lf hi io b ip ln it lo ix lp jb lq jf lr jj lj lk ll lm bi translated">全局对象由执行环境决定。在浏览器中，全局对象是<code class="du jk jl jm jn b">window</code>对象。在浏览器之外，全局对象是<code class="du jk jl jm jn b">global</code>。</li><li id="09a5" class="le lf hi io b ip ln it lo ix lp jb lq jf lr jj lj lk ll lm bi translated">而在严格模式下<code class="du jk jl jm jn b">this</code>是函数中的<code class="du jk jl jm jn b">undefined</code>。</li><li id="9f47" class="le lf hi io b ip ln it lo ix lp jb lq jf lr jj lj lk ll lm bi translated"><code class="du jk jl jm jn b">this</code>是作为第一个参数传递给<code class="du jk jl jm jn b">.call()</code>或<code class="du jk jl jm jn b">.apply()</code>或<code class="du jk jl jm jn b">bind()</code>方法的值。</li></ul><p id="e9be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">欲了解更多信息，请访问以下链接:</p><p id="681c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/enUS/docs/Web/JavaScript/Reference/Operators/this</a></p><p id="b586" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae ls" href="https://dmitripavlutin.com/gentle-explanation-of-this-in-javascript/" rel="noopener ugc nofollow" target="_blank">https://dmitripavlutin . com/gentle-explain-this-in-JavaScript/</a></p></div></div>    
</body>
</html>