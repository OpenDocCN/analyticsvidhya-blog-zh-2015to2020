<html>
<head>
<title>How to classify sounds using Pytorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Pytorch 对声音进行分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-classify-sounds-using-pytorch-27c9f2d4d714?source=collection_archive---------4-----------------------#2020-12-28">https://medium.com/analytics-vidhya/how-to-classify-sounds-using-pytorch-27c9f2d4d714?source=collection_archive---------4-----------------------#2020-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e358" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将讨论如何准备声音或音频数据集，以便我们能够对它们进行分类。它可能有点长，但如果你能保持耐心，通读一遍，这将是非常有益的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/ac09b22a9b2c26e99c2e075151c5184a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNN1HhUaGVgRYGNiLf0qsw.png"/></div></div></figure><ol class=""><li id="990f" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">首先我们将加载音频文件。从有 n 个声音文件的目录中，我们将首先使用<strong class="ih hj"> torchaudio.load </strong>加载其中的 2-3 个。torchaudio 支持“<strong class="ih hj">格式的声音文件。wav </strong>和<strong class="ih hj"> .mp3 </strong>，用于给出声音文件的波形和采样率。波形由数组格式的每帧声音的频率组成，而采样速率决定了可以表示波形的频率。</li></ol><pre class="je jf jg jh fd jy jz ka kb aw kc bi"><span id="b0a2" class="kd ke hi jz b fi kf kg l kh ki">import torchaudio<br/>waveform, sample_rate <strong class="jz hj">=</strong> torchaudio<strong class="jz hj">.</strong>load("_<strong class="jz hj">PATH OF THE AUDIO FILE</strong>_")</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/db11ccb58b4c96f87de94db5130e7a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7_GYH4Mf7I6aiY17wviwA.png"/></div></div></figure><p id="80fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果音频文件是其他格式，然后尝试谷歌提取出音频文件的波形，采样率。例如，如果你有。flac '音频文件你可以试试这个:→</p><pre class="je jf jg jh fd jy jz ka kb aw kc bi"><span id="0fd4" class="kd ke hi jz b fi kf kg l kh ki">import soundfile as sf<br/>waveform, sample_rate = sf.read("_<strong class="jz hj">PATH OF THE AUDIO FILE IN FLAC</strong>_")</span></pre><p id="058c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">将所有波形的形状标准化为一个尺寸</strong>。加载文件后，使用<strong class="ih hj"> waveform.size()[0] </strong>检查波形的形状。如果它的值大于 1，那么我们必须使用</p><pre class="je jf jg jh fd jy jz ka kb aw kc bi"><span id="f9f2" class="kd ke hi jz b fi kf kg l kh ki">from pydub import AudioSegment</span><span id="07da" class="kd ke hi jz b fi kj kg l kh ki">waveform = AudioSegment.from_mp3(_<strong class="jz hj">PATH OF THE AUDIO FILE</strong>_)<br/>waveform = waveform.set_channels(1)<br/>waveform = waveform.get_array_of_samples()<br/>waveform = torch.tensor(waveform, dtype = torch.float)<br/>waveform = torch.reshape(waveform, (1,waveform.shape[0]))</span></pre><p id="81fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj">将波形改为</strong> <strong class="ih hj">声谱图、梅尔声谱图或 MFCC 声谱图。</strong>现在我们将使用以下方法将波形转换成频谱图(<em class="kk">随着时间变化的信号频谱的直观表示</em></p><pre class="je jf jg jh fd jy jz ka kb aw kc bi"><span id="2198" class="kd ke hi jz b fi kf kg l kh ki">Spectrogram <strong class="jz hj">=</strong> torchaudio<strong class="jz hj">.</strong>transforms<strong class="jz hj">.</strong>Spectrogram()(waveform)</span></pre><p id="d5b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，梅尔声谱图(<em class="kk">声音的短期功率谱的表示，基于非线性</em> <strong class="ih hj"> <em class="kk">梅尔</em> </strong> <em class="kk">频率标度</em>上对数功率谱的线性余弦变换)使用</p><pre class="je jf jg jh fd jy jz ka kb aw kc bi"><span id="f1b9" class="kd ke hi jz b fi kf kg l kh ki">Mel_Spectrogram <strong class="jz hj">=</strong> torchaudio<strong class="jz hj">.</strong>transforms<strong class="jz hj">.</strong>MelSpectrogram()(waveform)</span></pre><p id="6116" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，MFCC( <em class="kk">梅尔频率倒谱系数(</em><strong class="ih hj"><em class="kk">MFCC</em></strong><em class="kk">)是共同构成梅尔频率倒谱的系数。梅尔频率倒谱是声音的短期功率谱的表示，基于对数功率谱在非线性梅尔频率标度上的线性余弦变换</em>，使用</p><pre class="je jf jg jh fd jy jz ka kb aw kc bi"><span id="ced6" class="kd ke hi jz b fi kf kg l kh ki">n_fft <strong class="jz hj">=</strong> 400.0<br/>frame_length <strong class="jz hj">=</strong> n_fft <strong class="jz hj">/</strong> sample_rate <strong class="jz hj">*</strong> 1000.0<br/>frame_shift <strong class="jz hj">=</strong> frame_length <strong class="jz hj">/</strong> 2.0<br/><br/>params <strong class="jz hj">=</strong> {<br/>    "channel": 0,<br/>    "dither": 0.0,<br/>    "window_type": "hanning",<br/>    "frame_length": frame_length,<br/>    "frame_shift": frame_shift,<br/>    "remove_dc_offset": <strong class="jz hj">False</strong>,<br/>    "round_to_power_of_two": <strong class="jz hj">False</strong>,<br/>    "sample_frequency": sample_rate,<br/>}<br/>mfcc <strong class="jz hj">=</strong> torchaudio<strong class="jz hj">.</strong>compliance<strong class="jz hj">.</strong>kaldi<strong class="jz hj">.</strong>mfcc(waveform, <strong class="jz hj">**</strong>params)</span></pre><p id="ec65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.<strong class="ih hj">最后，我们可以像这样使用以上 3 点创建数据集类</strong>。<em class="kk"># 1 #先定义数据集类名</em>。</p><pre class="je jf jg jh fd jy jz ka kb aw kc bi"><span id="c47a" class="kd ke hi jz b fi kf kg l kh ki">class <strong class="jz hj">audio_classification</strong>(<strong class="jz hj">torch.utils.data.Dataset</strong>):</span></pre><p id="a150" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kk"> #2#定义类构造函数来定义 audio _ ids，在列表中定义它们的分类 class _ ids，并对它们应用扩充</em></p><pre class="je jf jg jh fd jy jz ka kb aw kc bi"><span id="2704" class="kd ke hi jz b fi kf kg l kh ki">def __init__(self, ids, recording_id, class_id, required_columns, is_valid = 0):<br/>        self.ids = ids<br/>        self.audio_ids = audio_ids<br/>        self.class_id = class_id<br/>        self.required_columns = required_columns<br/>        self.is_valid = is_valid<br/>        if self.is_valid == 1:<br/>            self.aug = <em class="kk"># transfoms for validation images</em><br/>        else:                  <br/>            self.aug = <em class="kk"># transfoms for training images</em></span></pre><p id="49cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kk"> #3#定义 __len__ 函数</em></p><pre class="je jf jg jh fd jy jz ka kb aw kc bi"><span id="3c85" class="kd ke hi jz b fi kf kg l kh ki">def __len__(self):<br/>      return len(self.ids)</span></pre><p id="cdf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kk"> #4#最后定义 __getitem__ 函数</em></p><pre class="je jf jg jh fd jy jz ka kb aw kc bi"><span id="52e6" class="kd ke hi jz b fi kf kg l kh ki">def __getitem__(self, index):<br/>        filename = "<strong class="jz hj">__PATH OF THE AUDIO__</strong>"+ self.audio_ids[index] +"<strong class="jz hj">__EXTENSION OF THE AUDIO FILE__</strong>"</span><span id="571e" class="kd ke hi jz b fi kj kg l kh ki">        waveform , _ = torchaudio<strong class="jz hj">.</strong>load(filename)</span><span id="67ad" class="kd ke hi jz b fi kj kg l kh ki">        <strong class="jz hj"><em class="kk"># reshape to 1 channel if required</em></strong><br/>        waveform = torch.reshape(waveform, (1, waveform.shape[0]))</span><span id="aab8" class="kd ke hi jz b fi kj kg l kh ki">       <strong class="jz hj"><em class="kk"># Change the waveform to Spectrogram, Mel-Spectrogram or,MFCC</em></strong><br/>        specgram = torchaudio.transforms.Spectrogram()(waveform)<br/><br/>        <strong class="jz hj"><em class="kk"># convert 1 channel to 3 channels applying imagenet models</em></strong><br/>        specgram = specgram.repeat(3, 1, 1)<br/>        <br/>        <strong class="jz hj"><em class="kk"># Applying audio augmentations by converting to numpy array</em></strong><br/>        specgram = np.transpose(specgram.numpy(), (1,2,0))<br/>        specgram = self.aug(image = specgram)['image']<br/>        <br/>        <strong class="jz hj"><em class="kk">#As torch accepts channels first so applying this</em></strong><br/>        specgram = np.transpose(specgram,(2,0,1)).astype(np.float32)<br/>        <br/>        return {<br/>            '<strong class="jz hj"><em class="kk">specgram</em></strong>' : torch.tensor(specgram, dtype = torch.float) </span><span id="3b77" class="kd ke hi jz b fi kj kg l kh ki">            '<strong class="jz hj"><em class="kk">label</em></strong>' : torch.tensor(self.class_id[index], dtype = torch.float)<br/>        }</span></pre><p id="f4d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kk">完成所有这些步骤后，这将完全成为一个图像分类问题。在此之后，我们可以定义数据加载器、模型、损失函数、优化器和训练&amp;验证过程，并开始训练我们的模型，就像我们在图像分类问题中所做的那样。</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kl"><img src="../Images/8606073d503c5c1996ca51a60b1b33fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Dtdlry_6SZIU8EOk4rV-w.jpeg"/></div></div></figure><p id="0b90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你已经很好地理解了这篇文章，如果有任何与这篇文章相关的问题，请随时对这篇文章发表评论，直到那时享受学习。</p></div></div>    
</body>
</html>