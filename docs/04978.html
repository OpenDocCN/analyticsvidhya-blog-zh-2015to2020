<html>
<head>
<title>Analyzing NYC Taxi Open Data with GridDB and NodeJS | GridDB: Open Source Time Series Database for IoT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GridDB和NodeJS | GridDB分析纽约市出租车开放数据:面向物联网的开源时间序列数据库</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/analyzing-nyc-taxi-open-data-with-griddb-and-nodejs-griddb-open-source-time-series-database-for-86850008da5d?source=collection_archive---------46-----------------------#2020-04-06">https://medium.com/analytics-vidhya/analyzing-nyc-taxi-open-data-with-griddb-and-nodejs-griddb-open-source-time-series-database-for-86850008da5d?source=collection_archive---------46-----------------------#2020-04-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6abdf6a092ed690ab79a4c0787527534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U4szqX8DkVuOmeW8.jpg"/></div></div></figure><p id="9270" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博客中，我们将看看由<br/>纽约市出租车委员会提供的一些公开数据，并展示一些简单的脚本来摄取和分析数据。这里显示的原则<br/>适用于许多不同类型的问题。</p><p id="d0be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您还没有设置GridDB服务器，请遵循这个<a class="ae jo" href="https://griddb.net/en/blog/griddb-quickstart/" rel="noopener ugc nofollow" target="_blank">快速入门</a>。如果你需要为Node.js设置GridDB，这个<a class="ae jo" href="https://griddb.net/en/blog/nodejs-client/" rel="noopener ugc nofollow" target="_blank">博客</a>会帮你设置并运行。您可以在<a class="ae jo" href="https://data.cityofnewyork.us/Transportation/2018-Yellow-Taxi-Trip-Data/t29m-gskq" rel="noopener ugc nofollow" target="_blank">纽约市开放数据网站</a>上下载并找到关于纽约市出租车数据的更多详细信息。</p><h1 id="3830" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">数据模型</h1><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="840d" class="kw jq hi ks b fi kx ky l kz la">VendorID,tpep_pickup_datetime,tpep_dropoff_datetime,passenger_count,trip_distance,RatecodeID,store_and_fwd_flag,PULocationID,DOLocationID,payment_type,fare_amount,extra,mta_tax,tip_amount,tolls_amount,improvement_surcharge,total_amount<br/>2,03/13/2018 02:58:38 PM,03/13/2018 03:00:22 PM,1,0.31,1,N,132,132,2,3.5,0,0.5,0,0,0.3,4.3<br/>1,03/13/2018 02:34:11 PM,03/13/2018 02:40:35 PM,1,2.3,1,N,132,132,1,9,0,0.5,1.95,0,0.3,11.75<br/>1,03/13/2018 02:42:12 PM,03/13/2018 03:21:44 PM,1,17.5,2,N,132,230,1,52,0,0.5,5,5.76,0.3,63.56<br/>1,03/13/2018 02:36:05 PM,03/13/2018 03:04:08 PM,1,10.5,1,N,230,138,1,32.5,0,0.5,7.8,5.76,0.3,46.86<br/>1,03/13/2018 02:41:52 PM,03/13/2018 02:45:41 PM,1,0.7,1,N,264,264,2,5,0,0.5,0,0,0.3,5.8<br/>1,03/13/2018 02:47:40 PM,03/13/2018 02:55:06 PM,1,1.3,1,N,264,264,1,7,0,0.5,2,0,0.3,9.8<br/>1,03/13/2018 02:27:57 PM,03/13/2018 02:48:45 PM,1,4.8,1,N,142,13,1,18.5,0,0.5,3.85,0,0.3,23.15<br/>1,03/13/2018 02:03:27 PM,03/13/2018 02:10:51 PM,1,0.6,1,N,164,100,1,6,0,0.5,1.36,0,0.3,8.16<br/>1,03/13/2018 02:12:58 PM,03/13/2018 02:25:04 PM,1,1,1,N,100,230,2,8.5,0,0.5,0,0,0.3,9.3</span></pre><p id="d4d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">开放数据有17个字段，因此我们的第一个决定是确定如何将数据拆分到多个容器中。<br/>理想的方法是将来自每辆出租车的数据放入单独的容器中，但由于数据是匿名的，因此没有为每辆出租车提供唯一的<br/>标识符。下一个最好使用的字段是<br/> <code class="du lb lc ld ks b">PULocationID</code>，它是一个从1到265的整数，代表每个纽约<br/> MTA街区的唯一标识符。</p><p id="453f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于不同的出租车可能在完全相同的时间在完全相同的街区搭载乘客，<br/> <code class="du lb lc ld ks b">tpep_pickup_datetime</code>不是一个好的主键。取而代之的是，我们必须使用一个唯一的整数，它随着每一行的增加而递增。</p><p id="11c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还添加了几个计算字段:<code class="du lb lc ld ks b">hour_of_day</code>和<code class="du lb lc ld ks b">day_of_week</code>，它们将在出租车数据的<br/>分析中有用。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="143a" class="kw jq hi ks b fi kx ky l kz la">var colInfo = new griddb.ContainerInfo({<br/>    'name': "col"+data['PULocationID'],<br/>    'columnInfoList': [<br/>        ["id" , griddb.Type.LONG],<br/>        ["duration" , griddb.Type.INTEGER],<br/>        ["VendorID", griddb.Type.INTEGER ],<br/>        ["tpep_pickup_datetime", griddb.Type.TIMESTAMP ],<br/>        ["tpep_dropoff_datetime", griddb.Type.TIMESTAMP ],<br/>        ["passenger_count", griddb.Type.LONG],<br/>        ["store_and_fwd_flag" , griddb.Type.BOOL],<br/>        ["PULocationID", griddb.Type.INTEGER],<br/>        ["DOLocationID", griddb.Type.INTEGER],<br/>        ["payment_type", griddb.Type.INTEGER],<br/>        ["fare_amount", griddb.Type.FLOAT],<br/>        ["extra", griddb.Type.FLOAT],<br/>        ["mta_tax", griddb.Type.FLOAT],<br/>        ["tip_amount", griddb.Type.FLOAT],<br/>        ["tolls_aount", griddb.Type.FLOAT],<br/>        ["improvement_surcharge", griddb.Type.FLOAT],<br/>        ["total_amount", griddb.Type.FLOAT], <br/>        ["hour_of_day", griddb.Type.INTEGER], <br/>        ["day_of_week", griddb.Type.INTEGER]],<br/>   'type': griddb.ContainerType.COLLECTION, 'rowKey': true<br/>});</span></pre><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es le"><img src="../Images/43c5a0236892ffb19d3750ea75d6f517.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/0*qYzKp0KXuTIBN6xl.png"/></div></figure><h1 id="60e1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">摄取</h1><p id="a551" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">使用<a class="ae jo" href="https://www.npmjs.com/package/csv-parser" rel="noopener ugc nofollow" target="_blank"> csv解析器npm <br/>模块</a>，实际的摄取过程非常简单。数据从CSV解析器流出并由CSV解析器处理，然后我们将它转换成一个简单的数组，这个数组被<br/>放入适当的GridDB容器中。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="c57a" class="kw jq hi ks b fi kx ky l kz la">var griddb = require('griddb_node');<br/>var fs = require('fs');<br/>var csv = require('csv-parser')<br/><br/>let factory = griddb.StoreFactory.getInstance();<br/>let store = factory.getStore({<br/>    "host": '239.0.0.1',<br/>    "port": 31999,<br/>    "clusterName": "defaultCluster",<br/>    "username": "admin",<br/>    "password": "admin"<br/>});<br/><br/>let cols = {}<br/>let count=0<br/><br/>fs.createReadStream('data.csv')<br/>  .pipe(csv())<br/>  .on('data', (data) =&gt; {<br/>    let row = []<br/>    row[0] = count++;<br/>    row[1] = parseInt(Date.parse(data['tpep_dropoff_datetime'])-Date.parse(data['tpep_pickup_datetime']))/1000)<br/>    row[2] = parseInt(data['VendorID'], 10);<br/>    row[3] = Date.parse(data['tpep_pickup_datetime'])<br/>    row[4] = Date.parse(data['tpep_dropoff_datetime'])<br/>    row[5] = parseInt(data['passenger_count'], 10)<br/>    if(data['store_and_fwd_flag'] == 'Y')<br/>        row[6] = true<br/>    else<br/>        row[6] = false<br/>    row[7] = parseInt(data['PULocationID'])<br/>    row[8] = parseInt(data['DOLocationID'])<br/>    row[9] = parseInt(data['payment_type'])<br/>    row[10] = Number(data['fare_amount'])<br/>    row[11] = Number(data['extra'])<br/>    row[12] = Number(data['mta_tax'])<br/>    row[13] = Number(data['tip_amount'])<br/>    row[14] = Number(data['tolls_amount'])<br/>    row[15] = Number(data['improvement_surcharge'])<br/>    row[16] = Number(data['total_amount'])<br/>    let date = new Date(row[3])<br/>    row[17] = date.getHours()<br/>    row[18] = date.getDay()<br/><br/>    var colInfo = . . . snipped above . . .<br/>    store.putContainer(colInfo, false)<br/>        .then(cont =&gt; {<br/>            cont.put(row)<br/>            console.log(row[0])<br/>        })<br/>    .catch(err =&gt; {<br/>        if (err.constructor.name == "GSException") {<br/>            for (var i = 0; i &lt; err.getErrorStackSize(); i++) {<br/>                console.log("[", i, "]");<br/>                console.log(err.getErrorCode(i));<br/>                console.log(err.getMessage(i));<br/>            }<br/>        } else {<br/>            console.log(err);<br/>        }<br/>    });<br/><br/>});</span></pre><h1 id="ec31" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">分析</h1><p id="7ce7" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">有许多不同的查询可以产生有趣的结果；最长的一次旅行是什么？最贵的？哪个地区最繁忙？</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="85ed" class="kw jq hi ks b fi kx ky l kz la">// standard boilerplate<br/>var griddb = require('griddb_node');<br/>var fs = require('fs');<br/>var csv = require('csv-parser')<br/><br/>// our Cluster's credentials<br/>let factory = griddb.StoreFactory.getInstance();<br/>let store = factory.getStore({<br/>    "host": '239.0.0.1',<br/>    "port": 31999,<br/>    "clusterName": "defaultCluster",<br/>    "username": "admin",<br/>    "password": "admin"<br/>});<br/><br/>let promises = []<br/>let results = {}<br/><br/>var iterate = function(locID) {<br/>        return function(rowset) {<br/>            if(rowset != null) {<br/>                if (rowset.hasNext()) {<br/>                    row = rowset.next();<br/>                    results[locID] = row;<br/>                    // if result is an aggregation use this instead<br/>                    // results[locID] = row..get(griddb.GS_TYPE_LONG);<br/>                }<br/>        }<br/>    }<br/><br/>}<br/><br/>var query = function (locID) {<br/>    return function(cont) {<br/>        if(cont != null) {<br/>            q = cont.query("SELECT * ORDER BY fare_amount DESC LIMIT 1 ");<br/>            return q.fetch()<br/>        }<br/>    }<br/>}<br/><br/>for (let i=0; i &lt; 100; i++) {<br/>    var locID = i<br/>    promise = store.getContainer("col"+i)<br/>    .then(query(i))<br/>    .then(iterate(i))<br/>    .catch(err =&gt; {<br/>        if (err.constructor.name == "GSException") {<br/>            for (var i = 0; i &lt; err.getErrorStackSize(); i++) {<br/>                console.log("[", i, "]");<br/>                console.log(err.getErrorCode(i));<br/>                console.log(err.getMessage(i));<br/>            }<br/>        } else {<br/>            console.log(err);<br/>        }<br/>    })<br/>    promises.push(promise)<br/>}<br/><br/>Promise.all(promises).then(values =&gt; {<br/><br/>    var retval=null;<br/>    console.log("sorting...")<br/>    for (var k in results) {<br/>        if (retval == null || results[k][10] &gt; retval[10])<br/>            retval=results[k]<br/>    }<br/>    console.log(retval)<br/>})</span></pre><p id="dd6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码找到了3月22日最贵的旅行，时间超过3小时，总共花费了475美元:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="4a6f" class="kw jq hi ks b fi kx ky l kz la">[ 1725438,<br/>  true,<br/>  2,<br/>  2018-03-22T06:43:13.000Z,<br/>  2018-03-22T09:59:34.000Z,<br/>  1,<br/>  false,<br/>  93,<br/>  265,<br/>  1,<br/>  450,<br/>  0,<br/>  0,<br/>  0,<br/>  24.760000228881836,<br/>  0.30000001192092896,<br/>  475.05999755859375,<br/>  6,<br/>  4 ]</span></pre><p id="8351" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于Node.js的异步特性，需要两个技巧:首先是确定查询参数是什么<br/> (locationID)。这个问题有点棘手，它被放在一个承诺链中，并借助于<a class="ae jo" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">curry</a>来解决，这是一个在then()调用<br/>中指定的函数，如下所示:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a7f6" class="kw jq hi ks b fi kx ky l kz la">for (let i=0; i &lt; 100; i++) { promise=store.getContainer("col"+i) .then(query(i)) .then(iterate(i))<br/>        ... }</span></pre><p id="cf97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于所有查询都在后台同时执行，我们需要等待它们完成。<br/>首先我们将查询promise添加到一个列表中:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="1842" class="kw jq hi ks b fi kx ky l kz la">promises.push(promise)</span></pre><p id="8bd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们可以等待所有的承诺完成:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="dfd4" class="kw jq hi ks b fi kx ky l kz la">Promise.all(promises).then(values =&gt; {<br/>  // display results<br/>}</span></pre><p id="8d77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了对最长的旅程进行修改，您需要将“fare_amount”更改为“duration ”,并将最终比较关键字从“10”更改为<br/>“1”:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="8432" class="kw jq hi ks b fi kx ky l kz la">...<br/><br/>            q = cont.query("SELECT * ORDER BY duration DESC LIMIT 1 ");<br/><br/>...<br/><br/>        if (retval == null || results[k][1] &gt; retval[1])<br/><br/>...</span></pre><p id="6bec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您对最繁忙的位置感兴趣，将需要使用聚合查询，这也将改变<br/>结果获取和最终排序。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="58ee" class="kw jq hi ks b fi kx ky l kz la">...<br/><br/>var iterate = function(locID) {<br/>        return function(rowset) {<br/>            if(rowset != null) {<br/>                if (rowset.hasNext()) {<br/>                    row = rowset.next();<br/>                    results[locID] = row.get(griddb.GS_TYPE_LONG);<br/>                }<br/>        }<br/>    }<br/>}<br/><br/><br/>var query = function (locID) {<br/>    return function(cont) {<br/>        if(cont != null) {<br/>            q = cont.query("SELECT COUNT(*)");<br/>            return q.fetch()<br/>        }<br/>    }<br/>}<br/><br/>...<br/><br/>Promise.all(promises).then(values =&gt; {<br/>        var items = Object.keys(results).map(function(key) {<br/>          return [key, results[key]];<br/>        });<br/><br/>        items.sort(function(first, second) {<br/>         return second[1] - first[1];<br/>        });<br/><br/>        console.log(items.slice(0, 10))<br/>})</span></pre><p id="5005" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出如下，我们可以看到161区(曼哈顿中城)是最繁忙的，有156727次出行。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="342c" class="kw jq hi ks b fi kx ky l kz la">[ [ '161', 156727 ],<br/>  [ '237', 153388 ],<br/>  [ '162', 144923 ],<br/>  [ '230', 143784 ],<br/>  [ '186', 136234 ],<br/>  [ '236', 136093 ],<br/>  [ '170', 134533 ],<br/>  [ '48', 131547 ],<br/>  [ '234', 130747 ],<br/>  [ '79', 115052 ] ]</span></pre><h1 id="99e8" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">更复杂的分析</h1><p id="e0cc" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">上面的简单查询提供了有趣的见解，但是更复杂的查询，比如“在一天的某个给定时间，哪些区域最忙？”允许出租车公司决定如何调配他们的出租车，以实现利润最大化。</p><p id="3f6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了做到这一点，我们可以使用多个<br/>查询来确定在一天中给定的时间里从每个邻近地区进行了多少次旅行。对于每个位置和每个小时，运行一个简单的计数聚合。</p><p id="f763" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果被放入一个二维字典中以供进一步处理。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a022" class="kw jq hi ks b fi kx ky l kz la">var iterate = function(locID, hour ) {<br/>        return function(rowset) {<br/>            if(rowset != null) {<br/>                while (rowset.hasNext()) {<br/>                    row = rowset.next();<br/>                    results[hour][locID] = row.get(griddb.GS_TYPE_LONG)<br/>                }<br/>        }<br/>    }<br/><br/>}<br/><br/>var query = function (locID, hour) {<br/>    return function(cont) {<br/>        if(cont != null) {<br/>            q = cont.query("SELECT count(*) where hour_of_day = "+hour);<br/>            return q.fetch()<br/>        }<br/>    }<br/>}<br/><br/>for(let hour=0; hour &lt; 24; hour++) {<br/>    results[hour] = {};<br/>    for (loc=0; loc &lt; 265; loc++)<br/>        results[hour][loc] = 0<br/><br/>    for (let i=0; i &lt; 265; i++) {<br/>        var locID = i<br/>        promise = store.getContainer("col"+i)<br/>        .then(query(i, hour))<br/>        .then(iterate(i, hour))<br/>        .catch(err =&gt; {<br/>            if (err.constructor.name == "GSException") {<br/>                for (var i = 0; i &lt; err.getErrorStackSize(); i++) {<br/>                    console.log("[", i, "]");<br/>                    console.log(err.getErrorCode(i));<br/>                    console.log(err.getMessage(i));<br/>                }<br/>            } else {<br/>                console.log(err);<br/>            }<br/>        })<br/>        promises.push(promise)<br/>    }<br/>}</span></pre><p id="3944" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，脚本等待所有查询承诺，然后进行最终处理，打印10个最繁忙的位置。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f41f" class="kw jq hi ks b fi kx ky l kz la">Promise.all(promises).then(values =&gt; {<br/><br/>    for (hour=0; hour &lt; 24; hour++) {<br/>        var items = Object.keys(results[hour]).map(function(key) {<br/>          return [key, results[hour][key]];<br/>        });<br/><br/>        items.sort(function(first, second) {<br/>          return second[1] - first[1];<br/>        });<br/>  <br/>        locations = items.map(function(item) {<br/>            return item[0]<br/>        })<br/><br/>        console.log(hour+": "+locations.slice(0, 10))<br/>    }<br/>})</span><span id="0adc" class="kw jq hi ks b fi lk ky l kz la">0: 79,230,48,249,148,234,132,161,164,114<br/>1: 79,148,48,230,249,114,164,132,234,68<br/>2: 79,148,48,114,249,68,230,164,158,234<br/>3: 79,148,68,48,230,249,114,164,158,144<br/>4: 79,48,230,148,68,164,249,186,107,114<br/>5: 48,100,132,186,79,230,170,236,107,263<br/>6: 186,48,100,132,236,170,162,68,107,263<br/>7: 186,236,48,170,100,237,141,162,107,140<br/>8: 236,237,170,186,48,141,162,107,140,239<br/>9: 236,237,170,162,186,48,141,239,138,161<br/>10: 237,236,186,138,162,170,161,48,230,142<br/>11: 237,236,161,162,186,170,138,230,142,234<br/>12: 237,236,161,162,186,170,230,234,239,138<br/>13: 237,161,236,162,170,186,234,239,163,230<br/>14: 237,161,236,162,234,170,239,163,138,186<br/>15: 237,161,236,162,234,138,170,186,239,142<br/>16: 161,237,236,162,138,234,132,170,230,239<br/>17: 161,237,162,230,236,234,170,138,163,186<br/>18: 161,162,237,230,234,236,170,163,186,142<br/>19: 161,162,234,237,170,230,186,163,138,142<br/>20: 161,162,234,230,170,237,79,186,48,138<br/>21: 230,161,162,234,48,79,186,138,170,142<br/>22: 230,161,48,79,234,186,162,142,164,138<br/>23: 230,79,48,142,234,161,138,249,132,186</span></pre><p id="c99b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果显示，79区(东村)在清晨最繁忙，而237区(上东区)在中午最繁忙，161区(曼哈顿中城)在傍晚和晚上最繁忙。</p><p id="1d5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将最终处理更改为基于百分比计算旅行次数，或者修改上面的查询<br/>查找潜在的最大收入，这很简单。</p><p id="540b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整版本的脚本可以从<a class="ae jo" href="https://griddb.net/en/download/26412/" rel="noopener ugc nofollow" target="_blank">这里</a>下载</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="5b7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ls">原载于2020年4月6日https://griddb.net</em><a class="ae jo" href="https://griddb.net/en/blog/nyc-taxi-open-data-node-js/" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a><em class="ls">。</em></p></div></div>    
</body>
</html>