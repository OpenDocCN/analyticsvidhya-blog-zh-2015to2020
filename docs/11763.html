<html>
<head>
<title>Do Not Put your ML models in AWS EBS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要将您的 ML 模型放在 AWS EBS 中</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/do-not-put-your-ml-models-in-aws-ebs-3ae0db559669?source=collection_archive---------12-----------------------#2020-12-17">https://medium.com/analytics-vidhya/do-not-put-your-ml-models-in-aws-ebs-3ae0db559669?source=collection_archive---------12-----------------------#2020-12-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/5d2c622c987344aba77b0a8b8e627d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oD_8dHQOmARgKnwWLdEXw.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="f0ad" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">(从快照启动时)</h2></div><p id="01c8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是我想要的。我想要一个 AMI，我可以将它启动到 Amazon EC2 实例(使用 GPU)中，以便在每周二早上运行一个模型。实例必须加载模型，完成工作，然后终止。我希望一切尽可能快地执行，我想 100%确定图像将死亡，以避免一个大的 AWS 法案。</p><p id="262b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">本文建议了一种实现上述内容的方法。我还讨论了我犯的一个错误，即在 EBS 中存储我的 ML 模型，以及应该怎么做。</p><p id="1a93" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果您只是想知道，为什么不是 EBS，那么跳到文章的第二部分，忽略代码。</p><h1 id="27b7" class="ke kf ht bd kg kh ki kj kk kl km kn ko iz kp ja kq jc kr jd ks jf kt jg ku kv bi translated">阶跃函数+ Lambda + EC2</h1><p id="60f5" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hb bi translated">其想法是创建一个步骤函数工作流，该工作流将由星期二的 Cloudwatch 事件触发。工作流将依次执行以下操作:</p><ol class=""><li id="d500" class="lb lc ht jk b jl jm jo jp jr ld jv le jz lf kd lg lh li lj bi translated">启动 Lambda，这将启动 EC2 实例；Lambda 返回启动的实例的实例 id</li><li id="a1aa" class="lb lc ht jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">观察 EC2 实例的活动；在我们的实例中运行的程序必须启动活动，每分钟提交心跳，然后报告任务成功。</li><li id="741d" class="lb lc ht jk b jl lk jo ll jr lm jv ln jz lo kd lg lh li lj bi translated">启动相同的 Lambda，它将使用提供的实例 id 终止 EC2 实例。</li></ol><p id="93dc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是这个工作流的亚马逊州语言规范。</p><figure class="lq lr ls lt fd hk er es paragraph-image"><div class="er es lp"><img src="../Images/9b049ecfb6e9bd3d699d59af971118d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*TtZZ0c-KdMKpNL6WQ8RzQg.png"/></div></figure><figure class="lq lr ls lt fd hk"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="bde9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">注意，我们将 AMI id 和动作“start”传递给 Lambda 函数来启动实例，并将 AMI id、动作“stop”和生成的实例 id 传递给 stop 实例。我们的 lambda 函数应该读取“action”字符串，并启动或终止一个实例。</p><h1 id="9e99" class="ke kf ht bd kg kh ki kj kk kl km kn ko iz kp ja kq jc kr jd ks jf kt jg ku kv bi translated">为什么 EBS 对 ML 车型没有好处？</h1><p id="4fb7" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hb bi translated">我的 ML 型号大约是 5GB。不是一个巨大的模型，但嘿，我不是 OpenAI，他们(OpenAI)甚至不喜欢我(仍在等待进入 GPT-3)。</p><p id="9a8c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我最初的想法是将模型打包到 AMI 中。我不希望模型频繁更新，我认为将所有东西都放在实例的根卷中已经足够快了。毕竟，有什么设置会比在操作系统驱动器中启动所有必需文件的服务器更有效呢！</p><p id="f1ee" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我错了。</p><p id="b43a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">将<strong class="jk hu"> 5 GB 型号</strong>加载到我的桌面服务器上大约需要两分钟。同一型号的<strong class="jk hu">花了 20-30 分钟从 EBS </strong>加载。与此同时，GPU 基本上处于休眠状态，等待 I/O 完成——浪费时间和金钱。</p><p id="e9b1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">也许，最让人惊讶的是，这一点都不奇怪！</p><p id="a4ff" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">AWS <a class="ae lw" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-initialize.html" rel="noopener ugc nofollow" target="_blank">警告</a>不要从快照加载 EBS 图像:</p><blockquote class="lx ly lz"><p id="a347" class="ji jj ma jk b jl jm iu jn jo jp ix jq mb js jt ju mc jw jx jy md ka kb kc kd hb bi translated">对于从快照创建的卷，存储块必须从亚马逊 S3 下载并写入卷，然后才能访问它们。这一初步操作需要时间，并且在第一次访问每个数据块时，可能会导致 I/O 操作延迟显著增加。</p></blockquote><p id="6c1f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">真扫兴。基于以上所述，每当我们从 AMI 启动一个新实例时，我们的程序都必须等待模型从 S3 复制到 EBS。虽然 S3 可以很快，但由 AWS 实现的同步过程相当慢。</p><p id="3d4f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">想法？</p><p id="20c9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这里有一个。</p><p id="02ca" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">EBS 卷是网络连接驱动器。它们速度很慢，不适合高 I/O。对于更高的 I/O，您需要直接连接 SSD 驱动器(无网络)。</p><p id="ca6d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">你猜怎么着。GPU 实例附带 SSD 驱动器，作为临时存储。例如，<a class="ae lw" href="https://aws.amazon.com/ec2/instance-types/g4/" rel="noopener ugc nofollow" target="_blank"> <em class="ma"> g4dn.xlarge </em> </a>实例带有一个 125 GB 的 NVMe SSD，可在设备<code class="du me mf mg mh b">“/dev/nvme0n1”</code>上使用。呜哇！</p><p id="ac50" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">问题在于，NVMe 的短暂储存是短暂的。这意味着，如果停止或休眠实例，数据将会丢失。由于我们只启动实例一次，然后终止它，这对我们没有太大影响。然而，在实例启动时，临时存储将是空的；因此，我们需要将模型从其他地方复制到临时存储中。</p><p id="d86d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">显而易见的选择是 S3。这也给我们带来了无需接触实例就能更新模型的优势。我们所要做的就是添加一些额外的逻辑，将模型从 S3 复制到安装了临时存储的本地目录中。</p><p id="a17d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">转让费怎么样？如果您的 S3 存储桶和实例在同一个地区，您需要为每 GB 拷贝支付<em class="ma">0.02 美元。对于 5 GB，那是 10 美分，比最便宜的<em class="ma"> g4dn </em>实例 20 分钟便宜 50%。</em></p><p id="1104" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这似乎有悖直觉。为什么每次启动时复制数据比使用映像中已有的数据启动更快、更便宜？其实就应该这样。EBS 卷中的大多数内容(操作系统文件和库)永远不会被读取，因此不需要高 I/O。当需要时，您应该使用临时存储。</p><h2 id="7b5a" class="mi kf ht bd kg mj mk ml kk mm mn mo ko jr mp mq kq jv mr ms ks jz mt mu ku mv bi translated">让它工作</h2><p id="bb6a" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hb bi translated">我说过这个短暂的驱动器连接到了<code class="du me mf mg mh b">“/dev/nvme0n1”</code>(根据 AWS 的仪表板)，但是我发现在 Ubuntu 机器学习基础 AMI 实例中情况并非如此。</p><p id="624e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在我的实例中，临时存储被附加到<code class="du me mf mg mh b">“/dev/nvme1n1”</code> <em class="ma"> </em>上，并且必须被分区和挂载。我的解决方案是添加一个脚本，在引导时对临时存储进行分区和挂载。</p><pre class="lq lr ls lt fd mw mh mx my aw mz bi"><span id="6874" class="mi kf ht mh b fi na nb l nc nd">sudo nano /etc/rc.local</span><span id="4ecb" class="mi kf ht mh b fi ne nb l nc nd">mkfs -t xfs /dev/nvme1n1<br/>/dev/nvme1n1 ~/&lt;YOUR ML MODEL DIRECTORY&gt;</span><span id="64da" class="mi kf ht mh b fi ne nb l nc nd">sudo chmod a+x /etc/rc.local</span></pre><p id="5aff" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果您在 docker 容器中运行您的程序，您还需要使用<code class="du me mf mg mh b"><strong class="jk hu">-v</strong></code>标志将上述目录挂载到 docker:</p><pre class="lq lr ls lt fd mw mh mx my aw mz bi"><span id="29ac" class="mi kf ht mh b fi na nb l nc nd">sudo docker run -ti — gpus all -v ~/&lt;YOUR ML MODEL DIRECTORY&gt;:/app/&lt;YOUR ML MODEL DIRECTORY&gt; — name [NAME] [IMAGE]</span></pre><h1 id="0ec6" class="ke kf ht bd kg kh ki kj kk kl km kn ko iz kp ja kq jc kr jd ks jf kt jg ku kv bi translated">经验教训</h1><p id="a741" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hb bi translated">应该“明显”起作用的东西，并不总是起作用，但它可以成为一篇好文章。</p></div></div>    
</body>
</html>