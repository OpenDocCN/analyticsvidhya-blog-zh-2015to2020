<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/this-is-the-2nd-part-of-my-2-part-bit-masking-series-9830e690f51b?source=collection_archive---------12-----------------------#2020-03-25">https://medium.com/analytics-vidhya/this-is-the-2nd-part-of-my-2-part-bit-masking-series-9830e690f51b?source=collection_archive---------12-----------------------#2020-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/a0146aaaaf9f4f980fb3cf600ed524f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*VW253N9D77cs2MZBkMtBhA.png"/></div></div></figure><p id="3d79" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><strong class="hu iq">位屏蔽+ DP </strong></p><p id="b46a" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">这是我的2部分位屏蔽系列的第2部分。在这篇文章中，我将分享如何使用位屏蔽和动态编程来优化许多问题。</p><p id="214e" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">通过两个问题，我将试着分享比特魔术是如何应用于广泛的问题的。</p><p id="2ade" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><strong class="hu iq">先决条件:</strong></p><p id="5dc4" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">应该有一个关于比特和比特魔术如何工作的透彻的知识。</p><p id="368f" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">精通递归。</p><p id="bff7" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">随意浏览我的第一篇文章(bit.ly/Aman_Bitmask1)是你想重温位屏蔽的概念。</p><p id="7391" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><strong class="hu iq">跃上文章！！</strong></p><p id="114e" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">动态规划是一种通过消除重叠子问题的计算时间来降低程序复杂性的技术。它基本上记住了它经历的每一个状态，并试图用它来计算进一步的结果。</p><p id="1fe3" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">不，不像ML里的强化学习:)</p><p id="f66a" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">让我们从众所周知的问题开始，旅行推销员问题。</p><p id="ddcb" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">问:你有n个节点，每个节点都与其他节点相连。旅行者想要访问所有的节点，使得他覆盖的距离最小。找出旅行者要走的距离。</p><p id="d3d0" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><strong class="hu iq">溶胶:</strong></p><p id="2b96" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">这个问题可以简单地归结为这样一个事实:我们需要在给定的图中找到最小重量的哈密尔顿圈。</p><p id="61b2" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">解决这个问题的一个简单方法是使用深度优先搜索来计算所有可能的节点排列，并计算它们之间的距离。显然它的时间复杂度不低于O((n-1)！).</p><p id="c653" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><strong class="hu iq">那么我们该如何优化呢？</strong></p><p id="2c78" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">我将使用我在上一篇文章中使用的类似方法来计算不同的组合。</p><p id="c187" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">假设我们有4个节点:A、B、C、D</p><p id="1249" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">因为每个节点至少要被访问一次，所以为了简单起见，让我们把A作为源节点，然后遍历所有其他节点。</p><p id="748c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">与图形不同，我们不需要布尔数组来存储我们到目前为止访问过的节点。Bit-magic会自动为我们做到这一点:)</p><p id="feb6" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">对于当前的例子，因为我们有4个节点，所以我们在任何时间点的掩码将是MMMM的形式，其中每个“M”可以是0或1，这取决于该节点是否已经被访问过。Mask = 0000表示到目前为止没有访问过任何节点，mask = 1111表示我们已经访问了所有节点。</p><figure class="is it iu iv fd hk er es paragraph-image"><div class="er es ir"><img src="../Images/fdb6f37d52eee000bc4f61b398dd0f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*C24R2ut815aNLecgjVhi5g.png"/></div></figure><p id="aba9" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">我们应该注意的是，mask = 1111也是我们递归问题的基础。</p><p id="416c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在基本情况下，我们必须返回从最后访问的节点返回到源节点的成本。</p><p id="7005" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">从上面的讨论可以清楚地看出，对于给定的问题，[掩码][位置]形成了唯一的DP状态。</p><p id="768b" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">Mask表示到目前为止我们已经访问过的一组节点，position表示我们当前所处的节点。</p><figure class="is it iu iv fd hk er es paragraph-image"><div class="er es iw"><img src="../Images/d174bfe515f44d0ac02554c468b76e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*rWXLFbx2hkv_S_eCBZ74LQ.png"/></div><figcaption class="ix iy et er es iz ja bd b be z dx translated">在我们的例子中，我们假设A是源节点</figcaption></figure><p id="6c1a" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><strong class="hu iq">注意:在使用DP解决任何问题时，首先尝试思考可能的唯一状态。</strong></p><p id="0b77" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">由于掩码只能取2^n唯一值，并且总节点数= n，我们还将利用记忆化，因此该解决方案的时间复杂度降低到O((2^n)*n).</p><p id="f1f2" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">让我们看一下实现部分，以便更好地理解它。</p><figure class="is it iu iv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jb"><img src="../Images/c5890930cad3d9853553cdb4aad6e2c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2FXW3grzsc4-maS1Xsu9g.png"/></div></div></figure><p id="6b2a" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">希望这将有助于理解位屏蔽如何可以大大降低复杂性的概念。</p><p id="1f49" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">让我们再讨论一个问题以获得更多的见解。</p><p id="0046" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><strong class="hu iq"> Q .给定一个数n，将这个数n置换(将数n中的所有数字置换)。置换数字应该有相同的位数。给定一个数m(1 &lt; =m &lt; =100)，求能被m整除的排列数</strong></p><p id="71e5" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><strong class="hu iq">索尔:</strong></p><p id="51c3" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在处理这个问题时，我们需要认识到两个事实，首先，数字可以有重复的数字(如331)，其次，数字中不应该有任何前导零(因为提到数字应该有完全相同的数字)。</p><p id="634a" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">因此，在这里采取[ pos ][ mask ]可能会被证明是错误的。原因很简单，它会认为两个3是不同的(在331的情况下)，我们的ans会比实际的ans多，因为它会将相同的数字计数两次。</p><p id="40a3" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">所以在这里，我们还需要额外存储模。如果我们有重复的数字，那么我们只取最先出现的数字。如果号码是52442。掩码是[10000]，那么我们可以跳到掩码[11000]或[10100]。我们不能跳到[10010]或[10001]。</p><p id="9d5c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">pos基本上告诉新数字插入的位置，而mask也存储与设置位数相等的位数。因此，我们不需要像在上述问题中那样考虑pos。</p><p id="c00f" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">所以我们最终的解决方案看起来像这样:</p><p id="d947" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">对于任何位置，我们都需要考虑所有可能出现的值，并且只考虑第一次出现的值。同样如果我们的数字还没有开始，那么我们不能考虑0。</p><p id="b08e" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在每一次迭代中，我们将形成一个更小的数，当掩码的所有位都被设置时，数就完成了。这是我们的基本情况，当所有的位都被设置时，我们需要检查我们计算的mod是否为零。如果mod出来是0，那么实际上我们的置换数可以被M整除，否则不能。</p><p id="6b7a" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><strong class="hu iq">注意:我们只需要计算排列的数量，而不是打印出来。</strong></p><p id="b54f" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">让我们浏览一下代码，使它更清楚。</p><figure class="is it iu iv fd hk er es paragraph-image"><div class="er es jc"><img src="../Images/9c4b9a9ecec380de5f85cec0a2c73d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*9edO2EITKXgNMWXcKv9j1w.png"/></div></figure><p id="c6e3" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">希望通过阅读这些问题，到目前为止，您已经对有用的Bit-Magic有了一个基本的了解，它可以从实现和优化两方面得到证明。</p><p id="c913" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">以下是一些与类似概念相关的练习题的链接:</p><p id="dcdf" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><a class="ae jd" href="https://codeforces.com/problemset/problem/1169/E" rel="noopener ugc nofollow" target="_blank">https://codeforces.com/problemset/problem/1169/E</a></p><p id="ce8d" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><a class="ae jd" href="https://www.codechef.com/JAN15/problems/SEALCM" rel="noopener ugc nofollow" target="_blank">https://www.codechef.com/JAN15/problems/SEALCM</a></p><p id="0291" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">链接到我以前的文章:</p><p id="11e5" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><a class="ae jd" rel="noopener" href="/analytics-vidhya/bits-bitmasking-62277789f6f5">https://medium . com/analytics-vid hya/bits-bit masking-62277789 F6 F5</a></p><p id="523d" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">快乐编码: )</p></div></div>    
</body>
</html>