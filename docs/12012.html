<html>
<head>
<title>Best Model in PyTorch after training across all Folds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch所有褶皱训练后的最佳模特</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/best-model-in-pytorch-after-training-across-all-folds-d0ea9868ab33?source=collection_archive---------11-----------------------#2020-12-28">https://medium.com/analytics-vidhya/best-model-in-pytorch-after-training-across-all-folds-d0ea9868ab33?source=collection_archive---------11-----------------------#2020-12-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4408" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我将定义一个函数，它将帮助社区在数据集的所有折叠中训练一个模型后保存最佳模型。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/10182c3e624283378c05486a03acc469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RL30b_OHipSpGku_HFo-1Q.jpeg"/></div></div></figure><p id="ef1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，首先我们将我们的数据帧划分成我们选择的若干折叠。</p><pre class="jd je jf jg fd jo jp jq jr aw js bi"><span id="ccbf" class="jt ju hh jp b fi jv jw l jx jy">from sklearn import model_selection<br/><br/>dataframe["kfold"] = -1  <strong class="jp hi"><em class="jz"># defining a new column in our dataset</em></strong>  </span><span id="4dad" class="jt ju hh jp b fi ka jw l jx jy"><strong class="jp hi"><em class="jz"># taking a fraction of data from our dataframe and reset its index</em></strong> <br/>dataframe = dataframe.sample(frac=1).reset_index(drop=True)</span><span id="5bee" class="jt ju hh jp b fi ka jw l jx jy"><strong class="jp hi"><em class="jz"># storing the target values in a list</em></strong><br/>y = dataframe.label.values</span><span id="fb2f" class="jt ju hh jp b fi ka jw l jx jy"><strong class="jp hi"><em class="jz"># defining the number of required folds we want in our dataset</em></strong><br/>kf = model_selection.StratifiedKFold(n_splits= <strong class="jp hi"><em class="jz">number_of_folds</em></strong>)</span><span id="2b29" class="jt ju hh jp b fi ka jw l jx jy"><strong class="jp hi"><em class="jz"># assigning the fold number with respect to the data in kfold column</em></strong> <br/>for f, (t_, v_) <strong class="jp hi">in</strong> enumerate(kf.split(X=dataframe, y=y)):<br/>    dataframe.loc[v_, 'kfold'] = f<br/><strong class="jp hi"># looking into the new dataframe we created</strong>     <br/>dataframe</span></pre><p id="b7ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我将定义一个函数，该函数将在所有折叠训练后返回最佳模型。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/31deb4925d911840dbf2fa20de4f00d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fZHvUmC8tYl1lzA4nXDVg.jpeg"/></div></div></figure><pre class="jd je jf jg fd jo jp jq jr aw js bi"><span id="2bad" class="jt ju hh jp b fi jv jw l jx jy">from cpython.Lib import copy</span><span id="17f0" class="jt ju hh jp b fi ka jw l jx jy">a_string = "*" * 20</span><span id="7e41" class="jt ju hh jp b fi ka jw l jx jy">def _run():<br/>    <br/>    for i <strong class="jp hi">in</strong> range(<strong class="jp hi"><em class="jz">number_of_folds</em></strong>):</span><span id="a4fa" class="jt ju hh jp b fi ka jw l jx jy">        <strong class="jp hi"><em class="jz"># just a print statement for fomatting</em></strong><br/>        print(a_string, " FOLD NUMBER ", i, a_string) <br/>        <br/>        <strong class="jp hi"><em class="jz"># assigning fold numbers for training dataframe</em></strong><br/>        df_train = new_train[new_train.kfold != i].reset_index(drop=True)</span><span id="cb97" class="jt ju hh jp b fi ka jw l jx jy"><strong class="jp hi"><em class="jz">        # assigning fold numbers for validation dataframe<br/>        </em></strong>df_valid = new_train[new_train.kfold == i].reset_index(drop=True)<br/>        <br/>        <strong class="jp hi"><em class="jz"># defining an empty list to store all accuracies across the particular fold we are training</em></strong><br/>        all_accuracies = []<br/>        <br/>        for epoch <strong class="jp hi">in</strong> range(<strong class="jp hi"><em class="jz">NO_OF_EPOCHS</em></strong>):<br/>            print(f"Epoch --&gt; <strong class="jp hi">{</strong>epoch+1<strong class="jp hi">}</strong> / <strong class="jp hi">{<em class="jz">NO_OF_EPOCHS</em>}</strong>")<br/>            print(f"-------------------------------")<br/><br/>            train_loss, train_accuracy_metric_output = train_loop_fn()<br/>            print('training Loss: <strong class="jp hi">{:.4f}</strong> &amp; training accuracy : <strong class="jp hi">{:.2f}</strong>%'.format(train_loss, train_accuracy_metric_output*100))<br/><br/>            valid_loss , validation_accuracy_metric_output = eval_loop_fn(val_dataloader, model, device)<br/>            print('validation Loss: <strong class="jp hi">{:.4f}</strong> &amp; validation accuracy : <strong class="jp hi">{:.2f}</strong>%'.format(valid_loss , validation_accuracy_metric_output*100))<br/>            <br/>            all_accuracies.append(valid_acc)<br/>        <br/>        <strong class="jp hi"><em class="jz"># comparing and saving the best model in best_model variable at each training and validation checkpoint</em></strong><br/>        if i &lt; 1:<br/>            best_accuracy = max(all_accuracies)<br/>            best_model = copy.deepcopy(model)<br/>        else:<br/>            if best_accuracy &gt; max(all_accuracies):<br/>                continue<br/>            else:<br/>                best_accuracy = max(all_accuracies)<br/>                <strong class="jp hi">best_model</strong> = copy.deepcopy(model)<br/>  <br/>    print('<strong class="jp hi">\n</strong>============<strong class="jp hi">Saving the best mode</strong>l==================')<br/>    torch.save(best_model.state_dict(),'__<strong class="jp hi"><em class="jz">your best model</em></strong>__.pt')<br/>    print()</span><span id="349a" class="jt ju hh jp b fi ka jw l jx jy"><strong class="jp hi"><em class="jz">    # Printing out the best accuracy we got after training</em></strong><br/>    print("&amp; The highest accuracy we got among all the folds is <strong class="jp hi">{:.2f}</strong>%".format(best_accuracy*100))</span><span id="723e" class="jt ju hh jp b fi ka jw l jx jy">    return best_model</span></pre><p id="831e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于上面的代码中有很多行，所以我将一个一个地解释它们，我也强烈要求阅读代码上面的注释行，以便正确地理解它。</p><p id="ec86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第<strong class="ig hi">行的第</strong>行，我从cpython库中导入复制函数。</p><p id="7de3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后定义一个字符串来格式化，这没什么大不了的。</p><p id="fb10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后定义一个循环，这样我们可以一个接一个地迭代每个折叠。</p><p id="4a99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">之后，我们使用格式化变量来显示以迭代方式在每个褶皱上训练模型所获得的结果。</p><p id="04cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后定义df_train &amp; df_valid，它将只考虑df_valid的折叠数，其余的折叠数将分配给df_train。</p><p id="709a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在此之后，我们定义一个空列表来存储所有的精度值，这些值是我们在验证数据的特定折叠数内训练模型后获得的。</p><p id="754b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">之后，我们定义循环来为多个时期训练我们的模型，并使用一些格式化打印行来跟踪训练和验证损失，以及度量并在接下来的几行中打印出来。</p><p id="e6f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">all _ accurances . append(valid _ ACC)</strong>该行用于存储上述列表中折叠训练内获得的所有精度。</p><p id="fe78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来的几行是最重要的几行，实际的魔术正在发生，所以请密切注意这一点。<strong class="ig hi"> <em class="jz">因此，我们在这里检查，如果我们当前训练模型的折叠小于1，那么我们将在两个变量best_accuracy &amp; best_model中连续存储最佳精度和最佳模型。否则，如果折叠数的值大于或等于1，那么我们将它的最佳精度与我们在上一次折叠迭代中获得的最大精度进行比较。如果当前的最佳精度小于我们之前得到的精度，那么我们只是继续，否则我们用我们需要的变量中的值替换它。</em> </strong></p><p id="4b7f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望您已经很好地理解了pytorch代码。如果你还有任何问题、意见或顾虑，请不要害羞，在评论区提出来。我一定会回答的。在那之前享受学习。</p></div></div>    
</body>
</html>