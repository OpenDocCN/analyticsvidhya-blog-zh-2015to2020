<html>
<head>
<title>Logistics Center of Gravity Analysis in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的物流重心分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/logistics-center-of-gravity-analysis-in-python-a21ad034f849?source=collection_archive---------0-----------------------#2020-09-23">https://medium.com/analytics-vidhya/logistics-center-of-gravity-analysis-in-python-a21ad034f849?source=collection_archive---------0-----------------------#2020-09-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4fbe" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在物流中，重心分析用于得出仓库的最佳位置。下面是如何用 Python 实现的。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/989a47dcd68df5365824def52f90eeb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYGXjowm54P6lE4XledA5w.jpeg"/></div></div></figure><p id="8eee" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">本文原载于</em><a class="ae kg" href="http://victorangeloblancada.github.io" rel="noopener ugc nofollow" target="_blank"><em class="kf">victorangeloblancada . github . io</em></a><em class="kf">。</em></p><p id="d710" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在物流中，重心分析用于通过计算到设施所服务的每个供应或需求位置的运输成本来得出仓储设施的理想位置。因此，重心是总运输成本最低的位置。</p><p id="3fe4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">从其名称可以推断，重心分析类似于质心，其物理和工程对应物，其中质心是分布质量的加权相对位置总和为零的单点。该公式类似于物流重心的计算，使用进出仓储设施的运输量，而不是物理质心中的分布质量。物理质量中心或物流重心的坐标公式如下:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kh"><img src="../Images/3d5e0b9cfa169de7db1d3a1aed9f0dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*lWP2jVO_Wzn9qykdwcF6mw.png"/></div></figure><p id="19e1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">其中 x 和 y 是指所服务的 n 个位置的坐标(物理质心的 n 个分布质点的坐标)，m 是指输送体积(物理质心的质量)。</p><p id="7c39" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，将这种理论分析应用于实际问题会很快变得复杂，因为要考虑现实假设和业务约束，例如:</p><ol class=""><li id="7c9a" class="ki kj hi jl b jm jn jp jq js kk jw kl ka km ke kn ko kp kq bi translated">如果需要一个以上的仓储设施位置，该怎么办？</li><li id="fe03" class="ki kj hi jl b jm kr jp ks js kt jw ku ka kv ke kn ko kp kq bi translated">如果进出运费不同怎么办？这是一个现实的假设，因为入站交付成本往往较低，因为项目是批量运输到仓库，因此受益于规模经济，而项目是以较小的数量运出给客户或分销商。</li><li id="dfef" class="ki kj hi jl b jm kr jp ks js kt jw ku ka kv ke kn ko kp kq bi translated">如果企业只有几个可以建立设施的候选地点，该怎么办？</li><li id="53b2" class="ki kj hi jl b jm kr jp ks js kt jw ku ka kv ke kn ko kp kq bi translated">我们如何确保选定的坐标落在仓库位置的可行地点，例如，位置不在居民区、山上或水上？</li></ol><p id="57ed" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于问题 1 和 2，我们将看看如何使用 K-Means 来获得重心。下一节包括用 Python 实现这一点的代码。</p><p id="c7c2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于问题 3 和 4，我们将看看如何使用 Python 中的<a class="ae kg" href="https://docs.python.org/2/library/itertools.html" rel="noopener ugc nofollow" target="_blank"> Itertools </a>从一组候选站点中选择重心。最后一节包括实现这一点的代码。</p><h1 id="a902" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">对多个设施使用 K 均值</h1><p id="0e8e" class="pw-post-body-paragraph jj jk hi jl b jm lo ij jo jp lp im jr js lq ju jv jw lr jy jz ka ls kc kd ke hb bi translated">让我们使用以下虚拟数据来获得重心:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lt"><img src="../Images/40127de5e2e892590a1179a3ac6a67d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*Yn-JKY9Mw5bUEgkb0ODYag.png"/></div></figure><p id="dcf2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">假设我们想使用重心法确定两个仓库位置。上一节中的质心公式将仅提供一个重心，但是，根据其定义，即运输成本最小化的点，我们可以使用 K-means 聚类算法来确定将运输成本最小化的多个位置，因为 K-means 聚类是一种无监督的学习技术，它可以识别质心，从而根据最接近质心的质心为每个单独的数据点分配一个聚类。要确定两个仓库位置，我们可以运行 K=2 的 K-means 聚类算法，以获得两个最小化运输距离的质心，从而最小化运输成本。</p><p id="16a7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的代码块导入分析所需的库，并加载上面的表:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="4b87" class="lz kx hi lv b fi ma mb l mc md">%matplotlib inline<br/># Import libraries<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="fe76" class="lz kx hi lv b fi me mb l mc md">from itertools import combinations </span><span id="5b2f" class="lz kx hi lv b fi me mb l mc md">from sklearn.cluster import KMeans</span><span id="af52" class="lz kx hi lv b fi me mb l mc md">import folium</span><span id="7677" class="lz kx hi lv b fi me mb l mc md"># Load data<br/>data = pd.read_excel('Data.xlsx',<br/>                     dtypes={'Location Name': str,<br/>                             'Location Type': str})</span></pre><p id="02c1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的代码块使用叶在活页地图上绘制站点(红色代表需求站点，黄色代表供应站点):</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="57d4" class="lz kx hi lv b fi ma mb l mc md"># Color options<br/>color_options = {'demand': 'red',<br/>                 'supply': 'yellow',<br/>                 'flow': 'black',<br/>                 'cog': 'blue',<br/>                 'candidate': 'black',<br/>                 'other': 'gray'}</span><span id="be63" class="lz kx hi lv b fi me mb l mc md"># Instantiate map<br/>m = folium.Map(location=data[['Latitude', 'Longitude']].mean(),<br/>               fit_bounds=[[data['Latitude'].min(),<br/>                            data['Longitude'].min()], <br/>                           [data['Latitude'].max(),<br/>                            data['Longitude'].max()]])<br/>                            <br/># Add volume points<br/>for _, row in data.iterrows():<br/>    folium.CircleMarker(location=[row['Latitude'], <br/>                                  row['Longitude']],<br/>                        radius=(row['Volume']**0.5),<br/>                        color=color_options.get(str(row['Location Type']).lower(), 'gray'),<br/>                        tooltip=str(row['Location Name'])+' '+str(row['Volume'])).add_to(m)<br/>                                #row['Longitude']]).add_to(m)<br/>        <br/># Zoom based on volume points<br/>m.fit_bounds(data[['Latitude', 'Longitude']].values.tolist())</span><span id="2c67" class="lz kx hi lv b fi me mb l mc md"># Show the map<br/>m</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/b15d69ef63a3ea3a45190596fb40c33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Knj-AmjoNzV_nymf.PNG"/></div></div></figure><p id="8bce" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">还假设向外和向内的运输成本不同，向仓库的向内交货通常比从仓库的可比距离的交货花费更少，由于规模经济，它们往往会这样。假设向外运送的费用正好是向内运送的两倍。在这种情况下，我们需要相应地调整卷的权重。到需求地点的外向交货乘以 2，而来自供应地点的内向交货保持不变:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/fb46b2f83c8f2410ecf6983c540859cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTTZI1qAht__CDwYn4JOBQ.png"/></div></div></figure><p id="9343" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的代码块根据我们的原始数据调整数量，以说明可比较的入境和出境运输之间的成本差异:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="45d6" class="lz kx hi lv b fi ma mb l mc md"># The outbound shipments cost twice as much as inbound shipments<br/>IB_OB_ratio = 2</span><span id="2af5" class="lz kx hi lv b fi me mb l mc md">def loc_type_mult(x):<br/>    """A function to get the volume multiplier based on the location type and the IB-OB ratio.<br/>    x: The location type<br/>    """<br/>    if x.lower() == 'supply':<br/>        # No need to divide since we are already multiplying the demand<br/>        return 1<br/>    elif x.lower() == 'demand':<br/>        # Only apply multiplier to demand<br/>        return IB_OB_ratio<br/>    else:<br/>        # If neither supply nor demand, remove entirely<br/>        return 0</span><span id="af36" class="lz kx hi lv b fi me mb l mc md"># Adjust volumes used in the computation based on IB-OB ratio<br/>data['Calc_Vol'] = data['Location Type'].apply(str).apply(loc_type_mult)*data['Volume']</span></pre><p id="1cc2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的代码块使用 Scikit-learn 的 K-means 聚类算法的实现来获得两个质心作为建议的仓库位置:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="1ce5" class="lz kx hi lv b fi ma mb l mc md"># Fit K-means for 2 centroids<br/>kmeans = KMeans(n_clusters=2, <br/>                random_state=0).fit(data.loc[data['Calc_Vol']&gt;0, ['Latitude', <br/>                                                                  'Longitude']], <br/>                                    sample_weight=data.loc[data['Calc_Vol']&gt;0, <br/>                                                           'Calc_Vol'])<br/># Get centers of gravity from K-means<br/>cogs = kmeans.cluster_centers_<br/>cogs = pd.DataFrame(cogs, columns=['Latitude',<br/>                                   'Longitude'])</span><span id="d8d9" class="lz kx hi lv b fi me mb l mc md"># Get volume assigned to each cluster<br/>data['Cluster'] = kmeans.predict(data[['Latitude', 'Longitude']])<br/>cogs = cogs.join(data.groupby('Cluster')['Volume'].sum())</span><span id="067a" class="lz kx hi lv b fi me mb l mc md"># Include assigned COG coordinates in data by point <br/>data = data.join(cogs, on='Cluster', rsuffix='_COG')</span></pre><p id="bc13" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的代码块使用活页地图上的叶子绘制了最终的重心，同时用线条表示从建议的仓库位置到供应和需求地点的交货路线:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="69fa" class="lz kx hi lv b fi ma mb l mc md"># Add flow lines to centers of gravity to map<br/>for _, row in data.iterrows():<br/>    # Flow lines<br/>    if str(row['Location Type']).lower() in (['demand', 'supply']):<br/>        folium.PolyLine([(row['Latitude'],<br/>                          row['Longitude']),<br/>                         (row['Latitude_COG'],<br/>                          row['Longitude_COG'])],<br/>                        color=color_options['flow'],<br/>                        weight=(row['Volume']**0.5),<br/>                        opacity=0.8).add_to(m)<br/>                        <br/># Add centers of gravity to map<br/>for _, row in cogs.iterrows():<br/>    # New centers of gravity<br/>    folium.CircleMarker(location=[row['Latitude'],<br/>                                  row['Longitude']],<br/>                        radius=(row['Volume']**0.5),<br/>                        color=color_options['cog'],<br/>                        tooltip=row['Volume']).add_to(m)<br/>    <br/># Show map<br/>m</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/4cb16e69f00ffb894e7f5f942b126738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YsdedfUHcpc1gIIZ.PNG"/></div></div></figure><p id="8758" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于样本数据，算法似乎已经选择在伊利诺伊州厄巴纳和特拉华州威尔明顿附近建立两个仓库。</p><h1 id="8bc6" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">使用 Itertools 遍历站点组合</h1><p id="3060" class="pw-post-body-paragraph jj jk hi jl b jm lo ij jo jp lp im jr js lq ju jv jw lr jy jz ka ls kc kd ke hb bi translated">如果可以放置仓库的位置数量有限怎么办？这可能是由于多种因素:公司可能已经拥有现有的地块，或者他们可能希望避免在住宅区获得推荐。</p><p id="e1cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以通过为算法引入候选站点来选择仓库位置，从而改变我们的方法。在下表中，上一节的原始数据已更新为五个候选地点，从中选择两个仓库位置:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mi"><img src="../Images/abcc533f55f4408b033d655330209030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*MjuwqRkMvP_O3ZKSFATImg.png"/></div></figure><p id="c919" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">数据准备基本相同，由下面的代码块覆盖，以显示传单地图中的供应地点(黄色)和需求地点(红色)以及候选地点(黑色):</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="4540" class="lz kx hi lv b fi ma mb l mc md">%matplotlib inline<br/># Import libraries<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="8c25" class="lz kx hi lv b fi me mb l mc md">from itertools import combinations </span><span id="773b" class="lz kx hi lv b fi me mb l mc md">from tqdm import tqdm</span><span id="a436" class="lz kx hi lv b fi me mb l mc md">from sklearn.cluster import KMeans</span><span id="9bab" class="lz kx hi lv b fi me mb l mc md">import folium</span><span id="e932" class="lz kx hi lv b fi me mb l mc md"># Load data<br/>data = pd.read_excel('Data.xlsx',<br/>                     dtypes={'Location Name': str,<br/>                             'Location Type': str})<br/>                             <br/># Color options<br/>color_options = {'demand': 'red',<br/>                 'supply': 'yellow',<br/>                 'flow': 'black',<br/>                 'cog': 'blue',<br/>                 'candidate': 'black',<br/>                 'other': 'gray'}</span><span id="e94f" class="lz kx hi lv b fi me mb l mc md"># Instantiate map<br/>m = folium.Map(location=data[['Latitude', 'Longitude']].mean(),<br/>               fit_bounds=[[data['Latitude'].min(),<br/>                            data['Longitude'].min()], <br/>                           [data['Latitude'].max(),<br/>                            data['Longitude'].max()]])<br/>                            <br/># Add volume points<br/>for _, row in data.iterrows():<br/>    folium.CircleMarker(location=[row['Latitude'], <br/>                                  row['Longitude']],<br/>                        radius=(row['Volume']**0.5),<br/>                        color=color_options.get(str(row['Location Type']).lower(), 'gray'),<br/>                        tooltip=str(row['Location Name'])+' '+str(row['Volume'])).add_to(m)<br/>                                #row['Longitude']]).add_to(m)<br/>        <br/># Zoom based on volume points<br/>m.fit_bounds(data[['Latitude', 'Longitude']].values.tolist())</span><span id="d924" class="lz kx hi lv b fi me mb l mc md"># Show the map<br/>m</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/e9c83399f82b02e0a74d523ad6a40360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fbRdjF6NaGC0iDqF.PNG"/></div></div></figure><p id="6167" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">与上一节相同，下面的代码块根据我们的原始数据调整数量，以说明可比较的入境和出境运输之间的成本差异:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="cf74" class="lz kx hi lv b fi ma mb l mc md"># The outbound shipments cost twice as much as inbound shipments<br/>IB_OB_ratio = 2</span><span id="1ef0" class="lz kx hi lv b fi me mb l mc md">def loc_type_mult(x):<br/>    """A function to get the volume multiplier based on the location type and the IB-OB ratio.<br/>    x: The location type<br/>    """<br/>    if x.lower() == 'supply':<br/>        # No need to divide since we are already multiplying the demand<br/>        return 1<br/>    elif x.lower() == 'demand':<br/>        # Only apply multiplier to demand<br/>        return IB_OB_ratio<br/>    else:<br/>        # If neither supply nor demand, remove entirely<br/>        return 0</span><span id="1e2a" class="lz kx hi lv b fi me mb l mc md"># Adjust volumes used in the computation based on IB-OB ratio<br/>data['Calc_Vol'] = data['Location Type'].apply(str).apply(loc_type_mult)*data['Volume']</span></pre><p id="525d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的代码块显示了求解重心的不同方法。Itertools 用于遍历所有可能的仓库位置组合，以获得运输成本最小的组合。以下代码根据距离计算总的估计运输成本，并根据每个潜在位置组合的相对运输成本进行加权，然后保存使估计成本最小的位置组合:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="277d" class="lz kx hi lv b fi ma mb l mc md">cands = data.loc[data['Location Type'].str.lower()=='candidate']<br/>locs = data.loc[data['Calc_Vol']&gt;0]</span><span id="e0cc" class="lz kx hi lv b fi me mb l mc md">total_dist = np.inf<br/>best_cogs = []</span><span id="6ff1" class="lz kx hi lv b fi me mb l mc md"># Loop to find best combination of candidate sites<br/>for i in tqdm(list(combinations(cands.index, n))):<br/>    temp_cands = cands.loc[list(i)]<br/>    locs['Cluster'] = 0<br/>    locs['Distance_COG'] = np.inf<br/>    for i_l, r_l in locs.iterrows():<br/>        for i_c, r_c in temp_cands.iterrows():<br/>            # Get distance<br/>            dist = (r_l['Latitude']-r_c['Latitude'])**2<br/>            dist += (r_l['Longitude']-r_c['Longitude'])**2<br/>            dist **= 0.5<br/>            # Save values if distance is shorter<br/>            if dist &lt; locs.loc[i_l, 'Distance_COG']:<br/>                # Save distance<br/>                locs.loc[i_l, 'Distance_COG'] = dist<br/>                # Save index of nearest point<br/>                locs.loc[i_l, 'Cluster'] = i_c<br/>    # Weight distance by volume<br/>    locs['Weighted_Distance_COG'] = locs['Distance_COG'] * locs['Calc_Vol']<br/>    # Save scenario if total weighted distance is smaller<br/>    if locs['Weighted_Distance_COG'].sum() &lt; total_dist:<br/>        total_dist = locs['Weighted_Distance_COG'].sum()<br/>        best_cogs = list(list(i))</span><span id="99a0" class="lz kx hi lv b fi me mb l mc md"># Get centers of gravity<br/>cogs = cands.loc[best_cogs, ['Latitude',<br/>                             'Longitude']]<br/># Reloop to get site assignment<br/>locs['Cluster'] = 0<br/>locs['Distance_COG'] = np.inf<br/>for i_l, r_l in locs.iterrows():<br/>    for i_c, r_c in cogs.iterrows():<br/>        # Get distance<br/>        dist = (r_l['Latitude']-r_c['Latitude'])**2<br/>        dist += (r_l['Longitude']-r_c['Longitude'])**2<br/>        dist **= 0.5<br/>        # Save values if distance is shorter<br/>        if dist &lt; locs.loc[i_l, 'Distance_COG']:<br/>            # Save distance<br/>            locs.loc[i_l, 'Distance_COG'] = dist<br/>            # Save index of nearest point<br/>            locs.loc[i_l, 'Cluster'] = i_c</span><span id="c0ba" class="lz kx hi lv b fi me mb l mc md"># Get volume assigned to each cog<br/>cogs = cogs.join(locs.groupby('Cluster')['Volume'].sum())</span><span id="440e" class="lz kx hi lv b fi me mb l mc md"># Include assigned COG coordinates in data by point <br/>data = data.join(locs['Cluster'])<br/>data = data.join(cogs, on='Cluster', rsuffix='_COG')</span></pre><p id="9467" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">与上一节类似，下面的代码块在传单地图上使用叶子绘制了最终的重心，同时用线条表示从建议的仓库位置到供应和需求地点的交货路线:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="8584" class="lz kx hi lv b fi ma mb l mc md"># Add flow lines to centers of gravity to map<br/>for _, row in data.iterrows():<br/>    # Flow lines<br/>    if str(row['Location Type']).lower() in (['demand', 'supply']):<br/>        folium.PolyLine([(row['Latitude'],<br/>                          row['Longitude']),<br/>                         (row['Latitude_COG'],<br/>                          row['Longitude_COG'])],<br/>                        color=color_options['flow'],<br/>                        weight=(row['Volume']**0.5),<br/>                        opacity=0.8).add_to(m)<br/>                        <br/># Add centers of gravity to map<br/>for _, row in cogs.iterrows():<br/>    # New centers of gravity<br/>    folium.CircleMarker(location=[row['Latitude'],<br/>                                  row['Longitude']],<br/>                        radius=(row['Volume']**0.5),<br/>                        color=color_options['cog'],<br/>                        tooltip=row['Volume']).add_to(m)<br/>    <br/># Show map<br/>m</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/6591ba54ec84b073a663006d86217d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o1iIZre0ZOuIptik.PNG"/></div></div></figure><p id="8332" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于示例数据，该算法选择在宾夕法尼亚州的哈里斯堡和宾夕法尼亚州的拉斐特建立两个仓库。</p><p id="3648" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf"> Victor Blancada 是一名数据科学家。访问他的领英页面</em> <a class="ae kg" href="https://www.linkedin.com/in/geloblancada/" rel="noopener ugc nofollow" target="_blank"> <em class="kf">这里</em> </a> <em class="kf">。</em></p></div></div>    
</body>
</html>