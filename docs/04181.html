<html>
<head>
<title>“Coding a Neural Network Quick” in Nutshell!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简而言之就是“快速编写神经网络代码”！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/coding-a-neural-network-quick-in-nutshell-52b49cfa9b23?source=collection_archive---------16-----------------------#2020-03-08">https://medium.com/analytics-vidhya/coding-a-neural-network-quick-in-nutshell-52b49cfa9b23?source=collection_archive---------16-----------------------#2020-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/d417df56e2fd55e6ace509ebe8dbb2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*RoMubVAdMcehq73j.png"/></div></figure><p id="825d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">众所周知，理解神经网络的过程(数学上)有多复杂，但编写代码一样简单。KERAS的世界让这一切变得简单易行。因此，让我们花点时间来感谢Keras库使整个过程变得更加容易。</p><p id="137a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Keras是python的开源深度学习库，它使得构建网络变得简单而容易。它包括所有的代码示例和参数细节，用于构建网络架构，如层，以调整神经网络的超参数，如优化器和损失。这个库为你做了所有复杂的数学运算，并且给了你对编码的控制权，而不是让你为数学伤透了脑筋。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es jk"><img src="../Images/50ac8ba1c5f874e58cc3ec9b770d38cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*Jw0dXjNpcz8HVjNe.png"/></div></figure><p id="3435" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">花点时间浏览一下https://keras.io/<a class="ae jp" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank">的主页，你会对他们记录事情的方式感到惊讶。</a></p><p id="811e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们列出建立一个网络所需要的东西。在这里，我们将讨论建立一个人工神经网络结构的顺序模型。概括地说，人工神经网络由三部分组成:输入层、隐藏层和输出层。将存在偏差因子，且每个单元权重将被随机初始化，并且随后通过反向传播进行调整。更深入的直觉检查:</p><div class="jq jr ez fb js jt"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/neural-networks-in-nutshell-7d1cc3ae6443"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">简而言之，神经网络</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">神经网络</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">简单地说，神经Networksmedium.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh ik jt"/></div></div></a></div><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es ki"><img src="../Images/887704f337474cbe96b0887faa5e2079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/0*HBtythRVOmPHz0wT.gif"/></div></figure><p id="cca6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的架构是顺序模型，在keras中构建它是关于堆叠层和为权重调整设置一些时期。</p><p id="f92e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，让我们以贷款资格数据集为例，其特征列(我选择的)为“申请人收入”、“共同申请人收入”、“贷款金额”、“贷款金额期限”和“信用历史”，目标列为“贷款状态”。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kj"><img src="../Images/aa28fc840a351eb59668e366e3787dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGe3U0AkXsrmOsQ7QNnlkQ.jpeg"/></div></div></figure><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ko"><img src="../Images/aa83ea7669f31d381230535ee2ae18f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36sSV8qBOZHAUtWxC3AyxA.jpeg"/></div></div></figure><p id="5cc1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">数据集最初由614行和13列组成。我们不会在这里讨论特性工程(我已经注释掉了代码以供参考，并提供了下载的数据集链接),而是只关注构建模型。</p><pre class="jl jm jn jo fd kp kq kr ks aw kt bi"><span id="f82e" class="ku kv hi kq b fi kw kx l ky kz">import numpy as np<br/>import pandas as pd<br/>from sklearn.preprocessing import LabelEncoder as le<br/>from sklearn.preprocessing import StandardScaler as ss</span><span id="4321" class="ku kv hi kq b fi la kx l ky kz">#importing dataset<br/>ds = pd.read_csv("train.csv")</span><span id="9600" class="ku kv hi kq b fi la kx l ky kz">#feature columns<br/>x = ds.iloc[:,[6,7,8,9,10]]</span><span id="c457" class="ku kv hi kq b fi la kx l ky kz">#handling missing datas<br/>x["LoanAmount"].fillna(0, inplace = True)<br/>x["Loan_Amount_Term"].fillna(0, inplace = True)<br/>x["Credit_History"].fillna(0, inplace = True)</span><span id="2bc2" class="ku kv hi kq b fi la kx l ky kz">#target column<br/>y = ds.iloc[:,-1]</span><span id="fb99" class="ku kv hi kq b fi la kx l ky kz">#handling categorical datas<br/>y = le().fit_transform(y[0:614])</span><span id="36f2" class="ku kv hi kq b fi la kx l ky kz">#normalising the feature columns<br/>x = ss().fit_transform(x)</span></pre><div class="jq jr ez fb js jt"><a href="https://www.kaggle.com/burak3ergun/loan-data-set" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">贷款数据集</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">贷款数据集分类</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">www.kaggle.com</p></div></div><div class="kc l"><div class="lb l ke kf kg kc kh ik jt"/></div></div></a></div><p id="fc7c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们完成了特征工程，让我们开始构建模型。要构建一个模型，你只需要两个库Tensorflow(用于运行它的后端)和Keras。粘贴下面的代码直接安装，我强烈推荐使用谷歌Colab，因为它有免费的GPU来加快模型训练。</p><pre class="jl jm jn jo fd kp kq kr ks aw kt bi"><span id="7117" class="ku kv hi kq b fi kw kx l ky kz">!pip install tensorflow<br/>!pip install keras</span></pre><p id="4153" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在导入两个主要函数<strong class="io hj"> Sequential </strong>用于构建序列模型，导入<strong class="io hj"> Dense </strong>用于堆叠模型的层。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/7e02f0291859f13bf4555c06db7c07a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*_AsYLUuIHV6TyrKQIzY-5w.jpeg"/></div></figure><p id="1b02" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我使用了四个密集层序列模型，其中dense_1是输入参数，dense_4是输出层。dense_2和dense_3是隐含层，有159个训练参数。让我们导入必要的库。</p><pre class="jl jm jn jo fd kp kq kr ks aw kt bi"><span id="8821" class="ku kv hi kq b fi kw kx l ky kz">import keras<br/>from keras.models import Sequential <br/>from keras.layers import Dense</span></pre><p id="dd5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我们从keras.models导入sequential来构建序列模型，从keras.layers导入dense来创建层，我们完成了导入所需组件来构建神经网络，就这么简单！。现在让我们用我们想要的单位初始化层，但是记住选择正确的层数和单位是至关重要的，因为它直接影响模型的性能。</p><p id="6d43" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从我的角度来看，选择正确的层数和正确的单位是一种艺术，因为这需要实践和大量的计算，但你仍然可以用一种简单的方法来做到这一点。</p><p id="c570" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，考虑dense_1，第一层有10个单位(我刚才看到feature列有5个单位，所以增加了一倍)，dense_4有一个单位，如您所知，我们在输出层只需要一个单位，因为target列只有一个值为“yes”或“no”的列。现在把第一层单位和最后一层单位加起来。然后除以2，就是:10 + 1 / 2 = 5.5四舍五入它6，所以dense_2得了6个单位。同样像拿dense_2和dense_4，就是:6 + 1 / 2 = 3.5四舍五入到4个单位，dense_3得到4个单位。</p><p id="9ba0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意</strong>:这不是理想的方法，但效果很好。</p><pre class="jl jm jn jo fd kp kq kr ks aw kt bi"><span id="65d6" class="ku kv hi kq b fi kw kx l ky kz">#making function which got sequence architecture <br/>model = Sequential()</span></pre><p id="a2b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">制作模型后，现在添加密集层。</p><pre class="jl jm jn jo fd kp kq kr ks aw kt bi"><span id="07a6" class="ku kv hi kq b fi kw kx l ky kz">model.add(Dense(units = 10, activation = "relu", input_dim = 5))</span></pre><p id="8132" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> model.add </strong>会为你创建层，<strong class="io hj"> Dense </strong>会在层中添加单位。该层包括10个单元，参数来自这5个特征列，这使得<strong class="io hj"> input_dim = 5 </strong>，最后我们添加<strong class="io hj"> relu </strong>作为单元的激活函数，以从模型中移除非线性。</p><pre class="jl jm jn jo fd kp kq kr ks aw kt bi"><span id="d9f0" class="ku kv hi kq b fi kw kx l ky kz">model.add(Dense(units = 6, activation = "relu"))</span></pre><p id="bef0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是第二层，由6个单元组成，如上所述，具有relu激活功能。注意，这一层没有input_dim，因为这一层的输入单元来自前面的层。</p><pre class="jl jm jn jo fd kp kq kr ks aw kt bi"><span id="84bd" class="ku kv hi kq b fi kw kx l ky kz">model.add(Dense(units = 4, activation = "relu"))</span></pre><p id="d20e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是第三层，正如我们在前面几层所做的，单位和激活功能也以同样的方式初始化。</p><pre class="jl jm jn jo fd kp kq kr ks aw kt bi"><span id="d5b8" class="ku kv hi kq b fi kw kx l ky kz">model.add(Dense(units = 1, activation = "sigmoid"))</span></pre><p id="9e1b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，我们通过添加一个单元将其作为输出层，我们添加了用于激活的<strong class="io hj"> sigmoid </strong>函数，因为sigmoid是输出层中非常需要的概率解决方案的更好选择。</p><p id="2550" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们已经完成了模型架构的构建，但是我强烈建议调整层数和它们的单位，以便亲自了解一些事情。剩下的唯一事情是训练模型，这也很容易用一行代码完成。</p><pre class="jl jm jn jo fd kp kq kr ks aw kt bi"><span id="982d" class="ku kv hi kq b fi kw kx l ky kz">model.fit(x, y, batch_size = 32, epochs = 100)</span></pre><p id="2159" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> model.fit </strong>取我们分别声明为“x”和“y”的特征值和目标值。时段的数量只是通过反复遍历网络来重新计算权重，这是“反向传播”方法，选择正确的时段数量至关重要，因为数量较少的模型会欠拟合，数量较多的模型会过拟合。batch_size是将输入值划分到某个批次中并进行计算，该批次的默认值为32。</p><p id="cd4c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是一段完整的代码:</p><pre class="jl jm jn jo fd kp kq kr ks aw kt bi"><span id="bbe2" class="ku kv hi kq b fi kw kx l ky kz">import numpy as np<br/>import pandas as pd<br/>from sklearn.preprocessing import LabelEncoder as le<br/>from sklearn.preprocessing import StandardScaler as ss</span><span id="9a60" class="ku kv hi kq b fi la kx l ky kz">#importing dataset and make sure the dataset in same folder.<br/>ds = pd.read_csv("train.csv")</span><span id="c0d7" class="ku kv hi kq b fi la kx l ky kz">#feature columns<br/>x = ds.iloc[:,[6,7,8,9,10]]</span><span id="5ed2" class="ku kv hi kq b fi la kx l ky kz">#handling missing datas<br/>x["LoanAmount"].fillna(0, inplace = True)<br/>x["Loan_Amount_Term"].fillna(0, inplace = True)<br/>x["Credit_History"].fillna(0, inplace = True)</span><span id="b0f3" class="ku kv hi kq b fi la kx l ky kz">#target column<br/>y = ds.iloc[:,-1]</span><span id="86e7" class="ku kv hi kq b fi la kx l ky kz">#handling categorical datas<br/>y = le().fit_transform(y[0:614])</span><span id="fab4" class="ku kv hi kq b fi la kx l ky kz">#normalising the feature columns<br/>x = ss().fit_transform(x)</span><span id="1f85" class="ku kv hi kq b fi la kx l ky kz">import keras<br/>from keras.models import Sequential <br/>from keras.layers import Dense</span><span id="41fa" class="ku kv hi kq b fi la kx l ky kz">model = Sequential()</span><span id="2a2c" class="ku kv hi kq b fi la kx l ky kz">model.add(Dense(units = 10, activation = "relu", input_dim = 5))<br/>model.add(Dense(units = 6, activation = "relu"))<br/>model.add(Dense(units = 4, activation = "relu"))<br/>model.add(Dense(units = 1, activation = "sigmoid"))</span><span id="5c60" class="ku kv hi kq b fi la kx l ky kz">model.fit(x, y, batch_size = 32, epochs = 100)</span><span id="da7b" class="ku kv hi kq b fi la kx l ky kz">model.summary()</span></pre><p id="1eb2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意</strong>:尝试自己调整所有参数，也可以调整不同的数据集以获得更多理解，还可以使用Google Colab和GPU运行时进行深度学习。</p><p id="afaf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">谢谢，继续学习。！</p></div></div>    
</body>
</html>