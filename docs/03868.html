<html>
<head>
<title>An Example of Using JavaScript Class Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript类语法的示例</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/an-example-of-using-javascript-class-syntax-ebadd1cc4d5c?source=collection_archive---------9-----------------------#2020-02-23">https://medium.com/analytics-vidhya/an-example-of-using-javascript-class-syntax-ebadd1cc4d5c?source=collection_archive---------9-----------------------#2020-02-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7773" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这篇文章是关于采用伪经典继承风格编写的JavaScript代码，并将其转换为使用ES6类。</p><p id="ec95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">伪经典继承我就不太深入了。相反，我将从一些使用伪经典继承的示例代码开始。下面是我们的结构，下面是代码:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b0e4f72963eb7adeb8a8ba86ba4ca181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5c5cn7YBuqRYqnamghe1PA.png"/></div></div></figure><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="f60f" class="ju jv hi jq b fi jw jx l jy jz">function Animal() {}<br/>  Animal.prototype.eat = function() {<br/>  console.log("I'm eating");<br/>}</span><span id="1606" class="ju jv hi jq b fi ka jx l jy jz">Animal.prototype.sleep = function() {<br/>  console.log("I'm sleeping");<br/>}</span><span id="d4e7" class="ju jv hi jq b fi ka jx l jy jz">function Mammal(legs) {<br/>  this.legs = legs;<br/>  this.warmBlooded = true;<br/>}</span><span id="6058" class="ju jv hi jq b fi ka jx l jy jz">Mammal.prototype = Object.create(Animal.prototype);<br/>Mammal.prototype.constructor = Mammal;<br/>Mammal.prototype.giveLiveBirth = function() {<br/>  //the gift of life<br/>}</span><span id="22c1" class="ju jv hi jq b fi ka jx l jy jz">function Dog(name, breed) {<br/>  Mammal.call(this, 4);<br/>  this.name = name;<br/>  this.breed = breed;<br/>}</span><span id="a16d" class="ju jv hi jq b fi ka jx l jy jz">Dog.prototype = Object.create(Mammal.prototype);<br/>Dog.prototype.constructor = Dog;</span><span id="58b8" class="ju jv hi jq b fi ka jx l jy jz">function Cat(name, breed) {<br/>  Mammal.call(this, 4);<br/>  this.name = name;<br/>  this.breed = breed;<br/>}</span><span id="5ad8" class="ju jv hi jq b fi ka jx l jy jz">Cat.prototype = Object.create(Mammal.prototype);<br/>Cat.prototype.constructor = Cat;</span><span id="c4b5" class="ju jv hi jq b fi ka jx l jy jz">const nocturnalMixin = {<br/>  isNocturnal: true<br/>}</span><span id="3d25" class="ju jv hi jq b fi ka jx l jy jz">Object.assign(Cat.prototype, nocturnalMixin);</span><span id="4196" class="ju jv hi jq b fi ka jx l jy jz">let tito = new Cat("Tito", "American shorthair")<br/>console.log(tito.isNocturnal)</span><span id="1062" class="ju jv hi jq b fi ka jx l jy jz"><br/>function Reptile() {<br/>  Animal.call(this);<br/>}</span><span id="9b3e" class="ju jv hi jq b fi ka jx l jy jz">Reptile.prototype = Object.create(Animal.prototype);<br/>Reptile.prototype.constructor = Reptile;<br/>Reptile.prototype.shed = function() {<br/>  console.log("I'm molting");<br/>}</span><span id="0d9f" class="ju jv hi jq b fi ka jx l jy jz">function LeopardGecko() {}<br/>LeopardGecko.prototype = Object.create(Reptile.prototype);<br/>LeopardGecko.prototype.constructor = LeopardGecko;<br/>Object.assign(LeopardGecko.prototype, nocturnalMixin);</span><span id="4906" class="ju jv hi jq b fi ka jx l jy jz">let eco = new LeopardGecko()<br/>console.log(eco.isNocturnal)</span></pre><p id="0f7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的<strong class="ih hj"> Animal </strong>构造函数没有任何属性，但是在它的原型上有几个方法，因为这些行为对所有动物都是通用的。</p><p id="a73c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">哺乳动物</strong>是<strong class="ih hj">动物</strong>的一种。哺乳动物有腿，是温血动物。它们还可以产生live birth，我已经排除了这个实现，但是任何使用<strong class="ih hj">哺乳动物</strong>构造函数创建的对象都可以访问这个方法。</p><p id="db37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">狗</strong>是<strong class="ih hj">哺乳动物</strong>的一种。<strong class="ih hj">狗</strong>有名字，有品种。它们通常有4条腿，所以默认情况下我已经包括在内了。</p><p id="7874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上所有代码都演示了伪经典继承。用子类型创建的对象从称为超类型的其他构造函数继承方法和属性。这种继承方式类似于典型的OOP语言使用类来实现继承。</p><p id="21bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">介绍<strong class="ih hj">爬行动物</strong>和<strong class="ih hj">豹壁虎</strong>构造器给了一个展示<strong class="ih hj">混合</strong>的机会。</p><p id="bc31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的<strong class="ih hj"> nocturnalMixin </strong>将允许我们将<strong class="ih hj"> isNocturnal </strong>属性添加到由我们选择的指定构造函数创建的对象中。</p><p id="82b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的具体例子中，<strong class="ih hj">豹皮壁虎</strong>是夜行动物，而<strong class="ih hj">猫</strong>是夜行动物，但<strong class="ih hj">狗</strong>不是。但它们都继承的唯一构造函数是动物。</p><p id="4f33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并非所有的动物都是夜间活动的。我们可以给所有这些不同种类的哺乳动物加上夜间活动的特性，但是这是重复的。而且我们不能在<strong class="ih hj">哺乳动物</strong>构造函数本身上定义它。更不用说不是所有的爬行动物都是夜间活动的。那么我们如何将它包含在我们的代码中呢？</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="7067" class="ju jv hi jq b fi jw jx l jy jz">Object.assign(Cat.prototype, nocturnalMixin);<br/>Object.assign(LeopardGecko.prototype, nocturnalMixin);</span></pre><p id="c5d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Object.assign() </strong>将属性和方法从源对象复制到目标对象。在这种情况下，我们将混合中的属性添加到<strong class="ih hj"> Cat.prototype </strong>对象和<strong class="ih hj"> LeopardGecko.prototype </strong>对象。</p><p id="7a95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在任何用<strong class="ih hj">猫</strong>或<strong class="ih hj">豹壁虎</strong>构造器创建的对象都将是夜间活动的，而我们的<strong class="ih hj">狗</strong>不受影响。我们可以放置任何其他原型对象来代替<strong class="ih hj"> Cat.prototype </strong>或<strong class="ih hj"> LeopardGecko.prototype </strong>。<strong class="ih hj"> Object.assign() </strong>的功能不仅限于mixins。</p><p id="3c4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解释这一点很重要，因为我们也在JavaScript ES6类中使用mix-in。</p><p id="d54c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们准备将构造函数转换成类。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="2207" class="ju jv hi jq b fi jw jx l jy jz">class Animal {<br/>  eat() {<br/>    console.log("I'm eating");<br/>  }<br/>  sleep() {<br/>    console.log("I'm sleeping")<br/>  }<br/>}</span><span id="e6c8" class="ju jv hi jq b fi ka jx l jy jz">class Mammal extends Animal {<br/>  constructor(legs) {<br/>    super();<br/>    this.legs = legs;<br/>    this.warmBlooded = true;<br/>   }<br/>   <br/>  giveLiveBirth() {<br/>    //ah yes what a miracle<br/>  }<br/>}</span><span id="96f3" class="ju jv hi jq b fi ka jx l jy jz">class Dog extends Mammal {<br/>  constructor(name, breed) {<br/>    super(4);<br/>    this.name = name;<br/>    this.breed = breed;<br/>  }<br/>}</span><span id="aa5c" class="ju jv hi jq b fi ka jx l jy jz">const nocturnalMixin = {<br/>  isNocturnal: true<br/>}</span><span id="320b" class="ju jv hi jq b fi ka jx l jy jz">class Cat extends Mammal {<br/>  constructor(name, breed) {<br/>    super(4);<br/>    this.name = name;<br/>    this.breed = breed;<br/>  }<br/>}</span><span id="a1df" class="ju jv hi jq b fi ka jx l jy jz">Object.assign(Cat.prototype, nocturnalMixin);</span><span id="870f" class="ju jv hi jq b fi ka jx l jy jz">let tito = new Cat("Tito", "American Shorthair");<br/>console.log(tito.isNocturnal);</span><span id="c568" class="ju jv hi jq b fi ka jx l jy jz">class Reptile extends Animal {<br/>  shed() {<br/>    console.log("I'm molting");<br/>  }<br/>}</span><span id="65a3" class="ju jv hi jq b fi ka jx l jy jz">class LeopardGecko extends Reptile {}</span><span id="be2b" class="ju jv hi jq b fi ka jx l jy jz">Object.assign(LeopardGecko.prototype, nocturnalMixin);</span><span id="124b" class="ju jv hi jq b fi ka jx l jy jz">let eco = new LeopardGecko()<br/>console.log(eco.isNocturnal);</span></pre><p id="2463" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不是用<strong class="ih hj"> Object.create() </strong>创建新的原型对象，而是用<strong class="ih hj"> extends </strong>关键字为我们处理这些。当一个类扩展另一个类时，它继承了在所需类的原型上定义的所有属性和方法。</p><p id="090a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也不必在它们的原型上定义我们的类方法，我们可以在类中包含我们的定义。重要的是要注意，要定义一个类的方法，我们必须使用关键字static，就像这样:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="b398" class="ju jv hi jq b fi jw jx l jy jz">class Computer {<br/>  static powerOn() {<br/>    console.log("beep boop");<br/>  }<br/>}</span></pre><p id="53d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类的最大区别之一是构造函数方法的使用。当我们使用类实例化一个新对象时，构造函数方法执行。JavaScript会自动完成这项工作。</p><p id="e291" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们并不总是需要定义一个<strong class="ih hj">构造函数()</strong>方法。当我们希望用该类创建的新对象具有某些属性时，或者当我们希望它在它所继承的构造函数中定义属性时，我们确实需要定义它。如果这两个条件都不成立，我们可以完全省略构造函数方法，就像我们对动物类所做的那样。</p><p id="14b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类的另一个大区别是在构造函数方法中使用了<strong class="ih hj"> super() </strong>函数。就像我说的，如果你试图继承的类没有构造函数，就没有必要包含构造函数。</p><p id="cf6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，如果父类确实有一个接受参数的构造函数，并且您希望用继承类创建的任何对象都在父类的构造函数方法上定义了属性(并分配给您提供的参数)，那么您将需要<strong class="ih hj"> super() </strong>函数。</p><p id="4f19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> super() </strong>，在构造函数方法内调用时，执行父类的构造函数。例如，如果我想让我的狗有4条腿并且是温血动物，我需要在我的<strong class="ih hj"> Dog </strong>类构造方法中调用<strong class="ih hj"> super() </strong>。或者，如果我想添加额外的属性，如名称和品种，我将需要调用<strong class="ih hj"> super() </strong>，并且我需要在定义名称和品种属性之前调用<strong class="ih hj"> super() </strong>，否则我将得到一个错误消息。</p><p id="3a42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于伪经典继承，当我们想要重用一个构造函数时，我们必须包含这个。例如在我们的<strong class="ih hj">狗</strong>构造函数中，我们调用了<strong class="ih hj">哺乳动物</strong>构造函数，并在<strong class="ih hj">中传递了这个</strong>和4。我们必须包含<strong class="ih hj">这个</strong>，因为我们想要指定<strong class="ih hj">哺乳动物</strong>构造函数是用新的<strong class="ih hj">狗</strong>对象作为其执行上下文来执行的。换句话说，我们想要一个新的<strong class="ih hj"> Dog </strong>对象，我们想要它有4条腿，所以我们指定provide <strong class="ih hj"> this </strong>作为<strong class="ih hj">哺乳动物. call() </strong>的执行上下文，然后我们提供<strong class="ih hj">哺乳动物</strong>构造函数所期望的参数，也就是腿。</p><p id="65c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> super() </strong>类似，但不需要我们输入<strong class="ih hj">这个</strong>作为自变量。执行上下文已经设置为正在创建的新对象。如果你试图添加这个作为参数，你会得到一个错误。</p><p id="8f8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的混合工作方式与第一个代码示例非常相似。我们使用<strong class="ih hj"> Object.assign() </strong>，将目标原型对象作为第一个参数传递，将源对象作为第二个参数传递。现在，从<strong class="ih hj"> LeopardGecko.prototype </strong>和<strong class="ih hj"> Cat.prototype </strong>继承的所有对象都将有一个<strong class="ih hj">is non turnal</strong>属性设置为true。</p></div></div>    
</body>
</html>