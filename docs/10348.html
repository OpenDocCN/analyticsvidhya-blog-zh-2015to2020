<html>
<head>
<title>Scala reminder: Gotta name an argument to use it twice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala 提醒:必须命名一个参数才能使用两次</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/scala-reminder-gotta-name-an-argument-to-use-it-twice-b00593c356b3?source=collection_archive---------28-----------------------#2020-10-14">https://medium.com/analytics-vidhya/scala-reminder-gotta-name-an-argument-to-use-it-twice-b00593c356b3?source=collection_archive---------28-----------------------#2020-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/43e53139adfe7199091f9cc2f205ae1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hyfwapj2nPjGIcjk"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">micha Parzuchowski 在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="60e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将是一篇短文。Scala 是一种非常强大的编程语言，语法非常简洁。问题是，我时常会忘记这个简洁语法的某些细节。比如说，你如何使用通配符两次？</p><p id="bbb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我曾经很快学会了如何使用通配符。例如:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="8a65" class="kc kd hi jy b fi ke kf l kg kh">scala&gt; LazyList.iterate(1: BigInt)(_ * 7)<br/>res0: scala.collection.immutable.LazyList[BigInt] = LazyList(&lt;not computed&gt;)</span></pre><p id="b28f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一对括号将 1 括起来作为一个<code class="du ki kj kk jy b">BigInt</code>。在第二对括号中，下划线通配符在第一次迭代中表示初始值(在本例中为 1)，在以后的迭代中表示由前一次迭代计算出的值。</p><p id="c1ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在本例中，通配符代表的值乘以整数 7。由于我通常认为理所当然的隐式转换，<code class="du ki kj kk jy b">Int</code>被转换为<code class="du ki kj kk jy b">BigInt</code>，并且由于“操作符重载”，我们可以使用乘法操作符来代替<code class="du ki kj kk jy b">multiply()</code>或<code class="du ki kj kk jy b">times()</code>或其他任何可能的名称。</p><p id="c457" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，第一次迭代产生 7，然后第二次迭代产生 49，以此类推。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="ff42" class="kc kd hi jy b fi ke kf l kg kh">scala&gt; res0.take(20).toList<br/>res1: List[BigInt] = List(1, 7, 49, 343, 2401, 16807, 117649, 823543, 5764801, 40353607, 282475249, 1977326743, 13841287201, 96889010407, 678223072849, 4747561509943, 33232930569601, 232630513987207, 1628413597910449, 11398895185373143)</span></pre><p id="dcbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复制并粘贴到<a class="ae iu" href="https://oeis.org/" rel="noopener ugc nofollow" target="_blank">OEIS 搜索框</a>，第一个结果应该是 A420，7 的幂。事实上这应该是唯一的结果。</p><p id="2697" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，有时您需要使用通配符两次。</p><p id="d38c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，考虑有时被认为是艾萨克·牛顿爵士提出的近似平方根的方法。通过“牛顿法”，我们从最初的猜测<em class="kl"> g </em> (0)开始逼近<em class="kl"> x </em>的平方根，我们通过公式<em class="kl">g</em>(<em class="kl">n</em>)=(<em class="kl">g</em>(<em class="kl">n</em>-1)+<em class="kl">x</em>/<em class="kl">g</em>(<em class="kl">n</em>-1))/2 逐步细化。</p><p id="4168" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，<em class="kl">g</em>(<em class="kl">n</em>-1)似乎是在迭代函数中两次使用通配符的<code class="du ki kj kk jy b">LazyList</code>迭代的完美选择。除了你不能在 Scala 中这样做。有些 Scala 表达式可以使用两个下划线通配符，但这不是其中之一。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="6055" class="kc kd hi jy b fi ke kf l kg kh">scala&gt; def newtonSqrt(x: Double, initGuess: Double): LazyList[Double] = LazyList.iterate(initGuess)((_ + x/_)/2)                                                                                             <br/>                                                ^             <br/>       <strong class="jy hj">error:</strong> missing parameter type for expanded function ((&lt;x$1: error&gt;, x$2) =&gt; x$1.$plus(x.$div(x$2)))<br/>                                                      ^<br/>       <strong class="jy hj">error:</strong> missing parameter type for expanded function ((&lt;x$1: error&gt;, &lt;x$2: error&gt;) =&gt; x$1.$plus(x.$div(x$2)))</span></pre><p id="64b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我必须给下划线通配符一个类型？听起来不太对劲。</p><p id="6b79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在谷歌上搜索了一番后，我看到了布兰登·奥康纳的 Scala 备忘单。</p><blockquote class="km kn ko"><p id="cef9" class="iv iw kl ix b iy iz ja jb jc jd je jf kp jh ji jj kq jl jm jn kr jp jq jr js hb bi translated"><code class="du ki kj kk jy b">(1 to 5).map(x =&gt; x * x)</code></p><p id="ceed" class="iv iw kl ix b iy iz ja jb jc jd je jf kp jh ji jj kq jl jm jn kr jp jq jr js hb bi translated">匿名函数:要使用一个[参数]两次，[你]必须给它命名。</p></blockquote><p id="a865" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">啊哈！我必须命名“通配符”，但我不必指定它的类型，这是由编译器推断出来的。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3df6" class="kc kd hi jy b fi ke kf l kg kh">scala&gt; def newtonSqrt(x: Double, initGuess: Double): LazyList[Double] = LazyList.iterate(initGuess)(g =&gt; (g + x/g)/2)<br/>newtonSqrt: (x: Double, initGuess: Double)LazyList[Double]</span></pre><p id="32e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧，看起来有用。但是证据在布丁里。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c513" class="kc kd hi jy b fi ke kf l kg kh">scala&gt; newtonSqrt(13.0, 4.0)<br/>res12: LazyList[Double] = LazyList(&lt;not computed&gt;)</span><span id="7094" class="kc kd hi jy b fi ks kf l kg kh">scala&gt; res12.take(20).toList<br/>res13: List[Double] = List(4.0, 3.625, 3.605603448275862, 3.6055512758414574, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896, 3.6055512754639896)</span><span id="76b0" class="kc kd hi jy b fi ks kf l kg kh">scala&gt; res13(19) * res13(19)<br/>res14: Double = 13.000000000000002</span></pre><p id="ac7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于类型为<code class="du ki kj kk jy b">Double</code>(Java 中的<code class="du ki kj kk jy b">double</code>)的 JUnit 中的<code class="du ki kj kk jy b">assertEquals()</code>，我一般使用 0.00001 的 delta。因此，13.0000000000002 对于该增量来说就足够了。</p><p id="033c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，你知道了。在 Scala 中，你不能总是使用下划线通配符，但有时你可以命名一个通配符并使用两次。</p></div></div>    
</body>
</html>