<html>
<head>
<title>Scraping YouTube Data using Python and Selenium to Classify Videos</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和Selenium抓取YouTube数据以对视频进行分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/scraping-youtube-data-using-python-and-selenium-to-classify-videos-89afde8381c4?source=collection_archive---------0-----------------------#2019-05-20">https://medium.com/analytics-vidhya/scraping-youtube-data-using-python-and-selenium-to-classify-videos-89afde8381c4?source=collection_archive---------0-----------------------#2019-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="c9f1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="c0be" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我是一个狂热的YouTube用户。我在一个平台上可以观看的内容数量惊人。事实上，我的许多<a class="ae kb" href="https://courses.analyticsvidhya.com/courses/introduction-to-data-science-2?utm_source=blog&amp;utm_medium=scraping-classifying-youtube-video-data-python-selenium" rel="noopener ugc nofollow" target="_blank">数据科学</a>学习都是通过YouTube视频进行的！</p><p id="6437" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">所以，几周前我在浏览YouTube，搜索某个类别来观看。这时，我的数据科学家思维过程开始了。鉴于我对网络抓取和机器学习的热爱，我能提取关于YouTube视频的数据并建立一个模型来将它们分类吗？</p><p id="c197" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我很好奇！这听起来像是将我现有的Python和数据科学知识与我学习新事物的好奇心相结合的绝佳机会。分析Vidhya的实习挑战让我有机会以文章的形式写下我的学习。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/2fc3fc6327db1822d337d55940985c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eee4-XXVIn0ygqJm.png"/></div></div></figure><p id="0bdf" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我觉得Web抓取是每个数据科学爱好者都应该知道的技能。当我们为我们的项目寻找数据或者想要分析只出现在网站上的特定数据时，它非常有用。请记住，网络抓取不应该跨越道德和法律的界限。</p><p id="5c61" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在本文中，我们将学习如何使用Selenium和Python通过web抓取来提取YouTube视频数据。然后，我们将使用NLTK库清理数据，然后建立一个模型，根据特定的类别对这些视频进行分类。</p><p id="5f60" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kt">你也可以使用不同的库查看下面的网页抓取教程:</em></p><ul class=""><li id="505d" class="ku kv hi jf b jg kc jk kd jo kw js kx jw ky ka kz la lb lc bi translated"><a class="ae kb" href="https://www.analyticsvidhya.com/blog/2015/10/beginner-guide-web-scraping-beautiful-soup-python/?utm_source=blog&amp;utm_medium=scraping-classifying-youtube-video-data-python-selenium" rel="noopener ugc nofollow" target="_blank"><em class="kt">Python网页抓取入门(使用BeautifulSoup) </em> </a></li><li id="f80e" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><a class="ae kb" href="https://www.analyticsvidhya.com/blog/2017/07/web-scraping-in-python-using-scrapy/?utm_source=blog&amp;utm_medium=scraping-classifying-youtube-video-data-python-selenium" rel="noopener ugc nofollow" target="_blank"><em class="kt">Web Scrapy在Python中使用Scrapy(附多个例子)</em> </a></li><li id="e681" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><a class="ae kb" href="https://www.analyticsvidhya.com/blog/2017/07/web-scraping-in-python-using-scrapy/?utm_source=blog&amp;utm_medium=scraping-classifying-youtube-video-data-python-selenium" rel="noopener ugc nofollow" target="_blank"><em class="kt">R中的网页抓取入门指南(使用rvest) </em> </a></li></ul><h1 id="925d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目录</h1><ol class=""><li id="ca60" class="ku kv hi jf b jg jh jk jl jo li js lj jw lk ka ll la lb lc bi translated">硒概述</li><li id="1d6d" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">我们的网络抓取项目的先决条件</li><li id="0c3a" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">设置Python环境</li><li id="e3b3" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">从YouTube抓取数据</li><li id="3777" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">使用NLTK库清理擦除的数据</li><li id="ba97" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">建立我们的模型来分类YouTube视频</li><li id="3e74" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">分析结果</li></ol><h1 id="0810" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">硒概述</h1><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lm"><img src="../Images/58b5a21695bbbfd6426084996461ae33.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*9X-Q6u4nTDqEajEQ.png"/></div></figure><p id="7708" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">Selenium是自动化浏览器的流行工具。它主要用于行业内的测试，但对于网页抓取也非常方便。如果你在IT领域工作过，你一定会遇到Selenium。</p><p id="055c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们可以使用Selenium轻松编写Python脚本来自动化web浏览器。它给了我们高效提取数据并以我们喜欢的格式存储以备将来使用所需的自由。</p><p id="aa71" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">Selenium需要一个驱动程序来与我们选择的浏览器接口。比如Chrome，需要ChromeDriver，需要在我们开始刮之前安装。Selenium web驱动程序使用浏览器自己的引擎控制它，直接与浏览器对话。这使得它非常快。</p><h1 id="9907" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">我们的网络抓取项目的先决条件</h1><p id="4469" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在进入网络抓取之前，有几件事我们必须知道:</p><ul class=""><li id="c9af" class="ku kv hi jf b jg kc jk kd jo kw js kx jw ky ka kz la lb lc bi translated">必须具备<strong class="jf hj"> HTML </strong>和<strong class="jf hj"> CSS </strong>的基础知识。我们需要这个来理解我们将要抓取的网页的结构</li><li id="dc48" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">需要Python 来清理数据、探索数据和构建模型</li><li id="0f8b" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">一些基础库的知识，如<strong class="jf hj"> Pandas </strong>和<strong class="jf hj"> NumPy </strong>将是蛋糕上的樱桃</li></ul><h1 id="5833" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">设置Python环境</h1><p id="2d0d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">是时候启动你最喜欢的Python IDE了(对我来说这就是Jupyter笔记本)！让我们动手开始编码吧。</p><p id="65d5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">步骤1: </strong>安装Python绑定:</p><pre class="ki kj kk kl fd ln lo lp lq aw lr bi"><span id="b953" class="ls ig hi lo b fi lt lu l lv lw">#Open terminal and type- <strong class="lo hj">$ pip install selenium</strong></span></pre><p id="68e3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">第二步:</strong>下载Chrome WebDriver:</p><p id="b9f7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">步骤3: </strong>将驱动文件移动到一个路径:</p><p id="2bbb" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">转到下载目录，解压缩文件，并将其移动到u <em class="kt"> sr/local/bin路径。</em></p><pre class="ki kj kk kl fd ln lo lp lq aw lr bi"><span id="bf27" class="ls ig hi lo b fi lt lu l lv lw"><strong class="lo hj">$ cd Downloads$ unzip chromedriver_linux64.zip$ mv chromedriver /usr/local/bin/</strong></span></pre><p id="6825" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们现在都准备好开始抓取网页了。</p><h1 id="5b6d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">从YouTube抓取数据</h1><p id="c988" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本文中，我们将从YouTube上搜集特定类别的视频ID、视频标题和视频描述。我们将收集的类别包括:</p><p id="030a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">所以让我们开始吧！</p><p id="a46e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">首先，让我们导入一些库:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><ul class=""><li id="334a" class="ku kv hi jf b jg kc jk kd jo kw js kx jw ky ka kz la lb lc bi translated">在我们做任何其他事情之前，请在浏览器中打开YouTube。键入您想要搜索视频的类别，并将过滤器设置为“视频”。这将只显示与您的搜索相关的视频。完成此操作后复制URL。</li><li id="03ad" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">接下来，我们需要设置驱动程序来从YouTube获取URL的内容:</li></ul><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><ul class=""><li id="b514" class="ku kv hi jf b jg kc jk kd jo kw js kx jw ky ka kz la lb lc bi translated">将链接粘贴到to driver.get(“您的链接在此”)函数中，然后运行单元格。这将为该链接打开一个新的浏览器窗口。我们将在此浏览器窗口中执行以下所有任务</li><li id="188d" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">获取该特定页面上的所有视频链接。我们将创建一个“列表”来存储这些链接</li><li id="4f5b" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">现在，转到浏览器窗口，右键单击页面，并选择“检查元素”</li><li id="e465" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">用id = "video-title "搜索锚标记，然后右键单击它-&gt; Copy -&gt; XPath。XPath应该类似于:<strong class="jf hj"> //*[@id="video-title"] </strong></li></ul><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lz"><img src="../Images/c24e079136c2c57444ac42f43d52931e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/0*8z0_FQA3QkELZGT1.png"/></div></figure><p id="686e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">跟我到目前为止？现在，编写下面的代码开始从页面获取链接并运行单元格。这将获取网页上的所有链接，并将其存储在一个列表中。</p><p id="e61d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj"> <em class="kt">注意:一路向下遍历加载该页面的所有视频。</em>T3】</strong></p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="3473" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上面的代码将获取我们搜索的锚标记的“href”属性。</p><p id="21a2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，我们需要创建一个包含4列的data frame——“<strong class="jf hj">链接</strong>”、“<strong class="jf hj">标题</strong>”、“<strong class="jf hj">描述</strong>”和“<strong class="jf hj">类别</strong>”。我们将在这些栏中存储不同类别视频的详细信息:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="8ec9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们已经准备好从YouTube上抓取视频细节。下面是实现这一点的Python代码:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="866b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们分解这个代码块来理解我们刚刚做了什么:</p><ul class=""><li id="dbd4" class="ku kv hi jf b jg kc jk kd jo kw js kx jw ky ka kz la lb lc bi translated">将忽略默认情况下在“直到”条件下遇到(抛出)的<strong class="jf hj">“等待”</strong> <em class="kt"> NotFoundException </em>的实例。它会立即传播所有其他的</li><li id="80a4" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">参数:</li><li id="a066" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj">驱动程序:</strong>要传递给预期条件的WebDriver实例</li><li id="3f0b" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj"> timeOutInSeconds: </strong>调用期望时的超时秒数</li><li id="eb0b" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj"> v_category </strong>存储我们之前搜索的视频类别名称</li><li id="17a4" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">“for”循环应用于我们上面创建的链接列表</li><li id="2ae7" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj"> driver.get(x) </strong>逐个遍历所有链接，并在浏览器中打开它们以获取详细信息</li><li id="16b5" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj"> v_id </strong>存储从链接中剥离的视频id</li><li id="8f17" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj"> v_title </strong>存储使用CSS路径获取的视频标题</li><li id="57e2" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">类似地，<strong class="jf hj"> v_description </strong>通过使用CSS路径存储视频描述</li></ul><p id="5ac3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在每次迭代中，我们的代码将提取的数据保存在我们之前创建的dataframe中。</p><p id="669a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">对于其余五个类别，我们必须遵循上述步骤。一旦我们完成这个，我们应该有六个不同的数据帧。现在，是时候将它们合并成一个数据框架了:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="7b5a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">瞧啊。我们有我们的最终数据帧，包含所有上述所有类别的视频所需的细节。</p><h1 id="d34f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">使用NLTK库清理擦除的数据</h1><p id="762a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这一节中，我们将使用流行的NLTK库来清理“title”和“description”列中的数据。NLP爱好者会喜欢这个部分的！</p><p id="175c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在我们开始清理数据之前，我们需要分别存储所有的列，以便我们可以快速方便地执行不同的操作:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="58ba" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">首先导入所需的库:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="996b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，创建一个列表，我们可以在其中存储我们清理的数据。稍后我们将把这些数据存储在一个数据帧中。编写以下代码来创建一个列表，并对来自<strong class="jf hj"> <em class="kt"> df_title: </em> </strong>的“<strong class="jf hj"> title </strong>”列进行一些数据清理</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="f419" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">你看到我们做了什么吗？我们去掉了标题中的所有标点符号，只保留了英文词根。在所有这些迭代之后，我们已经准备好了我们的数据列表。</p><p id="1b73" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们需要按照同样的步骤从<strong class="jf hj">中清除<strong class="jf hj">描述</strong>列<em class="kt"> df_description </em> : </strong></p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="2de3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kt">注意:范围根据我们数据集中的行选择。</em></p><p id="1822" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，将这些列表转换为数据帧:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="8a9f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">接下来，我们需要对类别进行标签编码。函数的作用是:用一个介于0和n _ classes之间的值对标签进行编码，其中n是不同标签的数目。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="cc96" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这里，我们对<em class="kt"> df_category </em>应用了标签编码，并将结果存储到<em class="kt"> dfcategory </em>中。我们可以将经过清理和编码的数据存储到新的数据框架中:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="54b6" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们在清洁和转型方面的工作还没有完全完成。</p><p id="a6d3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们应该创建一个单词袋，这样我们的模型就可以理解来自该袋的关键词，从而对视频进行相应的分类。下面是创建一个单词包的代码</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="7733" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kt">注意:在这里，我们从存储在列表中的数据创建了1500个特征——语料库和corpus1。“X”存储所有特征，“y”存储我们的编码数据。</em></p><p id="4909" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们都已做好准备，迎接数据科学家角色中最令人期待的部分—建立模型！</p><h1 id="f561" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">构建我们的模型对YouTube视频进行分类</h1><p id="5b86" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在构建模型之前，我们需要将数据分为训练集和测试集:</p><ul class=""><li id="9824" class="ku kv hi jf b jg kc jk kd jo kw js kx jw ky ka kz la lb lc bi translated"><strong class="jf hj">训练集:</strong>训练我们模型的数据子集</li><li id="d19d" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj">测试集:</strong>包含对训练好的模型进行测试的剩余数据</li></ul><p id="b1f6" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">确保测试集满足以下两个条件:</p><ul class=""><li id="6ba3" class="ku kv hi jf b jg kc jk kd jo kw js kx jw ky ka kz la lb lc bi translated">足够大以产生统计上有意义的结果</li><li id="3beb" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">表示整个数据集。换句话说，不要挑选与训练集具有不同特征的测试集</li></ul><p id="f1c8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们可以使用以下代码来拆分数据:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="0348" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">是时候训练模型了！这里我们将使用<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2016/04/complete-tutorial-tree-based-modeling-scratch-in-python/?utm_source=blog&amp;utm_medium=scraping-classifying-youtube-video-data-python-selenium" rel="noopener ugc nofollow" target="_blank">随机森林算法</a>。因此，让我们继续使用RandomForestClassifier()函数来训练这个模型:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="7443" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">参数:</p><ul class=""><li id="6c86" class="ku kv hi jf b jg kc jk kd jo kw js kx jw ky ka kz la lb lc bi translated"><strong class="jf hj">n _ estimates</strong>森林中的树木数量</li><li id="8c11" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj">准则</strong>:衡量拆分质量的功能。支持的标准是基尼不纯的“基尼”和信息增益的“熵”</li></ul><p id="39bd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kt">注意:这些参数是特定于树的。</em></p><p id="83e7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，我们可以在测试集上检查模型的性能:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="e4ef" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">准确率高达96.05%。</strong>我们的整个过程进行得相当顺利！但我们还没有完成——我们还需要分析我们的结果，以便充分了解我们取得了哪些成就。</p><h1 id="bae5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">分析结果</h1><p id="fe21" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们检查分类报告:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ma"><img src="../Images/85cadecc74ba586dc150c44b3a0bf5e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jOn56R5bbkMjyXw0.png"/></div></div></figure><p id="4d23" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">结果将给出以下属性:</p><ul class=""><li id="6cca" class="ku kv hi jf b jg kc jk kd jo kw js kx jw ky ka kz la lb lc bi translated"><strong class="jf hj">精度</strong>是正确预测的正观测值与总预测正观测值之比。精度= TP/TP+FP</li><li id="fb75" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj">回忆</strong>是正确预测的正面观察值与实际类中所有观察值的比率。召回= TP/TP+FN</li><li id="f1bc" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj"> F1得分</strong>是准确率和召回率的加权平均值。因此，这个分数同时考虑了误报和漏报。F1得分= 2*(召回率*精确度)/(召回率+精确度)</li></ul><p id="66e8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们也可以通过创建混淆矩阵来检查我们的结果:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lx ly l"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mb"><img src="../Images/63b0377f08bb6c3c83f17862c09cf7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/0*cRzZjjCYHJtwft0S.png"/></div></div></figure><p id="9eb5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">混淆矩阵将是一个6×6的矩阵，因为我们的数据集中有六个类。</p><h1 id="395f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结束注释</h1><p id="7b61" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我一直想把我对抓取和提取数据的兴趣与NLP和机器学习结合起来。所以我喜欢让自己沉浸在这个项目中，写下我的方法。</p><p id="b57a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在本文中，我们见证了Selenium作为web抓取工具的潜力。本文使用的所有代码都是<a class="ae kb" href="https://github.com/shubham-singh-ss/Youtube-scraping-using-Selenium/tree/master" rel="noopener ugc nofollow" target="_blank">随机森林算法</a>恭喜你成功抓取并创建了一个数据集对视频进行分类！</p><p id="e451" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我期待听到您对本文的想法和反馈。</p><p id="2243" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">你也可以在分析Vidhya的Android应用上阅读这篇文章</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mc"><img src="../Images/8b480f0489599ba8a5ad6669666bce5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/0*45syZIdSvAWwhjMH.png"/></div></div></figure></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="9a60" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kt">原载于2019年5月20日</em><a class="ae kb" href="https://www.analyticsvidhya.com/blog/2019/05/scraping-classifying-youtube-video-data-python-selenium/" rel="noopener ugc nofollow" target="_blank"><em class="kt">https://www.analyticsvidhya.com</em></a><em class="kt">。</em></p></div></div>    
</body>
</html>