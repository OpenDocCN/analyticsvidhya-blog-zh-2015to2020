<html>
<head>
<title>Basics of K-Nearest Neighbour Classifier: Illustrations with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K-最近邻分类器的基础:用Python举例说明</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/topics-in-machine-learning-4edffd79237f?source=collection_archive---------17-----------------------#2019-12-05">https://medium.com/analytics-vidhya/topics-in-machine-learning-4edffd79237f?source=collection_archive---------17-----------------------#2019-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="23cb" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">机器学习专题</h2></div><h2 id="3e82" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><strong class="ak">简介</strong></h2><p id="ea1b" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">在机器学习(ML)中，关键的一点是，不存在适用于所有数据集的<strong class="jx hj"><em class="ko"/></strong>完美算法。每个算法都有一些<strong class="jx hj"> <em class="ko">假设</em> </strong>。了解这些假设很重要，这样我们才能知道何时应用不同的ML算法。今天，我们将尝试理解一种称为K -最近邻(KNN)的ML算法的假设和原理。</p><h2 id="1fa3" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><strong class="ak">直觉</strong></h2><p id="f1f8" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">在探索技术细节之前，我们将试图理解KNN背后的直觉。我们将通过玩一个叫做<strong class="jx hj"> <em class="ko">的游戏来识别职业</em> </strong>来做到这一点。这个游戏的目标和规则如下:</p><blockquote class="kp kq kr"><p id="977f" class="jv jw ko jx b jy ks ij ka kb kt im kd ku kv kf kg kw kx ki kj ky kz kl km kn hb bi translated">目标:确定A和b两个人的职业。</p><p id="7bb4" class="jv jw ko jx b jy ks ij ka kb kt im kd ku kv kf kg kw kx ki kj ky kz kl km kn hb bi translated">规则:你只知道A和B花费最多时间的五个人的职业。</p></blockquote><p id="5b42" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">让我们想出一个算法来识别他们的职业。</p><div class="la lb lc ld fd ab cb"><figure class="le lf lg lh li lj lk paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/850bf92c8ae1f698cd5d9cead32e8cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*A-AieXBtNsraZY6Mi2EF7Q.jpeg"/></div></figure><figure class="le lf lr lh li lj lk paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/051b2e620b2954d66bcfb9315d232952.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*ZNlpxKkcIo4rz8tyKf0KhQ.jpeg"/></div><figcaption class="ls lt et er es lu lv bd b be z dx lw di lx ly translated">图1:辨别A和b的职业。</figcaption></figure></div><p id="57da" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">我们将采用吉米·罗恩的模式来解决这个问题。</p><figure class="la lb lc ld fd lf er es paragraph-image"><div class="er es lz"><img src="../Images/9ff3f368c4de6cd6f0b96f9639cbd41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*O7J5H1icW7yqoz3zTBvWBg.jpeg"/></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图2:来源:<a class="ae ma" href="https://candicelatham.com/friends-inspire-me/" rel="noopener ugc nofollow" target="_blank">https://candicelatham.com/friends-inspire-me/</a></figcaption></figure><p id="2388" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">在这个模型中，我们试图根据A和B相处时间最长的五个朋友的职业对A和B的职业进行分类。A的前五个朋友大部分都是科学家。因此，我们把A的职业归类为科学家。同样，B的前五大好友中，绝大多数都是警察工作人员。所以我们把B的职业归类为警察。我们可以把这个量词命名为<strong class="jx hj"><em class="ko"/></strong>。</p><h2 id="6a9b" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">假设</h2><p id="66cc" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">记住每个模型都有一些假设，没有一个模型是完美的。最近朋友分类器中使用的假设是什么？如果我们假设每个人的职业为一个数据实例，那么我们就是假设<strong class="jx hj"> <em class="ko">相似的数据实例有相似的标签</em> </strong>。基于这个假设，我们将A的职业分类为科学家，B的职业分类为警察。</p><h2 id="f552" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">我们为什么选择这种模式？</h2><p id="57f5" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">我们选择这个模型的一个原因是通过观察数据集(即A和B的五个朋友的信息)。我们可以在这个数据集中看到一个模式，即A和B的朋友的职业相似。所以选择这个模型纯粹是基于数据，而不是任意的。在这两种情况下，我们对A和b的职业分类有很高的信心。现在考虑一个第三人C<strong class="jx hj"><em class="ko"/></strong>，他是一名<strong class="jx hj">法医科学家</strong> ( <em class="ko">一名法医科学家同时与科学家和警方人员</em>混在一起)。如果再玩一次游戏会怎么样？</p><p id="603e" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">能不能把C这个人分类正确？这个问题的答案取决于与C相处时间最长的五个人的职业。如果五个人中有三个是科学家，两个是警察，那么我们把C归类为科学家。另一方面，如果C的三个朋友是警察，两个是科学家，那么我们把C的职业归类为警察。注意，在A和B的情况下，职业分类的置信度很高，而在C的情况下，置信度降低。</p><h2 id="521a" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">KNN分类器</h2><p id="0ab1" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">KNN还假设<strong class="jx hj"> <em class="ko">相似的点(数据实例)有相似的标号。</em> </strong>现在我们将进入算法的细节。</p><p id="b8f1" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">让我们考虑一个二元分类任务，对圆和十字进行分类。</p><figure class="la lb lc ld fd lf er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mb"><img src="../Images/2c0e6c5e93fc80791e1c978a7e83e9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2g9C2f_xlsCkG5WB5-3ZA.png"/></div></div></figure><p id="6af1" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">训练数据和标签来自概率分布<strong class="jx hj"> <em class="ko"> P </em> </strong>。我们只有这个分布的一些数据实例。我们不知道实际的分布情况。让数据集<strong class="jx hj"> <em class="ko"> D </em> </strong>如下:</p><figure class="la lb lc ld fd lf er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mc"><img src="../Images/6e3aa96df902608bcd563eab097a5802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_ylLEhGoPe4IUye9Qm6oQ.png"/></div></div></figure><h2 id="a5e7" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">算法</h2><p id="1a11" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated"><strong class="jx hj"> <em class="ko">目标:给定一个测试数据实例，找出其k个最近的训练数据实例的最常见标签。将最常用的标签指定为测试数据的标签。</em>T15】</strong></p><p id="94c3" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated"><em class="ko">第一步:</em>选择<strong class="jx hj"> <em class="ko"> k </em> </strong>的值。<strong class="jx hj"> <em class="ko"> k </em> </strong>代表最近邻的个数。<strong class="jx hj"> <em class="ko"> k </em> </strong>是一个超参数，必须通过交叉验证来确定。<strong class="jx hj"> <em class="ko"> k </em> </strong>的值是奇数。</p><p id="122e" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated"><em class="ko">步骤2: </em>定义KNN使用的距离度量</p><p id="a214" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">KNN的分类输出依赖于距离度量。常用的距离度量是<strong class="jx hj"> <em class="ko">闵可夫斯基距离。</em> </strong>闵可夫斯基距离定义如下:</p><figure class="la lb lc ld fd lf er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es md"><img src="../Images/72dc5a6db896c9505bb50363f7e39fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdLFuOlTPDHz5K0BTRbyow.png"/></div></div></figure><p id="a14c" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated"><strong class="jx hj"> <em class="ko"> x </em> </strong>和<strong class="jx hj"> <em class="ko"> z </em> </strong>是长度<strong class="jx hj"> <em class="ko"> r </em> </strong>的向量。</p><ol class=""><li id="5b82" class="me mf hi jx b jy ks kb kt ji mg jm mh jq mi kn mj mk ml mm bi translated">当<strong class="jx hj"> <em class="ko"> p = 1时，dist(x，z) </em> </strong>为曼哈顿距离(L1范数)，</li><li id="39fb" class="me mf hi jx b jy mn kb mo ji mp jm mq jq mr kn mj mk ml mm bi translated">当<strong class="jx hj"> <em class="ko"> p = 2 </em> </strong>，<strong class="jx hj"> <em class="ko"> dist(x，z) </em> </strong>就是欧氏距离(L2-范数)。</li><li id="c9c7" class="me mf hi jx b jy mn kb mo ji mp jm mq jq mr kn mj mk ml mm bi translated"><strong class="jx hj"> <em class="ko"> p </em> </strong>也是一个超参数，必须通过交叉验证来选择。</li></ol><p id="1ea5" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated"><em class="ko">第三步:</em>考虑单个测试数据实例<strong class="jx hj"> <em class="ko"> z </em> </strong>。计算<strong class="jx hj"> <em class="ko"> z </em> </strong>到其最近的<strong class="jx hj"> <em class="ko"> k </em> </strong>训练实例的距离。</p><figure class="la lb lc ld fd lf er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es ms"><img src="../Images/1f27217351470164daf924f1b315ea92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w00AbFQcxIMgOkTyugHx6g.png"/></div></div></figure><figure class="la lb lc ld fd lf er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mt"><img src="../Images/a394a0b55cfe75fc99f342ea343ec7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Y41hh2X_s1vl6SD9LWZvw.png"/></div></div></figure><p id="175f" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated"><strong class="jx hj"> <em class="ko"> Sx </em> </strong>是训练集<strong class="jx hj"> <em class="ko"> D. Sx </em> </strong>由<strong class="jx hj"> <em class="ko"> k </em>训练<em class="ko"> </em>数据实例</strong>和测试数据实例<strong class="jx hj"> <em class="ko"> z </em> </strong>组成。测试数据实例<strong class="jx hj"> <em class="ko"> z </em> </strong>距<strong class="jx hj"><em class="ko"/></strong>D<strong class="jx hj"><em class="ko">Sx</em></strong>中数据实例的距离大于或等于测试数据实例<strong class="jx hj"><em class="ko"/></strong>z<strong class="jx hj"><em class="ko">Sx</em></strong>中数据实例的距离。这是因为<strong class="jx hj"><em class="ko"/></strong>Sx由测试数据实例z的<strong class="jx hj"> <em class="ko"> k个最近邻居组成，第k+1个邻居比第k个邻居</em></strong>【1】<strong class="jx hj"><em class="ko">更远。</em>T49】</strong></p><p id="5c31" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated"><em class="ko">第四步:</em>测试数据实例的分类——从集合<strong class="jx hj"> <em class="ko"> Sx </em> </strong>中选择最频繁出现的标签作为测试数据实例的标签<strong class="jx hj"> <em class="ko"> z. </em> </strong></p><h2 id="cac2" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">玩具示例</h2><p id="ecb3" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated"><strong class="jx hj"> <em class="ko">数据集生成</em> </strong></p><p id="223a" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">我们将创建一个圆圈和十字的数据集。我们将使用python来生成和绘制数据集。</p><figure class="la lb lc ld fd lf"><div class="bz dy l di"><div class="mu mv l"/></div></figure><figure class="la lb lc ld fd lf er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mw"><img src="../Images/d7d9cae4f06543e020fd9701a68ce038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VfjToDwxT-rnDOn-FMgbRA.jpeg"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图3:具有两个特征f1和f2的数据集。</figcaption></figure><p id="562b" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated"><strong class="jx hj"> <em class="ko">三重交叉验证和超参数调整</em> </strong></p><p id="a969" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">数据集随机分为训练集和测试集。训练数据被进一步分成训练集和验证集。现在，我们进行三重交叉验证，以找到最佳的<strong class="jx hj"> <em class="ko"> k </em> </strong>值。</p><p id="31d0" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated"><strong class="jx hj"> <em class="ko">需要注意的是，测试数据应该只访问一次</em> </strong>。我们不应该通过反复测试测试数据来修正超参数。超参数的选择必须基于验证集的性能。一旦确定了超参数，就使用完整的训练集重新训练该模型，并将该模型应用于测试集。测试集只需要被访问一次。这部分在所有机器学习算法中都是一样的。</p><figure class="la lb lc ld fd lf er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mx"><img src="../Images/122c9d44af741661622dc64f59beaa3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*xVgRmzblHnWRtsI_4_YBnA.jpeg"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图4:交叉验证</figcaption></figure><p id="c0f6" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated"><strong class="jx hj"> <em class="ko">将数据集拆分成训练和测试</em> </strong></p><figure class="la lb lc ld fd lf"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="41d2" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated"><strong class="jx hj"> <em class="ko"> KNN主要功能</em> </strong></p><figure class="la lb lc ld fd lf"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="23f8" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated"><strong class="jx hj"> <em class="ko">固定k的三重交叉验证</em> </strong></p><p id="0098" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">在这个例子中，我们只做交叉验证来确定最佳值<strong class="jx hj"><em class="ko"/></strong>我们已经确定了值<strong class="jx hj"> <em class="ko"> p </em> </strong>为2。理想情况下，<strong class="jx hj"> <em class="ko"> p </em> </strong>的值也必须通过交叉验证来固定。</p><figure class="la lb lc ld fd lf"><div class="bz dy l di"><div class="mu mv l"/></div></figure><figure class="la lb lc ld fd lf er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es my"><img src="../Images/10ab4399cd12744dad023ab64a3cbe0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uk2JqFpKG-WW1Wi77IY3Ag.jpeg"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图5:使用三重交叉验证为KNN选择k值。</figcaption></figure><p id="ed97" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">在超参数调整过程中，<strong class="jx hj"> <em class="ko"> k = 11 </em> </strong>给出了最好的<a class="ae ma" href="https://en.wikipedia.org/wiki/F1_score" rel="noopener ugc nofollow" target="_blank"> F1值</a>。</p><h2 id="2a0e" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">用全部训练数据进行再训练，并应用该模型对测试数据进行分类</h2><figure class="la lb lc ld fd lf"><div class="bz dy l di"><div class="mu mv l"/></div></figure><h2 id="0e7a" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">评估指标</h2><figure class="la lb lc ld fd lf"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="e479" class="pw-post-body-paragraph jv jw hi jx b jy ks ij ka kb kt im kd ji kv kf kg jm kx ki kj jq kz kl km kn hb bi translated">在本教程中，我们试图从头开始编写KNN代码。为了更快地实现，我们可以使用<a class="ae ma" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a> [2】。</p><h2 id="a3f2" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">参考</h2><ol class=""><li id="75ac" class="me mf hi jx b jy jz kb kc ji mz jm na jq nb kn mj mk ml mm bi translated">康奈尔CS4780《智能系统的机器学习》”<em class="ko">YouTube【www.youtube.com/playlist?】、YouTube、<a class="ae ma" href="http://www.youtube.com/playlist?list=PLl8OlHZGYOQ7bkVbuRthEsaLr7bONzbXS." rel="noopener ugc nofollow" target="_blank">list = pl l8 olhzgyoq 7 bkvburthesalr 7 bonzbxs。</a></em></li><li id="f4b3" class="me mf hi jx b jy mn kb mo ji mp jm mq jq mr kn mj mk ml mm bi translated">彼得雷戈萨，法比安，等着，〈sci kit-learn:Python中的机器学习〉。<em class="ko">机器学习研究杂志</em> 12。2011年10月:2825–2830。</li></ol></div></div>    
</body>
</html>