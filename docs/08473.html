<html>
<head>
<title>Statistical Arbitrage with Pairs Trading and Backtesting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有配对交易和回溯测试的统计套利</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/statistical-arbitrage-with-pairs-trading-and-backtesting-ec657b25a368?source=collection_archive---------0-----------------------#2020-07-31">https://medium.com/analytics-vidhya/statistical-arbitrage-with-pairs-trading-and-backtesting-ec657b25a368?source=collection_archive---------0-----------------------#2020-07-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="4542" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">统计套利(Stat Arb)是一种交易策略，通常利用股价的均值回归或市场微观结构异常创造的机会。这是一种高度量化的分析方法，涉及非常多样化的证券投资组合。然而，为了说明这个概念，我将以仅涉及两个共同整合证券的配对交易为例。</p><p id="ff0b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">配对交易是一种市场中立的策略，我们使用统计技术来识别两只历史上高度相关的股票。当这些股票的价格关系出现偏差时，我们预计这是均值回归，买入表现不佳的股票，同时卖出表现优异的股票。如果我们的均值回归假设是有效的，那么价格应该收敛到长期平均水平，贸易应该受益。然而，如果价格差异不是暂时的，而是由于结构性原因，那么亏损的风险就很高。你可以在我的<a class="ae jk" href="https://github.com/sabirjana/blog/tree/master/Pair_Trading" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> Github </strong> </a>页面找到本文用到的Python笔记本和数据。本文遵循的总体方法如下所述:</p><ol class=""><li id="f642" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">股票论域和股票协整对的识别。</li><li id="e7e7" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">对选定的线对进行静态测试。</li><li id="8913" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用z值生成交易信号。</li><li id="6ef7" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">投资组合损益计算。</li></ol></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="084f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">股票领域和股票协整对的识别</strong></p><p id="69d8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的第一步是确定股票领域，并确定具有高相关性的股票对。这是非常重要的，这是基于经济关系，如具有类似业务的公司，否则它可能是虚假的。我已经将NSE-100的所有成分归类为“金融服务”公司。这给了我们一份25家公司的名单。然而，我们过滤掉日定价数据少于10年的公司，只剩下最后15只股票。我们取这15只股票的每日收盘价，并将数据框架分成测试集和训练集。这是为了确保我们选择协整对的决定是基于训练数据集，并且回测是使用样本外测试数据集完成的。作为第一步，我们将使用<a class="ae jk" href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient" rel="noopener ugc nofollow" target="_blank">皮尔逊相关系数</a>来获得这些股票之间关系的基本概念，然后使用函数<code class="du jz ka kb kc b">coint</code> form <code class="du jz ka kb kc b">statsmodels.tsa.stattools </code>来识别协整股票。函数<code class="du jz ka kb kc b">coint,</code>将返回每一对的协整检验的p值。我们将这些p值存储在一个数组中，并将其可视化为热图。如果p值低于0.05，这意味着我们可以拒绝零假设，不同符号的两个时间序列可以进行协整。</p><p id="eba7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们直接跳到代码:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="33a5" class="kl km hi kc b fi kn ko l kp kq"># make the necessary imports<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>import datetime<br/>idx = pd.IndexSlice<br/>import statsmodels.api as sm</span><span id="05a8" class="kl km hi kc b fi kr ko l kp kq">from statsmodels.regression.linear_model import OLS<br/>from statsmodels.tsa.stattools import adfuller<br/>from statsmodels.tsa.stattools import coint<br/>from sklearn.model_selection import train_test_split</span><span id="7dd5" class="kl km hi kc b fi kr ko l kp kq">%matplotlib inline<br/>%config InlineBackend.figure_format = ‘retina’</span><span id="0210" class="kl km hi kc b fi kr ko l kp kq"># read the matadata csv<br/>nifty_meta = pd.read_csv('data/nifty_meta.csv')<br/>nifty_meta.head(2)</span><span id="1779" class="kl km hi kc b fi kr ko l kp kq"># get the ticker list with industry is equal to FINANCIAL SERVICES<br/>tickers = list(nifty_meta[nifty_meta.Industry=='FINANCIAL SERVICES'].Symbol)<br/>print(tickers)<br/>print(len(tickers))</span><span id="e9eb" class="kl km hi kc b fi kr ko l kp kq"># start and end dates for backtesting<br/>fromdate = datetime.datetime(2010, 1, 1)<br/>todate = datetime.datetime(2020, 6, 15)</span><span id="e108" class="kl km hi kc b fi kr ko l kp kq"># read back the pricing data<br/>prices = pd.read_csv('data/prices.csv', index_col=['ticker','date'], parse_dates=True)<br/>prices.head(2)</span><span id="ee65" class="kl km hi kc b fi kr ko l kp kq"># remove tickers where we have less than 10 years of data.<br/>min_obs = 2520<br/>nobs = prices.groupby(level='ticker').size()<br/>keep = nobs[nobs&gt;min_obs].index</span><span id="e3f6" class="kl km hi kc b fi kr ko l kp kq">prices = prices.loc[idx[keep,:], :]<br/>prices.info()</span><span id="c287" class="kl km hi kc b fi kr ko l kp kq"># final tickers list<br/>TICKERS = list(prices.index.get_level_values('ticker').unique())<br/>print(len(TICKERS))<br/>print(TICKERS)</span><span id="9225" class="kl km hi kc b fi kr ko l kp kq"># unstack and take close price<br/>close = prices.unstack('ticker')['close'].sort_index()<br/>close = close.dropna()<br/>close.head(2)</span><span id="a255" class="kl km hi kc b fi kr ko l kp kq"># train test split <br/>train_close, test_close = train_test_split(close, test_size=0.5, shuffle=False)</span><span id="ee4b" class="kl km hi kc b fi kr ko l kp kq"># quick view of head and tail of train set<br/>train_close.head(2).append(train_close.tail(2))</span><span id="7525" class="kl km hi kc b fi kr ko l kp kq"># Pearson correlation to get the basic idea about the relationship<br/>fig, ax = plt.subplots(figsize=(10,7))<br/>sns.heatmap(train_close.pct_change().corr(method ='pearson'), ax=ax, cmap='coolwarm', annot=True, fmt=".2f") #spearman<br/>ax.set_title('Assets Correlation Matrix')<br/>plt.savefig('images/chart1', dpi=300)</span><span id="c975" class="kl km hi kc b fi kr ko l kp kq"># function to find cointegrated pairs<br/>def find_cointegrated_pairs(data):<br/>    n = data.shape[1]<br/>    pvalue_matrix = np.ones((n, n))<br/>    keys = data.keys()<br/>    pairs = []<br/>    for i in range(n):<br/>        for j in range(i+1, n):<br/>            result = coint(data[keys[i]], data[keys[j]])<br/>            pvalue_matrix[i, j] = result[1]<br/>            if result[1] &lt; 0.05:<br/>                pairs.append((keys[i], keys[j]))<br/>    return pvalue_matrix, pairs</span><span id="a119" class="kl km hi kc b fi kr ko l kp kq"># calculate p-values and plot as a heatmap<br/>pvalues, pairs = find_cointegrated_pairs(train_close)<br/>print(pairs)<br/>fig, ax = plt.subplots(figsize=(10,7))<br/>sns.heatmap(pvalues, xticklabels = train_close.columns,<br/>                yticklabels = train_close.columns, cmap = 'RdYlGn_r', annot = True, fmt=".2f",<br/>                mask = (pvalues &gt;= 0.99))<br/>ax.set_title('Assets Cointregration Matrix p-values Between Pairs')<br/>plt.tight_layout()<br/>plt.savefig('images/chart2', dpi=300)</span></pre><p id="52ad" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="60d4" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">我们对python库进行必要的导入。</li><li id="0a32" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">接下来，我们阅读<code class="du jz ka kb kc b">nifty_meta.csv</code>并创建一个行业为“金融服务”的报价机列表，并设置开始和结束日期。</li><li id="c2c2" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">从<code class="du jz ka kb kc b">prices.csv</code>读取每日价格数据，并删除我们不到10年的数据。</li><li id="1b87" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">拆分定价数据框架，使其仅包含每日收盘数据，并将其分成50%的训练和测试数据集。</li><li id="cbf1" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">画出每日收益的皮尔逊相关图，以获得关系的基本概念。</li><li id="dd61" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">定义一个函数<code class="du jz ka kb kc b">find_cointegrated_pairs</code>来寻找协整对和相应的p值。</li><li id="440c" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">绘制p值的热图。</li></ol><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ks"><img src="../Images/1910541a1c28a2b94a846f18d985a987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNsmwGSgofPL5d-9f7pO6w.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">每日收益的皮尔逊相关性</figcaption></figure><p id="a99b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">皮尔逊相关系数在+1到-1之间变化，是两个变量之间关系的线性度量。值+1表示强正相关，0表示没有关系，而-1表示强负相关。我们可以在上面的热图中看到，有多对具有很强的正相关性。</p><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es le"><img src="../Images/6c5b5021fb68c2d7d4c7d8c7158d02d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4KE5TRwJ_i6PXgozPJvXQg.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">资产对之间的协整矩阵p值</figcaption></figure><p id="e9e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们也来分析一下协整检验的结果。我们可以在上面的热图中看到，有很多p值小于0.05的对。这意味着，对于这些对，我们可以拒绝零假设，他们可以协整。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="94f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">对所选对进行静态测试</strong></p><p id="03ee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，对于p值小于0.05的策略，我们有许多候选对。选择正确的组合至关重要，因为如果价格完全一致，这种策略就不会奏效。他们需要分化和均值回归，我们的战略才能盈利。</p><p id="f0b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们来看看BANKBARODA和SBIN，并使用扩展的Dickey-Fuller测试进一步测试利差的平稳性。重要的是传播是稳定的。如果均值和方差等参数不随时间变化，并且没有<a class="ae jk" href="https://en.wikipedia.org/wiki/Unit_root" rel="noopener ugc nofollow" target="_blank">单位根</a>，则认为时间序列是平稳的。我们将首先使用OLS回归计算这两个报价机之间的套期保值比率。然后，使用套期保值比率，我们将计算利差，并运行扩展的Dickey-Fuller测试。</p><p id="212b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看一下代码:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="db34" class="kl km hi kc b fi kn ko l kp kq"># final pair to test strategy<br/>asset1 = ‘BANKBARODA’<br/>asset2 = ‘SBIN’</span><span id="acb5" class="kl km hi kc b fi kr ko l kp kq"># create a train dataframe of 2 assets<br/>train = pd.DataFrame()<br/>train['asset1'] = train_close[asset1]<br/>train['asset2'] = train_close[asset2]</span><span id="e3d8" class="kl km hi kc b fi kr ko l kp kq"># visualize closing prices<br/>ax = train[['asset1','asset2']].plot(figsize=(12, 6), title = 'Daily Closing Prices for {} and {}'.format(asset1,asset2))<br/>ax.set_ylabel("Closing Price")<br/>ax.grid(True);<br/>plt.savefig('images/chart3', dpi=300)</span><span id="ecd6" class="kl km hi kc b fi kr ko l kp kq"># run OLS regression<br/>model=sm.OLS(train.asset2, train.asset1).fit()</span><span id="5ff9" class="kl km hi kc b fi kr ko l kp kq"># print regression summary results<br/>plt.rc('figure', figsize=(12, 7))<br/>plt.text(0.01, 0.05, str(model.summary()), {'fontsize': 16}, fontproperties = 'monospace')<br/>plt.axis('off')<br/>plt.tight_layout()<br/>plt.subplots_adjust(left=0.2, right=0.8, top=0.7, bottom=0.1)<br/>plt.savefig('images/chart4', dpi=300);</span><span id="4113" class="kl km hi kc b fi kr ko l kp kq">print('Hedge Ratio = ', model.params[0])</span><span id="3865" class="kl km hi kc b fi kr ko l kp kq"># calculate spread<br/>spread = train.asset2 - model.params[0] * train.asset1</span><span id="a596" class="kl km hi kc b fi kr ko l kp kq"># Plot the spread<br/>ax = spread.plot(figsize=(12, 6), title = "Pair's Spread")<br/>ax.set_ylabel("Spread")<br/>ax.grid(True);</span><span id="1a18" class="kl km hi kc b fi kr ko l kp kq"># conduct Augmented Dickey-Fuller test<br/>adf = adfuller(spread, maxlag = 1)<br/>print('Critical Value = ', adf[0])</span><span id="f459" class="kl km hi kc b fi kr ko l kp kq"># probablity critical values<br/>print(adf[4])</span></pre><p id="9b61" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="d9ec" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">选择资产1作为BANKBARODA，资产2作为SBIN。</li><li id="94f6" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用训练数据集创建上述两只股票收盘价的数据框架，并将其可视化。</li><li id="b569" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">运行OLS回归，得到斜率，这也是我们的对冲比率。</li><li id="b9a6" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">计算传播，并绘制可视化。</li><li id="6947" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">运行扩展的Dickey-Fuller测试来检查单位根的分布和存在的平稳性。</li></ol><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lf"><img src="../Images/ab9ee840b1920238bcbeaf5556692ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-KluO1QbzYyQakUhgjMAAw.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">该货币对的每日收盘价</figcaption></figure><p id="d837" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从上面的图中我们可以看出，这两只股票的收盘价变动相当一致。</p><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lg"><img src="../Images/61a0a82a482b9b1f2c3e1fa6814b04dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDCY5DyhK9oVFhGMA62_ZA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">OLS回归结果</figcaption></figure><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lf"><img src="../Images/bc264a9abb3f338b7f668d91529486d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVtDkehfTHImsgU2V07afg.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">一对的传播</figcaption></figure><p id="b6bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">来自OLS回归的高R平方值和接近零的p值表明这两只股票之间的相关性非常高。传播看起来是稳定的，并且来自扩充的Dickey-Fuller检验的临界值是-3.459，其小于在1% (-3.435)显著性水平的值。因此，我们能够拒绝零假设，传播有一个单位根，并可以得出结论，它是平稳的性质。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="8cf3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">使用z值生成交易信号</strong></p><p id="3e11" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">到目前为止，我们一直使用训练数据集来最终确定我们策略的股票对。从现在开始，我们将使用测试数据集来确保交易信号的生成，并使用样本数据集进行回溯测试。我们将使用两个股票价格之间的比率的z分数来生成交易信号，并设置上限和下限。这将告诉我们一个价格离总体均值有多远。如果它是正数，并且值高于上限，那么股票价格高于平均价格值。因此，它的价格预计会下跌，因此我们想卖空这只股票，做多另一只股票。</p><p id="5338" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看一下代码:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="6b70" class="kl km hi kc b fi kn ko l kp kq"># calculate z-score<br/>def zscore(series):<br/> return (series — series.mean()) / np.std(series)</span><span id="7160" class="kl km hi kc b fi kr ko l kp kq"># create a dataframe for trading signals<br/>signals = pd.DataFrame()<br/>signals['asset1'] = test_close[asset1] <br/>signals['asset2'] = test_close[asset2]<br/>ratios = signals.asset1 / signals.asset2</span><span id="125e" class="kl km hi kc b fi kr ko l kp kq"># calculate z-score and define upper and lower thresholds<br/>signals['z'] = zscore(ratios)<br/>signals['z upper limit'] = np.mean(signals['z']) + np.std(signals['z'])<br/>signals['z lower limit'] = np.mean(signals['z']) - np.std(signals['z'])</span><span id="fb21" class="kl km hi kc b fi kr ko l kp kq"># create signal - short if z-score is greater than upper limit else long<br/>signals['signals1'] = 0<br/>signals['signals1'] = np.select([signals['z'] &gt; \<br/>                                 signals['z upper limit'], signals['z'] &lt; signals['z lower limit']], [-1, 1], default=0)</span><span id="81c6" class="kl km hi kc b fi kr ko l kp kq"># we take the first order difference to obtain portfolio position in that stock<br/>signals['positions1'] = signals['signals1'].diff()<br/>signals['signals2'] = -signals['signals1']<br/>signals['positions2'] = signals['signals2'].diff()</span><span id="c158" class="kl km hi kc b fi kr ko l kp kq"># verify datafame head and tail<br/>signals.head(3).append(signals.tail(3))</span><span id="10b1" class="kl km hi kc b fi kr ko l kp kq"># visualize trading signals and position<br/>fig=plt.figure(figsize=(14,6))<br/>bx = fig.add_subplot(111)   <br/>bx2 = bx.twinx()</span><span id="3a0e" class="kl km hi kc b fi kr ko l kp kq">#plot two different assets<br/>l1, = bx.plot(signals['asset1'], c='#4abdac')<br/>l2, = bx2.plot(signals['asset2'], c='#907163')</span><span id="a397" class="kl km hi kc b fi kr ko l kp kq">u1, = bx.plot(signals['asset1'][signals['positions1'] == 1], lw=0, marker='^', markersize=8, c='g',alpha=0.7)</span></pre><p id="9c7a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="ea9d" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">定义函数<code class="du jz ka kb kc b">zscore </code>来计算z分数。</li><li id="9aa6" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">用测试数据集中的收盘价创建我们两只股票的信号数据框架，并计算它们的价格比。</li><li id="c13b" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">计算比率的z得分，并用正负一个标准差定义阈值上限和下限。</li><li id="cf2e" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用以下逻辑创建信号列—如果z得分大于上限阈值，则我们将得到-1(短信号),但是如果z得分小于下限阈值，则得到+1(长信号),对于无信号，默认值为零。</li><li id="59c0" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">取信号柱的一阶差分，得到股票仓位。如果是+1，那么我们做多，-1，那么做空，0，如果没有头寸。</li><li id="472c" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">第二个信号将正好与第一个相反，这意味着我们做多一只股票，同时做空另一只股票。同样，对第二个信号取一阶差分，计算第二个位置列。</li><li id="09a0" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">接下来，我们将股票价格及其在投资组合中的多头和空头头寸可视化。</li></ol><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lh"><img src="../Images/bd49a10966624e2bfabfdcfd8623e098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gQmg2tWi_0yU3oXgLbglFQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">配对交易——交易信号和头寸</figcaption></figure><p id="eeb6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">投资组合损益计算</strong></p><p id="327b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将从初始资本100，000开始，并使用初始资本计算每只股票的最大股票头寸数。在任何给定的一天，第一只股票的总损益将是该股票的总持有量和该股票的现金头寸。类似地，第二支股票的损益将是该股票的总持有量和该股票的现金。你需要记住，我们持有市场中性头寸，这意味着我们用大约相同的资金同时做多和做空。最后，为了得到总的利润和损失，我们必须合计这两个。基于股票1和2的头寸，我们计算它们各自的日收益。我们还将在最终的投资组合数据框架中添加一个带有上限和下限阈值列的z得分列，以实现可视化。</p><p id="527a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们跳到代码:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="8349" class="kl km hi kc b fi kn ko l kp kq"># initial capital to calculate the actual pnl<br/>initial_capital = 100000<br/><br/># shares to buy for each position<br/>positions1 = initial_capital// max(signals['asset1'])<br/>positions2 = initial_capital// max(signals['asset2'])<br/><br/># since there are two assets, we calculate each asset Pnl <br/># separately and in the end we aggregate them into one portfolio<br/>portfolio = pd.DataFrame()<br/>portfolio['asset1'] = signals['asset1']<br/>portfolio['holdings1'] = signals['positions1'].cumsum() * signals['asset1'] * positions1<br/>portfolio['cash1'] = initial_capital - (signals['positions1'] * signals['asset1'] * positions1).cumsum()<br/>portfolio['total asset1'] = portfolio['holdings1'] + portfolio['cash1']<br/>portfolio['return1'] = portfolio['total asset1'].pct_change()<br/>portfolio['positions1'] = signals['positions1']</span><span id="ef77" class="kl km hi kc b fi kr ko l kp kq"># pnl for the 2nd asset<br/>portfolio['asset2'] = signals['asset2']<br/>portfolio['holdings2'] = signals['positions2'].cumsum() * signals['asset2'] * positions2<br/>portfolio['cash2'] = initial_capital - (signals['positions2'] * signals['asset2'] * positions2).cumsum()<br/>portfolio['total asset2'] = portfolio['holdings2'] + portfolio['cash2']<br/>portfolio['return2'] = portfolio['total asset2'].pct_change()<br/>portfolio['positions2'] = signals['positions2']<br/><br/># total pnl and z-score<br/>portfolio['z'] = signals['z']<br/>portfolio['total asset'] = portfolio['total asset1'] + portfolio['total asset2']<br/>portfolio['z upper limit'] = signals['z upper limit']<br/>portfolio['z lower limit'] = signals['z lower limit']<br/>portfolio = portfolio.dropna()<br/><br/># plot the asset value change of the portfolio and pnl along with z-score<br/>fig = plt.figure(figsize=(14,6),)<br/>ax = fig.add_subplot(111)<br/>ax2 = ax.twinx()<br/>l1, = ax.plot(portfolio['total asset'], c='g')<br/>l2, = ax2.plot(portfolio['z'], c='black', alpha=0.3)<br/>b = ax2.fill_between(portfolio.index,portfolio['z upper limit'],\<br/>                portfolio['z lower limit'], \<br/>                alpha=0.2,color='#ffb48f')<br/>ax.set_ylabel('Asset Value')<br/>ax2.set_ylabel('Z Statistics',rotation=270)<br/>ax.yaxis.labelpad=15<br/>ax2.yaxis.labelpad=15<br/>ax.set_xlabel('Date')<br/>ax.xaxis.labelpad=15<br/>plt.title('Portfolio Performance with Profit and Loss')<br/>plt.legend([l2,b,l1],['Z Statistics',<br/>                      'Z Statistics +-1 Sigma',<br/>                      'Total Portfolio Value'],loc='upper left');<br/>plt.savefig('images/chart8', dpi=300);<br/><br/># calculate CAGR<br/>final_portfolio = portfolio['total asset'].iloc[-1]<br/>delta = (portfolio.index[-1] - portfolio.index[0]).days<br/>print('Number of days = ', delta)<br/>YEAR_DAYS = 365<br/>returns = (final_portfolio/initial_capital) ** (YEAR_DAYS/delta) - 1</span><span id="ca46" class="kl km hi kc b fi kr ko l kp kq">print('CAGR = {:.3f}%' .format(returns * 100))</span></pre><p id="2f60" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="751b" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">我们从初始资金10万开始，计算每只股票的买入股数。</li><li id="1b61" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">接下来，我们通过将第一只股票的持仓量乘以股价和总股数来计算其持股量。</li><li id="2240" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">然后，我们通过从初始现金头寸中减去持有量来计算现金头寸。投资组合中股票的总头寸是现金加持股的总和。</li><li id="2d79" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用总股票头寸计算每日回报。</li><li id="cf13" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">接下来，我们对第二只股票执行步骤1到4，并对总投资组合价值的两项资产头寸求和。</li><li id="852d" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">添加带有上限和下限阈值的z得分以进行可视化。</li><li id="68cc" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">可视化投资组合表现以及z值、上限和下限。</li><li id="2556" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">计算投资组合CAGR。</li></ol><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lh"><img src="../Images/e8a53733e2799e4dde243cdcdd18afb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sF01mrjPmq1lkjvcuZvNcg.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">损益情况下的投资组合绩效</figcaption></figure><p id="a4c2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该战略的复合年增长率(CAGR)为16.5%，这看起来很有希望，但在我们得出任何结论之前，还有许多事情要考虑。需要考虑的几个重要因素如下:</p><ol class=""><li id="1794" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">由于这是一种市场中性的方法，很大程度上取决于我们卖空的能力，这种能力可能由于各种原因(包括监管)而受到限制。</li><li id="0252" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">我们没有考虑与交易、市场下滑和证券借贷相关的成本。通常，市场中性策略会导致大量交易。</li><li id="8ff1" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用历史数据预测未来总是有局限性的。</li></ol><p id="f01e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们记住，任何实施策略的决策都应该基于对所有关键性能参数的考虑，包括可行性和扣除费用和收费后的回报。</p><p id="dcf5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">祝投资愉快，请在文章中留下您的评论！</p><p id="2472" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意:此分析仅用于教育目的，作者不对您的任何投资决策负责。</p><p id="5fdc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">参考资料:</p><ol class=""><li id="4f28" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><a class="ae jk" href="https://www.amazon.com/Learn-Algorithmic-Trading-algorithmic-strategies/dp/178934834X" rel="noopener ugc nofollow" target="_blank">学习算法交易:使用Python和高级数据分析构建和部署算法交易系统和策略</a>。</li><li id="ed33" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">【https://je-suis-tm.github.io/quant-trading/】T4。</li><li id="e1a1" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">请在我的<a class="ae jk" href="https://www.linkedin.com/in/sabirjana/detail/recent-activity/shares/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>页面或<a class="ae jk" rel="noopener" href="/@sabirh.jana"> Medium </a>查看我关于量化金融的其他文章/帖子。</li></ol></div></div>    
</body>
</html>