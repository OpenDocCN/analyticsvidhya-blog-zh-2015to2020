<html>
<head>
<title>Model and solution of the Traveling Salesman Problem with Python and Pyomo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Python和Pyomo的旅行商问题模型及求解</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/model-and-solution-of-the-traveling-salesman-problem-with-python-and-pyomo-db45f2631e8c?source=collection_archive---------4-----------------------#2019-11-19">https://medium.com/analytics-vidhya/model-and-solution-of-the-traveling-salesman-problem-with-python-and-pyomo-db45f2631e8c?source=collection_archive---------4-----------------------#2019-11-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/a674c017ed978da0ad88fabbfbf6cacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*71lAnN9K5Wh8d2XHiDgp8A.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">信用:<a class="ae iq" href="https://optimization.mccormick.northwestern.edu/index.php/Traveling_salesman_problems" rel="noopener ugc nofollow" target="_blank">https://optimization . McCormick . northwestern . edu/index . PHP/Traveling _ salesman _ problems</a></figcaption></figure><p id="f17d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">使用Python和Pyomo逐步建模和解决旅行推销员问题。</p><p id="16a4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这篇文章中，我们将讨论一个最著名的运筹学问题，TSP(旅行推销员问题)。问题提出如下问题:<strong class="it hj">“给定一个城市列表和每对城市之间的距离，访问每个城市并返回出发城市的最短可能路线是什么？”</strong>。</p><h1 id="dfa5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak"> Pyomo </strong></h1><p id="63a3" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">为了解决这个问题，我们将利用Pyomo，这是一种基于Python的开源优化建模语言，具有多种优化功能。如果你有任何编程语言(尤其是Python)的经验，用Pyomo建模和解决问题将是一项简单的任务。</p><div class="ks kt ez fb ku kv"><a href="http://www.pyomo.org/" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">Pyomo</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">Pyomo的主页，这是一种用于线性编程的基于Python的可扩展开源优化建模语言…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">www.pyomo.org</p></div></div><div class="le l"><div class="lf l lg lh li le lj ik kv"/></div></div></a></div><p id="043c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">Pyomo允许您在各种解决方案中进行选择，包括开源和商业解决方案。</p><p id="5ecc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我已经在我的机器上安装了带有conda的Pyomo，但也可以用pip来完成。可以在<a class="ae iq" href="http://www.pyomo.org/installation" rel="noopener ugc nofollow" target="_blank">http://www.pyomo.org/installation</a>上阅读安装说明。</p><p id="f8f9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这篇文章中，我们将利用CPLEX IBM Solver来解决一个整数线性规划问题。请随意使用ILP的任何其他求解器。</p><h2 id="f124" class="lk jq hi bd jr ll lm ln jv lo lp lq jz jc lr ls kd jg lt lu kh jk lv lw kl lx bi translated">问题描述</h2><p id="f484" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">旅行推销员的任务是找到游览每个城市并返回起点的最短路线。</p><h2 id="7fab" class="lk jq hi bd jr ll lm ln jv lo lp lq jz jc lr ls kd jg lt lu kh jk lv lw kl lx bi translated">模型组成</h2><p id="8112" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">TSP的米勒-塔克-泽姆林(MTZ)公式描述如下:</p><p id="f2a0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">用1，...，<em class="ly"> n </em>标记城市，并定义决策变量:</p><figure class="ma mb mc md fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/bf01436003053de1b4c79f60396973f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*UpCyrnwkiCkAhW4Nq-wTSA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">决策变量</figcaption></figure><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es me"><img src="../Images/cdc89f5f582873368a5e349338efa72e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nuxIn5QeGTPIUBI5Jg6i3A.png"/></div></div></figure><p id="d274" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">那么TSP可以写成如下整数线性规划问题:</p><figure class="ma mb mc md fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/a96f27353ca8d86bb8513d9f8a8a736e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*BKNnLkDZgV0xozshkdeDmw.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">信用:<a class="ae iq" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Travelling_salesman_problem</a></figcaption></figure><p id="2cd2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">第一组等式要求每个城市都是从恰好一个其他城市到达的，第二组等式要求每个城市都有到恰好一个其他城市的出发。最后一个约束条件是，只能有一个涵盖所有城市的旅游，而不能有两个或两个以上不连贯的旅游，它们只能共同涵盖所有城市。”</p><h2 id="8322" class="lk jq hi bd jr ll lm ln jv lo lp lq jz jc lr ls kd jg lt lu kh jk lv lw kl lx bi translated"><strong class="ak">脓杆菌制剂</strong></h2><p id="3ef7" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">第一步是输入数据，这意味着为模型提供成本矩阵。出于教学和实践的目的，我下载了一个包含17个城市成本矩阵的实例。<br/>我用python以如下方式读取了该文件:</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><figure class="ma mb mc md fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/014695d8c17d8bccf81fc9ed17db36c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*bwk-T2CVg1tSr4W20vKbWw.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">成本矩阵</figcaption></figure><p id="d337" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">变量<strong class="it hj"> cost_matrix </strong>和<strong class="it hj"> n </strong>包含成本矩阵和城市数量。现在我们将能够在定义约束时调用这些元素。</p><p id="7489" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">要使用Pyomo并解决这个问题，我们需要进行一次导入。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="ae4f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在我们可以初始化模型了。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><ul class=""><li id="a0f6" class="mn mo hi it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv bi translated"><strong class="it hj"> <em class="ly">混凝土模型()</em> - </strong>创建模型。</li><li id="bb4c" class="mn mo hi it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv bi translated"><strong class="it hj"> <em class="ly"> RangeSet(n) </em> - </strong>创建从1到n的索引</li><li id="80aa" class="mn mo hi it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv bi translated"><strong class="it hj"> <em class="ly"> RangeSet(2，n) </em> - </strong>创建一个从2到n的索引</li></ul><p id="b355" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">创建决策变量。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><ul class=""><li id="3e74" class="mn mo hi it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv bi translated"><code class="du nb nc nd ne b"><strong class="it hj">Var(model.N,model.M, within=pyEnv.Binary)</strong></code>创建大小为<strong class="it hj"> M. </strong>的<strong class="it hj"> N </strong>二元决策变量</li><li id="014a" class="mn mo hi it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv bi translated"><code class="du nb nc nd ne b"><strong class="it hj">Var(model.N, within=pyEnv.NonNegativeIntegers,bounds=(0,n-1))</strong></code>创建<strong class="it hj"> N </strong>只能取0到n-1之间值的非负整数决策变量。</li></ul><p id="23c0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们必须为模型提供成本矩阵。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><ul class=""><li id="0921" class="mn mo hi it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv bi translated"><code class="du nb nc nd ne b"><strong class="it hj">Param(modelo.N, model.M,initialize=lambda model, i, j: cost_matrix[i-1][j-1])</strong></code>使用lambda函数为模型提供一个<strong class="it hj"> N </strong> x <strong class="it hj"> M </strong>参数。</li></ul><p id="0095" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在定义了所有变量并提供了参数之后，我们就能够创建目标函数了。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="ce9d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">首先，我们创建一个返回目标函数的Python函数。<br/>我使用了一个神奇的python资源，叫做<em class="ly"> List Comprehension，</em>如果你不熟悉它，这个页面给出了一个很好的教程:<a class="ae iq" href="https://www.pythonforbeginners.com/basics/list-comprehensions-in-python" rel="noopener ugc nofollow" target="_blank">https://www . python forbeginners . com/basics/List-comprehensions-in-python</a>。</p><ul class=""><li id="2e63" class="mn mo hi it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv bi translated"><code class="du nb nc nd ne b"><strong class="it hj">Objective(rule=obj_func,sense=pyEnv.minimize) </strong></code>创建模型的目标函数及其意义(最大化或最小化)。</li></ul><h2 id="45cd" class="lk jq hi bd jr ll lm ln jv lo lp lq jz jc lr ls kd jg lt lu kh jk lv lw kl lx bi translated"><strong class="ak">约束</strong></h2><p id="0436" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">我们以非常相似的方式提供约束。</p><p id="53ee" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">确保每个城市只有1个叶子的第一个约束可以用下面的方式来表达:</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><ul class=""><li id="4aef" class="mn mo hi it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv bi translated"><code class="du nb nc nd ne b"><strong class="it hj">Constraint(model.M,rule=rule_const1)</strong></code> <strong class="it hj"> <em class="ly"> </em> </strong>创建由rule_const1定义的<strong class="it hj"> M </strong>约束。</li></ul><p id="3b27" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">确保每个城市仅接收1的第二个约束可以由下式表示:</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><ul class=""><li id="41ca" class="mn mo hi it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv bi translated"><code class="du nb nc nd ne b"><strong class="it hj">Constraint(model.N,rule=rule_const2)</strong></code> <strong class="it hj"> <em class="ly"> </em> </strong>创建由rule_const2定义的<strong class="it hj"> N个</strong>约束。</li></ul><p id="e211" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">第三个也是最后一个约束，它强制要求只能有一个覆盖所有城市的旅游，而不能有两个或更多不连贯的旅游，这些旅游只能共同覆盖所有城市。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><ul class=""><li id="8a68" class="mn mo hi it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv bi translated"><code class="du nb nc nd ne b"><strong class="it hj">Constraint(model.U,Model.N,rule=rule_const3)</strong></code> <strong class="it hj"> <em class="ly"> </em> </strong>创建由rule_const3定义的<strong class="it hj"> UxN </strong>约束。</li></ul><p id="d2ce" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">一个<em class="ly">规则</em>类型的函数必须提供一个<em class="ly"> Pyomo对象</em>，这就是为什么我不得不写那个奇怪的else条件。</p><h2 id="f4c4" class="lk jq hi bd jr ll lm ln jv lo lp lq jz jc lr ls kd jg lt lu kh jk lv lw kl lx bi translated">解决办法</h2><p id="f65e" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">为了求解我们的模型，我们需要安装一个求解器。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><ul class=""><li id="5064" class="mn mo hi it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv bi translated"><code class="du nb nc nd ne b"><strong class="it hj">pprint()</strong></code>打印整个模型(如果模型太大，这可能不是一个好主意)。</li><li id="4fdc" class="mn mo hi it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv bi translated"><code class="du nb nc nd ne b"><strong class="it hj">pprint(filename=’file.txt’)</strong></code>打印特定文件中的模型。</li></ul><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><ul class=""><li id="a814" class="mn mo hi it b iu iv iy iz jc mp jg mq jk mr jo ms mt mu mv bi translated"><code class="du nb nc nd ne b"><strong class="it hj">SolverFactory(‘cplex’)</strong></code>我初始化了名为CPLEX的IBM解算器。</li><li id="3a2d" class="mn mo hi it b iu mw iy mx jc my jg mz jk na jo ms mt mu mv bi translated"><code class="du nb nc nd ne b"><strong class="it hj">solve(model, tee= False)</strong></code>解决了模型。使用tee = False，您将看不到求解程序的日志屏幕。如果你想看，就用tee= True。</li></ul><figure class="ma mb mc md fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/3d3b6a556a5a87e9cb0238337f11d59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*OQe1Wm09SGCUMyPdCcC2GA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">问题解决了。</figcaption></figure><p id="fcfe" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果您希望查看选择了哪些决策变量，您可以这样做:</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><figure class="ma mb mc md fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/29f52ad37822ed58ca6939047591b3f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*QOBkJQgT2iCnE1tLnkVffA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">(城市I，城市j)</figcaption></figure><p id="d57b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这意味着最佳路线是1–17–8–9–4–5–15–7–16–6–13–10–11–2–14–3–12–1。</p><h2 id="1ef8" class="lk jq hi bd jr ll lm ln jv lo lp lq jz jc lr ls kd jg lt lu kh jk lv lw kl lx bi translated">临时演员</h2><p id="9934" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">要获得更多Pyomo的例子，你可以去他们的GitHub页面。</p><p id="f11c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在我自己的<a class="ae iq" href="https://github.com/titowoche30/PyomoExamples" rel="noopener ugc nofollow" target="_blank"> github页面</a>中有一些模型示例和更完整的手册(都是葡萄牙语)。</p><p id="83b6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这是我的第一篇文章:)。</p></div></div>    
</body>
</html>