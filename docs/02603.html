<html>
<head>
<title>Azure synapse analytics spark graph processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure synapse analytics spark图形处理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/azure-synapse-analytics-spark-graph-processing-6ccb36403baf?source=collection_archive---------25-----------------------#2019-12-24">https://medium.com/analytics-vidhya/azure-synapse-analytics-spark-graph-processing-6ccb36403baf?source=collection_archive---------25-----------------------#2019-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6142c42e775462943da574251b56fa33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*60uW8GPWzZs5kbqH.JPG"/></div></div></figure><h1 id="4f38" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">加载数据</h1><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7446" class="jx ir hi jt b fi jy jz l ka kb">spark.conf.set( "fs.azure.account.key.waginput.blob.core.windows.net", "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")</span></pre><h1 id="9c53" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">装载站数据</h1><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="10ba" class="jx ir hi jt b fi jy jz l ka kb">val dfstation = spark.read.option("header","true").option("inferSchema","true").csv("wasbs://graphdata@waginput.blob.core.windows.net/station.csv") display(dfstation)</span></pre><h1 id="56a9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">加载行程数据</h1><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="3d95" class="jx ir hi jt b fi jy jz l ka kb">val dftrip = spark.read.option("header","true").option("inferSchema","true").csv("wasbs://graphdata@waginput.blob.core.windows.net/trip.csv") display(dftrip)</span></pre><h1 id="7d01" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">显示方案以供审阅</h1><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6d56" class="jx ir hi jt b fi jy jz l ka kb">dfstation.printSchema() <br/>dftrip.printSchema()</span></pre><h1 id="05bf" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">创建基于图表的数据</h1><h1 id="d46c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">构建图表</h1><p id="12f3" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">现在您已经导入了数据，接下来需要构建图表。为此，你要做两件事。你将构建顶点(或节点)的结构，你将构建边的结构。GraphFrames的了不起之处在于，这个过程简单得令人难以置信。您需要做的就是在顶点表中获取不同的id值，并将边表的起点和终点桩号分别重命名为src和dst。这些是GraphFrames中顶点和边所需的约定。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="020c" class="jx ir hi jt b fi jy jz l ka kb">import org.apache.spark.graphx._ <br/>import org.apache.spark.rdd.RDD <br/>import org.apache.spark.sql.functions.col</span><span id="f22d" class="jx ir hi jt b fi la jz l ka kb">val justStations = dfstation.selectExpr("float(id) as station_id", "name").distinct()</span><span id="fa4d" class="jx ir hi jt b fi la jz l ka kb">val stations = dftrip.select("start_station_id").withColumnRenamed("start_station_id", "station_id").union(dftrip.select("end_station_id").withColumnRenamed("end_station_id", "station_id")).distinct().select(col("station_id").cast("long").alias("value"))</span><span id="dbd3" class="jx ir hi jt b fi la jz l ka kb">val stationVertices: RDD[(VertexId, String)] = stations.join(justStations, stations("value") === justStations("station_id")).select(col("station_id").cast("long"), col("name")).rdd.map(row =&gt; (row.getLong(0), row.getString(1))) // maintain type information</span><span id="ff4e" class="jx ir hi jt b fi la jz l ka kb">val stationEdges:RDD[Edge[Long]] = dftrip.select(col("start_station_id").cast("long"), col("end_station_id").cast("long")).rdd.map(row =&gt; Edge(row.getLong(0), row.getLong(1), 1))</span></pre><p id="81be" class="pw-post-body-paragraph kc kd hi ke b kf lb kh ki kj lc kl km kn ld kp kq kr le kt ku kv lf kx ky kz hb bi translated">现在你可以建立你的图表。</p><p id="a0e1" class="pw-post-body-paragraph kc kd hi ke b kf lb kh ki kj lc kl km kn ld kp kq kr le kt ku kv lf kx ky kz hb bi translated">您还需要将输入数据帧缓存到图表中。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7104" class="jx ir hi jt b fi jy jz l ka kb">val defaultStation = ("Missing Station") val stationGraph = Graph(stationVertices, stationEdges, defaultStation) stationGraph.cache()</span><span id="c6e8" class="jx ir hi jt b fi la jz l ka kb">println("Total Number of Stations: " + stationGraph.numVertices) println("Total Number of Trips: " + stationGraph.numEdges) // sanity check <br/>println("Total Number of Trips in Original Data: " + dftrip.count)</span></pre><h1 id="1ea5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">从一个车站到另一个车站的旅行</h1><p id="fd01" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">您可能会问的一个问题是，数据集中不同位置最常见的目的地是什么。您可以通过执行分组运算符并将边数相加来实现这一点。这将产生一个新的图形，除了每个边现在将是所有语义相同的边的总和。这样想:你有许多从A站到B站的完全相同的行程，你只是想把它们加起来！</p><p id="ef65" class="pw-post-body-paragraph kc kd hi ke b kf lb kh ki kj lc kl km kn ld kp kq kr le kt ku kv lf kx ky kz hb bi translated">在下面的查询中，您将看到您将获取最常见的站到站旅行，并打印出前10名。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1f38" class="jx ir hi jt b fi jy jz l ka kb">val ranks = stationGraph.pageRank(0.0001).vertices ranks.join(stationVertices).sortBy(_._2._1, ascending=false).take(10).foreach(x =&gt; println(x._2._2))</span><span id="8a0a" class="jx ir hi jt b fi la jz l ka kb">stationGraph.groupEdges((edge1, edge2) =&gt; edge1 + edge2).triplets.sortBy(_.attr, ascending=false).map(triplet =&gt; "There were " + triplet.attr.toString + " trips from " + triplet.srcAttr + " to " + triplet.dstAttr + ".").take(10).foreach(println)</span></pre><p id="8ae9" class="pw-post-body-paragraph kc kd hi ke b kf lb kh ki kj lc kl km kn ld kp kq kr le kt ku kv lf kx ky kz hb bi translated">你可以在上面看到，一个给定的顶点是一个Caltrain站似乎是有意义的！这是有意义的，因为这些是天然的连接器，可能是这些自行车共享程序最受欢迎的用途之一，以一种你不需要汽车的方式让你从A到B！</p><h1 id="53c4" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">进度和出度</h1><p id="0289" class="pw-post-body-paragraph kc kd hi ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">记住，在这个例子中，你得到了一个有向图。这意味着你的旅行是有方向的——从一个地方到另一个地方。因此，您可以获得大量可用的分析。您可以找到进入特定车站和离开特定车站的车次。</p><p id="3325" class="pw-post-body-paragraph kc kd hi ke b kf lb kh ki kj lc kl km kn ld kp kq kr le kt ku kv lf kx ky kz hb bi translated">很自然，你可以对这些信息进行分类，找到有很多进出站的车站！更多信息请查看顶点度数的定义。</p><p id="beff" class="pw-post-body-paragraph kc kd hi ke b kf lb kh ki kj lc kl km kn ld kp kq kr le kt ku kv lf kx ky kz hb bi translated">现在您已经定义了这个过程，接下来继续查找有大量入站和出站流量的车站。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="4380" class="jx ir hi jt b fi jy jz l ka kb">stationGraph.inDegrees.join(stationVertices).sortBy(_._2._1, ascending=false).take(10).foreach(x =&gt; println(x._2._2 + " has " + x._2._1 + " in degrees."))</span><span id="5b78" class="jx ir hi jt b fi la jz l ka kb">stationGraph.outDegrees.join(stationVertices).sortBy(_._2._1, ascending=false).take(10).foreach(x =&gt; println(x._2._2 + " has " + x._2._1 + " out degrees."))</span></pre><p id="f1b2" class="pw-post-body-paragraph kc kd hi ke b kf lb kh ki kj lc kl km kn ld kp kq kr le kt ku kv lf kx ky kz hb bi translated">你可能会问的一个有趣的后续问题是，哪个站的入度比最高，但出度比最低。就像，什么站几乎是一个纯粹的旅行接收器。旅行结束但很少开始的车站</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2944" class="jx ir hi jt b fi jy jz l ka kb">stationGraph.inDegrees.join(stationGraph.outDegrees).join(stationVertices).map(x =&gt; (x._2._1._1.toDouble/x._2._1._2.toDouble, x._2._2)).sortBy(_._1, ascending=false).take(5).foreach(x =&gt; println(x._2 + " has a in/out degree ratio of " + x._1))</span></pre><p id="736c" class="pw-post-body-paragraph kc kd hi ke b kf lb kh ki kj lc kl km kn ld kp kq kr le kt ku kv lf kx ky kz hb bi translated">您可以通过获取入度与出度比率最低的站点来做类似的事情，这意味着行程从该站点开始，但不会经常在该站点结束。这本质上与你上面的相反。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="a9a6" class="jx ir hi jt b fi jy jz l ka kb">stationGraph.inDegrees.join(stationGraph.inDegrees).join(stationVertices).map(x =&gt; (x._2._1._1.toDouble/x._2._1._2.toDouble, x._2._2)).sortBy(_._1).take(5).foreach(x =&gt; println(x._2 + " has a in/out degree ratio of " + x._1))</span></pre><p id="1cc5" class="pw-post-body-paragraph kc kd hi ke b kf lb kh ki kj lc kl km kn ld kp kq kr le kt ku kv lf kx ky kz hb bi translated">你从上面的分析中得到的结论应该是相对简单的。如果你有一个较高的值，这意味着更多的车次进入该站比出来，而一个较低的值意味着更多的车次离开该站比进入它！</p><p id="e5a9" class="pw-post-body-paragraph kc kd hi ke b kf lb kh ki kj lc kl km kn ld kp kq kr le kt ku kv lf kx ky kz hb bi translated">希望你已经从这本笔记本中获得了一些价值！一旦你开始寻找图形结构，你就会发现它们无处不在，希望GraphFrames能使分析它们变得容易！</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><p id="f474" class="pw-post-body-paragraph kc kd hi ke b kf lb kh ki kj lc kl km kn ld kp kq kr le kt ku kv lf kx ky kz hb bi translated"><em class="ln">最初发表于</em><a class="ae lo" href="https://github.com/balakreshnan/synapseAnalytics/blob/master/SparkGraph.md" rel="noopener ugc nofollow" target="_blank"><em class="ln">【https://github.com】</em></a><em class="ln">。</em></p></div></div>    
</body>
</html>