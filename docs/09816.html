<html>
<head>
<title>LeNet Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeNet架构</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/lenet-architecture-document-recognition-ed971ab2a23f?source=collection_archive---------14-----------------------#2020-09-21">https://medium.com/analytics-vidhya/lenet-architecture-document-recognition-ed971ab2a23f?source=collection_archive---------14-----------------------#2020-09-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8e1f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">数字识别概念介绍</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/0be8ef48fcca60b32cf28dd2befb9241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*9MRcNBz9uHXplXzd3ii6VQ.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">由<a class="ae jj" href="https://engmrk.com/wp-content/uploads/2018/09/LeNet_Original_Image.jpg" rel="noopener ugc nofollow" target="_blank"> engMRK </a>上<a class="ae jj" href="https://engmrk.com/author/admin/" rel="noopener ugc nofollow" target="_blank"> Muhammad Rizwan </a>拍摄的照片</figcaption></figure><p id="5e61" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">LeNet是图像识别领域的一大突破。它是最古老的卷积神经网络之一，由Yann LeCunn早在1995年在其研究论文中提出。在那些日子里，他想出了这个LeNet模型来寻找代表美国邮政服务的邮政编码的手写数字。</p><h2 id="8859" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">LeNet结构的组件:</h2><p id="45db" class="pw-post-body-paragraph jk jl hi jm b jn lb ij jp jq lc im js jt ld jv jw jx le jz ka kb lf kd ke kf hb bi translated">1.定义大小的输入图像</p><p id="5f69" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">2.与特定大小和填充的核或特征一起使用的卷积层</p><p id="cb02" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">3.卷积层中使用的滤波器符合要求</p><p id="492f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">4.平均最大池用于特定的大小、步幅和填充</p><h2 id="6c80" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">卷积层1</h2><p id="ae59" class="pw-post-body-paragraph jk jl hi jm b jn lb ij jp jq lc im js jt ld jv jw jx le jz ka kb lf kd ke kf hb bi translated">它是使用多个卷积和平均池层构建的。我们采用由数字组成的大小为32*32的输入灰度图像作为图像。我们引入一个5*5大小的核，填充为0，并将其与输入图像进行卷积。我们使用6个滤波器或内核来生成28*28*6的卷积层。图像步幅取为1。</p><p id="e471" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">输入图像= 32*32</p><p id="5e23" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">内核大小= 5*5</p><p id="cdfe" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">内核数量= 6</p><p id="c475" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">填充= 0</p><p id="07fb" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">步幅= 1</p><p id="2f9b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">因此，conv1的大小=[n+2p-f+1]/s =[32+0–5+1/1]= 28</p><p id="c199" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">因此conv1 = 28*28*6</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lg"><img src="../Images/14312f8842ca3b1bec8a1acb24208177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*x8BSOP_77evAP4DiM2jWEA.png"/></div></figure><h2 id="8b2d" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">平均池1</h2><p id="ba82" class="pw-post-body-paragraph jk jl hi jm b jn lb ij jp jq lc im js jt ld jv jw jx le jz ka kb lf kd ke kf hb bi translated">现在我们用2*2的内核大小和步长=2进行平均池化。它导致图像像素减少到14*14。</p><p id="fa3e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">输入图像= 28*28</p><p id="3d4c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">内核大小= 2*2</p><p id="42a5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">步幅= 2</p><p id="db9c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">所以conv1的大小= [n+2p-f+1] / s</p><p id="c896" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi">= [28+0–2+1/2]</p><p id="90f4" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">=最低值(13.5)</p><p id="2dad" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi">= 14</p><p id="695a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">因此，平均池1大小= 14*14*6</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lh"><img src="../Images/4d3617039b81a560755978625ecf3097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*1a7GTbV4wK0OQiXE5Gcb5Q.png"/></div></figure><h2 id="7f9b" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated"><strong class="ak">卷积层2 </strong></h2><p id="0a00" class="pw-post-body-paragraph jk jl hi jm b jn lb ij jp jq lc im js jt ld jv jw jx le jz ka kb lf kd ke kf hb bi translated">现在我们生成一个5*5内核大小的卷积层，取内核为16，步长=1。它导致图像像素减少到10*10*16。</p><p id="e720" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">输入图像= 14*14</p><p id="7313" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">内核大小= 5*5</p><p id="7f46" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">内核数量= 16</p><p id="b33a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">填充= 0</p><p id="6668" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">步幅= 1</p><p id="2574" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">因此，conv2的大小=[n+2p-f+1]/s =[14+0–5+1/1]= 10</p><p id="2fa5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">因此conv2 = 10*10*16</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es li"><img src="../Images/7cf2d6af92b7470cf89ab243121aa38f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*qDHh71x3_HxyBoO-hvVAzw.png"/></div></figure><h2 id="7059" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">平均池-2</h2><p id="c071" class="pw-post-body-paragraph jk jl hi jm b jn lb ij jp jq lc im js jt ld jv jw jx le jz ka kb lf kd ke kf hb bi translated">现在我们用2*2的内核大小和步长=2进行平均池化。它导致图像像素减少到5*5。</p><p id="e89d" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">输入图像= 10*10</p><p id="db1f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">内核大小= 2*2</p><p id="c8fb" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">步幅= 2</p><p id="43e1" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">所以conv1的大小= [n+2p-f+1] / s</p><p id="852c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi">= [10+0–2+1/2]</p><p id="a431" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">=底值(4.5) = 5</p><p id="8499" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">因此，avg-pool-2的大小= 5*5*16</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/5ea0448a8d2e814396ce40e31961f6d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwR9Y839rDRNJf6HIDw9sA.png"/></div></div></figure><h2 id="d669" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated"><strong class="ak">连接层1的输入</strong></h2><p id="5e85" class="pw-post-body-paragraph jk jl hi jm b jn lb ij jp jq lc im js jt ld jv jw jx le jz ka kb lf kd ke kf hb bi translated">现在，在第二次平均汇集之后，我们将所有像素展开到连接的第1层的输入神经元中。我们提供400个神经元作为连接层1的输入。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lo"><img src="../Images/d5103344e956eafc42307550c3baf126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wA8pkqDLonPQcKyrJsTIiw.png"/></div></div></figure><h2 id="4317" class="kg kh hi bd ki kj kk kl km kn ko kp kq jt kr ks kt jx ku kv kw kb kx ky kz la bi translated">第二、第三连接层的生成，以及softmax输出。</h2><p id="4a07" class="pw-post-body-paragraph jk jl hi jm b jn lb ij jp jq lc im js jt ld jv jw jx le jz ka kb lf kd ke kf hb bi translated">我们接收连接的第2层的120个输入。这些输入被处理并产生84个输入到连接的第3层。84个输入组合在一起成为一个softmax，它产生由10个标签组成的输出分类器。softmax生成10个输出，因为我们必须在文档识别过程中识别从0到9的10个数字。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lp"><img src="../Images/13c145b046881db02c8072d68059b3ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*vIpoanq7kvXfxSxUiB11xg.png"/></div></figure><p id="c2be" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">Mnist是由大约70000幅图像组成的数字图像数据集，其中60k被保留用于训练模型，10k被保留用于测试模型。我们创建一个LeNet模型，并将其应用于Mnist数据集，以便根据数字的标识对其进行分类。</p><p id="7d28" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">因此，最初我们提取Keras模型中可用的Mnist数据集。然后，我们将数据集分成训练和测试模型，并将输出标签或类的详细信息保存在NumPy数组中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="dc3c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">然后，我们创建一个Lenet架构，它将使用预测图像的标签分类对输入图像进行分类。在Lenet架构中，我们创建了一个Keras模型对象，并将其应用于Keras顺序模型。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="498c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们将输入图像作为训练和测试图像提供给架构，并在Lenet架构上训练模型，以基于接收到的输入对图像进行分类。我们可以通过增加历元使用输入图像进行训练来达到模型的精度。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="4dff" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在模型的训练之后，我们将输入传递给模型，以便基于测试图像来测试预测。在这里，我们将一个测试图像作为9进行传递，在对图像应用模型分类预测之后，我们接收到的输出是9。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ls"><img src="../Images/c62e24793ceb60e6a09eaf8b3f8ae3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*IXNdwR0Qpn0SbREo_rIwOg.png"/></div></figure><p id="31cd" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">希望这有助于你通过上面的例子更好地理解这个概念。</p><p id="20ff" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">感谢阅读！！</p><p id="a5e7" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如果感兴趣，请参考我的GitHub上的代码</p><p id="29a9" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><a class="ae jj" href="https://github.com/charanraj2411/Digit-Recognition" rel="noopener ugc nofollow" target="_blank">https://github.com/charanraj2411/Digit-Recognition</a></p></div></div>    
</body>
</html>