<html>
<head>
<title>Deploy ML models using Flask as REST API and access via Flutter app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flask作为REST API部署ML模型，并通过Flutter应用程序访问</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deploy-ml-models-using-flask-as-rest-api-and-access-via-flutter-app-7ce63d5c1f3b?source=collection_archive---------0-----------------------#2019-07-17">https://medium.com/analytics-vidhya/deploy-ml-models-using-flask-as-rest-api-and-access-via-flutter-app-7ce63d5c1f3b?source=collection_archive---------0-----------------------#2019-07-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="96a6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Flask的简单，Flutter的精彩，以及Keras的图像分类模型</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ac1f6de223986ad1f18e30b550f0aeb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nFTOvKLYdIp7Zml3FeWXA.jpeg"/></div></div></figure><h2 id="1f88" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">介绍</h2><p id="99f6" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">最近，机器学习已经成为一种很酷的技术，几乎市场上所有的软件产品都以这样或那样的方式使用ML。让我们看看如何建立一个应用程序，可以上传图像到服务器，并对它进行预测(图像分类)。这些图片可以通过应用程序访问，你可以简单地通过内容搜索图片。</p><p id="0556" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">我们将使用<strong class="kj hj"> Flask (Python框架)</strong>作为我们REST API的后端，<strong class="kj hj"> Flutter </strong>用于手机app，<strong class="kj hj"> Keras </strong>用于图像分类。我们还将使用<strong class="kj hj"> MongoDB </strong>作为我们的数据库来存储关于图像的数据，并使用Keras <strong class="kj hj"> ResNet50 model </strong>对图像进行分类，使用预训练模型似乎有助于实现这一目的。如果需要，我们可以通过保存Keras中可用的save_model()和load_model()方法来使用自定义模型。Keras第一次下载模型大约需要100 mb。要了解更多可用型号，请参考<a class="ae lf" href="https://keras.io/applications/" rel="noopener ugc nofollow" target="_blank">文档</a></p><h2 id="5c52" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">让我们从烧瓶开始</h2><p id="3a47" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">在Flask中定义路由非常简单，使用decorator @app.route('/')，其中@app是包含Flask应用程序的对象的名称。让我们看一个例子</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="0d4a" class="jj jk hi lh b fi ll lm l ln lo">from flask import Flask <br/>app = Flask(__name__)</span><span id="9d7d" class="jj jk hi lh b fi lp lm l ln lo">@app.route(’/’) <br/>def hello_world():<br/>    return ‘Hello, World!’</span></pre><p id="c4d9" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">从flask导入Flask，并为app提供一个名称，这里的“app”是包含我们的app的对象的名称。接下来，我们将使用装饰器来定义route，以便每当请求到达该路由时(例如:http://127.0.0.1:5000/)，flask将自动返回</p><blockquote class="lq lr ls"><p id="111e" class="kh ki lt kj b kk la ij km kn lb im kp lu lc kr ks lv ld ku kv lw le kx ky kz hb bi translated"><em class="hi">你好世界！</em></p></blockquote><p id="ec9b" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">作为回应。是的，就是这么简单！</p><p id="d848" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">如果你想了解更多关于Flask的信息，请查阅文档<a class="ae lf" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank">。现在看看我们的后端代码:</a></p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="3582" class="jj jk hi lh b fi ll lm l ln lo">import os<br/>import tensorflow as tf<br/>from tensorflow.keras.models import load_model<br/>from tensorflow.keras.preprocessing import image as img<br/>from keras.preprocessing.image import img_to_array<br/>import numpy as np<br/>from PIL import Image<br/>from keras.applications.resnet50 import  ResNet50,decode_predictions,preprocess_input<br/>from datetime import datetime<br/>import io<br/>from flask import Flask,Blueprint,request,render_template,jsonify<br/>from modules.dataBase import collection as db</span></pre><p id="b061" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">我们有一些包含tensorflow的import语句，因为我们使用tensorflow作为keras的后端，使用numpy处理多维数组。</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="7b57" class="jj jk hi lh b fi ll lm l ln lo">mod=Blueprint(‘backend’,__name__,template_folder=’templates’,static_folder=’./static’)<br/>UPLOAD_URL = ‘http://192.168.1.103:5000/static/'<br/>model = ResNet50(weights=’imagenet’)<br/>model._make_predict_function()</span></pre><p id="90e9" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">因为这个例子使用了<a class="ae lf" href="https://flask.palletsprojects.com/en/1.0.x/blueprints/" rel="noopener ugc nofollow" target="_blank"> Flask-blueprints </a>(将文件组织成模块的方式)，所以第一行将它作为一个对象。</p><p id="f2d8" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">有一点需要注意的是，现在我们所有的路由装饰器都会使用<strong class="kj hj"> @mod.route('/') </strong>来定义路由。我们的模型将在imagenet数据集上进行Resnet50训练，并在其上调用_make_predict_function()。如果不使用此方法，您可能会出错。如果你有自定义模型，你可以用同样的方式改变它</p><p id="d903" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated"><em class="lt">model = resnet 50(weights = ' imagenet ')</em></p><p id="a2d1" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">到</p><p id="e7d0" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated"><em class="lt">model = load _ model(" saved _ model . H5 ")</em></p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="3947" class="jj jk hi lh b fi ll lm l ln lo">@mod.route(‘/predict’ ,methods=[‘POST’])<br/>def predict():<br/>if request.method == ‘POST’:<br/><em class="lt"># check if the post request has the file part<br/>    </em>if ‘file’ not in request.files:<br/>    return “No file found”</span><span id="fc7b" class="jj jk hi lh b fi lp lm l ln lo">user_file = request.files[‘file’]<br/>temp = request.files[‘file’]<br/>if user_file.filename == ‘’:<br/>    return “file name not found …”</span><span id="e09f" class="jj jk hi lh b fi lp lm l ln lo">else:<br/>path=os.path.join(os.getcwd()+’\\modules\\static\\’+user_file.filename)<br/>user_file.save(path)</span><span id="22d9" class="jj jk hi lh b fi lp lm l ln lo">classes = identifyImage(path)</span><span id="928b" class="jj jk hi lh b fi lp lm l ln lo">#save image details to database</span><span id="6eec" class="jj jk hi lh b fi lp lm l ln lo">db.addNewImage(<br/>user_file.filename,<br/>classes[0][0][1],<br/>str(classes[0][0][2]),<br/>datetime.now(),<br/>UPLOAD_URL+user_file.filename)<br/>return jsonify({<br/>“status”:”success”,<br/>“prediction”:classes[0][0][1],<br/>“confidence”:str(classes[0][0][2]),<br/>“upload_time”:datetime.now()<br/>})</span></pre><p id="26f5" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">上述路径接受POST请求并检查文件，然后图像被传递给<em class="lt"> identifyImage(file_path) </em>方法，如下所示:</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="c330" class="jj jk hi lh b fi ll lm l ln lo">def identifyImage(img_path):<br/>    image = img.load_img(img_path,target_size=(224,224))<br/>    x = img_to_array(image)<br/>    x = np.expand_dims(x, axis=0)<br/>    x = preprocess_input(x)<br/>    preds = model.predict(x)<br/>    preds = decode_predictions(preds,top=1)<br/>    print(preds)<br/>    return preds</span></pre><p id="c3ea" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">此方法接受文件路径作为参数。然后，图像被转换为224*224大小，因为我们的模型需要图像的精确形状。然后，我们将预处理图像，并将其传递给model.predict()函数。现在，我们的模型将进行预测，解码后的预测将返回元组的2D数组(top=1仅返回1个具有最高置信度的预测)。</p><p id="b22f" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">然后，我们将把图像细节保存到我们的MongoDB数据库中，db.addData()将负责这项工作。数据库代码如下所示:</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="515f" class="jj jk hi lh b fi ll lm l ln lo">from pymongo import MongoClient<br/>from bson import ObjectId<br/>client = MongoClient(“mongodb://localhost:27017”) <em class="lt">#host uri<br/></em>db = client.image_predition <em class="lt">#Select the database</em></span><span id="8c1b" class="jj jk hi lh b fi lp lm l ln lo">image_details = db.imageData<br/>def addNewImage(i_name,prediction,conf,time,url):<br/>    image_details.insert({<br/>    “file_name”:i_name,<br/>    “prediction”:prediction,<br/>    “confidence”:conf,<br/>    “upload_time”:time,<br/>    “url”:url<br/>    })</span><span id="e668" class="jj jk hi lh b fi lp lm l ln lo">def getAllImages():<br/>    data = image_details.find()<br/>    return data</span></pre><p id="c5f6" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">由于此示例使用blueprint，我们可以将API代码编写在一个单独的文件中，如下所示:</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="2cc0" class="jj jk hi lh b fi ll lm l ln lo">from flask import Flask,render_template,jsonify,Blueprint<br/>mod = Blueprint(‘api’,__name__,template_folder=’templates’)<br/>from modules.dataBase import collection as db<br/>from bson.json_util import dumps</span><span id="b084" class="jj jk hi lh b fi lp lm l ln lo">@mod.route(‘/’)<br/>def api():<br/>    return dumps(db.getAllImages())</span></pre><p id="158a" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">我们有几个导入语句“dumps”帮助我们将py mongo(MongoDB的python api)对象转换成json值。</p><p id="4ccb" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">获取我们上传的所有图片。我们的API可以通过端点访问</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="99f5" class="jj jk hi lh b fi ll lm l ln lo"><a class="ae lf" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/</a>api  # address may vary depending upon the host provided in app.run()</span></pre><p id="2c4e" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">这里只解释代码的重要部分。要知道文件是如何排列的，请查看<a class="ae lf" href="https://github.com/SHARONZACHARIA/Deploy-ML-model" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。要了解更多关于Pymongo的信息，请点击查看<a class="ae lf" href="https://api.mongodb.com/python/current" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h2 id="7237" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">颤振应用</h2><p id="e149" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">该应用程序将使用REST API来获取图像并显示它，我们也可以通过内容搜索图像。我们的应用程序看起来会像这样</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/c4905ab2c694fe4df655e24921f1c4c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pe5_mSZroUox6XCpU1Rew.jpeg"/></div></div></figure><p id="e240" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">将作为我们的模型类的ImageData类</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="854f" class="jj jk hi lh b fi ll lm l ln lo">import ‘dart:convert’;<br/>import ‘package:http/http.dart’ as http;<br/>import ‘dart:async’;<br/>class ImageData<br/>{</span><span id="b61f" class="jj jk hi lh b fi lp lm l ln lo">String uri;<br/>String prediction;<br/>ImageData(<em class="lt">this</em>.uri,<em class="lt">this</em>.prediction);<br/>}</span><span id="a8f7" class="jj jk hi lh b fi lp lm l ln lo">Future&lt;List&lt;ImageData&gt;&gt; LoadImages() async<br/>{<br/>var data = await http.get(<br/>‘http://192.168.1.103:5000/api/'); #localhost api path<br/>var jsondata = json.decode(data.body);<br/>List&lt;ImageData&gt;list = [];<br/>for (var data in jsondata) {<br/>ImageData n = ImageData(data[‘url’],data[‘prediction’]);<br/>list.add(n);<br/>}</span><span id="6da9" class="jj jk hi lh b fi lp lm l ln lo">returnlist;</span><span id="8289" class="jj jk hi lh b fi lp lm l ln lo">}</span></pre><p id="ad9f" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">在这里，我们获取json数据，并将其转换为ImageData的对象列表，然后在LoadImages()函数的帮助下返回到Future Builder。</p><h2 id="713a" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">将图像上传到服务器</h2><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="cfdc" class="jj jk hi lh b fi ll lm l ln lo">uploadImageToServer(File imageFile)async</span><span id="4523" class="jj jk hi lh b fi lp lm l ln lo">{</span><span id="4f6f" class="jj jk hi lh b fi lp lm l ln lo">print(“attempting to connect to server……”);</span><span id="e3a3" class="jj jk hi lh b fi lp lm l ln lo">var stream = new http.ByteStream(DelegatingStream.typed(imageFile.openRead()));</span><span id="3c48" class="jj jk hi lh b fi lp lm l ln lo">var length = await imageFile.length();</span><span id="6db2" class="jj jk hi lh b fi lp lm l ln lo">print(length);</span><span id="8aa4" class="jj jk hi lh b fi lp lm l ln lo">var uri = Uri.parse(‘http://192.168.1.103:5000/predict');</span><span id="f177" class="jj jk hi lh b fi lp lm l ln lo">print(“connection established.”);</span><span id="1d0a" class="jj jk hi lh b fi lp lm l ln lo">var request = new http.MultipartRequest(“POST”, uri);</span><span id="e526" class="jj jk hi lh b fi lp lm l ln lo">var multipartFile = new http.MultipartFile(‘file’, stream, length,</span><span id="9471" class="jj jk hi lh b fi lp lm l ln lo">filename: basename(imageFile.path));</span><span id="ac33" class="jj jk hi lh b fi lp lm l ln lo"><em class="lt">//contentType: new MediaType(‘image’, ‘png’));</em></span><span id="eb37" class="jj jk hi lh b fi lp lm l ln lo">request.files.add(multipartFile);</span><span id="a3db" class="jj jk hi lh b fi lp lm l ln lo">var response = await request.send();</span><span id="cd12" class="jj jk hi lh b fi lp lm l ln lo">print(response.statusCode);</span><span id="644b" class="jj jk hi lh b fi lp lm l ln lo">}</span></pre><p id="1ae9" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">为了使我们的Flask应用程序在本地网络上可用，请确保该应用程序不处于调试模式，方法是将其更改为False，并使用<em class="lt"> ipconfig </em>命令从命令行找到ipv4地址。这里的地址是“192.168.1.103”</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="dd13" class="jj jk hi lh b fi ll lm l ln lo">app.run(debug=False,host=’192.168.1.103',port=5000)</span></pre><p id="15af" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">防火墙可能会阻止应用程序访问本地主机，因此请确保防火墙已关闭。</p><p id="fb99" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">关于Flutter app的完整代码参考可以在<a class="ae lf" href="https://github.com/SHARONZACHARIA/Deploy-ML-model" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。以下是一些其他有用的链接</p><p id="26b2" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">https://keras.io/</p><p id="7398" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">扑:<a class="ae lf" href="https://flutter.dev/" rel="noopener ugc nofollow" target="_blank">https://flutter.dev/</a></p><p id="761a" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">https://www.tutorialspoint.com/mongodb/</p><p id="264f" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">哈佛大学关于Python和flask的CS50课程:<a class="ae lf" href="https://www.youtube.com/watch?v=j5wysXqaIV8&amp;t=5515s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=j5wysXqaIV8&amp;t = 5515s</a>(观看讲座2、3、4)</p><p id="fead" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">GitHub:<a class="ae lf" href="https://github.com/SHARONZACHARIA/Deploy-ML-model" rel="noopener ugc nofollow" target="_blank">https://github.com/SHARONZACHARIA</a></p></div></div>    
</body>
</html>