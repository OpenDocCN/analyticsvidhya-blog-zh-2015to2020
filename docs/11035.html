<html>
<head>
<title>Categorical Encoding (One Hot Encoding) in Feature Engineering.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">特征工程中的分类编码(一种热编码)。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/categorical-encoding-in-feature-engineering-8f9e24737e48?source=collection_archive---------6-----------------------#2020-11-15">https://medium.com/analytics-vidhya/categorical-encoding-in-feature-engineering-8f9e24737e48?source=collection_archive---------6-----------------------#2020-11-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f9f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">一个热编码</strong></p><p id="a4a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一种热编码包括用不同的布尔变量(也称为哑变量)对每个分类变量进行编码，布尔变量取值0或1，指示某个类别是否出现在观察中。</p><p id="3657" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，对于分类变量“性别”，使用标签“女性”和“男性”，我们可以生成布尔变量“女性”，如果人是“女性”则取1，否则取0，或者我们可以生成变量“男性”，如果人是“男性”则取1，否则取0。</p><p id="078c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于值为“红色”、“蓝色”和“绿色”的分类变量“颜色”，我们可以创建3个新变量，称为“红色”、“蓝色”和“绿色”。如果观察是所述颜色，这些变量将取值1，否则取值0。</p><p id="041c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">编码成k-1个虚拟变量</strong></p><p id="1bc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，请注意，对于变量“颜色”，通过创建2个二进制变量，比如“红色”和“蓝色”，我们已经对所有的<strong class="ih hj"><em class="jd"/></strong>信息进行了编码:</p><p id="e837" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-如果观察值为红色，则由变量“红色”(红色= 1，蓝色= 0) <br/>捕获-如果观察值为蓝色，则由变量“蓝色”(红色= 0，蓝色= 1) <br/>捕获-如果观察值为绿色，则由“红色”和“蓝色”(红色= 0，蓝色= 0)组合捕获</p><p id="7c1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不需要添加第三个变量“绿色”来捕捉观察是绿色的。</p><p id="2096" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更一般地，分类变量应该通过创建k-1个二进制变量来编码，其中k是不同类别的数量。对于性别，k=2(男性/女性)，因此我们只需要创建1(k-1 = 1)个二元变量。以颜色为例，它有3个不同的类别(k=3)，我们需要创建2个(k-1 = 2)二进制变量来捕捉所有的信息。</p><p id="032c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一种热编码成k-1个二进制变量的方法考虑到，我们可以少用1个维度，但仍能表示全部信息:如果观察值在所有二进制变量中为0，那么它在最终的(不存在的)二进制变量中必然为1。</p><p id="6309" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">当一个热点编码分类变量时，我们创建k — 1个二元变量。</strong></p><p id="c8d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数机器学习算法在拟合时考虑整个数据集。因此，将分类变量编码成k-1个二进制变量更好，因为它避免了引入冗余信息。</p><p id="ce52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">异常:一次热编码成k个虚拟变量</strong></p><p id="27ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一些情况下，最好将变量编码为k个虚拟变量:</p><p id="7579" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-当构建基于树的算法时<br/> -当通过递归算法进行特征选择时<br/> -当对确定每个单一类别的重要性感兴趣时</p><p id="636f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与大多数机器学习算法相反，<strong class="ih hj">基于树的算法在被训练时不</strong>评估整个数据集。他们在每棵树的每个节点从数据集中随机提取一个特征子集。因此，如果我们想要一个基于树的算法来考虑<strong class="ih hj">所有</strong>的类别，我们需要将分类变量编码成<strong class="ih hj"> k个二元变量</strong>。</p><p id="1507" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们计划通过递归消除(或添加)来进行特征选择，或者如果我们想要评估分类变量的每个单一类别的重要性，那么我们还需要整个二元变量集(k)来让机器学习模型选择哪些变量具有最大的预测能力。</p><h2 id="9d33" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><strong class="ak">一次热编码的优势</strong></h2><p id="d28a" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">-直接实施<br/> -不假设分类变量<br/>的分布或类别-保留分类变量<br/>的所有信息-适用于线性模型</p><h2 id="af2e" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">限制</h2><p id="994e" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">-扩展特征空间<br/> -编码时不添加额外信息<br/> -许多虚拟变量可能相同，从而引入冗余信息</p><h2 id="d2cc" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">笔记</h2><p id="5dce" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">如果我们的数据集包含一些高度基数的变量，我们很快就会得到有数千列的数据集，这可能会使我们的算法训练缓慢，模型解释困难。</p><p id="b5db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，这些虚拟变量中的许多可能彼此相似，因为两个或更多变量共享相同的1和0的组合并不罕见。因此，即使我们编码成k-1，一个热编码也可能引入冗余或重复的信息。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ke"><img src="../Images/bdacd452956bf09584ff8dd47da5a63d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iipcQp-LXjP8b14lvMku0A.jpeg"/></div></div></figure><h2 id="9ac8" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">编码很重要</h2><p id="456d" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">就像插补一样，所有分类编码方法都应该在训练集上执行，然后传播到测试集。</p><p id="925e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么？</p><p id="b0df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为这些方法将从训练数据中“学习”模式，因此您希望避免泄露信息和过度拟合。但更重要的是，因为我们不知道在未来/实时数据中，我们是否会有所有类别出现在训练数据中，或者是否会有更多或更少的类别。因此，我们希望通过从一开始就设置正确的流程来预测这种不确定性。我们希望创建从训练集学习类别的转换器，并使用这些学习的类别在训练集和测试集中创建虚拟变量。</p><p id="63c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">##熊猫的一个热门编码</p><h2 id="caee" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">优势</h2><p id="391b" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">- quick <br/> -返回熊猫数据帧<br/> -返回虚拟变量的特征名称</p><h2 id="4fb0" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">熊猫的局限性:</h2><p id="e8f4" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">-它不保存从训练数据传播到测试数据的信息</p><p id="0949" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">— — -</p><p id="1253" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">pandas方法get_dummies()将创建与变量中的类别一样多的二进制变量:</p><p id="9a1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果变量颜色在训练数据中有3个类别，它将创建2个虚拟变量。然而，如果变量colour在测试数据中有5个类别，它将创建4个二进制变量，因此训练和测试集将以不同数量的特征结束，并且将与使用Scikit-learn的训练和评分不兼容。</p><p id="ed8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实践中，我们不应该在我们的机器学习管道中使用get-dummies。然而，它对于快速数据探索是有用的。我们用例子来看看这个。</p><h2 id="3e59" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">转换成k个虚拟变量</h2><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kq"><img src="../Images/dc492b2ecca8005b96fe8d856356488c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*wYO2H0KENEf4Vn6bTMi-VQ.jpeg"/></div></figure><h2 id="1162" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">额外收获:get_dummies()可以处理缺失值</h2><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kr"><img src="../Images/38d28f3720999dc6885722942d3dba0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fle-XhDpFMR8-8uJtl2h-g.jpeg"/></div></div></figure><h2 id="b2e3" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">Scikit-learn的一个热门编码</h2><p id="9b79" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated"><strong class="ih hj">优势</strong></p><p id="00aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-快速<br/> -在训练和测试集中创建相同数量的功能</p><p id="cd95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">局限性</strong></p><ul class=""><li id="4d9f" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated">它返回一个numpy数组，而不是pandas data frame<br/>——它不返回变量名，因此不便于变量探索。</li></ul><p id="9f77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读。我的<a class="ae lb" href="https://www.linkedin.com/in/ankush-kunwar777/" rel="noopener ugc nofollow" target="_blank"> linkedin </a></p></div></div>    
</body>
</html>