<html>
<head>
<title>Reverse LinkedList — Day 6(Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反向链接列表—第 6 天(Python)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/reverse-linkedlist-day-6-python-6561d068cb0?source=collection_archive---------4-----------------------#2020-09-29">https://medium.com/analytics-vidhya/reverse-linkedlist-day-6-python-6561d068cb0?source=collection_archive---------4-----------------------#2020-09-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/694e194146f8f3e8b0fa5d24f8436ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KhPEk5KBYDzPx9xo"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae iu" href="https://unsplash.com/@hush52?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hush Naidoo </a>拍摄的照片</figcaption></figure><p id="7af3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天我们将学习如何反转链表。365 天挑战系列的第 2 天介绍了链表的基本特性。如果你需要复习，可以点击这个<a class="ae iu" rel="noopener" href="/@atharayil/palindrome-linkedlist-day-2-python-441a963697dc">链接</a>。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="d0af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/reverse-linked-list/" rel="noopener ugc nofollow" target="_blank">T7】206</a><strong class="ix hj">。反向链表</strong></p><p id="80bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">反转单向链表。</p><p id="324e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">示例:</strong></p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="298f" class="kj kk hi kf b fi kl km l kn ko"><strong class="kf hj">Input:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br/><strong class="kf hj">Output:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></pre><p id="b6e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">跟进:</strong></p><p id="4e7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">链表可以迭代或递归地反转。你能两者都实现吗？</p><p id="6e86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们开始解决问题之前，让我们再看几个例子。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="467d" class="kj kk hi kf b fi kl km l kn ko"><strong class="kf hj">Input:</strong> 1-&gt;NULL<br/><strong class="kf hj">Output:</strong> 1-&gt;NULL</span><span id="db7c" class="kj kk hi kf b fi kp km l kn ko"><strong class="kf hj">Input:</strong> 1-&gt;2-&gt;NULL<br/><strong class="kf hj">Output:</strong> 2-&gt;1-&gt;NULL</span><span id="c8a1" class="kj kk hi kf b fi kp km l kn ko"><strong class="kf hj">Input:</strong> NULL<br/><strong class="kf hj">Output:</strong>NULL</span></pre><p id="eca2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决方案—迭代方法</p><p id="0a5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了通过迭代方法反转一个链表，我们需要 3 个指针。</p><ol class=""><li id="5d9e" class="kq kr hi ix b iy iz jc jd jg ks jk kt jo ku js kv kw kx ky bi translated">保存上一个节点。</li><li id="797a" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">保存当前节点。</li><li id="5924" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">保存下一个节点。</li></ol><p id="3915" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们只需要学习如何操作以上三个指针来反转一个链表。</p><ol class=""><li id="61ba" class="kq kr hi ix b iy iz jc jd jg ks jk kt jo ku js kv kw kx ky bi translated">将先前的(A)指针初始化为“无”。</li><li id="b2d0" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">让当前指针(B)指向链表的头部。</li><li id="83ec" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">运行循环，直到电流到达终点。</li><li id="608b" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">下一个指针(C)指向当前的下一个。</li><li id="a8ab" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">当前指针的下一个指向上一个。B -&gt; A</li><li id="3cc2" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">前一个指针现在是当前节点。</li><li id="541e" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">当前指针现在是当前指针的下一个</li></ol><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="5176" class="kj kk hi kf b fi kl km l kn ko">class Solution:<br/>    def reverseList(self, head: ListNode) -&gt; ListNode:<br/>         if head == None or head.next == None:<br/>            return head<br/>         prev, curr = None, head<br/>         while curr:<br/>               next_node = curr.next<br/>               curr.next = prev<br/>               prev = curr<br/>               curr = next_node<br/>         return prev</span></pre><p id="bfe8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复杂性分析</p><p id="78df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="7571" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要遍历 LinkedList 中的每个元素，这需要 O(N)时间。</p><p id="3074" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度</strong></p><p id="e06f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们没有使用任何额外的数据结构来存储上述逻辑。因此空间复杂度是 O(1)。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="ef0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解答——递归方法</p><p id="bf18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当使用递归方法时，我们需要一个基本条件。</p><ol class=""><li id="10c4" class="kq kr hi ix b iy iz jc jd jg ks jk kt jo ku js kv kw kx ky bi translated">对于这个问题，我们的基本条件是当 head 为 None 或 next of head 为 None。当我们到达基地时，我们需要返回。</li><li id="1ac1" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">如果我们必须在到达基本条件之前运行几个节点，递归调用函数。</li><li id="5599" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">头的下一个是头，头的下一个是无。</li><li id="25c1" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">然后返回电流。</li></ol><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="4d5a" class="kj kk hi kf b fi kl km l kn ko">class Solution:<br/>    def reverseList(self, head: ListNode) -&gt; ListNode:<br/>        if head == None or head.next == None:<br/>            return head<br/>        curr = self.reverseList(head.next)<br/>        head.next.next = head<br/>        head.next = None<br/>        return curr</span></pre><p id="5285" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面给出了上述逻辑的动画版本。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="bdb7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="be9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要遍历 LinkedList 中的每个元素，这需要 O(N)时间</p><p id="b65c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度</strong></p><p id="c47f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">内部递归函数使用堆栈来执行程序。因此空间复杂度是 O(N)。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="3790" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想提高我的写作技巧，所以任何建议或批评都非常欢迎。</p></div></div>    
</body>
</html>