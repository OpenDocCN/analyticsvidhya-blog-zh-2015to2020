<html>
<head>
<title>AWS Lambda layer in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的AWS Lambda层</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/aws-lambda-layer-in-java-ad67ce5d94b4?source=collection_archive---------1-----------------------#2020-01-22">https://medium.com/analytics-vidhya/aws-lambda-layer-in-java-ad67ce5d94b4?source=collection_archive---------1-----------------------#2020-01-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4116bac142604d5e33609f44fb5688cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_o_5O1wxIQYLc7qpYUwiA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">AWS层</figcaption></figure><h1 id="f291" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">什么是lambda层？</h1><p id="1bb9" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">AWS早在2018年就推出了Lambda层，作为在不同帐户内部和之间的功能之间共享代码和数据的一种方式。</p><p id="940c" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">Lambda层允许我们在多个lambda函数之间共享公共代码和依赖关系。</p><p id="5062" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">使用lambda层来管理和控制lambda功能将为基于lambda的架构提供一个灵活、可扩展且坚实的基础。</p><h1 id="c37b" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">为什么使用lambda层？</h1><p id="5909" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">使用lambda层的主要好处是:</p><ul class=""><li id="10a3" class="kv kw hi ju b jv kq jz kr kd kx kh ky kl kz kp la lb lc ld bi translated"><strong class="ju hj">小的结果JAR </strong> —部署的每个函数都很小，只包含与它打算做的动作相关的代码。</li><li id="a849" class="kv kw hi ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated"><strong class="ju hj">共享依赖项的单一打包</strong> —无需将共享依赖项或代码与每个功能打包在一起。</li><li id="bcbc" class="kv kw hi ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated"><strong class="ju hj">灵活的代码更新</strong> —代码或依赖项的更新只发生在一个地方，而不是每个函数。</li></ul><p id="27e5" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">简而言之，lambda层是为了帮助我们使用灵活、可扩展和简单的管理工具开发更高规模和复杂的lambda功能。</p><h1 id="90d1" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">什么时候使用lambda层？</h1><p id="be3f" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">lambda层的使用有时会产生更多的问题，而不是解决方案。尤其是在用Java这样的静态语言编码时，在编译过程中需要所有的代码和依赖项。</p><p id="98bd" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">在我看来，应该在以下情况下使用lambda层:</p><ul class=""><li id="8405" class="kv kw hi ju b jv kq jz kr kd kx kh ky kl kz kp la lb lc ld bi translated">频繁更新的大型依赖项。</li><li id="9d46" class="kv kw hi ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">自定义lambda运行时。</li><li id="fa78" class="kv kw hi ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">Lambda函数自定义包装。</li></ul><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/49920b3045c774204f4b097c378c1d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J9kmqLjFBzyTfIY7RlUmgg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">λ函数</figcaption></figure><h1 id="4302" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">Java中的Lambda层:</h1><p id="fb6a" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">据我们目前所知，用Java编写lambda层是一件非常痛苦的事情。我不建议这样做。使用Python或NodeJS会简单快捷得多。</p><p id="e1cb" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">但是在某些情况下。用不同的语言将现有的用Java编写的服务移植到lambda函数中的成本，将比用本教程和用Java部署lambda层更令人痛苦。</p><h1 id="a89f" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">Lambda基本包装:</h1><p id="a9a2" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">我们要做的第一件事是创建函数触发器处理程序，这个触发器处理程序将使用我们作为函数的第一个<strong class="ju hj">和最基本的lambda层</strong>。我们将使用MAVEN和openjdk8。</p><p id="9f2e" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">因此，我们的初始pom.xml应该包含以下依赖项:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/60255a3153ec68bb58db1af795f8ead6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yj9FQw8eJjYqgQyzJk722Q.png"/></div></div></figure><p id="e129" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">还有阴影插件:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/c45b20fa1a9ccc5a96f57eb291898f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_tWJ86KM7_j7O4rC3dTew.png"/></div></div></figure><ul class=""><li id="a7ba" class="kv kw hi ju b jv kq jz kr kd kx kh ky kl kz kp la lb lc ld bi translated">注意转换器到log4j2日志框架的依赖关系部分。如果您想在应用程序中使用log4j logger，请添加以下依赖项:</li></ul><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/88eb41757da931f1c8c90c96fd33b8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5CF7rX5ukr19Z8HzfVlMw.png"/></div></div></figure><p id="f3f8" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">现在我们正在编写我们的第一个功能层，包含一些功能而不仅仅是依赖。我建议尽可能减少这一层。欢迎您的实现所需的任何其他依赖项。只要记住，这一层应该是通用和轻。</p><p id="6b66" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">除此之外，根据您使用的aws SDK的版本，会出现一些版本冲突，应该予以解决。请确保按照<a class="ae lq" href="https://docs.aws.amazon.com/lambda/latest/dg/java-programming-model-handler-types.html" rel="noopener ugc nofollow" target="_blank"> AWS文档</a>完成您的pom.xml</p><h1 id="a33d" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">Lambda处理程序类:</h1><p id="2f68" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">下一步是创建需要时由AWS Lambda触发的处理程序。</p><p id="1279" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">这可以通过使用RequestHandler接口<i o="">来完成，该接口要求我们实现handleRequest方法。</i></p><p id="ac13" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">在我的例子中，我选择使用抽象类来实现这个接口，这将允许我在所有lambda函数和AWS Lambda接口之间创建一个可靠的基础结构。</p><p id="3a18" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我的例子描述了一个抽象的SQS消息lambda触发器。</p><p id="7c34" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">请注意课堂内的评论以获得进一步的解释</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/04863dbb726e1315f55e677e9cf54016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5nwl7-jIbaD-LON87nE5g.png"/></div></div></figure><h1 id="b193" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">本地安装和使用:</h1><p id="fae8" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">现在，为了使用我们的新lambda层，我们需要安装并导入它。</p><ol class=""><li id="177d" class="kv kw hi ju b jv kq jz kr kd kx kh ky kl kz kp ls lb lc ld bi translated"><strong class="ju hj">层安装:<br/> </strong>这是一个非常简单的任务，我们将使用MAVEN使用shade插件创建我们的fat jar】结果将是一个新的JAR安装在我们的本地存储库. m2中。我们将使用这个JAR作为我们的层部署的一部分(稍后将解释)。但也是lambda函数的基础层。</li><li id="bc2c" class="kv kw hi ju b jv le jz lf kd lg kh lh kl li kp ls lb lc ld bi translated"><strong class="ju hj">图层导入:<br/> </strong>在进入技术部分之前，我们先了解一下我们到底要做什么，为什么这不是那么微不足道。<br/>我们希望最终创建一个JAR，它可以被MAVEN使用我们在pom.xml中的描述正确地编译，但是我们不想把这个JAR的依赖项打包在一起。<br/> <br/> <strong class="ju hj">为什么？好吧，那样做将使层的使用变得毫无意义，我们不想把每个函数和它所有的依赖项打包在一起。我们希望能够只编译我们需要的代码，并在运行时为不同的存储库使用依赖关系。<br/> <strong class="ju hj">如何？为了让这个奇怪的设置工作起来，我们需要本地. m2存储库中所有可用的依赖项。我们需要将依赖项物理导入到我们的本地环境中。我们在编译时需要它，这样我们就能访问我们的代码。现在，为了标记MAVEN不要将这些依赖项与我们的代码打包在一起，我们将在依赖项定义中使用提供的作用域。</strong></strong></li></ol><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/715e61680a9cb721bb333834744a26a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CS91F5vIogDRGUNxRbFpsw.png"/></div></div></figure><p id="05a6" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">为运行时要从lambda层提取的每个依赖项添加提供的范围。只要确保版本和JAR名称匹配即可。</p><p id="0836" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">现在留给您的就是创建一个扩展您在基本层中创建的LambdaAbstractWrapper类的类，设置函数的返回类型并实现processMessage抽象方法。</p><h1 id="42d2" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">运行时的层打包:</h1><p id="c751" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">正如我们前面提到的，一旦函数被调用，我们的lambda层就被添加到lambda函数运行时环境中。那么，我们如何告诉lambda运行时我们想要哪些层呢？以及它们的位置，以便我们的应用程序能够使用它们？</p><p id="670c" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">首先，让我们创建一个lambda层:</p><ol class=""><li id="524b" class="kv kw hi ju b jv kq jz kr kd kx kh ky kl kz kp ls lb lc ld bi translated">将所有需要的JAR文件压缩成一个压缩文件— LambdaLayer.zip</li><li id="69df" class="kv kw hi ju b jv le jz lf kd lg kh lh kl li kp ls lb lc ld bi translated">将此ZIP文件上传到所需的S3存储桶中。<br/> <code class="du lt lu lv lw b">aws s3 cp LambdaLayer.zip s3://&lt;BUCKET_NAME&gt;</code></li><li id="abc1" class="kv kw hi ju b jv le jz lf kd lg kh lh kl li kp ls lb lc ld bi translated">使用aws CLI创建新的lambda层并保存响应。<br/> <code class="du lt lu lv lw b">aws lambda publish-layer-version --layer-name &lt;LAYER_NAME&gt;\<br/>--compatible-runtimes java8\<br/>--content S3Bucker=&lt;BUCKET_NAME&gt;,S3Key=LambdaLayer.zip\ <br/>&gt;&gt; LambdaLayerResult.json</code></li></ol><p id="11c2" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">现在，您应该有一个与Java lambda函数兼容的lambda层了。你可以通过登录你的AWS账户，导航到lambda并点击左侧菜单中的“层”来验证它。CLI调用的结果被保存到一个名为LambdaLayerResult.json的文件中。当我们定义lambda函数时，我们将需要它来将层附加到函数上。</p><h1 id="0a33" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">创建和部署Lambda函数:</h1><p id="3a84" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">现在，我们将创建我们的lambda执行角色，部署我们的Java lambda函数，并将其附加到我们在上一部分中创建的lambda层。</p><ol class=""><li id="97da" class="kv kw hi ju b jv kq jz kr kd kx kh ky kl kz kp ls lb lc ld bi translated">创建一个lambda执行角色<a class="ae lq" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html" rel="noopener ugc nofollow" target="_blank">的例子</a>，保存新角色ARN以备后用。</li><li id="5f32" class="kv kw hi ju b jv le jz lf kd lg kh lh kl li kp ls lb lc ld bi translated">使用MAVEN构建我们的lambda函数JAR—<code class="du lt lu lv lw b">mvn clean install</code></li><li id="72dd" class="kv kw hi ju b jv le jz lf kd lg kh lh kl li kp ls lb lc ld bi translated">使用aws CLI上传lambda函数:</li></ol><p id="4460" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><code class="du lt lu lv lw b">aws lambda create-fucntion --function-name &lt;FUNCTION_NAME&gt;\<br/>--runtime java8 --role &lt;ROLE_ARN&gt; --handler &lt;PATH_TO_HANDLER_CLASS&gt;\<br/>--memory-size &lt;MEMORY_SIZE_IN_MB&gt; --region &lt;REGION&gt; --layers &lt;LAYER_ARN&gt;\ --zip-file fileb://&lt;PATH_TO_JAR&gt; --publish</code></p><p id="3461" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">现在，我们已经创建了lambda执行角色，lambda函数，并为其附加了lambda层。你可以通过登录你的aws账户，导航到lambda并在Functions下搜索你的新函数来验证它。</p><p id="1e20" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">就是这样！</p><p id="d052" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">一般来说，Lambda函数是无服务器架构中的一个强大工具。用Java管理lambda层的能力将允许你维护一个简单、强大和灵活的无服务器环境。</p><h1 id="dd05" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">从VPC内部的lambda函数访问互联网有问题吗？我有一个解决方案给你！</h1><p id="80fa" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">阅读我的媒体<a class="ae lq" rel="noopener" href="/@asafadar55/vpc-lambda-internet-access-f70a55dc7a39">关于问题和解决方案的故事</a>！</p><p id="ae54" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">请继续关注更多关于aws无服务器基础设施的教程</p></div></div>    
</body>
</html>