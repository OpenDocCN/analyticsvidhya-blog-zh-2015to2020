<html>
<head>
<title>“Hello World” in Image Recognition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像识别中的“Hello World”</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/hello-world-in-image-recognition-136eba581464?source=collection_archive---------8-----------------------#2020-02-15">https://medium.com/analytics-vidhya/hello-world-in-image-recognition-136eba581464?source=collection_archive---------8-----------------------#2020-02-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="10e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着人工智能和人工智能新时代的到来，在图像识别、自动化、自然语言处理和物体检测领域进行了大量的研究和项目。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/38cba7bf064c8ca0cb54300ae3f0aef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUumH_GH2G82WyqZjROaIQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">物体检测(图像识别的外推)</figcaption></figure><p id="72c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">人工智能的应用是无限的。它们可以用来自动化不同的密切相关的活动，给人类带来更多的舒适。图像识别是人工智能的关键要素之一。有没有注意到脸书是如何立即认出你朋友的脸，并问你是否想在照片中给他做标记的？从控制无人驾驶汽车到为生物识别访问进行人脸检测，图像识别有助于根据训练好的算法对对象进行处理和分类。那么，让我们创建一个图像识别分类器，来简单介绍一下这个领域。</p><h1 id="c84d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">先决条件</h1><ol class=""><li id="9993" class="kr ks hi ih b ii kt im ku iq kv iu kw iy kx jc ky kz la lb bi translated">python-基本语法</li></ol><h1 id="ed7b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">工具和技术</strong></h1><ol class=""><li id="705a" class="kr ks hi ih b ii kt im ku iq kv iu kw iy kx jc ky kz la lb bi translated"><strong class="ih hj">巨蟒</strong></li><li id="b55c" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">文字编辑</strong>(Sublime)-<a class="ae lh" href="https://www.sublimetext.com/Sublime%20Text%201.4%20Setup.exe" rel="noopener ugc nofollow" target="_blank">https://www . Sublime Text . com/Sublime % 20 Text % 201.4% 20 setup . exe</a></li><li id="e51f" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj"> Keras </strong> - pip安装Keras</li><li id="ecf8" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">张量流</strong>-<a class="ae lh" href="https://www.tensorflow.org/install/install_windows" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/install/install_windows</a></li><li id="0755" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">卷积神经网络-</strong><a class="ae lh" href="https://adeshpande3.github.io/A-Beginner%27s-Guide-To-Understanding-Convolutional-Neural-Networks/" rel="noopener ugc nofollow" target="_blank">https://adeshpande 3 . github . io/A-初学者% 27s-理解指南-卷积神经网络/ </a></li></ol><h1 id="f5e6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">准备…稳定…开始… </strong></h1><p id="14d3" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">我们将使用CIFAR-10数据集开发一个图像识别系统。该过程主要由两个步骤组成</p><ol class=""><li id="fd0a" class="kr ks hi ih b ii ij im in iq ll iu lm iy ln jc ky kz la lb bi translated">创建和保存训练模型</li><li id="4711" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">加载训练好的模型进行分类</li></ol><h1 id="c67f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">如何着手去做？</h1><ol class=""><li id="8d46" class="kr ks hi ih b ii kt im ku iq kv iu kw iy kx jc ky kz la lb bi translated">导入库</li><li id="3e61" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">加载数据集并将其拆分</li><li id="97e5" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">正常化</li><li id="ff1c" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">设计神经网络架构</li><li id="bfdd" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">编译模型</li><li id="8cea" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">训练模型</li><li id="cee4" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">保存神经网络模型和权重</li><li id="6ad5" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">加载保存的模型和权重</li><li id="9862" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">测试</li></ol><h1 id="7a10" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">导入库</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lo"><img src="../Images/c6cbf4406185ea7c214794355744d0f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gbJjS5F_L2wM-eIC0XIeA.png"/></div></div></figure><p id="0518" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用由<strong class="ih hj"> keras </strong>提供的不同模块，因此我们需要首先导入它们。每个导入模块的使用将在相应模块的实现部分中得到理解。</p><h1 id="3a5b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">加载数据集</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lp"><img src="../Images/e77e1282c8dd2b48b6f5ee1448e91600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*zZok6LxpsfUxL7vVXBYVlQ.png"/></div></figure><p id="9367" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Keras由库中的一些数据集组成。我们将使用其中一个名为<strong class="ih hj"> CIFAR-10 </strong>的。CIFAR-10数据集由<strong class="ih hj"> 60000 </strong>张<strong class="ih hj">32×32像素大小</strong>的彩色图像组成<strong class="ih hj"> 10类</strong>，每类6000张图像。Keras具有load_data()函数，该函数以<strong class="ih hj"> 5:1的比率</strong>将CIFAR图像作为训练和测试分割数据返回。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/8826ebc23bb7a8c20044500c788907e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VaCOLnJjYENWnmdY8KbOTg.png"/></div></div></figure><p id="77bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">偷窥图像- </strong></p><p id="4a08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像基本上是三个通道的组合，即红色、蓝色和绿色。这些通道中的每一个的不同量一起构成适当的颜色。它可以用数值矩阵的形式来表示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lr"><img src="../Images/f0d8f276c9880bff2efda18dfce3af35.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*5tYiY5eyRkkVDjKLMmhrXQ.png"/></div></figure><h1 id="4fda" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">正常化</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ls"><img src="../Images/f47a5d0dd69127d41bf269891e5c867a.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*YWUoZM-kqjc-j9HoZJHUPA.png"/></div></figure><p id="9be5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将数值转换成'<strong class="ih hj">浮点型</strong>'类型。下一步是标准化数据，即从<strong class="ih hj">【0，255】转换到【0，1】</strong>。由于自变量在向量(整数)中，我们将其转换为二进制类矩阵。</p><h1 id="3921" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">设计神经网络架构</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lt"><img src="../Images/50c38447de86c17b89ea8627fb9bb167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDKXsXuJgrl-X87xSGfQpA.png"/></div></div></figure><p id="3c04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们选择模型为<strong class="ih hj">顺序</strong>，即一层的输出到下一层。还有其他模型，其中的连接是非顺序的。</p><p id="38e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卷积神经网络的基本构造块是卷积块。卷积块包括:-</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/b5e07766d0afc662f32e6cde7a8888ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ZE7CSuvVxkKg6POZ9_BsA.png"/></div></div></figure><ol class=""><li id="ee79" class="kr ks hi ih b ii ij im in iq ll iu lm iy ln jc ky kz la lb bi translated"><strong class="ih hj">卷积层(基本使用-平移不变性)</strong></li></ol><p id="0e22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">平移不变性-它是当ML模型能够识别一个对象而不管它是否在图像中移动(放置)时的属性。</p><p id="3dae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网络的顶层识别简单模式(线、边),底层识别密集模式。</p><p id="93d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“粗略的想法是，我们不断用每个卷积层压缩图像，同时从中捕捉最重要的信息。” </p><p id="de30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意——但这并不意味着增加层数就能提高精度。这是一个反复试验的过程。</p><p id="68e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于图像类型的数据，我们使用<strong class="ih hj"> Conv2D </strong>层。如果我们处理的数据是一维的，比如声波，那么我们使用Conv1D。这里我们使用Conv2D层，在这里我们分别定义了<strong class="ih hj">数量的滤镜</strong>、<strong class="ih hj">窗口平铺尺寸</strong>、<strong class="ih hj">填充</strong>、<strong class="ih hj">激活函数、</strong>和<strong class="ih hj">输入形状</strong>。由于我们使用的图像尺寸为32×32，有3个通道，因此我们相应地定义了第一层的<strong class="ih hj"> </strong>输入形状。</p><p id="52f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么我们基本都用<strong class="ih hj">填充</strong>？-可能发生图像的长度不能被窗口小块的尺寸整除的情况(这里我们使用<strong class="ih hj"> (3，3) </strong>窗口，图像的长度是<strong class="ih hj"> 32 </strong>像素)，在这种情况下，我们的一些边缘可能会保持未使用，这是一个问题，因为我们的对象可能在整个图像的任何地方。</p><p id="4c24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">激活函数</strong> -它定义了前一层的哪个节点的输出对于下一层的输入是重要的。<strong class="ih hj">Relu</strong>’(校正线性单位)是最常用于图像的激活功能。在神经网络结构的最后一层，我们使用max 的<strong class="ih hj">激活函数，因为它确保最后一层的所有输出加1。</strong></p><p id="4c28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">展平层- </strong>是Conv2D和密集层之间的过渡。它主要描述了我们正在从2 D数据过渡到1 D数据的事实。</p><p id="c94a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">密集层- </strong>(又名全连通层)是一个向量矩阵相乘的例子。我们还提到了这一层中需要的输出节点的数量。这里我们提到密集层中的<strong class="ih hj"> 10个节点</strong>，因为有<strong class="ih hj"> 10个类</strong>。</p><p id="f862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。最大汇集层(基本使用-下采样数据)</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/c33fc788f8846061e57f24bf284aabcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gaD6SJ6kQNVOclE_WkwLNQ.png"/></div></div></figure><p id="ee6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">下采样数据</strong>——顾名思义，它基本上只从所有值中选择最大值，从而减少了工作量(计算量和时间)。这里我们使用的池大小为<strong class="ih hj"> (2，2) </strong>，因此我们从每个(2，2)池中选择最大值进行训练。</p><p id="67c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。辍学层(基本用途-稳健学习)</strong></p><p id="7859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">鲁棒学习</strong>——它随机地丢弃神经网络的一些连接节点。这导致神经网络更努力地学习，并且不依赖于单个连接。<strong class="ih hj">【25%-50%】</strong>之间的一个漏接效果很好。</p><h1 id="604a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">编译模型</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lx"><img src="../Images/796d68c718a18485002b74f1e90aee19.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*4PKWIdStOhq1jfoBzzI_oQ.png"/></div></figure><p id="ce75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在编译过程中，有3个基本参数；-</p><ol class=""><li id="0b57" class="kr ks hi ih b ii ij im in iq ll iu lm iy ln jc ky kz la lb bi translated"><strong class="ih hj">损失函数</strong>——检验神经网络正确性的函数。损失函数有很多种。这里我们将使用'<strong class="ih hj">分类交叉熵</strong>，它用于分类因变量。二元因变量还有'<strong class="ih hj">二元交叉熵</strong>'。</li><li id="0aab" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">优化器</strong> -优化算法帮助我们<strong class="ih hj">最小化(或最大化)</strong>一个<strong class="ih hj">目标</strong>函数，它只是模型中使用的<strong class="ih hj">因变量(Y) </strong>和<strong class="ih hj">自变量(X) </strong>之间的数学关系。如果想要快速收敛并训练深度神经网络模型或高度复杂的神经网络，则应使用<strong class="ih hj"> Adam或任何其他自适应学习速率技术</strong>，因为它们优于所有其他优化算法。</li><li id="951f" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">指标</strong>——就这么简单，这些是我们的神经网络测试的参数。这里我们使用<strong class="ih hj">精确度</strong>作为衡量标准。</li></ol><h1 id="f9b5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">训练模型</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ly"><img src="../Images/ecdbeb10a260bfc802699df80a8d0f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*o6AbbRJ2yW83-s5XnK7C7Q.png"/></div></figure><p id="2231" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们需要检查我们的模型实际上是什么样子，它有什么特征，那么我们使用<strong class="ih hj">摘要</strong>来了解这个模型。它描述了我们的模型已经识别的<strong class="ih hj">可训练参数</strong>。我们还可以知道每个卷积层后的<strong class="ih hj">输出形状</strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lz"><img src="../Images/0c4313e773e855d2f786e1d11ac77a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*eRst7HLg1F4rlgBAbrGNGw.png"/></div></figure><p id="594d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们使用<strong class="ih hj">拟合</strong>方法来拟合我们的模型，并开始训练它。这些参数包括<strong class="ih hj">训练数据</strong> (x_train和y _ train)<strong class="ih hj">测试数据</strong> (x_test和y_test)以及其他不同的参数。</p><p id="730b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">批次大小</strong>表示在一个批次中要拍摄多少幅图像用于学习。通常批量大小从<strong class="ih hj"> 32 </strong>到<strong class="ih hj"> 128 </strong>不等。</p><p id="e2db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要多次重复训练以提高精确度，这是通过使用<strong class="ih hj">时期</strong>来完成的。大多数情况下，观察到数据集越大，历元越少(但不总是如此)。</p><p id="7e0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了确保我们避免由于训练数据的顺序而在训练中出现任何类型的重合，我们使用<strong class="ih hj">打乱</strong>默认的训练数据集。</p><p id="c16d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意-训练时，损耗应减少，准确度应增加。如果不是这样，那么尝试使用不同的数据集、不同的神经网络结构或调整您的参数。</strong></p><h1 id="2e3d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">保存神经网络模型和权重</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ma"><img src="../Images/958ca31fa248ccd1fb1142b5efba1c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*39LMPlIU0DG0zSGngX7t6A.png"/></div></figure><p id="75be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最后一步，我们保存模型，即神经网络<strong class="ih hj">结构</strong>以及<strong class="ih hj">权重</strong>。该结构保存在<strong class="ih hj">中。json </strong>格式，而权重以<strong class="ih hj"> hdf5 </strong> (.h5)格式存储。hdf5格式用于存储大型二进制文件。</p><h1 id="31c6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">加载保存的模型和重量</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/adb7dae2c4d205a4b990487fdd4cdd33.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*sTl2gwpwmbiPIFIa1f5iiA.png"/></div></div></figure><p id="730d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在代码的下一部分，我们导入所有在测试部分使用的模块。代码中的<strong class="ih hj">类标签</strong>以<strong class="ih hj">的特定顺序</strong>出现。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mc"><img src="../Images/6763fecfed6be6231ae91e6da248681d.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*DJC1IFsjZb1tJDEuOxtx8w.png"/></div></div></figure><p id="2b14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要指定。json和. h5文件放在它们各自的路径中。装载步骤包括<strong class="ih hj">装载结构</strong>以及<strong class="ih hj">重物</strong>。</p><h1 id="36c9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">测试</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es md"><img src="../Images/6e4ed84a1ab412d72d328726a07e2e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dpZpkyo60oLkLT2SFUOdDw.png"/></div></div></figure><p id="06a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们实际上正在等待的代码部分。首先，我们加载测试图像，并使用<strong class="ih hj">目标尺寸</strong>将其转换为与训练模型图像的尺寸相匹配。因此，我们将图像标准化，并将其转换成一个<strong class="ih hj"> NumPy数组</strong>进行测试。</p><p id="8067" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用扩展维度函数，因为预测函数接受<strong class="ih hj"> 4 D </strong>输入。4 D基本上是<strong class="ih hj">图像列表</strong>的<strong class="ih hj">第一个</strong>维度，其他<strong class="ih hj"> 3 </strong>代表<strong class="ih hj">图像</strong>。</p><p id="f00f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预测函数分别给出所有<strong class="ih hj">类</strong>及其<strong class="ih hj">可能性</strong>的集合。使用<strong class="ih hj"> argmax </strong>函数，我们选择具有最大可能性的类。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es me"><img src="../Images/55a21a29c6755a091eceabf63a75d66c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*fzo_pCqw6GLictTCOx0MTg.jpeg"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mf"><img src="../Images/75941b559dc6a27fb012eeb1ae0897d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*kKtLlCkiw7ELttToW5H64w.png"/></div></figure><h1 id="738e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">结论</strong></h1><p id="86e3" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">我们已经创建了一个简单的图像识别分类器。我们可以用同样的方法来训练我们选择的数据和网络。图像识别用于执行大量基于机器的视觉任务，例如图像标记、内容搜索和引导自主机器人、自动驾驶汽车和事故避免系统。</p><h1 id="1fc6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">最有趣的部分</strong></h1><p id="1c95" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">GitHub Link-<a class="ae lh" href="https://github.com/sidvsukhi/Image-Recognition-CIFAR-10" rel="noopener ugc nofollow" target="_blank">https://github.com/sidvsukhi/Image-Recognition-CIFAR-10</a></p></div></div>    
</body>
</html>