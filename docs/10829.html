<html>
<head>
<title>Spark RDD (Low Level API) Basics using Pyspark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Pyspark 的 Spark RDD(低级 API)基础</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/spark-rdd-low-level-api-basics-using-pyspark-a9a322b58f6?source=collection_archive---------2-----------------------#2020-11-04">https://medium.com/analytics-vidhya/spark-rdd-low-level-api-basics-using-pyspark-a9a322b58f6?source=collection_archive---------2-----------------------#2020-11-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ab25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然建议初学者学习和使用高级 API(Dataframe-Sql-Dataset)，但低级 API - <em class="jd">弹性分布式数据集</em> (RDD)才是 Spark 编程的基础。主要来说，RDD 是在集群的节点(工作节点)之间划分的元素的集合，它很容易在节点中提供并行操作。</p><p id="65ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">rdd 只能通过两种方式创建:并行化一个已经存在的数据集，收集在您的驱动程序和外部存储中，提供像 Hadoop InputFormats (HDFS，HBase，Cassandra)这样的数据源..)或从已经创建的 rdd 转换而来。</p><h1 id="6b29" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">创建 RDD 和火花背景</h1><p id="f12b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Spark RDDs 可以通过两种方式创建:</p><p id="0189" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一种方法是使用<code class="du kh ki kj kk b">SparkContext</code>的<code class="du kh ki kj kk b">textFile</code>方法，该方法通过获取文件的 URI 创建 rdd，并将文件作为行的集合读取:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="2cd5" class="kt jf hi kk b fi ku kv l kw kx">Dataset = sc.<strong class="kk hj">textFile</strong>("mydata.txt")</span></pre><p id="22a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二种方法是 SparkContext 的<code class="du kh ki kj kk b">parallelize()</code>方法，它使用程序中现有的 iterable 或集合:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="276c" class="kt jf hi kk b fi ku kv l kw kx">data = [1, 2, 3, 4, 5, 6]</span><span id="9782" class="kt jf hi kk b fi ky kv l kw kx">myData = sc.<strong class="kk hj">parallelize</strong>(data)</span></pre><h1 id="d92b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">RDD 行动</h1><figure class="kl km kn ko fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kz"><img src="../Images/02fdcc11cad6827b792da5cf0e363169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2uwvLC1HsWpOsmRw4ZOp2w.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">火花 RDD 操作模式</figcaption></figure><p id="814b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spark RDDs 只支持两种类型的操作:<strong class="ih hj"> <em class="jd">转换</em> </strong>，它通过转换现有的 RDD 来创建新的 RDD，以及<strong class="ih hj"> <em class="jd">动作</em> </strong>，它计算一个值并将其写入驱动程序。</p><p id="82ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spark 变换都是延迟求值的，也称为“延迟变换”。顾名思义，这意味着它们不执行每一个转换，而是等待一个动作来计算并将结果返回给驱动程序，这使得 Spark 运行得更高效、更快。</p><h1 id="3dad" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">RDD 变换</h1><p id="301d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在是时候动手了:)从创建我们的第一个 RDD 开始，并通过使用它展示一些转换:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="658e" class="kt jf hi kk b fi ku kv l kw kx">mydata=[1, 2, 2, 3, 4, 5, 5, 5, 6]</span><span id="4433" class="kt jf hi kk b fi ky kv l kw kx">rdd = sc.<strong class="kk hj">parallelize</strong>(mydata)</span></pre><p id="45b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们开始用我们的第一个 RDD 来玩一些在 Spark 中经常使用的重要和基本的转换:</p><ul class=""><li id="5ae5" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated">地图()</li><li id="9408" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">过滤器()</li><li id="4811" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">独特()</li><li id="b32c" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">联合()</li><li id="29d9" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">交集()</li><li id="57f5" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">减去()</li><li id="a145" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">样本()</li></ul><h2 id="bd31" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated"><strong class="ak">地图()</strong></h2><p id="176a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> map() </strong>转换将 lambda 函数应用于 RDD 的所有元素，并返回新的 RDD:</p><p id="afa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:<em class="jd">如上所述，转换结果不会返回到驱动程序。所以我们需要用一个动作方法来写结果。比如</em> <code class="du kh ki kj kk b"><em class="jd">take()</em></code> <em class="jd">，它取一个 RDD 的所述 n 个元素。</em></p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="d302" class="kt jf hi kk b fi ku kv l kw kx">new_RDD = rdd.<strong class="kk hj">map</strong>(lambda x: x*2)</span><span id="0d09" class="kt jf hi kk b fi ky kv l kw kx">new_RDD.<strong class="kk hj">take</strong>(10)</span><span id="09c7" class="kt jf hi kk b fi ky kv l kw kx">[2, 4, 4, 6, 8, 10, 10, 10, 12]</span></pre><h2 id="ac4d" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">过滤器()</h2><p id="dcba" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> filter() </strong>转换将 lambda 函数应用于 RDD 的所有元素，并通过使用确保函数返回 true 的元素来返回新的 RDD:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="9b95" class="kt jf hi kk b fi ku kv l kw kx">new_RDD = rdd.<strong class="kk hj">filter</strong>(lambda x: x &gt;= 4)</span><span id="d800" class="kt jf hi kk b fi ky kv l kw kx">new_RDD.<strong class="kk hj">take</strong>(10)</span><span id="e611" class="kt jf hi kk b fi ky kv l kw kx">[4, 5, 5, 5, 6]</span></pre><h2 id="af5e" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">独特()</h2><p id="409e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> distinct() </strong>转换应用于 RDD 的所有元素，并返回包含唯一元素的新 RDD:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="bde4" class="kt jf hi kk b fi ku kv l kw kx">new_RDD = rdd.<strong class="kk hj">distict</strong>()</span><span id="0d7f" class="kt jf hi kk b fi ky kv l kw kx">new_RDD.<strong class="kk hj">take</strong>(10)</span><span id="e1a0" class="kt jf hi kk b fi ky kv l kw kx">[1, 2 ,3, 4, 5 ,6]</span></pre><h2 id="70dc" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">联合()</h2><p id="f329" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> union() </strong>转换返回一个新的 RDD，其中包含来自两个 rdd 的所有元素:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="8615" class="kt jf hi kk b fi ku kv l kw kx">rdd2 = sc.<strong class="kk hj">parallelize</strong>([2, 2, 3, 5, 6, 6, 7, 8, 9])</span><span id="938c" class="kt jf hi kk b fi ky kv l kw kx">new_RDD = rdd.<strong class="kk hj">union</strong>(rdd2)</span><span id="6cdb" class="kt jf hi kk b fi ky kv l kw kx">new_RDD.<strong class="kk hj">take</strong>(20)</span><span id="a795" class="kt jf hi kk b fi ky kv l kw kx">[<!-- -->1, 2, 2, 3, 4, 5, 5, 5, 6, <!-- -->2, 2, 3, 5, 6, 6, 7, 8, 9]</span></pre><h2 id="9404" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">交集()</h2><p id="aef8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> intersection() </strong>转换返回一个新的 RDD，它包含两个 rdd 中元素的交集:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="0899" class="kt jf hi kk b fi ku kv l kw kx">new_RDD = rdd.<strong class="kk hj">intersection</strong>(rdd2)</span><span id="7bf0" class="kt jf hi kk b fi ky kv l kw kx">new_RDD.<strong class="kk hj">take</strong>(10)</span><span id="bbfa" class="kt jf hi kk b fi ky kv l kw kx">[2, 3, 5, 6]</span></pre><h2 id="9286" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">减去()</h2><p id="0c8d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> subtract() </strong>转换返回一个新的 RDD，其元素存在于第一个 RDD 中，但不存在于第二个 RDD 中:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="2e94" class="kt jf hi kk b fi ku kv l kw kx">new_RDD = rdd.<strong class="kk hj">subtract</strong>(rdd2)</span><span id="ac0c" class="kt jf hi kk b fi ky kv l kw kx">new_RDD.<strong class="kk hj">take</strong>(10)</span><span id="e121" class="kt jf hi kk b fi ky kv l kw kx">[1, 4]</span></pre><h2 id="2dbf" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">样本()</h2><p id="3e5f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> sample() </strong>变换返回包含现有 RDD 的 n 倍采样元素子集的新 RDD:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="5904" class="kt jf hi kk b fi ku kv l kw kx">new_RDD = rdd.<strong class="kk hj">sample</strong>(False,0.5)</span><span id="878d" class="kt jf hi kk b fi ky kv l kw kx">new_RDD.<strong class="kk hj">collect</strong>()</span><span id="eb46" class="kt jf hi kk b fi ky kv l kw kx">[2, 3, 5, 5]</span></pre><h1 id="fefa" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">对 RDD 变换</strong></h1><p id="62bf" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">成对 RDD 变换是指包含像数据元组这样的键/值对的 RDD 的另一种方式。成对 RDD 变换被并行地应用于每个键/元素，其中 RDD 上的正常变换(像 map())被应用于集合的所有元素。因为像具有键值对的字典一样，对 rdd 被广泛使用。</p><p id="e6ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看 Spark 中一些重要且常用的 RDD 对变换:</p><ul class=""><li id="5811" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated">groupByKey()</li><li id="1f19" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">reduceByKey()</li><li id="9b60" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">sortByKey()</li><li id="c107" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">减法键()</li><li id="ce6c" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">计数键()</li><li id="cc94" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">加入()</li></ul><h2 id="0f18" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">groupByKey()</h2><p id="7427" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> groupByKey() </strong>转换在 Pyspark 按键分组中将键-值对转换为键-结果可编辑对:</p><p id="8dd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:<em class="jd">正如我们之前提到的，转换的结果不会返回到驱动程序。所以我们需要用一个动作方法来写结果。比如</em> <code class="du kh ki kj kk b"><em class="jd">collect()</em></code> <em class="jd">，它获取一个 RDD 的所有元素。</em></p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="fd83" class="kt jf hi kk b fi ku kv l kw kx">rdd=sc.<strong class="kk hj">parallelize</strong>([(1, 2),(1, 5),(3, 4),(3, 6)])</span><span id="cfd5" class="kt jf hi kk b fi ky kv l kw kx">rdd.<strong class="kk hj">groupByKey</strong>().collect()</span><span id="bcd5" class="kt jf hi kk b fi ky kv l kw kx">[(1, &lt;pyspark.resultiterable.ResultIterable at 0x2218cd4b430&gt;),<br/> (3, &lt;pyspark.resultiterable.ResultIterable at 0x2218ccb9c70&gt;)]</span></pre><p id="0a64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的例子中可以看出，我们在 Pyspark 中得到一个 key- ResultIterable 对。为了查看<code class="du kh ki kj kk b">ReslutIterable</code>对象的样子，我们需要借助 map()转换将它们转换成一个列表:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6b8f" class="kt jf hi kk b fi ku kv l kw kx">rdd.<strong class="kk hj">groupByKey</strong>().map(lambda x:(x[0],list(x[1]))).collect()</span><span id="793a" class="kt jf hi kk b fi ky kv l kw kx">[(1, [2, 5]), (3, [4, 6])]</span></pre><h2 id="ca59" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">reduceByKey()</h2><p id="0138" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> reduceByKey() </strong>转换将 lambda 函数应用于新的 RDD，并产生一对 RDD，其中包含每个值的总和:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="3bad" class="kt jf hi kk b fi ku kv l kw kx"> rdd.<strong class="kk hj">reduceByKey</strong>(lambda x,y: x+y).collect()</span><span id="ae67" class="kt jf hi kk b fi ky kv l kw kx">[(1, 7), (3, 10)]</span></pre><h2 id="d8d1" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">sortByKey()</h2><p id="1f09" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> sortByKey() </strong>转换可以根据值对一对 RDD 进行升序或降序排序。通过使用<code class="du kh ki kj kk b">ascending=False</code>,我们得到一个升序:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="70a5" class="kt jf hi kk b fi ku kv l kw kx">rdd.<strong class="kk hj">sortByKey</strong>(ascending=False).collect()</span><span id="1463" class="kt jf hi kk b fi ky kv l kw kx">[(3, 4), (3, 6), (1, 2), (1, 5)]</span></pre><h2 id="c6c2" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">减法键()</h2><p id="bf8c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> subtractByKey() </strong>转换返回 self 中的每个键-值对，它与 other 中的键不匹配:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="417f" class="kt jf hi kk b fi ku kv l kw kx">rdd2=sc.parallelize([(1,9)])</span><span id="edb6" class="kt jf hi kk b fi ky kv l kw kx">rdd.<strong class="kk hj">subtractByKey</strong>(rdd2).collect()</span><span id="5408" class="kt jf hi kk b fi ky kv l kw kx">[(3, 4), (3, 6)]</span></pre><h2 id="71ab" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">计数键()</h2><p id="51cc" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">利用 using items()函数，对 RDD 的每个键的元素个数进行统计，并将结果作为字典返回:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="0db6" class="kt jf hi kk b fi ku kv l kw kx">rdd.<strong class="kk hj">countByKey</strong>().items()</span><span id="6f98" class="kt jf hi kk b fi ky kv l kw kx">dict_items([(1, 2), (3, 2)])</span></pre><h2 id="0f19" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">加入()</h2><p id="2c4b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> join() </strong>转换返回一个 RDD，其中包含 self 中具有匹配键的所有元素对，以及 SQL 中类似 RDD 的内部连接函数:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="edf5" class="kt jf hi kk b fi ku kv l kw kx">rdd.<strong class="kk hj">join</strong>(rdd2).collect()</span><span id="4818" class="kt jf hi kk b fi ky kv l kw kx">[(3, (4, 9)), (3, (6, 9))]</span></pre><p id="3554" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:<em class="jd">还有 rightOuter()和 leftOuter()转换，我们可以在类似 SQL right，left join 函数的逻辑中使用。</em></p><h1 id="f6ee" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">RDD 行动</h1><p id="c8f5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">正如我们在上面的 RDD 操作标题中提到的，由于懒惰，rdd 直到我们使用动作时才把最终结果返回给驱动程序。简而言之，动作是返回非 RDD 值的 RDD 操作。让我们看看在 Spark core 中经常使用的一些常见操作:</p><ul class=""><li id="3938" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated">收集()</li><li id="c26f" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">采取()</li><li id="e4dd" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">计数()</li><li id="5e58" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">顶部()</li><li id="98fb" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">减少()</li><li id="f216" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">首先()</li><li id="fab6" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">总和()</li><li id="b6dc" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">聚合()</li></ul><h2 id="14a5" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">收集()</h2><p id="047c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> collect() </strong>动作以列表形式返回 RDD 中的所有元素:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="5d82" class="kt jf hi kk b fi ku kv l kw kx">rdd = sc.<strong class="kk hj">parallelize</strong>([2, 2, 3, 5, 6, 6, 7, 8, 9, 0])</span><span id="0f3e" class="kt jf hi kk b fi ky kv l kw kx">rdd.<strong class="kk hj">collect</strong>()</span><span id="3ef4" class="kt jf hi kk b fi ky kv l kw kx">[2, 2, 3, 5, 6, 6, 7, 8, 9, 0]</span></pre><h2 id="5fb4" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">采取()</h2><p id="4bf9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> take() </strong>动作返回 RDD 的第一个<em class="jd"> n </em>元素:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="339b" class="kt jf hi kk b fi ku kv l kw kx">rdd.<strong class="kk hj">take</strong>(4)</span><span id="0b53" class="kt jf hi kk b fi ky kv l kw kx">[2, 2, 3, 5]</span></pre><h2 id="97e9" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">计数()</h2><p id="7259" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> count() </strong>动作计算 RDD 中元素的数量:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="1d27" class="kt jf hi kk b fi ku kv l kw kx">rdd.<strong class="kk hj">count</strong>()</span><span id="aff3" class="kt jf hi kk b fi ky kv l kw kx">10</span></pre><h2 id="6e48" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">顶部()</h2><p id="44a5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> top() </strong>动作返回 RDD 的前 n 个元素:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="a026" class="kt jf hi kk b fi ku kv l kw kx">rdd.<strong class="kk hj">top</strong>(3)</span><span id="15c0" class="kt jf hi kk b fi ky kv l kw kx">[9, 8, 7]</span></pre><h2 id="0946" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">减少()</h2><p id="f2f5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> reduce() </strong>动作通过应用 lambda 函数从 RDD 的两个元素中返回一个元素:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6885" class="kt jf hi kk b fi ku kv l kw kx">rdd.<strong class="kk hj">reduce</strong>(lambda x, y: x + y)</span><span id="fc0b" class="kt jf hi kk b fi ky kv l kw kx">48</span></pre><h2 id="d48c" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">首先()</h2><p id="756c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> first() </strong>动作返回 RDD 的第一个元素:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="a7c9" class="kt jf hi kk b fi ku kv l kw kx">rdd.<strong class="kk hj">first</strong>()</span><span id="c633" class="kt jf hi kk b fi ky kv l kw kx">2</span></pre><h2 id="17ea" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">总和()</h2><p id="a7f9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> sum() </strong>操作返回 RDD 元素的总和:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="bfc8" class="kt jf hi kk b fi ku kv l kw kx">rdd.<strong class="kk hj">sum</strong>()</span><span id="07b7" class="kt jf hi kk b fi ky kv l kw kx">48</span></pre><h2 id="5734" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">聚合()</h2><p id="e1df" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> aggregate() </strong>动作<strong class="ih hj"> </strong>采用两个函数返回最终结果:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="b70e" class="kt jf hi kk b fi ku kv l kw kx">new_rdd=sc.<strong class="kk hj">parallelize</strong>([1, 2, 3, 4])</span><span id="d2a6" class="kt jf hi kk b fi ky kv l kw kx">rdd.<strong class="kk hj">aggregate</strong>((0,0),(lambda x,y:(x[0]+y,x[1]+1)),(lambda x,y:(x[0]+y[0],x[1]+y[1])))</span><span id="34b9" class="kt jf hi kk b fi ky kv l kw kx">(10, 4)</span></pre><p id="d617" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在该模式的帮助下，我们可以逐步总结操作:</p><h2 id="146b" class="kt jf hi bd jg lz ma mb jk mc md me jo iq mf mg js iu mh mi jw iy mj mk ka ml bi translated">聚合(零值、seqOp、combOp)</h2><figure class="kl km kn ko fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mm"><img src="../Images/921b0d4a564734d24cde640b5fdff771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wpbQnUwro55h1H4DO8NQg.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">聚合()函数的模式</figcaption></figure><h1 id="3c1d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="4e05" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在本文中，我试图简要介绍 Apache Spark 的 RDD，它是 Spark 核心的非结构化部分，基于 Pyspark 中常用的 Spark RDD 转换和动作示例。您可以通过在 Apache Spark 文档中搜索 Spark RDD 编程指南和 pyspark 的 Python Api 文档来提高您的知识。</p><p id="2ccb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一篇文章中，我将讨论高级 Api (Spark-Sql 和 Dataframes ),它是 Spark core 的结构化部分。</p><p id="5659" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将很高兴听到您的任何意见或问题。愿数据伴随你！</p></div></div>    
</body>
</html>