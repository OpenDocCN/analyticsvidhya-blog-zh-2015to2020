<html>
<head>
<title>Color Quantization for Image Reduction using K-Means Clustering Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于K-Means聚类算法的彩色量化图像压缩</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/color-quantization-for-image-reduction-using-k-means-clustering-algorithm-321b33f4d5e8?source=collection_archive---------13-----------------------#2020-07-05">https://medium.com/analytics-vidhya/color-quantization-for-image-reduction-using-k-means-clustering-algorithm-321b33f4d5e8?source=collection_archive---------13-----------------------#2020-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b4c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">简介:</strong></p><p id="9531" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一句话叫‘一图胜千言’[1]。在当今的科技时代，我们都被图像所包围。从官方记录中的图像识别人，到在Instagram上上传图片，在whatsapp、facebook上更改个人资料图片，使用图片了解太空星系，存储记忆等。图像从四面八方覆盖了我们。</p><p id="8530" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些图像实际上使用了大量的磁盘空间，一个事件的照片加起来可能有几千兆字节。这就是图像压缩发挥作用的地方。图像压缩基本上意味着在不影响图像质量的情况下减小图像的磁盘大小。一种这样的图像压缩方法是颜色量化。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="a029" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">颜色量化:</strong></p><p id="c8fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">色彩量化是一个减少图像中不同颜色数量的过程，以使结果图像与原始图像相似，但尺寸减小[2]。一种这样的减少图像颜色的方法是通过K-均值聚类方法。该算法解释如下</p><p id="1b77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">K-均值聚类</strong></p><p id="a6fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种算法在无监督数据(无标签数据)中发挥作用，这意味着给定一些点集，我们希望找到数据中的结构。帮助形成相似数据点聚类的算法称为聚类算法。K均值聚类是一种将数据点分成K个不同聚类的技术。每个群集由群集的质心唯一标识。该算法将相似的颜色值分组到K个簇中，并且每个像素值(在最终输出图像中)由它所属的簇的质心值代替。</p><div class="jk jl jm jn fd ab cb"><figure class="jo jp jq jr js jt ju paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/cb01a0c7635d6a6bfb046fd83977f860.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*02uFILACupKcvW_FY-AGaQ.png"/></div></figure><figure class="jo jp kb jr js jt ju paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/9f513eb2650494307fe5cad4e9395c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*GbRFjlxgsytS4Y3IMfBnMw.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx kg di kh ki translated">k表示将非结构化数据(左)分成两个簇(右)(图片提供:Andre Ng ML课程[3])</figcaption></figure></div><p id="c4ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在随机初始化K个质心之后，K-Means的迭代算法主要有两个步骤:</p><ol class=""><li id="8a77" class="kj kk hi ih b ii ij im in iq kl iu km iy kn jc ko kp kq kr bi translated"><strong class="ih hj">聚类分配:</strong>我们将质心索引分配给像素值，使得像素和质心之间的欧几里德距离[2]最小。两点(a1，b1，c1)和(a2，b2，c2)之间的距离由下式给出:sqrt((a2-a1) + (b2-b1) + (c2-c1) ) [</li><li id="04a3" class="kj kk hi ih b ii ks im kt iq ku iu kv iy kw jc ko kp kq kr bi translated"><strong class="ih hj">移动质心:</strong>在这里，我们通过取分配给给定质心的所有像素值的平均值来计算新的质心。</li></ol><p id="e7ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">尺寸是如何缩小的？</strong></p><p id="c9f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">彩色图像有3个不同的通道，即红色(R)、绿色(G)、蓝色(B)或RGB，每个像素使用24位(8位(0到255的无符号整数) ,每个代表R、G和B)来表示一种颜色。在这种颜色量化技术中，假设我们将颜色的数量减少到32种，从而可以减小图像的大小，因为我们可以只存储这32个选定的RGB值，因此对于每个像素，我们可以存储这些颜色的索引，这将只占用5 (2⁵ = 32)位而不是24位。在这之后，我们将用32种选定的颜色替换像素值[3]。</p><p id="6ffd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Satyam Kumar在他的故事[4]中对尺寸缩减进行了深入的解释。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="1670" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果和结论</strong></p><p id="5297" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将看到运行K-Means算法的结果。使用K-Means压缩时，颜色数量范围为2、4、8、16、32和64，请参见下图。这里给出了使用K-Means的颜色量化的实现<a class="ae kx" href="https://github.com/keshav1245/Image-Compression-by-Color-Quantization/blob/master/COLOR%20QUANTIZATION.md" rel="noopener ugc nofollow" target="_blank"/>。我将在下一篇文章中讨论它的实现，在这篇文章中，我们将讨论如何用python从头开始实现它，并进行深入的解释。如果你喜欢这个故事，一定要看看我的<a class="ae kx" href="https://www.linkedin.com/in/keshav-t-7ab782104" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>。</p><figure class="jk jl jm jn fd jp er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ky"><img src="../Images/e39a2c355f9f7ffc0c0b44d3254865b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK9saN-Cax3u6GYOMbe6jA.jpeg"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">原图(图片提供:<a class="ae kx" href="https://www.instagram.com/apprentice_fotografo/" rel="noopener ugc nofollow" target="_blank">学徒_摄影图片</a>)</figcaption></figure><figure class="jk jl jm jn fd jp er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ky"><img src="../Images/d24fdedcd175215aef389004ae5cd52f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0xJ2Y0guIkr1ZrOaG0mX7Q.jpeg"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">聚类数(K) = 2</figcaption></figure><figure class="jk jl jm jn fd jp er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ky"><img src="../Images/b37b1f4b82fb461fd1542261ba190fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZyxE-EbxGcA3EeMkLQbXww.jpeg"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">聚类数(K) = 4</figcaption></figure><figure class="jk jl jm jn fd jp er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ky"><img src="../Images/e683e66cd3b9fa9833a55e1154a3dba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uleCgdD-wY-7HJio-Sb3ew.jpeg"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">聚类数(K) = 8</figcaption></figure><figure class="jk jl jm jn fd jp er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ky"><img src="../Images/c940dd1c948aa294cd5b18320eb8d706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gASRMJ5sI2mcAH-CBn0HQ.jpeg"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">聚类数(K) = 16</figcaption></figure><figure class="jk jl jm jn fd jp er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ky"><img src="../Images/d10b0ed1ee487d780cacb10a079ef32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6xRQc-l_xKNqCe2Qqv2XXQ.jpeg"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">聚类数(K) = 32</figcaption></figure><figure class="jk jl jm jn fd jp er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ky"><img src="../Images/de2069b902b38e4354b8037effb278d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AbaK82S4kNkT7xLft1kIRA.jpeg"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">聚类数(K) = 64</figcaption></figure><p id="ae1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong></p><p id="d963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[1]<a class="ae kx" href="https://en.wikipedia.org/wiki/A_picture_is_worth_a_thousand_words" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/A _ picture _ is _ worth _ A _ Millennium _ words</a></p><p id="0601" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[2]<a class="ae kx" href="https://en.wikipedia.org/wiki/Color_quantization" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Color_quantization</a></p><p id="381f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kx" href="https://coursera.org/share/f5010265b57b1dd841eb6dde1c554e4b" rel="noopener ugc nofollow" target="_blank">https://coursera.org/share/f5010265b57b1dd841eb6dde1c554e4b</a></p><p id="129c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[4]<a class="ae kx" href="https://towardsdatascience.com/image-compression-using-k-means-clustering-aa0c91bb0eeb" rel="noopener" target="_blank">https://towards data science . com/image-compression-using-k-means-clustering-aa 0 c 91 bb 0 eeb</a></p></div></div>    
</body>
</html>