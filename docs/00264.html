<html>
<head>
<title>Target Class-Labels in Prediction result of Tensorflow Estimator API in ML Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ML引擎中张量流估计器API预测结果中的目标类别标签</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/target-class-labels-in-prediction-result-of-tensorflow-estimator-api-in-ml-engine-439f23cc4047?source=collection_archive---------0-----------------------#2019-02-06">https://medium.com/analytics-vidhya/target-class-labels-in-prediction-result-of-tensorflow-estimator-api-in-ml-engine-439f23cc4047?source=collection_archive---------0-----------------------#2019-02-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e0e472fe2b327d1dc10e136f36da5976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fsaVJTfAwlIN2lIx"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">安妮·斯普拉特在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="04b8" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">问题简介</h2><p id="3cd9" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">这是我在云ML引擎中使用tensorflow estimators API配置服务模型时遇到的一个非常具体的问题。如果预测输入中有多行，并且您需要映射到每一行输出的目标类列表，这就相当棘手了。来自训练图的预测可以以配置的方式具有输出参数。例如，对于多类分类器，它可以包括预测的类或标签名称、类的概率列表、精确度等等。但是我发现有一件事很棘手，那就是将实际的类列表或标签名称添加到预测结果中。当一个已部署的模型被某个不知道类是什么的人使用时，这将是有用的，他可以获得关于它们的概率的信息。</p><p id="ff6e" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">似乎没有直接的方法可以在预测输出列表中添加类名。我们能够从softmax层获得与每个类相关联的概率，并且使用<strong class="jv hj"> tf.gather </strong>我们可以获得预测的类名。</p><p id="8bcb" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">但是，如果您想在预测结果中获得类名列表，该怎么办呢？在像StackOverflow这样的地方进行了大量疯狂的搜索后，我得出结论，以前从来没有人遇到过这个特殊的问题。所以经过大量的试错，我想出了这个解决方案(可能有点工程过度)。</p><h2 id="8102" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">解决办法</h2><p id="54fc" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">使用逻辑上的<strong class="jv hj"> tf.nn.softmax </strong>函数，可从神经网络的softmax层获得概率。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="b551" class="iv iw hi ky b fi lc ld l le lf">probabilities = tf.nn.softmax(logits)</span></pre><p id="2a26" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">现在，为了获得与最高概率相关联的目标标签或类名，我们可以对给定的目标名称列表使用<strong class="jv hj"> tf.gather </strong>方法。使用<strong class="jv hj"> tf.argmax </strong>方法获得预测指数，使用<strong class="jv hj"> tf.gather </strong>和目标列表获得目标名称。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="b093" class="iv iw hi ky b fi lc ld l le lf">predicted_indices = tf.argmax(probabilities, 1)</span><span id="4da8" class="iv iw hi ky b fi lg ld l le lf">predicted_class = tf.gather(TARGET_LABELS, predicted_indices)</span></pre><p id="b2dc" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">现在是获取姓名列表并将其添加到预测结果对象的棘手部分。首先，我使用<strong class="jv hj"> tf.where </strong>来获取所有概率值的所有索引，条件是所有值都小于2，这是所有的概率值。现在有了所有的指数，我找到了最后一个指数，形成了一个新的包含指数的列表，然后把它改造成概率的列表。现在，这个新的变形矩阵包含了所有的索引。</p><p id="9efd" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">如果目标类别是:-</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="ff7b" class="iv iw hi ky b fi lc ld l le lf">['Class A', Class B']</span></pre><p id="4946" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">如果有两个输入，预测的概率将以2x2矩阵的形式出现</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="36d5" class="iv iw hi ky b fi lc ld l le lf">[[.5, .4], [.4, .5]]</span></pre><p id="c31e" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">从CloudML引擎获得输出的方式将是多行预测的对象列表。为了映射到这种情况，首先形成一个形状相似的索引矩阵，并使用<strong class="jv hj"> tf.gather，</strong>将类名也转换成如下形式的矩阵</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="a364" class="iv iw hi ky b fi lc ld l le lf">[['Class A', Class B'], ['Class A', Class B']]</span></pre><p id="6ece" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">这将允许正确映射对象列表的结果。进行解释的代码是:-</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="4136" class="iv iw hi ky b fi lc ld l le lf">condition = tf.less(probabilities, 2)</span><span id="7935" class="iv iw hi ky b fi lg ld l le lf"><em class="lh">#all the indices are obtained<br/></em>indices = tf.where(condition)<br/><br/><em class="lh"># get the last index from the result<br/></em>last_index = indices.get_shape().as_list()[1] - 1</span><span id="d897" class="iv iw hi ky b fi lg ld l le lf">#the new list containing all the indices --&gt; [0, 1, 0, 1]<br/>last_indices_value = tf.slice(indices, [0, last_index], [-1, -1])<br/><br/><em class="lh"># reshape the result to the correct format<br/></em># [0, 1, 0, 1] --&gt; [[0, 1], [0, 1]]<br/>classes_shape = tf.reshape(last_indices_value, tf.shape(probabilities))<br/><br/><em class="lh"># form the classes list with the indices in the new shape<br/></em>classe_names = tf.gather(TARGET_LABELS, classes_shape)</span></pre><h2 id="44e2" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h2><p id="41a9" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">因此，这是在预测中映射或包含类名列表的过度设计的方法，它将与预测输入中的任意数量的行一起工作。这主要是为了让我记住这种方法以及我是如何着手解决它的，也是为了让任何碰巧遇到类似问题的人记住。</p><p id="943b" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">请评论，如果你有一个替代或更简单的方式做同样的事情。谢谢你。</p></div></div>    
</body>
</html>