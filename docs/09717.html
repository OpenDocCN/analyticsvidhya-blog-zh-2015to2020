<html>
<head>
<title>An Introduction to Searching with AI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能搜索简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/an-introduction-to-searching-with-ai-ca88a3a211c6?source=collection_archive---------24-----------------------#2020-09-17">https://medium.com/analytics-vidhya/an-introduction-to-searching-with-ai-ca88a3a211c6?source=collection_archive---------24-----------------------#2020-09-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="59a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今年夏天，我在 Edx 上参加了 CS50 人工智能与 Python 入门课程。这是我学到的两个基本搜索算法的总结。</p><h1 id="64d7" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">搭建舞台</h1><p id="2a37" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">好，我们想用人工智能搜索一些东西。但是我们在搜索什么呢？对于我要讲的搜索算法，我们搜索一些可以用一种特殊的图来表示的东西，这种图使用节点和边。一个<strong class="ih hj">节点</strong>是一个数据点，一个<strong class="ih hj">边</strong>显示各个数据点是如何连接的。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/fccf4a21f195a76a020f13e752223a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*OUTBv5AokjAofnzrJtwQww.gif"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">节点图。这里，字母是节点，它们之间的线是边。</figcaption></figure><h1 id="8e40" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">定义术语</h1><p id="cc38" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在讨论算法本身之前，让我们先列出一些基本术语:</p><ul class=""><li id="d70c" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated">一个<strong class="ih hj">状态</strong>将是我们图上的一个节点。(甲、乙、丙、丁等。)</li><li id="a423" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">目标状态</strong>将是我们最终想要到达的节点。例如，我们可能想要到达节点 f。</li><li id="baf1" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">前沿</strong>将是我们的人工智能知道并想要探索的所有节点。</li><li id="aad8" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">路径</strong>将记录我们的 AI 已经检查过的所有状态，以便到达它正在检查的当前状态。</li></ul><h1 id="d4ff" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">我们的第一个算法</h1><p id="6331" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们看到的第一个算法是<strong class="ih hj">深度优先搜索(dfs) </strong>。它将使用以下步骤:</p><ol class=""><li id="5616" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc lg ky kz la bi translated">随机选择一个州或被分配一个起始州。</li><li id="ebec" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">将您选择的州通过边连接的所有州添加到边界<em class="lh">，如果这些州以前没有被检查过(我们不想检查两次)</em>。如果所选州在边界中，则将其从边界中移除。</li><li id="1c2e" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">检查我们选择的州是否是目标州。</li><li id="e9dd" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">如果是的话，我们就完了。返回所走的路。</li><li id="48f8" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">否则，从第二步开始重复最近添加到边界的状态<em class="lh">(这很重要)。</em></li><li id="cf8b" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">如果最后没有返回路径，也没有找到目标状态，则不存在可能的路径。</li></ol><p id="dfb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Dfs 最终会寻找一条可能的路径，直到它到达一个死胡同。如果没有达到某个目标状态，dfs 会备份到另一个状态可能被探测到的最后一个位置，并再次进入死胡同。为了了解这是如何工作的，让我们以上面的图表为例。我们称节点 F 为目标状态。</p><h1 id="d0df" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">dfs 的扩展示例</h1><ol class=""><li id="04fd" class="ks kt hi ih b ii kb im kc iq li iu lj iy lk jc lg ky kz la bi translated">我们给我们的 AI 节点 A 作为它的起点。</li><li id="fc98" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它将 B、C 和 D 添加到边界中。</li><li id="95ba" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它看到 A 不是目标。</li><li id="89a1" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它现在看着 b。</li><li id="89ff" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它把 E 加到了前沿</li><li id="9193" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它看到 B 不是目标。</li><li id="fd28" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">注意，E 是最近被添加到边界的。这是 dfs 的深度优先部分，因为我们先深入到 E 的“兔子洞”,然后再看其他东西。</li><li id="ff22" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它没有给边疆增添任何东西。</li><li id="2718" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它看到 E 不是目标。</li><li id="1e46" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它已经到达了一个死胡同，所以它返回到 C，C 现在是最近添加到边界的节点。</li><li id="023a" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它没有给边疆增添任何东西</li><li id="e990" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它认为 C 不是目标</li><li id="c4e8" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它看着 D</li><li id="fc04" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它把 F 加到了前沿。</li><li id="aa58" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它看到 D 不是目标。</li><li id="7926" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">它看着 f。</li><li id="89ae" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc lg ky kz la bi translated">f 是目标，我们的 AI 已经完成了搜索！</li></ol><h1 id="ba4e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">我们的第二个算法:Dfs 的双胞胎</h1><p id="9d4f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们的第二个算法是<strong class="ih hj">广度优先搜索(bfs) </strong>。它看起来非常类似于 dfs，只有步骤 5 不同。修订后的第五步如下所示:</p><p id="aea8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.否则，对最近最少添加到边界的州<em class="lh">重复第二步。</em></p><p id="abb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能看起来微不足道，但它使我们的搜索呈现出完全不同的面貌。我们不去兔子洞，而是探索所有距离我们的起始节点一个距离的节点，两个距离的节点，等等。因此，我们挖的不是兔子洞，而是一个比一个浅的洞。诸如此类。只有当我们的洞都是 1 个单位深时，我们才回到第一个洞并扩大它。诸如此类。</p><p id="38fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不会用这个搜索算法的另一个例子来烦你，但如果你想检查你的理解，我会给你一个顺序，如果 F 是目标状态，bfs 将会查看节点:A，B，C，D，E，F(这不是很好吗)。注意它在第一次探索 C 和 d 之前是如何不看 E 的。</p><h1 id="1f15" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">关键要点</h1><ul class=""><li id="785e" class="ks kt hi ih b ii kb im kc iq li iu lj iy lk jc kx ky kz la bi translated">搜索算法将数据组织成<strong class="ih hj">节点</strong>和<strong class="ih hj">边。</strong></li><li id="01a9" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">状态</strong>是单独的节点</li><li id="8a2c" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">搜索算法有一个他们想要探索的状态<strong class="ih hj"> </strong>的边界<strong class="ih hj"/></li><li id="245b" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">深度优先搜索</strong>从最近添加的州开始探索边界</li><li id="fcf8" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">广度优先搜索</strong>从最近添加的州开始探索边界</li></ul><h1 id="9550" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">进一步阅读</h1><p id="434f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">如果你想了解更多，我强烈推荐 edx 的 CS50 课程。如果你想继续问我或者有更多的问题，请发邮件到 yamanhabip@icloud.com</p></div></div>    
</body>
</html>