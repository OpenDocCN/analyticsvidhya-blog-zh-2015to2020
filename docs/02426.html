<html>
<head>
<title>Panoramic Reconstruction.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">全景重建。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/panoramic-reconstruction-ab9fa35a38ef?source=collection_archive---------10-----------------------#2019-12-16">https://medium.com/analytics-vidhya/panoramic-reconstruction-ab9fa35a38ef?source=collection_archive---------10-----------------------#2019-12-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f0af" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个完全自动化的管道来缝合您的图像。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3e430acb0b87426ad23d1d0e7a108174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZTJUXw1ZJygQ3dzjeol2A.jpeg"/></div></div></figure><p id="8e6a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我希望你不要指望一次快门点击就能立刻捕捉到所有的美景。你猜怎么着？我们只需点击多个图像，然后将它们组合起来。我们就是这样一直看到遥远星系和行星的图像的。组合从不同时间和地点点击的多个图像。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="d30c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当然，你可以直接去看代码。下面是<a class="ae kn" href="https://github.com/peek1999/Image-Stitching" rel="noopener ugc nofollow" target="_blank"> <em class="kf">环节</em> </a>。</p><h1 id="dc49" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">引言。</h1><p id="dc0d" class="pw-post-body-paragraph jj jk hi jl b jm lg ij jo jp lh im jr js li ju jv jw lj jy jz ka lk kc kd ke hb bi translated">图像拼接的过程是具有4个阶段的流水线。</p><ul class=""><li id="0e04" class="ll lm hi jl b jm jn jp jq js ln jw lo ka lp ke lq lr ls lt bi translated">特征检测。</li><li id="ae78" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">特征匹配。</li><li id="0e3f" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">全球一致。</li><li id="250a" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">混合。</li></ul><p id="3e7c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们详细检查一下这些。</p><h1 id="89d0" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">特征检测。</h1><p id="e532" class="pw-post-body-paragraph jj jk hi jl b jm lg ij jo jp lh im jr js li ju jv jw lj jy jz ka lk kc kd ke hb bi translated">一般来说，你是如何识别任何事物的？你记得一些与众不同的<strong class="jl hj"><em class="kf"/></strong>关于那个东西的“特征”。一些你能再次认出的东西。类似地，我们希望识别图像中的一些点/像素/位置，当图像在比例、角度、定位、光照、曝光等方面发生变化时，这些点/像素/位置可以保持一致。</p><p id="244a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们表示这些特征的方式是使用一个叫做<strong class="jl hj"> <em class="kf">“特征向量”的向量。</em>T13】</strong></p><p id="d995" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">OpenCV为我们提供了多种检测和描述特征的方法。这些是筛，冲浪，圆形，轻快。我用过SIFT，但是你可以试着找出适合你的。</p><p id="fb16" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你需要重温SIFT，你可以看看这篇文章。</p><p id="45cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看这个的代码。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div><figcaption class="mb mc et er es md me bd b be z dx translated">这是属于“featureExtractor”类的方法，其实例是之前使用的“features”。</figcaption></figure><p id="82b2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面的这个函数用于查找所有图像中的特征，并在原始图像中定位它们。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div><figcaption class="mb mc et er es md me bd b be z dx translated">这是属于“featureExtractor”类的方法，其实例是之前使用的“features”。</figcaption></figure><p id="dcb2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看从这些函数中我们得到了什么。</p><div class="iy iz ja jb fd ab cb"><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/8b2c78a10dcad7dc11b6e8aa22061cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*UemOaN3DK3hCo57-rOl5Cg.jpeg"/></div></figure><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/f010290709397a371c64c44356d07a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*rqWBvY7ChH7G27QQRcPu0A.jpeg"/></div><figcaption class="mb mc et er es md me bd b be z dx ml di mm mn translated">1.jpg，2.jpg</figcaption></figure></div><div class="ab cb"><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/03d74b10840160234e5f2ec76c3a8bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*nHGv-Dz2TWBSTxlEWhgbzQ.jpeg"/></div></figure><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/dfed25b8b6ad12eefdf2df4c63f87dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*NjX7tzO8_wK0MZaxbdJNkA.jpeg"/></div><figcaption class="mb mc et er es md me bd b be z dx ml di mm mn translated">3.jpg，4.jpg</figcaption></figure></div><p id="e3e3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">到目前为止，我们已经定位了所有输入图像中的特征，并找出了它们的代表性特征向量。</p><h1 id="decc" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">特征匹配。</h1><p id="1de6" class="pw-post-body-paragraph jj jk hi jl b jm lg ij jo jp lh im jr js li ju jv jw lj jy jz ka lk kc kd ke hb bi translated">通常，我们可以使用欧几里德距离或点积或其他统计方法来匹配两个向量。但是我们将使用一种叫做“Flann Matcher”的东西，它更适合这个任务。一旦我们在两幅图像之间有足够数量的匹配，我们就可以使用RANSAC估计器来估计它们之间的单应变换。你可以在这里 阅读更多关于Flann Matcher <a class="ae kn" href="https://docs.opencv.org/3.4/d5/d6f/tutorial_feature_flann_matcher.html" rel="noopener ugc nofollow" target="_blank"> <em class="kf">。</em></a></p><p id="6d86" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果输入图像从0到n-1编号，我们可以用n*n矩阵表示每对图像之间的匹配数。对于之前显示的图像，结果是这样的。</p><blockquote class="mo mp mq"><p id="95d1" class="jj jk kf jl b jm jn ij jo jp jq im jr mr jt ju jv ms jx jy jz mt kb kc kd ke hb bi translated"><strong class="jl hj"> [[ 0，204，74，233]，[204，0，306，42]，[ 74，306，0，0]，[233，42，0，0]] </strong></p></blockquote><p id="d039" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">相同的代码如下所示。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div><figcaption class="mb mc et er es md me bd b be z dx translated">此方法是使用类“transformExtractor”实例的文件“panorama.py”的一部分。</figcaption></figure><p id="bb3d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看我们能识别的匹配。</p><div class="iy iz ja jb fd ab cb"><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/c8257483189bca7defbce6146c07761b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*U57rxNbF4u3u_okO7yEhVg.jpeg"/></div></figure><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/261167e47a57034d7191354eb70a9248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*lbuQ3vw5vLxHh4r1NCMUBg.jpeg"/></div></figure></div><div class="ab cb"><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/cb01ca78550e4103b369685b788578b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ORKZlxoVLAjPjP-gBJD_Bg.jpeg"/></div></figure><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/02bb3305b64c1675270e9b7bb3b95dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*FlqiTD7G4QWpOOEJ0GIaMg.jpeg"/></div><figcaption class="mb mc et er es md me bd b be z dx ml di mm mn translated">配对之间的Flann匹配。</figcaption></figure></div><h1 id="c41d" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">单应估计。</h1><p id="297e" class="pw-post-body-paragraph jj jk hi jl b jm lg ij jo jp lh im jr js li ju jv jw lj jy jz ka lk kc kd ke hb bi translated"><em class="kf">在下一部分，我需要读者多一点关注！:)</em></p><p id="3324" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们有了成对的单应性。假设这些是H_01，H_02，H_03，H_12，H_13，H_23。注意，H_01指的是将图像0变换到图像1的参考帧的单应性。</p><ul class=""><li id="2647" class="ll lm hi jl b jm jn jp jq js ln jw lo ka lp ke lq lr ls lt bi translated">为了创建一个单一的全景图像，我们基本上是在试图重现单个相机可能看到的东西。所以我们试图根据给我们的图像之一来改变我们的图像。</li><li id="b65a" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">选择中心图像作为参考是完全合理的，因为每个图像需要经历的平均变化量将被最小化，从而在所有变换之后产生最大的输出均匀性。</li><li id="7034" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">故障来了！我们不知道顺序。</li></ul><p id="77d6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我想出了一个算法，在某种程度上类似于k-means算法来找到这个顺序。请记住前面显示的代表每对匹配数量的矩阵。姑且称之为“探路者”。</p><blockquote class="mo mp mq"><p id="b71e" class="jj jk kf jl b jm jn ij jo jp jq im jr mr jt ju jv ms jx jy jz mt kb kc kd ke hb bi translated"><strong class="jl hj"> [[ 0，204，74，233]，[204，0，306，42]，[ 74，306，0，0]，[233，42，0，0]] </strong></p></blockquote><p id="5011" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">在图像中寻找顺序。</strong></p><ul class=""><li id="1433" class="ll lm hi jl b jm jn jp jq js ln jw lo ka lp ke lq lr ls lt bi translated">选择一个随机图像作为中心图像。假设是0。</li><li id="56b2" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">从矩阵的行中找出最匹配的。233对吗？</li><li id="b6c6" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">我现在肯定地知道0和3相邻出现，但是它是0–3还是3–0呢？Idk。我们会考虑的。现在我们先说0–3。</li><li id="761a" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">现在你的列表中有2个元素，找出谁与0最匹配，谁与3最匹配。避免考虑已经在你的列表中的图片。如果已经获得了图像的最佳匹配，则选择下一个最佳匹配。0的最佳匹配结果是1，对应于204个匹配，3的最佳匹配结果是1，对应于42个匹配。</li><li id="c28b" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">由于204&gt;42，0获胜并在它的左侧获得图像1，因此到目前为止顺序为{1，0，3}。如果3赢了，1将有权发出命令{0，3，1}。</li><li id="ac8f" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">现在重复相同的过程，选择1，3作为支点，找出顺序，直到列表达到最大可能大小。最终的顺序是{2，1，0，3}。</li><li id="4b04" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">一旦获得了完整的列表，我们需要验证我们一开始选择0作为中心图像的假设。我们用上一步获得的图像列表的中心来更新0。以此为中心图像，重复整个过程。3次迭代将会给你精确的顺序，如果不是2次的话。</li></ul><blockquote class="mo mp mq"><p id="b6ec" class="jj jk kf jl b jm jn ij jo jp jq im jr mr jt ju jv ms jx jy jz mt kb kc kd ke hb bi translated"><strong class="jl hj">重要-1:我们需要担心我们在这个算法中错过的最后一件事。我们不知道上面得到的顺序是图像从左到右的顺序还是从右到左的顺序。如果我们在第一步中选择3–0而不是0–3，输出顺序将与我们现在得到的完全相反。</strong></p></blockquote><p id="36fa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">相对于基础图像变换所有图像。</strong></p><ul class=""><li id="f50b" class="ll lm hi jl b jm jn jp jq js ln jw lo ka lp ke lq lr ls lt bi translated">让我们找出选择从上述算法接收的顺序的中心图像的变换，现在担心它现在是l-r还是r-l。</li><li id="b5ef" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">我们对pathFinder算法做了一个小小的改变，我们记录了帮助我们建立完整列表的图像对。例如，0的最佳匹配结果是3。所以，(0，3)是一对。然后下一个最好的结果是1比0。所以(0，1)是另一对。</li></ul><blockquote class="mo mp mq"><p id="5b02" class="jj jk kf jl b jm jn ij jo jp jq im jr mr jt ju jv ms jx jy jz mt kb kc kd ke hb bi translated"><strong class="jl hj">重要-2:为什么需要这样做？待说明。</strong></p></blockquote><ul class=""><li id="d411" class="ll lm hi jl b jm jn jp jq js ln jw lo ka lp ke lq lr ls lt bi translated">我们将最终相对于中心图像变换所有的图像。让我们在这里这样做，并假设顺序{2，1，0，3}从左到右。</li><li id="700e" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">选择1作为基础图像，相对于1变换其他图像。</li><li id="795c" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">对于图像2，我们知道H_12读作“1看到的图像2”。</li><li id="eefb" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">对于图像0，我们知道H_01读作“0看到的图像1”。我们需要逆变换为逆(H_01)。</li><li id="e5fc" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">对于图3，我们知道H_13仍然是H_13。</li></ul><blockquote class="mo mp mq"><p id="13eb" class="jj jk kf jl b jm jn ij jo jp jq im jr mr jt ju jv ms jx jy jz mt kb kc kd ke hb bi translated">重要-3:这里有一个问题。待说明。</p></blockquote><ul class=""><li id="bb76" class="ll lm hi jl b jm jn jp jq js ln jw lo ka lp ke lq lr ls lt bi translated">我们通过简单的计算逆(H_01)*Image(0)就知道了image 0看起来应该是怎样的1。仅对图像0的中心进行相同的操作将给出其变换后的位置。将其与中心图像的位置进行比较。如果发生在右侧，则<strong class="jl hj">重要-1中的假设为真。否则，颠倒你假设的顺序。</strong></li><li id="1388" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">我们计算了图像3在1看来像H_13，但是你不想使用这个值，因为它不会给出很好的结果。远离中心出现的图像在变换时会变形。这就是为什么你要把H_13看成是单应矩阵上的一系列级联运算。H_13 =逆(H_01)*H_03。可以这样理解，当1看到的图像0与0看到的图像3级联时，1会看到图像3。为此，我们需要维护<strong class="jl hj">重要-2中提到的线对。</strong>这也是<strong class="jl hj">重要-3中强调的问题。</strong></li></ul><p id="114f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们可以放松了！</p><p id="c15d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">到目前为止我们做了什么？</strong></p><ul class=""><li id="a4cd" class="ll lm hi jl b jm jn jp jq js ln jw lo ka lp ke lq lr ls lt bi translated">我们已经确定了图像中的正确顺序。</li><li id="ee75" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">我们还确定了基本图像。</li><li id="e3c8" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">我们知道如何在基本图像的参考系中变换其余的图像。</li><li id="7e4c" class="ll lm hi jl b jm lu jp lv js lw jw lx ka ly ke lq lr ls lt bi translated">我们现在要做的就是缝合和融合它们。</li></ul><h1 id="f8a0" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">缝合。</h1><p id="d1e4" class="pw-post-body-paragraph jj jk hi jl b jm lg ij jo jp lh im jr js li ju jv jw lj jy jz ka lk kc kd ke hb bi translated"><strong class="jl hj">我们不想做什么？</strong></p><p id="618f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们不想一次缝合一个图像！您可以在多个地方找到这种方法，但这不会每次都给你可靠的结果。如果数据中的图像数量很大，将会过度拉伸最右边和最左边的图像。</p><blockquote class="mo mp mq"><p id="829e" class="jj jk kf jl b jm jn ij jo jp jq im jr mr jt ju jv ms jx jy jz mt kb kc kd ke hb bi translated">重要提示-4:我们将创建一个单独的大平面，并将所有东西都投影到上面。</p></blockquote><p id="3aef" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">可以这样想，你有一个大小为400*400*3的中心图像。现在我们坐的飞机是4000*4000*3的。我们可以把第一张图片放在这个平面的中心。(注意这是翻译操作。)类似地，在我们的情况下，对于所有图像0，2，3，我们可以平移所计算的单应性，并将这些图像投影到该平面上。我们不需要担心实际拼接它们或者寻找交叉点等等。</p><p id="606f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们最终会看到的是，</p><div class="iy iz ja jb fd ab cb"><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/c02e53aa0e82ae7bc4f6b79d856c7ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ksNdyYEtjaZ-SkvKMK3gBQ.jpeg"/></div></figure><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/30fb88a5f96e4a6ec58def33749cbfb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*nfWBTEa7iKSRIKoHhaPUxA.jpeg"/></div></figure></div><div class="ab cb"><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/34bcd8eb0ce679160315605290f521ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*hCnUSWzRDv-Y66H2b3E8QQ.jpeg"/></div></figure><figure class="mf jc mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/375f4f2282168bab7affc38ef3897150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*i0BqfjwylBTqTeUGaImalw.jpeg"/></div></figure></div><p id="abd0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我们把这些加起来会怎么样？你会看到全景。哇！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/0b4b60faa5a214ba00e851485df97332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qr-xKm1rSgD-I_5_fwr1rA.jpeg"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">拼接图像。</figcaption></figure><p id="7b83" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们在这里看到一条可见的接缝。我们可以通过混合来去除。我使用了拉普拉斯算子，但是你也可以使用其他的技术，比如阿尔法，图形切割等等。</p><p id="a784" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">应用拉普拉斯混合并通过简单的平均强度来平衡曝光可以为你提供无缝的结果，如下所示。您可以在Git上查看相同的代码。如果你弄清楚拉普拉斯混合的遮罩是如何从代码中生成的，那将会很有趣。在这篇文章中讨论这个似乎有点过头了。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/af35f5690526bca4274c8d43d6d6fef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5i5kQj5I7VIkFQD1xLE7yA.jpeg"/></div></div></figure></div></div>    
</body>
</html>