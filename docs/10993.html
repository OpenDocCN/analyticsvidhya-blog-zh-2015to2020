<html>
<head>
<title>Finding the urgent blood/plasma requirements on Twitter using Spark Streaming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spark Streaming在Twitter上查找紧急血液/血浆需求</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/finding-the-urgent-blood-plasma-requirements-on-twitter-using-spark-streaming-959ebb6f5590?source=collection_archive---------12-----------------------#2020-11-12">https://medium.com/analytics-vidhya/finding-the-urgent-blood-plasma-requirements-on-twitter-using-spark-streaming-959ebb6f5590?source=collection_archive---------12-----------------------#2020-11-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="5989" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">简介:</h1><p id="60cb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这段代码中，我使用了spark流来</p><p id="eb50" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">1)确定与血液或血浆需求相关的推文</p><p id="d083" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">2)过滤掉推文，以便仅识别与紧急或即时血液或血浆需求相关的推文</p><p id="14bc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">3)提取用于这些推文的日期、用户ID、位置和标签，并将其存储在一个表和一个parquet文件中</p><h1 id="c2ab" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">使用的技术:</h1><p id="2461" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">1) Spark版本3.0.1</p><p id="aaff" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">2) Scala版本2.12.10</p><p id="606a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">3) Java 1.8.0_271</p><h1 id="93fa" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">初始配置:</h1><p id="91f6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">1.首先，我们将Spark流类的名称和一些隐式转换从StreamingContext导入到我们的环境中</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d58f" class="kp ig hi kl b fi kq kr l ks kt"><strong class="kl hj">import</strong> org.apache.spark._<br/><strong class="kl hj">import</strong> org.apache.spark.SparkContext._<br/><strong class="kl hj">import</strong> org.apache.spark.sql.functions.{col, lit, when}<br/><strong class="kl hj">import</strong> org.apache.spark.streaming._<br/><strong class="kl hj">import</strong> org.apache.spark.streaming.twitter._<br/><strong class="kl hj">import</strong> org.apache.spark.streaming.StreamingContext._<br/><strong class="kl hj">import</strong> org.apache.spark.sql.SparkSession<br/><strong class="kl hj">import</strong> org.apache.spark.sql.SaveMode<br/><strong class="kl hj">import</strong> org.apache.spark.rdd.RDD<br/><strong class="kl hj">import</strong> Utilities._</span></pre><p id="bb49" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">2.使用twitter.txt配置Twitter凭证</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a789" class="kp ig hi kl b fi kq kr l ks kt">setupTwitter()</span></pre><p id="b0bd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">setupTwitter的实现如下。它使用主工作区目录中的twitter.txt配置Twitter服务凭证。这里，twitter凭证是通过调用System.setProperty(Twitter4J的默认OAuth授权)来设置的</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5efd" class="kp ig hi kl b fi kq kr l ks kt"><strong class="kl hj">def</strong> setupTwitter() = {<br/><strong class="kl hj">import</strong> scala.io.Source</span><span id="0bec" class="kp ig hi kl b fi ku kr l ks kt"><strong class="kl hj">for</strong> (line &lt;- Source.fromFile(“../twitter.txt”).getLines) {<br/><strong class="kl hj">val</strong> fields = line.split(“ “)<br/><strong class="kl hj">if</strong> (fields.length == 2) {<br/>System.setProperty(“twitter4j.oauth.” + fields(0), fields(1))<br/>}<br/>}</span><span id="87cb" class="kp ig hi kl b fi ku kr l ks kt">}</span></pre><p id="7ec6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">3.StreamingContext是所有流功能的主要入口点。设置一个名为“DonateBlood”的Spark流上下文ssc，它使用所有CPU内核和一秒钟一批的数据在本地运行。它接收流数据作为输入，并生成批量数据。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="4fae" class="kp ig hi kl b fi kq kr l ks kt"><strong class="kl hj">val ssc = new StreamingContext(“local[*]”, “DonateBlood”, Seconds(1))</strong></span></pre><p id="da78" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">4.将日志级别设置为错误，以消除火花产生的噪声日志</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="00bf" class="kp ig hi kl b fi kq kr l ks kt">setupLogging()</span><span id="1286" class="kp ig hi kl b fi ku kr l ks kt"><strong class="kl hj">def</strong> setupLogging() = {<br/><strong class="kl hj">import</strong> org.apache.log4j.{Level, Logger}<br/><strong class="kl hj">val</strong> rootLogger = Logger.getRootLogger()<br/>rootLogger.setLevel(Level.ERROR)</span><span id="1b31" class="kp ig hi kl b fi ku kr l ks kt">}</span></pre><p id="264f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">5.使用Spark流上下文和过滤器从Twitter创建一个数据流。数据流是用户可以分析的连续数据流。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="9069" class="kp ig hi kl b fi kq kr l ks kt">val tweets = TwitterUtils.createStream(ssc, None, filters)</span></pre><p id="f746" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">注意:</p><p id="bc40" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">a)我们将“None”作为twitter4J身份验证进行传递，因为已经通过调用setup witter()<br/>设置了Twitter凭证。b)我们已经创建了一个不可变的过滤器关键字列表，在创建Twitter流时作为参数进行传递</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="6845" class="kp ig hi kl b fi kq kr l ks kt"><strong class="kl hj">val filters</strong> = List(“blood”,”plasma”, “#blood”, “#bloodrequired”,”#BloodMatters”,”#BloodDrive”,”#DonateBlood”,”#Blood”,”#NeedBlood”)</span></pre><h1 id="2eba" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">分析推文</h1><h2 id="831b" class="kp ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">1.现在使用map()从每条推文中提取id、日期、用户、文本、位置、转发和标签。注意，为了提取hashtags，我们通过使用' '(空格)分割状态文本来创建单词列表，然后只过滤以#开头的单词</h2><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5ddb" class="kp ig hi kl b fi kq kr l ks kt"><strong class="kl hj">val</strong> statuses = tweets.map{status =&gt;<br/>    <strong class="kl hj">val</strong> id = status.getUser.getId<br/>    <strong class="kl hj">val</strong> user = status.getUser.getName<br/>    <strong class="kl hj">val</strong> date = status.getCreatedAt.toString<br/>    <strong class="kl hj">val</strong> text = status.getText<br/>    <strong class="kl hj">val</strong> location = status.getUser.getLocation<br/>    <strong class="kl hj">val</strong> retweet = status.isRetweet()</span><span id="7df1" class="kp ig hi kl b fi ku kr l ks kt"><strong class="kl hj">    val</strong> hashtags = status.getText.split(“ “).toList.filter(word =&gt;   word.startsWith(“#”))<br/>(id, date, user,text,location, retweet, hashtags)</span><span id="5cd5" class="kp ig hi kl b fi ku kr l ks kt">}</span></pre><h2 id="abfc" class="kp ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">2.RDD变换:</h2><p id="6d4f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">a)status . Foreachrdd((rdd，time): Foreachrdd用于对数据流中的每个RDD执行任意操作，还用于将数据流保存到外部存储器，在这种情况下，是一个parquet文件和一个临时表。</p><p id="86ca" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">b) SparkSession.builder():要对流数据使用DataFrames和SQL操作，我们必须使用StreamingContext正在使用的SparkContext创建SparkSession。</p><p id="05c6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">c)使用rdd.toDF()将RDD[字符串]转换为DataFrame，并仅过滤出包含诸如紧急、需要、紧急和必需之类的词语的文本。这是为了过滤那些急需血液或血浆的邮件。这作为一个有效的过滤器来过滤一般的献血相关消息，如“我今天献血了”、“组织献血运动”等。</p><p id="273e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">d)使用dropDuplicates()删除重复项。这将过滤掉由于转发相同状态而出现的重复。</p><p id="082c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">e) rdd.count() &gt; 0且bloodonatetweets . count()&gt; 0:过滤出空批次</p><p id="fe4c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">f)最后，我们将生成的tweets保存为一个临时表，以提供SQL互操作性，并保存为一个parquet文件。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="ea4d" class="kp ig hi kl b fi kq kr l ks kt">statuses.foreachRDD((rdd, time) =&gt;<br/>{<br/><strong class="kl hj">val</strong> spark = SparkSession.builder().appName(“MyProject”).getOrCreate()</span><span id="f485" class="kp ig hi kl b fi ku kr l ks kt"><strong class="kl hj">import</strong> spark.implicits._</span><span id="eecf" class="kp ig hi kl b fi ku kr l ks kt"><strong class="kl hj">if</strong> (rdd.count() &gt; 0){</span><span id="587c" class="kp ig hi kl b fi ku kr l ks kt"><strong class="kl hj">     val</strong> requestsDataFrame =    rdd.toDF(“id”,”date”,”user”,”text”,”location”,”retweet”,”hashtags”)</span><span id="daae" class="kp ig hi kl b fi ku kr l ks kt"><strong class="kl hj">     val</strong> bloodDonateTweets = requestsDataFrame.filter(col(“text”).contains(“urgent”) || col(“text”).contains(“need”) || col(“text”).contains(“emergency”) || col(“text”).contains(“required”)).dropDuplicates(“text”)</span><span id="52c2" class="kp ig hi kl b fi ku kr l ks kt"><strong class="kl hj">    if</strong> (bloodDonateTweets.count() &gt; 0){       bloodDonateTweets.createOrReplaceTempView(“BloodDonationTable”)<br/>    <strong class="kl hj">val</strong> solution = spark.sqlContext.sql(“select * from BloodDonationTable order by date”)<br/>    solution.show(<strong class="kl hj">false</strong>)<br/>    solution.coalesce(1).write.mode(SaveMode.Append).parquet(path)</span><span id="0a36" class="kp ig hi kl b fi ku kr l ks kt">}</span><span id="4b94" class="kp ig hi kl b fi ku kr l ks kt">}</span><span id="f07f" class="kp ig hi kl b fi ku kr l ks kt">})</span></pre><h2 id="5c63" class="kp ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">3.全部踢开！</h2><p id="7b03" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">a)SSC . check point(" C:/check point/")—我们通过在容错、可靠的文件系统(例如，HDFS、S3等)中设置目录来启用检查点。)来保存检查点信息。</p><p id="25da" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">b) ssc.start() —直到此时，代码的实际执行才开始。在start()之后，JobScheduler启动，这又会启动JobGenerator来创建作业。</p><p id="3838" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">c) ssc.awaitTermination()-它只是等待来自用户的终止信号。当它接收到来自用户的信号(即CTRL+C或SIGTERM)时，它的流上下文将被停止。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="174a" class="kp ig hi kl b fi kq kr l ks kt">ssc.checkpoint(“C:/checkpoint/”)<br/>ssc.start()<br/>ssc.awaitTermination()</span></pre><h1 id="e58a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">输出:</h1><p id="ed62" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我在Scala eclipse IDE中运行了这段代码。几分钟后，我终止了进程，这是结果。</p><p id="9ce1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如下所示，显示了ID、日期、用户、文本、位置、转发和推文中的标签。</p><figure class="kg kh ki kj fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es li"><img src="../Images/6fbcd62893306fdd2a466b08727ac1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3ewaRez01DbuDRzJEy0qA.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">“solution.show( <strong class="bd ih"> false </strong>)的输出</figcaption></figure><figure class="kg kh ki kj fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lu"><img src="../Images/1f991f816ee16f1278e61db4d0253b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MrJjwr6ehqpWvdqhzZlXng.png"/></div></div></figure><h1 id="38e7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论:</h1><p id="3fb8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我的完整代码可以在这里找到:<a class="ae lv" href="https://github.com/annapooranik/TweetAnalysisForBloodDonation" rel="noopener ugc nofollow" target="_blank">https://github . com/annapooranik/tweetlanasisforblooddonation</a></p><p id="d426" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">尽管这个例子非常简单，但我们可以在这些结果的基础上构建一些有趣的仪表板来解决现实生活中的问题，从而确定:</p><p id="a70b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">1.如果紧急血型要求和地点之间有模式。该信息将有助于在特定位置安排献血者或血库。</p><p id="ff2c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">2.在这种场景中，什么标签是常用的，哪些标签提供了最大的可见性和可及性(使用isRetweet())</p></div></div>    
</body>
</html>