<html>
<head>
<title>Stylistic differences between R and Python for exploratory data analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于探索性数据分析的R和Python之间的风格差异</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/stylistic-differences-between-r-and-python-for-exploratory-data-analysis-1c5195162b8a?source=collection_archive---------13-----------------------#2020-03-11">https://medium.com/analytics-vidhya/stylistic-differences-between-r-and-python-for-exploratory-data-analysis-1c5195162b8a?source=collection_archive---------13-----------------------#2020-03-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="35d3" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">数据科学文体学</h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/81a7c4d909fb38c9b011ef322cb0fd3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VDbLTSHcqRKCkdbyc3v3xg.jpeg"/></div></div></figure><p id="2fb3" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在准备了我在<a class="ae jx" rel="noopener" href="/swlh/stylistic-differences-between-r-and-python-for-data-preparation-bfda6ebd15aa"> <strong class="jb hs">之前的博客</strong> </a>中解释的数据之后，个人可能会有他们想要测试的先验假设(ht)。在其他情况下，探索性数据分析(EDA)是在数据框架中寻找重要模式的驱动力。探索的方法可以是多方面的，并应导致可以描述关系和设置参数的视觉输入，以开发准确的统计模型。下图解释了基于视觉输出的数据浏览的目的。</p><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es jy"><img src="../Images/c186e77f13b1ee5a6e324861cc52b726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*rQMMFPbpUe2Koq6IB4YxkA.jpeg"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">探索性数据分析的目的</figcaption></figure><p id="710b" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">以下步骤旨在提供一个初步的可视化解决方案范围，以解决这三个目标，并推进最合适的统计模型的开发。另一个目标是强调Python和r中语义的一些不同和相似之处。</p><h1 id="15ab" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">1.重新创建可测试的数据框架</h1><p id="c4c2" class="pw-post-body-paragraph iz ja hi jb b jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js lj ju jv jw hb bi translated">视觉输出的生成受益于创建多个分类变量以创建覆盖图。为了增加我们在<strong class="jb hs"> Python、</strong>中的数据帧的复杂性，添加了一个新的分类变量，即“Balance”，如下面的代码所示。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="d7ad" class="lp ki hi ll b fi lq lr l ls lt">df = pd.DataFrame(np.random.randint(0,100,size=(100, 3)), columns= ('A','B','C'))</span><span id="ff7e" class="lp ki hi ll b fi lu lr l ls lt">Place = (['PlaceA','PlaceB','PlaceC'])<br/>df["Place"] = np.random.choice(Place, size=len(df))</span><span id="7268" class="lp ki hi ll b fi lu lr l ls lt">Balance = (["Credit", "Debit","Zero"])<br/>df["Balance"] = np.random.choice(Balance, size=len(df))</span><span id="c214" class="lp ki hi ll b fi lu lr l ls lt">df['index']=pd.Series(range(0,100))</span><span id="187e" class="lp ki hi ll b fi lu lr l ls lt">df['Geolocation']=df['Place']<br/>dict_place={"Geolocation":{"PlaceA":"London", "PlaceB":"Delhi", "PlaceC":"Rome"}}<br/>df.replace(dict_place, inplace=True)<br/>df.head()</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es lv"><img src="../Images/85a27c36444179e7d0128c0efda16a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*YL4MIuUgbEG-ULK_y_6MwA.jpeg"/></div></figure><p id="a4ad" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在<strong class="jb hs"> R </strong>中，扩充数据帧的生成遵循类似的过程。最明显的区别是增加了随机分类变量，这需要指定概率分布，而不是另一个库中的自动函数。除此之外，代码的结构非常相似，在语义上几乎没有区别。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="a0fe" class="lp ki hi ll b fi lq lr l ls lt">df &lt;- data.frame(replicate(3,sample(0:100, 100, rep=TRUE)))<br/>colnames(df) &lt;- c("A","B","C")</span><span id="b231" class="lp ki hi ll b fi lu lr l ls lt">df$Place &lt;- sample(c("PlaceA", "PlaceB","PlaceC"), size = nrow(df), prob = c(0.76, 0.14,0.1), replace = TRUE)<br/>df$Balance &lt;- sample(c("Credit", "Debit","Zero"), size = nrow(df), prob = c(0.70, 0.1,0.45), replace = TRUE)</span><span id="dfe9" class="lp ki hi ll b fi lu lr l ls lt">n&lt;-dim(df)[1]<br/>df$index&lt;-c(1:n)</span><span id="1e48" class="lp ki hi ll b fi lu lr l ls lt">dict_place&lt;-revalue(x=df$Place, replace= c("PlaceA"="London", "PlaceB"="Delhi", "PlaceC"="Rome"))<br/>df$Geolocation&lt;-dict_place<br/>head(df)</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es lw"><img src="../Images/75d0955bfe7b93d2e8046ef3f209bdcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*jUgyBxOk6_iDSPAKJELh7A.jpeg"/></div></figure><h1 id="15c3" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">2.带有响应覆盖的条形图</h1><p id="c61c" class="pw-post-body-paragraph iz ja hi jb b jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js lj ju jv jw hb bi translated">一旦用两种语言创建了数据框架，下一步就是通过图形方式可视化关系。带有反应重叠的条形图可用于探索分类预测值和目标变量之间的关系。</p><p id="496d" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">为此，第一步是通过建立可修改的参数来控制每个图形的大小。在Python中，最成熟的库之一是<code class="du lx ly lz ll b">matplotlib.pyplot </code>，后面还有<code class="du lx ly lz ll b">%matplotlib inline</code>，这是一个在Jupyter笔记本中添加图形的关键命令。该库允许输出遵循如下所示的图形大小。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="cedc" class="lp ki hi ll b fi lq lr l ls lt">import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="7775" class="lp ki hi ll b fi lu lr l ls lt">fig_size = plt.rcParams["figure.figsize"]<br/>fig_size[0] = 10<br/>fig_size[1] = 5<br/>plt.rcParams["figure.figsize"] = fig_size</span></pre><p id="5d68" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在基于最佳值设置了一个数字大小之后，下一步将是可视化两个分类变量之间的关系。在这种情况下,“Place”和“Balance”将在输出中显示为一个简单的堆积条形图，显示分布在响应变量的三个属性中的频率计数。在Pandas逻辑中，<code class="du lx ly lz ll b">crosstab</code>函数后的第一个变量是预测值(x ),第二个变量是目标值(y)。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="151b" class="lp ki hi ll b fi lq lr l ls lt">crosstab_01=pd.crosstab(df['Place'],df['Balance'])<br/>crosstab_01.plot(kind='bar', stacked=True)<br/>plt.legend(loc='center left', bbox_to_anchor=(1, 0.9))</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es ma"><img src="../Images/5a5f143b979c8f521d623b4152a77ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*_8CrdxZ6fADzddMLyP7Xow.jpeg"/></div></figure><p id="e3d8" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">频率分布需要通过基于每个分类属性内的比例进行计数来归一化。<code class="du lx ly lz ll b">div</code>和<code class="du lx ly lz ll b">sum</code>命令的组合将把预测变量“Place”的每个属性中的值的分布视为独立的，它们的总和除以轴0，这在Python中表示行，在这里由变量“Balance”举例说明。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="8ac9" class="lp ki hi ll b fi lq lr l ls lt">crosstab_norm=crosstab_01.div(crosstab_01.sum(1),axis=0)<br/>crosstab_norm.plot(kind='bar', stacked=True)<br/>plt.legend(loc='center left', bbox_to_anchor=(1, 0.9))</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es mb"><img src="../Images/2b597ba47c337361b1373cb8eff153dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*8vWVdRnKPNprW72otill4w.jpeg"/></div></div></figure><p id="e187" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">当设置绘图的尺寸时，<strong class="jb hs"> R </strong>允许通过简单调用(<code class="du lx ly lz ll b">set_plot_dimension</code>)和修改尺寸的数值参数，使用可应用于任何图形的功能。该函数结构允许控制<code class="du lx ly lz ll b">repr</code>包的行为，而不是直接调用它，并提供在括号内改变参数的灵活性。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="9ea6" class="lp ki hi ll b fi lq lr l ls lt">set_plot_dimensions &lt;- function(width_choice, height_choice) <br/>{options(repr.plot.width = width_choice, repr.plot.height = height_choice)}</span><span id="5a80" class="lp ki hi ll b fi lu lr l ls lt">set_plot_dimensions(8,4)</span></pre><p id="4124" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">一旦设置了绘图的大小，<strong class="jb hs"> R </strong>就可以用更简单的代码产生吸引人的视觉输出。上传<code class="du lx ly lz ll b">ggplot2</code>库后，要定义的参数是数据帧的名称和第一个实例中感兴趣的值(预测值)。第二步需要通过定义变量来描述函数<code class="du lx ly lz ll b">geom_bar </code>中的目标变量，以表征美学映射(<code class="du lx ly lz ll b">aes</code>)。R的另一个很酷的特性是通过使用<code class="du lx ly lz ll b">coord_flip</code>翻转图表的能力，以及生成吸引人的视觉输出的设计原则的内置自动化。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="6b32" class="lp ki hi ll b fi lq lr l ls lt">library(ggplot2)<br/>ggplot(df, aes(Place))+geom_bar(aes(fill=Balance))+ coord_flip()</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es mc"><img src="../Images/18de3f60e3aa66e0be6a05e9e225f669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*8pnVAg655JIQCkjozALLmw.jpeg"/></div></figure><p id="e90c" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">为了使分布标准化，增加了<code class="du lx ly lz ll b">geom_bar</code>中的填充规范，填充的位置将实现预测变量(位置)的每个分类属性内答案的比例分布。简单加法不需要进一步的说明，因为已经嵌入到应用于目标变量的函数中。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="3afa" class="lp ki hi ll b fi lq lr l ls lt">ggplot(df, aes(Place))+geom_bar(aes(fill=Balance), position='fill')+ coord_flip()</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es mb"><img src="../Images/7593580b52f8df10a97305583979a103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*wj-gZouE_MRBDst_vrER1g.jpeg"/></div></figure><h1 id="0bff" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">3.带响应覆盖的直方图</h1><p id="feff" class="pw-post-body-paragraph iz ja hi jb b jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js lj ju jv jw hb bi translated">直方图是数字变量频率分布的图形表示。为了确定响应分布的模式，应用了将频率计数转换成比例的类似方法。在Python中，构建数值变量的分层频率图需要创建两个子集，对应于一个分类属性及其沿数值变量的分布。可视化数字分布的方式是，<code class="du lx ly lz ll b">bin</code>命令沿着分布划分多个部分，而<code class="du lx ly lz ll b">stacked</code>沿着一个条编译分解。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="7ca8" class="lp ki hi ll b fi lq lr l ls lt">import numpy.np<br/>import matplotlib.pyplot as plt</span><span id="af59" class="lp ki hi ll b fi lu lr l ls lt">df_Debit= df[df.Balance=='Debit']['A']<br/>df_Credit= df[df.Balance=='Credit']['A']<br/>df_Zero= df[df.Balance=='Zero']['A'</span><span id="9e67" class="lp ki hi ll b fi lu lr l ls lt">plt.hist([df_Debit,df_Credit,df_Zero], bins=10, stacked=True)<br/>plt.legend(['Debit', "Credit",'Zero'])<br/>plt.title('Histogram of variable A with response overlay')<br/>plt.xlabel(''); plt.ylabel('Count'); plt.show()</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es md"><img src="../Images/1532d38293a55f0a58969708b2fd7c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*a3S4X3ovm6BW4CQugeF9fQ.jpeg"/></div></figure><p id="9c08" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">为了使分布正常化，如果保持仓间距，代码会变得复杂得多。初始的两列矩阵(其中列保存每个条的高度)需要通过将每行除以该行的总和来进行归一化。在为数据框中的每一列生成一个调整比例的标准化表格后，创建一个可视分布只需要比例表中的一个<code class="du lx ly lz ll b">plot</code>条。这种方法不需要定义仓之间的实际间距，因此更简单，并且会在图形中将每个仓视为一个单独的列。从这个例子来看，<strong class="jb hs"> Python </strong>似乎是通用的，因为它允许用户更多地动手定义对象之间的空间和边界，但也提供了快捷方式，尽管代价是减少了对美学的控制。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="54af" class="lp ki hi ll b fi lq lr l ls lt">(n, bins, patches)=plt.hist([df_Debit,df_Credit,df_Zero], bins=10, stacked=True)</span><span id="23ad" class="lp ki hi ll b fi lu lr l ls lt">n_table=np.column_stack((n[0],n[1],n[2]))<br/>n_norm=n_table/n_table.sum(axis=1)[:,None]<br/>n_norm = pd.DataFrame(n_norm, columns= ('Debit','Credit','Zero'))<br/>n_norm.plot(kind='bar', stacked=True)</span><span id="7383" class="lp ki hi ll b fi lu lr l ls lt">plt.legend(['Debit','Credit','Zero'])<br/>plt.title('Normalised histogram of variable A with response overlay')<br/>plt.xlabel('Variable A'); plt.ylabel('Proportion'); plt.show()</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es me"><img src="../Images/6d77855d3fa9da7b8545a3ccf9a01739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*kv3RaoXFRMyCkP-YBCEqTw.jpeg"/></div></figure><p id="f4ed" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">美观是r的核心特性，这简化了图形所需的代码量。在这种情况下，要产生频率计数，设置<code class="du lx ly lz ll b">geom_hist</code>函数中的参数就足以按分类属性进行分解。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="c14a" class="lp ki hi ll b fi lq lr l ls lt">ggplot(df,aes(A))+geom_histogram(aes(fill=Balance),color='black')</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es mf"><img src="../Images/b1b121802a88acc554ebb6b5344a4211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*MCwEGIFX7SOZjE0y36o7uw.jpeg"/></div></figure><p id="a688" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">为了生成一个直方图来表示每个条柱内的比例分布，计算被嵌入到<code class="du lx ly lz ll b">geom_histogram</code>中。通过指定直方图在同一个填充变量中的位置，比例会自动计算并以可视形式呈现。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="d95a" class="lp ki hi ll b fi lq lr l ls lt">ggplot(df,aes(A))+geom_histogram(aes(fill=Balance), color='black', binwidth=10, position='fill')</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es md"><img src="../Images/6ace98a2b1f1fcd0d1188c71ba36925d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*CfttxkdKKjKlXs7e9z90gw.jpeg"/></div></figure><h1 id="c639" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">4.基于预测的宁滨</h1><p id="ca58" class="pw-post-body-paragraph iz ja hi jb b jc lf je jf jg lg ji jj jk lh jm jn jo li jq jr js lj ju jv jw hb bi translated">宁滨作为一种导出新分类变量的策略，是一种根据数值预测值的不同集合相对于响应变量的表现将值置于特定范围内的方法。特定仓内的循环分布指示与预测的潜在值的关系。这种分析有助于识别分类变量和数字变量之间较强或较弱的关联。</p><p id="e7bb" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在<strong class="jb hs"> Python </strong>中，第一步是根据新的宁滨标准绘制频率计数图，该标准也可以反映百分位数或分位数，并且可以在bins命令中设置为首选值。基于新的分界点，交叉表的bar <code class="du lx ly lz ll b">plot</code>使输出能够堆叠各种分类属性的频率计数。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="3ec0" class="lp ki hi ll b fi lq lr l ls lt">df['binning']=pd.cut(x=df['A'], bins=[0,30,60,100], labels=['Under 30', '30 to 60','Over 60'], right=False)</span><span id="f944" class="lp ki hi ll b fi lu lr l ls lt">crosstab_02=pd.crosstab(df['binning'],df['Balance'])<br/>crosstab_02.plot(kind='bar', stacked=True, title='Bar graph of binned A variable with response overlay')</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es mf"><img src="../Images/762f7d6702cfebcc60c86cf5adc10381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*yLLy4-Z0iPT4DUN1C4gEtA.jpeg"/></div></figure><p id="90f2" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">跨新条柱的值分布的标准化基于跨分类值的比例。这个计算可以通过引入一个<code class="du lx ly lz ll b">lambda</code>函数来实现，这个函数产生一个比例表，用<strong class="jb hs"> Python </strong>来绘制。情节的其他特征(图例、标题……)如前定义。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="15cc" class="lp ki hi ll b fi lq lr l ls lt">table=pd.crosstab(df.binning, df.Balance).apply(lambda r: r/r.sum(), axis=1)</span><span id="ebb2" class="lp ki hi ll b fi lu lr l ls lt">table.plot(kind='bar',stacked=True)<br/>plt.legend(['Debit','Credit','Zero'])<br/>plt.title('Normalised histogram of variable A with response overlay')</span><span id="500d" class="lp ki hi ll b fi lu lr l ls lt">plt.xlabel('Variable A'); plt.ylabel('Proportion'); plt.show()</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es mg"><img src="../Images/7957758e737c6a8710ef93376aca4e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*Ot9U2Ug8XxvHkSsLhWmT4w.jpeg"/></div></figure><p id="0f8b" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在<strong class="jb hs"> R </strong>中，宁滨过程遵循类似的语言，函数cut生成分布中的间断。没有指定填充位置的ggplot中的视觉输出显示了频率计数。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="4662" class="lp ki hi ll b fi lq lr l ls lt">df$binning&lt;-cut(x=df$A, breaks=c(0,30,60,101), right=FALSE, <br/>                   labels= c("Under 30","30 to 60", "Over 60"))</span><span id="100c" class="lp ki hi ll b fi lu lr l ls lt">ggplot(df, aes(binning))+geom_bar(aes(fill=Balance))+ coord_flip()</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es mh"><img src="../Images/77f6ffbc9eb2f57828b7d40a6707373e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*uooCrFQ3d0TDfb9TH7vaHQ.jpeg"/></div></figure><p id="8bed" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">通过指定<code class="du lx ly lz ll b">fill</code>和<code class="du lx ly lz ll b">stat="count"</code>的位置，视觉输出提供了每个分类属性中的比例。这个比例的计算是通过使用stat自动完成的，它使条形的高度与每组中的病例数成比例。</p><pre class="jz ka kb kc fd lk ll lm ln aw lo bi"><span id="069c" class="lp ki hi ll b fi lq lr l ls lt">ggplot(df,aes(binning))+ geom_histogram(aes(fill=Balance), color='black', stat="count", position='fill')</span></pre><figure class="jz ka kb kc fd is er es paragraph-image"><div class="er es md"><img src="../Images/0973e97be87173ecb51282a5b949e1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*IODEsM7zQ_a922-kkn1ynQ.jpeg"/></div></figure><h1 id="1795" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">在此步骤之后，建议的数据科学方法的下一阶段是建立计算模型。这将在下一篇博客中解释</h1></div></div>    
</body>
</html>