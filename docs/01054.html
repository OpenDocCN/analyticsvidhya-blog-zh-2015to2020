<html>
<head>
<title>Adversarial Attack Using Genetic Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于遗传算法的对抗性攻击</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/adversarial-attack-using-genetic-algorithm-90beba13b6cb?source=collection_archive---------4-----------------------#2019-09-28">https://medium.com/analytics-vidhya/adversarial-attack-using-genetic-algorithm-90beba13b6cb?source=collection_archive---------4-----------------------#2019-09-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/28f0cfa9f8a9ac3171447c49b0349fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78GQG7k35-JnzhK4oxNxlg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">丹尼尔·利维斯·佩鲁西在Unsplash上的照片</figcaption></figure><p id="bbc3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对机器学习模型的对抗性攻击是去年的一个研究热点。虽然许多团队都在努力理解对抗性方法的含义，但这仍然是一个新的领域。</p><p id="02bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有两种主要的方法:<strong class="iw hj">白盒优化</strong>需要访问经过训练的模型架构和权重，并使用其可微性来生成对立样本。<strong class="iw hj">黑盒优化</strong>将模型视为一个隐藏状态未知的对象，只有一些I\O接口。虽然它通常涉及更多的计算，但黑盒场景更接近现实生活中的事件。</p><p id="5c9c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇文章中，我将解释如何使用遗传编程生成对立的例子。</p><p id="58a9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">想象一下，通过在你的社交资料图片中添加不引人注意的噪声，你的身份被窃取了。或者通过使用特殊的措辞或对内容进行其他细微的修改，让垃圾邮件通过提供商的过滤。这是典型的对抗性攻击的样子。</p><h1 id="bad6" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">建立模型</h1><p id="8625" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">事不宜迟，我们将采用MNIST数据集。它包含60000幅手写数字的灰度图像，每幅图像为28x28，包含一个数字。</p><p id="aa95" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我将使用PyTorch，因为它是高度灵活的库，允许快速原型化，并且是这种实验的理想选择。该架构是小型神经网络的典型架构——三个[卷积-&gt;池化-&gt;激活]块之后是全连接的“头”,以softmax层结束，以输出图像属于每个类的概率。</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="63c9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">经过几个时期的训练，模型在维持数据集上达到95%的准确率。以下是对测试图像的一些预测——它非常有效。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/5a48a06f76d962bbc3aa6480ea780c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*RMtl03LIxiNvQepcpn1G_w.png"/></div></div></figure><h1 id="4fae" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">遗传算法</h1><p id="128e" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">为了生成对立的例子，我们需要定义最优化问题。给定任何输入图像，我们的模型输出每一类的概率。假设，我们想让它相信图像包含高置信度的7。然后，我们需要生成这样的图像，它被分类为7的概率是<strong class="iw hj">最大化</strong>。<br/> <br/>遗传算法是一种通用方法，它需要预先定义几件事情:</p><ul class=""><li id="b669" class="lc ld hi iw b ix iy jb jc jf le jj lf jn lg jr lh li lj lk bi translated">基因——问题解决方案的单一实例。在我们的例子中，它是28×28的矩阵，代表一幅图像</li><li id="5b9c" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">群体——基因列表</li><li id="e60a" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">适应度函数——评估每个候选人的能力。在我们的设置中，它是概率(候选人= 7)</li><li id="e3ab" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">变异——增加候选解随机性的函数。在我们的例子中，随机改变像素强度</li><li id="237d" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">交叉——组合几个候选解决方案的例行程序。在我们的例子中，我们从一幅图像中随机选择一半的像素，剩下的一半从另一幅图像中选择</li></ul><p id="25c1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦我们定义了这个，算法就很简单了:</p><ol class=""><li id="ffc7" class="lc ld hi iw b ix iy jb jc jf le jj lf jn lg jr lq li lj lk bi translated">随机初始化群体</li><li id="6ee1" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lq li lj lk bi translated">对于<code class="du lr ls lt lu b">n</code>时代:</li></ol><ul class=""><li id="c341" class="lc ld hi iw b ix iy jb jc jf le jj lf jn lg jr lh li lj lk bi translated">使用适应度函数对每个候选人进行评分</li><li id="ddcf" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">选择前<em class="lv"> k </em>个候选者，其他的很有可能被丢弃</li><li id="42d1" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">随机变异其中的一部分(除了最好的一个)</li><li id="e647" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">对于剩余的位置，添加随机交叉，直到群体大小恢复</li></ul><p id="97de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我不会深入讨论实现细节，因为您可以在存储库中检查代码。可以说，我们有一个<code class="du lr ls lt lu b">GeneticSolver</code>类，它需要图像大小来进行初始化。<code class="du lr ls lt lu b">solve</code>方法以优化为切入点，以适应度函数为自变量。它也接受<code class="du lr ls lt lu b">n_generations</code>——运行的代数。</p><h1 id="1b5e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">对抗性攻击</h1><h2 id="aa4d" class="lw jt hi bd ju lx ly lz jy ma mb mc kc jf md me kg jj mf mg kk jn mh mi ko mj bi translated">类别概率</h2><p id="6143" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">我们从简单的目标开始:最大化敌对目标<code class="du lr ls lt lu b">adv_target</code>的概率。我们以<code class="du lr ls lt lu b">adv_target=7</code>为例。</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="07de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">结果相当令人印象深刻:经过1400个纪元后，我们说服了模型，图像上有99%的概率是7。这是优化过程的可视化:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/bf96b13d7c21f674e50cf123487326f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/1*_DsDi8snpAem7-uD4ETlPg.gif"/></div></figure><h2 id="8db7" class="lw jt hi bd ju lx ly lz jy ma mb mc kc jf md me kg jj mf mg kk jn mh mi ko mj bi translated">具有非零内容惩罚的类概率</h2><p id="b1fb" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">现在让我们做一些更有趣的事情。例如，让我们不仅说服模型图像上的噪声是某个数字，而且让我们用最小数量的有效像素来做这件事。将其转化为健身功能:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="2b2d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们把<code class="du lr ls lt lu b">adv_target=5</code>作为我们的下一个目标标签。为了获得良好的视觉效果，我将种群大小从默认的100增加到300。超过1800个时代的进化:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/1e451f2f1a8b5f37a915391b2bdc5995.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/1*tJxVGPRC6V4d6QEALPpFFw.gif"/></div></figure><h2 id="0daa" class="lw jt hi bd ju lx ly lz jy ma mb mc kc jf md me kg jj mf mg kk jn mh mi ko mj bi translated">在内容变化最小的情况下更改类别</h2><p id="27ee" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">接下来，让我们从抵制数据集中提取一些对立样本，并说服神经网络使用错误的标签，比如<code class="du lr ls lt lu b">adv_target=2</code>。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/d5a627b2e5d73bb37c08e060dffd868d.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*q-o_ka4p_3aOcLpShRkFSQ.png"/></div></figure><p id="2f91" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将其正式化为适应度函数，我们得到:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/ca27174f50298aab430deb698c00edb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/1*XzwrOLnjCAHlshnYHuw6xw.gif"/></div></figure><h1 id="c707" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="2276" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">正如您所看到的，给定适当的优化函数，您可以将模型“愚弄”成几乎任何您想要的输出。这种行为有几个原因:</p><h2 id="dad0" class="lw jt hi bd ju lx ly lz jy ma mb mc kc jf md me kg jj mf mg kk jn mh mi ko mj bi translated">分布式表示</h2><p id="cccb" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">使神经网络特别容易受到这种攻击的是分布式表示——从训练数据集中提取的知识在所有节点上以分层的方式共享。因此，输入的微小变化都会对输出产生类似雪崩的影响。</p><h2 id="c721" class="lw jt hi bd ju lx ly lz jy ma mb mc kc jf md me kg jj mf mg kk jn mh mi ko mj bi translated">糟糕的建筑</h2><p id="e0a4" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在我选择的设置中，没有办法包含关于输入看起来有多“真实”的信息。使模型更健壮的一种方法是增加对手样本检测的第二个任务。另一种方法是为无效输入添加虚拟类。如果体系结构的改变代价很高，假设输入分布是稳定的，可以增加使用训练数据进行异常检测的预处理步骤。</p><h2 id="0e48" class="lw jt hi bd ju lx ly lz jy ma mb mc kc jf md me kg jj mf mg kk jn mh mi ko mj bi translated">问题不可约性</h2><p id="1e72" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">不难认为，即使采取了预防措施，在黑盒攻击中也总是存在固有的易感性。与信息安全类似，新的利用和对策将以军备竞赛的方式发展。</p><h2 id="8f2b" class="lw jt hi bd ju lx ly lz jy ma mb mc kc jf md me kg jj mf mg kk jn mh mi ko mj bi translated">密码</h2><p id="5248" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">我已经为你建立了一个<a class="ae ml" href="https://github.com/ptyshevs/ga_adv" rel="noopener ugc nofollow" target="_blank">库</a>来重现和增强这个例子。</p><h2 id="b887" class="lw jt hi bd ju lx ly lz jy ma mb mc kc jf md me kg jj mf mg kk jn mh mi ko mj bi translated">文献学</h2><p id="84da" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">有几篇关于这个主题的论文，我觉得很有趣，也很有启发性:</p><ul class=""><li id="2561" class="lc ld hi iw b ix iy jb jc jf le jj lf jn lg jr lh li lj lk bi translated"><a class="ae ml" href="https://arxiv.org/abs/1901.09892" rel="noopener ugc nofollow" target="_blank">基于群体进化算法的神经网络黑盒攻击</a></li><li id="9509" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated"><a class="ae ml" href="https://arxiv.org/abs/1906.03181" rel="noopener ugc nofollow" target="_blank"> POBA遗传算法:通过遗传算法进行扰动优化的黑盒对抗攻击</a></li></ul></div></div>    
</body>
</html>