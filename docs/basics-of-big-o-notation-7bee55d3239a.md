# 大 O 符号的基础

> 原文：<https://medium.com/analytics-vidhya/basics-of-big-o-notation-7bee55d3239a?source=collection_archive---------44----------------------->

![](img/c16d888f0cad49bd5c36d860084070ce.png)

如果你想成为一家大公司的软件工程师，并且你正在寻找一份中高级的工作，那么在面试过程中，不可避免地会遇到一些算法作业和一个常见的问题:“什么是大 O 符号？”`.学习算法是成为一名更好软件开发人员的一项重要技能，它将帮助你在开始编码之前思考如何设计你的解决方案，且无疑将在你去你非常想要的公司进行技术面试时帮助你。我必须说，在我职业生涯的很长一段时间里，我都在回避这个话题，基本上是因为我认为这对我来说是一个令人恐惧、无用和困惑的话题。随着时间的推移，我意识到解决许多不同类型的问题是多么重要，以及我们如何在日常生活中直观、自动地使用算法。
在这篇文章中，我想分享我对大 O 符号的了解，以定义我们算法的复杂性，以及如何使用它，并提供一个小代码示例。

# 大 O 符号

## 什么是大 O？

> [**大 O 符号**是一种数学符号，描述当自变量趋向某一特定值或无穷大时，函数的极限行为。](https://en.wikipedia.org/wiki/Big_O_notation)

简而言之，我们使用大 O 来描述算法的性能，它帮助我们定义特定的算法是否可以随着输入数据集的增长而扩展。当您开发一个算法时，根据您决定使用的数据结构，一些操作可能比必要的更昂贵。
例如，通过索引访问数组元素将非常快，否则，数组具有固定的大小，如果您需要通过添加或删除元素来改变数组，它将调整大小，如果您有一个大的数据集，这些操作将花费大量时间。所以，在这种情况下你需要使用一个链表，这种数据结构可以以超快的方式调整大小，另一方面，通过索引访问链表的元素是非常慢的。
这就是大 O 符号的作用，它定义了算法的时间复杂度，帮助我们决定应该使用哪种数据结构。

## **O(1)**

在这个例子中，我们有一个方法，打印数组的第一个元素，数组的大小无关紧要，它可以是大小为 1 或 100 万的数组，时间复杂度将始终相同，要执行的操作数将始终为 1。因此，我们将其表示为 **O(1)** ，这是执行代码的运行时间复杂度，它始终与给定数组的大小无关。

如果我们复制操作，你可能会认为时间复杂度会变成 **O(2)** ，但是当我们考虑运行时复杂度时，操作的数量并不重要，重要的是随着输入数据的增加，算法如何变慢。在这种情况下，时间复杂度保持为 **O(1)** 。

## **O(n)**

在这个例子中，我们迭代给定数组中的所有元素并打印它，所以，数组的大小真的很重要，因为随着大小的增加，算法的成本也增加，它们有相关性，成本线性增加**。在这种情况下，我们将其表示为 **O(n)** ，其中 **n** 是我们的输入数据集的大小。**

**另一个例子是，如果我们迭代两个不同的数组，那么，在这种情况下，我们可以将运行时间复杂度表示为 **O(n + m)** ，但是当我们谈论时间复杂度时，我们只是在寻找与输入大小相关的算法成本的近似值。由于算法的运行时间复杂度仍然线性增加**，我们可以简单地将其表示为 **O(n)** 。****

## ******O(n )******

****当我们处理嵌套循环时，我们说算法运行在**二次**时间，这种算法比运行在 **O(n)** 的算法慢，随着输入数据集的增加，我们可以真正看到这两者之间的时间差。****

****在下面的示例中，我们在第一次运算后有另一个循环，这可以表示为 **O(n + n)** ，但是我们可以简化它，因为我们需要的只是算法成本的近似值，在这种情况下， **n** 将总是比 **n** 增长得更快，因此，我们可以删除 **n** ，并说该算法在 **O(n )** 中运行。****

## ****o(登录号)****

****在 **O(log n)** 中运行的算法的一个完美例子是二分搜索法算法。这里举一个代码例子太复杂了，但是这种算法在对数时间内运行，比在线性时间内运行的算法更高效，可扩展性更好。****

> ****[在数学中，对数是指数运算的反函数](https://en.wikipedia.org/wiki/Logarithm)****

****因此，当一个算法以对数增长时，这意味着您要根据输入数据集的大小来划分达到预期结果所需的运算次数。****

****实际上，假设我们有一个排序后的数组，我们需要找到数字 7 的位置。使用二分搜索法算法，我们将开始寻找数组的中间，这是数字 4，如果这是你在寻找的数字，该算法将只需要 1 次运算就可以完成。不幸的是，这不是我们需要的数字，所以，当数字 7 大于 4 时，我们知道它一定在这个数组的右边部分，我们可以把左边部分放在一边，现在我们可以把我们的搜索限制在一半，继续重复同样的过程，直到我们找到它。在每次操作中，我们将数组的大小减半，如果我们有数百万个数字，我们可以通过很少的操作找到我们要找的数字，通过这种方法，我们的算法非常具有可伸缩性。****

## ****O(2^n)****

****这被称为指数增长，与对数增长相反。随着输入数据集的增加，指数时间复杂度越来越快。以这种时间复杂度运行的算法是不可扩展的，并且如果我们有一个大的输入数据集，它会变得非常慢。****

******时间复杂度排名:******

****这里我们有一个复杂时间的排名，从最快到最慢排序。你还可以使用其他增长率，但这是最常见的。****

1.  ****常数 **O(1)**
    2。对数 **O(log n)**
    3。线性 **O(n)**
    4。二次的 **O(n )**
    5。指数 **O(2^n)******

## ****感谢阅读！****

****这篇文章的目的是以一种简单的方式分享我对大 O 符号的理解以及它的重要性，所以如果我犯了一个错误，不要犹豫留下评论。****

*******如果你喜欢这样，留个掌声！！！*******