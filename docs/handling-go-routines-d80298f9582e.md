# 处理围棋套路

> 原文：<https://medium.com/analytics-vidhya/handling-go-routines-d80298f9582e?source=collection_archive---------6----------------------->

![](img/d2119751b8d48a6d51c4ecd4cf0a00ef.png)

创建 go 例程很简单，因为 go 例程是轻量级的，所以我们可以创建数千个 go 例程来执行任务。但是每个例程都有代价，消耗内存或 CPU 使用等资源的代价。

尽管围棋程序很容易使用，但管理它们也很重要。我们需要确保 go 例程应该在分配的任务完成后释放计算资源。大多数情况下，我们使用 go 例程并发执行多个任务，但如果我们让 go 例程挂起，从长远来看，这将导致计算资源的高消耗。

消耗资源并且在完成后不释放它们的问题将导致可用于其他进程运行的资源减少。这将导致系统持续冻结，CPU 负载急剧增加。使用 go 例程后运行速度快 10 倍的代码，将开始运行速度慢 100 倍于之前的代码。有时候解决这个问题的唯一方法就是关机。

一种方法是使用运行时包将有限的 CPU 分配给 golang 代码，并分配有限的资源，但这并不能解决问题。我们应该对这个问题实施持久解决方案。给围棋程序分配工作量，并在分配的任务完成后关闭它们将是处理它的最佳方式。

让我们来看一些 go 常规泄露的例子。

上面提到的代码将按预期工作，没有错误，但 go 例程将继续运行，因为循环永不结束，这将导致泄漏，因为没有信号或方法在出现错误时停止它。

让我们看另一个 go 例程泄漏的例子，当运行多个 go 例程时，这些例程一起写入同一个通道。

因为我们对 select 使用默认情况，所以在例程中不会发生死锁。尽管多次运行程序，但传递给通道的值可能永远不会收到，例如 REST api 请求的情况。

有一个第三方包，通过运行测试来找出程序内部是否有漏洞。该软件包是开源的，可用作日常检漏仪[https://github.com/uber-go/goleak](https://github.com/uber-go/goleak)。我使用了相同的包来找出程序中运行的 go 例程是否包含漏洞。

在为第二个例子中提到的程序创建上述测试文件之后。我们可以使用`go test`运行测试文件。它将返回未能完成执行的 go 例程的编号。然后，我们需要验证 go 例程泄漏点并解决它。

为了解决上述漏洞，我们必须确保在一个通道上发送的所有值都应该被接收到。另一种选择是不在信道上发送无法接收的值。

在上述情况下，我已经发送了一个信号，在一段时间后停止循环，以确保不会有泄漏。有其他方法可以解决这个问题，即。接收通道上发送的所有值或不离开 go 例程挂起。

结论:- 使用 go 例程很容易，但是管理它们对于确保我们的软件长期高效运行很重要。如果处理不当，会导致进程阻塞，消耗大量 cpu 和内存资源来运行小块代码。关注更新…