<html>
<head>
<title>PYTHON FUNCTIONS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PYTHON 函数</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-functions-6920c88c9f6f?source=collection_archive---------14-----------------------#2020-10-08">https://medium.com/analytics-vidhya/python-functions-6920c88c9f6f?source=collection_archive---------14-----------------------#2020-10-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="6ab3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">功能介绍</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/aa03edca53702744cbf64f217d4fc68c.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*u8qBInCGZrFumnd-dti9Ug.jpeg"/></div></figure><p id="1916" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">函数是一组相关的语句，在任何语言如 C、C++、Python 和 Java 中执行特定的任务。函数将我们的程序分成更小的模块。随着我们的程序变得越来越大，函数使它变得更有组织性，更易管理，并且可以一次又一次地使用。</p><h1 id="fdf3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Python 中函数的语法</h1><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="98b2" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">function_name</strong>(arguments):<br/>    """docstring"""<br/>    statement(s)</span></pre><p id="7988" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">函数定义由以下组件组成:</p><ul class=""><li id="86f1" class="kt ku hi jn b jo jp js jt jw kv ka kw ke kx ki ky kz la lb bi translated">关键字<code class="du lc ld le kk b">def</code>在 python 中标记函数头的开始。</li><li id="b51d" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">唯一标识函数的函数名。</li><li id="76de" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">我们通过参数向函数传递值。它们是可选的。</li><li id="d750" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">冒号(:)标记函数头的结尾。</li><li id="448e" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">Docstring 描述了函数的可选功能，但它总是给出函数的清晰性。</li><li id="80f6" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">组成函数体的一个或多个有效 python 语句。语句必须具有相同的缩进级别(通常为 4 个空格)或制表符。</li><li id="50fa" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">可选的<code class="du lc ld le kk b">return</code>语句，用于从函数中返回值。</li><li id="d129" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">可以使用 function_name 打印 docstring。__doc__ 方法。</li><li id="b08c" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated"><code class="du lc ld le kk b">return</code>语句用于退出一个函数，并从调用它的地方返回。该语句可以包含一个表达式，该表达式被求值并返回值。如果语句中没有表达式或者<code class="du lc ld le kk b">return</code>语句本身不在函数中，那么函数将返回<code class="du lc ld le kk b">None</code>对象。</li></ul><h1 id="38aa" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">函数的示例</h1><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="bd4a" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">add</strong>(a,b):<br/>    """ This function return sum <br/>    of two numbers"""<br/>    sum=a+b<br/>    <strong class="kk hj">return</strong> sum</span></pre><h1 id="1da2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">如何在 python 中调用函数？</h1><p id="3a30" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">一旦我们定义了一个函数，我们就可以从另一个函数、程序甚至 Python 提示符中调用它。要调用一个函数，我们只需输入带有适当参数的函数名。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="0c85" class="ko ig hi kk b fi kp kq l kr ks">&gt;&gt;&gt;<strong class="kk hj">add</strong>(1,2)</span><span id="5270" class="ko ig hi kk b fi lp kq l kr ks"><strong class="kk hj">3</strong></span></pre><h1 id="6f98" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">文档字符串</h1><p id="2e00" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">函数头后面的第一个字符串称为 docstring，是 documentation string 的缩写。它简单地用来解释一个函数做什么，可以用 function_name 打印出来。__doc__ 方法。</p><p id="161f" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">例如:</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="5e0d" class="ko ig hi kk b fi kp kq l kr ks">&gt;&gt;&gt;print(add.__doc__)</span><span id="b52c" class="ko ig hi kk b fi lp kq l kr ks">This fuction return sum <br/>    of two numbers</span></pre><h1 id="ae09" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">退货单</h1><p id="7ac3" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated"><code class="du lc ld le kk b">return</code>语句用于退出一个函数，并返回到调用它的地方。</p><h1 id="1c1d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">返回语法</h1><p id="4378" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">返回[expression_list]</p><p id="2a91" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">该语句可以包含一个表达式，该表达式被求值并返回值。如果语句中没有表达式或者<code class="du lc ld le kk b">return</code>语句本身不在函数中，那么函数将返回<code class="du lc ld le kk b">None</code>对象。</p><h1 id="33d5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">变量的范围和生存期</h1><p id="3400" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">变量的作用域是程序中可以识别变量的部分。函数内部定义的参数和变量在函数外部是不可见的。因此，它们具有局部范围。</p><p id="a71b" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">变量的生存期是指变量在内存中存在的时间。函数内部变量的生存期与函数执行的时间一样长。</p><p id="0b88" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一旦我们从函数中返回，它们就被销毁了。因此，函数不会记住以前调用的变量值。</p><p id="5e75" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里有一个例子来说明函数中变量的作用域。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="4ece" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">func</strong>():<br/>    x = 20<br/>    print("Value inside function:",x)</span><span id="774d" class="ko ig hi kk b fi lp kq l kr ks">x = 100<br/><strong class="kk hj">func</strong>()<br/>print("Value outside function:",x)</span></pre><p id="2b5b" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">功能输出:</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="b125" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">Value</strong> inside <strong class="kk hj">function</strong>: 20</span><span id="8f6a" class="ko ig hi kk b fi lp kq l kr ks">Value outside <strong class="kk hj">function</strong>: 100</span></pre><p id="0ac7" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这里，我们可以看到 x 的值最初是 100。即使函数<code class="du lc ld le kk b">func()</code>将 x 的值更改为 20，也不会影响函数外部的值。</p><p id="243c" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是因为函数内部的变量 x 与外部的不同(对于函数是局部的)。虽然名称相同，但却是两个不同的变量，作用域不同。</p><p id="40cb" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">另一方面，函数外部的变量从内部是可见的。他们有全球性的视野。</p><p id="99b8" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们可以从函数内部读取这些值，但不能更改(写入)它们。为了修改函数外部的变量值，必须使用关键字<code class="du lc ld le kk b">global</code>将它们声明为全局变量。</p><h1 id="67a8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">功能类型</h1><p id="8ba8" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">基本上，我们可以将函数分为以下两种类型:</p><ul class=""><li id="468b" class="kt ku hi jn b jo jp js jt jw kv ka kw ke kx ki ky kz la lb bi translated">内置函数-内置于 Python 中的函数。</li><li id="a222" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">用户定义的功能-由用户自己定义的功能。</li></ul><h1 id="3468" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">争论</h1><p id="4a87" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">在用户定义函数中，我们首先定义一个函数并调用它。否则，函数调用将导致错误。这里有一个例子。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="f8ea" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">add</strong>(a,b):<br/>    """ This fuction return sum <br/>    of two numbers"""<br/>    sum=a+b<br/>    <strong class="kk hj">return</strong> sum</span><span id="5f74" class="ko ig hi kk b fi lp kq l kr ks">print("sum of numbers is:",add(1,2))</span></pre><p id="2324" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出:</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="e749" class="ko ig hi kk b fi kp kq l kr ks">sum of numbers is: 3</span></pre><p id="f1da" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里，函数 add <code class="du lc ld le kk b">()</code>有两个参数。因为我们用两个参数调用了这个函数，所以它运行得很平稳，没有任何错误。如果我们用不同数量的参数调用它，解释器将显示一条错误消息。下面是对这个函数的调用，有一个和没有参数，以及相应的错误消息。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="48d2" class="ko ig hi kk b fi kp kq l kr ks">&gt;&gt;&gt;add(1) #with one argument</span><span id="c67d" class="ko ig hi kk b fi lp kq l kr ks">TypeErorr: add() missing 1 required positional argument: 'b'</span><span id="5694" class="ko ig hi kk b fi lp kq l kr ks">&gt;&gt;&gt;add() #with no argument</span><span id="2cdf" class="ko ig hi kk b fi lp kq l kr ks"><strong class="kk hj">TypeError</strong>: add() missing 2 required positional arguments: 'a' and 'b'</span></pre><h1 id="854d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">可变函数参数</h1><p id="9804" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">在 Python 中，还有其他方法来定义可以接受可变数量参数的函数，如下所示:</p><h1 id="f57d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Python 默认参数</h1><p id="9aa1" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">Python 中的函数参数可以有默认值。</p><p id="5cf1" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们可以使用赋值运算符(=)为参数提供默认值。这里有一个例子。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="8850" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">greet</strong>(name, msg="Good morning!"):<br/>    """<br/>    This function greets to<br/>    the person with the<br/>    provided message.</span><span id="8c85" class="ko ig hi kk b fi lp kq l kr ks">    If the message is not provided,<br/>    it defaults to "Good<br/>    morning!"<br/>    """</span><span id="83d3" class="ko ig hi kk b fi lp kq l kr ks">    <strong class="kk hj">print</strong>("Hello", name + ', ' + msg)<br/></span><span id="a5a1" class="ko ig hi kk b fi lp kq l kr ks">greet("sumit")<br/>greet("sam", "How do you do?")</span></pre><p id="f8b7" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="f34e" class="ko ig hi kk b fi kp kq l kr ks">Hello sumit, Good morning!<br/>Hello sam, How <strong class="kk hj">do</strong> you <strong class="kk hj">do</strong>?</span></pre><p id="1a10" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在该函数中，参数<code class="du lc ld le kk b">name</code>没有默认值，在调用期间是必需的(强制的)。参数<code class="du lc ld le kk b">msg</code>的默认值为<code class="du lc ld le kk b">"Good morning!"</code>。因此，它在通话过程中是可选的。如果提供了一个值，它将覆盖默认值。函数中任意数量的参数都可以有默认值。但是一旦我们有了一个默认参数，它右边的所有参数也必须有默认值。也就是说，非默认参数不能跟在默认参数后面。例如，如果我们将上面的函数头定义为:</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="4590" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">greet</strong>(msg = "Good morning!", name):</span><span id="3d7b" class="ko ig hi kk b fi lp kq l kr ks">SyntaxError: non-default argument follows default argument</span></pre><h1 id="c6c5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Python 关键字参数</h1><p id="a5c3" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">当我们用一些值调用一个函数时，这些值根据它们的位置被分配给参数。</p><p id="8aa3" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">例如，在上面的函数<code class="du lc ld le kk b">greet()</code>中，当我们将其称为<code class="du lc ld le kk b">greet("sam", "How do you do?")</code>时，值<code class="du lc ld le kk b">"sam"</code>被赋给参数名，类似地<code class="du lc ld le kk b">"How do you do?"</code>被赋给 msg。Python 允许使用关键字参数调用函数。当我们以这种方式调用函数时，参数的顺序(位置)可以改变。对上述函数的以下调用都是有效的，并且产生相同的结果。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="c453" class="ko ig hi kk b fi kp kq l kr ks"># 2 keyword arguments<br/>greet(name = "sam",msg = "How <strong class="kk hj">do</strong> you <strong class="kk hj">do</strong>?")</span><span id="c7dd" class="ko ig hi kk b fi lp kq l kr ks"># 2 keyword arguments (out of order)<br/>greet(msg = "How <strong class="kk hj">do</strong> you <strong class="kk hj">do</strong>?",name = "sam") </span><span id="9395" class="ko ig hi kk b fi lp kq l kr ks">1 positional, 1 keyword argument<br/>greet("sam", msg = "How <strong class="kk hj">do</strong> you <strong class="kk hj">do</strong>?")</span></pre><p id="9c58" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">正如我们所看到的，我们可以在函数调用中混合位置参数和关键字参数。但是我们必须记住，关键字参数必须跟在位置参数之后。关键字参数后有位置参数会导致错误。例如，函数调用如下:</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="12a6" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">greet</strong>(name="Bruce","How do you do?")</span><span id="613f" class="ko ig hi kk b fi lp kq l kr ks"><strong class="kk hj">SyntaxError</strong>: <strong class="kk hj">non-keyword</strong> <strong class="kk hj">arg</strong> <strong class="kk hj">after</strong> <strong class="kk hj">keyword</strong> <strong class="kk hj">arg</strong></span></pre><h1 id="ad3a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Python 任意参数</h1><p id="37bf" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">有时，我们事先不知道传递给函数的参数的数量。Python 允许我们通过带有任意数量参数的函数调用来处理这种情况。在函数定义中，我们在参数名前使用星号(*)来表示这种类型的参数。这里有一个例子。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="807f" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">greet</strong>(*names):<br/>    """This function greets all<br/>    the person in the names tuple."""</span><span id="6e0e" class="ko ig hi kk b fi lp kq l kr ks">    # names is a tuple with arguments<br/>    <strong class="kk hj">for</strong> name <strong class="kk hj">in</strong> names:<br/>        <strong class="kk hj">print</strong>("Hello", name)<br/></span><span id="c4dc" class="ko ig hi kk b fi lp kq l kr ks">greet("sumit", "sam", "aman", "John")</span><span id="f0e6" class="ko ig hi kk b fi lp kq l kr ks">Hello sumit<br/>Hello sam<br/>Hello aman<br/>Hello John</span></pre><h1 id="e9dc" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">关键字参数</h1><p id="b730" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">Kwargs 允许你将关键字可变长度的参数传递给一个函数。如果你想处理一个函数中的命名参数，你应该使用**kwargs。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="93fe" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">greet</strong>(**kwargs):</span><span id="757b" class="ko ig hi kk b fi lp kq l kr ks">""" This function greets to the person with the provided message."""</span><span id="9a3c" class="ko ig hi kk b fi lp kq l kr ks"><strong class="kk hj">if</strong> kwargs:</span><span id="80ac" class="ko ig hi kk b fi lp kq l kr ks">print("Hello {0},{1}".format(kwargs['name'],kwargs['msg']))</span><span id="c986" class="ko ig hi kk b fi lp kq l kr ks">greet(name="sam",msg="How are you doing?")</span></pre><h1 id="71bf" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Python 递归</h1><p id="0c40" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">一个函数可以调用其他函数，函数甚至可以调用自己。这种结构称为递归函数。递归函数的示例如下:</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="c46c" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">factorial</strong>(x):<br/>    """This is a recursive function<br/>    to find the factorial of an integer"""</span><span id="ef42" class="ko ig hi kk b fi lp kq l kr ks">    <strong class="kk hj">if</strong> x == 1:<br/>        <strong class="kk hj">return</strong> 1<br/>    <strong class="kk hj">else</strong>:<br/>        <strong class="kk hj">return</strong> (x * factorial(x-1))<br/></span><span id="5b2b" class="ko ig hi kk b fi lp kq l kr ks">num =5<br/><strong class="kk hj">print</strong>("The factorial of", num, "is", factorial(num))</span></pre><p id="f2d7" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="2aec" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">The</strong> factorial of 5 is 120</span></pre><p id="856c" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在上面的例子中，<code class="du lc ld le kk b">factorial()</code>是一个递归函数，正如它自称的那样。每个函数都将该数字乘以它下面的数字的阶乘，直到它等于 1。这个递归调用可以在下面的步骤中解释。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="2c33" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">factorial</strong>(5)             # 1st call with 5<br/><strong class="kk hj">5</strong> * factorial(4)         # 2nd call with 4<br/><strong class="kk hj">5</strong> * 4 * factorial(3)     # 3rd call with 3<br/><strong class="kk hj">5</strong> * 4 * 3 * factorial(2) # 4th call with 2</span><span id="89db" class="ko ig hi kk b fi lp kq l kr ks">5 * 4 * 3 * 2 * factorial(1) #5th call with 1</span><span id="df1d" class="ko ig hi kk b fi lp kq l kr ks">5 * 4 * 3 * 2 * 1  # return from 5th call as number</span><span id="e9a7" class="ko ig hi kk b fi lp kq l kr ks">120    # return from 1st call</span></pre><h1 id="a384" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">递归的优点</h1><ul class=""><li id="2f4e" class="kt ku hi jn b jo lk js ll jw lq ka lr ke ls ki ky kz la lb bi translated">递归函数使代码看起来干净优雅。</li><li id="68e2" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">使用递归可以将复杂的任务分解成更简单的子问题。</li><li id="6e77" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">使用递归比使用嵌套迭代更容易生成序列。</li></ul><h1 id="0d2a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">递归的缺点</h1><ul class=""><li id="c50f" class="kt ku hi jn b jo lk js ll jw lq ka lr ke ls ki ky kz la lb bi translated">有时候递归背后的逻辑很难理解。</li><li id="ee7f" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">递归调用是昂贵的(低效的),因为它们占用了大量的内存和时间。</li><li id="cb2e" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">递归函数很难调试。</li></ul><h1 id="d475" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">λ函数</h1><p id="6ab8" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">在 Python 中，匿名函数是没有名字的函数。在 Python 中，普通函数是使用<code class="du lc ld le kk b">def</code>关键字定义的，而匿名函数是使用<code class="du lc ld le kk b">lambda</code>关键字定义的。因此，匿名函数也被称为 lambda 函数。</p><h1 id="a9e3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">python 中 Lambda 函数的语法</h1><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="44ac" class="ko ig hi kk b fi kp kq l kr ks">lambda arguments: expression</span></pre><p id="e3eb" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Lambda 函数可以有任意数量的参数，但只能有一个表达式。计算并返回表达式。Lambda 函数可以用在任何需要函数对象的地方。</p><h1 id="0030" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">python 中 Lambda 函数的示例</h1><p id="1973" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">假设我们想找出一个数的平方，那么我们可以用 lambda 函数按照下面的方法来做。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="d7b8" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">squr = lambda</strong> x : x**2</span><span id="0b03" class="ko ig hi kk b fi lp kq l kr ks">squr(5)</span></pre><p id="924e" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="bff4" class="ko ig hi kk b fi kp kq l kr ks">25</span></pre><p id="eac5" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在上面的程序中，<code class="du lc ld le kk b">lambda x: x ** 2</code>是 lambda 函数。这里 x 是参数，<code class="du lc ld le kk b">x ** 2</code>是被求值并返回的表达式。</p><h1 id="b212" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">python 中 Lambda 函数的使用</h1><p id="0d47" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">当我们在短时间内需要一个无名函数时，我们使用 lambda 函数。在 Python 中，我们一般把它作为一个高阶函数的参数(一个接受其他函数作为参数的函数)。Lambda 函数与内置函数一起使用，如<code class="du lc ld le kk b">filter()</code>、<code class="du lc ld le kk b">map()</code>等。</p><p id="da10" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">使用过滤器()的示例:</p><p id="8f7b" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Python 中的<code class="du lc ld le kk b">filter()</code>函数接受一个函数和一个列表作为参数。使用列表中的所有项目调用该函数，并返回一个新列表，其中包含该函数评估为<code class="du lc ld le kk b">True</code>的项目。下面是一个使用<code class="du lc ld le kk b">filter()</code>函数从列表中过滤出偶数的例子。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="bbb6" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">lst</strong>=[1,2,3,4,5,6]</span><span id="18f4" class="ko ig hi kk b fi lp kq l kr ks">even_list=list(filter(lambda x:(x%2==0),lst))</span><span id="aace" class="ko ig hi kk b fi lp kq l kr ks">print(even_list)</span></pre><p id="9aff" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="ea8a" class="ko ig hi kk b fi kp kq l kr ks">[2,4,6]</span></pre><p id="7306" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">map()的示例:</p><p id="23b3" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Python 中的<code class="du lc ld le kk b">map()</code>函数接受一个函数和一个列表。使用列表中的所有项目调用该函数，并返回一个新列表，该列表包含该函数为每个项目返回的项目。下面是一个使用<code class="du lc ld le kk b">map()</code>函数将列表中的所有项目加倍的例子。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="01a6" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">lst</strong>=[1,2,3,4,5,6]</span><span id="8260" class="ko ig hi kk b fi lp kq l kr ks">new_list=list(map(lambda x:x**2 ,lst))</span><span id="9958" class="ko ig hi kk b fi lp kq l kr ks">print(new_list)</span></pre><p id="64ad" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="f692" class="ko ig hi kk b fi kp kq l kr ks">[1,4,9,16,25,36]</span></pre><p id="b77c" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">reduce()示例:</p><p id="d4ae" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">reduce(fun，seq)函数用于将参数中传递的特定函数应用于传递序列中提到的所有列表元素。该功能在“functools”模块中定义。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="5b28" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">from</strong> functools <strong class="kk hj">import</strong> reduce</span><span id="bba6" class="ko ig hi kk b fi lp kq l kr ks">lst=[1,2,3,4,5]</span><span id="26c0" class="ko ig hi kk b fi lp kq l kr ks">mult=reduce(<strong class="kk hj">lambda</strong> x,y : x*y ,lst)</span><span id="710d" class="ko ig hi kk b fi lp kq l kr ks">print(mult)</span></pre><p id="4f91" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="eece" class="ko ig hi kk b fi kp kq l kr ks">120</span></pre><h1 id="f204" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Python 全局、局部和非局部变量</h1><h1 id="2db3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">全局变量</h1><p id="b562" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">在 Python 中，在函数外部或全局范围内声明的变量称为全局变量。这意味着可以在函数内部或外部访问全局变量。让我们看一个如何在 Python 中创建全局变量的例子。</p><h1 id="055a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">示例 1:创建一个全局变量</h1><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="7830" class="ko ig hi kk b fi kp kq l kr ks">x = "global"</span><span id="5621" class="ko ig hi kk b fi lp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">var</strong>():<br/>    <strong class="kk hj">print</strong>("x inside:", x)</span><span id="ef83" class="ko ig hi kk b fi lp kq l kr ks"><strong class="kk hj">var()</strong></span><span id="847f" class="ko ig hi kk b fi lp kq l kr ks"><strong class="kk hj">print</strong>("x outside:", x)</span></pre><p id="8f23" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="9b1c" class="ko ig hi kk b fi kp kq l kr ks">x inside: global</span><span id="af97" class="ko ig hi kk b fi lp kq l kr ks">x outside: global</span></pre><p id="e58f" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果你想改变函数中 x 的值呢？</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="ce48" class="ko ig hi kk b fi kp kq l kr ks">x = "global"</span><span id="3271" class="ko ig hi kk b fi lp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">double</strong>():<br/>    x = x * 2<br/>    <strong class="kk hj">print</strong>(x)</span><span id="c5f8" class="ko ig hi kk b fi lp kq l kr ks"><strong class="kk hj">double</strong>()</span></pre><p id="ace1" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="4023" class="ko ig hi kk b fi kp kq l kr ks">UnboundLocalError: local variable 'x' referenced before assignment</span></pre><p id="b56e" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出显示一个错误，因为 Python 将 x 视为局部变量，并且 x 也没有在 double <code class="du lc ld le kk b">()</code>中定义。</p><h1 id="aca4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">局部变量</h1><p id="27f7" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">在函数体内或局部范围内声明的变量称为局部变量。</p><h1 id="7d65" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">示例 2:访问范围外的局部变量</h1><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="19cc" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">foo</strong>():<br/>    y = "local"<br/></span><span id="fbe5" class="ko ig hi kk b fi lp kq l kr ks">foo()<br/><strong class="kk hj">print</strong>(y)</span></pre><p id="610c" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="62c4" class="ko ig hi kk b fi kp kq l kr ks">NameError: name 'y' <strong class="kk hj">is</strong> <strong class="kk hj">not</strong> defined</span></pre><p id="bf84" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出显示一个错误，因为我们试图在全局范围内访问局部变量 y，而局部变量只在<code class="du lc ld le kk b">foo()</code>或局部范围内工作。</p><h1 id="0901" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">示例 3:创建一个局部变量</h1><p id="7e7a" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">通常，我们在函数内部声明一个变量来创建一个局部变量。</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="b066" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">foo</strong>():<br/>    y = "local"<br/>    <strong class="kk hj">print</strong>(y)</span><span id="c544" class="ko ig hi kk b fi lp kq l kr ks">foo()</span></pre><p id="dd76" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="f92d" class="ko ig hi kk b fi kp kq l kr ks">local</span></pre><h1 id="9ef6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">示例 4:在同一代码中使用全局和局部变量</h1><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="26b0" class="ko ig hi kk b fi kp kq l kr ks">x = "global "</span><span id="1ec8" class="ko ig hi kk b fi lp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">foo</strong>():<br/>    <strong class="kk hj">global</strong> x<br/>    y = "local"<br/>    x = x * 2<br/>    <strong class="kk hj">print</strong>(x)<br/>    <strong class="kk hj">print</strong>(y)</span><span id="162e" class="ko ig hi kk b fi lp kq l kr ks">foo()</span></pre><p id="8d47" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="b190" class="ko ig hi kk b fi kp kq l kr ks">global global</span><span id="23d0" class="ko ig hi kk b fi lp kq l kr ks">local</span></pre><h1 id="218f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">示例 5:同名的全局变量和局部变量</h1><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="a29d" class="ko ig hi kk b fi kp kq l kr ks">x = 5</span><span id="729f" class="ko ig hi kk b fi lp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">foo</strong>():<br/>    x = 10<br/>    <strong class="kk hj">print</strong>("local x:", x)<br/></span><span id="82ce" class="ko ig hi kk b fi lp kq l kr ks">foo()<br/><strong class="kk hj">print</strong>("global x:", x)</span></pre><p id="edcf" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="4743" class="ko ig hi kk b fi kp kq l kr ks">local x: 10<br/>global x: 5</span></pre><h1 id="92f7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">非局部变量</h1><p id="806e" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">非局部变量用于未定义局部范围的嵌套函数中。这意味着变量既不能在局部范围内，也不能在全局范围内。</p><p id="b130" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们看一个如何在 Python 中创建全局变量的例子。</p><p id="d5c0" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们使用<code class="du lc ld le kk b">nonlocal</code>关键字来创建非局部变量。</p><h1 id="6042" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">示例 6:创建一个非局部变量</h1><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="af70" class="ko ig hi kk b fi kp kq l kr ks"><strong class="kk hj">def</strong> <strong class="kk hj">outer</strong>():<br/>    x = "local"</span><span id="da01" class="ko ig hi kk b fi lp kq l kr ks">    <strong class="kk hj">def</strong> <strong class="kk hj">inner</strong>():<br/>        <strong class="kk hj">nonlocal</strong> x<br/>        x = "nonlocal"<br/>        <strong class="kk hj">print</strong>("inner:", x)</span><span id="e971" class="ko ig hi kk b fi lp kq l kr ks">    inner()<br/>    <strong class="kk hj">print</strong>("outer:", x)<br/></span><span id="9073" class="ko ig hi kk b fi lp kq l kr ks">outer()</span></pre><p id="b6c6" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">输出</p><pre class="je jf jg jh fd kj kk kl km aw kn bi"><span id="db06" class="ko ig hi kk b fi kp kq l kr ks">inner: <strong class="kk hj">nonlocal</strong><br/>outer: <strong class="kk hj">nonlocal</strong></span></pre><p id="aff3" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在上面的代码中，有一个嵌套的<code class="du lc ld le kk b">inner()</code>函数。我们使用<code class="du lc ld le kk b">nonlocal</code>关键字来创建一个非局部变量。<code class="du lc ld le kk b">inner()</code>功能被定义在另一个功能<code class="du lc ld le kk b">outer()</code>的范围内。</p><p id="4b5f" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意:如果我们改变了一个非局部变量的值，这些改变就会出现在局部变量中。</p><h1 id="1cda" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">全局关键字</h1><p id="e806" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">在 Python 中，<code class="du lc ld le kk b">global</code>关键字允许你修改当前作用域之外的变量。它用于创建一个全局变量，并在局部上下文中对该变量进行更改。</p><h1 id="ea8e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">全局关键字规则</h1><p id="ff11" class="pw-post-body-paragraph jl jm hi jn b jo lk jq jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki hb bi translated">Python 中<code class="du lc ld le kk b">global</code>关键字的基本规则是:</p><ul class=""><li id="65da" class="kt ku hi jn b jo jp js jt jw kv ka kw ke kx ki ky kz la lb bi translated">当我们在函数内部创建变量时，默认情况下它是局部的。</li><li id="9595" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">当我们在函数之外定义变量时，默认情况下它是全局的。不一定要用<code class="du lc ld le kk b">global</code>关键字。</li><li id="c17f" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">我们使用<code class="du lc ld le kk b">global</code>关键字在函数中读写一个全局变量。</li><li id="03ef" class="kt ku hi jn b jo lf js lg jw lh ka li ke lj ki ky kz la lb bi translated">在函数外使用<code class="du lc ld le kk b">global</code>关键字没有任何效果。</li></ul><p id="0d3e" class="pw-post-body-paragraph jl jm hi jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi">***************************************************</p><blockquote class="lt lu lv"><p id="0ac4" class="jl jm lw jn b jo jp jq jr js jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ki hb bi translated">感谢您阅读文章！</p></blockquote></div></div>    
</body>
</html>