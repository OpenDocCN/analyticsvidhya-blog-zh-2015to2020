<html>
<head>
<title>Self-Organizing Map(Customer Segmentation in Banking)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自组织图(银行业的客户细分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/self-organizing-map-customer-segmentation-in-banking-9d7ce96bd3ec?source=collection_archive---------5-----------------------#2020-05-20">https://medium.com/analytics-vidhya/self-organizing-map-customer-segmentation-in-banking-9d7ce96bd3ec?source=collection_archive---------5-----------------------#2020-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/60a0c5c28141e8ba56ff802b9747f81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hG3uYaUt6Zlu39uVO61Aug.png"/></div></div></figure><p id="1f7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为Flipr实习项目的一部分，我得到了使用神经网络进行银行客户细分的任务。我使用自组织映射(SOM)解决了这个任务，SOM是一种基于无监督学习的人工神经网络(ANN ),这意味着在学习过程中不需要人工干预，并且几乎不需要知道输入数据的特征。SOM是最受欢迎的网络，属于竞争学习网络的范畴。</p><p id="8a8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">得知这个题目后，我想到了借助这篇文章来分享我的知识。</p><h2 id="5114" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">银行业为什么需要客户细分？</h2><p id="8f38" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">客户细分有助于银行在更精细的层面上了解他们的客户。分割揭示了显而易见的洞察力，这种洞察力可能会以某种方式被庞大的信息量所掩盖。因此，这些知识阐明了广告和客户服务程序的通知技术。细分同样有助于更好地理解客户生命周期和预测客户行为的账户管理。</p><h2 id="8866" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">自组织映射</h2><p id="add6" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在自组织地图中，信息与每个枢纽相关联，枢纽在空间上构造多维横截面(通常是二维点阵)。节点是竞争性的输入，每个节点都被轮流照顾，对信息有最基本响应的节点被宣布为“获胜节点”,并有机会将其权重分配给输入，并将其作为收益返回。这就是所谓的地形图。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/994c1c52841088d3e7f8b18fc07f6784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nl2uYQR228TrOojoHCY0Kg.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">SOM如何工作的可视化。</figcaption></figure><p id="3c9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SOM采用具有大量行和列的多维数据集，这些行和列是数据集的维度，并且减少了数据集的维度。SOM的目的是将许多列缩减为二维输出。</p><h2 id="002e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">自组织地图如何学习？</h2><p id="3602" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">这里我们有3个列的特征。这些可能有数千行，每行有3列，即我们的输入数据集实际上是三维的，而SOM中的输出总是二维的。</p><p id="20fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先要看的是顶部节点。顶部节点与3个输入要素相连。顶部节点与每个特征相连接，每个特征被分配了一些权重，即W(i，j) i是节点的位置，j是特征。这里我们得到了W(1，1)，W(1，2)，W(1，3)。重要的是，SOM中的权重不同于人工神经网络，没有激活函数。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/fce406ba5901af66cbf5c29cf1a32753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohr3BOXZ7kZB8Cy-gl8GYQ.png"/></div></div></figure><p id="bdf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，权重是节点本身的特征。基本上就是节点的坐标。该节点还尝试查看它在输入空间中的位置。类似地，我们分配每个输出节点的权重，并且每个输出节点是试图适合输入空间的虚拟数据点。</p><p id="c045" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是自组织映射算法的核心，现在这些节点之间将存在竞争，我们将检查数据集中的每一行，并找出这些节点中哪个最接近数据集中的每一行。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/62abff01ce39b3cdb662d08d204d8a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCFBoXs0bbneP2-ooqDWsg.png"/></div></div></figure><p id="cfd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用从输入节点到输出节点的欧几里德距离进行计算。类似地，我们计算每个输出的欧几里德距离，并且具有最近距离的节点被认为是最佳匹配单元(BMU)。</p><p id="03a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑一个更大的SOM，我们得到第一行的BMU。现在，SOM将更新BMU的权重。它变得更接近数据集中的第1行。我们更新的原因是因为我们无法控制我们的输入，也无法更新我们的数据集，我们在公式中唯一可以控制的是节点的权重，以便使其更接近行。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/3f6275376b9f0f3c8e2a00c553198998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ieLwGTVMYBbW-IxeTnwQdQ.png"/></div></div></figure><p id="e8d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从视觉上来说，这意味着SOM越来越接近数据点，而这些数据点本身会组织成您的输入数据。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/c4a4af5cb259ba59c3ca05607809373a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkSl8vBUGD3k__Bk9ycnrw.png"/></div></div></figure><p id="94e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是BMU周围的整个半径，SOM的每个节点都落在半径内，该半径将更新其权重，以更接近我们匹配的行，即第1行。节点越接近BMU，更新的权重就越大。类似地，如果我们对于不同的行有另一个BMU，则更靠近BMU的节点将落入其中。如果节点与其他BMU的距离相等，则它将在两个BMU下工作，并具有相等的影响。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/4893755851ba3b5e25b708c5064d7482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwORDXpdxGJVFfcRUwsBIw.png"/></div></div></figure><p id="43ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们有多个BMU，则在不同BMU下的节点将会产生影响，并且在每个时期之后应用学习率，并且BMU的半径缩小，直到每个BMU都有落入该半径下的单独节点。随着我们一次又一次地使用数据集，这个过程变得更加精确。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/67fd505e9b37012246c4d2aef101dbef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWyhs6FTNGJ8ybJGLpYBUw.png"/></div></div></figure><h2 id="46e3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">重要的是要知道-</h2><ul class=""><li id="84ae" class="ld le hi is b it kj ix kk jb lf jf lg jj lh jn li lj lk ll bi translated">SOMs保持输入集的拓扑结构</li><li id="9791" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">som揭示了不容易识别相关性</li><li id="c343" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">SOMs在没有监督的情况下对数据进行分类</li><li id="773c" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">无目标向量-&gt;无反向传播</li><li id="b4ff" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">输出节点之间没有横向连接</li></ul><h2 id="513e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">算法-</h2><p id="8a66" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">第一步:我们从由n_features自变量组成的数据集开始。</p><p id="f0b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤2:我们创建一个由节点组成的网格，每个节点都有一个n_features元素的权重向量。</p><p id="8740" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤3:将权重向量的值随机初始化为接近0的小数值(但不是0)。</p><p id="6504" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤4:从数据集中选择一个随机观测点。</p><p id="d12d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤5:计算从该点到网络中不同神经元的欧几里德距离。</p><p id="3112" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤6:选择与该点距离最小的神经元。这个神经元被称为获胜节点。</p><p id="dd08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤7:更新获胜节点的权重，以使其更接近该点。</p><p id="15cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤8:使用平均获胜节点的高斯邻域函数，也更新获胜节点邻居的权重以向该点移动。邻域半径是高斯函数中的σ。</p><p id="dc90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤9:重复步骤1至5，在每次观察或一批观察(批学习)后更新权重，直到网络收敛到邻域停止下降的点。</p><h2 id="49b2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">这是银行业客户细分的一个例子。</h2><h2 id="dffd" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">-数据集</h2><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/f67086517d1b08bc666c4dddf9255360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SmlaiDh8E7n2uThTQCwZhw.png"/></div></div></figure><h2 id="25b0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">-数据预处理</h2><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/75fcc027e0f2c68e4374eed49bf48082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdOk6vPW0q_14yFwHzJazQ.png"/></div></div></figure><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/1eca793957a376ddb97ac2311ade9d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxByklvaOFQWMg52YagOkg.png"/></div></div></figure><h2 id="d9e8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">-为训练定义X和y</h2><p id="254b" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">这里我们把数据分为X和y，并不代表我们在做监督学习。这里y代表贷款用途的区别。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/0c4c34df5c90fff1133ba362c9ed207f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9mXOWxrn0_2KkhKzmvvKwg.png"/></div></div></figure><h2 id="5aed" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">-特征缩放</h2><p id="e286" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">因为大多数时候，特征缩放对于深度学习是强制性的，原因很简单，因为我们从高维数据集开始，所以需要进行大量计算。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/c2df9f4075ddfed7c24a5af2af3d0545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Es4CY-TrUpMqPJfSbjwvOw.png"/></div></div></figure><h2 id="f9b8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">-训练高级管理人员</h2><p id="ad83" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我们可以安装迷你电脑— pip安装迷你电脑</p><p id="a5d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里x和y是维度的大小。我们可以选择任何尺寸的维度，这取决于数据集，input_len是X中的要素数量，sigma是网格中不同邻域的半径(默认值=1.0)和学习率(默认值=0.5)，学习率记住了决定每次迭代期间更新多少权重的超参数。因此，学习率越高，收敛越快，学习率越低，构建自组织映射所需的时间就越长。</p><p id="9c30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">som.random_weight_init(X)随机初始化权重向量的值。</p><p id="bec9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">som.train_random()训练som的迭代次数。</p><pre class="kp kq kr ks fd lw lx ly lz aw ma bi"><span id="1b99" class="jo jp hi lx b fi mb mc l md me"><strong class="lx hj">from</strong> <strong class="lx hj">minisom</strong> <strong class="lx hj">import</strong> MiniSom</span><span id="3ffe" class="jo jp hi lx b fi mf mc l md me">som=MiniSom(x=10,y=10,input_len=8,sigma=1.0,learning_rate=0.5)</span><span id="538d" class="jo jp hi lx b fi mf mc l md me">som.random_weights_init(X)<br/><br/>som.train_random(data=X,num_iteration=100)</span></pre><h2 id="0498" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><em class="mg"> —可视化结果</em></h2><p id="ab90" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">那就是绘制自组织地图本身。我们看到的是包含所有最终获胜节点的二维网格，对于每个节点，我们将获得对我们最重要的内容，即MID平均神经元间距。特定获胜节点的中点是邻域内获胜节点周围所有神经元距离的平均值，我们通过σ来定义该邻域，σ是该邻域的半径。MID越高，获胜的节点将远离其邻域内的邻居。MID越高，获胜节点就是异常值。</p><pre class="kp kq kr ks fd lw lx ly lz aw ma bi"><span id="d8d2" class="jo jp hi lx b fi mb mc l md me"><strong class="lx hj">from</strong> <strong class="lx hj">pylab</strong> <strong class="lx hj">import</strong> bone, pcolor,colorbar,plot,show</span><span id="23bf" class="jo jp hi lx b fi mf mc l md me">bone()<br/>pcolor(som.distance_map().T)<br/>colorbar()<br/>markers=['o','s','+','-','*','D','p','-s']<br/>colors=['C0','C1','C2','C3','C4','C5','C6','C7']<br/>plt.figure(figsize=(10, 10))<br/><br/><br/><strong class="lx hj">for</strong> i,x <strong class="lx hj">in</strong> enumerate(X):<br/>    w=som.winner(x)<br/>    plot(w[0]+0.5,<br/>         w[1]+0.5,<br/>        markers[t[i]],<br/>        markeredgecolor=colors[t[i]],markerfacecolor='None',markersize=10,markeredgewidth=2)<br/>show()<br/>plt.show()</span></pre><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/282fac984666962549a2444facac65ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*bqiOCeDuRZwK5ODIZ1xCzw.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">该图只告诉我们物种密度较大(较暗区域)或较小(较亮区域)的地方</figcaption></figure><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/cadeaf1dc7957560e15d78ef553c6bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRXRaGcBsTghJaQgwp214w.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">第二个观想告诉我们它们是如何特别聚集的。</figcaption></figure><pre class="kp kq kr ks fd lw lx ly lz aw ma bi"><span id="9dd1" class="jo jp hi lx b fi mb mc l md me">bone()<br/>pcolor(som.distance_map().T)<br/>colorbar()<br/>markers=['o','s','+','-','*','D','p','-s']<br/>colors=['C0','C1','C2','C3','C4','C5','C6','C7']<br/><br/><strong class="lx hj">for</strong> i,x <strong class="lx hj">in</strong> enumerate(X):<br/>    w=som.winner(x)<br/>    plot(w[0]+0.5,<br/>         w[1]+0.5,<br/>        markers[t[i]],<br/>        markeredgecolor=colors[t[i]],markerfacecolor='None',markersize=10,markeredgewidth=2)<br/>show()</span></pre><ul class=""><li id="b48c" class="ld le hi is b it iu ix iy jb mi jf mj jj mk jn li lj lk ll bi translated">收音机/电视' = 0 — →'o' →'C0 '</li><li id="128d" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">“教育”= 1—-&gt;“s”→“C1”</li><li id="9d9b" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">家具/设备' = 2 — →'+' →'C2 '</li><li id="eec7" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">汽车' = 3 — →'-' →'C3 '</li><li id="6520" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">商业' = 4 — →'*' →'C4 '</li><li id="0762" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">“修理”= 5—→“D”→“C5”</li><li id="b86d" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">“度假/其他”= 6—→“p”→“C6”</li><li id="69f3" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">家用电器' = 7 — →'-s' →'C7 '</li></ul><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/80030aa0d70a159d022c4b9d95a85d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*uMoibIxeFYeCben1wV40Ig.png"/></div></figure><pre class="kp kq kr ks fd lw lx ly lz aw ma bi"><span id="e7bc" class="jo jp hi lx b fi mb mc l md me"><strong class="lx hj">from</strong> <strong class="lx hj">matplotlib</strong> <strong class="lx hj">import</strong> gridspec<br/>label = np.genfromtxt('Dataset_II.csv', delimiter=',', usecols=(9), dtype=str)<br/>X=np.genfromtxt('data.csv', delimiter=',', usecols=(1, 2, 3, 4, 5, 6, 7, 8))<br/><strong class="lx hj">from</strong> <strong class="lx hj">sklearn.preprocessing</strong> <strong class="lx hj">import</strong> MinMaxScaler<br/>scaler = MinMaxScaler(feature_range=(0,1))<br/>X = scaler.fit_transform(X)<br/><br/>label = np.genfromtxt('Dataset_II.csv', delimiter=',', usecols=(9), dtype=str)<br/>labels_map = som.labels_map(X, label)<br/>label_names = np.unique(label)<br/>plt.figure(figsize=(10, 10))<br/>the_grid = gridspec.GridSpec(10, 10)<br/><strong class="lx hj">for</strong> position <strong class="lx hj">in</strong> labels_map.keys():<br/>    label_fracs = [labels_map[position][l] <strong class="lx hj">for</strong> l <strong class="lx hj">in</strong> label_names]<br/>    plt.subplot(the_grid[6-position[1], position[0]], aspect=1)<br/>    patches, texts = plt.pie(label_fracs)<br/>plt.legend(patches, label_names, bbox_to_anchor=(0., 6.5), ncol=3)<br/>plt.show()</span></pre><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/1a102a5518f3cf2a7a642160990f2907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zo92_k68NZU0Us4vKoJUAA.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">获胜节点对其邻居的影响。</figcaption></figure><h1 id="7ecd" class="mn jp hi bd jq mo mp mq ju mr ms mt jy mu mv mw kb mx my mz ke na nb nc kh nd bi translated">参考</h1><ul class=""><li id="8538" class="ld le hi is b it kj ix kk jb lf jf lg jj lh jn li lj lk ll bi translated"><a class="ae ne" href="https://towardsdatascience.com/self-organizing-map-layer-in-tensroflow-with-interactive-code-manual-back-prop-with-tf-580e0b60a1cc" rel="noopener" target="_blank">superdata science团队的自组织地图(SOM)终极指南。链接https://www . superdata science . com/blogs/the-ultimate-guide-to-self-organizing-maps-soms</a></li><li id="9ef0" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated"><a class="ae ne" href="https://en.wikipedia.org/wiki/Self-organizing_map" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Self-organizing_map</a></li><li id="e9c1" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">【http://blog.yhat.com/posts/self-organizing-maps-2.html T2】号</li></ul><h2 id="d63a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">密码</h2><p id="abbe" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">请在这里找到我的代码<a class="ae ne" href="https://github.com/kaushik1580/Flipr_Internship_program/blob/master/Assignment6/Project2/Assignment_06-Project-2.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>