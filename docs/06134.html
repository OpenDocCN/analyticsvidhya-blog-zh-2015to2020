<html>
<head>
<title>Pixelate me: creating a telegram bot to make beautiful pixelated profile pictures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像素化我:创建一个电报机器人，使美丽的像素化的个人资料图片</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pixelate-me-creating-a-telegram-bot-to-make-beautiful-pixelated-profile-pictures-7e2901004466?source=collection_archive---------18-----------------------#2020-05-12">https://medium.com/analytics-vidhya/pixelate-me-creating-a-telegram-bot-to-make-beautiful-pixelated-profile-pictures-7e2901004466?source=collection_archive---------18-----------------------#2020-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e7e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，照片的质量一直在快速增长。然而，我们中的许多人希望给我们的生活添加一些像素风格的图像。</p><p id="dd8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们将为Telegram创建一个机器人，它将使用Google Colab在15分钟内处理我们的照片和所有这些。</p><p id="de2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用Google Colab，因为它免费提供GPU实例。经过15分钟的编码，你将能够生成这样的图像:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/84fc9e43dd8a79504202d6727c3d3171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32ac2GuOSABreFo14xHgPQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><strong class="bd jt">算法结果</strong></figcaption></figure><h1 id="a11a" class="ju jv hi bd jt jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建Google Colab文件</h1><p id="947f" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Google Colab笔记本提供免费的GPU实例，使用PyTorch或TensorFlow等已知的深度学习库来加速图像处理。要创建Google Colab笔记本，请转到colab.research.google.com的<a class="ae kw" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a><strong class="ih hj">→“新笔记本”</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/4ddca1560a3364caa995572a3a865307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3e0GAdKIuDV3spW_"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图一。创建新的Google Colab笔记本</figcaption></figure><h1 id="1d7e" class="ju jv hi bd jt jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">人脸检测和分割</h1><p id="7f61" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">为了检测照片中我们感兴趣的区域，我们将使用人脸检测算法— <strong class="ih hj">人脸识别</strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/b3edda1374a69bf0528a92df1183dc70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*GiUS9L4do-WnD-SNNxhwRA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">人脸识别</figcaption></figure><p id="4ad2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要安装这个包，只需运行<code class="du kz la lb lc b">!pip3 install face_recognition</code>。让我们定义一个函数，该函数将一幅图像作为输入，并返回图片上被裁剪了一些填充的最大的脸:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">用户可以使用<strong class="ak"> get_cropped_image </strong>功能检测最大的面部和裁剪图像</figcaption></figure><p id="bc25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们在检测到的边界框周围明确添加了填充，因为人脸检测算法通常会忽略头发、脖子、耳朵等。</p><p id="8c36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于分段部分，我们将使用Grapy-ML，它可以通过使用以下代码来安装:</p><pre class="je jf jg jh fd lf lc lg lh aw li bi"><span id="07cc" class="lj jv hi lc b fi lk ll l lm ln">!git clone https://github.com/Charleshhy/Grapy-ML &gt; /dev/null</span></pre><p id="7d92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用分段网络，我们需要使用<strong class="ih hj"> gdown </strong>包下载权重。在笔记本中运行以下代码:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">下载细分模型的权重</figcaption></figure><p id="5abd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们定义细分模型的初始化:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">初始化分段网络的辅助函数</figcaption></figure><h1 id="e99e" class="ju jv hi bd jt jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">主算法</h1><p id="6510" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">该算法由以下步骤组成:</p><ul class=""><li id="6ea0" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">检测人脸并选择最大的一个</li><li id="6d7c" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">用填充裁剪图像</li><li id="582b" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">在裁剪的图像上分割人物</li><li id="2c60" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">像素分解</li><li id="f8cb" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">使用卷积查找和添加轮廓</li></ul><p id="1ad9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们定义<code class="du kz la lb lc b">pixelate</code>函数:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">该函数将图像(np.ndarray)或路径(str)作为输入，并返回图像的dict</figcaption></figure><h1 id="1206" class="ju jv hi bd jt jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">电报机器人</h1><p id="22c2" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">有几个telegram API包装器，我们将使用<strong class="ih hj"> pyTelegramBotAPI。</strong></p><pre class="je jf jg jh fd lf lc lg lh aw li bi"><span id="42dd" class="lj jv hi lc b fi lk ll l lm ln">!pip3 install requests &gt; /dev/null<br/>!pip3 install pyTelegramBotAPI &gt; /dev/null</span></pre><p id="d403" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以导入我们需要的所有内容:</p><pre class="je jf jg jh fd lf lc lg lh aw li bi"><span id="26bb" class="lj jv hi lc b fi lk ll l lm ln">import logging<br/>from io import BytesIO</span><span id="17c2" class="lj jv hi lc b fi mc ll l lm ln">import numpy as np<br/>import requests<br/>from PIL import Image<br/>from skimage.transform import rescale, resize</span><span id="f3cd" class="lj jv hi lc b fi mc ll l lm ln">import telebot</span></pre><p id="ffe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用Telegram API，您需要从<a class="ae kw" href="https://t.me/BotFather" rel="noopener ugc nofollow" target="_blank"> @BotFather </a>获取您的机器人令牌。<strong class="ih hj"> <em class="md"> </em> </strong>给机器人写一条消息，然后按照指令去做。添加令牌变量:</p><pre class="je jf jg jh fd lf lc lg lh aw li bi"><span id="c2b3" class="lj jv hi lc b fi lk ll l lm ln">TOKEN = '4346%%%%%:AAH7TebGbSKim6cPPC_um6Tt3yKzy%%%%%%'</span></pre><p id="75b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以用一个消息处理程序初始化一个机器人，它返回一个发送消息的文本:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">用两个简单的处理程序初始化机器人</figcaption></figure><p id="5b8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，我们需要以某种方式检查用户是否发送了图像，对其进行处理，并将结果发送回来。我们可以通过多一个处理程序来实现:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="e037" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，使用<code class="du kz la lb lc b">bot.polling()</code>运行机器人并查看结果</p><pre class="je jf jg jh fd lf lc lg lh aw li bi"><span id="2205" class="lj jv hi lc b fi lk ll l lm ln"><strong class="lc hj">Constructing DeepLabv3+ model...</strong><br/><strong class="lc hj">Number of classes:</strong> 21<br/><strong class="lc hj">Output stride:</strong> 16<br/><strong class="lc hj">Number of Input Channels:</strong> 3</span><span id="e8f0" class="lj jv hi lc b fi mc ll l lm ln"><strong class="lc hj">2020-05-09 18:15:05,687</strong> (__init__.py:420 MainThread) INFO - TeleBot: "Started polling."<br/><strong class="lc hj">2020-05-09 18:15:05,688</strong> (util.py:59 PollingThread) DEBUG - TeleBot: "Received task"<br/><strong class="lc hj">2020-05-09 18:15:05,691</strong> (apihelper.py:54 PollingThread) DEBUG - TeleBot: "Request: method=get url=<a class="ae kw" href="https://api.telegram.org/bot434680657:AAH7TebGbSKim6cPPC_um6Tt3yKzy1frPx0/getUpdates" rel="noopener ugc nofollow" target="_blank">https://api.telegram.org/bot43xxxxxxx:xxxxTebGbSKim6cPPC_um6Tt3yKzy1frPx0/getUpdates</a> params={'offset': 1, 'timeout': 20} files=None"<br/><strong class="lc hj">2020-05-09 18:15:25,725</strong> (apihelper.py:64 PollingThread) DEBUG - TeleBot: "The server returned: 'b'{"ok":true,"result":[]}''"<br/><strong class="lc hj">2020-05-09 18:15:25,726</strong> (__init__.py:323 PollingThread) DEBUG - TeleBot: "Received 0 new updates"<br/><strong class="lc hj">2020-05-09 18:15:25,727</strong> (util.py:63 PollingThread) DEBUG - TeleBot: "Task complete"</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es me"><img src="../Images/baf22d0de832c0b1e21c45a7238cd9e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*OZDoO4P6XKX_smHbhYNuUg.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">我们的机器人工作了！</figcaption></figure><h2 id="4bf8" class="lj jv hi bd jt mf mg mh jz mi mj mk kd iq ml mm kh iu mn mo kl iy mp mq kp mr bi translated">就是这样！代码可在<a class="ae kw" href="https://github.com/olegkhomenko/pixelate-me-tg" rel="noopener ugc nofollow" target="_blank"><strong class="ak">GitHub</strong></a>T5或<a class="ae kw" href="https://colab.research.google.com/github/olegkhomenko/pixelate-me-tg/blob/master/pixelate_me_tg.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="ms"> Google Colab </em> </a>获得</h2></div></div>    
</body>
</html>