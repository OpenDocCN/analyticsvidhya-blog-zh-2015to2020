<html>
<head>
<title>Algorithms with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/algorithms-with-javascript-75b867b74865?source=collection_archive---------11-----------------------#2020-05-09">https://medium.com/analytics-vidhya/algorithms-with-javascript-75b867b74865?source=collection_archive---------11-----------------------#2020-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="45b2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">JavaScript算法的一天——里程碑2(第6天——第2周)</h1><p id="4ed8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">今天，我们将简要讨论一些简单、基本但最常用的任何编程语言的算法，包括JavaScript。我们将涵盖——阶乘和斐波那契等数学算法，线性搜索和二分搜索法等搜索算法，冒泡排序、选择排序、插入排序、合并排序、快速排序和堆排序等排序算法，以及它们的实现。所以，让我们跳进这篇有趣的文章。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kb"><img src="../Images/40ad2304594d1fd0e86f66248066803b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*j3MFhGsSE2uZeiIsG_bfgw.png"/></div></figure><h2 id="9811" class="kj ig hi bd ih kk kl km il kn ko kp ip jo kq kr it js ks kt ix jw ku kv jb kw bi translated">1.阶乘</h2><p id="085b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在数学中，正整数的阶乘<strong class="jf hj"> <em class="kx"> n </em> </strong>，用<strong class="jf hj"> <em class="kx"> n表示！</em> </strong>，是所有小于等于<strong class="jf hj"> <em class="kx"> n </em> </strong>的正整数的乘积:</p><blockquote class="ky kz la"><p id="9a9a" class="jd je kx jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated"><strong class="jf hj"> n！= n x(n-1)x(n-2)x(n-3)x…x 3 x 2 x 1</strong></p></blockquote><p id="6b3b" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated">举个例子，</p><blockquote class="ky kz la"><p id="cd49" class="jd je kx jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated"><strong class="jf hj"> 5！= 5 x 4 x 3 x 2 x 1 = 120 </strong></p></blockquote><p id="1f0c" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated">同样，<br/> <em class="kx"> 6！= 720, 7!= 5040, 8!= 40320, 9!= 362880, 10!= 3628800 </em></p><p id="a574" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx"/><strong class="jf hj">除外<em class="kx"> 0！</em></strong>= 1<em class="kx">(按惯例为空品)</em></p><p id="60b1" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">迭代阶乘- JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lj"><img src="../Images/9fcff57dd80045f56923ca07b8383d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*oucKi-vhXLUyc1p56Ds2Gw.png"/></div></figure><p id="cd55" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">递归阶乘- JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lk"><img src="../Images/2d2382d60ec49eb35ba2ef5a727a7e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PogAI724eh5in1GfvurZw.png"/></div></div></figure><h1 id="1429" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">2.斐波那契数</h1><p id="b243" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在数学中，斐波纳契数列是以下整数序列中的数字，称为斐波纳契数列，其特征在于前两个数字之后的每个数字都是前两个数字之和:</p><blockquote class="ky kz la"><p id="0645" class="jd je kx jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated"><strong class="jf hj"> 0，1，1，2，3，5，8，13，21，34，55，89，144，… </strong></p></blockquote><p id="ec36" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj"> <em class="kx">我发现这个很有趣:<br/> </em> </strong> <em class="kx">一个由边长为连续斐波那契数的正方形组成的瓷砖</em></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lp"><img src="../Images/ba4edab4278ab7dc4cc4dfaab89942f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*Zo-Wh0fnTlTqHpw3JR21tg.png"/></div></div></figure><blockquote class="ky kz la"><p id="632d" class="jd je kx jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated"><strong class="jf hj">斐波纳契螺旋:</strong>通过在斐波纳契镶嵌中画出连接正方形对角的圆弧而产生的黄金螺旋的近似；[4]这一个使用大小为1、1、2、3、5、8、13和21的正方形。</p></blockquote><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lq"><img src="../Images/41c0426b232de4b2be60a98d75d8ac78.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*kAXN8LoWIz3oyM2v1_5a3Q.png"/></div></figure><p id="7db1" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">迭代阶乘- JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lr"><img src="../Images/dfc5a0d1988a100aefee48a2d12f1a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*z69GU_g0jGa0OuLuyYsLeg.png"/></div></figure><p id="9126" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">递归阶乘- JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es ls"><img src="../Images/c1f6506c5831a8a2ebd80e73019afc2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqBfpYlrQbbaPcshTtW6Tg.png"/></div></div></figure><h1 id="cc59" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">3.线性搜索</h1><p id="3e74" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">线性搜索或顺序搜索是一种在列表中查找目标值的方法。它按顺序检查目标值列表中的每个元素，直到找到匹配项或搜索完所有元素。线性搜索以最坏的线性时间运行，并且最多进行n次比较，其中n是列表的长度。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lt"><img src="../Images/f757d7c8d5ae5cab5916df1b8809fe48.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*m6Ni_Ry4iRIPMHY44uy49A.gif"/></div></figure><blockquote class="ky kz la"><p id="52ad" class="jd je kx jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">线性搜索的<strong class="jf hj">时间复杂度</strong>是<strong class="jf hj"> O(n) </strong>在<strong class="jf hj">最坏情况下</strong>我们正好检查每个元素一次。</p></blockquote><p id="d6aa" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">线性搜索- JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lu"><img src="../Images/0e0585d358e4a93fbbe70168b0966bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jocv9i8C6C8PnUql9acvHA.png"/></div></div></figure><p id="ba01" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">为什么线性搜索效率不高<br/> </strong>毫无疑问，线性搜索很简单。但是因为它逐个比较每个元素，所以很耗时，因此效率不是很高。如果我们必须从1，000，000个数字中找出一个数字，而这个数字位于最后一个位置，那么线性搜索技术将变得非常乏味。</p><p id="e4a8" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated">所以我们也要学习冒泡排序、快速排序等更高效的算法。</p><h1 id="e3bc" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">4.二进位检索</h1><p id="93c4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一种简单的搜索算法，通过将搜索间隔重复分成两半来搜索排序后的数组。以覆盖整个阵列的间隔开始。</p><p id="7bb4" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated">如果搜索关键字的值小于间隔中间的项目，则将间隔缩小到下半部分。否则缩小到上半部分。重复检查，直到找到值或间隔为空。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lv"><img src="../Images/95c3e132194e00ffe433db2dce52a337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*pLjDTIJBIPY4u0I97xvSaA.png"/></div></figure><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lw"><img src="../Images/c25e2b424ae5a64ea0eeccbf29338f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tyh5EfBnl9_Vkkc66tVCeA.png"/></div></div></figure><blockquote class="ky kz la"><p id="695b" class="jd je kx jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated"><strong class="jf hj">二分搜索法</strong>的思想是利用数组排序的信息，将<strong class="jf hj">时间复杂度</strong>降低到<strong class="jf hj"> O(log n) </strong>。</p></blockquote><p id="60c6" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">二分搜索法— JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lx"><img src="../Images/50224dadc55d1083fc83b3e8dd5e47ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x-AgLOMoF1l-tEI15kZXGQ.png"/></div></div></figure><h1 id="404e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">5.冒泡排序</h1><p id="2a0a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">冒泡排序是一种简单的排序算法，它重复遍历要排序的列表，比较每对相邻的项目，如果它们的顺序不对(升序或降序排列)，就交换它们。重复遍历列表，直到不需要交换，这表示列表已排序。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es ly"><img src="../Images/7b76d1c3b3d09191ff46a6130cd428ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*1MiLjMYgr2r2fDORCJn89w.gif"/></div></figure><p id="d1b2" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">冒泡排序的时间复杂度:</strong></p><p id="4db2" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">最佳- n </em></p><p id="78f0" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">平均值- n </em></p><p id="18ad" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">最差- n </em></p><p id="99cb" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">冒泡排序- JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lz"><img src="../Images/6cd697eb0cb1929b38cbaceb8c8667fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*SnzBpDBcd2CCCOVQmm_h7A.png"/></div></figure><h1 id="8505" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">6.选择排序</h1><p id="acb5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">选择排序是一种排序算法，特别是就地比较排序。它的时间复杂度为O(n ),这使得它在大型列表上效率很低，并且通常比类似的插入排序的性能差。</p><p id="6b4c" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated">选择排序以其简单性而著称，在某些情况下，特别是在辅助存储器有限的情况下，它比更复杂的算法具有性能优势。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es ma"><img src="../Images/9bd017b1a631050fb0450e5f294f34ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*8guImFhbPKA4Q9k84sNaaA.png"/></div></figure><p id="97e7" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">选择排序的时间复杂度:</strong></p><p id="31a5" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx"> Best - O(n ) </em></p><p id="e6fa" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">平均值- O(n ) </em></p><p id="940c" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">最差- O(n ) </em></p><p id="3265" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">选择排序- JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mb"><img src="../Images/341af7c856daf2f9bf6a89642d567027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6BabPcKHrszxrFxceN5Yw.png"/></div></div></figure><h1 id="9c3a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">7.插入排序</h1><p id="f0d3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">插入排序是一种简单的排序算法，它的工作原理就像我们手中的扑克牌排序一样。它一次构建一个最终排序的数组(或列表)。在大型列表上，它的效率比快速排序、堆排序或合并排序等更高级的算法要低得多。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es ly"><img src="../Images/434a5f4b5f65218f49cd487bead100db.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*bmfRxyIQZEK0Iu5T6YV1sw.gif"/></div></figure><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es mc"><img src="../Images/b046819f1880f94aafdedf49b44b4b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*EZY_Nyos3QWiHvcAov-Nxw.png"/></div></figure><p id="1880" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">插入排序的时间复杂度:</strong></p><p id="4481" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx"> Best - O(n) </em></p><p id="6777" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">平均值- O(n ) </em></p><p id="99ab" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">最差- O(n ) </em></p><p id="c856" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">选择排序- JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es md"><img src="../Images/81b5f77ea947c3ea05efb05bb231fdac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5TAWPQK2NiG17Jwm7dTuQ.png"/></div></div></figure><h1 id="cafe" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">8.合并排序</h1><p id="b88f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">合并排序是一种高效、通用、基于比较的排序算法。大多数实现产生稳定的排序，这意味着实现在排序的输出中保持相等元素的输入顺序。</p><blockquote class="ky kz la"><p id="aab9" class="jd je kx jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">合并排序是一种分治算法，由约翰·冯·诺依曼在1945年发明。</p></blockquote><p id="b93a" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated">合并排序的一个例子。首先将链表划分为最小单元(1个元素)，然后将每个元素与相邻链表进行比较，对两个相邻链表进行排序合并。最后，所有的元素被排序和合并。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es ly"><img src="../Images/4300dee9f0581fef7cba45352ba7de79.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*opwN0BhtH4zvPF697fPlow.gif"/></div></figure><p id="da6d" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated">一种递归合并排序算法，用于对7个整数值的数组进行排序。这些是模拟合并排序(自顶向下)的步骤。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es me"><img src="../Images/ffb6a3eb07e9633845fba76ec4341f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4iBX5bSs3caaf9w3l4sJow.png"/></div></div></figure><p id="9609" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">归并排序的时间复杂度:</strong></p><p id="99cd" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx"> Best - n log(n) </em></p><p id="173f" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">平均值- n对数(n) </em></p><p id="db51" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">最差- n对数(n) </em></p><p id="73c9" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">合并排序- JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mf"><img src="../Images/d166b1be873565134b9f3295ecb26e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Y2lts_MvwDt-VnNQVzSpg.png"/></div></div></figure><h1 id="6a5c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">9.快速排序</h1><p id="dd6f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">快速排序是一种分治算法。快速排序首先将一个大数组分成两个更小的子数组:低位元素和高位元素。然后，快速排序可以对子数组进行递归排序</p><p id="4b66" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj"> <em class="kx">步骤有:</em> </strong></p><blockquote class="ky kz la"><p id="9565" class="jd je kx jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">从数组中选择一个元素，称为<strong class="jf hj">枢轴</strong>。</p><p id="610d" class="jd je kx jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated"><strong class="jf hj">分区</strong>:对数组重新排序，使所有值小于轴心的元素排在轴心之前，而所有值大于轴心的元素排在轴心之后(两者值相等)。分割完成后，枢轴处于其最终位置。这称为分区操作。</p><p id="5fc5" class="jd je kx jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated"><strong class="jf hj">递归</strong>将上述步骤应用于具有较小值的元素的<strong class="jf hj">子数组</strong>，并分别应用于具有较大值的元素的<strong class="jf hj">子数组</strong>。</p></blockquote><p id="2c07" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated">快速排序算法的动画可视化。水平线是枢纽值。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es mg"><img src="../Images/77f7120ce6b6a3742a3a319392828ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/1*1OXQp3jbpyUJHYMX5rrJOQ.gif"/></div></figure><p id="7c8f" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">快速排序的时间复杂度:</strong></p><p id="3f4b" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">最佳- n对数(n) </em></p><p id="75b1" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">平均对数(n) </em></p><p id="a1bc" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">最差- n </em></p><p id="6ef8" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">快速排序- JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mh"><img src="../Images/74c0423ab0f697a2e24e7918211a3aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I41hUM4BRX8o-y9cikQ4kQ.png"/></div></div></figure><h1 id="bd7b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">10.堆排序</h1><p id="9555" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Heapsort是一种基于比较的排序算法。Heapsort可以被认为是一种<strong class="jf hj"> <em class="kx">改进的选择排序</em> </strong>:与该算法一样，它将其输入划分为一个排序区域和一个未排序区域，并通过提取最大元素并将其移动到排序区域来迭代缩小未排序区域。改进包括使用堆数据结构而不是线性时间搜索来寻找最大值。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es mg"><img src="../Images/f638a4619dbddb0f490a4d867f045588.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/1*t5B9NRgJKTxgZYsLhwU8Zg.gif"/></div></figure><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es mi"><img src="../Images/0218770e99cc0ade5996b15e18828e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/1*LVcbTeL6zPLfDHiQ2w3Jtw.gif"/></div></figure><p id="bdcf" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">堆排序的时间复杂度:</strong></p><p id="ddb1" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">最佳- n日志(n) </em></p><p id="0d90" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">平均- n对数(n) </em></p><p id="33fd" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><em class="kx">最差- n对数(n) </em></p><p id="ef40" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">堆排序- JavaScript </strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mj"><img src="../Images/488b083ba691a1ccba79ad32045e5288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zEhnGEBFMYPxMRZnvZmP-Q.png"/></div></div></figure><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mk"><img src="../Images/b6bd810378b5ed287fc1e55cf7846f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tgnf0rWDJiF2cG0RS546rw.png"/></div></div></figure><p id="8319" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj">今天就到这里……感谢阅读。快乐学习:)</strong></p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="054f" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><strong class="jf hj"> <em class="kx">资源参考:</em> </strong></p><p id="c05d" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated">【https://github.com/trekhleb/javascript-algorithms】T5<a class="ae ms" href="https://github.com/trekhleb/javascript-algorithms?fbclid=IwAR1_ulw28fQyQeDHxKpjXx5jlEx6UTI9MSv6pW4dLgfSDZEHbICX7GQ-zrw" rel="noopener ugc nofollow" target="_blank">T6</a></p><p id="2696" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><a class="ae ms" href="https://www.freecodecamp.org/news/linear-search/" rel="noopener ugc nofollow" target="_blank"><em class="kx">https://www.freecodecamp.org/news/linear-search/</em></a></p><p id="5088" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><a class="ae ms" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank"><em class="kx">https://en.wikipedia.org/wiki/Binary_search_algorithm</em></a></p><p id="0b6f" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><a class="ae ms" href="https://www.geeksforgeeks.org/binary-search/" rel="noopener ugc nofollow" target="_blank"><em class="kx">https://www.geeksforgeeks.org/binary-search/</em></a></p><p id="924e" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><a class="ae ms" href="https://reactgo.com/binary-search-algorithm-javascript/" rel="noopener ugc nofollow" target="_blank">https://reactgo.com/binary-search-algorithm-javascript/T21</a></p><p id="68c8" class="pw-post-body-paragraph jd je hi jf b jg lb ji jj jk lc jm jn jo le jq jr js lg ju jv jw li jy jz ka hb bi translated"><a class="ae ms" href="https://www.w3resource.com/javascript-exercises/searching-and-sorting-algorithm/index.php" rel="noopener ugc nofollow" target="_blank"><em class="kx">https://www . w3 resource . com/JavaScript-exercises/searching-and-sorting-algorithm/index . PHP</em></a></p></div></div>    
</body>
</html>