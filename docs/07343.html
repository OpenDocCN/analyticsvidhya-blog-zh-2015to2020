<html>
<head>
<title>Numpy — Stacking Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy —堆叠阵列</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/numpy-stacking-arrays-55be84cce2f4?source=collection_archive---------14-----------------------#2020-06-22">https://medium.com/analytics-vidhya/numpy-stacking-arrays-55be84cce2f4?source=collection_archive---------14-----------------------#2020-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="b6df" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">连接两个numpy数组</h1><ul class=""><li id="db84" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">stack将数组与给定的轴逐个元素连接起来</li><li id="2ab2" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">hstack —水平延伸</li><li id="0347" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">vstack垂直延伸</li></ul><h1 id="54ff" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Stack将数组与给定的轴逐个元素连接起来</h1><ul class=""><li id="64e0" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">两个输入数组应该具有相同的维度/形状</li><li id="7fbc" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">堆栈中的轴参数在这里作为dimention而不是水平/垂直方式工作。</li><li id="6b55" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">如果轴是0，那么它将通过第一维连接</li><li id="811b" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">如果轴是1，它将通过第二维连接</li><li id="9753" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">我们能提到的最大维数是输入数组的维数(比如n) + 1。</li><li id="38d6" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">如果给定的轴大于n + 1，那么将抛出“维数数组越界”异常</li></ul><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ka"><img src="../Images/b1d61010a2f2b8aef1e41ba92334c78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-c02ali_y5kNZjG-Xyd-sg.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">按第一维度堆叠</figcaption></figure><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es kq"><img src="../Images/3571599501c2bb1a3a1c4696b2f49d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*I5tifRDbzEKmxVsZojfLtg.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">按二维堆叠</figcaption></figure><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="e562" class="kw ig hi ks b fi kx ky l kz la">arr1 = np.array([1,5,2,10])<br/>arr2 = np.array([10,50,20,100])<br/>print(arr1)<br/>print(arr2)</span></pre><p id="28ee" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">输出:</p><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="877c" class="kw ig hi ks b fi kx ky l kz la">[ 1  5  2 10]<br/>[ 10  50  20 100]</span></pre><p id="f546" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">按第一维度堆叠:</p><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="eeb8" class="kw ig hi ks b fi kx ky l kz la">arr3 = np.stack((arr1, arr2), axis = 0)</span></pre><p id="12e3" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">输出:</p><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="f67d" class="kw ig hi ks b fi kx ky l kz la">array([[  1,   5,   2,  10],<br/>       [ 10,  50,  20, 100]])</span></pre><p id="a576" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">按第二维度堆叠:</p><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="405c" class="kw ig hi ks b fi kx ky l kz la">arr3 = np.stack((arr1, arr2), axis = 1)</span></pre><p id="8988" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">输出:</p><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="81da" class="kw ig hi ks b fi kx ky l kz la">array([[  1,  10],<br/>       [  5,  50],<br/>       [  2,  20],<br/>       [ 10, 100]])</span></pre><h1 id="ce6a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">HStack —水平堆叠</h1><ul class=""><li id="1591" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">此功能不适用于axis。它通过第二阵列水平延伸第一阵列</li><li id="eb24" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">当它水平扩展时，两个数组应该有相同的行数，否则将返回值错误。</li></ul><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ls"><img src="../Images/b8e374e0014235c37e78940541ad9365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WaZ7yIo6AfcdS8wMNf300A.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">HStack</figcaption></figure><p id="9398" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">1D阵列的HStack:</p><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="0f65" class="kw ig hi ks b fi kx ky l kz la">arr1 = np.array([1,5,2,10])<br/>arr2 = np.array([10,50,20,100])<br/>np.hstack((arr1, arr2))</span></pre><p id="0192" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">输出:</p><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="a255" class="kw ig hi ks b fi kx ky l kz la">array([  1,   5,   2,  10,  10,  50,  20, 100])</span></pre><p id="665f" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">2D阵列的HStack:</p><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="bbaf" class="kw ig hi ks b fi kx ky l kz la">arr1 = np.array([[1,2,3],[4,5,6]])<br/>arr2 = np.array([[10,20,30],[40,50,60]])<br/>np.hstack((arr1, arr2))</span></pre><p id="0eba" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">输出:</p><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="cadb" class="kw ig hi ks b fi kx ky l kz la">array([[ 1,  2,  3, 10, 20, 30],<br/>       [ 4,  5,  6, 40, 50, 60]])</span></pre><h1 id="3f8c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">VStack —垂直堆叠</h1><ul class=""><li id="e42e" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">此功能不适用于axis。它通过第二阵列垂直延伸第一阵列</li></ul><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es lt"><img src="../Images/6caa102b86c371c14bbf2826d7eddbe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xoS4f8XRhn1_F8c8Jio6zg.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">VStack</figcaption></figure><p id="707f" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">2D阵列的VStack:</p><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="f5a9" class="kw ig hi ks b fi kx ky l kz la">arr1 = np.array([[1,2,3],[4,5,6]])<br/>arr2 = np.array([[10,20,30],[40,50,60]])<br/>np.vstack((arr1, arr2))</span></pre><p id="3e73" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">输出:</p><pre class="kb kc kd ke fd kr ks kt ku aw kv bi"><span id="69d6" class="kw ig hi ks b fi kx ky l kz la">array([[ 1,  2,  3],<br/>       [ 4,  5,  6],<br/>       [10, 20, 30],<br/>       [40, 50, 60]])</span></pre><h1 id="9878" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">结论:</strong></h1><p id="93ec" class="pw-post-body-paragraph lb lc hi jf b jg jh le lf ji jj lh li jk lu lk ll jm lv ln lo jo lw lq lr jq hb bi translated">在本文中，我们对1D和2D阵列进行了叠加实验。</p><p id="e2d4" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">我将添加另一个帖子，对3D阵列进行更多的演示，因为它有点难以理解。</p><p id="e12d" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">如果你喜欢这篇文章，支持我，只要点击拍手图标，次数不限！！！</p><p id="1322" class="pw-post-body-paragraph lb lc hi jf b jg ld le lf ji lg lh li jk lj lk ll jm lm ln lo jo lp lq lr jq hb bi translated">编程快乐！！！</p></div></div>    
</body>
</html>