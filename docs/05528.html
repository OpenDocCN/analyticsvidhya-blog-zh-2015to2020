<html>
<head>
<title>Pandas DataFrame — simple transformations in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫数据框架Python中的简单转换</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pandas-dataframe-simple-transformations-in-python-6582523c3d81?source=collection_archive---------11-----------------------#2020-04-24">https://medium.com/analytics-vidhya/pandas-dataframe-simple-transformations-in-python-6582523c3d81?source=collection_archive---------11-----------------------#2020-04-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="a060" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">实用分析的有用数据转换。</h2><div class=""/><div class=""><h2 id="df9e" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">准备数据时通常需要几个简单的代码。</h2></div><p id="8a26" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在编码时，似乎很少有我经常需要的数据转换，并且总是试图找到最好的解决方案。在我的数据科学“旅程”开始时，我被那些让数据看起来更有代表性的简单答案所吸引。在学习的时候，我脑子里有它的逻辑，但是我没有足够的经验从袖子里拿出代码。</p><p id="8d96" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> <em class="kc">所以让我们一头扎进去。</em>T3】</strong></p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/30f5cc258a557b56b11e31cd7e5e336b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IfKwhfT4RuyOUnW1"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">由<a class="ae kt" href="https://unsplash.com/@franki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗兰基·查马基</a>在<a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="a2b2" class="ku kv hi bd kw kx ky kz la lb lc ld le ix lf iy lg ja lh jb li jd lj je lk ll bi translated">1.基于条件添加列</h1><p id="cdb2" class="pw-post-body-paragraph jg jh hi ji b jj lm is jl jm ln iv jo jp lo jr js jt lp jv jw jx lq jz ka kb hb bi translated">这是我的代码中一直需要的东西。为了做出更好的预测或可视化，无疑仍然需要在我的数据中添加一些额外的东西。在我看来，最有效的方法是添加一个具有功能的列——对它有更多的控制，并且可以根据任何需要轻松调整。</p><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="2519" class="lw kv hi ls b fi lx ly l lz ma">def func(data):<br/>    if data['column']==condition:<br/>        return 1<br/>    else:<br/>        return 0</span></pre><p id="1dc1" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们定义一个函数——取整个数据集，在<strong class="ji hs"> IF </strong>语句中检查所选列是否符合输入的条件。</p><p id="559e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">条件可以有多种变化:</p><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="b2c0" class="lw kv hi ls b fi lx ly l lz ma"># <strong class="ls hs">one condition</strong> <br/>if datadata['column']==(&gt;,&lt;,&gt;=,&lt;=)condition:<br/># <strong class="ls hs">multiple conditions - and (&amp;) , or(|)<br/></strong>if (datadata['column']==condition) | (datadata['column']==condition2):</span></pre><p id="8ce6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">使用<strong class="ji hs"> return，</strong>我们决定如果if语句为真，需要在新列中输入什么，可以是int、string、float等。…</p><p id="47c2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">例如，我将使用虹膜数据集:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es mb"><img src="../Images/1eed0b998fc219de0fd16525591f79c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*oSPcDR_nIzGObpMSTAuhFg.png"/></div></figure><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="0534" class="lw kv hi ls b fi lx ly l lz ma">def func(data):<br/>    if data['PetalWidthCm']&gt;1.19:<br/>        return 1<br/>    else:<br/>        return 0</span></pre><p id="e3b1" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们希望根据花瓣宽度(以厘米为单位)创建一个新列，如果花瓣宽度大于1.19，则在新列中写入1，如果小于或等于0，则写入0。</p><p id="cb21" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">调用函数:<br/>每行应用函数—轴=1 —使用<strong class="ji hs">。应用</strong>。</p><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="c45b" class="lw kv hi ls b fi lx ly l lz ma">data['Is-PetalWidth_greaterThen_1.19']=data.apply(func,axis=1)</span></pre><p id="3da8" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">输出:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es mc"><img src="../Images/c8ac9cd632453830f6ea83afd8ff98a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*aUqkKZITNc43hNrvrzAgDQ.png"/></div></figure><h1 id="d2b2" class="ku kv hi bd kw kx ky kz la lb lc ld le ix lf iy lg ja lh jb li jd lj je lk ll bi translated">2.获取虚拟变量</h1><p id="f281" class="pw-post-body-paragraph jg jh hi ji b jj lm is jl jm ln iv jo jp lo jr js jt lp jv jw jx lq jz ka kb hb bi translated">简而言之，虚拟变量是一个数值变量，它表示分类数据的唯一值。对于每个分类变量-虚拟变量的数量=分类变量中唯一值的数量。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="fffc" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> <em class="kc">注</em> </strong> <em class="kc">:在创建预测模型的过程中——虚拟变量的数量= </em> <strong class="ji hs"> <em class="kc">(分类变量中唯一值的数量)——1</em></strong><em class="kc">，因为我们希望模型中的预测特征尽可能少。背后的逻辑是——如果我们有3种颜色(蓝色、红色、绿色)以及蓝色和红色的虚拟变量。如果蓝色和红色是0，那么我们知道这个特定的“数据”是绿色的。提到可以通过pd.get_dummies来控制(data，</em><strong class="ji hs"><em class="kc">drop _ first = True</em></strong><em class="kc">)。</em></p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="134b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">循序渐进:<br/> 1。创建一个函数，它将采用:</p><ul class=""><li id="665f" class="mk ml hi ji b jj jk jm jn jp mm jt mn jx mo kb mp mq mr ms bi translated">资料组</li><li id="ee88" class="mk ml hi ji b jj mt jm mu jp mv jt mw jx mx kb mp mq mr ms bi translated">分类栏</li><li id="b80f" class="mk ml hi ji b jj mt jm mu jp mv jt mw jx mx kb mp mq mr ms bi translated">False(默认情况下)到True我们是否希望在获得虚拟变量后删除主要分类值</li></ul><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="68b2" class="lw kv hi ls b fi lx ly l lz ma">def create_dummy(data,col,drop_main=False):<br/>    return result</span></pre><p id="8990" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">2.为分类变量创建虚拟变量(例如:物种):</p><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="402c" class="lw kv hi ls b fi lx ly l lz ma">pd.get_dummies(data['Species'])</span></pre><p id="c647" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">3.将其与我们的数据连接:<br/>使用<strong class="ji hs">PD . concat</strong>(pandas imported as PD)将真实数据与虚拟变量按行连接(轴=1)。</p><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="223a" class="lw kv hi ls b fi lx ly l lz ma"><strong class="ls hs">def</strong> create_dummy(data,col,drop_main<strong class="ls hs">=False</strong>):<br/>result <strong class="ls hs">=</strong> pd.concat([data,pd.get_dummies(data[col])],axis<strong class="ls hs">=</strong>1,sort<strong class="ls hs">=False</strong>)</span></pre><p id="50e6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">4.创建删除主要分类变量的规则:<br/>当连接这两个数据帧时，主变量将保留在数据集中，创建新的“规则”drop _ main(False-不删除，True-删除)</p><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="dd41" class="lw kv hi ls b fi lx ly l lz ma">def create_dummy(data,col,drop_main=False):<br/>    result = pd.concat([data,pd.get_dummies(data[col])],axis=1,sort=False)<br/>    <strong class="ls hs">if drop_main==True:<br/>        result=result.drop(columns=[col])</strong><br/>    return result</span></pre><p id="3f2e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">最后，我们有一个包含虚拟变量的数据集。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es my"><img src="../Images/ea6f123b454dd52d1a26b5aa7b62edeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UoOlYRKUxMtRbK7dPS3ZIQ.png"/></div></div></figure></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="5cdd" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在分析新冠肺炎数据时，我想到了最后一个转换，它对时间序列数据非常有用。为了说明，我将使用自跟踪开始以来通过各国的确诊病例。</p><h2 id="25f5" class="lw kv hi bd kw mz na nb la nc nd ne le jp nf ng lg jt nh ni li jx nj nk lk ho bi translated">主旨:</h2><p id="60a7" class="pw-post-body-paragraph jg jh hi ji b jj lm is jl jm ln iv jo jp lo jr js jt lp jv jw jx lq jz ka kb hb bi translated">数据集由国家、日期和确诊病例组成，如果我们想要创建这样的数据集，其中国家将被索引，并且对于每个国家，我们跟踪自第一天以来的病例数。重要的<strong class="ji hs">是</strong>，每个国家的第一天都是不同的，因为我们正在跟踪特定国家自该国首例确诊病例以来的数字。</p><p id="0892" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">对于每个国家，我们将从第1天开始输入确诊病例的数据。当我们到达确诊病例的最后一天时，剩余的天数将用0填充。<strong class="ji hs">为什么？</strong> <br/>比如克罗地亚的病例活跃59天，而中国是93天。我们有34天的差异，对于克罗地亚的情况，这些需要用0来填充。</p><p id="28ae" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Code: <br/>对于数据集中的每个国家— unique()从选定的列中返回唯一值—如果您是SQL类型，那么它与DISTINCT相同。</p><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="a402" class="lw kv hi ls b fi lx ly l lz ma">def rows_to_col(data):<br/>    for i in data['Country/Region'].unique():</span></pre><p id="ff1f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">然后检查该国家的天数—如果它不等于最大日期范围，则追加现有值，剩余日期追加0。</p><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="9568" class="lw kv hi ls b fi lx ly l lz ma">def rows_to_col(data):<br/>    new=pd.DataFrame()<br/>    for i in data['Country/Region'].unique():<br/>        if data[data['Country/Region']==i].Confirmed.shape[0] != data.Date.unique().shape[0]:<br/>            a=np.append(data[data['Country/Region']==i].Confirmed.values, list(repeat(0,(data.Date.unique().shape[0]-data[data['Country/Region']==i].Confirmed.shape[0]))))<br/>            new[i]=a</span></pre><p id="b8c4" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果一个国家的活动天数与最大日期范围相同，那么只需将其添加到新的<strong class="ji hs">数据框架中。</strong></p><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="34f6" class="lw kv hi ls b fi lx ly l lz ma">else:<br/>       new[i]=data[data['Country/Region']==i].Confirmed.values</span></pre><p id="9dd6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">最后，我们想创建一个日期列表—第1天，第2天，…..，Day_n —并将其设置为我们的数据帧的索引。</p><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="a164" class="lw kv hi ls b fi lx ly l lz ma">day_list=['Day_'+str(x+1) for x in range(0,data.Date.unique().shape[0])]<br/>    new=new.set_index([day_list])</span></pre><p id="9fc3" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">目前，新的数据框架将活跃天数作为索引插入，将国家作为列插入。现在，我们只想转置整个数据帧，以获得所需的外观。用return <strong class="ji hs"> new可以很快完成。T </strong>，其中<strong class="ji hs">。T </strong>将转置表格。</p><p id="6572" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">最终代码在这里:</p><pre class="ke kf kg kh fd lr ls lt lu aw lv bi"><span id="b836" class="lw kv hi ls b fi lx ly l lz ma">from itertools import repeat</span><span id="5784" class="lw kv hi ls b fi nl ly l lz ma">def rows_to_col(data):<br/>    new=pd.DataFrame()<br/>    for i in data['Country/Region'].unique():<br/>        if data[data['Country/Region']==i].Confirmed.shape[0] != data.Date.unique().shape[0]:<br/>            a=np.append(data[data['Country/Region']==i].Confirmed.values, list(repeat(0,(data.Date.unique().shape[0]-data[data['Country/Region']==i].Confirmed.shape[0]))))<br/>            new[i]=a<br/>        else:<br/>            new[i]=data[data['Country/Region']==i].Confirmed.values<br/>    day_list=['Day_'+str(x+1) for x in range(0,data.Date.unique().shape[0])]<br/>    new=new.set_index([day_list])<br/>    <br/>    return new.T</span></pre><p id="e7e8" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">输出:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es nm"><img src="../Images/711cb05170168521ebec1dfe4aac7bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7tbmLqPDHoVRvoUSVoPuQ.png"/></div></div></figure></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="8a97" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">当创建新功能时，我总是将它们写在“示例”笔记本上，这样我可以快速找到它们，并在新项目中实现它们。有时候找不到你想要的东西真的会很沮丧，但是在解决问题之后，会有自豪和幸福的感觉。</p><p id="d3ff" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我希望通过一点点的学习，它变得有趣和流畅。</p><p id="2f93" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">感谢您的阅读，并保持安全。再见。</p></div></div>    
</body>
</html>