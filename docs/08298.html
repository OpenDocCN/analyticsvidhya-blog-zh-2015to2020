<html>
<head>
<title>Road lane detection using OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于OpenCV的道路车道检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/road-lane-detection-using-opencv-3e2d2740a4d?source=collection_archive---------9-----------------------#2020-07-24">https://medium.com/analytics-vidhya/road-lane-detection-using-opencv-3e2d2740a4d?source=collection_archive---------9-----------------------#2020-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9253" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用OpenCV实现一个道路车道检测器。</p><p id="a373" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用精明的边缘检测器和霍夫线。它们的功能可以用OpenCV实现。</p><p id="5337" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于Canny边缘检测器的工作原理，请查看我的上一篇文章,在这篇文章中我对它进行了深入的解释。Canny边缘检测器在这个模型中起着至关重要的作用，因此拥有它的知识是有帮助的。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="3a59" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">模型管道</h2><p id="06b5" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">首先让我们导入Matplotlib、OpenCV和Numpy库。对于那些不知道Matplotlib是可视化工具而OpenCV是图像处理库的人来说。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="839f" class="jl jm hi kq b fi ku kv l kw kx">import <strong class="kq hj">matplotlib</strong>.pylab as plt<br/>import <strong class="kq hj">cv2</strong><br/>import <strong class="kq hj">numpy</strong> as np</span></pre><p id="31f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，该模型的管道将如下:<br/> 1。读取图像并将其转换为RGB格式。获取其高度和宽度，并定义车道检测所需的感兴趣区域。<br/> 2。然后将图像转换为灰度格式，因为Canny边缘检测器只接受灰度图像作为输入。将图像传递给Canny边缘检测器。<br/> 3。现在，通过前面定义的感兴趣区域来遮盖图像。<br/> 4。然后对图像应用Hough变换，Hough变换是一种特征提取技术，它给出了某一类形状内的对象的实例。在我们的例子中，形状将是一条线，因此我们将使用HoughLines函数。<br/> 5。最后，转换将返回检测到的线，我们将在我们的图像中绘制它作为输出。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="5160" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们制作一个辅助函数，它将图像遮蔽到感兴趣的区域。你可以不这样做，但这有助于获得更好的结果。我们只是在图像中定义我们感兴趣的区域。</p><p id="4b88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过给函数顶点和输入图像来屏蔽图像。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="92aa" class="jl jm hi kq b fi ku kv l kw kx">def <strong class="kq hj">region_of_interest</strong>(img,vertices): <br/>    mask = np.<strong class="kq hj">zeros_like</strong>(img) <br/>    channel_count=img.shape[2]         <br/>    match_mask_color=  255   #(255,) * channel_count<br/>    cv2.<strong class="kq hj">fillPoly</strong>(mask,vertices,match_mask_color)<br/>    masked_image=cv2.<strong class="kq hj">bitwise_and</strong>(img,mask) <br/>    return masked_image</span></pre><p id="95f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，让我们实现一个在图像上绘制给定线条的辅助函数。霍夫变换后需要画的线就可以了。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="d15a" class="jl jm hi kq b fi ku kv l kw kx">def <strong class="kq hj">draw_the_lines</strong>(img,lines): <br/>  imge=np.<strong class="kq hj">copy</strong>(img)     <br/>  blank_image=np.<strong class="kq hj">zeros</strong>((imge.shape[0],imge.shape[1],3),\<br/>                                                   dtype=np.uint8)<br/>  for line in lines:  <br/>    for x1,y1,x2,y2 in line:<br/>      cv2.<strong class="kq hj">line</strong>(blank_image,(x1,y1),(x2,y2),(0,255,0),thickness=3)<br/>      imge = cv2.<strong class="kq hj">addWeighted</strong>(imge,0.8,blank_image,1,0.0) <br/>  return imge</span><span id="d95d" class="jl jm hi kq b fi ky kv l kw kx">**<strong class="kq hj">Note</strong>: Mind the indents, as it could differ for your IDE. Code link would be provided at the end.</span></pre><p id="e011" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">cv2.line()用于在空白图像上绘制线条，这些线条通过cv2.addWeighted()添加到原始图像中。</p><p id="5b1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要进一步了解这些功能，请参考<a class="ae jd" href="https://opencv-python-tutroals.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">原始文档</a>。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="e755" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">概率霍夫线变换</h2><p id="233a" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">先来理解概率霍夫线变换。如果你对理论不感兴趣，你可以跳过这一节。</p><p id="67bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">霍夫变换是一种流行的检测任何形状的技术，只要你能用数学形式来表示它。它可以检测形状，即使它被打破或扭曲了一点点。<br/>如需深入了解，请参考官方<a class="ae jd" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghlines/py_houghlines.html?highlight=houghlinesp" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="c8db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，一条线可以表示为p= x cosQ + y sinQ，其中p是垂直距离，Q是它与x轴所成的角度。</p><p id="305e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在霍夫线变换中，我们创建一个具有两列和多行的数组，其中列表示p和Q的值，这些值最初被设置为零。<br/>数组的大小取决于我们想要的精度，现在从给定的Canny边缘图像，我们在所有边缘点上迭代这些不同的p和Q值，并推导出最佳连续线，保存p和Q的值。稍后这将用于在原始图像上画线。</p><p id="3d97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">概率霍夫变换是霍夫变换的一种优化。它不考虑所有的边缘点，而是只考虑点的随机子集，这对于线检测是足够的。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="b92b" class="jl jm hi kq b fi ku kv l kw kx"> cv2.<strong class="kq hj">HoughLinesP</strong>(edges,rho,theta,threshold,minLineLength,maxLineGap)</span></pre><p id="bae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">‘edges’</strong>是边缘图像，<strong class="ih hj">‘rho’</strong>是p或垂直距离。<br/> <strong class="ih hj"> 'np.pi/180' </strong>是<strong class="ih hj"> theta </strong>的取值范围或者以弧度表示的角度，这里是-180到180。<br/> <strong class="ih hj">【阈值】</strong>需要根据图像进行微调。<br/> ' <strong class="ih hj"> minLineLength </strong>'是直线的最小长度，短于此长度的线段将被拒绝。<br/> ' <strong class="ih hj"> maxLinGap </strong>'是线段之间的最大允许间隙，将它们视为一条直线。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="7265" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用的输入图像是:</p><figure class="kl km kn ko fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kz"><img src="../Images/2f36a07fd355efe5fdab77bd0577a4ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTOydMnvcxnn_EcAdQUVOg.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">img.png</figcaption></figure><p id="882d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤1 </strong>:读取图像，转换成RGB格式。获取其高度和宽度，并定义车道检测所需的感兴趣区域。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="8e39" class="jl jm hi kq b fi ku kv l kw kx">image=cv2.<strong class="kq hj">imread</strong>('img.png')<br/>image=cv2.<strong class="kq hj">cvtColor</strong>(image,cv2.COLOR_BGR2RGB)<br/>height=image.shape[0]<br/>width=image.shape[1]<br/>region_of_interest_coor=[(0,height),(0,400),(width/2,height/3),\     <br/>                                                     (width,height)]</span></pre><p id="26a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步</strong>:将图像转换成灰色格式，传给Canny。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="de61" class="jl jm hi kq b fi ku kv l kw kx">gray_image = cv2.<strong class="kq hj">cvtColor</strong>(image,cv2.COLOR_RGB2GRAY)<br/>canny_image = cv2.<strong class="kq hj">Canny</strong>(gray_image,100,200)</span></pre><p id="8f1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Step3: </strong>现在，用之前定义的感兴趣区域来遮罩canny图像。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="4b56" class="jl jm hi kq b fi ku kv l kw kx">cropped=<strong class="kq hj">region_of_interest</strong>(canny_image,\<br/>np.array([region_of_interest_coor],np.int32))</span></pre><p id="1d6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤4: </strong>对掩蔽后的canny图像应用概率霍夫线变换。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="1cd2" class="jl jm hi kq b fi ku kv l kw kx">lines = cv2.<strong class="kq hj">HoughLinesP</strong>(cropped,rho=2,theta=np.pi/120,threshold=120\<br/>,lines=np.array([]),minLineLength=20,maxLineGap=35)</span></pre><p id="2445" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤5 </strong>:使用HoughLinesP()返回的“线条”通过之前定义的draw_the_lines()绘制线条，并绘制结果图像。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="ddda" class="jl jm hi kq b fi ku kv l kw kx">image_with_lines = <strong class="kq hj">draw_the_lines</strong>(image,lines) plt.<strong class="kq hj">imshow</strong>(image_with_lines)<br/>plt.<strong class="kq hj">show</strong>()</span></pre><figure class="kl km kn ko fd la er es paragraph-image"><div class="er es ll"><img src="../Images/6e17208f61d7e7d1bfb6a22ea163d602.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*sMYd4AMWxmrWFmbDs8WV5A.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx translated">输出图像:“带有线条的图像”</figcaption></figure><p id="86ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这总结了模型的实现。这里是<a class="ae jd" href="https://github.com/negiaditya/PROJECT-Road_Lane_detection/blob/master/detector.py" rel="noopener ugc nofollow" target="_blank">代码</a>。</p><p id="47a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以很容易地扩大到视频或实时。我们只需要使用cv2。VideoCapture('vid.mp4 ')函数返回逐帧图像，每个图像都可以通过我们刚刚创建的模型。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="0df8" class="jl jm hi kq b fi ku kv l kw kx">cap = cv2.<strong class="kq hj">VideoCapture</strong>('video.mp4')</span><span id="79f9" class="jl jm hi kq b fi ky kv l kw kx">while cap.<strong class="kq hj">isOpened</strong>():<br/>   ret, frame = cap.<strong class="kq hj">read</strong>()    <br/>   frame = process(frame)    <br/>   cv2.<strong class="kq hj">imshow</strong>('frame', frame)    <br/>   if cv2.<strong class="kq hj">waitKey</strong>(1) &amp; 0xFF == ord('q'):<br/>      break </span><span id="39f6" class="jl jm hi kq b fi ky kv l kw kx">cap.<strong class="kq hj">release</strong>()<br/>cv2.<strong class="kq hj">destroyAllWindows</strong>()</span></pre><p id="6d6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“cap”具有通过函数过程()的图像的每一帧，即我们创建的车道检测模型。</p><figure class="kl km kn ko fd la"><div class="bz dy l di"><div class="lm ln l"/></div><figcaption class="lh li et er es lj lk bd b be z dx translated">看看这个视频的视频结果。</figcaption></figure><p id="d5b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经实现了它，代码可以在这里找到<a class="ae jd" href="https://github.com/negiaditya/PROJECT-Road_Lane_detection/blob/master/video.py" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="e571" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我想感谢<a class="ae jd" href="https://www.youtube.com/channel/UCs6nmQViDpUw0nuIx9c_WvA" rel="noopener ugc nofollow" target="_blank">的编程知识</a>对他们工作的贡献。</p><p id="bffa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢你的阅读，如果你喜欢这篇文章，请鼓掌，你可以在这里阅读更多这样的文章。</p><p id="f185" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">干杯！<br/>快乐学习！</p></div></div>    
</body>
</html>