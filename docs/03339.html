<html>
<head>
<title>Finding the Minimum Index of an Array for Which the Sum of the Left and Right Sides are Equal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找左右两边之和相等的数组的最小索引</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/finding-the-minimum-index-of-an-array-for-which-the-sum-of-the-left-and-right-sides-are-equal-3feaa7dd7114?source=collection_archive---------21-----------------------#2020-01-26">https://medium.com/analytics-vidhya/finding-the-minimum-index-of-an-array-for-which-the-sum-of-the-left-and-right-sides-are-equal-3feaa7dd7114?source=collection_archive---------21-----------------------#2020-01-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3d81e1684965e23dda4f852c5f8b24d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*riu4VD6NR85ogKuuGlzYPw.jpeg"/></div></div></figure><p id="66fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也称为平衡数组索引或数组的平衡索引，这对于初学者来说是一个简单而有趣的问题。我第一次看到它是在Codewars (6 kyu)上，发现它很有趣。</p><h1 id="e927" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">问题是</h1><p id="919b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">对于还没有遇到这个问题的人来说，它是这样的:给你一个数组，让你创建一个函数，找到左边整数之和等于右边整数之和的索引。如果没有这样的数字，您的函数应该返回-1的输出。</p><p id="aa8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，在尝试解决问题之前，我们将分析问题。我更喜欢用简单的英语写下每一步，这样我就能知道哪些步骤有意义，哪些没有意义。</p><h1 id="bbac" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">分析问题</h1><p id="cf02" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">假设给我们以下数组:[1，2，3，4，5，6，5，4，3，2，1]作为输入，并让我们创建一个函数，返回左侧平衡右侧的最小索引。</p><p id="c666" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查看我们的数组，我们可以很容易地判断出我们的输出应该是5，表示整数‘6’的索引(记住Python索引是从0开始的)。这很简单，但是如果我们有一个更长的数组或者一个更大的数组呢？现在我们需要一个解决方案！</p><p id="6aea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，从我们的问题中，我们知道两件事:</p><ol class=""><li id="60a0" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz bi translated">从数组的左侧开始，我们必须沿着数组的全长移动，检查每个数字，直到找到中点的那个数字。</li><li id="23f5" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">这将意味着获取这些数字的增量总和，并检查左侧是否等于右侧。例如，在我们的数组中，我们将取0和1的和，将其与1右侧数字的和进行比较，将1和2的和与2右侧数字的和进行比较，取1、2和3的和，将其与3右侧数字的和进行比较，以此类推，直到我们找到一个数字，其中它之前的数字的和与它之后的数字的和相等。</li></ol><h1 id="486a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">解决方案</h1><p id="9501" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">从编写的步骤来看，很明显我们需要一个for循环来遍历整个数组。我们将在以下步骤中使用索引切片方法:</p><ol class=""><li id="29d6" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz bi translated">定义函数。</li><li id="804e" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">创建一个for循环来循环访问数组。</li><li id="79c2" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">编写一个if语句，比较我们分析的每个索引之前的索引位置和之后的索引位置，如果两者相等，则返回索引位置。</li><li id="2fe9" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">如果数组中没有左右两边相等的索引，则在for循环中返回-1。</li><li id="07dd" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">测试我们的功能。首先，我们定义函数find_midpoint_index，它接受一个参数arr。</li></ol><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/1feae4397c8e73766e4b4b3e736bbbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3SNB0bk5oI3FNJkp01XGA.png"/></div></figure><p id="0225" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将for循环设置为遍历整个数组。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/f7e9bd9b2a9a1cc3d5eb97ea620ea128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGNKQTS2guIwXtW8CYL8OA.png"/></div></div></figure><p id="f16e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们需要一种方法来告诉计算机在沿着数组移动时比较左右两边的总和。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/90ee0f3723a20f0465b8ffb026bcd6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTx-lCaxFH1kJ_BWmxfBXg.png"/></div></div></figure><p id="e274" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单地说，上面的表达式仅仅意味着程序将检查每个索引位置(I)中的数字。如果当前正在检查的索引位置之前的所有数字的总和等于它之后的数字的总和，它将返回该索引作为输出。注意，我们返回的不是整数本身，而是它所占据的索引位置。</p><p id="41fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看整个事情。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/2c03b964942eab0861da7349293b2d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3ufdBynnp31bT9nkpgnyA.png"/></div></div></figure><p id="2423" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果for循环中的条件没有得到执行的机会，我们将返回-1作为输出。</p><p id="85aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们测试我们的功能。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/3e71bd5c4dda15f5525ebd3d7538cbe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjIqIuFP_8Q6drEt3qf-sQ.png"/></div></div></figure><p id="e71d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个函数调用返回5，而第二个函数调用返回-1，因为没有找到中点。</p></div></div>    
</body>
</html>