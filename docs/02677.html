<html>
<head>
<title>Dynamic Programming(DP), Recursion and DFS with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现动态编程、递归和DFS</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/top-down-dp-python-recursion-and-dp-recursion-and-dfs-3daa5b36ee4d?source=collection_archive---------11-----------------------#2019-12-28">https://medium.com/analytics-vidhya/top-down-dp-python-recursion-and-dp-recursion-and-dfs-3daa5b36ee4d?source=collection_archive---------11-----------------------#2019-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1199" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">自上而下/自下而上的方法；递归和DP；递归和DFS</h2></div><p id="06cc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天我解决了一个新的Leetcode问题。它非常接近于经典的DP问题</p><p id="8440" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">"网格左上角到右下角之间的最短路径"</p><p id="d2f5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于这个经典问题的更多信息可以在这里找到:</p><div class="jt ju ez fb jv jw"><a rel="noopener follow" target="_blank" href="/@tiagot/dynamic-programming-an-induction-approach-b5c5e73c4a19"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">动态规划:归纳方法</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">动态编程(DP)是一种通用编程技术，它使用记忆来解决问题，可以…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk kl jw"/></div></div></a></div><p id="152c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个问题是:</p><p id="1ac3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1301.得分最高的路径数</p><p id="dceb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae km" href="https://leetcode.com/problems/number-of-paths-with-max-score/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/number-of-path-with-max-score/</a></p><p id="c2b6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是我的分析。</p><h2 id="5556" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">自上而下差压</h2><p id="cc50" class="pw-post-body-paragraph ix iy hi iz b ja li ij jc jd lj im jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">如果我们有四个像这样的单元格:<br/> O A <br/> B C <br/>那么，<br/> DP(O) =来自{DP(A)，DP(B)，DP(C)} + int(grid[O])的最大路径和</p><p id="2f40" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们有一个图来显示高层次的逐层探索过程，这个图会是这样的。那么从这个vis就很清楚，这个算法的复杂度是O(RC)或者O(mn)。在实际的探索过程中，它不会完全以这种方式进行探索，相反，它将遵循DFS方法，如下所示。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div class="er es ln"><img src="../Images/eb150f4055e88810115bc857faf61983.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/0*i7LRRemFA_ZN1m1B.png"/></div></figure><p id="c3a2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以从多个子状态中获得最大和，请将它们合并以保证正确性。</p><p id="c934" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们能达到(R-1，C-1)当R是总行数，C是总列数时，它是可达的。</p><p id="6cc9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自上而下差压(332毫秒)</p><pre class="lo lp lq lr fd lu lv lw lx aw ly bi"><span id="1c9c" class="kn ko hi lv b fi lz ma l mb mc">from functools import lru_cache<br/>class Solution:<br/>    def pathsWithMaxScore(self, grid: List[str]) -&gt; List[int]:<br/>        grid[0] = "0"+grid[0][1:]<br/>        R, C = len(grid), len(grid[0])<br/>        self.reachable = False<br/>        @lru_cache(None)<br/>        def dp(i, j):<br/>            if i==R-1 and j==C-1:<br/>                self.reachable=True<br/>                return [0, 1]<br/>            substates = [(i+1,j), (i,j+1),(i+1,j+1)]<br/>            valid_substates = [[r,c] for r, c in substates if 0&lt;=r&lt;R and 0&lt;=c&lt;C and grid[r][c]!='X']<br/>            if not valid_substates:return [0, 0]<br/>            results = [dp(r, c) for r,c in valid_substates]<br/>            max_path_sum, _ = max(results)<br/>            path_cnt = sum(this_path_cnt for this_path_sum, this_path_cnt in results if this_path_sum==max_path_sum)<br/>            return [max_path_sum+int(grid[i][j]), path_cnt%(10**9+7)]<br/>        <br/>        res = dp(0, 0)<br/>        return res if self.reachable else [0,0]</span></pre><h2 id="2d30" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated"><strong class="ak">自下而上DP 1(232毫秒)</strong></h2><p id="d3f2" class="pw-post-body-paragraph ix iy hi iz b ja li ij jc jd lj im jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">从图中，我们可以很容易地找出自下而上的顺序来生成正确的结果。顺序是:</p><p id="da70" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从(N-1，N-1)开始，求解包含整列网格[N-1，:]和整行网格[:，N-1]的每一层</p><p id="e489" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们应该在对角线(k，k)上这样做，其中k是从N-1到0。</p><pre class="lo lp lq lr fd lu lv lw lx aw ly bi"><span id="8afd" class="kn ko hi lv b fi lz ma l mb mc">class Solution:<br/>    def pathsWithMaxScore(self, grid: List[str]) -&gt; List[int]:<br/>        grid[0] = "0"+grid[0][1:]<br/>        N = len(grid)<br/>        <br/>        def get_this_res(i, j):<br/>            if grid[i][j] == 'X':return [-float('inf'), 0]<br/>            if i==N-1 and j==N-1:return [0, 1]<br/>            results = [dp[i+di][j+dj] for di, dj in [(1,0),(0,1),(1,1)]]<br/>            max_path_sum, _ = max(results)<br/>            max_path_sum_cnt = sum(this_path_cnt for this_path_sum, this_path_cnt in results if this_path_sum==max_path_sum)<br/>            return [max_path_sum+int(grid[i][j]), max_path_sum_cnt%(10**9+7)]<br/>            <br/>        dp = [[[-float('inf'), 0] for j in range(N+1)] for i in range(N+1)]<br/>        for k in range(N-1, -1, -1):<br/>            for i in range(k, -1, -1):<br/>                dp[i][k] = get_this_res(i, k)<br/>            for j in range(k, -1, -1):<br/>                dp[k][j] = get_this_res(k, j)<br/>        return dp[0][0] if dp[0][0][0]!=-float('inf') else [0, 0]</span></pre><p id="8c72" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们也可以一列一列地做。顺序是从最后一列到第一列。对于每一列，我们应该从最后一行到第一行。</p><h2 id="6574" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated"><strong class="ak">自下而上DP 2(280毫秒)</strong></h2><pre class="lo lp lq lr fd lu lv lw lx aw ly bi"><span id="2328" class="kn ko hi lv b fi lz ma l mb mc">class Solution:<br/>    def pathsWithMaxScore(self, grid: List[str]) -&gt; List[int]:<br/>        grid[0] = "0"+grid[0][1:]<br/>        N = len(grid)<br/>        <br/>        def get_this_res(i, j):<br/>            if grid[i][j] == 'X':return [-float('inf'), 0]<br/>            if i==N-1 and j==N-1:return [0, 1]<br/>            results = [dp[i+di][j+dj] for di, dj in [(1,0),(0,1),(1,1)]]<br/>            max_path_sum, _ = max(results)<br/>			# combine the path_cnt, think about this case results = [[2,1], [2,1], [1,1]], the path_cnt shoule be 1+1 not 1.<br/>            max_path_sum_cnt = sum(this_path_cnt for this_path_sum, this_path_cnt in results if this_path_sum==max_path_sum)<br/>            return [max_path_sum+int(grid[i][j]), max_path_sum_cnt%(10**9+7)]<br/>        <br/>        # use N+1 by N+1 to get rid of out of boundary issue<br/>        dp = [[[-float('inf'), 0] for j in range(N+1)] for i in range(N+1)]<br/>        for j in range(N-1, -1, -1):<br/>            for i in range(N-1, -1, -1):<br/>                dp[i][j] = get_this_res(i, j)<br/>        return dp[0][0] if dp[0][0][0]!=-float('inf') else [0, 0]</span></pre><h1 id="8cb8" class="md ko hi bd kp me mf mg kt mh mi mj kx io mk ip la ir ml is ld iu mm iv lg mn bi translated">递归和DP；递归和DFS</h1><p id="4800" class="pw-post-body-paragraph ix iy hi iz b ja li ij jc jd lj im jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">如果我们想要探索自底向上的DP过程，我们可以使用这个测试用例，基于上面的代码打印出I，j:<br/>[" E111 "，" 1111 "，" 1111 "，" 111S"] <br/>我们将得到下面的输出:</p><pre class="lo lp lq lr fd lu lv lw lx aw ly bi"><span id="077a" class="kn ko hi lv b fi lz ma l mb mc">step  0 :  0 0<br/>step  1 :  1 0<br/>step  2 :  2 0<br/>step  3 :  3 0<br/>step  4 :  3 1<br/>step  5 :  3 2<br/>step  6 :  3 3<br/>step  7 :  2 1<br/>step  8 :  2 2<br/>step  9 :  2 3<br/>step 10 :  1 1<br/>step 11 :  1 2<br/>step 12 :  1 3<br/>step 13 :  0 1<br/>step 14 :  0 2<br/>step 15 :  0 3</span></pre><p id="7a4f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">探索顺序可以这样解释:<br/>为了求解dp( <strong class="iz hj"> 0，0 </strong>)，我们需要dp( <strong class="iz hj"> 1，0 </strong>)，dp(0，1)，dp(1，1)。<br/>为了得到dp( <strong class="iz hj"> 1，0 </strong>)，我们需要dp( <strong class="iz hj"> 2，0 </strong>)、dp(1，1)和dp(2，1) <br/>为了得到dp( <strong class="iz hj"> 2，0 </strong>)，我们需要dp( <strong class="iz hj"> 3，0 </strong>)、dp(2，1)和dp(3，1) 【T15)为了得到dp( <strong class="iz hj"> 3，0 </strong>)，我们需要DP() 我们需要dp( <strong class="iz hj"> 3，2 </strong> ) <br/>为了得到dp( <strong class="iz hj"> 3，2 </strong>)，我们需要dp( <strong class="iz hj"> 3，3 </strong> ) <br/>既然触底了，我们回过头来求解dp(2，1) <br/>为了得到dp( <strong class="iz hj"> 2，1 </strong>)，我们需要dp(3，1)，dp(2，2)，dp(3，2)。 由于只有dp(2，2)没有做，我们需要根据dp(3，2)，dp(2，3)，dp(3，3)求解<br/> dp( <strong class="iz hj"> 2，2 </strong>)。由于只有dp(2，3)没有做，我们需要根据dp(3，3)求解<br/> dp( <strong class="iz hj"> 2，3 </strong>)。dp(3，3)已经解决了，我们又回到了<br/> dp( <strong class="iz hj"> 1，1</strong>)<br/>……<br/>从这个例子中，我希望我们可以对:</p><ol class=""><li id="5a06" class="mo mp hi iz b ja jb jd je jg mq jk mr jo ms js mt mu mv mw bi translated"><strong class="iz hj">递归与DP </strong>的关系</li><li id="8450" class="mo mp hi iz b ja mx jd my jg mz jk na jo nb js mt mu mv mw bi translated"><strong class="iz hj">递归和DFS </strong>之间的关系</li></ol><p id="579e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望有帮助。谢了。</p><p id="5683" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">附言</p><ol class=""><li id="e326" class="mo mp hi iz b ja jb jd je jg mq jk mr jo ms js mt mu mv mw bi translated">代码输出I和j</li></ol><pre class="lo lp lq lr fd lu lv lw lx aw ly bi"><span id="1952" class="kn ko hi lv b fi lz ma l mb mc">from functools import lru_cache<br/>class Solution:<br/>    def pathsWithMaxScore(self, grid: List[str]) -&gt; List[int]:<br/>        grid[0] = "0"+grid[0][1:]<br/>        R, C = len(grid), len(grid[0])<br/>        self.reachable = False<br/>        self.step = 0<br/>        @lru_cache(None)<br/>        def dp(i, j):<br/>            print("step {:2d}".format(self.step),": ", i, j)<br/>            self.step += 1<br/>            if i==R-1 and j==C-1:<br/>                self.reachable=True<br/>                return [0, 1]<br/>            candidates = [(i+1,j), (i,j+1),(i+1,j+1)]<br/>            valids = [[r,c] for r, c in candidates if 0&lt;=r&lt;R and 0&lt;=c&lt;C and grid[r][c]!='X']<br/>            if not valids:return [0, 0]<br/>            results = [dp(r, c) for r,c in valids]<br/>            max_sum, _ = max(results)<br/>            cnt = sum(this_cnt for this_sum, this_cnt in results if this_sum==max_sum)<br/>            this_res= [max_sum+int(grid[i][j]), cnt%(10**9+7)]<br/>            return this_res<br/>        <br/>        res = dp(0, 0)<br/>        return res if self.reachable else [0,0]</span></pre><ol class=""><li id="aef1" class="mo mp hi iz b ja jb jd je jg mq jk mr jo ms js mt mu mv mw bi translated">天真的BFS会明白的。</li></ol><pre class="lo lp lq lr fd lu lv lw lx aw ly bi"><span id="e9fc" class="kn ko hi lv b fi lz ma l mb mc">class Solution:<br/>    def pathsWithMaxScore(self, grid: List[str]) -&gt; List[int]:<br/>        grid[0] = "0"+grid[0][1:]<br/>        R, C = len(grid), len(grid[0])<br/>        dp = [[collections.defaultdict(int) for j in range(C)] for i in range(R)]<br/>        def bfs():<br/>            from collections import deque<br/>            Q = deque([(R-1, C-1, 0, 1)])<br/>            while Q:<br/>                i, j, path_sum, path_cnt = Q.popleft()<br/>                for di, dj in [(-1,0),(0,-1),(-1,-1)]:<br/>                    r,c  = i+di, j+dj<br/>                    if 0&lt;=r&lt;R and 0&lt;=c&lt;C and grid[r][c]!='X':<br/>                        this_path_sum, this_path_cnt = path_sum+int(grid[r][c]), path_cnt<br/>                        dp[r][c][this_path_sum] += this_path_cnt<br/>                        Q.append((r,c,this_path_sum, this_path_cnt))<br/>            values = sum(dp[0][0][key] for key in dp[0][0])<br/>            if values==0:return [0,0]<br/>            max_k = max(dp[0][0].keys())<br/>            return [max_k, dp[0][0][max_k]%(10**9+7)]<br/>        return bfs()</span></pre></div></div>    
</body>
</html>