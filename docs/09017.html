<html>
<head>
<title>Versioning a system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">版本化系统</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/versioning-a-system-3aa012d047eb?source=collection_archive---------15-----------------------#2020-08-22">https://medium.com/analytics-vidhya/versioning-a-system-3aa012d047eb?source=collection_archive---------15-----------------------#2020-08-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d2e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对接口进行版本控制只是一种“礼貌的”方式来杀死已部署的客户端<br/>——Django Rest框架</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/e2f9c5a1caf80f69eafb0875415d3e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNkNZed09Kf7gk9hY7eTVQ.png"/></div></div></figure></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><blockquote class="jx jy jz"><p id="4185" class="if ig jd ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated">为什么要版本化</p></blockquote><p id="5459" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当我们需要做一些不向后兼容的API改变时，例如:请求参数/头或响应对象的结构被改变</p><p id="9f42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通常不会面临网站的许多问题，因为我们可以部署前端系统，最终用户将有一个更新的系统来工作。</p><p id="3c68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，<br/>对于应用程序(移动或桌面)，更新不会同时发生，因为它取决于用户何时更新应用程序，因此我们也需要支持旧版本的应用程序<strong class="ih hj">和版本</strong>。</p><p id="5f65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">用更简单的话来说:</em> <br/>推出的新更新将适用于新版本的应用程序，同时保持API与旧版本的兼容。</p><blockquote class="kd"><p id="7917" class="ke kf hi bd kg kh ki kj kk kl km jc dx translated">两种常见的版本控制方法</p></blockquote><blockquote class="jx jy jz"><p id="5ebe" class="if ig jd ih b ii kn ik il im ko io ip ka kp is it kb kq iw ix kc kr ja jb jc hb bi translated">1:为每个版本创建不同的目录，并使用路由进行调度</p></blockquote><p id="a13a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤1:开发web应用程序</strong> <br/>假设您已经开发了一个简单的应用程序，其目录结构如下:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ks"><img src="../Images/059d6da268837c35586968748f84a041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rBtoU4SBbozN7yCdz4IOw.png"/></div></div></figure><p id="40cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第2步:根据推出的变更进行版本控制</strong> <br/>现在，您的应用程序的不同版本如下:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kt"><img src="../Images/5415e60fb21aa81dd5ec6738d642ff33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YhZ5VZLhUV2xweixCkfoXQ.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">v1和v2代表应用程序的版本1和版本2</figcaption></figure><p id="622b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:每个版本都有自己的代码来运行应用程序</p><p id="05f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第三步:创建派工文件</strong></p><p id="9774" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在base.urls中，您可以编写调度文件，例如:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ky"><img src="../Images/0627d8366f1f4e5279f6549689aafee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMzGa9FrDa1Lxzti1Uzx9w.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">对api/v1/*的调用将被定向到系统的v1</figcaption></figure><p id="6baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为凡事都有利弊，所以这种方法也是如此:</p><p id="51cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优点:</strong> <br/> 1:更少的if-else语句，因此代码可读性更好</p><p id="22e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">缺点:</strong> <br/> 1:代码冗余<br/> 2:由于代码嵌套而难以调试<br/> 3:如果做了一些常见的更改，那么需要复制它</p><blockquote class="jx jy jz"><p id="80ee" class="if ig jd ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated">2:使用代码级版本控制:</p></blockquote><p id="5a5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法将在请求本身中附加版本，您将能够像这样使用它:<br/><strong class="ih hj"><em class="jd">request . version<br/></em></strong>它将返回v1或v2或您在实现这种版本控制时设置的任何字符串。</p><p id="7e8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍后我将解释代码级版本控制实际上是如何完成的，但是现在，现在，让我们假设您已经实现了代码级版本控制。</p><p id="1256" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实现之后，您可以应用if-else语句来返回基于版本的序列化响应。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kz"><img src="../Images/f1c5432b0f6d462f785331d8c9bc589c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73JJ4o4ElRhnQjtFk_CJJw.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">假设您有两个客户序列化器，它们返回不同结构的数据</figcaption></figure><p id="e174" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此不需要为每个版本创建自己的目录等。</p><p id="de5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> - &gt;实现代码级版本化:</em> </strong></p><p id="91c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解释这一点，我将使用Django Rest框架示例:</p><p id="8e11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一步:</strong>你需要在settings.py中定义你将使用哪种版本，选项有:<br/>1:accept header versioning<br/>2:urlpath versioning<br/>3:namespace versioning<br/>4:hostname versioning<br/>5:query parameter versioning</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es la"><img src="../Images/318d9485ca20251322812ce3705b6c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_euMJdmf8nrphvDFbOsBsg.png"/></div></div></figure><p id="2498" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步</strong>:使用</p><p id="4634" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面解释的方法只是让Django知道请求连接到哪个版本的不同方式，您可以使用下面解释的任何方法:</p><p id="7017" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">1:accept header version</strong></p><p id="be6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种版本控制方法中，<strong class="ih hj">您需要在Accept报头</strong>中将版本指定为媒体类型的一部分</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lb"><img src="../Images/33b8e2c0d6ef1b3b08dc24388a162d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sah_bf_7NUxliUumlHRSIw.png"/></div></div></figure><p id="bd29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，您可以使用上面解释的request.version</p><p id="4c1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2: URLPathVersioning </strong></p><p id="d2e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种方法中，您需要在URL中指定版本，如下所示</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lc"><img src="../Images/a53b658feaeae5d600af945e0c5e2089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWiM92JbH05ndZa4mEUWcA.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/e4617164116afcbc292003e343f0e723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mqb_urCxg5e8s8Lr5VMMA.png"/></div></div></figure><p id="38ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3:命名空间版本</strong> ( <em class="jd">个人喜好</em>)</p><p id="0407" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此方法中，您需要在URL中指定类似于UrlPathVersioning的版本</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lc"><img src="../Images/a53b658feaeae5d600af945e0c5e2089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWiM92JbH05ndZa4mEUWcA.png"/></div></div></figure><p id="04d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而<code class="du le lf lg lh b">request.version</code>是基于与传入请求匹配的<code class="du le lf lg lh b">namespace</code>来确定的(如下所示)</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es li"><img src="../Images/b5962d0fb0ce8fae9f2516fb7b0c57ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OfuNSIpP_CW-qhkb_TLHQ.png"/></div></div></figure><p id="024d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4:主机名版本</strong></p><p id="b6d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种方法中，版本是在主机本身中定义的</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lj"><img src="../Images/523c625af48fa1ac6082c4d5d302c69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3eioDdv7iRNAn9YJG-_0Iw.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">版本:v1</figcaption></figure><p id="da89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 5:查询参数版本</strong></p><p id="3781" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此方案是一种简单的样式，它将版本作为查询参数包含在URL中，如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lk"><img src="../Images/1dd3e35104fb823da650583ced52423c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2AYeu7YyXE8lLPt_AYkCQ.png"/></div></div></figure><p id="28ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优点:</strong> <br/> 1:没有代码冗余<br/> 2:代码调试和可维护性更容易</p><p id="a860" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点:<br/>1:if-else语句越多，代码越不直观</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="35bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你读得很好:)</p></div></div>    
</body>
</html>