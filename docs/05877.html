<html>
<head>
<title>JavaScript — Coding the smart way!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript——聪明地编码！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/javascript-coding-the-smart-way-2fb040c902c2?source=collection_archive---------24-----------------------#2020-05-04">https://medium.com/analytics-vidhya/javascript-coding-the-smart-way-2fb040c902c2?source=collection_archive---------24-----------------------#2020-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="618b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">让您的JavaScript更加智能和健壮的一些技巧。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/719ff15dac1adef13f3c5230b43a722d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-c6iFdO4x2nhTezSxN0TYg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/@andrewtneel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安德鲁·尼尔</a>在<a class="ae jn" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="882a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">随着时间的推移，JavaScript越来越受欢迎。甚至连布伦丹·艾希自己都没有想到这种愚蠢可爱的语言会如此受欢迎。因此，作为JavaScript开发人员，我们有义务将对智能JavaScript技术的学习传承下去。</p><blockquote class="kl km kn"><p id="9c48" class="jo jp kk jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">正如道格拉斯·克洛克福特所说—<br/>“JavaScript是我所知道的唯一一种人们觉得在开始使用之前不需要学习的语言。”</p></blockquote><p id="cfe8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">强调这句话——“人们觉得他们不需要学习”<br/>拥有4年多的JavaScript编码经验，我仍然觉得有很多东西需要学习和适应。JavaScript永远不会停止给你带来惊喜。</p><p id="0b56" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">说够了！让我们现在开始行动吧。因此，我将在这里分享一些在日常编码中有用的经验。使用这些技巧和示例，您将能够编写更加智能和健壮的代码。</p><h1 id="0a7a" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">先决条件</h1><p id="aca6" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">本文面向已经熟悉任何格式的JavaScript代码(如TypeScript、JSX等)或者有这方面经验的开发人员。我假设您已经熟悉现代JavaScript(后ES6)语法、概念和其他基本的JavaScript要素。</p><p id="9d95" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你是一个有抱负的Web开发人员，并且不太适应最新的JavaScript生活标准。我建议你浏览下面的链接，尽快修改这些内容。</p><div class="lo lp ez fb lq lr"><a href="https://www.freecodecamp.org/news/write-less-do-more-with-javascript-es6-5fd4a8e50ee2/" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab dw"><div class="lt ab lu cl cj lv"><h2 class="bd hj fi z dy lw ea eb lx ed ef hh bi translated">JavaScript ES6 -写得更少，做得更多</h2><div class="ly l"><h3 class="bd b fi z dy lw ea eb lx ed ef dx translated">JavaScript ES6带来了新的语法和令人惊叹的新特性，使您的代码更加现代，可读性更好。它允许…</h3></div><div class="lz l"><p class="bd b fp z dy lw ea eb lx ed ef dx translated">www.freecodecamp.org</p></div></div><div class="ma l"><div class="mb l mc md me ma mf jh lr"/></div></div></a></div><p id="4d72" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">ES6和ES7语法是编写智能代码的基础。它给了你少写多做的力量。</p><h1 id="524f" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">1.类型检查</h1><p id="feea" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">JavaScript中的类型是最容易被误解的概念之一，理解它们是如何工作的很重要。</p><h2 id="8d49" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">a.<strong class="ak">类型的</strong>操作符</h2><p id="78e8" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated"><code class="du mu mv mw mx b">typeof</code>操作符返回一个字符串，表示给定值的JavaScript类型。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">JavaScript中可用的不同数据类型</figcaption></figure><h2 id="6a5b" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">b.相等运算符</h2><p id="c482" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">等号运算符由两个等号组成<code class="du mu mv mw mx b">==</code> <br/> JavaScript具有弱类型特性。这意味着相等运算符转换<code class="du mu mv mw mx b">types</code>是为了比较它们。此外，当类型被转换时，性能也会受到影响。<br/>例如，在与另一个数字进行比较之前，<code class="du mu mv mw mx b">string</code>必须转换为<code class="du mu mv mw mx b">number</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="b4af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以，永远不要使用等式操作符，因为它可能会导致难以跟踪的错误。相反，使用严格的等式运算符<code class="du mu mv mw mx b">===</code></p><p id="d372" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们在我们的智能代码中使用这些类型和等式检查。</p><h2 id="508d" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">c.函数中的类型检查</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">如果参数不是数字，你抛出一个错误。</figcaption></figure><h2 id="0f2b" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">d.类型转换</h2><ul class=""><li id="203c" class="na nb hi jq b jr lj ju lk jx nc kb nd kf ne kj nf ng nh ni bi translated"><strong class="jq hj">铸造要数。如果您曾经使用过原生html表单，那么您可能知道从表单输入标签中读取值的痛苦。</strong></li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nj mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">说明为什么需要类型转换的例子。</figcaption></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在这里，使用加号运算符会在将值赋给变量之前将其转换为数字。</figcaption></figure><ul class=""><li id="9997" class="na nb hi jq b jr js ju jv jx nk kb nl kf nm kj nf ng nh ni bi translated"><strong class="jq hj">铸造成串。<br/> </strong>无需使用<code class="du mu mv mw mx b">toString()</code>方法。只需在前面加上一个空字符串，任何数字都可以转换成字符串。</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">只需将您的号码添加到空字符串中。</figcaption></figure></div><div class="ab cl nn no gp np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hb hc hd he hf"><h1 id="5e92" class="kr ks hi bd kt ku nu kw kx ky nv la lb io nw ip ld ir nx is lf iu ny iv lh li bi translated">2.无效支票</h1><p id="38b9" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">根据我的经验，我可以说，如果我们在适当的位置添加适当的空值检查，许多损坏的脚本和错误是可以避免的。人们不应该总是盲目地相信那些吹牛大王。有错误，还有那些生产缺陷！空检查在UI中也很重要。</p><h2 id="28ca" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">a.原始值</h2><p id="69cd" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">以下是所有的<code class="du mu mv mw mx b">falsy</code>值-</p><ul class=""><li id="df02" class="na nb hi jq b jr js ju jv jx nk kb nl kf nm kj nf ng nh ni bi translated"><code class="du mu mv mw mx b">null</code></li><li id="20f3" class="na nb hi jq b jr nz ju oa jx ob kb oc kf od kj nf ng nh ni bi translated"><code class="du mu mv mw mx b">undefined</code></li><li id="6098" class="na nb hi jq b jr nz ju oa jx ob kb oc kf od kj nf ng nh ni bi translated"><code class="du mu mv mw mx b">'’</code>空弦</li><li id="eb65" class="na nb hi jq b jr nz ju oa jx ob kb oc kf od kj nf ng nh ni bi translated"><code class="du mu mv mw mx b">0</code>数量</li></ul><p id="9c90" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是这些是<code class="du mu mv mw mx b">truthy</code>—</p><ul class=""><li id="b159" class="na nb hi jq b jr js ju jv jx nk kb nl kf nm kj nf ng nh ni bi translated"><code class="du mu mv mw mx b">'0'</code>绳子</li><li id="6b22" class="na nb hi jq b jr nz ju oa jx ob kb oc kf od kj nf ng nh ni bi translated"><code class="du mu mv mw mx b">[]</code>空阵</li><li id="2f50" class="na nb hi jq b jr nz ju oa jx ob kb oc kf od kj nf ng nh ni bi translated"><code class="du mu mv mw mx b">{}</code>空的物体</li></ul><p id="ec40" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好吧，我已经知道了！告诉我一些新的东西。告诉我如何使用这些？<br/>好！让我们看看如何使用这个技巧—</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">不需要比较变量的错误值。除非您希望null或undefined有一些不同的行为。</figcaption></figure><h2 id="43d3" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">b.非原始值</h2><p id="c903" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">我们知道空集合是真实的，但是如何快速检查它们呢？我们将借助这两个本地方法。</p><ul class=""><li id="e237" class="na nb hi jq b jr js ju jv jx nk kb nl kf nm kj nf ng nh ni bi translated">对于对象— <code class="du mu mv mw mx b">Object.keys()</code></li><li id="a24a" class="na nb hi jq b jr nz ju oa jx ob kb oc kf od kj nf ng nh ni bi translated">对于数组— <code class="du mu mv mw mx b">array.length</code></li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">不需要检查数组。长度&gt; 0，因为长度不能是负数。所以它要么是0(假)，要么是任何小于2的正整数(真)</figcaption></figure><p id="1e1a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如何检查空对象？提示—我们将再次使用相同的概念！</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Object.keys将在一个数组中返回给定对象自己的键。所以如果它是一个空数组，你知道对象是空的。</figcaption></figure><h2 id="74c3" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">c.使用逻辑运算符&amp;&amp;和||</h2><ul class=""><li id="3c4d" class="na nb hi jq b jr lj ju lk jx nc kb nd kf ne kj nf ng nh ni bi translated"><strong class="jq hj">使用</strong> <code class="du mu mv mw mx b"><strong class="jq hj">&amp;&amp;</strong></code> <br/>如何安全地玩自己不太了解的物体。<br/>假设有一个嵌套的英雄对象。类似于-</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">定义英雄对象</figcaption></figure><p id="0ca1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是如果你不确定你正在处理的数据格式，可能会有API的回应。让我们说，你的一些英雄喜欢保持神秘的气氛。所以您可能得不到它们的<code class="du mu mv mw mx b">email</code>或任何其他属性。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">赋值前进行检查，如果没有找到，则赋一个默认值。以使您的脚本更健壮，更不容易出错。</figcaption></figure><p id="f16e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">相信我，这可能看起来很乏味，但它会把你从那些会破坏你该死的页面的生产和最后一分钟的错误中拯救出来。</p><p id="4d7f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">可选链接(ES2020)🚀</strong> <br/>在最近的ECMA2020草案中，已经引入了可选链接。ES2020从版本80开始在谷歌Chrome中可用。<br/>所以，上面的例子可以改成——</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">使用可选的链接会使代码更加简洁。</figcaption></figure><p id="dc7a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们使用JavaScript的可选链接的方式有<code class="du mu mv mw mx b">objects</code>、<code class="du mu mv mw mx b">arrays</code>、<code class="du mu mv mw mx b">functions </code>作为<br/><code class="du mu mv mw mx b">obj?.prop</code><br/><code class="du mu mv mw mx b">obj?.[expr]</code><br/><code class="du mu mv mw mx b">arr?.[index]</code><br/><code class="du mu mv mw mx b">func?.(args)</code></p><ul class=""><li id="b78e" class="na nb hi jq b jr js ju jv jx nk kb nl kf nm kj nf ng nh ni bi translated"><strong class="jq hj">使用或</strong> <code class="du mu mv mw mx b"><strong class="jq hj">||</strong></code> <strong class="jq hj"> <em class="kk">又名</em>短路操作符</strong></li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">当用户未定义或为假值时，or运算符将使用第二个字面值，直到找到非假值。</figcaption></figure><p id="2976" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">零合并(ES2020)🚀</strong> <br/> ES2020还引入了一种更好的方式来检查<code class="du mu mv mw mx b">null</code>和<code class="du mu mv mw mx b">undefined</code>。</p><p id="ffe1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">空合并操作符将遍历列表并返回第一个不是<code class="du mu mv mw mx b">null</code>或<code class="du mu mv mw mx b">undefined</code>的项目。<br/>需要注意的是，零合并运算符只寻找<code class="du mu mv mw mx b">null</code>或<code class="du mu mv mw mx b">undefined</code>值。<code class="du mu mv mw mx b">falsy</code>值被<code class="du mu mv mw mx b">null</code>合并运算符接受。<br/>无效合并的示例-</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">零合并与OR运算符略有不同</figcaption></figure><h2 id="a656" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">d.使用三元运算符(条件)</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">三元运算符的简单用例</figcaption></figure><p id="092e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">三元条件很简洁，但是要避免编写嵌套的三元条件，因为这会使你的代码在认知上变得复杂和难以阅读。导致代码更容易出现难以跟踪的逻辑错误。</p></div><div class="ab cl nn no gp np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hb hc hd he hf"><h1 id="b0af" class="kr ks hi bd kt ku nu kw kx ky nv la lb io nw ip ld ir nx is lf iu ny iv lh li bi translated">3.更好的迭代</h1><p id="8e43" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">当有人说迭代一个<code class="du mu mv mw mx b">array</code>或一个<code class="du mu mv mw mx b">object</code>时，你会想到什么？根据您想要执行的场景和任务，有许多数组函数和循环。但是如何决定什么时候使用数组方法或者简单的<code class="du mu mv mw mx b">for</code>、<code class="du mu mv mw mx b">for-of</code>循环呢？让我试着帮你</p><h2 id="959e" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">a.大型阵列的性能迭代</h2><p id="e995" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">但是当迭代大型数组时，最好使用经典的<code class="du mu mv mw mx b">for</code>循环来获得最佳性能。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">将数组长度存储在局部变量中以提高性能。</figcaption></figure><p id="2e06" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">将<code class="du mu mv mw mx b">array</code> <code class="du mu mv mw mx b">length</code>或<code class="du mu mv mw mx b">numbers.length</code>存储在变量中甚至会为JavaScript引擎节省一些开销。它确实可以将迭代的性能提高50%(也取决于集合的长度)。</p><h2 id="ca24" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">b.为什么不使用for-in循环</h2><p id="abc5" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated"><code class="du mu mv mw mx b">for-in</code>循环经常被错误地用于循环<code class="du mu mv mw mx b">array</code>中的项目。这总是很容易出错，因为它不是从<code class="du mu mv mw mx b">0</code>循环到<code class="du mu mv mw mx b">length-1</code>，而是在对象及其<code class="du mu mv mw mx b">prototype</code>链中的所有当前<code class="du mu mv mw mx b">keys</code>上循环。是的，它也穿过了<code class="du mu mv mw mx b">prototype chain</code>！</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">人们总是建议避免使用for-in循环来迭代数组</figcaption></figure></div><div class="ab cl nn no gp np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hb hc hd he hf"><h1 id="e737" class="kr ks hi bd kt ku nu kw kx ky nv la lb io nw ip ld ir nx is lf iu ny iv lh li bi translated">4.公用事业</h1><p id="48af" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">一些代码片段，你可以在你的代码库中正确地使用它们来智能地完成家务。</p><h2 id="8135" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">a.深度克隆阵列</h2><p id="d38b" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">避免使用旧的<code class="du mu mv mw mx b">JSON.parse(JSON.stringify(arr))</code>方式克隆阵列。解析一个<code class="du mu mv mw mx b">array</code>或<code class="du mu mv mw mx b">object</code>总是会涉及很多风险和资源。它只适用于没有<code class="du mu mv mw mx b">function</code>或<code class="du mu mv mw mx b">Symbol</code>属性的<code class="du mu mv mw mx b">Number</code>、<code class="du mu mv mw mx b">String</code>和<code class="du mu mv mw mx b">Object</code>文字。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">使用递归克隆数组</figcaption></figure><h2 id="7c5e" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">b.展平数组</h2><p id="e095" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">有时我们需要展平一个数组，下面的例子会很有用</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">使用递归展平数组</figcaption></figure><h2 id="2153" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">c.深度克隆一个对象</h2><p id="08ec" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">可悲的是，很难克隆一个嵌套很深的对象。所以我建议你尽可能使用外部库，比如——lodash有一个<a class="ae jn" href="https://lodash.com/docs#cloneDeep" rel="noopener ugc nofollow" target="_blank"> cloneDeep </a>方法。<br/>另一种方法是实现自己的克隆功能。大约</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h2 id="57a2" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">d.弄平一个物体</h2><p id="2956" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">复杂嵌套的对象可能很难迭代，或者如果你直接将数据绑定到UI，也可能导致<code class="du mu mv mw mx b">[object Object]</code></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h2 id="aa11" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">e.深度冷冻一个物体</h2><p id="55f9" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">JavaScript中的对象是可变的，不管您是否将它们定义为常量变量。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h2 id="47ba" class="mg ks hi bd kt mh mi mj kx mk ml mm lb jx mn mo ld kb mp mq lf kf mr ms lh mt bi translated">f.记忆函数以加速昂贵的计算</h2><p id="306c" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">记忆化是一种优化技术，在这种技术中，代价高昂的函数调用被缓存起来，以便下次使用相同的参数调用函数时，可以立即返回结果。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">计算阶乘的记忆示例</figcaption></figure><p id="5f45" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了记忆一个函数，它应该是纯的，这样每次对于相同的输入返回值都是相同的。此外，记忆化是在增加的空间和增加的速度之间的折衷，因此仅对具有有限输入范围的功能有意义。</p></div><div class="ab cl nn no gp np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hb hc hd he hf"><h1 id="fb69" class="kr ks hi bd kt ku nu kw kx ky nv la lb io nw ip ld ir nx is lf iu ny iv lh li bi translated">离别赠言</h1><p id="7574" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">在这篇文章中，我谈到了一些我经常使用的技巧和窍门。这些是我辛苦学到的一些知识。但是如果你在日常工作中使用这些，它肯定会使你的代码更加智能、易读和健壮。<br/>感谢阅读！我希望这篇文章对你有用。如果你注意到一些不正确的地方，或者可以解释得更好的地方，请随意发表评论。</p></div><div class="ab cl nn no gp np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hb hc hd he hf"><h1 id="dcd1" class="kr ks hi bd kt ku nu kw kx ky nv la lb io nw ip ld ir nx is lf iu ny iv lh li bi translated">资源</h1><ul class=""><li id="d59a" class="na nb hi jq b jr lj ju lk jx nc kb nd kf ne kj nf ng nh ni bi translated"><a class="ae jn" href="https://www.30secondsofcode.org/" rel="noopener ugc nofollow" target="_blank">https://www.30secondsofcode.org/</a></li><li id="8209" class="na nb hi jq b jr nz ju oa jx ob kb oc kf od kj nf ng nh ni bi translated"><a class="ae jn" href="http://bonsaiden.github.io/JavaScript-Garden" rel="noopener ugc nofollow" target="_blank">http://bonsaiden.github.io/JavaScript-Garden</a></li><li id="21c9" class="na nb hi jq b jr nz ju oa jx ob kb oc kf od kj nf ng nh ni bi translated"><a class="ae jn" href="https://www.freecodecamp.org/news/javascript-new-features-es2020/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/JavaScript-new-features-es 2020/</a></li><li id="8ea2" class="na nb hi jq b jr nz ju oa jx ob kb oc kf od kj nf ng nh ni bi translated"><a class="ae jn" href="http://inlehmansterms.net/2015/03/01/javascript-memoization/" rel="noopener ugc nofollow" target="_blank">http://inlehmansterms . net/2015/03/01/JavaScript-memo ization/</a></li><li id="9eef" class="na nb hi jq b jr nz ju oa jx ob kb oc kf od kj nf ng nh ni bi translated"><a class="ae jn" href="https://www.sitepoint.com/implementing-memoization-in-javascript/" rel="noopener ugc nofollow" target="_blank">https://www . site point . com/implementing-memo ization-in-JavaScript/</a></li></ul></div></div>    
</body>
</html>