<html>
<head>
<title>Building an API With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js构建API</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-an-api-with-node-j-part-1-4fa35071312b?source=collection_archive---------16-----------------------#2020-03-14">https://medium.com/analytics-vidhya/building-an-api-with-node-j-part-1-4fa35071312b?source=collection_archive---------16-----------------------#2020-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/f969ff9e6c78e2379e7e4ca676b59db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fjsQpIJtKIFJStyzdwrXgw.jpeg"/></div></div></figure><div class=""/><p id="1afd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着Node.js环境的安装和运行，我们将探索REST API应用程序的<br/>创建。这种类型的应用程序目前正由许多项目和公司开发，因为它提供了创建只关注任何客户端应用程序的数据馈送上的<br/>的应用程序的好处。</p><p id="99d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如今，创建web应用程序和/或移动应用程序来使用来自一个或多个API的数据是很常见的。</p><p id="1dae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这使得几种类型的客户端应用程序都要咨询同一台服务器，专注于数据处理。此外，它还允许不同的团队开发每个应用程序，无论是客户端还是服务器。我们将首先构建一个API，但是在最后几章中，我们将构建一个简单的客户端web应用程序来使用API中的数据。</p><p id="0672" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了开始开发API，我们<br/>将使用一个非常流行的叫做<a class="ae jo" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu"> <em class="jp"> Express的web框架。</em> </strong> </a></p><h1 id="e636" class="jq jr ht bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Express简介</h1><p id="351c" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">Express是一个极简主义的web框架，它从Ruby语言的Sinatra框架中受到了很大的启发。使用这个模块，您可以创建从小到大的复杂应用程序。这个框架允许你构建API和创建简单的网站。</p><p id="0b7f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它专注于与<strong class="is hu">视图</strong>、<strong class="is hu">路径</strong>和<strong class="is hu">控制器</strong>一起工作，只有<strong class="is hu">模型</strong>不由该框架处理，让您可以自由使用任何持久性框架，而不会在应用程序中产生任何不兼容或冲突。</p><p id="45ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个很大的优势，因为有很多ODM <br/> <em class="jp">(对象数据映射器)</em>和ORM <em class="jp">(对象关系映射)</em>可用。你可以使用任何人的Express没有问题，你只需要加载这种模块，写一些模型和<br/>在<strong class="is hu">控制器</strong>、<strong class="is hu">路线</strong>或<strong class="is hu">视图</strong>中使用它们。</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kt"><img src="../Images/844353131a43314647ef7c72b4970306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ixzMLtoAsR8KvniO6FYMQ.png"/></div></div></figure><p id="d6b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">综上所述，下面可以看到一个Express主要特性列表:<br/>·健壮路由；<br/>·易于与大量模板引擎集成；<br/>·极简代码；<br/>·使用中间件概念；<br/>·要集成的第三方中间件的庞大列表；<br/>·内容协商；<br/>·采用REST APIs的标准和最佳实践；</p><h1 id="b554" class="jq jr ht bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">试点项目的启动</strong></h1><p id="4c94" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在实践中创建一个项目怎么样？从第一部分开始，我们将探索如何使用一些Node.js框架创建REST API。我们的应用程序将是一个简单的任务管理器，它将分为两个项目:API和Web应用程序。我们的API将被称为Build_Api_Node_part1，并具有以下特征:</p><ul class=""><li id="fb45" class="ky kz ht is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">任务列表；</li><li id="64ed" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">创建、删除和更新任务。</li><li id="df7e" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">创建、删除和更新用户数据；</li><li id="d4b3" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">用户认证；</li><li id="80d1" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">API文档页面；</li></ul><h1 id="bf0e" class="jq jr ht bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">试点项目源代码</strong></h1><p id="c51c" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">如果你很想看看本书中将要探索的所有项目的源代码，就访问这个链接:【https://github.com/Savalone47/Build_Api_Node_part1<a class="ae jo" href="https://github.com/Savalone47/node-express-consign-mongodb-server" rel="noopener ugc nofollow" target="_blank"/></p><p id="0f99" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们将使用以下命令创建第一个名为Api_Node的项目:</p><blockquote class="lm ln lo"><p id="d0e7" class="iq ir jp is b it iu iv iw ix iy iz ja lp jc jd je lq jg jh ji lr jk jl jm jn hb bi translated">mkdir Api _ Node<br/>CD Api _ Node<br/>NPM init-y</p></blockquote><p id="ede6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当前的Node.js版本不完全支持ES6，但是我们可以使用一个模块来模拟ES6/ES7的一些资源，使我们的代码更酷。为此，我们将安装巴别塔。只有当JavaScript运行时不能识别某些ES6/ES7特性时，JavaScript transpiler才负责将ES6/ES7代码转换成ES5代码。</p><p id="0fdb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使用ES6/ES7的所有功能，我们将在项目中安装babel-cli和babel-preset-es2015模块，运行以下命令:</p><blockquote class="lm ln lo"><p id="d16b" class="iq ir jp is b it iu iv iw ix iy iz ja lp jc jd je lq jg jh ji lr jk jl jm jn hb bi translated">npm安装babel-CLI @ 6 . 5 . 1 babel-preset-es 2015 @ 6 . 5 . 0—保存<br/> npm快速安装@4.17.1 —保存<br/> npm安装交付@0.1.6 —保存</p></blockquote><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ls"><img src="../Images/561b277fee91ad483d21350b598e1651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzU3-IAJWYdY1uaXEyC9Kw.png"/></div></div></figure><p id="4a97" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您需要链接预设的babel-preset-es2015以被babel-cli识别，为此，只需创建文件。babelrc代码很简单:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lt"><img src="../Images/c0a8f34f307f31fc5ef30368880d31d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQPW6ompwGKIWHe7KSi2cw.png"/></div></div></figure><p id="7d1d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装Express，我们将创建我们的第一个代码。这段代码将加载express模块，使用GET / via函数app.get("/")创建一个简单的端点，并使用函数app.listen()启动端口3000 <br/>中的服务器。为此，使用以下代码创建app.js文件:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/6a8170ba74f59ab15415cba3e6ed6901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xp9aZ1gYv7NywHYqsmMz6A.png"/></div></div></figure><p id="747e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，打开浏览器，进入:localhost:3000 <br/>如果没有出错，将会显示一个JSON内容，类似下图:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/3796e2faedb816ea610911437f80bd0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwvBjd-Gr1OMxLpi6hQiRw.png"/></div></div></figure><h1 id="cbca" class="jq jr ht bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">应用简单的静态资源</strong></h1><p id="e044" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">REST APIs使用创建和操作资源的概念。这些资源是用于查询、条目、更新和删除数据的实体，顺便说一下，一切都是基于对资源中的数据进行操作。</p><p id="6190" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">API旨在处理和统一数据，最终构建和显示资源。最初，我们将使用静态数据，但在整本书中，我们将进行一些重构来集成数据库。</p><p id="5292" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在此期间，静态数据将仅用于构建终点。为了塑造我们的API，我们将通过app.get("/node ")函数包含一个路由，该函数将通过res.json()函数仅返回一个静态json，该函数负责将JSON内容呈现为输出。这里我们预计app.js文件的执行，结果如下:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/d1c488dae941c90a215e83b368807339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-aLyNw9sc4Br5vRvxZGng.png"/></div></div></figure><h1 id="771b" class="jq jr ht bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">模块装载装置</h1><p id="fd1f" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">事实上，将所有端点写入index.js并不是明智之举，尤其是如果您的应用程序有很多端点的话。所以，让我们根据他们的职责来安排目录和所有代码的加载。</p><p id="4f46" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将应用<em class="jp"> MVR(模型-视图-路由器)</em>模式来安排这个事情。为此，我们将使用委托模块，它允许轻松地加载和注入依赖项。所以，我们来安装吧！</p><p id="3a35" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装了这个新模块后，让我们将index.js文件中的端点迁移到名为routes的新目录中，创建一个新文件。为此，创建文件routes/task.js:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div class="er es lv"><img src="../Images/333caec8d8cc2df6bd1907ba35a31e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*JliMnwQivxf4_sQoOB6_Tw.png"/></div></figure><p id="706f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将端点函数app.get("/node ")从app.js移动到他的新文件routes/task.js:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lw"><img src="../Images/fcb41c4d69771bde611e6bcd3c56da75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NoaILDWFvWr-j6jUX087TA.png"/></div></div></figure><p id="c356" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要完成这一步，请编辑app.js，以便能够通过委托模块加载这些路线并启动服务器:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lx"><img src="../Images/3413b9ff231d789d2dcdb30fa144913f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydhXSzjyvDdgfOvoO8nIGw.png"/></div></div></figure><p id="4987" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这样，我们刚刚安排好所有<strong class="is hu">航线</strong>的装货。请注意，在这一点上，我们只关注MVR模式中的VR <em class="jp">(视图和路由器)</em>。在我们的例子中，<strong class="is hu"> JSON </strong>输出被<br/>认为是由路由提供的视图。下一步将是安排<strong class="is hu">型号</strong>。让我们创建模型目录，并返回app.js，在<em class="jp">commission()</em>中再添加一个<em class="jp"> include() </em>函数，以允许在路由之前加载模型。为了使这个修改更加清晰，<br/>编辑app.js:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ly"><img src="../Images/aca7001c5ce139f0d9923c058bda5a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tlze6O0c4YT46ZEG3nNohA.png"/></div></div></figure><p id="e8c2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，commission()函数不会加载任何模型，因为models目录不存在。为了填补这个空白，我们暂时用静态数据创建一个模型，就为了完成这一步。为此，创建文件models/task.js并填入以下代码:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lz"><img src="../Images/7d0ede52e215b4b077bb34ff1b7e884e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqeKqSFN6m7h499cZQ0pag.png"/></div></div></figure><p id="fada" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要在routes/task.js文件中调用它，您将通过app变量加载该模块。毕竟，commission()函数添加的模块是注入到一个主变量中的，在我们的例子中，是通过commission()注入到app中的。进(app)；。为了了解如何使用加载的模块，在本例中，我们将使用<br/> app.models.task模块，按照以下代码编辑routes/task.js:</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ma"><img src="../Images/160f4eb3fba336a88e4bb3d615faacee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkAHc6eOWhtapNccb1rP_w.png"/></div></div></figure><p id="9bf3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了完成这些重构，让我们创建一个文件，它将加载Express的所有中间件和特定设置。目前，我们只有一个关于JSON格式的简单配置，它是通过函数app . set(“JSON spaces”，4)实现的。但是，我们将包括另一个设置，在<br/>这种情况下，它将是调用app.set("port "，3000)函数的服务器端口。</p></div></div>    
</body>
</html>