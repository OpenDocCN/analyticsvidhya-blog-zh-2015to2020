<html>
<head>
<title>Proving Halting Problem is undecidable (for layman programmers)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">证明停机问题是不可判定的(对于外行程序员)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/proving-halting-problem-is-undecidable-for-layman-programmers-354bc147c760?source=collection_archive---------7-----------------------#2019-12-28">https://medium.com/analytics-vidhya/proving-halting-problem-is-undecidable-for-layman-programmers-354bc147c760?source=collection_archive---------7-----------------------#2019-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a3d9684015bcd5b75277a82067580196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SWcsdft5KCZKIsOD"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马库斯·斯皮斯克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="adeb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有些问题在计算上是不可能的。这些属于不可判定的问题。对于一个不可判定的问题，不管算法的运行时间如何，没有算法可以在每个输入上解决问题。你运行多项式时间，指数时间；没有算法可以解决每一个输入。</p><p id="f65b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1936年，伟大的阿兰·图灵证明了停机问题是不可判定的。我们现在来看看这个结果的想法。<br/>图灵在1936年的这篇论文<a class="ae iu" href="https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf" rel="noopener ugc nofollow" target="_blank">引入了我们现在称之为图灵机的概念。图灵证明了停机问题在图灵机上是不可判定的，而图灵机拥有传统计算机的能力。按照惯例，我们排除了量子计算机之类的东西。<br/>后来，许多其他问题被证明是不可判定的，但是停机问题非常好，所以我们将深入证明。</a></p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="12bc" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">定义停机问题</h2><p id="ba11" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated"><strong class="ix hj">输入</strong> : <br/>停机问题的输入是一个程序<strong class="ix hj"> P </strong>，该程序<strong class="ix hj"> P </strong>有一个输入<strong class="ix hj"> I </strong>。现在这个程序是怎么给你的？嗯，我们可以把它限制在任何我们想要的语言。我们可以说是用伪代码写的，可以说是用golang，C，Python，或者任何任意语言写的。</p><p id="83cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong> <br/>现在的输出有什么磕磕绊绊的问题？嗯，想想编译器的基本任务。给定一个程序和一个输入，我们想弄清楚这个程序是终止于这个输入还是有一个无限循环。</p><p id="bb86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是停机问题的任务，要弄清楚这个特定输入<strong class="ix hj"> I </strong>上的程序<strong class="ix hj"> P </strong>是永远运行，还是永远终止。<br/>所以如果输入<strong class="ix hj"> I </strong>上的程序<strong class="ix hj"> P </strong>曾经终止，那么它最终停止，然后我们输出<strong class="ix hj">真值</strong>。<br/>我们并不试图弄清楚它是否正确运行，它是否对这个输入给出了正确的解决方案。<br/>我们只是在问当我们在输入<strong class="ix hj"> I </strong>上运行程序<strong class="ix hj"> P </strong>时，它是否曾经停止过。<br/>另一方面，如果输入<strong class="ix hj"> I </strong>上的程序<strong class="ix hj"> P </strong>从未终止，我们输出<strong class="ix hj"> false </strong>。换句话说，它有一个无限循环。</p><h2 id="3849" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">例子</h2><p id="4382" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">让我们看一个暂停问题的例子。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="1bfe" class="ka kb hi lf b fi lj lk l ll lm">func P(x int32) {<br/> for x%2 == 1 {<br/>   x += 2<br/> }<br/>}</span></pre><p id="8b76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个简单的程序是用golang编写的。程序<strong class="ix hj"> P </strong>由一个输入变量<strong class="ix hj"> x </strong>组成，它由一个while循环组成(golang中的while循环就是这样)。while循环检查<strong class="ix hj"> x </strong>是否为奇数。<br/>如果<strong class="ix hj"> x </strong>是奇数，那么它会在<strong class="ix hj"> x </strong>上加2并重复。并且一直持续到<strong class="ix hj"> x </strong>为偶数。</p><p id="f408" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看看这个程序在输入<strong class="ix hj"> x=5 </strong>上的<strong class="ix hj"> P </strong>。对于这个简单的程序，很容易看到会发生什么。<br/> <strong class="ix hj"> x </strong>从5开始，然后就是7，9，11等等。<br/> <strong class="ix hj"> x </strong>永远是奇数。所以程序永远不会停止，因为这将是一个无限循环。当然，这是假设无限内存的情况下。所以没有溢出之类的东西。</p><p id="9eb3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果我们考虑用这一对输入来暂停，编程<strong class="ix hj"> P </strong>和这个输入<strong class="ix hj"> x=5 </strong>。那么这个程序在这个特定的输入上有一个无限循环。因此，<strong class="ix hj"> halting(P，5) </strong>为<strong class="ix hj"> false </strong>。<br/>同样<strong class="ix hj">停止(P，2) </strong>为<strong class="ix hj">真</strong>。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="84d3" class="ln kb hi bd kc lo lp lq kg lr ls lt kk lu lv lw kn lx ly lz kq ma mb mc kt md bi translated">定理:停机问题是不可判定的</h1><h2 id="8b29" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">我们怎么能希望证明这个定理呢？</h2><p id="a7ab" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">想出一个没有算法能解决程序停机问题的程序是非常困难的。更容易推理的是，对于每一个算法，都有一个该算法失败的程序。</p><p id="becf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们证明这个定理的方法是通过矛盾。让我们假设我们有一个算法可以解决每个输入的停顿问题。如果我们可以构建一个输入，这个算法是不正确的，那么这将与我们的假设相矛盾。因此，这将证明定理。</p><h2 id="53b3" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">定义此算法的签名</h2><p id="1aba" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">现在让我们给这个算法起个名字。因为该算法确定特定输入上的特定程序是否终止。所以我们把这个算法叫做<strong class="ix hj"> doesTerminate </strong>。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="8a1c" class="ka kb hi lf b fi lj lk l ll lm">func doesTerminate(P, I) bool</span></pre><p id="2e7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> doesTerminate </strong>带一对输入，<strong class="ix hj"> P </strong>和<strong class="ix hj"> I </strong>。<strong class="ix hj"> P </strong>是程序，<strong class="ix hj"> I </strong>是程序<strong class="ix hj"> P </strong>的输入，<strong class="ix hj"> doesTerminate </strong>输出<strong class="ix hj">真</strong>或<strong class="ix hj">假</strong>取决于该程序<strong class="ix hj"> P </strong>在该特定输入<strong class="ix hj"> I </strong>上是否最终终止。</p><p id="0c6c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果它最终终止，那么输出为真。<br/>如果它有一个无限循环，那么输出是假的。我们假设<strong class="ix hj">终止</strong>是正确的。它解决了每个程序<strong class="ix hj"> P </strong>和每个输入<strong class="ix hj"> I </strong>的暂停问题。</p><h2 id="0b5c" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">这个计划</h2><p id="99aa" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">现在我们要构造一个程序<strong class="ix hj"> Q </strong>和一个输入<strong class="ix hj"> J </strong>，并表明当我们在这个输入对<strong class="ix hj"> (Q，J) </strong>上运行<strong class="ix hj"> doesTerminate </strong>时，它的输出是不正确的。由于<strong class="ix hj"> doesTerminate </strong>在这一对输入上是不正确的，因此<strong class="ix hj"> doesTerminate </strong>并不能解决每一个输入上的停顿问题。<br/>所以这就给了我们矛盾，因此，这就通过矛盾完成了证明。</p><h2 id="85d1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">邪恶天才(前方重递归)</h2><p id="3ad5" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">现在我们如何希望构建这个程序呢？嗯，重要的一点是我们假设这个程序存在，<strong class="ix hj">不终止</strong>。所以我们可以使用这个算法，在我们的新程序<strong class="ix hj"> Q </strong>中<strong class="ix hj">不终止</strong>作为一个子程序。<br/>现在我们对<strong class="ix hj">终止</strong>的内部工作方式一无所知，所以我们必须把它当作一个黑盒，因此我们可以把它当作一个子程序。</p><p id="2ca6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以考虑下面这个邪恶的程序，它是邪恶的，因为<strong class="ix hj">并没有终止</strong>算法，我们假设它在这个程序上会失败。我们现在要定义的这个新程序，姑且称之为矛盾的。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="aa62" class="ka kb hi lf b fi lj lk l ll lm">func Contradictory(J) {<br/> for doesTerminate(J, J) {}<br/>}</span></pre><p id="acda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">矛盾</strong>有一个输入<strong class="ix hj"> J </strong>。<br/>矛盾<strong class="ix hj">的第一行</strong>是while循环。我们所做的是在这个输入对(<strong class="ix hj"> J，J) </strong>上运行<strong class="ix hj"> doesTerminate </strong>。因此<strong class="ix hj"> J </strong>是一个程序，而<strong class="ix hj"> J </strong>也是程序<strong class="ix hj"> J </strong>的输入。<br/>所以我们使用<strong class="ix hj">矛盾</strong>程序的这个输入<strong class="ix hj"> J </strong>作为程序<strong class="ix hj"> P </strong>和<strong class="ix hj"> doesTerminate </strong>算法的输入<strong class="ix hj"> I </strong>。<br/>现在<strong class="ix hj">终止</strong>返回<strong class="ix hj">真</strong>或<strong class="ix hj">假</strong>。所以两种可能性是</p><p id="af43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.如果<strong class="ix hj">不终止</strong>返回<strong class="ix hj">真值</strong>，那么程序将进入无限循环。<br/> 2。如果<strong class="ix hj">没有终止</strong>返回<strong class="ix hj">假</strong>则程序退出。</p><p id="73d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们再次详细说明这个简单程序中发生了什么。<br/>我们正在运行<strong class="ix hj"> doesTerminate(J，J) </strong>。那有什么用？<br/>对程序<strong class="ix hj"> J(J) </strong>求值，如果程序<strong class="ix hj"> J(J) </strong>终止，则<strong class="ix hj"> doesTerminate </strong>返回true。它最终停止。<br/>如果<strong class="ix hj"> J(J) </strong>没有终止，则返回<strong class="ix hj">假</strong>。即它有一个无限循环。</p><p id="2554" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总结一下</p><p id="596c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">a)如果程序<strong class="ix hj"> J(J) </strong>终止，那么<strong class="ix hj"> doesTerminate(J，J) </strong>将返回<strong class="ix hj"> true </strong>并且程序<strong class="ix hj">矛盾(J) </strong>永不终止。它进入了一个无限循环。</p><p id="f1ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">b)如果程序<strong class="ix hj"> J(J) </strong>永不终止，那么它有一个无限循环。然后<strong class="ix hj"> doesTerminate(J，J) </strong>将返回<strong class="ix hj"> false </strong>并且我们的程序<strong class="ix hj">矛盾(J) </strong>马上退出，因此它终止。</p><h2 id="96dd" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">悖论</h2><p id="ca21" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">现在，我们需要推导一个矛盾。我们所做的是我们设置输入<strong class="ix hj"> J </strong>为这个程序<strong class="ix hj">矛盾</strong>我们刚刚定义的。<br/>所以<strong class="ix hj">矛盾</strong>就是这个短短的一行程序，我们用它作为<strong class="ix hj">矛盾</strong>本身的输入。<br/>即<strong class="ix hj">J =矛盾</strong></p><p id="026e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在的问题是，程序<strong class="ix hj">矛盾(矛盾)</strong>，终止还是不终止？有两种可能，要么它终止，要么它有一个无限循环。让我们考虑这两种可能性。</p><p id="b655" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 1)矛盾(矛盾)终止</strong> <br/>假设程序<strong class="ix hj">矛盾</strong>以自身为输入时确实终止。<br/>我们已经看到，如果<strong class="ix hj"> J(J) </strong>终止，那么<strong class="ix hj">矛盾(J) </strong>永远不会终止，因为它进入了这个无限循环。<br/>所以插上<strong class="ix hj">J =矛盾</strong>，<br/>我们就得到了<strong class="ix hj">矛盾</strong>永不终止。</p><p id="fc1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以如果程序<strong class="ix hj">矛盾(矛盾)</strong>终止，那么<strong class="ix hj">矛盾(矛盾)</strong>永远不会终止。这是一个矛盾。因此，这不可能是事实。</p><p id="bd16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2)矛盾(interpolative)永不终止<br/> </strong>这种情况下会发生什么？<br/>在这个场景中，当<strong class="ix hj"> J(J) </strong>永远不会终止时，那么<strong class="ix hj">矛盾(J) </strong>终止，因为它立即退出程序<strong class="ix hj">矛盾</strong>。<br/>所以插入<strong class="ix hj">J =矛盾</strong>，<br/>如果程序<strong class="ix hj">矛盾</strong>永不终止，那么<strong class="ix hj">矛盾</strong>终止。</p><p id="066e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还是那句话，我们有矛盾，所以不能这样。</p><h2 id="8284" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">结论</h2><p id="382b" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">由于这两种情况都会导致矛盾，我们最初的假设，即程序<strong class="ix hj">不会终止</strong>来解决每个输入都存在的暂停问题，肯定是不可能的。因此，不存在一个程序可以解决每一个输入的停顿问题。这就完成了定理的证明。</p></div></div>    
</body>
</html>