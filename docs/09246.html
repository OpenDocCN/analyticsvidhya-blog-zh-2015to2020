<html>
<head>
<title>ANTLR and code generation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ANTLR和代码生成</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/antlr-and-code-generation-a71ead442005?source=collection_archive---------3-----------------------#2020-08-30">https://medium.com/analytics-vidhya/antlr-and-code-generation-a71ead442005?source=collection_archive---------3-----------------------#2020-08-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6e78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一点上，驱动每一种现代编程语言的写作风格的思想是使用编译器设计的概念来定义的。这是一套典型的步骤，从<strong class="ih hj">词汇</strong>、<strong class="ih hj">句法</strong>和<strong class="ih hj">语义分析</strong>开始(确定一个人应该如何用你的语言写作的基础，以便可以被识别)。接下来是一组非常有趣的步骤<strong class="ih hj">中间代码生成</strong>、<strong class="ih hj">优化</strong>和<strong class="ih hj">目标代码生成。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/e5f200544c3588384c330cd14771f72e.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*f_aOnC3-Ji2WYrfITAcbMw.png"/></div></figure><h1 id="375f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">编译器设计步骤？分析？扑朔迷离？我们是在写编程语言吗？号码</h1><p id="5773" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated"><strong class="ih hj"> ANTLR </strong>是<strong class="ih hj">AN</strong>other<strong class="ih hj">T</strong>ool for<strong class="ih hj">L</strong>language<strong class="ih hj">R</strong>ecognition的缩写，是一个<strong class="ih hj">功能强大的</strong>解析器生成器框架，用于从语法文件构建语言识别器、编译器和翻译器，这些语法文件包含从源语言到目标语言的每个语句要执行的操作。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ko"><img src="../Images/85eb21eafbd3bc4aa3e0ecc3eb68b929.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*r0VIZUBFaq3Ipj4inVwQ4w.jpeg"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated"><a class="ae kt" href="https://www.antlr.org/" rel="noopener ugc nofollow" target="_blank">www.antlr.org</a></figcaption></figure><p id="8d92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前在4.7版本中，它提供了一种方便且开发人员友好的方式来定义您自己的规则集，也称为<strong class="ih hj">语法</strong>，由一系列标记和动作组成，这些标记和动作定义了一个语句应该如何用您的源语言编写，以便它可以被正确地识别和解析。更有趣的是，它允许用户操作代码并将其生成目标代码的能力，所有这些都是以您选择的语言进行的。</p><p id="9146" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们开始之前，有人可能会问，这有多成熟？对你喜欢的语言的支持呢？</p><h1 id="6f48" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">有哪些可能的目标语言？</h1><ul class=""><li id="e5f3" class="ku kv hi ih b ii kj im kk iq kw iu kx iy ky jc kz la lb lc bi translated">Ada，Action Script，C，C#，C#3，D，Java，JavaScript，Python，Ruby，Perl，Perl6，PHP，Oberon，Scala…你不想让我再点名了吧？</li></ul><h1 id="2353" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">那么，谁在使用ANTLR呢？</h1><ul class=""><li id="3e3f" class="ku kv hi ih b ii kj im kk iq kw iu kx iy ky jc kz la lb lc bi translated">编程语言:Boo，Groovy，Mantra，Nemerle，XRuby等。</li><li id="b1ea" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">其他工具、框架:Apache Spark、Hibernate、Intellij IDEA、Jazillian、JBoss Rules、Keynote(Apple)、WebLogic(Oracle)等。</li></ul><h1 id="8623" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">基础知识</h1><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">Python中的Sum函数</figcaption></figure><p id="df1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑上面的Python示例，这些编译器设计步骤从一种方法开始，该方法识别用Python编写的每个语句(源代码)的基本单元，并将其分解成一个令牌流，每个令牌被识别或映射到一个特定的类型，也称为<strong class="ih hj">词法分析</strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/1875706a19c2495cd7d6418ac7cb6005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*ryPMfIfxCa568o52u_R-Tw.jpeg"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">python函数的词法分析产生了一个令牌流</figcaption></figure><p id="6027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随后，根据这些标记出现的顺序识别书面陈述的上下文，并通过构建树(或通过语义分析<strong class="ih hj">的<strong class="ih hj">A</strong>bstract<strong class="ih hj">S</strong>yntax<strong class="ih hj">T</strong>REE】来检查其正确性</strong>提供了使用一种现有的树遍历方法进行遍历的能力。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/c59b7d69b247d087d22d1c7330bf7bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgxQBhtUskEzUM5CkxhcnA.jpeg"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">语义分析后的语法树</figcaption></figure><h1 id="4eb1" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak"> TLDR？</strong></h1><ul class=""><li id="5963" class="ku kv hi ih b ii kj im kk iq kw iu kx iy ky jc kz la lb lc bi translated">Lexer:将字符流转换为标记流。</li><li id="e9ec" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">解析器:令牌的处理，可能创建AST。</li><li id="5319" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">抽象语法树(AST):已解析输入的中间树表示，比令牌流更容易处理。它也可以被多次处理。</li><li id="7589" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">树解析器:它处理AST。</li><li id="3d31" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">String Template:这个库支持使用带有占位符的模板来输出文本(ANTLR特有的)。</li></ul><p id="932f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ANTLR是一个<strong class="ih hj"> LL解析器</strong>(从左到右，最左边的派生)是一个<a class="ae kt" href="https://en.wikipedia.org/wiki/Top-down_parsing" rel="noopener ugc nofollow" target="_blank">自顶向下解析器</a>，用于<a class="ae kt" href="https://en.wikipedia.org/wiki/Context-free_languages" rel="noopener ugc nofollow" target="_blank">上下文无关语言</a>的子集。它从<strong class="ih hj"> L </strong> eft向右解析输入，执行句子的<a class="ae kt" href="https://en.wikipedia.org/wiki/Context-free_grammar#Derivations_and_syntax_trees" rel="noopener ugc nofollow" target="_blank">Left most派生</a>。它简化了许多步骤，使得创建语言识别器和解析器更加容易和方便。</p><p id="dff2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个我为解析python函数而编写的解析器的简单例子。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="44ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中一个主要的优点是它让用户拥有相同的词法和语法分析语法。然而，这里的区别因素是在语法层面上，是命名约定，其中以<strong class="ih hj">大写字母</strong>开头的规则是lexer规则。其他的都是解析规则。这花了我一些时间来适应，但是一旦用户熟悉了，这个想法就很方便了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lq"><img src="../Images/003acd60722d43228f6908af5af407d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nA68dsFTqqMNLLfNKzzvQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">上述python函数解析的ANTLR插件(在Intellij IDEA上)输出</figcaption></figure><p id="7f09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦定义完毕，<a class="ae kt" href="https://www.antlr.org/download/antlr-4.8-complete.jar" rel="noopener ugc nofollow" target="_blank"> complete ANLTR jar </a>文件提供了用您喜欢的编程语言代码生成一组文件的选项，也就是一个<strong class="ih hj">解析器</strong>。</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="23d4" class="lw jm hi ls b fi lx ly l lz ma">java -Xmx500M -cp &lt;path to ANTLR complete JAR&gt; org.antlr.v4.Tool -Dlanguage=&lt;target_language&gt; PythonParserExample.g4</span></pre><p id="a511" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我使用Python3作为要生成的解析器的目标，所以ANTLR的配置生成了3个Python文件，这些文件可以作为代码翻译过程的一部分，用于将一种语言的源代码转换成另一种语言。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mb"><img src="../Images/6f4a161e5d08c1c1ee3d13e136869695.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*DZcuoEoRN4r9B-QuEPn5gw.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">ANTLR运行时输出文件包含用于识别python函数的代码</figcaption></figure><p id="db49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在接下来的系列文章中，我将创建一个简单的ANTLR解析器，用于将简单的布尔表达式转换成相应的python代码。</p></div></div>    
</body>
</html>