<html>
<head>
<title>S.O.L.I.D Programming Principles explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">南解释了 O.L.I.D 编程原则</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/s-o-l-i-d-programming-principles-explained-23e2ba02ffbc?source=collection_archive---------20-----------------------#2020-12-13">https://medium.com/analytics-vidhya/s-o-l-i-d-programming-principles-explained-23e2ba02ffbc?source=collection_archive---------20-----------------------#2020-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/5b6c0bf31ffb8a193702d5261311e83d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CK0OWci7AHfw4lhgQjIKGg.jpeg"/></div></div></figure><div class=""/><p id="837c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">南 O.L.I.D 编程原则最初是由罗伯特·c·马丁(又名鲍勃大叔)阐明的。这些原则概述了面向对象的设计规则，旨在使大型代码库更容易维护、重用和扩展。它们还使开发团队在遵循敏捷原则的同时，更容易重构代码和添加新功能。</p><ol class=""><li id="0f68" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">单一责任原则</li><li id="a165" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">o:开闭原则</li><li id="dfa8" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">李:里斯科夫替代原理</li><li id="be2c" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">I:界面分离原理</li><li id="2f8e" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">依赖倒置原则</li></ol></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="3399" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> S —单一责任原则 SRP </strong></p><p id="00f6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单一责任原则规定一个类应该有且只有一个责任/功能。例如:</p><figure class="kj kk kl km fd hk"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="19ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在假设我们想画正方形和圆形。为了实现绘制功能，我们有两个选项:</p><ol class=""><li id="ad87" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">为每个类添加一个 draw 方法，并编写绘图代码。这将导致正方形和圆形类也有责任绘制给定的形状，这是违反 SRP 的。每个 draw 方法都有自己的基于类的方法实现。</li></ol><figure class="kj kk kl km fd hk"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="f5fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.创建另一个名为 ShapeDrawer 的类，它将绘制任何给定的输入形状。该选项将使代码遵守 SRP 原则。</p><figure class="kj kk kl km fd hk"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="434f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> O —开闭原理 OCP </strong></p><p id="aece" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对象或实体应该对扩展开放，对修改关闭。</p><p id="70e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个原则表明，一个类一旦被编写，就不应该对其进行修改，以防需要添加新的功能；相反，为了增加新的功能，这个类应该以一种易于扩展的方式创建。</p><p id="471a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再次考虑上面的代码片段:</p><figure class="kj kk kl km fd hk"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="5446" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以看出，如果添加一个新的形状，如三角形，ShapeDrawer 类将需要通过添加另一个方法 drawTriangle 来修改，这违背了开闭原则。</p><p id="fac8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的代码片段显示了如何使 ShapeDrawer 类变得易于扩展:通过创建一个 Shape 接口，然后在 Square 和 Circle 类中实现该接口，修改上面的 Square 和 Circle 示例，如下所示:</p><figure class="kj kk kl km fd hk"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="7025" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意上面 ShapeDrawer 类实现的变化。</p><p id="f992" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> L —利斯科夫替代原理 LSP </strong></p><p id="761a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Liskov 替换原则指出，在不改变程序正确性的情况下，子类型应该可以替换为类型。</p><p id="048c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请考虑下面鲍勃大叔(罗伯特·c·马丁)解释利斯科夫替代原则的意思的话:</p><p id="c7dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kp kq kr ks b">Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</code></p><p id="bcea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">超类的任何子类化或者抽象(接口)的实现必须遵守抽象接口的需求和约定。</p><p id="2069" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如:</p><figure class="kj kk kl km fd hk"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="4310" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> I —接口隔离原则 ISP </strong></p><p id="d36d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接口分离原则声明，消费者方法、接口实现或子类不应该被强制依赖于它不使用的方法。</p><figure class="kj kk kl km fd hk"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="af8e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是 ISP 遵守的修改示例。</p><figure class="kj kk kl km fd hk"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="3d6e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> D —依存反演原理倾角</strong></p><p id="9294" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">依赖性反转原理陈述如下:</p><ol class=""><li id="4216" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象。</li><li id="dcaa" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">抽象不应该依赖于细节。细节应该依赖于抽象。</li></ol><p id="7c85" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一个 PasswordReminder 类，它访问一个 MySQLConnection 对象来连接数据库并返回密码。</p><figure class="kj kk kl km fd hk"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="bbfa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以看出，PasswordReminder 类直接依赖于 MySQLConnection 对象。这很麻烦，并且违反了 DIP，因为如果明天我们决定将数据库迁移到 Teradata 会怎么样？我们将不得不再次重写这个类，这将违反开闭原则。</p><p id="baeb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PasswordReminder 类应该与数据库无关，并且不应该关心特定的数据库引擎。为了使 PasswordReminder 数据库不可知，我们创建了一个接口:</p><figure class="kj kk kl km fd hk"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="08b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们想要添加一个 TeradataConnection 对象，现在我们只需创建一个 TeradataConnection 类，因为它在 PasswordReminder 类中使用。</p><figure class="kj kk kl km fd hk"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="bafe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">结论</strong></p><p id="4678" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">南 O.L.I.D 原则对于编写可维护、可重用和易于扩展的代码库非常重要。此外，这些原则也是相互关联的。就像如果我们应用开闭原则&amp;利斯科夫替代原则，我们会自动确保依赖倒置原则。这一切都从单一责任的第一个原则开始，并归结为我们如何在代码中分离程序功能而不产生直接依赖。</p></div></div>    
</body>
</html>