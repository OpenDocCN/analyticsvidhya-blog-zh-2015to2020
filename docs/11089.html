<html>
<head>
<title>Let’s Talk about SQL — Part 7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来谈谈SQL —第7部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/lets-talk-about-sql-part-7-242364486a0f?source=collection_archive---------6-----------------------#2020-11-17">https://medium.com/analytics-vidhya/lets-talk-about-sql-part-7-242364486a0f?source=collection_archive---------6-----------------------#2020-11-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="599c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">临时表、cte和子查询</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/6b8b5c604470e1f68c5c70bc9b7829f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMhTI9vl43WQJWuNOlhPug.png"/></div></div></figure><p id="f424" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的上一篇文章中，我向你展示了一些简单的窗口函数。你可以在这里阅读。SQL中的最后一个查询:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="f079" class="jv jw hi jr b fi jx jy l jz ka">WITH CTE as (SELECT date, state, county,<br/>             cases — LAG (cases,1) OVER(PARTITION BY <br/>             fips ORDER BY date)as ‘new_cases’,<br/>             cases as ‘cumulative_cases’FROM counties)</span><span id="73b5" class="jv jw hi jr b fi kb jy l jz ka">SELECT date, state, county, new_cases,cumulative_cases,<br/>       AVG(new_cases) OVER (PARTITION BY state,county <br/>                            ORDER BY date ASC<br/>                            rows 6 PRECEDING) as ‘7_day_avg_new’<br/>FROM CTE<br/>ORDER BY state, county, date</span></pre><p id="bc1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这个查询中使用了CTE，以便为我们提供一种临时查询表，因此这似乎是讨论cte、临时表和子查询之间的区别的好时机。我们将使用同样的NYT·科维德和麻省理工学院的选举数据，这些数据在过去的几篇文章中使用过。</p><p id="e76e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们从一些定义开始。</p><p id="ff41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> CTE或公共表表达式— </strong>一种存放查询结果的临时数据源。cte仅在查询期间存储。</p><p id="7a4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">子查询— </strong>就像cte和临时表一样，子查询是一种生成临时结果集的方法，以便在主查询中使用。</p><p id="4e89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">临时表— </strong>与cte一样，临时表是一种存储为表的临时数据集。临时表可用于整个SQL会话。</p><p id="aea7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了说明不同之处，我们将使用这些临时数据存储解决方案生成相同的结果集。如果这听起来不像是一个好时机，那么我不知道什么才是！开始了。</p><p id="2825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经有了一组使用CTE的结果，这是我们在上一篇文章中使用的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kc"><img src="../Images/15580178df2c32d81ddfaab2409dfe2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7j-X4B5R-KPALyVs4DugRg.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">使用CTE的结果，前20行</figcaption></figure><p id="9468" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用CTE作为子查询来重写查询:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="bb81" class="jv jw hi jr b fi jx jy l jz ka">SELECT date, state, county, new_cases, cumulative_cases,<br/>       AVG(new_cases) OVER (PARTITION BY state, county <br/>                            ORDER BY date ASC<br/>                            rows 6 PRECEDING) as ‘7-day_avg_new’<br/>FROM (SELECT date, state, county,<br/>      cases — LAG (cases,1) OVER (PARTITION BY fips <br/>                                  ORDER BY date)as new_cases,<br/>      cases as cumulative_cases<br/>      FROM counties)<br/>ORDER BY state, county, date;</span></pre><p id="aba2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这会给我们相同的结果:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kh"><img src="../Images/09472c76487b25e0ce84c408f4812921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4uAFFLcesp_goyEYtlV4w.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">使用子查询的结果(仅显示结果的头部/尾部)</figcaption></figure><p id="372a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有什么理由选择使用CTE而不是子查询呢？就性能而言，它们几乎是一样的。从我们关于SQL中的操作顺序的讨论中，请记住子查询将在主查询之前运行，CTE也是如此，因此无论哪种情况，您基本上都是在查询一个查询。</p><p id="e37d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果两个选项的性能相同，为什么要选择CTE而不是子查询呢？对于像我的例子这样的简单查询，它可能会归结为个人偏好。然而，对于需要多个子查询的更复杂的查询，使用cte可以使您的查询更容易理解。当您编写需要多个用户使用或编辑的查询时，这一点尤其重要。使用子查询结构，并不总是容易看出作者的意图。</p><p id="cddd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以创建多个cte在查询中使用，就像您可以创建多个子查询一样。您也可以随意命名您的CTE(我之前使用CTE来说明哪个部分是CTE，但是最好使用描述性的名称)，这也将更容易理解您的查询在做什么。这里有一个例子:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="f7f6" class="jv jw hi jr b fi jx jy l jz ka">WITH mask AS (SELECT DISTINCT state, county, never, rarely,<br/>                     sometimes, frequently, always<br/>              FROM mask_use m<br/>              JOIN counties c on c.fips = m.countyfp),</span><span id="ae90" class="jv jw hi jr b fi kb jy l jz ka">     new AS (SELECT date, state, county,<br/>                    cases — LAG (cases,1) OVER<br/>                    (PARTITION BY fips ORDER BY date) as new_cases,<br/>                    cases as cumulative_cases<br/>     FROM counties)</span><span id="bf46" class="jv jw hi jr b fi kb jy l jz ka">SELECT date, n.state, n.county, new_cases, cumulative_cases,<br/>       AVG(new_cases) OVER (PARTITION BY n.state, n.county <br/>                            ORDER BY date ASC rows 6 PRECEDING) <br/>                            as ‘7-day_avg_new’, <br/>       always as ‘pct_always_mask’<br/>FROM new n<br/>JOIN mask m on n.state = m.state AND n.county = m.county<br/>ORDER BY n.state, n.county, date</span></pre><p id="5672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也可以使用多个子查询来编写:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="5bfa" class="jv jw hi jr b fi jx jy l jz ka">SELECT date, n.state, n.county, new_cases, cumulative_cases,<br/>       AVG(new_cases) OVER (PARTITION BY n.state, n.county <br/>                            ORDER BY date ASC rows 6 PRECEDING) <br/>       as ‘7-day_avg_new’, <br/>       always as ‘pct_always_mask’<br/>FROM (SELECT date, state, county,<br/>             cases — LAG (cases,1) OVER<br/>             (PARTITION BY fips ORDER BY date) as new_cases,<br/>             cases as cumulative_cases<br/>      FROM counties) n<br/>JOIN (SELECT DISTINCT state, county, never, rarely, sometimes,  <br/>             frequently, always<br/>      FROM mask_use m<br/>      JOIN counties c on c.fips = m.countyfp) m<br/>ON n.state = m.state AND n.county = m.county<br/>ORDER BY n.state, n.county, date</span></pre><p id="e3ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用多个cte的查询更容易阅读，但是无论您以何种方式编写查询，都会得到相同的结果。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/e69fe63da6e681ea0a34f9f0cd5771f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1iBrMFF49S8IR1rMKsdy1Q.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">cte和子查询将给出相同的结果集！</figcaption></figure><p id="dee9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里需要指出一点，当使用多个CTE时，你只需要使用一次WITH关键字，用逗号分隔各个cte。</p><p id="e134" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，所有这些都表明CTE和子查询将完成同样的事情。临时表呢？CTE/子查询表和临时表之间有一个主要区别。在同一个SQL会话中，多个查询可以访问临时表。CTE/子查询仅适用于单个查询。</p><p id="cb66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那是什么意思？假设我有多个查询需要使用相同的“掩码”CTE，我可以将CTE放在每个查询的开头，但这将需要大量的额外输入(这在我的浪费时间的方法列表中并不多)，并且性能会下降—每个查询都将运行相同的临时结果集，这需要额外的时间。这就是我们临时桌子的原因。让我们来看看这是如何工作的。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="45a5" class="jv jw hi jr b fi jx jy l jz ka">CREATE TABLE temp.mask AS<br/>       SELECT distinct state, county, never, rarely, sometimes,<br/>              frequently, always<br/>       FROM mask_use m<br/>       JOIN counties c on c.fips = m.countyfp</span></pre><p id="5037" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦创建并填充了临时表(SELECT子句正在填充该表)，就可以多次查询它，直到断开SQL会话。请注意，此语法适用于SQLite，SQL Server和其他SQL实例支持SELECT INTO语法。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="434d" class="jv jw hi jr b fi jx jy l jz ka">SELECT distinct state, county, never, rarely, sometimes,<br/>              frequently, always<br/>INTO #mask<br/>FROM mask_use m<br/>JOIN counties c on c.fips = m.countyfp</span></pre><p id="2f26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，现在我们可以像平常一样使用temp.mask表进行查询。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="0f2b" class="jv jw hi jr b fi jx jy l jz ka">WITH new AS (SELECT date, state, county,<br/>                    cases — LAG (cases,1) OVER<br/>                    (PARTITION BY fips ORDER BY date) as new_cases,<br/>                    cases as cumulative_cases<br/>             FROM counties)</span><span id="c2e3" class="jv jw hi jr b fi kb jy l jz ka">SELECT date, n.state, n.county, new_cases, cumulative_cases,<br/>       AVG(new_cases) OVER (PARTITION BY n.state, n.county <br/>       ORDER BY date ASC rows 6 PRECEDING) as ‘7-day_avg_new’,<br/>       always as ‘pct_always_mask’<br/>FROM mask m<br/>JOIN new n on m.state = n.state AND m.county = n.county<br/>ORDER BY n.state, n.county, n.date</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/810cd86c4f6d3cda167fda36ae680b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o1ofGmrfsmAkaZ1I1dtNFA.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">临时表的查询方式与任何其他表一样</figcaption></figure><p id="3c3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们仍然使用了CTE，查询时，您的临时表就像任何其他表一样工作，您只需为任何会话运行它一次。有一些事情要记住，您的临时表将被存储，因为它不是为每个查询运行的(像CTE/子查询)。如果您使用相同的临时数据运行多个查询，这可以显著提高性能。但是，因为如果您仅在单个查询中使用临时表，则会存储临时表，所以使用临时表时性能会更差。</p><p id="24de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，我们可以互换使用CTE/子查询，但是CTE更容易阅读和看到正在发生的事情，所以当查询将被其他用户使用/编辑时最好使用它。这些的用例是单个查询—信息不需要在单个SQL会话中被多个查询访问。临时表也是一个临时数据源，但是在同一个SQL会话中，它可用于多个查询。</p></div></div>    
</body>
</html>