<html>
<head>
<title>Time and space complexity simplified. How to reduce it for scalability?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化了时间和空间复杂度。如何降低它的可扩展性？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-and-space-complexity-simplified-how-to-reduce-it-for-scalability-435304f64191?source=collection_archive---------7-----------------------#2019-12-24">https://medium.com/analytics-vidhya/time-and-space-complexity-simplified-how-to-reduce-it-for-scalability-435304f64191?source=collection_archive---------7-----------------------#2019-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/20ce64151ca21054655e66f6540432ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iZdCVNidOg8YAJ1r"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae iu" href="https://unsplash.com/@aronvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aron视觉</a>拍摄的照片</figcaption></figure><blockquote class="iv iw ix"><p id="0ad6" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">为什么这很重要？</strong></p></blockquote><p id="9bca" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">作为数据科学家，总有人问我们代码或模型的时间和空间复杂度是多少？</p><p id="65cf" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">低时间和空间复杂度对于代码的可伸缩性非常重要。</p><blockquote class="iv iw ix"><p id="0363" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">它到底是什么？</strong></p></blockquote><p id="926a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">今天，我们来看看它到底是干什么的，怎么计算的。</p><p id="ff11" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">如果我们考虑一个顺序搜索的例子。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="f7c0" class="kj kk hi kf b fi kl km l kn ko">list=[1,2,3,4,5,6,7,.......,n]</span></pre><p id="8d82" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">因此，在上述列表中搜索特定元素所需的时间取决于列表的长度(n)。在上面的列表中，要搜索第7个元素，需要7次迭代。类似地，搜索列表中的最后一个元素，需要n次迭代。</p><p id="9d04" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj">所以这里的时间复杂度是O(n)，即n的阶</strong></p><p id="f86e" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">但是程序所需的空间是常数，所以空间复杂度是O(1)。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/ee7a92782995a3900a0e646f0d7246ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CR3AwRZ2NMvOHHzzOUtfIg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">信用:<a class="ae iu" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">https://www.bigocheatsheet.com/</a></figcaption></figure><p id="2c80" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这就是数据结构操作的时间和空间复杂度。数组的时间复杂度是O(n)，而哈希表(字典)的时间复杂度是O(1)。</p><p id="a2be" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">通过这样做，让我们降低代码的时间复杂度。</p><blockquote class="iv iw ix"><p id="6372" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">任务</strong></p></blockquote><p id="b2a3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这里我们的任务是找到并计算两个列表中的公共元素。</p><p id="6d77" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">首先，我们将使用传统的方法，通过使用for循环来比较两个列表。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="12de" class="kj kk hi kf b fi kl km l kn ko">l1=[2,4,6,8,10,12,14,16,18,20]<br/>l2=[3,6,9,12,15,18,21,24,27,30]<br/>common_element=[]<br/>count=0<br/>for i in l1:<br/>    for j in l2:<br/>        if j==i:<br/>            common_element.append(j)<br/>            count+=1<br/>print('common elements:', common_element)<br/>print('number of common elements are:',count)</span><span id="982a" class="kj kk hi kf b fi kq km l kn ko">----------------------------------------------------<br/>output<br/>----------------------------------------------------<br/>common elements: [6, 12, 18]<br/>number of common elements are: 3</span></pre><p id="32f8" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在这里，我们一个接一个地检查列表l1中列表l2的元素。</p><p id="f529" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj">所以时间复杂度为O(长度(L1)*长度(l2))，空间复杂度为O(1)。</strong></p><p id="caa0" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们知道数组的时间复杂度是O(n ),但是哈希表(字典)的时间复杂度是O(1 ),这意味着查找任何元素只需要一次迭代。</p><p id="48ae" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">所以，让我们使用哈希表来降低时间复杂度。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="ce9c" class="kj kk hi kf b fi kl km l kn ko">l1=[2,4,6,8,10,12,14,16,18,20]<br/>l2=[3,6,9,12,15,18,21,24,27,30]<br/>dict={}<br/>common_element=[]<br/>for i in l1:<br/>    dict[i]=1<br/>count=0<br/>for j in l2:<br/>    if dict.get(j) == 1:<br/>        common_element.append(j)<br/>        count+=1<br/>print('common elements:', common_element)<br/>print('number of common elements are:',count)<br/>----------------------------------------------------<br/>output<br/>----------------------------------------------------<br/>common elements: [6, 12, 18]<br/>number of common elements are: 3</span></pre><p id="f8cc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这里我们创建了一个字典，它有一个列表元素的键，值为1。我们不关心值，因为我们已经将值1赋给了列表l1的元素。<br/>如果我们得到列表l2的元素的相同值(1 ),那么我们认为这个元素是公共的。</p><p id="2918" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj">该码的时间复杂度为O(长度(L1)+长度(l2))。</strong></p><p id="014c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">哇，我们把时间复杂度从O(l1*l2)降低到O(l1+l2)。</p><blockquote class="kr"><p id="d2bf" class="ks kt hi bd ku kv kw kx ky kz la jw dx translated">这种策略将帮助我们在处理大型数据集时减少运行时间。</p></blockquote><figure class="lc ld le lf lg ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/794df122c89d1bf0db744577fd37f3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*da6Pd75yBVubgrdaI7z6sg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">信用:<a class="ae iu" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">https://www.bigocheatsheet.com/</a></figcaption></figure><blockquote class="iv iw ix"><p id="b27a" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">奖金:</strong></p></blockquote><p id="072f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">机器学习模型的训练和运行时间复杂性。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/2528a2123309ca5b0dca5e40cc1708d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*ZDd-PC_425a6s81QRzBEtw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">信用:thekerneltrip.com</figcaption></figure><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="08e0" class="kj kk hi kf b fi kl km l kn ko">n : number of training sample<br/>p : number of features<br/>ntrees : number of trees<br/>nsv : Number of support vectors.<br/>nli : number of neurons at layer i in a neural network</span></pre></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="4603" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">希望这个博客能帮到你。</p><p id="8038" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><a class="ae iu" href="https://forms.gle/3QE4Kb4AMLDjwTK78" rel="noopener ugc nofollow" target="_blank">https://forms.gle/3QE4Kb4AMLDjwTK78</a></p><p id="5619" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我很乐意在<a class="ae iu" href="https://www.linkedin.com/in/prafulla-dalvi-417708104/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上与你联系。</p><p id="9507" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">谢谢你，❤️</p></div></div>    
</body>
</html>