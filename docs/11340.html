<html>
<head>
<title>Hierarchical Clustering (Agglomerative)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分层聚类(凝聚)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/hierarchical-clustering-agglomerative-f6906d440981?source=collection_archive---------5-----------------------#2020-11-30">https://medium.com/analytics-vidhya/hierarchical-clustering-agglomerative-f6906d440981?source=collection_archive---------5-----------------------#2020-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/bed92e13ab6f2877109975ba2c621617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*1aQwlT5aQqlP9jFNWlwszw.jpeg"/></div></figure><div class=""/><p id="5e36" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我们将了解层次聚类的凝聚方法、算法步骤及其数学方法。</p><p id="1718" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在深入研究分层集群之前，让我们先了解一下集群。</p><blockquote class="jk jl jm"><p id="c083" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated"><strong class="io hq"> <em class="hp">什么是聚类？<br/> </em> </strong>聚类是将对象(或数据点)划分为彼此相似而与属于另一个簇的对象(或数据点)不相似的簇的方法。</p></blockquote><p id="5e2c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">聚类可以分为两种:<br/> 1。层次聚类<br/> 2。部分聚类</p><blockquote class="jk jl jm"><p id="9bef" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated"><strong class="io hq"> <em class="hp">层次聚类<br/> </em> </strong>层次聚类是根据某种相似性度量将数据从聚类的层次结构中分离到不同的组中。</p></blockquote><p id="eb87" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">层次聚类有两种类型:<br/> 1。凝聚的<br/> 2。分裂的</p><blockquote class="jk jl jm"><p id="b5a0" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated"><strong class="io hq"> <em class="hp">凝聚式聚类<br/> </em> </strong>凝聚式聚类又称为自下而上的方法。<br/>在这种方法中，我们将所有数据点视为聚类，并根据聚类之间的距离开始合并。这将一直持续到我们形成一个大集群。</p><p id="d1c0" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated"><strong class="io hq"> <em class="hp">分裂聚类<br/> </em> </strong>分裂聚类被称为自上而下的方法。<br/>在这种方法中，我们采用巨大的集群，并开始将其分解成更小的集群，直到它到达单个数据点(或单点集群)。</p></blockquote></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><p id="be9e" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">到目前为止，我们已经看到了聚类，层次聚类，凝聚聚类和分裂聚类。现在让我们详细了解其中一种技术，凝聚聚类。</p><p id="f26d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">凝聚聚类<br/>算法</strong> 1。将每个数据点作为单点聚类。<br/> 2。用单链法取两个距离最近的聚类，使它们成为一个聚类。<br/> 3。重复步骤 2，直到只有一个集群。<br/> 4。创建一个树状图来可视化分组的历史。<br/> 5。从树状图中找出最佳聚类数。</p><p id="e3b3" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">聚集聚类的数学方法<br/> </strong>让我们获取包含客户身高和体重的数据集。为了简单起见，我只取了 6 行。</p><figure class="jz ka kb kc fd hk er es paragraph-image"><div class="er es jy"><img src="../Images/a11d815d269b293926d89cb74cdcdc3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*Q3jRriLRN7xu_txAv20dqw.jpeg"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">资料组</figcaption></figure><p id="e7ac" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们把它画在图上，更好地形象化。</p><figure class="jz ka kb kc fd hk er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kh"><img src="../Images/f3a427619d54aadfb6cf4ccfa4748cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZHSB1vZ-CKNofs68Zbuuw.jpeg"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">身高体重图</figcaption></figure><p id="b142" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">步骤 1:将每个数据点作为单点聚类。</p><p id="0362" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第二步:用单链法取两个距离最近的聚类，使它们成为一个聚类。</p><p id="2ec9" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在对每个聚类使用单一链接方法之前，我们必须知道聚类之间的距离。<br/>让我们借助距离矩阵来可视化每个集群之间的距离。这里，我取两点之间的欧几里德距离。</p><p id="9ab1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">P00 = 0，P11 = 0，P22 = 0，P33 = 0，P44 = 0 <br/>(这是因为自身距离为 0)</p><p id="7515" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">两点间的距离 P12 <br/> = sqrt( (P1。X — P2。X) + (P1。P2。y))<br/>= sqrt((170–168)+(56–60))<br/>= sqrt(4+16)= sqrt(20)= 4.47</p><p id="b73b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同样，我们必须计算所有集群之间的距离，并制作一个距离矩阵。</p><figure class="jz ka kb kc fd hk er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es km"><img src="../Images/e189a20688ae243b617374ca8d0910e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxMxsYTRy_JfJ7pUDX_ddw.jpeg"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">所有点的距离矩阵</figcaption></figure><p id="2f50" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们要看看哪两个集群的距离最小。是的，你是对的！P0 和 P4 之间的距离是 3。因此，我们必须将这两个集群组合在一起。现在，在单连接方法的帮助下，我们将合并两个集群。</p><figure class="jz ka kb kc fd hk er es paragraph-image"><div class="er es kn"><img src="../Images/ef366ebadacba5a7fd28bf2003299586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*hnBwKnBnHtwZGksMM3XvzA.jpeg"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">合并 P0 和 P4 后</figcaption></figure><p id="67a6" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我知道你在想，等一下，我们是如何得到 P1-[P0，P4]，P2-[P0，P4]，P3-[P0，P4]，P5-[P0，P4]的值的。我们借助于单连锁法得到了这些值。</p><p id="cfc3" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面说，P1 的距离-[P0，P4] = d(P1，[P0-P4]) <br/> = min(d(P1，P0)，d(P1，P4)) = min( 21.93，20 ) = 20</p><p id="d8dc" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">距离 P2-[P0，P4] = d(P2，[P0，P4]) <br/> = min(d(P2，P0)，d(P2，P4)) = min( 20.81，18.44 ) = 18.44</p><p id="9472" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同样，我们计算了所有的距离。</p><p id="a6a1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第三步:再次重复第二步<br/>，最短距离为 P1-P2。因此，下一个距离矩阵将是:</p><figure class="jz ka kb kc fd hk er es paragraph-image"><div class="er es ko"><img src="../Images/31225acbdb815da89fc2bb8eec9d9f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*meoA6exZoEvaIZWMqL5z8g.jpeg"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">合并 P1 和 P2</figcaption></figure><p id="d7e4" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">步骤 3:重复步骤 2 <br/>现在最小距离是 P3-[P0，P4]也就是 5。因此，下一个距离矩阵将是:</p><figure class="jz ka kb kc fd hk er es paragraph-image"><div class="er es kp"><img src="../Images/e5df54058615b2fe7ed12c4cc3c5b800.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*mSAu3zjyeAUd1nTB7-BbGg.jpeg"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">P3 和[P0，P4]的合并</figcaption></figure><p id="615f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第三步:重复第二步<br/>，现在最小距离是 P5-[P3，[P0，P4]]，也就是 5.83。因此，下一个距离矩阵将是:</p><figure class="jz ka kb kc fd hk er es paragraph-image"><div class="er es kq"><img src="../Images/4adefb163ad5f42552de70241346dee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*-v8Pid12VsnN43y6J3VAJw.jpeg"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">合并 P5 和[P3，[P0，P4]]</figcaption></figure><p id="10d1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">步骤 3:重复步骤 2 <br/>现在只有两个距离为 13.6 的聚类。因此，最终的距离矩阵将是:</p><figure class="jz ka kb kc fd hk er es paragraph-image"><div class="er es kr"><img src="../Images/99b0509fe27a96cbbdd202926a6dec47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*-jNPu5yIeNAYa1eXFpUdcQ.jpeg"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">[P1、P2]和[P5、[P3、[P0、P4]]]合并</figcaption></figure><p id="1a2d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">步骤 4:创建一个树状图来可视化分组的历史。</p><figure class="jz ka kb kc fd hk er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ks"><img src="../Images/61e8e6ab221b1d6d049cc4ca2a73a020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HX1h-LphKWXaZvXwRI8YuQ.jpeg"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">系统树图</figcaption></figure><p id="1083" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如我们在树状图中看到的，首先 P0 和 P4 合并，然后 P1 和 P2 合并，然后 P3 和[P0，P4]合并，然后 P5 和[P3，[P0，P4]]，最后[P1，P2]和[P5，[P3，[P0，P4]]]。</p><p id="b1c4" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">步骤 5:从树状图中找到最佳的聚类数。</p><figure class="jz ka kb kc fd hk er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kt"><img src="../Images/a4b2c377fe59f8e0e68db324ba7a9db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dnCWB4IgSot-9wr9RzQPgA.jpeg"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">系统树图</figcaption></figure><p id="ab9e" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了找到最佳的集群数量，我们需要:<br/> 1。确定不与任何其他聚类相交的最大垂直距离。<br/> 2。在上图的 A 和 B 的两端画两条水平线。<br/> 3。最佳聚类数=穿过水平线的垂直线数。</p><p id="8d49" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这里，从上面的树状图我们可以清楚地看到，有 2 条垂直线穿过水平线。</p><p id="fe95" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，最佳聚类数= 2。</p><p id="11e8" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">可视化最终聚类</strong></p><figure class="jz ka kb kc fd hk er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ku"><img src="../Images/d7233c2777472c1aced72b8721d27263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-jg7xM8QoZn_JnqmYKs0Q.jpeg"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">最终聚类</figcaption></figure><p id="3d86" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是凝聚集群的工作原理。我希望这有助于您理解使用层次聚类的一种方法。</p><p id="3e35" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">注意:</strong>我们已经使用了单一链接方法来确定两个聚类之间的距离，但是您可以使用其他链接方法来计算距离。</p><p id="477c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">参考文献:<br/> 1。<a class="ae kv" href="https://www.youtube.com/watch?v=EFhcDnw7RGY" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=EFhcDnw7RGY</a>2<br/>。<a class="ae kv" href="https://towardsdatascience.com/machine-learning-algorithms-part-12-hierarchical-agglomerative-clustering-example-in-python-1e18e0075019" rel="noopener" target="_blank">https://towards data science . com/machine-learning-algorithms-part-12-hierarchical-agglomerate-clustering-example-in-python-1e 18 e 0075019</a><br/>3 .<a class="ae kv" href="https://www.youtube.com/watch?v=9U4h6pZw6f8&amp;t=908s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=9U4h6pZw6f8&amp;t = 908s</a></p></div></div>    
</body>
</html>