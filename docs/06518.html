<html>
<head>
<title>HAND DETECTION AND FINGER COUNTING AI using Opencv python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Opencv python的手检测和手指计数人工智能</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/finger-count-ai-using-opencv-python-b9090eb68928?source=collection_archive---------3-----------------------#2020-05-25">https://medium.com/analytics-vidhya/finger-count-ai-using-opencv-python-b9090eb68928?source=collection_archive---------3-----------------------#2020-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="6f64" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" rel="noopener" href="https://medium.com/towards-data-science/inside-ai/home"> <strong class="ak">里面的艾</strong> </a></h2><div class=""/><div class=""><h2 id="7d59" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">我如何从头开始构建实时手指计数模型</h2></div><h1 id="9921" class="jg jh hi bd ji jj jk jl jm jn jo jp jq ix jr iy js ja jt jb ju jd jv je jw jx bi translated">简介:</h1><p id="fadd" class="pw-post-body-paragraph jy jz hi ka b kb kc is kd ke kf iv kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">嘿你！如果你是<strong class="ka hs"> <em class="ku">计算机视觉</em> </strong>的新生家庭成员，想要进化和了解一些很酷的opencv工具和东西。在本文中，我们将从零开始，使用python对opencv的手指计数项目进行全面的理解和实现。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/0b8dcb1e4f6169aec4ad63c1996b46bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rxRvQbRx6_trQYI5Wi-k2Q.jpeg"/></div></div></figure><blockquote class="lh li lj"><p id="9b2a" class="jy jz ku ka b kb lk is kd ke ll iv kg lm ln kj kk lo lp kn ko lq lr kr ks kt hb bi translated">该项目的代码可以在我的<a class="ae ls" href="https://github.com/Adk2001tech/OpenCV-/blob/master/finger_count.py" rel="noopener ugc nofollow" target="_blank"> Github </a>找到</p><p id="2ffa" class="jy jz ku ka b kb lk is kd ke ll iv kg lm ln kj kk lo lp kn ko lq lr kr ks kt hb bi translated">opencv python的基础也可以在我的<a class="ae ls" href="https://github.com/Adk2001tech/OpenCV-" rel="noopener ugc nofollow" target="_blank"> Github </a>获得</p></blockquote><p id="5e21" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated">为了更好地理解，我将这个过程分解为以下几个步骤:</p><p id="9ddd" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated"><strong class="ka hs">步骤1 </strong>:设置平均值。感兴趣区域的背景值。</p><p id="495f" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated"><strong class="ka hs">步骤2 </strong>:对输入ROI的手应用模糊和阈值处理，以找到轮廓。</p><p id="f267" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated"><strong class="ka hs">第三步</strong>:使用被称为<em class="ku">凸包</em>的技术沿着多边形的顶点(<em class="ku"> x，y </em>)抓取多边形。</p><p id="f283" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated"><strong class="ka hs">第四步</strong>:用数学方法计算举起的手指的数量。稍后我会解释数学相关的东西。</p><p id="e1f8" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated">第五步:把所有的东西放在一起，建造我们的项目</p><h1 id="8a52" class="jg jh hi bd ji jj jk jl jm jn jo jp jq ix jr iy js ja jt jb ju jd jv je jw jx bi translated"><strong class="ak">第一步</strong>:</h1><p id="d172" class="pw-post-body-paragraph jy jz hi ka b kb kc is kd ke kf iv kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">在计算机视觉项目中，我们更关心我们感兴趣的图像或视频中的对象。背景不应该制造噪音或分散我们的机器给出错误和意想不到的结果。在这个项目中，我们只关心我们的手进入投资回报率。为了分割出我们的手，我们将把除了我们的手以外的所有像素都变成0(零)。这可以通过服用abs来实现。我们计算的平均值的差异。当前帧/图像的背景图像。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lt lu l"/></div></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lv"><img src="../Images/a3451e3fedae7d27dca56abf99e067ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rn2yEDiBnaKiu42clu9ZsQ.jpeg"/></div></div></figure><p id="a4d4" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated">在上面的代码中，我们首先使用<strong class="ka hs"><em class="ku">cv2 . select ROI(image)</em></strong><em class="ku">w</em>抓取单个帧来选择我们的ROI，它返回我们的ROI的<em class="ku"> x，y，宽度，高度</em>。然后，对于接下来的60帧，我们将<em class="ku">的每个像素修改回</em>以成为每个帧的加权平均值。这可以使用<strong class="ka hs"><em class="ku">cv2 . accumulate weighted()，</em> </strong>来完成，它采用的参数有<em class="ku">当前帧、背景帧(后退)、学习速率。</em></p><h1 id="12a9" class="jg jh hi bd ji jj jk jl jm jn jo jp jq ix jr iy js ja jt jb ju jd jv je jw jx bi translated">第二部分:</h1><p id="9661" class="pw-post-body-paragraph jy jz hi ka b kb kc is kd ke kf iv kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">这部分处理图像预处理。由于我们的手现在被分割，我们应该应用模糊和阈值。这样做，我们现在可以很容易地找到手的边界。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lt lu l"/></div></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lw"><img src="../Images/d4918a45320af0775da816dc1fdafdf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ht93g7h06o86nw0smwPfpA.jpeg"/></div></div></figure><p id="ea58" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated">在得到背景图像(<em class="ku"> back </em>之后，我们必须应用<strong class="ka hs"><em class="ku">cv2 . convertscaleabs()</em></strong>它一般会缩放，计算绝对值，并将结果转换为8位。然后将背景图像(<em class="ku"> back </em>)和当前帧转换成灰度图像。取灰度图像的绝对差值。使用<strong class="ka hs"><em class="ku">cv2 . threshold(</em></strong><em class="ku">image，min_thresh，max_thresh，method_of_thresholding </em>应用阈值处理。<strong class="ka hs"> <em class="ku">)。</em> </strong>现在我们的<strong class="ka hs"> <em class="ku"> </em> </strong>形象被提督得其外部轮廓。它返回轮廓(边界的点(坐标)列表)，它们的层次结构。取那些覆盖最大面积的点的列表(可能是我们手段的边界坐标)。我正在创建一个<em class="ku"> img的副本，你将在下一步得到它(这只是为了</em>可视化的目的。<em class="ku"> ) </em></p><h1 id="82bf" class="jg jh hi bd ji jj jk jl jm jn jo jp jq ix jr iy js ja jt jb ju jd jv je jw jx bi translated">第三部分:</h1><p id="3206" class="pw-post-body-paragraph jy jz hi ka b kb kc is kd ke kf iv kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">凸包通过连接帧中大多数外部点周围的点来绘制多边形。首先，我们将计算最极端的点(顶部、底部、左侧和右侧)。然后我们可以计算它们的交点，那一定是我们手的中心。接下来，我们将计算距离计算中心最远的点的距离。然后使用该距离的某个比例(取决于手与手的比例),我们创建一个圆。圆圈外的任何一点，离底部足够远，都应该伸出手指。要了解这背后的更多数学知识，请查看<a class="ae ls" href="https://books.google.co.in/books?id=vkNfw8SsU3oC&amp;pg=PA707&amp;lpg=PA707&amp;dq=counting+finger+with+a+circle+of+radii+from+center+of+hand+to+exterme+finger+point&amp;source=bl&amp;ots=2Jfk-6ipz5&amp;sig=ACfU3U1nLEbtKG5Ql0AY9sC5OJsJ3uT8eQ&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwjMoJW90MzpAhUBOSsKHfZfB1UQ6AEwAHoECAkQAQ#v=onepage&amp;q=counting%20finger%20with%20a%20circle%20of%20radii%20from%20center%20of%20hand%20to%20exterme%20finger%20point&amp;f=false" rel="noopener ugc nofollow" target="_blank">和</a>。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="aeca" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated">在这段代码中，首先调用一个函数<strong class="ka hs"><em class="ku">cv2 . convex hull(contour)</em></strong>和<strong class="ka hs"> <em class="ku"> </em> </strong>将其赋给一个变量名<em class="ku">conv _赫尔。</em>然后我们抓住最极端的点(<em class="ku">上、下、左、右</em>)。这只是一个简单的坐标几何。借助此点，抓住手中心(<em class="ku"> cx，cy </em>)。现在我们可以估计半径的值(<em class="ku"> radi </em>)。然后创建与所有零值像素的<em class="ku"> img </em>形状相同的<em class="ku"> circular_roi </em>。在上面画一个我们想要的半径的圆。然后在<em class="ku"> img2 </em>和c<em class="ku">circular _ ROI</em>之间做<strong class="ka hs"><em class="ku">bitwise _ and()</em></strong>运算，存储为<em class="ku"> mask </em>。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lx"><img src="../Images/139928805a0871110f62083cc2664eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*Z347AvjQLcOPutMMuqmAjg.jpeg"/></div></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ly"><img src="../Images/b8683455ceecd9b12a9f3baa7f064fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJ4c1DFy319QTlOsgzno5g.png"/></div></div></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lz"><img src="../Images/aa1b40b858c238bca166a9d66357d928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vVVvpdjW-k9GgNjxoLoabQ.png"/></div></div></figure><h1 id="7780" class="jg jh hi bd ji jj jk jl jm jn jo jp jq ix jr iy js ja jt jb ju jd jv je jw jx bi translated">第四部分:</h1><p id="050a" class="pw-post-body-paragraph jy jz hi ka b kb kc is kd ke kf iv kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">现在是数数的时候了。为此，我们首先再次抓取<em class="ku">蒙版</em>图像的轮廓，找到边界框的坐标，并在每个框上应用一些条件，以计数它是手指或手腕还是其他东西的轮廓。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="7f53" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated">如上图。我们捕捉轮廓。做了一个名为<em class="ku">的圆周变量。</em>然后，我们对轮廓<em class="ku">找到的每个边界框/矩形进行循环。</em>计算其方向(<em class="ku"> m_x，m_y，m_w，m_h </em>)，然后对其应用两个条件。即<em class="ku">out _腕力_范围</em>和<em class="ku">极限_pts。</em>我们希望确保轮廓区域不在手部底部，如果此人在<em class="ku"> ROI </em>中有很多手臂，我们可能会在底部得到一些轮廓点，但对我们没有用处。我们可以通过简单的数学来避免这种情况。我们可以说离手中心很远的盒子一定是我们手臂的轮廓，我们可以忽略它。因此，中心以上25%的有界框是手指凸起的一部分。我们可以确定的第二个条件是沿着轮廓的点数不超过圆形<em class="ku"> ROI </em>周长的25%。这是因为机器可以计算中心以上的某些点，但不能计算手指的点。这可能是因为一些噪声，一些外部轮廓可能会弹出。所以我们为此定义了一些限制(<em class="ku"> limit_pts </em>)。</p><h1 id="e587" class="jg jh hi bd ji jj jk jl jm jn jo jp jq ix jr iy js ja jt jb ju jd jv je jw jx bi translated">第五部分:</h1><p id="bd27" class="pw-post-body-paragraph jy jz hi ka b kb kc is kd ke kf iv kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">是时候把我们到目前为止所学的东西结合起来了。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="51d8" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated">在上面的代码中，我们抓取第一帧来选择我们的<em class="ku"> ROI </em>。有了我们的<em class="ku"> ROI </em>之后，我们计算加权平均值。前60帧，然后在每次迭代中获取背景图像和当前帧的绝对差值，同时从网络摄像头读取，并将其分配给新变量(<em class="ku"> img </em>)。取灰度阈值<em class="ku"> img </em>。稍后，我们通过先找到轮廓，使用<em class="ku">转换外壳</em>功能找到多边形的极值点(坐标)。跟踪这些点的交点，我们得到手的中心点。在阈值图像和具有某些半径的圆的<em class="ku"> circular_roi </em>之间应用<em class="ku"> bitwise_and() </em>运算。如果手的尺寸小，半径就小，反之亦然。再次抓取轮廓框，并应用条件来计算举起的手指。出于可视化目的，我们在<em class="ku"> cap </em>对象正在读取的帧上标记所选<em class="ku"> ROI </em>的矩形。我们还展示了<em class="ku">遮罩</em>和<em class="ku">加权</em>图像，以重新检查我们的逻辑和代码是否正常工作。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ma"><img src="../Images/d3d5e4536c437d9a6f7e61cd3465b1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9ybexY71ri4IMsa4p21xw.jpeg"/></div></div></figure><p id="b0ff" class="pw-post-body-paragraph jy jz hi ka b kb lk is kd ke ll iv kg kh ln kj kk kl lp kn ko kp lr kr ks kt hb bi translated">最终输出应该是这样的。希望你喜欢这个项目。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mb"><img src="../Images/8bc2ed286ae0ad1dd1d547df49cf60ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/1*vVIqvZF-voj_yrM_UqW_uw.gif"/></div></div></figure></div></div>    
</body>
</html>