<html>
<head>
<title>Music Genre Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">音乐流派分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/music-genre-classification-c9a52d89e07d?source=collection_archive---------19-----------------------#2020-03-03">https://medium.com/analytics-vidhya/music-genre-classification-c9a52d89e07d?source=collection_archive---------19-----------------------#2020-03-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3369f8b02e8aa3c991acbc5e20025ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y3RQUz9NnyoHNV_f"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">娜塔莉·卡多纳在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e3f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在做了关于情感分析和聚类的小项目后，我想做一个关于分类的项目。你会说，在CNN的帮助下做一个图像分类。但是我想做一些不同的事情，介入<strong class="ix hj">音乐流派分类。</strong></p><p id="cd45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Kaggle上搜索数据集后，我找到了<a class="ae iu" href="https://www.kaggle.com/zaheenhamidani/ultimate-spotify-tracks-db" rel="noopener ugc nofollow" target="_blank">一个</a>，其中包含了从Spotify中提取的歌曲特征，如流派、流行度、可跳性、效价、节奏等。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/4ab16864359968262cc245f3fe281f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMqpD8_ubTXa_l-4LW-GQQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">df.head()</figcaption></figure><p id="0868" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据集中所有列的列表</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/2a2fe892d0a53d50f6f86a9d7cce158a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*tLEj_iGct2eDtcj1Q82ktw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">df.columns</figcaption></figure><p id="1e22" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在分析我们想要预测的流派列。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/88d11e0167544c8ccd11d87b92d4103d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*rt5zpVyKMNSOpXMmNJWYTg.png"/></div></figure><p id="b624" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们看到，与其他流派相比，“五车二”流派的歌曲非常少。从而造成阶层失衡。我们稍后将删除它，以便它不会影响分类器的性能。</p><p id="6a2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来检查是否有任何缺失值和重复值。对缺失值的检查返回0，这表明数据集是完整的。对于重复值，有一个异常(al)宋。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/9dde40a63dd8d809b36071dea291016e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vjoxn9TEX3XQgiZlI1Ws6w.png"/></div></div></figure><p id="be00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个对分类器性能有严重影响的统计数据。</p><p id="d903" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了使我们的数据为我们的分类做好准备，我们将执行以下操作:</p><ul class=""><li id="6744" class="kb kc hi ix b iy iz jc jd jg kd jk ke jo kf js kg kh ki kj bi translated">删除诸如艺术家姓名、曲目名称和曲目id之类的与预测歌曲流派毫无关系的列</li></ul><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="5dd6" class="kp kq hi kl b fi kr ks l kt ku">unused_col = ['artist_name', 'track_name', 'track_id']</span><span id="5d14" class="kp kq hi kl b fi kv ks l kt ku">df = df.drop(columns=unused_col).reset_index(drop=True)</span></pre><ul class=""><li id="30e0" class="kb kc hi ix b iy iz jc jd jg kd jk ke jo kf js kg kh ki kj bi translated">从数据集中删除五车二流派</li></ul><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="969f" class="kp kq hi kl b fi kr ks l kt ku">df = df[df['genre'] != 'A Capella']</span></pre><ul class=""><li id="b69a" class="kb kc hi ix b iy iz jc jd jg kd jk ke jo kf js kg kh ki kj bi translated">将分类值更改为数值或布尔值。</li></ul><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="c2ae" class="kp kq hi kl b fi kr ks l kt ku">mode_dict = {'Major' : 1, 'Minor' : 0}</span><span id="b1e0" class="kp kq hi kl b fi kv ks l kt ku">key_dict = {'C' : 1, 'C#' : 2, 'D' : 3, 'D#' : 4, 'E' : 5, 'F' : 6,</span><span id="de5c" class="kp kq hi kl b fi kv ks l kt ku">'F#' : 7, 'G' : 9, 'G#' : 10, 'A' : 11, 'A#' : 12, 'B' : 12}</span><span id="95c1" class="kp kq hi kl b fi kv ks l kt ku">df['time_signature'] = df['time_signature'].apply(lambda x : int(x[0])) //converting fraction into whole number since denominator is common</span><span id="9ea5" class="kp kq hi kl b fi kv ks l kt ku">df['mode'].replace(mode_dict, inplace=True)</span><span id="1820" class="kp kq hi kl b fi kv ks l kt ku">df['key'] = df['key'].replace(key_dict).astype(int)</span></pre><p id="949c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据现在可以进行分类了。我决定用三个分类器——逻辑回归、随机森林和决策树。对于这些数据中的每一个，都被分成30%的测试数据和70%的训练数据。</p><p id="21be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一，逻辑回归。这种分类模型更适合二进制分类，但是我仍然决定使用它，因为Scikit Learn提供了一个多类分类的选项。</p><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="eb4c" class="kp kq hi kl b fi kr ks l kt ku">lr_model = LogisticRegression(multi_class = 'multinomial', solver='lbfgs', max_iter=500, verbose=1)</span></pre><p id="479e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不幸的是，这仅产生了11%的准确度(</p><p id="ad1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二，随机森林分类器。这可以被认为是决策树分类器的变异版本。在大多数情况下，随机树分类器比决策树分类器具有更好的准确性，让我们看看在我们的情况下会发生什么。</p><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="10e7" class="kp kq hi kl b fi kr ks l kt ku">rfc_model = RandomForestClassifier(n_estimators=50, random_state=5, verbose=1)</span></pre><p id="c63b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这给我们带来了37%的准确率。不够好，但比逻辑回归好得多。</p><p id="fbdd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，决策树分类器。</p><pre class="ju jv jw jx fd kk kl km kn aw ko bi"><span id="bc79" class="kp kq hi kl b fi kr ks l kt ku">dt_model = DecisionTreeClassifier(max_depth=10, random_state=20)</span></pre><p id="d648" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">显然，这也给我们带来了37%的准确率。因此，对于我们的数据，随机森林和决策树的性能是相同的。</p><p id="e8f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终，这是我在分类器世界中的一小步。通过调整一些参数可以提高分类器的性能。我稍后会深入探讨这个问题，并写一些其他的帖子，因为这是一个完全不同的话题。</p></div></div>    
</body>
</html>