<html>
<head>
<title>Unbeatable Tic-Tac-Toe AI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无与伦比的井字游戏AI</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/unbeatable-tic-tac-toe-ai-3411dff06f96?source=collection_archive---------6-----------------------#2020-05-30">https://medium.com/analytics-vidhya/unbeatable-tic-tac-toe-ai-3411dff06f96?source=collection_archive---------6-----------------------#2020-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1085" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">井字游戏是一种简单的游戏。构建一个无与伦比的人工智能也很简单。人工智能将研究极大极小算法。<strong class="ih hj"> Minimax </strong>是人工智能、决策理论、博弈论、统计学和哲学中使用的决策规则，用于<em class="jd"> mini </em>最小化最坏情况下可能的损失。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/65ed773629f8ddefe86809abe2bc1362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*S1TY0mvACRM7klyG0opoug.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">工作游戏</figcaption></figure><p id="9a12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">附言</strong>假设大家都懂井字游戏！无红利(ex-dividend)</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="88b1" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">人工智能</h1><p id="680f" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">历史上，人工智能有4种不同的方法。每一个都被不同的人用不同的方法使用。</p><p id="6eab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“令人兴奋的新努力，让计算机思考……有思想的机器，在完全和字面意义上。”(豪格兰，1985) </p><p id="c7dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">理性思考，</strong> <em class="jd">“使感知、推理和行动成为可能的计算研究。”(温斯顿，1992) </em></p><p id="f285" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">为人处事，</strong> <em class="jd">“研究如何让计算机做目前比人类更好的事情。”(里奇和奈特，1991) </em></p><p id="db4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">理性行事，</strong> <em class="jd">“人工智能……关注的是人工智能的行为。”(尼尔森，1998) </em></p><p id="bf5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不会谈论更多，但我的目标是给你一些关于不同人工智能方法的直觉。</p><p id="57d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些定义来自《Russel和Norvig的人工智能》一书<em class="jd">。</em></p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="966f" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">搜索问题</h1><p id="7e1a" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">井字游戏是一个怎样的搜索问题？AI的每一步棋都是基于最后的输出。我们想创造一个永远不会输的人工智能，它可能会以平局告终，但永远不会输。所以AI必须从可用的移动中搜索，这可以导致最好的结果(赢甚至平局)。</p><h2 id="73a3" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">搜索问题的术语。</h2><p id="e711" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated"><em class="jd"> agent </em>，一个感知其环境并对该环境做出反应的实体。</p><p id="4183" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">状态，</em>代理及其环境的一种配置。</p><p id="f95a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">初始状态，</em>代理开始的状态。</p><p id="e9bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">动作，</em>状态下可以做出的选择。</p><p id="5c70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">转换模型</em>，描述在任何状态下执行任何适用的动作会产生什么状态。</p><p id="15ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">状态空间，</em>任何动作序列从初始状态可达的所有状态的集合。</p><p id="bbe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">目标测试，</em>确定给定状态是否是目标状态的方式。</p><p id="29b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">路径成本，</em>与给定路径相关的数值成本。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="6fdc" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">谅解</h1><p id="71d2" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">正如我们讨论的术语，对于井字游戏，我们的代理可以是X或o。为了简单起见，X总是先开始。你可以选择X或者o。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lo"><img src="../Images/6f0987f263866a5aa2c41d65636756fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUUkA-18OtmS9PszBWNsBQ.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">使用极大极小值的井字游戏的树结构。</figcaption></figure><p id="9ac1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，如果X赢了，我们分配1，如果O赢了，我们分配-1，如果平局，我们分配0。极大极小算法将最大化X并最小化o。在上面的图像中，下一步是X。AI必须从剩余的空间中选择输出最大值的移动。x有3个选择，它会尝试每个选择，选择最大值。井字游戏是1v1游戏。所以下一步棋是O，现在AI会扮演O，选择一个最小值。这个过程会一直持续到游戏结束。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="7f3a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">履行</h1><p id="4f8b" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">我们的游戏由这十个功能组成。其中b是棋盘，m是移动。</p><p id="a6e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">初始状态():返回空矩阵。</p><p id="db8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">COUNT(b):返回X和o的计数。</p><p id="26b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">玩家(b):返回哪个玩家在状态b下移动</p><p id="ccb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">动作(b):返回状态b中的合法动作</p><p id="a05e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果(b，m):返回在状态b中采取动作a之后的状态</p><p id="5409" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">终端(b):检查状态b是否是终端状态</p><p id="3963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">效用(b):最终状态b的最终数值</p><p id="2741" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MINIMAX(b):返回当前棋盘上的最佳走法</p><p id="714e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MAX_VALUE(b):返回板上的最大值，递归调用<em class="jd"> min_value </em></p><p id="80ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MIN_VALUE(b):返回板上的最小值，递归调用<em class="jd"> max_value </em></p><h2 id="ff34" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">初态</h2><p id="de40" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">每个井字游戏都以一个空的3x3矩阵开始。</p><pre class="jf jg jh ji fd lt lu lv lw aw lx bi"><span id="2acb" class="la jy hi lu b fi ly lz l ma mb">X = "X"<br/>O = "O"<br/>EMPTY = None<br/>def initial_state():<br/>    return [[EMPTY, EMPTY, EMPTY],<br/>            [EMPTY, EMPTY, EMPTY],<br/>            [EMPTY, EMPTY, EMPTY]]</span></pre><h2 id="fd10" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">数数</h2><p id="83af" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">这将有助于跟踪下一个要移动的玩家。返回棋盘上X和O的个数。</p><pre class="jf jg jh ji fd lt lu lv lw aw lx bi"><span id="574e" class="la jy hi lu b fi ly lz l ma mb">def count(board):<br/>    count_x, count_o = (0, 0)<br/>    for i in range(3):<br/>        for j in range(3):<br/>            if board[i][j] == X:<br/>                count_x += 1<br/>            elif board[i][j] == O:<br/>                count_o += 1<br/>    return count_x, count_o</span></pre><h2 id="a5f7" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">运动员</h2><p id="e4a6" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">追踪他们的行动。返回有下一轮机会的玩家。</p><pre class="jf jg jh ji fd lt lu lv lw aw lx bi"><span id="b21d" class="la jy hi lu b fi ly lz l ma mb">def player(board):<br/>    count_x, count_o = count(board)<br/>    if count_o + count_x == 0:<br/>        return X<br/>    elif count_x &gt; count_o and count_x + count_o != 9:<br/>        return O<br/>    elif count_x == count_o and count_x + count_o != 9:<br/>        return X<br/>    elif count_x + count_o == 9:<br/>        return X</span></pre><h2 id="a9cd" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">行动</h2><p id="95cb" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">在每种状态下，返回棋盘上所有可能动作(I，j)的集合。</p><pre class="jf jg jh ji fd lt lu lv lw aw lx bi"><span id="3c52" class="la jy hi lu b fi ly lz l ma mb">def actions(board):<br/>    action = []<br/>    for i in range(3):<br/>        for j in range(3):<br/>            if board[i][j] == EMPTY:<br/>                action.append((i, j))<br/>    return action</span></pre><h2 id="6e30" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">结果</h2><p id="2539" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">它将状态和动作作为输入，并在动作发生后返回状态。返回在棋盘上移动(I，j)产生的棋盘。</p><pre class="jf jg jh ji fd lt lu lv lw aw lx bi"><span id="feb9" class="la jy hi lu b fi ly lz l ma mb">def result(board, action):<br/>    board_copy = copy.deepcopy(board)<br/>    if not action in actions(board):<br/>        raise Exception<br/>    else:<br/>        move = player(board_copy)<br/>        i, j = action<br/>        board_copy[i][j] = move<br/>        return board_copy</span></pre><h2 id="88df" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">赢家</h2><p id="2900" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">如果游戏结束，检查状态。并返回游戏的获胜者，如果有的话。</p><pre class="jf jg jh ji fd lt lu lv lw aw lx bi"><span id="4daf" class="la jy hi lu b fi ly lz l ma mb">def winner(board):<br/>    for i in range(3):<br/>        if (board[i][0] == board[i][1] == board[i][2] and board[i][0] != EMPTY):<br/>            return board[i][2]<br/>        elif (board[0][i] == board[1][i] == board[2][i] and board[0][i] != EMPTY):<br/>            return board[2][i]</span><span id="6743" class="la jy hi lu b fi mc lz l ma mb">if (board[0][0] == board[1][1] == board[2][2] and board[0][0] != EMPTY):<br/>        return board[0][0]<br/>    elif (board[0][2] == board[1][1] == board[2][0] and board[2][0] != EMPTY):<br/>        return board[0][2]<br/>    else:<br/>        return None</span></pre><h2 id="8d8e" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">末端的</h2><p id="7d2a" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">检查游戏是否结束。如果游戏结束，则返回True，否则返回False。</p><pre class="jf jg jh ji fd lt lu lv lw aw lx bi"><span id="eba6" class="la jy hi lu b fi ly lz l ma mb">def terminal(board):<br/>    count_x, count_o = count(board)<br/>    if count_x + count_o == 9 or winner(board) != None:<br/>        return True<br/>    else:<br/>        return False</span></pre><h2 id="d220" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">效用</h2><p id="5e87" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">赢家状态的效用，如果X赢了游戏，则返回1，如果O赢了，则返回-1，否则返回0。</p><pre class="jf jg jh ji fd lt lu lv lw aw lx bi"><span id="3a26" class="la jy hi lu b fi ly lz l ma mb">def utility(board):<br/>    if winner(board) == X:<br/>        return 1<br/>    elif winner(board) == O:<br/>        return -1<br/>    elif winner(board) == None:<br/>        return 0</span></pre><h2 id="c79e" class="la jy hi bd jz lb lc ld kd le lf lg kh iq lh li kl iu lj lk kp iy ll lm kt ln bi translated">极大极小</h2><p id="66e3" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">对于参与人X，我们想最大化，所以我们用负无穷大作为一个较小的值，对于O，我们用正无穷大。</p><pre class="jf jg jh ji fd lt lu lv lw aw lx bi"><span id="dd02" class="la jy hi lu b fi ly lz l ma mb">import math</span><span id="2f33" class="la jy hi lu b fi mc lz l ma mb">def minimax(board):<br/>    if terminal(board):<br/>        return None<br/>    if player(board) == X:<br/>        vI = -math.inf<br/>        move = set()<br/>        for action in actions(board):<br/>            v = min_value(result(board,action))<br/>            if v &gt; vI:<br/>                vI = v<br/>                move = action<br/>    elif player(board) == O:<br/>        vI = math.inf<br/>        move = set()<br/>        for action in actions(board):<br/>            v = max_value(result(board,action))<br/>            if v &lt; vI:<br/>                vI = v<br/>                move = action<br/>    return move</span><span id="c19f" class="la jy hi lu b fi mc lz l ma mb">def max_value(board):<br/>    if terminal(board): <br/>        return utility(board)<br/>    v = -math.inf<br/>    for action in actions(board):<br/>        v = max(v, min_value(result(board, action)))<br/>    return v</span><span id="b9e7" class="la jy hi lu b fi mc lz l ma mb">def min_value(board):<br/>    if terminal(board): <br/>        return utility(board)<br/>    v = math.inf<br/>    for action in actions(board):<br/>        v = min(v, max_value(result(board, action)))   <br/>    return v</span></pre></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="26b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你有了工作代码。但是作为游戏怎么跑呢？</p><ol class=""><li id="9dbf" class="md me hi ih b ii ij im in iq mf iu mg iy mh jc mi mj mk ml bi translated">将上面实现的文件保存为tictactoe.py</li><li id="805f" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated"><a class="ae mr" href="https://drive.google.com/file/d/14z0eyY2OjLewQxeW7qV-Zw2jUJNlVwVE/view" rel="noopener ugc nofollow" target="_blank">下载</a> runner文件(模块名为<em class="jd"> pygame，已安装</em>)。将两个文件放在同一个文件夹中。</li><li id="cd61" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">现在运行runner.py文件。你有正常的井字游戏。</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ms"><img src="../Images/a22abcc48824a11a7e38cd432075d744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*s-ioa2NrKL5tKZ3jOxwB4w.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">最终输出</figcaption></figure></div></div>    
</body>
</html>