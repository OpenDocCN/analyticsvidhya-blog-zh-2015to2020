<html>
<head>
<title>Why use autovacuum for PostgreSQL database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么对PostgreSQL数据库使用autovacuum</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/why-use-autovacuum-for-postgresql-database-8cdd3c2253bd?source=collection_archive---------9-----------------------#2020-04-21">https://medium.com/analytics-vidhya/why-use-autovacuum-for-postgresql-database-8cdd3c2253bd?source=collection_archive---------9-----------------------#2020-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="05b4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解数据库自动清空的重要性以及如何正确设置</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ca"><img src="../Images/9f8083d95faa11667778c5fe110c54d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MaTVd4QFfcvTJHls3LL7QA.jpeg"/></div></div></figure><p id="bf15" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">作为数据库开发人员或管理员，您总是希望数据库处于最佳状态并提供最佳性能。我们经常面临这样一种情况，当我们觉得我们的数据库没有达到预期的性能并且有点慢时，我们经常选择从RDBMS切换到NoSQL数据库来克服这一点，但是这不是最终的解决方案。这里我们忽略了一点:当数据库变得越来越老时，就会产生<em class="ke">膨胀</em>。膨胀是由于数据库删除和更新操作产生的死元组造成的。当我们对数据库表的行执行删除或更新操作时，实际上我们认为这些操作后的旧数据永远消失了，但它们仍然作为死元组保留在数据库中，除非被清除。这可能会导致数据库中的几个问题。除了消耗额外的未使用空间之外，这还会降低查询速度。这就是真空发挥作用的时候。</p><p id="2dd3" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><a class="ae kf" href="https://www.postgresql.org/docs/9.5/routine-vacuuming.html" rel="noopener ugc nofollow" target="_blank">真空</a>基本上是清理这些死元组的过程，如果不加处理，这些死元组可能会导致膨胀。真空可以通过某种命令手动完成，但我们感兴趣的是一个名为<a class="ae kf" href="https://www.postgresql.org/docs/9.6/runtime-config-autovacuum.html" rel="noopener ugc nofollow" target="_blank"> auto-vacuum </a>的守护程序，它会在需要时自动触发，使我们的生活更加轻松。但是，这里有一个陷阱，需要正确设置参数，以便它可以开箱即用。在本文中，我们将关注以下主题:</p><ol class=""><li id="5b6a" class="kg kh hi jk b jl jm jo jp jr ki jv kj jz kk kd kl km kn ko bi translated"><strong class="jk hj">检查与自动真空相关的参数</strong></li><li id="4858" class="kg kh hi jk b jl kp jo kq jr kr jv ks jz kt kd kl km kn ko bi translated"><strong class="jk hj">为正确设置自动吸尘而进行的更改</strong></li></ol></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><ol class=""><li id="621b" class="kg kh hi jk b jl jm jo jp jr ki jv kj jz kk kd kl km kn ko bi translated"><strong class="jk hj">检查与自动真空相关的参数</strong></li></ol><p id="26b3" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在继续之前，我们应该了解一些与自动吸尘<strong class="jk hj"> </strong>相关的事情。</p><p id="d1e9" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">a.检查数据库表中每个表的死元组(行)数:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="f5b8" class="lg lh hi lc b fi li lj l lk ll">SELECT <br/> relname AS table_name,<br/> n_live_tup AS live_tuples,<br/> n_dead_tup AS dead_tuples<br/>FROM pg_stat_user_tables;</span></pre><p id="3230" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">上面的查询将给出相应表中死亡和存活元组的数量。如果死元组的数量非常高，那么很可能vacuum从未在您的数据库中运行过，您就有大麻烦了。</p><p id="b110" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">b.检查数据库表中上次真空和自动真空运行的时间:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="4355" class="lg lh hi lc b fi li lj l lk ll">SELECT <br/> relname AS table_name,<br/> last_vacuum,<br/> last_autovacuum<br/>FROM pg_stat_user_tables;</span></pre><p id="3e66" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">使用这个查询，您将获得数据库中vacuum状态的更大图像。如果您发现<code class="du lm ln lo lc b">last_autovacuum</code>已经运行了很长时间，那么您需要调整您的参数，我们将在下一节讨论。<br/>注意:<code class="du lm ln lo lc b">last_vacuum</code>是给定表格中最后一次手动真空运行时的时间戳。</p><p id="60e5" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">c.检查自动真空是否打开，尽管默认情况下它是打开的:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="0bb8" class="lg lh hi lc b fi li lj l lk ll">SELECT name, setting FROM pg_settings WHERE name='autovacuum';</span></pre><p id="2a87" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">d.检查与自动真空相关的配置文件中设置的参数值:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="7c67" class="lg lh hi lc b fi li lj l lk ll">show autovacuum_vacuum_scale_factor;<br/>show autovacuum_vacuum_threshold;</span></pre><p id="ada0" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">只要运行这个并检查值。我们将在下一节详细讨论这些参数。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="2c28" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">2.<strong class="jk hj">为正确设置自动真空需做的更改</strong></p><p id="ed41" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在，我们已经在数据库表中检查了autovacuum的状态，是时候计算和设置正确的值了，这样autovacuum才能正常工作。简而言之，让我们了解一些与自动真空相关的参数:</p><p id="29ab" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">a.<strong class="jk hj"><em class="ke">auto VACUUM _ VACUUM _ scale _ factor:</em></strong><em class="ke"/>指定当决定是否触发真空时，添加到autovacuum_vacuum_threshold的表格大小的一部分。默认值为0.2(表格大小的20%)。</p><p id="16d4" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">b.<strong class="jk hj"><em class="ke">auto VACUUM _ VACUUM _ threshold:</em></strong>指定在任何一个表中触发真空所需的更新或删除元组的最小数量。默认值是50个元组。</p><p id="604c" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">c.<strong class="jk hj"><em class="ke">auto vacuum _ max _ workers:</em></strong>指定可同时运行的自动真空处理(除了自动真空启动程序)的最大数量。默认值为三。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="0e76" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">对于每个表，可以触发自动真空的阈值计算如下:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="c6b7" class="lg lh hi lc b fi li lj l lk ll">vacuum_threshold = autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor * number of tuples in given table</span></pre><p id="189f" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个参数的默认值对于测试环境来说可能已经足够好了，但是对于膨胀可能很高的生产环境来说，这是完全无效的。如果没有更改这些默认值，autovacuum可能也不会运行一次。只有当给定表中死元组的数量超过从上面的表达式计算出的<code class="du lm ln lo lc b">vacuum_threshold</code>值时，才会触发自动清空。因此，如果您有一个包含一百万行的表，并且autovacuum_vacuum_threshold和autovacuum_vacuum_scale_factor设置为50和0.2，那么只有当该表中的死元组超过200k时，才会触发autovacuum。</p><p id="162d" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们检查一下这些参数的值会给出更好的结果，并以最有效的方式运行自动吸尘:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="8931" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">您可以在postgres的配置文件中更改这些参数，即<code class="du lm ln lo lc b">postgresql.conf</code>，或者使用以下类型的查询，根据不同表的大小和更新操作的频率为不同的表设置不同的值:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="3c2d" class="lg lh hi lc b fi li lj l lk ll">ALTER TABLE &lt;tablename&gt;<br/>  SET autovacuum_vacuum_scale_factor = 0.01;</span></pre><p id="b71a" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">一旦你设置了正确的值，监控它并迭代直到你找到一个完美的值。您可以使用我在本文前面提到的查询来检查autovacuum是否为每个表运行，以及它上次运行的时间。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="43a3" class="pw-post-body-paragraph ji jj hi jk b jl jm ij jn jo jp im jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我希望这篇文章对你有用。感谢阅读。欢迎评论和建议。</p></div></div>    
</body>
</html>