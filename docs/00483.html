<html>
<head>
<title>A Week of Machine Learning: 3rd Day</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习一周:第三天</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-week-of-machine-learning-3rd-day-13843fda63c3?source=collection_archive---------4-----------------------#2019-07-06">https://medium.com/analytics-vidhya/a-week-of-machine-learning-3rd-day-13843fda63c3?source=collection_archive---------4-----------------------#2019-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e0f85a0a4c968913db2591f3a5e9bba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rEA6cBGpA5KBR9pG5hu8ww.png"/></div></div></figure><h2 id="d80c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h2><p id="5c2a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">这是“机器学习的一周”系列文章的第三篇。在第一篇文章中，我讨论了机器学习、线性回归算法和评估指标的基础知识。在<a class="ae kj" rel="noopener" href="/analytics-vidhya/a-week-of-machine-learning-2nd-day-d14c4a9b08f">的第二篇文章</a>中，我探索了逻辑回归算法和SVM算法，以及它们的python代码。</p><p id="e702" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">这是7天机器学习系列的第3天。在本文中，我们将探讨两种机器学习算法——kNN(k近邻)和朴素贝叶斯。我们开始吧！</p><h1 id="cd40" class="kp ir hi bd is kq kr ks iw kt ku kv ja kw kx ky je kz la lb ji lc ld le jm lf bi translated">k-最近邻</h1><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/614f766c436202688a95622c40cf6022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yx27_aOKkLX8g8mZoLxeg.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">【https://www.saedsayad.com/images/KNN_example_1.png T4】</figcaption></figure><p id="f7bb" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">它用于分类和回归。它的概念非常简单。它找出测试样本和训练样本之间的距离。然后挑选最接近的K个样本。预测这K个样本中的优势类。</p><p id="2259" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">例如:-</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/d9baff8613079e02187e66025c05866d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*IHJDDIQxTDT_W5D3zSOLOw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated"><a class="ae kj" href="https://www.saedsayad.com/images/KNN_example_2.png" rel="noopener ugc nofollow" target="_blank">https://www.saedsayad.com/images/KNN_example_2.png</a></figcaption></figure><p id="0daf" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">让我们开始编码吧。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/b1ce07bb5e30c32aef025e1c4c57606b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AuqMt26dHF8W_KhNObHQ7A.png"/></div></div></figure><p id="33bc" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">正在导入所需的库。Sklearn库有一个非常好的KNN实现。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/a712171169de9d6f2536906efe1f9c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNYxYWfpXAktmewIgUW-cg.png"/></div></div></figure><p id="56fa" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">从链接加载数据到熊猫数据帧。该数据集存在于互联网上，我们也可以加载本地存在于我们系统中的数据集。我们必须提供该数据的完整路径。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/803179ae7d69cbc6afdf9d9ece9df7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RIUr0afQZN4z7haZXGRLfA.png"/></div></div></figure><p id="9688" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">这将打印前五行。我们用它来查看我们的数据。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/cbc7682607110c4936827d360c9bafb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yxWDIAyaMsCxKN3CLMTphQ.png"/></div></div></figure><p id="d32d" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">这给出了我们数据的基本细节。您应该自己运行所有这些命令。和他们一起玩，你会很容易学会的。输出显示数据中的一列有空值。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/12ffb938f4e2f061b54274604c01013a.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*W93khG3ENb6GZZDRIYxhWw.png"/></div></figure><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/6d927a8b092a908d4c3fc90e9557de0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mfjxAQvP3j4eZZKTNuJ3OQ.png"/></div></div></figure><p id="8f9c" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">我们的数据有空值，我们使用<em class="ly"> fillna </em>用0填充这些空值。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/f2ad87b85e206d54e7f8776c0c7729a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzLFxOmuQiFNhNngyIc6oQ.png"/></div></div></figure><p id="c008" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">将目标变量和特性放在不同的变量中，这样我们就可以轻松地使用它们。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/05f2ce19436ccb4b7dbf6ea2d151fec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTrR_TZkH693RHTyXmjzSA.png"/></div></div></figure><p id="161b" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">我们将数据分为训练集和测试集。训练集将用于拟合我们的模型，测试集将用于验证。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/cadd9bdaa8a6299adc061d11a23addd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdypnPwpLDuIspJgUsxrDQ.png"/></div></div></figure><p id="49e9" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">我们正在使用sklearn库的<em class="ly"> KNeighborsClassifier </em>类训练我们的模型。方法拟合用于训练分类器。使用评分法来检查分类器的性能。它返回准确性，并接受两个参数测试特性和正确的目标值。</p><h1 id="3d67" class="kp ir hi bd is kq kr ks iw kt ku kv ja kw kx ky je kz la lb ji lc ld le jm lf bi translated">KNN回归</h1><p id="629a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">在回归的情况下，输出值是所有K个最接近值的平均值。</p><h2 id="d768" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">密码</h2><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="c3a1" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">让我们来分解代码。它类似于分类代码。唯一的区别是数据集和模型。我们将讨论这两个部分。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/56a2bb71d6effef29e4ae8d8aeb9ee98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFfuSJB9ZOnYX_o91cXtzA.png"/></div></div></figure><p id="3689" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">我们使用了波士顿房价数据集。我们必须预测给定某些特征的房子的价格，或者我们可以说房子的质量。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/03e8fdd1a868f97bc08211febee3a52a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NRbDKUf8G-IrKBi_14e1lg.png"/></div></div></figure><p id="f011" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">我们使用<strong class="jq hj">均方误差</strong>来检查我们模型的性能。模型的性能通过不同的度量标准来检查，这些度量标准取决于问题和数据的类型。我们的模型误差越小越好。</p><h1 id="71ed" class="kp ir hi bd is kq kr ks iw kt ku kv ja kw kx ky je kz la lb ji lc ld le jm lf bi translated">朴素贝叶斯</h1><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es me"><img src="../Images/5d9e008a1402b0e5df2f076982c50c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*QeCRN2uQCKk39WcLrbTv4w.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">https://www.saedsayad.com/images/Bayes_rule.png<a class="ae kj" href="https://www.saedsayad.com/images/Bayes_rule.png" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="27e8" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">这是一个概率分类器。它使用贝叶斯定理。它假设特征之间没有相关性。然后使用条件概率来预测因变量，即我们的目标值。所有特征都被视为独立的。现在，请记住这些事情。随着你在数学概念的帮助下在这个领域前进，你会更加清楚。如果你有数学背景，我想你有。举个例子，你会更清楚。</p><h2 id="0d30" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">密码</h2><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="538e" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">这里唯一的区别是分类器，代码的其余部分是相似的。朴素贝叶斯是一种非常快速的算法，因为与其他算法相比，它需要做更少的计算。我这篇文章的目的是让初学者熟悉这些算法。慢慢地，渐渐地，你会适应它们。你应该越来越多地练习。找到一些数据集并尝试实现这些算法。尽可能多做实验。</p><h2 id="eed4" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">感谢阅读。快乐学习！！</h2></div></div>    
</body>
</html>