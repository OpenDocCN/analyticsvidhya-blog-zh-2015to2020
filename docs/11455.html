<html>
<head>
<title>Stack Overflow Question Tagger</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆栈溢出问题标签</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/stack-overflow-question-tagger-96a045c1ca4c?source=collection_archive---------21-----------------------#2020-12-03">https://medium.com/analytics-vidhya/stack-overflow-question-tagger-96a045c1ca4c?source=collection_archive---------21-----------------------#2020-12-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a42d8e34ca13ff1d7d6598f9a3c5e9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZR-6mVLWHoQr7vBIU2-kw.png"/></div></div></figure><h2 id="ee1e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">背景</h2><p id="a207" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">如果我断言每个开发人员/工程师/学生在他们的旅程中都不止一次地使用过网站堆栈溢出，我不会说谎。被广泛认为是开发者学习和分享知识的最大和最值得信赖的网站之一，该网站目前拥有超过 10，000，000 个问题。在这篇文章中，我们试图根据网站上的问题文本来预测问题标签。网站上最常见的标签包括 Java、JavaScript、C#、PHP、Android 等等。</p><p id="a96f" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">标签的正确预测对于确保问题被建议给在与所建议的主题相关的回答方面具有丰富经验的用户是很重要的。</p><h2 id="e5d0" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">数据</strong></h2><p id="5fa1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">数据收集自脸书在 ka ggle(<a class="ae ko" href="https://www.kaggle.com/c/facebook-recruiting-iii-keyword-extraction/data" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/c/Facebook-recruiting-iii-Keyword-Extraction/data</a>)上举办的关键词提取大赛。</p><p id="a2fb" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">在解压缩数据集时，我们获得了 train.csv 和 text.csv 文件。</p><p id="0c98" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj"> Train.csv </strong>包含 4 列:Id、标题、正文、标签。主体由大量计算机代码组成，这是一个需要尽早解决的问题。<br/> <strong class="jq hj"> Test.csv </strong>包含相同的列，但是没有标签。<br/> <strong class="jq hj">火车大小. csv </strong> — 6.75GB <br/> <strong class="jq hj">火车大小. csv </strong> — 2GB</p><p id="5acc" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">train . CSV 中的行数</strong> = 6034195 <br/>这些问题是随机的，既包含冗长的文本网站，也包含与数学和编程相关的网站。每个站点的问题数量可能会有所不同，并且没有对问题进行过滤(如封闭式问题)。</p><p id="aee5" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">属性解释- </strong></p><blockquote class="kp kq kr"><p id="c348" class="jo jp ks jq b jr kj jt ju jv kk jx jy kt kl ka kb ku km kd ke kv kn kg kh ki hb bi translated"><strong class="jq hj"> Id </strong> -每个问题的唯一标识符<br/> <br/> <strong class="jq hj">标题</strong> -问题的标题<br/> <br/> <strong class="jq hj">正文</strong> -问题的正文<br/> <br/> <strong class="jq hj">标签</strong> -以空格分隔的格式与问题相关联的标签(全部小写，不应包含制表符' \t '或&amp;符号'【T36 ')</p></blockquote><h2 id="ea48" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">约束条件- </strong></h2><p id="3c14" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">与所有信息检索模型一样，高精度和高召回率是必须的。错误的标签会影响精确度，而遗漏的标签会影响召回率。两者都妨碍了用户在网站上的体验。延迟要求并不严格。</p><h2 id="80d8" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">预测问题-</h2><p id="bdb6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">我们的问题本质上是一个多标签分类问题，其中每个标签都是一个标签，并且它们的预测本质上不是互斥的。</p><p id="06f2" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">要使用的评估指标是微平均 F1 分数，它完美地同时包含了精确度和召回率。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/12a32ebe4672dec70be6bdc8515f4d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sRW4ti4a4YV1NkjNey1n7Q.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">来自竞争网站的绩效指标</figcaption></figure><p id="05a8" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">因为微观 F1 分数包括特定类别的真阳性、假阳性和假阴性的数量，所以它还固有地通过数据点的频率对每个类别进行加权。然而，宏观 F1 分数没有这种偏差。这是一个简单的平均函数。</p><p id="aabf" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们使用微观 F1 分数来说明班级规模的不平等。</p><h2 id="c4ab" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">探索性数据分析</strong></h2><p id="f5c8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">数据从 csv 文件加载到 SQLite 数据库。重复问题的删除是通过 SQL 查询完成的。数据库中的原始行数是 6034196。重复数据删除后的新数据库包含 4206314 行。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/3415717a6d67b9a49b03c1750f594950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxTlSIpiE1L9aL7e8788_g.png"/></div></div></figure><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="e960" class="iq ir hi lh b fi ll lm l ln lo">#Code to get the bag of words vocabulary for the tags<br/>tags = vectorizer.get_feature_names()</span></pre><p id="e5a2" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">让我们看看一些按字母顺序排序的标签及其数量。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/43a8f63ab45ca2eb8f08d1886b419a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*g1grMG1j9s7c5sxapnyRAw.png"/></div></figure><p id="0c38" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们按照出现次数的降序对标签进行排序，然后绘制分布图。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="72d5" class="iq ir hi lh b fi ll lm l ln lo">plt.plot(tag_counts)</span><span id="aeeb" class="iq ir hi lh b fi lq lm l ln lo">plt.title(“Distribution of number of times tag appeared questions”)</span><span id="3397" class="iq ir hi lh b fi lq lm l ln lo">plt.grid()</span><span id="6a3a" class="iq ir hi lh b fi lq lm l ln lo">plt.xlabel(“Tag number”)</span><span id="259b" class="iq ir hi lh b fi lq lm l ln lo">plt.ylabel(“Number of times tag appeared”)</span><span id="0b77" class="iq ir hi lh b fi lq lm l ln lo">plt.show()</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/af844fa62d1786cee3e2b0f32cecac9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rW6DFwiTgPmmrowZ8T-Rww.png"/></div></div></figure><p id="ff34" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">值得注意的是，分布是高度倾斜的，最频繁的标签出现超过 300 万次，而较罕见的标签出现大约一次。</p><p id="899d" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们需要放大数据，以便更好地了解分布情况。我们现在考虑前 100 个标签。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/91bb622b165c9697a74c2e5aa8048b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJN6X32Y8k1eLRqKx3cLtw.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">请注意，0→100 个百分点，25→75 个百分点，因为这是按降序排列的。</figcaption></figure><p id="2f4d" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">分位数的下降仍然很显著。第 75 百分位仅包含 100 百分位值的 15%。随着分位数的下降，这些数字变得更低。</p><p id="dc18" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">事实上，仅前 14 个标签就被使用了超过 100 万次。最常用的标签(C#)使用了 331505 次。</p><p id="d492" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">标签频率的巨大变化证明微观平均 F1 分数是合适的度量。</p><p id="76f1" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们现在绘制每个问题的标签数量。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="9d6c" class="iq ir hi lh b fi ll lm l ln lo">sns.countplot(tag_quest_count, palette='gist_rainbow')</span><span id="173e" class="iq ir hi lh b fi lq lm l ln lo">plt.title("Number of tags in the questions ")</span><span id="023b" class="iq ir hi lh b fi lq lm l ln lo">plt.xlabel("Number of Tags")</span><span id="d3bc" class="iq ir hi lh b fi lq lm l ln lo">plt.ylabel("Number of questions")</span><span id="57ec" class="iq ir hi lh b fi lq lm l ln lo">plt.show()</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/83dea456d80ea78f99af612f2785d20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBSXyOhtgQxfTrAthIZcbQ.png"/></div></div></figure><p id="f5de" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">大多数问题有 2-3 个标签，平均在 2.9 左右。每个问题的标签范围是从 1 到 5。</p><p id="b60f" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们现在为标签绘制单词 Cloud。每个单词的字体大小与其出现的频率成正比。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="dce5" class="iq ir hi lh b fi ll lm l ln lo">tup = dict(result.items())</span><span id="cb5b" class="iq ir hi lh b fi lq lm l ln lo">#Initializing WordCloud using frequencies of tags.</span><span id="f168" class="iq ir hi lh b fi lq lm l ln lo">wordcloud = WordCloud( background_color=’black’,</span><span id="3e3a" class="iq ir hi lh b fi lq lm l ln lo">width=1600,</span><span id="5d83" class="iq ir hi lh b fi lq lm l ln lo">height=800,</span><span id="0bf5" class="iq ir hi lh b fi lq lm l ln lo">).generate_from_frequencies(tup)</span><span id="3cc0" class="iq ir hi lh b fi lq lm l ln lo">fig = plt.figure(figsize=(30,20))</span><span id="a168" class="iq ir hi lh b fi lq lm l ln lo">plt.imshow(wordcloud)</span><span id="2c08" class="iq ir hi lh b fi lq lm l ln lo">plt.axis(‘off’)</span><span id="0125" class="iq ir hi lh b fi lq lm l ln lo">plt.tight_layout(pad=0)</span><span id="57ae" class="iq ir hi lh b fi lq lm l ln lo">fig.savefig(“tag.png”)</span><span id="fa81" class="iq ir hi lh b fi lq lm l ln lo">plt.show()</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/a79a04d85a425150120501d9d899e976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kc7uMaCaPhTUEurPhT1tpg.png"/></div></div></figure><p id="fd00" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">让我们来看看前 20 个标签。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/f0828544f2484d6f44249a031bc273bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66tx9qKUITGPTDiez0glPg.png"/></div></div></figure><p id="27ba" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">大多数顶级标签都与编程语言和平台相关联。</p><h2 id="13d3" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">文本预处理</strong></h2><p id="f57f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">由于计算能力的限制，从 400 万个数据点中抽取了 100 万个数据点。</p><p id="75a6" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">让我们来看一个示例数据点。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="39c5" class="iq ir hi lh b fi ll lm l ln lo"><strong class="lh hj">Title</strong>:  Implementing Boundary Value Analysis of Software Testing in a C++ program?<br/><strong class="lh hj">Body </strong>:</span><span id="fe7e" class="iq ir hi lh b fi lq lm l ln lo">#include&lt;<br/>        iostream&gt;\n<br/>        #include&lt;<br/>        stdlib.h&gt;\n\n<br/>        using namespace std;\n\n<br/>        int main()\n<br/>        {\n<br/>                 int n,a[n],x,c,u[n],m[n],e[n][4];\n         <br/>                 cout&lt;&lt;"Enter the number of variables";\n         cin&gt;&gt;n;\n\n         <br/>                 cout&lt;&lt;"Enter the Lower, and Upper Limits of the variables";\n         <br/>                 for(int y=1; y&lt;n+1; y++)\n         <br/>                 {\n                 <br/>                    cin&gt;&gt;m[y];\n                 <br/>                    cin&gt;&gt;u[y];\n         <br/>                 }\n         <br/>                 for(x=1; x&lt;n+1; x++)\n         <br/>                 {\n                 <br/>                    a[x] = (m[x] + u[x])/2;\n         <br/>                 }\n         <br/>                 c=(n*4)-4;\n         <br/>                 for(int a1=1; a1&lt;n+1; a1++)\n         <br/>                 {\n\n             <br/>                    e[a1][0] = m[a1];\n             <br/>                    e[a1][1] = m[a1]+1;\n             <br/>                    e[a1][2] = u[a1]-1;\n             <br/>                    e[a1][3] = u[a1];\n         <br/>                 }\n         <br/>                 for(int i=1; i&lt;n+1; i++)\n         <br/>                 {\n            <br/>                    for(int l=1; l&lt;=i; l++)\n            <br/>                    {\n                 <br/>                        if(l!=1)\n                 <br/>                        {\n                    <br/>                            cout&lt;&lt;a[l]&lt;&lt;"\\t";\n                 <br/>                        }\n            <br/>                    }\n            <br/>                    for(int j=0; j&lt;4; j++)\n            <br/>                    {\n                <br/>                        cout&lt;&lt;e[i][j];\n                <br/>                        for(int k=0; k&lt;n-(i+1); k++)\n                <br/>                        {\n                    <br/>                            cout&lt;&lt;a[k]&lt;&lt;"\\t";\n               <br/>                        }\n                <br/>                        cout&lt;&lt;"\\n";\n            <br/>                    }\n        <br/>                 }    \n\n        <br/>                 system("PAUSE");\n        <br/>                 return 0;    \n<br/>        }\n</span><span id="6c96" class="iq ir hi lh b fi lq lm l ln lo">\n\n</span><span id="50e6" class="iq ir hi lh b fi lq lm l ln lo">&lt;p&gt;The answer should come in the form of a table like&lt;/p&gt;\n\n<br/>    &lt;pre&gt;&lt;code&gt;       <br/>    1            50              50\n       <br/>    2            50              50\n       <br/>    99           50              50\n       <br/>    100          50              50\n       <br/>    50           1               50\n       <br/>    50           2               50\n       <br/>    50           99              50\n       <br/>    50           100             50\n       <br/>    50           50              1\n       <br/>    50           50              2\n       <br/>    50           50              99\n       <br/>    50           50              100\n<br/>    &lt;/code&gt;&lt;/pre&gt;\n\n<br/>    &lt;p&gt;if the no of inputs is 3 and their ranges are\n<br/>    1,100\n<br/>    1,100\n<br/>    1,100\n<br/>    (could be varied too)&lt;/p&gt;\n\n<br/>    &lt;p&gt;The output is not coming,can anyone correct the code or tell me what\'s wrong?&lt;/p&gt;\n'</span><span id="dd37" class="iq ir hi lh b fi lq lm l ln lo"><strong class="lh hj">Tags </strong>: 'c++ c'</span></pre><p id="485d" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">预处理采取了以下步骤-</p><ol class=""><li id="50ec" class="lw lx hi jq b jr kj jv kk jb ly jf lz jj ma ki mb mc md me bi translated">使用正则表达式从标题和正文(不包括代码)中删除了特殊字符。</li><li id="586e" class="lw lx hi jq b jr mf jv mg jb mh jf mi jj mj ki mb mc md me bi translated">停用词已被删除。(C 除外)。</li><li id="f7d1" class="lw lx hi jq b jr mf jv mg jb mh jf mi jj mj ki mb mc md me bi translated">HTML 标签(“<something>”)被移除。(这些用于将问题/答案的特定单词加粗，例如<b> Python </b>)</something></li><li id="b988" class="lw lx hi jq b jr mf jv mg jb mh jf mi jj mj ki mb mc md me bi translated">将单词转换成小写，然后用雪球斯特梅尔做词干。</li><li id="2140" class="lw lx hi jq b jr mf jv mg jb mh jf mi jj mj ki mb mc md me bi translated">每个问题都是标题+问题，因此取消了“标题”栏</li></ol><p id="69f6" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">这是一些问题体处理后的样子。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="b17e" class="iq ir hi lh b fi ll lm l ln lo">('ef code first defin one mani relationship differ key troubl defin one zero mani relationship entiti ef object model look like use fluent api object composit pk defin batch id batch detail id use fluent api object composit pk defin batch detail id compani id map exist databas tpt basic idea submittedtransact zero mani submittedsplittransact associ navig realli need one way submittedtransact submittedsplittransact need dbcontext class onmodelcr overrid map class lazi load occur submittedtransact submittedsplittransact help would much appreci edit taken advic made follow chang dbcontext class ad follow onmodelcr overrid must miss someth get follow except thrown submittedtransact key batch id batch detail id zero one mani submittedsplittransact key batch detail id compani id rather assum convent creat relationship two object configur requir sinc obvious wrong',) ---------------------------------------------------------------------------------------------------- ('explan new statement review section c code came accross statement block come accross new oper use way someon explain new call way',) ---------------------------------------------------------------------------------------------------- ('error function notat function solv logic riddl iloczyni list structur list possibl candid solut list possibl coordin matrix wan na choos one candid compar possibl candid element equal wan na delet coordin call function skasuj look like ni knowledg haskel cant see what wrong',) ---------------------------------------------------------------------------------------------------- ('step plan move one isp anoth one work busi plan switch isp realli soon need chang lot inform dns wan wan wifi question guy help mayb peopl plan correct chang current isp new one first dns know receiv new ip isp major chang need take consider exchang server owa vpn two site link wireless connect km away citrix server vmware exchang domain control link place import server crucial step inform need know avoid downtim busi regard ndavid',) ---------------------------------------------------------------------------------------------------- ('use ef migrat creat databas googl migrat tutori af first run applic creat databas ef enabl migrat way creat databas migrat rune applic tri',) ---------------------------------------------------------------------------------------------------- ('magento unit test problem magento site recent look way check integr magento site given point unit test jump one method would assum would big job write whole lot test check everyth site work anyon involv unit test magento advis follow possibl test whole site custom modul nis exampl test would amaz given site heavili link databas would nbe possibl fulli test site without disturb databas better way automaticlli check integr magento site say integr realli mean fault site ship payment etc work correct',) ---------------------------------------------------------------------------------------------------- ('find network devic without bonjour write mac applic need discov mac pcs iphon ipad connect wifi network bonjour seem reason choic turn problem mani type router mine exampl work block bonjour servic need find ip devic tri connect applic specif port determin process run best approach accomplish task without violat app store sandbox',) ---------------------------------------------------------------------------------------------------- ('send multipl row mysql databas want send user mysql databas column user skill time nnow want abl add one row user differ time etc would code send databas nthen use help schema',) ---------------------------------------------------------------------------------------------------- ('insert data mysql php powerpoint event powerpoint present run continu way updat slide present automat data mysql databas websit',) --------------------------------------------------------------------------------------------------<strong class="lh hj">--</strong></span></pre><h2 id="20c9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">造型- </strong></h2><p id="1ca6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">提出这种多标签分类问题作为二分类对于我们应用各种 ML 模型是至关重要的。42000 标签上一个 vs Rest 分类会太慢。分类器链的使用是相关的，因为标签本身可能是相关的。例如，“C++”的出现也可能触发“指针”的出现。标号幂集可能导致大量类的产生。采用现有算法进行多标签分类是另一种方法。关于这个话题的更多信息可以在<a class="ae ko" href="https://www.analyticsvidhya.com/blog/2017/08/introduction-to-multi-label-classification/" rel="noopener ugc nofollow" target="_blank">这个链接</a>上找到。</p><p id="41f0" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">由于计算的限制，我们不能使用所有的标签作为类。我们需要根据“部分覆盖”的出现频率选择顶部标签</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/e0bdcf23e24654874588938fbe4be171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnINhbSHPH1mCuAIKtmlOg.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">覆盖的问题与标签数量的百分比</figcaption></figure><p id="bf1b" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">仅使用前 5500 个标签就能让我们部分覆盖超过 99%的问题<strong class="jq hj"/>。</p><p id="28b5" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">随机执行 80-20 比例的训练测试分割。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="a758" class="iq ir hi lh b fi ll lm l ln lo">total_size=preprocessed_data.shape[0]</span><span id="d97e" class="iq ir hi lh b fi lq lm l ln lo">train_size=int(0.80*total_size)</span><span id="272b" class="iq ir hi lh b fi lq lm l ln lo">x_train=preprocessed_data.head(train_size)</span><span id="f608" class="iq ir hi lh b fi lq lm l ln lo">x_test=preprocessed_data.tail(total_size — train_size)</span><span id="cf61" class="iq ir hi lh b fi lq lm l ln lo">y_train = multilabel_yx[0:train_size,:]</span><span id="8acc" class="iq ir hi lh b fi lq lm l ln lo">y_test = multilabel_yx[train_size:total_size,:]</span></pre><p id="59ed" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们将问题的预处理文本数据转换成 Tf-Idf 形式。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="f0ce" class="iq ir hi lh b fi ll lm l ln lo">vectorizer = TfidfVectorizer(min_df=0.00009, max_features=200000, smooth_idf=True, norm="l2", \</span><span id="1f51" class="iq ir hi lh b fi lq lm l ln lo">tokenizer = lambda x: x.split(), sublinear_tf=False, ngram_range=(1,3))</span><span id="9182" class="iq ir hi lh b fi lq lm l ln lo">x_train_multilabel = vectorizer.fit_transform(x_train['question'])</span><span id="8efb" class="iq ir hi lh b fi lq lm l ln lo">x_test_multilabel = vectorizer.transform(x_test['question'])</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/497d90dce51b7164b8d780e71bc201cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ojam0NnQhw9LwWzTu0aoPA.png"/></div></div></figure><p id="7b09" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们的特征向量是 88244 维，而标签向量是 5500 维。我们遇到了一个问题。</p><p id="edac" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">Tf-idf 矢量器将这些高维向量存储为稀疏向量。scikit-multilearn' library 试图将这种稀疏向量表示转换为正常的密集数据矩阵，以供自己使用，这给我们带来了一个内存错误。因此，在这种情况下，我们没有使用 MLKNN(KNN 的多标签算法)。</p><p id="d467" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们使用一个 vs Rest 分类器。该算法分别训练 5500 个分类器，并使用它们的结果。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="16ef" class="iq ir hi lh b fi ll lm l ln lo">classifier = OneVsRestClassifier(SGDClassifier(loss='log', alpha=0.00001, penalty='l1'), n_jobs=-1)</span><span id="6732" class="iq ir hi lh b fi lq lm l ln lo">classifier.fit(x_train_multilabel, y_train)</span><span id="7db3" class="iq ir hi lh b fi lq lm l ln lo">predictions = classifier.predict(x_test_multilabel)</span><span id="a079" class="iq ir hi lh b fi lq lm l ln lo">print("accuracy :",metrics.accuracy_score(y_test,predictions))</span><span id="ada9" class="iq ir hi lh b fi lq lm l ln lo">print("macro f1 score :",metrics.f1_score(y_test, predictions, average = 'macro'))</span><span id="b58a" class="iq ir hi lh b fi lq lm l ln lo">print("micro f1 scoore :",metrics.f1_score(y_test, predictions, average = 'micro'))</span><span id="96bd" class="iq ir hi lh b fi lq lm l ln lo">print("hamming loss :",metrics.hamming_loss(y_test,predictions))</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/489453b37d87cd7211a191d361633838.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*A3UB_VsSfOGrOhub4GR6Ug.png"/></div></figure><p id="da60" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">这是前 10 个标签的精确召回报告-</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/b0ce49383850f1731a53ca18874918a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*r-KKL7j0f_4F6aISmsAzCQ.png"/></div></figure><p id="fa62" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">正如我们所观察到的，这些指标相对较低。由于数据集很大，超参数调整受到限制。培训在中级笔记本电脑(i5 处理器)上进行，大约需要 9 个小时。因此，我们重复相同的过程，但现在是 50 万个数据点，取前 500 个标签(占问题的 90%部分覆盖率)。</p><p id="1fc3" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">还执行了特征工程的另一步骤。问题的标题比正文更重要。这是通过使 question= title*3+ question(而不是 title+question)完成的，并存储在另一个数据库的表中，从该表中查询该问题。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/299a34762685b9a485ca2204aaf51692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*HI-sm40nOvpn4GgmNFMynQ.png"/></div></figure><p id="4f0a" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">正如所见，这些指标与之前的培训相比有所改进。召回率仍然很低，这增加了我们的模型丢失标签的可能性。可以通过进一步的调整来解决这个问题。</p><p id="bbf8" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">特别提及:【https://youtu.be/nNDqbUhtIRg】T4</p><h1 id="453c" class="mp ir hi bd is mq mr ms iw mt mu mv ja mw mx my je mz na nb ji nc nd ne jm nf bi translated">使用 MLFlow 管道:</h1><p id="bf15" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">虽然上面的方法对于小型的个人项目是可以的，但是一个更大的项目需要团队之间的合作，这就是 ML 生命周期跟踪变得必要的地方。</p><p id="1b06" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">从开源 MLFlow 项目的 Github 存储库中，</p><blockquote class="kp kq kr"><p id="ad86" class="jo jp ks jq b jr kj jt ju jv kk jx jy kt kl ka kb ku km kd ke kv kn kg kh ki hb bi translated">MLflow 是一个简化机器学习开发的平台，包括跟踪实验，将代码打包成可复制的运行，以及共享和部署模型。MLflow 提供了一组轻量级 API，可用于任何现有的机器学习应用程序或库(TensorFlow、PyTorch、XGBoost 等)，无论您当前在哪里运行 ML 代码(例如，在笔记本、独立应用程序或云中)。</p></blockquote><p id="4b0c" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">即使到目前为止，49%的企业只是在探索机器学习的大量用例，而没有具体的计划。这部分是因为他们采用简单的传统软件工程工具包来解决与 ML 工作流相关的挑战性问题，如处理规模、记录管道的各个方面，如数据工程、分析、建模、部署、这些团队之间的协作、跟踪和监控过去的实验等。</p><p id="eb1f" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">这就是 MLFlow 发挥作用的地方。一般来说，MLFlow 用于-</p><ol class=""><li id="823b" class="lw lx hi jq b jr kj jv kk jb ly jf lz jj ma ki mb mc md me bi translated">数据分析和统计推断，为业务问题选择一系列模型</li><li id="c0df" class="lw lx hi jq b jr mf jv mg jb mh jf mi jj mj ki mb mc md me bi translated">设计 MLFlow 实验以确定模型的最佳超参数。</li><li id="db2f" class="lw lx hi jq b jr mf jv mg jb mh jf mi jj mj ki mb mc md me bi translated">使用 Apache Spark 训练和部署大规模 ML 模型。</li></ol><p id="122e" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">这些都是使用 MLFlow 的不同组件完成的，我们将在下面讨论。</p><h2 id="4dcc" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">ml 流跟踪:监视和日志记录实验</h2><p id="3e35" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">Databricks Community Edition 工作区将是理想的，因为它们是 MLFlow 的提供者。然而，他们不允许超过 1 GB 的存储空间，所以我不得不使用 Colab 进行 MLFlow]</p><p id="3d4c" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">Ngrok 用于从 Google Colab 部署本地主机服务器。然后开始 MLFlow 训练，并记录参数(alpha)、度量分数和模型 pickle 文件。</p><p id="4f19" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">将 MLFlow 文件作为 zip 文件夹下载到您的本地计算机上。它们包含一组 alphas 的单独运行作为超参数。</p><h2 id="3630" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">MLFlow 项目:</h2><p id="fb80" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">在内部，工件文件夹将是 model.pkl 文件。MLmodel 文件中提到了项目的入口点和模型风格。</p><p id="c82e" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">要在端点部署模型，克隆 Github 存储库并使用:</p><blockquote class="kp kq kr"><p id="b904" class="jo jp ks jq b jr kj jt ju jv kk jx jy kt kl ka kb ku km kd ke kv kn kg kh ki hb bi translated">mlflow 型号 serve-m 4ce 61665 C3 e 443 a4 b 21 FB 605969 a1b 44/artifacts/model/-h 127 . 0 . 0 . 1-p 5000</p></blockquote></div></div>    
</body>
</html>