<html>
<head>
<title>Access specifier in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的访问说明符</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/access-specifier-in-swift-4c6698eb3577?source=collection_archive---------0-----------------------#2020-01-31">https://medium.com/analytics-vidhya/access-specifier-in-swift-4c6698eb3577?source=collection_archive---------0-----------------------#2020-01-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="eac7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">控制代码的可访问性</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/97f0c70b22297193cf05b42d98363f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOd-VBlPMSnyHuq-k48KrA.png"/></div></div></figure><h2 id="189b" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">什么是访问说明符？</h2><p id="c0ce" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">访问说明符是帮助代码块的<em class="la">访问控制的关键字。<em class="la">访问控制</em>限制其他源文件和模块中的代码对您的代码部分的访问。</em></p><blockquote class="lb lc ld"><p id="b448" class="kh ki la kj b kk le ij km kn lf im kp lg lh kr ks li lj ku kv lk ll kx ky kz hb bi translated">封装是面向对象编程的一个支柱，访问说明符有助于封装。</p></blockquote><p id="3997" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lh kr ks jy lj ku kv kc ll kx ky kz hb bi translated"><strong class="kj hj">什么是封装？</strong></p><p id="85d3" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lh kr ks jy lj ku kv kc ll kx ky kz hb bi translated">封装被定义为将数据包装在一个单元下。它是将代码和它所处理的数据绑定在一起的机制。考虑封装的另一种方式是，它是一个保护屏障，防止数据被屏障外的代码访问。</p><h1 id="df10" class="lm jk hi bd jl ln lo lp jp lq lr ls jt io lt ip jx ir lu is kb iu lv iv kf lw bi translated">swift中的访问级别类型</h1><h2 id="eff2" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">1.开放和公开:</h2><p id="07aa" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">允许在定义模块(目标/框架)之外使用实体。当指定框架的公共接口时，通常使用<code class="du lx ly lz ma b">open</code>或<code class="du lx ly lz ma b">public</code>访问。</p><p id="35e9" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lh kr ks jy lj ku kv kc ll kx ky kz hb bi translated">然而，<code class="du lx ly lz ma b"><strong class="kj hj">open</strong></code> <strong class="kj hj">访问只适用于类和类成员</strong>，它与<code class="du lx ly lz ma b">public</code>访问的区别如下:</p><ul class=""><li id="24c1" class="mb mc hi kj b kk le kn lf ju md jy me kc mf kz mg mh mi mj bi translated"><code class="du lx ly lz ma b">open</code>类和类成员可以在定义模块(目标/框架)内外被子类化和覆盖。</li><li id="5736" class="mb mc hi kj b kk mk kn ml ju mm jy mn kc mo kz mg mh mi mj bi translated"><code class="du lx ly lz ma b">public</code>类和类成员只能在定义模块(目标/框架)内被子类化和覆盖。</li></ul><blockquote class="lb lc ld"><p id="1ba3" class="kh ki la kj b kk le ij km kn lf im kp lg lh kr ks li lj ku kv lk ll kx ky kz hb bi translated">像开放访问级别一样，公共访问级别允许在定义模块(目标)之外使用实体。但是开放访问级别允许我们从另一个模块中继承它，而在公共访问级别，我们只能从定义它的模块中继承或重写它。</p></blockquote><pre class="iy iz ja jb fd mp ma mq mr aw ms bi"><span id="eddb" class="jj jk hi ma b fi mt mu l mv mw">//First.framework – A.swift</span><span id="7ab8" class="jj jk hi ma b fi mx mu l mv mw">open class A {}</span><span id="0205" class="jj jk hi ma b fi mx mu l mv mw">//First.framework – B.swift</span><span id="fe71" class="jj jk hi ma b fi mx mu l mv mw">public class B: A {} // ok</span><span id="9d79" class="jj jk hi ma b fi mx mu l mv mw">//Second.framework – C.swift</span><span id="c83e" class="jj jk hi ma b fi mx mu l mv mw">import First<br/>internal class C: A {} // ok</span><span id="594b" class="jj jk hi ma b fi mx mu l mv mw">//Second.framework – D.swift</span><span id="8ffd" class="jj jk hi ma b fi mx mu l mv mw">import First<br/>internal class D: B {} // error: B cannot be subclassed</span></pre><h2 id="054f" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">2.私人:</h2><p id="d365" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">将实体的使用限制在其封闭声明中。当那些细节仅在单个声明中使用时，通常使用<code class="du lx ly lz ma b">private</code> access来隐藏特定功能的实现细节。</p><pre class="iy iz ja jb fd mp ma mq mr aw ms bi"><span id="4859" class="jj jk hi ma b fi mt mu l mv mw">// First.framework – A.swift</span><span id="2eaf" class="jj jk hi ma b fi mx mu l mv mw">internal struct A {<br/>  private static let x: Int</span><span id="3601" class="jj jk hi ma b fi mx mu l mv mw">  internal static func doSomethingWithX() {<br/>    x // ok<br/>  }<br/>}</span><span id="1dcc" class="jj jk hi ma b fi mx mu l mv mw">A.x // error: x is unavailable</span></pre><h2 id="4c4e" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">3.文件私有:</h2><p id="1f9c" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">将实体的使用限制在其定义源文件中。当在整个文件中使用这些细节时，通常使用<code class="du lx ly lz ma b">fileprivate</code> access来隐藏特定功能的实现细节。</p><pre class="iy iz ja jb fd mp ma mq mr aw ms bi"><span id="3ae6" class="jj jk hi ma b fi mt mu l mv mw">// First.framework – A.swift</span><span id="b569" class="jj jk hi ma b fi mx mu l mv mw">internal struct A {</span><span id="70ca" class="jj jk hi ma b fi mx mu l mv mw">  fileprivate static let x: Int</span><span id="7f10" class="jj jk hi ma b fi mx mu l mv mw">}</span><span id="240b" class="jj jk hi ma b fi mx mu l mv mw">A.x // ok</span><span id="0701" class="jj jk hi ma b fi mx mu l mv mw">// First.framework – B.swift</span><span id="1ba2" class="jj jk hi ma b fi mx mu l mv mw">A.x // error: x is not available</span></pre><h2 id="e6d3" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">4.内部:</h2><p id="fd7c" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">允许在定义模块(目标)中使用实体。在定义应用程序或框架的内部结构时，通常会使用<code class="du lx ly lz ma b">internal</code> access。</p><pre class="iy iz ja jb fd mp ma mq mr aw ms bi"><span id="7c95" class="jj jk hi ma b fi mt mu l mv mw">// First.framework – A.swift</span><span id="5789" class="jj jk hi ma b fi mx mu l mv mw">internal struct A {<br/>  fileprivate static let x: Int<br/>}</span><span id="528f" class="jj jk hi ma b fi mx mu l mv mw">// First.framework – A.swift</span><span id="1496" class="jj jk hi ma b fi mx mu l mv mw">internal struct A {}</span><span id="19cf" class="jj jk hi ma b fi mx mu l mv mw">// First.framework – B.swift</span><span id="93ea" class="jj jk hi ma b fi mx mu l mv mw">A() // ok</span><span id="6614" class="jj jk hi ma b fi mx mu l mv mw"><br/>// Second.framework – C.swift</span><span id="e584" class="jj jk hi ma b fi mx mu l mv mw">import First<br/>A() // error: A is unavailable</span></pre><p id="d915" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lh kr ks jy lj ku kv kc ll kx ky kz hb bi translated"><strong class="kj hj">注意:</strong>swift中的默认访问说明符是<strong class="kj hj">内部，</strong>那么<strong class="kj hj"> final </strong>怎么样我们来读一下这篇<a class="ae my" rel="noopener" href="/@anilkotur/final-in-swift-625b534b2412">文章</a>。</p><p id="c6ef" class="pw-post-body-paragraph kh ki hi kj b kk le ij km kn lf im kp ju lh kr ks jy lj ku kv kc ll kx ky kz hb bi translated">感谢您的阅读👏🏻。请点赞并分享，让更多工程师了解这一点。</p></div></div>    
</body>
</html>