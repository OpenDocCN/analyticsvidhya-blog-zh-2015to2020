<html>
<head>
<title>Random Forest Interpretation &amp; Beyond — ML for coders by Fast.ai (Lesson 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Fast.ai为编码人员提供的随机森林解释和超越— ML(第3课)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/random-forest-deep-dive-beyond-ml-for-coders-by-fast-ai-lesson-3-a8caf01ac9d7?source=collection_archive---------27-----------------------#2020-04-05">https://medium.com/analytics-vidhya/random-forest-deep-dive-beyond-ml-for-coders-by-fast-ai-lesson-3-a8caf01ac9d7?source=collection_archive---------27-----------------------#2020-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9fe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">这篇文章深入讨论了Fast.ai提供的“程序员ML入门”课程中第三课的学习细节</em></p><p id="b1f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">与传统的课程笔记不同，我的重点是用外部来源的信息丰富讨论的主题。要访问我在本系列中讨论课程背景的第一篇文章，并浏览所有课程，请单击此处的</em><a class="ae je" rel="noopener ugc nofollow" target="_blank" href="/@alexrobwong/ml-for-coders-beyond-572ae05448"><em class="jd"/></a><em class="jd">。</em></p><h1 id="9cfe" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">摘要</h1><p id="cfaa" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">在课程的前半部分，Jeremey从分析一个<a class="ae je" href="https://www.kaggle.com/c/favorita-grocery-sales-forecasting" rel="noopener ugc nofollow" target="_blank">杂货销售预测数据集</a>开始，这是一个预测大型杂货连锁店销售额的kaggle挑战。与此同时，他提供了许多关于如何有效处理大型数据集的建议。</p><p id="3b4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在课程的后半部分，他切换回他在上一课中最初分析的<a class="ae je" href="https://www.kaggle.com/c/bluebook-for-bulldozers" rel="noopener ugc nofollow" target="_blank">推土机蓝皮书</a>数据集，并重温了一种用于解释随机森林中的单个树木预测的技术。</p><h1 id="cf06" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">目录</h1><ol class=""><li id="b8f7" class="ki kj hi ih b ii kd im ke iq kk iu kl iy km jc kn ko kp kq bi translated">使用大型数据集</li><li id="8940" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">创建良好的验证集</li><li id="5d39" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">解释采油树预测'置信度'</li><li id="78f4" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">特征重要性</li><li id="6a13" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">排列重要性</li></ol><h1 id="9acb" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">感谢</h1><p id="3eab" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">特别感谢<a class="ae je" href="https://github.com/fastai/fastai" rel="noopener ugc nofollow" target="_blank">杰瑞米·霍华德</a>发布他的课程和源代码。还要特别感谢<a class="ae je" rel="noopener" href="/@hiromi_suenaga">上原广美·末永</a>出版了她详细的课程笔记。</p><p id="fd92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是我综合了许多来源的信息。我已经尽力提供了原始资料的链接，并强调了我引用他人作品的地方。</p><h1 id="70e6" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated"><strong class="ak">处理大型数据集</strong></h1><p id="fe0b" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">杂货销售预测数据集包含大约1 . 25亿行，是一个关系数据集，其中几个表可以连接在一起。具体来说，该数据集以“星型模式”为特色，其中有一个链接所有数据的中央事务表。</p><p id="1d05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，本课的重点不是如何为此数据集构建高性能RF模型，而是如何跨以下主题处理大型数据集:</p><h2 id="5a74" class="kw jg hi bd jh kx ky kz jl la lb lc jp iq ld le jt iu lf lg jx iy lh li kb lj bi translated"><strong class="ak">读取数据</strong></h2><p id="e6db" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">当通过pandas加载一个数据帧时，只有当整个文件被读取后，它才会确定一个列的数据类型。虽然这通常很方便，但是如果仅仅为了推断一个数据类型就需要读取数百万行，那么这种方法的效率会很低。这里的解决方案是在读入数据时将列类型指定为参数，如下所示:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="0f58" class="kw jg hi lp b fi lt lu l lv lw">types = {'id': 'int64',<br/>         'item_nbr': 'int32',<br/>         'store_nbr': 'int8',<br/>         'unit_sales': 'float32',<br/>         'onpromotion': 'object'}</span><span id="c53e" class="kw jg hi lp b fi lx lu l lv lw">%%time<br/>df_all = pd.read_csv(f'{PATH}train.csv', parse_dates=['date'], <br/>                     dtype=types, infer_datetime_format=True)<em class="jd">CPU times: user 1min 41s, sys: 5.08s, total: 1min 46s<br/>Wall time: 1min 48s</em></span></pre><p id="e9b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，可以指定许多数据类型。虽然一个特定的列可以使用多种数据类型，但最好使用内存效率最高的一种数据类型，这种数据类型正好满足数据的要求(例如，int8和int32，具体取决于整数的大小)</p><p id="c65f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了熊猫特有的数据类型<code class="du ly lz ma lp b">categorical</code>和<code class="du ly lz ma lp b"> datetime64[ns, tz]</code>之外，以下数据类型也可通过numpy*获得:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="03a3" class="kw jg hi lp b fi lt lu l lv lw">[numpy.generic,<br/> [[numpy.number,<br/>   [[numpy.integer,<br/>     [[numpy.signedinteger,<br/>       [numpy.int8,<br/>        numpy.int16,<br/>        numpy.int32,<br/>        numpy.int64,<br/>        numpy.int64,<br/>        numpy.timedelta64]],<br/>      [numpy.unsignedinteger,<br/>       [numpy.uint8,<br/>        numpy.uint16,<br/>        numpy.uint32,<br/>        numpy.uint64,<br/>        numpy.uint64]]]],<br/>    [numpy.inexact,<br/>     [[numpy.floating,<br/>       [numpy.float16, numpy.float32, numpy.float64, numpy.float128]],<br/>      [numpy.complexfloating,<br/>       [numpy.complex64, numpy.complex128, numpy.complex256]]]]]],<br/>  [numpy.flexible,<br/>   [[numpy.character, [numpy.bytes_, numpy.str_]],<br/>    [numpy.void, [numpy.record]]]],<br/>  numpy.bool_,<br/>  numpy.datetime64,<br/>  numpy.object_]]</span></pre><p id="0aa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">*来源:<a class="ae je" href="https://stackoverflow.com/questions/24251219/pandas-read-csv-low-memory-and-dtype-options" rel="noopener ugc nofollow" target="_blank"> Stackoverflow </a></p><p id="14ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，<code class="du ly lz ma lp b">object</code>的dtype是一种通用的python数据类型，速度慢且占用大量内存。通常，通过对数据进行一些清理，可以将这种数据类型更新为内存效率更高的数据类型。</p><h2 id="fc90" class="kw jg hi bd jh kx ky kz jl la lb lc jp iq ld le jt iu lf lg jx iy lh li kb lj bi translated">如何在不加载数据帧的情况下知道数据类型</h2><p id="96e5" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">正如上一节所讨论的，在加载pandas数据帧时指定类型是最佳选择……但是我们怎么知道要指定什么呢？</p><p id="48cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果还没有指导模式存在，一个低效的选择是通过反复试验，加载数据并查看结果。然而，这自然违背了效率低下的目的。</p><p id="5f3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Jeremy提到，这里一个潜在的解决方案是使用UNIX命令<code class="du ly lz ma lp b">shuf</code>来获取数据的随机样本。然而，作为一个操作系统用户，如果没有一些额外的解决方法，这个命令就不能直接工作，比如这里列出的<a class="ae je" href="https://apple.stackexchange.com/questions/142860/install-shuf-on-os-x" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="c3de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于mac用户来说，另一种方法是在终端窗口中以稍微结构化的格式分析csv文件。更多详情请参考<a class="ae je" href="https://www.stefaanlippens.net/pretty-csv.html" rel="noopener ugc nofollow" target="_blank">斯特法安·利彭斯</a>的帖子:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="9df8" class="kw jg hi lp b fi lt lu l lv lw">cat data.csv | column -t -s, | less -S</span></pre><p id="606c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，虽然这不会返回随机的行样本，但它将提供对潜在数据类型的初步了解。</p><h2 id="a1a7" class="kw jg hi bd jh kx ky kz jl la lb lc jp iq ld le jt iu lf lg jx iy lh li kb lj bi translated">有效地设置最大值和最小值</h2><p id="4182" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">在应该存在最小值和最大值的地方，通过numpy处理异常值的一个有效方法是使用clip方法:</p><figure class="lk ll lm ln fd mc er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mb"><img src="../Images/96a291275695df718026f5ad9935659c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81QclCJVdsI6KTVh2uFloA.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">来源:<a class="ae je" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html" rel="noopener ugc nofollow" target="_blank">SciPy.org</a></figcaption></figure><h2 id="b57b" class="kw jg hi bd jh kx ky kz jl la lb lc jp iq ld le jt iu lf lg jx iy lh li kb lj bi translated"><code class="du ly lz ma lp b">Profiling</code></h2><p id="43dc" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">有几个IPython神奇的命令可以用来理解代码执行时间。虽然Jeremy使用<code class="du ly lz ma lp b">%prun</code>添加了一个分析器，并了解哪些代码行运行时间最长(例如在scikit-learns fit方法中),但还有其他几个值得一提，例如在<a class="ae je" href="https://jakevdp.github.io/PythonDataScienceHandbook/01.07-timing-and-profiling.html" rel="noopener ugc nofollow" target="_blank"> Python数据科学手册</a>中概述的:</p><ul class=""><li id="72ae" class="ki kj hi ih b ii ij im in iq mn iu mo iy mp jc mq ko kp kq bi translated"><code class="du ly lz ma lp b">%time</code>:计时单个语句的执行时间</li><li id="c6b7" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc mq ko kp kq bi translated"><code class="du ly lz ma lp b">%timeit</code>:定时重复执行一条语句，以提高准确性</li><li id="780c" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc mq ko kp kq bi translated"><code class="du ly lz ma lp b">%prun</code>:用概要分析器运行代码</li><li id="cb28" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc mq ko kp kq bi translated"><code class="du ly lz ma lp b">%lprun</code>:用逐行分析器运行代码</li><li id="1e20" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc mq ko kp kq bi translated"><code class="du ly lz ma lp b">%memit</code>:测量单个语句的内存使用情况</li><li id="8eb0" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc mq ko kp kq bi translated"><code class="du ly lz ma lp b">%mprun</code>:用逐行内存分析器运行代码</li></ul><p id="b3a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，在软件工程中，查看哪些事情占用了时间被称为“剖析”。</p><h1 id="fa1b" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">创建良好的验证集</h1><p id="0a02" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">作为快速复习，当构建机器学习模型时，可用数据被分成训练、验证和测试集。如本<a class="ae je" href="https://stackoverflow.com/questions/2976452/whats-is-the-difference-between-train-validation-and-test-set-in-neural-netwo" rel="noopener ugc nofollow" target="_blank">堆栈溢出帖子</a>所述:</p><ul class=""><li id="96c9" class="ki kj hi ih b ii ij im in iq mn iu mo iy mp jc mq ko kp kq bi translated"><strong class="ih hj"> <em class="jd">训练集</em> </strong> <em class="jd">:该数据集用于调整模型的权重</em></li><li id="1073" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc mq ko kp kq bi translated"><strong class="ih hj"> <em class="jd">验证集</em> </strong> <em class="jd">:该数据集用于最小化过拟合。您并没有使用该数据集来调整网络的权重，您只是验证了在训练数据集上的任何准确度的提高实际上产生了在以前没有向网络显示过的数据集上的准确度的提高，或者至少网络没有对其进行过训练(即验证数据集)。如果训练数据集的精度提高了，但验证数据集的精度保持不变或降低了，那么您的模型会过度拟合，您应该停止训练。</em></li><li id="5c78" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc mq ko kp kq bi translated"><strong class="ih hj"> <em class="jd">测试集</em> </strong> <em class="jd">:该数据集仅用于测试最终解决方案，以确认模型的实际预测能力。</em></li></ul><p id="b6bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，需要一个验证集，以便您可以知道您的模型是否会可靠地告诉您当它投入生产/用于测试数据时它将如何执行。在kaggle竞赛的上下文中，测试集是上传预测结果返回的分数。</p><p id="3642" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然测试集应该在项目/比赛结束时使用，但它可以用来<strong class="ih hj">校准您的验证集</strong>。</p><p id="3025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的方法是训练几个半体面的模型，并在验证和测试集上评估它们的性能——在这种情况下，测试集是kaggle结果。通过绘制验证与测试集分数的关系图，完美的45度线表示验证集完美地反映了测试集，如下所示:</p><figure class="lk ll lm ln fd mc er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mr"><img src="../Images/8d757948fa298460163bc245672e6c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bX6Lc4CzhYlskjRce9J5Kg.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">验证与测试(Kaggle)结果，用于了解验证集是否已“校准”。(来源:<a class="ae je" rel="noopener" href="/@hiromi_suenaga/machine-learning-1-lesson-3-fa4065d8cb1e">上原广美末永</a>)</figcaption></figure><p id="1a4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，y=x线不是必需的。更重要的是，验证集和测试集一致地告知模型之间的相对性能。</p><p id="65a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当选择与测试集中包含的观测值相似的观测值时，校准数据集需要一点技巧。通常情况下，可能会有相关的时间因素和可以利用的领域专业知识。</p><h1 id="4e93" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">解释树预测'置信度'</h1><p id="944e" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">在本课的这一点上，Jeremy切换主题并导航回推土机的<a class="ae je" href="https://www.kaggle.com/c/bluebook-for-bulldozers" rel="noopener ugc nofollow" target="_blank">蓝皮书</a>数据集。在上一课中，对随机森林进行了训练，并介绍了分析单棵树预测的概念。回想以下代码，查看各个树预测:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="1b62" class="kw jg hi lp b fi lt lu l lv lw">m = RandomForestRegressor(n_jobs=-1, verbose=3)<br/>m.fit(X_train, y_train)</span><span id="eb7c" class="kw jg hi lp b fi lx lu l lv lw">preds = np.stack([t.predict(X_valid) <strong class="lp hj">for</strong> t <strong class="lp hj">in</strong> m.estimators_]) preds[:,0], np.mean(preds[:,0]), y_valid[0]</span><span id="53c0" class="kw jg hi lp b fi lx lu l lv lw"><em class="jd">(array([ 9.21034,  8.9872 ,  8.9872 ,  8.9872 ,  8.9872 ,  9.21034,  8.92266,  9.21034,  9.21034,  8.9872 ]),  <br/>9.0700003890739005,  <br/>9.1049798563183568)</em>preds.shape<br/><em class="jd">(10, 12000)</em></span></pre><p id="4a1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了获得RF预测，取所有树的平均响应。然而，为了理解该预测的“相对置信度”,可以分析预测的标准偏差。请注意，这种意义上的“置信度”并不一定意味着准确性，相反，它表明RF模型中的各个树直接向最终值收敛，而输入会导致所有树具有非常不同的响应。</p><p id="6488" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码片段是获取单个观察的树预测的简单过程。fast.ai库有一个名为<code class="du ly lz ma lp b">parallel_trees</code>的函数来并行化计算。下面显示了如何使用该函数及其源代码的示例</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="401f" class="kw jg hi lp b fi lt lu l lv lw">def get_preds(t): return t.predict(X_valid)<br/>%time preds = np.stack(<strong class="lp hj">parallel_trees</strong>(m, get_preds))<br/>np.mean(preds[:,0]), np.std(preds[:,0])<em class="jd">CPU times: user 100 ms, sys: 180 ms, total: 280 ms<br/>Wall time: 505 ms(9.1960278072006023, 0.21225113407342761)</em></span></pre><figure class="lk ll lm ln fd mc"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">来自fast.ai的源代码</figcaption></figure><h2 id="4a81" class="kw jg hi bd jh kx ky kz jl la lb lc jp iq ld le jt iu lf lg jx iy lh li kb lj bi translated">示例-树预测的标准偏差</h2><p id="8ead" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">在之前的视频课程中，推土机最终价格的一个分类预测值被确定为<code class="du ly lz ma lp b">ProductSize</code>。可以分析不同机柜类型的预测标准偏差:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="15ec" class="kw jg hi lp b fi lt lu l lv lw">x.ProductSize.value_counts().plot.barh()</span></pre><figure class="lk ll lm ln fd mc er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mu"><img src="../Images/9908a273608abae53eadc1056e028a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8ZfHotL2aOqWMs9Xsqjzw.png"/></div></div></figure><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="2be2" class="kw jg hi lp b fi lt lu l lv lw">x = raw_valid.copy()<br/>x['pred_std'] = np.std(preds, axis=0)<br/>x['pred'] = np.mean(preds, axis=0)</span><span id="06ec" class="kw jg hi lp b fi lx lu l lv lw">flds = ['ProductSize', 'SalePrice', 'pred', 'pred_std']<br/>summ = x[flds].groupby(flds[0]).mean()<br/>summ</span></pre><figure class="lk ll lm ln fd mc er es paragraph-image"><div class="er es mv"><img src="../Images/7cd21848d59d8c362938ec3b28ee6b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*jLp2EsgdJGDvqtvLofxonQ.png"/></div></figure><p id="89b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于潜在的目标值较大，因此预期较大的产品会有较大的标准差。分析<code class="du ly lz ma lp b">SalePrice</code>与<code class="du ly lz ma lp b">pres_std</code>的比值，可以看出越大越紧凑的产品比值最大，相对标准差也最大。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="4ce5" class="kw jg hi lp b fi lt lu l lv lw">(summ.pred_std/summ.pred).sort_values(ascending=False)</span></pre><figure class="lk ll lm ln fd mc er es paragraph-image"><div class="er es mw"><img src="../Images/a0a1f1b93d5a7dc9d6a9a8a61caf7b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*JHXDzDIO-tncskjo_HlWdQ.png"/></div></figure><p id="29f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如<a class="ae je" rel="noopener" href="/@hiromi_suenaga/machine-learning-1-lesson-3-fa4065d8cb1e">上原广美·苏埃纳加</a>所说，您可以将这个置信区间用于两个主要目的:</p><ol class=""><li id="bdab" class="ki kj hi ih b ii ij im in iq mn iu mo iy mp jc kn ko kp kq bi translated"><em class="jd">您可以查看各组的平均置信区间，找出您似乎对哪些组没有信心。</em></li><li id="35c9" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated"><em class="jd">也许更重要的是，您可以查看它们的具体行。当您将它投入生产时，您可能总是希望看到置信区间。例如，如果你做信用评分来决定是否给某人贷款，你可能不仅想知道他们的风险程度，还想知道我们有多有信心。如果他们想借很多钱，而我们对预测他们是否会还钱的能力一点信心都没有，我们可能会给他们小额贷款。</em></li></ol><h1 id="19c7" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">特征重要性</h1><p id="5ab5" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">RandomForestRegressor类是一种内置的功能重要性方法。fast.ai库有一个函数可以优雅地调用这个方法，并为用户返回格式化的输出:</p><p id="3252" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ly lz ma lp b">fi = rf_feat_importance(m, df_trn); fi[:10]</code></p><figure class="lk ll lm ln fd mc er es paragraph-image"><div class="er es mx"><img src="../Images/fd2780204e99173eb29e7eab9a2e5255.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*xiJdIRGpyOTD9N1fqyvEsg.png"/></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">推土机蓝皮书数据集的要素重要性示例</figcaption></figure><figure class="lk ll lm ln fd mc"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">rf_feat_importance函数的Fast.ai源代码</figcaption></figure><p id="fd9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，对于随机森林预测来说，通常只有一部分特征是重要的。正是在这一点上，应该注入领域专业知识，以进一步理解底层特性是什么，因为这可以推动特性工程的其他想法。</p><h2 id="843c" class="kw jg hi bd jh kx ky kz jl la lb lc jp iq ld le jt iu lf lg jx iy lh li kb lj bi translated">特征重要性背后的数学原理</h2><p id="c017" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">scikit-learn特征重要性方法基于通过分割特征实现的杂质减少。如第1课所述，分类树通常使用基尼指数或熵，回归树通常使用标准差。以下对特征重要性背后的数学解释来自<a class="ae je" href="https://datascience.stackexchange.com/questions/66280/how-is-the-feature-importance-value-calculated-in-sklearn-modules-for-each" rel="noopener ugc nofollow" target="_blank">堆栈交换</a>:</p><p id="4aa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">对于具有左右子节点的给定(二进制)节点𝑚，杂质减少𝐺𝑎𝑖𝑛的计算如下，其中权重被定义为子节点中父实例的份额</em></p><figure class="lk ll lm ln fd mc er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es my"><img src="../Images/2fc02cd6781645cd2ab822dc87640d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OmvLa2wTDXzuIRZ87CGBMQ.png"/></div></div></figure><p id="eefd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">现在，为了导出树t、</em>  <em class="jd">中给定特征f </em>  <em class="jd"> </em> <strong class="ih hj"> <em class="jd">的</em> <strong class="ih hj"> <em class="jd">总杂质减少量，您需要对在该特征f上执行分割的所有节点求和，并除以该树所有节点的总杂质减少量:</em></strong></strong></p><figure class="lk ll lm ln fd mc er es paragraph-image"><div class="er es mz"><img src="../Images/40b63bccdda8e90cef80960310f04f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*re4eJSM39_1uc3Zt8WCk0Q.png"/></div></figure><p id="63bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，由于这一标准化步骤，您的特征重要性总计为1。最终，将计算任意森林中所有树木t的要素𝑓的总重要性，树木总数为t:</p><p id="34dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，要获得𝑡树中给定特征𝑓的总杂质减少量，需要对所有节点𝑚∈𝑀(𝑡)𝑓m∈Mf(t求和，这些节点对该特征𝑓f执行分割，然后除以该树所有节点的总杂质减少量:</p><figure class="lk ll lm ln fd mc er es paragraph-image"><div class="er es na"><img src="../Images/fd57674a103562fb55643f5fd26c1fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*egIor1id-UERJ4b8Oqw70w.png"/></div></figure><h2 id="936d" class="kw jg hi bd jh kx ky kz jl la lb lc jp iq ld le jt iu lf lg jx iy lh li kb lj bi translated">特征重要性的限制</h2><p id="d9e9" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">正如在<a class="ae je" href="https://scikit-learn.org/stable/auto_examples/inspection/plot_permutation_importance.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn文档</a>中直接指出的，请注意随机森林特征重要性的以下限制:</p><ul class=""><li id="4f6d" class="ki kj hi ih b ii ij im in iq mn iu mo iy mp jc mq ko kp kq bi translated"><em class="jd">基于杂质的重要性偏向高基数特性</em></li><li id="bfbe" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc mq ko kp kq bi translated"><em class="jd">基于杂质的重要度是根据训练集统计数据计算的，因此不能反映出特征对进行归纳到测试集的预测有用的能力</em></li><li id="dc2b" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc mq ko kp kq bi translated"><em class="jd">当两个特征相关且其中一个特征被置换时，模型仍可通过其相关特征访问该特征。这将导致这两个特性的重要性降低，而它们实际上可能是重要的。处理这种情况的一种方法是对相关的要素进行聚类，并且只保留每个聚类中的一个要素。</em></li></ul><h1 id="6f81" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">排列重要性</h1><p id="6731" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">本课的最后一个主题是排列重要性，这是一种模型不可知的技术，用于根据随机排列时特征对响应变量的影响来理解特征的重要性。</p><blockquote class="nb nc nd"><p id="8e10" class="if ig jd ih b ii ij ik il im in io ip ne ir is it nf iv iw ix ng iz ja jb jc hb bi translated">该过程打破了特征和目标之间的关系，因此模型得分的下降表明了模型对特征的依赖程度(来源:<a class="ae je" href="https://scikit-learn.org/stable/modules/permutation_importance.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>)</p></blockquote><p id="ad97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，通过比较单个预测器特性(例如下图中的<code class="du ly lz ma lp b">YearMade</code>)被随机打乱时的性能下降，我们可以对哪些特性相对更重要进行排序。</p><figure class="lk ll lm ln fd mc er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es nh"><img src="../Images/ef7d5457b4a0b142c2e5d94239f08cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZDzH-hxyjV8sCgpE7Q3O0A.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">来源:<a class="ae je" rel="noopener" href="/@hiromi_suenaga/machine-learning-1-lesson-3-fa4065d8cb1e">上原广美·苏娜加</a></figcaption></figure><p id="73dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Scikit-learn提供了一个<code class="du ly lz ma lp b">permutation_importance_ method</code>，它可以在下面的<a class="ae je" href="https://scikit-learn.org/stable/modules/generated/sklearn.inspection.permutation_importance.html#sklearn.inspection.permutation_importance" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。</p><p id="3c9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">请注意，在fast.ai课程中，Jeremey使用上面的排列重要性图表作为scikit-learn的特征重要性方法的简化解释。</strong>虽然有助于直观理解，因为两者都输出输入特征的相对重要性，但应理解它们不是一回事:</p><ul class=""><li id="5a71" class="ki kj hi ih b ii ij im in iq mn iu mo iy mp jc mq ko kp kq bi translated">fast.ai库中使用的scikit-learn特征重要性方法基于平均减少不完整性(MDI)</li><li id="9b83" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc mq ko kp kq bi translated">置换重要性，如scikit-learn中实现的版本，是基于指定的评分函数的。置换重要性被定义为“基线度量和置换特征列的度量之间的差异”。</li></ul><p id="005e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有关两者之间差异的更多信息，请参考sci-kit learn 的这篇<a class="ae je" href="https://scikit-learn.org/stable/modules/permutation_importance.html" rel="noopener ugc nofollow" target="_blank">文章。</a></p><h1 id="a1e0" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">这一课到此结束，敬请期待下一课！</h1></div></div>    
</body>
</html>