<html>
<head>
<title>API and Object Interaction Extravaganza in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby中的API和对象交互盛会</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/api-and-object-interaction-extravaganza-d0328e3f07a6?source=collection_archive---------24-----------------------#2020-06-01">https://medium.com/analytics-vidhya/api-and-object-interaction-extravaganza-d0328e3f07a6?source=collection_archive---------24-----------------------#2020-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="efbe" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第二部分:从执行到整合</h2></div><h2 id="9690" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">上接<a class="ae jv" rel="noopener" href="/@chaserabenn/api-and-object-interaction-extravaganza-a0ce928fbc2a">第1部分:从沙箱到API设置</a></h2><p id="e3f3" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke ji kf kg kh jm ki kj kk jq kl km kn ko hb bi translated">第二部分各节</p><ul class=""><li id="461f" class="kp kq hi jy b jz kr kc ks ji kt jm ku jq kv ko kw kx ky kz bi translated"><a class="ae jv" href="#f4e8" rel="noopener ugc nofollow"> Ruby API第五步:使用API </a></li><li id="1aa7" class="kp kq hi jy b jz la kc lb ji lc jm ld jq le ko kw kx ky kz bi translated"><a class="ae jv" href="#e1da" rel="noopener ugc nofollow"> Ruby API第六步:让它动态化</a></li><li id="b0f3" class="kp kq hi jy b jz la kc lb ji lc jm ld jq le ko kw kx ky kz bi translated"><a class="ae jv" href="#372b" rel="noopener ugc nofollow">结论</a></li></ul></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="f4e8" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">第五步:</h2><p id="cf46" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke ji kf kg kh jm ki kj kk jq kl km kn ko hb bi translated">是时候用我们的端点创造一些奇迹了。</p><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lm"><img src="../Images/d4aa290f027dc0e240d86d0035161da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DFJRYgiHGyPHVAP4"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">尼古拉斯·天梭在<a class="ae jv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="263a" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">在此之前，我们应该先弄清楚一些定义(一些新的，一些回顾)。为了理解这篇文章的其余部分，下面的定义过于简单了。这些术语中的每一个都可以成为他们自己博客文章的主题，所以不要觉得你现在需要完全理解它们(因为我不需要)。你只需要相信，在这种情况下，这些事情中的每一件都做了重要的事情。</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="20dd" class="ix iy hi mg b fi mk ml l mm mn">GET Request: an online request that our system sends to another systems that hosts information we are looking for.</span><span id="5c34" class="ix iy hi mg b fi mo ml l mm mn">Parse: when you break something down into parts so they can be read and manipulated. E.g. Breaking a sentence down into words and those words into individual characters.</span><span id="ef8d" class="ix iy hi mg b fi mo ml l mm mn">Nested Data Structure: a sometimes maddening mix of hashes and arrays inside of each other. The JSON-parsed (see below) response to a GET request will be some form of nested data. Think of it as the coding equivalent of a Russian Nesting Doll.</span><span id="7f4c" class="ix iy hi mg b fi mo ml l mm mn">Web Resource: Anything that can be obtained from the web and uniquely identified. E.g. that one puppy photo you love.</span><span id="d4a7" class="ix iy hi mg b fi mo ml l mm mn">URI: Uniform Resource Identifier. A string of characters that identifies and names a web resource. Also, a Ruby Module with a library of methods and functions. When you see lowercase "uri", it refers to the web resource identifier and when you see uppercase "URI", it refers to the Ruby Module.</span><span id="51d4" class="ix iy hi mg b fi mo ml l mm mn">URL: Uniform Resource Locater. A web address that is the location of a web resource on a network. Since it is a unique location, the URL for a resource is also technically its name.</span><span id="8826" class="ix iy hi mg b fi mo ml l mm mn">Net::HTTP : A built-in Ruby class that has a library of functions and methods that can be used to build user-agents like URI.</span><span id="7fa3" class="ix iy hi mg b fi mo ml l mm mn">Net::HTTPOK : Ruby Class and the type of object that is returned when a GET request is called with Net::HTTP. It has a method “body” that you will be using. Loves enthusiastically saying "OK" after regular Net::HTTP has done all the work.</span><span id="c1d1" class="ix iy hi mg b fi mo ml l mm mn">JSON: JavaScript Object Notation. A complex, yet human-readable, way of storing, transferring, and presenting the nested data from the GET response. Think of it as the drill sergeant of the GET Request response. JSON marches in and gets everyone in order.</span></pre><p id="c6b4" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">请记住，所有这些的目标是获得您的程序可以分解和操作的数据。我们可以尝试构建一个自定义的翻译器方法来对GET响应进行排序，或者我们可以依赖Ruby已经为我们制作的内置方法库。我想我会选择后者。</p><p id="27a3" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">请注意，列出的apiKey不是真实的，因此您将无法向Spoontacular创建真实的GET请求，除非您注册了一个帐户。</p><p id="72a2" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">设置您的系统以使用URI和Net::HTTP</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="529e" class="ix iy hi mg b fi mk ml l mm mn">require ‘open-uri’</span><span id="229f" class="ix iy hi mg b fi mo ml l mm mn">require ‘net/http’</span></pre><p id="4cae" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">将端点url保存到变量“url”</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="02b2" class="ix iy hi mg b fi mk ml l mm mn">url = “https://api.spoonacular.com/recipes/findByIngredients?apiKey=123abc123abc&amp;ingredients=onion+pepper&amp;number=10”<br/></span></pre><p id="406b" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">调用URI模块上的parse方法，并传入变量“url”。结果保存到变量“uri”换句话说，我们解析url并得到一个uri。</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="0f0f" class="ix iy hi mg b fi mk ml l mm mn">uri = URI.parse(url)</span><span id="8dc6" class="ix iy hi mg b fi mo ml l mm mn"># =&gt; #&lt;URI::HTTPS https://api.spoonacular.com/recipes/findByIngredients?apiKey=123abc123abc&amp;ingredients=onion+cheese&amp;number=10&amp;ranking=2&gt;</span></pre><p id="aeec" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">用Net::HTTP.get_response创建一个GET请求，传入变量“uri”。这个GET请求的返回值(或响应)是一个Net::HTTPOK对象，我们将把它保存到变量“response”中</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="a283" class="ix iy hi mg b fi mk ml l mm mn">response = Net::HTTP.get_response(uri)</span><span id="a399" class="ix iy hi mg b fi mo ml l mm mn">#=&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;</span></pre><p id="4cc0" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">我们在“response”上调用body方法，它从响应中检索正文文本。这样做是因为响应的主体包含了我们想要的数据。</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="a20a" class="ix iy hi mg b fi mk ml l mm mn">response_body = response.body</span><span id="1edf" class="ix iy hi mg b fi mo ml l mm mn">#=&gt;”[{\”id\”:514079,\”title\”:\”Easy Pinwheel Steaks with Spinach and Cream Cheese\”,\”image\”:\”https://spoonacular.com/recipeImages/514079-312x231.jpg\",\"imageType\":\"jpg\",\"usedIngredientCount\":1,\"missedIngredientCount\":2,\"missedIngredients\ . . . ”</span></pre><p id="272d" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">哇，真是一团糟。如您所见，此时，response_body是一个混合了各种格式符号的嵌套数据字符串。这不太好。这些杂乱的字符包含了我们想要的数据，但是以一种不可访问的方式。幸运的是，我们有一个清理响应的方法。</p><p id="29a7" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">JSON来拯救世界了。</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="5495" class="ix iy hi mg b fi mk ml l mm mn">require ’json’</span><span id="1a58" class="ix iy hi mg b fi mo ml l mm mn">json_response = JSON.parse(response_body)</span><span id="c2ea" class="ix iy hi mg b fi mo ml l mm mn">#=&gt; [<br/>     {“id”=&gt;514079, <br/>     “title”=&gt;”Easy Pinwheel Steaks with Spinach and Cream Cheese”, <br/>     “image”=&gt;”https://spoonacular.com/recipeImages/514079-312x231.jpg", <br/>     “imageType”=&gt;”jpg”, <br/>     “usedIngredientCount”=&gt;1, <br/>     “missedIngredientCount”=&gt;2, <br/>     “missedIngredients”=&gt;<br/>         [{“id”=&gt;11457, <br/>           “amount”=&gt;4.0,<br/>           “unit”=&gt;”oz”, <br/>           “unitLong”=&gt;”ounces”, <br/>           “unitShort”=&gt;”oz”, <br/>           “aisle”=&gt;”Produce”, <br/>           “name”=&gt;”baby spinach leaves”, <br/>            “original”=&gt;”4 oz. fresh baby spinach leaves”,        <br/>            “originalString”=&gt;”4 oz. fresh baby spinach leaves”}]}]</span></pre><p id="bf7c" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">漂亮！终于有我们可以合作的东西了。我们使用了一个为处理JSON而设计的Ruby库，并调用该库的“parse”方法来获取response_body，并去掉所有妨碍我们访问和理解所请求数据的格式化符号。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="e1da" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">第六步:</h2><p id="e481" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke ji kf kg kh jm ki kj kk jq kl km kn ko hb bi translated">是时候把这一切都集中起来了。</p><p id="2011" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">上面的代码很棒，但它是硬编码的。如果您计划在每个GET请求中手动输入用户选择的配料，那么您最好不要编写程序，而让用户直接向您发送食谱信息。这个想法是将自动化引入这个过程</p><p id="2d59" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">为了演示如何将上面的代码构建到您的应用程序中，我们将浏览UIOLI的代码片段</p><p id="70ef" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">我们需要一个在被调用时专门发出GET请求的类。还记得沙盒里的OlderKid吗？这就是OlderKid变成的样子。然而，将这个调用称为OlderKid是没有意义的，所以我们将使用GetRequester。GetRequester将接收一个url，并在我们刚刚讨论的所有代码中运行它。</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="3197" class="ix iy hi mg b fi mk ml l mm mn">require ‘net/http’</span><span id="c1ae" class="ix iy hi mg b fi mo ml l mm mn">require ‘open-uri’</span><span id="1b8f" class="ix iy hi mg b fi mo ml l mm mn">require ‘json’<br/></span><span id="54c6" class="ix iy hi mg b fi mo ml l mm mn">class GetRequester</span><span id="c532" class="ix iy hi mg b fi mo ml l mm mn">    def initialize(url)</span><span id="4015" class="ix iy hi mg b fi mo ml l mm mn">        @url = url</span><span id="dfd1" class="ix iy hi mg b fi mo ml l mm mn">    end<br/></span><span id="7751" class="ix iy hi mg b fi mo ml l mm mn">    def get_response_body</span><span id="193f" class="ix iy hi mg b fi mo ml l mm mn">        uri = URI.parse(@url)</span><span id="a880" class="ix iy hi mg b fi mo ml l mm mn">        response = Net::HTTP.get_response(uri)</span><span id="fc5f" class="ix iy hi mg b fi mo ml l mm mn">        response.body<br/>    end<br/></span><span id="831e" class="ix iy hi mg b fi mo ml l mm mn">    def parse_json</span><span id="d0c3" class="ix iy hi mg b fi mo ml l mm mn">        JSON.parse(self.get_response_body)</span><span id="028c" class="ix iy hi mg b fi mo ml l mm mn">    end</span><span id="de1c" class="ix iy hi mg b fi mo ml l mm mn">end</span></pre><p id="75b8" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">有了这样定义的类，我们只需要在GetRequester的实例上调用#parse_json方法。这是因为parse_json还调用了GetRequest类定义中的另一个方法:get_response_body。在一种方法中，我们可以用uri解析url，用Net::HTTP创建GET请求，在对该请求的响应中调用body方法，最后让JSON将数据解析为纯NDS delight。</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="6ca4" class="ix iy hi mg b fi mk ml l mm mn">recipe_url = “https://api.spoonacular.com/recipes/findByIngredients?apiKey=123abc123abc&amp;ingredients=onion+pepper&amp;number=10”</span><span id="926a" class="ix iy hi mg b fi mo ml l mm mn">recipes = GetRequester.new(recipe_url)</span></pre><p id="f513" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">我们设置了密码。现在我们需要将这个类与用户输入函数连接起来，要么使用它，要么失去它；</p><p id="59f6" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">我们的应用程序中的TTY提示(谢谢<a class="mp mq ge" href="https://medium.com/u/9eba2377ff56?source=post_page-----d0328e3f07a6--------------------------------" rel="noopener" target="_blank"> Grant Yoshitsu </a>)刚刚从用户那里接收了一组配料，并将其保存到一个数组中。</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="880e" class="ix iy hi mg b fi mk ml l mm mn">uioli_array = ["onion", "pepper"]</span></pre><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mr"><img src="../Images/9ada89b95ffead2d0977feb0239d8157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hA1SsrDuk6h97mmf"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated"><a class="ae jv" href="https://unsplash.com/@davornisevic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">达沃·尼塞维奇</a>在<a class="ae jv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1e68" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">我们需要将从用户那里获得的数据转换成插值所需的形式。根据API文件，该表格是由“+”分隔的一串食品项目。我们要寻找的最终结果是“onion+pepper ”,所以我们将对数组使用join方法，并将其保存到变量“uioli_items”</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="765d" class="ix iy hi mg b fi mk ml l mm mn">uioli_items = uioli_array.join(“+”)</span></pre><p id="d6ea" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">现在，我们可以使用recipe_url，它会将格式正确的用户输入粘贴到字符串插值字段原来所在的位置。</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="6047" class="ix iy hi mg b fi mk ml l mm mn">recipe_url = “https://api.spoonacular.com/recipes/findByIngredients?apiKey=12abc12&amp;ingredients=#{uioli_items}&amp;number=10&amp;ranking=2"</span></pre><p id="fa78" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">太好了！我们的url准备好被传递到GetRequester的实例中。我们将在实例上调用parse_json，并将其保存到变量“response”</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="2683" class="ix iy hi mg b fi mk ml l mm mn">recipe_url = “https://api.spoonacular.com/recipes/findByIngredients?apiKey=12abc12&amp;ingredients=onion+pepper&amp;number=10&amp;ranking=2"</span><span id="b2c5" class="ix iy hi mg b fi mo ml l mm mn">response = GetRequester.new(recipe_url).parse_json</span></pre><p id="385b" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">您可能已经注意到，当我们查看JSON解析时，从GET返回的10个食谱中的每一个都有大量的信息。然而，我们只需要来自每个菜谱的两条信息:名称和id。出于这个原因，我们将编写一个名为“clean_recipes”的方法来清理嵌套数据，只将我们需要的信息保存到一个散列数组中。</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="926f" class="ix iy hi mg b fi mk ml l mm mn">recipes = [{“name” =&gt; “Chicken Soup”,</span><span id="6bf2" class="ix iy hi mg b fi mo ml l mm mn">           “website_id” =&gt; “19283”},</span><span id="a4d9" class="ix iy hi mg b fi mo ml l mm mn">           {“name” =&gt; “Spaghetti and Meatballs”,</span><span id="6b72" class="ix iy hi mg b fi mo ml l mm mn">           “website_id” =&gt; “39290”}]</span></pre><p id="9dfd" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">该方法将创建一个空数组，遍历每个配方，将名称和Id作为键/值对保存到哈希中，将哈希放入我们创建的数组中，并返回该数组。</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="2388" class="ix iy hi mg b fi mk ml l mm mn">def clean_recipes(recipes) </span><span id="4dc1" class="ix iy hi mg b fi mo ml l mm mn">    recipes =[] </span><span id="01ac" class="ix iy hi mg b fi mo ml l mm mn">    <br/>    url.each do |recipe| </span><span id="b266" class="ix iy hi mg b fi mo ml l mm mn">        recipe_hash = {} </span><span id="7100" class="ix iy hi mg b fi mo ml l mm mn">        recipe_hash[“name”] = recipe[“title”].titleize </span><span id="45f4" class="ix iy hi mg b fi mo ml l mm mn">        recipe_hash[“website_id”] = recipe[“id”] </span><span id="7fe2" class="ix iy hi mg b fi mo ml l mm mn">        recipes &lt;&lt; recipe_hash</span><span id="f72f" class="ix iy hi mg b fi mo ml l mm mn">    end</span><span id="ce2e" class="ix iy hi mg b fi mo ml l mm mn">    recipes </span><span id="1ea5" class="ix iy hi mg b fi mo ml l mm mn">end</span></pre><p id="6c16" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">最后，我们将调用clean_recipes方法并传入recipes(对GET请求的json解析响应)。这将被保存到变量“结果”中。</p><pre class="ln lo lp lq fd mf mg mh mi aw mj bi"><span id="93da" class="ix iy hi mg b fi mk ml l mm mn">results = clean_recipes(recipes)</span></pre><p id="bbab" class="pw-post-body-paragraph jw jx hi jy b jz kr ij kb kc ks im ke ji mc kg kh jm md kj kk jq me km kn ko hb bi translated">TTY-Prompt从这里接管并向用户显示配方名称以供选择。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="372b" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">我们已经到达终点。。。</h2><p id="2ca7" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke ji kf kg kh jm ki kj kk jq kl km kn ko hb bi translated">呦喂。这是很多信息。我写这篇文章的目的是提供一些关于API的观点和见解。之前，我说过API令人兴奋，我是认真的。作为一名程序员新手，学习如何使用API让我的应用程序变得生动起来。我的应用程序不再注定要被关进MacBook监狱。他们可以与整个宇宙的系统和他们持有的数据进行对话和交互。我们能创造的可能性是无限的。</p></div></div>    
</body>
</html>