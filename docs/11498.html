<html>
<head>
<title>Multiprocessing/multithreading involving 2 dataframes in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中涉及 2 个数据帧的多重处理/多线程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/multiprocessing-multithreading-involving-2-dataframes-in-python-1f65e3e748b3?source=collection_archive---------7-----------------------#2020-12-06">https://medium.com/analytics-vidhya/multiprocessing-multithreading-involving-2-dataframes-in-python-1f65e3e748b3?source=collection_archive---------7-----------------------#2020-12-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/27cdbd16bfb88a88fa7ff36a42e93eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*063ohSjBWSypC_zTvn5LkA.png"/></div></div></figure><div class=""/><blockquote class="iq ir is"><p id="de48" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通常，不同的假设检验需要重复的数据争论和涉及 2 个或更多独立数据框架的工程。通常建议从一开始就对数据争论/工程进行并行处理。这将为我们节省大量重复等待时间，并使我们能够快速进行下游描述性/相关性/预测性分析。</p></blockquote><p id="b63a" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi jv translated">这里，假设我们正在使用 pandas DataFrame 处理结构化数据。我们将使用 Python 中的<a class="ae ke" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank"><strong class="iw hu"><em class="iv"/></strong></a>包来执行并行处理作业。</p><ol class=""><li id="679c" class="kf kg ht iw b ix iy jb jc js kh jt ki ju kj jr kk kl km kn bi translated">首先，我们生成两个虚拟数据帧，即 df_source 和 df_targets。两者都包含 x 和 y 坐标——这将允许在两个数据帧/数据集之间进行欧几里得距离计算。</li></ol><figure class="kp kq kr ks fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ko"><img src="../Images/f64929634b1b4268302e976997f83a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uob34K-mwIvOihOnRig0UQ.png"/></div></div></figure><p id="fc0e" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">2.接下来，我们为多处理/多线程准备数据块分割。</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kt"><img src="../Images/274a4888883977df1d793a041be17ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Brfs32qqs_D4u89ptSaaaA.png"/></div></div></figure><p id="328d" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">3.接下来，我们定义一个函数来计算两个数据帧中各点之间的欧几里德距离。</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ku"><img src="../Images/12791c7a745647cb38c275816870cf9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gBuAYxfjbSu0LcTf84N4mQ.png"/></div></div></figure><p id="90fd" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">4.接下来，我们将拆分的作业星形映射到 3 个 cpu 进程的池中，以便可以同时计算 3 组匹配数据帧的欧几里德距离。这里我们使用<strong class="iw hu"><em class="iv">zip()</em></strong><em class="iv"/>函数按照列表顺序列出数据帧。我还注意到，有些时候我们不得不使用<strong class="iw hu"> <em class="iv">多重处理。ThreadPool() </em> </strong> <em class="iv">，也就是多线程，</em>而不是<strong class="iw hu"> <em class="iv">多重处理。Pool() </em> </strong> <em class="iv">，即多处理，</em>具有预期的全部 cpu 负载和真正快速的处理。</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kv"><img src="../Images/6d8f252fa0c8f26faa082158ade6114e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDlJlUSWxkh6lod__xELeg.png"/></div></div></figure><p id="4cc1" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">5.最后，我使用终端上的<em class="iv"> top </em>函数检查了 CPU 的使用情况。事实上，它们与几乎 3 个满载的 CPU 并行运行。</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/27cdbd16bfb88a88fa7ff36a42e93eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*063ohSjBWSypC_zTvn5LkA.png"/></div></div></figure><p id="e25d" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">可选 1:另外，如果您想计算所有 df_source 组块中的主题与 df_target 组块中的主题之间的距离，您可以使用<strong class="iw hu"><em class="iv">intertools . repeat()</em></strong>以及<strong class="iw hu"> <em class="iv"> zip() </em> </strong>函数。在这里，当使用 df_source 的不同块压缩时，我们将 df_target 的第一块重复了 3 次。</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kw"><img src="../Images/2b0e37181dbfe9d64f1aff6bf7e84a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGe648HTmwWkJItBMygGcQ.png"/></div></div></figure><p id="34ba" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">可选 2:最后，还有一些额外的代码，我觉得在日常工作中很有用。例如，如果我们想要根据我们想要的作业数量来分割 df_source，而不考虑标签分组，我们可以使用下面的代码。首先，我们必须重置 df_source 的索引。</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kx"><img src="../Images/315a857a4e5b603135980b938b042481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQq6PAm0YBalJ9CXusS2Lw.png"/></div></div></figure><p id="197f" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">如果你觉得上面的教程很有用，你可以考虑在你的浏览器上为这个页面添加书签，以供将来参考。万一需要帮助，可以在下面留言评论；)</p></div></div>    
</body>
</html>