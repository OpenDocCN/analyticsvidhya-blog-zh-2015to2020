<html>
<head>
<title>Django with Docker and Docker Compose (Python part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django与Docker和Docker Compose (Python第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/django-with-docker-and-docker-compose-python-part-2-8415976470cc?source=collection_archive---------3-----------------------#2019-12-24">https://medium.com/analytics-vidhya/django-with-docker-and-docker-compose-python-part-2-8415976470cc?source=collection_archive---------3-----------------------#2019-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ea9619de1fdf74ea6819d050e7d7dce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dGoGdxSxK0P8RVNk.png"/></div></div></figure><p id="fe04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在文章的这一部分，介绍docker composer中的数据库服务。然后，我必须修改Django的一些配置，使项目与本地开发和Docker开发和部署兼容。展示本地环境和Docker环境的迁移过程。简要介绍Django交互式Shell以供开发使用。</p><p id="d33d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">文章系列的一部分</p><ol class=""><li id="5dcf" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/analytics-vidhya/django-with-docker-and-docker-compose-python-part-1-da0ed3f61566"> Django与Docker和Docker Compose (Python第1部分)</a></li></ol><p id="9a81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将被修改为连接的PostgreSQL docker服务的文件，其结构如下所示。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="9cac" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">django-docker<br/>└── </strong>app<strong class="kd hj"><br/>│   ├── main <br/>│   │      ├── model.py<br/>│   ├── docker-entrypoint.sh<br/>│   ├── Dockerfile<br/>└── </strong>env<strong class="kd hj"><br/>│   ├── django.env<br/>│   ├── postgresql.env<br/>└── docker-compose.yml</strong></span></pre><p id="b465" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">检查模块的<code class="du kn ko kp kd b">main</code>在<code class="du kn ko kp kd b">setting.py</code>中是否在项目范围内可用，如果不可用，在<code class="du kn ko kp kd b">setting.py</code>文件中找到<code class="du kn ko kp kd b">INSTALLED_APPS</code>数组，像下面的代码片段那样添加它</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="b5a7" class="kh ki hi kd b fi kj kk l kl km"># django-docker/app/main/setting.py</span><span id="1a76" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">INSTALLED_APPS</strong> = [<br/>    'django.contrib.admin',<br/>    'django.contrib.auth',<br/>    'django.contrib.contenttypes',<br/>    'django.contrib.sessions',<br/>    'django.contrib.messages',<br/>    'django.contrib.staticfiles',<br/>    <strong class="kd hj">'main',<br/></strong>]</span></pre><p id="5010" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要将<code class="du kn ko kp kd b">django-docker</code> <code class="du kn ko kp kd b">web</code>服务连接到Postgresql <code class="du kn ko kp kd b">db</code>服务，我们需要修改docker文件，如下所示，以添加<code class="du kn ko kp kd b">postgresql</code>依赖项。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="d931" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">FROM</strong> python:3.7.5-buster</span><span id="69b2" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj"># set up the psycopg2</strong></span><span id="85db" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj"># First RUN Statement: to install postgresql dependency</strong></span><span id="0ba5" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">RUN </strong>apt-get update &amp;&amp; apt-get install -y <strong class="kd hj">libpq-dev</strong>  \<br/>    <strong class="kd hj"> gcc</strong> \<br/>     <strong class="kd hj">postgresql-client</strong></span><span id="4414" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj"># Second RUN Statement: Install postgresql driver for django</strong></span><span id="c6de" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">RUN<em class="kr"> </em></strong>pip install psycopg2==2.8.3</span><span id="df96" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj"># Third RUN Statement: Remove the gcc compier after install the <br/># driver</strong></span><span id="8970" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">RUN </strong>apt-get autoremove -y <strong class="kd hj">gcc</strong></span></pre><p id="38f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Dockerfile中的"<code class="du kn ko kp kd b">FROM"</code>语句之后。添加上面提供的下列陈述。</p><p id="8eeb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">声明解释:</strong></p><p id="5627" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个<code class="du kn ko kp kd b">RUN</code>指令，运行命令更新docker基本映像的存储库。然后安装Postgresql和Postgresql-client以及“gcc ”,作为设置psycopg2的依赖项。</p><p id="5ef0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二条<code class="du kn ko kp kd b">RUN</code>指令安装了<code class="du kn ko kp kd b">psycopg2</code> PostgreSQL驱动程序库，它将用于将Django应用程序连接到PostgreSQL服务器。</p><p id="fefb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第三个<code class="du kn ko kp kd b">RUN</code>指令，解除<code class="du kn ko kp kd b">gcc</code>依赖，<code class="du kn ko kp kd b">gcc</code>的目的是完全完成<code class="du kn ko kp kd b">psycopg2</code>工艺库的构建。</p><p id="be1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">关于</strong> <code class="du kn ko kp kd b"><strong class="is hj">env</strong></code> <strong class="is hj">文件？</strong></p><p id="87b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Env文件用于配置应用程序和docker容器的外部化环境变量。这也有助于开发人员轻松地为不同用途的应用程序定义环境变量，以便在docker映像中运行应用程序。</p><p id="0243" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在</strong> <code class="du kn ko kp kd b"><strong class="is hj">env</strong></code> <strong class="is hj">文件夹</strong>中创建名为 <code class="du kn ko kp kd b"><strong class="is hj">postgresql.env</strong></code> <strong class="is hj">的env文件</strong></p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="d856" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj"># django-docker/env/postgresql.env</strong></span><span id="3d2e" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">POSTGRES_USER=hello_django<br/>POSTGRES_PASSWORD=hello_django<br/>POSTGRES_DB=hello_django_dev</strong></span></pre><p id="4ac9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">将与Django应用程序的Postgresql服务器连接相关的环境变量添加到</strong> <code class="du kn ko kp kd b"><strong class="is hj">django.env</strong></code> <strong class="is hj">文件</strong></p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="a825" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj"># django-docker/env/django.env</strong></span><span id="50fc" class="kh ki hi kd b fi kq kk l kl km">DEBUG=1<br/>SECRET_KEY=foo<br/>DJANGO_ALLOWED_HOSTS=localhost 127.0.0.1 [::1]</span><span id="b3b9" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj"># Environment Variable which is used in setting.py in django<br/># setting.py file to configure the database connection for<br/># application</strong></span><span id="d9b7" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">SQL_ENGINE=django.db.backends.postgresql<br/>SQL_DATABASE=django_docker<br/>SQL_USER=django_docker<br/>SQL_PASSWORD=django_docker<br/>SQL_HOST=db<br/>SQL_PORT=5432</strong></span></pre><p id="bb0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">重新配置</strong> <code class="du kn ko kp kd b"><strong class="is hj">settings.py</strong></code> <strong class="is hj">文件中的</strong> <code class="du kn ko kp kd b"><strong class="is hj">django-docker/app/main/settings.py</strong></code> <strong class="is hj">文件</strong></p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="ks kt l"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated"><strong class="ak">图:配置1.1 </strong></figcaption></figure><p id="a891" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kr">我已经在我文章的第一部分讨论过</em> <code class="du kn ko kp kd b"><em class="kr">os.environ</em></code> <em class="kr">库了，这个库是python用来处理环境变量的。</em></p><p id="0df1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是docker入口点shell文件？</strong></p><p id="0d4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建入口点外壳文件是为了在docker环境中的容器映像之后运行该命令。有时我们需要运行与应用程序配置、应用程序数据库迁移和应用程序状态检查相关的命令，创建调度程序来运行不同的任务，所有的指令我们都可以在入口点shell文件中声明，将那些入口点shell文件添加到“Dockerfile”中的“entry point”语句中。我们可以将多个入口点sh (shell)文件作为数组格式添加到“ENTRYPOINT”语句中。</p><p id="2141" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">创建</strong> <code class="du kn ko kp kd b"><strong class="is hj">docker-entrypoint.sh</strong></code> <strong class="is hj">文件，用于在</strong> <code class="du kn ko kp kd b"><strong class="is hj">django-docker</strong></code>开始之前做一些家务</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="a365" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第3行到第8行，用于在启动<code class="du kn ko kp kd b">django-docker</code>应用程序之前，刷新Django应用程序中任何先前未保存的<code class="du kn ko kp kd b">manage.py</code>命令。</p><p id="5f15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第12行到第16行，在<code class="du kn ko kp kd b">docker-container</code>中启动Django应用程序之前，用于迁移任何数据库更改的命令</p><p id="4c60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第20行中，exec“$ @”用于在手动访问docker映像或容器的容器后将其他命令作为参数。</p><p id="195d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">将这些行添加到Dockerfile文件的末尾</strong></p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="1ede" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj"># django-docker/app/Dockerfile</strong></span><span id="8846" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj"># set the docker entry file</strong></span><span id="a1a3" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">RUN chmod +x /opt/app/docker-entrypoint.sh<br/>ENTRYPOINT [ "/opt/app/docker-entrypoint.sh" ]</strong></span></pre><p id="1efa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">修改</strong> <code class="du kn ko kp kd b"><strong class="is hj">Dockerfile</strong></code> <strong class="is hj">后，最终的docker文件看起来像下面的一个</strong></p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="2068" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">然后将</strong> <code class="du kn ko kp kd b"><strong class="is hj">db</strong></code> <strong class="is hj">服务器添加到</strong> <code class="du kn ko kp kd b"><strong class="is hj">docker-compose.yml</strong></code> <strong class="is hj">文件</strong></p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="ac0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">web服务是如何工作的已经在前一篇文章中描述过了。你可以在我文章的第一部分找到它，下面，我只是讨论“db”服务如何与docker-compose一起工作</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="f9ae" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">volumes:<br/>   postgres_data:<br/>      driver: local</strong></span><span id="81e1" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">--------------------------------------------------------------------<br/>Specify the  `postgres_data` volume use the local driver for mount in docker container <br/>--------------------------------------------------------------------</strong></span></pre><p id="cb2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">docker-compose文件中的服务部分。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="f13e" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">db:<br/>  image: postgres:12.0-alpine<br/>  volumes:<br/>     - postgres_data:/var/postgres/data/<br/>  env_file:<br/>     - ./env/postgresql.env</strong></span><span id="779f" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">--------------------------------------------------------------------<br/>This difination means, db service use the base image as `postgres:12.0-alpine` image, using the `postgres_data` as volumne to save information and data of the server. using the `./env/postgresql.env` file to load the environment variable for configure the postgresql database.<br/>--------------------------------------------------------------------</strong></span></pre><p id="08af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">关于Django与本地环境和Docker容器的迁移和迁移过程</strong></p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="f47c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在创建迁移之前创建了<code class="du kn ko kp kd b">Company</code>模型，并将模型迁移到数据库中</p><p id="1b05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我继承了<code class="du kn ko kp kd b">django.db</code>库<code class="du kn ko kp kd b">model</code>类来创建<code class="du kn ko kp kd b">Company</code>模型。班级。在<code class="du kn ko kp kd b">Meta</code>嵌套类中，我们可以定义与模型相关的不同<code class="du kn ko kp kd b">meta</code>信息，例如</p><p id="c995" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kn ko kp kd b">ordering</code>用于指定字段名的数组，你必须使用哪些字段进行排序。</p><p id="9a41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kn ko kp kd b">table_name</code>，指定您想要用于此模型的<code class="du kn ko kp kd b">database</code>的表名。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="60a7" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">def __str__(self):<br/>    return self.name</strong></span></pre><p id="6a44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="kr">这个函数是帮助返回</em></strong><code class="du kn ko kp kd b"><strong class="is hj"><em class="kr">name</em></strong></code><strong class="is hj"><em class="kr"/></strong><code class="du kn ko kp kd b"><strong class="is hj"><em class="kr">object</em></strong></code><strong class="is hj"><em class="kr">的模型的，如果我们想用python代码记录并打印对象名来我们需要这个函数。对于Django模板，如果我们想打印模型的对象名称，只需指定对象，我们就需要这个</em> </strong> <code class="du kn ko kp kd b"><strong class="is hj"><em class="kr">__str__" </em></strong></code> <strong class="is hj"> <em class="kr">函数。</em> </strong></p><p id="8c63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">备注:</strong></p><p id="555c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于迁移的目的，我们需要使用本地环境，这是我用pipenv构建的，因为如果我们想要迁移一个新的模型或者更新web应用程序的一些字段，有时它会通过运行<code class="du kn ko kp kd b"><strong class="is hj">docker-compose up — build</strong></code>命令为构建映像创建一个新的自动迁移。并且自动迁移文件在主机的本地代码库中不可用。因此，在构建docker映像的过程中，它会在docker容器中产生错误。</p><p id="27b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">为了简单起见，我在</strong> <code class="du kn ko kp kd b"><strong class="is hj">settings.py</strong></code> <strong class="is hj"> </strong> <a class="ae jx" href="https://gist.github.com/tariqulislam/437938e351d9d225f8c883459d226573" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">处重新配置了代码。图:Config 1.1 </strong> </a> <strong class="is hj">，这里我指定，在本地pipenv环境中，使用</strong> <code class="du kn ko kp kd b"><strong class="is hj">sqlite3</strong></code> <strong class="is hj">作为数据库进行迁移。对于docker环境，使用Postgresql数据库进行迁移。</strong></p><p id="8059" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要创建迁移，迁移命令如下所示</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="7166" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">&gt; python manage.py makemigrations [module_name]</strong></span></pre><p id="c43c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在主模块中创建模型，因此迁移命令如下所示</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="4f2c" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">&gt; python manage.py makemigrations main</strong></span></pre><p id="0670" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成该命令后，文件夹结构将如下所示</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="862a" class="kh ki hi kd b fi kj kk l kl km">django-docker<strong class="kd hj"><br/>└── </strong>app<strong class="kd hj"><br/></strong>│   ├── main <strong class="kd hj"><br/>│   │      ├── migrations<br/>│   │      │     ├── __inti__.py<br/>│   │      │     ├── 0001_initial.py</strong></span></pre><p id="a636" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该命令在<code class="du kn ko kp kd b">main</code>文件夹中自动生成，<code class="du kn ko kp kd b">migrations</code>文件夹包含<code class="du kn ko kp kd b">0001__initial.py</code>迁移文件，该文件包含<code class="du kn ko kp kd b">Company</code> <code class="du kn ko kp kd b">model</code>数据库中<code class="du kn ko kp kd b">company</code>表的<code class="du kn ko kp kd b">create</code>命令的所有<code class="du kn ko kp kd b">ddl</code>。</p><p id="88aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，使用下面的命令将模型迁移到数据库中</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="f887" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">&gt; python manage.py migrate</strong></span></pre><p id="cfaa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">然后运行命令，通过使用</strong> <code class="du kn ko kp kd b"><strong class="is hj">docker-compose</strong></code>在 <code class="du kn ko kp kd b"><strong class="is hj">docker</strong></code> <strong class="is hj">中构建应用程序</strong></p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="76b5" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">&gt; docker-compose up --build</strong></span></pre><h1 id="141e" class="ky ki hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">检查<code class="du kn ko kp kd b">django</code> web服务是否与<code class="du kn ko kp kd b">postgresql</code> web服务连接</h1><p id="73f3" class="pw-post-body-paragraph iq ir hi is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated"><strong class="is hj">检查</strong> <code class="du kn ko kp kd b"><strong class="is hj">django-docker</strong></code> <strong class="is hj">项目是否连接了</strong> <code class="du kn ko kp kd b"><strong class="is hj">sqlite3</strong></code> <strong class="is hj">数据库中的本地环境</strong></p><p id="6561" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">转到<code class="du kn ko kp kd b">app</code>目录，然后运行以下命令</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="8d52" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">&gt; python manage.py shell</strong></span></pre><p id="3163" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您可以使用Django登录到项目的交互式shell。然后运行下面的命令</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="fe1f" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">To save the Company into database</strong></span><span id="a021" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">&gt;&gt;&gt; from main.models import Company<br/>&gt;&gt;&gt; company = Company()<br/>&gt;&gt;&gt; company.name = "New-Company-One"<br/>&gt;&gt;&gt; company.address = "new company address"<br/>&gt;&gt;&gt; company.country = "Japan"<br/>&gt;&gt;&gt; company.city = "Tokyo"<br/>&gt;&gt;&gt; company.save()</strong></span><span id="fd8f" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">To Get Data from database</strong></span><span id="2d65" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">&gt;&gt;&gt; Company.objects.all()<br/>&lt;QuerySet [&lt;Company: New-Company-One&gt;]&gt;</strong></span><span id="9bf5" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">To Exit the interactive shell</strong></span><span id="0737" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">&gt;&gt;&gt; exit()</strong></span></pre><p id="ed8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">检查</strong> <code class="du kn ko kp kd b"><strong class="is hj">django-docker</strong></code> <strong class="is hj">一个容器从</strong> <code class="du kn ko kp kd b"><strong class="is hj">django shell</strong></code>连接到 <code class="du kn ko kp kd b"><strong class="is hj">postgresql</strong></code> <strong class="is hj">数据库服务</strong></p><p id="a52c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您已经通过以下命令关闭了docker服务器</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="e50c" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">&gt; docker-compose down</strong></span><span id="1e8b" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">&gt; docker-compose up --build -d</strong></span></pre><p id="1d39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后运行Django交互式shell，从终端运行下面的命令</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="3d20" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">&gt; docker-compose exec web /bin/bash</strong></span></pre><p id="c3d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你现在在Django docker容器的外壳中</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="3533" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">root@&lt;image-no&gt;:/opt/app# python manage.py shell</strong></span></pre><p id="5332" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您可以使用DJANGO登录到项目的交互式shell。然后运行下面的命令</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="c22c" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">TO save the Company into database</strong></span><span id="9328" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">&gt;&gt;&gt; from main.models import Company<br/>&gt;&gt;&gt; company = Company()<br/>&gt;&gt;&gt; company.name = "New-Company-two"<br/>&gt;&gt;&gt; company.address = "new company address two"<br/>&gt;&gt;&gt; company.country = "Bangladesh"<br/>&gt;&gt;&gt; company.city = "Bangladesh"<br/>&gt;&gt;&gt; company.save()</strong></span><span id="64b3" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">To Get Data from database</strong></span><span id="ef39" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">&gt;&gt;&gt; Company.objects.all()<br/>&lt;QuerySet [&lt;Company: New-Company-two&gt;]&gt;</strong></span><span id="7872" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">To Exit the interactive shell</strong></span><span id="b42d" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">&gt;&gt;&gt; exit()</strong></span></pre><p id="756e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">您需要在docker容器</strong>中运行一次后刷新命令</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="a68b" class="kh ki hi kd b fi kj kk l kl km"><strong class="kd hj">&gt; python manage.py flush --no-input</strong></span><span id="71df" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj"># Use exit to logout from docker container bash</strong></span><span id="3602" class="kh ki hi kd b fi kq kk l kl km"><strong class="kd hj">&gt; exit</strong></span></pre><h1 id="681c" class="ky ki hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">你可以在GitHub repositor的“特性/自动迁移”分支</strong>中找到完整的代码库</h1><p id="8dcd" class="pw-post-body-paragraph iq ir hi is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">通过git克隆存储库</p><ol class=""><li id="589b" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">git克隆<a class="ae jx" href="https://github.com/tariqulislam/django-docker.git" rel="noopener ugc nofollow" target="_blank">https://github.com/tariqulislam/django-docker.git</a></li><li id="e085" class="jo jp hi is b it ma ix mb jb mc jf md jj me jn jt ju jv jw bi translated">签出到分支“git签出<a class="ae jx" href="https://github.com/tariqulislam/django-docker/tree/feature/automated-migration" rel="noopener ugc nofollow" target="_blank">特性/自动化迁移</a></li></ol><div class="mf mg ez fb mh mi"><a href="https://github.com/tariqulislam/django-docker.git" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab dw"><div class="mk ab ml cl cj mm"><h2 class="bd hj fi z dy mn ea eb mo ed ef hh bi translated">tariqulslam/django-docker</h2><div class="mp l"><h3 class="bd b fi z dy mn ea eb mo ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mq l"><p class="bd b fp z dy mn ea eb mo ed ef dx translated">github.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw io mi"/></div></div></a></div></div></div>    
</body>
</html>