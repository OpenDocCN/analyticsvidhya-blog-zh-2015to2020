<html>
<head>
<title>Setting up Django with Nginx, Gunicorn and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nginx、Gunicorn和Docker设置Django</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/setting-up-django-with-nginx-gunicorn-and-docker-352f7656f869?source=collection_archive---------0-----------------------#2020-04-07">https://medium.com/analytics-vidhya/setting-up-django-with-nginx-gunicorn-and-docker-352f7656f869?source=collection_archive---------0-----------------------#2020-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e38b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用Docker的生产就绪解决方案</h2></div><p id="0b85" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我之前的<a class="ae jt" rel="noopener" href="/@harshvijaythakkar/dajngo-with-nginx-gunicorn-aaf8431dc9e0">博客</a>中，我已经解释了如何使用<strong class="iz hj"> <em class="ju"> nginx </em> </strong>和<strong class="iz hj"> <em class="ju"> gunicorn </em> </strong>运行Django应用程序，这对于在<strong class="iz hj"> <em class="ju">生产环境</em> </strong>中运行Django来说是完美的。</p><p id="6a9e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将解释如何用Docker  轻松管理你的<strong class="iz hj"> <em class="ju"> Django应用程序。</em></strong></p><h1 id="1d51" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated"><strong class="ak">什么是docker？</strong></h1><p id="6db7" class="pw-post-body-paragraph ix iy hi iz b ja kn ij jc jd ko im jf jg kp ji jj jk kq jm jn jo kr jq jr js hb bi translated">Docker是一个容器化工具，用于构建隔离的、可复制的应用环境。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es ks"><img src="../Images/43481e44fad9e853d4268ba9ba9c7a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/0*aeIemGz_YpJbzbTo"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">架构图</figcaption></figure><p id="165f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以从我的GitHub库下载<a class="ae jt" href="https://github.com/harshvijaythakkar/harsh-django-docker" rel="noopener ugc nofollow" target="_blank">源代码</a>。这个项目是使用<strong class="iz hj"> Python3构建的。</strong></p><p id="36ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要测试这个应用程序，请转到django-harsh/hello_django/并运行以下命令</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="3546" class="lj jw hi lf b fi lk ll l lm ln">python hello/manage.py 0.0.0.0:8000</span></pre><p id="a725" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">进入浏览器，输入<strong class="iz hj"><em class="ju">&lt;ec2-DNS:8000&gt;</em></strong>你会看到django powered页面。如果您正在本地运行该应用程序，请在浏览器中键入<strong class="iz hj"><em class="ju">&lt;localhost:8000&gt;</em></strong>。确保您的<strong class="iz hj"> <em class="ju"> EC2安全组</em> </strong>允许端口8000上的流量。</p><p id="9586" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在生产中运行Django的本地服务器并不是推荐的方式，因为它只是一个测试服务器，而不是一个生产就绪的服务器。因此，在生产中运行Django就是运行Gunicorn，并使用Nginx作为反向代理，从而为我们的应用程序提供更多的安全性。</p><p id="353e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"><em class="ju">bin/guni corn _ start</em></strong>脚本是一个shell脚本，在run/目录下创建一个socket。</p><h1 id="ed0c" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated"><strong class="ak"> Dockerize Django应用程序。</strong></h1><p id="9f97" class="pw-post-body-paragraph ix iy hi iz b ja kn ij jc jd ko im jf jg kp ji jj jk kq jm jn jo kr jq jr js hb bi translated">确保您的目录结构如下所示:-</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="b3c6" class="lj jw hi lf b fi lk ll l lm ln">/home/ubuntu/my_django_dir<br/>  - hello_django (dir)<br/>  - Dockerfile</span></pre><p id="ca84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在您喜欢的文本编辑器中打开<strong class="iz hj"> <em class="ju"> Dockerfile </em> </strong>，添加以下几行:</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="c8e6" class="lj jw hi lf b fi lk ll l lm ln">FROM python:3.6</span><span id="19f3" class="lj jw hi lf b fi lo ll l lm ln">RUN mkdir -p /home/ubuntu/hello_django/</span><span id="a550" class="lj jw hi lf b fi lo ll l lm ln">WORKDIR /home/ubuntu/hello_django/</span><span id="ca7b" class="lj jw hi lf b fi lo ll l lm ln">ADD ./* /home/ubuntu/hello_django/</span><span id="badb" class="lj jw hi lf b fi lo ll l lm ln">RUN pip3 install -r /home/ubuntu/hello_django/requirements.txt</span><span id="b435" class="lj jw hi lf b fi lo ll l lm ln">VOLUME /home/ubuntu/hello_django/run/</span><span id="b534" class="lj jw hi lf b fi lo ll l lm ln">ENTRYPOINT ["/home/ubuntu/hello_django/bin/gunicorn_start"]</span></pre><p id="5417" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我使用的是基本图像python3.6。这个Dockerfile文件是自解释的。在这里，我创建并安装docker卷来存储我们的socket文件。当容器终止时，该卷将被删除。</p><p id="3c4d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">让我们建立docker图像。</strong></p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="da6f" class="lj jw hi lf b fi lk ll l lm ln">docker build -t hello-django .</span></pre><blockquote class="lp lq lr"><p id="9e35" class="ix iy ju iz b ja jb ij jc jd je im jf ls jh ji jj lt jl jm jn lu jp jq jr js hb bi translated">注意<strong class="iz hj">“”上面命令中的</strong>非常重要，它指定了<strong class="iz hj"> Dockerfile </strong>的路径。所以确保你在<strong class="iz hj">/home/Ubuntu/my _ django _ dir</strong></p></blockquote><p id="50fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经准备好了Django应用程序Docker映像。</p><p id="209f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">让我们运行docker容器。</strong></p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="c4b6" class="lj jw hi lf b fi lk ll l lm ln">docker run --name=container hello-django</span></pre><p id="1f03" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您运行这个容器时，您会看到类似这样的内容</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/f7d000b0ab4debfd1638fe7e5ca8e8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bOZ-kzduxVJSz_0e"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">码头集装箱日志</figcaption></figure><p id="4838" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我没有添加完整的截图，但只是我添加了一个重要的部分。您应该会看到类似上面的日志。</p><p id="5624" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您将无法在浏览器中看到任何东西，因为我们在运行容器时没有暴露任何端口。我们的容器将创建一个卷，我们的<strong class="iz hj"> <em class="ju"> gunicorn_start </em> </strong>脚本将创建一个套接字并存储在该卷中。</p><p id="3d01" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">让我们验证我们的套接字是通过进入容器</strong>创建的</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="0094" class="lj jw hi lf b fi lk ll l lm ln">docker exec -it container /bin/bash</span></pre><p id="5ac1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在你在docker容器中，你可以看到套接字被创建。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es ma"><img src="../Images/46859207c2b2b62fe34ca41356afd05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/0*ldICRghZkYD0LLJt"/></div></figure><p id="60af" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">键入<strong class="iz hj"><em class="ju"/></strong>从容器中出来。</p><p id="516a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="ju">恭喜恭喜！</em> </strong> <em class="ju">我们已经完成了Django应用程序的Dockerizing。</em></p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><h1 id="2345" class="jv jw hi bd jx jy mi ka kb kc mj ke kf io mk ip kh ir ml is kj iu mm iv kl km bi translated"><strong class="ak">对接Nginx </strong></h1><p id="200b" class="pw-post-body-paragraph ix iy hi iz b ja kn ij jc jd ko im jf jg kp ji jj jk kq jm jn jo kr jq jr js hb bi translated">确保您的目录结构如下:</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="c097" class="lj jw hi lf b fi lk ll l lm ln">/home/ubuntu/my_nginx_dir<br/>  - hello.conf<br/>  - Dockerfile</span></pre><p id="d490" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用一个指向我们的套接字的配置文件，并将我们的请求转发给我们的Django应用程序。</p><p id="9ecf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在您最喜欢的文本编辑器中打开<strong class="iz hj"> <em class="ju"> hello.conf </em> </strong>，并添加以下几行:</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="cffc" class="lj jw hi lf b fi lk ll l lm ln">upstream hello_app_server {</span><span id="745b" class="lj jw hi lf b fi lo ll l lm ln"># fail_timeout=0 means we always retry an upstream even if it failed</span><span id="25dd" class="lj jw hi lf b fi lo ll l lm ln"># to return a good HTTP response (in case the Unicorn master nukes a</span><span id="1e42" class="lj jw hi lf b fi lo ll l lm ln"># single worker for timing out).</span><span id="759d" class="lj jw hi lf b fi lo ll l lm ln">server unix:/home/ubuntu/hello_django/run/gunicorn.sock fail_timeout=0;</span><span id="96cb" class="lj jw hi lf b fi lo ll l lm ln">}</span><span id="0f2e" class="lj jw hi lf b fi lo ll l lm ln">server {</span><span id="084c" class="lj jw hi lf b fi lo ll l lm ln">listen   80;</span><span id="11ba" class="lj jw hi lf b fi lo ll l lm ln">server_name example.com;</span><span id="4acd" class="lj jw hi lf b fi lo ll l lm ln">client_max_body_size 4G;</span><span id="62fe" class="lj jw hi lf b fi lo ll l lm ln">access_log /home/ubuntu/hello_django/run/nginx-access.log;</span><span id="4378" class="lj jw hi lf b fi lo ll l lm ln">error_log /home/ubuntu/hello_django/run/nginx-error.log;<br/></span><span id="097e" class="lj jw hi lf b fi lo ll l lm ln">location /static/ {</span><span id="f297" class="lj jw hi lf b fi lo ll l lm ln">alias   /home/ubuntu/hello_django/static/;</span><span id="9933" class="lj jw hi lf b fi lo ll l lm ln">}</span><span id="0bc7" class="lj jw hi lf b fi lo ll l lm ln">location /media/ {</span><span id="8819" class="lj jw hi lf b fi lo ll l lm ln">alias   /home/ubuntu/hello_django/media/;</span><span id="2e05" class="lj jw hi lf b fi lo ll l lm ln">}</span><span id="e183" class="lj jw hi lf b fi lo ll l lm ln">location / {</span><span id="3f10" class="lj jw hi lf b fi lo ll l lm ln"># an HTTP header important enough to have its own Wikipedia entry:</span><span id="bfda" class="lj jw hi lf b fi lo ll l lm ln">#   http://en.wikipedia.org/wiki/X-Forwarded-For</span><span id="87e9" class="lj jw hi lf b fi lo ll l lm ln">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><span id="8da6" class="lj jw hi lf b fi lo ll l lm ln"># enable this if and only if you use HTTPS, this helps Rack</span><span id="8537" class="lj jw hi lf b fi lo ll l lm ln"># set the proper protocol for doing redirects:</span><span id="892a" class="lj jw hi lf b fi lo ll l lm ln"># proxy_set_header X-Forwarded-Proto https;</span><span id="6245" class="lj jw hi lf b fi lo ll l lm ln"># pass the Host: header from the client right along so redirects</span><span id="3450" class="lj jw hi lf b fi lo ll l lm ln"># can be set properly within the Rack application</span><span id="0f77" class="lj jw hi lf b fi lo ll l lm ln">proxy_set_header Host $http_host;</span><span id="32ee" class="lj jw hi lf b fi lo ll l lm ln"># we don't want nginx trying to do something clever with</span><span id="df5c" class="lj jw hi lf b fi lo ll l lm ln"># redirects, we set the Host: header above already.</span><span id="799e" class="lj jw hi lf b fi lo ll l lm ln">proxy_redirect off;</span><span id="6de5" class="lj jw hi lf b fi lo ll l lm ln"># set "proxy_buffering off" *only* for Rainbows! when doing</span><span id="dc2d" class="lj jw hi lf b fi lo ll l lm ln"># Comet/long-poll stuff.  It's also safe to set if you're</span><span id="dd6c" class="lj jw hi lf b fi lo ll l lm ln"># using only serving fast clients with Unicorn + nginx.</span><span id="1976" class="lj jw hi lf b fi lo ll l lm ln"># Otherwise you _want_ nginx to buffer responses to slow</span><span id="4ac8" class="lj jw hi lf b fi lo ll l lm ln"># clients, really.</span><span id="51b8" class="lj jw hi lf b fi lo ll l lm ln"># proxy_buffering off;</span><span id="ef05" class="lj jw hi lf b fi lo ll l lm ln"># Try to serve static files from nginx, no point in making an</span><span id="3e96" class="lj jw hi lf b fi lo ll l lm ln"># *application* server like Unicorn/Rainbows! serve static files.</span><span id="4418" class="lj jw hi lf b fi lo ll l lm ln">if (!-f $request_filename) {</span><span id="4a4b" class="lj jw hi lf b fi lo ll l lm ln">proxy_pass http://hello_app_server;</span><span id="7b7e" class="lj jw hi lf b fi lo ll l lm ln">break;</span><span id="faaa" class="lj jw hi lf b fi lo ll l lm ln">}</span><span id="db4b" class="lj jw hi lf b fi lo ll l lm ln">}</span><span id="1153" class="lj jw hi lf b fi lo ll l lm ln"># Error pages</span><span id="e0ef" class="lj jw hi lf b fi lo ll l lm ln">error_page 500 502 503 504 /500.html;</span><span id="79d5" class="lj jw hi lf b fi lo ll l lm ln">location = /500.html {</span><span id="fa63" class="lj jw hi lf b fi lo ll l lm ln">root /home/ubuntu/hello_django/static/;</span><span id="bd82" class="lj jw hi lf b fi lo ll l lm ln">}</span><span id="e3f6" class="lj jw hi lf b fi lo ll l lm ln">}</span></pre><p id="8a98" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，在您喜欢的文本编辑器中打开<strong class="iz hj"> <em class="ju"> Dockerfile </em> </strong>并添加以下行:</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="faf7" class="lj jw hi lf b fi lk ll l lm ln">FROM nginx</span><span id="357d" class="lj jw hi lf b fi lo ll l lm ln">WORKDIR /etc/nginx/</span><span id="9493" class="lj jw hi lf b fi lo ll l lm ln">RUN rm /etc/nginx/conf.d/default.conf</span><span id="9b0b" class="lj jw hi lf b fi lo ll l lm ln">COPY hello.conf /etc/nginx/conf.d/</span><span id="e074" class="lj jw hi lf b fi lo ll l lm ln">EXPOSE 80</span></pre><p id="4d9f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我使用nginx基础图像。Nginx附带了<strong class="iz hj"> <em class="ju"> default.conf </em> </strong>文件，其中包含了nginx的一些基本配置。我正在删除那个文件，并将添加我们的<strong class="iz hj"> <em class="ju"> hello.conf </em> </strong>文件。</p><p id="767d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">构建Nginx docker映像</strong></p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="bb87" class="lj jw hi lf b fi lk ll l lm ln">docker build -t hello-nginx .</span></pre><p id="9f11" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="ju">恭喜恭喜！</em> </strong> <em class="ju">我们已经创建了两个docker映像，现在我们准备好为Django应用程序提供服务了。</em></p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><h1 id="071b" class="jv jw hi bd jx jy mi ka kb kc mj ke kf io mk ip kh ir ml is kj iu mm iv kl km bi translated"><strong class="ak">让我们进行端到端测试</strong></h1><p id="2ed5" class="pw-post-body-paragraph ix iy hi iz b ja kn ij jc jd ko im jf jg kp ji jj jk kq jm jn jo kr jq jr js hb bi translated">首先使用我们之前创建的docker映像运行我们的Django应用程序。</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="6f24" class="lj jw hi lf b fi lk ll l lm ln">docker run --name=django-container hello-django</span></pre><blockquote class="lp lq lr"><p id="4ad8" class="ix iy ju iz b ja jb ij jc jd je im jf ls jh ji jj lt jl jm jn lu jp jq jr js hb bi translated">请注意，<strong class="iz hj"> <em class="hi"> "— name" </em> </strong>是运行Django容器时的重要参数，我们将使用这个名称来引用它创建的卷，并将该卷附加到我们的nginx容器。</p></blockquote><p id="4e1b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">打开新终端，运行nginx docker镜像。</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="b80f" class="lj jw hi lf b fi lk ll l lm ln">docker run -p 80:80 --volumes-from django-container hello-nginx</span></pre><p id="fa50" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们将我们的<strong class="iz hj"> <em class="ju">主机端口80 </em> </strong>与<strong class="iz hj"> <em class="ju">容器端口80 </em> </strong>进行映射，因为nginx运行在<strong class="iz hj"> <em class="ju">端口80 </em> </strong>上。不需要为Django容器映射端口，因为我们使用<strong class="iz hj"> <em class="ju">套接字</em> </strong>来请求服务器。确保您的<strong class="iz hj"> <em class="ju"> EC2安全组</em> </strong>允许端口80上的流量。</p><p id="7c8e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在进入你的浏览器，输入<strong class="iz hj"><em class="ju">&lt;ec2-DNS&gt;</em></strong>或<strong class="iz hj"><em class="ju">&lt;localhost:80&gt;</em></strong>你会看到一个Django驱动的页面。</p><blockquote class="lp lq lr"><p id="2db9" class="ix iy ju iz b ja jb ij jc jd je im jf ls jh ji jj lt jl jm jn lu jp jq jr js hb bi translated">请注意，我们没有公开Django容器端口，因此外界的人无法访问Django应用程序，他们必须先访问Nginx，Nginx会负责将请求转发给我们的应用程序，这样我们的应用程序就完全安全了。</p></blockquote><h1 id="275a" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated">恭喜你！</h1><p id="7549" class="pw-post-body-paragraph ix iy hi iz b ja kn ij jc jd ko im jf jg kp ji jj jk kq jm jn jo kr jq jr js hb bi translated">你已经使用Nginx和Gunicorn成功运行了Django应用程序，guni corn是一个使用Docker的<strong class="iz hj"> <em class="ju">生产就绪服务器</em> </strong>。</p><p id="d5e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae jt" rel="noopener" href="/@harshvijaythakkar/setting-up-django-with-nginx-gunicorn-and-aws-ecs-e1b279c7ae8"> <strong class="iz hj"> <em class="ju">第三部分</em> </strong> </a>中，我已经解释了如何在<strong class="iz hj"><em class="ju">“AWS弹性容器服务(ECS)”</em></strong>中运行这个Django应用程序，它是用于运行Docker容器的托管服务。</p><p id="b368" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="ju">谢谢！</em> </strong></p></div></div>    
</body>
</html>