<html>
<head>
<title>Dockerize Django with Nginx and PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Nginx和PostgreSQL实现Django</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dockerize-django-with-nginx-and-postgresql-4fd922ff8418?source=collection_archive---------0-----------------------#2020-10-13">https://medium.com/analytics-vidhya/dockerize-django-with-nginx-and-postgresql-4fd922ff8418?source=collection_archive---------0-----------------------#2020-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="254b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“docker是Linux的Inception”，这是我在解释Docker时喜欢用的说法。因为docker就是这样，一个Linux在一个共享主机内核的Linux里面。对于任何有同情心的Linux用户来说，可以在几天内学会docker。在本文中，我将讨论用docker-compose在生产环境(Nginx、PostgreSQL和Gunicorn)中对一个完整的Django应用程序进行dockerizing。所以，让我们开始-</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b38e1fae9f73c6ef8189f5ab978f1bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mdcBNM5dMOZOP4jrbahw2g.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">燕尾服和码头工人作者— <a class="ae jt" href="https://www.flickr.com/photos/134416355@N07/" rel="noopener ugc nofollow" target="_blank">伊藤京平</a></figcaption></figure><p id="9420" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">满足先决条件</strong></p><ul class=""><li id="b03a" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">安装docker</li><li id="f436" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">安装docker-compose</li></ul><p id="40a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">获取代码</strong></p><div class="ki kj ez fb kk kl"><a href="https://github.com/by-sabbir/django-gunicorn-nginx-docker" rel="noopener  ugc nofollow" target="_blank"><div class="km ab dw"><div class="kn ab ko cl cj kp"><h2 class="bd hj fi z dy kq ea eb kr ed ef hh bi translated">by-sab Bir/django-guni corn-nginx-docker</h2><div class="ks l"><h3 class="bd b fi z dy kq ea eb kr ed ef dx translated">当涉及到部署和CI/CD时，Docker会让您的生活稍微轻松一些。这种方法可用于部署大多数…</h3></div><div class="kt l"><p class="bd b fp z dy kq ea eb kr ed ef dx translated">github.com</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz jn kl"/></div></div></a></div></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="17f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在根目录(包含docker-compose.yml的同一个目录)创建一个. env文件，并按如下所示进行编辑</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="ab31" class="lm ln hi li b fi lo lp l lq lr">SECRET_KEY="YOUR SECRET KEY"<br/>DB_HOST="db"<br/>DB_PASSWORD="hello"   #from docker-compose.yml<br/>DB_USER="postgres"    #from docker-compose.yml<br/>DB_NAME="postgres"    #from docker-compose.yml<br/>DB_PORT="5432"        #from docker-compose.yml<br/>DB_ENGINE="django.db.backends.postgresql"</span></pre><p id="fbc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用以下两个命令<code class="du ls lt lu li b">docker-compose build</code>，系统将启动并运行</p><p id="7a6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将从docker hub下载所有的依赖项和docker映像</p><p id="9d3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ls lt lu li b">docker-compose up -d</code></p><p id="ffa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们必须将静态文件复制到我们指定的settings.py目录下，我们将这样做，</p><p id="5d2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ls lt lu li b">docker-compose exec web python manage.py collectstatic --no-input</code></p><p id="7c6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望现在您的项目已经启动并运行了，您可以在<a class="ae jt" href="http://localhost:8008/" rel="noopener ugc nofollow" target="_blank"> localhost:8008 </a>访问它。如果没有，使用<code class="du ls lt lu li b">docker-compose logs -f </code>进行调试。</p><p id="8a41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">设计/思考过程</strong></p><p id="19f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，问题是在生产环境中运行docker内的Django应用程序，意味着使用Nginx作为HTTP服务器，Postgresql作为DB服务器。这是我的计划——我将在不同的容器中运行应用程序、HTTP服务器和DB服务器，使其更易于管理和健壮。该应用程序将在Gunicorn上运行，稍后将使用Nginx的代理通行证。我们需要一个用于HTTP服务器的共享卷，一个用于静态和媒体文件托管的应用程序，以及一个用于DB的持久文件系统。所有的秘密都将储存在一个完全独立的。环境文件。</p><p id="307f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看web服务:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="6018" class="lm ln hi li b fi lo lp l lq lr">web:<br/>    build: .<br/>    container_name: test_deploy_web<br/>    command: gunicorn app.wsgi:application --bind 0.0.0.0:8000<br/>    volumes:<br/>      - ./app:/app/<br/>      - staticfiles:/app/static/<br/>    expose:<br/>      - 8000<br/>    env_file:<br/>      - ./.env<br/>    depends_on:<br/>      - db</span></pre><p id="6a40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二行是“构建”意味着它将从根docker文件创建一个docker映像，让我们来看看这个文件，</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="a986" class="lm ln hi li b fi lo lp l lq lr">FROM python:latest<br/>  ENV PYTHONDONTWRITEBYTECODE 1<br/>  ENV PYTHONUNBUFFERED 1<br/>  RUN mkdir /app<br/>  WORKDIR /app<br/>  RUN pip install --upgrade pip<br/>  COPY requirements.txt .<br/>  RUN pip install -r requirements.txt<br/>  COPY ./app /app</span></pre><p id="0f43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">法利简单易懂。让我们进入下一个阶段，数据库</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="4d6d" class="lm ln hi li b fi lo lp l lq lr">db:<br/>    image: postgres<br/>    container_name: test_deploy_db<br/>    volumes:<br/>      - postgres_data:/var/lib/postgresql/data/<br/>    environment:<br/>      - POSTGRES_DB=postgres<br/>      - POSTGRES_USER=postgres<br/>      - POSTGRES_PASSWORD=hello</span></pre><p id="bc04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将只使用官方的Postgres docker映像，postgres_data是docker中的持久数据量。应该够了。</p><p id="4c0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在Nginx。你可以用它做任何你想做的事。Nginx真正带给你的是极致的力量。</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="32dd" class="lm ln hi li b fi lo lp l lq lr">nginx:<br/>    build: ./nginx<br/>    container_name: test_deploy_nginx<br/>    volumes:<br/>      - staticfiles:/app/static/<br/>    ports:<br/>      - 8008:80<br/>    depends_on:<br/>      - web</span></pre><p id="f240" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们深入了解一下这个组合配置。第二行表示它将编译‘nginx’文件夹中的任何docker文件。让我们跟着线索走-</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="cc5d" class="lm ln hi li b fi lo lp l lq lr">FROM nginx:1.19.0-alpine<br/>RUN mkdir /app<br/>RUN rm /etc/nginx/conf.d/default.conf<br/>COPY nginx.conf /etc/nginx/conf.d/<br/>WORKDIR /app</span></pre><p id="e1c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇，那很容易。简单地说，我们只是删除了默认的配置文件，并用我们自己的替换它。问题是我们的配置文件中有什么，让我们看一个简单的版本-</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="77c8" class="lm ln hi li b fi lo lp l lq lr">upstream app {<br/>    server web:8000;<br/>}</span><span id="a903" class="lm ln hi li b fi lv lp l lq lr">server {<br/>    listen 80;<br/>    location / {<br/>        proxy_pass <a class="ae jt" href="http://app;" rel="noopener ugc nofollow" target="_blank">http://app;</a><br/>    }<br/>    location /static/ {<br/>        alias /app/static/;<br/>    }<br/>}</span></pre><p id="9193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Nginx的上游配置代理请求服务器。Gunicorn是我们Django应用程序的Python WSGI服务器。在第一个位置派生中，我们将“/”根位置从应用程序代理传递到HTTP服务器。二阶位置导数只是静态文件的别名。现在，我们可以用Nginx服务器来发挥创造力。</p><p id="a213" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想就是这里了。如果我错过了什么，请告诉我。<a class="ae jt" href="https://github.com/by-sabbir/django-gunicorn-nginx-docker#dockerize-django-along-with-nginx-and-postgresql" rel="noopener ugc nofollow" target="_blank">自述文件</a>有更详细的命令。你可以随意修改代码，我会检查Github的问题，到时见。</p></div></div>    
</body>
</html>