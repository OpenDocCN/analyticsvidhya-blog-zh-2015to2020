<html>
<head>
<title>Procs, Modules, and Mixins: Ruby’s Benchwarmers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进程、模块和混合:Ruby的冷板凳</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/procs-modules-and-mixins-rubys-benchwarmers-12bfe4835114?source=collection_archive---------11-----------------------#2020-05-21">https://medium.com/analytics-vidhya/procs-modules-and-mixins-rubys-benchwarmers-12bfe4835114?source=collection_archive---------11-----------------------#2020-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/3b85dc2d816e10226a5c210c3e5d7ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JV_Kl5rk0M9BPW9ZB9ch3Q.jpeg"/></div></div></figure><div class=""/><p id="8608" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">简介</strong></p><p id="ef03" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在许多情况下，基本的OOP教育关注于数据类型、变量、方法、数组和散列以及类。有很多很好的理由从基础开始，并在深入探索较少导航、动荡的水域之前熟悉这些工具。事实上，一些最古老的人类智慧赞美简单。然而，在对基础知识达到一定程度的熟悉后，程序员应该向前看，以便继续成长。因此，基础成为允许程序员使用其他精心设计的库和框架的构建块。一般来说，一个人对任何主题的基础理解得越好，新的和复杂的主题就越容易理解。当然，这篇文章的目的并不是建议程序员新手应该学习更少的基本技能；相反，它们是编程不可或缺的一部分。</p><p id="320e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，就其本身而言，以其最基本的形式，它们并没有涵盖软件工程师在该领域中面临的所有情况——呃，在计算机屏幕上。因此，如果基础如此之好，但它们没有提供足够的功能来涵盖每一个设计实现，那么pray tell是一个编码器要做什么呢？你这么问很有趣！在软件应用程序中创建对象、函数和类时，有些用例需要更大的灵活性。在这篇文章中，我想探讨OOPs的一些缺点，然后对Ruby提供给我们的一些工具做一个广泛而基本的介绍，这些工具增强了OOP最基本的构件的默认功能:过程、模块和混合。</p><p id="9840" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">让我们探讨一下OOP的一些缺点</strong></p><p id="d563" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">面向对象编程经常被标榜为解决问题能力和工程能力的表面典范。然而，在面向对象编程之前，在计算机科学领域还有其他的范例，例如过程化或函数式编程。事实上，在一些问题上，过程式编程比面向对象编程更有效。因此，如果至少有两种关于<em class="jo">如何</em>编程的思想流派，并且仅仅是这两种流派的存在就表明它们是为解决一组特定的问题而开发的，那么有理由认为至少在它们之间存在一些折衷，并且由此引申出OOP的缺点。</p><p id="c7e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OOP的缺点是概念上的、风格上的和架构上的。众所周知，面向对象编程可能会令人困惑，因此有一个陡峭的学习曲线。这需要时间来适应如何用这种方法解决问题，因为<em class="jo">如何创建</em>对象以及其他细节一开始可能看起来不符合逻辑。此外，面向对象的设计可能很冗长。让我吃惊的是，一个符合惯例的程序需要这么多的包、文件和目录来完成相对简单的任务。另一种思考方式是开销。作为程序员，程序经常会变得比我们最初预期的还要大。因此，程序的效率和性能会因其自身的大小和架构而受到影响。甚至，继承OOPs定义特性之一——也有它的缺点，在某些边缘情况下，一个类家族的成员具有或缺乏某些与其自己的层次结构共有的属性，但是它与另一个不相关的类共享。</p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="d021" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">幸运的是，有一些策略和特性可以用来减少程序的大小，减少样板代码的重复，以及容器化组件逻辑。当然，当开始永无止境的编程之旅时，这些细节可能看起来微不足道。更愤世嫉俗的是，这些担忧可能看起来很浮夸，因为它们只是炫耀的诡计，使用了比必要更复杂的语法；当一个问题可以用简单明了的代码通过一点额外的工作来解决时，却隐藏了清晰的含义。但是在踏上黄砖路的过程中，我们可以学到很多东西，哪怕只是为了最终揭露一个假巫师。</p><p id="56ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> Procs </strong></p><p id="dbae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">proc是封装块的对象。很简单，下课。JK。为了理解这句话的力量，我们有必要多花一点时间来理解它。首先，文字代码块——do和end之间或{ and }之间的代码——直到现在都不可重用，也不可传递。因此，通过封装，我们可以抽象出一些重复，并利用块级别的作用域。因此，过程增加了代码的模块性，减少了重复。具有讽刺意味的是，Ruby文档吹捧procs是“Ruby中的一个基本概念，也是其函数式编程特性的核心”。也许将它定义为Ruby函数式编程特性的核心，可以帮助我们理解procs如何解决OOPs的一些缺点。</p><p id="2dba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以通过多种方式创建Proc，但在本文中，我们将重点关注Proc类构造函数语法。这段代码类似于其他构造函数，但是注意花括号的使用会产生Proc数据类型，如下所示:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="14e2" class="ka kb ht jw b fi kc kd l ke kf">x = Proc.new {}</span><span id="a5d7" class="ka kb ht jw b fi kg kd l ke kf">puts x.inspect # =&gt; #&lt;Proc:<a class="ae kh" href="mailto:0x00007ff5a5900950@proc.rb" rel="noopener ugc nofollow" target="_blank">0x00007ff5a5900950@proc.rb</a>:3&gt;</span></pre><p id="bcca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，那很好，很好。但是我们如何使用它们呢？嗯，使用procs的一种方法是替换小的、重复的代码块。例如，如果您在程序中有一个对象，并且发现自己必须遍历该对象才能执行重复的任务，那么您可以使用proc来使您的代码更加D-R-Y:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="7197" class="ka kb ht jw b fi kc kd l ke kf">x = Proc.new {|num| puts num * 4}</span><span id="50b4" class="ka kb ht jw b fi kg kd l ke kf">[1, 2, 3, 4, 5, 6, 7].each &amp;x # =&gt; 4, 8, 12, 16, 20, 24, 28</span></pre><p id="6cb4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，我们的重复任务是将数组中的数字乘以4。请注意&amp;符号的使用，它让Ruby知道“x”不是任何ole变量，它是一个特殊的变量。下面是另一个例子:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="68c2" class="ka kb ht jw b fi kc kd l ke kf">x = Proc.new { |word| word.length &gt; 6 &amp;&amp; word.length % 2 == 0 }</span><span id="c9c2" class="ka kb ht jw b fi kg kd l ke kf">long_words = ['apple', 'wisdom', 'anonymous', 'elementary', 'monitor', 'computer', 'available', 'independence']</span><span id="bcd9" class="ka kb ht jw b fi kg kd l ke kf">puts long_words.select &amp;x # =&gt; elementary, computer, independence</span></pre><p id="163f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在前面的示例中，proc用于替换。<em class="jo">每种</em>方法。此外，您还可以将过程作为一等公民传递到方法中，并使用它们的。<em class="jo">谓</em>法:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="9fb8" class="ka kb ht jw b fi kc kd l ke kf">x = Proc.new do |word|</span><span id="4219" class="ka kb ht jw b fi kg kd l ke kf">      word.capitalize!</span><span id="52a9" class="ka kb ht jw b fi kg kd l ke kf">      word.reverse!</span><span id="b90f" class="ka kb ht jw b fi kg kd l ke kf">      puts word * 4</span><span id="0ceb" class="ka kb ht jw b fi kg kd l ke kf">   end</span><span id="a7fa" class="ka kb ht jw b fi kg kd l ke kf">def some_method(proc_x)</span><span id="9b7a" class="ka kb ht jw b fi kg kd l ke kf">   proc_x.call("hip hip")</span><span id="96d1" class="ka kb ht jw b fi kg kd l ke kf">end</span><span id="fdb6" class="ka kb ht jw b fi kg kd l ke kf">some_method(x) # =&gt; pih piHpih piHpih piHpih piH</span></pre><p id="61d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，您可以创建具有自定义块功能的自定义方法，如下所述:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="0cca" class="ka kb ht jw b fi kc kd l ke kf">x = Proc.new { puts "This is Proc-tically impossible"}</span><span id="c586" class="ka kb ht jw b fi kg kd l ke kf">def some_method</span><span id="5a1b" class="ka kb ht jw b fi kg kd l ke kf">   yield</span><span id="c2df" class="ka kb ht jw b fi kg kd l ke kf">end</span><span id="79f4" class="ka kb ht jw b fi kg kd l ke kf">some_method(&amp;x) # =&gt; This is Proc-tically impossible</span></pre><p id="b5e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你觉得危险，procs甚至可以用来简化一些数据类型转换和迭代器逻辑。根据Ruby文档，这是因为“任何实现。<em class="jo"> to_proc </em>方法可以通过'&amp;'操作符转换成proc，因此可以被迭代器使用在Ruby的核心类中，符号、方法和散列实现了。<em class="jo"> to_proc </em>方法。</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="2c00" class="ka kb ht jw b fi kc kd l ke kf">arr = ["1", "2", "3"]</span><span id="4e4f" class="ka kb ht jw b fi kg kd l ke kf">puts arr.map &amp;:to_i #=&gt; 1, 2, 3<br/></span><span id="d416" class="ka kb ht jw b fi kg kd l ke kf">arr = ["Danger's", "my", "middle", "name"]</span><span id="a4f1" class="ka kb ht jw b fi kg kd l ke kf">puts arr.map &amp;:upcase #=&gt; DANGER'S, MY, MIDDLE, NAME</span></pre><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="ki ju l"/></div></figure><p id="0e1c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Procs可用于简化块级代码和利用局部范围的变量。更重要的是，procs是Ruby对闭包<em class="jo">的实现，闭包</em>允许它们记住创建它们的上下文。但那是另一天的话题。因为proc在功能上是一个对象，所以块本身可以在程序中传递，而不必多次重复代码。因此，我们可以将代码分配给变量，并根据需要重用、转换和插入代码。在我看来，这绝对是一个值得熟悉并保存在工具箱中的工具。</p><p id="81eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">模块和混合模块</strong></p><p id="a446" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">模块是向类提供额外状态和行为的好方法，而不必担心继承链和覆盖其他方法。它们提供对模块声明中定义的方法和常数的访问。模块提供对实例级方法和模块级方法的支持，但是<em class="jo">包含</em>或使用模块行为的类只能访问实例级方法。相反，模块级方法可以直接在模块对象上访问。</p><p id="364f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然面向对象继承的好处已经有了很好的证明，但是也应该注意到，由于继承链的垂直性，它有一些限制。事实上，类从它们的祖先类继承，并在它们的子类中复制功能，但是没有与不相关的类共享状态和行为的本地方法。从表面上看，在不相关的类之间共享属性似乎不合逻辑，但这在现实生活中实际上很常见。想象一下，狗和猫会引起过敏，但是花和草，花生和小麦也会引起过敏。以这种方式包装行为并在不同的类之间共享是模块的常见用法。</p><p id="ee8e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在编码示例中尝试将一些模块方法容器化。首先，让我们创建一个父类:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="311d" class="ka kb ht jw b fi kc kd l ke kf"># superhero.rb</span><span id="34df" class="ka kb ht jw b fi kg kd l ke kf">class Superhero</span><span id="5dac" class="ka kb ht jw b fi kg kd l ke kf">   def righteous_call(evil_doer)</span><span id="bc60" class="ka kb ht jw b fi kg kd l ke kf">      puts "Hey, put that back, #{evil_doer}!"</span><span id="c11b" class="ka kb ht jw b fi kg kd l ke kf">   end</span><span id="03ac" class="ka kb ht jw b fi kg kd l ke kf">end</span></pre><p id="9649" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了，我们降落在超级英雄身上。接下来，让我们装备他们中的一些人，制作一个只有一些超级英雄才能使用的斯塔克工业模块:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="45b8" class="ka kb ht jw b fi kc kd l ke kf"># stark.rb</span><span id="f667" class="ka kb ht jw b fi kg kd l ke kf">module Stark</span><span id="1586" class="ka kb ht jw b fi kg kd l ke kf">   def thrusters</span><span id="437e" class="ka kb ht jw b fi kg kd l ke kf">      puts "Boomm!!"</span><span id="e291" class="ka kb ht jw b fi kg kd l ke kf">   end</span><span id="119f" class="ka kb ht jw b fi kg kd l ke kf">   def ai_sunglasses(name)</span><span id="50de" class="ka kb ht jw b fi kg kd l ke kf">      puts "A.I. System will track #{name} through sunglasses..."</span><span id="3a94" class="ka kb ht jw b fi kg kd l ke kf">   end</span><span id="5134" class="ka kb ht jw b fi kg kd l ke kf">end</span></pre><p id="e559" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，是时候制造这些超级英雄，并展示模块如何提供对基于类的继承之外的行为的访问。</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="5746" class="ka kb ht jw b fi kc kd l ke kf"># hero.rb</span><span id="03fa" class="ka kb ht jw b fi kg kd l ke kf">require_relative "./superhero"<br/>require_relative "./stark"</span><span id="aa65" class="ka kb ht jw b fi kg kd l ke kf"><br/>class Spiderman &lt; Superhero</span><span id="4acc" class="ka kb ht jw b fi kg kd l ke kf">   include Stark</span><span id="125a" class="ka kb ht jw b fi kg kd l ke kf">end</span><span id="d92b" class="ka kb ht jw b fi kg kd l ke kf">class Ironman &lt; Superhero</span><span id="d1c2" class="ka kb ht jw b fi kg kd l ke kf">   include Stark</span><span id="a3ec" class="ka kb ht jw b fi kg kd l ke kf">end</span><span id="28ad" class="ka kb ht jw b fi kg kd l ke kf">spidey = Spiderman.new </span><span id="fd80" class="ka kb ht jw b fi kg kd l ke kf">iron = Ironman.new</span><span id="1eeb" class="ka kb ht jw b fi kg kd l ke kf">spidey.thrusters # =&gt; Boomm!!</span><span id="d78e" class="ka kb ht jw b fi kg kd l ke kf">iron.thrusters # =&gt; Boomm!!</span><span id="cb36" class="ka kb ht jw b fi kg kd l ke kf">spidey.ai_sunglasses("Wilson Fisk") # =&gt; A.I. System will track Wilson Fisk through sunglasses...</span><span id="0c02" class="ka kb ht jw b fi kg kd l ke kf">iron.ai_sunglasses("Victor Von Doom") # =&gt; A.I. System will track Victor Von Doom through sunglasses...</span></pre><p id="4754" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与类继承语法不同，类&lt; ParentClass, modules are imported within the body of the class using the <em class="jo">包括</em>关键字。我认为这是有意义的，因为这个类没有变成新的东西，也没有获得新的属性；相反，它通过模块导入采用了新的行为。</p><p id="e58a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管蜘蛛侠和钢铁侠都是超级英雄，但并不是所有我们创造的超级英雄都可以使用斯塔克工业的推进器和人工智能太阳镜。例如，蝙蝠侠可能是一个超级英雄，但他来自DC宇宙，所以他不会接触到托尼·斯塔克的好东西。为了克服继承的限制，模块成为跨类共享行为的便捷方式。</p><p id="7c8d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过使用Mixins，这个特性可以得到进一步的发展。mixin只是在一个类中增加了对多个模块的访问。由于Ruby不支持多重继承，我们可以用多个模块混合成——读Mixin——一个子类。函数混合提供了多重继承提供给其他语言的可扩展性和模块化。因此，虽然Ruby没有提供其他语言实现的所有OOP特性，但是mixins实现了这个功能，并且是Ruby中<em class="jo"> ducktyping </em>的经典例子。根据作者Harmes和Diaz的说法，<em class="jo"> ducktyping </em>来源于这样一个表达，“如果它走路像鸭子，叫声像鸭子，那么它一定是一只鸭子。”在编程的上下文中，它可以被解释为如果一个给定的对象像另一个对象一样定义和运行，那么它也必须是第二个对象。</p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="8aa8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">模块的另一个用例是为公共类名创建名称空间，避免程序中的冲突。想象一个由英雄和恶棍组成的程序。如果程序足够大，有理由认为类名冲突会导致冲突。请注意下面的示例:</p><p id="5b4b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先让我们创建一个超级英雄模块:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="51b3" class="ka kb ht jw b fi kc kd l ke kf">module Superhero</span><span id="e040" class="ka kb ht jw b fi kg kd l ke kf">   class Cyclops</span><span id="9e4a" class="ka kb ht jw b fi kg kd l ke kf">      def eye</span><span id="fa1a" class="ka kb ht jw b fi kg kd l ke kf">         puts "My eye(s) shoots lasers. Zap!"</span><span id="06e6" class="ka kb ht jw b fi kg kd l ke kf">      end</span><span id="4539" class="ka kb ht jw b fi kg kd l ke kf">   end</span><span id="ab29" class="ka kb ht jw b fi kg kd l ke kf">   class Titans</span><span id="4472" class="ka kb ht jw b fi kg kd l ke kf">      def original_team</span><span id="52d8" class="ka kb ht jw b fi kg kd l ke kf">         puts "Robin, Superboy, Kid Flash, Wonder Girl"</span><span id="f4a4" class="ka kb ht jw b fi kg kd l ke kf">      end</span><span id="a289" class="ka kb ht jw b fi kg kd l ke kf">      def teen_titans</span><span id="b190" class="ka kb ht jw b fi kg kd l ke kf">         puts "Nightwing, Raven, Starfire, Beast Boy"</span><span id="c171" class="ka kb ht jw b fi kg kd l ke kf">      end</span><span id="800d" class="ka kb ht jw b fi kg kd l ke kf">   end</span><span id="c720" class="ka kb ht jw b fi kg kd l ke kf">end</span></pre><p id="64d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，让我们制作一个希腊语模块:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="c1bb" class="ka kb ht jw b fi kc kd l ke kf">module Greek</span><span id="ecd6" class="ka kb ht jw b fi kg kd l ke kf">   class Cyclops</span><span id="f4af" class="ka kb ht jw b fi kg kd l ke kf">      def eye</span><span id="a7d4" class="ka kb ht jw b fi kg kd l ke kf">         puts "I traded my eye to see the future"</span><span id="8240" class="ka kb ht jw b fi kg kd l ke kf">      end</span><span id="1b1b" class="ka kb ht jw b fi kg kd l ke kf">   end</span><span id="56ba" class="ka kb ht jw b fi kg kd l ke kf">   class Titans</span><span id="53e8" class="ka kb ht jw b fi kg kd l ke kf">      def original_team</span><span id="69c6" class="ka kb ht jw b fi kg kd l ke kf">         puts "Oceanus, Tethys, Hyperion, Theia, Coeus, Phoebe, Cronus, Rhea, Mnemosyne, Themis, Crius and Iapetus"</span><span id="1afd" class="ka kb ht jw b fi kg kd l ke kf">      end</span><span id="5572" class="ka kb ht jw b fi kg kd l ke kf">   end</span><span id="be42" class="ka kb ht jw b fi kg kd l ke kf">end</span></pre><p id="a57c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，是时候证明通过使用模块，Titans和Cyclops类的两个版本可以存在于同一个Ruby文件中，而不会有任何命名空间错误。</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="4a75" class="ka kb ht jw b fi kc kd l ke kf">require_relative './superhero'<br/>require_relative './greek'<br/></span><span id="d289" class="ka kb ht jw b fi kg kd l ke kf">s_cyclops = Superhero::Cyclops.new</span><span id="2b11" class="ka kb ht jw b fi kg kd l ke kf">g_cyclops = Greek::Cyclops.new</span><span id="c820" class="ka kb ht jw b fi kg kd l ke kf">s_titans = Superhero::Titans.new</span><span id="dbaf" class="ka kb ht jw b fi kg kd l ke kf">g_titans = Greek::Titans.new</span><span id="385d" class="ka kb ht jw b fi kg kd l ke kf">s_cyclops.eye # =&gt; My eye(s) shoots lasers. Zap!</span><span id="7d0b" class="ka kb ht jw b fi kg kd l ke kf">g_cyclops.eye # =&gt; I traded my eye to see the future</span><span id="5054" class="ka kb ht jw b fi kg kd l ke kf">s_titans.original_team # =&gt; Robin, Superboy, Kid Flash, Wonder Girl</span><span id="ce17" class="ka kb ht jw b fi kg kd l ke kf">g_titans.original_team # =&gt; Oceanus, Tethys, Hyperion, Theia, Coeus, Phoebe, Cronus, Rhea, Mnemosyne, Themis, Crius and Iapetus</span></pre><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="kj ju l"/></div></figure><p id="0005" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在继承和模块之间，Ruby为软件工程师提供了解决几乎所有类问题的工具。继承是OOP的原则之一，但是尽管它提供了强大的功能和多样性，它并不能解决所有的设计挑战。由于它们与这一组具有挑战性的边缘案例相关，模块提供了模块化和更高的灵活性，同时减少了重复。尽管模块不是<em class="jo">可实例化的</em>，但是它们确实提供了一个干净地组织、定义和构造代码的名称空间。区分何时使用基于类的继承和混合模块的简单方法是定义关系。蜘蛛侠”是一个“超级英雄；而他只有一个斯塔克工业推进器和人工智能太阳镜。</p><p id="4832" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">结论</strong></p><p id="05c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Ruby为程序员提供了面向对象语言中所有的基本功能。然后，Ruby通过它的一些高级特性，如进程、模块和混合，增加了灵活性、可扩展性和模块化。这些特性通过提供额外的工具来增强程序员坚持设计理念的能力，从而完善了Ruby的使用。</p><p id="1ab9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">参考书目</strong></p><ul class=""><li id="d182" class="kk kl ht is b it iu ix iy jb km jf kn jj ko jn kp kq kr ks bi translated"><a class="ae kh" href="https://ruby-doc.org/core-2.6/Proc.html" rel="noopener ugc nofollow" target="_blank">https://ruby-doc.org/core-2.6/Proc.html</a></li><li id="bb45" class="kk kl ht is b it kt ix ku jb kv jf kw jj kx jn kp kq kr ks bi translated"><a class="ae kh" href="https://ruby-doc.org/core-2.6/Module.html" rel="noopener ugc nofollow" target="_blank">https://ruby-doc.org/core-2.6/Module.html</a></li><li id="e08a" class="kk kl ht is b it kt ix ku jb kv jf kw jj kx jn kp kq kr ks bi translated"><a class="ae kh" href="https://resources.saylor.org/wwwresources/archived/site/wp-content/uploads/2013/02/CS101-2.1.2-AdvantagesDisadvantagesOfOOP-FINAL.pdf" rel="noopener ugc nofollow" target="_blank">https://resources . say lor . org/www resources/archived/site/WP-content/uploads/2013/02/cs 101-2 . 1 . 2-advantages ofoop-final . pdf</a></li><li id="2ab1" class="kk kl ht is b it kt ix ku jb kv jf kw jj kx jn kp kq kr ks bi translated"><a class="ae kh" href="https://launchschool.com/books/oo_ruby/read/inheritance" rel="noopener ugc nofollow" target="_blank">https://launchschool.com/books/oo_ruby/read/inheritance</a></li><li id="a7c4" class="kk kl ht is b it kt ix ku jb kv jf kw jj kx jn kp kq kr ks bi translated"><a class="ae kh" href="http://rubylearning.com/satishtalim/ruby_inheritance.html" rel="noopener ugc nofollow" target="_blank">http://rubylearning.com/satishtalim/ruby_inheritance.html</a></li></ul></div></div>    
</body>
</html>