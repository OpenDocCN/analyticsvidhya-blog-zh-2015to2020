<html>
<head>
<title>Time and Space Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间和空间复杂性</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-and-space-complexity-3b8016c0f3ae?source=collection_archive---------17-----------------------#2020-11-05">https://medium.com/analytics-vidhya/time-and-space-complexity-3b8016c0f3ae?source=collection_archive---------17-----------------------#2020-11-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c65c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是时间复杂度？</strong></p><p id="e7b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过观察运行时间如何根据输入增长，时间复杂度可以用来确定我们的算法是否能够在要求的时间内运行。我们不以秒来衡量运行时间，因为它取决于我们不想考虑的各种因素。我们对大量输入的算法行为感兴趣。</p><p id="7778" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们如何测量时间复杂性？</strong></p><p id="959f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Big-O符号给出了算法时间复杂度的上限。</p><p id="2d7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个函数T(n ),它给出了一个算法的运行时间，其中n是输入的数量。如果我们能找到一个函数f(n ),当它乘以c时大于T(n ),那么我们可以说f(n)是T(n)的上界。</p><p id="17e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在数学上可以表示为T(n) &lt;= c * f(n). And we write it as O(f(n)).</p><p id="bc0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何计算大O </strong></p><p id="1d5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">I)将你的算法分解成单独的操作。<br/> ii)计算每个操作重复的次数。<br/> iii)把所有东西加在一起。<br/> iv)去掉常数的倍数。<br/> v)去掉低阶项。</p><p id="16a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们去掉了所有的常数倍数和低阶项，因为它们对输入的大值贡献不大。我们将在下面的例子中看到这些步骤。</p><p id="13a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">有哪些不同的时间复杂度？</strong></p><p id="b265" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。恒定时间</strong></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="ed71" class="jm jn hi ji b fi jo jp l jq jr">int average(int a, int b) { <br/>   int avg = (a+b)/2; // occurs once <br/>   return avg; // occurs once }</span></pre><p id="46c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将所有值相加后，我们得到:<br/> 1 + 1 = 2</p><p id="55d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个函数中，每一步都出现一次，所以在将所有步骤相加之后，我们得到2。可以写成O(1 ),因为我们会去掉所有的常数倍数。</p><p id="a60f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，随着输入的增加，算法所用的时间保持不变。</p><p id="e159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。线性时间</strong></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="23cc" class="jm jn hi ji b fi jo jp l jq jr">int find(int arr[], int key) {<br/>    int n = sizeof(arr);         // 1<br/>    for(int i = 0; i &lt; n; i++) { // n<br/>        if(arr[i] == key)        // 1<br/>            return i;            // 1<br/>    }<br/>    return -1;                   // 1<br/>}</span></pre><p id="fff7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将所有值相加后，我们得到:<br/> 1 + n * (1 + 1)+1 <br/> = 2 + 2n</p><p id="e4a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将for循环中的值(即1 + 1)乘以循环发生的次数(即n ),因为for循环中的步骤将重复n次。</p><p id="a20a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">去掉低阶项2，我们得到2n。那我们就把常数乘以2。所以时间复杂度由O(n)给出。</p><p id="92ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，随着输入的增加，算法所用的时间线性增加。</p><p id="c4de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。二次时间</strong></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="4c96" class="jm jn hi ji b fi jo jp l jq jr">int findDuplicates(int array[]) {<br/>    int n = sizeof(array);                        // 1<br/>    for (int i = 0; i &lt; n; i++){                  // n<br/>        for (int j = 0; j &lt; n; j++){              // n<br/>            if (i !==j &amp;&amp; array[i] == array[j]){  // 1<br/>                return i;                         // 1<br/>            }<br/>        }<br/>    }<br/>    return -1;                                    // 1<br/>}</span></pre><p id="a087" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将所有值相加后我们得到:<br/>1+n *(n *(1+1))+1<br/>= 2+2n^2</p><p id="eac8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">去掉低阶项和常数倍数，我们得到O(n^2).</p><p id="e22b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，随着输入的增加，算法所用的时间以二次方式增加。</p><p id="a3ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。对数时间</strong></p><p id="6321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">日志被写成日志ₓ y</p><p id="7081" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对数₂ 8 = 3 <br/>你可以把它想成我们把多少个2相乘得到8。答案是3。</p><p id="9999" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们来看看二分搜索法。该算法的运行方式类似于我们在字典中搜索单词的方式。假设我们在中间的某个地方打开字典。如果我们要找的单词在左半部分，我们忽略右半部分，然后再把左半部分分成两半。</p><p id="8293" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们继续这样做，我们最终会找到我们要找的单词，因为字典里的单词是按字母顺序排列的。类似地，如果我们有一个排序的数组，我们想寻找一个值x，我们可以应用二分搜索法。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="30fa" class="jm jn hi ji b fi jo jp l jq jr">int binarySearch(int arr[], int x) {<br/><br/>    int l = 0;<br/>    int h = sizeof(arr)-1;<br/><br/>    while (r &gt;= l) {<br/>        int mid = l + (r - l) / 2;<br/><br/>        // If the element is present at the<br/>            // middle itself<br/>            if (arr[mid] == x)<br/>            return mid;<br/><br/>            // If element is smaller than mid, then<br/>            // it can only be present in left subarray<br/>            if (arr[mid] &gt; x)<br/>        h = mid - 1;<br/><br/>            // Else the element can only be present<br/>            // in right subarray<br/>    	if (arr[mid]&lt;)x<br/>    		l = mid + 1;<br/>    }<br/><br/>    // We reach here when element is not present<br/>    // in array<br/>    return -1;<br/>}</span></pre><p id="ff76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种算法中，我们必须处理的数据量随着每次迭代减少了一半。</p><p id="277a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">n/2，n/4，n/8 …</p><p id="1f75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在最坏的情况下，我们将在最后一次迭代中找到元素，也就是说，我们继续划分，直到只剩下一个元素。</p><p id="67f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在数学上可以用n/n = 1来表示。分母可以用2的幂来表示，因为我们每次迭代都要除以2。</p><p id="0e17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此我们可以把它写成n/2^k = 1，其中k是我们除以2的次数。∴ n = 2^k</p><p id="b4d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为k是我们除以2的次数，所以k将给出在最坏情况下得到该数所需的迭代次数。方程n = 2^k可以写成k =对数₂(n).因此时间复杂度为O(log n)。</p><p id="8fc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，随着输入的增加，算法所用的时间以对数方式增加。</p><p id="60f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果循环变量除以或乘以一个常数，则循环的时间复杂度被认为是O(logn)。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="bf40" class="jm jn hi ji b fi jo jp l jq jr">for (int i = 1; i &lt;=n; i *= c) {<br/>    // some O(1) expressions<br/>}<br/>for (int i = n; i &gt; 0; i /= c) {<br/>    // some O(1) expressions<br/>}</span></pre><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es js"><img src="../Images/326ced52d4fe900917450c9a81fac0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*q5V7GqQlqVOIsZsX.png"/></div></figure><p id="eb51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们可以看到我们上面讨论的不同时间复杂性，以及它们之间的相互比较。O(1)最快，O(n 2)最慢。</p><p id="addc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有其他的时间复杂度，比如O(nlog n)，O(c n)，O(n！)我们将在以后的帖子中讨论这个问题。在那之前，你可以<a class="ae jw" href="https://tinyletter.com/rohitdhatrak" rel="noopener ugc nofollow" target="_blank">注册</a>来获得新帖子的通知。</p><p id="161f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要注意的一个有趣的事情是，对于较小的值，O(log n)比O(n)慢。但是我们并不真正关心小值，当输入很大时，我们检查算法的行为。</p><p id="f756" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是空间复杂性？</strong></p><p id="8191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它与时间复杂度相同，但我们不是看我们的算法随着输入的增长花费了多少时间，而是看我们的算法随着输入的增长消耗了多少空间。</p><p id="83a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们经常优化时间而不是空间，因为通常空间不是问题，但我们希望我们的算法更快。然而，在像使用嵌入式系统这样内存有限的场景中，空间复杂度变得同样重要。</p><p id="092e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这个帖子，或者有任何问题/建议，请随时在任何社交媒体平台上联系。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="e4d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ke">原发布于</em><a class="ae jw" href="https://rohitdhatrak.netlify.app/time-space-complexity/" rel="noopener ugc nofollow" target="_blank"><em class="ke">https://rohitdhatrak . netlify . app</em></a><em class="ke">。</em></p></div></div>    
</body>
</html>