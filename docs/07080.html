<html>
<head>
<title>MNIST Handwritten Digit Recognition using multi-layer neural network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于多层神经网络的MNIST手写数字识别</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/mnist-handwritten-digit-recognition-using-neural-network-2b729bacb0d5?source=collection_archive---------6-----------------------#2020-06-13">https://medium.com/analytics-vidhya/mnist-handwritten-digit-recognition-using-neural-network-2b729bacb0d5?source=collection_archive---------6-----------------------#2020-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a87a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">人类视觉系统是世界的奇迹。人们很容易识别数字。但这并不像看起来那么简单。人类大脑有一百万个神经元和数十亿个神经元之间的连接，这使得这种异常复杂的图像处理任务变得更加容易。人们可以毫不费力地识别数字。</p><p id="d629" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，对于计算机来说，识别数字是一项具有挑战性的任务。关于如何识别数字的简单直觉变得难以用算法表达。此外，不同的人在写作上有很大的差异，这使得写作变得非常复杂。</p><p id="8949" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">手写数字识别系统</strong>是一台机器进行自我训练的工作，以便它能够识别来自不同来源的数字，如电子邮件、银行支票、文件、图像等。</p><h2 id="6fe4" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Google Colab</h2><p id="3bf0" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">Google Colab已经被用来实现网络。这是一个免费的云服务，可用于使用Keras、TensorFlow、PyTorch和OpenCV等流行的库开发深度学习应用程序。Colab区别于其他免费云服务的最重要的特点是；它提供GPU，而且完全免费。因此，如果PC与硬件要求不兼容或不支持GPU，那么它是最佳选择，因为稳定的互联网连接是唯一的要求。</p><h1 id="9dfa" class="kd je hi bd jf ke kf kg jj kh ki kj jn kk kl km jq kn ko kp jt kq kr ks jw kt bi translated">MNIST数据集</h1><p id="5340" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">MNIST代表“修改后的国家标准与技术研究所”。这是一个包含70，000张手写图像的数据集。每个图像是28×28像素，即大约784个特征。每个特征只代表一个像素的强度，即<strong class="ih hj">。从0(白色)到255(黑色)。</strong>该数据库进一步分为60，000幅训练图像和10，000幅测试图像。</p><h1 id="7c97" class="kd je hi bd jf ke kf kg jj kh ki kj jn kk kl km jq kn ko kp jt kq kr ks jw kt bi translated">实施阶段</h1><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ku"><img src="../Images/5e8af19ef2583f145aea01d3543bda14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*7u2x1tcLEWNU7Y825dDGyA.jpeg"/></div></figure><h2 id="5e59" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">导入库</h2><p id="c746" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">首先，我们导入了我们将要使用的所有库。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lc"><img src="../Images/2341e37832afd5ba07ff10c29dd97070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*bLIhHTeRqfg9r0mDcwhR3A.jpeg"/></div></figure><p id="1c24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们导入了<strong class="ih hj"> TensorFlow </strong>，这是一个<em class="ld">开源免费库</em>，用于机器学习应用，如神经网络等。此外，我们从用于<em class="ld">可视化</em>目的的<strong class="ih hj"> matplotlib </strong>库中导入了<strong class="ih hj"> pyplot </strong>函数，该函数主要用于<em class="ld">绘图。之后，我们引入了<strong class="ih hj"> NumPy </strong>即数值Python，用于<em class="ld">执行各种数学运算。</em></em></p><h2 id="e91b" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><em class="le">加载数据集</em></h2><p id="41ab" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">Keras库已经包含一些数据集，如CIFAR10、CIFAR100、波士顿房价回归数据集、IMDB电影评论情感分类数据集等。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lf"><img src="../Images/e461d78ec08373b57ae329583c20b472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*hLjXQ59Qj377YSLYCtaOXQ.jpeg"/></div></figure><p id="9658" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MNIST数据集也是其中的一部分。所以，我们从<em class="ld"> keras.datasets </em>中导入它，并将其加载到变量“objects”<em class="ld">中。</em><em class="ld">objects . load _ data()</em>方法返回训练数据(train_img)、其标签(train_lab)以及测试数据(test_img)及其标签(test_lab)。在数据集中提供的70，000幅图像中，60，000幅用于训练，10，000幅用于测试。</p><p id="ecc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在预处理数据之前，我们首先在循环的<em class="ld">的帮助下显示了训练集的前20幅图像。</em></p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lg"><img src="../Images/c23c80b8293c2f3ec66da9583b87eb33.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*jeh07XLCtEx73dlHDCNeKA.jpeg"/></div></figure><p id="41e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> subplot() </strong>用于给当前图形添加一个subplot或网格状结构。第一个参数用于“<em class="ld">行数”，</em>第二个参数用于“<em class="ld">列数”</em>，第三个参数用于网格中的位置索引。</p><p id="35df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们必须从网格中的第二个位置开始，在4x5网格中绘制10幅图像。然后，它会像</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lh"><img src="../Images/8ad900dcde4b9eb6e68d7fc52336e6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*aMj1lOPNgpDj2FvyPnfUcg.jpeg"/></div></figure><p id="5bc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> imshow() </strong>用于将数据显示为图像，即训练图像(train_img[i])，而<strong class="ih hj"> cmap </strong>代表彩色地图。<em class="ld"> Cmap </em>是可选功能。基本上，如果图像在shape (M，N)的数组中，那么<strong class="ih hj"> cmap </strong>控制用来显示值的颜色图。cmap='gray '将图像显示为灰度，而cmap='gray_r '用于将图像显示为反灰度。</p><p id="31c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> title() </strong>为每幅图像设置标题。我们已经将“Digit: train_lab[i]”设置为子情节中每个图像的标题。</p><p id="34aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">支线剧情_adjust() </strong>用于调谐支线剧情布局。为了改变两行之间提供的空间，我们使用了<strong class="ih hj"> hspace。如果你想改变两列之间的间距，你可以使用wspace。</strong></p><p id="7b43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，子情节布局的参数是，</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es li"><img src="../Images/2e29e57afc0743e6fe45f3cf35668b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*-xBFdXGwzBGR3aBfm_zq9A.jpeg"/></div></figure><p id="5af7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了隐藏图像的轴，使用了<strong class="ih hj">PLT . axis(‘off’)</strong>。</p><p id="ed6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们展示了培训和测试部分的形状。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lj"><img src="../Images/a06047fb735d20821e8f451c8039d189.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*H575WOe8fP7X_478xlICiQ.jpeg"/></div></figure><p id="c29a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> (60000，28，28) </strong>表示训练集中有60000幅图像，每幅图像的大小为28×28像素。类似地，在测试集中有10，000个相同大小的图像。</p><p id="f542" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，每个图像的大小为28×28，即784个特征，每个特征表示从0到255的每个像素的强度。</p><p id="2f85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用<strong class="ih hj"><em class="ld">print(train _ img[0])</em></strong>以28x28的矩阵形式打印第一张训练集图像。</p><p id="e751" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在直方图上绘制了第一幅训练图像。正常化之前，</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lk"><img src="../Images/5fd28e979e4daf4b573bec1c0d73d03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*O0X-_PIu2bLrDjlvhJVYkQ.jpeg"/></div></figure><p id="e169" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> hist() </strong>用于绘制第一幅训练图像的直方图，即train_img[0]。<strong class="ih hj"> </strong>图像被重新塑造成一个大小为784的一维数组。<strong class="ih hj"> facecolor </strong>是一个可选参数，指定直方图的颜色。直方图的标题，Y轴和X轴被命名为“像素与其强度”、“像素”和“强度”。</p><h2 id="b788" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">预处理数据</h2><p id="aaee" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在将数据输入网络之前，我们将对其进行归一化处理。标准化输入数据有助于加快训练速度。此外，它减少了陷入局部最优的机会，因为我们使用<a class="ae ll" href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent" rel="noopener ugc nofollow" target="_blank">随机梯度下降</a>来寻找网络的最优权重。</p><p id="525d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像素值介于0和255之间。因此，当使用神经网络模型时，输入值的缩放是很好的，因为缩放是众所周知的并且表现良好，我们可以通过将每个值除以最大强度255来非常快速地将像素值归一化到范围0和1。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lm"><img src="../Images/d95e590b646184598e72ea85f3562092.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*y_5QFFtZkxqyGnMTqW0D1Q.jpeg"/></div></figure><p id="1d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正常化后，</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ln"><img src="../Images/062c74893601b798a59b46bfb936e658.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*0OH1-GdNNJ2XhuVX1xHCnQ.jpeg"/></div></figure><h2 id="986d" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">创建模型</h2><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lo"><img src="../Images/7f4aeb9cef3776e9fe45352c031c6ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*E6X3ibVkU8U84k8czHXrCA.jpeg"/></div></div></figure><p id="d4df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Keras中创建模型有三种方式:</p><ul class=""><li id="a8c6" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated"><strong class="ih hj"> <em class="ld">时序模型</em> </strong>非常直观简单。它允许逐层建立模型。</li><li id="78af" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj"><em class="ld">Functional API</em></strong>是一个易于使用、功能全面的API，支持任意模型架构。这就是Keras的“行业实力”模型。</li><li id="0994" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj"> <em class="ld">模型子类</em> </strong>你可以自己从头开始实现所有的东西。</li></ul><p id="2d2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们使用了<strong class="ih hj"> <em class="ld">时序模型</em> </strong>。该模型有一个输入层、一个输出层和两个隐藏层。</p><p id="0c70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Sequential() </strong>用于按顺序创建一层网络。</p><p id="5a9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">。这里使用add() </strong>将图层添加到模型中。</p><p id="14e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一层(输入层)，我们输入图像。由于每个图像的大小为28x28，因此我们使用了<strong class="ih hj"> <em class="ld"> Flatten() </em> </strong>来压缩输入。</p><p id="6ec0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在其他图层<strong class="ih hj"> <em class="ld">中使用了<strong class="ih hj"><em class="ld"/></strong>。</em> </strong>它保证上一层的每一个神经元都与下一层的每一个神经元相连。</p><p id="4a87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该模型是一个简单的神经网络，具有两个带有512个神经元的隐藏层。一个整流器线性单元激活<strong class="ih hj"> (ReLU) </strong>函数用于隐藏层中的神经元。最棒的是它的梯度总是等于1，这样我们可以在反向传播过程中通过网络传递最大的误差。</p><p id="ea34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出层有10个神经元，即从0到9的每一类。在输出层使用了一个<strong class="ih hj"> softmax激活函数</strong>,将输出转化为类似概率的值。</p><p id="c5f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ld">注意:你可以在隐藏层中添加更多的神经元。你甚至可以增加模型中隐藏层的数量来提高效率。不过训练的时候会花更多的时间。</em></p><h2 id="b25c" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">编译网络</h2><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mh"><img src="../Images/fa9b2439dcc9a7062831e02762094185.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*d5L6r3t0MGN7cE8Yq36WCQ.jpeg"/></div></div></figure><p id="7ec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要编译我们的模型。编译模型需要三个参数:优化器、损失和指标。优化器控制学习速率。我们使用<strong class="ih hj">【亚当】</strong>作为我们的优化器。在许多情况下，它通常是一个很好的优化器。它可以在整个训练过程中调整学习速度。</p><p id="d447" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用<strong class="ih hj">‘Sparse _ category _ cross entropy’</strong>作为我们的损失函数，因为它节省了内存和计算的时间，因为它只是对一个类使用单个整数，而不是整个向量。分数越低，表示模型的性能越好。</p><p id="92c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了确定准确性，我们将在训练模型时使用<strong class="ih hj">“准确性”指标</strong>来查看验证集的准确性得分。</p><h2 id="606e" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">训练模型</h2><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mi"><img src="../Images/3a0dfc413a89fa8fc7273e8da54e7c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*24Z-MM6GF20a0hbAHzxHfg.jpeg"/></div></figure><p id="fa16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将借助<strong class="ih hj"> fit() </strong>函数对模型进行训练。它将具有作为训练数据(train_img)、训练标签(train_lab)和时期数的参数。历元数是模型在数据中循环的次数。在一定程度上，我们运行的时代越多，模型就会改进得越多。此后，模型将在每个时期停止改进。</p><p id="50b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将模型保存为<strong class="ih hj"> project.h5 </strong></p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mj"><img src="../Images/4f8eef6e09a8a53ce4b2e95681c9d154.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*K_-hemYaIMp43c6Qs1GjLg.jpeg"/></div></figure><h2 id="c2be" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">评估模型</h2><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mk"><img src="../Images/cdbc55ca789f7360af4b23b79b3fceba.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*yvRigOnFvXlspcHY0AQCBQ.jpeg"/></div></figure><p id="4afc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> model.evaluate() </strong>方法<em class="ld">在编译模型时计算损失和任何定义的度量</em>。因此，在我们的例子中，精度是使用由保存的模型给出的网络权重在10，000个测试示例上计算的。<br/> Verbose可以是0、1或2。默认情况下，verbose为1。<br/> verbose = 0，表示无声。<br/> verbose = 1，包括进度条和每个时期一行。<br/> verbose = 2，每个纪元一行，即纪元编号/纪元总数。</p><p id="f1e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在评估了模型之后，我们现在将检查测试部分的模型。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ml"><img src="../Images/633f2e6b80257c9804214cb873769c80.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*EWPI6eE2S4d_34VFsD3mBQ.jpeg"/></div></figure><p id="86bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> model.predict() </strong>用于对测试集进行预测。</p><p id="d234" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> np.argmax() </strong>返回轴上最大值的索引。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mm"><img src="../Images/94b8ac5a546db1a1379e2743e6eda3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*R0M0lwjgrnLxb1NMAC_PVg.jpeg"/></div><figcaption class="mn mo et er es mp mq bd b be z dx translated">图片来自谷歌图片</figcaption></figure><p id="590f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了对不属于MNIST数据集的新图像进行预测。我们将首先创建一个名为“<em class="ld"> load_image </em>”的函数。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mr"><img src="../Images/aded3851c9bde9cb6a971676006956dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*CkJ2VSbEsEKhuUfHcpldoQ.jpeg"/></div></figure><p id="5d20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述函数将图像转换为像素数组，作为输入提供给模型。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ms"><img src="../Images/31b8503cb5578a9c0f652274f167110c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*ipjiGad6gH3dms4qDrxuiQ.jpeg"/></div></figure><p id="e478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了从本地驱动器上传文件，我们使用了代码:</p><p id="f3a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ld">从google.colab导入文件<br/>uploaded = files . upload()</em></p><p id="5061" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它将引导您选择一个文件。点击<strong class="ih hj">选择文件</strong>，然后选择并上传文件，等待文件100%上传。一旦Colab上传了这个文件，你就会看到它的名字。</p><p id="bacd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了显示图像文件，我们使用了代码:</p><p id="25df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ld">来自IPython。显示导入图像Image('5img.jpeg '，宽度=250，高度=250) </em></p><p id="524d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【5img.jpeg T4】是文件名。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mt"><img src="../Images/96613a7bd1c03a08778256f316883cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4eiBKm7GnLreibfv3LQrw.jpeg"/></div></div></figure><p id="583a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，我们已经成功地预测到值为5。</p><p id="1037" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们想在几天后运行模型，我们将不得不再次运行整个代码，这是非常耗时的。</p><p id="e6b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，您可以使用保存的模型，即<strong class="ih hj"> project.h5 </strong></p><p id="6555" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在关闭colab笔记本之前，您可以从文件夹符号中下载模型。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mu"><img src="../Images/9e95dc2a44e98eedb97c620242774434.png" data-original-src="https://miro.medium.com/v2/resize:fit:192/format:webp/1*4YfZ6QNevUde6vy-PvrP6g.jpeg"/></div><figcaption class="mn mo et er es mp mq bd b be z dx translated">突出显示的文件夹</figcaption></figure><p id="f822" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，当您尝试再次运行该模型时，您所要做的就是使用以下代码从计算机上传project.h5文件:</p><p id="6658" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ld">从google.colab导入文件<br/> uploaded = files.upload() </em></p><p id="1ce0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当文件100%上传时，使用下面的代码&amp;之后，您可以预测新图像的数字，而无需运行整个代码。</p><p id="b8c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ld">model = TF . keras . models . load _ model(' project . H5 ')</em></p><p id="8621" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ld">链接供参考</em></strong><a class="ae ll" href="https://colab.research.google.com/drive/10LzhqSlJx4bnCNT6C8llhuXTDuh_WQPG?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/10 lzhqsljx 4 bn CNT 6 c8 llhuxtduh _ WQPG？usp =共享</a></p><p id="8767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>