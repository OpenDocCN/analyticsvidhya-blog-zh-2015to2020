# 熊猫教程 II —过滤数据帧

> 原文：<https://medium.com/analytics-vidhya/pandas-tutorial-ii-filtering-dataframes-7e430a196336?source=collection_archive---------17----------------------->

![](img/3a45906c3d010e9e263c94503a316a04.png)

过滤是用于选择数据帧部分的更通用的工具。与传统的切片或索引不同，过滤不基于标签或位置。在过滤中，基于数据本身的感兴趣的属性来选择数据帧的部分。

使用 Pandas 库，有几种特殊的过滤方法。我很快会谈到其中的一些。

在这篇教程文章中，我将使用与上一篇文章中相同的“销售”数据集。这是某一年 1 月至 6 月当地商店出售的鸡蛋、盐和鱼的数量数据。

我会加载数据，然后我们用它弄脏我们的手。

```
In [1]: import pandas as pd
In [2]: df = pd.read_csv('sales.csv', index_col='month')
In [3]: df
Out[3]:            eggs    salt    fish
        month
        Jan          47     12.0    17
        Feb         110     50.0    31
        Mar         221     89.0    72
        Apr          77     87.0    20
        May         132      NaN    52
        Jun         205     60.0    55
```

## 布尔级数

过滤数据帧的几种方法之一是使用布尔级数。使用布尔值从一个系列或一个数据帧中进行选择是非常强大的。

**布尔**指的是一个逻辑思维系统，用来创建真或假的语句。一个**布尔**值表示一个真值。**布尔**表达式使用运算符`AND`、`OR`和`NOT`来比较值并返回 true 或 false 结果。

```
In [4]: df.salt>60
Out[4]: False
        False
        True
        True
        False
        False
```

在这里，我们问的是盐这一栏中销售额超过 60 的地方。销售额超过 60 的月份返回 True，其他月份返回 False。

除此之外，布尔数组还可以用于从一个系列或一个数据帧中进行选择。

```
In [5]: df[df.salt>60]
Out[5]:       eggs     salt    fish
       month  
       Mar    221      89.0     72
       Apr     77      87.0     20
```

这将返回盐销售额高于 60 的所有列和月份。

当用于进行选择时，布尔序列称为过滤器。

## ***组合滤镜***

在组合过滤器时，我们可以使用`AND`操作符或`OR`操作符。&符号`&`用于表示`AND`操作符，而一个简单的竖线`|`表示`OR`操作符。

在两个布尔序列都满足的条件下,`AND`运算符返回一个结果。

```
In [6]: df[(df.salt>=50)&(df.eggs<200)]
Out[6]:         egg   salt   fish
       month                           
       Feb      110   50.0     31 
       Apr       77   87.0     20
```

这将返回一个数据框架，其中盐的销售额至少为 50，而鸡蛋的销售额低于 200。例如，6 月份的盐销售额超过 50，鸡蛋销售额超过 200，但是第二个条件被忽略，所以 6 月份的数据没有返回。要返回结果，这两个条件都必须为真。

`OR`操作符需要至少满足任一方的一个条件才能返回结果。

```
In [7]: df[(df.salt>=50)|(df.eggs<200)]
Out[7]:            eggs    salt    fish
        month
        Jan          47     12.0    17
        Feb         110     50.0    31
        Mar         221     89.0    72
        Apr          77     87.0    20
        May         132      NaN    52
        Jun         205     60.0    55
```

返回所有月份和列，因为它们都至少满足一个布尔序列条件。要返回结果，这两个条件中的任何一个都必须为真。

## 带有零和 nan 的数据帧

我将使用熊猫复制原始数据帧`df`。`copy()`方法。然后，我将继续添加另一列，并在零和 NaNs 上工作。稍后我们将回到原始数据帧

```
In  [8]: df2=df.copy()
In  [9]: df2['bacon']=[0,0,50,60,70,80]
In [10]: df2
Out[10]:          eggs    salt    fish   bacon
        month
        Jan          47     12.0    17     0
        Feb         110     50.0    31     0
        Mar         221     89.0    72    50
        Apr          77     87.0    20    60
        May         132      NaN    52    70
        Jun         205     60.0    55    80
```

现在让我们来探索如何处理零和 NaNs

*   我们可能会问哪些月份的值都不为零

```
In [11]: df2.loc[:,df2.all()]
Out[11]:            eggs    salt    fish
        month
        Jan          47     12.0    17
        Feb         110     50.0    31
        Mar         221     89.0    72
        Apr          77     87.0    20
        May         132      NaN    52
        Jun         205     60.0    55
```

*   我们可能还想检查哪些月份有非零值

```
In [12]: df2.loc[:,df2.any()]
Out[12]:          eggs    salt    fish   bacon
        month
        Jan          47     12.0    17     0
        Feb         110     50.0    31     0
        Mar         221     89.0    72    50
        Apr          77     87.0    20    60
        May         132      NaN    52    70
        Jun         205     60.0    55    80
```

*   我们可能还想检查哪些行和列有 NaN

```
In [13]: df.loc[:,df.isnull().any()]
Out[13]:        salt
        month   
          Jan   12.0 
          Feb   50.0
          Mar   89.0 
          Apr   87.0
          May    NaN
          Jun   60.0
```

*   所有条目显示的所有列

```
In [14]: df.loc[:, df.notnull().all()]
Out[14]:          eggs       fish   
        month
        Jan          47       17     
        Feb         110       31     
        Mar         221       72   
        Apr          77       20   
        May         132       52   
        Jun         205       55 
```

*   删除带有任何 NaNs 的行

```
In [15]: df2.dropna(how='any']
Out[15]:          eggs    salt    fish   bacon
        month
        Jan          47     12.0    17     0
        Feb         110     50.0    31     0
        Mar         221     89.0    72    50
        Apr          77     87.0    20    60
        Jun         205     60.0    55    80
```

五月已经被放弃了。这是因为 5 月份的盐销售额缺失。`how='any'`将确保删除任何缺少值的行。另一种方法是`how='all'`，这将保留所有行，即使只有一个非缺失的列条目。这会将五月的行保留在数据帧中。

## 基于另一列筛选一列

可以基于另一列的过滤器来过滤数据帧的一列。

```
In [16]: df.eggs[df.salt>55]
out[16]: month
         Mar      221
         Apr       77
         Jun      205
```

在这里，我过滤了盐的销售额高于 55 的月份的鸡蛋销售额。它返回了 3 月、4 月和 6 月的鸡蛋销售额。它可以复制到数据的任何部分。您所需要做的就是指定感兴趣的列和您想要取出的列的过滤器。

## 基于另一列修改列

我们还可以基于另一列的过滤器来修改一列。

```
In [17]: df.eggs[df.salt>55]+=5
In [18]: df
Out[10]:          eggs    salt    fish  
        month
        Jan          47     12.0    17     
        Feb         110     50.0    31     
        Mar         225     89.0    72   
        Apr          82     87.0    20   
        May         132      NaN    52    
        Jun         210     60.0    55 
```

上面的代码过滤了盐销售额大于 55 的月份的鸡蛋销售额，并在这些月份的鸡蛋销售额中增加了 5。在返回的新数据框架中，三月、四月和六月的鸡蛋销售额增加了 5 英镑。

可能有一个促销活动，如果盐的销量超过 55，就额外增加 5 个鸡蛋。每个人都喜欢偶尔的升职，不是吗？熊猫在这方面为我们提供了保障。

好了，这就是本教程的全部内容。有很多东西需要咀嚼和消化。这需要一点时间和一些练习。

请投入一些工作，你会好起来的。下次见，编码快乐！