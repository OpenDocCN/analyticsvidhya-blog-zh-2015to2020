<html>
<head>
<title>Covariant, Contravariant, Invariant: what for and how?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">共变，逆变，不变:为什么和如何？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/covariant-contravariant-invariant-what-for-and-how-3df4175c4d91?source=collection_archive---------16-----------------------#2020-05-04">https://medium.com/analytics-vidhya/covariant-contravariant-invariant-what-for-and-how-3df4175c4d91?source=collection_archive---------16-----------------------#2020-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/966051fdcdd87f73b061e1c518788f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVGb_AZpYYJKWA77V1Buag.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来自unsplash.com</figcaption></figure><p id="773e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi js translated">今天有许多编程语言，它们有静态类型检查、强类型系统和类型推理。这种工具允许开发人员添加额外的验证，避免编译或代码分析阶段的错误。在编程语言中，支持这些的有<a class="ae kb" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> Haskell </a>、<a class="ae kb" href="https://fsharp.org/" rel="noopener ugc nofollow" target="_blank"> F# </a>、<a class="ae kb" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>(可选)等。类型检查的基础是类型的<strong class="iw hj">协方差</strong>、<strong class="iw hj">逆变</strong>和<strong class="iw hj">不变性</strong>的概念。在某些情况下，如下所示，这不是微不足道的，除了违反直觉。让我们来看一下这些案例，并理解为什么它们是这样设计的。</p><h1 id="2612" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">这是什么？</h1><p id="a5a7" class="pw-post-body-paragraph iu iv hi iw b ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr hb bi translated">首先，我们来定义一个类型之间的关系。当你说“<em class="lf"> type1 </em>是<em class="lf"> type2 </em>的<em class="lf">子类型</em>时，这意味着<em class="lf"> type1 </em>包含了<em class="lf"> type2 </em>所有可能值的子集。简而言之，我们来介绍一下运算符<strong class="iw hj"> &lt; </strong>。如果<em class="lf">类型1 </em>是<em class="lf">类型2 </em>的子类型，那么表达式<strong class="iw hj">类型1 &lt;类型2 </strong>为<strong class="iw hj">真</strong>。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8d96" class="lp kd hi ll b fi lq lr l ls lt">/*pseudo code*/</span><span id="4cf6" class="lp kd hi ll b fi lu lr l ls lt">Type int<br/>Type float</span><span id="a411" class="lp kd hi ll b fi lu lr l ls lt">// true, integer is a subtype of float<br/>assert int &lt; float</span><span id="44dd" class="lp kd hi ll b fi lu lr l ls lt">// false<br/>assert float &lt; int</span></pre><p id="628f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">大多数更好的类型表达式的编程语言都有<strong class="iw hj">泛型类型</strong>(你好，<a class="ae kb" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>)。<strong class="iw hj">通用类型</strong>是类型，你可以在其中指定内部类型。使用<strong class="iw hj">类属</strong>的常见情况是容器，如<em class="lf">列表</em>、<em class="lf">集合</em>等。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="57dd" class="lp kd hi ll b fi lq lr l ls lt">/*pseudo code*/</span><span id="0453" class="lp kd hi ll b fi lu lr l ls lt">Type List[T]<br/>Type Set[T]<br/>Type int<br/>Type str</span><span id="f421" class="lp kd hi ll b fi lu lr l ls lt">// all elements in List should have type int<br/>Type IntList = List[int]</span><span id="4f7d" class="lp kd hi ll b fi lu lr l ls lt">// all elements in Set should have type str<br/>Type StrSet = Set[str]</span></pre><p id="05cb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">函数是函数式语言中的第一类公民，你也可以定义一种类型的函数作为参数传递给另一个函数或从该函数返回。此函数类型被描述为<strong class="iw hj">通用类型，</strong>因为它可以有许多类型作为输入，也可以有许多类型作为输出。让我们定义函数类型<strong class="iw hj">可调用</strong>如下</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="7f6d" class="lp kd hi ll b fi lq lr l ls lt">/*pseudo code*/</span><span id="b49d" class="lp kd hi ll b fi lu lr l ls lt">Callable[[&lt;argument-types&gt;,...], &lt;return-type&gt;]</span><span id="29f5" class="lp kd hi ll b fi lu lr l ls lt">// function that has one int parameter and return float Callable[[int], float]</span><span id="6816" class="lp kd hi ll b fi lu lr l ls lt">// function that has two int parameters and return float Callable[[int, int], float]</span></pre><p id="9ee9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当你面对<strong class="iw hj">泛型</strong>时，<em class="lf">子类</em>会发生什么？如果<em class="lf">List【int】</em>还是<em class="lf">List【float】</em>的子类型？还是<em class="lf"> List[float] </em>成为<em class="lf"> List[int] </em>的子类型？这就是<strong class="iw hj">协方差</strong>、<strong class="iw hj">逆变</strong>、<strong class="iw hj">不变性</strong>的概念。我们来声明两种类型:<em class="lf"> type1 </em>和<em class="lf"> type2 </em>，而<em class="lf"> type2 </em>是<em class="lf"> type1 </em>的一个子类型</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="bca4" class="lp kd hi ll b fi lq lr l ls lt">/*pseudo code*/</span><span id="2e2b" class="lp kd hi ll b fi lu lr l ls lt">Type type1<br/>Type type2</span><span id="eefa" class="lp kd hi ll b fi lu lr l ls lt">assert type2 &lt; type1 // true</span></pre><p id="a4ae" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后泛型类型<em class="lf"> GenericType </em>被调用:</p><ul class=""><li id="c7d0" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><strong class="iw hj">协变</strong>，如果<em class="lf"> GenericType[type1] </em>是<em class="lf"> GenericType[type2] </em>的子类型</li></ul><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f637" class="lp kd hi ll b fi lq lr l ls lt">assert GenericType[type1] &lt; GenericType[type2]</span></pre><ul class=""><li id="405c" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><strong class="iw hj">逆变</strong>，如果<em class="lf"> GenericType[type2] </em>是<em class="lf"> GenericType[type1] </em>的子类型</li></ul><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="2c26" class="lp kd hi ll b fi lq lr l ls lt">assert GenericType[type1] &gt; GenericType[type2] // or<br/>assert GenericType[type2] &lt; GenericType[type1]</span></pre><ul class=""><li id="8c83" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><strong class="iw hj">不变量</strong>，如果以上两者都不成立</li></ul><p id="2701" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我在<a class="ae kb" href="https://www.python.org/dev/peps/pep-0483/#covariance-and-contravariance" rel="noopener ugc nofollow" target="_blank">人教版483中发现了一个很好的数学例子——理论类型提示</a>对于<strong class="iw hj">协方差</strong>、<strong class="iw hj">逆变</strong>和<strong class="iw hj">不变性</strong>的定义:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="b18b" class="lp kd hi ll b fi lq lr l ls lt">def cov(x: float) -&gt; float:<br/>    return 2*x</span><span id="ddc4" class="lp kd hi ll b fi lu lr l ls lt">def contra(x: float) -&gt; float:<br/>    return -x</span><span id="0fa7" class="lp kd hi ll b fi lu lr l ls lt">def inv(x: float) -&gt; float:<br/>    return x*x</span></pre><p id="6c22" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果<em class="lf"> x1 &lt; x2 </em>，那么总是<em class="lf"> cov(x1) &lt; cov(x2) </em>，和<em class="lf">contra(x2)&lt;contra(x1)</em>，但是关于<em class="lf"> inv什么也说不出来。</em></p><p id="a62d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">协方差</strong>、<strong class="iw hj">逆变</strong>、<strong class="iw hj">不变性</strong>类型的例子:</p><ul class=""><li id="dc64" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><em class="lf">ImmutableList【T】</em>是<strong class="iw hj">协变</strong>。如果<em class="lf"> int </em>是<em class="lf"> float </em>的子类型，那么<em class="lf">immutable list【int】</em>是<em class="lf">immutable list【float】</em>(<strong class="iw hj">协方差</strong>)的子类型</li></ul><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="778d" class="lp kd hi ll b fi lq lr l ls lt">assert ImmutableList[int] &lt; ImmutableList[float] // true</span></pre><ul class=""><li id="4134" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><em class="lf">可变列表【T】</em>是<strong class="iw hj">不变量</strong>。如果<em class="lf">苹果</em>是<em class="lf">水果</em>的子类型，那么你不能说<em class="lf">可变列表【苹果】</em>是<em class="lf">可变列表【水果】</em>的子类型，反之亦然。不变性是可变类型的常见行为</li></ul><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="258b" class="lp kd hi ll b fi lq lr l ls lt">Type Fruit<br/>Type Apple</span><span id="77ee" class="lp kd hi ll b fi lu lr l ls lt">assert Apple &lt; Fruit // true</span><span id="ea46" class="lp kd hi ll b fi lu lr l ls lt">assert MutableList[Fruit] &lt; MutableList[Apple] // false<br/>assert MutableList[Apple] &lt; MutableList[Fruit] // false</span></pre><h1 id="1abc" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">为什么可变类型是不变的？</h1><p id="6f41" class="pw-post-body-paragraph iu iv hi iw b ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr hb bi translated">事实上，为了检测可变类型的类型检查错误，它们应该是<strong class="iw hj">不变的</strong>。让我们用上一段中一个非常简单的例子来看看这个。你有一个基础类型<em class="lf">水果</em>和两个子类型:<em class="lf">苹果</em>和<em class="lf">香蕉</em></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6a8c" class="lp kd hi ll b fi lq lr l ls lt">Type Fruit<br/>Type Apple<br/>Type Banana</span><span id="360c" class="lp kd hi ll b fi lu lr l ls lt">assert Apple &lt; Fruit // true<br/>assert Banana &lt; Fruit // true</span></pre><p id="e0c8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于我们的例子，你需要一个可变的<strong class="iw hj">泛型类型</strong><em class="lf">【T】</em>。为基本类型<em class="lf">水果</em>和<em class="lf">苹果</em>定义一个可变容器类型</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6a3e" class="lp kd hi ll b fi lq lr l ls lt">Type MutableList[T]</span><span id="346e" class="lp kd hi ll b fi lu lr l ls lt">Type MutableList[Fruit]<br/>Type MutableList[Apple]</span><span id="3aa8" class="lp kd hi ll b fi lu lr l ls lt">// define a varibles for list of Apples and list of Fruits<br/>apples :: MutableList[Apple]<br/>fruits :: MutableList[Fruit]</span></pre><p id="735d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们想象一下，那个<strong class="iw hj">泛型</strong> <em class="lf">可变列表【T】</em>是<strong class="iw hj">协变</strong>。这意味着，那</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0920" class="lp kd hi ll b fi lq lr l ls lt">// if Apple is a subtype of Fruit<br/>assert Apple &lt; Fruit // true</span><span id="2706" class="lp kd hi ll b fi lu lr l ls lt">// then<br/>assert MutableList[Apple] &lt; MutableList[Fruit] // true, covariant</span><span id="df37" class="lp kd hi ll b fi lu lr l ls lt">// and we assign apples to fruits<br/>fruits = apples</span></pre><p id="9dfc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">太好了！从类型的角度来看，一切都是正确的。水果是水果列表和<em class="lf">的列表，香蕉</em>是<em class="lf">水果</em>的子类型，所以我们可以在水果列表中添加一个香蕉</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ddfe" class="lp kd hi ll b fi lq lr l ls lt">// fruits is MutableList[Fruit]<br/>// and Banana is a subtype of Fruit<br/>assert Banana &lt; Fruit</span><span id="cae6" class="lp kd hi ll b fi lu lr l ls lt">// we can add banana to a list<br/>banana::Banana<br/>fruits.append(banana)</span></pre><p id="b3d5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">看起来还是正确的。水果列表包含<em class="lf">香蕉</em>和<em class="lf">苹果</em>种类。但是我们有变量<em class="lf">苹果</em>，也就是指向同一个列表，它的类型是<em class="lf">可变列表【苹果】</em>而<em class="lf">香蕉</em>不是<em class="lf">苹果</em>的子类型。但是经过我们的操作后<em class="lf">易变列表【苹果】</em>包含<em class="lf">香蕉</em>类型。<strong class="iw hj">协变</strong>可变类型破坏了类型检查，这就是为什么我们不能让可变类型<strong class="iw hj">协变</strong>！</p><h1 id="547e" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">可调用类型协方差/逆变</h1><p id="c92c" class="pw-post-body-paragraph iu iv hi iw b ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr hb bi translated"><strong class="iw hj">可调用的</strong>类型是<strong class="iw hj">共变的</strong>返回类型。也就是说，对于两个<strong class="iw hj">可调用的</strong>类型:<em class="lf">可调用[[type]，rtype1] </em>，<em class="lf">可调用[[type]，rtype2] </em>。如果<em class="lf"> rtype1 </em>是<em class="lf"> rtype2 </em>的子类型，那么<em class="lf"> Callable[[type]，rtype1] </em>是<em class="lf"> Callable[[type]，rtype2] </em>的子类型</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="83c1" class="lp kd hi ll b fi lq lr l ls lt">assert int &lt; float // true<br/>assert Callable[[str], int] &lt; Callable[[str], float] //true</span></pre><p id="16f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了实现这一点，让我们假设您有一些<em class="lf"> map </em>函数，它期望<em class="lf"> Callable[[str]，float] </em>作为参数。在<em class="lf">映射内</em>函数开发者可能会调用你的可调用函数，并期望它返回一个<em class="lf"> float </em>类型。既然<em class="lf"> int </em>是<em class="lf"> float </em>的一个子类型，那么把<em class="lf"> Callable[[str]，int] </em>传递给你的<em class="lf"> map </em>函数就可以了。</p><p id="3bf7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是<strong class="iw hj">可调用的</strong>类型是<strong class="iw hj">自变量类型中的逆变</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ef09" class="lp kd hi ll b fi lq lr l ls lt">assert Callable[[float], str] &lt; Callable[[int], str] // true<br/>// if<br/>assert int &lt; float // true</span></pre><p id="67a9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">比如这里你需要三种类型:<em class="lf"> int </em>，<em class="lf"> float </em>和<em class="lf"> complex </em>。并且让我们声明<em class="lf"> int </em>是<em class="lf"> float </em>的子类型，<em class="lf"> float </em>是<em class="lf"> complex </em>的子类型</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="1a52" class="lp kd hi ll b fi lq lr l ls lt">Type int<br/>Type float<br/>Type complex</span><span id="6c19" class="lp kd hi ll b fi lu lr l ls lt">assert int &lt; float &lt; complex</span></pre><p id="3643" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你还需要一个函数<em class="lf"> map </em>，它有一个参数——类型为<em class="lf"> Callable[[float]，str] </em>的函数。让我们想象一下，如果你将一个<em class="lf"> Callable[[int]，str] </em>传递给函数<em class="lf"> map </em>，会发生什么。作为一个<em class="lf">映射</em>作者，我期望<strong class="iw hj">可调用</strong>的第一个参数是<em class="lf">浮动</em>。所以我试着把我的<em class="lf"> float </em>传递给<strong class="iw hj"> Callable </strong>，那是什么？我不能，因为我将<em class="lf"> int </em>作为第一个参数类型，并且<em class="lf"> float </em>不是<em class="lf"> int </em>的子类型</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9751" class="lp kd hi ll b fi lq lr l ls lt">assert float &lt; int // false</span></pre><p id="16b6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是为什么<strong class="iw hj">可调用的</strong>类型在参数中不能是<strong class="iw hj">协变的</strong>！另一方面，将<em class="lf"> Callable[[complex]，str] </em>作为参数传递给函数<em class="lf"> map </em>是安全的。<em class="lf"> float </em>和<em class="lf"> int </em>类型都可以传递给<em class="lf"> complex </em>类型。它是安全的。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="d433" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我希望在理解了这些概念之后，作为开发者的你将开始设计更少错误的系统，并使用你最喜欢的程序语言类型系统的所有能力。感谢您的宝贵时间！</p></div></div>    
</body>
</html>