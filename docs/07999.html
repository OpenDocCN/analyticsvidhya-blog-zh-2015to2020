<html>
<head>
<title>An Industrial Case study on Deep learning image classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习图像分类的工业案例研究</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/an-industrial-case-study-on-deep-learning-image-classification-c909d331fc31?source=collection_archive---------7-----------------------#2020-07-14">https://medium.com/analytics-vidhya/an-industrial-case-study-on-deep-learning-image-classification-c909d331fc31?source=collection_archive---------7-----------------------#2020-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cea2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像分类的逐步指南</p><p id="5d06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将解释深度学习图像分类的一个端到端用例，以便在铸造厂自动对有缺陷和无缺陷的铸件进行分类。本问题陈述及数据集摘自<a class="ae jd" href="https://www.kaggle.com/ravirajsinh45/real-life-industrial-dataset-of-casting-product" rel="noopener ugc nofollow" target="_blank"><em class="je">https://www . ka ggle . com/ravi rajsinh 45/real-life-industrial-dataset-of-casting-product</em></a><em class="je">。</em></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es jf"><img src="../Images/b112be32252c7f2beced64ed6b5706db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*4SvaTBvyELzPTJ40h9hlnw.jpeg"/></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">铸件产品图片(潜水泵叶轮)，来源:<a class="ae jd" href="https://www.kaggle.com/ravirajsinh45/real-life-industrial-dataset-of-casting-product" rel="noopener ugc nofollow" target="_blank"><em class="jr">https://www . ka ggle . com/ravi rajsinh 45/real-life-industrial-dataset-of-casting-product</em></a><em class="jr">。</em></figcaption></figure><p id="f44f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">铸造工艺:</strong>铸造是一种主要的制造工艺，在这种工艺中，熔融金属被倒入一个叫做模具的空腔中，冷却直至凝固成产品。</p><p id="33ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">铸造缺陷:</strong>这些是在铸造过程中出现的铸造产品的缺陷，它们是不希望的。铸件中有许多类型的缺陷，如气孔、针孔、毛刺、缩孔、模具材料缺陷、浇注金属缺陷、冶金缺陷等。</p><p id="1f60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">铸造缺陷是不可取的，会给制造商造成损失，因此质量部门必须对产品进行目视检查，并将有缺陷的产品与合格的铸件分开。视觉检查是劳动密集型和耗时的，因此卷积神经网络(CNN)可以用于通过图像分类来自动化该过程。图一。显示了在这个项目中开发的铸造检查员应用程序。这篇文章的剩余部分解释了在这个案例研究中使用的逐步方法。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es js"><img src="../Images/c90f83864784634cedec8a4f6c8e5ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIi5ovjV2-PtWa5wJ6jl1w.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">图一。在这项工作中开发的铸造检查员应用程序的屏幕截图。</figcaption></figure><h1 id="988f" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">第一步:使用CNN训练模型。</strong></h1><p id="3b97" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated"><strong class="ih hj"> 1.1从网址:</strong><a class="ae jd" href="https://www.kaggle.com/ravirajsinh45/real-life-industrial-dataset-of-casting-product" rel="noopener ugc nofollow" target="_blank"><em class="je">https://www . ka ggle . com/ravi rajsinh 45/real-life-industrial-dataset-of-casting-product</em></a><em class="je"/>下载数据集，解压文件夹。在这个图像分类问题中有两类，即缺陷铸件和无缺陷(合格)铸件。数据集已经分为训练数据集和测试数据集。训练数据集包括3758幅有缺陷铸件图像和2875幅无缺陷铸件图像，测试数据集包括453幅有缺陷铸件图像和262幅无缺陷铸件图像。数据集中的每个图像都是形状为300X300像素的灰度图像。</p><p id="49a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1.2训练模型:</strong>我使用了稍加修改的VGG16算法来训练这些图像。在此之前，我尝试了Resnet 50和Lenet算法，但奇怪的是，结果并不令人满意。下面是我用来训练模型的代码，我在谷歌联合实验室GPU上用1000步训练了100个时期的模型。完成培训过程花了12个多小时。</p><pre class="jg jh ji jj fd la lb lc ld aw le bi"><span id="29fe" class="lf jy hi lb b fi lg lh l li lj">from keras.models import Sequential<br/>from keras.layers import Conv2D<br/>from keras.layers import MaxPooling2D<br/>from keras.layers import Flatten<br/>from keras.layers import Dense</span><span id="eefc" class="lf jy hi lb b fi lk lh l li lj"># Initialising the CNN<br/>classifier = Sequential()</span><span id="513b" class="lf jy hi lb b fi lk lh l li lj"># Step 1 - Convolution<br/>classifier.add(Conv2D(32, (3, 3), input_shape = (300, 300, 3), activation = 'relu'))</span><span id="7a30" class="lf jy hi lb b fi lk lh l li lj"># Step 2 - Pooling<br/>classifier.add(MaxPooling2D(pool_size = (2, 2)))</span><span id="0a1a" class="lf jy hi lb b fi lk lh l li lj"># Step 3 - Flattening<br/>classifier.add(Flatten())</span><span id="b168" class="lf jy hi lb b fi lk lh l li lj"># Step 4 - Full connection<br/>classifier.add(Dense(units = 128, activation = 'relu'))<br/>classifier.add(Dense(units = 1, activation = 'sigmoid'))</span><span id="44aa" class="lf jy hi lb b fi lk lh l li lj"># Compiling the CNN<br/>classifier.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])</span><span id="e1a8" class="lf jy hi lb b fi lk lh l li lj"># Part 2 - Fitting the CNN to the images<br/>from keras.preprocessing.image import ImageDataGenerator</span><span id="f919" class="lf jy hi lb b fi lk lh l li lj">train_datagen = ImageDataGenerator(rescale = 1./255,<br/>                                   shear_range = 0.2,<br/>                                   zoom_range = 0.2,<br/>                                   horizontal_flip = True)</span><span id="1df6" class="lf jy hi lb b fi lk lh l li lj">test_datagen = ImageDataGenerator(rescale = 1./255)</span><span id="7a10" class="lf jy hi lb b fi lk lh l li lj">training_set = train_datagen.flow_from_directory('/content/drive/My               Drive/casting/casting_512x512/CASTING/train', target_size = (300, 300), batch_size = 32, class_mode = 'binary')</span><span id="b5f4" class="lf jy hi lb b fi lk lh l li lj">test_set = test_datagen.flow_from_directory('/content/drive/My Drive/casting/casting_512x512/CASTING/test', target_size = (300, 300),batch_size = 32,class_mode = 'binary')</span><span id="ce7b" class="lf jy hi lb b fi lk lh l li lj">model = classifier.fit_generator(training_set,<br/>                                 steps_per_epoch = 1000,<br/>                                 epochs = 100,<br/>                                 validation_data = test_set,        validation_steps = 1000)</span><span id="09e8" class="lf jy hi lb b fi lk lh l li lj">classifier.save("vggmodel.h5")<br/>print("Saved model to disk")</span></pre><h1 id="7380" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">第二步:使用训练好的模型对图像进行分类。</strong></h1><p id="561f" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">在训练模型之后，包含权重的文件在这个项目中生成，它被命名为“vggmodel.h5”。这个文件被发现有1.01 GB重，超出了我的预期，在本教程的最后，我提供了下载这个文件的链接。我们可以使用该文件来预测或分类铸件的任何其他图像。下面是用来预测图像的代码。</p><pre class="jg jh ji jj fd la lb lc ld aw le bi"><span id="b962" class="lf jy hi lb b fi lg lh l li lj">from keras.models import load_model<br/>model = load_model('vggmodel.h5')</span><span id="b5ce" class="lf jy hi lb b fi lk lh l li lj">import numpy as np<br/>from keras.preprocessing import image</span><span id="8f16" class="lf jy hi lb b fi lk lh l li lj">test_image = image.load_img('/home/murali/ds/data/casting  problem/casting_data/casting_data/train/ok_front/cast_ok_0_46.jpeg', target_size = (300, 300))</span><span id="60c3" class="lf jy hi lb b fi lk lh l li lj">test_image = image.img_to_array(test_image)<br/>test_image = np.expand_dims(test_image, axis = 0)<br/>result = model.predict(test_image)<br/>print(result)</span><span id="ffe5" class="lf jy hi lb b fi lk lh l li lj">if result[0][0] == 1:<br/>    prediction = 'CASTING IS OK'<br/>    print(prediction)<br/>else:<br/>    prediction = 'CASTING IS DEFECTIVE'<br/>    print(prediction)</span></pre><p id="650f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这种代码不能每次都方便地用于对每个图像进行预测。因此，我决定为基于GUI的应用程序编写代码，通过它用户可以方便地加载铸造图像，并可以通过点击按钮进行分类。下一段解释了这种GUI的构建。</p><h1 id="f79b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">第三步:使用python的tkinter库构建一个GUI。</strong></h1><p id="3321" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">GUI是通过使用最简单有效的GUI构建工具<em class="je"> tkinter </em> python库构建的。它有丰富的小部件集合，这使得这个过程更加容易。以下是用于构建GUI的代码的不同部分及其功能。</p><p id="7117" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3.1导入库</strong></p><pre class="jg jh ji jj fd la lb lc ld aw le bi"><span id="d0f6" class="lf jy hi lb b fi lg lh l li lj">from tkinter import *<br/>from keras.preprocessing import image<br/>import numpy as np<br/>from keras.models import load_model<br/># loading Python Imaging Library <br/>from PIL import ImageTk, Image   <br/># To get the dialog box to open when required  <br/>from tkinter import filedialog</span></pre><p id="4ada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将导入tkinter库，然后导入如上所示的其他库。这些用于GUI相关功能、图像处理目的，numpy用于与图像相关的计算。ImageTk用于在GUI中处理图像，filedialog用于用户浏览图像等。</p><p id="bf63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3.2加载模型(重量文件)</strong></p><pre class="jg jh ji jj fd la lb lc ld aw le bi"><span id="b231" class="lf jy hi lb b fi lg lh l li lj">model = load_model('vggmodel.h5')<br/>print('Model Loaded Sucessfully')</span></pre><p id="c4f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码将加载预先训练好的模型，我添加了打印语句，以便用户了解进程的状态。</p><p id="0084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3.3函数<em class="je"> open_img() </em>和<em class="je"> openfilename() </em> </strong></p><p id="cda1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je"> openfilename() </em>是一个允许用户从对话框中选择文件并返回文件名的函数。<em class="je"> open_img() </em>加载由<em class="je"> openfilename() </em>函数提供文件名的图像，并保存为“casting.jpeg”以备后用，最后使用<em class="je"> place() </em>函数<em class="je">在GUI窗口的指定位置显示为标签。</em></p><pre class="jg jh ji jj fd la lb lc ld aw le bi"><span id="2e7b" class="lf jy hi lb b fi lg lh l li lj">def open_img(): <br/>    # Select the Imagename  from a folder  <br/>    x = openfilename() <br/>    # opens the image <br/>    img = Image.open(x) <br/>    im1 = img.save("casting.jpeg")<br/>    img = ImageTk.PhotoImage(img) <br/>    # create a label <br/>    panel = Label(root, image = img)   <br/>    # set the image as img  <br/>    panel.image = img <br/>    panel.place(bordermode=OUTSIDE, x=50, y=50)<br/>       <br/>    <br/>def openfilename(): <br/>    # open file dialog box to select image <br/>    # The dialogue box has a title "Open" <br/>    filename = filedialog.askopenfilename(title ='Select Image') <br/>    return filename</span></pre><p id="0610" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.4<em class="je">预测()</em>功能。</p><p id="739b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数用于预测使用模型的图像的分类，找到下面的代码同样适用。</p><pre class="jg jh ji jj fd la lb lc ld aw le bi"><span id="9251" class="lf jy hi lb b fi lg lh l li lj">def prediction():<br/>    img ="casting.jpeg"    <br/>    test_image = image.load_img(img, target_size = (300, 300))<br/>    test_image = image.img_to_array(test_image)<br/>    test_image = np.expand_dims(test_image, axis = 0)<br/>    result = model.predict(test_image)<br/>    <br/>    if result[0][0] == 1:<br/>        prediction = 'CASTING IS OK'        '<br/>        <br/>    else:<br/>        prediction = 'CASTING IS DEFECTIVE'<br/>        <br/>    result = Label(root, text = prediction)   <br/>    # set the image as img  <br/>    result.place(bordermode=OUTSIDE, x=400, y=120)</span></pre><p id="2c6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，<em class="je"> open_img() </em>先前保存的“casting.jpeg”将被加载并适当转换为<em class="je"> test_image </em>，可用于预测目的<em class="je">。</em>预测结果作为标签打印在GUI窗口上。</p><p id="8795" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">3.4 GUI窗口</strong></p><p id="8a8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GUI窗口由以下代码生成:</p><pre class="jg jh ji jj fd la lb lc ld aw le bi"><span id="9b69" class="lf jy hi lb b fi lg lh l li lj"># Create a window <br/>root = Tk()   <br/># Set Title as Image Loader <br/>root.title("CASTING INSPECTOR")   <br/># Set the resolution of window <br/>root.geometry("700x450")   <br/># Do't Allow Window to be resizable <br/>root.resizable(width = False, height = False) <br/>  <br/># Create a button and place it into the window using place layout <br/>btn_open_image = Button(root, text ='Open image', command = open_img).place(x = 10, y= 400) </span><span id="f873" class="lf jy hi lb b fi lk lh l li lj">btn_predict = Button(root, text ='Predict', command = prediction).place(x = 200, y= 400) </span><span id="ecb2" class="lf jy hi lb b fi lk lh l li lj">result_hd = Label(root, text = "RESULT")<br/>result_hd.place(bordermode=OUTSIDE, x=400, y=90)<br/>root.mainloop()</span></pre><p id="978a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je"> root </em>是我们窗口的名称，<em class="je"> root.title </em>将设置我们窗口的标题为“铸造检查器”，<em class="je"> root.geometry </em>将设置GUI窗口的大小。<em class="je"> root.resizable </em>有助于限制调整大小选项。然后创建两个按钮，一个用于浏览和打开图像文件，另一个用于使用模型进行预测。按钮<em class="je"> btn_open_image </em>调用前面讨论的<em class="je"> open_image() </em>函数，其中按钮<em class="je"> btn_predict </em>将调用函数<em class="je"> prediction() </em>，该函数将预测图像所属的类。最后，铸造检查员的工作如下所示</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ll"><img src="../Images/e5f003ebeabb7990d940713031083b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*yBV6kXL95bUnzZ2RPaOeKA.gif"/></div></figure><h1 id="2aa9" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">结论</strong></h1><p id="9d9e" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">该帖子说明了深度学习图像分类的实施，作为工业环境中的用例。以下是该项目的未来范围</p><ol class=""><li id="99ec" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">该应用程序可以与相机集成，以捕捉铸造产品的实时图像。</li><li id="0d84" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">可以通过增加历元数和使用其他深度学习算法来训练模型以获得更高的准确性。</li><li id="8f8e" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">该应用程序可以与一些致动器集成，以便一旦检测到有缺陷的铸件，就激活该机制来分离该有缺陷的铸件。</li></ol><p id="f077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本项目中使用的代码可以在<a class="ae jd" href="https://github.com/muralimambekar/casting_inspector" rel="noopener ugc nofollow" target="_blank">https://github.com/muralimambekar/casting_inspector</a>上找到</p><p id="7e5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型(重量)文件可从以下网址下载</p><p id="6a5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://drive.google.com/file/d/1r0FbT0vd-YfFaWzPLx84txsKnLF-G3Dc/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://drive . Google . com/file/d/1 r 0 fbt 0 VD-yffawzplx 84 xsknlf-G3Dc/view？usp =分享</a></p><p id="be0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤3:使用python的tkinter库构建一个GUI。</p><p id="382d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/muralimambekar/casting_inspector" rel="noopener ugc nofollow" target="_blank">https://github.com/muralimambekar/casting_inspector</a></p></div></div>    
</body>
</html>