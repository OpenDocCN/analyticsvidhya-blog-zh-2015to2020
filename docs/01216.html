<html>
<head>
<title>Demystifying Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘二叉查找树</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/demystifying-binary-search-tree-95cf26c90b33?source=collection_archive---------21-----------------------#2019-10-08">https://medium.com/analytics-vidhya/demystifying-binary-search-tree-95cf26c90b33?source=collection_archive---------21-----------------------#2019-10-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aad490b8c0b92f4cc0da0d801f729e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqaGWlJIuYfhtmJxXBbY6Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">乔纳斯·斯维德拉斯在<a class="ae iu" href="https://unsplash.com/s/photos/computer-science?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1e04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有时学习树相关的数据结构是令人生畏的。我会试着把事情分解成更小的部分来解释，然后我们看看如何把它们放在一起。</p><p id="8bfe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">二叉查找树的定义:</strong></p><p id="31b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">左侧子树中的所有元素都小于根元素，右侧子树中的所有元素都大于根元素。一个典型的二分搜索法<a class="ae iu" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">树</a>看起来类似于下图。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/75e371a9164426308045aa82347c184a.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/0*HnUgLcCSs1_uOV3j"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">1.二叉查找树</figcaption></figure><p id="6f3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">各节点内部</strong></p><p id="6372" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住这个图像，让我们开始把它分成更小的部分。我们将在开始时只选取一个元素，并了解它是如何构建的。取第一个元素，即8。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/16c743d0fc5c097a55e1bef569ebc9ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/0*BZHrTOnYsM8Ds5Sj"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">2.单个节点</figcaption></figure><p id="e787" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在构建更多这样的元素之前，我们需要先找到它的组成元素。就像工厂制造轮胎一样，我们需要学习制造第一个轮胎，然后运用所学知识制造更多这样的轮胎。</p><p id="ecc7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，这有3个元素，数据和两个指针。我们称它们为节点。节点的结构看起来像这样。数据元素是存储节点值的元素，左指针存储左子节点的<a class="ae iu" href="https://en.wikipedia.org/wiki/Reference_(computer_science)" rel="noopener ugc nofollow" target="_blank">引用</a>，右指针存储右子节点的引用。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/c9da62c0629e3b2d840822f0219de738.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/0*VG4teQ8puXEF7sJo"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">3.节点的内部</figcaption></figure><p id="1022" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那是一个节点的图示。我们需要以编程方式定义相同的结构。让我们用javascript试试。</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="7f09" class="kf kg hi kb b fi kh ki l kj kk">Class Node { <br/>    constructor(data) { <br/>        this.data = data; <br/>        this.left = null;<br/>        this.right = null;<br/>    }<br/>}</span></pre><p id="205f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的定义没有创建任何节点，它只是创建了节点的一个<a class="ae iu" href="https://www.vocabulary.com/dictionary/blueprint" rel="noopener ugc nofollow" target="_blank">蓝图</a>。使用这个蓝图，我们将创建我们的第一个节点，下面这条线会变魔术。</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="9dbf" class="kf kg hi kb b fi kh ki l kj kk">let node_1 = new Node(8);</span></pre><p id="7f73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以想象第三张图片，它创建了一个数据为8的节点，两个指针都没有指向任何东西。</p><p id="37aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">更多节点</strong></p><p id="f626" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您现在可以创建更多节点。比方说，我又创建了3个节点</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="3c55" class="kf kg hi kb b fi kh ki l kj kk">let node_2 = new Node(3);<br/>let node_3 = new Node(10);<br/>let node_4 = new Node(6);</span></pre><p id="be34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在您总共有4个节点。目前的图片如下图。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/6f87299b5ed7d66959e35595434f959b.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/0*xY7BVHXKVCzcMhaO"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">4.更多节点</figcaption></figure><p id="5d27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">将它们连接在一起</strong></p><p id="87b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经创建了许多节点，但是它们没有连接。让我们根据<a class="ae iu" href="https://en.wikipedia.org/wiki/Binary_search_tree" rel="noopener ugc nofollow" target="_blank">二叉查找树</a>的定义把他们联系起来。</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="d374" class="kf kg hi kb b fi kh ki l kj kk">node_1.left = node_2; // because node_2.data &lt; node_1.data node_1.right = node_3; // because node_3.data &gt; node_1.data node_2.right = node_4; // because node_4.data &gt; node_2.data</span></pre><p id="a7ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，你得到了第一张图片。太棒了。你可以建造二叉查找树。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/25c8b4b00521239004a698a171209038.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/0*ueElV81u1tLsYoW4"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">5.二叉查找树</figcaption></figure><p id="d9b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，您可以继续添加更多的节点，并按照二叉查找树的定义保持正确的顺序将它们链接起来。</p><p id="7dc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">将理智引入系统</strong></p><p id="ead0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">理论上，这都是关于二叉查找树的。但是过了10个节点就会变疯。你会发现管理节点很困难。仅仅为了提供一种更系统的方式来管理节点，我们还需要做更多的工作。在我们开始构建系统之前，让我们列出没有系统时的痛点，这样一旦系统构建完成，我们就可以欣赏它。第一个难点是，当任何新节点添加到系统中时，很难跟踪我的新节点应该去哪里。第二个难点是，如何跟踪到目前为止插入的所有节点。</p><p id="2c05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">解决问题</strong></p><p id="8b34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我可以直接介绍这个术语，但我希望你用一个现实生活中的例子来描述它。有一棵树，你想爬上树。理想情况下，您应该从寻找树根开始。一旦你有了树根，你就可以爬上树，摘水果或者在树上挂几个人造水果。(没人那么做，你在开玩笑吗？).所以，有一件事我们发现我们需要根来开始。回到我们的例子，我们从零开始。当我们添加节点时，我们需要确保root指向第一个节点。(一直！).</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="bf4c" class="kf kg hi kb b fi kh ki l kj kk">class BinarySearchTree { <br/>    constructor() { <br/>        this.root = null;<br/>    }<br/>}</span></pre><p id="324d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们就此打住，看看它现在有什么力量。让我们再次构建相同的节点，并确保根节点指向第一个节点。</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="ac98" class="kf kg hi kb b fi kh ki l kj kk">let BST = new BinarySearchTree(); // root is null <br/>let node_1 = new Node(8); // This is first node, root should point to this node <br/>root = node_1;<br/>let node_2 = new Node(3);<br/>node_1.left = node_2;<br/>let node_3 = new Node(10);<br/>node_1.right = node_3;<br/>let node_4 = new Node(6);<br/>node_2.right = node_4;</span></pre><p id="1c85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是目前的图片。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es km"><img src="../Images/44dd38dbeace2b18cbda50727e35d6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/0*Q2qYwKWW-jEHNQEA"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">6.扎根的感觉真好</figcaption></figure><p id="17c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经为我们的树添加了根，任何人想要检查(攀爬)所有的元素都可以从根开始。我们解决了跟踪的问题，但是添加节点仍然是一个挑战。我们需要向BinarySearchTree类添加一个方法来添加节点。</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="2eab" class="kf kg hi kb b fi kh ki l kj kk">addNode(data) {</span><span id="d8fe" class="kf kg hi kb b fi kn ki l kj kk">}</span></pre><p id="ecba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个方法应该使用为节点创建的蓝图。</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="67fe" class="kf kg hi kb b fi kh ki l kj kk">addNode(data) {<br/>    let node = new Node(data);<br/>}</span></pre><p id="a75a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当<em class="ko"> addNode() </em>被调用时，此时它已经用给定的数据创建了一个节点。请记住，如果它是第一个节点，根应该指向这个节点。让我们加上那张支票。</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="c578" class="kf kg hi kb b fi kh ki l kj kk">addNode(data) {<br/>    let node = new Node(data);<br/>    if(this.root === null) {<br/>        root = node;<br/>    }<br/>}</span></pre><p id="0555" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太好了！您已经添加了第一个节点，并且根节点也指向它。现在是具有挑战性的部分。如果不是第一个节点，这个节点应该去哪里？我们需要根的帮助。我们有节点和根，我们需要添加另一个方法，它接受这两个参数，为我们解决问题，我们不需要担心。</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="57ab" class="kf kg hi kb b fi kh ki l kj kk">addNode(data) {<br/>    let node = new Node(data);<br/>    if(this.root === null) {<br/>        this.root = node;<br/>    } else {<br/>        this.insertNode(node, this.root);<br/>    }<br/>}</span></pre><p id="7516" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我撒谎是为了让你开心1纳秒，我们需要担心<em class="ko"> insertNode() </em>。该方法将根据节点的值插入节点。</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="2d0b" class="kf kg hi kb b fi kh ki l kj kk">insertNode(node, root) {<br/>    if(node.data &lt; root.data) {<br/>        if(root.left === null) {<br/>            root.left = node; <br/>        } else {<br/>            this.insertNode(node, root.left);<br/>        }<br/>    } else {<br/>        if(root.right === null) {<br/>            root.right = node;<br/>        } else {<br/>            this.insertMethod(node, root.right);<br/>        }<br/>    }<br/>}</span></pre><p id="7a34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不好！一次抛出的代码太多了。抱歉，还在想怎么才能进一步打破它。反正是管用的。我们有一个系统的方法来添加更多的节点到系统中。接下来，我们希望爬上树并按排序顺序打印所有节点。您还可以在这里探索不同种类的树遍历算法。</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="9f93" class="kf kg hi kb b fi kh ki l kj kk">printInOrder(root) {<br/>    if(this.root === null) {<br/>        return;<br/>    }<br/>    this.printInOrder(root.left);<br/>    console.log(root.data);<br/>    this.printInOrder(root.right);<br/>}</span></pre><p id="8f2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">驱动程序</strong></p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="7315" class="kf kg hi kb b fi kh ki l kj kk">let bst = new BinarySearchTree();<br/>bst.addNode(8);<br/>bst.addNode(3);<br/>bst.addNode(10);<br/>bst.addNode(6);<br/>bst.printInOrder(bst.root); // prints 3,6,8,10</span></pre><p id="3819" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">把所有东西放在一起</strong></p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="8b83" class="kf kg hi kb b fi kh ki l kj kk">class Node {<br/>    constructor(data) {<br/>        this.data = data;<br/>        this.left = null;<br/>        this.right = null;<br/>    }<br/>}</span><span id="1fca" class="kf kg hi kb b fi kn ki l kj kk">class BST {<br/>    constructor() {<br/>        this.root = null;<br/>    }</span><span id="810a" class="kf kg hi kb b fi kn ki l kj kk">    add(data) {<br/>        let node = new Node(data);<br/>        if(this.root === null) {<br/>            this.root = node;<br/>        } else {<br/>            this.insertNode(node, this.root);<br/>        }<br/>    }</span><span id="e365" class="kf kg hi kb b fi kn ki l kj kk">    insertNode(node, root) {<br/>        if(node.data &lt; root.data) {<br/>            if(root.left === null) {<br/>                root.left = node;<br/>        } else {<br/>            this.insertNode(node, root.left);<br/>            }<br/>        } else {<br/>            if(root.right === null) {<br/>                root.right = node;<br/>            } else {<br/>                this.insertNode(node, root.right);<br/>            }<br/>        }<br/>    }</span><span id="76d1" class="kf kg hi kb b fi kn ki l kj kk">    printInorderBST(root) {<br/>        if(root === null) {<br/>            return;<br/>        } <br/>        this.printInorderBST(root.left);<br/>        console.log(root.data);<br/>        this.printInorderBST(root.right);<br/>   }<br/>}</span><span id="94ca" class="kf kg hi kb b fi kn ki l kj kk">let bst = new BST();<br/>bst.add(8);<br/>bst.add(3);<br/>bst.add(10);<br/>bst.add(6);<br/>bst.printInorderBST(bst.root); // prints 3,6,8,10</span></pre><p id="7adc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请随时提供意见以进一步改进它。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="2857" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ko">原载于2019年10月8日</em><a class="ae iu" href="https://www.arvindpandey.in/demystifying-binary-search-tree/" rel="noopener ugc nofollow" target="_blank"><em class="ko">http://arvindpandey . in</em></a><em class="ko">。</em></p></div></div>    
</body>
</html>