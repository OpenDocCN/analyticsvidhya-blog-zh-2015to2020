<html>
<head>
<title>Reference Functions in Event Listeners, Don’t Call</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件侦听器中的引用函数，不要调用</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/reference-functions-in-event-listeners-dont-call-53063b21d64a?source=collection_archive---------6-----------------------#2019-12-14">https://medium.com/analytics-vidhya/reference-functions-in-event-listeners-dont-call-53063b21d64a?source=collection_archive---------6-----------------------#2019-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8ea46af94d075a0528cd5ab66c9e657a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLuYypiK2q2R6HVNnajotA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">鲁布·戈德堡机器</figcaption></figure><p id="4eb0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的装置被称为“鲁布·戈德堡机器”。它以非常复杂的方式执行简单的任务。典型的情况是，一个动作引发另一个动作，以此类推，直到这个简单的任务被序列中的最后一个动作完成。这些动作中的每一个都在等待着什么事情发生。轮子在等待曲柄转动，滑轮在等待轮子转动。每个动作<em class="js">监听</em>前一个动作。在Javascript中，我们用“事件监听器”自己创建这些序列。我们用<code class="du jt ju jv jw b">addEventListener</code>创建事件监听器，<code class="du jt ju jv jw b">addEventListener</code>需要两个参数:1。要监听的事件和2。“听到”事件时要执行的函数。如果我们以不正确的方式提供一个函数，我们可能会搞砸这个监听过程。这就是为什么使用函数引用<strong class="iw hj">而不是函数调用</strong>很重要。</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="d5c7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">乔纳·希尔欣赏一个好的参考，我们的事件听众也是。为了正常工作，事件侦听器需要函数引用，而不是函数调用。有什么区别？假设我的页面上有一个心形按钮，看起来像这样:</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/6705294b95dadc7492a2ebb8b51287e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VgT3flqZJgwFui55-TyEg.png"/></div></div></figure><p id="ef2f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我决定当我的用户点击这个按钮时，我希望按钮变成蓝色，所以我在我的Javascript中创建了一个事件监听器。我们抓取元素，并使用<code class="du jt ju jv jw b">addEventListener</code>来确保这个按钮正在监听。下面，我声明了事件发生时将执行的函数。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/2481219f735c4b81a8930248a5172ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PxA6lhPTXDZxMW5snWfrkw.png"/></div></div></figure><p id="a03b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如您所看到的，这个函数需要一个参数“event ”,我们用它来访问它的目标的背景颜色，以便改变它。<code class="du jt ju jv jw b">event.target</code>是我们要换的按钮。如果我们<code class="du jt ju jv jw b">console.log(event)</code>，我们传递给这个参数的事件应该是这样的。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/e987c6ef39fa261b9bd8c10ddf728797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LYRdTSD__ui57LPaf1DoYg.png"/></div></div></figure><p id="456f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里发生了很多事情，如果我们仔细研究，这个事件有很多属性。我们想特别关注它的一个特性。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="er es kg"><img src="../Images/639c48e5d8f2dfe02cffa9b16da057d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*nuHMlaMBukIsUWECT4jy-A.png"/></div></figure><p id="ef68" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是我们想要在<code class="du jt ju jv jw b">changeToBlue</code>函数中访问的<code class="du jt ju jv jw b">event.target</code>。</p><p id="5552" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">假设我已经使用按钮元素的“id”获取了它，并将其设置为变量<code class="du jt ju jv jw b">hrtBtn</code>。现在我们可以向它添加一个事件侦听器。因为我们希望按钮在被点击时改变颜色，所以我将传递给侦听器的事件将是<code class="du jt ju jv jw b">'click'</code>。</p><p id="87f7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，让我们假设我还没有声明这个函数。为什么？因为这将有助于解释为什么我会被函数调用而不是引用绊倒。如果我们不在事件侦听器外声明函数，我们可以在事件侦听器内声明一个匿名函数作为第二个参数，如下所示:</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/29202107d0a36b5fc04caae0aafb1247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tRTHUZl2cmRVW16wlAg4gw.png"/></div></div></figure><p id="a02e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这工作非常好。附件A:</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="er es ki"><img src="../Images/0934e4b27bff1d7a00bae0e6e97fc1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/1*pBLtZX6qk4y3YPtHMemWrw.gif"/></div></figure><p id="eff7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意，我们将<code class="du jt ju jv jw b">event</code>传递给了这个函数声明。我假设<code class="du jt ju jv jw b">addEventListener</code>给了我们<code class="du jt ju jv jw b">event</code>，我们可以将它传递给函数。这就是为什么我在尝试将我之前声明的<code class="du jt ju jv jw b">changeToBlue</code>函数添加到事件监听器时犯了下面的错误。(<strong class="iw hj">请注意</strong>:下一个例子<strong class="iw hj">不正确</strong>是为了向你展示我在哪里出错)</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/8e01957ab1937bb52cb529b740157bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spM5l2v5lAm9FBrT2Ksz6g.png"/></div></div></figure><p id="620f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的<code class="du jt ju jv jw b">changeToBlue</code>函数需要一个事件参数，所以我像对待在事件监听器中声明的匿名函数一样传递事件给它。如果我们这样做，下面是我们在控制台上看到的内容。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/ccf9d559579c6b65621664072866625b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bo85h2RFWKoVDrOICp8zhg.png"/></div></div></figure><p id="d3bd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">显然我们在<code class="du jt ju jv jw b">changeToBlue(event)</code>中传递的<code class="du jt ju jv jw b">event</code>是未定义的。因此，事件侦听器没有给我们提供可以用关键字“event”传入的事件。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/29202107d0a36b5fc04caae0aafb1247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tRTHUZl2cmRVW16wlAg4gw.png"/></div></div></figure><p id="9089" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本文的重点:<code class="du jt ju jv jw b">addEventListener</code>将<code class="du jt ju jv jw b">event</code>隐式地传递给我们的函数<strong class="iw hj"/>。</p><p id="0540" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们之前给事件侦听器的匿名函数只是声明一个事件将被传递，然后在函数声明中解释我们将对该事件做什么。实际上，在这两种情况下，我们都不需要称之为“事件”。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/64fbf6cf1047a95865ad4cb47c8d6422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xs8CjM02CPPIausWzUvy8g.png"/></div></div></figure><p id="1f8d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">即使在用<code class="du jt ju jv jw b">schnozberries</code>替换<code class="du jt ju jv jw b">event</code>后，其工作原理也完全相同。让我们对之前声明的函数做同样的事情，只是为了证明我们不需要实际写出这个由事件监听器传递的神秘“事件”。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/37e15e874d0217f2c60f26ed5d1176a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wdHGpf_G4p5w17wxcMpG4g.png"/></div></div></figure><p id="2718" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于事件是隐式传递的<strong class="iw hj"/>，不能作为名为<code class="du jt ju jv jw b">event</code>的变量使用，我的下一步是尝试将我的<code class="du jt ju jv jw b">changeToBlue</code>函数传递给事件监听器，就像这样(<strong class="iw hj">注意</strong>:我下一部分<strong class="iw hj">又做错了</strong>)</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/e745bd29e2ca0aeab05f0e8f2bcd75c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*teZr2sL7mesEUBKBqeehig.png"/></div></div></figure><p id="4b40" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">同样，按钮不起作用，这是控制台告诉我们的。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/534f011fe8c63bf2f29439fae29586d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_yW2dz1nuX6y0YgY_Eibg.png"/></div></div></figure><p id="1b49" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这与我们试图像这样传递事件参数时的错误相同。正在发生的事情是，通过在<code class="du jt ju jv jw b">()</code>末尾用括号写出我们的函数，我们在<strong class="iw hj">调用</strong>函数。“难道我们不想调用函数吗？”你可能会说。我们确实想调用它，但是我们只想在事件发生时调用它。当我们像这样在末尾加上括号时，程序一读完这一行，我们就执行这个函数。该函数将在脚本加载后立即执行，这是在用户可以单击按钮之前。因此，我们没有一个事件来隐式传递我们的函数，因此程序不能读取<code class="du jt ju jv jw b">schnozberries</code>的<code class="du jt ju jv jw b">target</code>，因为<code class="du jt ju jv jw b">schnozberries</code>是未定义的。这就把我们带到了功能<strong class="iw hj">参考</strong>。</p><p id="3145" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们写出函数的名字，后面没有括号，我们就没有调用它。我们只是告诉事件监听器在事件发生时找到那个函数，然后执行它(向事件监听器添加回调函数的正确方法)。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/b7e5edf5e87a4be595a24695f06ec224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZIyJ8-uisTP3x4whO3-GLA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">函数引用，正确的做法是</figcaption></figure><p id="ef6c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过引用我们的<code class="du jt ju jv jw b">changeToBlue</code>函数，监听器在点击事件一发生就将其传递给函数，现在我们的<code class="du jt ju jv jw b">schnozberries</code>有了一些意义。</p></div></div>    
</body>
</html>