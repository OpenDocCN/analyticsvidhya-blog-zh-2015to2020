<html>
<head>
<title>BFS, DFS and Union Find</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BFS、DFS和Union Find</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/bfs-dfs-and-union-find-1e686490a936?source=collection_archive---------16-----------------------#2019-11-19">https://medium.com/analytics-vidhya/bfs-dfs-and-union-find-1e686490a936?source=collection_archive---------16-----------------------#2019-11-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3468" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将通过一个例子展示BFS(广度优先搜索)、DFS(深度优先搜索)和联合查找之间的联系。</p><p id="192a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例子是leetcode的一个问题。</p><p id="244d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题是1263。将盒子移动到目标位置的最少移动次数</p><p id="91d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/minimum-moves-to-move-a-box-to-the-target-location/</a></p><p id="9813" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个难题。难的原因是它含有两个bfs。</p><p id="419b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题的解决方案可以是:BFS + BFS或者BFS + DFS或者BFS + Union Find</p><p id="2d00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案1(BFS + BFS，运行时间160毫秒)</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="8574" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案1通过使用德克改进了BFS+BFS(116毫秒)</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="d029" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案2(BFS + DFS运行时间632毫秒)</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="d514" class="jq jr hi jm b fi js jt l ju jv">class Solution:<br/>    def minPushBox(self, grid: List[List[str]]) -&gt; int:<br/>        R, C = len(grid), len(grid[0])<br/>        for i in range(R):<br/>            for j in range(C):<br/>                if grid[i][j] == 'S':<br/>                    pi, pj = i, j<br/>                elif grid[i][j] == 'B':<br/>                    bi, bj = i, j<br/>                 <br/>        def dfs_person(i, j, ti, tj, bi, bj):<br/>            seen = set()<br/>            if ti&gt;=R or tj&gt;=C or grid[ti][tj]=='#':return False<br/>            open_list = [(i,j)]<br/>            while open_list:<br/>                i,j = open_list.pop()<br/>                if (i,j)==(ti,tj):return True<br/>                seen.add((i, j))<br/>                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:<br/>                    r, c = i+di, j+dj<br/>                    if 0&lt;=r&lt;R and 0&lt;=c&lt;C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!='#':<br/>                        open_list.append((r,c))<br/>            return False<br/>                        <br/>                <br/>        def bfs(i, j, pi, pj):<br/>            b_seen = set()<br/>            cur_level = {(i,j, pi, pj, 0)}<br/>            while cur_level:<br/>                nxt_level = set()<br/>                for i, j, pi, pj, d in cur_level:<br/>                    b_seen.add((i,j, pi, pj))<br/>                    if grid[i][j] == 'T':return d<br/>                    for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:<br/>                        r, c = i+di, j+dj<br/>                        if 0&lt;=r&lt;R and 0&lt;=c&lt;C and grid[r][c]!='#' and (r,c, i, j) not in b_seen:<br/>                            ti, tj = i-di, j-dj<br/>                            if dfs_person(pi, pj, ti, tj, i, j):<br/>                                nxt_level.add((r,c,i, j, d+1))<br/>                cur_level = nxt_level      <br/>            return -1<br/>        return bfs(bi, bj, pi, pj)</span></pre><p id="67a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案3(BFS +联合查找运行时间1608毫秒)</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="aab3" class="jq jr hi jm b fi js jt l ju jv">class Solution:<br/>    def minPushBox(self, grid: List[List[str]]) -&gt; int:<br/>        R, C = len(grid), len(grid[0])<br/>        self.uf = {}<br/>        for i in range(R):<br/>            for j in range(C):<br/>                if grid[i][j] == 'S':<br/>                    pi, pj = i, j<br/>                elif grid[i][j] == 'B':<br/>                    bi, bj = i, j<br/>        def find(x):<br/>            self.uf.setdefault(x, x)<br/>            if self.uf[x] != x:<br/>                self.uf[x] = find(self.uf[x])<br/>            return self.uf[x]<br/>            <br/>        def union(x, y):<br/>            self.uf[find(y)] = find(x)<br/>                 <br/>        def union_find(i, j, bi, bj):<br/>            open_list = [(i,j)]<br/>            seen = set()<br/>            while open_list:<br/>                i,j = open_list.pop()<br/>                seen.add((i, j))<br/>                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:<br/>                    r, c = i+di, j+dj<br/>                    if 0&lt;=r&lt;R and 0&lt;=c&lt;C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!='#':<br/>                        union((i, j), (r, c))<br/>                        open_list.append((r, c))                   <br/>                <br/>        def bfs(i, j, pi, pj):<br/>            b_seen = set()<br/>            cur_level = {(i,j, pi, pj, 0)}<br/>            while cur_level:<br/>                nxt_level = set()<br/>                for i, j, pi, pj, d in cur_level:<br/>                    b_seen.add((i,j, pi, pj))<br/>                    if grid[i][j] == 'T':return d<br/>                    children = [(i+di, j+dj, i-di, j-dj) <br/>                                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]<br/>                                if 0&lt;=i+di&lt;R and 0&lt;=j+dj&lt;C and grid[i+di][j+dj]!='#' and (i+di, j+dj, i, j) not in b_seen]<br/>                    if children:<br/>                        self.uf = {}<br/>                        union_find(pi, pj , i, j)<br/>                        for r, c, ti, tj in children:<br/>                            if find((ti, tj)) == find((pi, pj)):<br/>                                nxt_level.add((r,c,i, j, d+1))<br/>                cur_level = nxt_level      <br/>            return -1<br/>        return bfs(bi, bj, pi, pj)</span></pre><p id="1bd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案4(BFS + DFS TLE)这个解决方案的原因可能是如果我们在整个列表中保留所有级别的元素，那么open_list太大了。方案二与此方案相比，只改变了open_list部分，只维持当前级别和下一级别。方案2的速度要快得多，可以被接受。</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="cd07" class="jq jr hi jm b fi js jt l ju jv">class Solution:<br/>    def minPushBox(self, grid: List[List[str]]) -&gt; int:<br/>        R, C = len(grid), len(grid[0])<br/>        for i in range(R):<br/>            for j in range(C):<br/>                if grid[i][j] == 'S':<br/>                    pi, pj = i, j<br/>                elif grid[i][j] == 'B':<br/>                    bi, bj = i, j<br/>                 <br/>        def dfs_person(i, j, ti, tj, bi, bj):<br/>            seen = set()<br/>            if ti&gt;=R or tj&gt;=C or grid[ti][tj]=='#':return False<br/>            open_list = [(i,j)]<br/>            while open_list:<br/>                i,j = open_list.pop()<br/>                if (i,j)==(ti,tj):return True<br/>                seen.add((i, j))<br/>                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:<br/>                    r, c = i+di, j+dj<br/>                    if 0&lt;=r&lt;R and 0&lt;=c&lt;C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!='#':<br/>                        open_list.append((r,c))<br/>            return False                     <br/>                <br/>        def bfs(i, j, pi, pj):<br/>            b_seen = set()<br/>            open_list = [(i,j, pi, pj, 0)]<br/>            for i, j, pi, pj, d in open_list:<br/>                b_seen.add((i,j, pi, pj))<br/>                if grid[i][j] == 'T':return d<br/>                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:<br/>                    r, c = i+di, j+dj<br/>                    if 0&lt;=r&lt;R and 0&lt;=c&lt;C and grid[r][c]!='#' and (r,c, i, j) not in b_seen:<br/>                        ti, tj = i-di, j-dj<br/>                        if dfs_person(pi, pj, ti, tj, i, j):<br/>                            open_list.append((r,c,i, j, d+1))    <br/>            return -1<br/>        return bfs(bi, bj, pi, pj)</span></pre><p id="fdb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，解决方案4 get TLE并不是因为open_list太大。原因是太多的重复值被放入开放列表。当将代码更改为以下代码时，它可以工作，运行时间为348毫秒。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="97d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案5 (BFS + DFS返回一个可见集788毫秒)在这种情况下，联合查找似乎比DFS慢。</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="10a2" class="jq jr hi jm b fi js jt l ju jv">class Solution:<br/>    def minPushBox(self, grid: List[List[str]]) -&gt; int:<br/>        R, C = len(grid), len(grid[0])<br/>        for i in range(R):<br/>            for j in range(C):<br/>                if grid[i][j] == 'S':<br/>                    pi, pj = i, j<br/>                elif grid[i][j] == 'B':<br/>                    bi, bj = i, j<br/>                 <br/>        def dfs_person(i, j, bi, bj):<br/>            seen = set()<br/>            open_list = [(i,j)]<br/>            while open_list:<br/>                i,j = open_list.pop()<br/>                seen.add((i, j))<br/>                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:<br/>                    r, c = i+di, j+dj<br/>                    if 0&lt;=r&lt;R and 0&lt;=c&lt;C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!='#':<br/>                        open_list.append((r,c))<br/>            return seen                     <br/>                <br/>        def bfs(i, j, pi, pj):<br/>            b_seen = set()<br/>            cur_level = {(i,j, pi, pj, 0)}<br/>            while cur_level:<br/>                nxt_level = set()<br/>                for i, j, pi, pj, d in cur_level:<br/>                    b_seen.add((i,j, pi, pj))<br/>                    if grid[i][j] == 'T':return d<br/>                    children = [(i+di, j+dj, i-di, j-dj) <br/>                                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]<br/>                                if 0&lt;=i+di&lt;R and 0&lt;=j+dj&lt;C and grid[i+di][j+dj]!='#' and (i+di, j+dj, i, j) not in b_seen]<br/>                    if children:<br/>                        seen = dfs_person(pi, pj , i, j)<br/>                        for r, c, ti, tj in children:<br/>                            if (pi, pj) in seen and (ti, tj ) in seen:<br/>                                nxt_level.add((r,c,i, j, d+1))<br/>                cur_level = nxt_level      <br/>            return -1<br/>        return bfs(bi, bj, pi, pj)</span></pre><p id="2b18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案6 (BFS + DFS将DFS的open_list的数据类型从list改为set runtime 192 ms)不知道为什么它能有如此显著的加速。列表和集合之间的追加、遍历和弹出速度应该不会太快。这部分还是不清楚。</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="d147" class="jq jr hi jm b fi js jt l ju jv">class Solution:<br/>    def minPushBox(self, grid: List[List[str]]) -&gt; int:<br/>        R, C = len(grid), len(grid[0])<br/>        for i in range(R):<br/>            for j in range(C):<br/>                if grid[i][j] == 'S':<br/>                    pi, pj = i, j<br/>                elif grid[i][j] == 'B':<br/>                    bi, bj = i, j<br/>                 <br/>        def dfs_person(i, j, ti, tj, bi, bj):<br/>            seen = set()<br/>            if ti&gt;=R or tj&gt;=C or grid[ti][tj]=='#':return False<br/>            open_list = {(i,j)}<br/>            while open_list:<br/>                i,j = open_list.pop()<br/>                if (i,j)==(ti,tj):return True<br/>                seen.add((i, j))<br/>                for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:<br/>                    r, c = i+di, j+dj<br/>                    if 0&lt;=r&lt;R and 0&lt;=c&lt;C and (r,c)!=(bi,bj) and (r,c) not in seen and grid[r][c]!='#':<br/>                        open_list.add((r,c))<br/>            return False<br/>                        <br/>                <br/>        def bfs(i, j, pi, pj):<br/>            b_seen = set()<br/>            cur_level = {(i,j, pi, pj, 0)}<br/>            while cur_level:<br/>                nxt_level = set()<br/>                for i, j, pi, pj, d in cur_level:<br/>                    b_seen.add((i,j, pi, pj))<br/>                    if grid[i][j] == 'T':return d<br/>                    for di, dj in [(1, 0),(-1, 0), (0, 1), (0, -1)]:<br/>                        r, c = i+di, j+dj<br/>                        if 0&lt;=r&lt;R and 0&lt;=c&lt;C and grid[r][c]!='#' and (r,c, i, j) not in b_seen:<br/>                            ti, tj = i-di, j-dj<br/>                            if dfs_person(pi, pj, ti, tj, i, j):<br/>                                nxt_level.add((r,c,i, j, d+1))<br/>                cur_level = nxt_level      <br/>            return -1<br/>        return bfs(bi, bj, pi, pj)</span></pre><p id="0609" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这篇文章，希望读者能更好地理解BFS、DFS和union-find之间的区别和联系。</p></div></div>    
</body>
</html>