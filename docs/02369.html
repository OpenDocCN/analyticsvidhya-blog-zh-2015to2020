<html>
<head>
<title>Asynchronous Programming in Python — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的异步编程—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/asynchronous-programming-in-python-part-1-86d48b23e387?source=collection_archive---------6-----------------------#2019-12-13">https://medium.com/analytics-vidhya/asynchronous-programming-in-python-part-1-86d48b23e387?source=collection_archive---------6-----------------------#2019-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2194" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章基本介绍了在<code class="du jd je jf jg b">python</code>中<code class="du jd je jf jg b">asynchronous</code>编程的内容和原因。</p><p id="ad54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AsyncIO在哪里？</p><p id="b840" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们开始之前，让我们了解一下编程世界中的一些执行范例。</p><p id="1102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">parallelism</code>同时执行多项操作。</p><p id="32ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">concurrency</code>在重叠的时间框架内执行多项任务的方式是否给人一种近乎并行执行的错觉。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/a5987f2b55cedc812b1b5c8344840594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9Xl0-QbWzsMJt63qq9gLA.png"/></div></div></figure><p id="f877" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">multiprocessing</code>是<code class="du jd je jf jg b">parallelism</code>的一种方式，可以通过催生多个进程来利用CPU上的多个内核。</p><p id="c0d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">threading</code>和<code class="du jd je jf jg b">asyncio</code>是<code class="du jd je jf jg b">concurrency</code>的一种方式，可以在一些任务被IO绑定的情况下，以重叠的方式执行多个操作。</p><p id="13f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么构成了</strong>的核心<code class="du jd je jf jg b"><strong class="ih hj">asyncio?</strong></code></p><ol class=""><li id="dc57" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated"><code class="du jd je jf jg b">EventLoop</code>是Python中<code class="du jd je jf jg b">asyncio</code>的核心。它管理、分配不同任务之间的执行和控制流程。</li><li id="cadf" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><code class="du jd je jf jg b">coroutine</code>是一种特殊类型的Python生成器，它在遇到<code class="du jd je jf jg b">await</code>关键字时将控制返回给事件循环。</li><li id="50a0" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><code class="du jd je jf jg b">Coroutine</code>应该服从关键字<code class="du jd je jf jg b">async</code>和<code class="du jd je jf jg b">await</code></li></ol><pre class="ji jj jk jl fd kh jg ki kj aw kk bi"><span id="e168" class="kl km hi jg b fi kn ko l kp kq"><strong class="jg hj">import </strong>asyncio<br/><strong class="jg hj">import </strong>datetime<br/><br/><br/><strong class="jg hj">async def </strong>task(duration):<br/>    print(<strong class="jg hj">"starting task"</strong>, datetime.datetime.now())<br/>    <strong class="jg hj">await </strong>asyncio.sleep(duration) <em class="kr"># or do some IO operation<br/>    </em>print(<strong class="jg hj">"stopping task"</strong>, datetime.datetime.now())<br/><br/><br/><strong class="jg hj">async def </strong>main():<br/>    # We execute 2 task with sleep duration of 5 seconds and 10 seconds.<br/>    <strong class="jg hj">await </strong>asyncio.gather(task(5), task(10))<br/><br/><strong class="jg hj">if </strong>__name__ == <strong class="jg hj">"__main__"</strong>:<br/>    <strong class="jg hj">import </strong>time<br/>    s = time.perf_counter()<br/>    asyncio.run(main())<br/>    elapsed = time.perf_counter() - s<br/>    print(<strong class="jg hj">f"{</strong>__file__<strong class="jg hj">} executed in {</strong>elapsed<strong class="jg hj">:0.2f} seconds."</strong>)</span></pre><p id="7c4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出</strong></p><pre class="ji jj jk jl fd kh jg ki kj aw kk bi"><span id="aee0" class="kl km hi jg b fi kn ko l kp kq"><strong class="jg hj">starting task 2019-12-12 18:10:03.103732<br/>starting task 2019-12-12 18:10:03.103732<br/>stopping task 2019-12-12 18:10:08.105232<br/>stopping task 2019-12-12 18:10:13.100231<br/>C:/Users/bakthavatchalam.g/asynchronous.py executed in 10.00 seconds.</strong></span></pre><p id="0a80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们一步一步地深入研究代码。</p><ol class=""><li id="4735" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">当你用<code class="du jd je jf jg b">async</code>关键字声明一个函数时，你是在告诉<code class="du jd je jf jg b">eventloop</code>这个函数是一个异步生成器或者一个协同程序。</li><li id="4488" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">当你用<code class="du jd je jf jg b">await</code>关键字声明一个表达式时，你是在告诉<code class="du jd je jf jg b">eventloop</code>暂停当前操作，让别的东西运行，直到结果到达【https://docs.python.org/3/library/asyncio-task.html#id2】对象(<a class="ae ks" href="https://docs.python.org/3/library/asyncio-task.html#id2" rel="noopener ugc nofollow" target="_blank"/>)。</li><li id="e804" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><code class="du jd je jf jg b"><strong class="ih hj">asyncio.gather</strong></code> <strong class="ih hj"> </strong>是管理和运行协同程序的高级API(<a class="ae ks" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/library/asyncio-task . html # asyncio . gather</a>)</li></ol><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es kt"><img src="../Images/2c123620a717d2c3121bc7b362443a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*frETB534XGOkTbXgAcctiA.png"/></div></figure><p id="4065" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">同步方式的相同代码</strong></p><pre class="ji jj jk jl fd kh jg ki kj aw kk bi"><span id="940e" class="kl km hi jg b fi kn ko l kp kq"><strong class="jg hj">import </strong>datetime<br/><strong class="jg hj">import </strong>time<br/></span><span id="530b" class="kl km hi jg b fi ku ko l kp kq"><strong class="jg hj">def </strong>task(duration):<br/>    print(<strong class="jg hj">"starting task"</strong>, datetime.datetime.now())<br/>    time.sleep(duration) <em class="kr"># or do some IO operation<br/>    </em>print(<strong class="jg hj">"stopping task"</strong>, datetime.datetime.now())<br/><br/><br/><strong class="jg hj">def </strong>main():<br/>    <strong class="jg hj">task(5)<br/>    task(10)</strong></span><span id="4890" class="kl km hi jg b fi ku ko l kp kq"><strong class="jg hj"><br/>if </strong>__name__ == <strong class="jg hj">"__main__"</strong>:<br/>    s = time.perf_counter()<br/>    main()<br/>    elapsed = time.perf_counter() - s<br/>    print(<strong class="jg hj">f"{</strong>__file__<strong class="jg hj">} executed in {</strong>elapsed<strong class="jg hj">:0.2f} seconds."</strong>)</span></pre><p id="e500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出</strong></p><pre class="ji jj jk jl fd kh jg ki kj aw kk bi"><span id="a485" class="kl km hi jg b fi kn ko l kp kq"><strong class="jg hj">starting task 2019-12-12 18:16:34.553006<br/>stopping task 2019-12-12 18:16:39.554006<br/>starting task 2019-12-12 18:16:39.554006<br/>stopping task 2019-12-12 18:16:49.556006<br/>C:/Users/bakthavatchalam.g/synchronous.py executed in 15.00 seconds.</strong></span></pre><p id="f090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然，当我们以同步的方式做同样的事情时，对于运行同样的操作，代码的运行时间将是5 + 10 -&gt; 15秒。</p><p id="8ad4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">螺纹版本</strong></p><pre class="ji jj jk jl fd kh jg ki kj aw kk bi"><span id="59d0" class="kl km hi jg b fi kn ko l kp kq"><strong class="jg hj">import </strong>datetime<br/><strong class="jg hj">import </strong>threading<br/><strong class="jg hj">import </strong>time</span><span id="601c" class="kl km hi jg b fi ku ko l kp kq"><strong class="jg hj">def </strong>task(duration):<br/>    print(<strong class="jg hj">"starting task"</strong>, datetime.datetime.now())<br/>    time.sleep(duration) <em class="kr"># or do some IO operation<br/>    </em>print(<strong class="jg hj">"stopping task"</strong>, datetime.datetime.now())</span><span id="3505" class="kl km hi jg b fi ku ko l kp kq"><strong class="jg hj">def </strong>main():<br/>    t1 = threading.Thread(target=task, args=(5,))<br/>    t2 = threading.Thread(target=task, args=(10,))<br/>    t1.start()<br/>    t2.start()<br/>    t1.join()<br/>    t2.join()</span><span id="e108" class="kl km hi jg b fi ku ko l kp kq"><strong class="jg hj">if </strong>__name__ == <strong class="jg hj">"__main__"</strong>:<br/>    s = time.perf_counter()<br/>    main()<br/>    elapsed = time.perf_counter() - s<br/>    <strong class="jg hj">print</strong>(<strong class="jg hj">f"{</strong>__file__<strong class="jg hj">} executed in {</strong>elapsed<strong class="jg hj">:0.2f} seconds."</strong>)</span></pre><p id="1369" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出</strong></p><pre class="ji jj jk jl fd kh jg ki kj aw kk bi"><span id="8983" class="kl km hi jg b fi kn ko l kp kq"><strong class="jg hj">starting task 2019-12-13 12:44:38.243503<br/>starting task 2019-12-13 12:44:38.244003<br/>stopping task 2019-12-13 12:44:43.244503<br/>stopping task 2019-12-13 12:44:48.246003<br/>C:/Users/bakthavatchalam.g/thread.py executed in 10.00 seconds.</strong></span></pre><p id="6cef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">那么，</strong> <code class="du jd je jf jg b"><strong class="ih hj">asyncio</strong></code> <strong class="ih hj">和</strong> <code class="du jd je jf jg b"><strong class="ih hj">threading?</strong></code>有什么不同呢</p><p id="a532" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，要知道区别，你必须知道<code class="du jd je jf jg b">multithreading</code>在python中是如何工作的。下图说明了同样的情况。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es kv"><img src="../Images/dc9c97fdb0e6c89b037f872c08e1a831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ps153JpjI81PwCLsq39RMQ.png"/></div></div></figure><p id="cfba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">threading</code>和<code class="du jd je jf jg b">asyncio</code>都适合IO绑定代码。</p><p id="1c61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主要区别在于，</p><ol class=""><li id="f1eb" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">在<code class="du jd je jf jg b">threading</code>中，线程的执行和交换不是我们可以控制的。</li><li id="a9e2" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">由于<code class="du jd je jf jg b">threads</code>使用相同的内存，在它们之间共享对象有点棘手。意味着，那些对象必须<code class="du jd je jf jg b">thread-safe.</code>例如，一个<code class="du jd je jf jg b">queue</code></li><li id="d48b" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">很难理解线程如何运行以及它们的顺序，因此很难发现任何错误。例如，如果多个线程正在访问和更改一个<code class="du jd je jf jg b">non-thread safe </code>全局变量，有时可能会导致不一致的结果。</li></ol><p id="d489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用</strong> <code class="du jd je jf jg b"><strong class="ih hj">asyncio</strong></code> <strong class="ih hj">优于</strong> <code class="du jd je jf jg b"><strong class="ih hj">threading are</strong></code>的优势</p><ol class=""><li id="0c02" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">它让开发人员对任务的执行有更多的控制权</li><li id="75ee" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">管理任务之间的对象变得更加容易，并且不用担心竞争条件(<a class="ae ks" href="https://stackoverflow.com/questions/34510/what-is-a-race-condition" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/34510/what-is-a-race-condition</a>)</li><li id="c46f" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">代码可读性更强，重量更轻。</li><li id="a030" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">越来越多的库支持<code class="du jd je jf jg b">async &amp; await.</code>的<code class="du jd je jf jg b">asyncio</code>协议</li></ol><p id="ff03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">缺点</strong></p><ol class=""><li id="8e1f" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">主要适用于操作受限于IO的情况。当操作变得CPU密集型时，<code class="du jd je jf jg b">multiprocessing</code>成为更好的选择。</li><li id="8484" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><code class="du jd je jf jg b">async/await</code>应在非阻塞调用之前使用。换句话说，我们应该找到支持<code class="du jd je jf jg b">async/await</code>语法的特定包装器。</li></ol><p id="4819" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对于支持</strong> <code class="du jd je jf jg b"><strong class="ih hj">asyncio</strong></code> <strong class="ih hj">的库，请看下面来自</strong><code class="du jd je jf jg b"><strong class="ih hj">timofurrer</strong></code><a class="ae ks" href="https://github.com/timofurrer/awesome-asyncio" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">(https://github.com/timofurrer/awesome-asyncio</strong></a><strong class="ih hj">)</strong>的github项目</p><p id="4702" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一部分，我们可以看到一个使用<code class="du jd je jf jg b">asyncio</code>的更实际的例子，以及它如何提高代码的性能。敬请期待！</p></div></div>    
</body>
</html>