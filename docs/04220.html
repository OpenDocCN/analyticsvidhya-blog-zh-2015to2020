<html>
<head>
<title>How to Build your First Real-Time Streaming(CDC) system(Introduction-Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建您的第一个实时流(CDC)系统(简介-第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-build-your-first-real-time-streaming-cdc-system-introduction-part-1-5d61b2d9d511?source=collection_archive---------8-----------------------#2020-03-10">https://medium.com/analytics-vidhya/how-to-build-your-first-real-time-streaming-cdc-system-introduction-part-1-5d61b2d9d511?source=collection_archive---------8-----------------------#2020-03-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/982af29c2f985e96c1e22851a76ae915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iByscJ9wyp551cAwnPQgFQ.jpeg"/></div></div></figure><h1 id="9877" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="c5f5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">随着数据的指数级增长和大量业务转移到网上，<strong class="jq hj">设计能够以<strong class="jq hj">实时</strong>或接近实时的方式做出任何业务决策的系统</strong>已经变得势在必行。因此，在多年从事多个后端项目后，我终于开始构建一个<strong class="jq hj">实时流媒体平台</strong>。在做这个项目的时候，我开始尝试不同的技术来处理这个问题。因此，我试图在一系列文章中分享我的心得。这是其中的第一个。</p><p id="87b4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">此外，在本系列中，主要焦点将是如何做而不是如何做。我们将花大部分时间学习如何实现我们的用例。然而，我会在需要的时候讲述一些理论。</p><h1 id="8246" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">目标受众:</h1><p id="5137" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这篇文章的目标读者是那些已经熟悉微服务、java编程语言，并希望构建他们的第一个实时流管道的工程师。为了便于阅读，本POC分为4篇文章。它们如下:-</p><ul class=""><li id="212f" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated"><strong class="jq hj">第一篇文章(当前文章)</strong>包含基本概念、问题陈述、技术堆栈和我们需要了解的关于我们正在构建的东西的一切。</li><li id="0bab" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><a class="ae lf" rel="noopener" href="/@rohan.mudaliar/how-to-build-your-first-real-time-streaming-cdc-system-setup-part-2-bac2c5397d5e"> <strong class="jq hj">第2篇(系统设置)</strong> </a>将包含为Binlogs和docker基础设施设置设置MySql数据库的步骤。我们还将介绍如何使用Kafka connect创建Kafka主题。</li><li id="b6f1" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><a class="ae lf" rel="noopener" href="/analytics-vidhya/how-to-build-your-first-real-time-streaming-cdc-system-kafka-steams-and-aggregation-part-3-8a331e98961d"> <strong class="jq hj">第3条(Kafka流和聚合)</strong> </a> <strong class="jq hj"> </strong>将包含java后端代码，我们在其中监听Kafka主题以创建/更新Elasticsearch中的聚合指数。</li><li id="279b" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj">第4篇文章(验证和运行您的代码)</strong>将包含使用Kibana下载最终汇总报告、在本地运行代码以及使用Kibana验证实时流系统的步骤。</li></ul><h1 id="a06d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">期待什么:</h1><p id="16f9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">关于如何构建实时流(CDC)管道的概念验证。需要在优化方面做出努力，以使其为生产做好准备。</p><h1 id="3a84" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">问题陈述</h1><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/89e086012bb51c74ddc625410d6d64a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*o0YDlKrilQGJzWH7TGz0fg.jpeg"/></div></figure><p id="1b1e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设你在一家销售时尚产品的电子商务公司工作。您的业务团队希望根据后端系统上的实时更新做出一些决策。他们希望查看一些仪表板和视图。因此，让我们假设后端构建在微服务架构上，在任何用户操作期间，您都有多个系统相互交互，并且每个系统都与不同的数据库交互。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/f5b28ece65d30961008ba13820e9d1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOIenWSvxFLCI-Iv0OoOGA.jpeg"/></div></div></figure><p id="2c2e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们考虑一下POC中的三个系统。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/a6df44677c0c5bd7a57ef05b0cc073ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*FCaGwSHwknLGqKVDB4H1iw.jpeg"/></div></figure><p id="007c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">对于这个例子，业务团队想要创建一个出站仪表板。其中包含订单数量、售出商品的类型、每件商品的成本以及商品的运输成本。这将在多个系统中基于用户和真实世界的动作在任何时间点不断更新，如下所示。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/50db94d03f02b503a68d21838fca79ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*IcZZBSPftOpirhSdU0O5hQ.png"/></div></figure><p id="2e00" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一旦客户做出选择并付款，订单就被送到仓库，商品从那里被发送给客户。考虑在每个动作之后，一个系统将被实时更新。</p><p id="f824" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们看看业务团队需要的数据类型</p><ul class=""><li id="cfeb" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">每个仓库每个物料类型每天的发货单位。</li><li id="e61f" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">每个快递公司每天发货的订单。</li><li id="10c2" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">每个仓库每天装运的物品的总成本。</li></ul><p id="b13e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们知道这些数据存在于订单服务、仓储服务和物流服务中。假设他们都在使用MySQL数据库，并且都是实时更新的。现在，我们已经看了用例，让我们思考一下如何解决这个问题。</p><p id="dce4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">可能的解决方案</strong>:我们需要找到一种方法来捕获发生在不同服务的不同数据库中的所有更新/插入，并将其放在一个地方，从那里我们可以构建一些报告并进行一些分析。所以这就是<strong class="jq hj"> Kafka Connect和Debezium </strong>的用武之地。</p><h1 id="8976" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">了解CDC、Mysql Binlogs、Debezium和一些基本概念:</h1><p id="2239" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">因此，在我们开始实现这个系统之前，我们需要理解几个概念。它们如下:-</p><p id="e4f7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">更改数据捕获:</strong></p><p id="5ca4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">变更数据捕获(<a class="ae lf" href="https://en.wikipedia.org/wiki/Change_data_capture" rel="noopener ugc nofollow" target="_blank"> CDC </a>)跟踪数据变更(通常接近实时)。CDC可用于各种任务，如审计、将数据复制到另一个系统或处理(和响应)事件。在MySQL中，跟踪数据变化最简单也可能是最有效的方法是使用二进制日志。</p><p id="d50d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj"> MySQL Binlogs </strong></p><p id="7971" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">二进制日志是一组日志文件，包含有关对MySQL服务器实例进行的数据修改的信息。通过使用<code class="du lo lp lq lr b">--log-bin</code>选项启动服务器来启用日志。</p><p id="ccf6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">MySQL 3.23.14中引入了二进制日志。它包含所有更新数据的语句。除非使用基于行的日志记录，否则它还包含可能更新它的语句(例如，不匹配任何行的<code class="du lo lp lq lr b">DELETE</code>)。语句以描述修改的“事件”的形式存储。</p><p id="7aca" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">作战日志:</strong></p><p id="dbc6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">与MySQL Binlogs类似，MongoDB有一个叫做Oplogs的东西，它与Binlogs类似，用于CDC。</p><p id="046c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj"> Debezium: </strong></p><p id="2973" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Debezium是一组分布式服务，用于捕获数据库中的变化，以便您的应用程序可以看到这些变化并做出响应。Debezium在一个<em class="ls">变更事件流</em>中记录每个数据库表中的所有行级变更，应用程序只需读取这些流，就可以按照事件发生的顺序查看变更事件。</p><p id="d725" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">流处理、实时处理和复杂事件处理</strong></p><p id="318a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在我们深入问题陈述之前，我想提出的一件事是，在这个概念验证中，我正在构建一个复杂事件处理(CEP)系统。流处理、实时处理和复杂事件处理之间有非常细微的差别。它们如下:-</p><ul class=""><li id="5a70" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated"><strong class="jq hj">流处理:</strong>流处理对于欺诈检测和网络安全等任务非常有用。如果交易数据是流处理的，欺诈性交易甚至可以在完成之前就被识别和阻止。</li><li id="f94a" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj">实时处理:</strong>如果事件时间非常相关，并且秒范围内的延迟完全不可接受，则称之为实时(后方实时)处理。太空计划的飞行控制系统</li><li id="d776" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hj">复杂事件处理(CEP): </strong> CEP利用逐个事件的处理和聚合(例如，来自各种来源的潜在无序事件，通常具有大量规则或业务逻辑)。</li></ul><p id="d09b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这更多地取决于业务用例。相同的技术栈可以用于流处理以及实时处理。</p><h1 id="114b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">技术堆栈:</strong></h1><p id="89db" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在，我们已经对我们想要实现的目标和所涉及的概念有了一个总体的了解，下一步是了解总体的技术任务和我们将用来构建系统的技术堆栈。我们来看看同样的。</p><p id="ae40" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们深入了解一下我们将在本次概念验证中使用的技术。它们如下:-</p><ul class=""><li id="7dea" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">MySQL 8.0.18</li><li id="7093" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">阿帕奇卡夫卡连接1.1</li><li id="e78f" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">阿帕奇卡夫卡</li><li id="873a" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">阿帕奇卡夫卡流2.3.1</li><li id="ea4d" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">弹性搜索7.5.1</li><li id="4cc3" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">基巴纳语7.5.1</li><li id="283c" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">19.03.5</li><li id="bab0" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">Swagger UI</li><li id="25f3" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">邮递员7.18.1</li></ul><h1 id="e572" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">总体技术任务:</h1><p id="b6c9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">因此，就整体任务而言，我们将把它们划分如下</p><ol class=""><li id="01a9" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl lt kx ky kz bi translated">使用docker设置本地基础设施。</li><li id="b3f9" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lt kx ky kz bi translated">使用Kafka connect将数据从MySQL数据库摄取到Kafka。</li><li id="285b" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lt kx ky kz bi translated">在Java后端使用Kafka流读取数据。</li><li id="a8b3" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lt kx ky kz bi translated">为聚集视图创建弹性搜索索引。</li><li id="8847" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lt kx ky kz bi translated">实时收听事件并更新事件。</li><li id="ae8f" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lt kx ky kz bi translated">设置本地并运行java代码</li></ol><h1 id="f831" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">总结和后续步骤:</strong></h1><p id="d010" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">所以在这篇文章中，我们看了下面的内容</p><ul class=""><li id="0927" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">我们理解了问题陈述，并研究了可能的解决方案。</li><li id="b6ad" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">了解我们的解决方案所需的不同概念。</li><li id="c69e" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">我们查看了解决方案的技术堆栈</li></ul><p id="f86d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">接下来的步骤:</strong>在<strong class="jq hj">的下一篇文章</strong>中，我们将看看<strong class="jq hj">如何</strong>到<strong class="jq hj">设置MySQL数据库</strong>以编写BinLogs，以及<strong class="jq hj"> docker设置</strong>以在我们的本地系统中创建所需的基础设施。</p><blockquote class="lu"><p id="8bee" class="lv lw hi bd lx ly lz ma mb mc md kl dx translated">如果你喜欢这篇文章，请阅读后面的文章并分享你的反馈。在领英上  <a class="ae lf" href="https://www.linkedin.com/in/rohanganesh0506/" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> <em class="me">找我rohan _ LinkedIn</em></strong></a><strong class="ak"><em class="me">。</em>T25】</strong></p></blockquote></div></div>    
</body>
</html>