<html>
<head>
<title>Integer Programming for Graph Theory and Others with Python: 03 — Minimum Spanning Tree and Travelling Salesman</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现图论及其它的整数规划:03 —最小生成树和旅行推销员</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/integer-programming-for-graph-theory-and-others-with-python-03-minimum-spanning-tree-and-42a5bd75b663?source=collection_archive---------29-----------------------#2020-04-06">https://medium.com/analytics-vidhya/integer-programming-for-graph-theory-and-others-with-python-03-minimum-spanning-tree-and-42a5bd75b663?source=collection_archive---------29-----------------------#2020-04-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/db4c1d4dd18f8126da51074384232795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHMdtPbTJj6_1vaSAZWkVQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">《塞尔达传说》中的大德库树，由洛克沃克绘制</figcaption></figure><p id="38a1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">大家好！我很高兴你看到了我系列的第三集！今天我们将解决图论中的两个一般性问题，并看看如何用整数编程来解决它们！</p><h1 id="6507" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">最小生成树</h1><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/a43c1135854d4b73e0797caba1233736.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*bhYz_yG-6y2frbanTyE_wQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用于这个最小生成树问题的图</figcaption></figure><p id="1070" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里的目标是以尽可能低的成本直接或间接连接所有节点，而不需要<strong class="iw hj">产生循环</strong>。换句话说，最小化所用边的总成本。既然我们已经得出了这个结论，下面是变量声明和目标函数的代码:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="6d4c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">看一个有5个节点的无向图，我们很容易看出，我们只需要4条边就可以把它们全部连接起来，对吗？如果我们有2个节点，我们只需要1条边来连接它们。如果我们添加另一个节点，我们需要向其中一个连接的节点和新节点添加另一条边。所以，规则是:</p><pre class="kr ks kt ku fd kx ky kz la aw lb bi"><span id="726d" class="lc jt hi ky b fi ld le l lf lg">For a graph with N nodes, you need N-1 edges to build its Minimum Spanning Tree</span></pre><p id="b6b4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是约束的代码:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="8fab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们只需要确保每个节点至少有一条边与之相连:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="2cd5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，边的数量是固定的，所有节点必须至少有一条边与之相连。这就是给我们最优解所需要的，对吗？</p><p id="9a89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="lh">！！！不对！！！</em> </strong></p><p id="72c9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的模型可能在某些场景下有效，但不是所有的场景。为什么？因为它不能保证<strong class="iw hj">没有周期</strong>。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/2e68fcce996cd9f8b6c5b8f891bfd247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4u7VU3SkGs2KcANHnDzQw.jpeg"/></div></div></figure><p id="6f30" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">如何预防周期？</strong></p><p id="868f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好吧，这听起来有点昂贵，但实际上是这样做的:如果有一个圈，这意味着有一个N个节点的子图，它有N条边。所以我们需要保证，对于任意一个N节点的子图，边的和小于或等于N-1。这将会有很多代码，但只是重复的:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="5847" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是我们，完整的模型编码。如果我们运行它，我们最终得到我们的最小生成树:</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/21dfc4bd21ab41cb170c12b42a8aac0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*GiEgbhuNKirVy4RSo9nx_w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">最小生成树问题的最终解决方案</figcaption></figure><h2 id="930d" class="lc jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">可扩展性问题</h2><p id="05fe" class="pw-post-body-paragraph iu iv hi iw b ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr hb bi translated">有13个子图没有被使用，因为原始图没有那么多的边，但是如果我们处理一个完整的图(所有节点都直接相互连接)，将会有13个额外的约束。如果它是一个有6条边的完整图形，那么将有41个约束…</p><p id="3ae2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">…如果该图有7条边，它将有98个约束…</p><p id="8fae" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如你所见，它呈指数增长，所以当图又大又密时，它会成为一个很难解决的问题。不管怎样，这是:D的模型</p><h1 id="e681" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">旅行推销员</h1><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/637fd0ab9f03dd4b4123ce5709830c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LudpWYlf1GBGld7Xr5qRDw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">推销员连环漫画，由丹卡通</figcaption></figure><p id="4d4e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是另一个著名的，也可以说是更著名的，难以解决的问题！它包括找到从一个点到它自己的最短路径，同时访问每个点<strong class="iw hj">仅一次</strong>，就像一个推销员访问每个目的地推销他的产品，最后回到他的房子。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es md"><img src="../Images/6a41506e64da23942c734e261ee8c132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*HwGRnDkVY67osem1r3pu9A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用于旅行推销员问题示例的图形</figcaption></figure><p id="664c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于我们在寻找最短路径，这是一个最小化问题，我们要最小化所用边的总和乘以它们各自的权重。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="bbcc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些限制如下:</p><p id="161b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 1 —边的数量必须等于节点的数量；</strong></p><p id="9b6a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个很明显:想想画多边形:如果它有4个角，你需要4条线，如果它有5个角，你需要5条线…画多边形就像在一个图上画一个旅行推销员的路径，有相同数量的节点/角。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="843a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 2 —任何子图中都不能有圈；</strong></p><p id="f017" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">类似于最小生成树问题的模型，N个节点的所有子图的边数必须小于N。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="bf46" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们运行求解器，我们得到的解是Start-C-B-D-Start，成本为9。这就是我们如何从所有的行走中拯救我们的推销员的腿！</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es md"><img src="../Images/a396ffb04acf117e72f44e40bbd70213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*izutBfcB8LP5bkFyLaxgeg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">旅行推销员问题的解决方案</figcaption></figure><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es me"><img src="../Images/dc651f0b7be72a6a6f0e531b237e78bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*WKQJPV-AuQKFLqXiGNYqAw.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">对旅行推销员来说，每天都是出差日</figcaption></figure><h2 id="7d64" class="lc jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">下一集:无目标函数的整数规划数组排序</h2><p id="e240" class="pw-post-body-paragraph iu iv hi iw b ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr hb bi translated">下次见！:D</p></div></div>    
</body>
</html>