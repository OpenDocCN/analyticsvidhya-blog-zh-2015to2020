<html>
<head>
<title>XGBoost colsample_by* hyperparameters explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XGBoost colsample_by*超参数说明</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/xgboost-colsample-by-hyperparameters-explained-6c0bac1bdc1?source=collection_archive---------1-----------------------#2020-01-17">https://medium.com/analytics-vidhya/xgboost-colsample-by-hyperparameters-explained-6c0bac1bdc1?source=collection_archive---------1-----------------------#2020-01-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/87472515a398ce2bc3b0b359cdf797e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EuMEgDsaGPrqN7wyTN0nqQ.jpeg"/></div></div></figure><p id="3612" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同志们好！</p><p id="7723" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我第一次偶然发现XGBoost的colsample超参数时，我有点困惑它们是如何一起工作的。官方文档很好，但我花了一些时间来完全理解参数之间的差异。本文假设您熟悉XGBoost，并且只关注<strong class="is hj"> colsample_by* </strong>超参数。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="4775" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一个包含16个要素的数据集。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jv"><img src="../Images/fc7f52aa4e3536317fdb2eb3e44d88ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EP2M66FzlEKrMVdRhr_0_Q.png"/></div></div></figure><h1 id="78f4" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">列样本_字节树</h1><p id="63bf" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">我们知道，XGBoost构建了多个树来进行预测。<strong class="is hj"> colsample_bytree </strong>定义了用于构建每棵树的特征(列)的百分比。很明显，每棵树的特性集很可能是不同的(尽管有可能是相同的，但是不太可能是相同的)。为简单起见，让我们使用0.5作为所有参数的默认值。</p><p id="d296" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们将要建造我们的第一棵树。让我们从根节点开始。但是首先我们需要为我们的树过滤随机特征。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/830cc9596fe8f54fce7e5b767c2c39c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFlWZXr9NCcbhAIhttFArg.png"/></div></div></figure><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/8b21b0564710d08fa8d52a8dd01fd726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h2Du6NgJHpjU4z4cCnzr5g.png"/></div></div></figure><h1 id="68cc" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> colsample_bylevel </strong></h1><p id="3e16" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">每当我们在树中达到新的深度级别时，这就会发挥作用。在进行任何进一步的分割之前，我们提取应用<strong class="is hj"> colsample_bytree </strong>后剩下的所有特征，并使用<strong class="is hj"> colsample_bylevel再次过滤它们。</strong>在下一个深度级别，我们重复这一步，这样你就可以在每个级别上获得不同的特征集。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/fe6e44ee709c144316ea095a17b68569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89EnxsxdLKIUSTi_sxPbbA.png"/></div></div></figure><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/0307e563b245e73647ce0da96e56866c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxlKQ5_LduCIWT_-unN-4g.png"/></div></div></figure><h1 id="1f1a" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> colsample_bynode </strong></h1><p id="b242" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">选择特性的最后一个可能步骤是当我们设置<strong class="is hj"> colsample_bynode </strong>超参数时。在进行下一次分割之前，我们过滤掉应用<strong class="is hj"> colsample_bylevel </strong>后剩下的所有特征。我们分别为同一深度级别上的每个分割选择特征。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/9ad362202f8eff0d8a5438dfef11fbf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6A7ZZ8Tmeho0e7xwcFeZCw.png"/></div></div></figure><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/20ff80309289ec823685cb96b4761d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zx6DunKFcGsgrtf6yULoeg.png"/></div></div></figure><p id="c68e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如官方文件所述:</p><blockquote class="lk ll lm"><p id="7c8f" class="iq ir ld is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hb bi translated"><code class="du lq lr ls lt b">colsample_by*</code>参数累积工作。例如，具有64个特征的组合<code class="du lq lr ls lt b">{'colsample_bytree':0.5, 'colsample_bylevel':0.5, 'colsample_bynode':0.5}</code>将在每次分割时留下8个特征供选择。</p></blockquote><h2 id="fdc7" class="lu kb hi bd kc lv lw lx kg ly lz ma kk jb mb mc ko jf md me ks jj mf mg kw mh bi translated">为什么我需要这些参数？</h2><p id="fe61" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">通过限制构建每棵树的特征数量，我们可能最终得到从数据中获得不同见解的树。他们学习如何使用不同的特征集来优化目标变量。因此，如果您有足够的数据，您可以尝试调整<strong class="is hj"> colsample </strong>参数！</p><p id="dbab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这篇文章对你有帮助！</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/37412223fe4e94411ce48d8ca7334772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnCUUHb1glx3AS4U5RWGOw.png"/></div></div></figure></div></div>    
</body>
</html>