<html>
<head>
<title>Computer Vision Tutorial: A Step-by-Step Introduction to Image Segmentation Techniques (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉教程:图像分割技术的逐步介绍(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/computer-vision-tutorial-a-step-by-step-introduction-to-image-segmentation-techniques-part-1-c8a83a4fc9e7?source=collection_archive---------0-----------------------#2019-04-01">https://medium.com/analytics-vidhya/computer-vision-tutorial-a-step-by-step-introduction-to-image-segmentation-techniques-part-1-c8a83a4fc9e7?source=collection_archive---------0-----------------------#2019-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你打算过马路时，你做的第一件事是什么？我们通常会左顾右盼，看看路上的车辆，然后做出决定。我们的大脑能够在几毫秒内分析出哪种交通工具(轿车、公共汽车、卡车、汽车等)。)正向我们走来。机器能做到吗？</p><p id="9316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直到几年前，答案还是斩钉截铁的“不”。但是计算机视觉的兴起和进步已经改变了这个游戏。我们能够建立计算机视觉模型，可以检测物体，确定它们的形状，预测物体前进的方向，以及许多其他事情。你可能已经猜到了——这就是自动驾驶汽车背后的强大技术！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/74947b059531ba80adc52cdb87bd06f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ciq_m_VjUo3x2BO9.png"/></div></div></figure><p id="9f1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，有多种方法来应对计算机视觉的挑战。我遇到的最流行的方法是基于识别图像中存在的对象，也称为对象检测。但是如果我们想潜得更深呢？如果仅仅检测物体是不够的——我们想在更精细的层次上分析我们的图像，那该怎么办？</p><p id="daa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为数据科学家，我们总是好奇于更深入地挖掘数据。问这样的问题是我喜欢在这个领域工作的原因！</p><p id="b049" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将向您介绍图像分割的概念。这是一个强大的<a class="ae jd" href="https://courses.analyticsvidhya.com/courses/computer-vision-using-deep-learning-version2?utm_source=blog&amp;utm_medium=image-segmentation-article" rel="noopener ugc nofollow" target="_blank">计算机视觉算法</a>，它建立在对象检测的理念之上，将我们带到了一个全新的图像数据处理水平。这项技术带来了如此多的可能性——它让我大吃一惊。</p><p id="375b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jq">如果你是深度学习和计算机视觉的新手，我推荐以下资源来了解关键概念:</em></p><ul class=""><li id="0fbb" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated"><a class="ae jd" href="https://courses.analyticsvidhya.com/courses/computer-vision-using-deep-learning-version2?utm_source=blog&amp;utm_medium=image-segmentation-article" rel="noopener ugc nofollow" target="_blank"> <em class="jq">计算机视觉使用深度学习2.0课程</em> </a></li><li id="7ce6" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated"><a class="ae jd" href="https://courses.analyticsvidhya.com/bundles/computer-vision-combo?utm_source=blog&amp;utm_medium=image-segmentation-article" rel="noopener ugc nofollow" target="_blank"> <em class="jq">认证项目:计算机视觉初学者</em> </a></li></ul><h1 id="6d1d" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">目录</h1><ol class=""><li id="7b3e" class="jr js hi ih b ii ld im le iq lf iu lg iy lh jc li jx jy jz bi translated">什么是图像分割？</li><li id="6238" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">为什么我们需要图像分割？</li><li id="ed97" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">不同类型的图像分割</li><li id="5f8e" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">基于区域的分割</li><li id="8327" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">边缘检测分割</li><li id="a763" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">基于聚类的分割</li><li id="b1db" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">脸书的面具R-CNN框架</li><li id="64c7" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">图像分割技术综述</li></ol><h1 id="b359" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">什么是图像分割？</h1><p id="8d33" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">让我们用一个简单的例子来理解图像分割。考虑下图:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lm"><img src="../Images/3f5f2ead0fb129f0cffad1e68ff5553c.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/0*a-ITiLVt9YZ1q1do.jpeg"/></div></figure><p id="72f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里只有一个物体——一只狗。我们可以建立一个简单的猫狗分类器模型，并预测在给定的图像中有一只狗。但是如果我们在一个图像中同时有一只猫和一只狗呢？</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ln"><img src="../Images/8869c8bfa7f7d150d787135d2c7f9741.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/0*kR25UrErhMRj5JeR.jpeg"/></div></figure><p id="2d35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们可以训练一个多标签分类器。现在，还有另一个警告——我们不知道图像中任何一个动物/物体的位置。</p><p id="2018" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是图像本地化的由来(没有双关的意思！).它帮助我们识别给定图像中单个物体的位置。如果我们有多个对象存在，那么我们依赖于<a class="ae jd" href="https://www.analyticsvidhya.com/blog/2018/10/a-step-by-step-introduction-to-the-basic-object-detection-algorithms-part-1/?utm_source=blog&amp;utm_medium=introduction-image-segmentation-techniques-python" rel="noopener ugc nofollow" target="_blank">对象检测</a> (OD)的概念。我们可以使用OD来预测每个对象的位置和类别。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lo"><img src="../Images/47dec3f7f2eb6220282622cdf05d3427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/0*T1EQiEJ5EHISvXx6.png"/></div></figure><p id="f030" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在检测物体之前，甚至在对图像进行分类之前，我们需要了解图像是由什么组成的。输入—图像分割。</p><h1 id="9830" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">那么图像分割是如何工作的呢？</h1><p id="c6d7" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">我们可以将图像分割成不同的部分，称为片段。同时处理整个图像不是一个好主意，因为图像中会有不包含任何信息的区域。通过将图像分割成片段，我们可以利用重要的片段来处理图像。简而言之，这就是图像分割的工作原理。</p><p id="7cfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像是不同像素的集合或集合。我们使用图像分割将具有相似属性的像素组合在一起。花点时间浏览下面的视频(它会给你一个实际的图像分割的想法):</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lp"><img src="../Images/fce18fe638d2a529d7b6e150a06bdfcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*FHcmbpBr-ISsW2k0.jpg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">【cs231n.stanford.edu】来源:T2</figcaption></figure><p id="d10a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对象检测建立对应于图像中每个类别的边界框。但是它没有告诉我们物体的形状。我们只得到边界框坐标的集合。我们想获得更多的信息——这对我们的目的来说太模糊了。</p><p id="2d3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像分割为图像中的每个对象创建逐像素的遮罩。这项技术让我们对图像中的物体有了更细致的了解。</p><p id="2a1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么我们要去这么深的地方？不是所有的图像处理任务都可以用简单的包围盒坐标解决吗？让我们举一个真实世界的例子来回答这个相关的问题。</p><h1 id="3a7a" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">为什么我们需要图像分割？</h1><p id="f157" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">癌症长期以来一直是一种致命的疾病。即使在当今技术进步的时代，如果我们不在早期发现癌症，它也可能是致命的。尽快检测出癌细胞有可能挽救数百万人的生命。</p><p id="c7d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">癌细胞的形状在确定癌症的严重程度方面起着至关重要的作用。你可能已经把这些碎片放在一起了——物体检测在这里不会很有用。我们将只生成边界框，这不会帮助我们识别细胞的形状。</p><p id="6cb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像分割技术在这里产生了巨大的影响。它们帮助我们以更精细的方式处理这个问题，并获得更有意义的结果。对医疗保健行业的每个人来说都是双赢。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lv"><img src="../Images/782dc05ffd5114d33a11c67fbb3bc853.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/0*qeubU3vHQlA_KaQP.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated"><em class="lu">来源:维基百科</em></figcaption></figure><p id="8ed2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们可以清楚地看到所有癌细胞的形状。还有许多其他应用，其中图像分割正在改变行业:</p><ul class=""><li id="3caa" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">交通控制系统</li><li id="0d59" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">自动驾驶汽车</li><li id="af05" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">在卫星图像中定位物体</li></ul><p id="ef2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">甚至还有更多图像分割非常有用的应用。请在这篇文章下面的评论部分与我分享它们——让我们看看是否可以一起构建一些东西。🙂</p><h1 id="384c" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">不同类型的图像分割</h1><p id="33f7" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">我们可以将图像分割技术大致分为两种类型。考虑下面的图片:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lw"><img src="../Images/007025250fc88585ef659ee6007b111b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CRPfGFZfGzBQCsWk.png"/></div></div></figure><p id="d084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你能辨别这两者之间的区别吗？两幅图像都使用图像分割来识别和定位在场的人。</p><ul class=""><li id="3c59" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">在图像1中，每个像素属于一个特定的类(背景或人)。此外，属于特定类的所有像素都用相同的颜色表示(背景为黑色，人物为粉红色)。这是语义分割的一个例子</li><li id="4add" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">图像2还为图像的每个像素分配了一个特定的类。然而，同一类的不同对象具有不同的颜色(人1为红色，人2为绿色，背景为黑色，等等。).这是一个实例分段的例子</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lw"><img src="../Images/ac9cdebf81cc692ade52162ddacfa324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iSl2gQv7H0gGGHw0.png"/></div></div></figure><p id="3e34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我快速总结一下我们学到的东西。如果在一幅图像中有5个人，语义分割将集中于将所有人分类为单个实例。另一方面，实例分段。会逐一确认这些人的身份。</p><p id="1d77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们已经深入研究了图像处理和分割的理论概念。让我们稍微混合一下——我们将把学习概念与用Python实现它们结合起来。我坚信这是学习和记忆任何话题的最好方法。</p><h1 id="533d" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">基于区域的分割</h1><p id="f3fd" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">分割不同对象的一种简单方法是使用它们的像素值。需要注意的重要一点是，如果对象和图像背景之间存在鲜明的对比，那么它们的像素值会有所不同。</p><p id="c3a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们可以设置一个阈值。低于或高于该阈值的像素值可以被相应地分类(作为对象或背景)。这种技术被称为<strong class="ih hj">阈值分割</strong>。</p><blockquote class="lx ly lz"><p id="2959" class="if ig jq ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated"><em class="hi">如果我们想把图像分成两个区域(物体和背景)，我们定义一个单一的阈值。这就是所谓的</em><strong class="ih hj"><em class="hi"/></strong><em class="hi">。</em></p><p id="fad1" class="if ig jq ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">如果背景中有多个物体，我们必须定义多个阈值。这些阈值统称为<strong class="ih hj"><em class="hi"/></strong><em class="hi">。</em></p></blockquote><p id="c285" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们实施我们在本节中学到的内容。下载<a class="ae jd" href="https://drive.google.com/open?id=1aM4otWKSsDz1Rof3LZkY055YkYXeO-vf" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这个图像</strong> </a>并运行下面的代码。它会让你更好地理解阈值处理是如何工作的(如果你想尝试，你可以使用你选择的任何图像！).</p><p id="db9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将导入所需的库。</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="1650" class="mi kg hi me b fi mj mk l ml mm">from skimage.color import rgb2gray<br/>import numpy as np<br/>import cv2<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/>from scipy import ndimage</span></pre><p id="ec00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们阅读下载的图像并绘制它:</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="171e" class="mi kg hi me b fi mj mk l ml mm">image = plt.imread('1.jpeg')                       <br/>image.shape                       <br/>plt.imshow(image)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mn"><img src="../Images/05ebd05547163e5e3cfb53041c044035.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/0*WNrD-mmRy7FHBHk0.png"/></div></figure><p id="cfb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是三通道图像(RGB)。我们需要把它转换成灰度，这样我们就只有一个通道了。这样做也有助于我们更好地理解算法是如何工作的。</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="94d5" class="mi kg hi me b fi mj mk l ml mm">gray = rgb2gray(image)                       <br/>plt.imshow(gray, cmap='gray')</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mo"><img src="../Images/60feb86e545a33969cfc5e0c5e163699.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/0*uFWt7atmIA0CozTr.png"/></div></figure><p id="ad1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们想对这个图像应用一个特定的阈值。这个阈值应该将图像分成两部分——前景和背景。在此之前，让我们快速检查一下这张图片的形状:</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="a963" class="mi kg hi me b fi mj mk l ml mm">gray.shape</span></pre><p id="3afc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">(192, 263)</p><p id="1be6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像的高度和宽度分别为192和263。<strong class="ih hj">我们将取像素值的平均值，并将其用作阈值。</strong>如果像素值大于我们的阈值，我们可以说它属于一个物体。如果像素值小于阈值，它将被视为背景。让我们编码如下:</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="751f" class="mi kg hi me b fi mj mk l ml mm">gray_r = gray.reshape(gray.shape[0]*gray.shape[1])                       <br/>for i in range(gray_r.shape[0]):                           <br/>    if gray_r[i] &gt; gray_r.mean():                               <br/>        gray_r[i] = 1                           <br/>    else:                               <br/>        gray_r[i] = 0                       <br/>gray = gray_r.reshape(gray.shape[0],gray.shape[1])                       <br/>plt.imshow(gray, cmap='gray')</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mp"><img src="../Images/5ddb3165fa923c159fbd084497df5e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*sF9IS_AonORYIZlp.png"/></div></figure><p id="df9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不错！较暗的区域(黑色)代表背景，较亮的区域(白色)代表前景。我们还可以定义多个阈值来检测多个对象:</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="6e35" class="mi kg hi me b fi mj mk l ml mm">gray = rgb2gray(image)<br/>gray_r = gray.reshape(gray.shape[0]*gray.shape[1])<br/>for i in range(gray_r.shape[0]):<br/>    if gray_r[i] &gt; gray_r.mean():<br/>        gray_r[i] = 3<br/>    elif gray_r[i] &gt; 0.5:<br/>        gray_r[i] = 2<br/>    elif gray_r[i] &gt; 0.25:<br/>        gray_r[i] = 1<br/>    else:<br/>        gray_r[i] = 0<br/>gray = gray_r.reshape(gray.shape[0],gray.shape[1])<br/>plt.imshow(gray, cmap='gray')</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mq"><img src="../Images/9cf9f2adf544d5a2e94023b3c63e4028.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/0*zGr9I6zKyU2uPIYY.png"/></div></figure><p id="4ae9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上图中有四个不同的部分。您可以设置不同的阈值，并检查分段是如何制作的。这种方法的一些优点是:</p><ul class=""><li id="47ab" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">计算更简单</li><li id="a9b9" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">操作速度快</li><li id="4c18" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">当目标和背景具有高对比度时，该方法表现得非常好</li></ul><p id="d069" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这种方法有一些限制。当我们没有明显的灰度差异，或者灰度像素值有重叠时，很难获得准确的片段。</p><h1 id="5004" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">边缘检测分割</h1><p id="03be" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">是什么将图像中的两个对象分开？具有不同灰度值(像素值)的两个相邻区域之间总是存在边缘。边缘可以被认为是图像不连续的局部特征。</p><p id="efad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以利用这种不连续性来检测边缘，从而定义对象的边界。这有助于我们检测给定图像中存在的多个对象的形状。现在的问题是我们如何检测这些边缘？这是我们可以利用过滤器和卷积的地方。如果你需要了解这些概念，请参考本文。</p><p id="0751" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图将帮助您理解滤镜如何在图像上旋转:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mr"><img src="../Images/8da20daa992f3c5da41fd9705b509f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/0*to_AZ-Po869n17TK.gif"/></div></figure><p id="eeab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一步一步的工作过程:</p><ul class=""><li id="cb1a" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">以权重矩阵为例</li><li id="f7d2" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">把它放在图片上面</li><li id="75ca" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">执行逐元素乘法并获得输出</li><li id="caac" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">按照选择的步幅移动权重矩阵</li><li id="ab46" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">卷积，直到输入的所有像素都被使用</li></ul><p id="dfde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">权重矩阵的值定义卷积的输出。我的建议是——从输入中提取特征很有帮助。研究人员发现，为这些权重矩阵选择一些特定的值有助于我们检测水平或垂直边缘(甚至水平和垂直边缘的组合)。</p><p id="4b0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个这样的权重矩阵是sobel算子。它通常用于检测边缘。sobel算子有两个权重矩阵，一个用于检测水平边缘，另一个用于检测垂直边缘。让我展示一下这些操作符的样子，然后我们将在Python中实现它们。</p><p id="2cbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">索贝尔滤波器(水平)= 1</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ms"><img src="../Images/a181dab8178fd433c46353ad68aabebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:220/format:webp/1*S9lM-7K4dqkgE-OBc96iBg.png"/></div></figure><p id="b00f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">索贝尔滤波器(垂直)= 1</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mt"><img src="../Images/a93d022dbd09407e6d92c922e649d665.png" data-original-src="https://miro.medium.com/v2/resize:fit:216/format:webp/1*SkJRk4kHwncFqkG40QnpFQ.png"/></div></figure><p id="3e7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">边缘检测通过在给定图像上卷积这些滤波器来工作。让我们把它们形象化在<a class="ae jd" href="https://drive.google.com/file/d/1gohzcl0AI1yVCF3zdGZnfcbvI_1poM32/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">这篇文章</a>上。</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="c046" class="mi kg hi me b fi mj mk l ml mm">image = plt.imread('index.png')                       <br/>plt.imshow(image)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mu"><img src="../Images/8a48d4c1244c292bfd05584ccc44d095.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/0*YasCz08vavAeyaH9.png"/></div></figure><p id="71e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们来说，理解如何在该图像中检测边缘应该是相当简单的。让我们将其转换为灰度，并定义将在此图像上卷积的sobel滤波器(水平和垂直):</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="a861" class="mi kg hi me b fi mj mk l ml mm"># converting to grayscale<br/>gray = rgb2gray(image)<br/><br/># defining the sobel filters<br/>sobel_horizontal = np.array([np.array([1, 2, 1]), np.array([0, 0, 0]), np.array([-1, -2, -1])])<br/>print(sobel_horizontal, 'is a kernel for detecting horizontal edges')<br/> <br/>sobel_vertical = np.array([np.array([-1, 0, 1]), np.array([-2, 0, 2]), np.array([-1, 0, 1])])<br/>print(sobel_vertical, 'is a kernel for detecting vertical edges')</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mv"><img src="../Images/ab18675cb2ea77da05e1a15a20ad95d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/0*nHFuNWL3WuOO1Lld.png"/></div></figure><p id="2fb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，使用<em class="jq"> scipy </em>中<em class="jq"> ndimage </em>包的<em class="jq">卷积</em>函数对图像进行卷积。</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="b2c6" class="mi kg hi me b fi mj mk l ml mm">out_h = ndimage.convolve(gray, sobel_horizontal, mode='reflect')                       <br/>out_v = ndimage.convolve(gray, sobel_vertical, mode='reflect')                       <br/># here mode determines how the input array is extended when the filter overlaps a border.</span></pre><p id="8874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们绘制这些结果:</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="62bf" class="mi kg hi me b fi mj mk l ml mm">plt.imshow(out_h, cmap='gray')</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mw"><img src="../Images/dc6f26de1aad08cede6357f1e3537a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/0*aEZ5vcIf1Ww3oZSf.png"/></div></figure><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="ba55" class="mi kg hi me b fi mj mk l ml mm">plt.imshow(out_v, cmap='gray')</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mx"><img src="../Images/974291d60f7f2966887739ef6cc568a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/0*Cvt1xVQR0RG15rHv.png"/></div></figure><p id="084f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们能够识别水平和垂直边缘。还有一种类型的滤波器可以同时检测水平和垂直边缘。这被称为拉普拉斯算子:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es my"><img src="../Images/2fc920927b29aaa9a9450cbfd8eee9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*kBEfKkQRPNV0w2XwxqBsyw.png"/></div></figure><p id="954e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用Python定义这个过滤器，并在同一个图像上进行卷积:</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="1ba3" class="mi kg hi me b fi mj mk l ml mm">kernel_laplace = np.array([np.array([1, 1, 1]), np.array([1, -8, 1]), np.array([1, 1, 1])])                       <br/>print(kernel_laplace, 'is a laplacian kernel')</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mz"><img src="../Images/e4223ac8c2c3a83c1922784ae3225529.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/0*tsLo384L2C-lybDc.png"/></div></figure><p id="f198" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，卷积滤波器并打印输出:</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="3876" class="mi kg hi me b fi mj mk l ml mm">out_l = ndimage.convolve(gray, kernel_laplace, mode='reflect')                       <br/>plt.imshow(out_l, cmap='gray')</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es na"><img src="../Images/498c2c39492e23db52321b50182ba48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/0*xiRNTWMVzbCBVl6b.png"/></div></figure><p id="b7c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们可以看到我们的方法已经检测到水平和垂直边缘。我鼓励你在不同的图像上尝试，并与我分享你的结果。记住，最好的学习方法是通过练习！</p><h1 id="a3fa" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">基于聚类的图像分割</h1><p id="5997" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">这个想法可能是你在阅读图像分割时想到的。不能用聚类技术把图像分割成段吗？我们当然可以！</p><p id="1602" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一节中，我们将直观地了解什么是集群(修改某些概念总是好的！)以及我们如何使用它来分割图像。</p><p id="2b8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">聚类是将群体(数据点)分成若干组的任务，使得相同组中的数据点比其他组中的数据点更类似于该相同组中的其他数据点。这些组被称为集群。</p><p id="4166" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最常用的聚类算法之一是<a class="ae jd" href="https://www.analyticsvidhya.com/blog/2016/11/an-introduction-to-clustering-and-different-methods-of-clustering/" rel="noopener ugc nofollow" target="_blank"> k-means </a>。这里，k代表聚类的数量(不要与k-最近邻混淆)。让我们了解一下k-means是如何工作的:</p><ol class=""><li id="57cc" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc li jx jy jz bi translated">首先，随机选择k个初始聚类</li><li id="3180" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">将每个数据点随机分配给k个聚类中的任何一个</li><li id="ef78" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">计算这些集群的中心</li><li id="0fb6" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">计算所有点到每个聚类中心的距离</li><li id="f8a7" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">根据这个距离，这些点被重新分配给最近的聚类</li><li id="1e9c" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">计算新形成的集群的中心</li><li id="ac5b" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">最后，重复步骤(4)、(5)和(6)，直到聚类的中心不变或者我们达到设定的迭代次数</li></ol><p id="92e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用k-means算法的关键优点是简单易懂。</strong>我们将这些点分配给离它们最近的聚类。</p><p id="ca28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来测试一下我们的学习，看看k-means分割图像中的对象有多好。我们将使用<a class="ae jd" href="https://drive.google.com/open?id=1aM4otWKSsDz1Rof3LZkY055YkYXeO-vf" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这张图片</strong> </a>，所以下载它，阅读它并检查它的尺寸:</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="f2b3" class="mi kg hi me b fi mj mk l ml mm">pic = plt.imread('1.jpeg')/255  # dividing by 255 to bring the pixel values between 0 and 1                       <br/>print(pic.shape)                       <br/>plt.imshow(pic)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mn"><img src="../Images/e60c0dac823d7f9adf022f1a23684fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/0*H1MhkMa-y-aZoYf1.png"/></div></figure><p id="9700" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是形状(192，263，3)的三维图像。为了使用k-means对图像进行聚类，我们首先需要将其转换为一个二维数组，其形状为(长*宽，通道)。在我们的例子中，这将是(192*263，3)。</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="5941" class="mi kg hi me b fi mj mk l ml mm">pic_n = pic.reshape(pic.shape[0]*pic.shape[1], pic.shape[2])                       <br/>pic_n.shape</span></pre><p id="7db1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> (50496，3) </strong></p><p id="abd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到图像已经被转换成一个二维数组。接下来，将k-means算法应用于这个整形后的数组，并获得聚类。k-means的<em class="jq">cluster _ centers _ function</em>将返回聚类中心，而<em class="jq"> labels_ function </em>将为我们提供每个像素的标签(它将告诉我们图像的哪个像素属于哪个聚类)。</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="a2fe" class="mi kg hi me b fi mj mk l ml mm">from sklearn.cluster import KMeans                       <br/>kmeans = KMeans(n_clusters=5, random_state=0).fit(pic_n)                       <br/>pic2show = kmeans.cluster_centers_[kmeans.labels_]</span></pre><p id="d55d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经为这篇文章选择了5个集群，但是你可以使用这个数字并检查结果。现在，让我们将聚类恢复到其原始形状，即三维图像，并绘制结果。</p><pre class="jf jg jh ji fd md me mf mg aw mh bi"><span id="352a" class="mi kg hi me b fi mj mk l ml mm">cluster_pic = pic2show.reshape(pic.shape[0], pic.shape[1], pic.shape[2])                       <br/>plt.imshow(cluster_pic)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es nb"><img src="../Images/eab2acafcd5a312ac872ab9e878881d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/0*c1D3KroePmSgx1u7.png"/></div></figure><p id="b6ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很神奇，不是吗？我们能够使用仅仅5个聚类很好地分割图像。我相信你可以通过增加聚类的数量来改进分割。</p><p id="c006" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们有一个小的数据集时，k-means非常有效。它可以分割图像中的对象，并给出令人印象深刻的结果。但是当应用于大型数据集(更多数量的图像)时，该算法遇到了障碍。</p><p id="0b57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它会在每次迭代中查看所有样本，因此花费的时间太长。因此，实施起来也太昂贵了。并且由于k-means是一种基于距离的算法，它只适用于凸数据集，不适合聚类<a class="ae jd" href="https://en.wikipedia.org/wiki/Convex_set" rel="noopener ugc nofollow" target="_blank">非凸聚类</a>。</p><p id="b63e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们看看一个简单、灵活和通用的图像分割方法。</p><h1 id="a736" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">屏蔽R-CNN</h1><p id="826c" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">脸书人工智能研究所(FAIR)的数据科学家和研究人员开创了一种深度学习架构，称为Mask R-CNN，可以为图像中的每个对象创建一个像素级的掩模。这是一个非常酷的概念，请密切关注！</p><p id="bc2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Mask R-CNN是流行的<a class="ae jd" href="https://www.analyticsvidhya.com/blog/2018/10/a-step-by-step-introduction-to-the-basic-object-detection-algorithms-part-1/?utm_source=blog&amp;utm_medium=image-segmentation-article" rel="noopener ugc nofollow" target="_blank">更快R-CNN </a>对象检测架构的扩展。屏蔽R-CNN为已经存在的更快的R-CNN输出增加了一个分支。更快的R-CNN方法为图像中的每个对象生成两个东西:</p><ul class=""><li id="7bfb" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">它的类别</li><li id="8c9a" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">边界框坐标</li></ul><p id="8772" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Mask R-CNN为此添加了第三个分支，它也输出对象遮罩。看看下面的图片，直观地了解一下R-CNN是如何在内部工作的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nc"><img src="../Images/89cf8bd72d4362b2a216eca36c232225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WW9-19FIB9IVZki3.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">【arxiv.org】来源:T4</figcaption></figure><ol class=""><li id="6443" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc li jx jy jz bi translated">我们将一幅图像作为输入，并将其传递给ConvNet，后者返回该图像的特征图</li><li id="b823" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">区域建议网络(RPN)应用于这些特征地图。这将返回对象建议及其客观性分数</li><li id="ce2b" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">投资回报池层应用于这些提案，以将所有提案缩小到相同的大小</li><li id="98d5" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc li jx jy jz bi translated">最后，建议被传递到完全连接的层，以分类和输出对象的边界框。它还返回每个建议的掩码</li></ol><blockquote class="lx ly lz"><p id="de42" class="if ig jq ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated"><em class="hi"> Mask R-CNN是当前最先进的图像分割技术，运行速度为5 fps。</em></p></blockquote><h1 id="1bc2" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">图像分割技术综述</h1><p id="8dae" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">我在下表中总结了不同的图像分割算法..我建议下次在处理图像分割挑战或问题时，将它放在手边！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es nd"><img src="../Images/c82e0621ac9128772135fc6811298cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*dXV7mnzqQK7hy6ykyeG9lQ.png"/></div></figure><h1 id="c057" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结束注释</h1><p id="3e19" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">这篇文章只是我们学习图像分割的旅程的开始。在本系列的下一篇文章中，我们将深入探讨Mask R-CNN的实现。敬请关注！</p><p id="c3ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我发现图像分割在我的深度学习生涯中是一个非常有用的功能。我从这些技术中获得的粒度级别令人震惊。我总是惊讶于我们能用几行代码提取出多少细节。我在下面提到了一些有用的资源，可以帮助您完成计算机视觉之旅:</p><ul class=""><li id="54e1" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated"><a class="ae jd" href="https://courses.analyticsvidhya.com/courses/computer-vision-using-deep-learning-version2?utm_source=blog&amp;utm_medium=image-segmentation-article" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">计算机视觉使用深度学习2.0课程</strong> </a></li><li id="7950" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated"><a class="ae jd" href="https://courses.analyticsvidhya.com/bundles/computer-vision-combo?utm_source=blog&amp;utm_medium=image-segmentation-article" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">认证项目:计算机视觉初学者</strong> </a></li></ul><p id="299f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我总是很感谢对我的文章的任何反馈或建议，所以请随时在下面的评论部分与我联系。</p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="3d1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jq">原载于2019年4月1日</em><a class="ae jd" href="https://www.analyticsvidhya.com/blog/2019/04/introduction-image-segmentation-techniques-python/" rel="noopener ugc nofollow" target="_blank"><em class="jq">https://www.analyticsvidhya.com</em></a><em class="jq">。</em></p></div></div>    
</body>
</html>