<html>
<head>
<title>Multiprocessing Made Easy(ier) with Databricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据块简化了多重处理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/multiprocessing-made-easy-ier-with-databricks-bbe9d444ecbd?source=collection_archive---------2-----------------------#2020-07-28">https://medium.com/analytics-vidhya/multiprocessing-made-easy-ier-with-databricks-bbe9d444ecbd?source=collection_archive---------2-----------------------#2020-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/def28ecc389ba10cca6ac1756af5b060.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/0*8rEbG-cvA-VSV3iT.jpeg"/></div></div></figure><p id="1407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在某处读到过，当处理涉及数十亿事物的计算问题时，将工作分配给多个进程是一个好主意。</p><blockquote class="jo jp jq"><p id="fa8a" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">您也可以使用多线程，但我将坚持使用多处理，因为这更能反映数据块的工作方式。</p></blockquote><p id="8c07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Databricks 是一个多处理平台。有些问题乍一看似乎不适合数据块，但如果你换个角度思考，它们可能非常适合。</p><p id="247b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑使用蒙特卡罗模拟来估计πT2 的问题。你可以这样想估算方法:</p><ol class=""><li id="ff5f" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">向镖靶投掷飞镖。</li><li id="a27c" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">如果飞镖落在圆圈内，你得 1 分。</li><li id="f7ff" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">重复步骤 1 和 2，直到你厌倦了。</li><li id="7073" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">把你的点数加起来，乘以 4，再除以投掷次数。这将给你一个对<em class="jr">圆周率的估计。</em></li></ol><p id="e0c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你投的飞镖越多，估计就越准确。</p><h1 id="6065" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">串行实现</h1><p id="ce8a" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">下面的代码显示了一个串行实现:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="057f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我工作站上的执行时间。</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="d54e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">执行时间非常线性，这并不奇怪，因为串行算法是<em class="jr"> O(n)。</em>运行在一个核上，算法在 10 亿投的时候哭大叔。</p><h1 id="93a4" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">使用多重处理的并行实现</h1><p id="ccc9" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">Python 有一个很酷的<a class="ae jv" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">多重处理模块</a>，它是为分而治之类型的问题而构建的。那么，如何改变串行代码，使它能够在使用多个进程运行时工作呢？</p><p id="1c94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是我决定要做的:</p><ol class=""><li id="27e3" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">用迭代次数除以我想要生成的进程数。这是每个进程投掷的飞镖数量。</li><li id="9ee7" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">产生适当数量的进程。</li><li id="bc04" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">告诉每个过程投掷飞镖，并记录其分数。</li><li id="710b" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">当所有进程都完成后，将命中数加起来，乘以 4，再除以总投掷数，得到<em class="jr"> pi 的估计值。</em></li></ol><p id="e257" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是 1 <strong class="is hj"> <em class="jr">亿</em> </strong>掷的执行次数:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="4e6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多重处理使得对 10 亿次投掷的估计更加容易处理。注意，收益是线性的，在我的例子中，除了 4 个过程之外没有太多的收益。我的机器有 4 个物理内核(8 个带超线程),这就是为什么 4 是收益递减点。</p><p id="60ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码如下:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="20ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是该准则的要点:</p><ol class=""><li id="91a6" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">估算算法已经以这样一种方式被重新表述，即多个过程可以执行估算而不会相互干扰。换句话说，没有共享状态。</li><li id="e157" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><a class="ae jv" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool" rel="noopener ugc nofollow" target="_blank">池</a>对象负责收集结果，以便我们能够以安全的方式执行求和。</li></ol><h1 id="02ab" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">使用数据块的并行实现</h1><p id="7897" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">多重处理有所帮助，但也有严重的局限性。这段代码只能在一台物理机上运行！如果我们想利用 Azure 的计算能力会怎么样？为什么不考虑 Databricks？</p><p id="9c2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于一个执行器，估计 10 亿次投掷在 282 秒内完成。注意，Databricks 为此创建了 4 个任务，大概是因为每个执行器有 4 个物理核心。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/bbe2ee2e3716f14e181d17605ab0eb56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wt8WaQXvi3fzeqrjeGoFow.png"/></div></div></figure><p id="156d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了 8 个执行者，Databricks 仅用 33 秒就完成了估算！大约快了 8 倍！您可以用不同数量的执行器自己尝试这个实验，并验证您可以获得速度的线性增长。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/90a5be4a70dd5fcd24db6f9485c62199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GES4uD4vSqkYjc84k8jkwQ.png"/></div></div></figure><p id="6ba6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是 Databricks 笔记本代码:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="054f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是该准则的要点:</p><ol class=""><li id="6120" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">就像多重处理的例子一样，估算算法已经以这样一种方式被重新表述，即多个执行器可以在不互相干扰的情况下执行估算。换句话说，没有共享状态。</li><li id="4cc9" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">Databricks 负责将代码发送给执行器，并确保代码运行。</li><li id="e20b" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">没有新的 API 需要学习。代码是普通的数据块。</li><li id="279b" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">为了适应 Databricks 编程范式，构建了包含每次迭代结果的 RDD。</li></ol><h1 id="6bb9" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">结论</h1><p id="34f9" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">如果您习惯使用数据块，也可以考虑将它用于 CPU 受限的并行计算。你可能会惊喜！</p><p id="f5e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>