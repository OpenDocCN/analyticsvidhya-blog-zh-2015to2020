<html>
<head>
<title>Introduction to Bash Script — 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bash脚本简介— 3</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/introduction-to-bash-script-3-1b2dcf26eebd?source=collection_archive---------35-----------------------#2020-04-22">https://medium.com/analytics-vidhya/introduction-to-bash-script-3-1b2dcf26eebd?source=collection_archive---------35-----------------------#2020-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c21d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在bash脚本中引入退出代码、特殊参数和函数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/ac892e7fffb32ca68504eddada5a3cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tx-Not3gl9pDL3ReCa7Xfg.png"/></div></div></figure><h1 id="134f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">内容</h1><ol class=""><li id="8382" class="kn ko hi ih b ii kp im kq iq kr iu ks iy kt jc ku kv kw kx bi translated"><strong class="ih hj">退出代码</strong></li><li id="c797" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated"><strong class="ih hj">特殊论证</strong></li><li id="3e18" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated"><strong class="ih hj">功能</strong></li><li id="35de" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated"><strong class="ih hj">总结</strong></li></ol><h1 id="5447" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">退出代码</strong></h1><p id="e0a0" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated"><strong class="ih hj">退出代码</strong>用于显示Unix系统中的进程状态。例如，如果<strong class="ih hj">退出代码</strong>为0，则表示流程执行成功。否则，会有一些错误。事实上，退出代码<strong class="ih hj">的范围是从0到255 </strong>，它对所有代码都有不同的含义。但是我们可以把它们分成两类——成功和失败。</p><p id="f560" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，使用退出代码可以<strong class="ih hj">立即终止进程</strong>，例如:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="d3d0" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash</span><span id="f534" class="ll jq hi lh b fi lq ln l lo lp">echo "Hello"<br/>exit(0) # Exit here<br/>echo "World" # Won't be executed</span></pre><p id="c6f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意到“世界”不会被打印在屏幕上，因为它前面有exit语句。</p><p id="6df0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以自己设置退出密码。这里有一个例子:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="d1b4" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash</span><span id="7f0d" class="ll jq hi lh b fi lq ln l lo lp">TEST=1</span><span id="6520" class="ll jq hi lh b fi lq ln l lo lp">if [[ ${TEST} -eq 1 ]] <br/>then<br/>  echo "Success"<br/>  exit 0<br/>elif [[ ${TEST} -eq 2 ]]<br/>then<br/>  echo "Fail"<br/>  exit 1<br/>else<br/>  echo "Fail fail!"<br/>  exit 2<br/>fi</span></pre><p id="75a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一个主题中，我们将讨论如何在屏幕上打印出<strong class="ih hj">退出状态</strong>。</p><h1 id="3c1b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">特殊参数</h1><p id="99e5" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">特殊的自变量可以帮助我们获得一些信息，比如参数、退出状态或最后的命令。下面是特殊参数的表格:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lr"><img src="../Images/0d5b34a733d7826fe12678e54b3bb80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Me0vOTiHx14gYkLBsgW48A.png"/></div></div></figure><ul class=""><li id="296c" class="kn ko hi ih b ii ij im in iq ls iu lt iy lu jc lv kv kw kx bi translated"><strong class="ih hj"> $0，$1，$ 2……</strong></li></ul><p id="81fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仍然有很多特殊的论点，我们知道先试着了解这些。让我们关注第一个和第二个命令。如果我们想得到用户提示的参数，我们可以使用$1，$2…</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="2052" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash</span><span id="b765" class="ll jq hi lh b fi lq ln l lo lp"># Print out the name of the file<br/>echo "${0} is executed."</span><span id="b119" class="ll jq hi lh b fi lq ln l lo lp"># Print out the arguments we catch<br/>echo "The first argument is ${1}."<br/>echo "The second argument is ${2}."</span></pre><p id="4f89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们只想捕捉两个参数:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="2edc" class="ll jq hi lh b fi lm ln l lo lp">./test.sh Hello World</span><span id="f6b4" class="ll jq hi lh b fi lq ln l lo lp">./test.sh is executed.<br/>The first argument is Hello.<br/>The second argument is World.</span></pre><p id="d932" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从第一行，我们可以观察到”。/"已经包含到＄0中。事实上，$0从用户输入的路径中获取名称。</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="1c3d" class="ll jq hi lh b fi lm ln l lo lp">~/Desktop/test.sh</span><span id="a1dd" class="ll jq hi lh b fi lq ln l lo lp">/Users/justin/Desktop/test.sh is executed.<br/>The first argument is Hello.<br/>The second argument is World.</span></pre><p id="260c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们只想得到文件名，我们可以使用<code class="du lw lx ly lh b">baseline</code>命令。</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="3599" class="ll jq hi lh b fi lm ln l lo lp">echo "$(basename ${0}) is executed" # Get the file name only</span></pre><p id="37df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以试试</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="4da8" class="ll jq hi lh b fi lm ln l lo lp">~/Desktop/test.sh</span><span id="8157" class="ll jq hi lh b fi lq ln l lo lp">test.sh is executed.<br/>The first argument is .<br/>The second argument is .</span></pre><ul class=""><li id="3b11" class="kn ko hi ih b ii ij im in iq ls iu lt iy lu jc lv kv kw kx bi translated"><strong class="ih hj"> $@ </strong></li></ul><p id="92e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们继续讨论<strong class="ih hj"> $@。</strong>如果我们想从用户那里获得参数，而不知道它们的数量，我们可以使用$@来获得所有参数。</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="558f" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash</span><span id="c3c0" class="ll jq hi lh b fi lq ln l lo lp">ALL=$@</span><span id="0db6" class="ll jq hi lh b fi lq ln l lo lp">for para in $@<br/>do<br/>  echo "${para}"<br/>done</span></pre><p id="c91f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在输入参数:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="f2f3" class="ll jq hi lh b fi lm ln l lo lp">./test.sh 1 2 3 4 5 6 7 8 9 10 11</span><span id="a5fb" class="ll jq hi lh b fi lq ln l lo lp">1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>10<br/>11</span></pre><ul class=""><li id="9f7e" class="kn ko hi ih b ii ij im in iq ls iu lt iy lu jc lv kv kw kx bi translated"><strong class="ih hj"> $？</strong></li></ul><p id="7165" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想检查一些命令是否正常运行，但不是语法错误，我们可以使用<code class="du lw lx ly lh b">if</code>和<code class="du lw lx ly lh b">$?</code>来检查。让我们看看<code class="du lw lx ly lh b">$?</code>是如何工作的:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="4ac0" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash</span><span id="22b3" class="ll jq hi lh b fi lq ln l lo lp">true # exit status is 0<br/>echo $? # echoes 0<br/>false # exit status is 1<br/>echo $? # echoes 1</span></pre><p id="e1e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是输出</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="e0da" class="ll jq hi lh b fi lm ln l lo lp">./test.sh</span><span id="659c" class="ll jq hi lh b fi lq ln l lo lp">0<br/>1</span></pre><p id="6415" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们把<code class="du lw lx ly lh b">if</code>和<code class="du lw lx ly lh b">$?</code>结合起来:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="75f1" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash</span><span id="5654" class="ll jq hi lh b fi lq ln l lo lp">true</span><span id="09e4" class="ll jq hi lh b fi lq ln l lo lp">if [[ $? -eq 1 ]]<br/> then<br/>   echo "Fail!"<br/>   exit 1<br/>fi</span><span id="b133" class="ll jq hi lh b fi lq ln l lo lp">echo "Success!"</span></pre><p id="1fb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是输出:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="4c6e" class="ll jq hi lh b fi lm ln l lo lp">./test.sh</span><span id="d161" class="ll jq hi lh b fi lq ln l lo lp">Success!</span></pre><p id="026c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将<strong class="ih hj">变为真</strong>变为<strong class="ih hj">假，</strong>我们将得到:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="ef5f" class="ll jq hi lh b fi lm ln l lo lp">./test.sh</span><span id="2627" class="ll jq hi lh b fi lq ln l lo lp">Fail!</span></pre><p id="de4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经比较熟悉特殊的参数了！虽然有更多的特殊论点，但这些是我们首先要知道的基本东西。</p><h1 id="3730" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">功能</h1><p id="f27d" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">函数是重用代码的好方法。假设我们想在一个序列中找到一个最大值，最好是写一个函数，而不是每次遇到都写。简单来说，写函数可以帮助我们实现干(不要重复自己)原则！这是我们做的模板:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="54b7" class="ll jq hi lh b fi lm ln l lo lp">function [funciton_name] {<br/>  commands...<br/>}</span></pre><p id="e35b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想调用这个函数，我们应该这样使用:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="0648" class="ll jq hi lh b fi lm ln l lo lp">[function_name] args1, args2, ...</span></pre><p id="c30e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意函数名后面没有括号！让我们首先不带任何参数地尝试这个函数:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="c2aa" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash</span><span id="fe6f" class="ll jq hi lh b fi lq ln l lo lp">function HelloWorld {<br/>  echo "Hello World"<br/>}</span><span id="a956" class="ll jq hi lh b fi lq ln l lo lp">HelloWorld</span></pre><p id="9c95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="ee8d" class="ll jq hi lh b fi lm ln l lo lp">./test.sh</span><span id="4c57" class="ll jq hi lh b fi lq ln l lo lp">Hello World</span></pre><ul class=""><li id="20d7" class="kn ko hi ih b ii ij im in iq ls iu lt iy lu jc lv kv kw kx bi translated"><strong class="ih hj">路过的争论</strong></li></ul><p id="ba18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们想把参数传递给函数，我们该如何捕捉它们呢？还记得我们如何使用特殊的参数从用户那里获取参数吗？函数也是这样工作的！例如:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="668b" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash</span><span id="86e8" class="ll jq hi lh b fi lq ln l lo lp">function HelloWorld {<br/>  echo "Hello ${1}"<br/>}</span><span id="ffba" class="ll jq hi lh b fi lq ln l lo lp">HelloWorld Justin</span></pre><p id="19f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="fc13" class="ll jq hi lh b fi lm ln l lo lp">./test.sh</span><span id="0776" class="ll jq hi lh b fi lq ln l lo lp">Hello Justin</span></pre><p id="544e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此我们可以用同样的方法来实现多个参数！</p><ul class=""><li id="b943" class="kn ko hi ih b ii ij im in iq ls iu lt iy lu jc lv kv kw kx bi translated"><strong class="ih hj">返回值</strong></li></ul><p id="d8b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数编程语言中，函数会有返回值。然而，bash不支持这些东西，尽管它仍然有使用的<strong class="ih hj">返回语法。此处的返回是返回<strong class="ih hj">状态码</strong>与退出相同，但用于该功能。例如:</strong></p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="60bd" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash<br/>function HelloWorld {<br/>  VALUE=${1} # Set the value from input</span><span id="2783" class="ll jq hi lh b fi lq ln l lo lp">  if [[ VALUE -eq 1 ]]<br/>  then<br/>    return 5 # Return status code not the value<br/>  fi</span><span id="90e2" class="ll jq hi lh b fi lq ln l lo lp">  return 0 # Return status code not the value<br/>}</span><span id="0777" class="ll jq hi lh b fi lq ln l lo lp">HelloWorld 1</span><span id="ad05" class="ll jq hi lh b fi lq ln l lo lp">if [[ ${?} -eq 5 ]] # Use ${?} to get the recent status code<br/>then<br/>  echo "Get 1"<br/>else<br/>  echo "Others"<br/>fi</span></pre><p id="5cbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="267a" class="ll jq hi lh b fi lm ln l lo lp">./test.sh</span><span id="c064" class="ll jq hi lh b fi lq ln l lo lp">Get 1</span></pre><p id="a6d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看细节:</p><ol class=""><li id="03a8" class="kn ko hi ih b ii ij im in iq ls iu lt iy lu jc ku kv kw kx bi translated">从输入中获取值(在程序中为1)</li><li id="293e" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">检查值是否为1，并将状态代码设置为5，否则为0</li><li id="48ce" class="kn ko hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">使用<strong class="ih hj"> ${？} </strong>查看<strong class="ih hj">最近的状态码</strong>，如果状态码设置为5，则输出“Get 1”</li></ol><p id="69b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以知道返回是如何工作的了！</p><ul class=""><li id="abde" class="kn ko hi ih b ii ij im in iq ls iu lt iy lu jc lv kv kw kx bi translated"><strong class="ih hj">范围</strong></li></ul><p id="a90b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作用域是可以看到变量的地方。默认情况下是全局的，这意味着脚本的每个部分都可以共享相同的变量。然而，如果其他部分无意中修改了变量，这可能是危险的。为了将变量改为局部变量，我们可以在变量名称前加上<strong class="ih hj">局部</strong>修饰符:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="efc2" class="ll jq hi lh b fi lm ln l lo lp">local [Name]=[Value]</span></pre><p id="af6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看没有本地的例子:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="0b4c" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash<br/>function HelloWorld {<br/>  TEST="HELLO" # Global<br/>}</span><span id="565a" class="ll jq hi lh b fi lq ln l lo lp">echo "${TEST}" # TEST doesn't be created before execute function</span><span id="caf9" class="ll jq hi lh b fi lq ln l lo lp">HelloWorld # TEST be created now</span><span id="d5e4" class="ll jq hi lh b fi lq ln l lo lp">echo "${TEST}"</span></pre><p id="e23a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="a426" class="ll jq hi lh b fi lm ln l lo lp">./test.sh</span><span id="617d" class="ll jq hi lh b fi lq ln l lo lp"><br/>HELLO</span></pre><p id="8329" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意<strong class="ih hj">测试</strong>直到函数调用才被创建。</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="c5b7" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash<br/>function HelloWorld {<br/>  local TEST="HELLO" # Global<br/>}</span><span id="1ae0" class="ll jq hi lh b fi lq ln l lo lp">echo "${TEST}" # TEST doesn't be created before execute function</span><span id="f654" class="ll jq hi lh b fi lq ln l lo lp">HelloWorld # TEST be created but locally</span><span id="e88b" class="ll jq hi lh b fi lq ln l lo lp">echo "${TEST}" # Couldn't find TEST</span></pre><p id="a763" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="c5c6" class="ll jq hi lh b fi lm ln l lo lp">./test.sh<br/></span></pre><p id="e11d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，如果我们将函数中的变量设置为局部变量，那么函数和全局变量就可以同名。</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="98aa" class="ll jq hi lh b fi lm ln l lo lp">#!/bin/bash<br/> function HelloWorld {<br/>   local TEST="HELLO" # Global<br/> }</span><span id="b557" class="ll jq hi lh b fi lq ln l lo lp">TEST="WORLD"</span><span id="140b" class="ll jq hi lh b fi lq ln l lo lp">echo "${TEST}" # Get the TEST from global section</span><span id="8db9" class="ll jq hi lh b fi lq ln l lo lp">HelloWorld # local TEST be created but wouldn't affect global TEST</span><span id="ebde" class="ll jq hi lh b fi lq ln l lo lp">echo "${TEST}" # Still get the global TEST</span></pre><p id="4be1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="d37a" class="ll jq hi lh b fi lm ln l lo lp">./test.sh</span><span id="13c4" class="ll jq hi lh b fi lq ln l lo lp">WORLD<br/>WORLD</span></pre><p id="13e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像我之前提到的，使用<code class="du lw lx ly lh b">local</code>确实可以帮助我们在调试时避免大量的错误！</p><h1 id="d6df" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">摘要</h1><p id="8884" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">今天，我们已经学习了如何使用退出代码来警告用户或测试输出，以及获取位置参数的特殊参数。此外，我们使用函数来存储我们可能反复获得的任务。最后但同样重要的是，我们将范围集中在局部和全局，以及如何避免误用它们。如有问题，欢迎留言评论。感谢阅读！</p></div></div>    
</body>
</html>