<html>
<head>
<title>12 Uni-variate Data Visualizations With Illustrations in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">12个带Python插图的单变量数据可视化</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/12-uni-variate-data-visualizations-with-illustrations-in-python-a8fbdad4bd04?source=collection_archive---------22-----------------------#2020-07-29">https://medium.com/analytics-vidhya/12-uni-variate-data-visualizations-with-illustrations-in-python-a8fbdad4bd04?source=collection_archive---------22-----------------------#2020-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if"><p id="bee5" class="ig ih hi bd ii ij ik il im in io ip dx translated"><em class="iq">“一图胜千言”。</em></p></blockquote><p id="be14" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ip hb bi translated"><strong class="it hj">这句话绝对适用于数据可视化，因为传达的信息比老话更有价值。</strong></p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jo"><img src="../Images/fde971989fcf03e16bdcdbde98912c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SGZxC08X9b5xc0pF.jpg"/></div></div></figure><p id="cd34" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">数据可视化是使用图表、图形等可视化元素来表示数据的过程。这有助于从数据中获得有意义的见解。它旨在揭示数据背后的信息，并进一步帮助查看者看到数据中的结构。</p><p id="59c5" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">数据可视化将使任何接触数据科学最少的人都可以获得科学发现，并帮助人们轻松地交流信息。应当理解，人们对特定数据集采用的可视化技术取决于个人的喜好和偏好。</p><h1 id="a757" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">可视化数据的需求:</h1><ul class=""><li id="6749" class="ld le hi it b iu lf iy lg jc lh jg li jk lj ip lk ll lm ln bi translated">了解数据的趋势和模式</li><li id="7fa0" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip lk ll lm ln bi translated">分析数据的频率和其他此类特征</li><li id="8276" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip lk ll lm ln bi translated">知道数据中变量的分布。</li><li id="2da3" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip lk ll lm ln bi translated">将不同变量之间可能存在的关系可视化</li></ul><p id="190a" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">以数据为特征的感兴趣变量的数量将其分类为<strong class="it hj">单变量、双变量或多变量</strong>。例如，如果数据只包含一个感兴趣的变量，那么它就是单变量数据。进一步，根据数据的特性，可以分为<strong class="it hj">分类/离散</strong>和<strong class="it hj">连续</strong>数据。</p><p id="754c" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">在本文中，主要关注的是<strong class="it hj">单变量数据</strong>可视化(数据以一维方式可视化)。出于说明的目的，考虑<strong class="it hj">‘iris’</strong>数据集。iris数据集包含3类，每类50个实例，其中每类涉及一种类型的iris植物。数据集中涉及的不同变量是萼片长度、萼片宽度、花瓣长度、花瓣宽度(连续变量)和种类变量(分类变量)。尽管数据集本质上是多变量的，但对于单变量分析，我们一次只考虑一个感兴趣的变量。</p><p id="f25c" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">我们首先导入所需的库和数据集。你可以在这里下载python笔记本和数据集<a class="ae lt" href="https://drive.google.com/file/d/19RVxG_wRlOY1sqNwkUWcSTQ8HrYYM7_U/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es lu"><img src="../Images/780a27cf7e1d82cb33f282786c33526c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*iyNA89SOOKt60cWSmgYawQ.png"/></div></figure><p id="3a56" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">最初在中的数据集。csv格式使用pandas的<em class="lv"> pd.read_csv( ) </em>函数加载到数据帧df中。然后，它显示数据帧df。</p><p id="5202" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">在分析任何数据集之前，检查数据变量的数据类型。然后，人们可以决定单变量数据可视化的正确方法。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es lw"><img src="../Images/ba673796f30dd008949f118c6e763755.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*cuUYp8dn5qkFZAF0v6HrSw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">数据类型</figcaption></figure><p id="c811" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated"><em class="lv">。dtypes </em>属性用于知道数据集中变量的数据类型。Pandas根据它们的类型以不同的格式存储这些变量。Pandas将<em class="lv">分类变量存储为‘对象’</em>，另一方面，<em class="lv">连续变量存储为int或float </em>。用于单变量数据可视化的方法也取决于数据变量的类型。</p><p id="2df0" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">在本文中，我们使用库matplotlib和seaborn来可视化iris数据。我们用Matplotlib库来画基本的图。Seaborn库基于matplotlib库，它为单变量数据提供了多种可视化技术。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mb"><img src="../Images/b9835c9f544bf53dc833f9a26990c134.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/0*oc5C5KEr4_YQFrhy.png"/></div></figure><h1 id="13f1" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">可视化单变量连续数据:</h1><p id="d505" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">单变量数据可视化图有助于我们理解枚举属性以及特定数据变量的描述性摘要。这些图有助于理解数据变量中观察值的<strong class="it hj">位置/方位</strong>、其<strong class="it hj">分布</strong>和<strong class="it hj">分散</strong>。单变量图有两种类型:1) <strong class="it hj">枚举</strong>图和2) <strong class="it hj">汇总</strong>图</p><h1 id="407b" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">单变量枚举图:</h1><p id="2fce" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">这些图列举/显示了数据中的每个观察值，并提供了关于单个数据变量上观察值分布的信息。我们现在来看看不同的枚举图。</p><h2 id="2af7" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">1.单变量散点图:</h2><p id="1afa" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">这绘出了对应于指数/观察值的同一变量的不同观察值/值。考虑绘制变量‘萼片长度(厘米)’:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mt"><img src="../Images/779c46138b9b8fa8fdd0305e14fde417.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*o7nVj1m6ZwE8shRAipaF6g.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(使用Matplotlib的单变量散点图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mu"><img src="../Images/d942c84d96613a7fc6ff1a20211da8fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*9QNixJ5eRRe8NjAMjEYFjQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(使用Matplotlib的单变量散点图)</figcaption></figure><p id="9c82" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">使用matplotlib的<em class="lv"> plt.scatter() </em>函数绘制一元散点图。scatter()函数需要两个参数来绘制。因此，在本例中，我们将变量“sepal.width”与作为数据帧索引(df.index)存储的相应观测值相对应。</p><p id="7268" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">然后使用seaborn库的<em class="lv"> sns.scatterplot() </em>函数，通过考虑其多样性来可视化相同的图。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mv"><img src="../Images/f33952c38533d74cd8faacd72794fc2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*722C1VQyahln5oOFqMAkEA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(使用Seaborn的单变量散点图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mw"><img src="../Images/12c7df5a438fb982791a3bcfc42f09fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*Dy7K7vccufLZohh6TEl7Gw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(使用Seaborn的单变量散点图)</figcaption></figure><p id="c4ac" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">seaborn中一个有趣的特性是“色调”参数。在seaborn中，色调参数决定了数据框中的哪一列应该用于颜色编码。这有助于根据数据值所属的类别来区分数据值。色调参数将分组变量作为其输入，使用它将产生具有不同颜色的点。传递给“hue”的变量可以是分类的，也可以是数字的，尽管颜色映射在后一种情况下会有不同的表现。</p><blockquote class="mx my mz"><p id="80b7" class="ir is lv it b iu ka iw ix iy kb ja jb na kc je jf nb kd ji jj nc ke jm jn ip hb bi translated"><strong class="it hj"> <em class="hi">注意</em> </strong> <em class="hi"> : </em>每个函数都有各种各样的参数可以使用，以产生更好的结果。如果使用Jupyter notebook，可以使用“Shift+Tab”快捷键来查看所用功能的各种参数。</p></blockquote><h2 id="0c45" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">2.线形图(带标记) :</h2><p id="3017" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">折线图通过线段连接数据点来可视化数据。它类似于散点图，只是测量点是有序的(通常按其x轴值)并用直线段连接。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es nd"><img src="../Images/85f7cc762fbbcd7905ddc0dc60cc7ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsEdtrRQE_LpXj3pW3G6oQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(Matplotlib中带标记的线图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es ne"><img src="../Images/04f3b684a6658da12741ed9a3f62db7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*Q1wtQC3oEhyr7PtACe8qCw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(Matplotlib中带标记的线图)</figcaption></figure><p id="bc1e" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">默认情况下，matplotlib <em class="lv"> plt.plot() </em>函数使用线形图绘制数据。</p><p id="155d" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">之前我们讨论过seaborn的色相参数。虽然matplotlib中没有这样的自动化选项，但是可以使用pandas的<em class="lv"> groupby() </em>函数来绘制这样的图形。</p><p id="6dc3" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated"><strong class="it hj">注意</strong>:上图中也实现了matplotlib中设置标题、字体大小等方法。</p><p id="82cb" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated"><strong class="it hj">所用功能的说明:</strong></p><ul class=""><li id="c3c0" class="ld le hi it b iu ka iy kb jc nf jg ng jk nh ip lk ll lm ln bi translated"><em class="lv">图形(figsize=()) </em>:设置图形的大小</li><li id="0e17" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip lk ll lm ln bi translated"><em class="lv"> plt.title() </em>:设置标题</li><li id="efd6" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip lk ll lm ln bi translated"><em class="lv">PLT . xlabel()/PLT . ylabel()</em>:在X轴/Y轴上设置标签</li><li id="11bb" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip lk ll lm ln bi translated"><em class="lv"> df.groupby( ) </em>:根据传递给函数的参数对数据帧的行进行分组</li><li id="beac" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip lk ll lm ln bi translated">groupby()函数返回按传递的标准变量和标准变量分组的数据帧。</li><li id="ff48" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip lk ll lm ln bi translated">循环的<em class="lv">用于根据数据点的变化绘制每个数据点。</em></li><li id="b86c" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip lk ll lm ln bi translated"><em class="lv"> plt.legend() </em>:给图形添加一个图例(图例描述图形中看到的不同元素)。</li><li id="1c2a" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip lk ll lm ln bi translated"><em class="lv"> plt.show() </em>:展示剧情。</li></ul><p id="7011" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">函数<em class="lv"> plt.plot() </em>的“markevery”参数被赋值为“1 ”,这意味着它将从第一个数据点开始绘制每第一个标记。有多种标记样式，我们可以将它们作为参数传递给函数。</p><p id="2b8c" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated"><em class="lv"> sns.lineplot() </em>函数也可以可视化线图。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es ni"><img src="../Images/081879637bd9c278e13111c049a1f591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCiICMd9Dl-HivJIuotRPg.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(Seaborn中带标记的线图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nj"><img src="../Images/0eb5aea76c9eaad055741dfc3d16e1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*3AATuqbjcp3xMiTkuWwNPw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(Seaborn中带标记的线图)</figcaption></figure><p id="ba40" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">在seaborn中，轴上的标签是根据传递用于绘图的列自动设置的。然而，如果想要改变它，也可以使用set()函数。</p><blockquote class="mx my mz"><p id="74af" class="ir is lv it b iu ka iw ix iy kb ja jb na kc je jf nb kd ji jj nc ke jm jn ip hb bi translated"><strong class="it hj"> <em class="hi">注</em> </strong> <em class="hi"> : </em>经常会有这样的情况，人们想要探究单个连续变量的分布如何受到第二个分类变量的影响。seaborn库提供了各种各样的图，帮助在单变量分布之间进行这种类型的比较。本文讨论了三种样地:带状样地、群体样地(在列举样地下)和小提琴样地(在总结样地下)。上面图中提到的色调参数也有类似的用途。</p></blockquote><h2 id="7abd" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">3.带状图:</h2><p id="4850" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">带状图类似于散点图。它通常与其他类型的图一起使用，以便进行更好的分析。它用于可视化变量数据点的分布。</p><p id="3abd" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated"><em class="lv"> sns.striplot ( ) </em>函数用于绘制带状图:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es nk"><img src="../Images/e444ae57b7f9d7a9bb05442d158ef4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*ioEO6L0Rm6gbitKavoja4w.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(带状图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nl"><img src="../Images/e18b522865fbff7a1b050cff4563477d.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*YysiqzshO8EH03-0mQbOYQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(带状图)</figcaption></figure><p id="a51e" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">这也有助于将每个类别的变量分布绘制成单独的数据点。默认情况下，该函数会创建一个垂直带状图，其中连续数据点的分布沿Y轴绘制，类别沿X轴隔开。在上面的情节中，没有考虑类别。考虑类别有助于更好地可视化，如下图所示。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nm"><img src="../Images/9580ea2fa91e2d226a2083cc22bdcdf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*bwHEI27LDw2JwXLMnFm83g.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(带状图类别)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nl"><img src="../Images/ebbefb7d21bff2570c2b29d8b40e3d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*OvLxUGVF8HoIB9eN9_rrCw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(带状图类别)</figcaption></figure><h2 id="4dd9" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">4.群体图:</h2><p id="4d04" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">与带状图类似，群图为单变量数据提供了一种可视化技术，以查看连续变量中值的分布。带状图和群集图之间的唯一区别在于，群集图会自动展开变量的数据点以避免重叠，从而提供更好的数据视图。</p><p id="d353" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated"><em class="lv"> sns.swarmplot( ) </em>函数用于绘制群体图:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nn"><img src="../Images/a0f3f21e180edc9b50e9dce803c4457b.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*N6utM7FSr3ocT7yGpf-Oyg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(群体图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es no"><img src="../Images/55e9743f05061fa73b777026e0e527ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*LogSEhTZuhuHgytpbP5tfg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(群体图)</figcaption></figure><p id="ce96" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">变量“萼片宽度”根据类别的分布:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es np"><img src="../Images/44d2bb19b96a8c9eee55a06a174dd7b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*XS5nGevsvc2Ej8i7FWr7rg.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(群体图类别)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nl"><img src="../Images/1e09d732e2e68ff089fe09cfd99fbaed.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*5NKuFx60PNUFPDKT9CN-GA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(群体图类别)</figcaption></figure><h1 id="90d9" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">单变量汇总图:</h1><p id="fc4a" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">这些图比枚举图更简洁地描述了变量的位置、分散和分布。在汇总图中检索每个单独的数据值是不可行的，但它有助于有效地表示整个数据，从中可以对整个数据集做出更好的结论。</p><h2 id="d5a5" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">5.直方图:</h2><p id="cbef" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">直方图类似于条形图，显示落在不同类别间隔或范围内的值的计数或相对频率。直方图显示连续样本数据的形状和分布。它还帮助我们理解数据分布的偏斜度和峰度。</p><p id="0149" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">使用matplotlib <em class="lv"> plt.hist() </em>函数绘制直方图:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es nq"><img src="../Images/42f3df6c9b298f6af84543d1729c67fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUZLqINB4fJskto9CVNQOw.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入和输出单元格(Matplotlib中的直方图)</figcaption></figure><p id="6e32" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">seaborn函数<em class="lv"> sns.distplot() </em>也可用于绘制直方图。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nr"><img src="../Images/d86c43a9fdade6bd125bc8b1aec0f97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*RlqxLSsbIMbAYB44FpOahA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(锡伯恩的直方图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es ns"><img src="../Images/d6ac537940c3542df85e183f34e75d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*QQvzKowJL2EiFqclZFF5YQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(Seaborn的直方图)</figcaption></figure><p id="15c5" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">kde(内核密度)参数被设置为False，以便只查看直方图。有许多参数，如面元(指示绘图中允许的直方图中面元的数量)、颜色等；其可以被设置以获得期望的输出。</p><h2 id="d972" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">6.密度图:</h2><p id="a004" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">密度图就像直方图的平滑版本。通常，在密度图中使用核密度估计来显示变量的概率密度函数。绘制作为核心的连续曲线，以生成整个数据的平滑密度估计。</p><p id="e12a" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">绘制变量“花瓣长度”的密度图:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nt"><img src="../Images/77bf708eddfd68eabc1170ebebaaa2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*KUKGk3jT0BnlLac0KOz81A.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(使用熊猫的密度图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nu"><img src="../Images/8f6ad1847664d326bbcc77672e206700.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*inbubvWs2Wi6cizmLEyIvA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(使用熊猫时的密度图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nv"><img src="../Images/1093d0b9880c33df1c013f510a5d9823.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*YTZaB_ii95oAUuwNX3_jGQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(Seaborn的密度图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nw"><img src="../Images/866a6fae57ff3ed547d491331cb810eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*wcr6xe6VSjqkbF1al9Oi9Q.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(Seaborn的密度图)</figcaption></figure><p id="cf73" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">我们使用pandas <em class="lv"> df.plot() </em>函数(基于matplotlib构建)或seaborn库的<em class="lv"> sns.kdeplot() </em>函数来绘制密度图。许多功能，如阴影、分布类型等，都可以使用函数中的可用参数进行设置。默认情况下，使用的核是高斯核(这会产生一条高斯钟形曲线)。此外，其他图形平滑技术/过滤器也是适用的。</p><h2 id="acbb" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">7.地毯图:</h2><p id="3a0a" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">地毯图是一种非常简单，但也是一种理想合法的表示分布的方式。它由每个数据点的垂直线组成。在这里，高度是任意的。分布的密度可以通过刻度线的密集程度得知。</p><p id="05de" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">rug plot和histogram之间的联系非常直接:histogram只是沿着数据的范围创建条柱，然后绘制一个高度等于每个条柱中的刻度数的条柱。在地毯图中，所有数据点都绘制在单个轴上，每个轴对应一个刻度线或线条。</p><p id="b433" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">与边缘直方图相比，rug plot在分布的可读性方面有所欠缺，但它在数据表示方面更加紧凑。地毯是一个很短很长的点符号显示，每个点符号代表一个独特的价值。垂直管道符号|通常用于最小化重叠。地毯地块可能不被认为是主要的地块选择，但在某些情况下，它可以是一个很好的支持者地块。</p><p id="b60c" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">绘制可变萼片的地毯。长度' :</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nx"><img src="../Images/cd9c7a3939efc40f9755ffb4bd4e3fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*Lk85b1WikBlYRyLb39tL3g.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入和输出单元</figcaption></figure><blockquote class="mx my mz"><p id="a63a" class="ir is lv it b iu ka iw ix iy kb ja jb na kc je jf nb kd ji jj nc ke jm jn ip hb bi translated"><strong class="it hj"> <em class="hi">注</em> </strong> <em class="hi"> : </em>在少数情况下，可能需要设置各轴数值的范围。在上图中，plt.subplots()函数返回一个图形对象和轴对象。使用传递给set_xlim()方法的axes对象“ax ”,设置X轴上要考虑的值的范围。</p></blockquote><p id="468f" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">核密度估计可以与地毯一起绘制，这可以提供对数据的更好理解。</p><p id="ec80" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">在matplotlib中，没有创建地毯图的直接函数。因此，scipy.stats模块用于创建所需的内核密度分布，然后使用<em class="lv"> plt.plot() </em>函数和地毯一起绘制。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nx"><img src="../Images/b5bbf3e54824408f370606efb947c1f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*-pZr5P_kfY17gaki39tYCw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(在Matplolib中绘制地毯和高斯分布)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nw"><img src="../Images/25fe38811b4da237983c1b92877fbe04.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*PDiYtLtnLmH7eXxzM1CW-w.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(在Matplolib中绘制地毯和高斯分布)</figcaption></figure><p id="5b31" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated"><strong class="it hj">所用方法的说明:</strong></p><p id="5eb9" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated"><em class="lv"> kde.gaussian_kde( ) </em>函数使用高斯核生成一个核密度估计。在单变量数据的当前情况下，该函数将一维数组作为输入数据集。为了得到所需的一维数组，首先使用函数<em class="lv"> to_numpy() </em>将数据帧转换为numpy数组，然后使用<em class="lv"> np.hstack() </em>函数将输入数组的序列水平(即按列)堆叠，形成一个数组。这个一维数组“rdf”然后被作为输入传递给<em class="lv"> kde.gaussian_kde() </em>函数。使用<em class="lv"> np.arange() </em>函数指定要考虑的值范围和步长。然后，使用<em class="lv"> plt.plot() </em>获取绘图。</p><p id="69dc" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">Seaborn库提供了一个更直接、更简单的函数来可视化这样一个带有许多参数的图。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es ny"><img src="../Images/371b49c5d3271641639aff01bf4f6a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*KxMpxM3N6aQv9wZWt8nAew.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(在Seaborn绘制地毯和高斯分布图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nw"><img src="../Images/a5a1feadc11211e03de14918bea39f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*g63dzPPDm3poLlFvWhecAw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(绘制Seaborn中的地毯和高斯分布)</figcaption></figure><h2 id="cbc6" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">8.箱线图:</h2><p id="ad3e" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">箱线图是一种非常有用的标准化方法，它基于五个数字的汇总(最小值、第一个四分位数、第二个四分位数(中值)、第三个四分位数、最大值)来显示数据的分布。它有助于理解数据分布的这些参数，并且对检测异常值非常有帮助。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nz"><img src="../Images/1c8e10c5dcd8cf124ba033d0f5ca4d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*FPnhYs6cs3ipUKIZhl9caA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">(来源:leansigmacorporation.com)</figcaption></figure><p id="f05f" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">变量“sepal.width”的绘图框绘图:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es oa"><img src="../Images/f84ab9b019e9dd4e179420165ea48501.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*26A66Ow9vQssQnNKZItLBw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(Matplotlib中的方框图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es ob"><img src="../Images/cfd9aa66d753374da9a8c070bfb534ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*kdjHnlHPRNz91OrQXl8uXw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(Matplotlib中的方框图)</figcaption></figure><p id="042d" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">在一帧中绘制所有变量的箱线图:</p><p id="6bb2" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">由于箱线图用于连续变量，首先创建一个没有“变化”列的数据框。然后使用<em class="lv"> drop( ) </em>函数从数据帧中删除该列，并指定axis=1来表示它。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es nn"><img src="../Images/9833864f24254cefe78659b39a0117d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*CibLMTtUfgag9ClHioD23g.png"/></div></div></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nz"><img src="../Images/c09a408e88b8fc92253700613dc0c528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*gdccdkI5DOKlCpzsncTBtg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(使用Matplotlib绘制所有变量的方框图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es oc"><img src="../Images/26f86515d95b4806dd4a11214c75e79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*NDFYCgPQZPLssKk8HTa5Qw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(使用Matplotlib绘制所有变量的方框图)</figcaption></figure><p id="bf11" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">在matplotlib中，单独提及标签以在输出中显示它。</p><p id="d9dc" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">《海边的箱线图》的绘制；</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es od"><img src="../Images/4d7468c2aaffb2f1fc7afa0c717f2995.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*L3iquR_iR2D0KehTLTvaZQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(Seaborn)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es no"><img src="../Images/8c5310cee235cb82c54175f90bc1b003.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*aiGFPKBEHIQsm5VMN9yDHw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">产量(Seaborn)</figcaption></figure><p id="07b7" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">绘制一帧中所有变量的箱线图:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es oe"><img src="../Images/189f9901acf711bb3acd542de7c973c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*xtBuJv4fK3LNti9XEB7WRg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(使用Seaborn的所有变量的箱线图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es of"><img src="../Images/ecad7b47e84da1c4a077896b102e1d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*0x_qAsQ0ZblqfTgXS9cErg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(使用Seaborn的所有变量的箱线图)</figcaption></figure><p id="ba3d" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">将pandas函数<em class="lv"> pd.melt() </em>应用于修改后的数据帧，然后将其传递给<em class="lv"> sns.boxplot() </em>函数。</p><h2 id="b759" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">9.距离图() :</h2><p id="d308" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">seaborn库的<em class="lv"> distplot() </em>函数在前面的rug plot部分已经提到过。该函数将matplotlib <em class="lv"> hist() </em>函数与seaborn <em class="lv"> kdeplot() </em>和<em class="lv"> rugplot() </em>函数结合在一起。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es og"><img src="../Images/45338038df6528720de90b301d3fbd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*C8XrnVO831uKVRinFtWlFw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">投入</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mb"><img src="../Images/89865e2f3ae9a6abcde7eec37f0112d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*7xqUshvBswGn88mOS9Mdmw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出</figcaption></figure><h2 id="8525" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">10.小提琴情节:</h2><p id="b455" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">Violin图与box图非常相似，只是在每一侧增加了一个旋转的核密度图。它显示了数量数据在一个(或多个)分类变量的几个级别上的分布，以便对这些分布进行比较。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es oh"><img src="../Images/077d49dfd69f2d0f56f7b594cd7d9698.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/0*6KukPJwa0gKlptaY.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">资料来源:r-bloggers.com</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mb"><img src="../Images/44736ed36f0f4de54c26d2fe540346d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*4FjyrtWYeN8VFtG24XIxWA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(Matplotlib中所有变量的小提琴图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es oi"><img src="../Images/9d99184a3fb354f825e2b60f400e21e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*070IOlrq24Dk657XF6yAbw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(Matplotlib中所有变量的Violin图)</figcaption></figure><p id="0c38" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">我们使用<em class="lv"> plt.violinplot( ) </em>函数。布尔参数“showmedians”被设置为True，因此会为每个变量标记中间值。小提琴图有助于理解变量的估计密度。</p><p id="5cf1" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">在seaborn库中，用于绘制小提琴图的函数也是类似的。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es oj"><img src="../Images/1a819f92e6fb72ff0fe5c27e9757e284.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*PLd8UFYIkYxi0vLJmA76dQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(锡伯恩的小提琴情节)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nl"><img src="../Images/d7874206ae1e682dc8d3ee99d4364eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*kgzy9FEnfvjQiFUi8uq7Ew.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(锡伯恩的小提琴情节)</figcaption></figure><p id="186d" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">根据数据集中提到的物种“多样性”比较变量“萼片宽度”:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es ok"><img src="../Images/e81abbfed79b698dec9363ec637e626c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*Jdi788gFntgYb1C-rwMKKw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(根据Seaborn中的类别的小提琴情节)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es ol"><img src="../Images/9eff1e8880d3863c36ca54661bec68fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*6BefklySIxTT4qfbtT1qTg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(根据Seaborn中的类别绘制的小提琴图)</figcaption></figure><h1 id="8c24" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">可视化分类变量:</h1><h2 id="121a" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">11.条形图:</h2><p id="f040" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">条形图是二维轴上的单变量数据可视化图。一个轴是指示类别的类别轴，而第二个轴是显示该类别的数值的数值轴，由条形的长度指示。</p><p id="d620" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated"><em class="lv"> plot.bar() </em>函数绘制分类变量的条形图。<em class="lv"> value_counts() </em>返回一个包含变量中唯一值计数的序列。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es om"><img src="../Images/4439d58e88a173bae16b74420bd30085.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*jj4mb5qDLb867GEpoY29DQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(使用熊猫的条形图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es on"><img src="../Images/ec077a8d5ec3b6f7dd72b2d86d37976f.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*3CfkP0AckHPAOjkXoxCYkw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(使用熊猫的条形图)</figcaption></figure><p id="c49e" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">seaborn库的<em class="lv"> countplot() </em>函数获得了一个类似的条形图。使用<em class="lv"> sns.countplot() </em>函数时无需单独计算计数。</p><p id="c3af" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">因为这种变化是平均分布的，所以我们得到了高度相等的条形。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es oo"><img src="../Images/b7374c84d8649211ccad44a0aa4e9799.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*YH5qX9pmYymLoN5vQOhSJg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(Seaborn的计数图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es op"><img src="../Images/78d7d6ad758cd4a4e455165a920518f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*jgV7izuVqOW8cn87pjU3UQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(Seaborn的计数图)</figcaption></figure><h2 id="a984" class="mf kg hi bd kh mg mh mi kl mj mk ml kp jc mm mn kt jg mo mp kx jk mq mr lb ms bi translated">12.饼图:</h2><p id="5692" class="pw-post-body-paragraph ir is hi it b iu lf iw ix iy lg ja jb jc mc je jf jg md ji jj jk me jm jn ip hb bi translated">饼图是最常用的方法，用于显示每个类别所占的数字比例。</p><p id="a7b7" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">使用<em class="lv"> plt.pie() </em>函数绘制饼图。因为类别是平均分布的，所以在饼图中平均划分各部分。然后通过将值数组传递给“labels”参数来添加标签。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es oq"><img src="../Images/1331e7b1b57a73b80d89da16002c3729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*b0Q9dC8deMGbvjTMnGg2VA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(使用熊猫的饼图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es or"><img src="../Images/2600ab7605c9854092b8495dd0b3b2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*9BYYMKkNbWQtYyMe0fO2DA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(使用熊猫的饼图)</figcaption></figure><p id="4e73" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated">可以使用<em class="lv"> DataFrame.sample( ) </em>函数创建一个随机样本。<em class="lv"> sample() </em>函数的frac参数表示要返回的轴项目的分数。</p><p id="6e76" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated"><em class="lv"> pie() </em>函数的“startangle”参数以特定角度逆时针旋转所有东西。此外，startangle的默认值为0。“autopct”参数允许用户使用Python字符串格式显示百分比值。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es os"><img src="../Images/9babc37b513648fd2c6baaf4ba52d648.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*8OBoCwcathnHZKfXZ3GMAA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">从数据帧中创建随机样本</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es ot"><img src="../Images/6d349e8837e18365ec582f4dd864f445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*m7eGyt_-Xj3mjOGSWiqhkg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输入(使用熊猫的饼图)</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nk"><img src="../Images/336eb34f6b5134bf2cbd4f96f79ae432.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*FnySNKmCFf-SljzRVmI5HQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">输出(使用熊猫的饼图)</figcaption></figure><blockquote class="if"><p id="6195" class="ig ih hi bd ii ij ik il im in io ip dx translated">大多数有助于单变量数据可视化的方法已经在本文中进行了概述。如前所述，查看数据所承载的结构和信息的能力在于其可视化呈现。</p></blockquote><h1 id="7529" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq ou ks kt ku ov kw kx ky ow la lb lc bi translated">参考资料:</h1><ol class=""><li id="1a8c" class="ld le hi it b iu lf iy lg jc lh jg li jk lj ip ox ll lm ln bi translated">https://www.rpubs.com/harshaash/Univariate_analysis<a class="ae lt" href="https://www.rpubs.com/harshaash/Univariate_analysis" rel="noopener ugc nofollow" target="_blank"/></li><li id="1b5d" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip ox ll lm ln bi translated">https://www.wikipedia.org/<a class="ae lt" href="https://www.wikipedia.org/" rel="noopener ugc nofollow" target="_blank">(每个情节的基本素材)</a></li><li id="43f6" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip ox ll lm ln bi translated"><a class="ae lt" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank">https://matplotlib.org/</a></li><li id="a966" class="ld le hi it b iu lo iy lp jc lq jg lr jk ls ip ox ll lm ln bi translated"><a class="ae lt" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank">https://seaborn.pydata.org/</a></li></ol></div><div class="ab cl oy oz gp pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="hb hc hd he hf"><p id="7925" class="pw-post-body-paragraph ir is hi it b iu ka iw ix iy kb ja jb jc kc je jf jg kd ji jj jk ke jm jn ip hb bi translated"><em class="lv">原载于2020年7月29日https://www.analyticsvidhya.com</em><a class="ae lt" href="https://www.analyticsvidhya.com/blog/2020/07/univariate-analysis-visualization-with-illustrations-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="lv"/></a><em class="lv">。</em></p></div></div>    
</body>
</html>