<html>
<head>
<title>What’s the best way to handle NaN values?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理NaN值的最好方法是什么？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/whats-the-best-way-to-handle-nan-values-part-1-continuous-values-c02a0afc15e5?source=collection_archive---------13-----------------------#2020-01-10">https://medium.com/analytics-vidhya/whats-the-best-way-to-handle-nan-values-part-1-continuous-values-c02a0afc15e5?source=collection_archive---------13-----------------------#2020-01-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f9dc0577857374099e9590da7cb0f7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvICETaCLqQNqjOTjwed4A.png"/></div></div></figure><p id="76c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我进行大数据分析的实践中，我发现了一个可以破坏每个数据分析过程的障碍。这个障碍在数据科学和机器学习中被称为NaN值。</p><h2 id="ecc0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">什么是NaN价值观？</h2><p id="c4cc" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">NaN —不是数字，是在<a class="ae ko" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank"> DataFrames </a>和<a class="ae ko" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> numpy </a>数组中的特殊值，表示单元格中缺少某个值。在编程语言中，它们也被表示，例如在Python中，它们被表示为None值。</p><p id="7598" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能认为None(或NaN)值只是零，因为它们表示没有值。但是这里有一个陷阱，零和None值的区别在于，zero是一个值(例如integer或float)，而None值表示没有这个值。这里有一个迷因很好地解释了零价值和零价值之间的区别:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/67b1d9eeba52c7818c80bf4172f43141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*deBCy2VgkXZOzeH4osPiyA.jpeg"/></div></div></figure><h2 id="2deb" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">南价值观有多危险？</h2><p id="ffc0" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">NaN值在两个方面是危险的:</p><ol class=""><li id="a0ca" class="ku kv hi is b it iu ix iy jb kw jf kx jj ky jn kz la lb lc bi translated">一些指标的变化，如平均值或中间值，因此给科学家错误的信息。</li><li id="1f7b" class="ku kv hi is b it ld ix le jb lf jf lg jj lh jn kz la lb lc bi translated">sklearn实现的算法不能在具有这种值的数据集上执行(尝试在<a class="ae ko" href="https://archive.ics.uci.edu/ml/datasets/Heart+Disease" rel="noopener ugc nofollow" target="_blank"> hearth-disease </a>数据集上实现<a class="ae ko" href="https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html" rel="noopener ugc nofollow" target="_blank">决策树分类器</a></li></ol><h2 id="d889" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">怎么处理他们？</h2><p id="1d18" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">那么，如果NaN值对数据科学家的工作如此危险，我们应该如何处理它们呢？有几种解决方案:</p><ol class=""><li id="c798" class="ku kv hi is b it iu ix iy jb kw jf kx jj ky jn kz la lb lc bi translated">擦除具有NaN值的行。但是这不是一个好的选择，因为这样我们会丢失信息，尤其是当我们处理小数据集的时候。</li><li id="8f4b" class="ku kv hi is b it ld ix le jb lf jf lg jj lh jn kz la lb lc bi translated">用特定的方法或值估算NaN值。本文参考了这些方法。</li></ol><p id="1d77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有很多方法来估算这些差距，在大多数情况下，数据科学家，尤其是新手不知道如何去做。以下是做这件事的方法:</p><ol class=""><li id="8049" class="ku kv hi is b it iu ix iy jb kw jf kx jj ky jn kz la lb lc bi translated">用特定值估算。</li><li id="7f74" class="ku kv hi is b it ld ix le jb lf jf lg jj lh jn kz la lb lc bi translated">用特殊指标估算，例如平均值或中值。</li><li id="cde8" class="ku kv hi is b it ld ix le jb lf jf lg jj lh jn kz la lb lc bi translated">使用方法估算:鼠标或KNN。</li></ol><p id="9f2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，让我们看看每个人是如何工作的，以及他们如何影响数据集。</p><h2 id="6ed7" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">实验！</h2><p id="600a" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">为了验证每一种方法，我选择了一个名为Iris数据集的数据集，这可能是机器学习测试中最常见的数据集。我还在更大、更复杂的数据集上尝试了这些方法，但对于某些算法来说，时间太长了。</p><p id="dc1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我为这个数据集中的每个特性列生成了15个介于0和149之间的随机且唯一的索引。使用这些索引(对于每个列，它们是单独生成的)，我用NaN更改了列值。</p><p id="ebb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在对这些NaN值应用每种方法后，我使用均方差(MSE)来检查每种方法的“准确性”。</p><p id="4968" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，我们开始吧。</p><h2 id="128f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">方法1:用特定值插补。</h2><p id="f882" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在这种方法中，NaN值用一个特定的值(例如一个数字)来改变，在大多数情况下这个值是0。有时这是最好的选择，就像你的特征是花在糖果上的钱，但有时这是最糟糕的选择，就像年龄。现在让我们看看它是如何影响初始数据集的:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/445cc7a82e8afa15fb4ba8ea5bf233f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLt_eEFXW_f5EAelHHVZ1w.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">零插补后的数据集可视化(开始有插补值)。</figcaption></figure><p id="7b10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您所看到的，用0填充NaN值会强烈影响那些不可能有0值的列。这将严重影响空间，取决于所使用的算法，尤其是KNN和TreeDecissionClassifier。</p><p id="9709" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">提示:<em class="ln">我们可以通过应用</em> <a class="ae ko" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.describe.html" rel="noopener ugc nofollow" target="_blank"> <em class="ln">来看看零是不是一个好的选择。描述()</em> </a> <em class="ln">函数到我们的数据帧。如果最小值等于0，那么它可能是一个好的选择，如果不是，那么你应该选择另一个选项。</em></p><h2 id="7e72" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">方法2:指标插补。</h2><p id="d7da" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">指标插补是一种用一些特殊指标填充NaN值的方法，这些指标取决于您的数据:例如平均值或中值。</p><p id="f551" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">平均值是一个序列中某个值的总和除以该序列中所有值的个数。它是统计学中最常用的度量类型之一。但是为什么我们用平均值来估算NaN值呢？均值有一个非常有趣的性质，如果你在数列中加入更多的均值，它不会改变。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/809a9b65e5398c7a3f06510b4966d58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eva6sbXRm0YYjXrFt523mg.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">均值插补后的数据集可视化。</figcaption></figure><p id="3520" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的图中，你可以看到它并没有过多地影响数据集的结构，最重要的是它没有将一个类的任何样本放入另一个类的区域。</p><p id="16bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">中值通过将系列的最大值和最小值相加来计算。然后将这个总数除以2。Median显示一个系列的精确中间值。在正态分布中(实际上在现实生活中并不存在)，平均值和中值是相等的。</p><p id="25b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于不存在正态分布，在大多数情况下，平均值和中值非常接近。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/1d49d3d2fedff97de31f76b68d64a80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjmR3gmWfxf8DBYLrc1kRw.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">中位数插补后的数据集可视化。</figcaption></figure><p id="12ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上面的图中，如果你仔细观察，可以清楚地看到中间值是如何工作的，所有的星星(估算的值)都排列在两条正交线上(萼片长度为5.6，萼片宽度为3.0)。</p><h2 id="7fc0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">方法3:用KNN进行估算</h2><p id="2c35" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">这种插补算法与sklearn的KNearesNeighbours非常相似。它从数据集中找到与NaN值的样本最接近的k个样本，并用它估算这些样本的平均值。</p><p id="5674" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个方法是在库impyute和sklearn中实现的(当我开始写这篇文章时，我不知道sklearn的实现。)</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/5695887a5de0e0c3e63667b633c04bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8ba6VX-kbS_HXqbInrDQw.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">KNN插补后的数据集可视化(有3个邻居)。</figcaption></figure><p id="c9a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上面的图中，我们可以看到一个严重的错误——将来自红色类的样本放置在蓝绿色区域中(这是具有3个邻居的knn实现)。</p><h2 id="14a6" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">方法4:用小鼠输入</h2><p id="2464" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">本文的最后一个算法，也是我目前知道的最好的一个算法——链式方程的多重插补。这种算法适用于每一个有缺失值的列，用当前值进行线性回归。之后，它使用该线性函数来估算具有这些值的预测的NaN值。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/d87c0a2740604ab12f6ce4dd6a246d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fa6gdXxHaYkZCzZrm2cxRw.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">小鼠插补后的数据集可视化。</figcaption></figure><p id="e967" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，在上面的图上，它并没有强烈影响2D图上的数据集表示。但是为什么呢？</p><p id="882d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">KNN和MICE插补使用整个数据集来替换NaN值，而中值和平均值仅使用缺失值的列，这就是为什么后两种算法不会强烈影响数据集结构，也不会改变其信息。</p><h2 id="4a97" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">但是这些数字说明了什么呢？</h2><p id="7f73" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">最后的话交给数字。他们发现上面提到的方法有多有效，我使用MSE(均方误差)。我计算了原始值和估算值之间的MSE值。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/2e4e388e00b6cb73175a7ac3befc5e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*0ArqZ17f8K_FJ8trkc_lAA.png"/></div></div></figure><p id="053b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上表显示了每种方法的MSE(在KNN和鼠标上，我使用了两个版本:一个包括目标值(有y值),另一个不包括它)。</p><p id="0fdd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是哪种算法最适合哪一列。</p><ul class=""><li id="551e" class="ku kv hi is b it iu ix iy jb kw jf kx jj ky jn lp la lb lc bi translated">萼片长度—小鼠</li><li id="1f15" class="ku kv hi is b it ld ix le jb lf jf lg jj lh jn lp la lb lc bi translated">萼片宽度— KNN4_y</li><li id="2b01" class="ku kv hi is b it ld ix le jb lf jf lg jj lh jn lp la lb lc bi translated">花瓣长度—老鼠</li><li id="454a" class="ku kv hi is b it ld ix le jb lf jf lg jj lh jn lp la lb lc bi translated">花瓣宽度—鼠标</li></ul><p id="be63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我所想的那样，老鼠在大多数情况下表现良好。</p><h2 id="0368" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">遗言:</h2><p id="4a4e" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我从这个实验中得到的结论是，估算连续值的最好方法是使用整个数据集，如MICE或KNN，而不仅仅是一列。当然，我在这个实验中还发现了更多的方法，但是我将在本文的下一部分继续介绍它们。</p><h2 id="72d1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak">感谢您的阅读！</strong></h2></div></div>    
</body>
</html>