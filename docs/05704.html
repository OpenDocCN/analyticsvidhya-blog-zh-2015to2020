<html>
<head>
<title>Predicting the fall of the COVID curve with Math!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用数学预测COVID曲线的下降！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-the-fall-of-covid-19-curve-with-math-aabd4b21615?source=collection_archive---------26-----------------------#2020-04-29">https://medium.com/analytics-vidhya/predicting-the-fall-of-covid-19-curve-with-math-aabd4b21615?source=collection_archive---------26-----------------------#2020-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f7ecea166c50da0623c581bb019fdcdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*BXLeosOOc99tPIM6H05ekQ.png"/></div></figure><p id="e322" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" rel="noopener" href="/@ajaykumaar.ak/diy-data-analysis-of-covid-19-da6cd0c99cd8">https://medium . com/@ ajaykumaar . AK/DIY-data-analysis-of-新冠肺炎-da6cd0c99cd8 </a></p><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es jl"><img src="../Images/de26924692e87ea726c12c33b2b68076.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*0BPqbTa2vb9WXN_uDIRxoA.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">前一篇文章中的病毒传播图</figcaption></figure><p id="a252" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你看了我以前的一篇关于绘制新冠肺炎相关图表的文章(上面的链接)，特别是日期和病例之间的图表，那么一个问题很自然地跃入脑海——如果我们可以绘制病毒传播的图表，如果它遵循一个趋势，我们可以推断出曲线何时可能变平或下降吗？</p><p id="c473" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">是的，使用数学，主要是微分，可以数学地预测曲线在什么时间点会变平或下降！(不要畏缩！继续阅读…)好消息是，即使你不是像我一样的数学爱好者，你仍然可以做到。你只需要知道导数是什么意思，它能做什么，PyTorch会帮我们计算。</p><p id="1060" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在处理COVID曲线之前，让我们先解决一个样本问题。我假设您的Google Colab实例已经安装了库并正在运行。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="1724" class="jz ka hi jv b fi kb kc l kd ke">!pip install fastai2 -q<br/>from fastai2.basics import *<br/>from fastai2.tabular.all import *</span></pre><p id="07cd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们将“x”(时间)分配给一个从1到20的数字数组，将“y”(比如速度)分配给“x”的二次函数。“torch.randn()”函数随机生成20个数字。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="9fdb" class="jz ka hi jv b fi kb kc l kd ke">x=torch.arange(0,20).<em class="kf">float</em>();x<br/>y = torch.randn(20)*3 + 0.75*(x-9.5)**2 + 1<br/>plt.scatter(x,y)</span></pre><p id="1ac8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们的样本数据已经准备好了，为了预测在任何给定时间点的“y ”,我们将随机考虑一条曲线，并试图修改或拟合该曲线，使其尽可能接近我们的实际曲线。毫不奇怪，这种技术被称为“曲线拟合”。我们将创建一个以“x”和几个常量(参数)作为输入的函数，并返回预测的y值。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="8bee" class="jz ka hi jv b fi kb kc l kd ke"><em class="kf">def</em> f(<em class="kf">t</em>,<em class="kf">params</em>):<br/>  a,b,c=params <br/>  return a*((t-10)**2) + (b*(t-10)) + c</span></pre><p id="cee0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该方程可以是任何随机曲线方程，唯一的限制是它应该具有与我们的问题曲线相似的性质，即二次方程不能用于拟合三次曲线。你可以使用像<a class="ae jk" href="https://www.desmos.com/calculator" rel="noopener ugc nofollow" target="_blank">德斯莫斯</a>这样的图形计算器，想出不同的曲线，然后试着摆弄它们。</p><p id="d466" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下一步是随机初始化参数(常量)并设置requires_grad()，这告诉PyTorch我们将利用这些参数的导数。现在我们可以通过将x(时间)和参数传递给我们假设的函数(f)来进行预测。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="492e" class="jz ka hi jv b fi kb kc l kd ke">params=torch.randn(3).requires_grad_();params<br/>preds=f(x,params);preds</span></pre><p id="4b11" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，为了绘制我们的预测，我们将创建一个小函数，它利用Matplotlib并在同一个图中绘制我们的预测值和实际值。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="b0a0" class="jz ka hi jv b fi kb kc l kd ke"><em class="kf">def</em> show_preds(<em class="kf">x</em>,<em class="kf">preds</em>,<em class="kf">targ</em>, <em class="kf">ax</em>=None):<br/>  if ax is None: ax=plt.subplots()[1]<br/>  ax.scatter(x,targ)<br/>  ax.scatter(x,to_np(preds), color='red')</span><span id="7a0c" class="jz ka hi jv b fi kg kc l kd ke">show_preds(x,preds,y)</span></pre><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/90971b750cf5932ab64ef9e6478a2bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*fk8-dqG47NMTMIqnkmLyDQ.png"/></div></figure><p id="91fd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那是相当接近的！您的输出可能与此完全不同，因为参数是在每次执行代码时随机初始化的。</p><p id="29b0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们需要一种方法来测量我们的曲线相对于实际曲线有多差(即测量误差)，从技术上来说，我们称之为“损失”。我们将创建一个函数，通过计算两条曲线之间的均方误差(MSE)来计算这两条曲线之间的损耗，这样做的函数被称为“损耗函数”，这并不奇怪。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="5e04" class="jz ka hi jv b fi kb kc l kd ke"><em class="kf">def</em> mse(<em class="kf">preds</em>,<em class="kf">target</em>):<br/>  return ((preds-target)**2).mean()</span><span id="e7db" class="jz ka hi jv b fi kg kc l kd ke">loss=mse(preds,y);loss</span></pre><p id="3343" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我损失了大约1813，这取决于随机初始化的值。关键的部分来了！</p><p id="6380" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">既然我们知道我们的损失，我们必须找到一种方法来更新或改变我们的参数，使我们的损失最小化，这就是差异化发挥作用的地方。假设我们用一些神秘变量(ep)来描绘我们的损失，而这个图只是一个可爱的抛物线。</p><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es ki"><img src="../Images/8ec045a93400cc27c6faf72efcd62a69.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*bDndRu6xUZL6_64P1Wm3TA.png"/></div></figure><p id="335c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们要做的就是找到我们损失最小的参数。有几种方法可以做到这一点，但最流行和最有效的方法是“牛顿-拉夫逊”法。有印象吗？</p><p id="8677" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将通过对损失函数和w.k.t .求导来做到这一点，函数的导数给出了某一点的斜率。因此，我们的任务简化为寻找斜率接近零的点，即损耗曲线的底部。我们将通过增加或减去参数的一小部分(微分)来实现这一点，我们所说的小部分取决于调用者的“学习率(lr)”值。这个过程被称为梯度下降(这是NR方法的一种改进)。</p><p id="2904" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们付诸行动吧！</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="d9e2" class="jz ka hi jv b fi kb kc l kd ke">loss.backward()<br/>params.grad</span></pre><p id="9c24" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">backward()属性计算损失函数的梯度(导数),可以通过对参数使用grad()属性来访问这些值。现在让我们做第一步梯度下降(GD)。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="1d9a" class="jz ka hi jv b fi kb kc l kd ke">lr=1e-05<br/>params.data=params.data - (lr*params.grad.data)<br/>params.grad=None</span></pre><p id="ebe1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">学习率(lr)是一个值，通常小于0.1，它决定了我们在沿着损失曲线下降时的步长，即参数的数量将被减去或增加。在计算新的梯度之前，我们应该将梯度设置回零。</p><p id="85b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们根据修改后的参数再次进行预测，并计算损失。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="fb64" class="jz ka hi jv b fi kb kc l kd ke">preds=f(x,params)<br/>loss=mse(preds,y)<br/>loss</span></pre><p id="82be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">损失减少到了1672英镑，相当可观。现在让我们将所有这些代码行包装成一个函数，这样我们就可以循环遍历它们。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="7a0f" class="jz ka hi jv b fi kb kc l kd ke"><em class="kf">def</em> fit(<em class="kf">x</em>,<em class="kf">y</em>,<em class="kf">params</em>,<em class="kf">print_loss</em>=True):<br/>  preds=f(x,params)<br/>  loss=mse(preds,y)<br/>  if print_loss == True: print(loss)<br/>  loss.backward()<br/>  params.data=params.data - (lr*params.grad.data)<br/>  params.grad=None<br/>  return preds</span></pre><p id="9469" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们循环这个函数50次，这个数叫做epoch，也就是我们的神秘变量(ep)！</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="de73" class="jz ka hi jv b fi kb kc l kd ke">for i in range(10):<br/>  fit(x,y,params)</span></pre><p id="5d7c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">随着我们反复运行拟合函数，我们的损耗逐渐减少，并在某一点达到饱和。现在让我们看看我们通过在中间阶段绘图所做的改进。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="695c" class="jz ka hi jv b fi kb kc l kd ke">_,axs = plt.subplots(1,4,figsize=(12,3))<br/>for ax in axs:<br/>  preds=fit(x,y,params,False)<br/>  show_preds(x,preds,y,ax)<br/>plt.tight_layout()</span></pre><p id="dd34" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就是这样！我们已经创建了一个非常基本的模型，随着它的发展，从它的错误中学习。根据定义，这就是机器学习！-通过经验自动改进的算法。</p><p id="6446" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们深入研究COVID曲线。我们刚刚做的梯度下降非常简单，因为我们的数据简单，在现实世界中，从头实现这一点将是一个痛苦的大脑。所以我们将使用这样的库。</p><p id="9291" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们按照之前制作COVID图时的步骤准备好数据，直到我们创建了包含日期、病例、治愈和死亡的数据框。现在让我们将日期转换成表示天数的数字，这有助于我们的计算和包含病例数的数组。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="8782" class="jz ka hi jv b fi kb kc l kd ke">date=array(ddf['Date'])<br/>n_days=torch.arange(0,len(date)).<em class="kf">float</em>();<br/>cases=array(ddf['Total Confirmed cases'])<br/>cases=torch.tensor(cases)<br/>cases=cases.<em class="kf">float</em>()</span><span id="ec4e" class="jz ka hi jv b fi kg kc l kd ke">plt.scatter(x=n_days,y=cases)</span></pre><p id="9612" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">线性回归和多项式回归的唯一区别是我们假设的曲线函数。因此，我们将使用来自sklearn的多项式特征，转换我们的x值(n_days ),并使用线性回归进行拟合。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="352d" class="jz ka hi jv b fi kb kc l kd ke">from sklearn.preprocessing import PolynomialFeatures<br/>from sklearn.linear_model import LinearRegression<br/>poly_feat=PolynomialFeatures(degree=4)<br/>x=n_days.reshape(-1,1)<br/>x_poly=poly_feat.fit_transform(x)<br/>lin_reg=LinearRegression()<br/>lin_reg.fit(x_poly,cases)</span></pre><p id="c147" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们所做的只是假设一个4次曲线方程，重新调整x值以匹配预期的输入形状，将这些变换应用到我们的x值，最后用实际曲线拟合它。我们使用的LinearRegression()算法增加了复杂的调整，如归一化、正则化和权重衰减，因此看起来比我们使用的基本方法复杂得多。它们不过是基本GD方程的即兴发挥。</p><p id="b041" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们在实际曲线上画出我们的预测曲线。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="d827" class="jz ka hi jv b fi kb kc l kd ke"><em class="kf">def</em> plot_pred():<br/>  plt.scatter(x,cases,color='red')<br/>  plt.plot(x, lin_reg.predict(poly_feat.fit_transform(x)),  color='blue')<br/>  plt.ylabel('Number of cases')<br/>  plt.xlabel('Number of days')<br/>  plt.title('case rate')<br/>  plt.show()<br/>plot_pred()</span></pre><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/3ded81f5cbed1a3c7b661410932f2cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*QvO9GKP211ojSUI1Vp7LnQ.png"/></div></figure><p id="6d1c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">完美契合！现在让我们创建一个进行预测的函数，从60天到170天循环一次，找到案例达到最大值和下降的点。</p><pre class="jm jn jo jp fd ju jv jw jx aw jy bi"><span id="ed57" class="jz ka hi jv b fi kb kc l kd ke">up_case=[]<br/>for i in range(60,170):<br/>  new=pred_case(i)<br/>  up_case.append(new)<br/>up_date=torch.arange(60,170)<br/>plt.plot(up_date,up_case)</span><span id="9061" class="jz ka hi jv b fi kg kc l kd ke">max_case=array(up_case).max();max_case<br/>up_case.index(max_case)</span></pre><p id="a633" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出是85，即从现在起85天后，病例数将开始下降。</p><p id="9099" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">顾名思义，这是一个纯粹基于数学的预测，并且严重依赖于条件保持不变直到第170天的假设。随着封锁等遏制措施的实施，局势的紧张程度可能会减轻。</p><p id="9b06" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以从下面的GitHub链接获得完整的代码，并查看杰瑞米·霍华德关于深度学习的课程，以了解更多关于Fastai的信息。</p><div class="kk kl ez fb km kn"><a href="https://github.com/ajaykumaar/Deep-learning/blob/master/covid_curve_fit.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hj fi z dy ks ea eb kt ed ef hh bi translated">ajaykumaar/深度学习</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">permalink dissolve GitHub是4000多万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">github.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb ik kn"/></div></div></a></div><p id="4cb6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">谢谢，继续学习；)</p></div></div>    
</body>
</html>