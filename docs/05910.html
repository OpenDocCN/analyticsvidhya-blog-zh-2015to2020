<html>
<head>
<title>Slicing Hierarchical Indexes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分层索引切片</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/slicing-hierarchical-indexes-e4fae9c65011?source=collection_archive---------19-----------------------#2020-05-05">https://medium.com/analytics-vidhya/slicing-hierarchical-indexes-e4fae9c65011?source=collection_archive---------19-----------------------#2020-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/dd3c2c36694342c3fa75ba3fa2ee635a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlaHShHMrGZzKCNtr2tXgQ.jpeg"/></div></div></figure><p id="1f13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上一个教程中，我们学习了一些有用的工具，如何对一些数据集进行更细致的数据分析，特别是当它们以更高维度呈现时。这就是我们所说的层次索引或多重索引。当一个数据帧有一个以上的索引列或更高维度时，称之为分层索引。你可以在这里<a class="ae jo" rel="noopener" href="/analytics-vidhya/hierarchical-indexing-76dcc6a8dd86">刷新你的记忆</a>，这样你就能感觉到我们在哪里，我将在本教程中谈论什么。</p><p id="4a0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将进入一些有用的分析，这些分析可以在多索引数据框架上进行。我将使用我在上一篇文章中使用的相同的<code class="du jp jq jr js b">Fifa19</code>数据框架。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="727e" class="kb kc hi js b fi kd ke l kf kg">In [1]: import pandas as pd<br/>In [2]: data = {'Position': ['GK','GK','GK', 'DF','DF','DF',<br/>            'MF','MF','MF','CF','CF','CF'],   <br/>            'Name': ['De Gea', 'Coutois','Allison','Van Dijk',<br/>            'Ramos','Godin','Hazard','Kante','De Bruyne', 'Ronaldo'<br/>            'Messi','Neymar'],<br/>            'Overall': ['91','88','89','89','91','90','91',<br/>            '90','92','94','93','92'],<br/>            'Rank': ['1st','3rd','2nd','3rd','1st','2nd',<br/>            '2nd','3rd','1st','1st','2nd','3rd']}<br/>In [3]: fifa19 = pd.DataFrame(data, columns=['Position','Name',<br/>                'Overall','Rank'])<br/>In [4]: fifa19<br/>Out[4]: <br/>             Position     Name        Overall     Rank<br/>     0        GK         De Gea          91        1st<br/>     1        GK         Coutios         88        3rd<br/>     2        GK         Allison         89        2nd<br/>     3        DF         Van Dijk        89        3rd<br/>     4        DF         Ramos           91        1st<br/>     5        DF         Godin           90        2nd<br/>     6        MF         Hazard          91        2nd<br/>     7        MF         Kante           90        3rd<br/>     8        MF         De Bruyne       92        1st<br/>     9        CF         Ronaldo         94        1st<br/>     10       CF         Messi           93        2nd<br/>     11       CF         Neymar          92        3rd</span></pre><p id="2b69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个数据框架来自于从<code class="du jp jq jr js b">EA Sport</code>的FIFA19数据集中选出的几个球员的球员评级。数据帧目前没有以我们喜欢的格式呈现，所以我将快速跳过几个步骤，对其进行多索引和排序。如果漏了哪一步，可以参考之前的帖子<a class="ae jo" rel="noopener" href="/analytics-vidhya/hierarchical-indexing-76dcc6a8dd86">这里</a>。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="6206" class="kb kc hi js b fi kd ke l kf kg">In [5]: fifa19.set_index(['Position','Rank']).sort_index()<br/>Out[5]:              Name     Overall<br/>    Position  Rank  <br/>     CF       1st    Ronaldo     94<br/>              2nd    Messi       93<br/>              3rd    Neymar      92<br/>     DF       1st    Ramos       91<br/>              2nd    Godin       90<br/>              3rd    Van Dijk    89<br/>     GK       1st    De Gea      91<br/>              2nd    Coutois     89<br/>              3rd    Allison     88<br/>     MF       1st    De Bruyne   92<br/>              2nd    Hazard      91<br/>              3rd    Kante       90</span></pre><p id="01d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的数据现在已经以分层的方式分类，并准备好进行分析。</p><p id="e332" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对分层索引的数据帧进行排序是有用的切片。例如，如果我们想根据FIFA19数据集找出这些人中谁是最好的中锋，我们将调用<code class="du jp jq jr js b">.loc</code>访问器并传递一个元组<code class="du jp jq jr js b">('CF' ,'1st')</code>来提取数据帧中排名最高的前锋。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="9047" class="kb kc hi js b fi kd ke l kf kg">In [6]: fifa19.loc[('CF', '1st')]<br/>Out[6]:<br/>      Name    Ronaldo<br/>      Overall 94<br/>      Name: (CF, 1st), dtype: object</span></pre><p id="2f13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，如果我们在tuple后面加上一个特定的列名，即“name”或“total ”,我们将提取表中的一个元素。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="effe" class="kb kc hi js b fi kd ke l kf kg">In [7]: fifa19.loc[('CF', '1st'), 'Name']<br/>Out[7]: <br/>       'Ronaldo'</span></pre><p id="4b2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，如果我们碰巧用一个单独的字符串调用<code class="du jp jq jr js b">.loc</code>访问器，比如只调用‘GK’，Pandas将对外部索引进行切片，并返回所有与切片字符串对应的行，即‘GK’。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="cf1c" class="kb kc hi js b fi kd ke l kf kg">In [8]: fifa19.loc['GK']<br/>Out[8]:       Name      Overall<br/>    Rank<br/>     1st     De Gea     91<br/>     2nd     Alisson    89<br/>     3rd     Coutois    88</span></pre><p id="7178" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以做的另一件事是使用索引列表提取切片。我们通过在调用<code class="du jp jq jr js b">.loc</code>访问器后传递两个或更多索引字符串的列表来实现这一点。Pandas然后返回这些索引的所有行。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="58ec" class="kb kc hi js b fi kd ke l kf kg">In [9]: fifa19.loc[['GK', 'MF']]<br/>Out[9]:              Name       Overall<br/> Position    Rank<br/>       GK    1st     De Gea      91<br/>             3rd     Coutois     88<br/>             2nd     Alisson     89<br/>       MF    2nd     Hazard      91<br/>             3rd     Kante       90<br/>             1st     De Bruyne   92</span></pre><p id="673b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有些情况下，我们需要找出，例如，在一些特定的位置，只有排名最高的球员。Pandas使用由一个列表和内部选择索引组成的元组实现了这一点。我要说的是，如果我们需要切片，比方说，守门员(' GK ')和中场(' MF ')中的第三名球员，我们将在调用<code class="du jp jq jr js b">.loc</code>访问器后传递一个元组，在元组中，传递一个只包含' GK '和' MF '的列表，然后在逗号后传递'第三名'。然后，我们将在<code class="du jp jq jr js b">.loc</code>调用的最后添加一个冒号，表示我们希望返回这些索引的所有行。</p><p id="e355" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="53a8" class="kb kc hi js b fi kd ke l kf kg">In [10]: fifa19.loc[(['GK' ,'MF'], '3rd'), :]<br/>Out[10]:          Name     Overall<br/>  Postion  Rank  <br/>      GK    3rd   Coutois  88<br/>      MF    3rd   Kante    90</span></pre><p id="4610" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，我们只对特定的列感兴趣，而不是对所选位置的整行感兴趣，我们称该特定列为冒号<code class="du jp jq jr js b">:</code></p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="38bb" class="kb kc hi js b fi kd ke l kf kg">In [10]: fifa19.loc[(['GK' ,'MF'], '3rd'), 'Name']<br/>Out[10]:  <br/>       Postion  Rank  <br/>       GK       3rd   Coutois  <br/>       MF       3rd   Kante    <br/>       Name: Name, dtype: object</span></pre><p id="2b26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种奇特的索引切片方式也适用于内部级别。基于内部索引查找数据有时会很棘手。如果你注意细节，你可能会遇到问题。语法与外部索引非常相似。也就是说，如果我们想在数据帧中看到排名最好和最差的中锋，我们可以通过调用“CF ”,后跟“1st”和“3rd”列表，然后是冒号<code class="du jp jq jr js b">:</code>来返回这些行的所有列。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="9c8f" class="kb kc hi js b fi kd ke l kf kg">In [11]: fifa19.loc[('CF', ['1st' , '3rd']),:]<br/>Out[11]:         Name     Overall<br/>  Postion  Rank  <br/>      CF   1st   Ronaldo   94<br/>           3rd   Neymar    92</span></pre><p id="1259" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">说到分层索引，我觉得我必须向您介绍最后一个技巧。就是利用python的内置函数<code class="du jp jq jr js b">Slice()</code></p><p id="1a45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用于索引的元组本身不识别带冒号的切片。为了做到这一点，我们显式地使用Python的<code class="du jp jq jr js b">Slice()</code>。</p><p id="9d8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个<code class="du jp jq jr js b">Slice()</code>创建一个slice类型的实例。我们已经知道，一个切片可以用来索引<code class="du jp jq jr js b">Start</code>、<code class="du jp jq jr js b">End</code>、<code class="du jp jq jr js b">Step</code>中的序列。</p><p id="4f8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们想在每个位置上选择得分最高的球员，我们可以用</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="c526" class="kb kc hi js b fi kd ke l kf kg">In [12]: fifa19.loc[(['CF','DF','GK' ,'MF', ], '1st'), :]<br/>out[12]:           Name     Overall<br/>  Postion  Rank  <br/>      CF   1st     Ronaldo     94<br/>      DF   1st     Ramos       91<br/>      GK   1st     De Gea      91<br/>      MF   1st     De Bruyne   92</span></pre><p id="93f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这很完美，但是我们可以有一个“更简单”的选择，那就是使用<code class="du jp jq jr js b">Slice()</code>。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="1a3d" class="kb kc hi js b fi kd ke l kf kg">In [13]: fifa19.loc[(slice(None), '1st'), :]<br/>out[13]:           Name     Overall<br/>  Postion  Rank  <br/>      CF   1st     Ronaldo     94<br/>      DF   1st     Ramos       91<br/>      GK   1st     De Gea      91<br/>      MF   1st     De Bruyne   92</span></pre><p id="df6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用“None”来获取所有3个切片参数的默认值。</p><p id="edcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">Slice(None)</code>创建一个slice实例作为Slice(none，none，none ),从而返回所有具有“1st”索引的行。</p><p id="66d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这似乎是一个难题。此时你应该有足够多的东西可以咀嚼了。我会在这里结束它。你可以抽出时间自己练习这些。这些概念相对容易理解。</p><p id="6736" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下一个教程中，我将处理旋转，数据透视表，堆栈和融化。</p><p id="1bee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在那之前，继续编码吧！</p></div></div>    
</body>
</html>