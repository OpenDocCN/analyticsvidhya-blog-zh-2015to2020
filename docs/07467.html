<html>
<head>
<title>Making a d3.js scatter-plot interactive — part two</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使d3.js散点图具有交互性—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/making-a-d3-js-scatter-plot-interactive-part-two-f89bed0cb089?source=collection_archive---------17-----------------------#2020-06-26">https://medium.com/analytics-vidhya/making-a-d3-js-scatter-plot-interactive-part-two-f89bed0cb089?source=collection_archive---------17-----------------------#2020-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="208f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程是从<a class="ae jd" rel="noopener" href="/@sabahatiqbal/making-a-d3-js-scatter-plot-interactive-19916fb10bb1">之前的</a>教程中挑选出来的。提醒一下，这是数据结构的样子:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/3bcf23491527a275cc617a9476d7e7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ggJ8_b4sbTiJLsFX.png"/></div></div></figure><p id="168f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">贫困率是y轴值，最后一列中的指标是x轴值，随每个数据集而变化。</p><p id="6ce7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上一个教程中，我们更改了省值，但在本教程中，我们将更新年份。(在<a class="ae jd" href="https://github.com/SabahatPK/Data4Pakistan_PovertyIndicator_INTERACTIVE_a" rel="noopener ugc nofollow" target="_blank"> Github </a>上的所有代码和演示可在<a class="ae jd" href="https://interactive-scatter-tutorial-2.netlify.app/" rel="noopener ugc nofollow" target="_blank">这里</a>获得)。这意味着我们将需要调用<code class="du jq jr js jt b">update </code>选择，因为我们想要选择已经显示在页面上的数据点，并且<strong class="ih hj"> <em class="ju">以某种方式改变</em> </strong>(与调用从页面移除数据点的<code class="du jq jr js jt b">exit </code>或向页面添加数据点的<code class="du jq jr js jt b">enter</code>相反)。</p><p id="d38f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和前面的教程一样，我们必须首先“捕获”用户的选择，在本例中是<code class="du jq jr js jt b">Year </code>值。这可以通过多种方式实现，但我们将再次使用下拉元素，它位于省下拉列表的旁边:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jv"><img src="../Images/0cba4d227212e8f7b8d2f008b0e1fcb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*2KzaBvkr6vd_PT4TPlYBXA.png"/></div></figure><p id="9278" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，除了使用<code class="du jq jr js jt b">Province</code>值，还使用<code class="du jq jr js jt b">Year</code>值过滤数据。所有这些都是基本的JS，所以这里没有什么新东西:</p><pre class="jf jg jh ji fd jw jt jx jy aw jz bi"><span id="07fc" class="ka kb hi jt b fi kc kd l ke kf">//Function that builds the right chart depending on user choice on website:<br/>function updateChart(someData) {<br/> let dataAdultLit = d3<br/> .nest()<br/> .key(function (d) {<br/> return d[“Year”];<br/> })<br/> .entries(someData[0]);</span><span id="6c9c" class="ka kb hi jt b fi kg kd l ke kf">let selectedDate = new Date($(“#yearChoice”).val()).toString();</span><span id="8300" class="ka kb hi jt b fi kg kd l ke kf">let filteredData = dataAdultLit.filter(<br/> (each) =&gt; each.key === selectedDate<br/> )[0];</span><span id="7f97" class="ka kb hi jt b fi kg kd l ke kf">filteredData =<br/> $(“#geographicChoice”).val() === “allProv”<br/> ? filteredData[“values”]<br/> : filteredData[“values”].filter(<br/> (each) =&gt; each[“Province”] === $(“#geographicChoice”).val()<br/> );</span><span id="26b9" class="ka kb hi jt b fi kg kd l ke kf">//More code...</span><span id="c4ce" class="ka kb hi jt b fi kg kd l ke kf">}</span></pre><p id="0810" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加一个函数来捕捉用户的选择，然后触发图表的更新。同样，没什么新鲜的:</p><pre class="jf jg jh ji fd jw jt jx jy aw jz bi"><span id="26dd" class="ka kb hi jt b fi kc kd l ke kf">//Add in event listener for Year choice.<br/>$(“#yearChoice”).on(“change”, function () {<br/> updateChart(allData);<br/>});</span></pre><h2 id="2109" class="ka kb hi bd kh ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">d3更新模式:进入、更新、退出</h2><p id="1a5f" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">现在，我们需要考虑每当用户选择一个新的<code class="du jq jr js jt b">Year</code>时，图表的哪些部分需要改变。显然，有了新的<code class="du jq jr js jt b">Year</code>，唯一应该改变的元素是图表中的圆圈。不会改变的元素？x轴、y轴、轴标签、色标。最佳实践是从<code class="du jq jr js jt b">updateChart</code>函数中取出该代码，因为我们不希望每次用户改变<code class="du jq jr js jt b">Year</code>值时都重新创建这些元素。这有两个原因:</p><ol class=""><li id="5beb" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">性能—一般来说，不要重新运行不必要的代码。</li><li id="eb53" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">美观—如果x轴和y轴代码在每次更新<code class="du jq jr js jt b">Year</code>时运行，我们将在页面上以多个轴相互叠加而结束。起初它们可能不明显，但过一会儿线条和刻度会变粗。这很糟糕。</li></ol><p id="ab86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，我们必须把东西移到<code class="du jq jr js jt b">updateChart</code>之外。太好了。但是要小心。我们不应该移动那些链接到<code class="du jq jr js jt b">updateChart</code>中的参数的代码行，在这里是数据集。</p><p id="b843" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，因为x轴、y轴或色阶的属性都不使用数据集中的任何数据，所以我们可以安全地将所有代码移出函数。我们不能将代码移出函数的一个例子:例如，如果任一轴的<code class="du jq jr js jt b">domain</code>属性依赖于数据集中的一个值(这是<code class="du jq jr js jt b">updateChart</code>中的一个参数)</p><p id="a595" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，现在我们知道我们想要更新图表上圆圈的位置。我们如何做到这一点？通过更新它们的<code class="du jq jr js jt b">cx</code>和<code class="du jq jr js jt b">cy</code>属性。所以心理模型是:</p><ol class=""><li id="c381" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">用默认的<code class="du jq jr js jt b">Year</code>值加载网页，即<code class="du jq jr js jt b">2004</code>。</li><li id="cca1" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">将数据加入SVG元素，即<code class="du jq jr js jt b">circle</code>。</li><li id="9d29" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">显示图表。这是d3更新模式的<strong class="ih hj">输入</strong>部分。</li><li id="900e" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">用户选择新的<code class="du jq jr js jt b">Year</code>值。</li><li id="608f" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">所有现有的圆必须移动到新的<code class="du jq jr js jt b">cx</code>和<code class="du jq jr js jt b">cy </code>位置。这是d3更新模式的<strong class="ih hj">更新</strong>部分。</li><li id="fb66" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">如果新的<code class="du jq jr js jt b">Year</code>值没有特定圆的数据，即新的<code class="du jq jr js jt b">Year</code>值缺少<code class="du jq jr js jt b">District</code>的数据，则必须移除该圆。这是d3更新模式的<strong class="ih hj">退出</strong>部分。我们在上一个教程中看到了这一点。</li></ol><p id="1d67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们知道我们必须运行每个部分:进入，更新，退出。只不过我们不按那个顺序来。相反，在数据连接之后:</p><pre class="jf jg jh ji fd jw jt jx jy aw jz bi"><span id="32e8" class="ka kb hi jt b fi kc kd l ke kf">// JOIN data to elements.<br/> let circles = svg.selectAll(“circle”).data(filteredData, function (d) {<br/> return d[“District”];<br/> });</span></pre><ol class=""><li id="2eae" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">我们选择一个新的<code class="du jq jr js jt b">Year</code>值，首先，<strong class="ih hj">移除</strong>任何不再需要出现在屏幕上的圆圈。这些基本上是在默认<code class="du jq jr js jt b">Year</code>中有值的<code class="du jq jr js jt b">Districts</code>，但是由于某种原因(通常是缺少数据)，相同的<code class="du jq jr js jt b">District</code>没有新<code class="du jq jr js jt b">Year</code>的数据。因此，运行<code class="du jq jr js jt b">exit</code>步骤:</li></ol><pre class="jf jg jh ji fd jw jt jx jy aw jz bi"><span id="1367" class="ka kb hi jt b fi kc kd l ke kf">//EXIT old elements not present in new data.<br/> circles.exit().remove();</span></pre><p id="40b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.然后，我们运行更新步骤。注意:没有实际的更新关键字(就像<code class="du jq jr js jt b">exit</code>和<code class="du jq jr js jt b">enter</code>一样)。本质上，我们只是运行与<code class="du jq jr js jt b">enter</code>相同的代码，但只改变那些需要根据新数据而改变的属性，即新的<code class="du jq jr js jt b">Year,</code>:</p><pre class="jf jg jh ji fd jw jt jx jy aw jz bi"><span id="a99b" class="ka kb hi jt b fi kc kd l ke kf">//UPDATE existing elements to new position in graph:<br/> circles<br/> .attr(“cy”, function (d) {<br/> return y(d[“Poverty Rate (%)”]);<br/> })<br/> .attr(“cx”, function (d) {<br/> return x(<br/> d[<br/> “Adult literacy, 25 or more years old (% of population aged 25 or more)”<br/> ]<br/> );<br/> });</span></pre><p id="17a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.最后，我们运行<code class="du jq jr js jt b">enter</code>步骤:</p><pre class="jf jg jh ji fd jw jt jx jy aw jz bi"><span id="09c9" class="ka kb hi jt b fi kc kd l ke kf">// ENTER new elements present in new data.<br/> circles<br/> .enter()<br/> .append(“circle”)<br/> .attr(“class”, “enter”)<br/> .attr(“fill”, function (d) {<br/> return color(d[“Province”]);<br/> })<br/> .attr(“cy”, function (d) {<br/> return y(d[“Poverty Rate (%)”]);<br/> })<br/> .attr(“cx”, function (d) {<br/> return x(<br/> d[<br/> “Adult literacy, 25 or more years old (% of population aged 25 or more)”<br/> ]<br/> );<br/> })<br/> .attr(“r”, 5);<br/>}</span></pre></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="a4e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当数据连接到SVG圆形元素时，它立即返回三个选择。我们可以看到这是我们在数据加入步骤后立即进行的<code class="du jq jr js jt b">console.log(circles)</code>:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ma"><img src="../Images/b9ba548c222c6cd744c0db409b30b5f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*AAQly3Ss005vo826SZqBcw.png"/></div><figcaption class="mb mc et er es md me bd b be z dx translated">数据连接的结果。</figcaption></figure><p id="6196" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jq jr js jt b">_enter</code>选择包括作为数据连接的结果而存在但未在图表上显示的所有数据元素。在web页面的初始启动阶段，这是唯一一个绑定了数据的页面。</p><p id="6c24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jq jr js jt b">_exit</code>选择包括所有不再有数据元素链接的SVG元素。这在初始页面启动时是空的。</p><p id="467a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jq jr js jt b">_groups</code>选择包括图表上的所有SVG元素。这在初始页面启动时是空的。</p><p id="5530" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次数据更改时，这些选择都会更新，因此您可以对它们进行一些操作，例如，向页面添加具有特定属性的SVG元素，从页面中删除SVG元素，更改页面上已有的SVG元素的属性。</p><p id="2c17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进入、更新、退出的概念很难理解。所以，如果你没有马上得到它，也不要担心。这需要练习。</p><p id="f759" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你遇到任何问题，请留下评论。</p></div></div>    
</body>
</html>