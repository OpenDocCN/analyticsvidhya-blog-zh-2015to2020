<html>
<head>
<title>Serverless and SQL with Python on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS上使用Python的无服务器和SQL</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/serverless-and-sql-with-python-on-aws-9967554c1283?source=collection_archive---------8-----------------------#2020-06-14">https://medium.com/analytics-vidhya/serverless-and-sql-with-python-on-aws-9967554c1283?source=collection_archive---------8-----------------------#2020-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9937dddeefb4b33cde837a99c11e62b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VUYk9CrQZ8qVOzs1"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">卡斯帕·卡米尔·鲁宾在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3551" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们最近的一个项目中，由于数据及其关系的性质，我们需要一个经典的SQL数据库。只要有可能，我们就为我们的云项目使用无服务器方法。因此，我们决定在AWS环境中构建支持SQL的lambdas。让我告诉你一些我们是如何做到这一点的。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="3c2e" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">设置</h1><p id="c309" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们从以下组件开始:</p><ul class=""><li id="dd5f" class="ld le hi ix b iy iz jc jd jg lf jk lg jo lh js li lj lk ll bi translated"><a class="ae iu" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>带AWS Lambda和API网关</li><li id="d072" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">AWS RDS上的MySQL社区数据库</li></ul><p id="b696" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了扩大和缩小规模，你应该考虑使用<a class="ae iu" href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html" rel="noopener ugc nofollow" target="_blank"> AWS Aurora无服务器</a>。查看这篇关于<a class="ae iu" href="https://www.serverless.com/blog/choosing-a-database-with-serverless/" rel="noopener ugc nofollow" target="_blank">为无服务器应用</a>选择数据库的好文章。</p><p id="deee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的无服务器项目中，我们试图尽可能清晰地分离不同的模块，以便每个模块都有明确的职责。对于这个展示，我们将<em class="lr"> dogs </em>存储在数据库中，并通过lambda函数访问它们。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="bf92" class="mb kb hi lx b fi mc md l me mf">project<br/>  common<br/>    - db.py<br/>  data<br/>    model<br/>      - dog_data_object.py<br/>    - dog_data_access_service.py<br/>  function<br/>    common<br/>      - abstract.py<br/>    - dog.py<br/>  - serverless.yml</span></pre><h1 id="87c9" class="ka kb hi bd kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx bi translated">无服务器配置</h1><p id="6f46" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们使用serverless.yml文件将数据库连接变量设置为环境变量。这有助于我们稍后运行不同的环境概要文件(dev、int、prod……)，并允许我们使本地测试更加灵活。在这个例子中，我们仅仅创建了一个<em class="lr"> dog </em> GET函数来访问数据库。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="89ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，我们使用了<a class="ae iu" href="https://www.npmjs.com/package/serverless-python-requirements" rel="noopener ugc nofollow" target="_blank">server less-python-requirements</a>，这使得管理需求更加容易。</p><h1 id="4686" class="ka kb hi bd kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx bi translated">与数据库的连接</h1><p id="a8f0" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">为了连接到我们的MySQL数据库，我们使用强大的python库<a class="ae iu" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>。Alchemy是管理数据库会话的一个非常好的工具，可以帮助您进行对象关系映射。</p><p id="13d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们创建了一个单独的python模块来管理数据库引擎，提供<a class="ae iu" href="https://docs.sqlalchemy.org/en/13/orm/session_basics.html#what-does-the-session-do" rel="noopener ugc nofollow" target="_blank">会话</a>和Alchemy JSON编码器。编码器可以得到增强，以解决递归和循环对象结构(比较这个伟大的<a class="ae iu" href="https://stackoverflow.com/questions/5022066/how-to-serialize-sqlalchemy-result-to-json/41204271" rel="noopener ugc nofollow" target="_blank">职位</a>)。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h1 id="f69c" class="ka kb hi bd kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx bi translated">数据访问模块</h1><p id="bd29" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">为了将功能和数据清楚地分开，我们引入了一个提供数据库对象的数据访问模块。为此，您需要定义映射到某个表的数据库对象。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="3b04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个数据访问模块提供了对数据库对象的访问。注意，我们将SQLAlchemy会话作为参数传递，因为该会话是在函数级别上创建和管理的，并且还可以用于多个数据库访问调用。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h1 id="0f92" class="ka kb hi bd kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx bi translated">该功能</h1><p id="6654" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在我们想从函数中访问数据库。为此，我们创建了一个小的抽象处理程序，它包装我们的函数调用，并在函数成功运行后获取数据库会话并提交会话。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="c1b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个抽象处理程序提供了一个很好的方法来抽象像会话处理、用户管理或其他适用于您的函数集的一般事情。注意，我们也可以在这里使用装饰方法。</p><p id="0250" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们函数的实际逻辑非常简单，只专注于获取数据并返回数据的实际业务逻辑。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h1 id="6053" class="ka kb hi bd kc kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx bi translated">摘要</h1><p id="2a3e" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">用无服务器方法构建基于SQL的应用程序在业界肯定还不是默认的，但我相信它在未来会越来越强大。从实际的“服务器”中抽象出无服务器的美妙之处，使得DevOps世界中的软件工程师变得更加容易，以至于更多的经典应用程序(通常依赖于SQL数据库)最终也会考虑迁移到无服务器。</p><p id="1cca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了无服务器的巨大优势，在构建基于SQL的lambda函数时，还需要考虑两个主要的架构点:可伸缩性和关注点分离</p><p id="c9e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无服务器方法是使应用程序易于伸缩的好方法，但是如果数据库不能伸缩，这就帮不了你。你需要从一开始就考虑这一点，并找到合适的方法。显然，本文中的方法不太具有可伸缩性，但是有许多方法可以引导您。这里有一篇关于这个话题的不错的<a class="ae iu" href="https://www.red-gate.com/simple-talk/cloud/cloud-data/designing-highly-scalable-database-architectures/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="f1ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无服务器可以很好地将您的服务完全分离，并迁移到微服务架构，但请记住，您的数据组织需要代表您的微服务架构。因此，明智地决定哪一个无服务器功能负责哪一部分数据。让数百个功能分离您的服务是没有意义的，但是一个巨大的数据库由所有功能访问，没有任何分离。相应地分离您的数据，并为您的功能承担干净的数据责任。</p><p id="decd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我同意Paul Johnston的<a class="ae iu" rel="noopener" href="/@PaulDJohnston/serverless-and-microservices-a-match-made-in-heaven-9964f329a3bc">陈述</a>中的观点，即无服务器方法需要改变思维方式，需要分享更多的例子和经验，这样才能获得更大的动力。因此，分享你的观点和你对使用无服务器方法构建基于SQL的应用程序的看法。</p></div></div>    
</body>
</html>