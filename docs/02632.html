<html>
<head>
<title>A template for Python projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python项目的模板</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-template-for-python-projects-3539a5cbeaf1?source=collection_archive---------9-----------------------#2019-12-26">https://medium.com/analytics-vidhya/a-template-for-python-projects-3539a5cbeaf1?source=collection_archive---------9-----------------------#2019-12-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/c864dc02e9ab0add59d8762214d51de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m2QuNSNv6cHGfj76.jpg"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">我上周吃的午餐。完全不相关。</figcaption></figure><p id="df01" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我是一个懒惰的人。每次我发现自己做同样的事情超过两次，我就自动执行。一开始需要付出努力，但从长远来看是值得的。开始一个新的Python项目就是其中之一，今天我想和你们分享我的蓝图。可以在github 上找到<a class="ae ka" href="https://github.com/gabrieleangeletti/python-package-template" rel="noopener ugc nofollow" target="_blank">完整模板。对于中小型代码库来说，这种设置是一个很好的起点，它可以做一些常见的事情:</a></p><ul class=""><li id="ea97" class="kb kc hi je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj bi translated">设置开发环境</li><li id="1133" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">管理依赖关系</li><li id="f3fe" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">格式化您的代码</li><li id="249b" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">运行林挺、静态类型检查和单元测试</li></ul><p id="9757" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在接下来的部分中，我将描述如何在模板中设置这些东西。请注意，还缺少一些东西，我打算接下来添加:</p><ul class=""><li id="177e" class="kb kc hi je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj bi translated">部署脚本</li><li id="4938" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">持续集成管道</li></ul><h1 id="a78c" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">管理python版本— Pyenv</h1><p id="df49" class="pw-post-body-paragraph jc jd hi je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hb bi translated">管理python的多个版本，或者任何语言的多个版本，都是一种痛苦的经历，原因有很多:无法触及的系统版本、2对3的噩梦、需要不同解释器的两个不同项目等等。<a class="ae ka" href="https://github.com/pyenv/pyenv" rel="noopener ugc nofollow" target="_blank"> Pyenv </a>解决了这个问题:它是一个版本管理工具，在很多方面让你的生活更轻松。如果你来自Javascript /节点世界，这个工具类似于流行的<a class="ae ka" href="https://github.com/tj/n" rel="noopener ugc nofollow" target="_blank"> n </a>。</p><p id="99d7" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">使用<code class="du ls lt lu lv b">pyenv</code>,您可以轻松:</p><ul class=""><li id="5d15" class="kb kc hi je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj bi translated">安装新版本:<code class="du ls lt lu lv b">pyenv install X.Y.Z</code></li><li id="30b3" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">将版本设置为全局:<code class="du ls lt lu lv b">pyenv global X.Y.Z</code></li><li id="bae7" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">通过覆盖<code class="du ls lt lu lv b">PYENV_VERSION</code>环境变量来设置当前shell的版本</li><li id="a3f7" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">通过创建一个<code class="du ls lt lu lv b">.python-version</code>文件来设置特定于应用程序的版本</li></ul><h1 id="1048" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">管理依赖关系— Pipfile</h1><p id="9749" class="pw-post-body-paragraph jc jd hi je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hb bi translated">如果处理版本是痛苦的，那么处理依赖关系就更糟糕了。任何重要的应用程序都依赖于外部包，而外部包又依赖于其他包，确保每个人都获得相同的版本是相当具有挑战性的。在python世界中，依赖关系传统上是通过<code class="du ls lt lu lv b">requirements.txt</code>文件来管理的。它包含您的应用程序所需的软件包，可选地包含所需的版本。问题是这个文件不处理<em class="lw">递归</em>依赖，也就是你的应用程序依赖的依赖。Pipfile是一个新的规范，旨在解决这个问题。它比要求有许多优点。目前最大的一个是<em class="lw">确定性构建</em>。<code class="du ls lt lu lv b">Pipfile</code>和它的合作伙伴<code class="du ls lt lu lv b">Pipfile.lock</code>包含了在任何地方安装<em class="lw">相同环境</em>所需的所有信息。</p><p id="5087" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">举个例子吧。考虑以下场景:我们的应用程序<code class="du ls lt lu lv b">Ninja ducks</code>依赖于包<code class="du ls lt lu lv b">ninja</code>的版本<code class="du ls lt lu lv b">1.2.3</code>，而包<code class="du ls lt lu lv b">ninja</code>又依赖于另一个名为<code class="du ls lt lu lv b">requests</code>的包。</p><h2 id="8f1b" class="lx kq hi bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk bi translated">示例— requirements.txt</h2><p id="f179" class="pw-post-body-paragraph jc jd hi je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hb bi translated">一个<code class="du ls lt lu lv b">requirements.txt</code>文件应该是这样的:</p><p id="0576" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">运行<code class="du ls lt lu lv b">pip install -r requirements.txt</code>时，我们安装<code class="du ls lt lu lv b">ninja</code>的<code class="du ls lt lu lv b">1.2.3</code>版本，因为需求上是这么说的，还有<code class="du ls lt lu lv b">requests</code>的<code class="du ls lt lu lv b">2.7.9</code>版本，因为那是当时最新的公开版本。几周后，我们部署了应用程序，但同时<code class="du ls lt lu lv b">requests</code>被升级到了<code class="du ls lt lu lv b">3.0.0</code>。如果<code class="du ls lt lu lv b">ninja</code>使用了<code class="du ls lt lu lv b">requests</code>中已经被改变或删除的特性，我们的应用程序将会崩溃。我们可以通过将<code class="du ls lt lu lv b">requests</code>添加到需求文件中来解决这个问题，但是你可以自己看到这个解决方案并没有真正的扩展。</p><h2 id="b2eb" class="lx kq hi bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk bi translated">示例— Pipfile</h2><p id="3251" class="pw-post-body-paragraph jc jd hi je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hb bi translated">一个<code class="du ls lt lu lv b">Pipfile</code>应该是这样的:</p><pre class="in io ip iq fd ml lv mm mn aw mo bi"><span id="f9e9" class="lx kq hi lv b fi mp mq l mr ms">[[source]]<br/>url = "https://pypi.org/simple"<br/>verify_ssl = true<br/>name = "pypi"</span><span id="c6af" class="lx kq hi lv b fi mt mq l mr ms">[packages]<br/>ninja = {version = "==1.2.3"}</span></pre><p id="7d92" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">由此我们可以运行<code class="du ls lt lu lv b">pipenv lock</code>来生成一个<code class="du ls lt lu lv b">Pipfile.lock</code>:</p><pre class="in io ip iq fd ml lv mm mn aw mo bi"><span id="1f56" class="lx kq hi lv b fi mp mq l mr ms">{ "_meta":<br/>  {<br/>    "hash": {<br/>      "sha256": "[long string]"  <br/>    },<br/>    "pipfile-spec": 6,<br/>    "sources": [{<br/>        "name": "pypi",<br/>        "url": "https://pypi.org/simple",<br/>        "verify_ssl": true<br/>      }]<br/>    },<br/>    "default": {<br/>      "ninja": {<br/>        "hashes": [<br/>          "[long string]",<br/>          "[long string]"<br/>        ],<br/>        "version": "==1.2.3"<br/>      },<br/>      "requests": {<br/>        "hashes": [<br/>          "[long string]",<br/>          "[long string]"<br/>        ],<br/>        "version": "==2.7.9"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="2a4d" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">如你所见，<code class="du ls lt lu lv b">requests</code>是存在的，即使我们在<code class="du ls lt lu lv b">Pipfile</code>中没有提到它。这是因为<code class="du ls lt lu lv b">Pipfile</code>通过<code class="du ls lt lu lv b">Pipfile.lock</code>文件处理递归依赖关系。在部署期间，当我们运行<code class="du ls lt lu lv b">pipenv install --deploy</code>来安装依赖项时，将会安装正确版本的<code class="du ls lt lu lv b">requests</code>，而不管公共注册表中可用的最新版本。</p><ul class=""><li id="d042" class="kb kc hi je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj bi translated">注1:在上面我使用了几个<code class="du ls lt lu lv b">pipenv</code>命令，这是<code class="du ls lt lu lv b">Pipfile</code> <a class="ae ka" href="https://github.com/pypa/pipfile" rel="noopener ugc nofollow" target="_blank">规范</a>的<a class="ae ka" href="https://pipenv.readthedocs.io" rel="noopener ugc nofollow" target="_blank">参考实现</a></li><li id="454a" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">注意2:您需要将<code class="du ls lt lu lv b">Pipfile</code>和<code class="du ls lt lu lv b">Pipfile.lock</code>都添加到您的存储库中，否则您将无法恢复相同的环境</li><li id="2fcc" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">注3:如果你目前正在使用<code class="du ls lt lu lv b">requirements.txt</code>并想迁移到<code class="du ls lt lu lv b">Pipfile</code>，这里有一个<a class="ae ka" href="https://pipenv.readthedocs.io/en/latest/basics/#importing-from-requirements-txt" rel="noopener ugc nofollow" target="_blank">关于如何做的便捷指南</a></li></ul><p id="d2a8" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在<a class="ae ka" href="https://github.com/gabrieleangeletti/python-package-template" rel="noopener ugc nofollow" target="_blank">模板</a>中，<code class="du ls lt lu lv b">pyenv</code>和<code class="du ls lt lu lv b">pipenv</code>都可以通过提供的<code class="du ls lt lu lv b">./setup.sh</code>脚本进行安装。仅支持Linux和MacOS(部分软件包需要在Linux上手动安装)。</p><h1 id="6252" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">管理代码——我最喜欢的工具</h1><p id="5b7f" class="pw-post-body-paragraph jc jd hi je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hb bi translated">以下是我在Python项目中经常使用的代码质量工具的列表，没有特定的顺序。</p><h2 id="1d7e" class="lx kq hi bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk bi translated">格式—黑色</h2><p id="dd5f" class="pw-post-body-paragraph jc jd hi je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hb bi translated">根据我最近读的这本书，意志力是一种有限的资源。它就像一块肌肉，你不可能一整天都保持专注，并期望一直保持同样的生产力水平。这就是为什么在编程时，我想把时间花在重要的事情上，而不是缩进、括号等等。所有能自动化的事情都必须自动化。我认为代码格式化至少有两大好处:</p><ul class=""><li id="6e0a" class="kb kc hi je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj bi translated">您将对格式规则的控制权交给了该工具，这意味着您不再考虑它</li><li id="54f4" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">由于每个人都在船上，你不再和你的团队讨论完美的线路长度应该是42、79还是110(或者至少你在开始时只有一个大的讨论)</li></ul><p id="0575" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><a class="ae ka" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank"> Black </a>称自己是“不折不扣的Python代码格式化程序”，它是我最喜欢的格式化工具。使用起来超级简单，只需运行:</p><pre class="in io ip iq fd ml lv mm mn aw mo bi"><span id="5db6" class="lx kq hi lv b fi mp mq l mr ms">black {source directory}</span></pre><p id="dfa6" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">黑色有很多可配置的选项。我唯一用的是线长110。如果您查看完整的<a class="ae ka" href="https://github.com/gabrieleangeletti/python-package-template" rel="noopener ugc nofollow" target="_blank">项目模板</a>，我已经包含了一个方便的<code class="du ls lt lu lv b">./format_code.sh</code>脚本，它将在一个命令中格式化您的代码。</p><h2 id="f77d" class="lx kq hi bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk bi translated">林挺—薄片8</h2><p id="86f1" class="pw-post-body-paragraph jc jd hi je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hb bi translated">林挺是一个相当基本的代码质量检查，有助于防止代码中的简单错误。诸如打字错误、格式错误、未使用的变量等等。对我来说，林挺非常有用，因为:</p><ul class=""><li id="6f21" class="kb kc hi je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj bi translated">你不必检查次要的细节，因此你节省了时间</li><li id="6beb" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">其他开发人员不必检查次要的细节，因此他们节省了时间</li></ul><p id="b083" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我用<code class="du ls lt lu lv b">flake8</code>代表林挺。我特别喜欢的一个特性是忽略特定警告和错误的能力。例如，我使用110的线长，这与<a class="ae ka" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> PEP8 </a>样式指南(推荐79)相反。通过关闭相应的错误<code class="du ls lt lu lv b">E501</code>,我可以安全地使用任意长度的<code class="du ls lt lu lv b">flake8</code>。</p><p id="4909" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在<a class="ae ka" href="https://github.com/gabrieleangeletti/python-package-template" rel="noopener ugc nofollow" target="_blank">项目模板</a>中，你可以用<code class="du ls lt lu lv b">./test.sh lint</code>对你的包运行<code class="du ls lt lu lv b">flake8</code>。</p><h2 id="e77b" class="lx kq hi bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk bi translated">类型检查— Mypy</h2><p id="f272" class="pw-post-body-paragraph jc jd hi je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hb bi translated">这是迄今为止我最喜欢的。这个工具为python世界带来了静态类型检查。自从发现<code class="du ls lt lu lv b">mypy</code>以来，我从未写过一行非类型化的python。我不打算深入静态类型检查的细节，我只给你看一个从mypy的网站<a class="ae ka" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank">偷来的简单例子:</a></p><p id="ffcc" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">标准python:</p><pre class="in io ip iq fd ml lv mm mn aw mo bi"><span id="d22c" class="lx kq hi lv b fi mp mq l mr ms">def fibonacci(n):<br/>  a, b = 0, 1<br/>  while a &lt; n:<br/>    yield a<br/>    a, b = b, a+b</span></pre><p id="04f7" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">类型化python:</p><pre class="in io ip iq fd ml lv mm mn aw mo bi"><span id="adf8" class="lx kq hi lv b fi mp mq l mr ms">def fibonacci(n: int) -&gt; Iterator[int]:<br/>  a, b = 0, 1<br/>  while a &lt; n:<br/>    yield a<br/>    a, b = b, a+b</span></pre><p id="fd27" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这非常有用，因为:</p><ul class=""><li id="f5e4" class="kb kc hi je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj bi translated">通过查看函数的签名，我更有可能理解函数是做什么的</li><li id="c587" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">我甚至可以在运行代码之前就发现很多错误</li><li id="5026" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">我可以检查我是否正确地使用了第三方库</li></ul><p id="836e" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在<a class="ae ka" href="https://github.com/gabrieleangeletti/python-package-template" rel="noopener ugc nofollow" target="_blank">项目模板</a>中，你可以用<code class="du ls lt lu lv b">./test.sh type_check</code>对你的包运行<code class="du ls lt lu lv b">mypy</code>。</p><h2 id="92b1" class="lx kq hi bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk bi translated">测试— Pytest</h2><p id="34f5" class="pw-post-body-paragraph jc jd hi je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hb bi translated">Pytest是python最好的测试框架。它给你测试失败原因的详细信息，可以根据名称自动发现你的测试，对<a class="ae ka" href="https://docs.pytest.org/en/latest/fixture.html#fixture" rel="noopener ugc nofollow" target="_blank">夹具</a>有惊人的支持，还有很多有用的插件。使用<code class="du ls lt lu lv b">pytest</code>编写测试超级简单。考虑以下模块<code class="du ls lt lu lv b">my_module.py</code>:</p><pre class="in io ip iq fd ml lv mm mn aw mo bi"><span id="0854" class="lx kq hi lv b fi mp mq l mr ms">def my_func(x: int) -&gt; int:<br/>  return x ** 2</span></pre><p id="d6d5" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">为了测试这个函数，我们创建了一个名为<code class="du ls lt lu lv b">my_module_test.py</code>的模块:</p><pre class="in io ip iq fd ml lv mm mn aw mo bi"><span id="4e6e" class="lx kq hi lv b fi mp mq l mr ms">from . import my_module</span><span id="4d52" class="lx kq hi lv b fi mt mq l mr ms">def test_my_func():<br/>  expected = 9<br/>  actual = my_module.my_func(3)<br/>  assert actual == expected</span></pre><p id="7dfc" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我在<code class="du ls lt lu lv b">pytest</code>中使用的主要功能，按随机顺序排列如下:</p><ul class=""><li id="4fea" class="kb kc hi je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj bi translated"><code class="du ls lt lu lv b">pytest-cov</code>:为你的代码生成多种格式的测试覆盖报告的插件</li><li id="1bf9" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated"><code class="du ls lt lu lv b">pytest-mock</code>:为<a class="ae ka" href="https://stackoverflow.com/questions/5626193/what-is-monkey-patching" rel="noopener ugc nofollow" target="_blank">猴子打补丁</a>增加夹具的插件。用法:</li></ul><pre class="in io ip iq fd ml lv mm mn aw mo bi"><span id="f6f5" class="lx kq hi lv b fi mp mq l mr ms">def test_my_func(mocker):<br/>  mocker.patch(...)</span></pre><ul class=""><li id="f55f" class="kb kc hi je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj bi translated"><code class="du ls lt lu lv b">pytest-xdist</code>:并行运行单元测试。对于大型代码库尤其有用</li><li id="3962" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated">pytest的标记功能。您可以使用装饰器来标记测试:</li></ul><pre class="in io ip iq fd ml lv mm mn aw mo bi"><span id="fbdf" class="lx kq hi lv b fi mp mq l mr ms">import pytest</span><span id="1d2b" class="lx kq hi lv b fi mt mq l mr ms">@pytest.mark.integration<br/>def test_my_integration_test():<br/>  ...</span></pre><p id="79dc" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">那么您可以只运行标记为<code class="du ls lt lu lv b">integration</code>的测试。</p><p id="4ae0" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在<a class="ae ka" href="https://github.com/gabrieleangeletti/python-package-template" rel="noopener ugc nofollow" target="_blank">项目模板</a>中，你可以用<code class="du ls lt lu lv b">./test.sh unit_tests</code>对你的包运行<code class="du ls lt lu lv b">pytest</code>。</p><h2 id="4b98" class="lx kq hi bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk bi translated">其他人</h2><p id="7481" class="pw-post-body-paragraph jc jd hi je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hb bi translated">其他开发人员。我在项目中使用的工具有:</p><ul class=""><li id="b5d3" class="kb kc hi je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj bi translated"><code class="du ls lt lu lv b">isort</code>:自动对导入进行分类，并将其分成多个部分:内部、第一方、第三方等。再说一次，我完全是关于自动化的，这个工具从我的脑海中移除了另一件事</li><li id="263f" class="kb kc hi je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj bi translated"><code class="du ls lt lu lv b">vulture</code>检查死代码的工具，如未使用的函数、未使用的常数等。保持房子整洁是件好事，尤其是如果你知道破窗理论</li></ul><p id="0212" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">请在下面的评论中告诉我你的观点。完整的代码可以在<a class="ae ka" href="https://github.com/gabrieleangeletti/python-package-template" rel="noopener ugc nofollow" target="_blank">这里</a>找到(说明在自述文件中)。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="5347" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><em class="lw">原载于</em><a class="ae ka" href="https://gabrieleangeletti.github.io/blog/python-project-template/" rel="noopener ugc nofollow" target="_blank"><em class="lw">https://gabrieleangeletti . github . io</em></a><em class="lw">。</em></p></div></div>    
</body>
</html>