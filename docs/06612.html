<html>
<head>
<title>PyTorch🔦101, Part-1: Torch Tensors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch🔦101，第一部分:火炬张量</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pytorch-101-with-torch-tensors-2b7d5d7e2f21?source=collection_archive---------27-----------------------#2020-05-27">https://medium.com/analytics-vidhya/pytorch-101-with-torch-tensors-2b7d5d7e2f21?source=collection_archive---------27-----------------------#2020-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6f0fbaf454fb9ccd93f354766e7f0156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctRjv5OAkdAFtLCHLhblVw.jpeg"/></div></div></figure><p id="299a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PyTorch是一个令人惊叹的python库，它在构建深度学习中发挥了重要作用。Pytorch和Tensorflow一样有很高的社区支持。在这个脸书人工智能产品中有各种我想剪切的实用程序，</p><ol class=""><li id="da14" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">这个库在语法上与python 非常相似，因为它倾向于将python作为它的主要编程语言。您会发现与各种通用库(如-Numpy)在语法上有许多相似之处。现在，这一点把我们带到了下一个简单易学的点。</li><li id="a1f2" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">易学，</strong>由于语法与python非常相似，开发者学习起来更容易。并且文档组织得当，很容易在那个<a class="ae kc" href="https://pytorch.org/docs/stable/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>中找到你要找的东西，PyTorch 有一个巨大的<a class="ae kc" href="https://discuss.pytorch.org/" rel="noopener ugc nofollow" target="_blank">社区。</a></li><li id="b995" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">PyTorch有一个非常有用的特性叫做<a class="ae kc" href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html" rel="noopener ugc nofollow" target="_blank">数据并行</a>。使用这个特性，PyTorch可以在多个CPU或GPU核心之间分配计算工作。PyTorch的这个特性允许我们使用<code class="du kd ke kf kg b">torch.nn.DataParallel</code>来包装任何模块，并帮助我们在批处理维度上进行并行处理。</li></ol><p id="8f73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样的例子不胜枚举。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="42d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本教程基本上涵盖了不同的PyTorch张量函数，当您使用Pytorch执行不同的深度学习任务时，这些函数非常重要。实际上，任何PyTorch模型(如-ann、CNN)或操作都不能处理任何不是Torch张量的数组。因此，为了转换这些数组，特别是我正在考虑的NumPy数组，我们需要使用一些函数，还有一些奇妙的和sssuuupppeeerr简单的函数用于数学运算和一些深度学习实用程序。那么，说了这么多，让我们从目录开始吧</p><h2 id="f153" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jb kz la lb jf lc ld le jj lf lg lh li bi translated">目录:</h2><ol class=""><li id="d977" class="jo jp hi is b it lj ix lk jb ll jf lm jj ln jn jt ju jv jw bi translated">火炬。张量()</li><li id="10ec" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">torch.ones()</li><li id="ac49" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">火炬.零点()</li><li id="f0eb" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">torch.rand()</li><li id="f44c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">火炬.手动_种子()</li><li id="2995" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">将火炬张量从CPU移动到gup，反之亦然</li><li id="7b18" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">火炬张量的大小转换</li><li id="0753" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">数学实现</li></ol><h2 id="0b10" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jb kz la lb jf lc ld le jj lf lg lh li bi translated">导入所需的库:</h2><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="7111" class="lu kp hi bd kq lv lw lx ku ly lz ma ky mb mc md lb me mf mg le mh mi mj lh mk bi translated">火炬。张量()</h1><p id="b533" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn hb bi translated">这是一个PyTorch函数，它帮助我们创建PyTorch张量或数组。我们只需要在火炬内部传递一个NumPy数组或者一个list。张量()然后嘣，你的PyTorch张量就好了。在这里，我首先创建了一个列表(6号单元格)，然后创建了一个NumPy数组(7号单元格)，之后，我将列表和混乱转换成火炬张量。</p><p id="c6a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> torch.from_numpy() </strong>是另一种将numpy数组转换成torch张量的方法，我们只需要在那个函数中传递那个NumPy数组就可以了。</p><p id="2405" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们几乎涵盖了从NumPy数组和列表创建torch张量的所有方面，如果我们需要从torch张量创建一个NumPy数组呢？很简单，我们只需要加上<strong class="is hj">。numpy() </strong>同火炬张量。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="0576" class="lu kp hi bd kq lv lw lx ku ly lz ma ky mb mc md lb me mf mg le mh mi mj lh mk bi translated">torch.ones()</h1><p id="ec42" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn hb bi translated">这个函数创建一个1的数组，我们只需要提供数组大小(比如- 3x3或2x2)就可以创建一个数组。这个函数类似于我们在NumPy中的函数，即<strong class="is hj"> np.ones() </strong>。在<strong class="is hj"> torch.ones() </strong>的例子中可以看到语法也是类似的。</p><p id="599e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在PyTorch中，我们有一个函数，它不仅在功能上相似，在语法上也相似，而且它不是PyTorch中唯一一个与NumPy函数相似的函数，还有其他函数。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="9545" class="lu kp hi bd kq lv lw lx ku ly lz ma ky mb mc md lb me mf mg le mh mi mj lh mk bi translated">torch.zeros():</h1><p id="fcb5" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn hb bi translated">这个函数创建一个由零组成的数组，我们只需要传递数组的大小。这个函数也类似于NumPy函数<strong class="is hj"> np.zeros() </strong>。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="a11e" class="lu kp hi bd kq lv lw lx ku ly lz ma ky mb mc md lb me mf mg le mh mi mj lh mk bi translated">torch.rand():</h1><p id="649b" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn hb bi translated">这个函数创建了一个用随机数填充的数组，我们只需要传递数组的大小。它类似于NumPy函数<strong class="is hj"> np.random.rand() </strong>，也做类似的工作。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="0ce6" class="lu kp hi bd kq lv lw lx ku ly lz ma ky mb mc md lb me mf mg le mh mi mj lh mk bi translated">torch.manual_seed():</h1><p id="04c9" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn hb bi translated">种子是编码深度学习架构时非常重要的元素，改变种子可以改变深度神经网络的结果或输出。在NumPy中，我们使用n <strong class="is hj"> umpy.random.seed() </strong>进行播种，但是在PyTorch中，我们有<strong class="is hj"> torch.manual_seed() </strong>应用种子，这里我们只需要在<strong class="is hj"> torch.manual_seed() </strong>中传递任意随机数，这将防止一次又一次地改变输出。</p><p id="a559" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，当我们每次传递相同的播种数并创建相同的数组时，我们每次都得到相同的输出(查看单元格17和18)。但是，当我们改变播种的数量时，输出也会改变(单元格19)。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="e185" class="lu kp hi bd kq lv lw lx ku ly lz ma ky mb mc md lb me mf mg le mh mi mj lh mk bi translated">参考:</h1><ol class=""><li id="2f7b" class="jo jp hi is b it lj ix lk jb ll jf lm jj ln jn jt ju jv jw bi translated"><a class="ae kc" href="https://jovian.ml/outlink?url=https%3A%2F%2Fpytorch.org%2Fdocs%2Fstable%2Ftensors.html" rel="noopener ugc nofollow" target="_blank">https://pytorch.org/docs/stable/tensors.html</a></li><li id="e88a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kc" href="https://heartbeat.fritz.ai/10-reasons-why-pytorch-is-the-deep-learning-framework-of-future-6788bd6b5cc2" rel="noopener ugc nofollow" target="_blank">https://heart beat . fritz . ai/10-reasons-why-py torch-is-the-deep-learning-framework-of-future-6788 BD 6b 5 cc 2</a></li><li id="73c8" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">笔记本链接—<a class="ae kc" href="https://jovian.ml/soumya997-sarkar/torch-basics" rel="noopener ugc nofollow" target="_blank">https://jovian.ml/soumya997-sarkar/torch-basics</a></li></ol><h2 id="e4aa" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jb kz la lb jf lc ld le jj lf lg lh li bi translated">感谢您的阅读👩‍💻👨‍💻</h2></div></div>    
</body>
</html>