<html>
<head>
<title>RSI Based Momentum Trading Strategy Backtested using zipline for Nifty 100 Stocks Universe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于RSI的动量交易策略使用zipline对Nifty 100股票宇宙进行回溯测试</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/rsi-based-momentum-trading-strategy-backtested-using-zipline-for-nifty-100-stocks-universe-2598965203ba?source=collection_archive---------4-----------------------#2020-07-10">https://medium.com/analytics-vidhya/rsi-based-momentum-trading-strategy-backtested-using-zipline-for-nifty-100-stocks-universe-2598965203ba?source=collection_archive---------4-----------------------#2020-07-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="919f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作者:萨比尔·贾纳</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="4693" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">势头、价值、质量、情绪、波动性和规模是一些公认的回报风险因素。动量投资是指做多表现良好的资产，同时做空在一定时期内表现不佳的资产。关于动量投资为什么在挑战了有效或半有效市场假说后仍然有效，有很多解释。其中一些解释包括诸如投资者不理性并遭受行为偏差、宏观因素、资产价格的正序列相关性、需求和供给失衡以及资产与经济增长之间的正反馈循环。</p><p id="33a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多方法来衡量动量，我分享了一个交易策略在我早先的文章<a class="ae jk" href="https://www.linkedin.com/posts/sabirjana_momentum-strategy-backtested-with-backtrader-activity-6674177296561246208-kitL" rel="noopener ugc nofollow" target="_blank">动量策略使用Backtrader与BSE 500作为股票宇宙</a>。在这篇文章中，我将根据相对强弱指标(RSI)建立我的交易策略。该方法基于Andreas F. Clenow和Stefan Jansen在他们各自的书中提出的想法，请参见参考资料。这100只漂亮的股票将成为我们的宇宙，并将使用Quantopian <code class="du jl jm jn jo b"><a class="ae jk" href="https://www.zipline.io/" rel="noopener ugc nofollow" target="_blank">zipline</a></code>对至少10年的历史每日价格数据进行回溯测试。RSI是一个非常简单的动量指标，它比较最近的价格变化，以确定特定股票是超买还是超卖。例如，高于70的高RSI表示超买，而低于30的低RSI表示超卖。你可以通过<a class="ae jk" href="https://en.wikipedia.org/wiki/Relative_strength_index" rel="noopener ugc nofollow" target="_blank">链接</a>了解更多关于RSI的信息。您还可以在我的<a class="ae jk" href="https://github.com/sabirjana/blog/tree/master/RSI" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到本文使用的代码和数据。</p><p id="8a38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的总体方法如下:</p><ol class=""><li id="6bf1" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">收集数据。</li><li id="4090" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">使用zipline定义我们的回溯测试策略。</li><li id="5053" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">提取性能统计数据以与基准进行比较。</li></ol></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="d626" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">收集数据</strong></p><p id="5fad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">zipline是Quantopian Inc .开发的一款出色、开源、成熟且功能强大的回溯测试工具。然而，在本地使用zipline处理您自己的数据时会面临一些挑战。您需要接收数据并创建自己的数据包。如果您想按照本文中的代码进行操作，那么您需要完成这个设置。和往常一样，您可以选择自己的数据源，但是，作为一个开端，我为每个股票行情自动收录器提供了csv文件形式的OHLCV数据集。请关注我的文章— <a class="ae jk" rel="noopener" href="/@sabirh.jana/how-to-import-indian-equities-data-to-zipline-on-your-local-machine-3b8587aaf112">如何在本地机器上将印度股票数据导入zipline？</a>创建您自己的定制捆绑包。</p><p id="aa22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建这些csv文件，我从本地数据库中取出了2010年1月1日到2020年6月15日之间的100只股票，并按照zipline中的要求重命名了这些列。我还剔除了日历史价格数据少于10年的股票。这将我们的宇宙限制在84只股票。在此之后，我通过删除任何重复的行来清理数据，每天对其重新采样以确保没有任何丢失的行，并为每个ticker编写csv文件。你可以在Jupyter的笔记本上看到这段代码。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="8259" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用zipline定义我们的回溯测试策略</strong></p><p id="feb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来定义我们的交易策略:</p><ol class=""><li id="fcca" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">我们有84只来自Nifty 100的股票。</li><li id="cc11" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">投资组合的最大规模保持在30，所以我们的投资组合在任何时候都有0到30只股票。</li><li id="c443" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我们将每月进行一次再平衡，以避免过多的交易和相关成本。</li><li id="563b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">有0.4%的交易费。</li><li id="6b2c" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我们将使用14个周期的RSI来定义我们的买入和卖出逻辑。我们每个月都会计算这84只股票的RSI，并创建一个排名表。如果一只股票的RSI小于30，并且我们还没有持有它，那么它就在我们的买入名单中。如果股票的相对强弱指数超过70，我们持有，我们就退出。我们将最大投资组合规模保持在不超过30只股票。</li><li id="3a9c" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我们根据126天时间周期的20天滚动标准差的平均值进行头寸分配。这确保了头寸分配是基于风险对等，即股票将具有基于同等风险的权重，股票的波动性越小，权重越大。</li></ol><p id="5439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来理解一下python代码:</p><ol class=""><li id="ced1" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">我们进行必要的python库导入。我已经对代码进行了注释，以便从本地数据库中获取数据，进行清理，并编写csv文件。你可以在Jupyter笔记本中查看，为了节省空间，我没有在这里复制它。</li><li id="8598" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">定义测试日期范围，并将时区转换为UTC。</li><li id="08d2" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">读取<code class="du jl jm jn jo b">data/data</code>文件夹中的所有csv文件，并创建一个包含84个报价机的列表。</li><li id="88ee" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">现在，在继续下一步之前，我假设您已经获取了数据，可以在zipline中创建自己的定制数据包。如果没有，请这样做。</li><li id="43dc" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">接下来，我们定义模型参数，包括初始投资组合规模、RSI的上限和下限、RSI周期、标准差的滚动窗口、最大投资组合规模、佣金和滑点参数。</li><li id="1ca3" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">函数<code class="du jl jm jn jo b">compute_rsi </code>计算14天的RSI并返回时间序列的最后一个元素。我为此使用了python库<a class="ae jk" href="https://github.com/mrjbq7/ta-lib" rel="noopener ugc nofollow" target="_blank"> ta-lib </a>，但是你可以为这项工作选择任何合适的库。其他几个选项包括<code class="du jl jm jn jo b"><a class="ae jk" href="https://github.com/bukosabino/ta" rel="noopener ugc nofollow" target="_blank">ta</a></code>或<code class="du jl jm jn jo b"><a class="ae jk" href="https://github.com/peerchemist/finta" rel="noopener ugc nofollow" target="_blank">finta</a></code>。</li><li id="c61e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在<code class="du jl jm jn jo b">volatility</code>函数中，我们采用126天的收盘价时间序列，计算每日回报，并采用20天标准差滚动窗口的平均值。</li><li id="c82f" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><code class="du jl jm jn jo b">output_progress</code>的功能仅仅是在回溯测试执行期间跟踪进度输出和显示月度回报。</li><li id="b02b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我们在函数<code class="du jl jm jn jo b">initialize</code>中初始化佣金、滑点和报价器，并按月安排再平衡。</li><li id="bb6a" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">功能<code class="du jl jm jn jo b">rebalance</code>是我们策略的核心，我将在接下来的几个要点中详细描述它。首先，我们调用<code class="du jl jm jn jo b">output_progress</code>来显示回溯测试期间的每月进度。然后我们得到每个股票代码的滑索符号。接下来，我们获取126个时间段的历史每日收盘价。</li><li id="e70d" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">接下来，我们调用<code class="du jl jm jn jo b">compute_rsi</code>函数，传递每个股票的历史收盘价格时间序列，并按升序创建股票和相应RSI值的排名表。</li><li id="a5a7" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">现在，让我们先研究一下销售逻辑。我们使用变量<code class="du jl jm jn jo b">kept_positions</code>获得现有的投资组合股票列表。然后，对于投资组合中的每个现有证券，我们检查它是否是我们的论域的一部分，如果不是，我们命令目标百分比为零，并从变量<code class="du jl jm jn jo b">kept_positions</code>中移除该证券。然后，在<code class="du jl jm jn jo b">elif</code>中，我们检查证券的RSI值是否大于上限，如果是，我们退出头寸并将目标百分比设置为零。</li><li id="e873" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我们将转向我们的股票选择逻辑。我们通过最大投资组合规模和变量<code class="du jl jm jn jo b">kept_positions</code>的长度之差来确定要替换的股票数量。现在，我们创建一个买入列表，变量<code class="du jl jm jn jo b">kept_positions</code>中不包含股票。然后，从这个买入清单中，我们取出一定数量的证券，其长度等于RSI小于下限的替换长度。</li><li id="17df" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">最后，我们通过将买入清单与变量<code class="du jl jm jn jo b">kept_positions</code>中的证券结合起来，形成一个新的投资组合。</li><li id="2365" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">现在来讨论一下职位分配。我们可以有多种选择，如1/n(等权重)、有效前沿优化或等风险平价。我在以前的帖子中使用过1/n期权，即BSE 500的Backtrader动量策略，得到了非常好的结果。我们将把有效边界优化留到以后某一天进行，现在我们将采用同等风险平价。这意味着每种证券的权重将与使用标准差衡量的风险一致。风险越高，权重越低。我们通过对新投资组合表中的每种证券取126天时间周期的20天滚动标准差的平均值来计算波动率表。为了得到单个证券权重，我们取波动率表的倒数，并除以倒数表的和。</li><li id="f591" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">几乎完成了再平衡逻辑，我们有了新的证券组合和相应的权重。我们迭代新投资组合中的所有项目，如果证券在保留头寸列表中，或者如果RSI低于阈值，我们就设定目标百分比。</li><li id="90c6" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在函数<code class="du jl jm jn jo b">analyze</code>中，我们只需计算年化回报，并将其与最大提款一起打印出来。</li><li id="d228" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">最后，是时候使用我们之前定义的日期范围、初始资本和捆绑包作为您的定制捆绑包来运行算法了。</li></ol><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="8242" class="kl km hi jo b fi kn ko l kp kq"># Necessary imports<br/>%matplotlib inline<br/>%config InlineBackend.figure_format = ‘retina’</span><span id="37aa" class="kl km hi jo b fi kr ko l kp kq">import zipline<br/>from zipline.api import (order_target_percent, symbol, set_commission, set_slippage,<br/> schedule_function, date_rules, time_rules)<br/>from datetime import datetime<br/>import matplotlib.pyplot as plt<br/>import pyfolio as pf<br/>import pandas as pd<br/>import numpy as np <br/>from zipline.finance.commission import PerDollar<br/>from zipline.finance.slippage import VolumeShareSlippage, FixedSlippage<br/>import talib as ta<br/>import pytz<br/>import pandas_datareader.data as web<br/>from os import listdir</span><span id="463d" class="kl km hi jo b fi kr ko l kp kq"># for dataframe slicing operations<br/>idx = pd.IndexSlice</span><span id="3768" class="kl km hi jo b fi kr ko l kp kq"># Testing date range<br/>start = datetime(2010, 1, 1, 8, 15, 12, 0, pytz.UTC)<br/>end = datetime(2020, 6, 15, 8, 15, 12, 0, pytz.UTC)</span><span id="15b0" class="kl km hi jo b fi kr ko l kp kq">TICKERS = [f[:-4] for f in listdir('data/data/')]<br/>print(TICKERS)<br/>print(len(TICKERS))</span><span id="d10e" class="kl km hi jo b fi kr ko l kp kq"># Define Model Parameters<br/>intial_portfolio = 500000<br/>upper = 70<br/>lower = 30<br/>rsi_period = 14<br/>vola_window = 20<br/>mportfolio_size = 30</span><span id="9044" class="kl km hi jo b fi kr ko l kp kq"># Commission and Slippage Parameters<br/>enable_commission = True<br/>commission_pct = 0.004<br/>enable_slippage = True <br/>slippage_volume_limit = 0.025<br/>slippage_impact = 0.05</span><span id="96c4" class="kl km hi jo b fi kr ko l kp kq"># function to calculate RSI<br/>def compute_rsi(close):<br/>    rsi = ta.RSI(close.values, timeperiod=rsi_period)<br/>    return rsi[-1]</span><span id="06ee" class="kl km hi jo b fi kr ko l kp kq"># function to calculate volatility<br/>def volatility(ts):<br/>    std = ts.pct_change().dropna().rolling(vola_window).std().mean()<br/>    return std</span><span id="446e" class="kl km hi jo b fi kr ko l kp kq"># output performance<br/>def output_progress(context):<br/>    # Output performance numbers during backtest run on monthly basis<br/>    # Get today's date<br/>    today = zipline.api.get_datetime().date()<br/>    <br/>    # Calculate percent difference since last month<br/>    perf_pct = (context.portfolio.portfolio_value / context.last_month) - 1<br/>    <br/>    # Print performance, format as percent with two decimals.<br/>    print("{} - Last Month Result: {:.2%}".format(today, perf_pct))<br/>    <br/>    # Remember today's portfolio value for next month's calculation<br/>    context.last_month = context.portfolio.portfolio_value</span><span id="ba7d" class="kl km hi jo b fi kr ko l kp kq"># Initialization the trading logic<br/>def initialize(context):<br/>   <br/>    # Set commission and slippage.<br/>    if enable_commission:<br/>        comm_model = PerDollar(cost=commission_pct)<br/>    else:<br/>        comm_model = PerDollar(cost=0.0)<br/>    set_commission(comm_model)<br/>    <br/>    if enable_slippage:<br/>        slippage_model=VolumeShareSlippage(volume_limit=slippage_volume_limit, price_impact=slippage_impact)<br/>    else:<br/>        slippage_model=FixedSlippage(spread=0.0)   <br/>    set_slippage(slippage_model)    <br/>    <br/>    # Used only for progress output.<br/>    context.last_month = intial_portfolio<br/>    <br/>    # Fetch and store index tickers<br/>    context.index_members = TICKERS<br/>    <br/>    #Schedule rebalance monthly.<br/>    schedule_function(<br/>        func=rebalance,<br/>        date_rule=date_rules.month_start(),<br/>        time_rule=time_rules.market_open()<br/>    )</span><span id="98b7" class="kl km hi jo b fi kr ko l kp kq">def rebalance(context, data):</span><span id="e2e0" class="kl km hi jo b fi kr ko l kp kq">    # Write progress output during the backtest<br/>    output_progress(context)<br/>    <br/>    # Finally, get the Zipline symbols for the tickers<br/>    universe = [symbol(ticker) for ticker in context.index_members]<br/>    <br/>    # Get historical data for volatility calculation<br/>    hist = data.history(universe, "close", 126, "1d")<br/>    hist = hist.dropna()<br/>    <br/>    # Make momentum ranking table based on RSI<br/>    ranking_table = hist.apply(compute_rsi).sort_values(ascending=True)  <br/>    # ranking_table.to_csv('data/ranking_table.csv')</span><span id="18f2" class="kl km hi jo b fi kr ko l kp kq">    # Sell Logic<br/>    # First we check if any existing position should be sold.<br/>    # Sell if stock has RSI greater than upper value.<br/>    kept_positions = list(context.portfolio.positions.keys())<br/>    for security in context.portfolio.positions:<br/>        if (security not in universe):<br/>            order_target_percent(security, 0.0)<br/>            kept_positions.remove(security)<br/>        elif ranking_table[security] &gt; upper:<br/>            order_target_percent(security, 0.0)<br/>            kept_positions.remove(security)<br/>    <br/>    # Stock Selection Logic<br/>    # Check how many stocks we are keeping from last month.<br/>    # Take the desired number of stock from the ranking table where RSI is less than lower.<br/>    replacement_stocks = mportfolio_size - len(kept_positions)<br/>    buy_list = ranking_table.loc[~ranking_table.index.isin(kept_positions)]<br/>    buy_list = buy_list[buy_list.loc[buy_list.index] &lt; lower].dropna()[:replacement_stocks]    <br/>    new_portfolio = pd.concat((buy_list,ranking_table.loc[ranking_table.index.isin(kept_positions)]))</span><span id="d81a" class="kl km hi jo b fi kr ko l kp kq">    # Calculate inverse volatility for stocks,and make target position weights.<br/>    vola_table = hist[new_portfolio.index].apply(volatility)<br/>    inv_vola_table = 1 / vola_table <br/>    sum_inv_vola = np.sum(inv_vola_table)         <br/>    vola_target_weights = inv_vola_table / sum_inv_vola<br/>    <br/>    # Rebalance the tickers based on new weights<br/>    for security, rank in new_portfolio.iteritems():<br/>        weight = vola_target_weights[security]<br/>        if security in kept_positions:<br/>            order_target_percent(security, weight)<br/>        else:<br/>            if ranking_table[security] &lt; lower:<br/>                order_target_percent(security, weight)</span><span id="4420" class="kl km hi jo b fi kr ko l kp kq">def analyze(context, perf):<br/>    perf['max'] = perf.portfolio_value.cummax()<br/>    perf['dd'] = (perf.portfolio_value / perf['max']) - 1<br/>    maxdd = perf['dd'].min()<br/>    ann_ret = (np.power((perf.portfolio_value.iloc[-1] / perf.portfolio_value.iloc[0]),(252 / len(perf)))) - 1<br/>    print("Annualized Return: {:.2%} Max Drawdown: {:.2%}".format(ann_ret, maxdd))<br/>    return</span><span id="ef08" class="kl km hi jo b fi kr ko l kp kq">perf = zipline.run_algorithm(<br/>    start=start, end=end, <br/>    initialize=initialize, <br/>    analyze=analyze, <br/>    capital_base=intial_portfolio,  <br/>    data_frequency = 'daily', <br/>    bundle= 'nse_data')</span></pre></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="9ea3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提取性能统计数据，与基准测试进行比较和对比</strong></p><p id="b9f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一部分中，我们提取并可视化性能，并与我们的基准— S&amp;P Nifty 100进行比较。大多数情况下，我使用<code class="du jl jm jn jo b"><a class="ae jk" href="https://quantopian.github.io/pyfolio/" rel="noopener ugc nofollow" target="_blank">pyfolio</a> </code>进行性能和风险分析。</p><p id="b7a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们跳到python代码:</p><ol class=""><li id="afd7" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">我们使用pyfolio实用程序从回溯测试输出中提取回报、头寸和交易细节。</li><li id="73e8" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">为了获得漂亮的100个每日定价细节，我提供了一个csv文件，我们读取csv文件并创建一个数据框架。</li><li id="d8d9" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我们从上面的数据框架中获得收盘价，确保每日重新采样和向前填充，将日期时间指数转换为UTC，并根据策略回报指数过滤记录。</li><li id="e130" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">接下来，我们考虑初始投资组合价值，重新确定每日收盘基准价格。</li><li id="be69" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">类似地，我们从定价数据中获得基准日回报，将指数转换为UTC，并基于策略回报指数过滤记录。</li><li id="6d92" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">随后，我有了可视化策略和基准的投资组合价值和每日回报的代码。如果你是python的新手，就照原样使用它，慢慢你就会学会了。</li><li id="b4b1" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我已经使用了<code class="du jl jm jn jo b">pyfolio</code>的<code class="du jl jm jn jo b">show_perf_stats </code>函数来获得基准测试的关键性能统计数据，并使用了一些其他函数来定制图表，还使用了<code class="du jl jm jn jo b">create_full_tear_sheet</code>选项来获得所有可用参数的完整视图。我想更多地关注性能分析，而不是可视化代码的本质，因为我相信你会明白这一点。</li></ol><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="34cb" class="kl km hi jo b fi kn ko l kp kq"># Extract inputs for pyfolio<br/>returns, positions, transactions = pf.utils.extract_rets_pos_txn_from_zipline(perf)<br/>print(returns[:3])<br/>returns.name = ‘Strategy’</span><span id="23b1" class="kl km hi jo b fi kr ko l kp kq">benchmark = pd.read_csv('data/nifty100.csv', index_col = [0], parse_dates=True)<br/>benchmark.tail(3)</span><span id="858b" class="kl km hi jo b fi kr ko l kp kq"># Get the benchmark prices for comparison<br/>benchmark_prices = benchmark['close'].loc[start:end]<br/>benchmark_prices = benchmark_prices.asfreq('D', method='ffill')<br/>benchmark_prices.index = benchmark_prices.index.tz_localize('UTC')<br/>benchmark_prices = benchmark_prices.filter(returns.index)<br/>benchmark_prices.head(5)</span><span id="42d7" class="kl km hi jo b fi kr ko l kp kq"># Rebase the benchmark prices for comparison<br/>benchmark_prices = (benchmark_prices/benchmark_prices.iloc[0]) * intial_portfolio<br/>benchmark_prices.head()</span><span id="85fa" class="kl km hi jo b fi kr ko l kp kq"># Get benchmark returns<br/>benchmark_rets= benchmark['close'].loc[start:end].pct_change().dropna()<br/>benchmark_rets.index = benchmark_rets.index.tz_localize('UTC') <br/>benchmark_rets = benchmark_rets.filter(returns.index)<br/>benchmark_rets.name = 'S&amp;P BSE-100'<br/>benchmark_rets.head(2)</span><span id="c742" class="kl km hi jo b fi kr ko l kp kq"># Visulize the output<br/>fig, ax = plt.subplots(2, 1, sharex=True, figsize=[16, 9])<br/># portfolio value<br/>perf.portfolio_value.plot(ax=ax[0], label='Strategy')<br/>benchmark_prices.plot(ax=ax[0], label='Benchmark - Nifty 100')<br/>ax[0].set_ylabel('Portfolio Value')<br/>ax[0].grid(True)<br/>ax[0].legend()</span><span id="61c3" class="kl km hi jo b fi kr ko l kp kq"># daily returns<br/>perf.returns.plot(ax=ax[1], label='Strategy', alpha=0.5)<br/>benchmark_rets.plot(ax=ax[1], label='Benchmark - Nifty 100', alpha=0.5)<br/>ax[1].set_ylabel('Daily Returns')</span><span id="a43e" class="kl km hi jo b fi kr ko l kp kq">fig.suptitle('RSI Momemtum Strategy vs Nifty 100', fontsize=16)<br/>plt.grid(True)<br/>plt.legend()<br/>plt.show()<br/>fig.savefig('images/chart1')</span><span id="3269" class="kl km hi jo b fi kr ko l kp kq"># Performance of benchmark on key parameters<br/>pf.show_perf_stats(benchmark_rets)</span><span id="cd06" class="kl km hi jo b fi kr ko l kp kq"># plot performance for strategy<br/>fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(14, 8),constrained_layout=True)<br/>axes = ax.flatten()</span><span id="45ed" class="kl km hi jo b fi kr ko l kp kq">pf.plot_drawdown_periods(returns=returns, ax=axes[0])<br/>axes[0].grid(True)<br/>pf.plot_rolling_returns(returns=returns,<br/>                        factor_returns=benchmark_rets,<br/>                        ax=axes[1], title='Strategy vs Nifty-100')<br/>axes[1].grid(True)<br/>pf.plot_drawdown_underwater(returns=returns, ax=axes[2])<br/>axes[2].grid(True)<br/>pf.plot_rolling_sharpe(returns=returns, ax=axes[3])<br/>axes[3].grid(True)<br/>fig.suptitle('Strategy vs Nifty-100 - 1', fontsize=12, y=0.990)</span><span id="2203" class="kl km hi jo b fi kr ko l kp kq">plt.grid(True)<br/>plt.legend()<br/>plt.tight_layout()<br/>plt.savefig('images/chart2', dpi=300)</span><span id="f829" class="kl km hi jo b fi kr ko l kp kq"># plot performance<br/>fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(16, 9),constrained_layout=True)<br/>axes = ax.flatten()</span><span id="88be" class="kl km hi jo b fi kr ko l kp kq">pf.plot_rolling_beta(returns=returns, factor_returns=benchmark_rets, ax=axes[0])<br/>axes[0].grid(True)</span><span id="0613" class="kl km hi jo b fi kr ko l kp kq">pf.plot_rolling_volatility(returns=returns, factor_returns=benchmark_rets,ax=axes[1])<br/>axes[1].grid(True)</span><span id="c265" class="kl km hi jo b fi kr ko l kp kq">pf.plot_annual_returns(returns=returns, ax=axes[2])<br/>axes[2].grid(True)</span><span id="7ea8" class="kl km hi jo b fi kr ko l kp kq">pf.plot_monthly_returns_heatmap(returns=returns, ax=axes[3],)<br/>fig.suptitle('Strategy vs Nifty-100 - 2', fontsize=16, y=1.0)</span><span id="e791" class="kl km hi jo b fi kr ko l kp kq">plt.tight_layout()<br/>plt.savefig('images/chart3', dpi=300)</span><span id="6ec0" class="kl km hi jo b fi kr ko l kp kq">fig = pf.create_full_tear_sheet(returns, benchmark_rets=benchmark_rets, positions=positions, transactions=transactions)<br/>plt.savefig('images/chart4', dpi=400)<br/></span></pre><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ks"><img src="../Images/ea932dae5eee05c1d3028dacbf8e8304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVwKBNKnOTvGO5TzClIrhA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">RSI动量策略vs Nifty 100</figcaption></figure><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es le"><img src="../Images/d013cbc788708dc75b93689a0f6cac0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAxvn6SzSCCNtmbjFGeEIA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">战略与基准— Nifty 100</figcaption></figure><p id="29e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇！看来我们中大奖了！该策略的年化回报率、夏普比率和索提诺比率都远远领先于基准。每当你得到这样的回报，你必须检查算法2-3次，以确保你没有愚蠢的错误，检查每日定价数据的质量，最后，永远记住，过去的表现不是未来表现的保证。</p><p id="5011" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用更多的参数来想象结果。由于篇幅的原因，我在这里没有包括完整的活页，但是你可以在这篇文章的Jupyter笔记本中找到它。</p><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lf"><img src="../Images/0ca8d99662fda56fb495c0d7c63bf81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QB6LwafEY4oGcudSgU9Ktg.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">战略与优势100–1</figcaption></figure><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lg"><img src="../Images/1cb84ee74fc80d0d095274445ac1bbf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XpUykz6SobdzAZ5Z3bTNbA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">战略与优势100 — 2</figcaption></figure><figure class="kd ke kf kg fd kt er es paragraph-image"><div class="er es lh"><img src="../Images/5a08229d1a7330f95fe5dde253f7afa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*ucpahJ1C3XtnT3syvEslpA.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">有史以来的十大职位</figcaption></figure><p id="ebc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，总体而言，我们的战略表现良好，事实上，比我的预期要好。然而，我们无法在年度和6个月滚动波动性、最大提款和每日风险值方面击败基准。此外，6个月滚动夏普比率相当不稳定。正如我提到的，我已经分享了代码，包括你可以从我的Github获得的数据。你可以摆弄代码和数据，在我看来，这是最好的学习方法之一。</p><p id="b28d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">祝投资愉快，请在文章中留下您的评论！</p><p id="4108" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="li">请注意:此分析仅用于教育目的，作者不对您的任何投资决策负责。</em></p><p id="4251" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考资料:</p><ol class=""><li id="ae1d" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">Andreas F. Clenow — <a class="ae jk" href="https://www.amazon.in/Trading-Evolved-Anyone-Killer-Strategies-ebook/dp/B07VDLX55H" rel="noopener ugc nofollow" target="_blank">“交易进化了:任何人都可以用Python构建黑仔交易策略”</a>。</li><li id="812b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">Stefan Jansen — <a class="ae jk" href="https://www.amazon.com/Hands-Machine-Learning-Algorithmic-Trading-ebook/dp/B07JLFH7C5/ref=sr_1_2?ie=UTF8&amp;qid=1548455634&amp;sr=8-2&amp;keywords=machine+learning+algorithmic+trading" rel="noopener ugc nofollow" target="_blank">算法交易的动手机器学习:设计和实施基于智能算法的投资策略，这些算法使用Python </a>从数据中学习。</li></ol></div></div>    
</body>
</html>