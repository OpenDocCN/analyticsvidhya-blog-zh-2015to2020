<html>
<head>
<title>Input source reading patterns in Google Cloud Dataflow (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Cloud数据流中的输入源阅读模式(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/input-source-reading-patterns-in-google-cloud-dataflow-part-2-41cbcb38e6b4?source=collection_archive---------14-----------------------#2020-03-29">https://medium.com/analytics-vidhya/input-source-reading-patterns-in-google-cloud-dataflow-part-2-41cbcb38e6b4?source=collection_archive---------14-----------------------#2020-03-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="483a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我上一篇博客的续篇，解释了使用数据流管道从Google云存储或云发布/订阅中读取数据时的一些其他模式。如果你是数据流的新手，或者如果你还没有查看之前的<a class="ae jd" rel="noopener" href="/@pavankumarkattamuri/input-source-reading-patterns-in-google-cloud-dataflow-4c1aeade6831?source=friends_link&amp;sk=c40148c86a13775fa16ab54305cf3287">第一部分博客</a>，请这样做。如果你已经有了，谢谢！！</p><blockquote class="je jf jg"><p id="559c" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><em class="hi">这里我列出了几个</em> <strong class="ih hj"> <em class="hi">不常见的</em> </strong> <em class="hi">源阅读模式，重点放在云存储和Pub/Sub上。这并不侧重于利用不同的GCP服务作为源/汇，也不侧重于进行复杂的转换，我只重复源读取模式。</em></p></blockquote><p id="62d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>:对于以下模式，<strong class="ih hj"><em class="jh">—experiments = allow _ non _ updatable _ job</em></strong>在调用数据流作业时也应作为参数传递，否则您将收到以下错误“由于您的管道的形状，云数据流作业优化器使用— update pipeline选项生成了不可更新的作业图”。</p><blockquote class="je jf jg"><p id="da0b" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">完整代码可以在我的<a class="ae jd" href="https://github.com/pavan-kattamuri/dataflow_input_patterns_2" rel="noopener ugc nofollow" target="_blank"> github repo </a>找到</p></blockquote><h2 id="3e53" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated"><strong class="ak">分别读取多个GCS源<em class="kg"/></strong></h2><p id="9c63" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">最初，这可能看起来像两个不同的数据流作业，但令你惊讶的是，它不是。在<a class="ae jd" rel="noopener" href="/@pavankumarkattamuri/input-source-reading-patterns-in-google-cloud-dataflow-4c1aeade6831?source=friends_link&amp;sk=c40148c86a13775fa16ab54305cf3287">上一篇博客</a>中解释的<em class="jh"> List GCS &amp; Create </em>选项在所有输入文件都具有相同的结构/模式时非常有用，因为它会在<em class="jh"> ReadAllFromText </em>之后创建一个<em class="jh"> single PCollection </em>元素。然而，如果您出于某种原因想要不同的PCollections，您仍然可以使用Dataflow来实现。下面的方法假设您有一个要转换的输入源的有限列表。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es kt"><img src="../Images/d95ea28e619cbee3400bcdf6ef24317c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*LREBM4uvZN3GVrmHcHgjdA.png"/></div></figure><h2 id="5ced" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">分别读取多个发布订阅源</h2><p id="6f3b" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">与上面的模式类似，您也可以对多个PubSub源做同样的事情，分别处理它们。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es kw"><img src="../Images/03452ee28db8dca29c83190101bf4306.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*Nm3Jaf9cZQyuBwxBXcHA7g.png"/></div></figure><h2 id="ff37" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">从可变数量的源读取</h2><p id="71d7" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">使用GCS match检索匹配前缀模式的文件列表，我们可以动态地为每个文件创建一个<em class="jh">p集合</em>。因为数据流中的每一步都应该有一个唯一的步骤名，所以每一步的标签也是动态创建的。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="023c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当只有两个文件匹配该模式时，管道创建了两个p collection，当有五个文件匹配该模式时，管道创建了五个p collection。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es kx"><img src="../Images/a02b2912095ff0963c5192c2436b39e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*mKX19lPVeT5WSx4vqoU3Rg.png"/></div></figure><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ky"><img src="../Images/618194190ee7c7776efc70dccdd86256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0S7WHJBhWeCGINAAWGjV6g.png"/></div></div></figure><h2 id="0eaf" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">类似处理的云功能</h2><p id="cf8a" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">云功能和云存储触发器帮助您实现异步、无服务器和轻量级处理。例如，一个文件已经被上传到桶1 &gt;触发云功能1 &gt;进行一些处理&gt;将处理过的文件上传到桶2 &gt;云功能2触发&gt;再次进行一些处理&gt;将处理过的文件上传到桶3。如果你想做一些由于内存和存储限制而在云功能上不支持的繁重处理，那么saviour Dataflow就来了。</p><p id="1084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与上述方法一样，这可以使用云存储桶上的pubsub通知来实现，或者实际上只使用pubsub。您可以使用下面的任何一种实现，第一种方法是合并&amp;拆分来自不同主题的pubsub消息，第二种方法是分别处理来自不同主题的消息。第二种方法给出了数据处理的更清晰和更好的可视化，消除了合并和分割阶段的需要</p><p id="fc4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">实现</strong>:启用发布主题1的桶1通知和发布主题2的桶2通知。数据流是这样进行的:文件已经上传到桶1 &gt;通知到<strong class="ih hj">从主题1读取</strong>步骤&gt;T4】处理桶1文件将进行一些处理<strong class="ih hj"> &gt;写入桶2 </strong>通知到<strong class="ih hj">从主题2读取</strong>步骤&gt;T10】处理桶2文件将再次进行一些处理<strong class="ih hj"> &gt;写入桶3 </strong></p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es ld"><img src="../Images/ad265d461429187fae878d4a8ad61cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*U9SNIBIuly7CrXefFayOUQ.png"/></div></figure><p id="19d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一样的东西，但是更好:)</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es le"><img src="../Images/fff40cfbdf6fc452d4ff211e85104f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*d5U5Mvk9t7kxaosRdNG-9w.png"/></div></figure></div></div>    
</body>
</html>