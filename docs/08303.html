<html>
<head>
<title>Predicting MLB Pitch Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测MLB音高等级</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-mlb-pitch-classes-8c8163cd6c41?source=collection_archive---------14-----------------------#2020-07-24">https://medium.com/analytics-vidhya/predicting-mlb-pitch-classes-8c8163cd6c41?source=collection_archive---------14-----------------------#2020-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b1af" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">错过了比赛？构建K-最近邻分类器。</h2></div><p id="082b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近，我在做一个涉及棒球数据的项目——特别是投球数据——遇到了一个问题。这些数据是在<a class="ae jt" href="http://baseballsavant.com" rel="noopener ugc nofollow" target="_blank">棒球专家</a>获得的，包括克里斯·塞尔(当时是芝加哥白袜队的)在2015年和2016年投掷的每一个球，总计超过6500个球。然而，其中大约有75个丢失了音高类型分类标签。</p><p id="153b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，我可以检索一个俯仰观察值，并知道它以6.396英尺的释放距离向本垒板投掷，或者它在轨迹中以每分钟2093转的速度从左向右移动了1.161英尺；但是我不能确定那是快速球、变速球还是滑球——这些信息对我预测投手疲劳和受伤危险信号的最终目标非常重要。</p><p id="264d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然我不能回到2015-2016年观看这些比赛，但我可以做的是建立一个K-最近邻模型，为我生成球场类型标签。尽管我在我的棒球项目中使用了它，但是当你打算使用机器学习来快速解决像我这样的多类问题时，也可以采取类似的方法。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/0e49192c57c472be1afba1a040a23307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFzZ79xnaX1ShHwCrA6n1w.jpeg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图片来自<a class="ae jt" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1499783" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jt" href="https://pixabay.com/users/KeithJJ-2328014/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1499783" rel="noopener ugc nofollow" target="_blank">基思·约翰斯顿</a></figcaption></figure><p id="a63c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi kk translated"><span class="l kl km kn bm ko kp kq kr ks di">答</span>在尽可能彻底地清理完我的数据后，下一步是只收集对预测<code class="du kt ku kv kw b">Pitch_Name</code>有用的特征，然后从没有<code class="du kt ku kv kw b">Pitch_Name</code>值缺失的行中筛选出<code class="du kt ku kv kw b">Pitch_Name</code>值缺失的行。当我说<em class="kx">有用的</em>时，我指的是合理描述或表征特定类型音高的信息。例如，我不需要<code class="du kt ku kv kw b">Inning</code>(因为任何类型的投球都可以在任何一局中进行)，但我确实想引入<code class="du kt ku kv kw b">Release_Speed</code>，因为每种类型的投球在速度方面都有自己的均值和标准差。</p><pre class="jv jw jx jy fd ky kw kz la aw lb bi"><span id="290f" class="lc ld hi kw b fi le lf l lg lh"># data subset to be used in KNN</span><span id="8089" class="lc ld hi kw b fi li lf l lg lh">pitch_metrics = data[['Release_Speed', 'Release_Point_X',<br/>                      'Release_Point_Z', 'Horizontal_Movement',<br/>                      'Vertical_Movement', 'Velocity_X',<br/>'Velocity_Y','Velocity_Z', 'Acceleration_X', 'Acceleration_Y', 'Acceleration_Z', 'Perceived_Speed', 'Release_Spin_Rate',<br/>'Release_Extension', 'Release_Point_Y',<br/>'Pitch_Name']]</span></pre><p id="e9df" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我想把缺少<code class="du kt ku kv kw b">Pitch_Name</code>的行和没有缺少的行分开:</p><pre class="jv jw jx jy fd ky kw kz la aw lb bi"><span id="7425" class="lc ld hi kw b fi le lf l lg lh"># make subset of data where labels are not missing<br/>pitchname_notnull = pitch_metrics[pitch_metrics['Pitch_Name'].notnull()]</span><span id="76db" class="lc ld hi kw b fi li lf l lg lh"># make subset of data where labels are missing<br/>pitchname_isnull = pitch_metrics[pitch_metrics['Pitch_Name'].isnull()]</span></pre><p id="13a3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，使用<code class="du kt ku kv kw b">pitchname_notnull</code>，我将我的目标(<code class="du kt ku kv kw b">Pitch_Name</code>)从剩余的数据中分离出来，然后将它们分别划分为训练集和测试集。</p><pre class="jv jw jx jy fd ky kw kz la aw lb bi"><span id="3e10" class="lc ld hi kw b fi le lf l lg lh"># data, with target dropped (X)<br/>pitchname_notnull_data = pitchname_notnull.drop(columns='Pitch_Name')</span><span id="0725" class="lc ld hi kw b fi li lf l lg lh"># labels, or target (y)<br/>pitchname_notnull_labels = pitchname_notnull['Pitch_Name']</span><span id="f595" class="lc ld hi kw b fi li lf l lg lh"># split into train and test sets<br/>X_train, X_test, y_train, y_test = train_test_split(pitchname_notnull_data,<br/>pitchname_notnull_labels, test_size=0.20, random_state=55)</span></pre><p id="eb88" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为KNN是一个基于距离的分类器，如果数据的各种特征在不同的尺度上(像我一样)，那么更大尺度的特征将对点之间的距离产生更大的影响。</p><p id="6bd9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对此的补救方法是对数据进行归一化，即确保所有数据都以相同的比例表示。(注意，这只能在将数据分成训练集和测试集之后<em class="kx">进行，以避免“数据泄漏”，当测试集的信息泄漏到训练集或使训练集失真时，就会发生“数据泄漏”。)</em></p><p id="e1dc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了缩放我的数据，我使用了<code class="du kt ku kv kw b">sklearn.preprocessing</code>模块中的<code class="du kt ku kv kw b">StandardScaler</code>。</p><pre class="jv jw jx jy fd ky kw kz la aw lb bi"><span id="b59f" class="lc ld hi kw b fi le lf l lg lh"># Instantiate StandardScaler<br/>scaler = StandardScaler()</span><span id="b301" class="lc ld hi kw b fi li lf l lg lh"># Transform the train and test sets<br/>scaled_data_train = scaler.fit_transform(X_train)<br/>scaled_data_test = scaler.transform(X_test)</span><span id="f4e3" class="lc ld hi kw b fi li lf l lg lh"># Convert into a DataFrame<br/>scaled_df_train = pd.DataFrame(scaled_data_train,<br/>                               columns=X_train.columns)</span></pre><p id="d46b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，对数据进行适当的预处理后，就可以训练KNN分类器并验证其准确性了。在每次迭代中，我下面使用的自定义函数将…</p><ul class=""><li id="bfa0" class="lj lk hi iz b ja jb jd je jg ll jk lm jo ln js lo lp lq lr bi translated">搜索“K”的最佳值，</li><li id="1bc9" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">将分类器安装到训练数据中，然后…</li><li id="9322" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">为<code class="du kt ku kv kw b">X_test</code>(现在的<code class="du kt ku kv kw b">scaled_data_test</code>)生成预测。</li></ul><p id="e4f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用最佳K值生成预测后，该函数将计算并打印评估指标和混淆矩阵。(这个自定义<code class="du kt ku kv kw b">find_best_k</code>函数的完整代码可以在本文的底部找到。)</p><pre class="jv jw jx jy fd ky kw kz la aw lb bi"><span id="a57e" class="lc ld hi kw b fi le lf l lg lh">find_best_k(scaled_data_train, y_train, scaled_data_test, y_test)</span></pre><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es lx"><img src="../Images/40838bacd064e624b889ce21b14daba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*GbkGBcBmH0MUtCfInmjyxQ.png"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">使用Yellowbrick的<a class="ae jt" href="https://www.scikit-yb.org/en/latest/api/classifier/confusion_matrix.html" rel="noopener ugc nofollow" target="_blank">混淆矩阵</a>可视化工具制作</figcaption></figure><p id="9991" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果相当令人鼓舞，正如你可能已经从上面的图表中收集到的那样。具体的评估指标如下:</p><pre class="jv jw jx jy fd ky kw kz la aw lb bi"><span id="e8bd" class="lc ld hi kw b fi le lf l lg lh">Best Value for k: 9<br/>Accuracy: 0.972<br/>Precision: 0.975<br/>Recall: 0.965<br/>F1-Score: 0.974</span></pre><p id="1251" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用9的“K ”,是时候继续为缺少这些标签的76行生成<code class="du kt ku kv kw b">Pitch_Name</code>预测了。</p><pre class="jv jw jx jy fd ky kw kz la aw lb bi"><span id="e676" class="lc ld hi kw b fi le lf l lg lh"># set data apart from empty labels<br/>pitchname_isnull_data = pitchname_isnull.drop(columns=’Pitch_Name’)</span><span id="352e" class="lc ld hi kw b fi li lf l lg lh"># make array of the empty labels<br/>pitchname_isnull_labels = pitchname_isnull[‘Pitch_Name’]</span><span id="0af0" class="lc ld hi kw b fi li lf l lg lh"># Instantiate StandardScaler<br/>scaler = StandardScaler()</span><span id="eb18" class="lc ld hi kw b fi li lf l lg lh"># Transform the data<br/>scaled_data = scaler.fit_transform(pitchname_isnull_data)</span><span id="8554" class="lc ld hi kw b fi li lf l lg lh"># Convert into a DataFrame<br/>scaled_df_data = pd.DataFrame(scaled_data,<br/>columns=pitchname_isnull_data.columns,<br/>index=pitchname_isnull_data.index)</span></pre><p id="2acd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，终于到了生成预测来替换<code class="du kt ku kv kw b">Pitch_Name</code>下的空值的时候了。</p><pre class="jv jw jx jy fd ky kw kz la aw lb bi"><span id="74f2" class="lc ld hi kw b fi le lf l lg lh"># Instantiate KNeighborsClassifier<br/>knn = KNeighborsClassifier(n_neighbors=9)<br/># Fit the classifier<br/>knn.fit(scaled_data_train, y_train)<br/># Predict on the data<br/>data_preds = knn.predict(scaled_df_data)</span></pre><p id="ebb7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果是一个类似这样的数组…</p><pre class="jv jw jx jy fd ky kw kz la aw lb bi"><span id="beec" class="lc ld hi kw b fi le lf l lg lh">array(['Sinker', 'Sinker', 'Slider', 'Sinker', 'Sinker', 'Sinker',<br/>       'Sinker', 'Sinker', 'Sinker', 'Sinker', 'Changeup', 'Sinker',<br/>       'Sinker', 'Changeup', 'Sinker', ...], dtype=object)</span></pre><p id="de4a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我把它变成了一个相框:</p><pre class="jv jw jx jy fd ky kw kz la aw lb bi"><span id="c6c2" class="lc ld hi kw b fi le lf l lg lh"># Convert new predictions into DataFrame<br/># Set index to match original DataFrame (`data`) where ‘Pitch_Name’ values are missing</span><span id="1e6f" class="lc ld hi kw b fi li lf l lg lh">predictions = pd.DataFrame(data_preds,<br/> columns=[‘Pitch_Name’], index=pitchname_isnull_labels.index)</span></pre><p id="0562" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，我终于准备好用我生成的新预测值替换原始数据帧的<code class="du kt ku kv kw b">Pitch_Name</code>列中的空值。</p><pre class="jv jw jx jy fd ky kw kz la aw lb bi"><span id="730f" class="lc ld hi kw b fi le lf l lg lh">data['Pitch_Name'].fillna(value=predictions['Pitch_Name'], inplace=True)</span></pre><p id="09eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样，数据框就没有了缺失的标签，我也能够避免丢弃76个完全可弥补的观察结果。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">上面使用的“find_best_k”函数的完整代码</figcaption></figure></div></div>    
</body>
</html>