<html>
<head>
<title>Apache Flink Series 4 — DataStream API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Flink系列4 —数据流API</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/apache-flink-series-4-datastream-api-21ffdd8f2bc0?source=collection_archive---------6-----------------------#2020-02-18">https://medium.com/analytics-vidhya/apache-flink-series-4-datastream-api-21ffdd8f2bc0?source=collection_archive---------6-----------------------#2020-02-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/352266837f8f909a97f624b028300972.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*I37a4qi0iF8K8bXZfsHDoA.jpeg"/></div></figure><div class=""/><p id="bff1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这篇文章中，我将解释Flink中的数据流API。</p><blockquote class="jk jl jm"><p id="a213" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">(你可以参考我之前关于弗林克 的<a class="ae jr" rel="noopener" href="/@mehmetozanguven/apache-flink-series-3-architecture-of-flink-a1ae34f0a8d2"> <strong class="io hq">架构的博客)</strong></a></p></blockquote><p id="0887" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们把Flink看作一个软件时，Flink是作为分层系统构建的。其中一层是位于运行时层之上的数据流API。</p><p id="7417" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们深入了解带有Flink中的转换的数据流API</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="f0c0" class="jz ka hp bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">转换</h1><ul class=""><li id="b771" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">流<strong class="io hq">变换</strong>应用于一个或多个流，并将它们转换成一个或多个输出流</li><li id="e6a6" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">大多数流转换都基于用户定义函数。函数定义了如何将输入流的元素转换成输出流的元素。</li><li id="83d4" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">大多数函数(也许是全部，我不确定)都被设计成单一抽象方法(SAM)，因此你也可以使用lambda表达式。</li><li id="e57f" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">我们可以将转换分为4个部分:</li></ul><ol class=""><li id="a05d" class="kx ky hp io b ip iq it iu ix ln jb lo jf lp jj lq lf lg lh bi translated">基本转换</li></ol><p id="309a" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.键控流转换</p><p id="e668" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.多数据流转换</p><p id="2d74" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">4.分布变换</p><h2 id="2f43" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">1.基本转换</h2><ul class=""><li id="8be8" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">处理单个事件，这意味着每个输出记录都是由单个输入记录生成的</li></ul><h2 id="1e6f" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">基本变换—地图</h2><ul class=""><li id="8f58" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">使用DataStream.map()调用它，并使用定义的函数生成新的数据流</li></ul><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">数据流映射转换</figcaption></figure><h2 id="3cc2" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">基本转换—过滤器</h2><ul class=""><li id="d4a7" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">用“DataStream.filter()”调用它，并产生相同类型的新数据流</li><li id="09a4" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">过滤器转换通过评估每个输入的布尔条件来丢弃(移除)流的事件。</li><li id="d6ab" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">返回值true意味着事件将转发到新的数据流</li><li id="57ee" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">返回值false表示事件将被丢弃。</li></ul><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">过滤流</figcaption></figure><h2 id="4286" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">基本转换—平面图</h2><ul class=""><li id="7707" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">类似于地图转换，但它可以产生零个、一个或多个结果</li><li id="9006" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">因为它可能产生更多的结果，所以它的输出类型将用收集器<t>包装，收集器收集记录并转发它。</t></li></ul><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">平面地图</figcaption></figure><h2 id="86ab" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">2.键控转换</h2><ul class=""><li id="a29c" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">大多数情况下，您希望将共享某个属性的事件分组在一起。例如，您可能想要查看“每种颜色的无效令牌的计数”。这可以通过sql来完成，如下所示:(假设如果令牌不为空，那么它是有效的)</li></ul><pre class="mf mg mh mi fd mp mq mr ms aw mt bi"><span id="8f41" class="lr ka hp mq b fi mu mv l mw mx">SELECT tableName.color, count(token) AS countOfValidToken<br/>FROM tableName<br/>WHERE tableName.token IS NOT NULL<br/>GROUP BY tableName.color;</span></pre><ul class=""><li id="ec2a" class="kx ky hp io b ip iq it iu ix ln jb lo jf lp jj le lf lg lh bi translated">同样的事情可以通过键控转换在Flink中完成。DataStream API提供了这个称为KeyedStream的特性。</li><li id="d069" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">注意:小心使用KeyedStream。如果键域持续增长(每个事件可以有唯一的键)，那么不要忘记清理不再活动的键的状态，以避免内存问题</li></ul><h2 id="f959" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">键控转换—键控</h2><ul class=""><li id="e198" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">keyBy转换通过指定密钥将数据流转换为KeyedStream。</li><li id="d717" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">基于密钥，相同的密钥由相同的任务处理。</li></ul><figure class="mf mg mh mi fd hk er es paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="er es my"><img src="../Images/d7895e09159852a78f2883402a9b7f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Zy8BCCuPqGAwncrGnC-SQ.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">基比</figcaption></figure><pre class="mf mg mh mi fd mp mq mr ms aw mt bi"><span id="18e0" class="lr ka hp mq b fi mu mv l mw mx">DataStream&lt;LogObject&gt; yourLogs =... // kafka topic, file etc..</span><span id="c707" class="lr ka hp mq b fi nd mv l mw mx">// Note: assumed that LobObject has attibute called color, this one way of the defining key in the Flink, we will touch this later<br/>DataStream&lt;LogObject, String&gt; eachColorStream = yourLogs.keyBy(color)</span></pre><h2 id="56a1" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">键控转换—滚动聚合</h2><ul class=""><li id="1020" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">滚动聚合应用于KeyedStream并生成聚合的数据流。</li><li id="b9a5" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">滚动聚合不需要用户定义的函数</li><li id="0538" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">滚动聚合方法:<strong class="io hq"> sum()、min()、max()、minBy()、maxBy() </strong></li></ul><h2 id="7ecc" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">键控转换—减少</h2><ul class=""><li id="c70b" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">将当前元素与最后一个减少的元素合并，并发出新值。</li></ul><pre class="mf mg mh mi fd mp mq mr ms aw mt bi"><span id="91e0" class="lr ka hp mq b fi mu mv l mw mx">keyedStream.reduce(new ReduceFunction&lt;Integer&gt;(){<br/>    @override<br/>    public Integer reduce(Integer value1, Integer value2){<br/>        return value1+value2;<br/>    }<br/>}</span></pre><h2 id="2f09" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">3.多数据流转换</h2><ul class=""><li id="3b3f" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">用于合并不同的流或将流分成不同的流</li></ul><h2 id="1ec8" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">多数据流转换—联合</h2><ul class=""><li id="e299" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">合并两个或多个<strong class="io hq">相同类型</strong>的数据流，产生一个新的<strong class="io hq">相同类型的数据流。</strong></li><li id="5ff7" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">事件以FIFO方式合并，操作符不产生事件的特定顺序。</li><li id="f84b" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">union运算符不执行重复消除。</li></ul><figure class="mf mg mh mi fd hk er es paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="er es ne"><img src="../Images/d57e4eda79f765eccbc6cf3a3b135f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6IkoitRT_iWkC3ocN4SlSQ.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">联合变换</figcaption></figure><h2 id="8610" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">多数据流转换—拆分</h2><ul class=""><li id="a67b" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">拆分是联合转换的逆转换</li><li id="83f0" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">它将一个输入流分成两个或多个与输入流类型相同的输出流。</li></ul><h2 id="f69b" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">4.分布变换</h2><ul class=""><li id="cbdb" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">这些操作定义了如何将事件分配给任务。</li><li id="b3f7" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">如果你不指定一个，数据流API将自动选择一个策略，这取决于并行性等..</li></ul><h2 id="e644" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">分布变换—随机</h2><ul class=""><li id="22b2" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">随机分发记录</li><li id="ff03" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">用<strong class="io hq"> dataStream.shuffle() </strong>调用</li></ul><h2 id="293d" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">分销转型—循环法</h2><ul class=""><li id="9144" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">以循环方式分发事件</li><li id="20b2" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">用<strong class="io hq">datastream . rebalance()</strong>调用</li></ul><h2 id="09d2" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">分布变换-重新缩放</h2><ul class=""><li id="0ad8" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">以循环方式分发事件，但只分发到后续任务的子集</li><li id="682b" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">用<strong class="io hq"> dataStream.rescale() </strong>调用</li></ul><h2 id="7945" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">分发转换—广播</h2><ul class=""><li id="138c" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">复制输入数据流，以便将所有事件发送给下游操作符的所有并行任务。</li><li id="1911" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">用<strong class="io hq"> dataStream.broadcast() </strong>调用</li></ul></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="8336" class="jz ka hp bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">定义键</h1><ul class=""><li id="9a9a" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">我们可以用3种方式定义keyedStream的键</li></ul><h2 id="9bdb" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">1.现场位置</h2><ul class=""><li id="66c9" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">如果数据类型是tuple，只需使用相应tuple元素的字段位置就可以定义键。</li></ul><pre class="mf mg mh mi fd mp mq mr ms aw mt bi"><span id="3e77" class="lr ka hp mq b fi mu mv l mw mx">DataStream&lt;Tuple3&lt;Integer,String,Long&gt;&gt; input = // defined DataStream as Tuple which has 3 objects</span><span id="3ec4" class="lr ka hp mq b fi nd mv l mw mx">KeyedStream&lt;Tuple3&lt;Integer,String,Long&gt;,Tuple&gt; keyed = input.keyBy(0) // keyed stream with integer input of the tuple</span></pre><h2 id="e6d7" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">2.字段表达式</h2><ul class=""><li id="35c6" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">使用基于字符串的字段表达式定义键。</li><li id="e844" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">字段表达式适用于元组、POJOs和case类</li></ul><pre class="mf mg mh mi fd mp mq mr ms aw mt bi"><span id="3735" class="lr ka hp mq b fi mu mv l mw mx">public class LogObject{<br/>    private String color;<br/>}</span><span id="a128" class="lr ka hp mq b fi nd mv l mw mx">DataStream&lt;LogObject&gt; input = // ...</span><span id="2bf6" class="lr ka hp mq b fi nd mv l mw mx">KeyedStream&lt;LogObject, String&gt; keyed = input.keyBy("color") </span></pre><h2 id="e51e" class="lr ka hp bd kb ls lt lu kf lv lw lx kj ix ly lz kn jb ma mb kr jf mc md kv me bi translated">3.按键选择器</h2><ul class=""><li id="ad97" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">用KeySelector函数指定键。</li><li id="b2eb" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">KeySelector函数从输入事件中提取一个键。</li></ul><pre class="mf mg mh mi fd mp mq mr ms aw mt bi"><span id="502a" class="lr ka hp mq b fi mu mv l mw mx">KeyedStream&lt;LogObject, String&gt; keyed = input.keyBy(new KeySelector&lt;LogObject, String&gt;(){<br/>    public String getKey(LogObject logObject){<br/>        return logObject.token;<br/>    }<br/>});</span></pre></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="df0a" class="jz ka hp bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">丰富的功能</h1><ul class=""><li id="da5b" class="kx ky hp io b ip kz it la ix lb jb lc jf ld jj le lf lg lh bi translated">当需要在函数处理第一条记录之前初始化函数，或者需要检索函数执行时的上下文信息时，我们使用丰富函数</li><li id="3f80" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">rich函数的名称以<strong class="io hq"> Rich </strong>开头，后面是转换名称<strong class="io hq"> RichMapFunction、RichFlatMapFunction </strong>等…</li><li id="da4b" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">当我们使用rich函数时，我们有2个额外的方法:</li></ul><p id="8b3f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> open() = &gt; </strong>是富函数的一种初始化方法。每个任务调用一次<strong class="io hq">。</strong></p><p id="d8f9" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> close()= &gt; </strong>是一种终结方法。在转换的最后一次调用之后，每个任务都会调用一次<strong class="io hq"/></p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="60c3" class="jz ka hp bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">设置平行度</h1><p id="bf45" class="pw-post-body-paragraph im in hp io b ip kz ir is it la iv iw ix nf iz ja jb ng jd je jf nh jh ji jj hb bi translated">众所周知，Flink应用程序是在分布式环境中并行执行的。</p><p id="d8ab" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们记住它是如何发生的:</p><ul class=""><li id="9853" class="kx ky hp io b ip iq it iu ix ln jb lo jf lp jj le lf lg lh bi translated">当一个数据流程序提交给作业管理器时(可以通过仪表板或命令行完成)，系统创建一个数据流图，并准备好<strong class="io hq">操作符</strong>用于执行</li><li id="a633" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">每个操作员将被转换到<strong class="io hq">并行任务</strong></li><li id="2e99" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">每个任务将处理操作员输入流的子集</li><li id="a3de" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">一个操作符的# <strong class="io hq">并行任务</strong>称为<strong class="io hq">操作符的并行性</strong></li></ul><p id="cb15" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以在编写数据流程序时控制这种并行性。我们还可以控制执行环境或每个操作员的并行性。</p><p id="7639" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不要忘记，默认情况下，所有操作符的并行性都被设置为应用程序执行环境的并行性</p><p id="d662" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看这个例子</p><pre class="mf mg mh mi fd mp mq mr ms aw mt bi"><span id="b162" class="lr ka hp mq b fi mu mv l mw mx">StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();</span><span id="3af7" class="lr ka hp mq b fi nd mv l mw mx">int defaultParallelism = env.getParallelism();</span><span id="d8d7" class="lr ka hp mq b fi nd mv l mw mx">// the source will runs with the default parallelism<br/>DataStream&lt;LogObject&gt; source = env.addSource(YourApahceFlinkKafkaConsumer);</span><span id="0a9f" class="lr ka hp mq b fi nd mv l mw mx">// the map parallelism is set to double the defaul parallelism<br/>DataStream&lt;LogObject&gt; mappedLog = source.map(...).setParallelism(defaultParallelism*2);</span><span id="6713" class="lr ka hp mq b fi nd mv l mw mx">// the filterLog is fixed to 2<br/>DataStream&lt;LogObject&gt; filterLog = source.filter(...).setParallelism(2);</span></pre><p id="1ae0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们提交并行度为16的应用程序，那么</p><ul class=""><li id="92d8" class="kx ky hp io b ip iq it iu ix ln jb lo jf lp jj le lf lg lh bi translated">源代码将运行16个任务</li><li id="2b34" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">Mapper将运行32个任务</li><li id="04f6" class="kx ky hp io b ip li it lj ix lk jb ll jf lm jj le lf lg lh bi translated">过滤器将与2项任务一起运行</li></ul><p id="47bb" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后但同样重要的是，等待下一个帖子…</p></div></div>    
</body>
</html>