<html>
<head>
<title>Predicting Movie Genres using NLP — An Awesome Introduction to Multi-Label Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NLP预测电影类型——多标签分类的精彩介绍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-movie-genres-using-nlp-46d70b97c67d?source=collection_archive---------3-----------------------#2019-04-22">https://medium.com/analytics-vidhya/predicting-movie-genres-using-nlp-46d70b97c67d?source=collection_archive---------3-----------------------#2019-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="5318" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="1263" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">上周，我饶有兴趣地阅读了<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2019/04/build-first-multi-label-image-classification-model-python/https://www.analyticsvidhya.com/blog/2019/04/build-first-multi-label-image-classification-model-python/?utm_source=medium&amp;utm_medium=predicting-movie-genres-nlp-multi-label-classification" rel="noopener ugc nofollow" target="_blank">这篇关于构建多标签图像分类模型</a>的精彩文章。我心中的数据科学家开始探索将这个想法转化为一个<a class="ae kb" href="https://courses.analyticsvidhya.com/courses/natural-language-processing-nlp?utm_source=medium&amp;utm_medium=predicting-movie-genres-nlp-multi-label-classification" rel="noopener ugc nofollow" target="_blank">自然语言处理(NLP) </a>问题的可能性。</p><p id="bfed" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">那篇文章展示了预测电影类型的计算机视觉技术。所以我必须找到一种方法将问题陈述转换成基于文本的数据。现在，大多数NLP教程着眼于解决单标签分类挑战(当每个观察只有一个标签时)。</p><p id="a82b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">但是电影不是一维的。一部电影可以跨越几个流派。作为一名数据科学家，这是我乐于接受的挑战。我摘抄了一堆电影剧情概要，用这个多标签分类的概念开始着手工作。即使使用简单的模型，结果也确实令人印象深刻。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/66c4bae0351627e288a04df8d23ea45c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2QfpjBlhyspuP3Oa.jpg"/></div></div></figure><p id="2352" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在本文中，我们将采取一种非常实用的方法来理解NLP中的多标签分类。我在使用NLP构建电影类型预测模型的过程中获得了很多乐趣，我相信你也一样。让我们开始吧！</p><h1 id="6bf4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目录</h1><ol class=""><li id="e924" class="kt ku hi jf b jg jh jk jl jo kv js kw jw kx ka ky kz la lb bi translated">多标签分类简介</li><li id="9c07" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">设置我们的多标签分类问题陈述</li><li id="6ced" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">关于数据集</li><li id="2cd6" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">我们建立电影类型预测模型的策略</li><li id="4121" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">实现:使用多标签分类建立电影类型预测模型(Python语言)</li></ol><h1 id="a474" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">多标签分类简介</h1><p id="f73f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我和你一样兴奋地跳入代码，开始建立我们的流派分类模型。不过，在此之前，让我先向您介绍一下NLP中多标签分类的概念。<em class="lh">在开始实现之前，首先理解技术是很重要的。</em></p><p id="90a7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">从名称中可以明显看出潜在的概念——多标签分类。这里，一个实例/记录可以有多个标签，并且每个实例的标签数量是不固定的。</p><p id="d813" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我用一个简单的例子来解释一下。请看下表，其中“X”代表输入变量，“y”代表目标变量(我们正在预测):</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es li"><img src="../Images/1589c537790149ca1fa3ccdf08198a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/0*ANofhq3fhxuyauR4.png"/></div></figure><ul class=""><li id="a1e2" class="kt ku hi jf b jg kc jk kd jo lj js lk jw ll ka lm kz la lb bi translated">“y”是表1中的二进制目标变量。因此，只有两个标签——t1和t2</li><li id="f5cd" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated">表2中的“y”包含两个以上的标签。但是，请注意<strong class="jf hj">在这两个表</strong>中，每个输入只有一个标签<em class="lh"/></li><li id="ab02" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated">你一定猜到了为什么表3会脱颖而出。我们在这里有多个标签，不仅仅是整个表，还可以用于单独的输入</li></ul><p id="3409" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们不能在这种数据集上直接应用传统的分类算法。为什么？因为这些算法期望每个输入只有一个标签，而实际上我们有多个标签。这是一个有趣的挑战，也是我们将在本文中解决的问题。</p><p id="940c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">您可以在下面的文章中更深入地了解多标签分类问题:</p><ul class=""><li id="eda3" class="kt ku hi jf b jg kc jk kd jo lj js lk jw ll ka lm kz la lb bi translated"><a class="ae kb" href="https://www.analyticsvidhya.com/blog/2017/08/introduction-to-multi-label-classification/https://www.analyticsvidhya.com/blog/2019/04/build-first-multi-label-image-classification-model-python/?utm_source=medium&amp;utm_medium=predicting-movie-genres-nlp-multi-label-classification" rel="noopener ugc nofollow" target="_blank">解决多标签分类问题(使用案例研究)</a></li></ul><h1 id="91f8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">设置我们的多标签分类问题陈述</h1><p id="3b7e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有几种方法可以建立一个推荐引擎。当谈到电影类型时，你可以根据多个变量对数据进行分割。但这里有一个简单的方法——建立一个可以自动预测流派标签的模型！我已经可以想象给推荐者增加这样一个选项的可能性。对所有人都是双赢。</p><blockquote class="ln lo lp"><p id="8d1b" class="jd je lh jf b jg kc ji jj jk kd jm jn lq ke jq jr lr kf ju jv ls kg jy jz ka hb bi translated"><em class="hi">我们的任务是建立一个模型，仅使用情节细节(以文本形式提供)就可以预测电影的类型。</em></p></blockquote><p id="b215" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">看看下面来自IMDb的快照，挑选出展出的不同物品:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lt"><img src="../Images/697f9ccf2a968ee2ac5ba2a2c8073068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/0*TqyD0F6obYP7EucI.png"/></div></figure><p id="81c0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在这么小的空间里有很多信息:</p><ul class=""><li id="a36c" class="kt ku hi jf b jg kc jk kd jo lj js lk jw ll ka lm kz la lb bi translated">电影标题</li><li id="74db" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated">右上角的电影分级</li><li id="5f94" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated">电影总时长</li><li id="1dc8" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated">发布日期</li><li id="e34e" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated">当然，我在洋红色边框中突出显示的电影类型</li></ul><p id="9d87" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">类型告诉我们可以从电影中期待什么。由于这些类型是可点击的(至少在IMDb上)，它们允许我们发现其他同类的类似电影。看似简单的产品功能突然有了这么多有前途的选择。🙂</p><h1 id="c984" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">关于数据集</h1><p id="a69e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将为我们的项目使用<a class="ae kb" href="http://www.cs.cmu.edu/~ark/personas/" rel="noopener ugc nofollow" target="_blank"> CMU电影摘要语料库</a>开放数据集。<strong class="jf hj">你可以直接从这个</strong> <a class="ae kb" href="http://www.cs.cmu.edu/~ark/personas/data/MovieSummaries.tar.gz" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj">链接</strong> </a> <strong class="jf hj">下载数据集。</strong></p><p id="12d0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这个数据集包含多个文件，但是我们现在只关注其中的两个:</p><ul class=""><li id="d4fb" class="kt ku hi jf b jg kc jk kd jo lj js lk jw ll ka lm kz la lb bi translated"><strong class="jf hj">movie . Metadata . tsv:</strong>81，741部电影的元数据，从2012年11月4日的Freebase转储中提取。该文件中提供了电影类型标签</li><li id="7aae" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated"><strong class="jf hj"> plot_summaries.txt: </strong>从2012年11月2日的英文维基百科转储中提取的42，306部电影的情节摘要。每一行都包含维基百科电影ID(索引到<em class="lh"> movie.metadata.tsv </em>)和情节摘要</li></ul><h1 id="09e0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">我们建立电影类型预测模型的策略</h1><p id="d03e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们知道不能在多标签数据集上直接使用监督分类算法。因此，我们首先必须转换我们的目标变量。让我们看看如何使用虚拟数据集来实现这一点:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lu"><img src="../Images/4ffa11e80054571099bbde445b314898.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/0*dTPKiyqucqSNw0VV.png"/></div></figure><p id="9e38" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这里，X和y分别是要素和标注，这是一个多标注数据集。现在，我们将使用<strong class="jf hj">二元相关性</strong>方法来转换我们的目标变量y。我们将首先取出数据集中的唯一标签:</p><p id="3261" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">唯一标签= [ t1，t2，t3，t4，t5 ]</p><p id="4ad0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">数据中有5个唯一的标记。接下来，我们需要用多个目标变量替换当前的目标变量，每个目标变量都属于数据集的唯一标签。由于有5个唯一标签，因此将有5个新的目标变量，值为0和1，如下所示:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lv"><img src="../Images/6bb8e1a62d93753e01dc92ef085e0a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/0*ZuHpXMjGTSIh9SV-.png"/></div></figure><p id="2e1f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们现在已经讨论了最终开始解决这个问题的必要基础。在下一节中，我们将最终使用Python制作一个<strong class="jf hj">自动电影类型预测系统</strong>！</p><h1 id="0342" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">实现:使用多标签分类建立电影类型预测模型(Python语言)</h1><p id="8684" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们已经理解了问题陈述，并建立了逻辑策略来设计我们的模型。让我们一起开始编码吧！</p><h1 id="ab8f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">导入所需的库</h1><p id="298d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将从导入项目所需的库开始:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h1 id="dffb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">加载数据</h1><p id="6f54" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们先加载电影元数据文件。使用' \t '作为分隔符，因为它是一个制表符分隔的文件(。tsv):</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="5b04" class="md ig hi lz b fi me mf l mg mh">meta = pd.read_csv("movie.metadata.tsv", sep = '\t', header = None) meta.head()</span></pre><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mi"><img src="../Images/e4fa7295aefa016bb2af59b7eeb8983c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ch4xbvTGT23guM1K.png"/></div></div></figure><p id="6fd4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">哦，等等，这个数据集中没有标题。第一列是<strong class="jf hj">唯一电影id </strong>，第三列是电影的<strong class="jf hj">名称，最后一列包含<strong class="jf hj">电影类型</strong>。在此分析中，我们将不使用其余的列。</strong></p><p id="ee26" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们为上述三个变量添加列名:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="8f81" class="md ig hi lz b fi me mf l mg mh"># rename columns <br/>meta.columns = ["movie_id",1,"movie_name",3,4,5,6,7,"genre"]</span></pre><p id="dd58" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，我们将把<strong class="jf hj">电影情节数据集</strong>载入内存。这些数据来自一个文本文件，每行包含一个电影id和一个电影情节。我们将逐行阅读:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="91c1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">接下来，将电影id和情节分成两个单独的列表。我们将使用这些列表来形成一个数据框架:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="e60a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们看看“电影”数据框架中有什么:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="6238" class="md ig hi lz b fi me mf l mg mh">movies.head()</span></pre><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mj"><img src="../Images/16aa722148575d0fe4c9ea0a4e180e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EEQ5SoUrOBvUxh_5.png"/></div></div></figure><p id="f687" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">完美！我们既有电影id，也有对应的电影剧情。</p><h1 id="d115" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">数据探索和预处理</h1><p id="0966" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们根据<em class="lh"> movie_id </em>列，通过将后者合并到前者来添加电影元数据文件中的电影名称及其类型:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mk"><img src="../Images/9c88238de1897c1c11ae1df79c9ad174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z2jYkd0iPmCMmzlw.png"/></div></div></figure><p id="eeda" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">太好了！我们已经添加了电影名称和类型。然而，这些类型是用字典符号表示的。如果我们能把它们转换成一个Python列表，使用起来会更容易。我们将使用第一行:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="71ae" class="md ig hi lz b fi me mf l mg mh">movies['genre'][0]</span></pre><p id="029a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="323b" class="md ig hi lz b fi me mf l mg mh">'{"/m/07s9rl0": "Drama", "/m/03q4nz": "World cinema"}'</span></pre><p id="4c6a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们不能只使用<em class="lh">来访问这一行中的流派。values( ) </em>。你能猜到原因吗？这是因为该文本是字符串，而不是字典。我们将不得不把这个字符串转换成字典。我们将在这里利用<strong class="jf hj"> json库</strong>的帮助:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="9e3c" class="md ig hi lz b fi me mf l mg mh">type(json.loads(movies['genre'][0]))</span></pre><p id="0177" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="3b98" class="md ig hi lz b fi me mf l mg mh">dict</span></pre><p id="bbd7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们现在可以轻松访问该行的流派:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="e476" class="md ig hi lz b fi me mf l mg mh">json.loads(movies['genre'][0]).values()</span></pre><p id="cff9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="d73c" class="md ig hi lz b fi me mf l mg mh">dict_values(['Drama', 'World cinema'])</span></pre><p id="75a9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这段代码帮助我们从电影数据中提取所有的类型。完成后，将提取的类型作为列表添加回电影数据帧:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="4f42" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">有些样本可能不包含任何流派标签。我们应该删除这些样本，因为它们不会在我们的模型构建过程中发挥作用:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="af64" class="md ig hi lz b fi me mf l mg mh"># remove samples with 0 genre tags <br/>movies_new = movies[~(movies['genre_new'].str.len() == 0)]</span><span id="d3fe" class="md ig hi lz b fi ml mf l mg mh">movies_new.shape, movies.shape</span></pre><p id="5a0a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="98de" class="md ig hi lz b fi me mf l mg mh">((41793, 5), (42204, 5))</span></pre><p id="43bf" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">只有411个样本没有流派标签。让我们再看一下数据框:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="8f8b" class="md ig hi lz b fi me mf l mg mh">movies.head()</span></pre><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mj"><img src="../Images/e9f0285e0c85beac5fd1ad1720acebf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TNjbXVWNGziJPIWZ.png"/></div></div></figure><p id="654d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">请注意，流派现在是列表格式。你是否很好奇这个数据集中涵盖了多少电影类型？下面的代码回答了这个问题:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="0da5" class="md ig hi lz b fi me mf l mg mh"># get all genre tags in a list <br/>all_genres = sum(genres,[]) <br/>len(set(all_genres))</span></pre><p id="82a8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="7fc6" class="md ig hi lz b fi me mf l mg mh">363</span></pre><p id="a071" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们的数据集中有超过363个独特的流派标签。这是一个相当大的数字。我能努力回忆起5-6个流派！让我们看看这些标签是什么。我们将使用来自<em class="lh"> nltk </em>库的<strong class="jf hj"> FreqDist( ) </strong>来创建一个流派字典以及它们在数据集中的出现次数:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="6535" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我个人觉得可视化数据比简单地输出数字要好得多。那么，让我们画出电影类型的分布图:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mm"><img src="../Images/f75a674ebcb6ed2f823da2530ded3ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sOPKY_wIL4rWSDH9.png"/></div></div></figure><p id="b15f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">接下来，我们将清理一些数据。我将使用一些非常基本的文本清理步骤(因为这不是本文的重点):</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="41cb" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们通过使用apply-lambda duo将该函数应用于电影情节:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="96f7" class="md ig hi lz b fi me mf l mg mh">movies_new['clean_plot'] = movies_new['plot'].apply(lambda x:  <br/>                                                    clean_text(x))</span></pre><p id="f033" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">请随意查看新旧电影情节。我在下面提供了一些随机样本:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mn"><img src="../Images/8dedcc220c947c564c65bd8e1c3682dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L1JcGNRnLgMrgN0h.png"/></div></div></figure><p id="09a5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在<em class="lh"> clean_plot </em>栏中，所有文本都是小写的，也没有标点符号。我们的文本清理工作非常有效。</p><p id="35f5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">下面的函数将可视化一组文档中的单词及其频率。让我们用它来找出电影情节栏中最常用的词:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mo"><img src="../Images/194a89191eac6ef4c16357673e615994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HlTlrzuGBfb_orFD.png"/></div></div></figure><p id="6b9b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">以上情节中的大部分术语都是停用词。这些停用词远没有文本中的其他关键字有意义(它们只是给数据增加了噪音)。我将继续把它们从情节文本中删除。您可以从<em class="lh"> nltk </em>库中下载停用词列表:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="13c4" class="md ig hi lz b fi me mf l mg mh">nltk.download('stopwords')</span></pre><p id="c921" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们去掉停用词:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="e966" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">检查不带停用词的最常用术语:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="ec83" class="md ig hi lz b fi me mf l mg mh">freq_words(movies_new['clean_plot'], 100)</span></pre><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mp"><img src="../Images/c1378c45f028939b20970fc023a87849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vfODRpjfMBNAPAfc.png"/></div></div></figure><p id="0ba4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">看起来好多了，不是吗？现在出现了更有趣、更有意义的词，如“警察”、“家庭”、“金钱”、“城市”等。</p><p id="2da6" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我前面提到过，我们将把这个多标签分类问题作为一个二元相关性问题来处理。因此，我们现在将使用sklearn的<strong class="jf hj"> MultiLabelBinarizer( ) </strong>对目标变量进行热编码，即<em class="lh"> genre_new </em>。由于有363个独特的风格标签，将有363个新的目标变量。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="d349" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，是时候将我们的注意力转向从电影情节数据的干净版本中提取特征了。对于本文，我将使用TF-IDF特性。您可以随意使用任何您熟悉的其他特征提取方法，比如词袋、word2vec、GloVe或ELMo。</p><p id="39b4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我建议查看以下文章，了解更多关于从文本创建要素的不同方法:</p><ul class=""><li id="b60b" class="kt ku hi jf b jg kc jk kd jo lj js lk jw ll ka lm kz la lb bi translated"><a class="ae kb" href="https://www.analyticsvidhya.com/blog/2017/06/word-embeddings-count-word2veec/?utm_source=medium&amp;utm_medium=predicting-movie-genres-nlp-multi-label-classification" rel="noopener ugc nofollow" target="_blank">对单词嵌入的直观理解:从计数向量到Word2Vec </a></li><li id="4f7c" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated"><a class="ae kb" href="https://www.analyticsvidhya.com/blog/2019/03/learn-to-use-elmo-to-extract-features-from-text/?utm_source=medium&amp;utm_medium=predicting-movie-genres-nlp-multi-label-classification" rel="noopener ugc nofollow" target="_blank">学习ELMo从文本中提取特征的分步NLP指南</a></li></ul><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="8d52" class="md ig hi lz b fi me mf l mg mh">tfidf_vectorizer = TfidfVectorizer(max_df=0.8, max_features=10000)</span></pre><p id="7057" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我使用了数据中最常用的10，000个单词作为我的特征。您也可以为<em class="lh"> max_features </em>参数尝试任何其他数字。</p><p id="f3fd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，在创建TF-IDF特征之前，我们将把数据分成训练集和验证集，用于训练和评估模型的性能。我将采用80–20的比例，80%的数据样本在训练集中，其余的在验证集中:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="7115" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，我们可以为训练和验证集创建特征:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="0205" class="md ig hi lz b fi me mf l mg mh"># create TF-IDF features <br/>xtrain_tfidf = tfidf_vectorizer.fit_transform(xtrain) <br/>xval_tfidf = tfidf_vectorizer.transform(xval)</span></pre><h1 id="f978" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">建立你的电影类型预测模型</h1><p id="0176" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们已经为模型构建部分做好了准备！这是我们一直在等待的。</p><p id="696a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">记住，我们将不得不为每一个热编码的目标变量建立一个模型。由于我们有363个目标变量，我们将不得不用同一组预测因子(TF-IDF特征)来拟合363个不同的模型。</p><p id="dbc6" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">可以想象，在一个中等规模的系统上训练363个模型需要相当长的时间。因此，我将构建一个逻辑回归模型，因为它可以在有限的计算能力上快速训练:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="fe6a" class="md ig hi lz b fi me mf l mg mh">from sklearn.linear_model import LogisticRegression </span><span id="7d5c" class="md ig hi lz b fi ml mf l mg mh"># Binary Relevance <br/>from sklearn.multiclass import OneVsRestClassifier </span><span id="2bbc" class="md ig hi lz b fi ml mf l mg mh"># Performance metric <br/>from sklearn.metrics import f1_score</span></pre><p id="224b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们将使用sk-learn的<em class="lh"> OneVsRestClassifier </em>类来解决这个二进制相关性或一对一问题:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="b62d" class="md ig hi lz b fi me mf l mg mh">lr = LogisticRegression() <br/>clf = OneVsRestClassifier(lr)</span></pre><p id="beee" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">最后，在列车组上安装模型:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="29a3" class="md ig hi lz b fi me mf l mg mh"># fit model on train data <br/>clf.fit(xtrain_tfidf, ytrain)</span></pre><p id="cb7b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">预测验证集上的电影类型:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="0731" class="md ig hi lz b fi me mf l mg mh"># make predictions for validation set <br/>y_pred = clf.predict(xval_tfidf)</span></pre><p id="eda6" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们看看这些预测中的一个例子:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="209b" class="md ig hi lz b fi me mf l mg mh">y_pred[3]</span></pre><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mq"><img src="../Images/0c8c6282b5d8cb0cc521c11a91a4df36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K5e2dR1pEZrKLjAg.png"/></div></div></figure><p id="0865" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">它是一个长度为363的二进制一维数组。基本上，它是独一无二的流派标签的一次性编码形式。我们必须想办法把它转换成电影类型标签。</p><p id="d168" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">幸运的是，sk-learn再次拯救了我们。我们将使用<strong class="jf hj"> inverse_transform( ) </strong>函数和<em class="lh">multilabel binary izer()</em>对象将预测的数组转换成电影类型标签:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="9a7d" class="md ig hi lz b fi me mf l mg mh">multilabel_binarizer.inverse_transform(y_pred)[3]</span></pre><p id="4e31" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="7bde" class="md ig hi lz b fi me mf l mg mh">('Action', 'Drama')</span></pre><p id="e450" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">哇！很顺利。</p><p id="9d88" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">但是，为了评估我们模型的整体性能，我们需要考虑所有预测和验证集的整个目标变量:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="6659" class="md ig hi lz b fi me mf l mg mh"># evaluate performance <br/>f1_score(yval, y_pred, average="micro")</span></pre><p id="c75a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="bf13" class="md ig hi lz b fi me mf l mg mh">0.31539641943734015</span></pre><p id="7473" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们得到了0.315的不错的F1分数。这些预测是基于阈值0.5做出的，这意味着大于或等于0.5的概率被转换为1，其余的被转换为0。</p><p id="d34c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试着改变这个阈值，看看是否能提高我们模型的分数:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="5d19" class="md ig hi lz b fi me mf l mg mh"># predict probabilities <br/>y_pred_prob = clf.predict_proba(xval_tfidf)</span></pre><p id="a872" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在设置一个阈值:</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="e4e5" class="md ig hi lz b fi me mf l mg mh">t = 0.3 # threshold value <br/>y_pred_new = (y_pred_prob &gt;= t).astype(int)</span></pre><p id="6b37" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我试过0.3作为阈值。您也应该尝试其他值。让我们根据这些新的预测再次检查F1的分数。</p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="d236" class="md ig hi lz b fi me mf l mg mh"># evaluate performance <br/>f1_score(yval, y_pred_new, average="micro")</span></pre><p id="b0b5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">输出:</strong></p><pre class="ki kj kk kl fd ly lz ma mb aw mc bi"><span id="8fa6" class="md ig hi lz b fi me mf l mg mh">0.4378456703198025</span></pre><p id="f423" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这对我们模型的性能是一个相当大的提升。找到正确阈值的更好方法是使用k倍交叉验证设置并尝试不同的值。</p><h1 id="4b84" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">创建推理函数</h1><p id="4e70" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">等待——我们还没有解决这个问题。我们还必须考虑未来将出现的新数据或新电影情节，对吗？我们的电影类型预测系统应该能够以原始形式的电影情节作为输入，并生成其类型标签。</p><p id="6ec0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">为了实现这一点，让我们构建一个推理函数。它将采用电影情节文本，并遵循以下步骤:</p><ul class=""><li id="0c60" class="kt ku hi jf b jg kc jk kd jo lj js lk jw ll ka lm kz la lb bi translated">清理文本</li><li id="8708" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated">从清除的文本中删除停用字词</li><li id="af5c" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated">从文本中提取特征</li><li id="d4f9" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated">做预测</li><li id="2626" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated">返回预测的电影类型标签</li></ul><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="3c4a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们在验证集中的几个样本上测试这个推理函数:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lw lx l"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mr"><img src="../Images/3081dda550e4589f8cec5d4bedfd2e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WAc8oIQa6aD8KBC9.png"/></div></div></figure><p id="9c11" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">耶！我们已经建造了一个非常实用的模型。该模型还不能预测罕见的流派标签，但这是另一个时间的挑战(或者你可以采取它，让我们知道你遵循的方法)。</p><h1 id="14b0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">从这里去哪里？</h1><p id="9cf8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果你正在寻找类似的挑战，你会发现下面的链接很有用。我已经在我们的自然语言处理课程中使用机器学习和深度学习模型解决了一个<strong class="jf hj"> Stackoverflow问题标签预测</strong>问题。</p><p id="5c74" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">本课程的链接如下，供您参考:</p><ul class=""><li id="f205" class="kt ku hi jf b jg kc jk kd jo lj js lk jw ll ka lm kz la lb bi translated"><a class="ae kb" href="https://courses.analyticsvidhya.com/courses/natural-language-processing-nlp/?utm_source=medium&amp;utm_medium=predicting-movie-genres-nlp-multi-label-classification" rel="noopener ugc nofollow" target="_blank">认证课程:使用Python的自然语言处理(NLP)</a></li><li id="a4b8" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated"><a class="ae kb" href="https://courses.analyticsvidhya.com/bundles/nlp-combo?utm_source=medium&amp;utm_medium=predicting-movie-genres-nlp-multi-label-classification" rel="noopener ugc nofollow" target="_blank">认证项目:初学者NLP</a></li><li id="33fa" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka lm kz la lb bi translated"><a class="ae kb" href="https://courses.analyticsvidhya.com/bundles/ai-blackbelt-beginner-to-master?utm_source=medium&amp;utm_medium=predicting-movie-genres-nlp-multi-label-classification" rel="noopener ugc nofollow" target="_blank">终极AI &amp; ML黑带程序</a></li></ul><h1 id="4861" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结束注释</h1><p id="2da5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我希望看到来自我们社区的不同方法和技术来实现更好的结果。尝试使用不同的特征提取方法，建立不同的模型，微调那些模型等。你可以尝试的事情太多了。不要止步于此，继续尝试吧！</p><p id="4e3f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">欢迎在下面的评论区自由讨论和评论。完整的代码可在<a class="ae kb" href="https://github.com/prateekjoshi565/movie_genre_prediction/blob/master/Movie_Genre_Prediction.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="0b3d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">你也可以在分析Vidhya的Android应用上阅读这篇文章</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ms"><img src="../Images/66a683496b89632a1839de18a9bbc3f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/0*JdSXeRuM0Ns-i4yy.png"/></div></div></figure><p id="3cfb" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">相关文章</p></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><p id="c0e7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="lh">原载于2019年4月22日</em><a class="ae kb" href="https://www.analyticsvidhya.com/blog/2019/04/predicting-movie-genres-nlp-multi-label-classification/" rel="noopener ugc nofollow" target="_blank"><em class="lh">https://www.analyticsvidhya.com</em></a><em class="lh">。</em></p></div></div>    
</body>
</html>