<html>
<head>
<title>Artificial Intelligence Songwriter : What If Taylor Swift’s Songs Were Written By A Machine ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能歌曲作者:如果泰勒·斯威夫特的歌是机器写的会怎样？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/artificial-intelligence-songwriter-what-if-taylor-swifts-songs-were-written-by-a-machine-b6e2218e9967?source=collection_archive---------11-----------------------#2020-04-27">https://medium.com/analytics-vidhya/artificial-intelligence-songwriter-what-if-taylor-swifts-songs-were-written-by-a-machine-b6e2218e9967?source=collection_archive---------11-----------------------#2020-04-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ee83" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">几周前，我发现了一个很酷的<a class="ae ix" href="https://theselyricsdonotexist.com/" rel="noopener ugc nofollow" target="_blank">网站</a>，它使用人工智能为各种主题生成原创歌词，我想知道:这究竟是如何工作的？所以你猜怎么着！我决定建立自己的人工智能词曲作者，生成假泰勒斯威夫特歌词。</h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/e4ba7ca6d1a67a6dd87164e29e60453e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQG1Qz6wW61MSbD1SR_eKQ.jpeg"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">照片由<a class="ae ix" href="https://unsplash.com/@raphaellovaski?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Raphael Lovaski </a>在<a class="ae ix" href="https://unsplash.com/s/photos/taylor-swift?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6aac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这篇文章充分描述了所承担的项目。如图所示，它分为6个部分<br/>:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es kk"><img src="../Images/cb3f058f1d9c3f6cff921327be90dc4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvLtVGQPGcCIX9YWMXvChg.jpeg"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">实施的步骤</figcaption></figure><p id="31bd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以让我们开始实现我们的智能词曲作者！</p><h1 id="d833" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated"><strong class="ak">第一节:问题公式化</strong></h1><p id="ed7d" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">长短期记忆网络——通常被称为“lstm”——是一种特殊的RNN，能够学习长期依赖性。它们是由<a class="ae ix" href="https://en.wikipedia.org/wiki/Sepp_Hochreiter" rel="noopener ugc nofollow" target="_blank">hoch Reiter</a>&amp;<a class="ae ix" href="https://en.wikipedia.org/wiki/J%C3%BCrgen_Schmidhuber" rel="noopener ugc nofollow" target="_blank">schmid Huber</a>(1997)提出的，并在随后的工作中被许多人提炼和推广。</p><p id="93e2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文不讨论LSTM-RNNs背后的理论。你可以在这里了解他们。</p><p id="07cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">LSTM递归神经网络可用于许多应用<br/>如语言建模、文本分类、<strong class="jq hj">自然语言生成(NLG) </strong> …</p><p id="0706" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">自然语言生成是一种从结构化数据中产生文本的人工智能。我们的应用程序是自然语言生成的众多应用程序之一。</p><p id="eeb3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将使用KERAS和TensorFlow实现一个基于长短期记忆递归神经网络(LSTM-RNN)的泰勒斯威夫特歌词生成器。该项目试图从头开始设计、训练、验证和测试一个模型，使我们能够生成这样的歌词。</p><p id="7e09" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将在本文结尾看到机器学习技术<br/>是否能为泰勒·斯威夫特创作更好的歌曲。</p><h1 id="524d" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">第2部分:准备工作区</h1><p id="7513" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">由于我们有一个大的数据集，我们将需要一个非常高的计算能力。然后我们将使用<a class="ae ix" href="https://colab.research.google.com/notebooks/intro.ipynb#recent=true" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>，这是一个免费的云服务，有助于使用Keras、TensorFlow等流行的库开发深度学习应用程序…</p><p id="2ac8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们导入开发中需要的库。一个<br/>库本质上是一个可以被调用和使用的模块的集合。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es li"><img src="../Images/d41646a62452666fb32fc3fb063ec290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nu4TI6bjTRZD_OvM96iCbw.png"/></div></div></figure><p id="e54c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里要讨论两个深度学习库:</p><p id="695b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">。Keras </strong>是一个开源库，用于在接口的高层构建神经网络，它是用Python编写的。它使用Theano或TensorFlow作为后端。</p><p id="87e7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">。TensorFlow </strong>来自谷歌的开发者，它是一个数据流图计算的开源库，为机器学习而锐化。它被设计用来训练神经网络。</p><p id="251e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Keras和TensorFlow之间的关键区别在于，Keras在模型级别进行接口，它不处理较低级别的操作。<br/> TensorFlow从另一个侧面，在CUDA、GPU、CPU深层次接口。</p><p id="6541" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经导入了所有需要的库，让我们加载、研究和预处理我们的数据。</p><h1 id="c416" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">第3部分:预处理</h1><p id="8567" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated"><strong class="jq hj">“数据科学家大约80%的时间只花在准备处理数据上”~福布斯</strong></p><p id="061b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们从广泛的来源收集数据，大多数时候，数据是以原始格式收集的，不适用于分析。数据预处理是开始处理数据的第一步。</p><h2 id="9b31" class="lj km hi bd kn lk ll lm kr ln lo lp kv jx lq lr kx kb ls lt kz kf lu lv lb lw bi translated">1.数据采集和探索</h2><p id="d07d" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">在这个项目中，我们将使用<a class="ae ix" href="https://www.kaggle.com/PromptCloudHQ/taylor-swift-song-lyrics-from-all-the-albums" rel="noopener ugc nofollow" target="_blank">Kaggle上可用的数据集</a>，该数据集由PromptCloud(数据即服务提供商)创建，使用泰勒斯威夫特歌曲歌词的Genius.com公开的API。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lx"><img src="../Images/909d4483ea4bcde67cd0691c46dd3d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9oVqORO1XnU2k_0894jtw.png"/></div></div></figure><h2 id="3285" class="lj km hi bd kn lk ll lm kr ln lo lp kv jx lq lr kx kb ls lt kz kf lu lv lb lw bi translated">2.数据集和数据字典</h2><p id="ee78" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated"><em class="ly">我们的数据集有以下数据字段:</em></p><p id="e381" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="ly">艺人</em> </strong> <em class="ly">:艺人名称</em></p><p id="2b86" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="ly">专辑</em> </strong> <em class="ly">:专辑名称</em></p><p id="8085" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="ly">曲目_标题</em> </strong> <em class="ly"> : </em> <em class="ly">歌名</em></p><p id="5a28" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="ly"> track_n </em> </strong> <em class="ly">:专辑中的曲目号</em></p><p id="83c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="ly">抒情</em> </strong> <em class="ly">:抒情</em></p><p id="6bf8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="ly">线</em> </strong> <em class="ly"> : </em> <em class="ly">轨道中的线数</em></p><p id="647b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="ly">年份</em> </strong> <em class="ly">:发行年份</em></p><h2 id="a32e" class="lj km hi bd kn lk ll lm kr ln lo lp kv jx lq lr kx kb ls lt kz kf lu lv lb lw bi translated">3.单变量分析和质量检查</h2><p id="d56a" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">这是我们数据集的前5行:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lz"><img src="../Images/930e07fd484b16602aa94e5a775f0746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YvnapSTf1wz_yh5-0WvPqg.png"/></div></div></figure><p id="dba3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">数据集由7列/变量/预测值和4862行(来自不同歌曲的4862行歌词)组成</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ma"><img src="../Images/fabf53c0e49fcfdf23faf52e6c1bfb4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*H-4m3P1PnFb-m3pX19MJWA.png"/></div></figure><p id="51fa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以使用seaborn库对我们的变量进行单变量分析，以可视化它们的变化:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mb"><img src="../Images/9c713a93b9f258b62a0458663a73d977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*esiJbC3RaP5n9tNq9J3Ypw.jpeg"/></div></div></figure><p id="018f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们检查数据集的质量，看看是否有任何缺失值:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mc"><img src="../Images/53392a25ba513d7ce0c440330cb463b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*YixeHzBQA6FLdGf0lzRN0Q.png"/></div></figure><p id="ef86" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">数据集不包含缺失值，我们在每个变量中正好有4862个非空值。</p><h2 id="0295" class="lj km hi bd kn lk ll lm kr ln lo lp kv jx lq lr kx kb ls lt kz kf lu lv lb lw bi translated">4.数据集整理</h2><p id="6957" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">我们的数据集有点乱，还没有完全准备好被正确地用来构建我们的应用程序。这一步包括整理、组织和准备我们的数据，使我们能够在最近构建和训练我们的模型时使用它。</p><p id="8912" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在开始处理细节之前，我们应该回答两个关键问题:</p><p id="dae3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">模型应该输入什么？输入的是100个字符的序列。</p><p id="5c3f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">这个模型应该预测什么？</strong>模型必须预测该序列之后的字符。</p><p id="71d0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的问题是一个<strong class="jq hj">多分类</strong>问题！</p><p id="795c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">a.我们开发了函数<strong class="jq hj"> processFirstLine </strong>来帮助我们处理歌词的第一行:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es md"><img src="../Images/72a12131f1aa761fcad0150eb73345e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*oD1ecruA76IHfO_-a5b5lQ.png"/></div></figure><p id="d398" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们想要创建3个列表:</p><ul class=""><li id="2030" class="me mf hi jq b jr js ju jv jx mg kb mh kf mi kj mj mk ml mm bi translated">列出歌曲ID，其元素是歌曲的唯一标识符(年份和track_n的线性组合)</li><li id="08a8" class="me mf hi jq b jr mn ju mo jx mp kb mq kf mr kj mj mk ml mm bi translated">列出元素为歌曲曲目标题的歌曲名称</li><li id="0c75" class="me mf hi jq b jr mn ju mo jx mp kb mq kf mr kj mj mk ml mm bi translated">列出元素为歌曲歌词的歌词。</li></ul><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es ms"><img src="../Images/6d90744151b01eb365f83c71eec41b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtVNV7BtOVLc-CRolQZVcw.png"/></div></div></figure><p id="b092" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，让我们打印歌词的第一个元素，我们将获得歌曲的歌词，其<strong class="jq hj"> track_n </strong>为1。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mt"><img src="../Images/f2fcc519e1742ab80c01d647ca5f4fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Bswu3v4Qru6DvJYr1cASyQ.png"/></div></figure><p id="3e3f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">b.我们定义了一个新的熊猫数据帧来保存歌曲ID，歌曲名称，歌词。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mu"><img src="../Images/6e8892f86e2f30c428b79fd36086aab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNLqbnN4LmYfdOgg38nI_g.png"/></div></div></figure><p id="90d6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个数据帧是一个表，其列是songID(歌曲的唯一标识符)、songName(歌曲的音轨标题)、歌词(每首歌曲的串联歌词)</p><p id="96c9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">c.现在，我们将所有歌曲的歌词存储在一个文本文件中，以便在LSTM RNN中使用。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mv"><img src="../Images/0a9365d160dc6cd99f28e58d4dcaa7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*F5dxARq4bQy-hyVt247tyQ.png"/></div></figure><p id="56d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">3.我们在一个巨大的字符串中加载文件，我们称之为raw_text，raw_text是所有歌曲歌词的连接，我们将歌词转换成小写，以便能够映射它们。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mw"><img src="../Images/2c63880ed1c8448af890b755c0629b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*8gK0BLwIepxlAv0qqol8hQ.png"/></div></figure><p id="c929" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">d.因为机器理解和处理文本变得复杂，而且因为模型是基于数学方程和计算的，我们必须对<strong class="jq hj">分类数据</strong>进行编码。我们创建了两个字典，一个将char转换成int，另一个将int转换回char，以便映射字符。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mx"><img src="../Images/49cd4f72bf2ac9051a2b7d5cdbef91f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*odrzejT-Z7ShOmdRK9veLw.png"/></div></figure><p id="f5e4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">e.我们计算文本中字符和字母的总数:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es my"><img src="../Images/5a15e53205655f949820888137fb434c.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*O9WWPjwBPtY7GF9KQwFv8Q.png"/></div></figure><p id="f34d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">f.我们制作样品和标签来喂养LSTM RNN</p><p id="8bbf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们模型的输入将是一个100个字符的序列。我们的模型必须预测序列后面的字符。我们将预测器存储在data_X中(data_X是100个字符的序列列表)。我们将目标存储在data_Y中(data_y是一个字符列表)。data_X[i]是一个100个字符的序列，data_y[i]是这个序列后面的字符。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mz"><img src="../Images/aed2c23846a6cfe3fb6df9aac3e6990b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*6gMsgg4psH5K2yXgIbqr6w.png"/></div></figure><p id="44b1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">g.我们重塑X以适合进入LSTM RNN</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es na"><img src="../Images/91cc0cf0cd1ab0e6f510691243264c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*eVWAHPzPSbtPbi10rEDt3A.png"/></div></figure><p id="d3f6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">h.我们将输入数据标准化:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nb"><img src="../Images/d09ab66bf8a78a194a910ac04e57cbfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*WxJXfEasw0AnfkD3JuKbxw.png"/></div></figure><p id="a27d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我<em class="ly">。</em>我们将整数<em class="ly">的输出向量编码转换成二进制类矩阵。</em></p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nc"><img src="../Images/0f6676ddf80aba7fa643b3a5044f2578.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*HhMrn2-C_pArgYVeuwO1hA.png"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es na"><img src="../Images/b77d0cf8a57b80802df2e6d47d5dc789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*NnNp-G3upOjaJBuhXk_lAg.png"/></div></figure><h2 id="3416" class="lj km hi bd kn lk ll lm kr ln lo lp kv jx lq lr kx kb ls lt kz kf lu lv lb lw bi translated">5.测试列车分离</h2><p id="ba87" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">在我们开始构建和训练我们的神经网络模型之前，我们应该将数据集分成3个部分。因为我们的模型必须首先根据可用的数据分布进行训练，然后进行验证和测试，然后才能用于预测新数据的输出。</p><p id="c342" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">训练数据:</strong>这是我们的模型实际训练的部分。</p><p id="475b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">验证数据:</strong>这是数据集的一部分，用于验证我们的各种模型拟合。</p><p id="39ff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">测试数据:</strong>这部分数据集用来测试我们的模型假设。</p><p id="12f1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们的例子中，我们只将数据分成两部分(训练和测试数据)，验证数据将在训练模型时定义。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nd"><img src="../Images/a81e6e3e15cea9ff2954ac0c2d99b7dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZLm-Tgi7pvScKTVABVdew.jpeg"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">测试列车分离</figcaption></figure><p id="4206" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们使用sklearn.model_selection中的函数train_test_split将X和y拆分为X，y(75%)和X_test，y_test(25%)</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ne"><img src="../Images/31438c8138537d5ca387963850827b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*q2pZUMtVTe5csmKpcyRpew.png"/></div></figure><h1 id="3bd4" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">第4部分:模型构建</h1><h2 id="330b" class="lj km hi bd kn lk ll lm kr ln lo lp kv jx lq lr kx kb ls lt kz kf lu lv lb lw bi translated">1.从头开始构建模型</h2><p id="af4e" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">在这一部分，我们将设计模型的架构。</p><p id="62d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的模型是一个长短期记忆递归神经网络。</p><p id="8ba9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">多次运行相同的代码会产生不同的结果。为了确保我们的模型在每次运行时都会生成相同的结果:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nf"><img src="../Images/34927d15f2111cef80881cd0272d41d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*Defj1v39xaIvfz8Bk3TMIw.png"/></div></figure><p id="481a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们首先定义一个顺序模型:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ng"><img src="../Images/0f06903816df703db93880f38fe126d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*0DXY4IG8EuVQQmq-ufe49g.png"/></div></figure><p id="dada" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们添加一个LSTM层作为输入层。我们确定该层中节点的数量，由于这是第一层，我们定义输入X的形状，以告知网络它将训练的数据的形状。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nh"><img src="../Images/8177763618fdf888108fbfc336554e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*IzD3UKnhHYx_tSL7bZUJgA.png"/></div></figure><p id="5828" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们添加三个LSTM层作为隐藏层，每层有256个节点。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mt"><img src="../Images/900a34055cd99cec2816beb6e82e03c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*r4LdgmQl4JHpNBYkVwOImw.png"/></div></figure><p id="c9db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们展平来自最后一个隐藏层的数据，将其输入到输出层:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ni"><img src="../Images/e97ef08458f122b5396691a862267b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*fStn0Ul7eoaXU3-Vsb0p8A.png"/></div></figure><p id="2822" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们添加了一个密集层，这是一个完全连接的神经网络层，其中每个输入节点都连接到每个输出节点。</p><p id="9b49" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们还添加了一个激活层，它决定了我们的神经网络用来计算节点输出的激活函数。由于这是一个多分类问题，我们使用softmax函数。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nj"><img src="../Images/6a813b711676e9930808fe0bf42363dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*kC6IEzqeUgOA-LfSfCohaw.png"/></div></figure><p id="f996" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们编译我们的模型。由于这是一个多分类问题，我们使用分类交叉熵计算每次迭代训练的损失，并使用“adam”优化器优化我们的网络。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nk"><img src="../Images/393acc8eb461a40bfc0e86953d2f4da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oF9klDScHvgrhn3vxigu0A.png"/></div></div></figure><p id="b36b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以使用以下内容查看我们模型的摘要:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nl"><img src="../Images/b85f8c6985fc51ae7545c044c89d5d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*ru7dv1hxkkWKeQEiezRNUw.png"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nm"><img src="../Images/a46f09cbb66c7272badae020452c2c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*i9RwGMG1SzVOM6y3nsP8TA.png"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nn"><img src="../Images/78fe5aaff29ae4fbf473897b10b81ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*0mHTVZx8DriRX8CeUQDy6g.png"/></div></figure><p id="d68d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了避免丢失我们的工作，我们使用模型检查点，以便在每个历元之后将网络节点的权重保存到文件中。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es no"><img src="../Images/920618e3146a123855f8334c5cbeda44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmmayUExDI1eejO6tD01NQ.png"/></div></div></figure><h2 id="860e" class="lj km hi bd kn lk ll lm kr ln lo lp kv jx lq lr kx kb ls lt kz kf lu lv lb lw bi translated">2.训练模型</h2><p id="efa4" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">既然我们已经定义了模型的结构，它应该自我训练，以便用于预测新数据的输出。</p><p id="f079" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了训练模型，我们使用拟合方法。</p><p id="a5ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们表示:</p><ul class=""><li id="f9ac" class="me mf hi jq b jr js ju jv jx mg kb mh kf mi kj mj mk ml mm bi translated"><strong class="jq hj"> X </strong>:输入数据</li><li id="0799" class="me mf hi jq b jr mn ju mo jx mp kb mq kf mr kj mj mk ml mm bi translated"><strong class="jq hj"> y </strong>:目标数据</li><li id="0b50" class="me mf hi jq b jr mn ju mo jx mp kb mq kf mr kj mj mk ml mm bi translated"><strong class="jq hj">时期</strong>:提供的整个X和y数据的迭代次数。</li><li id="a687" class="me mf hi jq b jr mn ju mo jx mp kb mq kf mr kj mj mk ml mm bi translated"><strong class="jq hj"> batch_size </strong>:每次梯度更新的样本数。</li><li id="0121" class="me mf hi jq b jr mn ju mo jx mp kb mq kf mr kj mj mk ml mm bi translated"><strong class="jq hj">回调</strong>:培训和验证期间应用的回调列表。</li><li id="7cc5" class="me mf hi jq b jr mn ju mo jx mp kb mq kf mr kj mj mk ml mm bi translated"><strong class="jq hj">啰嗦</strong>:整数。0、1或2。详细模式。0 =无声，1 =进度条，2 =每个时期一行。</li><li id="61c5" class="me mf hi jq b jr mn ju mo jx mp kb mq kf mr kj mj mk ml mm bi translated"><strong class="jq hj"> validation_split </strong>:作为验证数据的训练数据的一部分。该模型将把这部分训练数据分开，不在其上训练，并且将在每个时期结束时评估该数据的损失和任何模型度量。我们选择使用2%的训练数据来验证模型。</li><li id="2bbc" class="me mf hi jq b jr mn ju mo jx mp kb mq kf mr kj mj mk ml mm bi translated"><strong class="jq hj">混洗</strong>:决定是否在每个历元之前混洗训练数据。</li><li id="b3db" class="me mf hi jq b jr mn ju mo jx mp kb mq kf mr kj mj mk ml mm bi translated"><strong class="jq hj"> initial_epoch </strong>:开始训练的时期(用于恢复之前的训练运行)。</li></ul><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es np"><img src="../Images/1106c1bf38b1a6adb92cd7ccff5c1ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qdldma5IFcUYBMYUeYyjMQ.png"/></div></div></figure><p id="d139" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于数据集非常大，这一步需要花费大量时间。我花了大约65分钟运行一个纪元。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nq"><img src="../Images/e882a7b15bac342e5fd951cc9667f9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9Jm9qJa8AwmYcT1rgEaew.png"/></div></div></figure><p id="6ae4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于使用了检查点，您可以看到一些文件已经下载。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nr"><img src="../Images/ac15a3d5ed202c7967a1d0c46b81b609.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*CZEe5MMxBFzO_kK6srcuOw.jpeg"/></div></figure><h1 id="17fe" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">第5部分:验证和模型准确性</h1><h2 id="c4db" class="lj km hi bd kn lk ll lm kr ln lo lp kv jx lq lr kx kb ls lt kz kf lu lv lb lw bi translated">1.确认</h2><p id="1c7c" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">我们可以通过显示训练数据的准确性、验证数据的准确性、训练数据的损失和验证数据的损失来验证我们的模型。</p><p id="9da7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以观察到损耗在减少，精度在提高。这证明该模型正在有效地学习，并且通过更多的时期来训练网络将使我们能够达到令人满意的准确度。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ns"><img src="../Images/ae41579e175271ae488d050cd7c8cd51.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*YI6RFROqomOoGY3F3OZHnA.png"/></div></figure><p id="731b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以通过绘制我们训练的历史来形象地描述这一点。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nt"><img src="../Images/3cb62be15646f73cb7aa9f4547d781e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*y7V3yPOQ4p-UsQ8u3pdA7A.png"/></div></figure><h2 id="526b" class="lj km hi bd kn lk ll lm kr ln lo lp kv jx lq lr kx kb ls lt kz kf lu lv lb lw bi translated">2.模型精度</h2><p id="5c9e" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">检查模型的性能是模型测试中最重要的步骤之一。这将使我们能够看到模型对从未见过的数据将如何表现，以及它的预测是否准确。</p><p id="b128" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以用evaluate方法来衡量这个值:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nu"><img src="../Images/f1b825b030171b4fd57b2b3b5721f538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*zBukXIeR6TycHssghAAVYA.png"/></div></figure><p id="0997" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们获得了2.16的损失和0.41的准确度。这些值可以通过调整模型的超参数来改善，也可以针对更多的时期对其进行训练。你训练你的模型越多，你的结果就越准确！</p><h1 id="9c45" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">第6节:预测和结果</h1><h2 id="dc02" class="lj km hi bd kn lk ll lm kr ln lo lp kv jx lq lr kx kb ls lt kz kf lu lv lb lw bi translated">1.预言；预测；预告</h2><p id="fb3e" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">现在我们的模型已经建立、训练、验证和测试，我们终于可以用它来预测新数据的输出并生成一些假歌词。</p><p id="8df2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于我们有一个完整的歌词序列列表，我们将在列表中随机选取一个索引作为我们的起点，并预测该序列之后的500个字符。</p><p id="3ece" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">步骤1 </strong>:我们重塑序列x</p><p id="704b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">第二步</strong>:我们将其归一化</p><p id="3d0b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">步骤3 </strong>:我们计算每个类遵循这个序列的概率</p><p id="7891" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">第四步</strong>:检测概率最高的指标</p><p id="f45b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">步骤5 </strong>:我们确定概率最高的类</p><p id="90ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第六步:我们将这个字符(预测的结果)添加到序列中</p><p id="f8ff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">步骤7 </strong>:我们去掉序列的第一个字符，得到一个新的序列，重复同样的过程，直到预测到500个字符。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nv"><img src="../Images/a1d9096c6fea7e1b17ed07fdbb9f0b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*Yr5Clid3CCHjMHL4lwrQmA.png"/></div></figure><h2 id="82c3" class="lj km hi bd kn lk ll lm kr ln lo lp kv jx lq lr kx kb ls lt kz kf lu lv lb lw bi translated">2.结果</h2><p id="2ba9" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">然后我们看到我们的500个字符正在生成..</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nw"><img src="../Images/e1067290da3efe54020f0a09ff70b63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SOeBSLPy3vVtBYYijF0xYg.png"/></div></div></figure><p id="49a4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以看到，该模型生成了一些假的歌词，并有许多拼写错误。</p><p id="99fa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们想生成更好的歌词，我们需要调整一些参数。</p><p id="7e31" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一粒种子来自我们，这是泰勒·斯威夫特在2010年制作的专辑《现在说话》中的一首歌，让我们来比较一下我们的假歌词和真歌词:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nw"><img src="../Images/e1067290da3efe54020f0a09ff70b63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SOeBSLPy3vVtBYYijF0xYg.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">人工生成的歌词</figcaption></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nx"><img src="../Images/1a44f859125865dd3be2f913f15ebc73.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*KpbKTHpm5BBj0pkRzCAwKA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">原创歌词</figcaption></figure><p id="3985" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这两种歌词之间的差异是巨大的，因为模型需要越来越多的训练，以便生成更准确的歌词。由于数据集非常庞大，尽管使用了具有非常高计算能力的高级云服务，但我花了65分钟运行一个时期，这使得很难达到令人满意的精度。尽管如此，该模型永远不会为泰勒·斯威夫特生成更好的歌词，训练它将使我们能够生成合理的单词，但永远不会生成更好的歌词。<strong class="jq hj">人工智能永远打不过自然智能。</strong></p><p id="359c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个项目中进行的工作可以进行相当多的扩展。可以采取的三种主要发展途径是:</p><p id="cbd6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="ly"> 1。</em> <em class="ly">改善网络的架构(层数，每层神经元数…) </em></p><p id="e953" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="ly"> 2。</em> <em class="ly">改进和扩展历元数因为模型自己训练的越多，它的预测就越准确。</em></p><p id="1c6d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="ly"> 3。</em> <em class="ly">使用textgenrnn，这是一个python包，它将创建和训练LSTM-RNN的过程抽象为几行代码，具有大量的模型架构和训练改进..</em></p><h1 id="90e9" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">一些最后的想法</h1><p id="d98a" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">从事这个项目使我能够体验到当我建立、训练和评估自己的神经网络开始生成歌词时的兴奋，就像人类学会了一种技能并开始用它来解决生活问题。虽然结果可能并不完美，但它们是我未来可能从事的许多新想法和潜在应用的真正来源</p><p id="1cf3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="ly">查看我为教程制作的Github资源库</em> <a class="ae ix" href="https://github.com/mellouksafae/Taylor_Swift_Lyrics_Generator" rel="noopener ugc nofollow" target="_blank"> <em class="ly">这里</em> </a> <em class="ly">！</em></p></div></div>    
</body>
</html>