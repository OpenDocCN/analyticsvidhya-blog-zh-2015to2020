<html>
<head>
<title>Are you susceptible to a heart attack? A Machine Learning approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你容易患心脏病吗？机器学习方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/are-you-susceptible-to-a-heart-attack-a-machine-learning-approach-f4ed34e811fe?source=collection_archive---------20-----------------------#2020-12-18">https://medium.com/analytics-vidhya/are-you-susceptible-to-a-heart-attack-a-machine-learning-approach-f4ed34e811fe?source=collection_archive---------20-----------------------#2020-12-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/62d957457889d8b81c44aecf6a704034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LWhOkfKOKVlaITAP"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">塔曼娜·茹米在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="1a4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在 Datern 的数据科学课程中提出的研讨会中，有一个给我留下了特别深刻的印象。<br/>顾名思义，这项任务是根据病人的生理状况来判断他是否患有心脏病。在本文的其余部分，我将介绍我的发现以及我实现这些发现的方法。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="51e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所使用的数据集包含<strong class="ix hj"> 303 名患者</strong>，共有 14 个变量:<br/> <strong class="ix hj">年龄</strong>，<br/> <strong class="ix hj">性别</strong>，<br/> <strong class="ix hj"> cp </strong> <em class="ka">(胸痛型)</em>，<br/><strong class="ix hj">trest bps<em class="ka"/></strong><em class="ka">(静息血压)</em>，<br/> <strong class="ix hj">胆固醇</strong> <em class="ka">(胆固醇)【T30 <br/><strong class="ix hj">【thal ach】</strong><em class="ka">(达到最大心率)</em><br/><strong class="ix hj">exang</strong><em class="ka">(运动诱发心绞痛)</em><br/><strong class="ix hj">old peak</strong><em class="ka">(运动相对于休息诱发的 st 段压低)<br/></em><strong class="ix hj">slope</strong><em class="ka">(</em>运动 ST 段峰值的斜率<em class="ka">)，<br/></em></em></p><p id="75d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们进一步研究这些数据</p><p id="64d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该计数图显示了数据集中男性与女性的比例:</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/15ad7aaadce7c383d8cc1b08a6c80a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kjoRQg7-rBFyg-2BT7R4CQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">0 表示女性，1 表示男性</figcaption></figure><p id="f37b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到女性是 98 岁，男性是 205 岁。这可能导致在男性患者中预测疾病诊断的更强准确性。</p><p id="78db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这张小提琴图看的是男性和女性的年龄分布:</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/1d83dbc42f76c5e4e6f36332dbc5f441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SVRBVg9QYYWLkigbEJYlrg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">0 表示女性，1 表示男性</figcaption></figure><p id="e0f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它表明，女性在年龄上比男性更相似，而且她们往往更老。</p><p id="6550" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该相关矩阵分析变量之间的相关性:</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/e3107ab78db1ebca6f7e8d65061f14f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VAbpXCOOw50bd4Gm_YLWg.png"/></div></div></figure><p id="9c6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到，与目标最相关的特征似乎是“exang”<em class="ka">(运动诱发的心绞痛)。</em>此外，我们观察到特征之间没有多重共线的迹象。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="b1f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在着手构建 K 最近邻模型来预测“目标”，即患者是否患有心脏病(1)或(0)。</p><p id="dccd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在将每个观察值放置在 N 维平面中之后，其中 N 是所考虑的特征的数量，KNN 通过考虑其 K 个最近邻来确定未知数据的类别。他们每个人都有一张“选票”，投给自己所属的阶层。在投票结束时拥有更多票数的类将是未知观察的类。</p><p id="d255" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下面的代码中，我们创建了特征矩阵 X 和目标向量 y。然后，我们缩放数据。这对 knn 来说至关重要，因为它依赖于距离的概念。我们用 sk learn . preprocessing . standard scaler .<br/>实现这一点，然后我们把数据分成两部分:训练和测试(20%的数据)。这是为了避免过度拟合。</p><pre class="kc kd ke kf fd ki kj kk kl aw km bi"><span id="9390" class="kn ko hi kj b fi kp kq l kr ks"># Create feature and target arrays<br/>y = df["target"].values<br/>X = df.drop(["target"], axis = 1)</span><span id="6b46" class="kn ko hi kj b fi kt kq l kr ks">#Scaling - crucial for knn<br/>from sklearn.preprocessing import StandardScaler<br/>ss = StandardScaler()<br/>X = ss.fit_transform(X)</span><span id="6ed8" class="kn ko hi kj b fi kt kq l kr ks">from sklearn.model_selection import train_test_split</span><span id="8348" class="kn ko hi kj b fi kt kq l kr ks"># Split into training and test set<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state=42, stratify=y)</span></pre><p id="b617" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下面的代码中，我们创建了一个 k=3 的 knn 对象。我们用<em class="ka">训练它。用<em class="ka">配合</em>方法并产生结果。预测</em>法。在所有这些之后，精度将被打印出来。</p><pre class="kc kd ke kf fd ki kj kk kl aw km bi"><span id="9f5f" class="kn ko hi kj b fi kp kq l kr ks">from sklearn.neighbors import KNeighborsClassifier</span><span id="5f3b" class="kn ko hi kj b fi kt kq l kr ks"># Create a k-NN classifier with 3 neighbors<br/>knn1 = KNeighborsClassifier(n_neighbors = 3)</span><span id="6b07" class="kn ko hi kj b fi kt kq l kr ks"># Fit the classifier to the training data<br/>knn1.fit(X_train,y_train)</span><span id="38b4" class="kn ko hi kj b fi kt kq l kr ks"># Print the accuracy<br/>print(knn1.score(X_test, y_test))</span></pre><p id="f534" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们得到了 79%的准确率。让我们尝试 k 的一些其他值，并尝试提高这个精度。这是下一个代码片段的任务。</p><pre class="kc kd ke kf fd ki kj kk kl aw km bi"><span id="9b0a" class="kn ko hi kj b fi kp kq l kr ks"># Setup arrays to store train and test accuracies<br/>neighbors = np.arange(1, 16)<br/>train_accuracy = np.empty(len(neighbors))<br/>test_accuracy = np.empty(len(neighbors))</span><span id="ca6b" class="kn ko hi kj b fi kt kq l kr ks"># Loop over different values of k<br/>for i, k in enumerate(neighbors):<br/>    # Setup a k-NN Classifier with k neighbors: knn<br/>    knn = KNeighborsClassifier(n_neighbors = k)</span><span id="1afe" class="kn ko hi kj b fi kt kq l kr ks">    # Fit the classifier to the training data<br/>    knn.fit(X_train,y_train)<br/>    <br/>    #Compute accuracy on the training set<br/>    train_accuracy[i] = knn.score(X_train, y_train)</span><span id="4387" class="kn ko hi kj b fi kt kq l kr ks">    #Compute accuracy on the testing set<br/>    test_accuracy[i] = knn.score(X_test, y_test)</span></pre><p id="2f66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们画出每个 k 的精度</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/43bcfe48300f0dca3dc13e19e8d55ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJM_ZE3EcXeB4pYtP_YWmA.png"/></div></div></figure><p id="70c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们看到，当 k = 12 时，精度最高，但这可能会导致过拟合，因此我们还应该考虑其他指标，以确定应该使用什么样的 k 值。<br/>为此，我们来绘制一个 ROC(接收机工作特性)曲线。这是 TPR (y 轴)和 FPR (x 轴)之间的曲线。由于我们的模型基于为每一类生成的概率将患者分类为患有心脏病或不患有心脏病，因此我们也可以决定概率的阈值。让我们用<code class="du kv kw kx kj b">k = 3</code>为我们的模型生成一条 ROC 曲线。</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/c2dd00db22524451e4590926799cced9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdndaWwj4cTAD2oON6JN7w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">每个顶点上面的小数字是考虑的阈值。</figcaption></figure><p id="a0d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以曲线和轴为边界的面积称为曲线下面积(AUC)。正是这个领域被认为是一个好模式的标志。这个指标的范围从 0 到 1，我们应该以较高的 AUC 值为目标。具有高 AUC 的模型被称为具有良好技能的模型。</p><p id="23e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该模型的 AUC 为 85%。这意味着它将能够在 85%的时间里区分心脏病患者和非心脏病患者。</p><p id="e952" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个诊断工具是 PRC(精确召回曲线)。同样，它向我们展示了不同阈值的精确度和召回率，我们的目标应该是最大化曲线下的面积。</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/d8840d1006717332e2ab7e1ba4fbe5b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mYJgEH2m_EgOimWtA6Usw.png"/></div></div></figure><p id="3087" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于该模型，中国的 AUC 为 88%</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="0892" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在能够在 85%的情况下正确预测新患者是否患有心脏病。这对医生来说无疑是一个有用的诊断工具。</p><p id="4333" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还应该记住，模型会因过度拟合而有偏差，因此真正的准确性可能与我们获得的值不同，而且它还取决于模型接受训练的数据部分。</p><p id="0d6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这只是项目的开始。下一步将包括尝试不同的训练/测试分割比、不同种类的距离、不同的特征组合等…</p><p id="ed99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谢谢你的时间。</p></div></div>    
</body>
</html>