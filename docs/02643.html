<html>
<head>
<title>0-Based Indexing: A Julia How-To</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于0的索引:Julia指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/0-based-indexing-a-julia-how-to-43578c780c37?source=collection_archive---------4-----------------------#2019-12-27">https://medium.com/analytics-vidhya/0-based-indexing-a-julia-how-to-43578c780c37?source=collection_archive---------4-----------------------#2019-12-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ec0aa274f40556ce4f6e715d721a72e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tcTZq5lDwuYzOHCN"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">丹尼·米勒在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="ff5c" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">介绍</h1><p id="e0a3" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">与大多数语言不同，Julia是从1开始的，而不是从0开始的。这意味着数组从索引1开始。这导致了明显不同的算法和循环设计。要了解每个系统的优点和一些用例，请参考本文档:<a class="ae iu" href="https://docs.google.com/document/d/11ZKaR0a6hvc6xmYLfmslAAPnkVRSZFGz5GZYRNmxmsQ/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank">数组索引:0 vs 1 </a>。</p><p id="3907" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在本文中，我们将探索一种方法来改变Julia中数组的索引，以满足我们的需要。我们将使用OffsetArrays.jl包来做同样的事情。它的GitHub repo可以在<a class="ae iu" href="https://github.com/JuliaArrays/OffsetArrays.jl" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="56de" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">使用Julia内置的示例，我们将逐步完成在Julia中创建自定义索引数组的过程。</p><h1 id="ec50" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">安装软件包</h1><p id="6731" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在您的REPL中，(通过在命令行上键入<code class="du kw kx ky kz b">julia</code>来访问，并且只有当Julia在您的路径上时才起作用)键入:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="f76e" class="li iw hi kz b fi lj lk l ll lm"><em class="ln">import</em> Pkg</span></pre><p id="8627" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">然后，您可以使用以下命令安装<code class="du kw kx ky kz b">OffsetArrays</code>包:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="3ee7" class="li iw hi kz b fi lj lk l ll lm">Pkg.add(“OffsetArrays”)</span></pre><h1 id="a856" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">导入包</h1><p id="79d4" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">要导入包，只需输入</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="9a00" class="li iw hi kz b fi lj lk l ll lm"><em class="ln">using</em> OffsetArrays</span></pre><p id="269f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个包现在已经导入，可以使用了。</p><h1 id="d3fe" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">基本用法</h1><p id="1cb7" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">要在导入包后创建自定义索引数组，请键入:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="4ee2" class="li iw hi kz b fi lj lk l ll lm">array_name = OffsetVector([element1, element2, element3, element3], start_index:end_index)</span></pre><p id="6791" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">其中element1，2，3等是数组的元素，<code class="du kw kx ky kz b">start_index</code>是数组第一个元素的索引，<code class="du kw kx ky kz b">end_index </code>是最后一个元素的索引。</p><p id="f26a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们甚至可以使用这个包创建多维数组，它有这样的自定义索引:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="621c" class="li iw hi kz b fi lj lk l ll lm">array_name = OffsetArray{Float64}(undef, -1:1, -7:7)</span></pre><p id="3202" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这创建了一个2D数组，它有3行(索引分别为-1、0和1)，15列(索引为-7、-6、-5等等，直到7)，包含所有的<code class="du kw kx ky kz b">#undef</code>对象。</p><h1 id="d682" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">示例:循环列表</h1><p id="16fa" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">让我们实现一个循环链表，而不像循环链表那样使用任何指针。我们将不会创建一个对象，我们将只写一个循环访问一个基于0的数组的函数。</p><p id="ecdd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">代码有注释并解释了我们的算法:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="fc92" class="li iw hi kz b fi lj lk l ll lm"><em class="ln">using</em> OffsetArrays</span><span id="fe47" class="li iw hi kz b fi lo lk l ll lm"><em class="ln"># Create a 0-indexed array<br/></em>a = OffsetVector([‘a’, ‘b’, ‘c’, ‘d’], 0:3)</span><span id="8395" class="li iw hi kz b fi lo lk l ll lm"><em class="ln"># 1-based array to compare with and show that it does not work<br/></em>b = [‘a’, ‘b’, ‘c’, ‘d’]</span><span id="4cd6" class="li iw hi kz b fi lo lk l ll lm"><em class="ln"># Create a function that takes in an array, and cycles through it cycle_count times<br/></em>function print_circular(array, cycle_count)</span><span id="cd9a" class="li iw hi kz b fi lo lk l ll lm"><em class="ln"># Loop through values of j ranging from 0 to size_of_array*cycle_count-1. This makes j complete the correct number of cycles</em></span><span id="93fa" class="li iw hi kz b fi lo lk l ll lm"><em class="ln"># NOTE: it says size(array)[1] because the size function returns a tuple with the 2D dimensions of the array.</em></span><span id="2ba5" class="li iw hi kz b fi lo lk l ll lm"><em class="ln"># Since we are working with a 1D vector, we are only interested in its x-dimension. This happens to be the 1st element. The tuple returned is 1-based since the core functions of Julia still use 1-based indexing. We have only created a custom array. We have not changed the behaviour of Julia.</em></span><span id="7b93" class="li iw hi kz b fi lo lk l ll lm"><em class="ln">    for</em> j in 0:(size(array)[1]*cycle_count)-1</span><span id="b0fd" class="li iw hi kz b fi lo lk l ll lm"><em class="ln">    # Print the element at the j%size th position. This is what gives us the cyclic behaviour. As j increases to any number, the element accessed is the j%size th element. So, j snaps back to 0 when j becomes a multiple of the size. This means that at the end of a cycle, the 0th element is accessed. This is the reason 0-based indexing is necessary.</em></span><span id="641b" class="li iw hi kz b fi lo lk l ll lm">    print(array[j%size(array)[1]])</span><span id="57e6" class="li iw hi kz b fi lo lk l ll lm"><em class="ln">    # If we are at the last step of a cycle, print a space character. This is only to make the output easier to see, and the cycles easy to count. This does not affect the circular list in any way.<br/>        if</em> j%size(array)[1] == (size(array)[1]-1)<br/>            print(“ ”)<br/><em class="ln">        end<br/>    end<br/>end</em></span><span id="d653" class="li iw hi kz b fi lo lk l ll lm"><em class="ln"># Test the function on our custom 0-based array and also on our 1-based array for comparison</em></span><span id="b813" class="li iw hi kz b fi lo lk l ll lm">print_circular(a, 5)<br/>println(“\n”)<br/>print_circular(b, 5)</span><span id="e324" class="li iw hi kz b fi lo lk l ll lm"><em class="ln"># OUTPUT:<br/># The 0-based array works fine, while the 1-based array throws an error.</em></span></pre><h1 id="3ddd" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">最后一点</h1><p id="7781" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">同样，正如代码中提到的，我们没有改变Julia的行为。我们仍然可以用正常的方式创建数组，它们将从索引1开始。当一个函数返回一个元组或数组时，它的索引仍然从1开始。我们只创建了一个自定义对象，它的工作方式完全像一个数组，并且有自定义索引，而不是传统的基于1的索引。</p></div></div>    
</body>
</html>