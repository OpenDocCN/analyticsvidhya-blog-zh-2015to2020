<html>
<head>
<title>Wandering in the Python itertools Module — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python itertools模块中漫游—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/wandering-in-the-python-itertools-module-part-i-278b449d0f29?source=collection_archive---------27-----------------------#2020-10-17">https://medium.com/analytics-vidhya/wandering-in-the-python-itertools-module-part-i-278b449d0f29?source=collection_archive---------27-----------------------#2020-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cde0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">迭代是编程中的关键概念之一。最直接的方法显然是使用for或while循环；然而，当可迭代变量变大时，我们需要更有效的方法。好消息是Python的标准库中已经有了它，在名为<code class="du jd je jf jg b">itertools</code>的模块中。</p><p id="ce00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">itertools</code>是一个很棒的模块，它包含一组内存优化的迭代器构建块(你可以在<a class="ae jh" href="https://docs.python.org/3.8/library/itertools.html" rel="noopener ugc nofollow" target="_blank"> Python itertools文档</a>中了解更多)。该模块包含许多有用的函数，您可能已经尝试在代码中的某个地方实现了这些函数；例如，这个名为<code class="du jd je jf jg b">product</code>的函数相当于一个嵌套的for循环。我们将在这个由三部分组成的系列文章中讨论这个问题。</p><p id="b270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我决定写一个由三部分组成的系列有两个原因:<br/> - <code class="du jd je jf jg b">itertools</code>模块有三种类型的迭代器，因此每篇文章将涵盖其中一种。我希望每篇文章都易于阅读，而不是让读者不知所措。</p><p id="4c58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我想解释一下(因为你可能已经在问了，已经有相关的文档了，为什么我们需要一篇文章)为什么我决定写这篇文章。我编码已经快四年了，开始时阅读Python的文档是非常困难的(至少对我来说)。现在我更加精通编码，我认为它写得非常好。因此，在这篇文章中，我的目标是让那些在当前编码水平下觉得太复杂的人更容易过渡到Python文档(不管怎样，这是我的第一篇博客文章)。但我也想强调，理解和参考文档是最重要的技能之一，所以我强烈建议新程序员花时间阅读Python的文档。</p><h1 id="fa81" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">先决条件</h1><p id="c7ff" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">我使用了Python 3.8文档，所以唯一的先决条件是拥有Python 3.8和Python的基础知识。</p><p id="c0c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还使用了<a class="ae jh" href="https://colab.research.google.com" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>，在我看来这是一个很棒的工具，但是欢迎你使用任何你喜欢的平台，因为我们只需要Python标准库中的一个模块。</p><h1 id="34de" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">导入itertools</h1><p id="6330" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">我们要做的第一件事是从Python标准库中导入itertools模块，如下所示:</p><pre class="kl km kn ko fd kp jg kq kr aw ks bi"><span id="f35e" class="kt jj hi jg b fi ku kv l kw kx">import itertools as it</span></pre><p id="c33d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这种方式，我们可以通过简单的<code class="du jd je jf jg b">it.&lt;function_name&gt;</code>来访问itertools函数。</p><p id="8551" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经解决了这个问题，让我们开始吧！</p><h1 id="8694" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">Itertools —无限迭代器</h1><p id="0150" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">我们将介绍的itertools模块的第一部分叫做<em class="ky">无限迭代器</em>，它有三个功能:</p><h1 id="3b55" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">数数</h1><p id="accb" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">count函数有两个参数:</p><pre class="kl km kn ko fd kp jg kq kr aw ks bi"><span id="cf0d" class="kt jj hi jg b fi ku kv l kw kx">it.count(start=0, step=1)</span></pre><p id="8892" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它基本上是一个无限迭代器，通过增加<em class="ky">步骤</em>的值(默认为1)，从<em class="ky">开始</em>的值(默认为0)开始创建均匀间隔的数字。</p><p id="46b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>我只想声明，使用count时要格外小心，因为你很容易陷入无限循环。</p><p id="46b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将看到的一些例子包括我们可能还没有涉及到的函数，但是释放<code class="du jd je jf jg b">itertools</code>威力的最好方式是当你一起使用它们来生成更复杂的迭代器时。因此，让我们来看一些如何使用<em class="ky">计数</em>的例子:</p><h2 id="638d" class="kt jj hi bd jk kz la lb jo lc ld le js iq lf lg jw iu lh li ka iy lj lk ke ll bi translated">生成数字序列</h2><p id="f748" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated"><code class="du jd je jf jg b">count</code>最基本的功能是生成数字，从Python 3.1开始，<code class="du jd je jf jg b">step</code>参数允许非整数值。</p><p id="e501" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如说；让我们写一个函数，它将在我们想要的范围内产生一个数的倍数<code class="du jd je jf jg b">n</code>。让我们编写一个不使用itertools的函数和一个使用itertools的函数，然后比较两个函数的运行时:</p><pre class="kl km kn ko fd kp jg kq kr aw ks bi"><span id="6aa8" class="kt jj hi jg b fi ku kv l kw kx"># without using itertools<br/># desired_range is a list [start, stop]<br/>def generate_without_itertools(n, desired_range): <br/>    return [i <br/>            for i in range(desired_range[0], desired_range[1]) <br/>            if i % n == 0] </span><span id="a627" class="kt jj hi jg b fi lm kv l kw kx"># with using itertools <br/>def generate_with_itertools(n, stop): <br/>    return it.takewhile(lambda x: x &lt;= stop, it.count(step=n))</span></pre><p id="bd9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们比较一下两个函数在[0，100000]之间生成8的倍数需要多长时间:</p><pre class="kl km kn ko fd kp jg kq kr aw ks bi"><span id="31df" class="kt jj hi jg b fi ku kv l kw kx">&gt;&gt; %%timeit <br/>   generate_without_itertools(8, [0,100000]) </span><span id="7686" class="kt jj hi jg b fi lm kv l kw kx">100 loops, best of 3: 6.54 ms per loop <br/></span><span id="6ae0" class="kt jj hi jg b fi lm kv l kw kx">&gt;&gt; %%timeit <br/>   list(generate_with_itertools(8, 100000)) </span><span id="4bb7" class="kt jj hi jg b fi lm kv l kw kx">1000 loops, best of 3: 1.55 ms per loop</span></pre><p id="aebe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数使用<code class="du jd je jf jg b">itertools</code>是x4倍快，这是一个很大的差异，在我看来，加上<code class="du jd je jf jg b">itertools</code>有优势。注意<code class="du jd je jf jg b">generate_with_itertools</code>函数被转换为<code class="du jd je jf jg b">list</code>。这是因为当我运行<code class="du jd je jf jg b">generate_with_itertools</code>时，它不会立即返回任何东西，这被称为<a class="ae jh" href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="noopener ugc nofollow" target="_blank">惰性求值</a>。当我要的时候，它会给我下一个号码。这种方法可以大大减少函数的运行时间，并且消耗更少的内存。</p><h2 id="e90b" class="kt jj hi bd jk kz la lb jo lc ld le js iq lf lg jw iu lh li ka iy lj lk ke ll bi translated">模拟枚举</h2><p id="1f9e" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">假设您有一个字符串<code class="du jd je jf jg b">s='python'</code>，那么您可以使用<em class="ky"> count </em>来模拟枚举的行为，如下所示:</p><pre class="kl km kn ko fd kp jg kq kr aw ks bi"><span id="e7f4" class="kt jj hi jg b fi ku kv l kw kx">&gt;&gt; s = "python" <br/>&gt;&gt; list(zip(it.count(), s)) </span><span id="7a14" class="kt jj hi jg b fi lm kv l kw kx">[(0, 'p'), (1, 'y'), (2, 't'), (3, 'h'), (4, 'o'), (5, 'n')]</span></pre><p id="2d81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个例子的好处是，在不知道输入字符串长度的情况下，我们枚举了它。</p><p id="8e01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个简单的例子，也可以通过<code class="du jd je jf jg b">list(enumerate(s))</code>来实现，但是根据我的经验，知道不同的做事方法是很好的，因为你永远不知道什么时候它会派上用场。</p><h1 id="a438" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">循环</h1><p id="a3e2" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated"><code class="du jd je jf jg b">cycle</code>函数将任何iterable作为参数，并无限重复内容。下面是几个例子:</p><pre class="kl km kn ko fd kp jg kq kr aw ks bi"><span id="f02e" class="kt jj hi jg b fi ku kv l kw kx">&gt;&gt; s = "python is great" <br/>&gt;&gt; c = it.cycle(s) </span><span id="27c3" class="kt jj hi jg b fi lm kv l kw kx"># this will print the letters one by one indefinitely<br/>&gt;&gt; [print(letter) for letter in c]</span></pre><p id="5096" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我把<code class="du jd je jf jg b">s</code>放在一个列表中，比如<code class="du jd je jf jg b">["python is great"]</code>，它将循环列表中的元素:</p><pre class="kl km kn ko fd kp jg kq kr aw ks bi"><span id="83be" class="kt jj hi jg b fi ku kv l kw kx">&gt;&gt; s = ["python is great"] <br/>&gt;&gt; c = cycle(s) <br/>&gt;&gt; i = 0 <br/>   while i &lt; 5: # cycle it 5 times<br/>      # next(c) asks for the next element from the cycle object <br/>      print(next(c)) <br/>      i += 1 </span><span id="9b00" class="kt jj hi jg b fi lm kv l kw kx">python is great <br/>python is great <br/>python is great <br/>python is great <br/>python is great</span></pre><p id="79c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在玩循环函数的时候，我发现了一个有趣的事情，如果你把一个字典作为一个iterable传入，它会循环这些键:</p><pre class="kl km kn ko fd kp jg kq kr aw ks bi"><span id="f7ec" class="kt jj hi jg b fi ku kv l kw kx">&gt;&gt; d = {"dog": 5, "cat": 3} <br/>&gt;&gt; d_cycle = it.cycle(d) <br/>&gt;&gt; i = 0 <br/>   while i &lt; 5: <br/>       next_key = next(d_cycle) <br/>       print(f"{next_key}: {d[next_key]}") <br/>       i += 1 <br/>dog: 5 <br/>cat: 3 <br/>dog: 5 <br/>cat: 3 <br/>dog: 5</span></pre><h1 id="da19" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">重复</h1><p id="d635" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">顾名思义，这个函数无限重复一个对象，除非你指定可选的<code class="du jd je jf jg b">times</code>参数。但它仍然不会开始重复，直到我们要求它:</p><pre class="kl km kn ko fd kp jg kq kr aw ks bi"><span id="3235" class="kt jj hi jg b fi ku kv l kw kx"># this returns repeat object <br/>&gt;&gt; repeat(10) <br/>repeat(10) </span><span id="db70" class="kt jj hi jg b fi lm kv l kw kx"># this will actually call the numbers from repeat and exhaust the generator <br/>&gt;&gt; [i for i in repeat(10,3)] </span><span id="6d36" class="kt jj hi jg b fi lm kv l kw kx">[10, 10, 10]</span></pre><p id="3eb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们为幂[1，10]找到8的幂:</p><pre class="kl km kn ko fd kp jg kq kr aw ks bi"><span id="eeda" class="kt jj hi jg b fi ku kv l kw kx">&gt;&gt; list(map(pow, range(10), repeat(8))) <br/>[0, 1, 256, 6561, 65536, 390625, 1679616, 5764801, 16777216, 43046721]</span></pre><h1 id="b812" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">结论</h1><p id="6561" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">因此，在本文中，我们介绍了Python标准库中<code class="du jd je jf jg b">itertools</code>模块的无限迭代器，它们是:</p><ul class=""><li id="ab7d" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ls lt lu lv bi translated">数数</li><li id="2faf" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">循环</li><li id="22d4" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">重复</li></ul><p id="3fc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文中的例子很简单，只是为了演示的目的，然而<code class="du jd je jf jg b">itertools</code>函数在相互结合构建更复杂的迭代器时运行得最好。<code class="du jd je jf jg b">itertools</code> module绝对是一个重要的Python模块，应该学习并保存在您的工具集中。</p><p id="3dd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">附言</strong>这是我的第一篇博文，所以我感谢任何<strong class="ih hj">建设性的</strong>反馈！感谢阅读！</p></div></div>    
</body>
</html>