<html>
<head>
<title>Who-Where-WhomWith(WWWW): A Facial Recognition Tool for Image-based Data Gathering and Graph Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Who-Where-WhomWith(WWWW):一个面部识别工具，用于基于图像的数据收集和图形分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/who-where-whomwith-wwww-a-facial-recognition-tool-for-image-based-data-gathering-and-graph-dd8f2b13c279?source=collection_archive---------4-----------------------#2020-05-13">https://medium.com/analytics-vidhya/who-where-whomwith-wwww-a-facial-recognition-tool-for-image-based-data-gathering-and-graph-dd8f2b13c279?source=collection_archive---------4-----------------------#2020-05-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1442ce904b0fd1446051fc17228c1c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6Zb2uAszv-TLujJWwjhEw.png"/></div></div></figure><p id="fa18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jo" rel="noopener" href="/@lorenzoromani/facial-recognition-with-python-and-elasticsearch-quick-tutorial-85cd02fe903d">这篇</a>上一篇文章中，我展示了建立一个Elasticsearch实例来存储面部编码和建立自己的面部识别数据库是多么容易。</p><p id="d25d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博客中，我将基于相同的架构添加一个非常有趣的特性。因此，如果您不知道如何设置Elasticsearch并存储面部编码以供进一步分析，请返回并设置所有内容！</p><p id="b1dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之前的帖子展示了如何从一张已知的图片开始，在数据库<strong class="is hj">中搜索一个看似合理的匹配。基本上，这被称为<strong class="is hj">监督学习</strong>。从概念上讲，这是最简单的任务。但是，面部识别数据库可以做更多的事情，我相信它在信息分析中会非常有用:我们正在谈论的是<strong class="is hj">面部聚类</strong>。</strong></p><p id="1c23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用人脸聚类，我们不是从输入图像开始在数据库中搜索匹配:我们要求我们的计算机找到独特的人脸(属于同一个人的人脸编码)并对这些人脸做一些事情。这是一个<strong class="is hj">无监督学习</strong>任务。</p><p id="ff34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下，你从社交媒体上收集了数以千计的图片，这些图片与许多不同的人参加的一个或多个公共事件有关。假设您想要调查每位与会者，他/她出现在哪个图像中，同一个人是否出席了多个活动，以及此人与谁一起出席。</p><p id="58fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你需要一个解决方案，分析图片中显示的所有单个面部，将面部聚集在一起，并生成一个关系图<strong class="is hj">unique _ face&gt;image.jpg</strong>。</p><p id="b140" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继续读下去，你马上就能做到这一切！</p><p id="8cdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步是找到一堆有很多人的图像。如果你还没有收藏，你可以使用<strong class="is hj">instalouter</strong>很容易地制作一个，这是一个很棒的工具，可以让你从Instagram下载数据。您可以通过命令行安装它:</p><p id="e540" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> &gt; &gt; pip安装安装程序</strong></p><p id="ab77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在去<a class="ae jo" href="https://github.com/lorenzoromani1983/wwww" rel="noopener ugc nofollow" target="_blank">这个</a> github库下载文件:</p><p id="6421" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">cluster _ faces . py<br/>encode _ faces . py</strong></p><p id="d30b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">/输出<br/>/温度<br/>/数据集</strong></p><p id="c4b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">现在通过pip </strong>安装所有需要的Python库:</p><p id="30b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> pip安装opencv-python <br/> pip安装scikit-learn <br/> pip安装elasticsearch <br/> pip安装numpy <br/> pip安装cmake <br/> pip安装face_recognition <br/> pip安装imutils <br/> pip安装networkx <br/> pip安装shutil <br/> pip安装dlib </strong></p><p id="8bbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您遵循了之前的教程<a class="ae jo" rel="noopener" href="/@lorenzoromani/facial-recognition-with-python-and-elasticsearch-quick-tutorial-85cd02fe903d">您应该已经安装了其中的一些库。</a></p><p id="f529" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，你需要用instalooter下载一些图片。这个工具让你不仅可以从用户的时间线<strong class="is hj">下载图片，还可以从标签</strong>下载图片。我发现从事推广庞氏骗局或类似骗局的用户热衷于分享许多事件的照片，所以我选择了一家知名公司(<strong class="is hj"> Global Intergold </strong>)，该公司使用<strong class="is hj"> #globalintergold </strong>标签进行推广。</p><p id="f58f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从命令行中，下载所有标记为#globalintergold的图片，并将它们保存在您之前应该已经创建的“dataset”目录中。使用此命令:</p><p id="6880" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">&gt;&gt;</strong><strong class="is hj">instalooter标签global integold/path-to-dataset-directory</strong></p><p id="48c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你下载了大量的图片后(我设法为这个标签准备了超过40.000张)，你需要为每张脸编码面部向量，并把它们存储到你的Elasticsearch实例中。使用<strong class="is hj"> encode_faces.py </strong>脚本(代码<a class="ae jo" href="https://github.com/lorenzoromani1983/wwww/blob/master/wwww/encode_faces.py" rel="noopener ugc nofollow" target="_blank">此处为</a>)来执行此操作:</p><p id="0a3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">&gt;&gt;python encode _ faces . py-d路径-数据集-目录</strong></p><p id="4995" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于40，000张图像，可能需要大约10/16个小时来编码你收集的每张脸。</p><p id="aac8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦编码工作完成，你就可以开始了！</p><p id="7a43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，启动<strong class="is hj"> cluster_faces.py </strong>脚本(源代码<a class="ae jo" href="https://github.com/lorenzoromani1983/wwww/blob/master/wwww/cluster_faces.py" rel="noopener ugc nofollow" target="_blank">此处</a>):</p><p id="c113" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">&gt;&gt;python cluster _ faces . py</strong></p><p id="fbb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，程序将开始面部聚类工作。同样，需要一些时间，因为这是一项对你的CPU要求很高的任务。你的电脑将需要40/60分钟来聚集50.000/60.000个面部向量，以便找到独特的面部。<strong class="is hj">这样做时，它会给每个独特的脸分配一个数字ID </strong>。</p><p id="66bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，由于我们正在进行一项无人监督的学习工作，<strong class="is hj">数字id将与唯一的面孔相关联，而不是真实姓名</strong>。但这是我们做进一步图形分析所需要的一切。</p><p id="9634" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该程序将所有的脸聚集在一起并为每个唯一的脸分配一个数字ID后，它将开始编辑你的<strong class="is hj">/数据集</strong>目录<strong class="is hj">中的图像，在每个脸周围画一个方框。在边界框下方，唯一ID也会出现</strong>:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/481c425e72fe311a0bb773e8338ff03c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*8-IRzNcaUfdSUA7tKrQKvQ.jpeg"/></div></figure><p id="8313" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在作业结束时，所有编辑过的图像将被保存在您之前创建的<strong class="is hj">/输出</strong>目录中。</p><p id="caff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在开始对人脸进行聚类之前，最好对原始数据集进行备份！</strong></p><p id="68e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该脚本还将在您的根目录中创建一个名为<strong class="is hj"> face_graph.graphml </strong>的图形文件。这是最重要的输出。您可以使用<strong class="is hj"> Gephi </strong>打开它，以检查和研究独特面孔与显示它们的相应图片之间的所有相关性:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/ea7c6ac086bbfdb9d56d1ba1701d165b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*HIwU-wrixU6dk60btc-hTQ.jpeg"/></div></figure><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jv"><img src="../Images/1b2b86b922a1d08504a18f4baebcabc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fdyid6Es8fj7CktfF75RFw.jpeg"/></div></div></figure><p id="a937" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在# globalintergold的例子中，我能够检测到超过6000个独特的面孔。检查图表，您将能够看到文件名和其中出现的人的唯一id。为了验证图形，您可以在/output目录中打开文件名。</p><p id="59b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意事项</strong></p><p id="12a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有机器学习/面部识别算法是完美的。你肯定也会发现假阳性和假阴性。然而，我发现这种方法非常可靠。我没有测量过错误率，但我相信它小于10-5%。</p><p id="5b33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也许需要强调的是，集群工作的可靠性会受到您输入的数据的质量和数量的影响。每个人可用的图片越多，质量越高越好。但是，当从社交媒体/互联网收集数据时，这是您无法控制的，因此您需要考虑潜在的错误，并验证通过图表检查发现的关系。</p><p id="6101" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，在cluster_faces.py文件中，有几个非常重要的参数可以手动设置:<strong class="is hj"> eps </strong>和<strong class="is hj"> min_samples: </strong></p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jw"><img src="../Images/73653a8067d66b593f08b0de01adc8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*uZIIjzoY5BHNfulHSmpIGg.jpeg"/></div></figure><p id="e472" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> eps </strong>定义了欧氏距离值。该值越高，检测到的人脸就越少，而更多的人脸，甚至是属于多个个人的人脸，将聚集在同一个ID下，从而导致误导性的结果。我发现面部编码的可靠值是<strong class="is hj"> 0.35/0.37 </strong>。您可以使用<strong class="is hj"> epsilon.py </strong>(源代码<a class="ae jo" href="https://github.com/lorenzoromani1983/wwww/blob/master/wwww/epsilon.py" rel="noopener ugc nofollow" target="_blank">此处为</a>)脚本在您的数据集中查找平均距离的估计值:</p><p id="e154" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">&gt;&gt;pythonεpy</strong></p><p id="8aad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，我发现，如果数据库中存储了许多(数千个)面部向量，脚本返回的值可以产生良好的结果。不管epsilon.py会怎么说，我建议尝试一个介于0.35和0.40之间的值。</p><p id="2a8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> min_samples </strong>值是您可以设置的另一个参数，它将定义一个面部是否必须被视为唯一ID(唯一聚类)。例如，如果将参数设置为5，如果面部向量在数据集中没有出现至少5次，它将被跳过。这意味着可以选择min_samples来减少图形和/output目录中显示的唯一面的总数。如果你的目标只是找出你关系网中最重要的人，这种策略是可以使用的。</p><p id="3c1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">更新</strong></p><p id="af0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有些人问是否有可能用视频<strong class="is hj">代替图片来使用这里描述的技术。的确如此。<a class="ae jo" href="https://github.com/lorenzoromani1983/wwww/tree/master/wwww" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">我已经用两个新的Python脚本更新了Github库</strong> </a>，这两个脚本将允许视频分析和人脸聚类。然而，整个过程<strong class="is hj">仍将基于图像作为面部编码和聚类工作</strong>的输入。事实上，在编码任何东西之前，你需要在你的视频</strong>的同一个目录下运行<strong class="is hj"> segment_frames.txt </strong>脚本<strong class="is hj">。这个脚本将每个视频分割成帧，并将每个帧保存为同一文件夹中的. jpg图像。例如，给定一个video.mp4输入，您将有。jpg文件命名为:</strong></p><p id="8ae3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">/directory/video . MP4 _ _ _ 500 . jpg<br/>/directory/video . mp5 _ _ _ 1000 . jpg</strong></p><p id="016a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中“__500”字符串将标识视频中的帧号。该脚本目前配置为每500帧保存一次，但是您可以更改参数以满足您的需要。显然，参数越低，输出的帧数越多，对人脸进行编码和聚类所需的时间就越长。</p><p id="63fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将所有视频分割成“第N”帧后，像标准过程一样运行encode_faces.py文件。但是您将需要使用<strong class="is hj"> cluster_faces_video.py </strong>脚本，而不是cluster_faces.py，以便在图形中的边缘处生成输出:</p><p id="83a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">独一无二的脸&gt;video.mp4</strong></p><p id="d1fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">而不是:</strong></p><p id="9f07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">独一无二的脸&gt;frame.jpg</strong></p><p id="dded" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了达到这个结果，脚本简单地拆分了每一个。jpg帧由“__”分隔符分成两部分，其中第一部分将是视频的绝对名称，第二部分将是帧编号。</p><p id="1727" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从技术上讲，它将为每个帧创建一个Python列表，例如:</p><p id="ec10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> ['video.mp4 '，' 500.jpg'] </strong></p><p id="0c98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且将只使用索引[0]进入列表，即视频绝对名称。</p><p id="8697" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这些了。我希望你会喜欢这些代码，并且，很明显，做进一步的改进！</p></div></div>    
</body>
</html>