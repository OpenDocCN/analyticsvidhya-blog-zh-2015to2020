<html>
<head>
<title>Data structures from scratch— Part 1: Lists I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始的数据结构—第1部分:列表I</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-structures-and-algorithms-a-theoretical-approach-part-1-lists-i-eb676f698e34?source=collection_archive---------18-----------------------#2019-10-23">https://medium.com/analytics-vidhya/data-structures-and-algorithms-a-theoretical-approach-part-1-lists-i-eb676f698e34?source=collection_archive---------18-----------------------#2019-10-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/915624f008523f352537e53f1c54e553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LwrqAZECpPcBD4nB"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">格伦·卡斯滕斯-彼得斯在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5292" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据结构和算法(DS&amp;A)是计算机科学领域最重要的课题之一。在这篇文章(以及后面的文章)中，我们将看到最常见的DS&amp;A的理论方法和使用NumPy在Python中从头开始的实现。</p><p id="b993" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第1部分中，我们将研究线性抽象数据类型:列表、堆栈和队列。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="8345" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">目录</h1><p id="3887" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">0.必需的知识。<br/> 1。快速提醒。<br/> 2。列表抽象数据类型。<br/> 3。用Python实现数组列表。<br/> 4。记录代码。<br/> 5。运行时间。<br/> 6。优点和缺点。<br/> 7。资源。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="0d58" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">0.必需的知识</h1><p id="65a3" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在我们开始这篇文章之前，你必须知道:</p><ol class=""><li id="12b8" class="ld le hi ix b iy iz jc jd jg lf jk lg jo lh js li lj lk ll bi translated">我们不会从头开始讨论渐近符号，只讨论不同数据结构的计算复杂性。</li><li id="3a2d" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">需要基本的Python和编程知识。</li><li id="622e" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">需要非常基本的数字知识。</li></ol><h1 id="a8d5" class="ka kb hi bd kc kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx bi translated">1.快速提醒</h1><p id="6d19" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">让我们从一些基本定义开始:</p><ul class=""><li id="a0cf" class="ld le hi ix b iy iz jc jd jg lf jk lg jo lh js lw lj lk ll bi translated"><strong class="ix hj">原始数据类型:</strong>数据类型是指特定信息的编码方式。它是一个变量可以代表的一组值。例如，<em class="lx"> int </em> type只能表示整数。</li><li id="4ccc" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js lw lj lk ll bi translated"><strong class="ix hj">抽象数据类型:</strong>是一种类型，其作为类型的表示已经被抽象，其数据只能通过一组操作来访问。从形式上讲，它是一个数学模型，由一组称为<em class="lx">属性</em>的值和一组作用于这些值的操作定义。</li><li id="8c9a" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js lw lj lk ll bi translated"><strong class="ix hj">数据结构:</strong>是一组信息的有组织的表示。表示的不同部分通常是原始数据类型(它也可以有抽象数据类型)。这些部分的组合用于获得满足抽象数据类型规范的表示。这意味着一个<em class="lx">列表</em>是一个抽象数据类型(ADT ),可以用数组(ArrayList)来表示。</li></ul></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="0d49" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">2.列表抽象数据类型</h1><p id="2303" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">列表是零个或多个元素的有限序列。元素可以是不同的类型，但是如果所有的元素都是相同的类型<em class="lx"> T </em>，我们有一个类型<em class="lx"> T </em>的列表。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/2d6da15fd5a2e5c5916d5d926d0c146b.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*KPjemlyMb08Aig4bT0XLqg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1:元素序列</figcaption></figure><p id="c91a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">列表中元素的个数为<em class="lx"> n </em>，通常称为<em class="lx">长度</em>。如果<em class="lx"> n </em>为0，则列表为空。如果<em class="lx"> n </em>等于或大于<em class="lx"> 1 </em>，<em class="lx"> a </em> ₁称为<em class="lx">第一个元素</em>，<em class="lx">a</em>称为<em class="lx">最后一个元素</em>。</p><p id="1a4b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">列表是一个灵活的ADT，可以根据需要增长或缩短:我们可以在列表的任何给定位置插入或删除元素。</p><p id="7a3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们通常以两种不同的方式实现列表:</p><ol class=""><li id="5083" class="ld le hi ix b iy iz jc jd jg lf jk lg jo lh js li lj lk ll bi translated"><strong class="ix hj">链表</strong>:作为元素(节点)的链接序列。</li><li id="c7cf" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated"><strong class="ix hj"> ArrayLis </strong> t:或<em class="lx">基于数组的</em> list实现。</li></ol><p id="51b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这篇文章，我们将采用第二种选择。</p><p id="6c57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个ArrayList用一个大小为<em class="lx"> n </em>的数组<em class="lx"> v[ ] </em>表示列表，数组的元素<em class="lx"> v[i] </em>存储在连续的位置<em class="lx"> i </em>，其中<em class="lx">0</em>≤<em class="lx">I</em>≤<em class="lx">n-1</em>。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/d8e748e681e49e000aea3ae61d268efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3xKGVRGqmLYPWY6t15w4Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图2:基于数组的列表表示。</figcaption></figure><p id="476e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在后面看到这种表示的缺点和优点。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="07eb" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">3.用Python实现数组列表</h1><p id="606e" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">你可能认为“理论方法”需要伪代码来描述算法，你可能是对的，但Python是一种非常高级的语言，使用它的结果是一个你可以实际使用的函数类，而不是把它留在伪代码中。所以，让我们编写一个数组列表！</p><p id="2dd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们想导入NumPy库来使用它的数组。</p><pre class="lz ma mb mc fd me mf mg mh aw mi bi"><span id="cc95" class="mj kb hi mf b fi mk ml l mm mn">import numpy as np</span></pre><h2 id="5280" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">3.1.定义类别</h2><p id="b4a8" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在，我们用将要实现的空方法定义抽象类<em class="lx">列表</em>:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">代码1:列出抽象类。</figcaption></figure><h2 id="f964" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">3.2.魔法属性</h2><p id="b79d" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">要启动<em class="lx"> ArrayList </em>对象，我们需要使用NumPy预先分配数组的长度，称为<em class="lx">向量</em>。属性<em class="lx">大小</em>将是列表中元素的数量。最后，<em class="lx"> __str__ </em>方法将以字符串形式返回列表，这样我们就可以打印它了。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">代码二:魔法属性。</figcaption></figure><h2 id="e4e2" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">3.3.获取并搜索</h2><p id="d5e8" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated"><em class="lx"> get </em>方法将返回给定位置的元素。我们只需要在确认合法后进入那个位置。</p><p id="7926" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lx">搜索</em>方法将查找给定元素的索引。我们需要遍历列表，直到找到元素或者到达列表的末尾。如果元素不在列表中，我们将返回一个值<em class="lx"> -1 </em>，而不是引发一个异常。这样做是因为我们将在后面的方法中使用该属性。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">代码3:获取并搜索。</figcaption></figure><h2 id="1a28" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">3.4.插入和追加</h2><p id="e997" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果我们想在给定的位置插入一个元素<em class="lx"> x </em>，我们需要为<em class="lx"> x </em>腾出空间。我们通过将位置<em class="lx"> i </em>中的元素移动到位置<em class="lx"> i + 1 </em>来实现这一点。也就是说，我们将每个元素向右移动一个位置。</p><p id="4502" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了执行这个操作，我们通常使用一个反向循环来完成所需的移位。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/9eb2b44b7d6a435be3f0509e22f932ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*npydPRdeeoTExrO7NRdmVg.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3:插入元件19的过程。</figcaption></figure><p id="b54c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于<em class="lx"> append </em>操作，我们只需要检查列表是否未满，如果是，则在最后一个位置插入元素。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">代码4:插入和追加。</figcaption></figure><h2 id="deef" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">3.4.移除方法</h2><p id="1353" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">要从列表中删除一个元素，我们可以采用两种方法:</p><ol class=""><li id="5911" class="ld le hi ix b iy iz jc jd jg lf jk lg jo lh js li lj lk ll bi translated">移除给定位置的元素。</li><li id="39f6" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">通过在列表中搜索来移除给定元素。</li></ol><p id="4a5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于第一个选项，我们应该检查索引的合法性，以及列表元素的数量。之后，我们将位置<em class="lx"> i + 1 </em>的元素移动到<em class="lx"> i </em>。换句话说，我们将列表中的元素向左移动。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/7f309f4e33c977c77e0ecf4a3a500f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*N3UF0fkvdFtelqZ3q88xlw.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4:删除给定列表的元素19的过程。</figcaption></figure><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">代码5:移除方法。</figcaption></figure><h2 id="b27b" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">3.5.其他方法</h2><p id="2637" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可能要考虑一些其他方法，这些方法可以用于不同的目的。在我们的例子中，我们会多考虑2个:<em class="lx">清理</em>和<em class="lx">清空</em>。</p><p id="b733" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lx"> clean </em>方法将设置所有元素为空，而<em class="lx"> empty </em>方法将检查列表是否为空。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">代码6:其他方法。</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="e2ef" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">4.记录代码</h1><p id="a29b" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在我们有了一个实现ADT列表的全功能类，我们应该添加一个适当的文档来解释这些方法在做什么，这些方法工作需要什么参数，异常等等。</p><p id="47c3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面，您将找到一种可能的方法来记录该类。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">代码7:文档类。</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="bbfe" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">5.执行时间</h1><p id="60e5" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">是时候研究一下链表ADT不同操作的运行时间了。请记住，我们正在与一个香草列表ADT，而不是一个排序，循环或任何其他变量。</p><p id="a6c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:</strong>记住在渐近符号中我们定义了算法的上下限。算法的上界是其最坏情况的上界(大O)，算法的下界是其最好情况的下界(大ω)。</p><p id="1dc9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，要知道<em class="lx">ω</em>并不是最佳情况，而是最佳情况的下界。因此，这是算法的下限。当我们谈论<em class="lx"> O </em>时，情况也是如此。</p><h2 id="5c78" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.1.得到</h2><p id="1238" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">这是一个简单的。元素要么是位置，要么不是。这两种情况具有相同的复杂性:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/dd4216fa9cd9beffea533bbe868b2da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:182/format:webp/1*GIdurHv9KHX07ghHL2DMgA.png"/></div></figure><h2 id="533e" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.2.搜索</h2><h2 id="bf61" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.2.1.最坏情况</h2><p id="017e" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">假设元素存在于列表中，那么<em class="lx">搜索</em>方法的最坏情况是元素位于列表的最后一个位置。这意味着我们将遍历整个列表减去一个位置来找到元素。</p><p id="a15c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，我们也可以认为最坏的情况是元素不在列表中，所以我们遍历了列表却什么也没有。</p><p id="1ca4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用渐近符号规则，这两种复杂性将是相等的。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/11feee57f8c34e050ffcebab4cb639e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*-uBiavslk6d08QfGWA1ung.png"/></div></figure><h2 id="419a" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.2.2.最好的情况</h2><p id="81c4" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">最好的情况是元素在第一个位置，我们只需要做一步。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/069693fde6fe5ec6a6c0c27811d53725.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/format:webp/1*aWTyGXO0_Jp6pJFVFVAHcw.png"/></div></figure><h2 id="332c" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.2.3.一般情况</h2><p id="096a" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">请记住，平均案例是问题所有可能实例的平均成本。有<em class="lx"> n </em>个可能的实例，每一个都有<em class="lx"> 1/n </em>的概率。为了简单起见，我们将认为搜索总是成功的，即元素总是在列表中。如果每个实例的成本为<em class="lx"> i </em>(因为如果元素在索引<em class="lx"> i </em>处，循环将执行<em class="lx"> i </em>次)，其中<em class="lx"> i </em>是其位置，那么</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/9326a1ad93ec0481a22d52be4ebc8dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GC-XGnMHgMIDBqlBTVLqcw.png"/></div></div></figure><h2 id="00ed" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.3.插入</h2><h2 id="7b70" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.3.1.最坏情况</h2><p id="3db3" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果我们在第一个位置插入一个元素，我们必须将列表中的所有元素向右移动一个位置。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/11feee57f8c34e050ffcebab4cb639e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*-uBiavslk6d08QfGWA1ung.png"/></div></figure><h2 id="6bea" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.3.2.最好的情况</h2><p id="9796" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们在最后一个位置插入一个元素，所以我们不需要移动任何元素。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/069693fde6fe5ec6a6c0c27811d53725.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/format:webp/1*aWTyGXO0_Jp6pJFVFVAHcw.png"/></div></figure><h2 id="e710" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.3.3.一般情况</h2><p id="1b33" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果我们应用我们在搜索平均情况下所做的相同分析，我们得到</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ni"><img src="../Images/b11da1ccf86a0431f93126d24624b0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:194/format:webp/1*iijNjb58ch3PPl4TdVLFLg.png"/></div></figure><h2 id="50dc" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.4.附加</h2><p id="d41c" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">对于append方法，我们只需要检查列表是否已满，如果没有，就插入元素。这给了我们恒定的时间。所有情况都是一样的，因此:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/dd4216fa9cd9beffea533bbe868b2da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:182/format:webp/1*GIdurHv9KHX07ghHL2DMgA.png"/></div></figure><h2 id="21c2" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.5.去除</h2><p id="f619" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们将处理<em class="lx"> remove_by_index </em>，因为它确实是移除元素的主要方法，而<em class="lx"> remove_by_value </em>是<em class="lx"> remove_by_index </em>加上<em class="lx"> search </em>的组合。</p><h2 id="5b04" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.5.1.最坏情况</h2><p id="cd27" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">假设元素在列表中，最坏的情况是我们要移除的元素在数组的第一个位置。然后，我们必须将所有元素从右向左移动。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/11feee57f8c34e050ffcebab4cb639e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*-uBiavslk6d08QfGWA1ung.png"/></div></figure><h2 id="1795" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.5.2.最好的情况</h2><p id="ce21" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果我们删除最后一个位置的元素，我们不需要移动任何元素。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/069693fde6fe5ec6a6c0c27811d53725.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/format:webp/1*aWTyGXO0_Jp6pJFVFVAHcw.png"/></div></figure><h2 id="ce83" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">5.5.3.一般情况</h2><p id="3aa9" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">类似于搜索和插入</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ni"><img src="../Images/b11da1ccf86a0431f93126d24624b0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:194/format:webp/1*iijNjb58ch3PPl4TdVLFLg.png"/></div></figure><p id="22c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于<em class="lx"> remove_by_value </em>，我们称之为<em class="lx"> search </em>和<em class="lx"> remove_by_index </em>，所以复杂度来源于那两个。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="7258" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">6.优势和劣势</h1><h2 id="647c" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">6.1优势</h2><ol class=""><li id="a6d0" class="ld le hi ix b iy ky jc kz jg nj jk nk jo nl js li lj lk ll bi translated">我们可以在恒定时间内执行随机访问。</li><li id="0498" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">如果不浪费空间，这是非常有效的内存。我们不需要太多空间来存储内容。</li><li id="8efc" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">实现简单。</li></ol><h2 id="2852" class="mj kb hi bd kc mo mp mq kg mr ms mt kk jg mu mv ko jk mw mx ks jo my mz kw na bi translated">6.2.弱点</h2><ol class=""><li id="1212" class="ld le hi ix b iy ky jc kz jg nj jk nk jo nl js li lj lk ll bi translated">当插入或删除元素时，我们必须移动它们。:D的加工者不喜欢搬东西</li><li id="f1eb" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">如果达到空间限制，我们必须创建另一个比旧数组更大的数组，并复制所有元素，复杂度为θ(n)。</li><li id="e163" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">如果我们没有填满足够的位置，可能会浪费空间。</li></ol></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="d93f" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">7.资源</h1><p id="2b9d" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">[1].Pat Morin — <a class="ae iu" href="http://opendatastructures.org/ods-python.pdf" rel="noopener ugc nofollow" target="_blank">开放式数据结构</a></p><p id="6c66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[2].托马斯·h·科尔曼，查尔斯·e·莱瑟森，罗纳德·L·李维斯特，克利福德·斯坦— <em class="lx">算法简介</em>。</p><p id="619d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[3].阿尔弗雷德·v·阿霍，杰弗里·d·乌尔曼，约翰·E·霍普克罗夫特— <em class="lx">数据结构和算法</em>。</p><p id="0b0a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[4].Anany Levitin — <em class="lx">介绍算法的设计和分析</em>。</p><p id="023e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[5].乔恩·克莱因伯格，埃娃·塔尔多斯— <em class="lx">算法设计</em>。</p><h1 id="9f6e" class="ka kb hi bd kc kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx bi translated">注意</h1><p id="b992" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果您有任何问题、疑问或您认为有些地方是错误的(或可以改进的)，请不要犹豫联系我或写下评论。</p></div></div>    
</body>
</html>