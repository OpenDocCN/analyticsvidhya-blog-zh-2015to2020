<html>
<head>
<title>Introduction To Information Retrieval, Rank Retrieval &amp; TF-IDF Using A Search Engine In NLP.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NLP中使用搜索引擎的信息检索、排名检索和TF-IDF介绍。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/introduction-to-information-retrieval-rank-retrieval-tf-idf-using-a-search-engine-in-nlp-9c988d9f0051?source=collection_archive---------4-----------------------#2020-07-13">https://medium.com/analytics-vidhya/introduction-to-information-retrieval-rank-retrieval-tf-idf-using-a-search-engine-in-nlp-9c988d9f0051?source=collection_archive---------4-----------------------#2020-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/7981ccf7bc6f08c1daad93491d751970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UBtOJfIDzPhHBRt6y23nVw.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://unsplash.com/@matthewhenry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马太·亨利</a>在<a class="ae hv" href="https://unsplash.com/t/technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><div class=""/><blockquote class="iv iw ix"><p id="b129" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hz">你说的信息检索是什么意思？</strong></p></blockquote><p id="8880" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">机器学习中的信息检索可以定义为从大型集合(通常存储在计算机上)中找到满足信息需求的非结构化性质(通常是文本)的材料(通常是文档)。</p><p id="3d29" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">有许多信息检索场景，如电子邮件搜索、笔记本电脑搜索、公司知识库搜索、法律信息检索，但最常见的信息检索搜索之一是web搜索。一直以来，大部分人类知识信息都是以人类语言文本文档的形式存储的。在早期，特别是在90年代，非结构化数据比结构化数据<strong class="jb hz">的比例大，但是在90年代中期，特别是在工业化评估之后，结构化数据变得比非结构化数据更受欢迎。如今，非结构化数据的数据量比结构化数据大得多，这只是因为其他数据源平台，特别是twitter、Instagram、Medium等社交媒体平台，但这已经成为企业方面的一个重大转变，特别是主要网络搜索巨头解决非结构化数据的问题。所以问题出现了<strong class="jb hz">他们如何处理这个问题？在这篇博客结束的时候，你会得到你的答案。</strong></strong></p><blockquote class="iv iw ix"><p id="5de6" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hz">信息检索的基本假设</strong></p></blockquote><p id="c288" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们的信息检索目标必须是与用户信息需求相关的信息，并且有助于完成任务。假设我想搜索一辆汽车，它在我的预算之内，具有我想要的所有新功能，包括一系列功能，并且在同类产品中也是最好的，所以这是我的信息需求，但我们不能只在网络搜索栏中输入完整的信息，所以我们将这种信息需求转换为更紧凑的形式<strong class="jb hz"> (query) </strong>并将其输入到我们的搜索栏中。现在，这个查询查询它所拥有的文档集合，并返回结果。可能有这样一种情况，我们对结果不满意，我们根据结果数据修改我们的查询，并再次搜索更好的结果。所以每次我们修改我们的查询，我们都会得到一些结果数据，我们总是想知道结果是否好，以及查看结果是否好的基本方法，我们考虑两个度量</p><ol class=""><li id="b425" class="ka kb hy jb b jc jd jg jh jx kc jy kd jz ke jw kf kg kh ki bi translated"><strong class="jb hz"> Precision </strong>:检索到的文档中与用户信息相关的部分，或者换句话说，在查看结果后，十分之一的文档与您需要的信息相关，或者十分之七的文档与您需要的信息相关。</li><li id="0342" class="ka kb hy jb b jc kj jg kk jx kl jy km jz kn jw kf kg kh ki bi translated"><strong class="jb hz">回忆</strong>:检索到的相关文档在文档集中的比例，或者换句话说，系统成功地从文档集中找到了多少有用的信息。</li></ol><blockquote class="iv iw ix"><p id="6a5c" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hz">术语文档关联矩阵</strong></p></blockquote><p id="2b0f" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">假设我们在世界文学中有两部最大的古代史诗<a class="ae hv" href="https://en.wikipedia.org/wiki/Ramayana" rel="noopener ugc nofollow" target="_blank"> <strong class="jb hz">【罗摩衍那】</strong></a><strong class="jb hz"/>&amp;<strong class="jb hz"/><a class="ae hv" href="https://en.wikipedia.org/wiki/Mahabharata" rel="noopener ugc nofollow" target="_blank"><strong class="jb hz">【摩诃婆罗多】</strong> </a> <strong class="jb hz"> </strong>，我们很少有具体的问题，比如哪一部和哪一章包含了湿婆、克里希纳而不是罗摩。</p><p id="85ed" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">好吧，如果你从一个基本的文本搜索命令开始，你要考虑的解决这个问题的第一个方法是彻底搜索文档的文本。如果您使用Python或UNIX或任何其他语言来实现这一点，您可能会考虑在文档中找到想要的单词时使用标志，或者在找不到任何单词时移动到下一个文档， 这对于数量较少或字数较少的文档完全适用，但对于上述文档，或者说我们添加了少量更多的文档，我们无法进行线性搜索和寻找匹配的内容，我们将讨论所有这些问题以及现代信息检索系统中处理这些问题的方式，但让我们讨论一下<strong class="jb hz">术语-文档关联矩阵的概念。 </strong></p><figure class="kp kq kr ks fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ko"><img src="../Images/5fa8704ec108d40712484a6b13392786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnvEVMMZz2tSoxqo-cVlUw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">带有章节的文档的关联矩阵</figcaption></figure><p id="fca1" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">创建矩阵后，我们可以清楚地看到《摩诃婆罗多》第二章满足了我们的查询。</p><blockquote class="iv iw ix"><p id="0f93" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hz">倒排索引，现代信息检索的关键数据结构</strong></p></blockquote><p id="f9a2" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">倒排索引是现代信息检索系统的关键数据结构，从运行在单个笔记本电脑上的系统到运行在最大的商业搜索引擎上的系统。倒排索引是一种数据结构，它利用了我们刚刚谈到的术语文档矩阵的这种稀疏性，并允许非常高效的信息检索。</p><p id="203d" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hz">那么什么是倒排索引呢？</strong></p><p id="cc40" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这与我们在<a class="ae hv" rel="noopener" href="/analytics-vidhya/introduction-to-n-grams-language-modeling-text-classification-naive-bayes-classification-in-5623ce2a36f1">之前的博客</a>中所做的非常相似，即通过将文档标记为单字母、双字母或N字母，删除特殊字符并对具有相似含义的不同单词进行排序，如Bharat和India，来为单词包创建单词字典(语料库)。</p><p id="d00a" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">现在，我们将从我们已经从文档中创建的词典或语料库中处理我们的信息检索查询。为了使它更高级，我们可以有位置索引，将查询分成一元、二元，使用AND或OR操作符以获得更好的结果，找出下一次出现(索引)或前一次出现的所需查询N元，并提取关系，简而言之，我们的前一个矩阵的反演和我们的新矩阵将看起来像这样</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div class="er es kt"><img src="../Images/c872a9f3249b34e10140d7ac97af31e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*oGm6J58DNFZ-qer4Ome2jA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">文档的逆矩阵</figcaption></figure><blockquote class="iv iw ix"><p id="c8c2" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hz">排名检索模型的构想</strong></p></blockquote><p id="3f66" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">到目前为止，我们已经讨论了用户为搜索引擎生成的布尔查询。这些查询使用关键字之间的And或or关系，并因此提供相关文档。为搜索引擎生成一个完美的查询以提供适当的相关数据是一项特殊的任务，这方面的专家有时会发现创建一个完美的查询是非常懒惰的。</p><p id="0786" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">引入了一种排序算法，这样我们在搜索后得到的结果数据按IR的顺序排列，即根据搜索结果提供一个分数。我们可以通过<strong class="jb hz"> </strong> <a class="ae hv" href="https://www.statisticshowto.com/jaccard-index#:~:text=The%20Jaccard%20similarity%20index%20(sometimes,more%20similar%20the%20two%20populations." rel="noopener ugc nofollow" target="_blank"> <strong class="jb hz"> Jaccard系数</strong> </a>来实现排名检索模型即</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div class="er es ku"><img src="../Images/10e5e39f20cb404124762942e8543f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*tghVJEJygCoRIA_nh0xpkw.png"/></div></figure><p id="8fae" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">但是我们不能认为Jaccard系数是IR模型的一个好主意，因为它有几个问题</p><ol class=""><li id="1a40" class="ka kb hy jb b jc jd jg jh jx kc jy kd jz ke jw kf kg kh ki bi translated">它不考虑术语频率，即一个术语在文档中出现的次数</li><li id="45ae" class="ka kb hy jb b jc kj jg kk jx kl jy km jz kn jw kf kg kh ki bi translated">有时集合中的罕见术语比频繁术语更能提供信息。</li><li id="0cb2" class="ka kb hy jb b jc kj jg kk jx kl jy km jz kn jw kf kg kh ki bi translated">我们需要一种更复杂的长度标准化方法</li></ol><blockquote class="iv iw ix"><p id="7d5a" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hz">词频和文档频率(TF-IDF)权重</strong></p></blockquote><p id="e66e" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">术语频率是一个单词(查询属性)在一个文档中出现的次数，而文档频率是存在或可用的文档的数量(在我们的例子中是《罗摩衍那》和《摩诃婆罗多》的章节数量),我们将tf-idf定义为</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/ea7b9807893b20c7baee67f95c6fe491.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*2lEsM7VZEcxIrhjhr_KzXA.png"/></div></figure><p id="a1be" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们使用log(N/df)代替N/df来抑制idf的影响。</p><p id="77ff" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">术语的tf -idf权重是其术语频率(tf)权重与其文档频率(idf)权重的倒数的乘积</p><p id="caff" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hz">Wtd =(1+log TF)* log(N/df)</strong></p><p id="36f8" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这是IR中最著名的加权方案，已经有了很多研究，并且引入了许多新的方案，但是如果你只想知道一个，那么这就是一个。tf-idf分数可以定义为</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div class="er es kw"><img src="../Images/19c78760c69c48d9c6a876bb5c23d40f.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*IEK46AnKhMhA1JBSyWRJxA.png"/></div></figure><blockquote class="iv iw ix"><p id="228d" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hz">查询为向量</strong></p></blockquote><p id="ff25" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">到目前为止，我们已经讨论了如何将文档转换为特征向量，但要获得更精确的结果，将查询转换为向量，然后根据排名获得搜索结果将会更加有用。这种方法帮助我们根据文档接近度对文档进行排序，接近度对应于向量的相似度和距离的倒数。</p><p id="c8f0" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">但是像往常一样，使用距离作为等级不是一个好主意，让我解释给你听，假设你有一个查询“嫉妒导致仇恨”,它们是三个文档，我们得到d1、d2和d3。文档d1与“嫉妒”有很大关系，d3与“仇恨”有很大关系，而d3与“嫉妒和仇恨”都有很大关系，所以如果使用<strong class="jb hz">欧几里德距离</strong>，我们将获取我们自己的不那么相关的信息，因为<strong class="jb hz">欧几里德距离</strong>适用于大距离，所以我们考虑距离的角度，所以最终的想法是根据查询的角度对文档进行排序。</p><p id="d967" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">以下两个概念是等价的。</p><ol class=""><li id="e4ed" class="ka kb hy jb b jc jd jg jh jx kc jy kd jz ke jw kf kg kh ki bi translated">按照查询和文档之间角度的降序排列文档</li><li id="6b0b" class="ka kb hy jb b jc kj jg kk jx kl jy km jz kn jw kf kg kh ki bi translated">按照余弦(查询，文档)的升序排列文档，因为余弦对于区间(0 -180)是单调递减函数。</li></ol><p id="abfd" class="pw-post-body-paragraph iy iz hy jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">希望事情已经非常清楚，许多问题已经得到解决，但如果仍然没有，那么请随时联系我，给我写一封短信。</p></div></div>    
</body>
</html>