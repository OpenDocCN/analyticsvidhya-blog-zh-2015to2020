<html>
<head>
<title>Indexing of Arrays: 0 vs 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数组索引:0对1</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/indexing-of-arrays-0-vs-1-83c080cde374?source=collection_archive---------20-----------------------#2019-12-27">https://medium.com/analytics-vidhya/indexing-of-arrays-0-vs-1-83c080cde374?source=collection_archive---------20-----------------------#2019-12-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/99fb877b408132c953e2c902bc976c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ct8_vbejsLk4ACvH4sVyTA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由来自<a class="ae iu" href="https://www.pexels.com/photo/alberta-amazing-attraction-banff-417074/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae iu" href="https://www.pexels.com/@souvenirpixels?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">詹姆斯·惠勒</a>拍摄</figcaption></figure><h1 id="9fd6" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">1.1:为什么是零？</h1><p id="af08" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">大多数编程语言使用基于0的索引，即该语言中的数组从索引0开始。其中一个主要原因是公约。早在1966年，Martin Richards——IBM BPCL的创造者——使用0作为初始索引，这样指针p就可以访问p<a class="ae iu" href="https://en.wikipedia.org/wiki/Zero-based_numbering#Origin" rel="noopener ugc nofollow" target="_blank">T5的内存位置。由于它的广泛使用和可移植性，C建立了这个基于0的索引。从那时起，大多数编程语言，其中许多是C的衍生物，开始使用基于0的索引。</a></p><p id="1906" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">后来，著名的计算机科学家Edsgar W. Dijkstra接着写了一篇名为《为什么编号应该从0开始》的笔记，列举并辩护了这种“奇怪”约定<a class="ae iu" href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html" rel="noopener ugc nofollow" target="_blank"> </a>的所有理由。</p><p id="4360" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">根据Dijkstra，为了表示数字1，2，3 … 5的集合，我们可以使用以下4个约定:</p><p id="0c80" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">A.0 &lt; i &lt; 6</p><p id="f208" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">B. 0 ≤ i &lt; 6</p><p id="4f9b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">C. 0 &lt; i ≤ 5</p><p id="7799" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">D. 0 ≤ i ≤ 5</p><p id="a5c1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">Dijkstra laid out a rule for the <em class="kw">理想约定</em>。</p><ul class=""><li id="72d2" class="kx ky hi jv b jw kr ka ks ke kz ki la km lb kq lc ld le lf bi translated">约定应该能够显示一个空集</li></ul><p id="ffbf" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">同样，Dijkstra排除了A和C，因为要表示从0开始，我们必须在符号中使用-1。Dijkstra称这是“丑陋的”。</p><p id="6026" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们现在只剩下选项B和d。根据Dijkstra提出的规则，为了表示一个空集，我们可以用下面的方式写它:</p><p id="58eb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">B.0 ≤ i &lt; 0</p><p id="9ebc" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">D.0 ≤ i ≤ -1</p><p id="14cb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">同样，Dijkstra称选项D“丑陋”，不仅因为它使用了负数，还因为它使用了较小的数作为上限，较低的数作为下限。自然，我们倾向于选择b。</p><p id="f9d9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">除了这种主观的“丑陋”，许多递归算法使用0作为基本情况，如果没有基于0的索引，将更难实现。在许多组合算法中——比如得到一个集合的所有子集——空集经常出现，简单的符号表示更好。</p><p id="74af" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">此外，对于循环列表，可以使用模操作符在最后一个元素后将迭代器返回0。</p><p id="b933" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">对于具有n个元素和不断迭代自身的变量k的循环列表，表示被访问的元素的索引的迭代器I可以以如下方式迭代:</p><p id="2cc0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">i = (k % n)</p><p id="6ffe" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">注意，在访问第(n-1)个元素之后，我们退回到第‘零’个元素。</p><p id="681a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">同样，C和许多其他低级语言使用0，以便可以以简单的公式方式访问数据<a class="ae iu" href="https://en.wikipedia.org/wiki/Zero-based_numbering#Numerical_properties" rel="noopener ugc nofollow" target="_blank"> </a>:</p><p id="c29a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果a是数组中第一个(初始的，不是位置1的)元素的内存地址，其中s是数组中每个元素的大小，I是迭代器，则第I个位置的元素的内存地址可以表示为:</p><p id="1e12" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">a + (i * s)</p><h1 id="8d63" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">1.2:为什么一个？</h1><p id="a954" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">一些语言如Lua、Fortran、COBOL和Julia使用基于1的索引。这种与惯例相反的索引实践的共同论点是“从一开始计数是很自然的”，并且在一定程度上是正确的。自从数学诞生以来，人类就学会了从1开始计数，因为不可能什么也“数”不出。</p><p id="e07e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">Julia主要用于科学和数学研究领域，对科学家来说，从1开始计数更直观，因此更受欢迎。</p><p id="5240" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">Julia最初也是为数学领域更好的编程语言而设计的，用于迭代MATLAB，并使用类似语言中没有的通用编程功能。</p><p id="4d65" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">然而，需要注意的是，在朱莉娅<a class="ae iu" href="https://docs.julialang.org/en/v1/devdocs/offset-arrays/" rel="noopener ugc nofollow" target="_blank"> ⁴ </a>中改变索引是可能的。</p><p id="0dea" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">另一个原因是新手友好。当编程新手学习索引一个列表时，将1:3想象成1，2，3比通常的0:3更直观，0:3表示数字0，1，2。</p><p id="d91f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">像Pascal和Perl这样的一些语言允许程序员定义数组的索引到他们选择的<a class="ae iu" href="https://en.wikipedia.org/wiki/Zero-based_numbering#Usage_in_programming_languages" rel="noopener ugc nofollow" target="_blank"> ⁵ </a>。这个选项通常可以使解决问题变得容易得多(例如，算术级数的3个连续项之和取为(n-d)+(n)+(n+d)= 3n，而不是(n) + (n + d) + (n + 2d) = (3n + 3d)</p><p id="ce7f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">高级语言应该使用基于1的索引的另一个原因是，它们不允许程序员单独访问内存位置，也不需要基于0的索引，这反而会使代码变得复杂。</p><p id="04bb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">此外，基于0的索引提供的“索引优化”不是真正的优化<a class="ae iu" href="https://en.wikipedia.org/wiki/Zero-based_numbering#Numerical_properties" rel="noopener ugc nofollow" target="_blank"> ⁶ </a>，因为内存地址的访问可以通过用以下公式定义术语“b”来简化:</p><p id="2b42" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">b = a-s</p><p id="7b56" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这将把存储器地址公式简化为:</p><p id="2b01" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">b + (i * s)</p><p id="d36b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这不需要如该公式所示计算每次迭代(I-1 ),该公式通常用作反对基于1的索引的论据:</p><p id="f233" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">a+(s *(I-1))</p><h1 id="bfcf" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">1.3:结论:哪个更好？</h1><p id="8719" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">因为这是从Julia的角度写的，我们将检查每个系统相对于Julia的优点和缺点。</p><p id="903f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">因为Julia的社区深深植根于纯数学和科学，所以基于1的索引是首选。此外，如果Julia进行切换，使其遵循一般的编程规范，许多脚本将停止工作，并导致关键研究项目的失败。</p><p id="ddd1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">此外，将1:3索引为1，2，3的概念比将标准的0:3索引为0，1，2更直观。虽然Dijkstra已经展示了半开音程的内在美，但使用1作为基数是自然和直观的。我们还看到，基于0的索引并没有像通常认为的那样提供真正的内存访问优化。</p><p id="b355" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">基于1的索引的唯一缺点是循环列表和1索引语言中这些列表所需的笨拙设置。</p><p id="d5e6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">总之，这可以归结为个人偏好、语言应用和索引，这样不仅可以解决问题，还可以更容易地调试和编写代码。</p><p id="4261" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在我看来，语言应该像Perl和Pascal那样为程序员提供索引选项的灵活性。然而，如果没有正确地编写代码，或者没有正确地实现灵活的索引，这会使代码难以阅读。</p><p id="03c6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">对Julia来说，同样重要的是注意到指数是可以改变的。</p><p id="4df0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">考虑到Julia的社区、使用情况、当前标准以及对初学者的友好程度，基于1的索引是有意义的，并且会一直存在下去，除非Julia在类似于Python 2和3之间的重大更新中得到彻底改革。</p><h1 id="517f" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">1.4:引用和参考文献</h1><p id="0b57" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">[1]-引用自<a class="ae iu" href="https://en.wikipedia.org/wiki/Zero-based_numbering#Origin" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Zero-based_numbering#Origin</a>的关于BPCL的信息</p><p id="4548" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">[2]-迪杰斯特拉的笔记可以在<a class="ae iu" href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html" rel="noopener ugc nofollow" target="_blank">http://www . cs . ut exas . edu/users/EWD/transcriptions/ewd 08 xx/ewd 831 . html</a>找到</p><p id="fb19" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">[3]-内存访问的数值属性，引用自<a class="ae iu" href="https://en.wikipedia.org/wiki/Zero-based_numbering#Numerical_properties" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Zero-based _ numbering # numeric _ Properties</a></p><p id="5e3a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">[4]-关于改变Julia数组索引的更多信息:<a class="ae iu" href="https://docs.julialang.org/en/v1/devdocs/offset-arrays/" rel="noopener ugc nofollow" target="_blank">https://docs.julialang.org/en/v1/devdocs/offset-arrays/</a></p><p id="1618" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">[5]-帕斯卡中索引的自定义性质:</p><p id="7a38" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Zero-based_numbering#Usage_in_programming_languages" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Zero-base _ numbering # Usage _ in _ programming _ languages</a></p><p id="bbb3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">[6]-证明基于0的索引不提供优化:<a class="ae iu" href="https://en.wikipedia.org/wiki/Zero-based_numbering#Numerical_properties" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Zero-based _ numbering # numeric _ properties</a></p><p id="0433" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">封面图片“湖光山色”由Pexels上的“James Wheeler”提供免费使用许可:<a class="ae iu" href="https://www.pexels.com/photo/alberta-amazing-attraction-banff-417074/" rel="noopener ugc nofollow" target="_blank">https://www . Pexels . com/photo/Alberta-amazing-attraction-banff-417074/</a></p></div></div>    
</body>
</html>