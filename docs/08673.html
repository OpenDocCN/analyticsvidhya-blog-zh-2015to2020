<html>
<head>
<title>How does Self Organizing Algorithm works?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自组织算法是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-does-self-organizing-algorithm-works-f0664af9bf04?source=collection_archive---------9-----------------------#2020-08-08">https://medium.com/analytics-vidhya/how-does-self-organizing-algorithm-works-f0664af9bf04?source=collection_archive---------9-----------------------#2020-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="65bf" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">带有数学示例的简单分步指南</h2></div><p id="81fa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Teuvo Kohonen 提出的自组织地图(SOM)是一种数据可视化技术。通过将数据的维度缩减到地图上，有助于理解高维数据。此外，它还通过将相似的数据分组来展示聚类。这种聚类能力在SOM的一个变种——生长自组织ma被引入后得到了广泛的认可。</p><p id="f351" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以将SOM总结为:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/49cb35a6307acd4e5a8fd6d84e97939e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BcjCgnZ1_InejCH1yw7Nwg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图1 . SOM是做什么的？作者绘制</figcaption></figure><p id="f936" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">SOM是独特的，因为它偏离了大多数通用的“纠错”方法，而是遵循竞争学习。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kj"><img src="../Images/9d43e4196881815e065a5abe7ef36b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*KSXhzDgPPCTPQDtitborOA.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图2<a class="ae kk" href="https://www.researchgate.net/profile/Zhe_Li9" rel="noopener ugc nofollow" target="_blank">李哲</a>绘制的SOM示意图</figcaption></figure><h2 id="2d88" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">实际发生了什么？</h2><p id="80a8" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">数据点将相互竞争以获得网络中的表示。首先，用权重初始化网络。从训练数据集中随机选择数据，并计算节点(权重)和样本向量之间的距离。最短的距离被认为是T4 BMU T5。然后找到获胜节点或BMU的邻域。更新邻居权重或节点。重复该过程，直到针对每个训练数据对网络进行了训练。</p><p id="9699" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">最佳匹配单元(BMU) </strong>:从自身到样本向量距离最短的胜出节点(或权重)。确定距离的方法有很多，但是，最常用的方法是<a class="ae kk" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank"> <em class="ll">欧氏距离，</em> </a> <em class="ll">是计算权重和样本向量之间距离的最常见度量。</em></p><h2 id="6582" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">算法崩溃</h2><ul class=""><li id="da94" class="lm ln hi iz b ja lg jd lh jg lo jk lp jo lq js lr ls lt lu bi translated">初始(随机化)</li><li id="cb2b" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">竞赛(选择获胜者节点)</li><li id="a09f" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">合作(识别邻居)</li><li id="2f0b" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">适应(适应赢家和邻居的权重)</li><li id="cc43" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">平滑(随着迭代的增加减少NR/引入可选的平滑阶段)</li></ul><h2 id="0387" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">因素</h2><blockquote class="ma mb mc"><p id="a8d2" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><strong class="iz hj">遥控</strong> —行数/列数</p><p id="85c0" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><strong class="iz hj"> N </strong> -神经元的数量</p><p id="1c11" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><strong class="iz hj"> MaxIter </strong> —迭代次数</p><p id="594b" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><strong class="iz hj"> MaxNR </strong> —网格的最大半径</p><p id="fbb1" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><strong class="iz hj"> nr(t) </strong> —邻域半径</p><p id="18b3" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">ර(t)——学习率</p><p id="72d4" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">A —尺寸数量</p><p id="09d8" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">神经元I和j之间的距离=&gt; D(wi，wj)</p><p id="a6f2" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">输入-&gt; <strong class="iz hj"> All_inputs={x1，x2…} </strong></p><p id="f117" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">wk=所有权重或节点</p></blockquote><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mg"><img src="../Images/74b06618c8c3d4dcd606e07e4272a3e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wm5_lGWsbeF3qxhXB92x-A.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图4作者起草的SOM算法</figcaption></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mg"><img src="../Images/4d72b827a250b3ac3529f653a9adb787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nft8fhcQ6oQ1aInpXu7DRw.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图5 .作者起草的方程</figcaption></figure></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h2 id="e390" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">对特定数据尝试SOM算法</h2><p id="acb4" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">初始权重是w1 = (0.45，0.89)，w2 = (0.55，0.83)，w3 = (0.95，0.32)，w4 = (0.62，0.78)。并且让四个神经元(N=4) N1、N2、N3和N4分别位于笛卡尔平面位置(0，0)、(1，0)、(1，0)和(1，1)中的网格处。并且假设网络取2维(A=2)输入向量(x1，x2)。设w_i= (w1_i，w2_i)为神经元<strong class="iz hj"> i </strong>的权重。nr = 0.6。输入向量(3，1)。假设学习率= 0.5，并且始终保持不变。假设初始重量如图所示。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mg"><img src="../Images/70ac187f9bb2adc6e7ba305a2e611cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwVQhb8mm7mCNMC82o3s-Q.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图6 .作者绘制的网格和权重</figcaption></figure><h2 id="937e" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">第一次迭代</h2><ol class=""><li id="7df6" class="lm ln hi iz b ja lg jd lh jg lo jk lp jo lq js mo ls lt lu bi translated">计算邻域半径= &gt; <strong class="iz hj"> nr </strong> = 0.6(从第一次迭代开始)</li><li id="70f2" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js mo ls lt lu bi translated">计算学习率= &gt;<strong class="iz hj">【ර(t】)</strong>= 0.5(和常数)</li></ol><p id="5399" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.查找给定矢量输入的最近邻或优胜节点(使用欧几里德距离)</p><blockquote class="ma mb mc"><p id="e874" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">d (V，N1)=(3–0.45)+(1–0.89)= 6.514</p><p id="eb5c" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">d (V，N2)=(3–0.55)+(1–0.83)= 6.03</p><p id="69c0" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">d (V，N3)=(3–0.62)+(1–0.78)= 5.71</p><p id="e20b" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">d (V，N4)=(3–0.95)+(1–0.32)= 4.66</p></blockquote><p id="05ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.因为d(V，N4)是最小距离，所以<strong class="iz hj">胜出节点是N4 </strong>。</p><p id="9b2e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.计算获胜者节点和其他节点之间的距离</p><blockquote class="ma mb mc"><p id="74ba" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">d(N4，N1)= sqrt((0.45–0.95)+(0.89–0.3))= 0.75(&gt; NR)</p><p id="e983" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">d(N4，N2)= sqrt((0.55–0.95)+(0.89–0.32))= 0.648(&gt; NR)</p><p id="9591" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">d(N4，N3)= sqrt((0.62–0.95)+(0.89–0.78))= 0.566(&lt; nr)</p><p id="17e1" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">d(N4,N4) = sqrt ( (0.95–0.95)² + (0.89–0.89)²) = 0 (<nr/></p></blockquote><p id="3fb4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6. Choose nodes to Update weights</p><blockquote class="ma mb mc"><p id="9b01" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">Since d(N4,N3), d(N4,N4) &lt; nr =&gt;N3，N4被选择用于更新它们的权重</p></blockquote><p id="5f77" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">7.使用更新他们的权重</p><blockquote class="mp"><p id="2d7e" class="mq mr hi bd ms mt mu mv mw mx my js dx translated">w(t+1) = w(t) + Q(t) * ර(t) (x-w(t))</p></blockquote><blockquote class="ma mb mc"><p id="27a9" class="ix iy ll iz b ja mz ij jc jd na im jf md nb ji jj me nc jm jn mf nd jq jr js hb bi translated"><strong class="iz hj">更新N3的权重:</strong></p></blockquote><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mg"><img src="../Images/f7da0773b6407174b00d2ab55e6c3765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TzJkt1sRUAvXfMuLOcZ4nw.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图7。作者起草的N3体重更新</figcaption></figure><blockquote class="ma mb mc"><p id="5613" class="ix iy ll iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><strong class="iz hj">更新N4的权重:</strong></p></blockquote><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mg"><img src="../Images/e3b320827002270e81a71761f7eca0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6DQSSh8uxIr18I2Dr5VTA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图8 .更新作者起草的N4的权重</figcaption></figure></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><p id="8d0b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博客中，我们讨论了一个小例子，说明了如何为单个输入添加权重。对每个输入和每个时期的手动计算是复杂的，因此缺乏这种能力。但是我希望任何事情都可以通过一个恰当的例子来解释。希望这个例子能让你对SOM算法及其工作原理有更多的了解。很高兴知道这里的任何问题，并希望在同一博客中添加更多的例子，如果可能的话。</p></div></div>    
</body>
</html>