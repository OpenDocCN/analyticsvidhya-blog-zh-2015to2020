<html>
<head>
<title>Bayesian Optimization Basics (1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">贝叶斯优化基础(1)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/bayesian-optimization-basics-1-30e362119cf?source=collection_archive---------18-----------------------#2020-10-17">https://medium.com/analytics-vidhya/bayesian-optimization-basics-1-30e362119cf?source=collection_archive---------18-----------------------#2020-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b44cac218190c88d4c5b15a74657bc8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmWLl7FJuMdBFQLSWzkyAA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:<a class="ae iu" href="https://pxhere.com/en/photo/1225110" rel="noopener ugc nofollow" target="_blank">https://pxhere.com/en/photo/1225110</a></figcaption></figure><p id="0a7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将基于NIPS 2012年发表的论文《机器学习算法的实用贝叶斯优化》来谈谈几个基本概念。</p><p id="a1fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">内容包括以下内容:</p><ol class=""><li id="2664" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">代理函数和高斯过程。</li><li id="d030" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">采集功能。</li><li id="65d1" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">贝叶斯优化的可能局限性。</li></ol></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="ee30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代理函数和高斯过程。</p><p id="9fdf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">什么是代理函数？“代理人”的意思是“<a class="ae iu" href="https://www.merriam-webster.com/dictionary/surrogate" rel="noopener ugc nofollow" target="_blank">作为替代品的人</a>”。在我们的例子中，由于我们试图优化的函数要么是黑盒函数(如神经网络)，要么是带有隐式参数的东西，因此我们需要使用一些众所周知的函数来表示它们，以便更好地优化。</p><p id="4caa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么有哪些众所周知的函数被用作这些代理函数呢？在大多数情况下，我们使用高斯过程。</p><p id="0d73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么什么是高斯过程呢？</p><p id="368f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">高斯过程是一个随机过程，它具有这样的性质:如果从过程中采样N个点，它将形成一个多元高斯分布。</p><p id="3973" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">典型的高斯过程如下所示，其中蓝色点(样本数据)回归为高斯过程(红色曲线):</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/80e7acb936f08687e1c8befb0f862e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*zYKMLiGj2veKtkiO.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:【https://www.mathworks.com/help/stats/fitrgp.html T4】</figcaption></figure><p id="d27a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用高斯过程作为代理函数，因为GP很好理解，而且它很平滑！</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="2678" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们假设我们可以用一个GP来近似原始函数，那么我们自然会问:达到近似的最好方法是什么？或者另一种提问方式是，如果我们通过迭代生成GP来逼近原函数，那么搜索下一个样本点的方向应该是什么，这样才能加快逼近的速度？再者，是否可以给搜索范围内的所有点一个估计值，这样就可以简单地将值最大的点作为下一个样本点。</p><p id="e5a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是的，这是可能的。因为我们要给搜索范围内的所有点一个估计值，所以我们要定义一个新的函数——获取函数。</p><p id="79ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">NIPS 2012年的这篇论文提到了定义获取函数的3种不同方法:a)改进的概率；b)预期的改进；c) GP置信上限。</p><p id="c3e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里重点说一下改善获取函数的概率。</p><p id="61d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们已经采样了N个具有相应值{y_n}的点{x_n}，那么就有可能估计均值函数</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/60e5f9a3ee44f47a80599a06c9bfc3ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:132/format:webp/1*Ym-uFx-WtEadXqAOV65wAQ.png"/></div></figure><p id="6bee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和方差函数</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/b33b6dcf4f8cf16991ac08d543dc6c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:124/format:webp/1*dNT3eaYSDkj6ybFOfoxgQA.png"/></div></figure><p id="36e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且我们可以定义对应的f(x_best)=argmin f(x_n)</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es kv"><img src="../Images/87b8f21fe6cde75f9c5f182cf9f24b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*8PO0l49QaZQCW8of6y1nuw.png"/></div></figure><p id="eb71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/4d366eedf5c3cff51bd1622478ec21ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*27x6G7kRj9GYZawLrT0M9g.png"/></div></figure><p id="acc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">伽玛函数应该看起来像下面的青色曲线:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/4f066439f5b912263bc04770ba3e7200.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*235IwZpvy-jZvVONFqXyIw.png"/></div></figure><p id="330d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们基于gamma定义采集函数，则alpha(x)=CDF(gamma(x))，看起来像下面的绿色曲线:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/04375e1deff0ab203316bdbb18254dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*Iz4rvg6VmvwdEhvu5sJFMQ.png"/></div></figure><p id="05a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">获取函数给出了接近原点的最大概率改善值，这意味着搜索方向如下</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es kv"><img src="../Images/1aaef79555e19ae4ea717edc9239c9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*3inOvxgPqi_pteDcu6h6oQ.png"/></div></figure><p id="a103" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">生成图形的MATLAB代码可以在<a class="ae iu" href="https://gist.github.com/adoskk/5ca0e0ef146b63ba2c8720a976a2aff2" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这个例子改编自<a class="ae iu" href="https://www.mathworks.com/help/stats/fitrgp.html" rel="noopener ugc nofollow" target="_blank"> MATLAB官网</a>上的原始文档页面。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="217f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们开始使用贝叶斯优化，那么自然会出现问题，这种方法的局限性是什么？如果它是完美的，那么到目前为止每个人都应该在使用它，对吗？</p><p id="6f7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在论文中，作者确实提到了3个主要问题:</p><ol class=""><li id="870c" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">不同的核函数选择和超参数可能会影响结果</li><li id="d0c7" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">在参数空间的不同区域，执行时间可能会有所不同</li><li id="138a" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">并行化问题。</li></ol><p id="172a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不打算在这里深入这些话题，但主要的想法是，贝叶斯优化本身可以进一步优化。特别是当你试图用它来进行深度网络的超参数搜索时，要三思而行，优化方法也有超参数。并行化绝对是一个令人担忧的因素，因为如今人们正在将作业转移到具有多个GPU的集群。</p><p id="0ea0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是希望这篇文章能够阐明一些基本概念，并帮助您更好地理解贝叶斯优化！</p></div></div>    
</body>
</html>