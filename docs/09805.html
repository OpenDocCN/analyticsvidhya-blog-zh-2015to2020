<html>
<head>
<title>Creating Dockerized Flask + MongoDB Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Dockerized Flask + MongoDB应用程序</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-dockerized-flask-mongodb-application-20ccde391a?source=collection_archive---------3-----------------------#2020-09-21">https://medium.com/analytics-vidhya/creating-dockerized-flask-mongodb-application-20ccde391a?source=collection_archive---------3-----------------------#2020-09-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bcc512a4e826e1fbc0145299f4d40643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ccRsJFp3b1q4dOTT5BwYA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">dockered Flask+MongoDB应用程序</figcaption></figure><p id="3fa9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要创建这种涉及两个以上组件的应用程序，我们首先想到的是，我们应该运行一个容器，该容器将暴露Flask server和MongoDB。但在我看来，这不是一个好的设计。这种设计有以下缺点。</p><ul class=""><li id="6615" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">如果容器崩溃，我们将失去Flask server和MongoDB。</li><li id="d1eb" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">访问Flask并且不需要DB操作的前端应用程序将无法工作。</li><li id="cb30" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">访问数据库且不需要Flask server的前端应用程序将无法工作。</li></ul><p id="9c66" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">更好、更优化的设计是拥有两个容器:一个用于Flask server，另一个用于MongoDB，并将拥有Flask server的容器与拥有MongoDB的容器链接起来。这样，我们可以克服第一种设计的一些非常严重的缺点。</p><p id="d273" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你对视觉学习感兴趣，我在我的YouTube频道上制作了一个视频，你可以看看下面。</p><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="kk kl l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">这个博客的YouTube教程</figcaption></figure><p id="ad8e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我们可以把这个应用问题分成两部分:Flask和MongoDB。我们需要创建足够的代码来创建dockerized Flask应用程序和托管在容器中的MongoDB。我们可以独立完成这两件事。最后一步是连接这两个代码。</p><p id="0d34" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，这是实现我们目标的简单路线图:</p><ul class=""><li id="7fb5" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">归档烧瓶应用需要<strong class="iw hj"> <em class="km"> app.py </em> </strong>、<strong class="iw hj"> <em class="km"> requirements.txt </em> </strong>、<strong class="iw hj"> <em class="km"> Dockerfile </em> </strong>等<em class="km"> app.py </em>需要的文件。</li><li id="3350" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">要在容器上托管MongoDB，我们可以从<a class="ae kn" href="https://hub.docker.com/_/mongo" rel="noopener ugc nofollow" target="_blank">这里</a>拉已经存在的mongo映像，此外我们还需要<strong class="iw hj"> <em class="km"> init-db.js </em> </strong>文件，当MongoDB在容器上托管时，我们将在其中编写JavaScript代码来初始化带有一些表的数据库。注意，如果你不想在创建时初始化数据库，这个文件可以是空的。</li><li id="0134" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">我们将用<em class="km"> yml </em>文件连接Flask和MongoDB。所以，我们还需要<strong class="iw hj"><em class="km">docker-compose . yml</em></strong>文件。</li></ul><p id="94bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，事情变得简单了。我们只需要遵循上面的路线图。</p><h1 id="9dcd" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">步骤1:为烧瓶应用程序创建代码库</strong></h1><p id="4400" class="pw-post-body-paragraph iu iv hi iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">这里，我将有一个小Flask应用程序，它将从MongoDB获取动物及其类型。代码如下所示。</p><p id="4717" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可以看一下下面的代码，你可以观察到route<strong class="iw hj"><em class="km">"/</em></strong>只是返回一个字符串，这个字符串只是用来检查代码，route <strong class="iw hj"> <em class="km"> "/animals" </em> </strong>会查询在另一个容器中运行的MongoDB。请注意，我们还没有用MongoDB创建容器，所以这段代码现在无法工作。但是请注意，Flask server将运行在端口<strong class="iw hj"> <em class="km"> 5000 </em> </strong>上，我们假设MongoDB运行在端口<strong class="iw hj"> <em class="km"> 27017 </em> </strong>上。</p><p id="5613" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们还需要<strong class="iw hj"><em class="km">requirements . txt</em></strong>，其中包含<strong class="iw hj"> <em class="km"> app.py </em> </strong>和<strong class="iw hj"> <em class="km"> Dockerfile </em> </strong>在容器中部署Flask app所需的依赖项。</p><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="lr kl l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">箱式烧瓶应用</figcaption></figure><p id="9ec7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当然，您可以根据自己的需求在Flask应用程序中包含一些功能，但是要确保您获取的数据在下面的第二步中被填充到MongoDB中。</p><h1 id="770c" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤2:为在Docker容器上托管MongoDB创建代码库</h1><p id="958f" class="pw-post-body-paragraph iu iv hi iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">在这一步中，我们不需要手动提取mongo的docker映像。我们可以在步骤3的<strong class="iw hj"><em class="km">docker-compose . yml</em></strong>中定义图片的名称。在这一步中，我们只需要创建<strong class="iw hj"> <em class="km"> init-db.js </em> </strong>文件，该文件将在创建MongoDB时预先填充数据。本演示的<strong class="iw hj"> <em class="km"> init-db.js </em> </strong>文件如下所示。</p><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="lr kl l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">初始化数据库</figcaption></figure><p id="4e13" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以看到，我们访问了一个数据库<strong class="iw hj"><em class="km">“animal _ db”</em></strong>，并在这个数据库中初始化了名为<strong class="iw hj"><em class="km">“animal _ TB”</em></strong>的集合，其中包含3个元素。</p><h1 id="9c89" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">第三步:创建docker-compose.yml文件链接上述组件并部署</strong></h1><p id="bc64" class="pw-post-body-paragraph iu iv hi iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">我们需要创建<strong class="iw hj"><em class="km">docker-compose . yml</em></strong>文件，我们将在其中定义链接组件的详细信息，以及在上面两个步骤中创建的代码库所需的信息。示例<strong class="iw hj"><em class="km">docker-compose . yml</em></strong>文件如下所示。</p><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="lr kl l"/></div></figure><p id="6db9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你遵守上面的代码。我们有一个应用程序，其中我们定义了一个命令来运行该应用程序。此外，我们已经将<strong class="iw hj"> <em class="km"> db </em> </strong>与app链接，其中<strong class="iw hj"> <em class="km"> db </em> </strong>在上述代码的后面部分定义，这就是我们的MongoDB。</p><p id="846f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们已经给出了MongoDB图像的名称，它需要从docker-hub中提取。这里注意，您可以更改<strong class="iw hj"> <em class="km">主机名</em> </strong>和<strong class="iw hj"> <em class="km">环境</em> </strong>，但请确保在步骤1中创建的<strong class="iw hj"> <em class="km"> app.py </em> </strong>和步骤2中创建的<strong class="iw hj"> <em class="km"> init-db.js </em> </strong>中进行相同的更改。</p><p id="a265" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，请注意，我们已经为app  公开了<strong class="iw hj"> <em class="km">端口5000，为db </em> </strong>公开了<strong class="iw hj"> <em class="km">端口27017，因为我们在Flask app代码中使用了相同的端口。</em></strong></p><p id="73aa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们离部署整个应用程序只差一个命令了。运行下面的命令，直到所有的东西都部署完毕。</p><p id="7983" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">$ docker-撰写</p><p id="29c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Flask + MongoDB应用程序已部署，您可以访问Flask应用程序，如下所述。</p><p id="2500" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你运行的是docker desktop，那么你可以通过<a class="ae kn" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000/ </a>访问flask app，但是如果你已经安装了docker with virtual-machine，那么你首先需要获得docker-machine的IP。你可以通过执行命令“docker-machine default ip”来实现。这里，default是docker-machine的名称。现在可以用网址http://&lt;docker-machine-IP&gt;:5000/访问flask app了。</p><p id="bb26" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你想要完整项目的代码，你可以在GitHub库<a class="ae kn" href="https://github.com/ashutosh1919/flask_mongodb_dockerized_app" rel="noopener ugc nofollow" target="_blank">这里</a>获得代码。</p><p id="7d33" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢你阅读这篇博客。</p></div></div>    
</body>
</html>