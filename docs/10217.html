<html>
<head>
<title>Indian Number Plate Detection using OpenCV &amp; Pytesseract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 OpenCV &amp; Pytesseract 检测印度车牌</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/indian-license-plate-detection-using-opencv-pytesseract-ee347d2ff8f7?source=collection_archive---------19-----------------------#2020-10-09">https://medium.com/analytics-vidhya/indian-license-plate-detection-using-opencv-pytesseract-ee347d2ff8f7?source=collection_archive---------19-----------------------#2020-10-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/43b47167344634ee76dacea85eb45fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4eReD4iAaYwBbMLNNzkmQ.png"/></div></div></figure><p id="965f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">有了这个循序渐进的教程，你将能够接受用户的图像，检测车牌，然后识别写在车牌上的文字。在本教程中，我们将使用一些库:</p><p id="8a72" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">OpenCV(用于基本图像处理)</p><p id="316e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Pytesseract(用于从图像中提取文本)</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="c73a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">首先:确保你有一个清晰的图像，以便正确提取车牌</p><p id="adf2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">为了尽可能准确地处理图像，我们需要将图像转换成灰度。这可以通过以下方式轻松实现:</p><pre class="in io ip iq fd jw jx jy jz aw ka bi"><span id="adc1" class="kb kc hi jx b fi kd ke l kf kg">image = cv2.imread(image_path)<br/>gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span></pre><p id="310a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">为了让我们的步骤更直观，一个显示我们前进过程的功能可能会派上用场。这个功能所做的就是以并排的方式显示照片，这样更容易跟踪进度。(注:这部分绝对可选)</p><pre class="in io ip iq fd jw jx jy jz aw ka bi"><span id="25f9" class="kb kc hi jx b fi kd ke l kf kg">def plot_images(img1, img2, title1="", title2=""):<br/>    fig = plt.figure(figsize=[15,15])<br/>    ax1 = fig.add_subplot(121)<br/>    ax1.imshow(img1, cmap="gray")<br/>    ax1.set(xticks=[], yticks=[], title=title1)</span><span id="2318" class="kb kc hi jx b fi kh ke l kf kg">ax2 = fig.add_subplot(122)<br/>    ax2.imshow(img2, cmap="gray")<br/>    ax2.set(xticks=[], yticks=[], title=title2)</span></pre><p id="39a1" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">所以我们可以看到这样的图像:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/269006c22aa60b6c079be4655094e24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8K2Q-VuTTOzW1AUljTwFbw.png"/></div></div></figure><p id="acbe" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在，我们需要平滑图像，但我们同时需要确保边缘完好无损。OpenCV 中有一个函数可以做到这一点:<code class="du ki kj kk jx b">cv2.bilateralFilter(img, d, sigmaColor1, sigmaColor2)</code>其中 d 是它周围每个像素的直径。</p><p id="abec" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">借助 OpenCV 中的 Canny，我们可以很容易地从图像中检测出边缘。这借助于给定像素周围的 BGR 的差异而发生。在这之后，图像应该看起来像这样:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es kl"><img src="../Images/32e4aba03da6597ba6801d1a2904e66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0lD9Qz-se6hr88Zg4FbjQ.png"/></div></div></figure><p id="078b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在我们有了边缘，让我们把它们转换成轮廓(轮廓基本上是连接沿着图像边界具有相同强度的所有点的线)。这是通过 findContours()函数实现的，该函数将边作为参数。如果我们要找出一条直线的轮廓。我们只需要这条线的两个端点。这就是<code class="du ki kj kk jx b">cv2.CHAIN_APPROX_SIMPLE</code>的作用。它删除所有冗余点并压缩轮廓，从而节省内存。</p><pre class="in io ip iq fd jw jx jy jz aw ka bi"><span id="8abc" class="kb kc hi jx b fi kd ke l kf kg">cnts, new = cv2.findContours(edges.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)</span></pre><p id="5b9c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">轮廓应该是这样的:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es kl"><img src="../Images/c7d35917288f76d7093985b6100c5e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZQjX7q8EDagp4bAsNTm8A.png"/></div></div></figure><p id="47a7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">由于我们可以清楚地看到轮廓，让我们使用 drawContours()将它们绘制到我们的图像上。我们在这里所要做的就是在第二个参数中传递-1，以表明我们想要绘制所有检测到的轮廓:</p><pre class="in io ip iq fd jw jx jy jz aw ka bi"><span id="01f5" class="kb kc hi jx b fi kd ke l kf kg">_ = cv2.drawContours(image_copy, cnts, -1, (255,0,255),2)</span></pre><p id="e9fe" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">轮廓的坐标现在已经存储，我们需要做的就是用存储的坐标裁剪图像，瞧！我们有车牌。</p><pre class="in io ip iq fd jw jx jy jz aw ka bi"><span id="2f9c" class="kb kc hi jx b fi kd ke l kf kg">plate = None<br/>for c in cnts:<br/> perimeter = cv2.arcLength(c, True)<br/> edges_count = cv2.approxPolyDP(c, 0.02 * perimeter, True)<br/> if len(edges_count) == 4:<br/> x,y,w,h = cv2.boundingRect(c)<br/> plate = image[y:y+h, x:x+w]<br/> break</span><span id="3b3c" class="kb kc hi jx b fi kh ke l kf kg">cv2.imwrite(“plate.png”, plate)</span></pre><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es km"><img src="../Images/f0c7e053f4d7fb2bce60ff71c0cf919e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGhvzBG8d59MqYmUM8KMqA.png"/></div></div></figure><p id="9172" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们还需要从 pytesseract 支持的图像中提取文本:</p><pre class="in io ip iq fd jw jx jy jz aw ka bi"><span id="1a1b" class="kb kc hi jx b fi kd ke l kf kg">text = p.image_to_string(plate, lang=”eng”)</span></pre><h1 id="8d7e" class="kn kc hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">正文:MH20EJ0365</h1><p id="cea0" class="pw-post-body-paragraph iy iz hi ja b jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv hb bi translated">希望这篇教程在某种程度上帮助了你，现在你对我们如何在它们的帮助下找到轮廓和探测物体有了更清晰的理解。</p><p id="82a9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">为了你的参考，我在下面也提到了我的 GitHub 链接，你可以随意浏览整个代码来更清楚地理解它。</p><p id="115e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae lp" href="https://github.com/kunjshah2511/License-Plate-Detection" rel="noopener ugc nofollow" target="_blank">T3【https://github.com/kunjshah2511/License-Plate-Detection】T5</a></p></div></div>    
</body>
</html>