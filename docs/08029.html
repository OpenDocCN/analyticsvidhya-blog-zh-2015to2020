<html>
<head>
<title>COBOL vs. Python — A sort battle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">COBOL vs . Python——一场排序战</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cobol-vs-python-a-sort-battle-b23bc1d5fcf4?source=collection_archive---------11-----------------------#2020-07-15">https://medium.com/analytics-vidhya/cobol-vs-python-a-sort-battle-b23bc1d5fcf4?source=collection_archive---------11-----------------------#2020-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="03dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python是一种编码语言，虽然它在20世纪80年代就已经出现了，但在过去的几十年里取得了巨大的成功，而另一方面，COBOL(有些人可能甚至没有听说过)是在20世纪50年代创立的。</p><p id="cfe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两种开发软件的格式非常不同，使用它们的人也是如此。Python主要用于开源系统和各种初创企业，而COBOL是一种企业语言，主要用于大型银行、汽车和零售公司。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><blockquote class="jk jl jm"><p id="5a09" class="if ig jn ih b ii ij ik il im in io ip jo ir is it jp iv iw ix jq iz ja jb jc hb bi translated"><strong class="ih hj">COBOL简史</strong></p><p id="c574" class="if ig jn ih b ii ij ik il im in io ip jo ir is it jp iv iw ix jq iz ja jb jc hb bi translated">因为大多数读者可能熟悉Python。COBOL是一种编译的、自顶向下的过程化编程语言，主要用于大型机上，这些大型机为高度关键的系统提供动力，如银行业、许多财富500强公司，甚至NASA。尽管COBOL已经有70多年的历史了，但我坚信它仍然是一种很好的编码和工作语言，因为它很容易理解(像英语一样),并且仍然有超过500亿行代码是用COBOL运行的。每当你刷卡时，COBOL和大型机很可能是后端处理你的数据，以确保你不必在咖啡店排队时多等一秒钟。</p></blockquote><p id="4b84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，为了证实我的上述观点，我将COBOL与21世纪最流行、最广泛使用的语言之一(显然是Python)进行对比。这里的测试是在不同的时间复杂度水平上采用一些排序算法，并在COBOL和Python中运行它们，看看谁领先。我会支持COBOL。你呢。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><ol class=""><li id="aa3c" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated"><strong class="ih hj">插入排序</strong></li></ol><p id="6417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是继冒泡排序之后最简单的排序算法之一。我选择了这种方式，因为它比冒泡排序更快，而且对于一个巨大的数据集来说并不可取。但是，我们将立即忽略这一点，并在两个系统上运行它，数据集有十万行(100，000)未排序，等待它排序并写入输出文件供我们验证。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ka"><img src="../Images/55f95f1edb213d9e3e858d26e1826350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yUgPSvb3Yt8iAdgmspAXQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">插入排序— COBOL性能</figcaption></figure><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kq"><img src="../Images/4b1f4d14005d0419d39bba0d83bd170a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9wBb02w4-Pj6rPnHQvkzQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">插入排序— Python性能</figcaption></figure><p id="914b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我猜它是COBOL 1和Python 0。由于这种类型在处理大量数据时具有最糟糕的时间复杂性，所以两个程序都需要很长时间来运行</p><p id="847f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">贝壳分类</strong></p><p id="436f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">外壳排序是一种更有效的算法，其中在间隙中应用插入排序以减少由于插入排序所做的大量交换而造成的性能影响。因为shell sort可以处理更多的记录，所以我将输入数据从100，000增加到100万。从现在开始，一百万将是两种语言的基线。但是请注意，两个竞争者必须处理相同数量的记录。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kr"><img src="../Images/b01e90854ce355b8d481e56f177d37fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sA4XNcQ-1iADPphB3bjizA.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">Shell排序— COBOL性能</figcaption></figure><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ks"><img src="../Images/37b51ea88c2405861ee71c234404edb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLcExSc_g1emZE6BfC2jEg.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">外壳排序— Python性能</figcaption></figure><p id="7ee9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该死，太接近了，Python以不到半秒的优势赢了。但不管怎样，比分是1比1。</p><p id="7171" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj">快速排序</strong></p><p id="29e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与shell sort相比，Quicksort是一种更省时的处理大型数据集的方法。它的工作方式是从数组中选择一个“pivot”元素，并根据其他元素是小于还是大于pivot将它们划分为两个子数组。然后对子数组进行递归排序。我用COBOL语言写了一个球。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kr"><img src="../Images/9d12c9afe07436d1dbb91e7feb2c6b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEa4t1fq5yoOJFd7IeKxQg.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">快速排序— COBOL性能</figcaption></figure><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kt"><img src="../Images/33aa586a5882d5665c8bf41fe9c22023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnpLql4SSF2FZeZ9wi61ww.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">快速排序— Python性能</figcaption></figure><p id="6129" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python再次领先于COBOL半秒。Python 2，COBOL 1。对一个大了30岁的人来说还是如此接近。</p><p id="750f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.<strong class="ih hj"> DF排序与df.sort_values </strong></p><p id="3566" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而不是合并或堆排序。我想我可以尝试一些不同的东西来演示股票可用的方法如何帮助快速排序数据集，而不是为此编写自己的代码。</p><p id="3c59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将使用DF sort(一种基于JCL(作业控制语言)的排序方法，这种方法适用于(几乎)所有大型机安装和df.sort_values，这是Python中一种现成的数据帧排序方法，它使用Timsort(插入和合并排序的组合，用于对列表中的元素进行排序)</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ku"><img src="../Images/24e83fc61cc576c9ae93428d63a4c722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9tuifcR8umAwHAq7ng1IA.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">DF排序—大型机性能</figcaption></figure><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kv"><img src="../Images/7afa4a46652df414fb39c3944c2d8d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZIp16byrNuKA8Sta1QorRw.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">df . sort _ values()-Python性能</figcaption></figure><p id="9700" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DF排序刚刚在这里创建了DF . Sort _ values<strong class="ih hj">T3，它完成的时间不到数据帧方法的十分之一。女士们先生们，我想我们打成平手了(这不是我想要的结果)。但是，你仍然不得不把它交给COBOL，它离Shell和Quicksort不远。</strong></p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="eefe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是对每一个方面的总结。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kw"><img src="../Images/af303b8704e2ccd5f6b4f7d1e5d7e25c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KbYG_Ya_8lffPjsCI6PLCA.png"/></div></div></figure><p id="653b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，我想最快的是那些我们没有编写任何代码，只是使用已经可用的工具(机器人起义？).这是否意味着我是一个糟糕的程序员，或者只是股票方法只是使用更快的方法来排序？。无论如何，在某些情况下，我们可能需要编写自己的方法/过程来排序和定制给定的数据。</p><p id="15c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>这并不是对COBOL和Python中所有可用排序方法的全面分析，可能有方法可以提高这两个领域的效率(希望大家对此有所贡献)。</p></div></div>    
</body>
</html>