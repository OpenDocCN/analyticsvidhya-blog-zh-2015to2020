<html>
<head>
<title>Demystifying Markov Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开马尔可夫聚类的神秘面纱</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/demystifying-markov-clustering-aeb6cdabbfc7?source=collection_archive---------2-----------------------#2019-08-25">https://medium.com/analytics-vidhya/demystifying-markov-clustering-aeb6cdabbfc7?source=collection_archive---------2-----------------------#2019-08-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="417c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">介绍马尔可夫聚类算法，以及它如何成为一个真正有用的无监督聚类工具。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/17b428392e7e6058089997af1a214cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a0kCyolXJ5tHKC7Y"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">克林特·王茂林在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="b048" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated">介绍</h1><p id="f74a" class="pw-post-body-paragraph kn ko hi kp b kq kr ij ks kt ku im kv kw kx ky kz la lb lc ld le lf lg lh li hb bi translated">在数据科学的巨大海洋世界中，人们可能会遇到集群岛。当谈到无监督学习和跨数据发现模式时，聚类是最古老和最广泛使用的技术。</p><p id="8633" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">在这篇博客中，我们将谈论一个具体的和一点点的利基，如果你会说，被称为MCL或马尔可夫聚类。在接下来的参考文献中，我将马尔可夫聚类称为MCL。</p><p id="5b41" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">MCL与其他聚类算法的真正区别在于，它帮助你在现有节点中检测社区，因为它是无监督的，它不需要你的任何输入来形成聚类，不像K-means算法和其他算法。当涉及到网络数据、社交网络数据或者相似性检测时，这确实使得该算法至关重要。</p><p id="bd76" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">通常集群分为两个主要部分:</p><ol class=""><li id="b451" class="lo lp hi kp b kq lj kt lk kw lq la lr le ls li lt lu lv lw bi translated">向量聚类和</li><li id="1a7d" class="lo lp hi kp b kq lx kt ly kw lz la ma le mb li lt lu lv lw bi translated">图形聚类可以自己讲述自己的故事。</li></ol><p id="6ad4" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">MCL是一种图聚类，所以你必须了解一点图论，但不要太花哨。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="da46" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated">一点图论知识</h1><p id="86fc" class="pw-post-body-paragraph kn ko hi kp b kq kr ij ks kt ku im kv kw kx ky kz la lb lc ld le lf lg lh li hb bi translated">如果让我用简单明了的术语来解释一个图，那就是:<em class="mc">图是一组向量和边，表示为G = (V，E ),其中V = {v1，v2，v3…vn}即n个向量，E = {e1，e2，e3…em}有m条边。如果顶点vi和vj是边的端点，那么当没有歧义时，我们用有序对(vi，vj)来表示该边。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es md"><img src="../Images/3a13c948be2447eec49c951d6eee6ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*KxXDIOrwx-T7T78UlS3xBQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">简单未加权图</figcaption></figure><p id="e573" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">虽然上面显示的图是一个简单的未加权图，我们将在前面的MCL算法中使用加权图。加权图只不过是一个信息量更大的图，它告诉你访问下一个节点的概率，或者一个节点到另一个节点的距离，或者一个节点对另一个节点的依赖性。</p><p id="cf26" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">一般来说，为了存储这样的信息，我们使用邻接图矩阵，如果你想知道的话，这将在后面解释。对于MCL，这就是你需要知道的一切..参见easy-peay。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="bfeb" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated">随机漫步和马尔可夫链</h1><p id="b6bc" class="pw-post-body-paragraph kn ko hi kp b kq kr ij ks kt ku im kv kw kx ky kz la lb lc ld le lf lg lh li hb bi translated">随机漫步是MCL的核心，所以让我们用一个简单的例子来理解它。如果你还记得旅行推销员问题，这个问题比那个问题更随机，但是思路是一样的。</p><p id="bc7f" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">所以，想想旅行者山姆——真正的旅行家住在伦敦的一个城市，想要环游世界。把城市想象成我们图表中的节点，把边想象成人们可以从一个城市旅行到另一个城市。如果两个城市之间没有边界，就不可能去那个城市旅行，就这么简单。</p><p id="95c6" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">随着他随意的想法，山姆没有做计划，出去了。因此，根据一个假设的n面骰子，萨姆选择去他想去的城市。这个过程在数学上被称为<strong class="kp hj">随机过程或随机过程</strong>，这将描述前方随机路径的路径。这被称为随机漫步。</p><p id="165e" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">现在，来看马尔可夫链，</p><blockquote class="me mf mg"><p id="c263" class="kn ko mc kp b kq lj ij ks kt lk im kv mh ll ky kz mi lm lc ld mj ln lg lh li hb bi translated">马尔可夫链是一个系统，其中下一个状态基于某种概率或规则依赖于当前状态。</p></blockquote><p id="ef0d" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">在任何时间点，当前状态完全由上一个状态决定，而不管它是如何到达的。简单来说就是<em class="mc">马尔可夫链</em>。最后，我们计算基于“马尔可夫链”的随机图。这背后的直觉是，随机性不是完全随机的，在一个城市，Sam访问附近城市的概率大于访问非常远的城市。还在迷茫？看看下面的例子..</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mk"><img src="../Images/529b68b9b84427eb200f307dc0a03980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wk7guD_v6HmuJu6mZMyW7Q.jpeg"/></div></div></figure><p id="65c5" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">如上图所述，这就是我们如何得到第一时间步的转移矩阵或概率矩阵。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="0179" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated">通货膨胀和扩张</h1><p id="b535" class="pw-post-body-paragraph kn ko hi kp b kq kr ij ks kt ku im kv kw kx ky kz la lb lc ld le lf lg lh li hb bi translated">为了实现MCL，我们需要考虑两个重要的操作，即通货膨胀和经济扩张。</p><h2 id="f2a6" class="ml jw hi bd jx mm mn mo kb mp mq mr kf kw ms mt kh la mu mv kj le mw mx kl my bi translated"><strong class="ak">通货膨胀:</strong></h2><ul class=""><li id="4e25" class="lo lp hi kp b kq kr kt ku kw mz la na le nb li nc lu lv lw bi translated">在膨胀操作下，对于每个顶点，转变值被改变，使得强邻居值被加强，而大邻居值被降级。这可以通过将列值提高到非负幂，然后重新归一化来实现。</li><li id="7940" class="lo lp hi kp b kq lx kt ly kw lz la ma le mb li nc lu lv lw bi translated">例如，取膨胀算子为2。因此，对列中的每个元素求平方，然后对值进行归一化。</li><li id="c898" class="lo lp hi kp b kq lx kt ly kw lz la ma le mb li nc lu lv lw bi translated">膨胀算子负责电流的增强和减弱。(加强强电流，并削弱已经<br/>弱电流)。最后，这会影响集群的粒度。</li></ul><h2 id="6003" class="ml jw hi bd jx mm mn mo kb mp mq mr kf kw ms mt kh la mu mv kj le mw mx kl my bi translated"><strong class="ak">扩展:</strong></h2><ul class=""><li id="5822" class="lo lp hi kp b kq kr kt ku kw mz la na le nb li nc lu lv lw bi translated">扩展有助于使更远的节点或邻居可达。这在数学上是通过取矩阵的n次方来实现的。这个值，扩展运算符“e”是在实现时选择的。</li><li id="0d19" class="lo lp hi kp b kq lx kt ly kw lz la ma le mb li nc lu lv lw bi translated">例如，取e=2，取矩阵的2次方为A。对于取n次方，我们需要另一个博客，因为它需要计算本征向量、本征值和对角矩阵来计算n次方，如果需要，我会解释。</li><li id="48b6" class="lo lp hi kp b kq lx kt ly kw lz la ma le mb li nc lu lv lw bi translated">扩展运算符负责允许流连接图形的不同区域。</li></ul></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="57d6" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated">MCL算法…终于</h1><p id="b082" class="pw-post-body-paragraph kn ko hi kp b kq kr ij ks kt ku im kv kw kx ky kz la lb lc ld le lf lg lh li hb bi translated">如果你到目前为止都做得很好，那就完成了一半以上的工作。好的，让我们直接进入正题。MCL的步骤:</p><ul class=""><li id="e007" class="lo lp hi kp b kq lj kt lk kw lq la lr le ls li nc lu lv lw bi translated">输入将是一个无向图，功率参数<strong class="kp hj"> e </strong>和充气参数<strong class="kp hj"> r </strong>。</li><li id="e40e" class="lo lp hi kp b kq lx kt ly kw lz la ma le mb li nc lu lv lw bi translated">通过创建关联矩阵来计算马尔可夫矩阵或概率矩阵。这里需要注意的一点是，我们需要通过归一化邻接矩阵来获得马尔可夫矩阵。</li><li id="ad17" class="lo lp hi kp b kq lx kt ly kw lz la ma le mb li nc lu lv lw bi translated">一旦获得了马尔可夫矩阵，就可以通过交替两个操作来模拟随机游走，这两个操作就是上面解释的<strong class="kp hj">膨胀</strong>和<strong class="kp hj">膨胀</strong>。</li><li id="255b" class="lo lp hi kp b kq lx kt ly kw lz la ma le mb li nc lu lv lw bi translated">第一步:使用“e”参数展开矩阵。</li><li id="6a55" class="lo lp hi kp b kq lx kt ly kw lz la ma le mb li nc lu lv lw bi translated">步骤j:使用“r”参数膨胀结果矩阵。</li><li id="1fcd" class="lo lp hi kp b kq lx kt ly kw lz la ma le mb li nc lu lv lw bi translated">重复步骤I和j，直到收敛(即达到值的平衡或没有观察到明显的值变化)。</li><li id="0067" class="lo lp hi kp b kq lx kt ly kw lz la ma le mb li nc lu lv lw bi translated">解释结果以获得聚类。</li></ul><h1 id="1d21" class="jv jw hi bd jx jy nd ka kb kc ne ke kf io nf ip kh ir ng is kj iu nh iv kl km bi translated">瞧啊。MCL准备好了！</h1><p id="fce1" class="pw-post-body-paragraph kn ko hi kp b kq kr ij ks kt ku im kv kw kx ky kz la lb lc ld le lf lg lh li hb bi translated">新鲜烹制的MCL可以和一些可见的串一起食用。如果你想从头开始写马尔可夫聚类，这应该不是什么大问题，但是一定要添加自循环以获得更好的收敛性。如果你想知道是否有可用的东西，确实有一个python包<a class="ae jn" href="https://pypi.org/project/markov-clustering/" rel="noopener ugc nofollow" target="_blank"> markov-clusterin </a> g可以帮助你。如果您从未使用过networkx，您可能也需要看看它，这是一个python包，它使得图形操作更容易编写。</p><p id="3a1a" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">最后看一下下面的代码，看看python中同样的实现。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ni nj l"/></div></figure><p id="08a1" class="pw-post-body-paragraph kn ko hi kp b kq lj ij ks kt lk im kv kw ll ky kz la lm lc ld le ln lg lh li hb bi translated">如果你已经走了这么远，感谢你的耐心。如果你从博客中学到了什么，非常感谢，或者如果你有任何问题，请大声说出来。再见..！！</p></div></div>    
</body>
</html>