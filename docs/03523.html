<html>
<head>
<title>Coding the Impossible: Palindrome Detector with a Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写不可能的代码:带正则表达式的回文检测器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/coding-the-impossible-palindrome-detector-with-a-regular-expressions-cd76bc23b89b?source=collection_archive---------2-----------------------#2020-02-06">https://medium.com/analytics-vidhya/coding-the-impossible-palindrome-detector-with-a-regular-expressions-cd76bc23b89b?source=collection_archive---------2-----------------------#2020-02-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/69f6e83f4149bbf1755916de0a6ff006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PnWWJ9SKKdYf4mo2Az4Kbw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">安德烈·木桐在<a class="ae iu" href="https://unsplash.com/s/photos/mirror?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c171" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我遇到了一个<a class="ae iu" href="https://stackoverflow.com/questions/233243/how-to-check-that-a-string-is-a-palindrome-using-regular-expressions" rel="noopener ugc nofollow" target="_blank">堆栈溢出问题</a>，它询问如何使用正则表达式检查一个字符串是否是回文。有147张赞成票的顶级答案指出这是<strong class="ix hj">不可能的</strong>，所以甚至没有尝试的意义。从技术上讲，他对任意长度的回文是对的，但这并不意味着我们不能对最大长度的回文做一个。顺便说一句，有更简单的方法来检查回文，例如反转字符串并将其与原始字符串进行比较。所以何必呢？为了智力挑战和锻炼我的正则表达式技能。我想让它处理我最喜欢的回文:“一个人，一个计划，一条运河，巴拿马！”所以我写了一个正则表达式来检测多达22个字符的回文，忽略制表符、空格、逗号和引号。我使用JavaScript风格的正则表达式。</p><p id="f60c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是解决方案</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="1c5a" class="kc kd hi jy b fi ke kf l kg kh">\b(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*\11?[ \t,'"]*\10|\10?)[ \t,'"]*\9|\9?)[ \t,'"]*\8|\8?)[ \t,'"]*\7|\7?)[ \t,'"]*\6|\6?)[ \t,'"]*\5|\5?)[ \t,'"]*\4|\4?)[ \t,'"]*\3|\3?)[ \t,'"]*\2|\2?))?[ \t,'"]*\1\b</span></pre><p id="2331" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能在想，要么是一只猫在我的键盘上走过，要么这是用某种早已被遗忘的语言召唤克苏鲁的秘密咒语。不，它实际上是一个有效的正则表达式。请随意使用<a class="ae iu" href="http://regexr.com/4tmui" rel="noopener ugc nofollow" target="_blank">regexr.com</a>来检查它，这是一个很棒的工具，可以立即看到你的正则表达式的结果，并解释了每个部分的作用。我会告诉你我是怎么做到的，这样就说得通了。</p><p id="cf03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们需要检测一个字符是否重复。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="12f4" class="kc kd hi jy b fi ke kf l kg kh">(.)\1</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es ki"><img src="../Images/285073e400820aa376c8ad17d3173196.png" data-original-src="https://miro.medium.com/v2/resize:fit:110/format:webp/1*25OPcJavnsaU18vU6PZCDw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">匹配正则表达式的文本被突出显示。</figcaption></figure><p id="d297" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很简单。两个字重复？<em class="kj">新零件以</em> <strong class="ix hj">粗体<em class="kj">显示。</em>T15】</strong></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f1f7" class="kc kd hi jy b fi ke kf l kg kh">Old: (.)     \1<br/>New: (.)<strong class="jy hj">(.)\2</strong>\1</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/494e8573e8b23a545d367ab8a782e7b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:118/format:webp/1*mo17xUMZvt6g0UDaZAXDkw.png"/></div></figure><p id="074e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的，这只适用于长度正好为4个字符的回文。如果第二次回看是可选的，我们可以用3个字符的回文来实现它。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="8907" class="kc kd hi jy b fi ke kf l kg kh">Old: (.)(.)\2 \1<br/>New: (.)(.)\2<strong class="jy hj">?</strong>\1</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/fb62d4f50431eea2b4511611fc1d7865.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/format:webp/1*EWIJeYo-OPq59aiyBHYuJw.png"/></div></figure><p id="97d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">酷，现在我们可以让它为2个字符串工作，让内部部分可选。<em class="kj">把(？:…)创建非捕获组。</em></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c701" class="kc kd hi jy b fi ke kf l kg kh">Old: (.)   (.)\2?  \1<br/>New: (.)<strong class="jy hj">(?:</strong>(.)\2?<strong class="jy hj">)?</strong>\1</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es km"><img src="../Images/36334b525edc662e9ed4cbd66500aa78.png" data-original-src="https://miro.medium.com/v2/resize:fit:122/format:webp/1*mzjDU17u0M9Ua_AWZcKlWg.png"/></div></figure><p id="68d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们进展顺利，继续吧。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="045d" class="kc kd hi jy b fi ke kf l kg kh">Old: (.)(?:(.)           \2?)?\1<br/>New: (.)(?:(.)<strong class="jy hj">(?:(.)\3?)?</strong>\2)?\1</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kn"><img src="../Images/5b54e897781e58faf9e340aeaf23f763.png" data-original-src="https://miro.medium.com/v2/resize:fit:142/format:webp/1*QkYBBFsyJNEBC8HipTSiHQ.png"/></div></figure><p id="153a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">啊哦…我们设法检测到5和6个字符串，但是我们丢失了3个字符串。问题是<strong class="ix hj"> \2 </strong>不是可选的，例如，当<strong class="ix hj"> aba </strong>到达第三个字符时，它在寻找第二个<strong class="ix hj"> b </strong>字符，但没有找到。这仍然是一个有效的回文，因为<strong class="ix hj"> b </strong>正好在字符串的中间。所有奇数长度的回文中间都有一个不重复的字符。我们能修好它。让我们使<strong class="ix hj"> \2 </strong>可选！</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="8da8" class="kc kd hi jy b fi ke kf l kg kh">Old: (.)(?:(.)(?:(.)\3?)?\2 )?\1<br/>New: (.)(?:(.)(?:(.)\3?)?\2<strong class="jy hj">?</strong>)?\1</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/88b4c53da2f7bb779d1dcc228c113416.png" data-original-src="https://miro.medium.com/v2/resize:fit:132/format:webp/1*7jzVKb2VGmrwAHEBNY8WUg.png"/></div></figure><p id="a191" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">耶！等等…现在<strong class="ix hj"> abca </strong>是假阳性🤦。这是最棘手的一点。如果你准备迎接一个挑战，在向下滚动查看答案之前，花一点时间想一想你会如何解决它。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/997ff779bd23ea33f2aa40cb3de93769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_SgJRRlbYqowMus-RPYBA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Juan Rumimpunu 在<a class="ae iu" href="https://unsplash.com/s/photos/thinking?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c3f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们真的希望可以用if语句将<strong class="ix hj"> \2 </strong>替换为<strong class="ix hj"> \2？</strong>只有在没有<strong class="ix hj"> \3 </strong>的情况下，但是regex没有if语句…但是，它有一个OR运算符，我们可以用它来得到相同的结果。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="a042" class="kc kd hi jy b fi ke kf l kg kh">Old: (.)(?:(.)(?:(.)\3?)? \2? )?\1<br/>New: (.)(?:(.)(?:(.)\3?<strong class="jy hj">\2|</strong>\2?)<strong class="jy hj">)</strong>?\1</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kn"><img src="../Images/6c1245d6c90e25d12f74bca656dcaab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:142/format:webp/1*4_OdEsGVJh_O300vRzBESQ.png"/></div></figure><p id="82d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">头奖！这是一个微妙的变化，使所有的差异。还是我有<strong class="ix hj">(。)\3?\2 </strong>意思是“如果有一个新的内部字符(或两个相同的)，我们必须重复第二组”，另一边是<strong class="ix hj"> \2？</strong>这意味着“如果没有新的内部字符，可选地重复第二组。”第二种情况表明我们现在正处于回文的中间，所以只有一个中间字符是可以的，或者有两个。这就是我们需要<strong class="ix hj">的原因？</strong>。否则，组2必须存在，它才是有效的回文。我们能继续吗？没错。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="faf5" class="kc kd hi jy b fi ke kf l kg kh">Old: (.)(?:(.)(?:(.)            \3? \2|\2?))?\1<br/>New: (.)(?:(.)(?:(.)<strong class="jy hj">(?:(.)\4?\3|\3?)</strong>\2|\2?))?\1</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/02cb9d121c19022f3a62afe75e430ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:168/format:webp/1*OA4hm3APEF-siaOIx04ssQ.png"/></div></figure><p id="98a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不错！我干脆把<strong class="ix hj"> \3换掉？</strong>同<strong class="ix hj">(？:(.)\4?\3|\3?)</strong>，和之前的逻辑一样。现在我们可以不断替换内部组来制作任意长度的正则表达式回文检测器！唯一的问题是正则表达式的长度也会不断增长，因为我们不能在正则表达式中写循环。让我们做一个足够大的来检测我的目标句子。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5e12" class="kc kd hi jy b fi ke kf l kg kh">(.)(?:(.)(?:(.)(?:(.)(?:(.)(?:(.)(?:(.)(?:(.)(?:(.)(?:(.)(?:(.)\11?\10|\10?)\9|\9?)\8|\8?)\7|\7?)\6|\6?)\5|\5?)\4|\4?)\3|\3?)\2|\2?))?\1</span></pre><p id="85f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管regex中没有忽略空白，我还是添加了新的行和缩进来使这种混乱更容易阅读，但是请记住顶部的表达式是有效的。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="eee9" class="kc kd hi jy b fi ke kf l kg kh">(.)(?:<br/>  (.)(?:<br/>    (.)(?:<br/>      (.)(?:<br/>        (.)(?:<br/>          (.)(?:<br/>            (.)(?:<br/>              (.)(?:<br/>                (.)(?:<br/>                  (.)(?:<br/>                    (.)\11?\10|\10?)<br/>                  \9|\9?)<br/>                \8|\8?)<br/>              \7|\7?)<br/>            \6|\6?)<br/>          \5|\5?)<br/>        \4|\4?)<strong class="jy hj"><br/>      </strong>\3|\3?)<br/>    \2|\2?))?<br/>\1</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/2a05d895397c5a454fae921bacd1a6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*oNQ1TeuO8na5EafoZMPIzw.png"/></div></figure><p id="2bb0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有用！现在困难的部分已经完成了。为了庆祝胜利，我们让回文字符只包含字母数字和独立的单词。我使用了不区分大小写的标志。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="4ca9" class="kc kd hi jy b fi ke kf l kg kh">\b(\w)(?:(\w)(?:(\w)(?:(\w)(?:(\w)(?:(\w)(?:(\w)(?:(\w)(?:(\w)(?:(\w)(?:(\w)\11?\10|\10?)\9|\9?)\8|\8?)\7|\7?)\6|\6?)\5|\5?)\4|\4?)\3|\3?)\2|\2?))?\1\b</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/6adba86aef786e7f799514a5960887b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*DLYhe1sc7IPDyagPppZ3nA.png"/></div></figure><p id="ed1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我换掉了每一个<strong class="ix hj">。</strong>用<strong class="ix hj"> \w </strong>我把表达式用<strong class="ix hj"> \b </strong>包起来，这样单词的内部部分就被排除了，就像P <strong class="ix hj"> ana </strong> ma中一样。为了支持短语，让我们忽略空格、制表符、逗号和引号。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2a38" class="kc kd hi jy b fi ke kf l kg kh">\b(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*(?:(\w)[ \t,'"]*\11?[ \t,'"]*\10|\10?)[ \t,'"]*\9|\9?)[ \t,'"]*\8|\8?)[ \t,'"]*\7|\7?)[ \t,'"]*\6|\6?)[ \t,'"]*\5|\5?)[ \t,'"]*\4|\4?)[ \t,'"]*\3|\3?)[ \t,'"]*\2|\2?))?[ \t,'"]*\1\b</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/9dcfa6671a90167c30dc9fd74ad4c4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*JYC2HE-8Yg2ysucwmI5O5g.png"/></div></figure><p id="2835" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我只是在捕获组之外的每个字符之间插入了一串<strong class="ix hj"> [ \t，' "]* </strong>表达式，所以这些字符可以存在于字符串中，而不需要在另一端进行镜像。</p><p id="683d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们做到了！任务完成。他们说不可能！…他们是对的，有限的正则表达式不可能检测任意长度的回文，但是我们仍然可以做一个有限的来取乐！</p><p id="a1b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你的家庭作业是写一个函数，它取一个长度，并输出一个正则表达式，这个正则表达式可以检测到这个长度的回文。</p></div></div>    
</body>
</html>