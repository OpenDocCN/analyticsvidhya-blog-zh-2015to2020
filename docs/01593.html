<html>
<head>
<title>End-to-End ML in Tensorflow and Tensorflow Extended — 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensorflow和tensor flow Extended-2中的端到端ML</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/end-to-end-ml-in-tensorflow-and-tensorflow-extended-2-ac20276ebef0?source=collection_archive---------7-----------------------#2019-11-02">https://medium.com/analytics-vidhya/end-to-end-ml-in-tensorflow-and-tensorflow-extended-2-ac20276ebef0?source=collection_archive---------7-----------------------#2019-11-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4350bd891f2d62c774a100491448add0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xBaeCKj2J6veWIvs"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">卢卡·布拉沃在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="54a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将是这个系列的第二部分，早些时候我发布了一个<a class="ae iu" rel="noopener" href="/@jagesh.maharjan007/end-to-end-ml-in-tensorflow-and-tensorflow-extended-1-db32b32334b7">第一部分</a>，介绍了创建模型的基本方法。这一次将更多地使用具有多个要素的真实数据，并对数据集进行一些变换。</p><p id="b105" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将使用的数据集是来自IRIS数据集的开源数据集，用于根据输入特征对花卉类型(三种花卉类别)进行分类。不多说了，让我们直接进入代码吧。</p><p id="c893" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们导入一些python包/头文件。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b0df" class="kc kd hi jy b fi ke kf l kg kh">from sklearn import datasets<br/>from sklearn.model_selection import train_test_split<br/>import tensorflow as tf</span></pre><p id="cad9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来自sklearn的数据集已经有了iris数据集，所以我们可以通过调用名称来加载数据集，但是，我们也可以使用pandas.read_csv从磁盘加载CSV文件。但此时我们保持简单。在另一个系列中，我们将从CSV加载数据，并使用Tensorflow transform进行数据转换。</p><p id="eb2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">加载数据后，我们可以将数据分为训练集和评估/测试数据集。此外，我们将特征和标签分开。然后，我们创建一个输入特征关键字为x的特征列，其形状为(4，)。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="cb7f" class="kc kd hi jy b fi ke kf l kg kh">INPUT_FEATURE = 'x'<br/>NUM_CLASSES = 3</span><span id="c2ea" class="kc kd hi jy b fi ki kf l kg kh">iris = datasets.load_iris()<br/>X = iris.data<br/>y = iris.target</span><span id="8f35" class="kc kd hi jy b fi ki kf l kg kh">index_list = range(len(y))<br/>index_train, index_eval = train_test_split(index_list, train_size=0.8)<br/>X_train, X_eval = X[index_train], X[index_eval]<br/>y_train, y_eval = y[index_train], y[index_eval]</span><span id="1d30" class="kc kd hi jy b fi ki kf l kg kh">feature_columns = [<br/> tf.feature_column.numeric_column(INPUT_FEATURE, shape=[4])<br/>]</span></pre><p id="182e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们使用estimator API定义配置，如下所示。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b099" class="kc kd hi jy b fi ke kf l kg kh">training_config = tf.estimator.RunConfig(<br/> model_dir=’/tmp/iris/models/ckpt/’,<br/> save_summary_steps=100,<br/> save_checkpoints_steps=100)</span></pre><p id="d208" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们使用名为DNNClassifier的估计器API构建DNNClassifier，其中包含带有隐藏单元的参数、上面的配置、类的数量和保存检查点模型的目录。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="d1e7" class="kc kd hi jy b fi ke kf l kg kh">classifier = tf.estimator.DNNClassifier(<br/>                  config=training_config,<br/>                  feature_columns=feature_columns,<br/>                  hidden_units=[10, 20, 10],<br/>                  n_classes=NUM_CLASSES,<br/>                  model_dir='/tmp/iris/models/ckpt/')</span><span id="a9f3" class="kc kd hi jy b fi ki kf l kg kh">train_spec = tf.estimator.TrainSpec(<br/>                 input_fn=train_input_fn,<br/>                 max_steps=10000)</span></pre><p id="5797" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在此管道下，我们将使用estimator API来训练和保存模式，具有训练输入功能和评估输入功能。这就是为什么estimator API (TensorFlow高级API)是一个很好的工具。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="736f" class="kc kd hi jy b fi ke kf l kg kh">def serving_input_receiver_fn():<br/>    receiver_tensors = {<br/>        'sepal_length': tf.placeholder(tf.float32, [None, 1]),<br/>        'sepal_width': tf.placeholder(tf.float32, [None, 1]),<br/>        'petal_length': tf.placeholder(tf.float32, [None, 1]),<br/>        'petal_width': tf.placeholder(tf.float32, [None, 1]),<br/>    }</span><span id="dfa4" class="kc kd hi jy b fi ki kf l kg kh">    features = {<br/>        INPUT_FEATURE: tf.concat([<br/>            receiver_tensors['sepal_length'],<br/>            receiver_tensors['sepal_width'],<br/>            receiver_tensors['petal_length'],<br/>            receiver_tensors['petal_width']<br/>        ], axis=1)<br/>    }<br/>    return  tf.estimator.export.ServingInputReceiver(receiver_tensors=receiver_tensors, features=features)</span><span id="a5ae" class="kc kd hi jy b fi ki kf l kg kh">latest_exporter = tf.estimator.LatestExporter(<br/>        name="models",<br/>        serving_input_receiver_fn=serving_input_receiver_fn,<br/>        exports_to_keep=10)</span><span id="3a1e" class="kc kd hi jy b fi ki kf l kg kh">best_exporter = tf.estimator.BestExporter(<br/>        serving_input_receiver_fn=serving_input_receiver_fn,<br/>        exports_to_keep=1)</span><span id="3416" class="kc kd hi jy b fi ki kf l kg kh">exporters = [latest_exporter, best_exporter]</span><span id="8cfa" class="kc kd hi jy b fi ki kf l kg kh">eval_input_fn = tf.estimator.inputs.numpy_input_fn(<br/>        x={INPUT_FEATURE: X_eval},<br/>        y=y_eval,<br/>        num_epochs=1,<br/>        shuffle=False)</span><span id="0c1e" class="kc kd hi jy b fi ki kf l kg kh">eval_spec = tf.estimator.EvalSpec(<br/>        input_fn=eval_input_fn,<br/>        throttle_secs=180,<br/>        steps=10,<br/>        exporters=exporters)</span></pre><p id="c62c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们准备好了所有的成分，我们就可以使用估计器的train_and_evaluate函数进行训练和评估了。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="4335" class="kc kd hi jy b fi ke kf l kg kh">tf.estimator.train_and_evaluate(classifier, train_spec=train_spec, eval_spec=eval_spec)</span></pre><p id="3340" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">培训完成后，您可以看到带有评估分数的培训输出。以及保存在指定目录下的模型</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c342" class="kc kd hi jy b fi ke kf l kg kh">({'accuracy': 1.0,<br/>  'average_loss': 0.0020009247,<br/>  'loss': 0.060027737,<br/>  'global_step': 938},<br/> [b'/tmp/iris/models/ckpt/export/models/1572589822',<br/>  b'/tmp/iris/models/ckpt/export/best_exporter/1572589822'])</span></pre><p id="9197" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些是保存模型的目录</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/3b268099d189f7c8efcf52373d0528fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*fNLnEMSp-diQ6DquSMjsPA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图:保存的模型</figcaption></figure><p id="db7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以从终端使用saved_model_cli函数检查模型的签名，以找出输入和输出参数。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2b36" class="kc kd hi jy b fi ke kf l kg kh">(myvenv) jugs@jugs:/tmp/iris$ saved_model_cli show --dir /tmp/iris/models/ckpt/export/models/157258982</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/6d486b0a3e2af99c86352b22491449bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*VcugChjGnk73l3T7Qtlnmg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图:保存模型的签名</figcaption></figure><p id="e80b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，现在我们可以使用TensorFlow服务来服务/托管模型以进行部署。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="0340" class="kc kd hi jy b fi ke kf l kg kh">tensorflow_model_server --port=8500 --rest_api_port=8501 --model_name=iris --model_base_path=/tmp/iris/models/ckpt/export/models/</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/0b3474b6430e5acbae7062838d74a5ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWJA624g6RWiKlFLnLWWww.png"/></div></div></figure><p id="4606" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们的模型正在部署中，并准备好从传入的客户端提供服务。所以现在我们可以创建一个客户端部件来进行推理。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="6922" class="kc kd hi jy b fi ke kf l kg kh">import json<br/>import requests<br/>import os<br/>import numpy as np</span><span id="8891" class="kc kd hi jy b fi ki kf l kg kh">endpoint = “<a class="ae iu" href="http://localhost:8501/v1/models/iris:predict" rel="noopener ugc nofollow" target="_blank">http://localhost:8501/v1/models/iris:predict</a>"<br/>headers = {“content-type”:”application-json”}</span><span id="d3bd" class="kc kd hi jy b fi ki kf l kg kh">instances = [{“sepal_length”:[6.8],”sepal_width”:[3.2],”petal_length”:[5.9],”petal_width”:[2.3]}]</span><span id="3e8f" class="kc kd hi jy b fi ki kf l kg kh">data = json.dumps({“signature_name”:”predict”,”instances”: instances})</span><span id="3346" class="kc kd hi jy b fi ki kf l kg kh">response = requests.post(endpoint, data=data, headers=headers)<br/>prediction = json.loads(response.text)[‘predictions’]<br/>prediction</span></pre><p id="32d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们所需要的模型输出只是基于签名定义的预测结果。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="bd6a" class="kc kd hi jy b fi ke kf l kg kh">[{'class_ids': [2],<br/>  'classes': ['2'],<br/>  'all_class_ids': [0, 1, 2],<br/>  'all_classes': ['0', '1', '2'],<br/>  'probabilities': [2.90285893e-08, 0.00058580871, 0.999414206],<br/>  'logits': [-9.90864372, 0.00382383168, 7.445755]<br/>}]</span></pre></div></div>    
</body>
</html>