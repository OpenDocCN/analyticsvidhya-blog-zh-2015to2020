<html>
<head>
<title>How to add additional layers in a pre-trained model using Pytorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Pytorch 在预训练模型中添加附加层</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-add-additional-layers-in-a-pre-trained-model-using-pytorch-5627002c75a5?source=collection_archive---------2-----------------------#2020-08-25">https://medium.com/analytics-vidhya/how-to-add-additional-layers-in-a-pre-trained-model-using-pytorch-5627002c75a5?source=collection_archive---------2-----------------------#2020-08-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="917f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们大多数人发现添加附加层并在模型和附加层之间生成连接是非常困难的。但是，在这里，我将使它变得简单。这样，每个人都能从中受益。只要把这个读一遍，我们就可以开始了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/1e2efc43303669e6e8f35c6a66a0ad8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJO9F0YPpf928r4T2LqWvA.png"/></div></div></figure><p id="75b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在这里我将使用两个小模型的架构(<strong class="ih hj">efficient net _ B0</strong>&amp;<strong class="ih hj">resnet 18</strong>)作为我们理解这个主题的例子。</p><h2 id="1e81" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak">效率网 _b0 </strong> →</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kk"><img src="../Images/d360ef17959a6c1286a51948e4d30320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*6EirE5kIFgTc-IXDXuCN6A.png"/></div></figure><p id="8e89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将安装预先训练的模型</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="2782" class="jp jq hi km b fi kq kr l ks kt">!pip install efficientnet_pytorch</span></pre><p id="e8f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，如果我们在 Pytorch 的 efficientNet 的 GitHub 中查找<a class="ae ku" href="https://github.com/lukemelas/EfficientNet-PyTorch" rel="noopener ugc nofollow" target="_blank">,我们会发现它的重要性</a></p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="8959" class="jp jq hi km b fi kq kr l ks kt">from efficientnet_pytorch import EfficientNet</span></pre><p id="5a60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们将定义自己的类</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="2e6c" class="jp jq hi km b fi kq kr l ks kt">class <strong class="km hj">EfficientNet_b0</strong>(nn.Module):</span></pre><p id="ccdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们为我们的类定义构造函数</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="1f28" class="jp jq hi km b fi kq kr l ks kt">def __init__(self):<br/>        super(EfficientNet_b0, self).__init__()<br/>        <br/>#  where this line <strong class="km hj">super(EfficientNet_b0, self).__init__()</strong> is used to inherit nn.Module used above.</span></pre><p id="b8ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们将加载预训练的 EfficientNet 模型。</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="e27e" class="jp jq hi km b fi kq kr l ks kt">self.model = efficientnet_pytorch.EfficientNet.from_pretrained('efficientnet-b0')</span></pre><p id="037a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我致力于添加额外的层<strong class="ih hj">一个密集层</strong>，然后<strong class="ih hj">批量规格化层</strong>然后<strong class="ih hj">一个脱落层</strong>和<strong class="ih hj">最后两个密集层。</strong></p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="0c5c" class="jp jq hi km b fi kq kr l ks kt">self.classifier_layer = nn.Sequential(<br/>            nn.Linear(1280 , 512),<br/>            nn.BatchNorm1d(512),<br/>            nn.Dropout(0.2),<br/>            nn.Linear(512 , 256),<br/>            nn.Linear(256 , <strong class="km hj">no._of_outputs_classes_for_your_dataset</strong>)<br/>        )</span></pre><p id="fb11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kv">注</em> </strong> : <strong class="ih hj"> nn。Linear(1280，512) </strong>第一个附加密集层包含<strong class="ih hj"> 1280 </strong>作为 in_features 因为如果我们打印<strong class="ih hj"> </strong> model <strong class="ih hj">最后一层</strong>(<strong class="ih hj"><em class="kv">_ fc</em></strong>)<strong class="ih hj">of</strong>efficient net-B0 model 包含<strong class="ih hj"> 1280 作为 in features </strong>和<strong class="ih hj"> 1000 作为 out_features 来分类</strong></p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="39ca" class="jp jq hi km b fi kq kr l ks kt">(<strong class="km hj">_bn1</strong>): BatchNorm2d(1280, eps=0.001, momentum=0.010000000000000009, affine=True, track_running_stats=True) <br/>(<strong class="km hj">_avg_pooling</strong>): AdaptiveAvgPool2d(output_size=1) <br/>(<strong class="km hj">_dropout</strong>): Dropout(p=0.2, inplace=False) <br/><strong class="km hj">(_fc): Linear(in_features=1280, out_features=1000, bias=True)</strong> (<strong class="km hj">_swish</strong>): MemoryEfficientSwish()</span></pre><p id="9da6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们将定义 forward 函数来生成模型和我们定义的层之间的连接。对于这个<a class="ae ku" href="https://github.com/lukemelas/EfficientNet-PyTorch/blob/master/efficientnet_pytorch/model.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="kv">我们需要看看 GitHub Repo </em> </strong> </a>中模型类的 forward 函数</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="606e" class="jp jq hi km b fi kq kr l ks kt"># forward function of Efficient-Net model <br/>def forward(self, inputs):<br/>   x = self.extract_features(inputs)<br/>   x = self._avg_pooling(x)<br/>   x = x.flatten(start_dim=1)        <br/>   x = self._dropout(x)        <br/>   x = self._fc(x)<br/>   return x</span></pre><p id="16c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将通过<strong class="ih hj">移除最后一层</strong>和<strong class="ih hj">添加 self.model </strong>来改变一些事情，因为我们已经在构造函数类中定义了<strong class="ih hj"> self.model </strong>。</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="669c" class="jp jq hi km b fi kq kr l ks kt">def forward(self, inputs):<br/>    x = <strong class="km hj">self.model</strong>.extract_features(inputs)<br/>    x = <strong class="km hj">self.model</strong>._avg_pooling(x)<br/>    x = x.flatten(start_dim=1)<br/>    x = <strong class="km hj">self.model</strong>._dropout(x)<br/>    x = self.classifier_layer(x)<br/>    return x</span></pre><p id="72fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">终于准备好了。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h2 id="4841" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak"> RestNet18 </strong> →</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/e2f9b5924667d45cea4c42955af6a368.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*sfGZkSFZRDJ3fEt1tfiq3Q.png"/></div></figure><p id="335b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，对于 resNet18 型号，我们将遵循与之前类似的步骤。</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="d89c" class="jp jq hi km b fi kq kr l ks kt">!pip install pretrainedmodels</span><span id="9e40" class="jp jq hi km b fi kz kr l ks kt">import pretrainedmodels</span></pre><p id="d5a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将把模型类和构造函数定义为</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="21c6" class="jp jq hi km b fi kq kr l ks kt">class <strong class="km hj">Resnet18</strong>(nn.Module):<br/>    def __init__(self):<br/>        super(Resnet18, self).__init__()<br/>        self.model =  pretrainedmodels.__dict__['resnet18'](pretrained='imagenet')</span></pre><p id="467b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并像在 EfficientNet_b0 模型中一样添加我们的额外层。</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="3bec" class="jp jq hi km b fi kq kr l ks kt">self.classifier_layer = nn.Sequential(<br/>            nn.Linear(<strong class="km hj">512</strong> , 256),<br/>            nn.BatchNorm1d(256),<br/>            nn.Dropout(0.2),<br/>            nn.Linear(256 , 128),<br/>            nn.Linear(128 , <strong class="km hj">no._of_outputs_classes_for_your_dataset</strong>)<br/>        )</span></pre><p id="68ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kv">注</em> </strong> : <strong class="ih hj"> nn。线性(512，</strong> 256 <strong class="ih hj"> ) </strong>第一个附加密集层包含<strong class="ih hj"> 512 </strong>作为 in_features 因为如果我们打印<strong class="ih hj"/><strong class="ih hj"/><strong class="ih hj"/>最后一个<strong class="ih hj"> </strong>层<strong class="ih hj"> </strong> ( <strong class="ih hj">最后 _ 线性</strong> ) 【T22)的 resnet18 模型包含<strong class="ih hj"> 512 作为 in features 【T25</strong></p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="3974" class="jp jq hi km b fi kq kr l ks kt">(avgpool): AdaptiveAvgPool2d(output_size=(1, 1)) <br/>(fc): None <br/>(<strong class="km hj">last_linear</strong>): Linear(in_features=<strong class="km hj">512</strong>, out_features=1000, bias=True)</span></pre><p id="9023" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后我们将通过<a class="ae ku" href="https://github.com/Cadene/pretrained-models.pytorch/blob/master/pretrainedmodels/models/torchvision_models.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="kv">查看 GitHub Repo </em> </strong> </a>中模型类的转发函数来定义转发函数</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/9540bbab111f76f7e140da9fc44b1de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*fjy_2Pip55SbAs3nL2opAg.png"/></div></figure><p id="5311" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并将其更改为:→</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="469a" class="jp jq hi km b fi kq kr l ks kt">def forward(self, x):<br/>    <strong class="km hj">batch_size</strong> ,_,_,_ = x.shape #taking out <strong class="km hj">batch_size</strong> from input image<br/>    x = self.model.features(x)<br/>    x = torch.nn.functional.adaptive_avg_pool2d(x,1).reshape(<strong class="km hj">batch_size</strong>,-1) # then reshaping the <strong class="km hj">batch_size</strong><br/>    x = self.classifier_layer(x)<br/>    return x</span></pre><p id="0790" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在所有的改变之后，我们的类将会是这样的</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="28cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们就可以通过创建它们的对象来使用我们的模型类了。我希望你已经明白了这一点，如果你有任何问题，评论或关注，请让我知道在评论部分；在那之前，享受学习吧。</p></div></div>    
</body>
</html>