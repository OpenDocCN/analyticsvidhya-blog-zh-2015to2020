<html>
<head>
<title>Named Entity Recognition in Java using Open NLP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用开放自然语言处理的 Java 命名实体识别</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/named-entity-recognition-in-java-using-open-nlp-4dc7cfc629b4?source=collection_archive---------6-----------------------#2020-08-31">https://medium.com/analytics-vidhya/named-entity-recognition-in-java-using-open-nlp-4dc7cfc629b4?source=collection_archive---------6-----------------------#2020-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/207ae9141c117bbf90bc5d2d03ecf50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2C1GFgaIBQmVE7_hnRovDQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">毛罗·利马在<a class="ae iu" href="https://unsplash.com/s/photos/text-highlight?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="cd9c" class="jc jd hi bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">简介</strong></h1><p id="ee83" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">您可能想知道，我们如何从文本中提取信息，或者我们如何仅使用 Java 从文本中提取关键字。当我们想到使用自然语言处理时，我们通常会在 python 中得到稳定的库，如 NLTK、spacy 等。因此，您通常会用 python 来实现这一点。当涉及到与可能用 java 编写的现有系统集成时，您可能最终会在 python 代码上编写 rest 包装器，以便系统可以与之通信。但是这样也有很多弊端。</p><ol class=""><li id="a83a" class="ky kz hi kc b kd la kh lb kl lc kp ld kt le kx lf lg lh li bi translated">构建认证和授权机制，并确保 rest API 遵循安全协议</li><li id="1c71" class="ky kz hi kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated">为托管和部署此应用程序设置单独的环境</li><li id="3106" class="ky kz hi kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated">故障点可能会增加</li></ol><p id="1eb0" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">在我从事的一个项目中，我也遇到了类似的问题。我必须从维护电子邮件中提取数据中心的不同维护信息，如 ID、维护日期和提供商，并相应地创建票证。自动票据创建是用 Mulesoft 编写的，Mulesoft 是一个基于 spring 的 java 集成工具。</p><p id="eb9a" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">我可以实现一个基于正则表达式的方法，在那里我可以编写提取这些实体的模式。但是有许多不同的模式需要注意，这不是一个可行的解决方案。然后我知道这些信息已经存在于手工处理的现有票据中。因此，我想到建立一个 NER 模型，它可以通过用包含这些信息的门票数据集训练模型来提取这些实体。</p><p id="aabd" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">我查看了许多提供培训定制 NER 模型选项的库，其中一个是非常受欢迎的生产级库空间。由于创建票证的集成已经出现在 Java 中，所以用 python 构建模型并将其与 rest wrapper 集成有点难以克服，因为上面列出了缺点。</p><p id="afce" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">因此，我遇到了一个由 Apache 命名为 Open NLP 的库。它有一个非常酷的 NER 模型，这是一个基于 java 的库，通过使用 Java 组件，它也可以很容易地用于 Mulesoft ESB。</p><p id="7a11" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">让我们深入了解如何在 Open NLP 中创建一个定制的 NER 模型。</p></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="3102" class="jc jd hi bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">第一步:添加库</strong></h1><p id="cfaa" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">下面是可以添加到 maven 项目的 pom.xml 中的依赖项，或者您也可以下载 jar 并将其添加到构建路径中。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="0a10" class="ma jd hi lw b fi mb mc l md me">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.apache.opennlp&lt;/groupId&gt;<br/>    &lt;artifactId&gt;opennlp-tools&lt;/artifactId&gt;<br/>    &lt;version&gt;1.9.2&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.apache.opennlp&lt;/groupId&gt;<br/>    &lt;artifactId&gt;opennlp-uima&lt;/artifactId&gt;<br/>    &lt;version&gt;1.9.2&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="5bae" class="jc jd hi bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">步骤 2:准备训练数据集</strong></h1><p id="6086" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">需要提供给开放 NLP 模型的数据集应该出现在一个文本文件中。该训练数据集应该包含文本，该文本包含需要提取的实体或关键字，并且这些实体应该用开始和结束标签进行注释。开始标签将表示需要提取的实体的开始。它应该遵循以下语法:<entity_type.entity_name>，其中 entity_name 是可选的，它可以在所有不同种类的将被注释的实体中保持通用。entity_name 是必需的，用于标记实体。<end>用来标记实体的结束。</end></entity_type.entity_name></p><p id="6e7e" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">例如，在我的训练数据集中，训练数据集由不同电子邮件的正文组成，其中维护日期用开始和结束标签进行了注释。不同的电子邮件正文被放入文本文件的不同行中。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="8fea" class="ma jd hi lw b fi mb mc l md me">Dear Network User, Please be advised that the network will be unavailable from 01:00am to 05:30am on &lt;START:maint.mdate&gt; November 12th, 2014 &lt;END&gt; . This period of downtime will be scheduled for necessary updates to be applied to the network servers. We apologise for the inconvenience that this may cause. Kindly inform the IT Service Desk (at ext. 1234) of any concerns that you may have about the planned outage. Kind regards, abc name Network Administrator.</span><span id="3abc" class="ma jd hi lw b fi mf mc l md me">Due to system maintenance, Certain account related features on Net Banking would not be available till &lt;START:maint.mdate&gt;Monday 6th September 17:00 hrs &lt;END&gt;. Credit Card Enquiry, Demat, and Debit Card details would continue to be available. We regret the inconvenience caused</span></pre><p id="56e4" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">准备训练数据集时，需要注意以下几点</p><ol class=""><li id="0e00" class="ky kz hi kc b kd la kh lb kl lc kp ld kt le kx lf lg lh li bi translated">当注释标记前后有空格时，该模型可以工作。</li><li id="eb0e" class="ky kz hi kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated">训练数据集应该包含每种文本至少 7-10 条记录，以便模型学习模式并正确预测</li><li id="c6b9" class="ky kz hi kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated">训练数据集的每个记录应该出现在单独的行中(即由\n 换行符分隔)</li><li id="e7ab" class="ky kz hi kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated">也可以应用标准的数据预处理技术，如删除标点符号、停用词、非 ascii 字符等</li></ol></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="d2ca" class="jc jd hi bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">第三步:建立模型</strong></h1><p id="dcf7" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">导入以下模块</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="4baa" class="ma jd hi lw b fi mb mc l md me">import java.io.File;<br/>import java.io.FileNotFoundException;<br/>import java.io.FileOutputStream;<br/>import java.io.IOException;<br/>import java.nio.charset.StandardCharsets;<br/>import java.util.Collections;<br/>import opennlp.tools.namefind.BioCodec;<br/>import opennlp.tools.namefind.NameFinderME;<br/>import opennlp.tools.namefind.NameSample;<br/>import opennlp.tools.namefind.NameSampleDataStream;<br/>import opennlp.tools.namefind.TokenNameFinder;<br/>import opennlp.tools.namefind.TokenNameFinderFactory;<br/>import opennlp.tools.namefind.TokenNameFinderModel;<br/>import opennlp.tools.util.InputStreamFactory;<br/>import opennlp.tools.util.MarkableFileInputStreamFactory;<br/>import opennlp.tools.util.ObjectStream;<br/>import opennlp.tools.util.PlainTextByLineStream;<br/>import opennlp.tools.util.Span;<br/>import opennlp.tools.util.TrainingParameters;</span></pre><p id="26a1" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">读取步骤 2 中准备的训练数据集(training_dataset.txt)文本文件</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="971b" class="ma jd hi lw b fi mb mc l md me">InputStreamFactory in = null;<br/>try {<br/>    in = new MarkableFileInputStreamFactory(new File("AnnotatedSentences.txt"));<br/>} catch (FileNotFoundException e2) {<br/>    e2.printStackTrace();<br/>}<br/>ObjectStream sampleStream = null;<br/>try {<br/>    sampleStream = new NameSampleDataStream(<br/>        new PlainTextByLineStream(in, StandardCharsets.UTF_8));<br/>} catch (IOException e1) {<br/>    e1.printStackTrace();<br/>}</span></pre><p id="9a4b" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">我们可以改变训练参数，例如迭代次数、损失截止参数和算法类型(目前开放的 NLP 仅支持 Maxent 和朴素贝叶斯)</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="6477" class="ma jd hi lw b fi mb mc l md me">// setting the parameters for training<br/>TrainingParameters params = new TrainingParameters();<br/>params.put(TrainingParameters.ITERATIONS_PARAM, 70);<br/>params.put(TrainingParameters.CUTOFF_PARAM, 1);<br/>paramaters.put(TrainingParameters.ALGORITHM_PARAM, 'MAXENT');</span></pre><p id="a949" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">我们通过传入诸如编解码器、语言、训练数据集等参数来训练模型。训练之后，我们可以用一个名字将模型保存到文件系统中，这个名字将用于以后提取实体。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="e77e" class="ma jd hi lw b fi mb mc l md me">// training the model using TokenNameFinderModel class<br/>TokenNameFinderModel nameFinderModel = null;<br/>try {<br/>nameFinderModel = NameFinderME.train("en", null, sampleStream,<br/>params, TokenNameFinderFactory.create(null, null, Collections.emptyMap(), new BioCodec()));<br/>} catch (IOException e) {<br/>e.printStackTrace();<br/>}<br/>// saving the model to "ner-custom-model.bin" file<br/>try {<br/>File output = new File("ner-custom-model.bin");<br/>FileOutputStream outputStream = new FileOutputStream(output);<br/>nameFinderModel.serialize(outputStream);<br/>} catch (FileNotFoundException e) {<br/>e.printStackTrace();<br/>} catch (IOException e) {<br/>e.printStackTrace();<br/>}</span></pre><p id="f8d3" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">从<a class="ae iu" href="http://opennlp.sourceforge.net/models-1.5/en-token.bin" rel="noopener ugc nofollow" target="_blank">开放 NLP 官网</a>下载分词器模型，这个将用于对句子进行分词，因为模型需要以分词的形式出现的文本。我们加载模型，然后输入我们想要测试模型的标记化测试句子。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="8b79" class="ma jd hi lw b fi mb mc l md me">sentence = "&lt;put in the sample sentence that you want to test here&gt;"</span><span id="13a5" class="ma jd hi lw b fi mf mc l md me">// Tokenise sentences<br/>InputStream inputStreamTokenizer = new FileInputStream("en-token.bin");<br/>TokenizerModel tokenModel = new TokenizerModel(inputStreamTokenizer);<br/>TokenizerME tokenizer = new TokenizerME(tokenModel);<br/>tokens =  tokenizer.tokenize(sentence);</span><span id="d858" class="ma jd hi lw b fi mf mc l md me">//Load the model created above<br/>InputStream inputStream = new FileInputStream("ner-custom-model.bin");<br/>TokenNameFinderModel model = null;<br/>try {<br/>    model = new TokenNameFinderModel(inputStream);<br/>} catch (IOException e) {<br/>    // TODO Auto-generated catch block<br/>    e.printStackTrace();<br/>} <br/>NameFinderME nameFinder = new NameFinderME(model);<br/>Span nameSpans[] = nameFinder.find(tokens);</span><span id="b2aa" class="ma jd hi lw b fi mf mc l md me">// testing the model and printing the types it found in the input sentence<br/>for(Span name:nameSpans){<br/>String entity="";<br/>System.out.println(name);<br/>for(int i=name.getStart();i&lt;name.getEnd();i++){<br/>    entity+=tokens[i]+" ";<br/>}<br/>System.out.println(name.getType()+" : "+entity+"\t [probability="+name.getProb()+"]");</span></pre></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="e097" class="jc jd hi bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">为什么不是斯坦福核心 NLP？</h1><p id="cc50" class="pw-post-body-paragraph ka kb hi kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hb bi translated">你可能想知道，为什么我不选择斯坦福核心 NLP，它也是一个广泛流行的 NLP Java 库。原因是 Stanford core NLP 需要大量的训练数据集来训练客户 NER 模型，而不像 Open NLP 可以用很少的训练数据集来学习模式。也许在我的下一篇博客中，我会尝试解释如何用斯坦福核心自然语言处理训练一个定制的 NER 模型，并与开放自然语言处理进行比较。</p></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><p id="c5d3" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">我希望你喜欢我在 Open NLP 上的帖子，如果是的话，请与你感兴趣的朋友和同事分享。还有，多给这个帖子鼓掌，会鼓励我多写帖子。如果你有任何疑问，需要帮助来完成这段代码，请在下面的评论区留下你的想法。</p><p id="2c1e" class="pw-post-body-paragraph ka kb hi kc b kd la kf kg kh lb kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx hb bi translated">直到下一个帖子，谢谢！！！</p></div></div>    
</body>
</html>