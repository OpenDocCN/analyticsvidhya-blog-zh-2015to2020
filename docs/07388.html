<html>
<head>
<title>Managing Machine Learning Life cycle with MLflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用MLflow管理机器学习生命周期</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/managing-machine-learning-life-cycle-with-mlflow-3bea291d771b?source=collection_archive---------0-----------------------#2020-06-24">https://medium.com/analytics-vidhya/managing-machine-learning-life-cycle-with-mlflow-3bea291d771b?source=collection_archive---------0-----------------------#2020-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ae841b1c1ca6b880779294ecf121e342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fzKo7qy1FKL3-uPH"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@antisocia1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Greg Ortega </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f8f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">机器学习项目的生命周期是复杂的。在《机器学习系统中隐藏的技术债务<a class="ae iu" href="https://papers.nips.cc/paper/5656-hidden-technical-debt-in-machine-learning-systems.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"/></a>一文中，Google引用了<strong class="ix hj"> <em class="jt">技术债务</em> </strong> <em class="jt"> </em>的软件工程框架，解释了现实世界中ML系统的维护会产生巨大的成本。下图真实地描绘了真实的场景。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/273d5bedc3e3a7aee059063bf68cec36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*9kTXHJqeZOR-7jAi8EeHNg.png"/></div></figure><p id="1761" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">夹在中间的小黑盒，周围是大盒子，是<strong class="ix hj">神奇的机器学习代码:)</strong>为了在生产中运行这个神奇的代码，我们需要处理其他几个过程，例如数据收集、验证、特征提取/生成、过程管理、部署、服务基础设施、监控等。</p><p id="9a39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，当ML系统处于探索阶段时，一组数据科学家/ML工程师密切关注不同模型的指标和性能，以获得优化的模型。捕获并与其他团队共享这些度量和分析，或者跟进业务以共享模型，需要一个健壮的模型沿袭系统(存储、版本化、可再现性)。除此之外，一旦证明了模型的价值，那么还需要一些工具，包括计算和部署框架，以支持模型在生产中的执行。如果模型的性能下降，则还需要及时跟踪它，并根据更改的数据集进行相应的重新训练。这整个过程使得ML项目的整个生命周期比软件开发生命周期更复杂。</p><p id="4aed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">传统软件和机器学习开发的区别可以总结如下。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/acc031cf6a2ff98b930a0113304e4662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*40h8R-Y3Gow7SV9MgdqjDg.png"/></div></figure><p id="6e93" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住这些事实，许多企业创建了他们自己的平台来支持分析模型开发的整个生命周期，但是保持一个高效和专注的工程和平台团队也是要付出代价的。这类平台的例子有谷歌的Tensorflow、脸书的FBLearner和优步的米开朗基罗。但是对于这些平台来说，也存在一些挑战</p><ul class=""><li id="c180" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated"><em class="jt">有限或小套算法支持。</em></li><li id="cd89" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><em class="jt">不可共享的代码。</em></li><li id="b889" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><em class="jt">与通常不能满足所有需求的企业基础设施紧密结合。</em></li></ul><p id="1242" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，为了解决上述所有问题，Databricks开源了名为<strong class="ix hj"> MLflow </strong>的库。MLflow的目标不仅支持复杂的ML生命周期，而且还提供用户友好的API来缓解常见的挑战，如模型可再现性、可共享的工件和跨语言支持。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="5a1c" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">MLflow</h1><p id="69c3" class="pw-post-body-paragraph iv iw hi ix b iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">根据MLflow <a class="ae iu" href="https://www.mlflow.org/docs/latest/index.html#" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">文件</strong> </a></p><blockquote class="ly lz ma"><p id="512d" class="iv iw jt ix b iy iz ja jb jc jd je jf mb jh ji jj mc jl jm jn md jp jq jr js hb bi translated">MLflow是一个管理端到端机器学习生命周期的开源平台。</p></blockquote><p id="b4e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MLflow的设计理念是模块化和基于API的。其功能分为4个部分</p><ol class=""><li id="3ae2" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js me kg kh ki bi translated"><strong class="ix hj">跟踪</strong></li><li id="ad6f" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js me kg kh ki bi translated"><strong class="ix hj">项目</strong></li><li id="205a" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js me kg kh ki bi translated"><strong class="ix hj">型号</strong></li><li id="3258" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js me kg kh ki bi translated"><strong class="ix hj">注册表</strong></li></ol><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/1df402d5df05f546caac8acaa13eba8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pSxjdDbPxjtn3cIZSaH0qw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">资料来源:databricks.com/mlflow</figcaption></figure><p id="b40b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们详细了解上述各个组件，稍后我们将看到它们的实现。</p><h1 id="175f" class="kv kw hi bd kx ky mg la lb lc mh le lf lg mi li lj lk mj lm ln lo mk lq lr ls bi translated">1.跟踪</h1><p id="ce9c" class="pw-post-body-paragraph iv iw hi ix b iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">MLflow跟踪是MLflow的元存储，是获取模型细节的集中场所。它使用HTTP协议在客户端应用程序和跟踪服务器之间建立连接。跟踪服务器捕获模型的以下细节，并使用后端存储来记录实体和工件。</p><ul class=""><li id="d922" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">测井参数</li><li id="6ee1" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">代码版本</li><li id="3135" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">韵律学</li><li id="48b4" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">工件(模型和数据文件)</li><li id="626a" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">运行的开始和结束时间</li><li id="b4da" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">作为附加信息的标签和注释</li></ul><p id="99ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下<strong class="ix hj"> MLflow tracking后端存储</strong>使用本地文件系统并创建<strong class="ix hj"> mlruns目录</strong>来捕获实体和工件。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/b23bb6eaef98cca02cce22985f1b4486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KYuL98s065nXDcCriM7nAA.png"/></div></div></figure><p id="429c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">mlruns文件夹的<strong class="ix hj">文件结构</strong></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/0e9622b4123e3457297ddc4a42bd2def.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*ispG4HT2roO4ZaCXByRm1A.png"/></div></figure><p id="88ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于生产用例，MLflow提供了不同的存储选项来存储工件和元数据。</p><p id="3864" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">神器- &gt; </strong>亚马逊S3、Azure Blob、谷歌云存储、Databricks DBFS</p><p id="6e47" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">元数据-&gt;</strong>SQL store(PostgreSQL、MySQL、SQL Lite、SQL Server等)，定制实体metastore的MLflow插件模式等。</p><h1 id="79e0" class="kv kw hi bd kx ky mg la lb lc mh le lf lg mi li lj lk mj lm ln lo mk lq lr ls bi translated">2.项目</h1><p id="57ca" class="pw-post-body-paragraph iv iw hi ix b iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">MLflow项目只不过是一个支持模型可再现性的组织和打包的代码。为了组织项目的文件和文件夹，MLflow提供了一个名为<strong class="ix hj">ml project</strong>(YAML文件)的文件，可以根据数据科学项目的要求进行配置。在MLproject中，我们还可以为项目执行配置<strong class="ix hj"> docker容器</strong>和<strong class="ix hj"> Kubernetes </strong>。</p><p id="0869" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它还提供了命令行工具和API来执行项目和创建工作流。</p><p id="c7c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> MLproject </strong>的一个典型例子是这样的</p><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="c7f4" class="ms kw hi mo b fi mt mu l mv mw"><strong class="mo hj">name</strong>: sklearn-demo<br/><strong class="mo hj">conda_env</strong>: conda.yaml<br/><strong class="mo hj">entry_points</strong>:<br/>  <strong class="mo hj">model_run</strong>:<br/>    <strong class="mo hj">parameters</strong>:<br/>      <strong class="mo hj">max_depth</strong>: int<br/>      <strong class="mo hj">max_leaf_nodes</strong>: {<strong class="mo hj">type</strong>: int, <strong class="mo hj">default</strong>: 32}<br/>      <strong class="mo hj">model_name</strong>: {<strong class="mo hj">type</strong>: string, <strong class="mo hj">default</strong>: <strong class="mo hj">"tree-classification"</strong>}<br/>      <strong class="mo hj">run_origin</strong>: {<strong class="mo hj">type</strong>: string, <strong class="mo hj">default</strong>: <strong class="mo hj">"default" </strong>}<br/>    <strong class="mo hj">command</strong>: <strong class="mo hj">"python model_run.py -r {max_depth} {max_leaf_nodes}   {model_name}"</strong></span></pre><p id="5da4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，一个<strong class="ix hj"> conda </strong>环境被定义为<strong class="ix hj"> conda.yaml </strong>，它负责为项目设置依赖关系。</p><p id="c409" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">构建MLflow项目的步骤</strong></p><p id="1cab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1-创建一个MLproject文件[定义项目的入口点]</p><p id="8197" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2-为所有python依赖项创建一个conda.yaml文件。</p><p id="1760" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3-创建一个python项目，并将MLproject和conda.yaml文件保存在根目录中(或者保存主执行器的任何其他位置)</p><p id="219c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4-将python项目推送到GitHub</p><p id="0a8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">测试本地项目和git hub</p><p id="e2eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">本地测试→ </strong> mlflow运行。-P &lt;参数&gt;</p><p id="42c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> github测试→ </strong> mlflow运行git:// &lt;项目-url &gt; &lt; param &gt;</p><p id="61d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MLproject可以有一个包含不同入口点(生产工作流)的多步骤项目。同样的例子可以在<a class="ae iu" href="https://github.com/mlflow/mlflow/blob/master/examples/multistep_workflow/MLproject" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">多步示例中找到。</strong> </a></p><h1 id="d68b" class="kv kw hi bd kx ky mg la lb lc mh le lf lg mi li lj lk mj lm ln lo mk lq lr ls bi translated">3.模型</h1><p id="d977" class="pw-post-body-paragraph iv iw hi ix b iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">模型定义了以不同的<strong class="ix hj">【风格】</strong>保存ML模型的约定。</p><p id="8dea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据文件</p><blockquote class="ly lz ma"><p id="0da1" class="iv iw jt ix b iy iz ja jb jc jd je jf mb jh ji jj mc jl jm jn md jp jq jr js hb bi translated">口味是使MLflow模型强大的关键概念:它们是部署工具可以用来理解模型的约定，这使得编写与来自任何ML库的模型一起工作的工具成为可能，而不必将每个工具与每个库集成</p></blockquote><p id="7d09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，味道的目的是-</p><ul class=""><li id="9bff" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">为不同的系统使用相同的内存格式</li><li id="efa8" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">为了避免跨系统通信的开销(序列化和反序列化)</li><li id="a80a" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">为了提供常见的可共享功能</li></ul><p id="454c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">风味通常有两种类型——</p><ol class=""><li id="2ed2" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js me kg kh ki bi translated">内置风格(适用于所有流行的机器学习算法和库)</li><li id="e39e" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js me kg kh ki bi translated">定制口味</li></ol><p id="8eca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的库作为<strong class="ix hj">内置风格</strong>提供，但是也可以使用python_function包装在<strong class="ix hj">自定义风格</strong>下。</p><ul class=""><li id="b88c" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">H2O</li><li id="97a3" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">克拉斯</li><li id="3f59" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">MLeap</li><li id="28fe" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">PyTorch</li><li id="ff06" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">sci kit-学习</li><li id="8bef" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">MLlib</li><li id="7ef8" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">张量流</li><li id="57ee" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">开放式神经网络交换</li><li id="de2f" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">MXNET胶子</li><li id="c44c" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">XGBoost</li><li id="d0af" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">LightGBM</li></ul><p id="821b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">定制风味</strong></p><p id="b5ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以为模型创建自定义风格。</p><p id="5c0a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://mlflow.org/docs/latest/models.html#custom-python-models" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">创建python自定义风格的文档。</strong>T19】</a></p><p id="78bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦mlflow项目被执行，在<strong class="ix hj">工件文件夹</strong>中<strong class="ix hj"> MLmodel </strong>文件被创建。下面是python_function风格相同的例子。</p><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="b487" class="ms kw hi mo b fi mt mu l mv mw">artifact_path: decision-tree-classifier<br/>flavors:<br/>  python_function:<br/>    data: model.pkl<br/>    env: conda.yaml<br/>    loader_module: mlflow.sklearn<br/>    python_version: 3.6.5<br/>  sklearn:<br/>    pickled_model: model.pkl<br/>    serialization_format: cloudpickle<br/>    sklearn_version: 0.23.1<br/>run_id: 10c75a05fb124eddbf2b13b458e9a26e<br/>utc_time_created: '2020-06-19 11:53:55.328301'</span></pre><h1 id="5bfe" class="kv kw hi bd kx ky mg la lb lc mh le lf lg mi li lj lk mj lm ln lo mk lq lr ls bi translated">4.模型注册表</h1><p id="069d" class="pw-post-body-paragraph iv iw hi ix b iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">ML模型管理是大型组织中的常见问题。为了解决模型管理方面的挑战，构建了模型注册组件。</p><p id="2edc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MLflow模型注册组件管理机器学习模型的整个生命周期，并提供</p><ul class=""><li id="79df" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated"><strong class="ix hj">集中模型存储:</strong>注册模型的存储。</li><li id="3ad0" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><strong class="ix hj">模型谱系:</strong>实验和运行细节</li><li id="9518" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><strong class="ix hj">模型版本化:</strong>跟踪注册模型的版本。</li><li id="aa8d" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><strong class="ix hj">模型阶段:</strong>为每个模型版本分配预设或自定义的阶段，如“试运行”和“生产”来表示模型的生命周期。在将模型部署到生产应用程序之前，最佳实践通常是在临时环境中对其进行测试。这个<a class="ae iu" href="https://mlflow.org/docs/latest/registry.html#transitioning-an-mlflow-models-stage" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">环节</strong> </a>有助于理解<strong class="ix hj">模型阶段转换的工作流程。</strong></li><li id="0b85" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><strong class="ix hj">对注册模型的CRUD操作:</strong>对模型的创建、更新、删除、存档、列表等操作。</li></ul></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="96e3" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">从头开始构建MLflow项目</h1><p id="668f" class="pw-post-body-paragraph iv iw hi ix b iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">完整的代码可以在我的<a class="ae iu" href="https://github.com/saurabh2mishra/mlflow-demo" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> github </strong> </a> <strong class="ix hj">上找到。</strong>在GitHub中，我添加了一个<strong class="ix hj"> </strong> mlflow-demo项目，演示一个scikit-learn和Keras <strong class="ix hj"> </strong>模型。然而，在本演练中，我将演示scikit-learn项目及其执行。</p><p id="a33b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">演示项目<strong class="ix hj"> sklearn-demo </strong>的结构如下。项目的结构可以根据用例需求重新安排和配置。这只是一个例子。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/471a9e08c24134202172914d484c7b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*nApMMl7Dv7PFHCIB6wVLEw.png"/></div></figure><p id="01b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">先决条件- </strong>要复制下面的示例，先决条件是必不可少的。但是，如果设置了conda环境并且提到了依赖项，那么它会自动创建一个环境来执行mlflow项目。</p><ul class=""><li id="6c9c" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">所需的python版本应为3.5以上</li><li id="f3f7" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">安装mlflow，numpy，pandas，scikit-learn，scikit-plot，matplotlib，seaborn。</li></ul><p id="f8bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤1- </strong></p><p id="a8e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为项目设置创建<strong class="ix hj">conda . YAML</strong>&amp;<strong class="ix hj">ml project . YAML</strong>文件。这两个文件是<strong class="ix hj"> mlflow的项目</strong>组件的一个重要方面，由工作流执行组成，如入口点、要执行的命令、依赖项等。</p><p id="5384" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> conda.yaml </strong></p><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="f7b6" class="ms kw hi mo b fi mt mu l mv mw"><strong class="mo hj">name</strong>: sklearn-demo<br/><strong class="mo hj">channels</strong>:<br/>  - defaults<br/><strong class="mo hj">dependencies</strong>:<br/>  - python=3.7.6<br/>  - <strong class="mo hj">pip</strong>:<br/>    - mlflow==1.8.0<br/>    - numpy=1.18.5<br/>    - pandas=1.0.4<br/>    - scikit-learn==0.23.1<br/>    - scikit-plot==0.3.7<br/>    - matplotlib==3.2.1<br/>    - seaborn==0.10.1</span></pre><p id="ca0d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">conda.yaml文件非常容易理解。<strong class="ix hj"> name </strong>是项目名称，dependencies是python的版本，而<strong class="ix hj"> pip </strong>列出了执行项目所需的所有库。</p><p id="10f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> MLproject.yaml </strong></p><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="ff66" class="ms kw hi mo b fi mt mu l mv mw"><strong class="mo hj">name</strong>: sklearn-demo<br/><strong class="mo hj">conda_env</strong>: conda.yaml</span><span id="f4d0" class="ms kw hi mo b fi my mu l mv mw"><strong class="mo hj">entry_points</strong>:<br/>  <strong class="mo hj">model_run</strong>:<br/>    <strong class="mo hj">parameters</strong>:<br/>      <strong class="mo hj">max_depth</strong>: int<br/>      <strong class="mo hj">max_leaf_nodes</strong>: {<strong class="mo hj">type</strong>: int, <strong class="mo hj">default</strong>: 32}<br/>      <strong class="mo hj">model_name</strong>: {<strong class="mo hj">type</strong>: string, <strong class="mo hj">default</strong>: <strong class="mo hj">"tree-classification" </strong>}<br/>      <strong class="mo hj">run_origin</strong>: {<strong class="mo hj">type</strong>: string, <strong class="mo hj">default</strong>: <strong class="mo hj">"default" </strong>}<br/>    <strong class="mo hj">command</strong>: <strong class="mo hj">"python model_run.py -r {max_depth} {max_leaf_nodes} {model_name}"</strong></span></pre><p id="fcac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MLproject也很容易理解。</p><ul class=""><li id="b19a" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated"><strong class="ix hj">名称:</strong>任何项目名称</li><li id="8ac8" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><strong class="ix hj"> conda_env: </strong>这是公寓YAML文件的名称(它应该与上面定义的conda文件名相同)</li><li id="dd73" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><strong class="ix hj"> entry_points: </strong>文件中的一个重要键。它是代码的执行点。在parameters部分，我们可以定义所有的命令行参数，我们需要传递这些参数来执行主脚本。我们可以设置默认值，也可以依靠用户来设置。根据项目设置，<strong class="ix hj"> model_run </strong>的名称可以是任何名称，默认名称是<strong class="ix hj"> main。</strong></li></ul><p id="0466" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们的项目将继续进行。</p><p id="c672" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第二步- </strong></p><p id="1c3d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在模型模块中创建一个python文件(prediction.py )(可以在任何地方创建；只是为了使它模块化，我一直把它放在模型里面)。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="25c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码相当简单，让我们一步一步地理解它</p><ul class=""><li id="6f46" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">创建一个类<strong class="ix hj"> TreeModel </strong>，它是DecisionTreeClassifier模型的包装器类。该类有一个名为<strong class="ix hj"> create_instance </strong>的类方法，它接受参数来创建DecisionTreeClassifier的实例。</li><li id="f3f8" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">TreeModel还有3个属性，名为<strong class="ix hj"> data、Model、</strong>和<strong class="ix hj"> params </strong>，为分类器提供数据集、模型和加载参数。</li><li id="7c24" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">所以，TreeModel类中的重要方法是<strong class="ix hj"> mlflow_run。</strong>这个方法为我们捕获<strong class="ix hj">工件、度量、</strong>和<strong class="ix hj">图做了很多事情。</strong>使用<strong class="ix hj"> python上下文</strong>对于一次性获取所有需要的指标也很重要。</li></ul><p id="f606" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">理解这些方法很重要，并且可以用于所有类型的模型。</p><blockquote class="ly lz ma"><p id="09f4" class="iv iw jt ix b iy iz ja jb jc jd je jf mb jh ji jj mc jl jm jn md jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi"> mlflow.log_param(key，value): </em> </strong>捕捉当前运行下的一个参数。如果没有运行处于活动状态，此方法将创建一个新的活动运行。</p><p id="5a1d" class="iv iw jt ix b iy iz ja jb jc jd je jf mb jh ji jj mc jl jm jn md jp jq jr js hb bi translated"><strong class="ix hj"><em class="hi">ml flow . Log _ params(params):</em></strong>记录当前运行的一批params(param _ name的字典)。如果没有运行处于活动状态，此方法将创建一个新的活动运行。</p><p id="d6fb" class="iv iw jt ix b iy iz ja jb jc jd je jf mb jh ji jj mc jl jm jn md jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi"> mlflow.log_metric(key，value，step=None): </em> </strong>记录给定运行的模型度量。如果没有运行处于活动状态，此方法将创建一个新的活动运行。</p><p id="e0b4" class="iv iw jt ix b iy iz ja jb jc jd je jf mb jh ji jj mc jl jm jn md jp jq jr js hb bi translated"><strong class="ix hj"><em class="hi">【ml flow . Log _ metrics(metrics，step=None): </em> </strong>记录当前运行的多个度量</p><p id="8e1e" class="iv iw jt ix b iy iz ja jb jc jd je jf mb jh ji jj mc jl jm jn md jp jq jr js hb bi translated"><strong class="ix hj"><em class="hi">ml flow . Log _ artifact(local _ path，artifacts_path=None): </em> </strong>将本地文件或目录记录为当前活动运行的工件。如果没有运行处于活动状态，此方法将创建一个新的活动运行。</p><p id="e67a" class="iv iw jt ix b iy iz ja jb jc jd je jf mb jh ji jj mc jl jm jn md jp jq jr js hb bi translated"><strong class="ix hj"><em class="hi">ml flow . Log _ artifacts(local _ path，artifacts_path=None): </em> </strong>将本地文件或目录记录为当前活动运行的工件。如果没有运行处于活动状态，此方法将创建一个新的活动运行。</p></blockquote><p id="9e98" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个<strong class="ix hj"> utils </strong>模块有一些通用功能(绘制混淆矩阵和roc)用于整个项目。用下面的内容创建一个utils.py文件。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="636a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第三步- </strong></p><p id="f70a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一步中，我们将创建我们的主执行器(model_run.py ),它将作为mlflow条目的驱动程序。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="0f97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">model_run接受max_depth超参数并执行TreeModel。</p><p id="9364" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样。一切都准备好了，我们可以走了！！！</p><p id="32f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，要查看mlflow记录的详细信息，我们可以直接执行我们的程序，如<strong class="ix hj"><em class="jt">python model _ run . py</em></strong>或<strong class="ix hj"> <em class="jt"> mlflow run。-P max_depth=5 </em> </strong>从命令行提示。</p><p id="63d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看mlflow是如何捕获所有工件和元数据的。有许多方法可以检查记录的详细信息。本地mlflow捕获mlruns文件夹中的所有工件、沿袭和度量(在解释理论时，我已经在教程的开头演示并附上了截图)。但是mlflow还附带了方便的UI命令，丰富了用户体验。</p><p id="69f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">转到命令提示符，导航到<strong class="ix hj"> mlruns文件夹</strong>并键入</p><pre class="jv jw jx jy fd mn mo mp mq aw mr bi"><span id="151d" class="ms kw hi mo b fi mt mu l mv mw"><strong class="mo hj">mlflow ui</strong></span></pre><p id="0107" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个本地浏览器<a class="ae iu" href="http://kubernetes.docker.internal:5000" rel="noopener ugc nofollow" target="_blank">http://kubernetes . docker . internal:5000</a>将会提示，通过点击它，我们可以探索关于ML运行的所有有用的细节。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/1eab86b6d84495369bdf31aaad85d185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*NxBo9tBYaQfzRE2X7RnW4Q.png"/></div></figure><p id="a5b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本地MLflow的主页。在这里，每个<strong class="ix hj">运行</strong>(生成文件夹和文件的代码的单独执行)和<strong class="ix hj">实验</strong>(运行组的名称)被注册。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/09428760a101c3adc623c890084abeda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LzYuGIayNk3axn06ubBnYA.png"/></div></div></figure><p id="1228" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们检查第一次运行。单击第一次运行，将出现以下页面。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/e3fecb090d75758e7486d99dc125e3e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OwFRZpwdT0dqdIr-rdbOQ.png"/></div></div></figure><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/2f877159a2cba95a0722ee8371d9e1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*FIt0TCflZY0nZt0ku9UUPA.png"/></div></figure><p id="8b4f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们向下滚动一点，我们可以看到我们的文物</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/49a8b307ed14c8792bd895ab9e08b984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxMp49bRDYCzoItBomJduw.png"/></div></div></figure><p id="5200" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，让我们检查一下这个实验的ROC曲线</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/b38813795815ba02ee62cb8a52dcea99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOGRteeM3S0jjhY9eg_c7Q.png"/></div></div></figure><p id="f37b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也可以并排看到不同实验的对比。这个特性对于追踪结果和特性对模型性能的影响非常有帮助。</p><p id="0ef4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">进入主页，点击<strong class="ix hj">比较</strong>，选择不同的型号运行。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/ffcd9050313f69f78aea3b00d943cd61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Y-B7s0IX0bFbPLoUZyZuQ.png"/></div></div></figure><p id="1462" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们可以看到MLflow提供了许多很酷的功能，只需几行代码，我们就可以实现所有复杂的事情，而这些事情在MLflow出现之前是困难和繁琐的。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="7431" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">MLflow API的一些亮点</h1><p id="76a7" class="pw-post-body-paragraph iv iw hi ix b iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">MLflow API设计良好，并定期添加新功能。检查API是否与新特性和变化同步是值得的。但是，我想强调MLflow的几个有趣的特性</p><ul class=""><li id="c8f7" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">在我写这篇博客的时候，MLflow API <strong class="ix hj">不仅是关于Python </strong>的，它还支持<strong class="ix hj"> Java、</strong>和<strong class="ix hj"> R </strong>编程语言。很快<strong class="ix hj"> Scala </strong>也将成为API的一部分。REST API也是可用的，它有助于实验、运行、日志参数、度量和工件的创建、列表和获取操作。</li><li id="6b0f" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">自动记录值得用于深度学习模型。正如我们所知，深度学习模型在模型的训练期间捕获几个参数/超参数，并且每个值并不总是能够通过使用mlflow.log_metric来记录。进行手动捕获可能会导致错过一些重要的指标。因此，简单来说，MLflow带有自动日志记录。它使用起来非常简单，只要启用它就能确保捕获和记录每一个可能的指标。自动记录功能可用于Keras、Tensorflow、Gluon、LighGBM、XGBoost和Spark <strong class="ix hj">。</strong>访问<a class="ae iu" href="https://mlflow.org/docs/latest/tracking.html#tensorflow-and-keras-experimental" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">文档</strong> </a> <strong class="ix hj"> </strong>和<a class="ae iu" href="https://github.com/saurabh2mishra/mlflow-demo/blob/master/keras-demo/models/prediction.py" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">我的github </strong> </a>查看它的用法。</li><li id="ee41" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">本地文件系统上的模型跟踪有利于实验的目的。为了跟踪生产中的模型，<strong class="ix hj">最好将所有元数据、数据、工件保存在云存储或SQL数据库中</strong>，并使用<strong class="ix hj">单独的专用服务器</strong>来更好地跟踪和维护。</li></ul><p id="a58a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有更多可用的特性可以在文档中研究，并根据不同的用例使用。</p><h1 id="9992" class="kv kw hi bd kx ky mg la lb lc mh le lf lg mi li lj lk mj lm ln lo mk lq lr ls bi translated">结论</h1><p id="5c55" class="pw-post-body-paragraph iv iw hi ix b iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">总的来说，我们已经看到了MLflow的强大功能，也了解到无论使用哪种框架、哪种编程语言来开发模型，MLflow都能够提供一个健壮的机制，只需几行代码就可以跟踪模型的开发、调整、打包和可再现性。这是机器学习武器库中的必备工具。</p><h1 id="da1b" class="kv kw hi bd kx ky mg la lb lc mh le lf lg mi li lj lk mj lm ln lo mk lq lr ls bi translated">参考</h1><p id="28e4" class="pw-post-body-paragraph iv iw hi ix b iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated"><a class="ae iu" href="https://papers.nips.cc/paper/5656-hidden-technical-debt-in-machine-learning-systems.pdf" rel="noopener ugc nofollow" target="_blank">https://papers . nips . cc/paper/5656-hidden-technical-debt-in-machine-learning-systems . pdf</a></p><p id="6248" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">强烈推荐这3个系列的MLflow研讨会</p><p id="d508" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.youtube.com/playlist?list=PLTPXxbhUt-YWjDg318nmSxRqTgZFWQ2ZC" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/playlist?list = PLTPXxbhUt-yw jdg 318 nmsxrqtgzfwq 2 ZC</a></p><p id="497a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.mlflow.org/docs/latest/index.html" rel="noopener ugc nofollow" target="_blank">www.mlflow.org</a></p><p id="9f4d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://databricks.com/product/managed-mlflow" rel="noopener ugc nofollow" target="_blank">https://databricks.com/product/managed-mlflow</a></p></div></div>    
</body>
</html>