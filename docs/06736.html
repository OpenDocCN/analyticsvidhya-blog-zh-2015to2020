<html>
<head>
<title>Python Library Hijacking on Linux (with examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux上的Python库劫持(附例子)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-library-hijacking-on-linux-with-examples-a31e6a9860c8?source=collection_archive---------2-----------------------#2020-06-01">https://medium.com/analytics-vidhya/python-library-hijacking-on-linux-with-examples-a31e6a9860c8?source=collection_archive---------2-----------------------#2020-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8a68a676c38187cb2ff8eff67db193e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CAwFRrsfm-24kuZIoRU1Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">(戴维·克洛德在<a class="ae iu" href="https://unsplash.com/s/photos/python?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片)</figcaption></figure><p id="2fbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将讨论在Linux环境中劫持Python库的三种有效方法。</p><h2 id="8a0d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">为什么重要？</h2><p id="9554" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">让我们看看……如果一个Python脚本以<strong class="ix hj"> <em class="kt"> sudo </em> </strong>权限运行，但是您在导入的模块上获得了<strong class="ix hj"> <em class="kt"> write </em> </strong>权限，会发生什么？</p><p id="713a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没错。您可以通过编辑导入的函数来升级您的权限，以调用系统命令，甚至生成一个shell，它将拥有<strong class="ix hj"> <em class="kt"> root </em> </strong>权限。</p><h2 id="065e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">滥用这个问题的方法</h2><p id="2e0c" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我将分享三个任何人都可以利用这个漏洞的场景(或者更好地称之为“安全错误配置”):</p><ol class=""><li id="c05e" class="ku kv hi ix b iy iz jc jd jg kw jk kx jo ky js kz la lb lc bi translated"><strong class="ix hj"> <em class="kt">对导入的Python模块的写权限</em> </strong></li><li id="35ca" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated"><strong class="ix hj"> <em class="kt">优先级更高的Python库路径拥有破碎权限</em> </strong></li><li id="7498" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated"><strong class="ix hj"> <em class="kt">通过PYTHONPATH环境变量</em> </strong>重定向Python库搜索</li></ol><h2 id="d647" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">共同要求</h2><p id="ec50" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">每个场景都有一个共同的特定需求。Python脚本必须满足以下条件之一才能成功进行权限提升尝试:</p><ul class=""><li id="e05e" class="ku kv hi ix b iy iz jc jd jg kw jk kx jo ky js li la lb lc bi translated">脚本必须被编译成二进制格式，呈现更高特权用户的<strong class="ix hj"> SUID </strong>权限(可执行文件将继承所有者的特权)。您可以通过以下命令在Linux系统中搜索SUID文件:</li></ul><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="e479" class="jt ju hi lo b fi ls lt l lu lv">find / -perm /4000</span></pre><ul class=""><li id="ec5c" class="ku kv hi ix b iy iz jc jd jg kw jk kx jo ky js li la lb lc bi translated">脚本必须被编译成二进制格式，表示更高特权组的<strong class="ix hj"> SGID </strong>权限(脚本将继承组所有者的特权)。您可以通过以下命令在Linux系统中搜索SGID文件:</li></ul><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="f50b" class="jt ju hi lo b fi ls lt l lu lv">find / -perm /4000</span></pre><p id="80e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，您可以搜索同时拥有SUID和SGID权限的文件:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="cbaf" class="jt ju hi lo b fi ls lt l lu lv">find / -perm /6000</span></pre><ul class=""><li id="3284" class="ku kv hi ix b iy iz jc jd jg kw jk kx jo ky js li la lb lc bi translated">脚本可以使用<strong class="ix hj"> SUDO </strong>来启动，并且可以在<strong class="ix hj"> <em class="kt">根目录</em> </strong>下运行。您可以通过终端输入以下命令来检查这是否可行:</li></ul><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="68cb" class="jt ju hi lo b fi ls lt l lu lv">sudo -l</span></pre><h2 id="9ab7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">场景1:对导入的Python模块的写权限</h2><p id="c478" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">假设我们有一个Python脚本，它导入了<strong class="ix hj"> <em class="kt"> base64 </em> </strong>模块，并从该模块调用了<strong class="ix hj"> <em class="kt"> b64encode </em> </strong>函数，以便对特定的字符串进行编码。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/a0af520e313d79297402e877c268a481.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*-S_90wrCSCFMmyQVHYtFLw.png"/></div></figure><p id="98ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们在Linux文件系统中定位<strong class="ix hj"> <em class="kt"> base64 </em> </strong>模块路径。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/2be3f7b1be19ed3c3132702669196520.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*5oBMQbmlx3-KAITj0vKq3g.png"/></div></figure><p id="74fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在许多路径下得到它(因为我安装了更多的Python版本)，但是我们的注意力应该落在Python3.7路径上:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="3975" class="jt ju hi lo b fi ls lt l lu lv">/usr/lib/python3.7/base64.py</span></pre><p id="8812" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们检查一下Python模块的权限。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/8ba6052f1fff738db88db5325a27ec0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*Ftw0OCz9ZaxokRz17WE3nQ.png"/></div></figure><p id="0974" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以清楚地看到，它获得了<strong class="ix hj"> <em class="kt">读</em> </strong>，<strong class="ix hj"> <em class="kt">写</em> </strong>，<strong class="ix hj"> <em class="kt">执行</em> </strong>的权限，为<strong class="ix hj"> <em class="kt">所有人。</em>T15】</strong></p><p id="ab36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，必须编辑该文件中的<strong class="ix hj"> <em class="kt"> b64encode </em> </strong>函数，以执行系统命令，如<strong class="ix hj"> <em class="kt"> whoami </em> </strong>。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/99b19642fdad5541587d0606e65a56db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mCzv_IHyJdbPW6Izwz_Jsw.png"/></div></div></figure><p id="0196" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">保存文件，返回终端并输入以下命令，检查我们可以使用<strong class="ix hj"> <em class="kt"> sudo </em> </strong>运行哪些文件:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="3eb2" class="jt ju hi lo b fi ls lt l lu lv">sudo -l</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/06bdb20a54a0e1a4fb1ac26f0b0d0dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*gZXE5c3ryWJqvgCJrH9EMA.png"/></div></figure><p id="088f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行完脚本后，我们在这里:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/8587f1fe4ff799e3f6133d6fe28e0672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*NLUDo5SoOQDqRHCV1YNJWQ.png"/></div></figure><p id="70cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们注意到<strong class="ix hj"> <em class="kt"> whoami </em> </strong>系统命令被执行<strong class="ix hj"> <em class="kt"> </em> </strong>并返回预期结果<strong class="ix hj"> <em class="kt">。</em> </strong></p><h2 id="55c2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">场景2: <strong class="ak"> <em class="mc">优先级更高的Python库路径与破碎特权</em> </strong></h2><p id="5527" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">当在脚本中导入模块时，Python将按照特定的优先级顺序在一些预定义的目录中搜索该模块文件，并选择第一个出现的位置。</p><p id="af95" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，在Ubuntu上，默认的搜索优先级如下:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="1acb" class="jt ju hi lo b fi ls lt l lu lv">/usr/lib/pythonX<br/>/usr/lib/pythonX/plat-x86_64-linux-gnu<br/>/usr/lib/pythonX/lib-tk<br/>/usr/lib/pythonX/lib-old<br/>/usr/lib/pythonX/lib-dynload<br/>/usr/local/lib/pythonX/dist-packages<br/>/usr/lib/pythonX/dist-packages</span><span id="cea7" class="jt ju hi lo b fi md lt l lu lv">X - Python Version (2.6, 2.7, 3.7, and so on)</span></pre><p id="7182" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以根据您的Python版本，使用以下命令查找您的订单:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="e297" class="jt ju hi lo b fi ls lt l lu lv">pythonX -c 'import sys; print("\n".join(sys.path))'</span><span id="f08c" class="jt ju hi lo b fi md lt l lu lv">X - Python Version (2.6, 2.7, 3.7, and so on)</span></pre><p id="d77a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也许你已经知道了攻击是如何进行的，如果没有，我将在下面的段落中解释。</p><p id="2012" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">被搜索的模块将位于一个定义的路径中，但是如果Python在一个优先级更高的文件夹中找到一个与<strong class="ix hj"><em class="kt"/></strong>同名的模块，它将导入那个模块而不是“合法的”模块。</p><p id="ea9e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种方法的工作要求是能够在模块所在的文件夹之上的文件夹中创建文件。</p><p id="b6cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用相同的<strong class="ix hj"> <em class="kt">劫持. py </em> </strong>脚本，但是我将<strong class="ix hj"> <em class="kt"> base64.py </em> </strong>模块移动到了目录层次结构中优先级较低的文件夹，因此现在<em class="kt"> /usr/lib/python3.7/ </em>文件夹不再包含该模块<em class="kt">。</em></p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/93e2bcf0966dbff711dc2d61c4e6c838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*gFvYGg2-okounPchjVStMg.png"/></div></div></figure><p id="89f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的截图提供了Python库搜索的实际文件夹优先级层次，在我的本地机器上。</p><p id="18b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我将检查<em class="kt"> /usr/lib/python3.7. </em>的权限</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/5f7e6ce3e1822ba96f661485ebf2ccc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*AbPk_ViAe_EUEANca7WF6A.png"/></div></figure><p id="dc10" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样，文件夹里有<strong class="ix hj"> <em class="kt">读</em> </strong>，<strong class="ix hj"> <em class="kt">写</em> </strong>，<em class="kt">执行</em> 的权限，所以我们可以在里面创建我们自定义的<strong class="ix hj"> <em class="kt"> base64.py </em> </strong>模块。</p><p id="895d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">恶意模块必须包含一个通过Python脚本调用的函数定义(在我们的例子中为<strong class="ix hj"> <em class="kt"> b64encode </em> </strong>)，并具有确切的参数数量(在我们的例子中，只有一个字符串被解析为参数，因此我们将使用一个参数来定义函数，称为“<em class="kt"> a </em>”)。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/0e2933b6c4940f399fc70f116aef3e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*vM-kWz4rHKTY44eQPMVLkg.png"/></div></figure><p id="1aec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，保存模块，运行脚本，注意有效负载已经成功执行。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/e5b314b76fc04b3a2796864bb5ef01a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*Xnn1jzxQzQqMCE-oMrC7Uw.png"/></div></figure><h2 id="27b7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">场景3: <strong class="ak"> <em class="mc">通过PYTHONPATH环境变量</em> </strong>重定向Python库搜索</h2><p id="b9c0" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated"><strong class="ix hj"> <em class="kt"> PYTHONPATH </em> </strong>环境变量<strong class="ix hj"> <em class="kt"> </em> </strong>表示一个(或多个)目录，Python可以在其中搜索要导入的模块。</p><p id="8f8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果用户获得了设置或修改该变量的权限，通常是通过一个可以使用<strong class="ix hj"> <em class="kt"> sudo </em> </strong>权限运行的脚本，并获得了设置到<strong class="ix hj"> <em class="kt"> /etc/sudoers </em> </strong>文件中的<strong class="ix hj"> <em class="kt"> SETENV </em> </strong>标记，则该漏洞可能会被滥用。</p><p id="c58c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的例子中，我将Python模块移动到了<strong class="ix hj"> <em class="kt"> /tmp/ </em> </strong>文件夹中。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/e0726af56215ca93c7512687e334e3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*Jdk5SKGJed8AyuVhj-T3NA.png"/></div></figure><p id="dc69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们通过“<em class="kt"> sudo -l </em>”命令来检查<strong class="ix hj"> <em class="kt"> SETENV </em> </strong>标签是否被设置:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/85bada6cf744e728791eb37b5d45fe59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*opKgBDwIQ_6EXHiAFRqpuA.png"/></div></figure><p id="f90e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以这样运行脚本:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/5dc4f8e7278e02e3dc9f06b9cb13f1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*-YkvfhsyYKnvfax0wByByw.png"/></div></figure><p id="1c25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在那里！</p><h2 id="a56a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">预防提示</h2><p id="0b89" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">不要在Python模块所在的文件夹上为用户设置写权限。</p><p id="8e1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过虚拟环境限制对特定模块的访问，而不是让Python搜索文件夹。</p><p id="bec4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我真的希望这篇文章是有用的，并祝大家有一个美好的一天！</p></div></div>    
</body>
</html>