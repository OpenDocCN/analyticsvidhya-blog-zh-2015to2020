<html>
<head>
<title>Looking for the Best Lightweight Data Analysis Script Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找最好的轻量级数据分析脚本工具</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/looking-for-the-best-lightweight-data-analysis-script-tools-ccde17a63fc6?source=collection_archive---------21-----------------------#2020-08-27">https://medium.com/analytics-vidhya/looking-for-the-best-lightweight-data-analysis-script-tools-ccde17a63fc6?source=collection_archive---------21-----------------------#2020-08-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cf70" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">哪些编程语言适合做桌面分析工作？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/b01fb7589f998a8d31dc4ac1c2945a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*u7jHkSqyt3FMzwMDeFVUGA.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">作者图片</figcaption></figure><p id="96bd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">几乎所有的编程语言都可以操作数据。有些过于笼统，缺少执行结构化计算的功能，比如C++和JAVA，产生冗长的代码来处理日常的数据分析场景，更适合打理重大的特殊项目。有些面向技术，对于日常分析工作来说过于专业，比如数学编程语言MATLAB和R，尽管它们提供了结构化数据处理的功能。我在本文中的主题是适合做桌面分析工作的轻量级编程语言。分别是以MySQL、Excel VBA、Python熊猫、esProc为代表的轻量级数据库。</p><p id="8cff" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我将仔细分析每种方法的优缺点，看看它们的能力。</p><h1 id="3515" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">关系型数据库</h1><p id="ed05" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">在桌面上运行小型数据库很容易，比如HSQLDB、DerbyDB、SQLite或MySQL。这里我就以MySQL为例。</p><p id="42f7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">MySQL的便携版便于安装和配置。虽然环境配置问题，如文件夹权限问题，只能通过安装程序版本来解决，但用户友好的向导将弥补这一麻烦。</p><p id="e1a1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">MySQL支持使用其内置的命令行工具执行SQL，但交互式用户界面很粗糙。许多人求助于第三方工具Navicat或Toad来做同样的事情。所以UI设计不是MySQL的强项。</p><p id="f367" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">编程语言的本质优势当然是数据处理能力。为此，MySQL本质上依赖于SQL来获得它的能力。</p><p id="3358" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">SQL经过近50年的发展，已经接近其模型框架的极限。几乎每个基本算法都有它们的SQL表达式。这大大降低了想要进行数据处理的分析师的门槛。近年来，MySQL开始提供对窗口函数、WITH子句和存储过程的支持。这使得它的能力不亚于任何大型数据库。以在MySQL中实现以下算法为例:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="4a67" class="lh kg hi ld b fi li lj l lk ll">/*Filtering. emp table stores information of employees in every department*/</span><span id="d94c" class="lh kg hi ld b fi lm lj l lk ll">select eid, name, deptid, salary from emp where salary between 8000 and 10000 and hireday&gt;=’2010–01–01'</span><span id="b5ca" class="lh kg hi ld b fi lm lj l lk ll">/*Sorting*/</span><span id="a8ec" class="lh kg hi ld b fi lm lj l lk ll">select * from emp order by salary</span><span id="09bc" class="lh kg hi ld b fi lm lj l lk ll">/*Distinct*/</span><span id="25a1" class="lh kg hi ld b fi lm lj l lk ll">select distinct deptid from emp</span><span id="aa9c" class="lh kg hi ld b fi lm lj l lk ll">/*Grouping &amp; aggregation. share table stores the daily closing prices for a certain share*/</span><span id="b371" class="lh kg hi ld b fi lm lj l lk ll">select year(sDate),month(sDate),max(price) from share group by year(sDate),month(sDate)</span><span id="f10a" class="lh kg hi ld b fi lm lj l lk ll">/*Join; dept table stores department information*/</span><span id="12a3" class="lh kg hi ld b fi lm lj l lk ll">select e.name, e.salary, d.deptname from emp e inner join dept d on e.deptid=d.deptid</span><span id="18b5" class="lh kg hi ld b fi lm lj l lk ll">/*Windowing; rank employees in each department by their salaries*/</span><span id="587d" class="lh kg hi ld b fi lm lj l lk ll">select eid, name, deptid, salary, rank()over( partition by deptid order by salary desc) rk from emp</span></pre><p id="825e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">MySQL处理基本操作真的很好。但是对于复杂的操作就不是这样了，因为SQL不擅长处理它们。</p><p id="bb69" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">SQL不擅长实现多步进程模式算法。这里的一个例子是根据<em class="ln"> emp </em>表找到雇员最多的部门和雇员最少的部门。直觉上，完成任务有两个步骤。首先，将表格按部门分组，统计每个部门的员工数；第二，按雇员数量降序排列各组。现在第一个部门和最后一个部门是我们需要的。然而，SQL通过使其成为4步过程来实现该算法。第一步不变。接下来，它使用max函数计算雇员的最大数量，并使用嵌套查询或连接查询找到相应的部门。然后用同样的方法找到员工最少的部门。最后，使用union合并第二步和第三步的结果。代码如下:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="297c" class="lh kg hi ld b fi li lj l lk ll">with tmp as (<br/>select dept, count(*) total from employee group by dept),<br/>deptmax as(<br/>select dept from tmp where total=(<br/>select max(total) from tmp)<br/>),</span><span id="90e3" class="lh kg hi ld b fi lm lj l lk ll">deptmin as(<br/>select dept from tmp where total=(<br/>select min(total) from tmp)<br/>)</span><span id="7588" class="lh kg hi ld b fi lm lj l lk ll">select dept from deptmax<br/>union<br/>select dept from deptmin</span></pre><p id="013a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是不必要的冗长。</p><p id="f1b7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">考虑到SQL发明的时间，它有一定的缺陷是可以理解的。基于订单的计算是SQL不擅长的另一个场景。例如，根据<em class="ln">股票</em>表，找出某一股票连续上涨了多少天。SQL没有一种直接的方式来表达“连续上升”的概念，所以我们需要采取一种非常迂回的方式。首先，您计算每个交易日期的累计非上升天数。非上涨天数相同的交易日为连续上涨天数。然后，根据日期是否连续上升对记录进行分组，以获得最大连续间隔。即使是SQL专家也觉得处理这样的算法很头疼。而且他们的代码解决方案对于普通用户来说很难读懂。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="8d1f" class="lh kg hi ld b fi li lj l lk ll">select max(consecutive_days)<br/>from (select count(*) consecutive_days<br/> from (select sum(updown_flag) over(order by sdate) no_up_days<br/> from (select sDate,<br/> case when<br/> price&gt;LAG(price) over(order by sDate)<br/> then 0 else 1 end updown_flag<br/> from share) )<br/>group by no_up_days)</span></pre><p id="ccdf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">实际上，由于使用了窗口函数，这更简单。如果您使用早期版本的SQL，代码将更难编写和阅读。</p><p id="8bc8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">另一个例子是按照指定的集合对齐记录。<em class="ln">订单</em>表存储订单记录。我们需要计算从周日到周六的订单中当天的大订单金额(金额&gt; 15000)。给没有订单的一天一个空值。SQL使用伪表技术将工作日列表转换为一组记录，然后将伪表左连接到<em class="ln"> orders </em>表。实现是复杂的:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="4dd9" class="lh kg hi ld b fi li lj l lk ll">with std as(<br/>select 1 No,’Sun.’ name from dual union<br/>select 2 ,’Mon.’ from dual union<br/>select 3 ,’Tues.’ from dual union<br/>select 4 ,’Wed.’ from dual union<br/>select 5 ,’Thur’ from dual union<br/>select 6 ,’Fri.’ from dual union<br/>select 7 ,’Sat.’ from dual<br/>)</span><span id="f12d" class="lh kg hi ld b fi lm lj l lk ll">select std.No,std.name,data.total from std left join (<br/> select DAYOFWEEK(orders.orderdate) No,sum(amount) total<br/> from orders<br/> where amount&gt;15000<br/> group by DAYOFWEEK(orders.birthday)<br/>) data<br/>on std.No=data.No order by std.No</span></pre><p id="961c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我可以举出很多SQL头疼的例子。这种语言太老了，无法适应我们复杂的业务需求。虽然它试图通过一系列修补和升级来跟上时代，包括with子句、存储过程和窗口函数，但它所基于的框架限制了它的表达。</p><p id="7893" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，SQL被实现为面向内部的，尽管本质上不是这样。基于SQL的数据库可以计算数据库内部的数据表，但很难读写外部数据源中的数据。</p><p id="b83b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，数据操作的第一步是数据源检索，最后一步是以目标格式输出结果集。评估脚本工具的一个重要方面是它支持外部数据源读/写的能力。不幸的是，MySQL只能读取(不包括写入)一个外部数据源，即CSV文件。而且阅读过程一点也不简单。例如，要将标准格式的<em class="ln"> emp.csv </em>文件导入数据库，需要4个步骤:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="0145" class="lh kg hi ld b fi li lj l lk ll">mysql&gt;use testdb;<br/>mysql&gt;create table emp (<br/>-&gt; empid int(10) not null,<br/>-&gt; name varchar(50),<br/>-&gt; deptid int(10),<br/>-&gt; salary float,<br/>-&gt; sex varchar(1),<br/>-&gt; birthday date,<br/>-&gt; hireday date)CHARSET = utf8;<br/>mysql&gt;LOAD DATA INFILE 'd:\data\emp.csv' INTO TABLE emp<br/>-&gt;CHARACTER SET utf8<br/>-&gt;FIELDS TERMINATED BY ','<br/>-&gt;LINES TERMINATED BY '\r\n'<br/>-&gt;IGNORE 1 LINES;<br/>mysql&gt;ALTER TABLE emp ADD PRIMARY KEY (empid);</span></pre><p id="a2ae" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">SQL的闭包设计在开始时没有考虑文件检索，这导致了极其复杂的实现，尽管后来它被打上了文件检索特性的补丁。</p><p id="1e85" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Navicat等第三方工具使MySQL能够支持更多类型的数据源。但本质上，它们只是将外部数据源转换成文本文件，然后将其加载到MySQL数据库中。非本地的修补方法有很多缺点。古老格式的数据源，如Dbase和Paradox，得到了最好的支持，但很少使用。Excel文件加载有非常严格的要求，因此很少成功。JSON的支持只适用于特殊的二维格式。实际上，Navicat并不支持我们现在使用的几乎所有常见数据源。</p><p id="ec93" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">SQL很难调试。这大大降低了开发速度。</p><p id="d1ec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">标准的教科书算法不需要调试，因为它们只用几行代码就实现了。真实世界的数据操作代码很复杂，通常有大约一百行嵌套的SQL查询。无法调试使得理解和维护代码变得困难，从而导致低性能。</p><p id="93f3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">简而言之，SQL擅长用基本操作处理数据库数据，但在处理外部数据源中的数据和实现复杂算法方面有所欠缺。SQL所没有的东西为新的脚本工具提供了机会，这些工具是轻量级的，是为PC时代设计的桌面工具。</p><h1 id="865d" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">超越VBA</h1><p id="2ca5" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">PC的兴起，让用户群体从科学家变成了普通人。于是，一种非编程的桌面数据处理工具Excel应运而生，并赢得了世界范围的流行。它在最近几年添加了一系列插件，包括PowerQuery，以扩展其对数据源类型的支持，并加强数据处理能力。</p><p id="4e6e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这使得它成为非程序员使用的最强大的数据操作工具。我没有夸张。</p><p id="d23e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，非编程优势很快变成了一个巨大的劣势。VBA出生了。VBA的目标是通过支持编程为Excel创造无限的数据处理能力。</p><p id="6844" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">问题是这个目标实现得有多好。作为一个支持编程能力的脚本工具，VBA在理论上当然是极其灵活和全能的，尤其是它的进程模式实现算法和调试能力。这比SQL好得多。另一方面，由于缺乏用于结构化计算的特殊函数，该语言仍然是通用的，尽管它有用于访问单元格的特殊函数。所以在VBA操纵数据是非常复杂的。在很多场合我宁愿使用SQL。</p><p id="780c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">以文件读取为例，因为那是数据处理最基础的东西。例如，要将第一行是列标题的<em class="ln"> order.csv </em>读入当前的Excel工作表，您需要编写一段很长的代码:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="ce49" class="lh kg hi ld b fi li lj l lk ll">Const Title As String =   "IMPORT CSV TEST"</span><span id="d1d7" class="lh kg hi ld b fi lm lj l lk ll">Sub fMain()<br/>Dim fTextDir As String<br/>Dim pintLen As Integer<br/>Dim pstrValue As String<br/>Dim rowIndex As Integer<br/>Dim i As Integer<br/>rowIndex = 1<br/>pstrValue = ""<br/>pintLen = Len(Title)<br/>fTextDir =   "D:/orders.csv" <br/>Open fTextDir For Input As #1 <br/>Do While Not EOF(1) ' loop every   line<br/>Line Input #1, currLine <br/>  If Right(currLine, pintLen) =  Title Then<br/>  Range(Cells(rowIndex, 1),  Cells(rowIndex, 4)).Select<br/>   With Selection<br/>       .HorizontalAlignment =   xlCenter<br/>       .VerticalAlignment = xlTop<br/>     .WrapText  = False<br/>       .Orientation = 0<br/>     .AddIndent  = False<br/>       .ShrinkToFit = False<br/>      .ReadingOrder = xlContext<br/>      .MergeCells  = True<br/>      .RowHeight  = 27.75<br/>      .Font.Name  = "Arial"</span><span id="0d67" class="lh kg hi ld b fi lm lj l lk ll">.Font.Size  = 18<br/>      .Font.Bold  = True<br/>      .FormulaR1C1 = Title<br/>        .Interior.ColorIndex = 6<br/>      .Interior.Pattern = xlSolid<br/>    End With<br/>    Else<br/>    rowDataArr = Split(currLine,  ",")<br/>    For i = 0 To UBound(rowDataArr)<br/>      Cells(rowIndex, i + 1).Select<br/>    With  Selection<br/>       .HorizontalAlignment =   xlCenter<br/>       .VerticalAlignment = xlTop<br/>       .WrapText = False<br/>       .Orientation = 0<br/>       .AddIndent = False<br/>       .ShrinkToFit = False<br/>       .ReadingOrder = xlContext<br/>       .MergeCells = True<br/>       .RowHeight = 20<br/>       .Font.Name = "Arial"<br/>       .Font.Size = 12<br/>       .Font.Bold = False<br/>       .FormulaR1C1 = rowDataArr(i)<br/>     End With<br/>  Next i<br/>    End If<br/>    rowIndex = rowIndex + 1<br/> Loop<br/>   Close #1<br/>End Sub</span></pre><p id="3d09" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是标准数据格式的文件。你可以想象如果数据是脏的，比如空行、特殊分隔符或者由一条记录组成的多行，代码的复杂程度。</p><p id="d75f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们来看看PowerQuery。它支持许多类型的数据源，但只有在根据向导加载静态数据时才是方便的。然而，动态加载将是一场噩梦。PowerQuery仅支持数据加载。要将结果集输出到目标数据源，您必须求助于VBA方法(但是您可以直接输出CSV)。</p><p id="f8ea" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">用PowerQuery甚至很难实现基本的结构化算法。例如，要对sheet1中的列A进行分组并对列B进行求和，您需要一大段代码。下面是省略了数据检索部分的代码片段:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="6d1a" class="lh kg hi ld b fi li lj l lk ll">Public Sub test()<br/> Dim Arr<br/> Dim MyRng As Range<br/> Dim i As Long<br/> Dim Dic As Object<br/> <br/> Set MyRng = Range("A1").CurrentRegion<br/> Set MyRng = MyRng.Offset(1).Resize(MyRng.Rows.Count   - 1, 2)<br/> Set Dic = CreateObject("Scripting.dictionary")<br/> Arr = MyRng<br/> For i = 1 To UBound(Arr)<br/>    If Not Dic.exists(Arr(i, 1)) Then<br/>    Dic.Add Arr(i, 1), Arr(i, 2)<br/> Else<br/>       Dic.Item(Arr(i, 1)) = Dic.Item(Arr(i, 1)) + Arr(i, 2)<br/>       End If<br/> Next i<br/> Sheet2.Range("A1") =   "subject"<br/> Sheet2.Range("A2").Resize(Dic.Count)   =  Application.WorksheetFunction.Transpose(Dic.keys)<br/> Sheet2.Range("B1") =   "subtotal"<br/> Sheet2.Range("B2").Resize(Dic.Count)   =  Application.WorksheetFunction.Transpose(Dic.items)<br/> Set Dic = Nothing<br/>End Sub</span></pre><p id="48f3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一句话，VBA没有真正实现它的目标。事实上，它对程序员没有什么价值，尤其是桌面分析师。那真是太遗憾了。通过关注过程模式描述，VBA绕过了结构化算法的实现。</p><p id="bcf3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">哪里有失败，哪里就有替代。</p><h1 id="8452" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">蟒蛇熊猫</h1><p id="f758" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">实际上，Python比VBA还要古老。但是在互联网普及之前，它是看不见的，它跳上了使用开源社区来扩展各种第三方函数库的潮流。其中一个明星函数库是用于数据操作的Pandas。</p><p id="fb93" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Python旨在易于读写。它在功能层面上不辜负最初的期望。每个功能简单，功能强大，界面清晰，易于使用。以下是其用于基本结构化计算的功能:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="eebc" class="lh kg hi ld b fi li lj l lk ll">df.query(‘salary&gt;8000 and salary&lt;10000’) #Filering</span><span id="5aa3" class="lh kg hi ld b fi lm lj l lk ll">df.sort_values(by=”salary”,ascending = True) #Sorting</span><span id="b181" class="lh kg hi ld b fi lm lj l lk ll">df.groupby(“deptid”)[‘salary’].agg([len, np.sum, np.mean]) #Grouping &amp; Aggregation</span></pre><p id="ac48" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">依靠开源社区的廉价和高效的资源，Pandas已经能够产生大量丰富的功能，几乎涵盖了所有常见的结构化算法。因为它继承了Pythons的语法，所以调用Pandas函数也很容易。由于这两个优点，熊猫处理基本的数据操作任务又快又好。</p><p id="5da3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在结构化计算的函数存储中，它与SQL打了个平手。但是它比SQL支持更多的外部数据源。下面是用于检索CSV/TXT文件的read_csv函数:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="3772" class="lh kg hi ld b fi li lj l lk ll">import pandas as pd</span><span id="970c" class="lh kg hi ld b fi lm lj l lk ll">df=pd.read_csv(‘D:/emp.csv’) #return as a DataFrame</span></pre><p id="cb53" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是为了检索一个标准格式的CSV文件。通过设置参数，它可以轻松处理非标准数据格式，如第一行不是列标题和跳过N行。</p><p id="9f72" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Pandas支持简单地通过函数从几乎所有类型的外部数据源加载数据，包括数据库、JSON文件、Excel文件和web数据。它也很容易写，因为它的函数有清晰的接口，很容易调用。这些是典型的Pythons风格。</p><p id="cb37" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Pandas(实际上是Python)，一种标准的过程语言，有一个SQL没有的优点。它支持常见的调试技术，包括断点、单步执行和跳进/跳出，以快速消除代码错误并轻松维护复杂的算法。它远比SQL高效。</p><p id="0078" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于初学者来说，Pandas丰富且易于使用的库函数很有吸引力，这些库函数是为执行结构化计算和访问外部数据源而设计的。然而，当他们潜得更深时，他们会看到一幅不同的画面。当一起工作来执行日常算法时，作为个体高效而轻松地工作的函数变得笨拙而困难。结果是困难和复杂的代码。</p><p id="8aff" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如，<em class="ln"> split_field.csv </em>是一个制表符分隔的文本文件，它有两个字段ID和ANOMOALIES。我们需要用空格将每个ANOMOALIES字段值分成多个字符串，并将每个字符串组合到相应的ID字段值中，以生成一个新记录。</p><p id="1b52" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">源数据(<em class="ln"> split_field.csv </em>):</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lo"><img src="../Images/fab8394082a320cc4ca0315a02f76791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x39PaXQ3N2IS1XOvyWa7ig.png"/></div></div></figure><p id="b337" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">已处理的数据:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lo"><img src="../Images/a69a63e62defec6e28c8291833d44ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEaPce2wmWUOIwVsQj0AyQ.png"/></div></div></figure><p id="01f8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">实现上述算法的代码:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="da17" class="lh kg hi ld b fi li lj l lk ll">import pandas as pd<br/>import numpy as np</span><span id="2012" class="lh kg hi ld b fi lm lj l lk ll">split_field = pd.read_csv('C:\\split_field.csv',sep='\t')<br/>split_dict = split_field.set_index('ID').T.to_dict('list')<br/>split_list = []</span><span id="9087" class="lh kg hi ld b fi lm lj l lk ll">for key,value in split_dict.items():<br/>    anomalies = value[0].split(' ')<br/>    key_array = np.tile(key,len(anomalies))<br/>    split_df =   pd.DataFrame(np.array([key_array,anomalies]).T,columns=['ID','ANOMALIES'])<br/>    split_list.append(split_df)</span><span id="3edf" class="lh kg hi ld b fi lm lj l lk ll">split_field = pd.concat(split_list,ignore_index=True)<br/>print(split_field)</span></pre><p id="a0a9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这段代码并不那么简单，尽管字符串分割是熊猫的强项之一。进行基于顺序的计算的代码会更加困难。这里有一个例子。<em class="ln"> duty.csv </em>记录每天的工作安排。一个人将在另一个人轮班之前连续工作几天。任务是得到每个工人所有连续的轮班时间。</p><p id="2b7f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">源数据(<em class="ln"> duty.csv </em>):</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lt"><img src="../Images/39a6f16a0a8af4251ff2fba673becb2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwYhJyXTxz5rxFvbi-FagA.png"/></div></div></figure><p id="2682" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">已处理的数据:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lu"><img src="../Images/503528a1575355e66b351d7433984808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zu8Bg6OGXBJpKUX2p--LOA.png"/></div></div></figure><p id="5d2e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">熊猫代码实现上述算法:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="3b8d" class="lh kg hi ld b fi li lj l lk ll">import pandas as pd<br/>import numpy as np</span><span id="e69b" class="lh kg hi ld b fi lm lj l lk ll">duty = pd.read_csv('C:\\duty.csv',sep='\t')<br/>name_rec = ''<br/>start = 0<br/>duty_list = []</span><span id="25a5" class="lh kg hi ld b fi lm lj l lk ll">for i in range(len(duty)):<br/>    if name_rec == '':<br/>        name_rec = duty['name'][i]<br/>    if name_rec != duty['name'][i]:<br/>        begin =   duty['date'].loc[start:i-1].values[0]<br/>        end =   duty['date'].loc[start:i-1].values[-1]<br/>        duty_list.append([name_rec,begin,end])<br/>        start = i<br/>        name_rec = duty['name'][i]</span><span id="cc25" class="lh kg hi ld b fi lm lj l lk ll">begin = duty['date'].loc[start:i].values[0]<br/>end = duty['date'].loc[start:i].values[-1]<br/>duty_list.append([name_rec,begin,end])<br/>duty_b_e = pd.DataFrame(duty_list,columns=['name','begin','end'])<br/>print(duty_b_e)</span></pre><p id="4f66" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这两个例子表明，只有个别熊猫函数易于读写，但在处理日常业务算法时却变得难以使用。然而，现实世界中的源数据格式并不总是标准的，也不可能只使用基本算法。随时随地都有未知。基本功能必须善于团队合作，足够灵活，根据需要做好数据清理、转换和计算。</p><p id="fb41" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">熊猫问题是由于Python和它的众多开源社区(熊猫是其中的一员)之间的松散关系。Pandas有权更新自己的函数，但无权更改函数调用语法。Python开发团队也缺乏足够的资源来照顾好每一个开源社区，来改进语法，使功能方便流畅地协作。</p><p id="998e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">熊猫在处理无法放入内存的数据(不是大数据)方面也有困难。</p><p id="04a8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一般来说，语言以递归的方式处理这种数据。一次读取和计算一小部分数据，存储每个中间结果集，并组合这些结果集(如过滤)或进一步处理它们(如分组和聚合)以获得最终结果集。即使是一个基本的结构化算法，当数据量很大的时候，也不简单，更不用说join、merge、set运算等复杂的算法，或者做现实业务的基本算法的动态组合了。</p><p id="b80c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了简化用于处理大量数据的算法的实现，如果脚本工具在底层提供一种机制来实现自顶向下的内存数据和外部数据的自动交换，并自底向上隐藏计算细节，从而允许分析师使用与用于处理少量数据的语法类似的语法来操作数据，那将会更好。然而Python并没有给熊猫配备这种能力。桌面分析师必须自己编写底层逻辑。这解释了难以置信的复杂的熊猫代码处理大量数据。</p><p id="e98c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如，<em class="ln"> orders.csv </em>存储订单数据，我们希望找到每个销售人员的3个最大订单。这是熊猫的代码:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="dcf3" class="lh kg hi ld b fi li lj l lk ll">import pandas as pd<br/>import numpy as np</span><span id="2644" class="lh kg hi ld b fi lm lj l lk ll">chunksize=1000000<br/>order_data = pd.read_csv(d:\\orders.csv',iterator=True,chunksize=chunksize)<br/>group_list = []<br/>for chunk in order_data:<br/>    for_inter_list = []<br/>    top_n =   chunk.groupby(by='sellerid',as_index=False)<br/>    for index,group in top_n:<br/>        group = group.sort_values(by='amount',ascending=False).iloc[:3]<br/>          for_inter_list.append(group)<br/>    for_inter_df =   pd.concat(for_inter_list,ignore_index=True)   <br/>    group_list.append(for_inter_df)</span><span id="766e" class="lh kg hi ld b fi lm lj l lk ll">top_n_gr = pd.concat(group_list,ignore_index=True).groupby(by='sellerid',as_index=False)<br/>top_n_list=[]<br/>for index,group in top_n_gr:<br/>    group =   group.sort_values(by='amount',ascending=False).iloc[:3]<br/>    top_n_list.append(group)<br/>top_3 = pd.concat(top_n_list)<br/>print(top_3)</span></pre><p id="b7fa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一个优秀的数据脚本工具不仅会尝试简化算法表达式，还会使用压缩分段和多线程处理等方式来加速执行。Python应该向其开源社区提供这些底层优化技术，以确保第三方库函数的稳定和统一能力。它没有。开源社区自己做的。例如，joblib社区实现了对多线程处理的支持。</p><p id="73f6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以熊猫现在跑得更快了，不是吗？</p><p id="236d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">不要！正如我所说的，Python和开源社区之间的关系是松散的。而且开源社区之间的关系更松散。熊猫很难使用第三方多线程库函数。理论上，上面的示例代码可以重写以使用多线程；实际上，更快是不可能的！</p><p id="adfb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">另一个后果是，这限制了熊猫对各种数据源的访问。</p><p id="16dc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Pandas支持几乎所有类型的数据源，因为每种类型的数据源背后都有开源社区和第三方函数库。MySQL数据库有三个最常用的函数库——sqlalchemy、MySQLdb和PyMySQL。每个数据库都由多个开源社区支持，并且有多个函数库，每个函数库都有自己的用途。</p><p id="3420" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">专业程序员可能认为有更多选择是件好事。但是没有桌面分析师愿意使用复杂的pip命令来搜索和部署不同的函数库并测试它们的差异。我们只想要一个轻量级的桌面脚本工具，它可以使用简单和统一的语法来访问数据源，以进行进一步的数据操作。</p><p id="2792" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">总之，熊猫有同样明显的优点和缺点。优点是丰富多样的库函数。缺点是日常算法的复杂实现，处理大量数据的算法的复杂实现，以及对桌面分析师不友好。</p><p id="3bbd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有没有一个轻量级的桌面数据脚本工具，配备了专业和丰富的结构化计算功能，但没有熊猫的弱点？这就是我接下来想谈的。</p><h1 id="eb78" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">埃斯普罗克</h1><p id="2be2" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">它提供了丰富的操作结构化数据的函数。例如:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lv"><img src="../Images/b74c46d117a733a34ba8067fcd7c9a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mybCj1sEK4-cIQuy0JdXWA.png"/></div></div></figure><p id="6810" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">A1使用的import()函数是加载标准格式CSV文件的方法。它可以加载一个非标准格式的，比如第一行不是列标题，通过设置不同的参数跳过N行。而且很简单。</p><p id="c6f9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">esProc很容易从几乎所有外部数据源读取数据和向其写入数据，包括数据库(如A6所示)、JSON文件、Excel文件和web数据。</p><p id="a946" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">esProc是标准的程序语言。它支持常见的调试方式，如断点、单步和跳转，以提高开发效率。</p><p id="39bb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">esProc还有熊猫没有的东西。最大的一个就是esProc是由独立团队维护的闭源软件。它既不依赖于某些开源社区中的第三方库功能，也不由所谓的上级组织管理。esProc能够从灵活和全面的角度来设计语法。它的功能尽可能灵活地协作，以便能够更快、更方便地解决现实世界中的业务问题。</p><p id="f8e9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里有一个安排非标准数据格式的例子。我们需要将<em class="ln"> split_field.csv </em>的ANOMOALIES字段按空格拆分成字符串，将原来的一行转换成多行。esProc程式码很简单:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lu"><img src="../Images/9027f084d176ad90ad733f0365e4e0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eoqXARhKEtC-pDPaag-A5w.png"/></div></div></figure><p id="0935" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">基于<em class="ln"> duty.csv </em>很容易得到每个工人的所有连续轮班时间:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lu"><img src="../Images/3becd9592eeefa279367f9f72001d507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BppcyvNmCxdTotnRuHbfgw.png"/></div></div></figure><p id="bfe1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">比Python简单多了。这真的很容易读和写。有了统一的语法，esProc可以在底层提供游标机制，使桌面分析人员能够以类似于处理小数据的语法直观地处理大量数据。根据<em class="ln"> orders.csv </em>为每个销售人员获取最大的三个订单:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lw"><img src="../Images/317df8e2916a89b28446f93df5fea6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tu3kHGemLnxjwQ6O6riAg.png"/></div></div></figure><p id="8203" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">统一的语法让esProc很容易在低层级支援多执行绪处理。修改代码以提高性能是很方便的。您可以在上面的代码中使用多线程，如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lw"><img src="../Images/2063a58f808cf5fbe1b9c658e441f912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9Gfa14aD4edFKTOWd06Ew.png"/></div></div></figure><p id="0a76" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">统一的语法使esProc能够通过一种类型的接口访问所有数据库——Pandas使用不同的第三方函数库来实现这一点——并将结果集作为一种数据类型(表序列)返回，供任何类型的数据源直接计算它们。Pandas返回某些数据源的dataframe。对于其他数据源，它将结果集作为CSV文件写入，然后作为dataframe读取。它易于使用，开发速度快，因为你不再需要下载第三方库函数。</p></div></div>    
</body>
</html>