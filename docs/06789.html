<html>
<head>
<title>Use Pytorch Lightning to Decouple Science science code from engineering code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pytorch Lightning将科学代码从工程代码中分离出来</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/use-pytorch-lightning-to-decouple-science-science-code-from-engineering-code-1e6f36cf6a1a?source=collection_archive---------19-----------------------#2020-06-02">https://medium.com/analytics-vidhya/use-pytorch-lightning-to-decouple-science-science-code-from-engineering-code-1e6f36cf6a1a?source=collection_archive---------19-----------------------#2020-06-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if"><p id="726b" class="ig ih hi bd ii ij ik il im in io ip dx translated">Pytorch lighting通过为定义和训练模型提供明确的代码结构，显著减少了样板代码。</p></blockquote><figure class="ir is it iu iv iw er es paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="er es iq"><img src="../Images/28df53f83f7eec8d9f0b9b5bdfdbd729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JANKKXdopykNVg66IFHVVg.png"/></div></div></figure><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="jh ji l"/></div></figure><h2 id="c86f" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">介绍</h2><p id="35c1" class="pw-post-body-paragraph kh ki hi kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la ip hb bi translated">PyTorch Lightning让你将科学代码从工程代码中分离出来。研究通常包括用新的实验变体编辑样板代码。由于这种修补过程，大多数错误都被引入到代码库中。Pytorch lighting通过为定义和训练模型提供明确的代码结构，显著减少了样板代码。</p><h1 id="3522" class="lb jk hi bd jl lc ld le jp lf lg lh jt li lj lk jx ll lm ln kb lo lp lq kf lr bi translated">装置</h1><p id="9c1c" class="pw-post-body-paragraph kh ki hi kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la ip hb bi translated">安装pytorch lightning非常简单:</p><pre class="jd je jf jg fd ls lt lu lv aw lw bi"><span id="1f30" class="jj jk hi lt b fi lx ly l lz ma">pip install pytorch-lightning</span></pre><p id="6236" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">为了在我们的pytorch代码中使用它，我们将导入必要的pytorch lightning模块:</p><pre class="jd je jf jg fd ls lt lu lv aw lw bi"><span id="bac0" class="jj jk hi lt b fi lx ly l lz ma">import pytorch_lightning as pl<br/>from pytorch_lightning.loggers import WandbLogger</span></pre><p id="5a9e" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">我们将使用WandbLogger来跟踪我们的实验结果，并将它们直接记录到wandb。</p><h1 id="56fe" class="lb jk hi bd jl lc ld le jp lf lg lh jt li lj lk jx ll lm ln kb lo lp lq kf lr bi translated">创建我们的闪电课堂</h1><p id="43b6" class="pw-post-body-paragraph kh ki hi kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la ip hb bi translated">为了在pytorch中创建一个神经网络类，我们必须从torch.nn.module导入或扩展。</p><p id="9778" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">让我们创建我们的类，我们将使用它来训练一个对MNIST数据集进行分类的模型。为了比较我们的结果，我们将使用与官方文档中相同的例子。</p><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="mg ji l"/></div></figure><p id="18db" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">正如您在上面看到的，除了导入的基类之外，代码中的其他内容与原始pytorch代码非常相似。在PyTorch中，这种数据加载可以在主训练文件中的任何地方进行。在PyTorch Lightning中，这是在Lightning模块的三个特定方法中完成的。</p><ul class=""><li id="31e2" class="mh mi hi kj b kk mb ko mc ju mj jy mk kc ml ip mm mn mo mp bi translated">train_dataloader()</li><li id="b24c" class="mh mi hi kj b kk mq ko mr ju ms jy mt kc mu ip mm mn mo mp bi translated">val_dataloader()</li><li id="e720" class="mh mi hi kj b kk mq ko mr ju ms jy mt kc mu ip mm mn mo mp bi translated">test_dataloader()</li></ul><p id="b55a" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">第四种方法意味着数据准备/下载。</p><ul class=""><li id="9865" class="mh mi hi kj b kk mb ko mc ju mj jy mk kc ml ip mm mn mo mp bi translated">准备_数据()</li></ul><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="mg ji l"/></div></figure><p id="8be3" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">Lightning的优化器代码是一样的，只是它被添加到LightningModule中的configure _ optimizers()函数中。</p><p id="ecb6" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">如果我们考虑一个传统的pytorch训练管道，我们将需要为epochs实现循环，迭代小批量，为每个小批量执行前馈传递，计算损失，为每个批量执行反向投影，然后最终更新梯度。为了在lightning中做到这一点，我们将训练循环和验证循环的主要部分分成三个函数:</p><ul class=""><li id="b85d" class="mh mi hi kj b kk mb ko mc ju mj jy mk kc ml ip mm mn mo mp bi translated">训练_步骤</li><li id="5a47" class="mh mi hi kj b kk mq ko mr ju ms jy mt kc mu ip mm mn mo mp bi translated">验证_步骤</li><li id="79b3" class="mh mi hi kj b kk mq ko mr ju ms jy mt kc mu ip mm mn mo mp bi translated">验证_结束</li></ul><p id="25c0" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">这些函数的原型是:</p><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="mg ji l"/></div></figure><p id="96e3" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">使用这些功能，Pytorch lightning将自动完成管道的培训部分。我们会谈到这一点，但在此之前，让我们看看pytorch lightning如何轻松地与Weights &amp; Buases集成，以跟踪实验并创建您可以在任何地方监控的可视化效果。</p><h1 id="5fee" class="lb jk hi bd jl lc ld le jp lf lg lh jt li lj lk jx ll lm ln kb lo lp lq kf lr bi translated">训练循环</h1><p id="85e7" class="pw-post-body-paragraph kh ki hi kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la ip hb bi translated">现在，让我们进入训练任何模型的最重要的部分，训练循环。因为我们使用pytorch lightning，大部分的事情已经在幕后处理好了。我们只需要指定一些超参数，训练过程将自动完成。作为一个额外的好处，你还会得到一个很酷的每次迭代的进度条。</p><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="mg ji l"/></div></figure><p id="d0e8" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">为了用闪电训练你的pytorch模型，你需要做的就是这些。这一行代码将很容易取代你的庞大和低效的香草pytorch代码。PyTorch还提供了一个很好的进度条来跟踪每次迭代。</p><figure class="jd je jf jg fd iw er es paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="er es mv"><img src="../Images/1ef25c63a0e48f62e7a7a9ef5438efa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUQkTnJK0Xs0H71Cd-VHGQ.png"/></div></div></figure><p id="46c6" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">让我们看看仪表板中为这次运行<a class="ae mw" href="https://app.wandb.ai/cayush/pytorchlightning/reports/How-to-use-Pytorch-Lightning-with-Weights-%26-Biases--Vmlldzo2NjQ1Mw" rel="noopener ugc nofollow" target="_blank">生成的可视化效果。</a></p><figure class="jd je jf jg fd iw er es paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="er es mv"><img src="../Images/a56338b085dc222c3ca03240ad901800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hwXyxiYKRfNE93whSAejfw.png"/></div></div><figcaption class="mx my et er es mz na bd b be z dx translated">当模型被训练时，特定运行的训练丢失和验证丢失被实时自动记录在仪表板中。</figcaption></figure><p id="7151" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">我们可以用不同的超参数重复相同的训练步骤，以比较不同的跑步。我们将更改记录器的名称，以唯一地标识每次运行。</p><p id="8b7e" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">这是我们的模型到目前为止的进展情况。</p><figure class="jd je jf jg fd iw er es paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="er es mv"><img src="../Images/81395cb05d5ced25aac5dc199c102672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zmb_GtxeEsoFmQw-io5EfQ.png"/></div></div></figure><figure class="jd je jf jg fd iw er es paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="er es mv"><img src="../Images/71fa005ad4383275b1f011f53240b3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cpc7g4lr0-RM1tgAnAmmcQ.png"/></div></div></figure><p id="4cf7" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">这些可视化效果将永久保存在您的项目中，这使得比较不同超参数变量的性能、恢复最佳性能模型以及与您的团队共享结果变得更加容易。</p><h1 id="a1d6" class="lb jk hi bd jl lc ld le jp lf lg lh jt li lj lk jx ll lm ln kb lo lp lq kf lr bi translated">多GPU训练</h1><p id="a4a3" class="pw-post-body-paragraph kh ki hi kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la ip hb bi translated">Lightning提供了一个简单的API来执行数据并行和多gpu训练。不需要在采样器中使用torch的数据并行类。您只需要指定并行模式和您希望使用的GPU数量。</p><p id="d02a" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">有多种培训方式:</p><ul class=""><li id="6ce8" class="mh mi hi kj b kk mb ko mc ju mj jy mk kc ml ip mm mn mo mp bi translated">数据并行(distributed_backend='dp ')(多GPU，1台机器)</li><li id="976c" class="mh mi hi kj b kk mq ko mr ju ms jy mt kc mu ip mm mn mo mp bi translated">distributed data parallel(distributed _ back end = ' DDP ')(跨多台机器的多GPU)。</li><li id="3867" class="mh mi hi kj b kk mq ko mr ju ms jy mt kc mu ip mm mn mo mp bi translated">distributeddataparallel 2(distributed _ back end = ' Ddp 2 ')(机器中的DP，跨机器的ddp)。</li><li id="f0ae" class="mh mi hi kj b kk mq ko mr ju ms jy mt kc mu ip mm mn mo mp bi translated">TPUs(TPU核心数=8|x) (tpu或TPU pod)</li></ul><p id="696c" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">在本文中，我们将使用数据并行后端。下面是我们如何将它合并到现有的代码中。</p><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="mg ji l"/></div></figure><p id="91a8" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">在这里，我只使用了1个GPU，因为我在谷歌colab上工作。</p><p id="9419" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">随着您使用更多的GPU，您将能够监控不同配置之间的内存使用差异，如下图所示。</p><figure class="jd je jf jg fd iw er es paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="er es nb"><img src="../Images/85443d4255c9ea54c0b389cba876598b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ad0mzcT1QIAT_jvb7Z2xw.png"/></div></div></figure><p id="e213" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">Pytorch Lightning提供了两种提前停车的方法。以下是你如何使用它们:</p><p id="cb91" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">a)将early_stop_callback设置为True。将查找“val_loss”</p><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="mg ji l"/></div></figure><p id="e2dc" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">b)或者配置您自己的回拨</p><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="mg ji l"/></div></figure><h1 id="468a" class="lb jk hi bd jl lc ld le jp lf lg lh jt li lj lk jx ll lm ln kb lo lp lq kf lr bi translated">16位精度</h1><p id="316d" class="pw-post-body-paragraph kh ki hi kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la ip hb bi translated">根据项目的要求，您可能需要提高或降低模型权重的精度。降低精度可以让你在GPU中安装更大的模型。让我们看看如何在pytorch lightning中融入16位精度。</p><p id="ca10" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">首先，我们需要安装NVIDIA apex。为此，我们将在colab中创建一个shell脚本并执行它。</p><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="mg ji l"/></div></figure><p id="5e2b" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">现在我们可以直接在训练器的精度参数中传入所需的值。</p><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="mg ji l"/></div></figure><h1 id="da70" class="lb jk hi bd jl lc ld le jp lf lg lh jt li lj lk jx ll lm ln kb lo lp lq kf lr bi translated">与Pytorch的比较</h1><p id="e42f" class="pw-post-body-paragraph kh ki hi kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la ip hb bi translated">现在我们已经看到了lightning提供的简单框架，让我们快速看一下它与pytorch的比较。在lightning中，我们可以通过自动回调和进度条来训练模型，只需创建一个训练器并在其上调用train()方法。</p><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="mg ji l"/></div></figure><p id="6bf6" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">你可以看到训练代码可以变得多么复杂，我们甚至还没有包括合并多GPU训练、提前停止或跟踪wandb性能的修改。</p><p id="be0d" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">为了在Pytorch中添加分布式训练，我们需要使用DistributedSampler对数据集进行采样。</p><figure class="jd je jf jg fd iw"><div class="bz dy l di"><div class="mg ji l"/></div></figure><p id="d0fb" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">您还需要编写一个自定义函数来包含早期停止。但是在使用lightning时，所有这些都可以通过一行代码来完成。</p><p id="ff05" class="pw-post-body-paragraph kh ki hi kj b kk mb km kn ko mc kq kr ju md kt ku jy me kw kx kc mf kz la ip hb bi translated">这个故事到此为止！</p></div></div>    
</body>
</html>