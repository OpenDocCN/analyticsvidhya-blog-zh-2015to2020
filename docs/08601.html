<html>
<head>
<title>Easiest Way to build your Data Science Web app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建数据科学 Web 应用程序的最简单方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/easiest-way-to-build-your-data-science-web-app-b5fa640c1a39?source=collection_archive---------24-----------------------#2020-08-04">https://medium.com/analytics-vidhya/easiest-way-to-build-your-data-science-web-app-b5fa640c1a39?source=collection_archive---------24-----------------------#2020-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8f24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我知道这种开发机器学习 Web 应用程序的超级简单的方法还不到一个月。我已经开发了各种 ML 模型，但总是难以让它看起来像样，更像一个产品或 MVP。</p><p id="2b61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Streamlit 是一个 python 框架，在这个框架中，您只需几行代码就可以轻松构建一个交互式 web 应用程序。数据科学家现在是 Streamlit 的 Web 开发人员！</p><p id="47e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很容易上手。你只需要通过 pip 安装软件包。您可以使用<em class="jd"> streamlit hello </em>运行一个示例 streamlit 应用程序，以了解它的外观。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="55b5" class="jn jo hi jj b fi jp jq l jr js">pip install streamlit<br/>streamlit hello</span><span id="96ef" class="jn jo hi jj b fi jt jq l jr js">streamlit run main.py</span></pre><p id="85f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的主文件夹中:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="18cf" class="jn jo hi jj b fi jp jq l jr js">import streamlit as st<br/>st.title(“Poly Cystic Ovarian Symdrome Prediction”)<br/>st.sidebar.title(“PCOS Prediction”)<br/>st.sidebar.markdown(“This is for changing the model parameters”)</span></pre><p id="70a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">python 脚本中的更改在每次保存时都会被扫描，并且在您编码时，它也会在 web 应用程序中实时更改。运行文件为:<strong class="ih hj"><em class="jd">streamlit run main . py</em></strong>，输出为:</p><figure class="je jf jg jh fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es ju"><img src="../Images/a77209fc968c866c58096613981957ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PC7yWvM3jISOPDFTLIfNg.png"/></div></div></figure><p id="d18b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就对了。</p><p id="3e3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将用一个多囊卵巢综合征预测的演示项目来解释。如今，PCOS 是女性中非常常见的疾病，卵巢出现某种囊肿可能会导致不孕。数据集可以从这里的<a class="ae kc" href="https://www.kaggle.com/prasoonkottarathil/polycystic-ovary-syndrome-pcos" rel="noopener ugc nofollow" target="_blank">获取</a>。数据集分为两个表:</p><ol class=""><li id="c941" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">没有不孕</li><li id="d9c9" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">不孕不育</li></ol><p id="b2e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们需要在一个公共列上连接这两个表，并删除与我们的输出不太相关的特性。此外，我们将需要一些数据清理。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="0b85" class="jn jo hi jj b fi jp jq l jr js">@st.cache(persist=True)<br/>def load_data():<br/> no_inf=pd.read_csv(“C:/Users/dell/Documents/PCOS Prediction/no_inf.csv”)<br/> inf=pd.read_csv(“C:/Users/dell/Documents/PCOS Prediction/inf.csv”)<br/> data = pd.merge(no_inf,inf, on=’Patient File No.’, suffixes={‘’,’_y’},how=’left’)<br/> data[‘Fast food (Y/N)’].fillna(data[‘Fast food (Y/N)’].median(),inplace=True)<br/> data.drop([‘PCOS (Y/N)_y’,’AMH(ng/mL)_y’,’Patient File No.’,’Unnamed: 42'],axis=1,inplace=True)<br/> corr_features=data.corrwith(data[“PCOS   (Y/N)”]).abs().sort_values(ascending=False)<br/> corr_features=corr_features[corr_features&gt;0.25].index<br/> data=data[corr_features]<br/> return data</span><span id="a9d1" class="jn jo hi jj b fi jt jq l jr js">df=load_data()</span></pre><p id="ad39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数<em class="jd"> load_data() </em>负责加载数据、清理和功能选择。这项工作只能做一次。当您重新运行脚本时，将再次执行 load_data()。但这可以通过使用<em class="jd"> @st.cache </em> decorator 来避免，它将缓存应用程序，这样你就可以避免昂贵的重复计算，如训练或加载巨大的数据集。在这里，我们将根据一名女性的体重增加、痤疮、月经不调等症状来预测她是否患有 PCOS。我们只选择那些与我们的输出特征非常相关的特征，即<em class="jd"> PCOS (Y/N) </em>。</p><p id="1f1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们转向分类器。由于我们正在创建一个交互式仪表板，我们需要有多个分类器，以便用户可以找到最好的分类器。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="2c9b" class="jn jo hi jj b fi jp jq l jr js">st.sidebar.subheader("Choose Classifier")<br/> classifier = st.sidebar.selectbox("Classifier", ("SVM", "Random Forest"))<br/> if classifier == 'SVM':<br/>  st.sidebar.subheader("Model Hyperparameters")<br/>  C = st.sidebar.number_input("Regularization (C)", 0.01, 10.0, step=0.01, key='C_SVM')<br/>  kernel = st.sidebar.radio("Kernel", ("rbf", "linear"), key='kernel')<br/>  gamma = st.sidebar.radio("Gamma (Kernel Cofficient)", ("scale", "auto"), key='gamma')<br/>  metrics = st.sidebar.multiselect("Plot Metrices", ('Confusion Matrix', 'ROC Curve', 'Precision-Recall Curve'))</span><span id="e248" class="jn jo hi jj b fi jt jq l jr js">if st.sidebar.button("Classify", key='classify'):<br/>   st.subheader("Results of SVM")<br/>   model = SVC(C=C, kernel=kernel, gamma=gamma)<br/>   model.fit(x_train, y_train)<br/>   accuracy = model.score(x_test, y_test)<br/>   y_pred = model.predict(x_test)<br/>   st.write("Accuracy: ", accuracy.round(2))<br/>   st.write("Precision: ", precision_score(y_test, y_pred, labels=class_names).round(2))<br/>   st.write("Recall: ", recall_score(y_test, y_pred, labels=class_names).round(2))<br/>   plot_metrics(metrics)</span><span id="8c85" class="jn jo hi jj b fi jt jq l jr js">if classifier == 'Random Forest':<br/>  st.sidebar.subheader("Model Hyperparameters")<br/>  n_estimators = st.sidebar.number_input("The number of trees in the forest", 100, 5000, step=10, key='n_estimators')<br/>  max_depth = st.sidebar.number_input("The maximum depth of the tree", 1, 20, step=1, key='n_estimators')<br/>  bootstrap = st.sidebar.radio("Bootstrap samples when building trees", ('True', 'False'), key='bootstrap')<br/>  metrics = st.sidebar.multiselect("What metrics to plot?", ('Confusion Matrix', 'ROC Curve', 'Precision-Recall Curve'))</span><span id="616c" class="jn jo hi jj b fi jt jq l jr js">if st.sidebar.button("Classify", key='classify'):<br/>   st.subheader("Random Forest Results")<br/>   model = RandomForestClassifier(n_estimators=n_estimators, max_depth=max_depth, bootstrap=bootstrap, n_jobs=-1)<br/>   model.fit(x_train, y_train)<br/>   accuracy = model.score(x_test, y_test)<br/>   y_pred = model.predict(x_test)<br/>   st.write("Accuracy: ", accuracy.round(2))<br/>   st.write("Precision: ", precision_score(y_test, y_pred, labels=class_names).round(2))<br/>   st.write("Recall: ", recall_score(y_test, y_pred, labels=class_names).round(2))<br/>   plot_metrics(metrics)</span></pre><p id="6b13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> st.sidebar.selectbox("分类器"，(" SVM "，"随机森林"))</em>显示一个单选按钮，允许您在 SVM 分类器和随机森林分类器之间进行选择。对于每个分类器，您还可以设置可变参数。您可以通过以下几行代码为分类器输入您想要的参数:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="18b2" class="jn jo hi jj b fi jp jq l jr js">C = st.sidebar.number_input("Regularization (C)", 0.01, 10.0, step=0.01, key='C_SVM')<br/>kernel = st.sidebar.radio("Kernel", ("rbf", "linear"), key='kernel')<br/>gamma = st.sidebar.radio("Gamma (Kernel Cofficient)", ("scale", "auto"), key='gamma')</span></pre><p id="818e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并在训练分类器时发送这些参数:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="4b52" class="jn jo hi jj b fi jp jq l jr js">model = SVC(C=C, kernel=kernel, gamma=gamma)<br/>model.fit(x_train, y_train)</span></pre><p id="9eec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找到准确性，您需要创建一个训练测试分割。拆分只需要做一次，这就是为什么我们再次缓存这部分计算。让我们将分割函数设为:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="f760" class="jn jo hi jj b fi jp jq l jr js"><a class="ae kc" href="http://twitter.com/st" rel="noopener ugc nofollow" target="_blank">@st</a>.cache(persist=True)<br/>def split(df):<br/>  y = df['PCOS (Y/N)']<br/>  x=df.drop(columns=['PCOS (Y/N)'])<br/>  x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=0)<br/>  return x_train, x_test, y_train, y_test</span><span id="7df5" class="jn jo hi jj b fi jt jq l jr js">x_train, x_test, y_train, y_test = split(df)</span></pre><p id="2cc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面这部分特定的代码完成了准确性计算和实际预测的工作。<em class="jd"> plot_metrics </em>函数中的 argumet<em class="jd">metrics</em>之前被定义为用户想要的精确度可视化列表。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="65ad" class="jn jo hi jj b fi jp jq l jr js">metrics = st.sidebar.multiselect("Plot Metrices", ('Confusion Matrix', 'ROC Curve', 'Precision-Recall Curve'))</span><span id="5432" class="jn jo hi jj b fi jt jq l jr js">accuracy = model.score(x_test, y_test)<br/>y_pred = model.predict(x_test)<br/>plot_metrics(metrics)</span></pre><p id="ce23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将<em class="jd"> plot_metrics() </em>函数定义为:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="c4f9" class="jn jo hi jj b fi jp jq l jr js">def plot_metrics(metrics_list):<br/>  if 'Confusion Matrix' in metrics_list:<br/>   st.subheader("Confusion Matrix")<br/>   plot_confusion_matrix(model, x_test, y_test, display_labels=class_names)<br/>   st.pyplot()</span><span id="5c83" class="jn jo hi jj b fi jt jq l jr js">if 'ROC Curve' in metrics_list:<br/>   st.subheader("ROC Curve")<br/>   plot_roc_curve(model, x_test, y_test)<br/>   st.pyplot()<br/>  <br/>  if 'Precision-Recall Curve' in metrics_list:<br/>   st.subheader('Precision-Recall Curve')<br/>   plot_precision_recall_curve(model, x_test, y_test)<br/>   st.pyplot()</span></pre><p id="dc49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，您可以选择分类器、更改预测以及可视化准确性度量。你也可以用同样的方法添加其他型号。</p><h2 id="90ff" class="jn jo hi bd kr ks kt ku kv kw kx ky kz iq la lb lc iu ld le lf iy lg lh li lj bi translated">将症状作为用户的输入</h2><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="b8da" class="jn jo hi jj b fi jp jq l jr js">skin=st.number_input("Have you experienced skin darkening?(0/1)", key='skin')<br/> hair=st.number_input("Have you experienced hair growth?(0/1)", key='hair')<br/> weight=st.number_input("Have you experienced weight gain?(0/1)", key='weight')<br/> <br/> ff=st.number_input("Do you eat too much fast foods?(0/1)", key='ff')<br/> pimple=st.number_input("Do you get pimples?(0/1)", key='pimple')<br/> lf = st.number_input("No of left follicles", key='lf')<br/> rf=st.number_input("No of right follicle", key='rf')<br/> cycle=st.number_input("Cycle(R/I)", key='cycle')<br/> my_data=[[lf,rf,skin,hair,weight,cycle,ff,pimple]]<br/> pd.DataFrame.from_dict(my_data)<br/> if st.button("Predict", key='predict'):<br/>   st.subheader("Your Result:")<br/>   model = SVC(C=0.01, kernel="linear", gamma="auto")<br/>   model.fit(x_train, y_train)<br/>   accuracy = model.score(x_test, y_test)<br/>   y_pred = model.predict(my_data)<br/>   if y_pred==1:<br/>    st.write("Alert!!You are predicted to have PCOS")<br/>   else:<br/>    st.write("Congratulations!!You are predicted negative for PCOS")<br/>   <br/>   st.write("The prediction made has Accuracy: ", accuracy.round(2))</span></pre><p id="6da5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终输出如下所示:</p><figure class="je jf jg jh fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es lk"><img src="../Images/27745e4db4d668e18ee8cfe1affbfd24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yz7HIuk65N-F-XPbkSN6JA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">使用 SVM 分类器</figcaption></figure><figure class="je jf jg jh fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es lp"><img src="../Images/b2dcbde91a2d61e4d862e50404fbafa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPCr7PKW1ks6LCCQmfOyWw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">使用随机森林分类器</figcaption></figure><figure class="je jf jg jh fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es lq"><img src="../Images/fba55e1b2df1bbe3e96f8a16338323b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8TXMNULR7I6R_5r605ZebA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">供用户输入</figcaption></figure><p id="0fed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整体项目可以从<a class="ae kc" href="https://github.com/paridhi-parajuli/PCOS-Prediction-with-Streamlit" rel="noopener ugc nofollow" target="_blank">我的 github repo </a>下载。</p><p id="69c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>