<html>
<head>
<title>How does Java Application run? What is Bytecode? Write a simple VM simulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java应用如何运行？什么是字节码？编写一个简单的虚拟机模拟</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-does-java-application-run-what-is-bytecode-write-a-simple-vm-simulation-d31e89c4839a?source=collection_archive---------15-----------------------#2020-07-06">https://medium.com/analytics-vidhya/how-does-java-application-run-what-is-bytecode-write-a-simple-vm-simulation-d31e89c4839a?source=collection_archive---------15-----------------------#2020-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在研究Java和JVM架构时，我找到了meetup talk[1]和其他资源。然后我意识到其他开发人员可能对Java的幕后工作很好奇。所以我决定写一篇关于Java应用如何运行的文章？Java VM如何一步一步解释运行？为了讨论这个问题，我收集了一些背景资料。最后举例说明虚拟机的运行步骤。该示例应用程序基于meetup talker Terence Parr[1]。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/62f854027deb76248c384edd234941f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p-qWdalcQtyojQ1P.png"/></div></div></figure><p id="2ca1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">背景信息</strong></p><p id="8008" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">“Java</strong>是一种通用的编程语言，它是基于类的、面向对象的，并且被设计成具有尽可能少的实现依赖性。它旨在让应用程序开发人员<em class="jp">编写一次，在任何地方运行</em> (WORA)，这意味着编译后的Java代码可以在所有支持Java的平台上运行，而无需重新编译。Java应用程序通常被编译成可以在任何Java虚拟机(JVM)上运行的字节码，而不管底层的计算机架构如何。Java的语法类似于C和C++，但是它的底层工具比它们都少。据GitHub称，截至2019年，Java是最受欢迎的编程语言之一，特别是对于客户端-服务器web应用程序，据报道有900万开发者。”[2]</p><p id="bf2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如在Java定义中所说的，一旦你用Java编写了你的程序，它可以在任何地方运行。为了达到这个目的，Java使用了字节码和JVM。在开始讨论Java架构之前，我们先来看看c等其他语言。</p><p id="fbda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在编译阶段之后，所有的对象被合并并成为可执行文件。这叫做链接。输出exe已准备好运行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jq"><img src="../Images/621f9bd4417fd418cd40d315faea7510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XAIDEhaEo1-CJ868p4i6Og.png"/></div></div></figure><p id="143c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，Java编译器将。类文件，而不链接这些文件。这些类文件包含另一个称为字节码的IL。但是计算机不能直接读取和运行字节码。所以虚拟机需要将这些转换成计算机可执行的代码。这种方法的优点是，当您创建字节码文件时，每个架构都使用自己的JVM，并且可以运行Java。Java就是这样在每个平台上运行的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jq"><img src="../Images/94e599a8c3794362491e5f894117fbba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLY19YrSqYPUngsvMCBJ6g.png"/></div></div></figure><p id="c330" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，JIT编译器(Just-In-Time)在运行时解释这个字节码。所以Java比一些语言要慢。同样，这种体系结构使得Java既是编译语言又是解释语言。因为java编译器编译Java文件生成类文件。然后JIT将类文件解释为本机代码。</p><p id="9570" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">利用这些背景信息，我们将编写自己的虚拟机。这个虚拟机会非常原始。但是理解了主要概念就更清楚了。理解字节码是如何执行的比编写简单的代码更重要。</p><p id="81e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将Java代码转换成字节码是Java编译器的责任。但是让我们不看细节。下面的代码包含了最原始的阶乘代码。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="ad71" class="jw jx hi js b fi jy jz l ka kb"><em class="jp">/**<br/> * </em><strong class="js hj"><em class="jp">@author </em></strong><em class="jp">Yunus<br/> */<br/></em>public class Main {<br/><br/>    static int factorial(int num) {<br/>        if (num &lt; 2) {<br/>            return 1;<br/>        }<br/>        return num * <em class="jp">factorial</em>(num - 1);<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        <em class="jp">factorial</em>(2);<br/>    }<br/>}</span></pre><p id="fdc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用下面的命令将生成字节码。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="4eb6" class="jw jx hi js b fi jy jz l ka kb">javac Main.java</span></pre><p id="aeb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用下面的命令来看看Main.class文件。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="ba68" class="jw jx hi js b fi jy jz l ka kb">$javap -p -c -v Main.class</span><span id="8c3d" class="jw jx hi js b fi kc jz l ka kb">Last modified Jul 3, 2020; size 378 bytes<br/>  MD5 checksum 1928bdcf95625d8714f1aa34b13ec2f2<br/>  Compiled from "Main.java"<br/>public class Main<br/>  minor version: 0<br/>  major version: 52<br/>  flags: ACC_PUBLIC, ACC_SUPER<br/>Constant pool:<br/>   #1 = Methodref          #4.#16         // java/lang/Object."&lt;init&gt;":()V<br/>   #2 = Methodref          #3.#17         // Main.factorial:(I)I<br/>   #3 = Class              #18            // Main<br/>   #4 = Class              #19            // java/lang/Object<br/>   #5 = Utf8               &lt;init&gt;<br/>   #6 = Utf8               ()V<br/>   #7 = Utf8               Code<br/>   #8 = Utf8               LineNumberTable<br/>   #9 = Utf8               factorial<br/>  #10 = Utf8               (I)I<br/>  #11 = Utf8               StackMapTable<br/>  #12 = Utf8               main<br/>  #13 = Utf8               ([Ljava/lang/String;)V<br/>  #14 = Utf8               SourceFile<br/>  #15 = Utf8               Main.java<br/>  #16 = NameAndType        #5:#6          // "&lt;init&gt;":()V<br/>  #17 = NameAndType        #9:#10         // factorial:(I)I<br/>  #18 = Utf8               Main<br/>  #19 = Utf8               java/lang/Object<br/>{<br/>  public Main();<br/>    descriptor: ()V<br/>    flags: ACC_PUBLIC<br/>    Code:<br/>      stack=1, locals=1, args_size=1<br/>         0: aload_0<br/>         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V<br/>         4: return<br/>      LineNumberTable:<br/>        line 4: 0</span><span id="c908" class="jw jx hi js b fi kc jz l ka kb">static int factorial(int);<br/>    descriptor: (I)I<br/>    flags: ACC_STATIC<br/>    Code:<br/>      stack=3, locals=1, args_size=1<br/>         0: iload_0<br/>         1: iconst_2<br/>         2: if_icmpge     7<br/>         5: iconst_1<br/>         6: ireturn<br/>         7: iload_0<br/>         8: iload_0<br/>         9: iconst_1<br/>        10: isub<br/>        11: invokestatic  #2                  // Method factorial:(I)I<br/>        14: imul<br/>        15: ireturn<br/>      LineNumberTable:<br/>        line 7: 0<br/>        line 8: 5<br/>        line 10: 7<br/>      StackMapTable: number_of_entries = 1<br/>        frame_type = 7 /* same */</span><span id="77d1" class="jw jx hi js b fi kc jz l ka kb">public static void main(java.lang.String[]);<br/>    descriptor: ([Ljava/lang/String;)V<br/>    flags: ACC_PUBLIC, ACC_STATIC<br/>    Code:<br/>      stack=1, locals=1, args_size=1<br/>         0: iconst_2<br/>         1: invokestatic  #2                  // Method factorial:(I)I<br/>         4: pop<br/>         5: return<br/>      LineNumberTable:<br/>        line 14: 0<br/>        line 15: 5<br/>}<br/>SourceFile: "Main.java"</span></pre><p id="04d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的主函数有一条指令，</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="dae0" class="jw jx hi js b fi jy jz l ka kb">1: invokestatic #2 // Method factorial:(I)I</span></pre><p id="b04c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上就是说调用阶乘方法。#2的含义可以在常量池内找到，说明了我们的阶乘函数及其信息。可以从方法表中找到正确的函数。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="9934" class="jw jx hi js b fi jy jz l ka kb">#2 = Methodref          #3.#17</span><span id="f352" class="jw jx hi js b fi kc jz l ka kb">#3 = Class              #18</span><span id="1e49" class="jw jx hi js b fi kc jz l ka kb">#17 = NameAndType        #9:#10         // factorial:(I)I<br/>#18 = Utf8               Main</span><span id="ac42" class="jw jx hi js b fi kc jz l ka kb">#9 = Utf8               factorial<br/>#10 = Utf8               (I)I</span></pre><p id="2755" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面我们来关注阶乘函数的字节码:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="2cd7" class="jw jx hi js b fi jy jz l ka kb">0: iload_0<br/>1: iconst_2<br/>2: if_icmpge     7<br/>5: iconst_1<br/>6: ireturn<br/>7: iload_0<br/>8: iload_0<br/>9: iconst_1<br/>10: isub<br/>11: invokestatic  #2                  // Method factorial:(I)I<br/>14: imul<br/>15: ireturn</span></pre><p id="d592" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，要运行阶乘代码，我们需要将其转换为计算机运算。有一个庞大的指令列表[5]。但是我将只在阶乘代码中实现使用过的指令。有了这种极简主义的方法，就容易理解了。</p><p id="fd98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开始时，我们有唯一的内存堆栈，因为我们没有对象，等等。</p><p id="c9c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的极简VM基本上接受指令并执行它。所以为了保存重要的信息，我们需要堆栈指针(sp)、指令指针(ip)和帧指针(fp)。</p><p id="82c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将使用堆栈指针，即堆栈中的当前位置。</p><p id="5598" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">指令指针保持哪个指令被执行。</p><p id="8c27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">帧指针…</p><p id="a53f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:iload_0，从局部变量0加载一个int <em class="jp">值</em></p><p id="ba33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有，有一个叫iload的教练，从局部变量<em class="jp"> #index </em>加载一个int <em class="jp">值</em></p><p id="8b2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> iload_0 </strong>和<strong class="ih hj"> iload 0 </strong>两者都为真。为了更加通用，我将使用iload 0来加载任何索引。其他说明也一样。</p><p id="960f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于简单的原因，我们将只调用<strong class="ih hj">和指令号，而不是调用static #2</strong></p><p id="6c59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> if_icmpge </strong> = &gt;如果<em class="jp"> value1 </em>大于或等于<em class="jp"> value2 </em>，则分支到<em class="jp"> branchoffset处的指令。所以我把这些指令划分如下(ilt和brf)。</em></p><p id="17b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们继续前进，就好像生成了下面的字节码。如果一条指令有操作数，那么下一条指令的编号就会改变。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="c1be" class="jw jx hi js b fi jy jz l ka kb">Factorial method:</span><span id="faeb" class="jw jx hi js b fi kc jz l ka kb">0: iload 0<br/>2: iconst 2<br/>4: ilt<br/>5: brf 10<br/>7: iconst 1<br/>9: return<br/>10: iload 0<br/>12: iload 0<br/>14: iconst 1<br/>16: isub<br/>17: call  0,1                  <br/>20: imul<br/>21: return</span><span id="c193" class="jw jx hi js b fi kc jz l ka kb">Main method:</span><span id="b304" class="jw jx hi js b fi kc jz l ka kb">22: iconst 2<br/>24: call 0,1<br/>27: print<br/>28: halt</span></pre><p id="e81f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们来定义指令。代码片段摘自会议讨论正如我在开始时所说，我做了一些重构[1]。我想演示每一步来说明它是如何工作的？实际上代码非常简单。理解概念更重要。</p><p id="61e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我创建了Instruction类，它只包含阶乘样本所需的指令。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="a8cd" class="jw jx hi js b fi jy jz l ka kb">import java.util.Arrays;<br/>import java.util.Optional;<br/><em class="jp"><br/></em>public enum Instruction {<br/><br/>    <em class="jp">ILOAD</em>(1, 1),<br/>    <em class="jp">ICONST</em>(2, 1),<br/>    <em class="jp">ILT</em>(3, 0),<br/>    <em class="jp">RET</em>(4, 0),<br/>    <em class="jp">ISUB</em>(5, 0),<br/>    <em class="jp">CALL</em>(6, 2),<br/>    <em class="jp">IMUL</em>(7, 1),<br/>    <em class="jp">PRINT</em>(8, 0),<br/>    <em class="jp">HALT</em>(9, 0),<br/>    <em class="jp">BRF</em>(10, 1);<br/><br/>    private final int code;<br/>    private final int numberOfOperand;<br/><br/>    Instruction(int code, int numberOfOperands) {<br/>        this.code = code;<br/>        this.numberOfOperand = numberOfOperands;<br/>    }<br/><br/>    public static Optional&lt;Instruction&gt; findByCode(int code) {<br/>        return Arrays.<em class="jp">asList</em>(Instruction.<em class="jp">values</em>()).stream().filter(x -&gt; x.getCode() == code).findFirst();<br/>    }<br/><br/>    public int getCode() {<br/>        return code;<br/>    }<br/><br/>    public int getNumberOfOperand() {<br/>        return numberOfOperand;<br/>    }<br/>}</span></pre><p id="1ade" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">定义测试类，字节码作为输入。状态从主方法的第一条指令开始。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="58bb" class="jw jx hi js b fi jy jz l ka kb">public class Test {<br/>    static int[] <em class="jp">factorial </em>= {<br/>            Instruction.<em class="jp">ILOAD</em>.getCode(), 0,<br/>            Instruction.<em class="jp">ICONST</em>.getCode(), 2,<br/>            Instruction.<em class="jp">ILT</em>.getCode(),<br/>            Instruction.<em class="jp">BRF</em>.getCode(), 10,<br/>            Instruction.<em class="jp">ICONST</em>.getCode(), 1,<br/>            Instruction.<em class="jp">RET</em>.getCode(),<br/>            Instruction.<em class="jp">ILOAD</em>.getCode(), 0,<br/>            Instruction.<em class="jp">ILOAD</em>.getCode(), 0,<br/>            Instruction.<em class="jp">ICONST</em>.getCode(), 1,<br/>            Instruction.<em class="jp">ISUB</em>.getCode(),<br/>            Instruction.<em class="jp">CALL</em>.getCode(), 0, 1,<br/>            Instruction.<em class="jp">IMUL</em>.getCode(),<br/>            Instruction.<em class="jp">RET</em>.getCode(),</span><span id="8615" class="jw jx hi js b fi kc jz l ka kb"><br/>            Instruction.<em class="jp">ICONST</em>.getCode(), 2,<br/>            Instruction.<em class="jp">CALL</em>.getCode(), 0, 1,<br/>            Instruction.<em class="jp">PRINT</em>.getCode(),<br/>            Instruction.<em class="jp">HALT</em>.getCode()<br/>    };<br/><br/>    public static void main(String[] args) {<br/>        Vm vm = new Vm(<em class="jp">factorial</em>, 22);<br/>        vm.execute();<br/>    }<br/>}</span></pre><p id="48d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虚拟机类别:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="89ed" class="jw jx hi js b fi jy jz l ka kb">public class Vm {<br/>    public static final int <em class="jp">DEFAULT_STACK_SIZE </em>= 1000;<br/>    public static final int <em class="jp">NUMBER_OF_GLOBAL </em>= 0;<br/>    public static final int <em class="jp">FALSE </em>= 0;<br/>    public static final int <em class="jp">TRUE </em>= 1;<br/>    int ip = -1, sp = -1, fp = -1, defaultOffset = -3;<br/>    int[] code, globals, stack;<br/><br/>    public Vm(int[] code, int startip) {<br/>        this.code = code;<br/>        ip = startip;<br/>        globals = new int[<em class="jp">NUMBER_OF_GLOBAL</em>];<br/>        stack = new int[<em class="jp">DEFAULT_STACK_SIZE</em>];<br/>    }<br/><br/>    public void execute() {<br/>        int opcode = code[ip];<br/>        Instruction instruction = getInstruction(opcode);<br/>        Optional&lt;Instruction&gt; optionalInstruction;<br/>        if (instruction == null) return;<br/>        int a, b, addr, offset;<br/><br/>        while (opcode != Instruction.<em class="jp">HALT</em>.getCode() &amp;&amp; ip &lt; code.length) {<br/>            instruction = getInstruction(opcode);<br/>            ip++;<br/>            switch (instruction) {<br/>                case <em class="jp">ILOAD</em>:<br/>                    offset = defaultOffset + code[ip++];<br/>                    stack[++sp] = stack[fp + offset];<br/>                    break;<br/>                case <em class="jp">ICONST</em>:<br/>                    stack[++sp] = code[ip++];<br/>                    break;<br/>                case <em class="jp">ILT</em>:<br/>                    b = stack[sp--];<br/>                    a = stack[sp--];<br/>                    stack[++sp] = (a &lt; b) ? <em class="jp">TRUE </em>: <em class="jp">FALSE</em>;<br/>                    break;<br/>                case <em class="jp">ISUB</em>:<br/>                    b = stack[sp--];<br/>                    a = stack[sp--];<br/>                    stack[++sp] = a - b;<br/>                    break;<br/>                case <em class="jp">CALL</em>:<br/>                    addr = code[ip++];<br/>                    int nargs = code[ip++];<br/>                    stack[++sp] = nargs;<br/>                    stack[++sp] = fp;<br/>                    stack[++sp] = ip;<br/>                    fp = sp;<br/>                    ip = addr;<br/>                    break;<br/>                case <em class="jp">RET</em>:<br/>                    int rvalue = stack[sp--];<br/>                    sp = fp;<br/>                    ip = stack[sp--];<br/>                    fp = stack[sp--];<br/>                    nargs = stack[sp--];<br/>                    sp -= nargs;<br/>                    stack[++sp] = rvalue;<br/>                    break;<br/>                case <em class="jp">IMUL</em>:<br/>                    b = stack[sp--];<br/>                    a = stack[sp--];<br/>                    stack[++sp] = a * b;<br/>                    break;<br/>                case <em class="jp">PRINT</em>:<br/>                    System.<em class="jp">out</em>.println(stack[sp--]);<br/>                    break;<br/>                case <em class="jp">BRF</em>:<br/>                    addr = code[ip++];<br/>                    if (stack[sp--] == <em class="jp">FALSE</em>) ip = addr;<br/>                    break;<br/>            }<br/>            opcode = code[ip];<br/>        }<br/>    }</span></pre><p id="6fd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在最重要的部分来了。我想讨论一下在执行完每条指令之后的堆栈状态，以便深入研究逻辑。</p><p id="6014" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们举例说明如何计算阶乘2。</p><p id="f109" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在执行任何字节码之前，我们的堆栈看起来像这样:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/1369d095cc05d62b33e30e7ef1812d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*zqo-ugwHh9WHYpZMTODpsA.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="76f3" class="jw jx hi js b fi jy jz l ka kb">22: iconst 2 // bytecode<br/>Instruction.<em class="jp">ICONST</em>.getCode(), 2,  // input equilavent</span></pre><p id="f659" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个字节码基本上在栈中定义了一个整数常量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/1a306486778299d12856a87306034b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*uSxmADVm9jrozF62UubJiw.png"/></div></figure><p id="15d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，2位于堆栈中。ip变为24，这意味着下一条指令。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="599d" class="jw jx hi js b fi jy jz l ka kb">24: call 0,1<br/>Instruction.<em class="jp">CALL</em>.getCode(), 0, 1</span></pre><p id="0cad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当前指令说用1个参数调用指令0。调用和返回是最复杂的操作。所以我试着给你更多的细节。在调用另一个函数时，我们需要存储重要的信息。该信息将在回电后使用。在我们的示例应用程序中，我们存储了3条信息。</p><p id="c5f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1-)参数数量(1)</p><p id="ab25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2-)当前帧指针(-1)</p><p id="9c59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3-)下一条指令(27)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/00b8fd906a29077a46fdbab59cab4931.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*EZQ1xlGsqsEnL3kmJkWy7g.png"/></div></figure><p id="36f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的ip变成了0，因为下一条指令是0。Sp是3。Fp变成了3，因为在执行另一个函数之前，sp是3。所以阶乘函数的Fp是3。最后，我们从main方法调用阶乘函数。现在让我们迭代阶乘函数的第一条指令。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="4c35" class="jw jx hi js b fi jy jz l ka kb">0: iload 0<br/>Instruction.<em class="jp">ILOAD</em>.getCode(), 0,</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/6881f80d9fa35650369100ed868b77f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*iqmULbTF84Jc4TqV3IrQxQ.png"/></div></figure><p id="a310" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在加载数据时注意到的代码，有<strong class="ih hj"> -3偏移</strong>。为什么会存在？因为在调用函数的时候，我们放了3个关于之前情况的额外信息。当从堆栈中加载数据时，我们需要用这个偏移量来获取值，以找到正确的值。3额外信息显示为黄色。参数是蓝色的，本地值是绿色的。<strong class="ih hj"> iload 0 </strong>加载2，它作为参数被推入main方法中。然后再次压入堆栈以用作本地值。现在ip变成了2。我们走吧:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="e6a0" class="jw jx hi js b fi jy jz l ka kb">2: iconst 2<br/>Instruction.<em class="jp">ICONST</em>.getCode(), 2,</span></pre><p id="cc16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们来对n&lt;2 part of our functions. In order to that, we need to put value 2 to our stack.</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/ada49bddaaa062016e07228d8e39a673.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*c0O9T4Q-LfdG63yWzaDFEA.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="6b6c" class="jw jx hi js b fi jy jz l ka kb">4: ilt<br/>Instruction.<em class="jp">ILT</em>.getCode(),</span></pre><p id="b860" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ILT, just pop the last 2 values and execute less than operations. If true then puts 1 to stack else puts 0. 2&lt;2 is false so puts 0.</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/32cee387614128a37a7159e81e4a9ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*0QSq8vRzOxqy3aIAd2lKhQ.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="c46f" class="jw jx hi js b fi jy jz l ka kb">5: brf 10<br/>Instruction.<em class="jp">BRF</em>.getCode(), 10,</span></pre><p id="47ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">We divide if_icmpge operation to lt and brf. Brf means if false then branch specified index. Brf pops and looks stack whose last element 0. 0 means false, so we need to branch instruction number 10.</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/422135d12312cc7b2fb46650579438e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*gVjfxdJDMdiBEkeqDgnPyw.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="7103" class="jw jx hi js b fi jy jz l ka kb">10: iload 0<br/>Instruction.<em class="jp">ILOAD</em>.getCode(), 0,</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/e1d0436b79b769a7522239281c96e830.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*KPNYU14-ONkd__H3aDfwkg.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="cd88" class="jw jx hi js b fi jy jz l ka kb">12: iload 0<br/>Instruction.<em class="jp">ILOAD</em>.getCode(), 0,</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/3ae8b8212997bd47d2a30c4b7e731224.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*FNtxpr7xhjOeG0oF3Nyvqw.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="0936" class="jw jx hi js b fi jy jz l ka kb">14: iconst 1<br/>Instruction.<em class="jp">ICONST</em>.getCode(), 1,</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/d8251dd776ed6f0f874bec16a44e86aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*Q_Sm_vLPfC-G_To1f68Vmw.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="2d5a" class="jw jx hi js b fi jy jz l ka kb">16: isub<br/>Instruction.<em class="jp">ISUB</em>.getCode(),</span></pre><p id="8e4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Now we are trying to return 2* factorial(<strong class="ih hj">2–1</strong>进行一次短接操作。我们的程序弹出最后两个值，并将它们的差放入堆栈。所以我们弹出了2和1。然后将1压入堆栈。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/9a3389084225f909302696cfbf797b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*-tPWhK40n47deVE6MLlErA.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="3885" class="jw jx hi js b fi jy jz l ka kb">17: call  0,1<br/>Instruction.<em class="jp">CALL</em>.getCode(), 0, 1</span></pre><p id="7b61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们进行递归调用(2* <strong class="ih hj">阶乘(1) </strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/af70e2f5e2db9fabc8a1cf0fe582802f.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*c3OjmYMcm23YGyso_jLBPA.png"/></div></figure><p id="b544" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们放1是因为参数的数量是1。我们上一次的fp是3，所以我们推3。最后，在第17个指令之后，我们需要继续第20个指令，所以推20。现在我们再次开始阶乘函数。我们一会儿将重复同样的操作。我只放当前状态的图片。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="9662" class="jw jx hi js b fi jy jz l ka kb">0: iload 0<br/>Instruction.<em class="jp">ILOAD</em>.getCode(), 0,</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/f9cf832a09de440caac289466d806b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*D31zoHCPzuXFD1WwiG_ZaQ.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="dacc" class="jw jx hi js b fi jy jz l ka kb">2: iconst 2<br/>Instruction.<em class="jp">ICONST</em>.getCode(), 2,</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/525d5d1fb76499e98a9fc2c80c51b80f.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*h9gLdtXm5eJk7cW9S-DXvA.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="7cda" class="jw jx hi js b fi jy jz l ka kb">4: ilt<br/>Instruction.<em class="jp">ILT</em>.getCode(),</span></pre><p id="5c72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次1&lt;2为真，就把1压入栈。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/4a22fc83057fdc3c71655b7636b5192f.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*9wawez2Q0etzEyp-TYk_VQ.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="1643" class="jw jx hi js b fi jy jz l ka kb">5: brf 10<br/>Instruction.<em class="jp">BRF</em>.getCode(), 10,</span></pre><p id="ede6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次最后一个元素stack不为false，所以我们不进行分支。我们继续学习指令7。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/ffe594e25fb890e7f6a9d00494a59e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*2kdE4ZPQ3xjSmkc_vv8aCA.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="a6e9" class="jw jx hi js b fi jy jz l ka kb">7: iconst 1<br/>Instruction.<em class="jp">ICONST</em>.getCode(), 1,</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/bf76c4ca2efc7f4e428c8abccac453d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*CulA0jiFCmnAk15s4vLtig.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="f28f" class="jw jx hi js b fi jy jz l ka kb">9: return<br/>Instruction.<em class="jp">RET</em>.getCode(),</span></pre><p id="ce0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个非常重要的指令是返回。执行以下步骤:</p><ul class=""><li id="8d5e" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc kk kl km kn bi translated">从堆栈中获取返回值。在我们的例子中，它是1。</li><li id="fea9" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">从堆栈中获取指令指针值。我们需要这个值来找到继续的地方。在我们的例子中，是20。在factorial返回递归调用后，我们需要应用乘法(inst#20)。</li><li id="d425" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">获取帧指针。现在是3点。</li><li id="d843" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">从堆栈中弹出这些值后。我们减少了参数数量。</li><li id="5d19" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">我们需要将返回值压入堆栈。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/bb71809cf645d159582e635e13cc9b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*ZFE3weVWzXUXY1JytKLAXQ.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="295d" class="jw jx hi js b fi jy jz l ka kb">20: imul<br/>Instruction.<em class="jp">IMUL</em>.getCode(),</span></pre><p id="8403" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将堆栈中的最后两个元素相乘。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/8e38f6c33409078561894a76b9e7c2d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*FGT_ZxQ_mgyYhZL5si4C-Q.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="f2f7" class="jw jx hi js b fi jy jz l ka kb">21: return<br/>Instruction.<em class="jp">RET</em>.getCode(),</span></pre><p id="0148" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将执行另一个返回指令。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/c5381059cb5c2d4ddc62b66e1990b61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*czhTXeh9LQIzf8U7VHei8g.png"/></div></figure><p id="a8d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，我们返回了指令27。我们又回到了主函数中。局部2是阶乘函数的返回值。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="3e75" class="jw jx hi js b fi jy jz l ka kb">27: print<br/>Instruction.<em class="jp">PRINT</em>.getCode(),</span></pre><p id="de24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和你一样，没有任何打印说明。但是为了演示我们的工作，增加了这个指令。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/98b449fa3d9bda6070eb3b3f2c8adf6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*uORqwwLJxk2e712yO6wSIw.png"/></div></figure><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="e3bc" class="jw jx hi js b fi jy jz l ka kb">28: halt<br/>Instruction.<em class="jp">HALT</em>.getCode()</span></pre><p id="552a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在halt指令之后，我们的程序将被退出。</p><p id="b71b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次我研究了字节码、JVM和JIT资源，并编写了这些资源的输出。下次分享Java、GraalVM中的<strong class="ih hj">提前编译</strong> ( <strong class="ih hj"> AOT编译</strong>)和优缺点。保持联系。</p><p id="28ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引用:</p><p id="e9ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1-)【https://www.youtube.com/watch?v=OjaAToVkoTw】T4</p><p id="8189" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2-)<a class="ae kt" href="https://en.wikipedia.org/wiki/Java_(programming_language)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Java _(编程语言)</a></p><p id="823d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3-)<a class="ae kt" href="https://www.guru99.com/java-virtual-machine-jvm.html" rel="noopener ugc nofollow" target="_blank">https://www.guru99.com/java-virtual-machine-jvm.html</a></p><p id="7eab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4-)<a class="ae kt" href="https://www.lohika.com/methods-invocation-inside-of-a-java-virtual-machine#:~:text=JVM%20methods%20invocations,dedicated%20part%20of%20the%20article." rel="noopener ugc nofollow" target="_blank">https://www . lo hika . com/methods-invocation-inside-of-a-Java-virtual-machine #:~:text = JVM % 20 methods % 20 invocations，dedicated % 20 part % 20 of % 20文章。</a></p><p id="49c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5-)<a class="ae kt" href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Java _ bytecode _ instruction _ listings</a></p></div></div>    
</body>
</html>