<html>
<head>
<title>Reducing Memory Consumption in Python using Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用生成器减少Python中的内存消耗</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/reducing-memory-consumption-in-python-using-generators-fc43dd71f150?source=collection_archive---------9-----------------------#2019-10-05">https://medium.com/analytics-vidhya/reducing-memory-consumption-in-python-using-generators-fc43dd71f150?source=collection_archive---------9-----------------------#2019-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/44766dad3cc9814784603c651798ec05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIiVBfu7DrFgil0LeOJviw.jpeg"/></div></div></figure><div class=""/><p id="99ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您是否曾经不得不处理一个大型数据集，并在Python中遇到可怕的<em class="jo">内存错误</em>，或者只是需要限制大型数据集的内存消耗？如果答案是肯定的，考虑使用发电机。</p><p id="20e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生成器提供了一种处理数据的方法，无需先将整个数据源加载到内存中。这在以高效的pythonic方式处理非常大的文件时特别有用。</p><p id="f3b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生成器的核心是返回迭代器的函数，这意味着生成器可以循环。然而，与Python中的常规迭代器不同，整个数据集不会预先加载到内存中。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="2bf2" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">创建生成器函数</h2><p id="1177" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">发生器函数围绕着<code class="du kw kx ky kz b">yield</code>语句(后面的会有更多的<em class="jo">)。它们被定义为一个普通的函数，只是增加了一个<code class="du kw kx ky kz b">yield</code>语句来代替我们熟悉的<code class="du kw kx ky kz b">return</code>。</em></p><p id="a9fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面(<em class="jo">人为</em>)的例子中，定义了发生器函数<code class="du kw kx ky kz b">basic_generator</code>。这将返回一个生成器，一次生成50，000，000个整数。</p><p id="5399" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由<code class="du kw kx ky kz b">basic_generator</code>返回的生成器被分配给变量<code class="du kw kx ky kz b">gen</code>，然后可以像普通迭代器一样对其进行迭代。这里的区别在于，生成器一次生成一个值，而不是像list那样预先将所有50，000，000个整数加载到内存中。</p><h2 id="90fc" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">读取大文件</h2><p id="8f66" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">生成器函数最常见的用法可能是在读取大文件时，在Python中读取文件时，通常是一次将文件的全部内容读入内存。当处理大文件时，这可能会有问题，要么消耗过多的内存，要么在最坏的情况下消耗所有可用的内存，引发一个<code class="du kw kx ky kz b">MemoryError</code>并最终使应用程序崩溃。</p><p id="0207" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">注意:使用32位版本的Python时，Python进程只能寻址2GB的内存，因此无论有多少可用的物理内存，一旦Python消耗了2GB的内存，就会引发MemoryError错误。</em></p><p id="14e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据文件的类型和内容，你可能想要逐行读取(文本文件常见的<em class="jo">，或者二进制文件</em>常见的<em class="jo">)。</em></p><p id="992d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python中内置的<code class="du kw kx ky kz b">open</code>函数已经一行一行地对文件进行了惰性评估，因此对于一次一行地读取一个大文件，不需要实现一个生成器函数。这可以像下面的例子一样简单地实现。</p><p id="e40d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在需要以<em class="jo"> n </em>大小的字节块读取文件的情况下，可以使用下面的生成器函数。这将打开文件并产生等于<em class="jo"> chunk_size </em>字节的数据块。</p><h2 id="35a6" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">序列生成</h2><p id="31b6" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">生成器函数的另一个常见和流行的用途是生成大型或潜在的无限值序列。</p><h2 id="f671" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">无限数列</h2><p id="ca05" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">生成器函数是解决生成无限数列问题的理想选择，因为序列生成的状态可以巧妙地封装在一个函数定义中。</p><h2 id="efde" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">斐波那契数列</h2><p id="3db2" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">内存受限环境中的斐波那契数列是使用生成器函数求解的另一个很好的选择，因为可以避免将生成的斐波那契数列中的所有值加载到内存中。</p><h2 id="f873" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">生成器表达式</h2><p id="c027" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">如果一个完整的生成器函数对于简单的序列生成器来说过于冗长，那么可以选择使用生成器表达式来创建一个生成器。语法与列表理解非常相似，唯一的区别是生成器表达式需要<code class="du kw kx ky kz b">( )</code>圆括号，而列表理解需要<code class="du kw kx ky kz b">[ ]</code>括号。</p><p id="28f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">如果你有兴趣学习列表理解，看看我的帖子</em> <a class="ae la" href="https://www.lachlaneagling.com/python-list-comprehensions-at-a-glance/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">这里</em> </a> <em class="jo">。</em></p><h2 id="0c16" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">在后台</h2><p id="c521" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">当python解释器在函数中遇到<code class="du kw kx ky kz b">yield</code>语句时，它知道该函数是一个生成器函数。此时，函数将返回一个特殊的迭代器对象，并将其赋给目标变量。</p><p id="1659" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生成器对象使用内部<code class="du kw kx ky kz b">f_locals</code>变量存储状态。此外，该对象有一个<code class="du kw kx ky kz b">next()</code>方法，该方法调用并运行生成器函数内的代码，直到yield语句，此时返回生成的值，存储当前状态，并暂停函数的执行，直到再次调用<code class="du kw kx ky kz b">next()</code>。</p><p id="956d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一个方法既可以手动调用，也可以在循环结构中隐式调用。</p><p id="9dbc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当生成器的值用尽时，会出现一个<code class="du kw kx ky kz b">StopIteration</code>异常，表示生成器已经用尽，无法生成更多的值。这个异常由一个循环结构(比如for循环)自动处理，但是，如果在生成器上手动调用next，这个异常需要被捕获并手动处理。</p><h2 id="d354" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">内存和性能指标</h2><p id="f682" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">当涉及到内存消耗时，生成器提供了最大的好处，这是因为它们提供了<a class="ae la" href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="noopener ugc nofollow" target="_blank">惰性评估</a>，防止所有的值被一次加载到内存中。</p><p id="993d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的示例中，将生成50，000个整数的序列的生成器的字节大小与50，000个整数的静态列表进行比较。与静态生成的整数列表消耗406，488字节的内存相比，生成器只消耗112字节的内存。在这个特殊的例子中，生成器的内存效率比list高出约3600倍。</p><p id="d8c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这种内存效率的缺点是通过运行时性能观察到的，与静态生成的值列表相比，使用生成器会导致更多的函数调用，从而导致更长的运行时间。下面是使用<a class="ae la" href="https://docs.python.org/3.7/library/profile.html" rel="noopener ugc nofollow" target="_blank"> cProfile </a>对100，000以内的整数进行简单的<em class="jo">求和</em>分析。生成器表达式在123毫秒内产生100，005个函数调用，而列表理解在12毫秒内只需要5个函数调用。</p><p id="9ff7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">看我在Python </em> <a class="ae la" href="https://www.lachlaneagling.com/ghost/#/editor/post/5daf945c2955a95a7370b937" rel="noopener ugc nofollow" target="_blank"> <em class="jo">中关于剖析的帖子这里</em> </a> <em class="jo">。</em></p><p id="028d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是由于生成器表达式调用<code class="du kw kx ky kz b">next()</code>来获取序列中的每个值而返回的生成器。</p><p id="69c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从这些观察中自然得出的结论是，需要仔细考虑系统的需求。如果内存约束将超过性能影响，那么生成器是最合适的解决方案。相反，如果内存消耗没有运行时性能重要，那么使用静态数据源(如列表)更合适。</p></div></div>    
</body>
</html>