<html>
<head>
<title>Time Series Forecasting in Python — Part 1 : Data Processing &amp; Feature Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的时间序列预测第1部分:数据处理和特征工程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-forecasting-in-python-part-1-data-processing-feature-engineering-c347cb3d5e9d?source=collection_archive---------18-----------------------#2020-06-01">https://medium.com/analytics-vidhya/time-series-forecasting-in-python-part-1-data-processing-feature-engineering-c347cb3d5e9d?source=collection_archive---------18-----------------------#2020-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/30698a0fae6f680c0e5ebcde88bb7bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*5p8rKwpTZS7QDuqVl_soaQ.png"/></div></figure><p id="3f1e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">时间序列预测</strong>是一种预测销售、股票市场、收入等未来变动的方法。基本上，时间序列是一种统计模型，它试图在历史模式的基础上确定未来的粗略数据。时间序列数据必须将日期作为特征之一。预测可以每年、每月、每季度、每周、每天进行。开发一些强大的软件包，如<strong class="io hj"> fbprophet </strong>可以进行每小时、分钟甚至每秒的预测。</p><ul class=""><li id="0138" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">时间序列是一组连续的数据点，通常在连续的时间内测量。</li><li id="2b57" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">它在数学上被定义为一组向量x(t)，t = 0，1，2，…其中t代表经过的时间。</li><li id="b320" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">变量x(t)被视为随机变量。</li><li id="3746" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">在时间序列中的一个事件期间进行的测量按适当的时间顺序排列。</li><li id="2435" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">包含单个变量记录的时间序列称为单变量时间序列，包含多个变量的时间序列称为多变量时间序列。</li></ul><p id="9309" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如下所述，业务用例可以位于以下领域之一:</p><ul class=""><li id="82c3" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">销售预测</strong> —零售产品销售预测</li><li id="306d" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated"><strong class="io hj">需求预测</strong> —用于定价、库存和劳动力管理</li><li id="3a59" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated"><strong class="io hj">交通预测</strong> —交通和路线优化、道路设施设计、客户访问网站</li><li id="be79" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated"><strong class="io hj">收入预测</strong> —预算、目标设定</li></ul><p id="8727" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在进入任何建模部分之前，我们将进行数据处理并检查时间序列的属性。</p><h1 id="6083" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">时间序列数据分析</h1><p id="b7da" class="pw-post-body-paragraph im in hi io b ip kw ir is it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj hb bi translated">时间序列的数据分析有点不同，因为我们需要处理不同的时间格式。只需确保没有特定日期或时间的值丢失。否则模型无法建立。类似地，一个时间序列应该是平稳的，以获得更可靠的预测，如果不是，那么需要转换成一个。</p><p id="98ef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面讨论了对时间序列数据进行探索性数据分析的几种方法以及相应的Python代码。用于参考的数据集是一个经典的<strong class="io hj">航空公司乘客数据集</strong>，可在线获取。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="bef0" class="lk jz hi lg b fi ll lm l ln lo">#Import the Analysis Libraries<br/><strong class="lg hj">import</strong> <strong class="lg hj">numpy</strong> <strong class="lg hj">as</strong> <strong class="lg hj">np</strong><br/><strong class="lg hj">import</strong> <strong class="lg hj">matplotlib.pyplot</strong> <strong class="lg hj">as</strong> <strong class="lg hj">plt</strong><br/><strong class="lg hj">import</strong> <strong class="lg hj">pandas</strong> <strong class="lg hj">as</strong> <strong class="lg hj">pd</strong><br/><strong class="lg hj">import</strong> <strong class="lg hj">statsmodels.api</strong> <strong class="lg hj">as</strong> <strong class="lg hj">sm</strong><br/><strong class="lg hj">from</strong> <strong class="lg hj">statsmodels.tsa.stattools</strong> <strong class="lg hj">import</strong> adfuller<br/><strong class="lg hj">import</strong> <strong class="lg hj">matplotlib</strong><br/><strong class="lg hj">import</strong> <strong class="lg hj">seaborn</strong> <strong class="lg hj">as</strong> <strong class="lg hj">sns</strong><br/><strong class="lg hj">from</strong> <strong class="lg hj">random</strong> <strong class="lg hj">import</strong> random</span><span id="1a67" class="lk jz hi lg b fi lp lm l ln lo">#Data Reading<br/>df = pd.read_csv('international-airline-passengers.csv',header=<strong class="lg hj">None</strong>)<br/>df.columns = ['year','passengers']<br/>df.head(3)</span></pre><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/46b1be0f2dce30fe496101507237cc31.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*3SKSmxA7JwhYLtF4Kc3G5A.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">数据包含两列</figcaption></figure><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="41d5" class="lk jz hi lg b fi ll lm l ln lo">#Converting the column into datetime format<br/>df['year'] = pd.to_datetime(df['year'], format='%Y-%m')</span><span id="1792" class="lk jz hi lg b fi lp lm l ln lo">#Set index as years<br/>y = df.set_index('year')<br/>y.isnull().sum()</span><span id="c025" class="lk jz hi lg b fi lp lm l ln lo">#Plot the series<br/>y.plot(figsize=(15, 6))<br/>plt.show()</span></pre><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/03c521052435df572e5d7136a95d313d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Jj4hQycvQdlRFJxXQZMgg.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">时间序列图</figcaption></figure><ul class=""><li id="6861" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">序列分布检查:</strong>时间序列应遵循高斯(正态)分布。如果分布不是正态或偏斜的，那么在建模之前进行转换可能是有用的。</li></ul><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="6b76" class="lk jz hi lg b fi ll lm l ln lo"><strong class="lg hj">from</strong> <strong class="lg hj">pandas</strong> <strong class="lg hj">import</strong> Series<br/><strong class="lg hj">from</strong> <strong class="lg hj">matplotlib</strong> <strong class="lg hj">import</strong> pyplot<br/>pyplot.figure(1)<br/>pyplot.subplot(211)<br/>y.passengers.hist()<br/>pyplot.subplot(212)<br/>y.passengers.plot(kind='kde')<br/>pyplot.show()</span></pre><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es ma"><img src="../Images/9b145218a30343436829b36edfc26c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBmcmGkzVnEi2p85CnOgvQ.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">数据略有偏差</figcaption></figure><ul class=""><li id="c340" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">平稳性检验:</strong>如果一个时间序列的均值、方差等统计特性随时间保持不变，则称该时间序列是平稳的。大多数时间序列模型都假设TS是稳定的。这主要是因为一个序列有许多种非平稳的方式，但只有一种平稳的方式。凭直觉，我们可以说，如果一个时间序列在一段时间内有一个特定的行为，那么它很有可能在未来也会遵循同样的行为。与非平稳序列相比，平稳序列的相关理论更加成熟，也更容易实现。我们可以使用各种技术来检查序列的平稳性，如下所示:</li></ul><ol class=""><li id="a5f4" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj mb jq jr js bi translated"><strong class="io hj"> ACF和PACF图</strong>:如果时间序列是平稳的，ACF/PACF图会在点与点之间有少量的滞后后显示相关性的<strong class="io hj">快速下降。</strong></li></ol><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="f53b" class="lk jz hi lg b fi ll lm l ln lo"><strong class="lg hj">from</strong> <strong class="lg hj">statsmodels.graphics.tsaplots</strong> <strong class="lg hj">import</strong> plot_acf<br/><strong class="lg hj">from</strong> <strong class="lg hj">statsmodels.graphics.tsaplots</strong> <strong class="lg hj">import</strong> plot_pacf<br/><br/>pyplot.figure()<br/>pyplot.subplot(211)<br/>plot_acf(y.passengers, ax=pyplot.gca(), lags = 30)<br/>pyplot.subplot(212)<br/>plot_pacf(y.passengers, ax=pyplot.gca(), lags = 30)<br/>pyplot.show()</span></pre><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mc"><img src="../Images/4b93261a102ba43e4380ad1a01eef93a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LftE5DtTof3-sI5uwfgJPw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">ACF和PACF图</figcaption></figure><p id="eb4c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个数据是不稳定的，因为大量以前的观察值与将来的值相关。置信区间被绘制成一个圆锥。默认情况下，这被设置为95%的置信区间，表明该圆锥之外的相关值很可能是相关的，而不是统计上的侥幸。滞后k处的部分自相关是在去除了由较短滞后处的项引起的任何相关的影响之后得到的相关。</p><p id="6b3b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2。绘制滚动统计</strong>:我们可以绘制移动平均线或移动方差，看它是否随时间变化。移动平均值/方差是指任何时刻“t”的平均值/方差，即过去12个月的平均值/方差。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="a59c" class="lk jz hi lg b fi ll lm l ln lo"><em class="md">#Determing rolling statistics</em><br/>rolmean = pd.rolling_mean(y, window=12)<br/>rolstd = pd.rolling_std(y, window=12)<br/><br/><em class="md">#Plot rolling statistics:</em><br/>orig = plt.plot(y, color='blue',label='Original')<br/>mean = plt.plot(rolmean, color='red', label='Rolling Mean')<br/>std = plt.plot(rolstd, color='black', label = 'Rolling Std')<br/>plt.legend(loc='best')<br/>plt.title('Rolling Mean &amp; Standard Deviation')<br/>plt.show(block=<strong class="lg hj">False</strong>)</span></pre><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es me"><img src="../Images/6f4790966fde72d762c0a7ac30ec3c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXM9J81lBIRdyHLPMU5L0A.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">滚动平均值和标准偏差</figcaption></figure><p id="357c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，滚动平均值和标准偏差相对于时间不是常数(增加趋势)。因此，时间序列不是静止的。</p><p id="8afa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 3。增强的Dickey-Fuller检验:</strong>这是检验平稳性的统计检验之一。这里的零假设是TS是非平稳的。测试结果由测试统计数据和不同置信水平的一些临界值组成。如果“检验统计量”小于“临界值”，我们可以拒绝零假设，说序列是平稳的。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="faad" class="lk jz hi lg b fi ll lm l ln lo"><strong class="lg hj">from</strong> <strong class="lg hj">statsmodels.tsa.stattools</strong> <strong class="lg hj">import</strong> adfuller<br/>print ('Results of Dickey-Fuller Test:')<br/>dftest = adfuller(y.passengers, autolag='AIC')<br/>dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])<br/><strong class="lg hj">for</strong> key,value <strong class="lg hj">in</strong> dftest[4].items():<br/>    dfoutput['Critical Value (<strong class="lg hj">%s</strong>)'%key] = value<br/>print (dfoutput)</span></pre><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/f209534ca5b2e226263b529d5edb4c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*lGBdvg4yFZARKzOe5mz25w.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">迪基富勒试验</figcaption></figure><p id="853c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该测试表明，如果对序列进行积分，那么序列y(t-1)的滞后水平将不会提供预测y(t)变化的相关信息。零假设:时间序列不是平稳的。拒绝零假设(即非常低的p值)将表示稳定。</p><h1 id="bc58" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">非平稳序列向平稳序列的转换</strong></h1><p id="b9ee" class="pw-post-body-paragraph im in hi io b ip kw ir is it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj hb bi translated">在建立任何一种预测模型之前，将非平稳序列转换成平稳序列是非常重要的。时间序列的非平稳性背后有几个主要原因:</p><ol class=""><li id="5c4f" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj mb jq jr js bi translated"><strong class="io hj">趋势</strong> —随时间变化的平均值。例如，在上面的问题中，我们看到，平均而言，乘客的数量随着时间的推移而增长。</li><li id="ae17" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj mb jq jr js bi translated"><strong class="io hj">季节性</strong> —特定时间段的变化。因为夏天或节日，人们可能会在某个特定的月份购买冰淇淋。</li></ol><p id="9a80" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下述方法可用于将非平稳序列转换为平稳序列。</p><ul class=""><li id="7ccb" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">对数变换:</strong>对数变换对较高值的惩罚比对较小值的惩罚更大。这些可能需要一段时间。</li></ul><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="8960" class="lk jz hi lg b fi ll lm l ln lo">ts_log = np.log(y)<br/>plt.plot(ts_log)</span></pre><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mg"><img src="../Images/0cb58abbc4cfea1d0e9565dfc1e5b078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LCrnYuaT1rpAMzLn3mLxQw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">转换系列</figcaption></figure><ul class=""><li id="990c" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">趋势去除或平滑:</strong>平滑是在时间窗口内取滚动平均值。我们根据时间序列的频率取“k”个连续值的平均值。这里我们可以取过去1年的平均值，即最后12个值。这种特定方法的缺点是必须严格定义时间段。</li></ul><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="40e6" class="lk jz hi lg b fi ll lm l ln lo">moving_avg = pd.rolling_mean(ts_log,12)<br/>plt.plot(ts_log)<br/>plt.plot(moving_avg, color='red')</span><span id="1acd" class="lk jz hi lg b fi lp lm l ln lo">ts_log_moving_avg_diff = ts_log.passengers - moving_avg.passengers<br/>ts_log_moving_avg_diff.head(12)<br/>ts_log_moving_avg_diff.dropna(inplace=<strong class="lg hj">True</strong>)</span><span id="aaae" class="lk jz hi lg b fi lp lm l ln lo">#Using Dickeys Fuller Test<br/>CheckForStationarity(ts_log_moving_avg_diff)</span></pre><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mh"><img src="../Images/aa2ea65f353f9ecb768cb15d6bb705c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7rfRC3BcluO2tOu_0Qb4OA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">缓和</figcaption></figure><ul class=""><li id="fdb2" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">差异:</strong>之前讨论的简单趋势缩减技术并不适用于所有情况，尤其是季节性较强的情况。在这种技术中，我们取某一特定时刻的观测值与前一时刻的观测值之差。</li></ul><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="f1ca" class="lk jz hi lg b fi ll lm l ln lo">ts_log_diff = ts_log.passengers - ts_log.passengers.shift()<br/>plt.plot(ts_log_diff)</span></pre><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mi"><img src="../Images/67c8a27961670971e8eb7279da41c9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3c4-xixR7UQPHspOyRPSw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">对数列求差使其平稳</figcaption></figure><p id="44f1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">做一个迪基的更全面的平稳性测试，结果将是上述系列</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/ebd0259e9ffd8bd93d3171409c11647d.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*AElfMMWxahtzK_W1u4ERIw.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">迪基富勒试验</figcaption></figure><p id="9a46" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，一旦时间序列是稳定的，它就可以作为预测模型的消耗，这将在时间序列预测的下一篇文章中讨论。</p><p id="2f29" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果想了解更多关于模型构建和特征工程的知识，请参考下面提到的文章。</p><div class="mk ml ez fb mm mn"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/machine-learning-model-development-life-cycle-dcb238a3bd2d"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hj fi z dy ms ea eb mt ed ef hh bi translated">机器学习模型开发生命周期</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">机器学习开发生命周期是数据科学行业用来设计、开发和测试…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">medium.com</p></div></div></div></a></div><div class="mk ml ez fb mm mn"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/feature-selection-feature-engineering-3bb09c67d8c5"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hj fi z dy ms ea eb mt ed ef hh bi translated">特征选择和特征工程</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">数据科学视角中的特征，也称为维度、自变量、列。选择和处理…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">medium.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb ik mn"/></div></div></a></div><p id="379d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以通过Linkedin联系我:</p><div class="mk ml ez fb mm mn"><a href="https://www.linkedin.com/in/utkarsh-kulshrestha-69692666/" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hj fi z dy ms ea eb mt ed ef hh bi translated">Utkarsh Kulshrestha -人工智能工程师-银行&amp;金融服务|…</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">在人工智能解决方案、机器/深度学习方面拥有丰富的专业知识——RNN、LSTM、GRU、CNN、DNN、Keras、Tensorflow、文本挖掘……</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">www.linkedin.com</p></div></div></div></a></div></div></div>    
</body>
</html>