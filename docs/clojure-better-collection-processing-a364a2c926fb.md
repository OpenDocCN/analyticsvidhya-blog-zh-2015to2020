# Clojure:更好的集合处理

> 原文：<https://medium.com/analytics-vidhya/clojure-better-collection-processing-a364a2c926fb?source=collection_archive---------8----------------------->

在一个完美的世界中，数据将被结构化和清理，我们不必在它准备好供消费之前花费时间清理和处理它。

不幸的是，我们都发现自己在处理大量的原始数据，这些数据在提供给其他人之前需要清理和处理。

鉴于 Clojure 是一个 LISP(字面意思是列表处理人员),它有很好的开箱即用列表处理工具..)但是通常代码并不是以最好的方式编写的，这导致了较慢的处理时间和愤怒的客户。

**让我们从一个小的问题陈述开始，通过一个小的角色扮演来强调 Clojure 能为我们做些什么(最佳的)**

你是一名新加入的软件工程师，就职于一家著名的跨国公司，该公司在美国、英国、澳大利亚、爱尔兰、新西兰、月球等地都设有办事处

你第一天在他们的 Airoli 办公室报道，非常兴奋

![](img/7cc6211f649df3d8d7e1bb8234d9ea04.png)

您的老板要求您提供一份经过处理的符合特定匹配条件的选民名单

让我们收集一些数据

*重复*函数返回一个惰性序列，**实现**列表，这样就可以精确测量我们不同解决方案的计算时间，同时也给我们一个数据外观的概念

源数据是一个简单的地图列表

我们的客户要求我们返回姓氏为“baker”和“miller”的选民姓名

我们的最终用户并不真正关心单独的**名**和**姓**字段，他们喜欢将名和姓结合在一起的**全名**字段。听起来很简单，对吗？

我们知道，通过 map 函数，我们可以为客户提供他想要的新字符串

我们知道过滤函数让我们只从列表中挑选感兴趣的项目

我们可能以前使用过线程宏，并且知道我们可以把它包装在一起成为一个完整的解决方案

不错，你在 1.2 秒内处理了 100 多万条记录。但是我们可以做得更好。

根据经验，每当您遇到需要运行**映射**和**过滤器**的情况时，总是首先运行**过滤器**，这将删除不满足谓词函数的项目，以便我们的**映射**函数在更少的项目上运行。

用掌握的知识重写上面的函数

干得好。您已经将处理时间减少了不到一半！！

但这篇博客的标题是更好的收集处理。所以我们要更进一步。

首先是一些背景信息..

> Clojure 数据结构是**不可变的**，这意味着当修改数据时，clojure 会创建一个**新的**副本，并对其应用更改。

这导致了一个问题，因为我们所做的每一个修改都有一个在后台创建的新数据结构的开销。

在上述示例中的线程宏中，由于对原始数据集合应用了过滤函数，所以在后台创建了一个**中介**数据结构，然后该数据结构被传递给映射函数，该函数在完成后将再次创建另一个中介数据结构

这并不全是坏事，因为 clojure 数据结构也是**持久的**，这意味着由于修改而创建的新数据结构与原始数据结构共享其结构(这里有更多关于持久数据的内容[持久集合](https://clojure.org/reference/data_structures#Collections))。

但是对于面向性能的应用程序，为了获得更快的速度，我们可能希望取消中间数据结构的创建。

我们知道**映射**和**过滤器**返回惰性序列，但是有时我们可能对处理时间不完全满意，并且想要实现我们自己的**更快的**惰性序列。

Clojure 提供了 **lazy-seq** 函数，允许您创建定制的惰性序列

凭借新发现的知识，作为我们虚构的著名跨国公司的一名员工，我们知道**足够好还不够好。**

让我们尝试使用广受欢迎的**循环递归**支持的 **lazy-seq** 来重新编写我们的函数，这一次是为了创建我们自己的更快的 lazy-seq，而不是 Clojure 给我们的普通**映射**和**过滤器**

哇哦..为了便于理解，我们已经将处理时间减少到最初的 1/3。

接下来我们看一下 **keep** 函数，这是另一个集合处理工具，它允许您在对集合执行过滤的同时对集合元素进行转换。你可以把它看成是**贴图**和**滤镜**的组合。让我们再写一遍上面的例子，但是这次利用**保持**

**保持**和**过滤器**之间的一个重要区别是，如果对一个项目的过滤函数的结果为**逻辑假**(包括假和零)，过滤器将从集合中删除该项目

其中，as **keep** 只会在对其执行的函数的结果为 **nil** 时移除该项，这意味着它不会从集合中移除 **false** 项。

我们的经验法则有一点改变，当你遇到需要应用**贴图**和**滤镜**的情况时，使用**保持**来代替

请注意，虽然使用**保持**的处理时间比使用**映射**和**过滤器**的处理时间要快，但仍然比我们定制的基于惰性序列的解决方案慢。

> 要点是，在处理性能关键型应用时，您不应该回避创建自己的基于定制惰性序列的解决方案。

**何去何从？**

1.  在您当前的生产代码中找到一个数据管道，在那里收集处理做得很差，客户总是抱怨装载时间慢。
2.  实现您新发现的 clojure 集合技巧
3.  ??
4.  利润

如果你读到这里，感谢你的时间，如果你觉得这很有帮助，我真的很想听听:)，联系我:[卡万·大卫](https://www.linkedin.com/in/cavan-david-604222b2/)