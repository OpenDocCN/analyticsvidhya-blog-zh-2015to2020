<html>
<head>
<title>An Introduction to Implementing Neural Networks using TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用张量流实现神经网络的介绍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/an-introduction-to-implementing-neural-networks-using-tensorflow-4082c036d40c?source=collection_archive---------1-----------------------#2016-10-03">https://medium.com/analytics-vidhya/an-introduction-to-implementing-neural-networks-using-tensorflow-4082c036d40c?source=collection_archive---------1-----------------------#2016-10-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="96f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你一直在关注数据科学/机器学习，你就不能错过围绕深度学习和神经网络的嗡嗡声。组织正在尽可能地寻找具有深度学习技能的人。从举办竞赛到开放采购项目和支付高额奖金，人们正在尝试一切可能的事情来挖掘这个有限的人才库。自动驾驶工程师正在被汽车行业的大佬们追逐，因为该行业正处于过去几十年来面临的最大破坏的边缘！</p><p id="956c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对深度学习提供的前景感到兴奋，但还没有开始你的旅程——我在这里可以实现它。从这篇文章开始，我将撰写一系列关于深度学习的文章，涵盖流行的深度学习库及其实际实现。</p><p id="982f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将向您介绍TensorFlow。读完这篇文章后，你将能够理解神经网络的应用，并使用TensorFlow解决现实生活中的问题。本文将要求您了解神经网络的基础知识，并熟悉编程。尽管本文中的代码是用python编写的，但我还是把重点放在了概念上，并尽可能保持语言无关性。</p><p id="e71a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们开始吧！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/9412acc2f5021e2cc65b50a4e87bc2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5CR2kWlRW8yh-Ebd.jpg"/></div></div></figure><ul class=""><li id="1f30" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">什么时候应用神经网络？</li><li id="19b1" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">用神经网络解决问题的一般方法</li><li id="3e2f" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">了解图像数据和流行的库来解决它</li><li id="4a1b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">什么是张量流？</li><li id="a3e3" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">一个典型的张量流“流”</li><li id="d2b7" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在TensorFlow中实现MLP</li><li id="7041" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">张量流的局限性</li><li id="f3ee" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">TensorFlow与其他库</li><li id="677b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">从这里去哪里？</li></ul><h1 id="65b8" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么时候应用神经网络？</h1><p id="3ad9" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">神经网络成为焦点已经有一段时间了。关于神经网络和深度学习的更详细的解释<a class="ae lg" href="https://www.analyticsvidhya.com/blog/2016/08/evolution-core-concepts-deep-learning-neural-networks/" rel="noopener ugc nofollow" target="_blank">请阅读这里的</a>。它的“更深入”版本正在许多领域取得巨大突破，如图像识别、语音和自然语言处理等。</p><p id="fd57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出现的主要问题是什么时候应用神经网络，什么时候不应用神经网络？这个领域现在就像一座金矿，每天都有许多新发现被发现。要成为这股“淘金热”的一部分，你必须记住几件事:</p><ul class=""><li id="c155" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><strong class="ih hj">首先，神经网络需要清晰、翔实的数据(大多是大数据)来训练。</strong>试着想象小时候的神经网络。它首先观察它的父母如何走路。然后它试着自己走路，每走一步，孩子就学会如何完成一项特殊的任务。它可能会跌倒几次，但在几次不成功的尝试后，它学会了如何走路。如果你不让它走路，它可能永远也学不会走路。你能给孩子提供的接触越多越好。</li><li id="e78f" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">使用神经网络处理图像处理等复杂问题是谨慎的。神经网络属于一类叫做表示学习算法的算法。这些算法将复杂的问题分解成更简单的形式，以便它们变得可以理解(或“可表示”)。把它想象成吞咽前的咀嚼食物。这对于传统的(非表示学习)算法来说会更加困难。</li><li id="95dd" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">当你有合适类型的神经网络来解决问题时。每个问题都有它自己的曲折之处。所以数据决定了你解决问题的方式。例如，如果问题是序列生成，递归神经网络更适合。然而，如果是图像相关的问题，你可能会更好地采取卷积神经网络的变化。</strong></li><li id="6ab8" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">最后同样重要的是，</strong> <strong class="ih hj">硬件</strong> <strong class="ih hj">需求对于运行深度神经网络模型是必不可少的。</strong>神经网络很早以前就被“发现”了，但近年来大放异彩，主要原因是计算资源更好、更强大。如果你想用这些网络解决一个现实生活中的问题，准备买一些高端硬件吧！</li></ul><h1 id="2a37" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">用神经网络解决问题的一般方法</h1><p id="2e84" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">神经网络是一种特殊类型的机器学习(ML)算法。因此，作为每一个最大似然算法，它遵循通常的数据预处理，模型建立和模型评估的最大似然工作流程。为了简洁起见，我列出了一个如何处理神经网络问题的待办事项列表。</p><ul class=""><li id="327a" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">检查神经网络是否比传统算法更好(参考上一节中的清单)</li><li id="aebf" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">调查哪种神经网络架构最适合所需的问题</li><li id="4b29" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">定义你所选择的语言/库的神经网络架构。</li><li id="fb74" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">将数据转换为正确的格式，并分批进行分割</li><li id="19f7" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">根据您的需要预处理数据</li><li id="c3d1" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">扩充数据以增加规模并制作更好的训练模型</li><li id="2f33" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">向神经网络输入批次</li><li id="e9d0" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">培训并监控培训和验证数据集的变化</li><li id="78ee" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">测试您的模型，并保存它以供将来使用</li></ul><p id="e3ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将重点讨论图像数据。因此，在我们深入研究张量流之前，让我们先了解这一点。</p><h1 id="1b07" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">了解图像数据和流行的库来解决它</h1><p id="a415" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">图像通常被排列成三维阵列，其维度是指高度、宽度和颜色通道。例如，如果你现在给你电脑截图，它会先被转换成一个三维数组，然后再进行压缩。jpeg或。“png”文件格式。</p><p id="8781" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这些图像对人类来说很容易理解，但计算机却很难理解它们。这种现象被称为“语义鸿沟”。我们的大脑可以在几秒钟内看到图像并理解完整的画面。另一方面，计算机认为图像只是一组数字。所以问题是我们如何向机器解释这个图像？</p><p id="c1be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在早期，人们试图像“模板”一样将图像分解为机器“可理解”的格式。例如，一张脸总是有一个特定的结构，这个结构在每个人身上都有所保留，比如眼睛的位置，鼻子或者我们脸的形状。但是这种方法会很繁琐，因为当需要识别的物体数量增加时，“模板”就不适用了。</p><p id="fe29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快进到2012年，一种深度神经网络架构赢得了ImageNet挑战赛，这是一项从自然场景中识别物体的著名挑战。在所有即将到来的ImageNet挑战中，它继续统治着它的主权，从而证明了解决图像问题的有用性。</p><p id="2e9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么人们通常使用哪种库/语言来解决图像识别问题呢？我最近做的一个调查显示，大多数流行的深度学习库都有Python接口，其次是Lua、Java和Matlab。举几个例子，最受欢迎的库是:</p><ul class=""><li id="e53d" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><a class="ae lg" href="http://caffe.berkeleyvision.org/" rel="noopener ugc nofollow" target="_blank">咖啡馆</a></li><li id="ee9e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><a class="ae lg" href="http://deeplearning4j.org/" rel="noopener ugc nofollow" target="_blank">深度学习4j </a></li><li id="185d" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><a class="ae lg" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank">张量流</a></li><li id="36d5" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><a class="ae lg" href="http://www.deeplearning.net/software/theano" rel="noopener ugc nofollow" target="_blank">theno</a></li><li id="c958" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><a class="ae lg" href="http://torch.ch/" rel="noopener ugc nofollow" target="_blank">火炬</a></li></ul><p id="61ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您已经了解了图像的存储方式以及常用的库，让我们看看TensorFlow提供了什么。</p><h1 id="2bc4" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是张量流？</h1><p id="f30c" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">让我们从官方定义开始，</p><blockquote class="lh li lj"><p id="2794" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">“tensor flow是一个使用数据流图进行数值计算的开源软件库。图中的节点表示数学运算，而图边表示它们之间通信的多维数据阵列(也称为张量)。灵活的架构允许您使用单个API将计算部署到台式机、服务器或移动设备中的一个或多个CPU或GPU。”</em></p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lo"><img src="../Images/7715552f0899d8a3284e3c49ddf21cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/0*ZsDKAgI4HN5SToMK.gif"/></div></figure><p id="255a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这听起来有点可怕，不要担心。这是我的简单定义——把张量流看做一个扭曲的numpy。如果你之前做过numpy，理解TensorFlow将是小菜一碟！numpy和TensorFlow的一个主要区别是TensorFlow遵循一种惰性编程范式。它首先构建一个所有要完成的操作的图，然后当一个“会话”被调用时，它“运行”这个图。它通过将内部数据表示改为张量(也称为多维数组)来实现可伸缩性。建立一个计算图可以被认为是张量流的主要组成部分。要了解更多关于计算图的数学构成，请阅读本文。</p><p id="bc91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很容易把TensorFlow归为神经网络库，但不仅仅是这样。是的，它被设计成一个强大的神经网络库。但它有能力做的远不止这些。你可以在其上建立其他机器学习算法，如决策树或k-最近邻。你可以在numpy中做任何你平常会做的事情！它被恰当地称为“类固醇上的numpy”</p><p id="ce74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用张量流的优点是:</p><ul class=""><li id="4d46" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><strong class="ih hj">它有一个直观的构造</strong>，因为顾名思义它有<em class="lk">“张量流”。</em>您可以轻松地将图表的每个部分可视化。</li><li id="a982" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">轻松在cpu/gpu上训练分布式计算</strong></li><li id="97da" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">平台灵活性</strong>。你可以在任何你想去的地方运行这些模型，无论是在移动设备、服务器还是个人电脑上。</li></ul><h1 id="bcb7" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">一个典型的张量流“流”</h1><p id="d285" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">每个库都有自己的“实现细节”，即遵循其编码范式的编写方式。例如，当实现scikit-learn时，首先创建所需算法的对象，然后在训练中构建模型并在测试集上获得预测，如下所示:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="e376" class="lu ke hi lq b fi lv lw l lx ly"># define hyperparamters of ML algorithm<br/>clf = svm.SVC(gamma=0.001, C=100.)<br/># train <br/>clf.fit(X, y)<br/># test <br/>clf.predict(X_test)</span></pre><p id="e897" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我前面所说，TensorFlow遵循一种懒惰的方法。在TensorFlow中运行程序的通常工作流程如下:</p><ul class=""><li id="f296" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><strong class="ih hj">构建计算图，</strong>这可以是TensorFlow支持的任何数学运算。</li><li id="116e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">初始化变量，</strong>编译先前定义的变量</li><li id="cfad" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">创建会话，</strong>这是魔法开始的地方！</li><li id="8c5a" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">在会话中运行图形，</strong>编译后的图形被传递给会话，并开始执行。</li><li id="c4ce" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">关闭会话，</strong>关闭会话。</li></ul><p id="a60b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TensoFlow中使用的少数术语；</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="ee21" class="lu ke hi lq b fi lv lw l lx ly">placeholder: A way to feed data into the graphs</span></pre><ul class=""><li id="5d81" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">占位符:将数据输入图表的一种方式</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="43bc" class="lu ke hi lq b fi lv lw l lx ly">feed_dict: A dictionary to pass numeric values to computational graph</span></pre><p id="ecc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们写一个小程序将两个数相加！</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="66a8" class="lu ke hi lq b fi lv lw l lx ly"># import tensorflow<br/>import tensorflow as tf<br/><br/># build computational graph<br/>a = tf.placeholder(tf.int16)<br/>b = tf.placeholder(tf.int16)<br/><br/>addition = tf.add(a, b)<br/><br/># initialize variables<br/>init = tf.initialize_all_variables()<br/><br/># create session and run the graph<br/>with tf.Session() as sess:<br/>    sess.run(init)<br/>    print "Addition: %i" % sess.run(addition, feed_dict={a: 2, b: 3})<br/><br/># close session<br/>sess.close()</span></pre><h1 id="535e" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">在TensorFlow中实现神经网络</h1><p id="c12b" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">注意:我们可以使用不同的神经网络架构来解决这个问题，但是为了简单起见，我们决定采用前馈多层感知器进行深入实施。</p><p id="c538" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先回忆一下我们对神经网络的了解。</p><p id="1d4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">神经网络的典型实现如下:</p><ul class=""><li id="c0dc" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">定义要编译的神经网络架构</li><li id="036b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">将数据传输到您的模型</li><li id="93ab" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在引擎盖下，数据首先被分批次，以便能够被摄取。这些批次首先经过预处理、扩充，然后输入神经网络进行训练</li><li id="2371" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">然后，该模型得到增量训练</li><li id="f0c2" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">显示特定时间步长数的精确度</li><li id="1c9a" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">训练后，保存模型以备将来使用</li><li id="2139" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在新数据上测试模型，并检查其表现如何</li></ul><p id="3c83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们解决我们的深度学习实践问题——<a class="ae lg" href="https://datahack.analyticsvidhya.com/contest/practice-problem-identify-the-digits/" rel="noopener ugc nofollow" target="_blank">识别数字</a>。让我们看一下我们的问题陈述。</p><p id="416a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的问题是图像识别，从给定的28×28图像中识别数字。我们有一个图像子集用于训练，其余的用于测试我们的模型。所以首先，下载训练和测试文件。数据集包含数据集中所有图像的压缩文件，并且train.csv和test.csv都具有相应的train和test图像的名称。数据集中不提供任何附加特征，只提供原始图像。“png”格式。</p><p id="9006" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所知，我们将使用TensorFlow来制作一个神经网络模型。所以你应该首先在你的系统中安装TensorFlow。根据您的系统规格，参考<a class="ae lg" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/g3doc/get_started/os_setup.md" rel="noopener ugc nofollow" target="_blank">官方安装指南</a>进行安装。</p><p id="8822" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将遵循如上所述的模板。用python 2.7内核创建一个Jupyter笔记本，按照下面的步骤操作。</p><ul class=""><li id="dadc" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">让我们导入所有需要的模块</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="bdf5" class="lu ke hi lq b fi lv lw l lx ly">%pylab inline<br/><br/>import os<br/>import numpy as np<br/>import pandas as pd<br/>from scipy.misc import imread<br/>from sklearn.metrics import accuracy_score<br/>import tensorflow as tf</span></pre><ul class=""><li id="f0e6" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">让我们设置一个种子值，这样我们就可以控制模型的随机性</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="7617" class="lu ke hi lq b fi lv lw l lx ly"># To stop potential randomness <br/>seed = 128 <br/>rng = np.random.RandomState(seed)</span></pre><ul class=""><li id="bf04" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">为了安全起见，第一步是设置目录路径！</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="9b95" class="lu ke hi lq b fi lv lw l lx ly">root_dir = os.path.abspath('../..')<br/>data_dir = os.path.join(root_dir, 'data')<br/>sub_dir = os.path.join(root_dir, 'sub')<br/><br/># check for existence<br/>os.path.exists(root_dir)<br/>os.path.exists(data_dir)<br/>os.path.exists(sub_dir)</span></pre><ul class=""><li id="cc7d" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">现在让我们阅读我们的数据集。这些是流行的。csv格式，并有一个带有适当标签的文件名</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="086a" class="lu ke hi lq b fi lv lw l lx ly">train = pd.read_csv(os.path.join(data_dir, 'Train', 'train.csv'))<br/>test = pd.read_csv(os.path.join(data_dir, 'Test.csv'))<br/><br/>sample_submission = pd.read_csv(os.path.join(data_dir, 'Sample_Submission.csv'))<br/><br/>train.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lz"><img src="../Images/eb75767336ffaa4471c28578802670f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*hqq-0YpuTkKTW-_AiR6hmA.png"/></div></figure><ul class=""><li id="ff8d" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">让我们看看我们的数据是什么样的！我们读取并显示我们的图像。</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="8e4a" class="lu ke hi lq b fi lv lw l lx ly">img_name = rng.choice(train.filename)<br/>filepath = os.path.join(data_dir, 'Train', 'Images', 'train', img_name)<br/><br/>img = imread(filepath, flatten=True)<br/><br/>pylab.imshow(img, cmap='gray')<br/>pylab.axis('off')<br/>pylab.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ma"><img src="../Images/e3ca8110fb4895a234f2fff1ab13ac5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/0*s_jBg404Ih7eU4Il.png"/></div></figure><p id="3283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的图像表示为numpy数组，如下所示</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/0ce49bcfe056b86b229ac6edd285abfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fDOB63gt3gT_qDoo.png"/></div></div></figure><ul class=""><li id="79ca" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">为了便于数据操作，让我们将所有图像存储为numpy数组</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="7c11" class="lu ke hi lq b fi lv lw l lx ly">temp = []<br/>for img_name in train.filename:<br/>    image_path = os.path.join(data_dir, 'Train', 'Images', 'train', img_name)<br/>    img = imread(image_path, flatten=True)<br/>    img = img.astype('float32')<br/>    temp.append(img)<br/>    <br/>train_x = np.stack(temp)<br/><br/>temp = []<br/>for img_name in test.filename:<br/>    image_path = os.path.join(data_dir, 'Train', 'Images', 'test', img_name)<br/>    img = imread(image_path, flatten=True)<br/>    img = img.astype('float32')<br/>    temp.append(img)<br/>    <br/>test_x = np.stack(temp)</span></pre><ul class=""><li id="521c" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">由于这是一个典型的ML问题，为了测试我们模型的正常运行，我们创建了一个验证集。让我们对训练集和验证集采用70:30的分割大小</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="9dec" class="lu ke hi lq b fi lv lw l lx ly">split_size = int(train_x.shape[0]*0.7)<br/><br/>train_x, val_x = train_x[:split_size], train_x[split_size:]<br/>train_y, val_y = train.label.values[:split_size], train.label.values[split_size:]</span></pre><ul class=""><li id="c1fd" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">现在我们定义一些辅助函数，我们稍后会在程序中用到</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="f4d4" class="lu ke hi lq b fi lv lw l lx ly">def dense_to_one_hot(labels_dense, num_classes=10):<br/>    """Convert class labels from scalars to one-hot vectors"""<br/>    num_labels = labels_dense.shape[0]<br/>    index_offset = np.arange(num_labels) * num_classes<br/>    labels_one_hot = np.zeros((num_labels, num_classes))<br/>    labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1<br/>    <br/>    return labels_one_hot<br/><br/>def preproc(unclean_batch_x):<br/>    """Convert values to range 0-1"""<br/>    temp_batch = unclean_batch_x / unclean_batch_x.max()<br/>    <br/>    return temp_batch<br/><br/>def batch_creator(batch_size, dataset_length, dataset_name):<br/>    """Create batch with random samples and return appropriate format"""<br/>    batch_mask = rng.choice(dataset_length, batch_size)<br/>    <br/>    batch_x = eval(dataset_name + '_x')[[batch_mask]].reshape(-1, input_num_units)<br/>    batch_x = preproc(batch_x)<br/>    <br/>    if dataset_name == 'train':<br/>        batch_y = eval(dataset_name).ix[batch_mask, 'label'].values<br/>        batch_y = dense_to_one_hot(batch_y)<br/>        <br/>    return batch_x, batch_y</span></pre><ul class=""><li id="5783" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">现在是主要部分！让我们定义我们的神经网络架构。我们定义了一个具有3层的神经网络；输入、隐藏和输出。输入和输出中神经元的数量是固定的，因为输入是我们的28 x 28图像，输出是代表类的10 x 1向量。我们在隐藏层取了500个神经元。这个数字可以根据您的需要而变化。我们也给剩余的变量赋值。阅读关于神经网络基础的<a class="ae lg" href="https://www.analyticsvidhya.com/blog/2016/03/introduction-deep-learning-fundamentals-neural-networks/" rel="noopener ugc nofollow" target="_blank">文章，深入了解其工作原理。</a></li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="d304" class="lu ke hi lq b fi lv lw l lx ly">### set all variables<br/><br/># number of neurons in each layer<br/>input_num_units = 28*28<br/>hidden_num_units = 500<br/>output_num_units = 10<br/><br/># define placeholders<br/>x = tf.placeholder(tf.float32, [None, input_num_units])<br/>y = tf.placeholder(tf.float32, [None, output_num_units])<br/><br/># set remaining variables<br/>epochs = 5<br/>batch_size = 128<br/>learning_rate = 0.01<br/><br/>### define weights and biases of the neural network (refer <a class="ae lg" href="https://www.analyticsvidhya.com/blog/2016/03/introduction-deep-learning-fundamentals-neural-networks/" rel="noopener ugc nofollow" target="_blank">this article</a> if you don't understand the terminologies)<br/><br/>weights = {<br/>    'hidden': tf.Variable(tf.random_normal([input_num_units, hidden_num_units], seed=seed)),<br/>    'output': tf.Variable(tf.random_normal([hidden_num_units, output_num_units], seed=seed))<br/>}<br/><br/>biases = {<br/>    'hidden': tf.Variable(tf.random_normal([hidden_num_units], seed=seed)),<br/>    'output': tf.Variable(tf.random_normal([output_num_units], seed=seed))<br/>}</span></pre><ul class=""><li id="99fb" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">现在创建我们的神经网络计算图</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="3bd8" class="lu ke hi lq b fi lv lw l lx ly">hidden_layer = tf.add(tf.matmul(x, weights['hidden']), biases['hidden'])<br/>hidden_layer = tf.nn.relu(hidden_layer)<br/><br/>output_layer = tf.matmul(hidden_layer, weights['output']) + biases['output']</span></pre><ul class=""><li id="0464" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">此外，我们需要定义神经网络的成本</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="ecac" class="lu ke hi lq b fi lv lw l lx ly">cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output_layer, y))</span></pre><ul class=""><li id="dec3" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">并设置优化器，即我们的反向传播算法。这里我们使用<a class="ae lg" href="https://arxiv.org/abs/1412.6980" rel="noopener ugc nofollow" target="_blank"> Adam </a>，它是梯度下降算法的一个高效变体。tensorflow中还有许多其他的优化器(参见<a class="ae lg" href="https://www.tensorflow.org/versions/r0.11/api_docs/python/train.html#optimizers" rel="noopener ugc nofollow" target="_blank">这里</a>)</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="2f60" class="lu ke hi lq b fi lv lw l lx ly">optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(cost)</span></pre><ul class=""><li id="d097" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">在定义了我们的神经网络架构之后，让我们初始化所有的变量</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="c763" class="lu ke hi lq b fi lv lw l lx ly">init = tf.initialize_all_variables()</span></pre><ul class=""><li id="ec1e" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">现在让我们创建一个会话，并在会话中运行我们的神经网络。我们还在我们创建的验证集上验证我们的模型的准确性</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="e652" class="lu ke hi lq b fi lv lw l lx ly">with tf.Session() as sess:<br/>    # create initialized variables<br/>    sess.run(init)<br/>    <br/>    ### for each epoch, do:<br/>    ###   for each batch, do:<br/>    ###     create pre-processed batch<br/>    ###     run optimizer by feeding batch<br/>    ###     find cost and reiterate to minimize<br/>    <br/>    for epoch in range(epochs):<br/>        avg_cost = 0<br/>        total_batch = int(train.shape[0]/batch_size)<br/>        for i in range(total_batch):<br/>            batch_x, batch_y = batch_creator(batch_size, train_x.shape[0], 'train')<br/>            _, c = sess.run([optimizer, cost], feed_dict = {x: batch_x, y: batch_y})<br/>            <br/>            avg_cost += c / total_batch<br/>            <br/>        print "Epoch:", (epoch+1), "cost =", "{:.5f}".format(avg_cost)<br/>    <br/>    print "\nTraining complete!"<br/>    <br/>    <br/>    # find predictions on val set<br/>    pred_temp = tf.equal(tf.argmax(output_layer, 1), tf.argmax(y, 1))<br/>    accuracy = tf.reduce_mean(tf.cast(pred_temp, "float"))<br/>    print "Validation Accuracy:", accuracy.eval({x: val_x.reshape(-1, input_num_units), y: dense_to_one_hot(val_y)})<br/>    <br/>    predict = tf.argmax(output_layer, 1)<br/>    pred = predict.eval({x: test_x.reshape(-1, input_num_units)})</span></pre><p id="2828" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将是上述代码的输出</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="3001" class="lu ke hi lq b fi lv lw l lx ly">Epoch: 1 cost = 8.93566<br/>Epoch: 2 cost = 1.82103<br/>Epoch: 3 cost = 0.98648<br/>Epoch: 4 cost = 0.57141<br/>Epoch: 5 cost = 0.44550<br/><br/>Training complete!<br/>Validation Accuracy: 0.952823</span></pre><ul class=""><li id="deed" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">为了用我们自己的眼睛测试我们的模型，让我们想象它的预测</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="6840" class="lu ke hi lq b fi lv lw l lx ly">img_name = rng.choice(test.filename)<br/>filepath = os.path.join(data_dir, 'Train', 'Images', 'test', img_name)<br/><br/>img = imread(filepath, flatten=True)<br/><br/>test_index = int(img_name.split('.')[0]) - 49000<br/><br/>print "Prediction is: ", pred[test_index]<br/><br/>pylab.imshow(img, cmap='gray')<br/>pylab.axis('off')<br/>pylab.show()</span><span id="14f0" class="lu ke hi lq b fi mc lw l lx ly">Prediction is: 8</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ma"><img src="../Images/ac7abb70cdba754e06254516aae96df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/0*xcfVfUGvyWrxcGyW.png"/></div></figure><ul class=""><li id="9eb2" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">我们看到我们的模型性能相当不错！现在让我们创建一个提交</li></ul><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="5715" class="lu ke hi lq b fi lv lw l lx ly">sample_submission.filename = test.filename<br/><br/>sample_submission.label = pred<br/><br/>sample_submission.to_csv(os.path.join(sub_dir, 'sub01.csv'), index=False)</span></pre><p id="390f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">搞定了。我们刚刚创建了我们自己训练过的神经网络！</p><h1 id="489e" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">张量流的局限性</h1><ul class=""><li id="9847" class="jp jq hi ih b ii lb im lc iq md iu me iy mf jc ju jv jw jx bi translated">即使TensorFlow很强大，它仍然是一个低级的库。例如，它可以被认为是一种机器语言。但是对于大多数目的，你需要模块化和高级接口，比如keras</li><li id="ac14" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">它仍在开发中，所以更多的精彩即将到来！</li><li id="ecc9" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">这取决于你的硬件规格，越多越好</li><li id="ca3b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">仍然不是许多语言的API。</li><li id="05d4" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">TensorFlow还有很多东西还没有包含进来，比如OpenCL支持。</li></ul><p id="4d91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面提到的大部分都在TensorFlow开发者的视野之内。他们已经制定了一个路线图，用于指定未来应该如何开发这个库。</p><h1 id="8d2d" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">TensorFlow与其他库</h1><p id="a87d" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">TensorFlow建立在与使用数学计算图的ano和Torch相似的原理上。但是有了分布式计算的额外支持，TensorFlow在解决复杂问题方面表现得更好。此外，TensorFlow模型的部署已经得到支持，这使得它更容易用于工业目的，从而与Deeplearning4j、H2O和Turi等商业库展开竞争。TensorFlow有Python，C++和Matlab的API。最近对Ruby和r等其他语言的支持也有所增加。因此，TensorFlow正试图拥有一个通用的语言支持。</p><h1 id="5a95" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">从这里去哪里？</h1><p id="abf9" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">所以你看到了如何用TensorFlow建立一个简单的神经网络。这段代码是为了让人们理解如何开始实现TensorFlow，所以要有所保留。请记住，要解决更复杂的现实生活问题，您必须稍微调整一下代码。</p><p id="c0ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述许多功能都可以抽象出来，形成无缝的端到端工作流。如果您使用过scikit-learn，您可能会知道高级库如何抽象“幕后”实现，以便为最终用户提供更简单的界面。尽管TensorFlow已经抽象出了大部分实现，但高级库正在出现，如TF-slim和TFlearn。</p><h1 id="1fdf" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">有用的资源</h1><ul class=""><li id="f73b" class="jp jq hi ih b ii lb im lc iq md iu me iy mf jc ju jv jw jx bi translated"><a class="ae lg" href="https://github.com/tensorflow/tensorflow" rel="noopener ugc nofollow" target="_blank"> TensorFlow官方知识库</a></li><li id="8fc3" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">Rajat Monga (TensorFlow技术负责人)<a class="ae lg" href="https://youtu.be/wmw8Bbb_eIE" rel="noopener ugc nofollow" target="_blank">“tensor flow for every one”</a>视频</li><li id="3779" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><a class="ae lg" href="https://github.com/jtoy/awesome-tensorflow/#github-projects" rel="noopener ugc nofollow" target="_blank">专门资源的精选列表</a></li></ul><h1 id="725c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结束注释</h1><p id="21dd" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">我希望这篇文章对你有所帮助。现在，是你尽可能多的练习和阅读的时候了。祝你好运！如果你遵循不同的方法/包/库来开始学习神经网络，我很乐意在评论中与你互动。如果你有更多的建议，请在下面留言。为了获得在神经网络中工作的专业知识，不要忘记尝试我们的深度学习实践问题— <a class="ae lg" href="https://datahack.analyticsvidhya.com/contest/practice-problem-identify-the-digits/" rel="noopener ugc nofollow" target="_blank">识别数字</a>。</p><p id="43d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lk">原载于2016年10月3日</em><a class="ae lg" href="https://www.analyticsvidhya.com/blog/2016/10/an-introduction-to-implementing-neural-networks-using-tensorflow/" rel="noopener ugc nofollow" target="_blank"><em class="lk">www.analyticsvidhya.com</em></a><em class="lk">。</em></p></div></div>    
</body>
</html>