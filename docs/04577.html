<html>
<head>
<title>Playing Snake with AI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与艾玩蛇</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/playing-snake-with-ai-2ea68f0e914a?source=collection_archive---------3-----------------------#2020-03-25">https://medium.com/analytics-vidhya/playing-snake-with-ai-2ea68f0e914a?source=collection_archive---------3-----------------------#2020-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0686" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">比较不同的算法以最大化分数。</h2></div><blockquote class="ix iy iz"><p id="88d7" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><a class="ae jx" href="https://github.com/stschoberg/snakeGame" rel="noopener ugc nofollow" target="_blank">https://github.com/stschoberg/snakeGame</a></p></blockquote><h2 id="f9c3" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">游戏</h2><p id="d068" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj kj ky jm jn kn kz jq jr kr la ju jv jw hb bi translated">街机经典，蛇，是一个单人的，基于网格的游戏，挑战玩家尽可能长一条蛇。玩家引导蛇在网格中寻找苹果，每接触一个苹果，蛇的身体就会增长一个单位的长度。但是，如果蛇与自己的身体或网格的边界发生碰撞，游戏结束。随着蛇的成长，它变得越来越难以在自己的身体周围活动和吃苹果。目标是让蛇在与自身或墙壁发生碰撞之前尽可能长时间地生长(即尽可能多吃苹果)。</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="lg lh l"/></div></figure><h2 id="dd89" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">该项目</h2><p id="3073" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj kj ky jm jn kn kz jq jr kr la ju jv jw hb bi translated">作为人，我们可以制定不同的策略来玩好这个游戏。例如，我们可以直奔苹果，尽量远离蛇身体的其他部分，或者我们可以在屏幕上之字形移动，以最大化屏幕上我们可以移动的自由空间。</p><p id="8c18" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">如果我们可以直观地为Snake提出成功的策略，我们应该能够将这些策略编码到算法中，以便构建人工智能来玩这个游戏。这个项目的目标是实现和分析各种算法，从极其幼稚的算法到更加复杂的算法，以便在游戏中最大化一个分数。</p><h2 id="669a" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">实施</h2><p id="cace" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj kj ky jm jn kn kz jq jr kr la ju jv jw hb bi translated">首先，该表扬的我会表扬。感谢<a class="ae jx" href="https://techwithtim.net/tutorials/game-development-with-python/snake-pygame/" rel="noopener ugc nofollow" target="_blank"> techwithtim </a>提供了玩这个游戏的基础代码，所以我可以开始接触人工智能了。为了让游戏不那么复杂，我确实不得不改变他的一些设计选择。</p><p id="c4b5" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">我们的游戏是一个20x20的网格，每个蛇的身体单位和苹果占据一个空间。这条蛇一次只能移动NSWE一个街区。当蛇接触到墙壁或自身时，游戏重置。与其他实现不同，snake不能从屏幕的一边绕到另一边。当蛇死亡时，它会随机出现在长度为1的网格上。当蛇吃掉苹果时，另一个苹果会随机出现在格子中蛇不在的地方。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/5f14e317a1d1d8117b7a9dea7b9b61b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BvFBX6oWUm7OXx37lajh-A.png"/></div></div></figure><p id="f40d" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">在一个完美的游戏中，这条蛇会吃400个苹果，长400个单位(20x20网格)。我们现在可以更精确地重新定义我们的目标。<strong class="jd hj">找到一种算法，使平均分数在[0，400] </strong>的范围内最大化。</p><h1 id="e4f2" class="lp jz hi bd ka lq lr ls ke lt lu lv ki io lw ip km ir lx is kq iu ly iv ku lz bi translated">算法</h1><p id="f429" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj kj ky jm jn kn kz jq jr kr la ju jv jw hb bi translated">本节重点介绍确定性算法，以最大化分数。对于给定的输入，确定性算法将总是产生相同的输出。换句话说，我们将决策逻辑编码到算法中(例如，不要转向你的身体，选择到达苹果的最短路径)。当给定蛇的位置(蛇占据的单元列表)和苹果的位置以及确定性算法时，蛇将总是沿着相同的路径到达苹果。</p><p id="9c6c" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">对于每个算法，我将提供一些直觉、问题、游戏性和从不同运行中收集的数据。</p><h2 id="c2b4" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">确定性算法:编码决策逻辑</h2><h2 id="9b80" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.随机:一种愚蠢的方法</h2><p id="6f32" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj kj ky jm jn kn kz jq jr kr la ju jv jw hb bi translated">完全随机化的算法是最简单的，也是最不成功的，让人工智能玩游戏的方法。给定一个蛇的位置(被蛇占据的单元格列表)，AI随机移动一个有效的单元格。这个想法没有利用所有提供的信息(苹果的位置)，游戏看起来很随机。</p><p id="603a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">大多数时候，游戏以1分结束。偶尔会以2分结束。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ma"><img src="../Images/287b0db0444346621161061f32888678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*c2OoE5sUxWsc0tIZTFQqew.gif"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">完全随机化的算法。</figcaption></figure><p id="4cd8" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">试验的数据并不令人惊讶。</p><pre class="lb lc ld le fd mf mg mh mi aw mj bi"><span id="f797" class="jy jz hi mg b fi mk ml l mm mn">Number of Runs: 64<br/>Min: 1.000<br/>Q1: 1.000<br/>Median: 1.000<br/>Q3: 1.000<br/>Max: 3.000<br/>Mean: 1.078<br/>The 95.0% confidence interval of the mean score is between 0.997 and 1.159.</span></pre><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mo"><img src="../Images/9584019eec1982f117075e60e3ec9092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0cwvtx8gIelzFnrMAL99Tw.png"/></div></div></figure><h2 id="2c75" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.最短路径:好一点</h2><p id="c03a" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj kj ky jm jn kn kz jq jr kr la ju jv jw hb bi translated">在随机化方法中没有使用额外的信息之后，下一步使用所有可用的信息是有意义的。在下一个算法中，我们将使用苹果的位置来引导蛇到正确的方向。</p><p id="27b5" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">在每一步，AI将计算所有NSWE方格(即所有可能的移动)中蛇和水果之间的曼哈顿距离。曼哈顿距离就是从A点移动到b点所需的NSWE步数。人工智能选择与苹果距离最短的方向，并朝那个方向移动。它会重新计算所有1步相邻方块的距离，然后再次移动。这个过程一直持续到它找到果实或者死去。这个算法保证找到从蛇头到苹果的最短路径，因为它总是朝着最靠近苹果的方向移动。你应该能在下面的GIF中注意到这一点。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mp"><img src="../Images/0943339e1b94649935e386508a7fa9b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mSqt-6j53SVXmyNoebsG5Q.gif"/></div></div></figure><p id="fbf3" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">这种算法的得分明显更高。</p><pre class="lb lc ld le fd mf mg mh mi aw mj bi"><span id="a03e" class="jy jz hi mg b fi mk ml l mm mn">Number of Runs: 53<br/>Min: 3.000<br/>Q1: 9.000<br/>Median: 13.000<br/>Q3: 15.000<br/>Max: 31.000<br/>Mean: 12.962<br/>The 95.0% confidence interval of the mean score is between 11.375 and 14.549.</span></pre><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mq"><img src="../Images/0794e9419732069ec3ddcccde6d01a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*309EZSGQxAxM8N9OW2GZhQ.png"/></div></div></figure><p id="aeb7" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">虽然算法更好，但还是会犯傻乎乎的错误。例如，如果从头部到苹果的最短路径包括蛇的身体，它仍然会走那条路径，游戏将结束。参见下面的示例。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es mr"><img src="../Images/f29163e3b97e26bc82ac4ee5067430ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/1*XokyDMtFTWqExKuKqKwYlw.gif"/></div></figure><p id="2dd7" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">我们将修改我们的最短路径算法，这样蛇就永远不会选择与自己身体相撞的方向。</p><h2 id="ef9d" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.1最短路径:无自碰撞</h2><p id="d38b" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj kj ky jm jn kn kz jq jr kr la ju jv jw hb bi translated">这和上面的算法是一样的，但是蛇永远不会转弯，不会和自己的身体发生碰撞。如果蛇把自己困在一个盒子里，它将不得不与它的身体碰撞，游戏将结束。你会看到，视觉算法产生了一些有趣的动作，让蛇摆脱困境。我无法捕捉GIF中的大部分动作，所以我建议您克隆repo并在本地测试它。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ms"><img src="../Images/819472fefdf8f75521c559f8dceb1d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Nf4LFaxI96Md45jGFAlBnw.gif"/></div></div></figure><p id="2532" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">正如预测的那样，当蛇避免自我碰撞时，我们会得到更好的分数。</p><pre class="lb lc ld le fd mf mg mh mi aw mj bi"><span id="f8ee" class="jy jz hi mg b fi mk ml l mm mn">Number of Runs: 50<br/>Min: 8.000<br/>Q1: 26.250<br/>Median: 34.000<br/>Q3: 39.000<br/>Max: 57.000<br/>Mean: 33.720<br/>The 95.0% confidence interval of the mean score is between 30.813 and 36.627.</span></pre><p id="bdf5" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">这个算法有一个特点，那就是我们选择搜索方块到苹果的距离的顺序的结果。先看看下面的GIF。我们发现了一条逃跑的蛇。当蛇到达与苹果相同的一排时，它向左转并继续进入墙中，而不是找到通向苹果的路径。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es mt"><img src="../Images/4383f01717673aac0d8efd0725bba21d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/1*_LH1bO-moKME0nKSxl6wvw.gif"/></div></figure><p id="fc96" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">这里，它又一次一帧一帧地慢下来。请记住两件事。首先，蛇不会向它身体所在的方向移动。第二，当决定向哪个方向移动时，蛇按照右、左、上、下的顺序看方块。看一下第一帧。蛇只会考虑向左和向下两个方向。因为LEFT和DOWN与水果的距离相同，所以算法必须决定选择哪个方向。这个决定会在算法中引入偏差。在这个版本中，算法选择它看到的第一个方向，在这个例子中是左。</p><p id="4bd3" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">蛇选择向左移动后，类似的情况出现。这条蛇看着右边、左边、上面、下面的街区，知道它只能向左、向上或向下走。再一次，因为所有三个方向离苹果的曼哈顿距离相同，所以算法必须做出任意选择。在这个版本中，它选择它看到的第一个东西，所以蛇向左移动。这种情况一直重复，直到蛇撞到墙上</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es mu"><img src="../Images/3e903e131d582ee4cb5a863ff941f327.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/1*MQMvcAVT2u5Ks3kbUgwCfg.gif"/></div></figure><p id="61a0" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">我们可以说，当蛇只能移动到靠近苹果的一个相邻的街区，但是这个街区被蛇自己的身体占据时，就发生了逃跑蛇(RAS)现象。然后，蛇必须做出决定，在2+苹果之间移动，等距块。在这些块之间选择的不同方式导致算法的不同风格。我们将看看这些不同的口味是否能提高平均分数。</p><h2 id="612e" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.2最短路径:无自碰撞，随机RAS选择</h2><p id="0442" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj kj ky jm jn kn kz jq jr kr la ju jv jw hb bi translated">我们可以选择一个随机的区块，而不是总是从苹果等距列表中选择第一个看到的区块。这将很有可能防止蛇反复选择同一个方向，直到它跑出屏幕(如上图所示)。相反，随机运动可能会将蛇移动到一个街区，在那里到苹果的最短距离路径不会被它的身体阻挡。</p><p id="3429" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">很明显，在这种特定情况下，随机移动可能有助于提高游戏分数，但目前还不清楚随机移动是否会提高算法的平均分数。这取决于RAS情况在游戏中出现的频率。判断这一点的数学方法超出了我的能力范围，所以我们要作弊并使用统计数据。但是首先，这里是这个版本的<strong class="jd hj">最短路径的基线统计:没有自我碰撞</strong>。</p><pre class="lb lc ld le fd mf mg mh mi aw mj bi"><span id="b16d" class="jy jz hi mg b fi mk ml l mm mn">Number of Runs: 50<br/>Min: 4.000<br/>Q1: 25.000<br/>Median: 35.000<br/>Q3: 44.500<br/>Max: 67.000<br/>Mean: 35.060<br/>The 95.0% confidence interval of the mean score is between 31.078 and 39.042.</span></pre><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mv"><img src="../Images/d4a6d05ad2c34cf2ea3469b7b479d684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PtGE0q08J5HpQcX8YKDfsw.png"/></div></div></figure><p id="2023" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">从基线统计数据来看，新版本的最短路径表现稍好。我们将计算两个独立算法平均值的T检验。</p><pre class="lb lc ld le fd mf mg mh mi aw mj bi"><span id="9d68" class="jy jz hi mg b fi mk ml l mm mn">Ttest_indResult(statistic=0.5461821125601, pvalue=0.5861820444893)</span></pre><p id="70a4" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">因为p值很高，我们不能拒绝相同分数的零假设。我们不能断定这两种算法的平均分有什么不同。从统计学上来说，我们不能说我们的随机口味比选择我们看到的第一个街区更好。</p><h2 id="5de3" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.哈密尔顿循环(更像蛮力)</h2><p id="bddc" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj kj ky jm jn kn kz jq jr kr la ju jv jw hb bi translated">如果算法运行时间不是问题，我们可以建立一个机器人，保证得分完美的游戏。我们将使用一个叫做哈密顿圈的概念。在一个哈密尔顿循环中，在返回到任何一个空间之前，蛇将只访问网格中的所有空间一次。这保证了蛇在每个循环中至少吃一个苹果，并且只有当棋盘满了的时候，蛇才会跑进它的尾巴。</p><p id="bd2f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">在算法中，我们将硬编码一个已知的哈密尔顿循环。这条蛇将在屏幕上曲折前进，然后使用顶行返回到左上角的空间重复曲折前进。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es mw"><img src="../Images/ee8ff6e40b5c50fa07fcaa67fd27d7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/1*OqArHdr6Enb5U_CxzRtKfA.gif"/></div></figure><p id="563e" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">你可以看到，在开始的时候，蛇需要一段时间才能找到苹果。随着蛇的长度越来越长，可供苹果产卵的空间越来越少。正因为如此，蛇找到苹果的速度更快，蛇的生长速度也加快了。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es mw"><img src="../Images/73771915e846f45a75326b5b6da93689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/1*KpIKh1EzLvx-cOLqRsCgnw.gif"/></div></figure><p id="da60" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">这个版本不需要统计。通过重复哈密尔顿循环，蛇保证得到满分。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es mw"><img src="../Images/7996022ee6430962e455fba8457081f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/1*bQ2dMevrxAta06-BboVk6A.gif"/></div></figure><h2 id="6ff6" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h2><p id="e61e" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj kj ky jm jn kn kz jq jr kr la ju jv jw hb bi translated">总结一下，我们研究了不同的确定性方法来让机器人玩贪吃蛇游戏。随机算法没用。使用一个聪明的最短路径算法很快，当与随机算法相比，甚至与人类相比时，会给出相当好的分数。最好的算法使用哈密尔顿循环，并保证获胜(但速度慢)。</p><p id="b5f1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kj jl jm jn kn jp jq jr kr jt ju jv jw hb bi translated">其他方法包括使用非确定性算法来玩游戏。机器人不是编码决策逻辑，而是自己学习。请留意另一篇文章中的一些内容。</p></div></div>    
</body>
</html>