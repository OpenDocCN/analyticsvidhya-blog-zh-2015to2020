<html>
<head>
<title>The Intuition and working behind AdaBoost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AdaBoost背后的直觉和工作</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/intuition-and-working-behind-adaboost-1c559f8d7a73?source=collection_archive---------13-----------------------#2019-09-04">https://medium.com/analytics-vidhya/intuition-and-working-behind-adaboost-1c559f8d7a73?source=collection_archive---------13-----------------------#2019-09-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c11d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有多种机器学习算法对数据进行分类。在之前的博客文章中，我们已经看到了<a class="ae jd" rel="noopener" href="/analytics-vidhya/math-behind-support-vector-machines-642421e45b08">支持向量机</a>和<a class="ae jd" rel="noopener" href="/analytics-vidhya/logistic-regression-b35d2801a29c">逻辑回归</a>的工作原理，现在是时候探索另一种称为AdaBoost或自适应Boosting的算法了。这是决策树算法的一个变种。</p><p id="31ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AdaBoost是一个更大的算法集的一部分，属于称为集成学习的方法。集成学习背后的整个思想是创建多个学习模型而不是一个模型，并预测值。</p><p id="03da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AdaBoost通过创建多个弱学习器，根据每个学习器中该点的预测将权重与每个数据点相关联，并最终给出输出，来预测值。</p><p id="0250" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">弱学习者与助推:</strong></p><p id="2e44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们基本上是在数据特征子集上运行的多个模型(在本例中是决策树)。这些弱学习者有一个特别有趣的特性，我们将在创建boosting算法时利用它，该算法是欠拟合或低方差的。</p><p id="97d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地理解，请看下图</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/95de73b72c48a5036cd34743a47a5075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*131sBdM2wNqbj5IBp_bFCw.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">多重决策难题</figcaption></figure><p id="33e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设我们必须使用机器学习算法来预测某人是否会买房。我们不是创建一个决策树或逻辑回归模型来预测，而是创建多个弱学习器，即决策树桩或深度为1或2的弱逻辑回归模型或树，一个接一个地预测输出。在AdaBoost中，我们以这样一种方式装配系统，即在先前的学习器中预测不佳的特征在随后的模型中预测到较好的结果。</p><p id="6027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们给上面的决策树桩一个输入的例子。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ju"><img src="../Images/de889c2cd9f957c53a0a04cfe53ef211.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/1*-jD-SGLBbGSAb17ne_TgaQ.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">对树桩的投入</figcaption></figure><p id="0cf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述输入中的<em class="jv">数字室</em>为“<em class="jv"> 2 </em>”，这将转到主伐桩和产量预测“<em class="jv"> +1 </em>”。<em class="jv"> sqft </em>将转到第二个树桩，并将产生预测“<em class="jv"> +1 </em>”，<em class="jv">草坪</em>将得到预测“<em class="jv"> -1 </em>”，类似地<em class="jv">区域</em>将得到预测“<em class="jv"> +1 </em>”。因此，我们需要问的最后一个问题是，我们如何结合来自各种弱学习者的所有这些预测，并对上述数据点给出一个最终预测？。这是通过下面的公式完成的</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jw"><img src="../Images/ac516c789628ac9f1ee0afe05af94dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/1*24N7Pv8Goe7VVFx24Fy39w.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">第一个数据点的加权投票方案</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jx"><img src="../Images/81ad91c2048ad12d8f13e0a5ee5e60fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/1*KzTQRnOLvrAGvHiQJF2EFA.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">每个方案的预测，即+1或-1</figcaption></figure><p id="47d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们基本上是在乘以与每个树桩相关联的权重，再乘以预测值，并与来自每个树桩的其余值相加之后，得到最终符号。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jy"><img src="../Images/2c670ea4954ccdaa35a44b789a94c95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/1*e2oCyMEht7dVhGntT_Z_Ew.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">最终预测方程。l树桩数。</figcaption></figure><p id="8a71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> AdaBoost: </strong></p><p id="b71a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AdaBoost的工作方式如下:</p><p id="08ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.)首先，每个数据点用等于(1/数据点的数量)的权重'<em class="jv">α</em>初始化。</p><p id="4244" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.)然后，对于每个弱学习器或模型，我们迭代计算预测值，然后继续计算权重'<em class="jv"> w </em>'(加权误差)，并基于此重新调整下一次迭代的'<em class="jv">α</em>'项，直到最后。</p><p id="4b81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.)在所有迭代完成之后，我们基于上面的等式计算预测。</p><p id="9189" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们需要问两个关于AdaBoost的基本问题，我们将如何更新权重'<em class="jv"> w </em>'以及我们将如何更新'<em class="jv"> alpha </em>'值。？</p><p id="dd4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在该算法中，我们所做的是将所有被错误分类的数据点的权重相加，然后除以所有数据点的权重，即</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jz"><img src="../Images/64b1d587770d3861676648d741f44c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:202/1*I-eJUBiTTOf0BcPHoiNOQA.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">对错误分类点的权重求和</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ka"><img src="../Images/de409be7251882f6446acb6041a1bd74.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*rWhYyl-6meBTC5Lv1A202Q.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">加权误差公式</figcaption></figure><p id="41f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建加权误差后，我们确保更新与每个树桩相关联的权重，其公式为</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kb"><img src="../Images/320f5d4c4d90e5a2d9f6b9111dff98b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/1*xies2dpxdSsAV6SMzQk2aA.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">更新每个树桩的重量</figcaption></figure><p id="3a82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的等式非常有趣:</p><p id="fd96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于加权误差= 0.5的值，它将产生“0”，因为输出为(1/2) * log(1)等于0，而以正确方式对点进行分类的良好决策树桩将具有非常低的加权误差，这意味着((1-加权_误差)/加权_误差)的高值，取该值的一半log将产生具有高值的正权重。对于分类不好的树桩，权重会很低。</p><p id="0749" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面关于更新'<em class="jv"> alpha </em>'的部分中，我们将看到为什么具有良好分类的决策树桩具有高权重，而与不良分类相关联的树桩具有低权重值。</p><p id="fbb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在权重被更新之后，我们以这样的方式更新α，即被错误分类的点比被正确分类的点被给予更大的重要性，从而确保我们的机器学习模型更多地迎合错误分类的点。这是借助于指数函数完成的。当预测正确时，使用下面的公式更新与每个数据点相关联的alphas</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kc"><img src="../Images/620d2768f20f8d273624108df75319e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/1*CyNKQF-vKvEZX_5QegBVbg.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">i -&gt;针对每个数据点，j-&gt;针对每个树桩</figcaption></figure><p id="4db2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当预测不正确时，我们使用以下公式更新与每个数据点相关的alpha值</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kd"><img src="../Images/4b8c9a6f05d1635f7fb8900e0a9542f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:226/1*E8MXki8nLzJTH220qCIKfA.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">i -&gt;针对每个数据点，j-&gt;针对每个树桩</figcaption></figure><p id="4c8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里使用带正负符号的指数函数是至关重要的，因为每当一个点被正确分类时，我们就在指数的顶部使用一个负值以及与树桩相关联的权重。对于'<em class="jv"> w </em>'的高值意味着被正确分类的点在下一个树桩中的重要性较低。如果一个树桩在某组数据点上分类失误，那么与这些点相关联的alpha值将在下一个树桩中具有更高的值，这是通过赋予它们更大的重要性来实现的。</p><p id="407b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，一旦我们有了基于我们的训练数据的所有树桩以及相关联的权重(不是加权误差而是与每个树桩相关联的权重)，我们就可以计算必须分类的数据的预测，</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jy"><img src="../Images/2c670ea4954ccdaa35a44b789a94c95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/1*e2oCyMEht7dVhGntT_Z_Ew.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">最终预测方程。l树桩数。</figcaption></figure><p id="0c9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">github要点如下。</p><p id="e99c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>要点仅针对adaboost，而非创建决策树桩</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="b61c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请随意在评论中指出任何错误。</p></div></div>    
</body>
</html>