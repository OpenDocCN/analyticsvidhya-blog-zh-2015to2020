<html>
<head>
<title>What do the Top Trending Tweets tell us about Trump, Obama and Biden?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于特朗普、奥巴马和拜登，热门推文告诉了我们什么？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/what-do-the-top-trending-tweets-tell-us-about-trump-obama-and-biden-1c10b33d7273?source=collection_archive---------19-----------------------#2020-09-22">https://medium.com/analytics-vidhya/what-do-the-top-trending-tweets-tell-us-about-trump-obama-and-biden-1c10b33d7273?source=collection_archive---------19-----------------------#2020-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="31e0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从 2008 年初开始，用 Python 收集了 56，000 多条推文</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/7ff769a57cad97ade3b9420259f96814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*2F0Ttg7k5BywthqX2bebOA.jpeg"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">WordCloud 显示了自 2017 年以来特朗普、奥巴马和拜登最常使用的 250 条转发量最高的推文</figcaption></figure><h1 id="22de" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">介绍</h1><p id="f9ab" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">随着 2020 年美国总统大选的临近，唐纳德·特朗普在推特上发布的大量消息让他迷惑不解，例如，下面这条推文恰好是他自 2008 年以来第七次被转发的推文…</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kx"><img src="../Images/78930d63a04fad8dd5e5b806dbefc46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*geCGdvyFnV7J2-KAlaBARw.png"/></div></figure><p id="99a2" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">我开始变得好奇，想找到一种方法来并排比较乔·拜登、巴拉克·奥巴马和唐纳德·特朗普是如何利用 Twitter 作为交流手段的。</p><p id="e111" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">带着一点 Python 代码和挠头。瞧啊。</p><p id="49b1" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">我能够从追溯到 2008 年初的推文数据中收集到一些有趣的观察结果。让我们先来看看一些最上面的数字。</p><h1 id="67dc" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">这些年来，特朗普、奥巴马和拜登发推特的频率如何？</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ld"><img src="../Images/5314e8e994ae8d7f059edcf90875aeee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MEOpYC8GGdaD37_rfGhjw.png"/></div></div></figure><ul class=""><li id="9779" class="li lj hi kd b ke ky kh kz kk lk ko ll ks lm kw ln lo lp lq bi translated">我们可以看到，奥巴马在第二个总统任期(2013 年至 2016 年)期间是一个相当活跃的推特用户，特别是在最初几年(2013 年至 2014 年)。尽管卸任后，他已经变成了一个相当被动的推特用户。</li><li id="fb05" class="li lj hi kd b ke lr kh ls kk lt ko lu ks lv kw ln lo lp lq bi translated">另一方面，特朗普一直是一个非常活跃的推特用户，从 2013 年起，推文的频率急剧上升。在赢得美国总统大选后，他在接受哥伦比亚广播公司(CBS)电视采访时表示，他对社交媒体的使用将是“<em class="lx">非常克制的，如果我真的使用的话。</em>“似乎不是这样。我想知道他最常发的是什么…#中国，#让美国再次伟大#杂志等等。</li><li id="c177" class="li lj hi kd b ke lr kh ls kk lt ko lu ks lv kw ln lo lp lq bi translated">乔·拜登从 2012 年起才开始发推特。虽然我们可以看到他在 2012 年期间非常活跃，但他在 2013 年至 2018 年期间很少发推特，在这期间他大部分时间都在担任副总统。尽管他的使用频率从 2019 年开始肯定有所增加，因为我们将迎来 2020 年的总统选举。我们将进一步了解他最受欢迎的推文是什么样的。</li></ul><p id="2c90" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">看着这张图表，我想到了许多问题，其中之一是这些推文后面有多少转发和参与？让我们来看看…</p><h1 id="f037" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated"><strong class="ak">特朗普、奥巴马和拜登这些年的平均每条推文转发数是多少？</strong></h1><p id="cf00" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">快看，奥巴马遥遥领先！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ld"><img src="../Images/d92d7a0d5ba73e375d782587dee4f208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOI8lJitSz99i4mQdLEDsw.png"/></div></div></figure><ul class=""><li id="23a1" class="li lj hi kd b ke ky kh kz kk lk ko ll ks lm kw ln lo lp lq bi translated">有趣的是，尽管自奥巴马第二个总统任期结束以来，他已经成为一个更加被动的推特用户，但从 2017 年起，他每条推特的平均转发数真的爆炸了。</li><li id="caff" class="li lj hi kd b ke lr kh ls kk lt ko lu ks lv kw ln lo lp lq bi translated">值得注意的是，这些年来，每条微博的粉丝数量都在增长，这在很大程度上解释了为什么我们近年来看到了更多的转发量。尤其是特朗普，自从他当选总统以来，他的粉丝数量激增，在 1800 万的基础上又增加了 7000 万粉丝。这些年来的追随者增长统计见下图(<em class="lx">来自 trackalytics.com</em>)。</li></ul><div class="iy iz ja jb fd ab cb"><figure class="ly jc lz ma mb mc md paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><img src="../Images/d08cf036b1c4418652963afa8cdd32ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*I2NmEaEtgJOnCCsLVwN8rQ.png"/></div></figure><figure class="ly jc lz ma mb mc md paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><img src="../Images/0cceca8664b6dd82bd6ad349026ac11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*UR6jEFcAHV7zFRs8MBYwNQ.png"/></div></figure><figure class="ly jc lz ma mb mc md paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><img src="../Images/6a1c1d3da5208441ee395319f84e0a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*r1vzIDAHfIIXgRdzUwqfTA.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx me di mf mg translated">截至 2020 年 9 月 21 日:特朗普粉丝 8610 万，奥巴马粉丝 1.227 亿，拜登粉丝 950 万</figcaption></figure></div><p id="deaa" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">让我们来看看奥巴马、特朗普和拜登的转发量最大的推文中是否有任何共同趋势。</p><p id="9a1f" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">基于上述观察数据，我专注于用 Python 制作一个定制的 WordCloud，以分析 2017 年以来奥巴马、特朗普和拜登的前 250 条被转发最多的推文的情绪。</p><h1 id="dd7e" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated"><strong class="ak">对于川普、奥巴马和拜登来说，自定义词云向我们展示了什么？</strong></h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es mh"><img src="../Images/30206004bda887c88033bea64b41fab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmsBHwEKA-NPXuBkCdz63g.jpeg"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">WordCloud 显示了自 2017 年以来特朗普、奥巴马和拜登最常使用的 250 条转发量最高的推文</figcaption></figure><p id="a296" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">看到特朗普大多数转发的推文带有相当民族主义的语气，比如:</p><blockquote class="mi mj mk"><p id="205c" class="kb kc lx kd b ke ky ij kg kh kz im kj ml la km kn mm lb kq kr mn lc ku kv kw hb bi translated">制造'，'美国'，'伟大'，'伊朗'，'法律'，'秩序'，'敌人'和'中国'</p></blockquote><p id="885a" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">频繁出现。</p><p id="65b3" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">有趣的是，拜登转发最多的推文是那些他在 2020 年总统选举前经常攻击唐纳德·特朗普的推文。这次选举无疑被证明是现代最两极分化的选举之一。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="9d45" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">请继续阅读，看看我是如何通过 Python 制作上述可视化和外推推文级数据的，这些数据可以追溯到 2008 年…</p><h1 id="7388" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">这是怎么做到的？</h1><h2 id="8412" class="mv jk hi bd jl mw mx my jp mz na nb jt kk nc nd jv ko ne nf jx ks ng nh jz ni bi translated">步骤 1:导入必要的包</h2><pre class="iy iz ja jb fd nj nk nl nm aw nn bi"><span id="a776" class="mv jk hi nk b fi no np l nq nr">import GetOldTweets3 as got;<br/>import pandas as pd<br/>import glob<br/>import datetime as dt<br/>import csv<br/>import GetOldTweets3 as got;<br/>import glob<br/>import seaborn as sb<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>from wordcloud import WordCloud, STOPWORDS, ImageColorGenerator<br/>from PIL import Image<br/>import matplotlib.gridspec as gridspec<br/>import re</span></pre><h2 id="f9d4" class="mv jk hi bd jl mw mx my jp mz na nb jt kk nc nd jv ko ne nf jx ks ng nh jz ni bi translated">步骤 2:提取 Tweet 级别的数据</h2><p id="a54e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">鉴于只能通过免费的基本 Twitter API 访问收集 3200 条推文的限制，使用“<a class="ae lw" href="https://pypi.org/project/GetOldTweets3/" rel="noopener ugc nofollow" target="_blank"> GetOldTweets3 </a>”库是收集无限量推文级数据的有用工具。这种方法通过 web 抓取 Twitter 用户提要来工作，而传统方法需要通过后门 API 连接来访问数据。长话短说，只要数据在网页上可见，即(时间戳，文本，提及，标签等)…我们就可以收集数据。</p><p id="5b52" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">下面构建的函数将使我们能够在指定的开始和结束日期内抓取任何用户的 Twitter feed(<a class="ae lw" rel="noopener" href="/@AIY/getoldtweets3-830ebb8b2dab">代码灵感来自媒体博客作者</a>)。</p><pre class="iy iz ja jb fd nj nk nl nm aw nn bi"><span id="a16e" class="mv jk hi nk b fi no np l nq nr"><strong class="nk hj">def get_tweets</strong>(username, start_date, end_date):<br/>   <br/><strong class="nk hj">    # specifying tweet search criteria </strong><br/>    tweetCriteria = got.manager.TweetCriteria()\<br/>                       setUsername(username)\<br/>                          .setSince(start_date)\<br/>                          .setUntil(end_date)<br/>    <br/><strong class="nk hj">    # scraping tweets based on criteria<br/></strong>    tweet = got.manager.TweetManager.getTweets(tweetCriteria)<br/>    <br/><strong class="nk hj">    # creating list of tweets with the tweet attributes <br/>    # specified in the list comprehension</strong><br/>    text_tweets = [[tw.username,<br/>                tw.id,<br/>                tw.text,<br/>                tw.date,<br/>                tw.retweets,<br/>                tw.favorites,<br/>                tw.mentions,<br/>                tw.hashtags] for tw in tweet]<br/>    <br/><strong class="nk hj">    # creating DataFrame, assigning column names to list of<br/>    # tweets corresponding to tweet attributes</strong><br/>    tweet_df = pd.DataFrame(text_tweets, <br/>                            columns = [‘User’, ‘tweet_id’, ‘Text’,<br/>                                       ‘Date’, ‘Favorites’,<br/>                                       ‘Retweets’, ‘Mentions’,<br/>                                       ‘HashTags’])<br/>    <br/>    return tweet_df</span></pre><p id="bab4" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">因为我们希望收集 2008 年以来的推文数据，以及收集的推文数量(约 56K 推文！).为了确保函数不会中途崩溃，我在下面创建了一个循环脚本，将 tweet 级别的数据存储在一系列按年份划分的 CSV 文件中。使用方便的'<a class="ae lw" href="https://docs.python.org/3/library/glob.html" rel="noopener ugc nofollow" target="_blank"> glob </a>'方法，我们可以将 CSV 文件连接成一个单独的<a class="ae lw" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a>数据帧。</p><pre class="iy iz ja jb fd nj nk nl nm aw nn bi"><span id="b9f4" class="mv jk hi nk b fi no np l nq nr"><strong class="nk hj"># Define the list of Twitter users we want to scrape tweet level data from</strong><br/>user_names = ['JoeBiden', "realDonaldTrump", "BarackObama"]</span><span id="352b" class="mv jk hi nk b fi ns np l nq nr"><strong class="nk hj">#List of year ranges we want to extrapolate tweets from:<br/></strong>year_range = [["2020-01-01", "2020-09-15"],<br/>              ["2019-01-01", "2020-01-01"],<br/>              ["2018-01-01", "2019-01-01"],<br/>              ["2017-01-01", "2018-01-01"],<br/>              ["2016-01-01", "2017-01-01"],<br/>              ["2015-01-01", "2016-01-01"],<br/>              ["2014-01-01", "2015-01-01"],<br/>              ["2013-01-01", "2014-01-01"],<br/>              ["2012-01-01", "2013-01-01"],<br/>              ["2011-01-01", "2012-01-01"],<br/>              ["2010-01-01", "2011-01-01"],<br/>              ["2009-01-01", "2010-01-01"],<br/>              ["2008-01-01", "2009-01-01"]]</span><span id="4c04" class="mv jk hi nk b fi ns np l nq nr"><strong class="nk hj">#Start scraping Twitter user feeds and save the data into a series of CSV files broken out by year </strong><br/>for year in year_range:<br/>    tweet_df = get_tweets(user_names, <br/>                     start_date = year[0], <br/>                     end_date = year[1])<br/>    <br/>    year_name = year[0][:4]<br/>    file_name = '{user_names}_{year_name}.csv'\<br/>                .format(year_name = year_name,<br/>                        user_names = user_names)<br/>    <br/>    tweet_df.to_csv(file_name, index = False)<br/>    <br/><strong class="nk hj">#Import the yearly CSV files and store in a list which we can use with the handy Glob method</strong><br/>files = glob.glob('*.csv')</span><span id="7432" class="mv jk hi nk b fi ns np l nq nr"><strong class="nk hj">#Convert the CSV files into DataFrames and store these in a list</strong><br/>list_df = []</span><span id="8385" class="mv jk hi nk b fi ns np l nq nr">for file in files:<br/>    df = pd.read_csv(file)<br/>    list_df.append(df)<br/>    <br/><strong class="nk hj">#Concatenate the list of DataFrames into a single big DataFrame</strong><br/>user_names_df = pd.concat(list_df)</span></pre><p id="880d" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">瞧啊。上面的代码可以用来抓取指定日期范围内任何 Twitter 用户的提要。经过一点数据清理后，我们现在可以进入有趣的解释性分析了。</p><h2 id="1d7b" class="mv jk hi bd jl mw mx my jp mz na nb jt kk nc nd jv ko ne nf jx ks ng nh jz ni bi translated">步骤 3:解释性分析——带有 Seaborn 的可视化图表</h2><p id="0873" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">您可以选择使用 Seaborn 或 Matplotlib 来生成可视化图形。我更喜欢使用 Seaborn，因为与 Matplotlib 相比，它需要更少的语法。</p><pre class="iy iz ja jb fd nj nk nl nm aw nn bi"><span id="7df1" class="mv jk hi nk b fi no np l nq nr"><strong class="nk hj">#Code to produce Frequency of Tweets graph by Year</strong></span><span id="a4a6" class="mv jk hi nk b fi ns np l nq nr">plt.figure(figsize = (15, 10))</span><span id="b7e9" class="mv jk hi nk b fi ns np l nq nr">sb.set_context('notebook', font_scale = 1.75)</span><span id="9fbc" class="mv jk hi nk b fi ns np l nq nr">palette ={"JoeBiden": "C0", "BarackObama": "C1",<br/>          "realDonaldTrump": "C2"}</span><span id="40fc" class="mv jk hi nk b fi ns np l nq nr">sb.countplot(data = user_names_df, x = 'Year', hue = 'User',<br/>             palette = palette, hue_order = ["JoeBiden",<br/>                                             "BarackObama",<br/>                                             "realDonaldTrump"])<br/>plt.ylabel('Frequency of Tweets')</span><span id="c98f" class="mv jk hi nk b fi ns np l nq nr">plt.title('Frequency of Tweets by year')</span><span id="c845" class="mv jk hi nk b fi ns np l nq nr">plt.yticks(np.arange(0, 8001, 1000),<br/>           [0,'1k','2k','3k','4k','5k','6k','7k','8k'])</span><span id="c679" class="mv jk hi nk b fi ns np l nq nr">plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ld"><img src="../Images/5e185fb94f5d3f6066c031ba5a26b0f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osBHPa1kdDrcKQDf3YVAyg.png"/></div></div></figure><pre class="iy iz ja jb fd nj nk nl nm aw nn bi"><span id="8111" class="mv jk hi nk b fi no np l nq nr"><strong class="nk hj">#Code to produce Average Number of Retweets per Tweet graph by Year</strong></span><span id="7994" class="mv jk hi nk b fi ns np l nq nr"><strong class="nk hj">#We'll need to do some cleaning first.</strong></span><span id="2565" class="mv jk hi nk b fi ns np l nq nr"><strong class="nk hj">#Groupby to obtain sum of retweets by year<br/></strong>tweet_retweet = user_names_df.groupby(['User', 'Year'])\<br/>                             .Retweets.sum().reset_index()</span><span id="90c3" class="mv jk hi nk b fi ns np l nq nr"><strong class="nk hj">#Groupby to obtain the frequency of tweets by year<br/></strong>tweet_frequency = user_names_df[['User', 'Year', 'Tweet_id']]\<br/>                                .groupby(['User', 'Year'])\<br/>                                .Tweet_id.count().reset_index()</span><span id="4a7f" class="mv jk hi nk b fi ns np l nq nr">tweet_frequency.rename(columns = {'Tweet_id': 'Tweet_frequency'},<br/>                       inplace = True)</span><span id="9a39" class="mv jk hi nk b fi ns np l nq nr"><strong class="nk hj">#Merge the above two DataFrames so we get retweets and frequency of tweets by year in the same table</strong><br/>tweet_frequency_retweet = pd.merge(tweet_retweet, tweet_frequency)</span><span id="55bf" class="mv jk hi nk b fi ns np l nq nr"><strong class="nk hj">#Create additional column which calculates the average retweet per tweet ratio<br/></strong>tweet_frequency_retweet['Retweet_per_Tweet_ratio'] = tweet_frequency_retweet.Retweets / tweet_frequency_retweet.Tweet_frequency</span><span id="6284" class="mv jk hi nk b fi ns np l nq nr"><strong class="nk hj">#Plot Graph<br/></strong>plt.figure(figsize = (15, 10))</span><span id="ab3b" class="mv jk hi nk b fi ns np l nq nr">sb.set_context('notebook', font_scale = 1.75)</span><span id="d9b7" class="mv jk hi nk b fi ns np l nq nr">sb.barplot(data = tweet_frequency_retweet, x = 'Year',<br/>           y = 'Retweet_per_Tweet_ratio', hue = 'User',<br/>           palette = palette,<br/>           hue_order = ["JoeBiden",<br/>                        "BarackObama",<br/>                        "realDonaldTrump"])</span><span id="c3c4" class="mv jk hi nk b fi ns np l nq nr">plt.ylabel('Average Number of Retweets per Tweet (million)')</span><span id="8839" class="mv jk hi nk b fi ns np l nq nr">label_range_2 = np.arange(0, 8, 1)</span><span id="33ed" class="mv jk hi nk b fi ns np l nq nr">plt.yticks(label_range_2 * 100000, label_range_2 / 10)</span><span id="090e" class="mv jk hi nk b fi ns np l nq nr">plt.title('Average Number of Retweets per Tweet by Year')</span><span id="8be1" class="mv jk hi nk b fi ns np l nq nr">plt.legend(loc='center')</span><span id="daf3" class="mv jk hi nk b fi ns np l nq nr">plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ld"><img src="../Images/d92d7a0d5ba73e375d782587dee4f208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOI8lJitSz99i4mQdLEDsw.png"/></div></div></figure><p id="938b" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">我们现在有了用 Seaborn 绘制的图表。下一步…</p><h2 id="2886" class="mv jk hi bd jl mw mx my jp mz na nb jt kk nc nd jv ko ne nf jx ks ng nh jz ni bi translated">步骤 4:构建自定义单词云</h2><p id="2f9b" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在这里，我们开始使用<a class="ae lw" href="https://github.com/amueller/word_cloud" rel="noopener ugc nofollow" target="_blank">的单词云库</a>来生成我们自己的定制单词云。</p><ol class=""><li id="0930" class="li lj hi kd b ke ky kh kz kk lk ko ll ks lm kw nt lo lp lq bi translated">以便将单词云可视化成定制的形状。在我们的情况下，这是特朗普，奥巴马和拜登的形状。我们需要一个黑白背景图片作为遮罩(下面的图片就足够了)。</li></ol><div class="iy iz ja jb fd ab cb"><figure class="ly jc nu ma mb mc md paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><img src="../Images/d3db6ce1610a2e4479d6d98a089e4523.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*ALByHE3fv8xNfD1eTx12XQ.png"/></div></figure><figure class="ly jc nv ma mb mc md paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><img src="../Images/636310d59bd49b6edb8e2b1aea9cc7f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*cwGTVjud-iITOEkWChD7ew.png"/></div></figure><figure class="ly jc nw ma mb mc md paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><img src="../Images/66ed21888d40fc674577f7b317001786.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*a_djU8t4VPoXC7h7iohiyw.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx nx di ny mg translated">唐纳德·特朗普、巴拉克·奥巴马和乔·拜登:黑白模板</figcaption></figure></div><p id="422d" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">2.我们需要将数据集分解成特朗普、奥巴马和拜登各自的数据框架。每个数据帧从转发最多到转发最少排序。</p><pre class="iy iz ja jb fd nj nk nl nm aw nn bi"><span id="1798" class="mv jk hi nk b fi no np l nq nr"><strong class="nk hj">#Create individual DataFrames for Obama, Trump and Biden<br/></strong>obama_df = user_names_df[user_names_df_clean.User == \<br/>                         'BarackObama']<br/>trump_df = user_names_df[user_names_df_clean.User == \<br/>                         'realDonaldTrump']<br/>biden_df = user_names_df[user_names_df_clean.User == \<br/>                         'JoeBiden']</span><span id="cabc" class="mv jk hi nk b fi ns np l nq nr"><strong class="nk hj">#Sort DataFrames in order of most retweeted and drop tweets without text</strong><br/>obama_retweet_df = obama_df.sort_values(by = ['Retweets'],<br/>                                        ascending = \<br/>                                        False).dropna(subset = \<br/>                                                      ['Text'])<br/>trump_retweet_df = trump_df.sort_values(by = ['Retweets'],<br/>                                        ascending = \<br/>                                        False).dropna(subset = \<br/>                                                      ['Text'])<br/>biden_retweet_df = biden_df.sort_values(by = ['Retweets'],<br/>                                        ascending = \<br/>                                        False).dropna(subset = \<br/>                                                      ['Text'])</span><span id="ce9a" class="mv jk hi nk b fi ns np l nq nr"><strong class="nk hj">#Setting a global variable for the range of years in our dataset<br/></strong>year_range = np.arange(2008, 2021, 1)</span></pre><p id="2482" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">现在我们可以继续构建下面的函数…</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><pre class="iy iz ja jb fd nj nk nl nm aw nn bi"><span id="da50" class="mv jk hi nk b fi no np l nq nr"><strong class="nk hj">def wordcloud_retweet</strong>(top_number, trump_year = year_range, obama_year = year_range, biden_year = year_range):<br/>    <br/><strong class="nk hj">    #Loop through the individual DataFrames and store the Tweets into a list</strong><br/>    obama_ls = [re.sub(r"http\S+", "", tweet).strip() for tweet\<br/>                in obama_retweet_df[obama_retweet_df.Year<br/>                                    .isin(obama_year)].dropna\<br/>                (subset = ['Text']).Text.head(top_number)]<br/>    trump_ls = [re.sub(r"http\S+", "", tweet).strip() for tweet\<br/>                in trump_retweet_df[trump_retweet_df.Year\<br/>                                    .isin(trump_year)].dropna\<br/>                (subset = ['Text']).Text.head(top_number)]<br/>    biden_ls = [re.sub(r"http\S+", "", tweet).strip() for tweet\<br/>                in biden_retweet_df[biden_retweet_df.Year\<br/>                                    .isin(biden_year)].dropna\<br/>                (subset = ['Text']).Text.head(top_number)]<br/>    <br/>    <strong class="nk hj">#Create empty lists to house the individual words from the individual Tweets gathered</strong><br/>    obama_series = []<br/>    trump_series = []<br/>    biden_series = []<br/>    <br/>    <strong class="nk hj">#loop through obama_ls, trump_ls and biden_ls and populate empty list with words. We'll want to strip out the punctuation for the last ending word in each Tweet, given how Trump often finishes off Tweets with excessive punctuation i.e. (?!?!!!)</strong><br/>    for tweet in obama_ls:<br/>        splits = tweet.split()<br/>        for word in splits:<br/>            obama_series.append(word.strip("-").strip("\"")\<br/>                                .strip(".").strip(":").strip(",")\<br/>                                .strip("?").strip("!").strip("?")\<br/>                                .strip("-").strip("\"").strip("!"))<br/>    for tweet in trump_ls:<br/>        splits = tweet.split()<br/>        for word in splits:<br/>            trump_series.append(word.strip("-").strip("\"")\<br/>                                .strip(".").strip(":").strip(",")\<br/>                                .strip("?").strip("!").strip("?")\<br/>                                .strip("-").strip("\"").strip("!"))<br/>    for tweet in biden_ls:<br/>        splits = tweet.split()<br/>        for word in splits:<br/>            biden_series.append(word.strip("-").strip("\"")\<br/>                                .strip(".").strip(":").strip(",")\<br/>                                .strip("?").strip("!").strip("?")\<br/>                                .strip("-").strip("\"").strip("!"))<br/>    <br/><strong class="nk hj">    #Combine all the Tweets into one big text</strong><br/>    obama_text = " ".join(word for word in obama_series)<br/>    trump_text = " ".join(word for word in trump_series)<br/>    biden_text = " ".join(word for word in biden_series)<br/>    <br/>    <strong class="nk hj">#Generate masks for Obama, Trump and Biden</strong><br/>    mask_obama = np.array(Image.open('obama_1.png'))<br/>    mask_trump = np.array(Image.open('trump_3.png'))<br/>    mask_biden = np.array(Image.open('biden_edit.png'))<br/>    <br/><strong class="nk hj">    #Create a stopword list, i.e. a list of words to ignore when generating a Custom WordCloud</strong><br/>    stopwords = set(STOPWORDS)<br/>    stopwords.update(['will', 'of', 'a', 'well', 'way', 've',<br/>                      'don', 'let', 'thing', 'day', 'thing',<br/>                      'keep', 'two', 'see', 're', 'today',<br/>                      'week', 'far', 'now', 'act'])<br/>    <br/>    #Setup parameters for WordCloud image<br/>    wordcloud_obama = WordCloud(background_color="white",<br/>                                stopwords = stopwords,<br/>                                max_words = 50, mask=mask_obama,<br/>                                contour_width=3,<br/>                                contour_color='steelblue',<br/>                                collocations=False)\<br/>                                .generate(obama_text)<br/>    wordcloud_trump = WordCloud(background_color="white",<br/>                                stopwords = stopwords,<br/>                                max_words = 50, mask=mask_trump,<br/>                                contour_width=3,<br/>                                contour_color='steelblue',<br/>                                collocations=False)\<br/>                                .generate(trump_text)<br/>    wordcloud_biden = WordCloud(background_color="white",<br/>                                stopwords = stopwords,<br/>                                max_words = 50, mask=mask_biden,<br/>                                contour_width=3,<br/>                                contour_color='steelblue',<br/>                                collocations=False)\<br/>                                .generate(biden_text)<br/>    <br/><strong class="nk hj">    #Display the Custom WordCloud image:</strong><br/>    plt.figure(figsize = (32, 16))<br/>    <br/>    plt.subplot(1, 3, 1)<br/>    plt.imshow(wordcloud_trump, interpolation = 'bilinear')<br/>    plt.axis('off')<br/>    <br/>    plt.subplot(1, 3, 2)<br/>    plt.imshow(wordcloud_obama, interpolation = 'bilinear')<br/>    plt.axis('off')<br/>    <br/>    plt.subplot(1, 3, 3)<br/>    plt.imshow(wordcloud_biden, interpolation = 'bilinear')<br/>    plt.axis('off')<br/>    plt.show()</span></pre><p id="f28e" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">最后，我们现在有了一个功能，它将使我们能够从给定年份范围内的热门转发推文中生成一个定制的 WordCloud。在我们的例子中，我们希望从 2017 年开始，从每个人转发最多的前 250 条推文的后面生成一个词云。我们可以通过在下面的内置函数中输入以下参数来做到这一点:</p><pre class="iy iz ja jb fd nj nk nl nm aw nn bi"><span id="a468" class="mv jk hi nk b fi no np l nq nr">wordcloud_retweet(250, np.arange(2017, 2021, 1), np.arange(2017, 2021, 1), np.arange(2017, 2021, 1))</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es mh"><img src="../Images/30206004bda887c88033bea64b41fab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmsBHwEKA-NPXuBkCdz63g.jpeg"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">WordCloud 显示了自 2017 年以来特朗普、奥巴马和拜登最常使用的 250 条转发量最高的推文</figcaption></figure><p id="cb13" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">现在你知道了！我们自己定制的 WordCloud 可以处理任何 tweet 级别的数据集。这些数据可以通过以下 DataStudio 链接获得，如果你想看的话:<a class="ae lw" href="https://datastudio.google.com/reporting/f45b50d8-ff49-49ae-9a96-2b147c387956/page/1xZU" rel="noopener ugc nofollow" target="_blank">链接此处</a></p><p id="ec34" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">你也可以看看我下面的 GitHub repo:</p><div class="nz oa ez fb ob oc"><a href="https://github.com/hiten-naran/Twitter-Python-Tweet-Analysis-Trump-Biden-Obama-2008-2020" rel="noopener  ugc nofollow" target="_blank"><div class="od ab dw"><div class="oe ab of cl cj og"><h2 class="bd hj fi z dy oh ea eb oi ed ef hh bi translated">hiten-naran/Twitter-Python-Tweet-Analysis-特朗普-拜登-奥巴马-2008-2020</h2><div class="oj l"><h3 class="bd b fi z dy oh ea eb oi ed ef dx translated">这个项目的目的是通过分析从 2008 年到 2020 年收集的 tweet 级别数据来可视化观察结果…</h3></div><div class="ok l"><p class="bd b fp z dy oh ea eb oi ed ef dx translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq jd oc"/></div></div></a></div><p id="f112" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi">-</p><h2 id="943d" class="mv jk hi bd jl mw mx my jp mz na nb jt kk nc nd jv ko ne nf jx ks ng nh jz ni bi translated">参考资料:</h2><p id="fe08" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">https://medium.com/@AIY/getoldtweets3-830ebb8b2dab</p><p id="daa5" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">https://pypi.org/project/GetOldTweets3/</p><p id="b40e" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">https://github.com/amueller/word_cloud</p><p id="42ab" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">https://www.trackalytics.com/</p></div></div>    
</body>
</html>