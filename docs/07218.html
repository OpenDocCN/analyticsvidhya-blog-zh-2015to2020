<html>
<head>
<title>The power of ReGex | Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReGex | Python的威力</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-power-of-regex-python-19e74b24bbbe?source=collection_archive---------12-----------------------#2020-06-17">https://medium.com/analytics-vidhya/the-power-of-regex-python-19e74b24bbbe?source=collection_archive---------12-----------------------#2020-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/914b6aeba100ea6ffcb8cf812fa72ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0Vzi9IDwZ7Acp9YLQBCag.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">ReGex的威力举世闻名</strong></figcaption></figure><p id="31ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为正则表达式的缩写，<strong class="ix hj"> ReGex </strong>或<strong class="ix hj"> Regexp </strong>被计算机科学领域的语言学家称为一串文本，允许你创建用于匹配、定位和管理文本的模式。给它一个更简单的定义——ReGex是构成搜索模式的一系列字符。它还用于检查一个字符串是否包含指定的搜索模式。</p><p id="8665" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您通常会发现在字符串搜索算法中使用了这样的搜索模式，特别是针对字符串的<strong class="ix hj">“find”</strong>或<strong class="ix hj">“find and replace”</strong>操作，这种用法还扩展到了编程中的输入验证。众所周知，正则表达式是在理论计算机科学中发展起来的一种技术，它的根基是自动机的<strong class="ix hj"> <em class="jt">理论</em> </strong>和<strong class="ix hj"> <em class="jt">形式语法/语言。</em> </strong></p><h1 id="1048" class="ju jv hi bd iu jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">谁发明了正则表达式？</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/f64f51621c3f7c64d6d4fbc14ae33f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*o-3ThAF9mO3Ou7ixwD9VRQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">斯蒂芬·科尔·克莱尼</strong></figcaption></figure><p id="f79a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正则表达式的概念出现在20世纪50年代，当时美国数学家斯蒂芬·科尔·克莱尼T20形式化了正则语言的描述。这一概念因其主要用于Unix文本处理实用程序而出名。</p><p id="b99b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天，正则表达式在计算机科学和语言学的各个领域中被广泛使用。</p><p id="6b16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">举几个ReGex的此类领域/应用:- </strong></p><ul class=""><li id="1482" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">搜索引擎:每个人都知道基于网络的搜索引擎在当前信息时代的重要性。然而，计算机科学的消费者所面临的最大问题是，在现有的大量信息中，他们如何真正将需要的信息与不需要的信息分开。很明显，ReGex解决了这个问题，并且帮助计算机行业的成员或者你可以称之为<strong class="ix hj"> <em class="jt">【查询提交者】</em> </strong>获得与他们的查询最相关的结果。</li><li id="f10b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">文字处理器和文本编辑器的搜索和替换实用程序</strong><strong class="ix hj">:</strong>其中用户可以搜索对话/字符串并用另一个对话/字符串替换它们。我敢打赌。你会经常看到并使用它。不是吗？所有你字&amp; Excel的粉丝😉</li><li id="968f" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">在诸如流编辑器&amp; AWK </strong>的文本处理实用程序中:前者是一个解析和转换文本的Unix实用程序，后者是一个为文本处理而设计的特定领域语言，通常被用作一个包含数据提取的报告工具。</li><li id="16f9" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">词法分析:</strong>虽然我们知道词法分析是做什么的(即将一系列字符或我们所知的字符串转换成记号)；我们还应该知道正则表达式在词法分析中的重要性。词法分析中的正则表达式有助于扫描和识别属于某种语言的有效字符串/标记/词位集。正则表达式只帮助搜索那些由该语言的规则定义的模式。</li></ul><h2 id="d7e2" class="lk jv hi bd iu ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated"><strong class="ak">还有，你应该知道，</strong></h2><p id="527f" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated">许多编程语言或者内置或者通过库提供正则表达式功能。<strong class="ix hj">正则表达式支持</strong>是许多编程语言的标准库的一部分，其中<strong class="ix hj"> <em class="jt"> Java </em> </strong>和<strong class="ix hj"> <em class="jt"> Python </em> </strong>可能是世界上最著名的。并且，与此同时ReGex也被内置到其他的语法中，包括<strong class="ix hj"> <em class="jt"> Perl </em> </strong>和<strong class="ix hj"> <em class="jt"> ECMAScript。</em> </strong></p><p id="3371" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果到目前为止它已经让你感到有点无聊，让我们稍微点亮阅读:- <br/>你知道对于初学者来说，<strong class="ix hj"> <em class="jt">一个正则表达式就像一种“通用语”一样出现，用于人类和外星人之间可能的交流，每当未来发生外星人入侵时。</em> </strong></p><p id="4d6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">😆 😆 😆 😆 👽 👽 😯 😯 👽 👽 😖 😖👽 👽 😯 😯 👽 👽 😖 😖👽 👽 😆 😆 😆 😆</p><h1 id="5b67" class="ju jv hi bd iu jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">想象一下，你曾经遇到过像/^([a-z0–9_\.这样的序列-而你就像是我无法理解的密码。在这个星球上，这意味着什么？</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/34f8f8c040e5ced7b6e47834f4466aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zx52x0cjr260XuYmykJpqQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">简单地说:“ReGex”语法就像一只猫在你的键盘上玩耍。</figcaption></figure><h1 id="dc06" class="ju jv hi bd iu jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">现在，严肃地说</h1><h2 id="d9c1" class="lk jv hi bd iu ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated">你应该问问全世界的计算机科学家和程序员，为什么正则表达式如此重要？</h2><p id="c0ce" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated">他们将听到一个共同的裁决。ReGex通过自动搜索模式<strong class="ix hj"><em class="jt"/></strong><strong class="ix hj"><em class="jt">清理和处理基于文本的数据</em> </strong>使生活变得简单，因此，<strong class="ix hj"> <em class="jt">节省了您手动搜索大量文本数据的时间和麻烦。</em> </strong></p><h1 id="84e3" class="ju jv hi bd iu jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">今天，我们将使用Python3来使用ReGex🙌</strong></h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/e8c0dde8bf6c5a16492140abb662ee1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*732AQ5sT8_oIMlvySgVppg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">一个外行人对如何使用Python执行正则表达式的理解</strong></figcaption></figure><p id="77a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">干脆，开门见山……</em></strong></p><p id="51d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一点上，我想在Python的上下文中给出一个新的、更先进的正则表达式的定义(你也可以在python.org上找到相同的定义):-</p><blockquote class="mf mg mh"><p id="08eb" class="iv iw jt ix b iy iz ja jb jc jd je jf mi jh ji jj mj jl jm jn mk jp jq jr js hb bi translated">正则表达式(称为REs，或regexe，或regex模式)本质上是一种嵌入在Python中的微小的、高度专门化的编程语言，并通过<strong class="ix hj"> re </strong>模块提供。</p></blockquote><p id="8054" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">程序员想用ReGex + Python回答的那种问题？</p><ul class=""><li id="8aac" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">该字符串是否包含我要搜索的一组模式？</li><li id="53c3" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">这个字符串完全符合我的模式吗？</li><li id="78ab" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">我的搜索模式是否遵循所有预定义的规则？</li><li id="1877" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">我可以为我的正则表达式设置一些新的基本规则吗？</li><li id="13cd" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">我的语料库能容纳消费者/用户所有可能的搜索模式吗？</li><li id="fb88" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">我的文档与最常见的消费者关键词搜索类型的相关性如何？</li><li id="8920" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">我的文本语料库是否包含任何不相关的字符/符号/关键字，我可以删除这些字符/符号/关键字以保持我的文档的相关性和准确性？</li></ul><p id="e32f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是的，ReGex给出了所有这些问题的答案。现在，我将使用Python3来尝试将这一切付诸实践。</p><p id="a628" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">马上，</strong>让我们做一些不可避免的事情来完成它。让我们导入正确的Python模块"<strong class="ix hj"> re" </strong>来实现我们想在ReGex中做的任何事情</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/beea813df08595cdc38205f308dfb840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*AXwIw3TfFVFzI4TVc24YRA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">从Python导入re模块</strong></figcaption></figure><p id="2f87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> re，</strong>是Python中的内置包，可以用来处理正则表达式。</p><p id="6d76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在开始尝试一个非常基本的正则表达式的例子。这基本上演示了如何导入re模块并对样本字符串执行ReGex操作。这只是ReGex拥有的巨大潜力的一小部分。所以，请不要被你所看到的弄得不知所措，因为随着我们的进步，我们会做更多有趣的事情。</p><p id="1a13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">所以…… </strong> <br/>打开你的Jupyter笔记本/ Anaconda提示符/或者你通常写Python脚本的任何地方，简单地导入<strong class="ix hj"> re模块。</strong></p><p id="1902" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦你准备好了，在你的编辑器/终端/笔记本上写下下面几行代码。只是检查，如果你得到和我一样的输出。对下面代码的理想输出是- <strong class="ix hj"> <em class="jt">“平台:Medium.com”。</em> </strong>请确认您在输出控制台上也看到了这一信息。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/28f12e098bb9e3295ed8692be0d42ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*hhqQRZO2cNNobdyU_divrQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">一个基本的正则表达式示例</strong></figcaption></figure><p id="e70f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">这里刚刚发生了什么？</strong></p><p id="34ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">刚刚有人告诉我，他准备在某个网络平台上发表文章。我把他的声明写在了某个地方。我现在想做的只是从语句(字符串)中提取平台名称。如果你在上面的代码中看到，我也做了同样的事情。我定义了一个搜索模式，从原始输入字符串中提取序列“Medium.com”。</p><p id="f8db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这到底是怎么发生的？</p><p id="408b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个问题，一旦我们深入到ReGex- <strong class="ix hj">的基本原理，我们就可以回答这个问题，它的函数</strong>、<strong class="ix hj">字符、元字符、集合、序列、</strong>等等。</p><h1 id="dbc6" class="ju jv hi bd iu jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">正则表达式函数</h1><p id="1b70" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated">Python中的<strong class="ix hj"> re </strong>模块提供了一系列函数，允许程序员搜索字符串进行匹配</p><ol class=""><li id="7331" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js mn lc ld le bi translated">这个ReGex函数返回所有匹配的列表。它采用的两个参数是— <strong class="ix hj">第一个参数</strong>是他们想要查找的正则表达式字符串/序列的模式，而<strong class="ix hj">第二个参数</strong>是他们想要从中查找与给定正则表达式相对应的所有匹配模式的主字符串。</li></ol><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/fa72b7c6dda615c41f35d55335567ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8XzRZWnWU6Ubu-EIfzj0g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">一个演示findall()用法的例子</strong></figcaption></figure><p id="c431" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我试图找到给定句子中所有包含<strong class="ix hj"> "ing" </strong>作为子串(部分)的单词的列表。因此，您会看到，返回的列表是['Channing '，' swimming '，' dancing '，' dining']，其中显然每个单词都有<strong class="ix hj"> "ing" </strong>作为其一部分。</p><p id="efaf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。search() : </strong>如果在字符串中找到任何匹配，这个ReGex函数返回一个match对象。它采用的两个参数是— <strong class="ix hj">第一个参数</strong>是他们想要搜索的正则表达式字符串/序列的模式，第二个参数<strong class="ix hj">是他们想要在其中搜索与给定正则表达式相对应的特定模式的主字符串。如果有两个或更多匹配项，则只返回第一个匹配项。<br/>我将在这里向您展示两个案例:-</strong></p><p id="181e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一种情况:匹配/搜索字符串出现一次。这很简单，你会看到单词“going”出现在第15个位置，知道字符串的起始索引是0。因此，x.start()返回15。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/aac80efffd02e5212573b70e6a78031a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*8mi5R0GKMDSjZrj_Q-dlbw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">当我想匹配“going”而只有一个“going”时</strong></figcaption></figure><p id="8dea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二种情况:匹配/搜索字符串出现两次(多次)。这是一个例子，当我想匹配“going”时，我可以看到在句子中有两个“going”出现。这里，根据规则，我只得到第一次出现的位置，如果你愿意看的话。x.start()返回9，因为第一个单词位于第9个索引处。它没有考虑字符串末尾的另一个“将要”的单词。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/45c2be21cac0fb84e9d8d2aaf8bf12f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*wogZoudeFzfDCPeuueFvrg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">当我想要匹配“going”并且存在两个“going”事件时</figcaption></figure><p id="87dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。split() : </strong>这是一个ReGex函数，它返回一个列表，其中的字符串在每次匹配时都被拆分。它采用的两个参数是— <strong class="ix hj">第一个参数</strong>是他们将拆分主字符串的字符/序列、基础(at ),第二个参数<strong class="ix hj">是他们想要拆分的主字符串。我也刚刚给了你一个一行程序的方法来计算一个句子中的字数，下次你打算在任何程序中这样做的时候。😁 😀只需导入re并在空格处使用split(" \ s ")。瞧吧！</strong></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/90f52c9695a81382ff69818c2fdaf6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*1fSGCgdW45Lq6oWK_LuaOQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我在空格处拆分了一个句子。</figcaption></figure><p id="fe34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看一个例子，其中我们想要拆分某个字母或单词，而不是空格(这通常是一种常见的情况)。所以下面，我试着在字母<strong class="ix hj">“I”处拆分句子。</strong>功能显然保持不变:-</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/23715e6b4ea0d31f2e15c8627e630b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*HJjblXZA6nvHBFQyp-X9lA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">我在字母‘I’处拆分了与上面相同的句子</strong></figcaption></figure><p id="120a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 4。sub() : </strong>这个ReGex函数用于用您自己选择的文本替换匹配/搜索字符串。它采用的三个参数是— <strong class="ix hj">第一个参数</strong>是您想要替换的子字符串，<strong class="ix hj">第二个参数</strong>是您想要替换的子字符串，<strong class="ix hj">第三个参数</strong>是您想要进行替换的主要相关字符串。</p><p id="7fd5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你在下面的字符串“我们正在讨论正则表达式”中看到，我匹配了一个模式“正则表达式”并用“Python正则表达式”替换它，这样得到的字符串是<strong class="ix hj"> <em class="jt">“我们正在讨论Python正则表达式”。</em>T15】</strong></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/00b570a6b21ed1015395bf957f21a795.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*O0lw4F_qibcugHYx0AJDbg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">在正则表达式中使用sub()</strong></figcaption></figure><h1 id="6591" class="ju jv hi bd iu jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Python正则表达式字符备忘单:-</h1><p id="b439" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated"><strong class="ix hj">正则表达式基础:- </strong></p><p id="76c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">。(点)</strong> —除新行<br/> <strong class="ix hj"> a </strong>以外的任何字符—字符a <br/> <strong class="ix hj"> ab </strong> —字符串ab <br/> <strong class="ix hj"> a|b </strong> — a或b<br/><strong class="ix hj">—a *</strong>—0或更多a的<br/> <strong class="ix hj"> \ </strong> —转义特殊字符</p><p id="3099" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">正则表达式字符类:- </strong></p><p id="3640" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">【a b-d】</strong>—a、b、c、d<br/><strong class="ix hj">【^ab-d】</strong>中的一个字符—a、b、c、d<br/><strong class="ix hj">[\ b】</strong>—退格字符<br/> <strong class="ix hj"> \d </strong> —一位数字<br/> <strong class="ix hj"> \D </strong> —一位非数字<br/> <strong class="ix hj"> \s </strong> —一个空格<br/></p><p id="0d7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">正则表达式标志:- </strong></p><p id="7538" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> i </strong> —忽略大小写<br/> <strong class="ix hj"> m </strong> — ^和$匹配行的开始和结束<br/> <strong class="ix hj"> s </strong> —。也匹配换行符<br/> <strong class="ix hj"> x </strong> —允许空格和注释<br/> <strong class="ix hj"> L </strong> —区域设置字符类<br/> <strong class="ix hj"> u </strong> — Unicode字符类<br/> <strong class="ix hj">(？iLmsux) </strong> —在正则表达式中设置标志</p><p id="0b52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">正则表达式量词:- </strong></p><p id="316c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> * </strong> — 0以上<br/> <strong class="ix hj"> + </strong> — 1以上<br/> <strong class="ix hj">？</strong> — 0或1 <br/> <strong class="ix hj"> {2} </strong> —正好2个<br/> <strong class="ix hj"> {2，5} </strong> —介于2个和5个<br/> <strong class="ix hj"> {2，} </strong> — 2个或更多个<br/> <strong class="ix hj">(，5 }【T19)—最多5个</strong></p><p id="7438" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">正则表达式断言:- </strong></p><p id="9bf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> ^ </strong> —字符串开始<br/> <strong class="ix hj"> \A </strong> —字符串开始，忽略m标志<br/> <strong class="ix hj"> $ </strong> —字符串结束<br/> <strong class="ix hj"> \Z </strong> —字符串结束，忽略m标志<br/> <strong class="ix hj"> \b </strong> —单词边界<br/> <strong class="ix hj"> \B </strong> —非单词边界<br/> <strong class="ix hj">(？=…) </strong> —正向前瞻<br/> <strong class="ix hj">(？！…) </strong> —消极前瞻<br/> <strong class="ix hj">(？&lt; =…) </strong> —正面后视<br/> <strong class="ix hj">(？&lt;！…) </strong> —消极后视<br/> <strong class="ix hj">(？()|) </strong> —有条件</p><p id="f90e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">正则表达式组:- </strong></p><p id="3846" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> (…) </strong> —捕捉组<br/> <strong class="ix hj">(？P &lt; Y &gt; …) </strong> —捕获组命名为Y <br/> <strong class="ix hj">(？:…) </strong> —非捕获组<br/> <strong class="ix hj"> \Y </strong> —匹配第Y个捕获组<br/> <strong class="ix hj">(？P=Y) </strong> —匹配命名组Y <br/> <strong class="ix hj">(？#…) </strong> —注释</p><p id="bdbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">正则表达式特殊字符:- </strong></p><p id="be1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> \n </strong> —换行符<br/> <strong class="ix hj"> \r </strong> —回车符<br/> <strong class="ix hj"> \t </strong> —制表符<br/> <strong class="ix hj"> \YYY </strong> —八进制字符YYY <br/> <strong class="ix hj"> \xYY </strong> —十六进制字符YY</p><p id="c875" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">正则表达式替换:- </strong></p><p id="7f4f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> \g &lt; 0 &gt; </strong> —插入整个匹配<br/> <strong class="ix hj"> \g &lt; Y &gt; </strong> —插入匹配Y(名称或编号)<br/> <strong class="ix hj"> \Y </strong> —插入编号为Y的组</p><p id="ecbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我认为，到目前为止，我们已经很好地了解了Python正则表达式的基础知识，并对这些概念有了深入的了解。<br/>也许，是时候看看使用ReGex(与Python一起)的一些真实应用了。T103】</p><h1 id="2b17" class="ju jv hi bd iu jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">你听说过信用卡诈骗吗？</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/a94b8bc05b67ba42bac429cd5249dfaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*-b9y_8vlqsQssq6oCHlp2g.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu"> ReGex拥有识别信用卡欺诈的魔力……</strong></figcaption></figure><p id="ea5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我有一个朋友叫Mohan，他在一家信用卡公司工作。他的经理给了他大量的信用卡，并要求他验证信用卡号码。我的朋友研究了一下，发现ReGex的知识可以帮助他。</p><p id="3aef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">他知道我认识ReGex，他联系了我。他问我是否可以帮他确认他的信用卡上是否有有效的信用卡号码？</p><p id="4582" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">他给了我以下规则/断言，作为真实信用卡号的基本特征:- </strong></p><p id="82e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它必须以4、5或6开头。<br/>它必须正好包含16位数字。<br/>只能由数字(0-9)组成。<br/>它可能有4个一组的数字，由一个连字符<strong class="ix hj"> "-" </strong>分隔。不得使用任何其他分隔符，如' '、' _ '等。不得有4个或更多连续重复的数字。</p><h2 id="39bc" class="lk jv hi bd iu ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated">然后他给了我几个有效的信用卡号码的例子</h2><pre class="ks kt ku kv fd mv mw mx my aw mz bi"><span id="d2b7" class="lk jv hi mw b fi na nb l nc nd">6954627879619786<br/>5126424824942942<br/>4127-2267-7924-3914</span></pre><h2 id="fd21" class="lk jv hi bd iu ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated">然后他给了我一些无效/欺诈信用卡号码的例子</h2><pre class="ks kt ku kv fd mv mw mx my aw mz bi"><span id="5ff8" class="lk jv hi mw b fi na nb l nc nd">62531254792151867 #17 digits in card number → Hence Invalid <br/>692<strong class="mw hj">44444</strong>24441344  #Consecutive digits &gt;= 4 times → Hence Invalid<br/>5122-2368-7954<strong class="mw hj"> - </strong>3214 #Separators other than '-' are used → Invalid<br/>65244<strong class="mw hj">x</strong>4521242547 #Contains non digit characters('x') → Hence Invalid<br/><strong class="mw hj">9</strong>625312582963578 #Doesn't start with 4, 5 or 6 → Hence Invalid</span></pre><p id="38d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我说:“好的，我会尽力帮助你的”。</p><p id="71f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我没花多少时间就用下面的代码回复了他。这也解释了使用Python和它的有效模块“re”执行ReGex是多么容易和快速。你只需要很好地了解你的正则表达式字符集，就是这样！</p><p id="54c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我告诉我的朋友——<strong class="ix hj">“我相信我与你分享的这个代码是为了验证你的信用卡是否有真实的信用卡号码。只需输入您的信用卡号码，然后自己检查。</strong></p><h2 id="7132" class="lk jv hi bd iu ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated"><strong class="ak">你(读者)能看看我的这段代码，告诉我这里到底发生了什么吗？</strong></h2><p id="4e11" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated"><strong class="ix hj"><em class="jt">*请考虑if/else、语句、函数的适当缩进，以便让您的控制台/笔记本识别语法正确的代码块；在执行这个脚本之前。</em> </strong></p><blockquote class="mf mg mh"><p id="06c1" class="iv iw jt ix b iy iz ja jb jc jd je jf mi jh ji jj mj jl jm jn mk jp jq jr js hb bi translated">导入re<br/>def cc _ rules(cc _ num _):<br/>pass _ = 0<br/>rule 1 = '^[456].+' <br/> if re.search(rule1，cc _ num _):<br/>pass _+= 1<br/># print(" rule 1 "，pass_) <br/> rule2 = ' '。join(filter(lambda i: i.isdigit()，cc _ num _)<br/>if len(rule 2)= = 16:<br/>pass _+= 1<br/># print(" rule 2 "，pass_) <br/> rule3 = all(item in [0，1，2，3，4，5，6，7，8，9]for list(int(x)for x in rule 2))<br/>if rule 3 = = true:<br/>pass _+= 1<br/>[0–9]{4}\-?[0–9]{4}\-?[0–9]{ 4 } '<br/>if re . search(rule 4，cc _ num _):<br/>pass _+= 1<br/># print(" rule 4 "，pass _)<br/>rule 5 = '^[456][0–9]{3}[\s_][0–9]{4}[\s_)？[0–9]{ 4 }[\ s _]？[0–9]{ 4 } '<br/>if re . search(rule 5，cc _ num _)= = None:<br/>pass _+= 1<br/># print(" rule 5 "，pass_) <br/> rule6 = r'(\d)\1{3，}' <br/> if re.search(rule6，rule 2)= = None:<br/>pass _+= 1<br/>if pass _ = = 6:<br/>返回“有效”<br/>否则:【T47</p><p id="3904" class="iv iw jt ix b iy iz ja jb jc jd je jf mi jh ji jj mj jl jm jn mk jp jq jr js hb bi translated">if _ _ name _ _ = = ' _ _ main _ _ ':<br/>N = int(input())<br/>assert 0&lt;N&lt;100，" 0&lt;N&lt;100 "<br/>for I in range(N):<br/>str _ = input()<br/>ans _ = cc _ rules(str _)<br/>print(ans _)</p></blockquote><h2 id="b303" class="lk jv hi bd iu ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated">如果您认为您已经了解了这段代码中发生了什么，并且在阅读本文后对ReGex现在更有信心，那么请留下掌声。</h2><p id="a25e" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated">如果你认为你有任何疑问，请在下面的评论中留下你的问题，我很乐意回答。</p><h1 id="3fbd" class="ju jv hi bd iu jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">谢谢你！</strong></h1><p id="9ef1" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated">快乐正则表达式！<br/>不要忘记使用你的Python来更好更快地执行😉</p></div></div>    
</body>
</html>