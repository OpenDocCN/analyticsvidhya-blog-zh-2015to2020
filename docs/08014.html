<html>
<head>
<title>Automated Browsers, Scraping and Crawling — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动化浏览器，抓取和爬行—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/automated-browsers-scraping-and-crawling-part-2-cc9e2149a64?source=collection_archive---------22-----------------------#2020-07-14">https://medium.com/analytics-vidhya/automated-browsers-scraping-and-crawling-part-2-cc9e2149a64?source=collection_archive---------22-----------------------#2020-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4073" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一种可重用的、面向对象的浏览器自动化方式</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/62d035035d1acc8e89f9270e9685ec8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-GB6inSvQlitoTcU"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn">摄影:萨法尔·萨法罗夫，Unsplash </strong></figcaption></figure><p id="a67c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你是一个完全的初学者，我强烈建议你先看看本教程的<a class="ae kk" rel="noopener" href="/swlh/automated-browsers-scraping-and-crawling-easier-than-it-looks-af37bd765bca"> <strong class="jq hj">第一部分</strong> </a>。本教程的开头是面向初学者的，所以我将讲述Python类和方法的基础知识，但它只讲述最基本的知识。你可以找到TL；博士就在它下面。</p><p id="c7e6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为什么不重用第1部分的代码？</p><p id="aad7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可能已经注意到，在前面的过程中有许多手动输入。我们需要将大量代码复制粘贴到一个新的Python文件中，或者全部重新输入。我使用的一个经验法则是:如果你发现自己需要复制代码，尽可能地尝试自动化这个过程。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="3f96" class="ks kt hi bd jn ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated"><strong class="ak">类和方法</strong></h1><p id="f4f4" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">为了自动化，理解什么是类和方法是至关重要的。让我给你举个例子:假设我们希望能够在你的代码中轻松高效地创建‘狗’。我们需要一个狗类——一个包含狗通常具有的基本特征的蓝图。在dog类中，我们首先定义了我们的<strong class="jq hj">构造函数</strong>，在这里我们定义了属于我们创建的所有dog的所有属性和对象(这并不完全是一个构造函数方法所做的事情，但是为了有一个初步的概念理解，我们将会处理它)。构造函数(在Python中显示为__init__)是一个<strong class="jq hj">方法，</strong>是在类内执行的东西。方法不限于构造函数；方法只是我们的类可以执行的特定功能的总称。</p><p id="bf0e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的__init__方法接受我们认为所有狗都必须给出的所有默认参数，在本例中是品种和名字。我们的bark方法接受我们传递的名称和物种，并根据这些属性打印出一个句子。<strong class="jq hj"> </strong>下面是一个被大量评论的例子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="03c4" class="ks kt hi bd jn ku lq kw kx ky lr la lb io ls ip ld ir lt is lf iu lu iv lh li bi translated">只是简单回顾一下…</h1><ul class=""><li id="cc61" class="lv lw hi jq b jr lj ju lk jx lx kb ly kf lz kj ma mb mc md bi translated"><strong class="jq hj">类</strong>是一只狗的蓝图</li><li id="c1b4" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">类中的<strong class="jq hj"> __init__ </strong> <strong class="jq hj">构造函数</strong>定义了属于该类所有方法的所有属性。</li><li id="e27f" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">bark方法只接受__init__方法的属性(即品种和名称)，在调用时打印出狗的类别名称和狗的类别。</li></ul><p id="cb56" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同样，这非常简单，但这是理解我们为无头浏览编写的代码所需要的视图。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="a716" class="ks kt hi bd jn ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated"><strong class="ak">TL；博士——给我代码</strong></h1><h1 id="295a" class="ks kt hi bd jn ku lq kw kx ky lr la lb io ls ip ld ir lt is lf iu lu iv lh li bi translated">定位器类别</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="3f98" class="ks kt hi bd jn ku lq kw kx ky lr la lb io ls ip ld ir lt is lf iu lu iv lh li bi translated">导航器类</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="422e" class="ks kt hi bd jn ku lq kw kx ky lr la lb io ls ip ld ir lt is lf iu lu iv lh li bi translated"><strong class="ak">利用率</strong></h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lo lp l"/></div></figure></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="973c" class="ks kt hi bd jn ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">让我们来分解一下:定位器类</h1><p id="39c7" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">__init__构造函数接受一个参数；我们创建的驱动程序对象。我们看到web元素也包含在构造函数中，但是它已经被赋值为“None”当我们实例化这个类的对象时，我们不需要提供它。它在构造函数中的原因是因为我们以后会覆盖它，我们希望能够在类中的任何地方使用这个元素。一旦我们覆盖了它，它将属于整个类，类中的所有方法都可以使用它。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="e900" class="mo kt hi mk b fi mp mq l mr ms">def __init__(self, driver):<br/>    self.driver = driver<br/>    # We will overwrite the element later<br/>    self.element = None</span></pre><p id="1500" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来的两个方法为我们找到了web元素。第一个使用XPath，第二个使用CSS。我们使用一个<strong class="jq hj">预期条件，selenium.webdriver.support的</strong>部分。</p><p id="b798" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，一旦我们定位了元素，我们就把它分配给类的element对象。这样我们知道它现在可以被类中的任何方法访问。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="566e" class="mo kt hi mk b fi mp mq l mr ms"># Finding an element via XPATH</span><span id="4c45" class="mo kt hi mk b fi mt mq l mr ms">def locate_xpath(self, seconds, val):<br/><br/>      locator = (By.XPATH, val)<br/><br/>      ele = WebDriverWait(self.driver,    seconds).until(EC.visibility_of_all_elements_located(locator = locator))<br/><br/>     self.element = ele<br/></span><span id="ccf6" class="mo kt hi mk b fi mt mq l mr ms"># Doing it with CSS instead</span><span id="7045" class="mo kt hi mk b fi mt mq l mr ms"> def locate_css(self, seconds, val):<br/><br/>      locator = (By.CSS_SELECTOR, val)<br/><br/>      ele = WebDriverWait(self.driver,  seconds).until(EC.visibility_of_all_elements_located(locator = locator))<br/><br/>      self.element = ele</span></pre><p id="f886" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">前两种方法找到了多个元素，而这种方法只找到了一个元素。这对于在输入框中点击和输入非常有用。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="b64e" class="mo kt hi mk b fi mp mq l mr ms">def find_single_xpath(self, seconds, val):<br/>      locator = (By.XPATH, val)<br/>      ele = WebDriverWait(self.driver,  seconds).until(EC.visibility_of_element_located(locator = locator))<br/>      self.element = ele</span></pre><p id="367d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这些方法相对来说是不言自明的。一个点击，一个输入，一个拉出网页上的元素。我们看到在scrape()方法中append_list默认为none。如果我们传递一个列表，它会为我们追加。否则它只会返回列表。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="23c1" class="mo kt hi mk b fi mp mq l mr ms">def scrape(self, append_list = None):<br/>     scraped_list = [x.text for x in self.element]<br/>     if append_list is not None:<br/>     scraped_list = append_list + scraped_list<br/>     return(scraped_list)<br/> <br/> def click(self):<br/>     self.element.click()<br/> <br/> def typein(self, text):<br/>     self.element.sendKeys(text)</span></pre></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="e1c0" class="ks kt hi bd jn ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">导航器类</h1><p id="75b1" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">这个比我们的定位器类简单多了。我们的__init__只包含驱动程序，所以只有我们传递的驱动程序对所有方法都可用。back()和fwd()方法允许我们传递想要移动的页数。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="e199" class="mo kt hi mk b fi mp mq l mr ms"> def __init__ (self, driver):<br/>     self.driver = driver<br/> <br/><br/> def get_pg(self, url):<br/>     self.driver.get(url)</span><span id="c30a" class="mo kt hi mk b fi mt mq l mr ms"><br/>    def back(self, num_pg):<br/>        for i in range(1,num_pg+1):<br/>            self.driver.back()</span><span id="4d42" class="mo kt hi mk b fi mt mq l mr ms"> <br/>    def fwd(self, num_pg):<br/>        for i in range(1,num_pg+1):<br/>            self.driver.forward()</span></pre><p id="a35b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种方法允许我们最小化、最大化或全屏显示浏览器窗口。如果需要，可以跟踪更改，如果没有必要，可以将浏览器从屏幕上移除。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="aba5" class="mo kt hi mk b fi mp mq l mr ms"> def change_window(self, how):<br/>     if how == “min”:<br/>          self.driver.minimize_window()<br/>     elif how == “max”:<br/>          self.driver.maximize_window()<br/>     elif how == “full”:<br/>          self.driver.fullscreen_window()</span></pre></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="8676" class="ks kt hi bd jn ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">使用类</h1><p id="45de" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">一旦创建了类，使用它们就相对简单了。我们确保每个类中的所有方法都易于理解，这样任何人看了你的代码都能立即知道每个方法的作用。</p><p id="8214" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们在这里做的是创建一个navigator和locator类的对象。一旦我们这样做了，我们就可以利用我们写在类中的所有可重用的功能</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="8910" class="mo kt hi mk b fi mp mq l mr ms"># Creating our navigator object<br/>nav = navigator.navigator(driver)</span><span id="1f35" class="mo kt hi mk b fi mt mq l mr ms"># Creating our locator object<br/>loc = locator.locator(driver)</span><span id="bec7" class="mo kt hi mk b fi mt mq l mr ms"># Now we can easily move to our website<br/>nav.get_pg("https://www.google.com")</span><span id="80b1" class="mo kt hi mk b fi mt mq l mr ms"># And then locate whichever xpath we want<br/>loc.locate_xpath(10, "your/xpath/here")</span></pre></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="dca6" class="ks kt hi bd jn ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">预期条件</h1><p id="3a59" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">使用time.sleep()，我们在算法的每次迭代之间有一个静态的、不变的等待期。如果我们节流，比方说每次10秒，并且需要运行算法数百次，这可能导致巨大的等待时间。Selenium提供了一个很好的方法来降低web浏览器的速度，或者在不使其静态化的情况下优化其效率。</p><p id="89e1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有了预期的条件，我们可以让驱动程序等待它需要等待的时间，而不再…例如，一旦元素被加载，驱动程序就继续执行它的任务。你可以在这里<a class="ae kk" href="https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html" rel="noopener ugc nofollow" target="_blank">得到所有的文档</a>，但是这里有一些有用的预期条件:</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="cebf" class="mo kt hi mk b fi mp mq l mr ms"># Executes the script once the exact element is found. NOTE: this does mean that it is loaded; only found!<br/><strong class="mk hj">visibility_of_element_located</strong></span><span id="057c" class="mo kt hi mk b fi mt mq l mr ms"># Executes the script once the exact element is clickable<br/><strong class="mk hj">element_to_be_clickable</strong></span><span id="cf33" class="mo kt hi mk b fi mt mq l mr ms"># Executes the script when at least one element is present. Once all are loaded, it can return all of the elements at once<br/><strong class="mk hj">presence_of_all_elements_located</strong></span></pre></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="429f" class="ks kt hi bd jn ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">更简单的定位方法</h1><p id="0498" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">有很多方法可以找到你想要的元素。最耗时的方法是像我在第1部分中描述的那样手工编写XPath或CSS。当您在contains()、starts-with()等上分层时，这对于一些高级情况很有用。，但在大多数初学者的情况下，你可以做得更快。如果你想深入研究更复杂的方法，可以看看这篇关于<a class="ae kk" href="https://www.swtestacademy.com/xpath-selenium/" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj"/></a><strong class="jq hj">的文章。</strong></p><ol class=""><li id="dac0" class="lv lw hi jq b jr js ju jv jx mu kb mv kf mw kj mx mb mc md bi translated"><strong class="jq hj">使用</strong><a class="ae kk" href="https://selectorgadget.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">SelectorGadget</strong></a><strong class="jq hj">:</strong>这个插件对于快速CSS选择和XPath生成非常棒。只需启动插件并点击所需的元素。它会突出显示所有类似的元素，并让您选择获取XPath。</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/0975ad1203296c1d44770f8473ed4d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EIY19B7YJIl-YFIPKNXkQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">这个插件向我们展示了。价格_颜色web元素</figcaption></figure><p id="47ab" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">2.在检查特定元素时，只需转到<strong class="jq hj">复制→复制XPath </strong>。只需记住在导出到Python之前在您的控制台中测试这一点！你不一定总能得到你想要的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/c0413ae0a195b4f48af3a48fdeb6ea4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ho1s7t09oijj_z0OPAaFLA.png"/></div></div></figure></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="9b81" class="ks kt hi bd jn ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">在你走之前…</h1><p id="ab98" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">就像我在第1部分提到的，在做这些之前，请阅读ToS和Robots.txt。自动化浏览器的好处是巨大的，但是请负责任地自动化。</p><p id="892b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢您对第1部分的所有积极反馈，祝您浏览愉快！</p></div></div>    
</body>
</html>