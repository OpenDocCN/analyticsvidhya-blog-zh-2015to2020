<html>
<head>
<title>Building a Game Engine from Scratch with C++ and Native Platform Languages (Part Two)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++和本地平台语言从头开始构建游戏引擎(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-game-engine-from-scratch-with-c-and-native-platform-languages-part-two-991618781c33?source=collection_archive---------2-----------------------#2019-12-22">https://medium.com/analytics-vidhya/building-a-game-engine-from-scratch-with-c-and-native-platform-languages-part-two-991618781c33?source=collection_archive---------2-----------------------#2019-12-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/88abe32550422e8ce3d3672eb8156c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*8EvsPg8J77M1rpC7KA-MgQ.jpeg"/></div></figure><p id="43e8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们开始吧！本系列将利用终端，所以您将需要复习一下如何使用操作系统的命令行。我会解释这是怎么回事，但这将取决于你为你的操作系统找出它。</p><p id="eeb3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，请在您最喜欢的代码编辑器中打开我们的项目。此外，弹出打开一个终端和cd(更改目录)到项目的根目录。让我们编写我们创建的CMakeLists.txt文件的第一行。</p><p id="5fc0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第一行需要是我们希望这个文件使用的CMake的最低版本。这将向CMake发出信号，如果安装了足够新版本的CMake，就只尝试构建我们的项目。</p><p id="0342" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在终端中，输入命令…</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="920d" class="jt ju hi jp b fi jv jw l jx jy">cmake --version</span></pre><p id="a79f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出将告诉您已经安装的CMake的版本。我的写着“cmake版本3.16.1”。复制这个数字，让我们把这一行添加到我们的文件的顶部。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="7a8c" class="jt ju hi jp b fi jv jw l jx jy">cmake_minimum_required(VERSION 3.16.1 FATAL_ERROR)</span></pre><p id="064a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">太好了！我们的引擎已经正式启动了！干得好。下一步是命名我们的项目。将这些行添加到文件中。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="c293" class="jt ju hi jp b fi jv jw l jx jy">project(engine)</span><span id="8f9d" class="jt ju hi jp b fi jz jw l jx jy">set(CMAKE_CXX_STANDARD 11)</span></pre><p id="c006" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们已经告诉CMake我们项目的名称，以及我们将使用哪个版本的C++。对我们来说，C++11就是我们所需要的。</p><p id="51c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，我们将添加一个静态库目标，这将是我们的引擎，以及一个可执行目标，这只是为了测试。稍后我们将创建本地平台项目来运行我们的游戏。但是现在，我们只是想要一个快速的方法来测试我们写的代码。</p><p id="50fa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，让我们定义我们的源代码文件。我们还没有创建任何C++文件，但接下来我们会这样做。</p><p id="90f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将这几行添加到CMakeLists.txt的底部</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="4cad" class="jt ju hi jp b fi jv jw l jx jy">set(ENGINE_SOURCE</span><span id="c89f" class="jt ju hi jp b fi jz jw l jx jy">    ${CMAKE_CURRENT_LIST_DIR}/src/engine.h</span><span id="dd86" class="jt ju hi jp b fi jz jw l jx jy">    ${CMAKE_CURRENT_LIST_DIR}/src/engine.cpp</span><span id="cfda" class="jt ju hi jp b fi jz jw l jx jy">)</span><span id="213f" class="jt ju hi jp b fi jz jw l jx jy">add_library(engine STATIC ${ENGINE_SOURCE})</span><span id="3d20" class="jt ju hi jp b fi jz jw l jx jy"><br/>set(TESTING_SOURCE</span><span id="8389" class="jt ju hi jp b fi jz jw l jx jy">    ${CMAKE_CURRENT_LIST_DIR}/src/testing.cpp</span><span id="cb81" class="jt ju hi jp b fi jz jw l jx jy">)<br/>add_executable(program ${TESTING_SOURCE})</span><span id="b04e" class="jt ju hi jp b fi jz jw l jx jy"><br/>target_link_libraries(program</span><span id="be06" class="jt ju hi jp b fi jz jw l jx jy">   engine</span><span id="5327" class="jt ju hi jp b fi jz jw l jx jy">)</span></pre><p id="42ca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我们已经定义了一个静态库目标和一个可执行文件，并为每个目标分配了一些源代码文件。希望这是不言自明的。CMAKE_CURRENT_LIST_DIR只是一个变量，它存储磁盘上CMAKE文件的绝对路径。</p><p id="7d33" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们继续添加这些源文件，并在其中填充一些代码！</p><p id="536b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们创造。/src/engine.h优先。现在我们将保持它非常简单。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="5af2" class="jt ju hi jp b fi jv jw l jx jy">#pragma once</span><span id="f727" class="jt ju hi jp b fi jz jw l jx jy">void Initialise();</span></pre><p id="e040" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">…还有。/src/engine.cpp可以实现这个功能。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="5525" class="jt ju hi jp b fi jv jw l jx jy">#include "engine.h"</span><span id="edd7" class="jt ju hi jp b fi jz jw l jx jy">#include &lt;iostream&gt;</span><span id="87e8" class="jt ju hi jp b fi jz jw l jx jy">void Initialise(){</span><span id="9bad" class="jt ju hi jp b fi jz jw l jx jy">    std::cout &lt;&lt; "ENGINE INITIALISED!" &lt;&lt; std::endl;</span><span id="ea18" class="jt ju hi jp b fi jz jw l jx jy">}</span></pre><p id="7447" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">很好，一个强大的游戏引擎！</p><p id="e4f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们创建临时测试可执行文件将使用的文件。那是。/src/testing.cpp</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="958e" class="jt ju hi jp b fi jv jw l jx jy">#include "engine.h"</span><span id="beaf" class="jt ju hi jp b fi jz jw l jx jy">int main(){</span><span id="97b5" class="jt ju hi jp b fi jz jw l jx jy">    Initialise();</span><span id="1a11" class="jt ju hi jp b fi jz jw l jx jy">    return 0;<br/>}</span></pre><p id="4cc1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这可能看起来非常基本和简单，但这是我们整个项目的基础！</p><p id="0003" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">时间到了，我们全能游戏引擎的第一次构建…希望我们没有增加太多功能！</p><p id="5096" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们进入终端，确保我们已经将目录设置为项目的根目录，并创建一个名为bin的新文件夹。在Mac和Linux上，创建名为bin的文件夹的命令是“mkdir bin”。</p><p id="f4d6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通常将这个文件夹称为bin，因为编译后的二进制文件将存放在这里。让我们进入该文件夹并运行cmake命令。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="568a" class="jt ju hi jp b fi jv jw l jx jy">cmake --help</span></pre><p id="d789" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这会吐出一堆信息，但我们感兴趣的，是靠近底部的生成器列表。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="e9db" class="jt ju hi jp b fi jv jw l jx jy">* Unix Makefiles               = Generates standard UNIX makefiles.<br/>  Ninja                        = Generates build.ninja files.<br/>  Xcode                        = Generate Xcode project files.<br/>  CodeBlocks - Ninja           = Generates CodeBlocks project files.<br/>  CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files.<br/>  CodeLite - Ninja             = Generates CodeLite project files.<br/>  CodeLite - Unix Makefiles    = Generates CodeLite project files.</span></pre><p id="9172" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些是我的CMake可以生成的可能的构建系统。你的可能看起来不一样。“Unix Makefiles”旁边有一个星号，表示这是我的默认设置。这是完美的，因为这是我想用的。如果你在Mac或Linux上，那么这也是你想要的，但是如果你在Windows上，那么你将需要使用Visual Studio生成器。继续复制列表中的Visual Studio生成器名称。</p><p id="7823" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们运行CMake！</p><p id="2b20" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你在Mac或Linux上…</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="6696" class="jt ju hi jp b fi jv jw l jx jy">cmake ..</span></pre><p id="abc8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">…对于Windows，只需确保用您从列表中复制的精确文本字符串替换该命令。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="da34" class="jt ju hi jp b fi jv jw l jx jy">cmake .. -G"Visual Studio 16 2019"</span></pre><p id="b885" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个命令告诉cmake运行，但是要在下面的目录中查找CMakeLists.txt文件，这就是..意味着。那..可能是磁盘上某个地方的完整绝对路径，只要那里有CMakeLists.txt文件，它就能工作。</p><p id="fefc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果一切顺利，那么我们现在将在bin目录中有一个生成的项目准备构建了！在Windows上，打开已创建的Visual Studio项目，然后点击build and run。</p><p id="c830" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在Mac和Linux上，确保你进入了bin目录(或者任何你运行cmake的地方),然后简单的输入…</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="87bd" class="jt ju hi jp b fi jv jw l jx jy">make</span></pre><p id="b133" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这将运行CMake创建的Makefile，并构建我们的库目标和可执行文件。</p><p id="ee71" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果代码中有任何语法错误，那么……修复它们……然后再试一次。</p><p id="e6a5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">构建成功后，继续运行测试可执行文件，方法是双击它或者在终端中运行它。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="c8e6" class="jt ju hi jp b fi jv jw l jx jy">./program</span></pre><p id="04bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们应该看到输出“引擎初始化！”</p><p id="0229" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们在做生意！功能强大的游戏引擎！</p><p id="1717" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我希望你对此感到兴奋，它没有花哨的3D图形…或者任何图形…然而，我们现在有一个组织良好的项目，我们可以在此基础上继续发展。继续并完全删除bin文件夹。什么？！删除bin文件夹？！你一定是疯了！</p><p id="da5d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我没疯！bin文件夹的内容是由CMake为我们生成的，这意味着我们不必担心它，当然也不应该将其签入版本控制。因此，继续删除bin文件夹，重新创建它，在您的终端cd到它，并尝试再次生成项目。</p><p id="be7c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不过，我们不需要每次进行更改时都重新生成，CMake非常强大，它知道您何时更改了源代码或CMakeLists.txt文件本身。它会检测变化并为您更新自身。所以我们的开发过程将会是这样的:</p><ol class=""><li id="075f" class="ka kb hi io b ip iq it iu ix kc jb kd jf ke jj kf kg kh ki bi translated">创建或编辑源代码文件</li><li id="fad9" class="ka kb hi io b ip kj it kk ix kl jb km jf kn jj kf kg kh ki bi translated">向CMakeLists.txt添加任何新文件</li><li id="ad91" class="ka kb hi io b ip kj it kk ix kl jb km jf kn jj kf kg kh ki bi translated">在IDE中运行“make”或“build”。</li><li id="a3cc" class="ka kb hi io b ip kj it kk ix kl jb km jf kn jj kf kg kh ki bi translated">重复直到游戏引擎完成。</li></ol><p id="6c01" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我希望你能体会到CMake在维护你自己的Makefile / XCode项目/ Visual Studio解决方案等方面的强大功能。不仅仅是CMake跨平台，如果我们对生成的项目乱搞，破坏了什么，我们可以重新生成！</p><p id="30aa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">目前就这些。下一集，我们将添加一些真正的代码到我们的引擎中。</p></div></div>    
</body>
</html>