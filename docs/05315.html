<html>
<head>
<title>How to Build a ChatOps-Bot in Python with Slack and Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Slack和Kubernetes在Python中构建ChatOps-Bot</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-build-a-chatops-bot-with-slack-and-kubernetes-6f25b9c20a8?source=collection_archive---------10-----------------------#2020-04-17">https://medium.com/analytics-vidhya/how-to-build-a-chatops-bot-with-slack-and-kubernetes-6f25b9c20a8?source=collection_archive---------10-----------------------#2020-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/582e9f69e8a5f58c5a30c8ca78702d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DUe9dAPsKqUWqD8n"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@askkell?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安迪·凯利</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d985" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ChatOps允许您使用基于聊天的界面管理您的DevOps任务。了解如何使用Slack构建一个简单的bot来控制Kubernetes集群。</p><p id="9b7c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，您可以使用Slack聊天消息查看Kubernetes日志和信息。</p><p id="8c76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有Kubernetes或Slack API的先验知识是必要的。</p><p id="7824" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，让我们通过探索什么是ChatOps来开始构建。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/6e0e7e9430f2b85736c5052e575c9e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TjOBvBdmgxEUKoeoqO0luw.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">与完成的聊天机器人互动</figcaption></figure><h1 id="e592" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是ChatOps</h1><p id="e0e6" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">ChatOps是执行DevOps任务的一种方式，例如使用聊天消息进行部署、监控和系统管理。例如，向聊天机器人发送日志消息可以检索最新的日志消息。或者可以从聊天消息中触发部署。</p><p id="6ab2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这提供了一些重要的优势:</p><ul class=""><li id="f91d" class="lb lc hi ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">一种非常人性化的管理基础设施的方式，通过与机器人聊天。<code class="du lk ll lm ln b"><em class="lo">@chatbot logs</em></code>比<code class="du lk ll lm ln b"><em class="lo">kubectl logs hello-minikube-64b64df8c9-fkb6w -ndefault</em></code>更容易理解</li><li id="233c" class="lb lc hi ix b iy lp jc lq jg lr jk ls jo lt js lg lh li lj bi translated">它可以是共享聊天的一部分，以便人们可以协作和共享信息。这也提供了执行命令和动作的记录。</li><li id="0032" class="lb lc hi ix b iy lp jc lq jg lr jk ls jo lt js lg lh li lj bi translated">它可以帮助安全地克服网络和防火墙的限制，使在家或外出工作成为可能</li><li id="c2db" class="lb lc hi ix b iy lp jc lq jg lr jk ls jo lt js lg lh li lj bi translated">DevOps工具上的统一界面，使用同一界面管理Kubernetes和OpenShift</li><li id="1fb7" class="lb lc hi ix b iy lp jc lq jg lr jk ls jo lt js lg lh li lj bi translated">它可以简化和保护基础设施任务，因此它们可以由开发人员自己来完成。</li></ul><h1 id="23b5" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">设置</h1><p id="8063" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">本文描述了使用以下工具构建一个最小的聊天机器人:</p><ul class=""><li id="8f1d" class="lb lc hi ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">Minikube作为一个Kubernetes环境。<a class="ae iu" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>被贴上“生产级容器编排”的标签。Kubernetes允许我们部署、管理和扩展docker映像。Minikube是一个在开发机器上运行Kubernetes的交钥匙解决方案。</li><li id="529d" class="lb lc hi ix b iy lp jc lq jg lr jk ls jo lt js lg lh li lj bi translated">作为聊天服务器的Slack</li><li id="5710" class="lb lc hi ix b iy lp jc lq jg lr jk ls jo lt js lg lh li lj bi translated">Python来实现聊天机器人。</li></ul><h1 id="d992" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">迷你库贝</h1><p id="1b50" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">为了在开发机器上快速运行Kubernetes，<a class="ae iu" href="https://kubernetes.io/docs/setup/learning-environment/minikube/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>在单个虚拟机映像中实现了一个Kubernetes集群。详细的安装说明可以在<a class="ae iu" href="https://kubernetes.io/docs/setup/learning-environment/minikube/#installation" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="375f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了在我的macOs系统上安装它，我使用VirtualBox作为虚拟化驱动程序。VirtualBox可以在<a class="ae iu" href="https://www.virtualbox.org/wiki/Downloads" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="ca04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">安装VirtualBox后，可以使用下面的命令在macOs上安装Minikube。它还将部署一个示例应用程序。这假设你已经安装了<a class="ae iu" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制软件</a>。</p><pre class="ju jv jw jx fd lu ln lv lw aw lx bi"><span id="021e" class="ly jz hi ln b fi lz ma l mb mc"><em class="lo">$ brew install minikube # install via Homebrew</em></span><span id="8715" class="ly jz hi ln b fi md ma l mb mc"><em class="lo">§ minikube start — driver=virtualbox # start and use Virtualbox</em></span><span id="e92c" class="ly jz hi ln b fi md ma l mb mc"><em class="lo">$ kubectl create deployment hello-minikube-image=k8s.gcr.io/echoserver:1.10 # install sample app</em></span></pre><p id="f1f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<code class="du lk ll lm ln b">kubectl get all</code>来验证安装，结果应该显示示例pod，类似于<code class="du lk ll lm ln b">pod/hello-minikube-64b64df8c9-fkb6w</code>。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/77d7f427728b2b84fb868016acc8555d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dupNXgqOxd4s8L6D8tNKfg.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">执行kubectl的结果得到所有</figcaption></figure><h1 id="80b9" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">对Kubernetes的(难以置信的)简短介绍</h1><p id="e8cd" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">Kubernetes是一款允许管理集群中docker映像的软件。这包括部署、扩展、管理和监控。基本部署单元是一个吊舱。窗格可以包含多个docker图像或容器。我们将在本文中开发的聊天机器人只支持具有单一图像的窗格。Kubernetes可以通过<code class="du lk ll lm ln b">kubectl</code>命令和其他方式控制。</p><p id="e270" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的服务器将使用以下Kubernetes命令</p><p id="44af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm ln b">kubectl get pods --selector=app={app} --namespace={namespace}</code>:检索名称空间中应用程序的窗格。</p><p id="9d2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm ln b">kubectl logs {pod} --namespace={namespace}</code>:获取pod中容器的日志(如果容器中只有一个图像)</p><p id="1502" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm ln b">kubectl describe pod {pod} --namespace={namespace}</code>:描述pod的详细信息。</p><h1 id="fd1c" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">松弛的</h1><p id="eb8b" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">如果您没有Slack账户，您可以在<a class="ae iu" href="https://slack.com" rel="noopener ugc nofollow" target="_blank">https://slack.com获得自己的工作空间。</a></p><p id="30dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将创建一个所谓的经典应用程序，因此我们能够使用<a class="ae iu" href="https://api.slack.com/rtm" rel="noopener ugc nofollow" target="_blank">实时消息(RTM) </a> API。</p><p id="7e8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里可以创建一个经典的app<a class="ae iu" href="https://api.slack.com/apps?new_classic_app=1" rel="noopener ugc nofollow" target="_blank">。</a>确保不要只是创建一个新的Slack应用程序，因为它不支持实时消息。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/55c35403b4bf7528422c349cbd8d226f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XV1ZOL18rZcLBCDaKbO4rg.png"/></div></div></figure><p id="8e6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该应用程序将需要以下范围，机器人和聊天:写:机器人。如果你没有找到这些范围，你可能在最后一步创建了一个非经典的应用程序。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/3e0261e4007997ff4cb06d32960cdddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9BWYqSsFtrMcBnnAM-Lfxg.png"/></div></div></figure><p id="afeb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将为应用程序添加描述和图标。对于我的机器人，我使用了来自维基媒体的图片。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/91be72ae9750212e56f082b71a347378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIGelktaTrx5J27GLxEAmA.png"/></div></div></figure><p id="1e20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一步是将应用程序安装到工作区，记下bot令牌，单击“将应用程序安装到您的团队”。我们将允许应用程序访问我们的工作区，并记下“Bot用户OAuth访问令牌”。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/591d3ac0f41ae6ca9020ad5fb443576c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyTeg3oNUYcN8fy8CRz1hQ.png"/></div></div></figure><h1 id="50bf" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">ChatOps服务器</h1><p id="c20c" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">该服务器的代码可以在https://gitlab.com/alexk/chatops-kubernetes<a class="ae iu" href="https://gitlab.com/alexk/chatops-kubernetes" rel="noopener ugc nofollow" target="_blank">找到。它需要python 3，例如可以在macOs上安装<code class="du lk ll lm ln b"><em class="lo">brew install python3</em></code>。</a></p><p id="2f7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后下载并安装需求</p><pre class="ju jv jw jx fd lu ln lv lw aw lx bi"><span id="c7a2" class="ly jz hi ln b fi lz ma l mb mc"><em class="lo">git clone git@gitlab.com:alexk/chatops-kubernetes.git</em></span><span id="ab66" class="ly jz hi ln b fi md ma l mb mc"><em class="lo">cd chatops-kubernetes/</em></span><span id="4c52" class="ly jz hi ln b fi md ma l mb mc"><em class="lo">pip3 install -r requirements.txt</em></span></pre><p id="f3c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，设置要与一起使用的松弛令牌</p><pre class="ju jv jw jx fd lu ln lv lw aw lx bi"><span id="850c" class="ly jz hi ln b fi lz ma l mb mc"><em class="lo">export SLACK_API_TOKEN=&lt;Your Slack token starts with xoxb-…&gt;</em></span></pre><p id="9b55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并启动聊天机器人服务器</p><pre class="ju jv jw jx fd lu ln lv lw aw lx bi"><span id="bc4a" class="ly jz hi ln b fi lz ma l mb mc"><em class="lo">python3 chatbot.py</em></span></pre><h1 id="4b45" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">ChatOps服务器</h1><p id="6386" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">正如在设置部分所讨论的，我们将利用Slack中的实时消息传递功能。要使用这一功能，我们必须创建一个经典应用程序。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/06244fc50ffc3f1a188592b8d7d4dc11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*DyHudQb7km_TcTs0a4GYvw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用WebSockets的经典Slack应用实时消息模型</figcaption></figure><p id="2095" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在当前的Slack应用模型中，Slack为每个聊天消息或命令向chatbot服务器发送HTTP Post消息。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/d1fe54da40c16cb1a7645a37ff9e4ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*GBKQ3VQEVK3uaVQOpxhtog.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用HTTP POSTS的现代Slack应用程序模型</figcaption></figure><p id="c834" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，在ChatOps的背景下，经典应用程序允许我们使用WebSockets连接到Slack。我们的chatbot服务器将对Slack端点使用HTTP GET调用。Slack服务器将保持连接开放，并向我们的聊天机器人传输更新。</p><p id="2df4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着我们不需要在DevOps基础架构上打开一个传入端点。相反，我们将使用传出连接。</p><p id="ea37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于ChatOps服务器通常以提升的权限运行，因此很难向外界开放端口。通过使用经典应用程序和websockets连接，我们关闭了网络犯罪分子的另一个攻击角度。</p><p id="7332" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">服务器将支持4个命令</p><p id="dd28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm ln b">set-app </code>为用户设置应用程序。因此，我们不需要在每次使用另一个命令时都提供应用程序名称。保护访问安全的一个简单方法是只允许admin用户执行这个命令。</p><p id="ff65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm ln b">get-app </code>为用户获取应用程序</p><p id="ddb3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm ln b">logs</code>和<code class="du lk ll lm ln b">describe</code>检索pod上所选应用程序的日志和信息。</p><p id="4c6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了存储选定的应用程序，我们将在db.py模块中使用一个嵌入式<a class="ae iu" href="https://www.sqlite.org/index.html" rel="noopener ugc nofollow" target="_blank"> sqllite3 </a>数据库。</p><p id="8b83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主事件循环如下所示:</p><pre class="ju jv jw jx fd lu ln lv lw aw lx bi"><span id="a242" class="ly jz hi ln b fi lz ma l mb mc">@RTMClient.run_on(event="message")  # subscribe to 'message' events<br/>def process_command(**payload):<br/>    data = payload['data']<br/>    web_client = payload['web_client']<br/>    print(payload)<br/>    # ignore service messages, like joining a channel<br/>    is_service = 'subtype' in data and data['subtype'] is not None<br/><br/>    if not is_service and 'text' in data:<br/>        channel_id = data['channel']<br/>        thread_ts = data['ts']<br/>        user = data['user']<br/>        text = data['text']  # get data from the event<br/>        tokens = text.split()  # split it up by space characters<br/>        me = tokens[0]  # user id of the cht bot<br/>        # object to track the conversation state<br/>        conv = Conversation(web_client, channel_id, user)<br/>        if len(tokens) &gt; 1:<br/>            print(tokens)<br/>            # first token is my userid, second will be the command e.g. logs<br/>            command = tokens[1]<br/>            print('received command ' + command)<br/>            if command in commands:<br/>                # get the actual command executor<br/>                command_func = commands[command]<br/>                try:<br/>                    args = tokens[slice(2, len(tokens))]<br/>                    # execute the command<br/>                    result = command_func(conv, args)<br/>                    if result is not None:<br/>                        # and return the value from the <br/>                        # command back to the user<br/>                        conv.msg(result)<br/>                except Exception as e:<br/>                    conv.msg(str(e))<br/><br/>            else:<br/>                # show welcome message<br/>                web_client.chat_postMessage(<br/>                    conv.msg(welcome.format(user=user, me=me))<br/>                )<br/>        else:<br/>            # show welcome message<br/>            conv.msg(welcome.format(user=user, me=me))</span></pre><p id="bfbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它被注释为<code class="du lk ll lm ln b">@RTMClient.run_on(event=”message”)</code>，每次在当前聊天中发送消息时，Python Slack客户端都会调用这个消息。</p><p id="59f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了确保我们没有收到我们自己的消息和服务消息(“…已经加入对话”)，我们使用这行代码<code class="du lk ll lm ln b">is_service = ‘subtype’ in data and data[‘subtype’] is not None</code></p><p id="fae6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">获得消息后，我们将它转换成令牌，并获得每个命令的实际处理程序，然后单个命令将解析传入的参数。例如，set-app命令将为用户将应用程序存储在db中。为了实现这一点，我们使用了<code class="du lk ll lm ln b">os.popen(cmd)</code></p><pre class="ju jv jw jx fd lu ln lv lw aw lx bi"><span id="c480" class="ly jz hi ln b fi lz ma l mb mc">def logs(pod, namespace):<br/>    cmd = f'kubectl logs  {pod} --namespace={namespace}'<br/>    print(f'Executing {cmd}')<br/>    stream = os.popen(cmd)<br/>    return stream.read()</span></pre><h1 id="4e23" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="353f" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">使用Slack客户端支持的实时消息API，我们能够构建一个简单的聊天机器人来执行kubernetes命令。聊天机器人也可以使用Slack中的现代POST事件来构建。如果您对那个API感兴趣，请告诉我，我会添加一篇后续文章。</p><p id="2e53" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一步是通过建立一个授权模型来提高安全性，以使它能够像ChatOps bot一样工作。当编排多个DevOps工具时，实现一个DevOps API可能是有意义的，它处理实际的编排并提供一个公共接口。该接口可用于构建多通道DevOps工具集，例如仪表板和ChatOps。</p></div></div>    
</body>
</html>