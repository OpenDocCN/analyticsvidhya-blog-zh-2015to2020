<html>
<head>
<title>Image Manipulations using OpenCV, Numpy and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCV、Numpy和Python进行图像处理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/images-manipulations-using-opencv-numpy-and-python-2e5538d35614?source=collection_archive---------8-----------------------#2020-06-27">https://medium.com/analytics-vidhya/images-manipulations-using-opencv-numpy-and-python-2e5538d35614?source=collection_archive---------8-----------------------#2020-06-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/bbb271e65adbd039a8824e7884691308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*JQofwNWO5ancK5ug2ezDgw.png"/></div></figure><p id="ba79" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi jk translated"><span class="l jl jm jn bm jo jp jq jr js di"> O </span> <strong class="io hj"> penCV </strong>由<strong class="io hj">加里·布拉德斯基</strong>于1999年在英特尔创立，第一版于2000年发布。Vadim Pisarevsky 加入Gary Bradsky，管理英特尔的俄罗斯软件OpenCV团队。2005年，OpenCV被用在Stanley上，这辆车赢得了2005年DARPA大挑战赛。后来，在Gary Bradsky和Vadim Pisarevsky领导的Willow Garage的支持下，该项目继续积极发展。OpenCV现在支持大量与计算机视觉和机器学习相关的算法，并且每天都在扩展</p><p id="1ff9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi jk translated">ython是一种通用编程语言，由吉多·范·罗苏姆创立，很快变得非常流行，主要是因为它的简单性和代码可读性。它使程序员能够用更少的代码行表达思想，而不降低可读性</p><p id="5b5e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">图像操作是很好理解OpenCV的非常基本的概念。在这里，我试图以一种简单易懂的方式介绍OpenCV的一些概念。</p><p id="b00a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">来开发OpenCV。首先，检查是否安装了OpenCV。打开新的Jupiter笔记本，键入following并运行。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="da6f" class="kc kd hi jy b fi ke kf l kg kh">import cv2<br/>print(cv2.__version__)</span></pre><p id="3280" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果输出是OpenCV的一个版本，则安装OpenCV。如果没有，执行以下命令。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="ed35" class="kc kd hi jy b fi ke kf l kg kh">pip install opencv-python<br/>pip install opencv-contrib-python</span></pre><p id="a8a9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在再次运行上面的命令来检查OpenCV是否成功安装</p><p id="2016" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在在下一个单元格中导入所需的库</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f98d" class="kc kd hi jy b fi ke kf l kg kh">import cv2<br/>import numpy as np</span></pre><h1 id="92c1" class="ki kd hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak"> <em class="lf">图片翻译</em> </strong></h1><p id="adbf" class="pw-post-body-paragraph im in hi io b ip lg ir is it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj hb bi translated">翻译很简单。它基本上是在一个方向(左，右，上，下和对角线)移动图像。要进行翻译，我们需要翻译矩阵。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2727" class="kc kd hi jy b fi ke kf l kg kh">T = [[1 0 x],<br/>      [0 1 y]] #Translation Matrix</span></pre><p id="7f5d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> X </strong>表示沿X轴移动，<strong class="io hj"> Y </strong>表示沿Y轴移动</p><p id="a805" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，读取图像</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="403b" class="kc kd hi jy b fi ke kf l kg kh">image = cv2.imread('image.jpg')<br/>cv2.imshow('image',image)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/927323c574f9ac138c1fd43746f79639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Beh2_z9oS3uNbeNqAYNZNw.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">实际图像</figcaption></figure><p id="ef91" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在对图像进行平移</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="487f" class="kc kd hi jy b fi ke kf l kg kh">image = cv2.imread('image.jpg')<br/>height, width = image.shape[:2]<br/>wrap_x, wrap_y = 100,100<br/>T= np.float32([[1, 0, wrap_x],[0, 1, wrap_y]])<br/>img_trans = cv2.warpAffine(image,T,(width,height))<br/>cv2.imshow('image',img_trans)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lu"><img src="../Images/5f714faf5b576920ef8133ae61b40f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZn4r8H1kmXePzdoBmR6HQ.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">对角翻译</figcaption></figure><p id="57cf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以通过改变<strong class="io hj">翻译矩阵</strong>中的值来获得不同的翻译。</p><h1 id="9a9b" class="ki kd hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">旋转</strong></h1><p id="6137" class="pw-post-body-paragraph im in hi io b ip lg ir is it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj hb bi translated">OpenCV允许我们一次旋转和缩放。我们使用<strong class="io hj">旋转矩阵</strong>进行图像旋转。</p><blockquote class="lv lw lx"><p id="601e" class="im in ly io b ip iq ir is it iu iv iw lz iy iz ja ma jc jd je mb jg jh ji jj hb bi translated">语法:cv2.getRotationMatrix2D(center，angle，scale) <br/>语法:cv2.warpAffine(src，Matrix，dsize，dst，flags，borderMode，borderValue)</p></blockquote><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="bb55" class="kc kd hi jy b fi ke kf l kg kh">image = cv2.imread('image.jpg')<br/>height, width = image.shape[:2]<br/>rotation_matrix = cv2.getRotationMatrix2D((width/2,height/2),90,1)<br/>img_rotated = cv2.warpAffine(image,rotation_matrix,(width,height))<br/>cv2.imshow('image',img_rotated)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><p id="459c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">90表示图像逆时针旋转多少，1表示缩放。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mc"><img src="../Images/75157a8b40ed679e24ede0718f01b399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsBCRM7E9wT_QlazacBErw.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">旋转图像</figcaption></figure><h1 id="a2b0" class="ki kd hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">调整图像大小</h1><p id="93a1" class="pw-post-body-paragraph im in hi io b ip lg ir is it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj hb bi translated">调整图像大小是OpenCV的技术之一。这使得图像在磁盘中占用较少的空间。插值是调整图像大小的一种更好的方法。</p><p id="4bd3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">插值:</strong>是在一组离散的已知数据点的范围内构造新的数据点的方法。</p><p id="231b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">插值是可选的。插值有不同的类型。它采用以下方法之一。INTER _ NEAREST最近邻插值INTER _ LINEAR双线性插值(默认情况下使用)INTER _ AREA使用像素面积关系进行重采样。这可能是图像抽取的优选方法，因为它给出了无波纹的结果。但是当图像被缩放时，它类似于INTER_NEAREST方法。INTER _ CUBIC-4×4像素邻域内的双三次插值INTER _ LANCZOS 4-8×8像素邻域内的lanc zos插值。</p><blockquote class="lv lw lx"><p id="4e14" class="im in ly io b ip iq ir is it iu iv iw lz iy iz ja ma jc jd je mb jg jh ji jj hb bi translated">语法: cv2.resize(src，dsize，fx，fy，interpolation)</p></blockquote><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c71f" class="kc kd hi jy b fi ke kf l kg kh">image = cv2.imread('image.jpg')<br/>image_scaled = cv2.resize(image,None,fx=0.75,fy=0.75)<br/>cv2.imshow('image Scalled',image_scaled)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span><span id="6257" class="kc kd hi jy b fi md kf l kg kh">#interpolation<br/>#increasing size of image<br/>img_scl=cv2.resize(image,None,fx=2,fy=2,interpolation=cv2.INTER_CUBIC)<br/>cv2.imshow('image Scalled',img_scl)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span><span id="440e" class="kc kd hi jy b fi md kf l kg kh">#Resizing the image to specific size<br/>image_scaled = cv2.resize(image,(700,540),interpolation=cv2.INTER_AREA) <br/>cv2.imshow('image Scalled',image_scaled)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><h1 id="e91c" class="ki kd hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">种植</h1><p id="d4ea" class="pw-post-body-paragraph im in hi io b ip lg ir is it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj hb bi translated">从图像中裁剪出特定的片段是如此简单。我们可以直接给出图像中的起点和终点来裁剪某个片段。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="9941" class="kc kd hi jy b fi ke kf l kg kh">image = cv2.imread('image.jpg')<br/>height, width = image.shape[:2]</span><span id="62b1" class="kc kd hi jy b fi md kf l kg kh">start_row,start_col =int(height * 0.25), int(width * 0.25)<br/>end_row,end_col = int(height * 0.75),int( width * 0.75)<br/>crop = image[start_row:end_row,start_col:end_col]</span><span id="d725" class="kc kd hi jy b fi md kf l kg kh">cv2.imshow('actual image', image)<br/>cv2.waitKey(0)<br/>cv2.imshow('cropped image',crop)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es me"><img src="../Images/6c44b8a83037ebd9953532e3ca919827.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*4M-21MRgIA6riCoEO8M0lA.jpeg"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">裁剪图像</figcaption></figure><h1 id="69a3" class="ki kd hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">变亮和变暗</h1><p id="0767" class="pw-post-body-paragraph im in hi io b ip lg ir is it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj hb bi translated">我们可以简单地通过在图像矩阵的每个元素上加/减一个值来使图像变亮或变暗。该值必须介于0和255之间。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="788d" class="kc kd hi jy b fi ke kf l kg kh">image = cv2.imread('image.jpg')</span><span id="c772" class="kc kd hi jy b fi md kf l kg kh">value =100<br/>mat = np.ones(image.shape,dtype = 'uint8')*value</span><span id="66cd" class="kc kd hi jy b fi md kf l kg kh">brighter = cv2.add(image,mat)<br/>cv2.imshow('brighter',brighter)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mc"><img src="../Images/0fe53dc0b1d55458aaf4416d4f21e633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nfBNF6I6x9F05CbKcuRjPw.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">增亮图像</figcaption></figure><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="e8a6" class="kc kd hi jy b fi ke kf l kg kh">image = cv2.imread('image.jpg')</span><span id="f8ed" class="kc kd hi jy b fi md kf l kg kh">value =100<br/>mat = np.ones(image.shape,dtype = 'uint8')*value<br/>subtract = cv2.subtract(image,mat)<br/>cv2.imshow('subtract',subtract)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mc"><img src="../Images/52a0e6229829747ab1046d89499b5c42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lR7BdpOqZj5X1QOPNp5gzw.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">变暗图像</figcaption></figure><h1 id="809e" class="ki kd hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">位运算</h1><p id="a8e8" class="pw-post-body-paragraph im in hi io b ip lg ir is it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj hb bi translated">按位运算有助于图像蒙版。理解位运算。让我们建立一些形状。</p><p id="6e5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">广场</strong></p><blockquote class="lv lw lx"><p id="1ce5" class="im in ly io b ip iq ir is it iu iv iw lz iy iz ja ma jc jd je mb jg jh ji jj hb bi translated"><strong class="io hj">语法:</strong> cv2.rectangle(图像，起点，终点，颜色，粗细)</p></blockquote><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3a01" class="kc kd hi jy b fi ke kf l kg kh">image=np.zeros((300,300),np.uint8)<br/>cv2.rectangle(image,(50,50),(250,250),255,-2)<br/>cv2.imshow('square',image)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/7ec45ed1145e2efcbd7efe30ce64c026.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*yGYI2ZDx74NgJ2YmLbzi-A.png"/></div></figure><p id="9091" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">椭圆</strong></p><blockquote class="lv lw lx"><p id="f031" class="im in ly io b ip iq ir is it iu iv iw lz iy iz ja ma jc jd je mb jg jh ji jj hb bi translated"><strong class="io hj">语法:</strong> cv2.ellipse(图像、中心坐标、轴长度、角度、起始角度、终止角度、颜色、厚度)</p></blockquote><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="ed58" class="kc kd hi jy b fi ke kf l kg kh">image=np.zeros((300,300),np.uint8)<br/>cv2.ellipse(image,(150,150),(150,150),30,0,180,255,-1)<br/>cv2.imshow('Eclipse',image)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/021e9fd58516b667a671427199302c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*lSr8nt6o9Lcz34Ppioaf-g.png"/></div></figure><p id="ce07" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在应用位运算(AND，OR，XOR，NOT)来更清楚地理解上面的形状</p><p id="f0e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">按位与</strong></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="00a6" class="kc kd hi jy b fi ke kf l kg kh">And = cv2.bitwise_and(square,image)<br/>cv2.imshow('And',And)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/d98ffbb581d47940170379275337c850.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*9mcZWrq8m9yACxwHNMb4vg.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">和</figcaption></figure><p id="9010" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">按位或</strong></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b42b" class="kc kd hi jy b fi ke kf l kg kh">Or = cv2.bitwise_or(square,image)<br/>cv2.imshow('OR',Or)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/c7e648445bc4de05a1c5bb10f08d798b.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*3UueDmJUUXNqyKlwZKdGqQ.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">运筹学</figcaption></figure><p id="804c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">按位异或</strong></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="8284" class="kc kd hi jy b fi ke kf l kg kh">xor = cv2.bitwise_xor(square,image)<br/>cv2.imshow('XOR',xor)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/aa23e231a757b921da6f86099dbdd205.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*ieLDoMt_6VNws2pAS-L3mg.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">异或运算</figcaption></figure><p id="d31b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">按位非</strong></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="069b" class="kc kd hi jy b fi ke kf l kg kh">Not = cv2.bitwise_not(square)<br/>cv2.imshow('Not',Not)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/3a1c85942ef38d405447ad027135879f.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*4y3V6bAl8aszjvHx1oCX1g.jpeg"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">不</figcaption></figure><p id="733b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些是OpenCV的一些图像操作的概念。你可以在我的GitHub repo <a class="ae ml" href="https://github.com/venku2208/OpenCV/blob/master/image%20manipulations/Image%20Manipulations.ipynb" rel="noopener ugc nofollow" target="_blank">中找到完整的代码。如果你有任何疑问，请随时留下评论。</a></p></div></div>    
</body>
</html>