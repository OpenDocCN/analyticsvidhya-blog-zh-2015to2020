<html>
<head>
<title>Categorical Variable Encoding Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分类变量编码技术</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/categorical-variable-encoding-techniques-17e607fe42f9?source=collection_archive---------0-----------------------#2020-02-23">https://medium.com/analytics-vidhya/categorical-variable-encoding-techniques-17e607fe42f9?source=collection_archive---------0-----------------------#2020-02-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="94d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分类变量是指有两个或更多类别(值)的变量。分类变量有两种类型，<strong class="ih hj">名词性</strong>和<strong class="ih hj">序数</strong>。一个名义变量对其类别没有内在的排序。例如，性别是一个具有两个类别(男性和女性)的分类变量，这些类别没有内在的顺序。序数变量有明确的顺序。</p><p id="92f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多ML算法不能直接对分类或标签数据进行操作。但是，决策树可以直接从这些数据中学习。因此，它们要求所有输入变量和输出变量都是数字。这意味着分类数据必须转换成数字形式。</p><p id="0062" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分类变量编码的几种类型有:</p><ol class=""><li id="4cd6" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">一个热编码</strong>:用不同的布尔变量(也称为哑变量)对每个分类变量进行编码，布尔变量取值为0或1，表示某个类别是否出现在观察中。</li></ol><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es jm"><img src="../Images/4390d3714fea279a4c5527d503d79e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*vk4VIVzU9MO6zmnpHTusCA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">一键编码</figcaption></figure><p id="a861" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">整数编码/标签编码</strong>:用1到n(或0到n-1，取决于实现)的数字替换类别，其中n是变量的不同类别的数量。</p><p id="824c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj">计数或频率编码</strong>:用数据集中显示类别的观察值的计数替换类别。类似地，我们可以用数据集中观察值的频率或百分比来代替类别。也就是说，如果我们100次观察中有10次显示蓝色，如果进行计数编码，我们将用10代替蓝色，如果用频率代替，则用0.1代替蓝色。</p><p id="bd03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.<strong class="ih hj">有序整数编码</strong>:类别由整数1到k代替，其中k是变量中不同的类别，但这种编号是由每个类别的目标决定的。在下面的示例中，绿色的目标平均值为0，红色的目标平均值为0.5，黄色的目标平均值为1。因此黄色被1代替，红色被2代替，绿色被3代替。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es jy"><img src="../Images/4d2df1ce20678b0e3dc46f6a2214c894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*Q7dR37XB-ndJLCQDdQZFkw.png"/></div></figure><p id="9943" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.<strong class="ih hj">使用“证据权重”编码</strong>:每个类别将被[p(1)/p(0)]的自然对数代替，其中p(1)是类别变量中每个类别的好目标变量的概率，p(0)是坏目标变量的概率。在著名的“<strong class="ih hj">泰坦尼克号</strong>”<strong class="ih hj"/>数据集中，分类变量之一，“<strong class="ih hj">船舱</strong>”<strong class="ih hj"/>可以编码如下，假设“<strong class="ih hj">幸存</strong>”为目标变量。<strong class="ih hj"> p(1) </strong>是每个类别的存活概率<strong class="ih hj"> p(0) </strong>是死亡概率。<strong class="ih hj">注意:WoE非常适合于逻辑回归，因为Logit变换只是概率的对数，即ln(P(货物)/P(货物))。</strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es jz"><img src="../Images/233ef95bbf5641c0c96b0c47e16fa5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*tCDfdEZA9G7zHZV3bGvCfA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">证据的重要性</figcaption></figure></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="0be1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们继续用python实现上述技术:</p><p id="54e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导入所需的库，并在加载“titanic”数据集后做一些预处理来删除空值</p><pre class="jn jo jp jq fd kh ki kj kk aw kl bi"><span id="2ce7" class="km kn hi ki b fi ko kp l kq kr">import numpy as np #for numpy operations<br/>import pandas as pd #for creating DataFrame using Pandas <br/># to split the dataset using sklearn <br/>from sklearn.model_selection import train_test_split<br/># load titanic dataset<br/>data = pd.read_csv('titanic.csv',<br/>                   usecols=['sex', 'embarked', 'cabin', 'survived'])<br/># let's capture only the first letter of the <br/># cabin for this demonstration<br/>data['cabin'] = data['cabin'].fillna('Missing')<br/>data['cabin'] = data['cabin'].str[0]</span><span id="3461" class="km kn hi ki b fi ks kp l kq kr">data.head()</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es kt"><img src="../Images/4b96cdea3f774d84f70a188a05a9568b.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*qOt0vGyQyBHAPgw_7bQAtQ.png"/></div></figure><h1 id="2325" class="ku kn hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一个热编码</h1><p id="6f15" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">熊猫库中的get_dummies 会做如下所示的编码工作。它将使用0和1为每个类别创建额外的列，以指示该类别是否存在。如果类别存在，则用1表示，否则用0表示。</p><pre class="jn jo jp jq fd kh ki kj kk aw kl bi"><span id="d113" class="km kn hi ki b fi ko kp l kq kr">pd.get_dummies(data)</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es lw"><img src="../Images/dfde97f24edf81892c0798048104cb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Rsry-efXzt23tOpMxBcmg.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">独热编码列</figcaption></figure><p id="f347" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">限制:它会随着列数的增加而扩展维度，这可能会导致训练时数据过度拟合。</p><h1 id="0b5c" class="ku kn hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">整数编码/标签编码</strong></h1><p id="e952" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">要替换列中的每个类别，我们必须创建一个字典，其中每个类别都有键，每个类别的值都是任意数字。然后，每个类别可以映射到列中字典中定义的数字。这可以通过使用以下两个函数来实现:</p><pre class="jn jo jp jq fd kh ki kj kk aw kl bi"><span id="ded4" class="km kn hi ki b fi ko kp l kq kr"># Returns dictionary having key as category and values as number<br/>def find_category_mappings(data, variable):<br/>    return {k: i for i, k in enumerate(data[variable].unique())}</span><span id="77ae" class="km kn hi ki b fi ks kp l kq kr"># Returns the column after mapping with dictionary<br/>def integer_encode(data,variable, ordinal_mapping):<br/>    data[variable] = data[variable].map(ordinal_mapping)</span><span id="0bae" class="km kn hi ki b fi ks kp l kq kr">for variable in ['sex','cabin','embarked']:<br/>    mappings = find_category_mappings(data,variable)<br/>    integer_encode(data, variable, mappings)</span><span id="5cee" class="km kn hi ki b fi ks kp l kq kr">data.head()</span></pre><p id="b639" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数"<strong class="ih hj"> find_category_mapping" </strong>会返回字典:</p><pre class="jn jo jp jq fd kh ki kj kk aw kl bi"><span id="4e04" class="km kn hi ki b fi ko kp l kq kr">{‘male’: 0, ‘female’: 1} <strong class="ki hj">=&gt; 'sex'</strong><br/>{‘M’: 0, ‘C’: 1, ‘E’: 2, ‘G’: 3, ‘D’: 4, ‘A’: 5, ‘B’: 6, ‘F’: 7, ‘T’: 8}  <strong class="ki hj">=&gt; 'cabin'</strong><br/>{‘S’: 0, ‘C’: 1, ‘Q’: 2, nan: 3}  <strong class="ki hj">=&gt; 'embarked'</strong></span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mb"><img src="../Images/6f072d25d10f4a265936cddf89934951.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*1N4iFhyOesPfDyyKir4yUg.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">整数/标签编码列</figcaption></figure><p id="b68e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">限制:标签编码不适合像逻辑回归这样的线性模型。</p><h1 id="be19" class="ku kn hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">计数或频率编码</strong></h1><p id="afc3" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">第一步是创建字典，其中键作为类别，值作为该类别的频率(或计数)。然后，使用字典将类别替换为计数</p><pre class="jn jo jp jq fd kh ki kj kk aw kl bi"><span id="fa0b" class="km kn hi ki b fi ko kp l kq kr"># create the dictionary<br/>count_map_sex = data['sex'].value_counts().to_dict()<br/>count_map_cabin = data['cabin'].value_counts().to_dict()<br/>count_map_embark = data['embarked'].value_counts().to_dict()<br/># Map the column with dictionary<br/>data['sex'] = data['sex'].map(count_map_sex)<br/>data['cabin'] = data['cabin'].map(count_map_cabin)<br/>data['embarked'] = data['embarked'].map(count_map_embark)<br/>data.head()</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mc"><img src="../Images/9692f42a698182958062e72307bbd9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*0156MvjnwxvpZDJ0A1052w.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">计数/频率编码</figcaption></figure><p id="8e6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">限制:如果两个不同的类别在数据集中出现相同的次数，也就是说，它们出现在相同数量的观察值中，它们将被相同的数量所取代，因此，可能会丢失有价值的信息。</p><h1 id="be4a" class="ku kn hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">有序整数编码</strong></h1><p id="2f1d" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">首先计算column中每个类别的目标均值(在Pandas中使用<strong class="ih hj"> groupby() </strong>)并排序。将数值按升序分配给目标平均值。目标平均值越低，数值越低，反之亦然。</p><pre class="jn jo jp jq fd kh ki kj kk aw kl bi"><span id="77c5" class="km kn hi ki b fi ko kp l kq kr">def find_category_mappings(data, variable, target):<br/>    # first  we generate an ordered list with the labels<br/>    ordered_labels = data.groupby([variable])[target].mean().sort_values().index<br/>    # return the dictionary with mappings<br/>    return {k: i for i, k in enumerate(ordered_labels, 0)}</span><span id="38f1" class="km kn hi ki b fi ks kp l kq kr">def integer_encode(data,variable, ordinal_mapping):<br/>    data[variable] = data[variable].map(ordinal_mapping)</span><span id="a668" class="km kn hi ki b fi ks kp l kq kr">data.head()</span></pre><p id="886a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数<strong class="ih hj">find _ category _ mapping()</strong>将根据每个类别的<strong class="ih hj">排序目标均值</strong>返回以下字典</p><pre class="jn jo jp jq fd kh ki kj kk aw kl bi"><span id="70ed" class="km kn hi ki b fi ko kp l kq kr">{'male': 0, 'female': 1} <strong class="ki hj">=&gt; 'sex'</strong><br/>{'T': 0, 'M': 1, 'A': 2, 'G': 3, 'C': 4, 'F': 5, 'B': 6, 'E': 7, 'D': 8}  <strong class="ki hj">=&gt; 'cabin'</strong><br/>{'S': 0, 'Q': 1, 'C': 2} <strong class="ki hj">=&gt; 'embarked'</strong></span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es md"><img src="../Images/757d342b0609ffbad86ec7356613c207.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*Bk7K67ZV-M4QaBnxCvsDiw.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">有序整数编码</figcaption></figure><p id="0bfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">局限性:容易造成过拟合</p><h1 id="0d96" class="ku kn hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">编码使用“证据权重”</strong></h1><p id="8d7f" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">对于“cabin”列，计算每个类别存活= 1和存活= 0的概率(类似于其他分类列)。</p><pre class="jn jo jp jq fd kh ki kj kk aw kl bi"><span id="75fb" class="km kn hi ki b fi ko kp l kq kr">#probability of survived = 1<br/>prob_df = data.groupby(['cabin'])['survived'].mean()<br/># and capture it into a dataframe<br/>prob_df = pd.DataFrame(prob_df)</span><span id="2aad" class="km kn hi ki b fi ks kp l kq kr"># and now the probability of survived = 0<br/># (probability of non-events or p(0))</span><span id="36fc" class="km kn hi ki b fi ks kp l kq kr">prob_df['died'] = 1-prob_df['survived']</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es me"><img src="../Images/f330047bf46300671a90559042037a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*iOvISAUApRuMexR1O_90tg.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">“客舱”栏中每个类别的p(1)和p(0)</figcaption></figure><p id="69e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算“证据权重”:</p><pre class="jn jo jp jq fd kh ki kj kk aw kl bi"><span id="f85b" class="km kn hi ki b fi ko kp l kq kr">prob_df['ratio'] = np.log( prob_df['survived'] / prob_df['died'] )</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mf"><img src="../Images/0f287ab230471a41f6d84ec126aae9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*QkVr6JyKj8zQxt2dhBVS4A.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">证据的重要性</figcaption></figure><p id="3435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在计算了WoE之后，可以在字典中捕获它，并且可以映射到‘cabin’列。</p><p id="5fb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我定义了两个函数来执行上述所有步骤:</p><pre class="jn jo jp jq fd kh ki kj kk aw kl bi"><span id="76e5" class="km kn hi ki b fi ko kp l kq kr"># Encoding using WoE<br/>def find_category_mappings(data, variable, target):<br/>    tmp = pd.DataFrame(data.groupby([variable])[target].mean())<br/>    tmp['non-target'] = 1 - tmp[target]<br/>    tmp['ratio'] = np.log( tmp[target] / tmp['non-target'] )<br/>    return tmp['ratio'].to_dict()</span><span id="fa12" class="km kn hi ki b fi ks kp l kq kr">def integer_encode(data, variable, ordinal_mapping):<br/>    data[variable] = data[variable].map(ordinal_mapping)</span><span id="c5ca" class="km kn hi ki b fi ks kp l kq kr">for variable in ['sex','cabin','embarked']:<br/>    mappings = find_category_mappings(data, variable, 'survived')<br/>    integer_encode(data,variable, mappings)</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mg"><img src="../Images/46991307afd12edfd34417ee3b14a6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*AUU63JONgiq2H7cfj4Kl4w.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">使用证据权重的编码</figcaption></figure><p id="a118" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">局限性:也容易造成过拟合</p><h1 id="0c7c" class="ku kn hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">结论</strong></h1><p id="a6ff" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">由于处理任何数据集中的分类变量都是特征工程中的关键步骤，因此可以根据模型的类型应用上述任何技术。有些技术与线性模型(如逻辑回归)一起使用效果更好，而有些技术与非线性模型(如决策树)一起使用效果更好。如果有更少的类别，并且是<strong class="ih hj">名义上的</strong>分类数据，那么<strong class="ih hj">一键编码</strong>就可以了。如果作为自变量和因变量(目标变量)的任何分类列之间的关系很重要，那么可以应用<strong class="ih hj">有序整数编码</strong>。对于<strong class="ih hj">序数</strong>分类数据，只需使用<strong class="ih hj">标签编码</strong>即可。</p><p id="9cd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你喜欢文章:)</p></div></div>    
</body>
</html>