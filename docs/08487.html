<html>
<head>
<title>Are you making this mistake? How to perform data normalization in your models.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你在犯这个错误吗？如何在您的模型中执行数据规范化。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-effect-of-data-normalization-in-your-models-should-we-use-a-pipeline-6b97510f1908?source=collection_archive---------14-----------------------#2020-07-31">https://medium.com/analytics-vidhya/the-effect-of-data-normalization-in-your-models-should-we-use-a-pipeline-6b97510f1908?source=collection_archive---------14-----------------------#2020-07-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0291" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你已经使用Scikit-learn有一段时间了，你可能已经在某个地方听说过<strong class="ih hj">管道</strong>有多好和多安全。Pipeline是一个Scikit-learn函数，用于聚合数据预处理和模型训练/优化之间的所有步骤。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e8783d091902c970371d8f19c3ce17e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DHI4f8V5eC5KXMsXhqdinQ.jpeg"/></div></div></figure><p id="215c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将引用下图中的函数和库，你可以在这里找到完整的代码<a class="ae jp" href="https://colab.research.google.com/drive/1GE-kyeQA0bz27zKhf_6aQUKWqFK3R9rN#scrollTo=LmrsMHIJmZb4" rel="noopener ugc nofollow" target="_blank"/>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/a9bfe2466f62cd5a99cff6db7fcfbc5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*EVW6DHjwOdw3jf7Jefe2dA.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">这篇文章的一些有用的功能</figcaption></figure><p id="5250" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用管道的主要优势之一是数据标准化。数据标准化是许多机器学习分类器的重要步骤。对于一些基于距离的方法，如支持向量机(SVM)，最重要的是确保计算出的特征之间的距离不受大值的支配。对于其他的，如神经网络，可以大大提高训练和收敛时间。</p><p id="8aff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在使用标准化方法之前，最好将数据分成训练集和测试集。使用训练集来训练该方法，并且利用变换函数将该方法应用于测试集。这可以防止数据从训练集泄漏到测试集中，这可能会严重影响我们的结果。有关代码示例，请参见下图。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jv"><img src="../Images/6ffbd294923103ebf65541fce1762f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*m-AfWIHvqdllZ6AbFHd0CQ.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">标准标尺的通用惯例</figcaption></figure><p id="0971" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，下一步是为我们的分类器找到最佳参数。为此，我们经常使用一种网格搜索形式，要么是RandomizedSearchCV，要么是GridSearchCV。参见下图中的示例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jw"><img src="../Images/236c01596e3e311c7a136b72fb148098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cs1aV_6Wpl72NhvsYnsyCA.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated">数据标准化后的网格搜索实例</figcaption></figure><p id="c79b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，不使用管道会产生一个问题。GridSearch将只使用训练集，并将它分成<em class="jx"> N </em>个折叠(<em class="jx"> N </em>由<em class="jx"> cv </em>参数给出)。<em class="jx"> N-1个</em>折叠供用户训练，剩余的1个折叠用于测试和查看超参数的给定组合有多好。但是，当我们标准化数据时，我们没有考虑GridSearch步骤中会发生的分裂(内部交叉验证)。我们使用我们的整个训练集来训练标准化者，因此，在GridSearch期间生成的分裂不是100%独立的。该模型正在优化列车上的超参数，并在引入数据泄漏的地方进行验证分割，因此，我们的优化结果可能会有偏差。</p><p id="6627" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的测试集并没有受到这个小问题的影响，但是在GridSearch期间选择的超参数可能不会在测试集中得到推广，因为找到它们的过程并不是100%可信的。</p><p id="5a54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们使用Scikit-learn中的Pipeline类，这可以很容易地避免。在下图中，我们定义了GridSearch(标准化和要优化的分类器)期间管道中将要发生的每个步骤。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jy"><img src="../Images/cff18f2b6c61cafd8800f06d043ef22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*Gi3jXVBgG-Gh_3X54SRztA.png"/></div></div></figure><p id="aee1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的方法将保证GridSearch内部的分割以适当的方式完成，防止数据泄漏。</p><p id="7ca6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，使用或不使用管道的实际效果如何？为了展示这一点，我使用Pima Indians糖尿病数据库(来自ka ggle challenge:available<a class="ae jp" href="https://www.kaggle.com/uciml/pima-indians-diabetes-database" rel="noopener ugc nofollow" target="_blank">here</a>)和乳腺癌Wisconsin (Diagnostic)数据集(也来自Kaggle: available <a class="ae jp" href="https://www.kaggle.com/uciml/breast-cancer-wisconsin-data" rel="noopener ugc nofollow" target="_blank"> here </a>)创建了两个实验设置。</p><p id="dfca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于糖尿病数据集，目标是预测给定患者是否患有糖尿病。对于乳腺癌数据集，目标是将癌症分类为恶性或良性。</p><p id="8372" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用5重交叉验证拆分了两个数据集，对于每一次k重迭代，我使用和不使用管道对数据进行了标准化，并优化了超参数。对于每个k倍迭代，我记录了测试集的受试者操作特征曲线(AUC)下的面积和网格搜索产生的超参数。</p><p id="fe52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是代码，这样你可以很容易地理解它(要在Colab中运行它，你需要从上面提供的链接中的Kaggle下载数据):</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jz ka l"/></div></figure><h1 id="d276" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">结果— </strong>皮马印第安人糖尿病数据库</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kz"><img src="../Images/e9284c3f1bec777e51aad75bb3a46e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*kY_OmseJRyFif7Ux9Ppf7g.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">5重交叉验证的结果</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/31e503ff1c3901f9f3deb7d83f018152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*t5vOB-wNuLCYPI2fWd_wGQ.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">为每个k次迭代选择的超参数</figcaption></figure><h1 id="ff10" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">结果——乳腺癌威斯康星州</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lb"><img src="../Images/47eb6025a7aad4fa5aa2bd9c7f3aedd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*WFrnO4uKoPO5_cGYM4nNBQ.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">5重交叉验证的结果</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/a98a246dae1c4eb0982f92f0802c88db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*x4qzOXipePUXuGJaasqrmw.png"/></div></figure><p id="44dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我找不到使用管道或单独规范化数据之间的任何区别。两个数据集选择的AUC和超参数完全相同。当然，这可能是由于数据集本身(并不复杂)或所选择的模型*。</p><p id="0d03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，使用pipeline函数背后的理论推理无疑是正确的，它的使用不仅会使您的代码更干净、更易于维护，还会使您的代码更安全，不会出现过于乐观的结果。</p><p id="db67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">*你觉得代码有问题吗？你还想看另一个实验吗？请留言或给我发电子邮件。拉莫斯@amsterdamumc.nl</p></div></div>    
</body>
</html>