<html>
<head>
<title>Precision vs. Recall — An Intuitive Guide for Every Machine Learning Person</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">精确与回忆——每个机器学习者的直观指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/precision-vs-recall-an-intuitive-guide-for-every-machine-learning-person-796a6caa3842?source=collection_archive---------15-----------------------#2020-09-03">https://medium.com/analytics-vidhya/precision-vs-recall-an-intuitive-guide-for-every-machine-learning-person-796a6caa3842?source=collection_archive---------15-----------------------#2020-09-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="08db" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">概观</h1><ul class=""><li id="0ae2" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">精确度和召回率是机器学习中两个关键但被误解的主题</li><li id="0cac" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">我们将讨论什么是精确度和召回率，它们如何工作，以及它们在评估机器学习模型中的作用</li><li id="6345" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">我们还将了解曲线下面积(AUC)和精确度术语</li></ul><h1 id="f32f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="bf1f" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">向任何机器学习专业人士或数据科学家询问他们学习旅程中最容易混淆的概念。答案总是倾向于精确和回忆。</p><p id="a749" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">精确和回忆之间的区别实际上很容易记住——但只有当你真正理解了每个术语的含义之后。但是很多时候，我可以证明这一点，专家们倾向于提供不成熟的解释，这让新来者更加困惑。</p><p id="351f" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">所以让我们在这篇文章中澄清一下。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/5b19ee92d3b2087084fd67c2f53fa3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r46YHzjy2aqA2kMo.jpg"/></div></div></figure><p id="dd5c" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">对于任何机器学习模型，我们知道实现模型的“良好拟合”是极其重要的。这包括实现欠拟合和过拟合之间的平衡，或者换句话说，偏差和方差之间的权衡。</p><p id="1f0e" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">然而，当涉及到分类时，有另一个权衡常常被忽视，而偏向于<a class="ae lg" href="https://www.analyticsvidhya.com/blog/2020/08/bias-and-variance-tradeoff-machine-learning/?utm_source=blog&amp;utm_medium=precision_and_recall" rel="noopener ugc nofollow" target="_blank">偏差-方差权衡。</a>这是精度-召回的权衡。不平衡的类通常出现在数据集中，当涉及到特定的用例时，我们实际上希望更加重视精度和召回指标，以及如何实现它们之间的平衡。</p><p id="7e56" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">但是，怎么做呢？在本文中，我们将通过关注精确度和召回率来探索分类评估指标。我们还将学习如何通过一个数据集和一个简单的分类算法在Python中计算这些指标。所以，让我们开始吧！</p><p id="946c" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated"><em class="lh">你可以在这里深入了解评测指标- </em> <a class="ae lg" href="https://courses.analyticsvidhya.com/courses/evaluation-metrics-for-machine-learning-models?utm_source=blog&amp;utm_medium=precision_and_recall" rel="noopener ugc nofollow" target="_blank"> <em class="lh">机器学习模型评测指标</em> </a> <em class="lh">。</em></p><h1 id="1fae" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目录</h1><ol class=""><li id="066f" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq li js jt ju bi translated">理解问题陈述</li><li id="25ff" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">什么是精准？</li><li id="2dc2" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">什么是回忆？</li><li id="b433" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">最简单的评估指标——准确性</li><li id="7c6e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">F1分数的作用</li><li id="538b" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">著名的精确召回权衡</li><li id="8912" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">了解曲线下面积(AUC)</li></ol><h1 id="1cd8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">理解问题陈述</h1><p id="fdd3" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">我坚信边做边学。因此，在整篇文章中，我们将用实际术语来讨论——通过使用数据集。</p><p id="aad9" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">让我们来看看UCI资料库中流行的心脏病数据集。这里，我们必须预测患者是否患有心脏病，或者是否没有使用给定的特征集。你可以从<a class="ae lg" href="https://www.kaggle.com/ronitf/heart-disease-uci" rel="noopener ugc nofollow" target="_blank">这里</a>下载干净的数据集。</p><p id="cf87" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">由于本文只关注模型评估指标，我们将使用最简单的分类器kNN分类模型来进行预测。</p><p id="ee52" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">和往常一样，我们将从导入必要的库和包开始:</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="6486" class="lo ig hi lk b fi lp lq l lr ls">import numpy as np<br/>import pandas as pd<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.preprocessing import StandardScaler<br/>from sklearn.neighbors import KNeighborsClassifier<br/>from sklearn.metrics import confusion_matrix<br/>from sklearn.metrics import classification_report<br/>from sklearn.metrics import roc_curve<br/>from sklearn.metrics import roc_auc_score<br/>from sklearn.metrics import precision_recall_curve<br/>from sklearn.metrics import auc<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>%matplotlib inline</span></pre><p id="ddeb" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">然后，让我们来看看我们正在处理的数据和目标变量:</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="6a1b" class="lo ig hi lk b fi lp lq l lr ls">data_file_path = '../input/heart-disease-uci/heart.csv'<br/>data_df = pd.read_csv(data_file_path)<br/><br/>#To get information on the number of entries and the datatypes of the features<br/>data_df.head()</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lt"><img src="../Images/a8ef6fd1817ac1418f44fb06c23568c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BxoJe0gxqOU9bCmL.png"/></div></div></figure><p id="69ab" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">让我们检查一下是否有遗漏的值:</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="68d3" class="lo ig hi lk b fi lp lq l lr ls">data_df.isnull().sum()</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lu"><img src="../Images/360549fe8ac710c2ba9a38f72ee9fdb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/0*w9LKndA0dnwjaRfn.png"/></div></figure><p id="27c8" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">没有丢失的值。现在我们可以看看有多少患者实际上患有心脏病(1)，有多少没有(0):</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="1c0b" class="lo ig hi lk b fi lp lq l lr ls">#2. distribution of target variable.<br/>sns.countplot(data_df['target'])<br/><br/># Add labels<br/>plt.title('Countplot of Target')<br/>plt.xlabel('target')<br/>plt.ylabel('Patients')<br/>plt.show()</span></pre><p id="4280" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">这是下面的计数图:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lv"><img src="../Images/5ee316eeaed1efa20cb1b98dbebf4964.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*ej2E9gyqTf44SDpL.png"/></div></figure><p id="5098" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">让我们从分割我们的训练和测试数据以及我们的输入和目标变量开始。由于我们使用的是<a class="ae lg" href="https://www.analyticsvidhya.com/blog/2018/03/introduction-k-neighbours-algorithm-clustering/" rel="noopener ugc nofollow" target="_blank"> KNN </a>，因此也必须扩展我们的数据集:</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="b1b9" class="lo ig hi lk b fi lp lq l lr ls">y = data_df["target"].values<br/>x = data_df.drop(["target"], axis = 1)<br/><br/>#Scaling - mandatory for knn<br/>from sklearn.preprocessing import StandardScaler<br/>ss = StandardScaler()<br/>x = ss.fit_transform(x)<br/><br/>#Splitting into train and test<br/>X_train, X_test, y_train, y_test = train_test_split(x, y, test_size = 0.3) # 70% training and 30% test</span></pre><p id="a6d5" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">选择k的最佳值背后的直觉超出了本文的范围，但是我们应该知道，当我们获得k的最佳值的最高测试分数时，我们可以确定k的最佳值。为此，我们可以评估多达20个最近邻的训练和测试分数:</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="7eb9" class="lo ig hi lk b fi lp lq l lr ls">train_score = []<br/>test_score = []<br/>k_vals = []<br/><br/>for k in range(1, 21):<br/>    k_vals.append(k)<br/>    knn = KNeighborsClassifier(n_neighbors = k)<br/>    knn.fit(X_train, y_train)<br/>    <br/>    tr_score = knn.score(X_train, y_train)<br/>    train_score.append(tr_score)<br/>    <br/>    te_score = knn.score(X_test, y_test)<br/>    test_score.append(te_score)</span></pre><p id="df63" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">要评估最大测试分数及其相关的k值，请运行以下命令:</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="f928" class="lo ig hi lk b fi lp lq l lr ls">## score that comes from the testing set only<br/>max_test_score = max(test_score)</span><span id="c032" class="lo ig hi lk b fi lw lq l lr ls">test_scores_ind = [i for i, v in enumerate(test_score) if v == max_test_score]</span><span id="dc15" class="lo ig hi lk b fi lw lq l lr ls">print('Max test score {} and k = {}'.format(max_test_score * 100, list(map(lambda x: x + 1, test_scores_ind))))</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lx"><img src="../Images/62dee11946f7c0a88feefe6b09a22f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LWjyzAV68qVz8bkc.png"/></div></div></figure><p id="f2ae" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">因此，我们获得了k的最佳值为3、11或20，得分为83.5。我们将最终确定其中一个值，并相应地拟合模型:</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="d64d" class="lo ig hi lk b fi lp lq l lr ls">#Setup a knn classifier with k neighbors<br/>knn = KNeighborsClassifier(3)<br/><br/>knn.fit(X_train, y_train)<br/>knn.score(X_test, y_test)</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ly"><img src="../Images/a2b40b3090f1a38af55adc8d7f553100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xackz-B1xC93lbgM.png"/></div></div></figure><p id="2fae" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">现在，我们如何评价这个模型是不是一个‘好’模型？为此，我们使用一种叫做<a class="ae lg" href="https://www.analyticsvidhya.com/blog/2020/04/confusion-matrix-machine-learning/" rel="noopener ugc nofollow" target="_blank">混淆矩阵</a>的东西:</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="0651" class="lo ig hi lk b fi lp lq l lr ls">y_pred = knn.predict(X_test)</span><span id="85c6" class="lo ig hi lk b fi lw lq l lr ls">confusion_matrix(y_test,y_pred)</span><span id="9baf" class="lo ig hi lk b fi lw lq l lr ls">pd.crosstab(y_test, y_pred, rownames = ['Actual'], colnames =['Predicted'], margins = True)</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lz"><img src="../Images/ef60d332ecf4c4254537068b0776e8f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/0*xsdSa-nDuaIbDfIF.png"/></div></figure><p id="629d" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">混淆矩阵有助于我们深入了解我们的预测有多正确，以及它们与实际值的对比如何。</p><p id="c9c1" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">从我们的训练和测试数据中，我们已经知道我们的测试数据由91个数据点组成。这是最后第3行第3列的值。我们还注意到有一些实际值和预测值。实际值是最初归类为0或1的数据点的数量。预测值是我们的KNN模型预测为0或1的数据点的数量。</p><p id="28eb" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">实际值为:</p><ul class=""><li id="2816" class="jd je hi jf b jg kp ji kq jk ma jm mb jo mc jq jr js jt ju bi translated">实际上没有心脏病的病人= 41</li><li id="301b" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">真正患有心脏病的患者= 50人</li></ul><p id="8cc2" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">预测值为:</p><ul class=""><li id="9bd0" class="jd je hi jf b jg kp ji kq jk ma jm mb jo mc jq jr js jt ju bi translated">预测没有心脏病的患者人数= 40</li><li id="b988" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">预测患有心脏病的患者人数= 51</li></ul><p id="cab9" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们上面得到的所有值都有一个项。让我们一个一个来看:</p><ol class=""><li id="5a4b" class="jd je hi jf b jg kp ji kq jk ma jm mb jo mc jq li js jt ju bi translated">患者实际上没有心脏病，我们的模型也预测没有心脏病的情况称为<strong class="jf hj">真阴性。对于我们的矩阵，真阴性= 33。</strong></li><li id="9152" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">患者实际上患有心脏病并且我们的模型也预测患有心脏病的病例被称为<strong class="jf hj">真阳性。</strong>对于我们的矩阵，真阳性= 43</li><li id="35e1" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">然而，有一些情况下，病人实际上没有心脏病，但我们的模型预测他们有。这种误差是I型误差，我们称这些值为<strong class="jf hj">误报。</strong>对于我们的矩阵，假阳性= 8</li><li id="d6f8" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">类似地，在某些情况下，病人实际上有心脏病，但我们的模型预测他/她没有。这种误差是第二类误差，我们称这些值为<strong class="jf hj">假阴性。对于我们的矩阵，假阴性= 7</strong></li></ol><h1 id="abd7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是精准？</h1><p id="26c2" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">好的——现在我们来看这篇文章的关键。精确到底是什么？而以上这些学习又和它有什么关系呢？</p><p id="51ab" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">用最简单的话来说，精确度是真阳性和所有阳性之间的比率。对于我们的问题陈述，这将是我们在所有实际患有心脏病的患者中正确识别出患有心脏病的患者的度量。数学上:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es md"><img src="../Images/2bb1609beb239513b2bf68a71e663f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*XiJIVbcl54Yl--idyYGGig.png"/></div></figure><p id="0e28" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们模型的精度是多少？是的，它是0.843，或者，当它预测病人有心脏病时，它在84%的情况下是正确的。</p><p id="f3e2" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">精度也为我们提供了相关数据点的度量。重要的是，我们不要开始治疗实际上没有心脏病，但我们的模型预测有心脏病的病人。</p><h1 id="be14" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是回忆？</h1><p id="4475" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">召回是我们的模型正确识别真阳性的量度。因此，对于所有真正患有心脏病的病人，回忆告诉我们有多少人被我们正确地诊断为患有心脏病。数学上:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es me"><img src="../Images/e3c0e2bae3534488051b0c99a9879f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*UeMAHbpC2Kqv8yMUJprrQw.png"/></div></figure><p id="4ab9" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">对于我们的模型，回忆= 0.86。回忆也给出了我们的模型能够多精确地识别相关数据的度量。我们称之为敏感度或真阳性率。如果患者患有心脏病，但由于我们的模型预测到了这一点，因此没有对他/她进行治疗，该怎么办？这是我们希望避免的情况！</p><h1 id="cd7a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">最容易理解的指标——准确性</h1><p id="3943" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">现在我们来看一个最简单的指标，准确性。准确度是正确预测总数与预测总数之比。你能猜出精确度的公式是什么吗？</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mf"><img src="../Images/754a57320dd1f12db0f684270c1f88b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h88Omp-UZYL1cMm4yv9R2A.png"/></div></div></figure><p id="4f5f" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">对于我们的模型，精确度将= 0.835。</p><p id="4056" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">使用准确性作为我们模型的定义标准从直觉上来说是有意义的，但是通常情况下，使用精确度和召回率也是明智的。可能还有其他情况，我们的准确率非常高，但我们的精确度或召回率很低。理想情况下，对于我们的模型，我们希望完全避免患者患有心脏病的任何情况，但我们的模型将他归类为没有心脏病，即，以高回忆为目标。</p><p id="8a2f" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">另一方面，对于患者没有患有心脏病并且我们的模型预测相反的情况，我们也希望避免治疗没有心脏病的患者(当输入参数可能指示不同的疾病时这是至关重要的，但是我们最终治疗了他/她心脏病)。</p><p id="100b" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">虽然我们的目标是高精度和高召回值，但同时实现这两个目标是不可能的。例如，如果我们把模型改成一个给我们高回忆的模型，我们可能会发现所有实际上患有心脏病的病人，但我们可能最终会给许多没有患心脏病的病人提供治疗。</p><p id="c936" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">同样，如果我们的目标是高精度，以避免给予任何错误和不必要的治疗，我们最终会让许多实际上患有心脏病的患者得不到任何治疗。</p><h1 id="eb44" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">F1分数的作用</h1><p id="b535" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">对精确度的理解让我们意识到，我们需要在精确度和召回率之间进行权衡。我们首先需要决定哪个对我们的分类问题更重要。</p><p id="54fe" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">例如，对于我们的数据集，我们可以认为实现高召回率比获得高精确度更重要——我们希望检测尽可能多的心脏病患者。对于其他一些模型，如对银行客户是否是贷款违约者进行分类，需要有较高的精度，因为银行不希望失去那些根据模型预测会违约而被拒绝贷款的客户。</p><p id="13c6" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">在很多情况下，准确率和召回率同样重要。例如，对于我们的模型，如果医生告诉我们，被错误地分类为患有心脏病的患者同样重要，因为他们可能是其他疾病的指示，那么我们的目标不仅是高召回率，而且是高精确度。</p><p id="61e9" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">在这种情况下，我们使用F1分数。f1-得分是精确度和召回率的调和平均值:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mg"><img src="../Images/96017023fd1e0a61af71e358ba8a05b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Zj-XcQpVqSOiR18UN-Fyw.png"/></div></div></figure><p id="e27e" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">这更容易操作，因为现在，我们可以只瞄准一个好的F1分数，而不是平衡精度和召回值，这将表明一个好的精度和好的召回值。</p><p id="5686" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们也可以使用sklearn为我们的数据集生成上述指标:</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="1f02" class="lo ig hi lk b fi lp lq l lr ls">print(classification_report(y_test, y_pred))</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mh"><img src="../Images/db910aaa2fbd05bfde8fd9af513e3985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*N-3Xq7dJeziURAe6.png"/></div></figure><h1 id="b69e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">受试者工作特征曲线</h1><p id="c8a3" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">除了上述各项，我们还可以从混淆矩阵中计算出更多的值:</p><ol class=""><li id="680a" class="jd je hi jf b jg kp ji kq jk ma jm mb jo mc jq li js jt ju bi translated">假阳性率(FPR):它是假阳性与实际阴性数的比率。在我们的模型中，这是一个衡量标准，用来衡量在所有实际上没有心脏病的患者中，模型预测有多少人患有心脏病。对于我们的数据，FPR = 0.195</li><li id="f949" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">真阴性率(TNR)或特异性:它是真阴性和实际阴性数的比率。对于我们的模型来说，它是模型从所有实际上没有心脏病的患者中正确预测患者没有心脏病的病例的数量。上述数据的TNR = 0.804。从这两个定义，我们也可以得出结论，特异性或TNR = 1-FPR</li></ol><p id="a984" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们还可以使用ROC曲线和PRC曲线可视化精度和召回率。</p><h1 id="ac2a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">1.ROC曲线(接收机工作特性曲线)</h1><p id="eadd" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">这是TPR(y轴)和FPR(x轴)之间的曲线。由于我们的模型基于为每一类生成的概率将患者分类为患有心脏病或不患有心脏病，因此我们也可以决定概率的阈值。</p><p id="161b" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">例如，我们希望将阈值设置为0.4。这意味着如果患者患有心脏病的概率大于0.4，则该模型会将数据点/患者分类为患有心脏病。这显然会给出高召回值并减少误报的数量。类似地，我们可以使用ROC曲线可视化我们的模型在不同阈值下的表现。</p><p id="0936" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">让我们为k = 3的模型生成一条ROC曲线。</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="53fb" class="lo ig hi lk b fi lp lq l lr ls">y_pred_proba = knn.predict_proba(X_test)[:,1]<br/>fpr, tpr, thresholds = roc_curve(y_test, y_pred_proba)</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mi"><img src="../Images/94394d9d1f1787535ad5d6553e89c975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*slMn7dv2erBFfNvR.png"/></div></div></figure><h2 id="0265" class="lo ig hi bd ih mj mk ml il mm mn mo ip jk mp mq it jm mr ms ix jo mt mu jb mv bi translated">AUC解释-</h2><ul class=""><li id="8519" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">在最低点，即在(0，0)-阈值设置为1.0。这意味着我们的模型将所有患者分类为没有心脏病。</li><li id="eba9" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">在最高点，即在(1，1)，阈值设置为0.0。这意味着我们的模型将所有患者归类为患有心脏病。</li><li id="73fb" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">曲线的其余部分是阈值在0和1之间的FPR和TPR的值。在某个阈值，我们观察到对于接近0的FPR，我们正在实现接近1的TPR。这是模型将几乎完美地预测心脏病患者的时候。</li><li id="fdc5" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">以曲线和轴为边界的面积称为曲线下面积(AUC)。正是这个区域被认为是一个好模型的度量。这个指标的范围从0到1，我们应该以较高的AUC值为目标。AUC高的车型称为<strong class="jf hj">技术好的车型</strong>。让我们计算我们的模型和上述图的AUC分数:</li></ul><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="794a" class="lo ig hi lk b fi lp lq l lr ls">roc_auc_score(y_test, y_pred_proba)</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mw"><img src="../Images/b3efa86d280a881cd3fbffd53342e3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Br2_cLcSmQgvyqFN.png"/></div></div></figure><ul class=""><li id="37ee" class="jd je hi jf b jg kp ji kq jk ma jm mb jo mc jq jr js jt ju bi translated">我们得到的AUC值为0.868，这是一个非常好的分数！用最简单的话来说，这意味着该模型将能够在87%的情况下区分心脏病患者和非心脏病患者。我们可以提高这个分数，我建议你尝试不同的超参数值。</li><li id="cfb7" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">对角线是AUC为0.5的随机模型，这是一个没有技巧的模型，就像进行随机预测一样。你能猜到原因吗？</li></ul><h1 id="c33d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">2.精确召回曲线</h1><p id="3ed8" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">顾名思义，这条曲线是精度(y轴)和召回率(x轴)的直接表示。如果你观察我们上面的精确和回忆的定义和公式，你会注意到我们在任何时候都没有使用真正的否定(没有心脏病的实际人数)。</p><p id="dbc6" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">这对于我们有一个不平衡的数据集并且阴性的数量远大于阳性的情况(或者当没有心脏病的患者的数量远大于患有心脏病的患者的数量)特别有用。在这种情况下，我们更关心的是尽可能正确地检测出心脏病患者，而不需要TNR。</p><p id="2470" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">像ROC一样，我们绘制了不同阈值的精确度和召回率:</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="77b8" class="lo ig hi lk b fi lp lq l lr ls">precision, recall, thresholds = precision_recall_curve(y_test, y_pred_proba)<br/><br/>plt.figure(figsize = (10,8))<br/>plt.plot([0, 1], [0.5, 0.5],'k--')<br/>plt.plot(recall, precision, label = 'Knn')<br/>plt.xlabel('recall')<br/>plt.ylabel('precision')<br/>plt.title('Knn(n_neighbors = 8) PRC curve')<br/>plt.show()</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mx"><img src="../Images/552ad4d0c3f21c7c33fc13a6d073b5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Xq70ZS1LOCI90Vc9.png"/></div></div></figure><h2 id="6ae6" class="lo ig hi bd ih mj mk ml il mm mn mo ip jk mp mq it jm mr ms ix jo mt mu jb mv bi translated">中国解释:</h2><ul class=""><li id="107c" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">在最低点，即在(0，0)-阈值设置为1.0。这意味着我们的模型没有区分心脏病患者和非心脏病患者。</li><li id="02e2" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">在最高点，即在(1，1)，阈值设置为0.0。这意味着我们的准确率和召回率都很高，并且模型能够完美地区分。</li><li id="e219" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">曲线的其余部分是0和1之间的阈值的精度和召回值。我们的目标是使曲线尽可能接近(1，1)——这意味着良好的精确度和召回率。</li><li id="03ec" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">与ROC类似，以曲线和轴为边界的面积是曲线下面积(AUC)。将此区域视为一个好模型的衡量标准。AUC的范围从0到1。因此，我们应该以较高的AUC值为目标。让我们为我们的模型和上面的图计算AUC:</li></ul><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="da8d" class="lo ig hi lk b fi lp lq l lr ls"># calculate precision-recall AUC<br/>auc_prc = auc(recall, precision)<br/>print(auc_prc)</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es my"><img src="../Images/7b3fa30b473ae1d582fc249c8405c89c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/0*y6ZX9J9g0iUXAqfa.png"/></div></figure><p id="f966" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">和以前一样，我们获得了90%左右的良好AUC。此外，该模型可以在召回率为0的情况下实现高精度，并且可以通过牺牲50%的精度来实现高召回率。</p><h1 id="037b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结束注释</h1><p id="bbfe" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">总之，在本文中，我们看到了如何评估一个分类模型，尤其是关注精度和召回率，并在它们之间找到平衡。此外，我们解释了如何使用不同的度量和混淆矩阵来表示我们的模型性能。</p><p id="4581" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">这里有一篇附加文章供你了解评测指标- <a class="ae lg" href="https://www.analyticsvidhya.com/blog/2019/08/11-important-model-evaluation-error-metrics/?utm_source=blog&amp;utm_medium=precision_and_recall" rel="noopener ugc nofollow" target="_blank">机器学习的11个重要模型评测指标大家都应该知道</a></p><p id="693d" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated"><em class="lh">另外，如果你想开始学习机器学习，这里有一些免费的资源给你- </em></p><p id="0545" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我希望这篇文章能帮助你理解精确和召回之间的权衡。如果有任何疑问，请在下面的评论中告诉我。</p><p id="f798" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated"><em class="lh">原载于2020年9月3日https://www.analyticsvidhya.com</em><a class="ae lg" href="https://www.analyticsvidhya.com/blog/2020/09/precision-recall-machine-learning/" rel="noopener ugc nofollow" target="_blank"><em class="lh"/></a><em class="lh">。</em></p></div></div>    
</body>
</html>