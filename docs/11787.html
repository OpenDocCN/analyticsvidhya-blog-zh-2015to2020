<html>
<head>
<title>Matching samples for controlled analyses in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R中受控分析的匹配样品</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/matching-samples-for-controlled-analyses-in-r-e7091ae2320?source=collection_archive---------17-----------------------#2020-12-18">https://medium.com/analytics-vidhya/matching-samples-for-controlled-analyses-in-r-e7091ae2320?source=collection_archive---------17-----------------------#2020-12-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/99a452e073d16cdce4d7d7312f6da9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*yTQ2ha9PQ4RHKLMU.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">这段代码展示了使用tidyverse获取匹配样本进行分析的不同方法。这些信息包括多人的贡献。</figcaption></figure><h1 id="f794" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么匹配？</h1><p id="02de" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果你想分离出一个效果并进行分组比较，我们需要排除任何其他干扰。比如说你有两个人。一个人得到辅导，另一个人没有，然后他们都参加同样的测试。我们想知道辅导课是否有效。我们不能简单地比较这两个人的考试成绩。我们必须<em class="km">控制</em>个人层面的变量，这些变量可能对不同的考试分数负责，以便隔离辅导课程的影响。一些个人层面的差异可能会影响一个人在这项测试中的表现，包括先验知识、平均绩点、学生时代等。我们很少能分离出一种影响(这就是为什么拥有好的研究方法如此重要，但我们并不总是有这个选择)。相反，我们可以用几种不同类型的匹配来近似:</p><p id="c846" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您还可以使用以下内容，这些内容不在本文件中讨论。</p><ol class=""><li id="0808" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl kx ky kz la bi translated">倾向得分匹配</li><li id="d7e6" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">替代方案:分层样本</li></ol><p id="6c25" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我将逐一介绍这些，以及如何在r中执行它们。</p><p id="4496" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">配什么:</strong></p><p id="a7b1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这实际上是针对你的业务问题或研究问题的。然而，我在下面描述了我的方法:我的方法，尤其是当处理大量数据时，是从查看我<em class="km">可能</em>想要匹配的变量开始。我将使用下面的代码来计算每个潜在匹配变量的水平组合下每组有多少人。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ae1c" class="lp ir hi ll b fi lq lr l ls lt">data %&gt;%<br/>group_by(group, matchvar1, matchvar2, matchvar3) %&gt;% <br/>summarise(n=n()) %&gt;%  <br/>ungroup()</span></pre><p id="fa03" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果我注意到我的<strong class="jq hj">控制</strong>组中很少有人有特定的级别组合，那么就很难将他们与我的<strong class="jq hj">目标</strong>组匹配。如果某个组合的<strong class="jq hj">目标</strong>组的人比<strong class="jq hj">控制</strong>组的人多，尤其如此，除非你可以使用替换。使用替换通常是针对你的假设的。</p><p id="ccd9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">让我们更具体一点:假设我们在性别和种族上进行匹配。</p><p id="b10c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您的小组细分如下所示:</p><p id="a271" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">最后一行表明没有多少控件有这种特殊的变量组合。如果不使用替换，将不可能用相同的变量组合(斜体)匹配目标组中的99个人。在这种情况下，我可能会考虑将我未知的性别群体浓缩为女性或男性，或者根本不使用性别。</p><h1 id="519e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">1.艰难的比赛:</h1><p id="a1dc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">严格匹配从目标群体中寻找最像他们的人。例如，如果您的目标组中有一个人是22岁的西班牙裔女性，那么这个过程将遍历对照组中的每个人，直到找到匹配的人。这个严格的匹配标准创建了一个比较组，该比较组完全由与目标组中的人尽可能相似的人组成。</p><p id="998c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">如何准备数据:</strong></p><ul class=""><li id="ebe4" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl lu ky kz la bi translated">您需要有一个转换成数值的分组变量。</li><li id="4403" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lu ky kz la bi translated">您将需要所有匹配的变量也是数字。</li><li id="fe9e" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lu ky kz la bi translated">如果数据帧中有任何NA，则GenMatch无法运行。</li><li id="84bb" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lu ky kz la bi translated">你控制的人越多，你匹配的可能性就越大，你就可以匹配更多的变量！</li><li id="25a7" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lu ky kz la bi translated">更多信息请查看我的存储库管理。</li></ul><p id="d055" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">如何进行比赛:</strong></p><p id="b14d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这是你需要的全部代码。我选择在每一行旁边使用注释来解释代码中发生了什么。我使用<a class="ae lv" href="https://www.rdocumentation.org/packages/Matching/versions/4.9-7/topics/GenMatch" rel="noopener ugc nofollow" target="_blank"> GenMatch </a>函数如下:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6614" class="lp ir hi ll b fi lq lr l ls lt">matches.df = GenMatch(data$group, <br/>                   data[,c("var.1", "var.2", "var.3")], <br/>                   exact = c(T, F, F), <br/>                   caliper = c(0, 1, 0.5), <br/>                   replace = T, ties = F)</span></pre><p id="eaa7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">然而，这是我的代码通常最终的样子:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="cea8" class="lp ir hi ll b fi lq lr l ls lt">library(Matching)<br/><br/>matches.df = GenMatch(data$group, #define your grouping variable <br/>                               Match.ready%&gt;% #pipe in dataframe<br/>                                 #You can do some manipulating of variables for the match that you don't<br/>                                 #want saved in your dataframe here. <br/>                                 mutate(<br/>                                 #if you haven't releveled your variables you can use case_when<br/>                                   matchvar1 = case_when(matchvar1 == "level1" ~ 1,<br/>                                                         matchvar2 == "level2" ~ 2,<br/>                                                         T ~ 2), <br/>                                  #if your var only has 1 important level. Example = gender                               <br/>                                   ,matchvar2 = ifelse(matchvar2 == "level1", 1, 0)<br/>                                   #if you like the way your variables are leveled you can do this:<br/>                                   matchvar3 = as.numeric(as.factor(matchvar3)))%&gt;%<br/>                                   #select all variables you want to match on<br/>                                 dplyr::select(matchvar1, matchvar2, matchvar3,<br/>                                               matchvar4, matchvar5, matchvar6),<br/>                               #each true/false matches 1/0, respectively<br/>                               #each one represents a parameter for each of the 6 variables<br/>                               #see documentation on ?Matching for more information<br/>                               exact = c(T,T,T,<br/>                                         F,F,F),<br/>                               caliper = c(0,1,.5,<br/>                                           0,1,.5),<br/>                               replace = F, ties = F)</span></pre><p id="58da" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">如何拉出匹配的个人:</strong></p><p id="b82f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">首先，您将定义一个名为matched.df的新数据帧。您希望将其绑定到您的原始数据帧，以便您可以保留所有旧信息。您可以使用bind_rows()函数来实现这一点。使用索引找出唯一匹配的人。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d427" class="lp ir hi ll b fi lq lr l ls lt">matches.df = bind_rows(<br/>                        data[unique(maches.df$matches[,1]),],<br/>                        data[unique(matches.df$matches[,2]),])</span></pre><p id="3602" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">另一种方法是这样的:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="1206" class="lp ir hi ll b fi lq lr l ls lt">library(dplyr) <br/>library(tibble) <br/><br/>data = data %&gt;% <br/>  rownames_to_column("row.id") %&gt;% <br/>  filter(row.id %in% matches$matches[,1:2])</span></pre><p id="2983" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在您有了一个名为matched.df的数据框架，可以用来进行分析！</p><h1 id="cd67" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">2.松散的匹配:</h1><p id="361b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj">如何准备数据</strong></p><p id="321b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">把你的分组变量分成两列:我通常用yes和no。这里有一个:</p><ol class=""><li id="64eb" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl kx ky kz la bi translated">基于组分成两个数据帧</li><li id="2297" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">为每个变量创建一个新变量</li><li id="2854" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">把他们绑在一起</li></ol><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3f09" class="lp ir hi ll b fi lq lr l ls lt">yes &lt;- data %&gt;% <br/>    dplyr::select(c("id.yes")) %&gt;% <br/>    mutate(Group = 1) %&gt;% <br/>    rename(id = "id.yes") %&gt;% <br/>    distinct_all()<br/>  no &lt;- data %&gt;% <br/>    dplyr::select(c("id.no")) %&gt;% <br/>    mutate(Group = 0) %&gt;% <br/>    rename(id = "id.no") %&gt;% <br/>    distinct_all()<br/>  all.matched &lt;- rbind(yes, no)</span></pre><p id="00b9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在我们要做一个松散的匹配:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0bae" class="lp ir hi ll b fi lq lr l ls lt">matched.df &lt;- matched.df%&gt;% <br/>  # Start with the group of interest<br/>  filter(Group == 1) %&gt;%<br/>  inner_join(matched.df %&gt;%<br/>               filter(Group == 0),<br/>             by = c("matchvar1", "matchvar2", "matchvar3", "matchvar4", "matchvar5", "matchvar6")) %&gt;%<br/>  # Filter out rows that don't meet our criteria for fuzzy matching.<br/>  # if you are matching on a numeric value where you don't need to have an exact match you can use the code with abs()<br/>  # an example of this is age. If it doesn't matter that much that one person is 38.88 years old vs 38.22<br/>  # manipulate the &lt;= 1 to make it more or less granular or you can bin your data before you do the match<br/>  filter(abs(matchvar1.x - matchvar1.y) &lt;= 1 &amp; <br/>    abs(matchvar2.x - matchvar2.y) &lt;= 1) %&gt;% <br/>  # Keep IDs. Used in filter later<br/>  dplyr::select(id.group = ID.yes, matchvar1.yes = matchvar1.x, <br/>                matchvar2.yes = matchvar2.x, <br/>                id.no = ID.y, <br/>                matchvar1.no = matchvar1.y,<br/>                matchvar2.no = matchvar2.y)<br/><br/># acceptable matches.<br/>matched.terms.df = students.raw.df %&gt;%<br/>  semi_join(bind_rows(matches.df %&gt;%<br/>                        dplyr::select(ID = IDsacm, GPA = GPAsacm #, ft = term.code.SACM<br/>                        ),<br/>                      matches.df %&gt;%<br/>                        dplyr::select(ID = IDnot, GPA= GPAnot #, ft = term.code.not<br/>                        )),<br/>            by = c("ID"))</span></pre><h1 id="5cf6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">如何评估你的比赛:</h1><p id="4aad" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于您想要进行的任何类型的匹配，您可以创建一个可视化来查看您的匹配有多“好”。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9ac4" class="lp ir hi ll b fi lq lr l ls lt">library(ggplot2)<br/>ntiles = seq(0, 1, 0.01),<br/>matched.df%&gt;%<br/>  mutate(Group = ifelse(Group == 1, "Yes", "No"),<br/>         matchvar1 = as.numeric(as.factor(matchvar1)),<br/>         matchvar2 = as.numeric(as.factor(matchvar2)),<br/>         matchvar3 = as.numeric(as.factor(matchvar3)),<br/>         matchvar4 = as.numeric(as.factor(matchvar4)),<br/>         matchvar5 = as.numeric(as.factor(matchvar5)),<br/>         matchvar6 = as.numeric(as.factor(matchvar6))<br/>         ) %&gt;%<br/>  dplyr::select(Group, matchvar1, matchvar2, matchvar3,<br/>                matchvar4, matchvar5, matchvar6) %&gt;%<br/>  gather(predictor, value, -Group) %&gt;%<br/>  mutate(predictor = case_when(predictor == "matchvar1" ~ "Matched Variable 1",<br/>                                predictor == "matchvar2" ~ "Matched Variable 2",<br/>                                 predictor == "matchvar3" ~ "Matched Variable 3" )) %&gt;%<br/>  group_by(predictor, Group) %&gt;%<br/>  summarize(ntile = list(ntiles),<br/>            ntile.value = list(quantile(value, ntiles))) %&gt;%<br/>  unnest(cols = c(ntile, ntile.value)) %&gt;%<br/>  ungroup() %&gt;%<br/>  dplyr::select(ntile, Group, predictor, ntile.value) %&gt;%<br/>  spread(Group, ntile.value) %&gt;%<br/>  ggplot(aes(x = No, y = Yes)) +<br/>  geom_point(position = "jitter", alpha = 0.2) +<br/>  geom_abline(slope = 1, intercept = 0) +<br/>  facet_wrap(~ predictor, ncol = 2, scales = "free") +<br/>  scale_x_continuous("No") +<br/>  scale_y_continuous("Yes")</span></pre><p id="6099" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这将产生一个大致如下的图形。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es lw"><img src="../Images/550453c62a634e2207df1b5c87d90277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SKh2V8BnCYrXAcGw.png"/></div></div></figure><p id="595e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">完美匹配的集合将遵循x=y线。我们假设第一个变量是年龄。y轴上有Group ==“是”, x轴上有Group ==“否”。这意味着在组== "是"的人比在组== "否"的人更老。</p><h1 id="9c6e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">需要考虑的事项:</h1><ul class=""><li id="f182" class="ks kt hi jq b jr js jv jw jz mb kd mc kh md kl lu ky kz la bi translated">你的兴趣小组失去了多少人？例如，如果您的治疗组中有500人，您希望您的匹配返回尽可能多的人。</li><li id="57f2" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lu ky kz la bi translated">如果你失去了很多人或者得到了一个参数化错误，你可能需要减少你试图匹配的变量的数量。</li><li id="f7c6" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lu ky kz la bi translated">“控件”的数量越多，匹配的选项就越多。</li></ul></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="ca5e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="km">最初发表于</em><a class="ae lv" href="https://github.com/lsouthard/Matching" rel="noopener ugc nofollow" target="_blank"><em class="km">【https://github.com】</em></a><em class="km">。</em></p></div></div>    
</body>
</html>