<html>
<head>
<title>Getting Started with Unit Testing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python单元测试入门</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/getting-started-with-unit-testing-in-python-cac981ab6318?source=collection_archive---------16-----------------------#2019-10-02">https://medium.com/analytics-vidhya/getting-started-with-unit-testing-in-python-cac981ab6318?source=collection_archive---------16-----------------------#2019-10-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/584c678f9d86fae0e72a69a3370e9264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wD74coYZSIiuGiZa.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:https://www.360logica.com/blog/use-unit-testing/</figcaption></figure><p id="ca5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">背景</strong></p><blockquote class="jt ju jv"><p id="46d4" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi">“测试导致失败，失败导致理解”</em> </strong></p><p id="e28c" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><em class="hi">——伯特·鲁坦</em></p></blockquote><p id="5c76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“Smalltalk因为缺乏测试文化而遭受损失。是Kent Beck在他的论文的引言部分的第一句话— <a class="ae iu" href="http://swing.fit.cvut.cz/projects/stx/doc/online/english/tools/misc/testfram.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">简单的闲聊测试:使用模式</strong> </a>。在这篇文章中，他解释了一个测试策略和一个支持该策略的框架。肯特还区分了失败和错误。当我们测试时，重要的是能够区分正在检查的错误(<strong class="ix hj">失败</strong>)，比如二加三得到六，以及没有预料到的错误(<strong class="ix hj">错误</strong>)，比如下标越界或者消息不被理解。</p><p id="0c04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们编写测试时，我们只检查预期的结果，如果我们得到不同的答案，那就是失败。该框架使得对预期案例的测试变得简单。对于意料之外的错误，我们无能为力。如果你对他们做些什么，他们就不再是意料之外的了，是吗？。<a class="ae iu" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">单元测试模块</strong> </a>，是Python中的标准单元测试框架，标准库自带，就是基于这个测试框架。</p><p id="5e5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么要编写好的测试？</p><p id="e39f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在讨论测试框架的一些主要概念之前，我们需要知道为什么我们需要编写测试。第一次听说，我觉得写测试是浪费时间。我觉得这些测试对我的项目来说只是一个不必要的补充。使用<strong class="ix hj"> print </strong>语句进行调试对我来说感觉真好。我一直保持这种心态，直到我参与了一个大项目，使用打印语句变得非常乏味。这时我意识到了编写测试的重要性。</p><p id="16bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我很清楚，好的测试给了我信心，对我的程序的更新和调整不会以任何方式对我的整个程序产生任何意想不到的后果。也就是说，它使得检查在我的程序中添加一行或多行代码是否没有中断我的程序变得容易。</p><p id="2bab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，这节省了调试的时间和麻烦。用<strong class="ix hj"> print </strong>语句进行测试是一种不好的做法，因为这不是自动化的，并且很难维护。该框架有助于解决其中的一些问题。该框架支持测试自动化、测试的设置和关闭代码的共享、测试集合的聚合以及测试与报告框架的独立性。我们将很快编写代码来实现这一点。</p><p id="c4f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">你如何开始编写测试？</strong></p><p id="ec76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们开始编写自己的测试时，我们可能不知道从哪里开始。我们希望绝对完整，这样我们就可以确保该软件将工作。然而，如果这是我们的方法，我们将永远不会开始。Kent建议最好从行为可预测的单一配置开始。这种配置被称为<strong class="ix hj">夹具</strong>。他提到，通过选择夹具，您可以说明您愿意测试什么，不愿意测试什么。</p><p id="eb7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，当灾难性错误发生时，框架停止运行测试用例<strong class="ix hj">(一个单独的测试单元)</strong>，记录错误并运行下一个测试用例。由于每个测试用例都有自己的夹具，前一个用例中的错误不会影响下一个。因此，支持了关于测试独立性的观点。一旦你有两个测试用例在运行，你会想要一个接一个地运行它们，而不必执行两个do it。测试框架提供了一个对象来表示“<strong class="ix hj">一堆测试</strong>”、<strong class="ix hj">测试套件</strong>。TestSuite通过运行一组测试用例并一次报告所有结果来利用多态性。测试套件还可以包含其他测试套件。</p><p id="9345" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">是时候用Python编码了！让我们创建将要测试的内容</strong></p><p id="1c62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，为了实现这些功能，我们需要有我们想要测试的东西。因此，让我们定义一个简单的类。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/9b8f1b376c738bc4dc38d7946e4dec48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*myAUS_XGW_M_EjyJbwTLQg.png"/></div></div></figure><p id="aa00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面，我们定义了一个类<strong class="ix hj"> CreateAccount </strong>，用新客户的<strong class="ix hj">名字</strong>、<strong class="ix hj">姓氏</strong>和<strong class="ix hj">初始存款</strong>初始化。构造函数使用实例变量(<strong class="ix hj">名字</strong>和<strong class="ix hj">姓氏</strong>)来创建一个<strong class="ix hj">帐户名称。</strong>这也确保了初始存款必须至少为<strong class="ix hj"> 1000。</strong>如果初始存款少于1000英镑，则会引发异常。最后，构造器通过从初始存款中减去<strong class="ix hj"> 100 </strong>来设置账户中的余额，其中<strong class="ix hj"> 100 </strong>是新账户的费用。同样，<strong class="ix hj">创建账户</strong>也有两个额外的方法——<strong class="ix hj">存款</strong>和<strong class="ix hj">加利息</strong>。</p><p id="64e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">存款</strong>方法接受一个<strong class="ix hj">金额</strong>参数，该参数必须大于<strong class="ix hj"> 0。</strong>如果金额小于或等于0，则会引发异常。如果金额大于<strong class="ix hj"> 0 </strong>，该金额被添加到<strong class="ix hj">余额</strong>中，新的<strong class="ix hj">余额</strong>被返回。<strong class="ix hj"> add_interest </strong>方法还用获得的<strong class="ix hj">利率</strong>更新<strong class="ix hj">余额</strong>，并返回新的<strong class="ix hj">余额</strong>。</p><p id="e014" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">来测试一下吧！！！</strong></p><p id="ce51" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，让我们为上面的类编写测试。提醒一下，我们为预期的结果编写测试，如果我们得到不同的答案，那就是失败。因此，我们将编写检查预期结果的测试。为了创建一个<strong class="ix hj">测试用例</strong>，我们首先需要创建一个从<strong class="ix hj"> unittest继承的类。测试用例</strong>。从<strong class="ix hj">单元测试继承而来。TestCase </strong>让我们能够访问与上述框架相关的不同测试功能，包括访问assert方法。要编写一个测试，我们在类中定义一个方法，该方法需要以<strong class="ix hj"> test_ </strong>开始。我们需要命名约定来确保当我们运行它时，它确实知道哪些方法代表了测试用例。同样，<strong class="ix hj">设置</strong>和<strong class="ix hj">拆卸</strong>方法包含应该分别在每个测试用例之前和之后实现的指令。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/4a5ce5cd328251e69423e698ee0a6c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e_bJ-BFl2UxjuJTOiNEkQg.png"/></div></div></figure><p id="c192" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们从Python标准库中导入了<strong class="ix hj"> unittest </strong>模块，从<strong class="ix hj"> createaccount </strong>模块中导入了<strong class="ix hj"> CreateAccount </strong>类(注意:这些文件在同一个目录下)。接下来，我们创建了<strong class="ix hj"> TestCreateAccount </strong>类(一个<strong class="ix hj"> TestSuite </strong>)并从<strong class="ix hj"> unittest继承了测试功能。测试用例</strong>。然后，我们定义了<strong class="ix hj">设置</strong>和<strong class="ix hj">拆卸</strong>方法。这里，<strong class="ix hj"> setUp </strong>和<strong class="ix hj"> tearDown </strong>方法包含一个<strong class="ix hj"> print </strong>语句，只是为了展示这是如何工作的，当我们看到输出时就会显示出来。另外，<strong class="ix hj"> setUp </strong>方法为我们的每个测试用例创建一个新的客户端。这些方法有更多的实际应用。在这里，我只是试图展示他们做什么，我希望这是清楚的。最后，我们定义了我们的测试用例，它们都遵循从<strong class="ix hj"> test_ </strong>开始的命名惯例。</p><ul class=""><li id="818a" class="kg kh hi ix b iy iz jc jd jg ki jk kj jo kk js kl km kn ko bi translated">第一个测试案例</li></ul><p id="ef81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个<strong class="ix hj">测试用例</strong>检查<strong class="ix hj">帐户名</strong>是否如预期。它还检查添加到新<strong class="ix hj">账户</strong>费用的<strong class="ix hj">余额</strong>是否等于<strong class="ix hj">初始_存款</strong>。最后，当我们创建一个少于<strong class="ix hj"> 1000的<strong class="ix hj">账户</strong>时，</strong>测试用例确保一个异常被引发。</p><ul class=""><li id="b72a" class="kg kh hi ix b iy iz jc jd jg ki jk kj jo kk js kl km kn ko bi translated">第二个测试案例</li></ul><p id="3787" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个测试用例测试<strong class="ix hj">存款</strong>方法。它断言<strong class="ix hj">余额</strong>用存入的<strong class="ix hj">金额</strong>更新。然后，如果我们尝试存入任何小于或等于<strong class="ix hj">零</strong>的金额，它会断言抛出异常。可以注意到，<strong class="ix hj"> assertRaises </strong>的编写方式与<strong class="ix hj"> test_constructor </strong>方法(使用了上下文管理器)完全不同。这里在<strong class="ix hj"> test_deposit </strong>方法中，应该传递给<strong class="ix hj"> deposit </strong>方法的参数没有直接放入<strong class="ix hj"> deposit </strong>方法中。因此，我们在测试用例中展示了两种编写这种<strong class="ix hj">断言</strong>的方法。</p><ul class=""><li id="91e8" class="kg kh hi ix b iy iz jc jd jg ki jk kj jo kk js kl km kn ko bi translated">第三个测试案例</li></ul><p id="e47d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们有最后一个测试用例<strong class="ix hj"> test_add_interest </strong>方法，这意味着我们在<strong class="ix hj">测试套件</strong> ( <strong class="ix hj"> TestCreateAccount </strong>)中有三个测试用例。当添加<strong class="ix hj">利率</strong>时，测试用例断言<strong class="ix hj">余额</strong>被更新<strong class="ix hj"> </strong>。3个测试用例包含<strong class="ix hj">打印</strong>语句。这显示了它们何时被执行。</p><p id="f847" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">奖金</strong></p><p id="1233" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> __name__ </strong>是Python中的一个特殊变量，值为<strong class="ix hj"> '__main__' </strong>。<strong class="ix hj"> if __name__ == '__main__' </strong>条件语句通常在我们的模块中使用，因为当我们在Python中导入一个模块时，模块中的所有代码都会被执行，即使我们只从模块中导入了一个函数。所以，这个条件语句用于确保当我们导入模块时，一些代码(我们不想执行的)不会真正被执行。因此，条件块<strong class="ix hj"> if __name__ == '__main__' </strong>中的代码只有在我们直接运行模块时才会被执行。此外，这有助于我们使用以下代码运行测试模块:</p><p id="d923" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">&gt;&gt;python 3&lt;module _ name&gt;</strong></p><p id="c75a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而不是:</p><p id="9dd1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">&gt;&gt;python 3-m unittest&lt;module _ name&gt;</strong></p><p id="043c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出</strong></p><p id="15a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是运行我们代码的输出:</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/19e8b9cf47897234bbacf63c7a58e6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqL7QheTc5XChyEoWxBsEw.png"/></div></div></figure><p id="936e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们观察到这三个测试用例已经用“<strong class="ix hj">在0.012秒</strong>内运行了3个测试”，并且它们都成功地通过了<strong class="ix hj"> OK </strong>。如果我们的一个测试用例失败了，这将显示<strong class="ix hj">失败(失败= &lt;失败次数&gt; ) </strong>。为每个测试用例执行<strong class="ix hj">设置</strong>和<strong class="ix hj">拆卸</strong>方法。因此，输出显示安装和拆卸3次。</p><p id="23f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">点</strong>也表明测试用例是成功的。失败的测试用例将显示<strong class="ix hj"> F </strong>而不是点。很明显，我们的测试已经自动化，因为我们可以随时重新运行测试，以确保我们的代码仍然正常工作。此外，我们已经证实了测试的设置和关闭代码的共享以及测试集合的聚合和测试的独立性。</p><p id="8df0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经走到了尽头！在我们走之前，拿着这个:</p><blockquote class="jt ju jv"><p id="eb5c" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><em class="hi">没有测试的代码按设计被破坏。</em></p></blockquote><p id="0ac6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>