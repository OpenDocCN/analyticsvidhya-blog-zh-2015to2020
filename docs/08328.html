<html>
<head>
<title>Decision Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">决策图表</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/decision-tree-ea1ed031d6bc?source=collection_archive---------17-----------------------#2020-07-25">https://medium.com/analytics-vidhya/decision-tree-ea1ed031d6bc?source=collection_archive---------17-----------------------#2020-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9a37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将了解什么是决策树以及它是如何工作的。它如何变得过拟合，以及我们如何解决过拟合。</p><blockquote class="jd je jf"><p id="f992" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">决策树是一种基于规则的算法，在这种算法中，为了预测结果，我们需要回答一系列问题并做出决策。</p></blockquote><p id="bddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们用一个每个人都能容易理解的图表来说明这个过程，它就会像一棵树一样出现。</p><p id="7baa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在现实生活中，我们可能会遇到这样的情况:我们进行了一次问卷调查，最后我们得到了一个解决方案。</p><p id="6ecc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:检查患者是否准备好进行“对比CT扫描”。准备好如果1。在进行CT扫描检查前三小时，允许患者饮用清澈的液体，但不允许饮用固体食物。</p><ul class=""><li id="4168" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated">你吃饭了吗？还是喝酒？</li><li id="697b" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated"><strong class="ih hj">如果吃—拒绝</strong></li><li id="cbe6" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated"><strong class="ih hj">如果喝酒——你只喝清澈的液体吗？</strong></li><li id="d316" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated"><strong class="ih hj">如果是——符合检查条件，</strong></li><li id="e1ad" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated"><strong class="ih hj">如果否——拒绝。</strong></li></ul><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es jy"><img src="../Images/858b637f5d4134c6cdd523b753bf6ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*3SVmF1JmvrbhqCsPtiTwfg.png"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">符合CT检查资格—决策树:作者提供的图片</figcaption></figure><p id="69fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以清楚地了解到，一份调查问卷是多么有用。</p><p id="0a84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将借用这种技术来预测目标变量，我们称之为决策树。</p><p id="ca59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种技术难道不是在提醒你流程图，并且容易理解吗？</p><p id="1b19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的树中，每个框被标识为一个节点。</p><p id="f1d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个节点称为<strong class="ih hj">根节点</strong>。</p><p id="e2f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">橙色和绿色的节点是问卷的最终结果。这些节点叫做<strong class="ih hj">终端节点</strong>，有最终答案。</p><p id="ee76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有剩余的中间节点被称为内部节点。</p><h1 id="cc20" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">决策树算法的工作原理:</h1><p id="40e7" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">因为提问者知道应该首先考虑什么因素，应该做出什么决定，所以他们很容易做出决定。人类就是这样思考的。</p><p id="6d50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是机器怎么能对它起作用呢？</p><h2 id="b4d6" class="ln kl hi bd km lo lp lq kq lr ls lt ku iq lu lv ky iu lw lx lc iy ly lz lg ma bi translated">程序如何识别哪个问题先出现？</h2><p id="790f" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在我们之前的“对比CT扫描”示例中，我们需要从所有可能的问题中找出哪个问题，制作一份简短的问卷来做出决定。</p><p id="4f26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在第一步就把吃东西的人和喝醉的人分开了。所以，我们可以拒绝在第一步中谁吃了固体食物。想一想其他的方法，想出你的步骤。最后你会看到多一步或几步。</p><p id="5e53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下图中，如果你想用一条水平线或垂直线来区分橙子和西瓜，那么最好的分割线是中间的一条垂直线。同意吗？</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es mb"><img src="../Images/566fa563c8aa3842def48dfead62f31b.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*V_MbGp2ILk-nJNbX4gZsOQ.png"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">作者图片</figcaption></figure><p id="38fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果是垂直线，那么存在于X轴的特征在这里播放。</p><p id="9aa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，我们希望两个分开的部分具有相似的类值。这样我们就可以决定左边的类别应该是一个橙子，右边的应该是一个西瓜。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es mb"><img src="../Images/9a10402f4615ae3f43ee988aac371f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*kfEn4ewE3DPexFZ8r13HSw.png"/></div></figure><p id="0987" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，在下面的图片中，您可以看到前三张图片没有很好地分割以隔离项目。在第四张图中，这是最可能的好分割，因此分割的进一步步骤被最小化。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mc"><img src="../Images/9fa007ea980fc91fcdc62d7edd78e6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0F-GnI8AR04QPtD-gUSXw.png"/></div></div></figure><p id="e3ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在划分数据后，两个区域有相同类型的水果(相同的类值)。我们称之为“纯洁”。</p><h2 id="d49a" class="ln kl hi bd km lo lp lq kq lr ls lt ku iq lu lv ky iu lw lx lc iy ly lz lg ma bi translated">机器如何找到这个最佳分裂，找到节点的纯度？</h2><p id="3966" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">要做到这一点，首先我们需要选择第一个根节点，以及在哪里进行分割。</p><p id="8853" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将使用以下两种方法中的任何一种来完成:</p><ol class=""><li id="ce5b" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc mh jq jr js bi translated">信息增益(使用熵)。</li><li id="1b69" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc mh jq jr js bi translated">基尼指数。</li></ol><p id="f45d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基尼系数和熵值都谈到了“不确定性的度量”。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mi"><img src="../Images/297c6f9512fb592e8331299c2f8faf1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nuVsczVmT1lpWfagH4RVIw.png"/></div></div></figure><p id="6fb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的图片中，A是纯的，因为它只有一个类。b有杂质，但是它可以给出中等的关于哪个阶级统治这个地区的知识。但是在C语言中，太阳和星星的数量相等。我们在这里无法做出任何决定。该节点具有高杂质。</p><h1 id="141f" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">信息增益(使用熵):</h1><p id="c119" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg">信息增益=目标熵—属性熵</em> </strong></p><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es mj"><img src="../Images/29e4adc1a45ac8087cb51bd72368f496.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*UM3vuIPIDe9ob6EEOnYcRQ.png"/></div></figure><p id="762e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，目标的熵是水果列的熵。属性的熵只不过是特征(预测值/列)的熵。</p><p id="45ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看，</p><p id="676f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">形状的信息增益=水果的熵—形状的熵= 0.25</p><p id="b067" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">颜色的信息增益=水果的熵—颜色的熵= 0.35</p><p id="498c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里颜色的信息增益是最高值。</p><p id="29aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，颜色将是根节点。</p><h1 id="5994" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">基尼指数:</h1><p id="0a5e" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">基尼系数的计算方法是从1中减去每一类概率的平方和。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es mk"><img src="../Images/4d86139b5d949b6f984f2c4f29fd59e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*yZqA_KwcadQ2lmFGQrjQtw.png"/></div></figure><p id="b5c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里Pj是物体被分类到特定类别的概率。</p><p id="306b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看，</p><p id="07c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按形状分列的基尼指数= 0.31</p><p id="a84d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按颜色划分的基尼指数= 0.23</p><p id="9f8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里基尼系数的颜色是最低值。</p><p id="ef40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，颜色将是根节点。</p><h1 id="b38b" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">基尼指数与信息增益:</h1><p id="9935" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">基尼指数或信息增益(熵)，两者的工作原理相似，只是公式不同。</p><blockquote class="jd je jf"><p id="3f92" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">将提取每个特征并计算基尼系数。给出</em> <strong class="ih hj"> <em class="hi">最低基尼分数的特征被用作根节点或决策节点</em> </strong> <em class="hi">。</em></p><p id="ded3" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">类似地，为每个特征计算熵值，然后为该特征计算信息增益分数。最后给出</em> <strong class="ih hj"> <em class="hi">最高信息增益的特征将作为根节点或决策节点</em> </strong> <em class="hi">。</em></p></blockquote><p id="9790" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，剩余的内部节点将使用基尼/熵进一步分裂。</p><p id="3384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，我们可以在算法中控制这个参数。</p><blockquote class="jd je jf"><p id="e1a0" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">熵是最古老的使用Log in计算的方法</em> </strong> <em class="hi">。所以，它比基尼系数计算要慢。</em></p><p id="1a64" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">所以，</em> <strong class="ih hj"> <em class="hi">基尼系数是最常用的方法，因为它比熵值</em> </strong> <em class="hi">更快。但是这两种方法将提供相同的结果。</em></p></blockquote><p id="6268" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们不深入探讨这个话题。稍后我会发布一篇有好的和简单的例子的新文章，并链接到这里。</p><p id="d4aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使在分割之后，如果仍然有不同类型的水果，该算法将再次分割不同类型水果存在的区域。这将通过使用给定的特性来完成，并且将终端节点作为纯节点(具有单个类的节点)。</p><blockquote class="jd je jf"><p id="c02e" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">决策树也可用于回归问题，以预测连续值。</em></p><p id="2d87" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">在分类问题中，通过检查纯度来进行最佳划分。在回归中，通过检查最小方差来完成。</em></p></blockquote><h2 id="87d6" class="ln kl hi bd km lo lp lq kq lr ls lt ku iq lu lv ky iu lw lx lc iy ly lz lg ma bi translated">另一个例子:</h2><p id="377a" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">让我们制作一个模型，用给定的水果大小和颜色来预测这是什么水果。</p><p id="76e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果给我们水果的大小和颜色，那么我们可以先根据颜色进行分类。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es ml"><img src="../Images/2a264e290018da5a141e955e4bb44cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*MVnfSo8K91h2s1LyOSD0GQ.png"/></div></figure><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es mm"><img src="../Images/aee3ea61ea32f49ff262ef70d50c4c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*MNpBuH-pbU5dTn4VNhCX9A.png"/></div></figure><p id="7298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的图片中你可以看到，首先颜色被用来划分区域，结果是橙色和红色。</p><p id="d456" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中Orange是一个纯节点，这里只存在一个类。</p><p id="731a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是红色有杂质，因为在那个区域有两种类型的水果(在那个区域存在两个等级)。</p><p id="a739" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当使用size时，我们可以除以，size &gt;一个特定的厘米。应该是7cm吧？还是5cm？哪个会让结果更好？</p><p id="f17a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在内部，机器尝试所有可能的值，并检查结果区域的方差。</p><p id="d987" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于7cm的值，如果纯度良好，则机器会以7cm为边界来划分区域。</p><p id="8710" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们得到了葡萄和西瓜的纯节点。</p><h1 id="6bfe" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">过度拟合:</h1><p id="5748" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在前面的例子中，数据中没有噪声。数据本身是干净的，我们通过一次或两次拆分得到纯节点。</p><p id="90ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果数据中有很多噪音怎么办？</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mn"><img src="../Images/ace4013e907866ca0f08167332d09f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*nM2hdu66bDEF0127gmfKMA.png"/></div></div></figure><p id="efd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，根节点是蓝线。根节点的条件是X1&gt; 4.3</p><p id="fd2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">黄线是第二层。X2 &gt; 3.5</p><p id="3ce4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在R3区域是纯的。这个m =可以是终端节点。</p><p id="c098" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是R1和R2地区仍然有杂质。</p><p id="afed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，机器将处理R1，并使用条件“X1 &gt; 3，X1 &lt; 3.5，X2 &lt; 2.5”导出R4地区。可能吧？</p><p id="c83f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以同样的方式，通过衍生R5来纯化R2。</p><p id="d9a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在所有的终端节点R1、R2、R3、R4和R5都是纯的。</p><p id="f736" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">算法到此结束。</p><p id="d315" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是你觉得这样好吗？R4和R5中的数据可能是一个噪声。</p><p id="8398" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是啊！此模型对于训练数据来说过拟合。</p><p id="ed4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果测试数据有一颗红星落在R4，那么它将以错误告终。R5区也发生同样的情况。</p><p id="9744" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那我们怎么告诉模型在某个点停止划分区域呢？</p><h1 id="d1b4" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">修剪树:</h1><p id="fa5f" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">这是我们通过设置决策树的参数来修剪树的地方。</p><p id="605c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jg"> Max_depth: </em> </strong>该参数帮助设置树的最大深度。如果我们将上面例子中的max_depth设置为3，那么将不会创建R4和R5区域。</p><p id="fc24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jg">Min _ sample _ split:</em></strong>该参数设置进一步拆分所需的最小样本数(行数)。例如，如果一个节点有4颗星和1颗太阳，并且如果我们将min_sample_split设置为6，那么这个节点不能被进一步划分，因为它只有5个样本。</p><p id="4bff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jg">Min _ samples _ leaf:</em></strong>该参数可用于提及终端节点(叶节点)应出现的最小样本数。</p><h1 id="ca73" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">什么时候使用决策树？</h1><p id="2ccd" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">我们已经有了用于分类的逻辑算法和用于回归的线性算法。那我们为什么需要决策树呢？以下是您应该使用决策树的原因和情况。</p><ul class=""><li id="58ec" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated">如果数据是线性的，那么我们可以使用逻辑回归本身。但是当维度更高时，我们如何知道数据是线性的还是非线性的呢？</li><li id="5088" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated">我们可以开始使用一些基本的分类技术，如逻辑回归。经验法则是使用简单的方法。如果结果不好，那么线性分类方法可能无法解决问题，我们可能需要使用更复杂的非线性分类算法。</li><li id="646f" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated">如果逻辑和DT给出相同的结果，那么为什么我们需要一个复杂耗时的算法。</li><li id="2a7d" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated">如果数据<strong class="ih hj">不平衡</strong>，那么<strong class="ih hj">最佳选择是决策树</strong>。</li><li id="c130" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated">如果<strong class="ih hj">的特征数较高</strong>(例如&gt; 100)且样本较少(数据= 100000)，那么<strong class="ih hj">我们可以使用逻辑回归</strong>，因为当特征数较高时决策树较慢。</li><li id="1481" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated">如果特征的数量高于样本的数量，那么我们就不应该使用逻辑回归。</li><li id="b409" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated">决策树容易过度适应。</li><li id="ef33" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated">决策树最大的优点之一是这个算法<strong class="ih hj">不需要缩放</strong>。</li><li id="898a" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated">我们可以看到决策树是如何分割数据的，决策树是一个<strong class="ih hj">白盒算法</strong>。</li></ul><h1 id="4869" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">结论:</h1><p id="81cd" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在这篇文章中，我们学习了决策树。</p><p id="7d14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将添加一个新帖子来练习Python中的决策树。</p><p id="7c5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编程快乐！🙂</p><p id="75ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">喜欢支持？只需点击心形图标❤️.</p></div></div>    
</body>
</html>