<html>
<head>
<title>Polymorphism in Python !</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的多态性！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/polymorphism-in-python-1fef01f3ec4c?source=collection_archive---------4-----------------------#2020-09-04">https://medium.com/analytics-vidhya/polymorphism-in-python-1fef01f3ec4c?source=collection_archive---------4-----------------------#2020-09-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7c69" class="pw-subtitle-paragraph ig hh hi bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dx translated"><em class="if">为什么学不会&amp;通过实验探索多态的概念&amp;尝试自己的代码&amp;例子？</em></h2></div><blockquote class="iy iz ja"><p id="5543" class="jb jc jd je b jf jg ik jh ji jj in jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">在这篇博客中，我想通过<strong class="je hj">在我的 Jupyter 笔记本上做这些来揭开多态性的神秘面纱，</strong>因为这个概念在不同的网站上有不同的解释&amp;它是用 Python 实现的</p></blockquote><p id="7b98" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">议程:- </strong> <br/> 1。)什么是多态性？<br/> 2。)多态的内置实现(运算符&amp;函数)<br/> 3。)与类方法的多态性<br/> 4。)多态性与函数<br/> 5。)方法重载<br/> 6。)方法覆盖</p><h1 id="de6e" class="kb kc hi bd kd ke kf kg kh ki kj kk kl ip km iq kn is ko it kp iv kq iw kr ks bi translated">什么是多态性？</h1><p id="ba38" class="pw-post-body-paragraph jb jc hi je b jf kt ik jh ji ku in jk jy kv jn jo jz kw jr js ka kx jv jw jx hb bi translated">多态是面向对象编程的一个概念。</p><ul class=""><li id="5622" class="ky kz hi je b jf jg ji jj jy la jz lb ka lc jx ld le lf lg bi translated">多态性这个词意味着有许多形式。</li><li id="576d" class="ky kz hi je b jf lh ji li jy lj jz lk ka ll jx ld le lf lg bi translated">在编程中，多态性意味着相同的函数名(但不同的签名)用于不同的类型。</li><li id="5f6d" class="ky kz hi je b jf lh ji li jy lj jz lk ka ll jx ld le lf lg bi translated">如果我们有一个按钮，有许多不同的绘制输出(圆形按钮、复选按钮、方形按钮、带图像的按钮),但是它们共享相同的逻辑:onClick()</li></ul><blockquote class="iy iz ja"><p id="8837" class="jb jc jd je b jf jg ik jh ji jj in jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">我们用同样的方法访问它们。这种想法叫做<em class="hi"> </em> <strong class="je hj">多态性。</strong></p></blockquote><ul class=""><li id="8ab1" class="ky kz hi je b jf jg ji jj jy la jz lb ka lc jx ld le lf lg bi translated">多态性是为不同的底层形式(如数据类型或类)利用相同接口的能力。这允许函数在不同时间使用不同类型的实体。</li></ul><h1 id="fd62" class="kb kc hi bd kd ke kf kg kh ki kj kk kl ip km iq kn is ko it kp iv kq iw kr ks bi translated"><strong class="ak">多态性的类型:- </strong></h1><h2 id="020a" class="lm kc hi bd kd ln lo lp kh lq lr ls kl jy lt lu kn jz lv lw kp ka lx ly kr lz bi translated">1.多态性的内置实现:-</h2><ul class=""><li id="56ed" class="ky kz hi je b jf kt ji ku jy ma jz mb ka mc jx ld le lf lg bi translated"><strong class="je hj"> <em class="jd">多态性中的'+'运算符</em> </strong></li></ul><p id="d507" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">对于整数数据类型，<code class="du md me mf mg b">+</code>运算符用于执行算术加法运算。</p><h2 id="04f7" class="lm kc hi bd kd ln lo lp kh lq lr ls kl jy lt lu kn jz lv lw kp ka lx ly kr lz bi translated"><strong class="ak">多态性加法运算符:- </strong></h2><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="0142" class="lm kc hi mg b fi mp mq l mr ms"># Case 1 : When Data Types are Integers<br/>num_1 = 5<br/>num_2 = 10</span><span id="de46" class="lm kc hi mg b fi mt mq l mr ms">print(num_1+num_2)  #Addition for int Data Types</span></pre><h2 id="d6cb" class="lm kc hi bd kd ln lo lp kh lq lr ls kl jy lt lu kn jz lv lw kp ka lx ly kr lz bi translated"><strong class="ak">输出:- </strong></h2><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="9c4e" class="lm kc hi mg b fi mp mq l mr ms">15</span></pre><p id="f490" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">类似地，对于字符串数据类型，<code class="du md me mf mg b">+</code>运算符用于执行连接</p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="6314" class="lm kc hi mg b fi mp mq l mr ms"># Case 2 : When Data Types are Strings<br/>str_1 = "Abhay"<br/>str_2 = "Bansal"</span><span id="5f7b" class="lm kc hi mg b fi mt mq l mr ms">print(str_1+" "+str_2) #Concatenation</span></pre><h2 id="59cc" class="lm kc hi bd kd ln lo lp kh lq lr ls kl jy lt lu kn jz lv lw kp ka lx ly kr lz bi translated">输出:-</h2><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="6cab" class="lm kc hi mg b fi mp mq l mr ms">Abhay Bansal</span></pre><p id="e42a" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">这里我们可以注意到，单个操作符<code class="du md me mf mg b">+</code>被用来根据数据类型执行不同的操作。<br/>这个你可以想到 Python 中最基本的多态。</p><h2 id="706f" class="lm kc hi bd kd ln lo lp kh lq lr ls kl jy lt lu kn jz lv lw kp ka lx ly kr lz bi translated">2.多态的内置函数实现:-</h2><p id="b909" class="pw-post-body-paragraph jb jc hi je b jf kt ik jh ji ku in jk jy kv jn jo jz kw jr js ka kx jv jw jx hb bi translated">len()是 Python 中的一个内置函数，它基于不同的数据类型和结构给出不同的结果或表现出不同的行为。</p><p id="92ec" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">len()函数中的多态性:- </strong></p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="f84f" class="lm kc hi mg b fi mp mq l mr ms">print("Length when String :",len("Python"))<br/>print("Length when List:",len(["DataScience","AI","ML"]))<br/>print("Length when Dictionary:",len({"Name":"Abhay","City":"Pune"}))</span></pre><h2 id="3994" class="lm kc hi bd kd ln lo lp kh lq lr ls kl jy lt lu kn jz lv lw kp ka lx ly kr lz bi translated">输出:-</h2><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="66c8" class="lm kc hi mg b fi mp mq l mr ms">Length when String : 6<br/>Length when List: 3<br/>Length when Dictionary: 2</span></pre><h1 id="0007" class="kb kc hi bd kd ke kf kg kh ki kj kk kl ip km iq kn is ko it kp iv kq iw kr ks bi translated">Python 中的类多态性:-</h1><p id="492c" class="pw-post-body-paragraph jb jc hi je b jf kt ik jh ji ku in jk jy kv jn jo jz kw jr js ka kx jv jw jx hb bi translated">在直接讨论类方法多态性的概念之前，让我们<br/>举一个例子，问题陈述是计算正方形的面积&amp;矩形的面积。</p><p id="e02d" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">把自己想象成一名开发人员&amp;让我们想象一下你可以采用什么方法，以及选择哪种方法更好。</p><figure class="mh mi mj mk fd mv er es paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="er es mu"><img src="../Images/f06801bd7402f2f9a3f4b81c2413ffe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oedTEABsoUSlpO5ubaccdw.png"/></div></div></figure><p id="b13f" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">方法 1 :- </strong></p><ul class=""><li id="11b9" class="ky kz hi je b jf jg ji jj jy la jz lb ka lc jx ld le lf lg bi translated">用不同的名字定义不同的函数:calculate_area_rect()和<br/> calculate_area_sqr()</li></ul><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="23a2" class="lm kc hi mg b fi mp mq l mr ms">class Rectangle:<br/>    def calculate_area_rect(self,length,breadth):<br/>        self.length=length<br/>        self.breadth=breadth<br/>        return (self.length*self.breadth)</span><span id="5c45" class="lm kc hi mg b fi mt mq l mr ms">class Square:<br/>    def calculate_area_squar(self,side):<br/>        self.side=side<br/>        return(self.side*self.side)</span><span id="e091" class="lm kc hi mg b fi mt mq l mr ms">obj_rect = Rectangle()  # Instance of Class Rectangle<br/>obj_squar = Square()    # Instance of Class Square</span><span id="641a" class="lm kc hi mg b fi mt mq l mr ms">obj_rect.calculate_area_rect(2,4)<br/>obj_squar.calculate_area_squar(2)</span><span id="65f8" class="lm kc hi mg b fi mt mq l mr ms">print("Area of Rectangle is : ",obj_rect.calculate_area_rect(2,4))</span><span id="5d16" class="lm kc hi mg b fi mt mq l mr ms">print("The Area of Square is : ",obj_squar.calculate_area_squar(4))</span></pre><p id="f54d" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">输出:- </strong></p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="5a04" class="lm kc hi mg b fi mp mq l mr ms">Area of Rectangle is :  8<br/>Area of Square is :  16</span></pre><p id="0ed6" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">这种方法的问题:- <br/> 开发者必须记住&amp;计算面积的两个函数名。在一个更大的程序中，很难记住我们执行的每个小操作的函数名。</p><p id="80e0" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">接下来是<strong class="je hj">方法重载</strong>的作用，这将在后面详细讨论。</p><p id="264b" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">方法 2:- </strong></p><p id="e546" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">现在，让我们将计算面积的函数的名称改为相同的名称 calculate_area()，同时在两个具有不同定义的类中保持这些函数分开。</p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="e4ce" class="lm kc hi mg b fi mp mq l mr ms">class Rectangle:<br/>    def calculate_area(self,length,breadth):<br/>        self.length=length<br/>        self.breadth=breadth<br/>        return (self.length*self.breadth)</span><span id="9a11" class="lm kc hi mg b fi mt mq l mr ms">class Square:<br/>    def calculate_area(self,side):<br/>        self.side=side<br/>        return(self.side*self.side)</span><span id="b2da" class="lm kc hi mg b fi mt mq l mr ms">obj_rect = Rectangle()  # Instance of Class Rectangle<br/>obj_squar = Square()    # Instance of Class Square</span><span id="a90f" class="lm kc hi mg b fi mt mq l mr ms">obj_rect.calculate_area(2,4)<br/>obj_squar.calculate_area(2)</span><span id="9263" class="lm kc hi mg b fi mt mq l mr ms">print("Area of Rectangle is : ",obj_rect.calculate_area(2,4))</span><span id="57f9" class="lm kc hi mg b fi mt mq l mr ms">print("Area of Square is : ",obj_squar.calculate_area(4))</span></pre><p id="87aa" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">输出:- </strong></p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="6713" class="lm kc hi mg b fi mp mq l mr ms">Area of Rectangle is :  8<br/>Area of Square is :  16</span></pre><p id="a51b" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">在这里你可以观察到两个类的实现，例如 Rectangle &amp; Square 有相同的函数名 calculate_area()，但是由于对象不同，它的调用被正确解析。</p><p id="e69c" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">用 object : <br/> i.)obj_rect 调用 calculate_area()会给出矩形<br/> ii 的面积。)obj_squar 将给出正方形的面积</p><p id="f748" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">这种类型的行为是显而易见的，因为我们使用不同的对象，但没有明确证明多态性的定义。</p><h1 id="2199" class="kb kc hi bd kd ke kf kg kh ki kj kk kl ip km iq kn is ko it kp iv kq iw kr ks bi translated">类方法的多态性:-</h1><p id="2a8c" class="pw-post-body-paragraph jb jc hi je b jf kt ik jh ji ku in jk jy kv jn jo jz kw jr js ka kx jv jw jx hb bi translated"><strong class="je hj">方法 3:- <br/> </strong>在这种方法中，一切都保持不变，只是我们引入了一个 for 循环，它将对创建的对象元组进行迭代(将不同的对象打包到一个元组中)</p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="d589" class="lm kc hi mg b fi mp mq l mr ms">class Rectangle:<br/>    def __init__(self,length,breadth):<br/>        self.length=length<br/>        self.breadth=breadth<br/>        <br/>    def cal_area(self):<br/>        return (self.length*self.breadth)</span><span id="c1a2" class="lm kc hi mg b fi mt mq l mr ms">class Square:<br/>    def __init__(self,side):<br/>        self.side = side<br/>        <br/>    def cal_area(self):<br/>        return(self.side*self.side)</span><span id="c922" class="lm kc hi mg b fi mt mq l mr ms"># Instantiating a Class or creating an Object</span><span id="6b2c" class="lm kc hi mg b fi mt mq l mr ms">obj_rect = Rectangle(2,3)  # Instance of Class Rectangle<br/>obj_squar = Square(2)    # Instance of Class Square</span><span id="4bf2" class="lm kc hi mg b fi mt mq l mr ms">for obj in(obj_rect,obj_squar):<br/>         print(obj.cal_area())</span></pre><p id="77d4" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">你可能会想，当我们使用一个循环遍历一组对象时会发生什么？</strong></p><p id="c609" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">回答:- <br/> </strong>这里 Python 并不关心调用函数的对象的类型，语句只是:obj.cal_area()</p><p id="2af4" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">现在这是一个更好的多态例子，因为我们把不同类的对象当作一个可以调用相同函数的对象。</p><p id="8c40" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">您还可以再次回忆一下多态性的定义:</p><p id="b442" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi nc translated">多态支持使用具有不同数据类型输入的单一接口。</p><h1 id="9ccc" class="kb kc hi bd kd ke kf kg kh ki kj kk kl ip km iq kn is ko it kp iv kq iw kr ks bi translated">函数的多态性:-</h1><p id="a4cf" class="pw-post-body-paragraph jb jc hi je b jf kt ik jh ji ku in jk jy kv jn jo jz kw jr js ka kx jv jw jx hb bi translated"><strong class="je hj">方法 4:- <br/> </strong>代替我们在上面的例子中创建的循环，我们也可以创建一个以不同的类对象作为自变量或参数的函数&amp;给出想要的结果。</p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="5187" class="lm kc hi mg b fi mp mq l mr ms">def func(obj):<br/>    return obj.cal_area()</span><span id="955d" class="lm kc hi mg b fi mt mq l mr ms"># Instantiating a Class or creating an Object</span><span id="822c" class="lm kc hi mg b fi mt mq l mr ms">obj_rect = Rectangle(2,3)  # Instance of Class Rectangle<br/>obj_squar = Square(2)    # Instance of Class Square</span><span id="095b" class="lm kc hi mg b fi mt mq l mr ms">print("Area of rectangle is :",func(obj_rect))<br/>print("Area of Square is : ",func(obj_squar))</span></pre><p id="0119" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">输出:- </strong></p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="73ae" class="lm kc hi mg b fi mp mq l mr ms">Area of rectangle is : 6<br/>Area of Square is :  4</span></pre><h1 id="d998" class="kb kc hi bd kd ke kf kg kh ki kj kk kl ip km iq kn is ko it kp iv kq iw kr ks bi translated">Python 中的方法重载</h1><p id="0e8f" class="pw-post-body-paragraph jb jc hi je b jf kt ik jh ji ku in jk jy kv jn jo jz kw jr js ka kx jv jw jx hb bi translated"><strong class="je hj">方法 5:- </strong></p><blockquote class="iy iz ja"><p id="b45c" class="jb jc jd je b jf jg ik jh ji jj in jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">Python 中的两个方法不能有相同的名称(例外情况请参考博客:</p></blockquote><div class="nl nm ez fb nn no"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/unpack-overloading-in-python-da17350c9c75"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">用 Python 解包重载:-</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">在这篇博客中，我们将按以下顺序详细了解 Python 中的重载:-</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">medium.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc na no"/></div></div></a></div><p id="7955" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">重载是函数或运算符基于传递给函数的参数或运算符所作用的操作数以不同方式表现的能力。</p><p id="ae04" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">让我们试着理解下面这段代码:- <br/> </strong>如果 calculate_area()中没有传递任何参数，那么 area 就是 0，如果有一个参数，它假设我们想要的是边*边的正方形的面积，如果传递了两个参数，calculate_area(2，4)就假设这是矩形<br/>的面积，即长度*宽度</p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="2790" class="lm kc hi mg b fi mp mq l mr ms">class FindArea:<br/>    def cal_area(self,length=None,breadth=None):<br/>        self.length=length<br/>        self.breadth=breadth<br/>        if self.length !=None and self.breadth!=None:<br/>            return(self.length*self.breadth)<br/>        elif self.length !=None:<br/>            return(self.length*self.length)<br/>        else:<br/>            return 0</span><span id="251c" class="lm kc hi mg b fi mt mq l mr ms">obj_area = FindArea()</span><span id="ec9e" class="lm kc hi mg b fi mt mq l mr ms">print("Area is :",obj_area.cal_area())<br/>print("Area of Square is :",obj_area.cal_area(4))<br/>print("Area of Rectangle is :",obj_area.cal_area(2,4))</span></pre><p id="8438" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">输出:- </strong></p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="6676" class="lm kc hi mg b fi mp mq l mr ms">Area is : 0<br/>Area of Square is : 16<br/>Area of Rectangle is : 8</span></pre><p id="1a2f" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">现在，作为一名开发人员，重新开始思考，试着记住我们之前的例子，我们在 Rectangle &amp; Square 中创建了不同的对象和不同的函数，并使用各自类的对象名来调用它们。</p><p id="74f7" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">难道你不认为现在用方法重载开发者是有救了吗？不需要在不同的类中记忆不同的函数名。二。)需要创建单个对象，基于不同的参数，我们可以获得矩形、正方形等的面积。</strong></p><h1 id="0ffd" class="kb kc hi bd kd ke kf kg kh ki kj kk kl ip km iq kn is ko it kp iv kq iw kr ks bi translated">具有继承性的多态性:-</h1><p id="61d8" class="pw-post-body-paragraph jb jc hi je b jf kt ik jh ji ku in jk jy kv jn jo jz kw jr js ka kx jv jw jx hb bi translated">python 中的多态性定义了子类中与父类中的方法同名的方法。</p><p id="1513" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">在继承中，子类从父类继承方法。此外，还可以修改子类中从父类继承的方法。</p><p id="136f" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">这主要用于从父类继承的方法不适合子类的情况。这个在子类中重新实现方法的过程被称为<strong class="je hj">方法覆盖。</strong></p><p id="1d93" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">让我们试着理解下面这段代码:- </strong></p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="ff7c" class="lm kc hi mg b fi mp mq l mr ms">class School: # Main Class<br/>    def students_all(self): <br/>        print("There are many Students in Class")<br/>    def student(self):<br/>        print("This is the student function of Class- School")<br/>        <br/>class Student_1(School): # Student1 Sub Class of School<br/>    def student(self):<br/>        print( "This is a student function of:Class Student_1")</span><span id="f462" class="lm kc hi mg b fi mt mq l mr ms">class Student_2(School): # Student2 Sub Class of School<br/>    def student(self):<br/>        print("This is a student function of Class Student_2")<br/>  <br/>    <br/>obj_student_2 = Student_2()<br/>obj_student_2.student()</span><span id="79f4" class="lm kc hi mg b fi mt mq l mr ms">obj_student_1 = Student_1()<br/>obj_student_1.student()</span><span id="8575" class="lm kc hi mg b fi mt mq l mr ms">obj_student = School()<br/>obj_student.student()</span></pre><p id="e829" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated"><strong class="je hj">输出:- </strong></p><pre class="mh mi mj mk fd ml mg mm mn aw mo bi"><span id="6099" class="lm kc hi mg b fi mp mq l mr ms">This is a student function of Class Student_2<br/>This is a student function of:Class Student_1<br/>This is the student function of Class- School</span></pre><p id="bc07" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">由于多态性，Python 解释器自动识别出<code class="du md me mf mg b">student()</code>方法在类<code class="du md me mf mg b">Student_1 </code>和类<code class="du md me mf mg b">Student_2 </code>中被覆盖，并使用在子类中定义的方法。</p><p id="7f9f" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">用 Student_2 <code class="du md me mf mg b">obj_student_2.student()<br/></code>的对象调用<code class="du md me mf mg b">student()</code>方法将首先检查自己类中的<code class="du md me mf mg b">student()</code>方法，即<code class="du md me mf mg b">Student_2</code>，如果不存在，它将在父类中寻找<code class="du md me mf mg b">student()</code>方法，即<code class="du md me mf mg b">School()</code></p><p id="9a8d" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">这就是为什么调用<code class="du md me mf mg b">obj_student_2.student()</code>给出的输出是“这是类 Student_2 的一个学生函数”的原因，与其他函数的方式相同。</p><p id="d4d4" class="pw-post-body-paragraph jb jc hi je b jf jg ik jh ji jj in jk jy jm jn jo jz jq jr js ka ju jv jw jx hb bi translated">不要忘记查看代码库的 GitHub 链接:-<a class="ae od" href="https://github.com/bansalabhay/Python-Skill-Set.git" rel="noopener ugc nofollow" target="_blank"><strong class="je hj">Python 中的多态性</strong> </a></p><blockquote class="iy iz ja"><p id="ebc3" class="jb jc jd je b jf jg ik jh ji jj in jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated"><strong class="je hj">我已经为 Python 中的重载创建了一个详细的博客，其中也考虑到了异常:- </strong></p></blockquote><div class="nl nm ez fb nn no"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/unpack-overloading-in-python-da17350c9c75"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">用 Python 解包重载:-</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">在这篇博客中，我们将按以下顺序详细了解 Python 中的重载:-</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">medium.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc na no"/></div></div></a></div><h2 id="c2a3" class="lm kc hi bd kd ln lo lp kh lq lr ls kl jy lt lu kn jz lv lw kp ka lx ly kr lz bi translated">如果你喜欢这篇文章，请点击👏按钮背书。这将有助于其他媒体用户搜索它。</h2><h2 id="6aec" class="lm kc hi bd kd ln lo lp kh lq lr ls kl jy lt lu kn jz lv lw kp ka lx ly kr lz bi translated"><strong class="ak">请随时在</strong> <a class="ae od" href="http://www.linkedin.com/in/%20abhay-bansal-0aa374a2" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> LinkedIn </strong> </a> <strong class="ak">上联系我，分享你对文章的想法。</strong></h2><p id="a51a" class="pw-post-body-paragraph jb jc hi je b jf kt ik jh ji ku in jk jy kv jn jo jz kw jr js ka kx jv jw jx hb bi translated">随时欢迎反馈😄</p></div></div>    
</body>
</html>