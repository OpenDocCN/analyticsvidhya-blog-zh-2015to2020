<html>
<head>
<title>C++ Memory Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++内存管理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/c-memory-management-a3c1651329bc?source=collection_archive---------13-----------------------#2020-08-28">https://medium.com/analytics-vidhya/c-memory-management-a3c1651329bc?source=collection_archive---------13-----------------------#2020-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="3321" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">可视化记忆</h1><p id="8ba8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下面是内存如何查找堆栈/自动变量的示例:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="fcd0" class="kk ig hi kg b fi kl km l kn ko">int foo()<br/>{<br/>    double d = 3.0;<br/>    return 0;<br/>}</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es kp"><img src="../Images/6fd82a23ac164e4964d4bc33994b25f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*mEjNBDF0rFeBsRNx.png"/></div></figure><p id="f2a3" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">注意当<code class="du ky kz la kg b">foo</code>的作用域结束时<code class="du ky kz la kg b">d</code>被释放。在堆上分配内存时，图片如下所示。指针在堆栈上，分配的内存在堆上。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="4676" class="kk ig hi kg b fi kl km l kn ko">int foo()<br/>{<br/>    double * dptr = new double;<br/>}</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es kp"><img src="../Images/e9c57a4634d3ccbc9d95926fbf5e0f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*1r-gLcs03xYSsXnM.png"/></div></figure><p id="b19a" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">下一个示例显示了位于堆上的指针:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="91b4" class="kk ig hi kg b fi kl km l kn ko">float **ptrToPtr = new float*;<br/>*ptrToPtr = new float;</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es kp"><img src="../Images/d49ca276aef8c23af08ceebe1d7b1b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*vP-t7Hsb5ma7TBj3.png"/></div></figure><h1 id="6e8d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">使用<code class="du ky kz la kg b">new</code>和<code class="du ky kz la kg b">delete</code></h1><p id="9fac" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">不要使用 C 中的<code class="du ky kz la kg b">malloc</code>和<code class="du ky kz la kg b">free</code>，因为它们没有对象初始化和销毁的概念。使用<code class="du ky kz la kg b">new</code>和<code class="du ky kz la kg b">delete</code>代替。使用<code class="du ky kz la kg b">new</code>分配内存，使用<code class="du ky kz la kg b">delete</code>释放内存。当使用原始指针时，每个对<code class="du ky kz la kg b">new</code>的调用必须与对<code class="du ky kz la kg b">delete</code>的调用成对出现。如果系统内存不足，对<code class="du ky kz la kg b">new</code>的调用可能会失败，所以必须有某种方法来处理这种情况。</p><h1 id="ab6e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">数组</h1><p id="2019" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">人们可以将阵列视为保存相同类型数据的连续内存位置，类似于邮箱的排列方式。在堆栈上创建数组时，大小必须在编译时已知。基于堆栈的阵列示例:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="6da6" class="kk ig hi kg b fi kl km l kn ko">int ary[5] = {0};</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es lb"><img src="../Images/f8ae9c933aadc154322e74d33437f202.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*Z_nKEsvGq0n705qd.png"/></div></figure><p id="0a19" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">在堆上使用数组是类似的，只是大小可以在运行时确定。示例:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="1641" class="kk ig hi kg b fi kl km l kn ko">#include &lt;iostream&gt;<br/>using namespace std;<br/>int main()<br/>{<br/>    int numElems = 0;<br/>    cout &lt;&lt; "Enter the number of elements for the array" &lt;&lt;endl;<br/>    cin &gt;&gt; numElems;</span><span id="32a0" class="kk ig hi kg b fi lc km l kn ko">    int* aryPtr = new int[numElems];<br/>}</span></pre><p id="f957" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">如果用户输入 3，可视化如下:</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es kp"><img src="../Images/e7784fd6b1294b55cd9656490e9a56b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*CFzObAQLwvLF17D4.png"/></div></figure><p id="4970" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">对数组版本 new ( <code class="du ky kz la kg b">new[]</code>)的每次调用都应与数组版本 delete ( <code class="du ky kz la kg b">delete[]</code>)成对出现，如下所示:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="e601" class="kk ig hi kg b fi kl km l kn ko">delete[] aryPtr;<br/>aryPtr = nullptr;</span></pre><h1 id="1b54" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">对象数组</h1><p id="1bea" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">对象数组类似于基本类型的数组。示例:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="253b" class="kk ig hi kg b fi kl km l kn ko">class Basic<br/>{<br/>    public: <br/>        Basic() {cout &lt;&lt; "Basic constructor called" &lt;&lt; endl;}<br/>        ~Basic() {cout &lt;&lt; "Basic destructor called" &lt;&lt; endl;}<br/>};</span></pre><p id="ab83" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">如果分配 3 个<code class="du ky kz la kg b">Basic</code>对象的数组，则<code class="du ky kz la kg b">Basic</code>构造函数被调用 3 次:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="c472" class="kk ig hi kg b fi kl km l kn ko">Basic* basicAryPtr = new Basic[3]; <br/>/*Use basicAryPtr here */</span><span id="c49a" class="kk ig hi kg b fi lc km l kn ko">delete[] basicAryPtr;<br/>basicAryPtr = nullptr;</span></pre><p id="cc88" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">照常使用 delete 的数组版本来释放内存，并让析构函数调用相同的次数。</p><p id="45ec" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">如果在堆上存储指向对象的指针，必须在如下所示的循环中调用<code class="du ky kz la kg b">new</code>和<code class="du ky kz la kg b">delete</code>:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="bc07" class="kk ig hi kg b fi kl km l kn ko">int numElems = 3;<br/>Basic **ptrToBasicPtrs = new Basic* [numElems];</span><span id="9876" class="kk ig hi kg b fi lc km l kn ko">for(int k = 0; k &lt; numElems; k++)<br/>{<br/>    ptrToBasicPtrs[k] = new Basic();<br/>}</span><span id="125f" class="kk ig hi kg b fi lc km l kn ko">//Use the objects</span><span id="62e7" class="kk ig hi kg b fi lc km l kn ko">for(int k = 0; k &lt; numElems; k++)<br/>{<br/>    delete ptrToBasicPtrs[k];<br/>}</span><span id="7d41" class="kk ig hi kg b fi lc km l kn ko">//delete the stack pointer<br/>delete[] ptrToBasicPtrs;<br/>ptrToBasicPtrs = nullptr;</span></pre><p id="1674" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">使用 STL 容器存储智能指针比使用数组存储原始指针更好。</p><h1 id="f377" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">多维数组</h1><p id="a287" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">多维数组可以被认为是一个由行和列组成的表格。示例:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="1c2d" class="kk ig hi kg b fi kl km l kn ko">double matrix[3][3];</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es ld"><img src="../Images/3a12e2e0d1e9a7137b5e63d0b55b2c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/0*vFtM6k3PVvdQTGlM.png"/></div></figure><p id="837e" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">然而，在内存中，多维数组以<em class="le">行主</em>顺序线性存储:</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es kp"><img src="../Images/f4adc74178968bb277ce43f26097c93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*541km5GQ-uCcKmMf.png"/></div></figure><h1 id="89c1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">多维堆数组</h1><p id="8375" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">多维数组更棘手，因为需要更多的手动内存分配。下图显示了多维数组在堆上的样子:</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es kp"><img src="../Images/e3b2f70e36d76a583c259c0d4aba9e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*0GiWJEyGsOYOifJA.png"/></div></figure><p id="cf22" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">要为类似于上图中的二维数组分配内存，必须执行以下操作</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="cc13" class="kk ig hi kg b fi kl km l kn ko">double** allocateMatrix(int numRows, int numCols)<br/>{<br/>    double** myMat = new double*[numRows];<br/>    for(int i = 0; i &lt; numRows; i++)<br/>    {<br/>        myMat[i] = new double[numCols];<br/>    }<br/>    return myMat;<br/>}</span></pre><p id="e232" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">要取消分配内存，必须执行以下操作:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="01bd" class="kk ig hi kg b fi kl km l kn ko">void deallocateMatrix(double** myMat, int numRows)<br/>{<br/>    for(int i = 0; i &lt; numRows ; i++)<br/>    {<br/>        delete[] myMat[i]; //Delete columns<br/>    }<br/>    delete[] myMat; //delete rows<br/>}</span></pre><p id="9a9f" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">在现代 C++代码中，更喜欢使用<code class="du ky kz la kg b">vector&lt;T&gt;</code>而不是普通数组。对于二维数组，例如使用<code class="du ky kz la kg b">vector&lt;vector&lt;double&gt;&gt;</code>。</p><h1 id="a123" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">指针转换</h1><p id="29e0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">指针的大小总是一样的，不管它们是指向<code class="du ky kz la kg b">int</code>还是<code class="du ky kz la kg b">double</code>的指针。可以通过以下方式对指针执行强制转换:</p><p id="e248" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">第一种是 C 样式的强制转换(不推荐使用，并且不提供类型安全):</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="e927" class="kk ig hi kg b fi kl km l kn ko">XMLDocument* docPtr = getXMLDocument();<br/>char* charPtr = (char*)docPtr;</span></pre><p id="3090" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">使用<code class="du ky kz la kg b">static_cast</code>，编译器强制执行类型应该相关的规则:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="a151" class="kk ig hi kg b fi kl km l kn ko">XMLDocument *docPtr = getXMLDocument();<br/>char *charPtr = static_cast&lt;char*&gt;(docPtr);</span></pre><h1 id="28ee" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">数组指针关系</h1><p id="8b1c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">数组名是指向数组第一个元素的指针。数组元素也可以按如下方式访问:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="dbbe" class="kk ig hi kg b fi kl km l kn ko">int myAry[3] = {0};<br/>*(myArray) = 1;<br/>*(myArray+1) = 2;<br/>*(myArray+2) = 3;</span></pre><p id="f82d" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">如下所示:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="68fd" class="kk ig hi kg b fi kl km l kn ko">myArray[0] = 1;<br/>myArray[1] = 2;<br/>myArray[2] = 3;</span></pre><p id="48dd" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">当数组被传递给函数时，编译器将数组视为指针。因此，对数组的更改会更改原始数组，而不是副本。</p><h1 id="79d9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">智能指针</h1><p id="6a55" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最简单的智能指针<code class="du ky kz la kg b">std::unique_ptr</code>获得资源的单一所有权，并在它超出范围或被重置时释放底层内存。当所有权被共享时，使用<code class="du ky kz la kg b">std::shared_ptr</code>，它使用<em class="le">引用计数</em>来跟踪对象的所有引用，并且只在最后一个引用被移除时释放内存。</p><h2 id="928b" class="kk ig hi bd ih lf lg lh il li lj lk ip jo ll lm it js ln lo ix jw lp lq jb lr bi translated">智能指针的基本原理</h2><p id="e8fc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">即使是最简单的<code class="du ky kz la kg b">new</code>和<code class="du ky kz la kg b">delete</code>配对也会出问题。例如，考虑以下情况:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="ac6c" class="kk ig hi kg b fi kl km l kn ko">Basic* basicPtr = new Basic();<br/>basicPtr-&gt;doWork();<br/>delete basicPtr;</span></pre><p id="56b1" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">如果<code class="du ky kz la kg b">doWork()</code>抛出异常，则<code class="du ky kz la kg b">delete</code>语句不执行，导致内存泄漏。这种情况下应使用<code class="du ky kz la kg b">std::unique_ptr</code>。当指针超出范围或抛出异常时，底层内存将被释放。使用<code class="du ky kz la kg b">make_unique</code>定义一个<code class="du ky kz la kg b">unique_ptr</code>:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="1a77" class="kk ig hi kg b fi kl km l kn ko">auto myPtr = make_unique&lt;Basic&gt;();<br/>auto myPtr2 = make_unique&lt;Basic&gt;(p1,p2); //constructor parameter variant.</span></pre><p id="1b20" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">因为<code class="du ky kz la kg b">uniwue_ptr</code>代表单一所有权，所以不能复制。但是，可以使用<code class="du ky kz la kg b">std::move</code>移动责任，如本<a class="ae ls" href="https://docs.microsoft.com/en-us/cpp/cpp/how-to-create-and-use-unique-ptr-instances?view=vs-2019" rel="noopener ugc nofollow" target="_blank">文章链接</a>所示。</p><p id="ad3d" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">为了表示共享所有权，使用<code class="du ky kz la kg b">std::shared_ptr</code>。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="34f3" class="kk ig hi kg b fi kl km l kn ko">auto owner1 = make_shared&lt;Basic&gt;();<br/>std::shared_ptr&lt;Basic&gt; owner2(owner1);</span></pre><h1 id="8f2a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考资料:</h1><p id="e11f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">m .格雷瓜尔(2018)。<em class="le">专业 C++ </em>。印第安纳州，约翰·威利的儿子们。</p><div class="lt lu ez fb lv lw"><a href="https://codingadventures1.blogspot.com/2020/02/memory-management.html" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab dw"><div class="ly ab lz cl cj ma"><h2 class="bd hj fi z dy mb ea eb mc ed ef hh bi translated">内存管理</h2><div class="md l"><h3 class="bd b fi z dy mb ea eb mc ed ef dx translated">下面是一个内存如何寻找堆栈/自动变量的例子:注意，当 foo 的作用域…</h3></div><div class="me l"><p class="bd b fp z dy mb ea eb mc ed ef dx translated">codingadventures1.blogspot.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kr lw"/></div></div></a></div></div></div>    
</body>
</html>