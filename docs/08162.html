<html>
<head>
<title>Time Series Modeling —Journey towards forecast.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列建模-预测之旅。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-dirty-hands-48e9805c2132?source=collection_archive---------30-----------------------#2020-07-19">https://medium.com/analytics-vidhya/time-series-dirty-hands-48e9805c2132?source=collection_archive---------30-----------------------#2020-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d51286b8a0ae75cabce213954094740b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdQVimqJMP1TpW2MpFmUOQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Jshoots — Unsplash</figcaption></figure><p id="3a48" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以固定的时间间隔<em class="js">记录时间序列数据。</em></p><p id="5193" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">时间间隔可以是每年、每季度、每月、每周、每天、每小时、分钟、每秒…如果你能有一个更精细的时间间隔，那就多想想。</p><p id="3fbf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，样本可能代表全年的每日库存水平。</p><blockquote class="jt ju jv"><p id="b0a2" class="iu iv js iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><em class="hi">一个产品的一系列市场份额数据可能由几年来的每周市场份额组成。</em></p><p id="0635" class="iu iv js iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><em class="hi">一系列总销售数字可能由多年来每月的一次观察组成。</em></p><p id="1dea" class="iu iv js iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><em class="hi">物联网传感器数据由微米或纳秒级的信息组成，这些信息被分成若干间隔。</em></p></blockquote><p id="7ea7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些例子的共同点是，在一定的时间长度内，以规则的、已知的间隔观察到一些变量。因此，典型时间序列的数据形式是一个单一的序列或观察值列表，代表定期进行的测量。</p><p id="7a6b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇博客中，我们将试着看看它们的样子，以及我们应该采取什么方法来得到一个能够预测的模型。</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="0273" class="ki kj hi ke b fi kk kl l km kn">import statsmodel as sm</span><span id="3866" class="ki kj hi ke b fi ko kl l km kn">#Data Gathering<br/>data = sm.datasets.co2.load_pandas()<br/>co2 = data.data<br/>co2.head()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="ab fe cl kp"><img src="../Images/3088a94d5569f3fdced92e81a49d3129.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hT_lPeEEcKpjNiQfVR2wtw.png"/></div></figure><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="740d" class="ki kj hi ke b fi kk kl l km kn">y = co2['co2'].resample('MS').mean()<br/>#Check for the null values in the dataset<br/>y.isnull().sum()</span></pre><p id="9d1c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您尝试运行上面的单元格，总共找到5个空值，我们必须填补空白。</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="2e64" class="ki kj hi ke b fi kk kl l km kn">y = y.fillna(y.bfill())</span></pre><p id="d313" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当处理时间序列数据时，通过可视化可以揭示很多信息。需要注意的几件事是:</p><ul class=""><li id="bfb6" class="kq kr hi iw b ix iy jb jc jf ks jj kt jn ku jr kv kw kx ky bi translated">季节性:数据是否显示出清晰的周期性模式？</li><li id="af7c" class="kq kr hi iw b ix kz jb la jf lb jj lc jn ld jr kv kw kx ky bi translated">趋势:数据遵循一致的上升或下降趋势吗？</li><li id="5534" class="kq kr hi iw b ix kz jb la jf lb jj lc jn ld jr kv kw kx ky bi translated">噪声:是否存在任何与其余数据不一致的异常点或缺失值？</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="8e72" class="ki kj hi ke b fi kk kl l km kn">df = co2.reset_index()<br/>plt.figure(figsize = (17,8))<br/>sns.lineplot(x="index",<br/>             y="co2",<br/>             data=df,<br/>             err_style="bars",<br/>             markers=True,<br/>             dashes=False,)<br/>plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="ab fe cl kp"><img src="../Images/ae7c453c60d755b3d84a456e1daeea78.png" data-original-src="https://miro.medium.com/v2/format:webp/1*YGX8yF7SvjZ6tpkFuXyUaQ.png"/></div></figure><p id="b89e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">明显可辨的图案清晰可见。该时间序列具有明显的季节性，以及总体上升趋势。我们还可以使用一种叫做时间序列分解的方法来可视化我们的数据。</strong></p><p id="4eae" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个写得很好的关于时间序列数据分解的东西可以在<a class="ae le" href="https://machinelearningmastery.com/decompose-time-series-data-trend-seasonality/#:~:text=Time%20series%20decomposition%20involves%20thinking,time%20series%20analysis%20and%20forecasting." rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们可以尝试加法分解。</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="4df5" class="ki kj hi ke b fi kk kl l km kn">from pylab import rcParams<br/>rcParams['figure.figsize'] = 17, 9<br/><br/>decomposition = sm.tsa.seasonal_decompose(y, model='additive')<br/>fig = decomposition.plot()<br/>plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="ab fe cl kp"><img src="../Images/535ef4c8f5dc95748d3373610b347a96.png" data-original-src="https://miro.medium.com/v2/format:webp/1*2PTHczXPXH680zkQ_9Tgyg.png"/></div></figure><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="9479" class="ki kj hi ke b fi kk kl l km kn"># ARIMA models are denoted with the notation ARIMA(p, d, q).<br/># where -:<br/># p : seasonality<br/># d : trend<br/># q : noise<br/>#Let's generate few p,d,q<br/><br/>p = d = q = range(0, 2)<br/>pdq = list(itertools.product(p, d, q))<br/>seasonal_pdq = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]<br/>print('Parameter combinations for Seasonal ARIMA ::')<br/>print('SARIMAX: {} x {}'.format(pdq[1], seasonal_pdq[1]))<br/>print('SARIMAX: {} x {}'.format(pdq[1], seasonal_pdq[2]))<br/>print('SARIMAX: {} x {}'.format(pdq[2], seasonal_pdq[3]))<br/>print('SARIMAX: {} x {}'.format(pdq[2], seasonal_pdq[4]))</span><span id="16bc" class="ki kj hi ke b fi ko kl l km kn">Parameter combinations for Seasonal ARIMA ::<br/>SARIMAX: (0, 0, 1) x (0, 0, 1, 12)<br/>SARIMAX: (0, 0, 1) x (0, 1, 0, 12)<br/>SARIMAX: (0, 1, 0) x (0, 1, 1, 12)<br/>SARIMAX: (0, 1, 0) x (1, 0, 0, 12)</span><span id="ca13" class="ki kj hi ke b fi ko kl l km kn">## Grid search way to find optimal parameter aka. p,d,q<br/>for param in pdq:<br/>    for param_seasonal in seasonal_pdq:<br/>        try:<br/>            mod = sm.tsa.statespace.SARIMAX(y,<br/>                                            order=param,<br/>                                            seasonal_order=param_seasonal,<br/>                                            enforce_stationarity=False,<br/>                                            enforce_invertibility=False)<br/><br/>            results = mod.fit()<br/>            print('ARIMA{}x{}12 - AIC:{}'.format(param, param_seasonal, results.aic))<br/>        except:<br/>            continue</span></pre><p id="2434" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在运行时:</p><p id="3762" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> ARIMA(0，1，1)x(1，1，1，12)12具有最低的AIC，因此它可能是迄今已知的最佳参数信息。</strong></p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="7b6a" class="ki kj hi ke b fi kk kl l km kn">mod = sm.tsa.statespace.SARIMAX(y,<br/>                                order=(0, 1, 1),<br/>                                seasonal_order=(1, 1, 1, 12),<br/>                                enforce_stationarity=True,<br/>                                enforce_invertibility=False)<br/><br/>results = mod.fit()<br/><br/>print(results.summary().tables[1])<br/> <br/>####################################################################</span><span id="1df4" class="ki kj hi ke b fi ko kl l km kn">pred = results.get_prediction(start=pd.to_datetime('1960-01-01'),dynamic=False)<br/><br/><br/>pred_ci = pred.conf_int()<br/>ax = y['1970':].plot(label='observed')</span><span id="2541" class="ki kj hi ke b fi ko kl l km kn">pred.predicted_mean.plot(ax=ax, <br/>                         label='forecast',<br/>                         color="red",<br/>                         alpha=.7,<br/>                         figsize=(17, 8))</span><span id="d730" class="ki kj hi ke b fi ko kl l km kn">ax.fill_between(pred_ci.index,<br/>                pred_ci.iloc[:, 0],<br/>                pred_ci.iloc[:, 1], <br/>                color='yellow', <br/>                alpha=.1)</span><span id="c354" class="ki kj hi ke b fi ko kl l km kn">ax.set_xlabel('Date')<br/>ax.set_ylabel('CO2_Level')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="ab fe cl kp"><img src="../Images/58511821c9ea8dc944497b2986b67804.png" data-original-src="https://miro.medium.com/v2/format:webp/1*eLxiJbemWXLYizS4BX0uyg.png"/></div></figure><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="19cc" class="ki kj hi ke b fi kk kl l km kn">results.plot_diagnostics(figsize=(17, 12))<br/>plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="ab fe cl kp"><img src="../Images/6acb1b85154ec91e10f33ad88097742e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*IOov2i5ODO6ks2xw-ClxxQ.png"/></div></figure><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="c8b0" class="ki kj hi ke b fi kk kl l km kn">y_forecasted = pred.predicted_mean<br/>y_truth = y['1960-01-01':]<br/>mse = ((y_forecasted - y_truth) ** 2).mean()<br/>print('The Mean Squared Error of our forecasts is {}'.format(round(mse, 2)))</span><span id="6291" class="ki kj hi ke b fi ko kl l km kn">The Mean Squared Error of our forecasts is 0.11</span><span id="5135" class="ki kj hi ke b fi ko kl l km kn">print('The Root Mean Squared Error of our forecasts is {}'.format(round(np.sqrt(mse), 2)))</span><span id="37bc" class="ki kj hi ke b fi ko kl l km kn">The Root Mean Squared Error of our forecasts is 0.33</span></pre><h2 id="7dcc" class="ki kj hi bd lf lg lh li lj lk ll lm ln jf lo lp lq jj lr ls lt jn lu lv lw lx bi translated">静态预测</h2><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="747a" class="ki kj hi ke b fi kk kl l km kn">pred_uc = results.get_forecast(steps=50)<br/>pred_ci = pred_uc.conf_int()<br/>ax = y.plot(label='observed', figsize=(17, 7))<br/>pred_uc.predicted_mean.plot(ax=ax, label='Forecast')<br/>ax.fill_between(pred_ci.index,<br/>                pred_ci.iloc[:, 0],<br/>                pred_ci.iloc[:, 1], color='k', alpha=.25)<br/>ax.set_xlabel('Date')<br/>ax.set_ylabel('CO2_Level')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="ab fe cl kp"><img src="../Images/224ffeae6c49943cec19f45a9cbb23ce.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zGG51BwzRqSCiK2pvJKSgA.png"/></div></figure><h2 id="41d2" class="ki kj hi bd lf lg lh li lj lk ll lm ln jf lo lp lq jj lr ls lt jn lu lv lw lx bi translated">动态预测</h2><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="f7b8" class="ki kj hi ke b fi kk kl l km kn">pred_dynamic = results.get_prediction(start=pd.to_datetime('1998-01-01'), dynamic=True, full_results=True)<br/>pred_dynamic_ci = pred_dynamic.conf_int()<br/><br/>ax = y['1990':].plot(label='observed', figsize=(17, 9))<br/>pred_dynamic.predicted_mean.plot(label='Dynamic Forecast', ax=ax)<br/><br/>ax.fill_between(pred_dynamic_ci.index,<br/>                pred_dynamic_ci.iloc[:, 0],<br/>                pred_dynamic_ci.iloc[:, 1], color='k', alpha=.25)<br/><br/>ax.fill_betweenx(ax.get_ylim(), pd.to_datetime('1998-01-01'), y.index[-1],<br/>                 alpha=.1, zorder=-1)<br/><br/>ax.set_xlabel('Date')<br/>ax.set_ylabel('CO2 Levels')<br/><br/>plt.legend()<br/>plt.show()</span></pre><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="ab fe cl kp"><img src="../Images/d1343abdc8b4ed6446601814bc80279b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0inJPj0X1g89dn82yqQUNA.png"/></div></figure><p id="92c4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有各种各样的时间序列分析技术，如预测不确定性界限，变点和异常检测，预测时间序列与外部数据源，我们可以探索。这只是题目上的一点擦伤。</p><p id="a3cd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于进一步的学习，资源可能是有帮助的。</p><ol class=""><li id="5901" class="kq kr hi iw b ix iy jb jc jf ks jj kt jn ku jr ly kw kx ky bi translated"><a class="ae le" href="https://www.ibm.com/support/knowledgecenter/ko/SSLVMB_23.0.0/spss/trends/trends_introduction.html" rel="noopener ugc nofollow" target="_blank">https://www . IBM . com/support/knowledge center/ko/SSL vmb _ 23 . 0 . 0/SPSS/trends/trends _ introduction . html</a></li><li id="215c" class="kq kr hi iw b ix kz jb la jf lb jj lc jn ld jr ly kw kx ky bi translated"><a class="ae le" href="https://www.machinelearningplus.com/time-series/time-series-analysis-python/" rel="noopener ugc nofollow" target="_blank">https://www . machine learning plus . com/time-series/time-series-analysis-python/</a></li></ol></div></div>    
</body>
</html>