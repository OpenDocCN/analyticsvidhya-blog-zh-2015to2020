<html>
<head>
<title>LSTM Multi-Class Classification— Visual Description and Pytorch Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LSTM多类分类法——直观描述和Pytorch代码</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/classification-with-classic-lstm-visual-description-and-pytorch-code-d7d734573fbb?source=collection_archive---------7-----------------------#2020-03-01">https://medium.com/analytics-vidhya/classification-with-classic-lstm-visual-description-and-pytorch-code-d7d734573fbb?source=collection_archive---------7-----------------------#2020-03-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6c46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很久以前我就想写这篇文章，但是我没有太多的时间。事实上，这篇文章是基于我对LSTM的理解困难而写的，因为我开始了解LSTM分类器。因为我很难理解如何获取LSTM输出并进行分类。我相信一些新手可能会像我早期一样面临同样的问题。</p><p id="d778" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们简短地讨论一下LSTM。那么什么是LSTM呢？简而言之，这是一种长期的短期记忆，是自然语言处理的特殊形式。然而，由于它的多功能性，它被广泛应用于能源、股票和自然语言处理。如果你对LSTM感兴趣并有深入的了解，在'<a class="ae jd" href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank"> Colah </a> <a class="ae jd" href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank">博客</a>有非常好的GitHub源码。</p><p id="b154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么有多少种类型的LSTMs可用呢？基于架构，到目前为止，我已经使用了5种类型的LSTMs。你可以在<a class="ae jd" href="https://blog.exxactcorp.com/5-types-lstm-recurrent-neural-network/" rel="noopener ugc nofollow" target="_blank">这里</a>看到关于LSTMS类型的非常深入的讨论。然而，我要讨论的只是经典的LSTM。</p><p id="b808" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我相信你已经看过前面的链接了，那么LSTM细胞是由什么组成的呢？它有隐藏、输入和输出，如图1所示。它接受一个向量作为输入，给出另一个向量作为输出(暂时忽略c)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/3c5e5490b7ede9c481a0b8d65b253fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlTs5XFgpggVrVMzmOUsoA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图1:一个经典的LSTM电池<a class="ae jd" href="https://blog.exxactcorp.com/5-types-lstm-recurrent-neural-network/" rel="noopener ugc nofollow" target="_blank">【1】</a></figcaption></figure><p id="5834" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只是一个LSTM，所以它只能处理一个向量。然而，如果你有一系列的数据，那么你如何积累呢？嗯，有一个很酷的方法来处理这个问题。正如你所看到的，它接受输入并给出输出，因此，如果你需要在网络中添加另一个LSTM，那么第一层的输出将作为下一层输入的隐藏，这个过程将持续到最后一个LSTM。</p><p id="026e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你困惑了吗？嗯，为了让你更好的理解，我给你画一张照片。如图2所示，我有4个LSTMs。所以，第一个LSTM是把I(t)作为输入隐藏H(t-1)并提供H(t)作为输出。这表明第一个LSTMS输出作为下一个LSTM的输入。这个过程还在继续。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ju"><img src="../Images/bcdbbf38da86818e123e83f55e4bda6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*fS0r3quRJpQolT0lTSRn8w.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图2: LSTM分类器</figcaption></figure><p id="40a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在LSTM 4分类的最后，我们刚刚得到了最后一个LSTM的输出，你必须通过简单的前馈神经网络。例如，我放置了一个密集层来减少输出的维度，这样我就可以将数据放入softmax层并获得分类结果。所以，让我们从数学上看一切，然后我们将跳转到代码中</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="beb5" class="ka kb hi jw b fi kc kd l ke kf">Input Dimension =[4*25] # Here 25 is features<br/>Hidden Input = [1*50]<br/>target = 12 CATEGORY / CLASS</span><span id="d8ff" class="ka kb hi jw b fi kg kd l ke kf">LSTM 1 <br/>input = [1*25] #1st vector of the input<br/>hidden = [1*50]<br/>output = [1*50]</span><span id="91a5" class="ka kb hi jw b fi kg kd l ke kf">LSTM 2<br/>input = [1*25]  #2nd vector of the input<br/>hidden = output(LSTM 1)<br/>output = [1*50]</span><span id="2df3" class="ka kb hi jw b fi kg kd l ke kf">LSTM 3<br/>input = [1*25]  #3rd vector of the input<br/>hidden = output(LSTM 2)<br/>output = [1*50]</span><span id="7acb" class="ka kb hi jw b fi kg kd l ke kf">LSTM 4<br/>input = [1*25] #4th vector of the input<br/>hidden = output(LSTM 3)<br/>output = [1*50]</span><span id="2940" class="ka kb hi jw b fi kg kd l ke kf">Dense<br/>input = output(LSTM 4)<br/>output = [1*12]</span><span id="d5c6" class="ka kb hi jw b fi kg kd l ke kf">Softmax<br/>input = output(Dense)<br/>output = CLASS</span></pre><p id="41b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，如何用代码来实现呢？</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="b646" class="ka kb hi jw b fi kc kd l ke kf">class Network(nn.Module):<br/>    def __init__(self):<br/>        super(Network, self).__init__()<br/>        self.lstmCells = nn.LSTM(25, 50, 4)   <br/>        self.linearLayer = nn.Linear(50, 12)  # equivalent to Dense in keras <br/>        self.softAct = nn.Softmax()<br/>  <br/>    def forward(self, x):<br/>        clsf, _ = self.lstmCells(clsf)<br/>        clsf = self.linearLayer(clsf[:,-1,:])<br/>        clsf = self.softAct(clsf)<br/>        return clsf</span></pre><p id="f359" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，在代码上方，我用24个输入50个隐藏和4个单独的LSTM初始化了一个LSTM。我在一个函数中写了所有3个，你可以这样做，因为Pytorch库自己管理它，你不用担心。我将最后一层的输出“clsf[:，-1，:”推送到密集层，在密集层中将其缩小到我的目标类的数量，我们都设置好了！现在我们为网络的训练过程做好了准备。干杯！！</p><p id="4b27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我已经讨论了如何与LSTM合作进行分类。如果你正在解决回归问题，这都是一样的，只要用你的线性/非线性激活将密集层合并到一维，你就会做得很好。</p></div></div>    
</body>
</html>