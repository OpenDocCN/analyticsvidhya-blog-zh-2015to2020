<html>
<head>
<title>Multi-Channel Attribution Model with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Python的多渠道归因模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/multi-channel-attribution-model-with-python-adcff6a85829?source=collection_archive---------6-----------------------#2020-01-21">https://medium.com/analytics-vidhya/multi-channel-attribution-model-with-python-adcff6a85829?source=collection_archive---------6-----------------------#2020-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/c0f9411d4865ced991858a18187f1a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*XJCrUoaMtyZ585vBbvamTQ.jpeg"/></div></figure><div class=""/><p id="8a87" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一个典型的顾客在网上购物前会经过多个渠道。如果我们知道用户在进行转换之前经过的渠道路径，我们就能够使用渠道属性模型来确定哪个渠道帮助进行了转换。</p><p id="d639" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我将使用google analytics多渠道漏斗报告来确定哪个渠道帮助进行了转化</p><p id="2d1c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Google Analytics中的多渠道漏斗报告以多种途径展示了客户旅程，如下图所示</p><figure class="jl jm jn jo fd hk er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jk"><img src="../Images/7a89b47f5010c6c444bbf93ba9074798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qw3X41oOtSBcO3Wyiapfag.jpeg"/></div></div></figure><p id="a029" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">多渠道漏斗报告给出了两个转化值，即最后点击转化和辅助转化。</p><p id="ab21" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">谷歌分析是给予信贷的最后一个渠道的路径作为最后点击转换，除了最后一个渠道的路径被视为辅助渠道</p><p id="a3ca" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当给予辅助转换时，google对路径中的每个渠道给予相同的权重。但它可能会在优化广告词和脸书的活动时给出错误的信息。为了克服这个问题，我们可以使用渠道属性马尔可夫模型来寻找渠道的辅助转换。</p><p id="5bf4" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你使用python语言来计算信道属性，到目前为止，web上还没有任何包或库或任何资源。对于这种情况，我编写了python代码来查找python中的通道属性。</p><p id="eb16" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">今天我将讲述如何在python中找到通道属性的辅助转换</p><p id="2f4a" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第一步是提取多渠道漏斗报告。要提取多通道报告数据，您可以使用<a class="ae jt" href="https://www.linkedin.com/pulse/google-analytics-multi-channel-funnel-data-extraction-gamwasam/" rel="noopener ugc nofollow" target="_blank">(使用python中的API进行Google Analytics多通道数据提取)</a></p><p id="e214" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">GitHub资源库:<a class="ae jt" href="https://github.com/sherangaG/multichannel-attribution-model-python" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/sherangaG/多渠道-归属-模型-python </a></p><p id="657a" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是我用于代码的<a class="ae jt" href="https://docs.google.com/spreadsheets/d/11pa-eQDHEX63uSEA4eWiDTOZ7lbO6Vwt-dHkuhuhbSo/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank">数据集</a></p><p id="9823" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ju">导入下面的库</em></p><pre class="jl jm jn jo fd jv jw jx jy aw jz bi"><span id="0f23" class="ka kb hp jw b fi kc kd l ke kf">import time<br/>import pandas as pd<br/>import numpy as np<br/>import collections<br/>from itertools import chain<br/>import itertools<br/>from scipy.stats import stats<br/>import statistics</span></pre><p id="d637" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ju">以下函数用于返回唯一列表</em></p><pre class="jl jm jn jo fd jv jw jx jy aw jz bi"><span id="31d5" class="ka kb hp jw b fi kc kd l ke kf">def unique(list1):  <br/>    unique_list = []   <br/>    for x in list1: <br/>        if x not in unique_list: <br/>            unique_list.append(x) <br/>        <br/>    return(unique_list)</span></pre><p id="74e0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ju">下面的函数用于通过“&gt;分割字符串，并返回排序向量升序</em></p><pre class="jl jm jn jo fd jv jw jx jy aw jz bi"><span id="1447" class="ka kb hp jw b fi kc kd l ke kf">def split_fun(path):<br/>    return path.split('&gt;')</span><span id="9d0c" class="ka kb hp jw b fi kg kd l ke kf">def calculate_rank(vector):<br/>  a={}<br/>  rank=0<br/>  for num in sorted(vector):<br/>    if num not in a:<br/>      a[num] = rank<br/>      rank = rank + 1<br/>  return[a[i] for i in vector]</span></pre><p id="60d5" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ju">以下函数用于返回转移矩阵</em></p><pre class="jl jm jn jo fd jv jw jx jy aw jz bi"><span id="65cd" class="ka kb hp jw b fi kc kd l ke kf">def transition_matrix_func(import_data):<br/>    <br/>    import_data_temp = import_data.copy()<br/>     <br/>    import_data_temp['path1'] = 'start&gt;' + import_data_temp['path']<br/>    import_data_temp['path2'] = import_data_temp['path1'] + '&gt;convert'<br/>    <br/>    import_data_temp['pair'] = import_data_temp['path2'].apply(split_fun)<br/>    <br/>    list_temp = import_data_temp['pair'].tolist()<br/>    list_temp = list(chain.from_iterable(list_temp))<br/>    list_temp = list(map(str.strip, list_temp))<br/>    T = calculate_rank(list_temp)<br/>    <br/>    M = [[0]*len(unique(list_temp)) for _ in range(len(unique(list_temp)))]<br/>    <br/>    for (i,j) in zip(T,T[1:]):<br/>        M[i][j] += 1<br/>    <br/>    df_temp = pd.DataFrame(M)<br/>        <br/>    np.fill_diagonal(df_temp.values,0)<br/>    <br/>    df_temp = pd.DataFrame(df_temp.values/df_temp.values.sum(axis = 1)[:,None])<br/>    df_temp.columns = sorted(unique(list_temp))<br/>    df_temp['index'] = sorted(unique(list_temp))<br/>    df_temp.set_index("index", inplace = True) <br/>    df_temp.loc['convert',:] = 0<br/>    return(df_temp)</span></pre><p id="c975" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ju">以下功能用于返回模拟路径</em></p><pre class="jl jm jn jo fd jv jw jx jy aw jz bi"><span id="def8" class="ka kb hp jw b fi kc kd l ke kf">def simulation(trans,n):<br/>   <br/>    sim = ['']*n<br/>    sim[0] = 'start'<br/>    i = 1<br/>    while i&lt;n:<br/>        sim[i] = np.random.choice(trans.columns, 1, p=trans.loc[sim[i-1],:])[0]<br/>        if sim[i] == 'convert':<br/>            break<br/>        i = i+1<br/>        <br/>    return sim[0:i+1]</span></pre><p id="da45" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ju">以下函数用于返回带有p值的辅助转换</em></p><pre class="jl jm jn jo fd jv jw jx jy aw jz bi"><span id="78db" class="ka kb hp jw b fi kc kd l ke kf">def markov_chain(data_set,no_iteration=10,no_of_simulation=10000,alpha=5):<br/><br/><br/>    import_dataset_v1=data_set.copy()<br/>    import_dataset_v1=(import_dataset_v1.reindex(import_dataset_v1.index.repeat(import_dataset_v1.conversions))).reset_index()<br/>    import_dataset_v1['conversions']=1<br/>    <br/>    import_dataset_v1=import_dataset_v1[['path','conversions']]<br/>    <br/>    import_dataset=(import_dataset_v1.groupby(['path']).sum()).reset_index()<br/>    import_dataset['probability']=import_dataset['conversions']/import_dataset['conversions'].sum()<br/>    <br/>    final=pd.DataFrame()<br/>    <br/>    <br/>    for k in range(0,no_iteration):<br/>        start = time.time()<br/>        import_data=pd.DataFrame({'path':np.random.choice(import_dataset['path'],size=import_dataset['conversions'].sum(),p=import_dataset['probability'],replace=True)})<br/>        import_data['conversions']=1                           <br/>    <br/>        tr_matrix=transition_matrix_func(import_data)<br/>        channel_only = list(filter(lambda k0: k0 not in ['start','convert'], tr_matrix.columns)) <br/>    <br/>        ga_ex=pd.DataFrame()<br/>        tr_mat=tr_matrix.copy()<br/>        p=[]<br/>        <br/>        i=0<br/>        while i&lt;no_of_simulation:<br/>            p.append(unique(simulation(tr_mat,1000)))<br/>            i=i+1<br/>           <br/>        <br/>        path=list(itertools.chain.from_iterable(p))<br/>        counter=collections.Counter(path)<br/>        <br/>        df=pd.DataFrame({'path':list(counter.keys()),'count':list(counter.values())})<br/>        df=df[['path','count']]<br/>        ga_ex=ga_ex.append(df,ignore_index=True) <br/>        <br/>        df1=(pd.DataFrame(ga_ex.groupby(['path'])[['count']].sum())).reset_index()<br/>        <br/>        df1['removal_effects']=df1['count']/len(path)<br/>        #df1['removal_effects']=df1['count']/sum(df1['count'][df1['path']=='convert'])<br/>        df1=df1[df1['path'].isin(channel_only)]<br/>        df1['ass_conversion']=df1['removal_effects']/sum(df1['removal_effects'])<br/>                   <br/>        df1['ass_conversion']=df1['ass_conversion']*sum(import_dataset['conversions']) <br/>        <br/>        final=final.append(df1,ignore_index=True)<br/>        end = time.time()<br/>        t1=(end - start)<br/>        print(t1)   <br/>    <br/>    '''<br/>    H0: u=0<br/>    H1: u&gt;0<br/>    '''<br/><br/><br/>    unique_channel=unique(final['path'])<br/>    #final=(pd.DataFrame(final.groupby(['path'])[['ass_conversion']].mean())).reset_index()<br/>    final_df=pd.DataFrame()<br/>    <br/>    for i in range(0,len(unique_channel)):<br/>        <br/>        x=(final['ass_conversion'][final['path']==unique_channel[i]]).values<br/>        final_df.loc[i,0]=unique_channel[i]<br/>        final_df.loc[i,1]=x.mean()<br/>        <br/>        v=stats.ttest_1samp(x,0)<br/>        final_df.loc[i,2]=v[1]/2<br/>        <br/>        if v[1]/2&lt;=alpha/100:<br/>            final_df.loc[i,3]=str(100-alpha)+'% statistically confidence'<br/>        else:<br/>            final_df.loc[i,3]=str(100-alpha)+'% statistically not confidence'<br/>        <br/>        final_df.loc[i,4]=len(x)<br/>        final_df.loc[i,5]=statistics.stdev(x)<br/>        final_df.loc[i,6]=v[0]<br/>        <br/>    final_df.columns=['channel','ass_conversion','p_value','confidence_status','frequency','standard_deviation','t_statistics']       <br/>    final_df['ass_conversion']=sum(import_dataset['conversions']) *final_df['ass_conversion'] /sum(final_df['ass_conversion'])<br/>    <br/>    return final_df,final</span></pre><p id="dd06" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于我们有获得每个通道的辅助转换的函数，我们将导入数据集</p><pre class="jl jm jn jo fd jv jw jx jy aw jz bi"><span id="029a" class="ka kb hp jw b fi kc kd l ke kf"># import the channel attribution example csv <br/><br/>import_dataset = pd.read_csv('channel attribution example.csv')</span></pre><p id="05a1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">执行以下代码以获得与通道相关的辅助转换值。这里有3个参数，分别是数据集、迭代次数、模拟次数和alpha值</p><pre class="jl jm jn jo fd jv jw jx jy aw jz bi"><span id="b6bd" class="ka kb hp jw b fi kc kd l ke kf">data,dataset = markov_chain(import_dataset,no_iteration=10,no_of_simulation=10000,alpha=5)</span></pre><p id="bf04" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出如下所示</p><figure class="jl jm jn jo fd hk er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es kh"><img src="../Images/347bc173d9f64d3643c10be5592b35b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUyS9N-l0he9wbg9THFAcg.jpeg"/></div></div></figure></div></div>    
</body>
</html>