<html>
<head>
<title>Creating an ML model for predicting English Premiership results (or using Machine Learning to figure out if Arsenal will return to the Champions League in 2020–2021)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个预测英格兰超级联赛结果的ML模型(或使用机器学习来计算阿森纳是否会在2020-2021年重返冠军联赛)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-an-ml-model-for-predicting-english-premiership-results-or-using-machine-learning-to-875b369c1b48?source=collection_archive---------10-----------------------#2020-07-05">https://medium.com/analytics-vidhya/creating-an-ml-model-for-predicting-english-premiership-results-or-using-machine-learning-to-875b369c1b48?source=collection_archive---------10-----------------------#2020-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/309d821a472685f4358e0c7c9ce59f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*p3D3wg0gJVoIssjhIPErow.png"/></div></figure><p id="5316" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">大家好！这是我第一篇关于媒介的文章。我将写下我学习机器学习的旅程，让我们开始吧！</p><p id="d00b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在墨西哥长大，所以我只喜欢一项运动。事实上，与其说它是一项运动，不如说它是一种宗教。当然，我说的是足球。你可能已经从上面的图片中推断出，我最喜欢的球队是<a class="ae jk" href="https://www.arsenal.com/" rel="noopener ugc nofollow" target="_blank">阿森纳</a> ( <a class="ae jk" href="https://www.youtube.com/watch?v=VLZeTOID0jU" rel="noopener ugc nofollow" target="_blank">我们跑北伦敦！</a>)所以，当我寻找一些数据时，我希望能找到一些关于足球的东西，尤其是关于阿森纳的。谢天谢地，我找到了这个<a class="ae jk" href="https://www.kaggle.com/irkaal/english-premier-league-results?select=EPL.csv" rel="noopener ugc nofollow" target="_blank">公共Kaggle数据集</a>(感谢<a class="ae jk" href="https://www.kaggle.com/irkaal" rel="noopener ugc nofollow" target="_blank"> Alvin </a>！！)拥有从2000年到2020年3月的每一场英超比赛的结果。</p><p id="ff93" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们要做的是利用这个数据集，建立一个神经网络来预测未来英超比赛的结果。即使利物浦已经赢得了冠军，阿森纳仍然有机会晋级冠军联赛，所以我们需要知道这是否可能发生。具体来说，我们要做的是:</p><ul class=""><li id="8025" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">创建一个Jupyter笔记本，我们将在其中进行所有的计算</li><li id="172e" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">下载艾尔文的数据集</li><li id="15b0" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">可视化数据集的几个维度</li><li id="8a5d" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">对数据进行预处理，以便将其输入神经网络</li><li id="e8b8" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">将数据分成训练集和测试集</li><li id="342c" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">创建一个神经网络</li><li id="acc8" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">用我们的训练数据训练神经网络</li><li id="b0b6" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">用我们的测试数据来测试我们的神经网络有多好</li><li id="5ec6" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用TensorFlow模型服务将我们的模型部署为API</li><li id="e656" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">让我们的API预测阿森纳剩余比赛的所有结果，看看我们是否能重返冠军联赛</li></ul><h1 id="593e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">创建Jupyter笔记本</strong></h1><p id="1b75" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">我们可以在许多环境中创建我们的笔记本，但我们将使用<a class="ae jk" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> google colab </a>来托管我们的笔记本。只要转到那个网址，你就会立即进入你的第一个笔记本。如果是第一次，您应该会看到类似下图的内容:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lc"><img src="../Images/2aaba671b47f0bf886746cd8969c5eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eFwHSSksVgZ1iLj-cbpNbQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">Google Colab欢迎屏幕</figcaption></figure><p id="6038" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以开始在笔记本上添加数据和代码了。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="be0f" class="jz ka hi bd kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw bi translated"><strong class="ak">下载我们的数据</strong></h1><p id="c036" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">我们可以在Kaggle的环境中创建我们的笔记本，但我已经在我参加的一些Coursera ML课程中使用了Google Colab，所以我使用了我熟悉的东西。</p><p id="6f09" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们有很多方法可以下载艾尔文的数据集。我所做的是将它下载到我的Google Drive上，从那里我可以将数据集下载到colab笔记本上。因此，我们需要做的第一件事是导入我们需要的所有库，并安装我们的驱动器，以便我们的colab笔记本可以访问它的文件系统。您的colab单元格看起来会像这样:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="45af" class="mg ka hi mc b fi mh mi l mj mk">import pandas as pd<br/>import tensorflow as tf<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import os<br/>import codecs, json<br/>import tempfile<br/>import requests<br/>import base64</span><span id="4dc7" class="mg ka hi mc b fi ml mi l mj mk">from google.colab import drive</span><span id="d1cb" class="mg ka hi mc b fi ml mi l mj mk">drive.mount("/content/drive")</span></pre><p id="9844" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦你执行了这个单元，google将带你通过一个授权周期，这个授权周期包括让Google Drive访问你的colab笔记本。一旦发生这种情况，驱动器被安装。我们可以运行一个<em class="mm"> ls </em>命令来确保驱动器已经安装:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="b811" class="mg ka hi mc b fi mh mi l mj mk">!ls /content/drive</span></pre><p id="2011" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你的回答应该是下图这样的。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mn"><img src="../Images/1c89b086aa27b8d47f55d4f9897c452e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_DJnvQwnC9srgHXh0Wg_Q.png"/></div></div></figure><p id="947b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">酷！我们的硬盘已经装好了。我们的文件在“/content/drive/My Drive/”下，所以从这里我可以去寻找我们想要使用的数据集。我将其命名为EPLresults.csv，因此我们将把这个csv文件加载到pandas数据帧中，并显示该文件的前几行。下面的代码完成这些任务:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="a1b2" class="mg ka hi mc b fi mh mi l mj mk">file_path = "/content/drive/My Drive/EPLresults.csv"</span><span id="fb17" class="mg ka hi mc b fi ml mi l mj mk">my_df = pd.read_csv(file_path)</span><span id="a596" class="mg ka hi mc b fi ml mi l mj mk">print('The shape of our dataset is ', my_df.shape)</span><span id="e551" class="mg ka hi mc b fi ml mi l mj mk">my_df.head()</span></pre><p id="1dd6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您应该得到的结果如下图所示:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mo"><img src="../Images/aff8e7e9ce6c5206e5df4bfea1066f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4PxNqr4tiom1dk7jIzUFQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">显示了英超比赛数据集中的前几行</figcaption></figure><p id="1bae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如我们所看到的，我们的数据集有7，386行(这是很多足球比赛！)每行22列。我们可以看到一些行是:</p><ul class=""><li id="e64c" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">玩游戏的日期</li><li id="793d" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">主队</li><li id="52d1" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">客场球队</li><li id="4dac" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">全职结果(FTR)</li></ul><p id="7f3c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">诸如此类。你可以在这里看到所有<a class="ae jk" href="https://www.kaggle.com/irkaal/english-premier-league-results" rel="noopener ugc nofollow" target="_blank">栏目的描述。好了，我们有了所有的列，但是我们需要检查它们是什么类型。你会问为什么？嗯，一个原因是因为神经网络不接受字符串作为输入。让我们用下面的命令来看看列类型:</a></p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="30d5" class="mg ka hi mc b fi mh mi l mj mk">my_df.info()</span></pre><p id="5567" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您的输入应该如下图所示:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/c53ec8e4e82787119e9ac034bb097612.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*RLRtwI7OazCacZdSLVj0JQ.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">超级联赛游戏数据集的列类型</figcaption></figure><p id="402a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好，我们有16个int列和6个object列。记住这个事实，因为我们稍后将需要修改对象列，以便它们可以用作我们的神经网络的输入。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="a42a" class="jz ka hi bd kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw bi translated">可视化我们的数据</h1><p id="53e6" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">建议我们做一些可视化来熟悉我们的数据集。我们将为这个数据集做几个。</p><p id="95c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第一个是全职结果的频率(FTR)。我们想知道哪种结果更普遍:主队赢，客队赢还是平局。我们将使用matplotlib来绘制全职结果的直方图。代码如下所示:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="c7f4" class="mg ka hi mc b fi mh mi l mj mk">fig, chart = plt.subplots()<br/>data = my_df['FTR'].value_counts()</span><span id="2cc2" class="mg ka hi mc b fi ml mi l mj mk">points = data.index<br/>frequency = data.values</span><span id="62cf" class="mg ka hi mc b fi ml mi l mj mk">chart.bar(points, frequency)</span><span id="82e4" class="mg ka hi mc b fi ml mi l mj mk">chart.set_title('Frequency of different results in the English Premiership (2001-2020) ')<br/>chart.set_xlabel('Result Type')<br/>chart.set_ylabel('Frequency')</span></pre><p id="0de1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们得到的直方图如下所示:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/cc1ad38d8f5d85318cac515167b47eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*2RjTMYJqTxWvHHzsAkge0A.png"/></div></figure><p id="2f57" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以看到主场胜利比客场胜利更普遍，这是有道理的。在足球比赛中，观众总是一个重要的因素。然后我们可以推断，打了最多主场比赛的球队最有可能获胜，因此，更有可能赢得冠军和/或获得冠军联赛的资格。</p><p id="2b6d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用类似上面的代码，让我们画出每支英超球队主场比赛的数量。生成的直方图如下所示:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/a45d327fd3dc172ddce3a512453ef7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*USUhKtka525c77iMfGvgxA.png"/></div></figure><p id="24ec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有点难以理解，但我们可以看到大约有6支球队拥有最多的主场比赛:切尔西、埃弗顿、曼联、利物浦、热刺和阿森纳。你会认为其中一支球队最有可能赢得冠军，这6支球队最有可能在积分榜上排名第一，因此最有可能参加冠军联赛。</p><p id="0fc4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以想象其他的维度，但是现在让我们停在这里。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="cc3a" class="jz ka hi bd kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw bi translated"><strong class="ak">数据预处理</strong></h1><p id="fc68" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">现在，我们有了决定将哪些列用作神经网络输入所需的数据。在此之前，我们将制作数据框的副本，并在该副本上进行所有列更改。为什么？我们希望保留原始数据帧，以防我们在新数据帧中搞砸了列转换。</p><p id="ae2e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好，那么我们保留哪些列，去掉哪些列，如果有的话？</p><p id="a861" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们肯定需要参加比赛的球队和统计数据，如犯规次数、黄牌数、红牌数和半场比分。所有这些栏目看起来都像是帮助我们预测未来游戏分数的功能。其他几个专栏呢？</p><p id="0e9b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">先说裁判。裁判对比赛有着巨大的影响，但这个数据集包含了过去20个赛季的比赛。一些裁判已经退休了，所以我不确定使用裁判栏是否能帮助我们预测。出于这个原因，我们将放弃它。</p><p id="392e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面的代码创建了我们的dataframe副本并删除了referee列。我们还打印前几行，以确认referee列已删除。</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="ea41" class="mg ka hi mc b fi mh mi l mj mk">epl_df_objects = my_df.copy()<br/>epl_df_objects.drop('Referee', axis=1, inplace=True)</span><span id="06ed" class="mg ka hi mc b fi ml mi l mj mk">epl_df_objects.head()</span></pre><p id="3c94" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您应该会看到这样的结果:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ms"><img src="../Images/9256b8df6173f3afb253b6b8f7dad062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgrl6IwBBoI10NSREmqWuA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">删除Referee列后的Dataframe列</figcaption></figure><p id="8a6d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">很好，我们可以看到我们现在有21列(所有我们最初拥有的列减去我们刚刚删除的referee列)。</p><p id="68c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在继续之前，让我们检查一下我们的数据集是否有空值。如果是这样，我们将需要修复它们。下面的命令将显示我们的数据集中有多少空值:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="0e34" class="mg ka hi mc b fi mh mi l mj mk">print(epl_df_objects.isnull().values.sum())</span></pre><p id="47ba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">结果应该是0。这太棒了！Alvin将我们从修复数据集的繁琐过程中解救了出来。艾尔文的爸爸！！！</p><p id="8816" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们现在可以转到其他栏目了。比赛的日期怎么样？我要说的是，我们不太关心实际的日子，而是更关心一周中的某一天。英超比赛通常在周六、周日和周一进行。如果你在一个比赛日的周一比赛，你有一周的时间为下一个比赛日恢复。然后，我们可以假设周一比赛的球队在下周的比赛中处于劣势，他们更有可能输掉或打平那场比赛。然而，我们也可以提出相反的论点:周一比赛的球队比周末比赛的球队有更长的休息时间，所以他们可能有更好的机会赢得周一的比赛。无论如何，看起来星期几确实是一个因素，所以我们将把它包括在内。然后，我们将把日期列转换成星期几列。下面的代码实现了这一点:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="f2fa" class="mg ka hi mc b fi mh mi l mj mk">epl_df_objects["matchDate"] = pd.to_datetime(epl_df_objects["Date"], infer_datetime_format=True)</span><span id="1452" class="mg ka hi mc b fi ml mi l mj mk">epl_df_objects['matchDay'] = epl_df_objects['matchDate'].dt.day_name()</span><span id="d465" class="mg ka hi mc b fi ml mi l mj mk">print(epl_df_objects["matchDate"][0])<br/>print(epl_df_objects['matchDay'][149])</span><span id="a042" class="mg ka hi mc b fi ml mi l mj mk">epl_df_objects.drop('Date', axis=1, inplace=True)<br/>epl_df_objects.drop('matchDate', axis=1, inplace=True)<br/>epl_df_objects.head()</span></pre><p id="8f16" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们做了什么？首先，我们创建了一个新的dataframe列matchDate，它转换日期字符串列(还记得我们打印所有列类型时它有一个“object”类型吗？)转换为python <em class="mm"> datetime </em>对象。然后，我们将一周的日期提取到一个新的dataframe列中，我们称之为“比赛日”。然后我们打印一个比赛日实例，在本例中是第149行，只是为了确保我们得到了我们需要的东西。这两个drop命令删除了我们不再需要的列。最后，我们打印几行数据帧来确认我们的数据帧是正确的。您应该会看到如下所示的输出:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mt"><img src="../Images/3a4a37144f5cd80b5980339e2532f13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTxIjOFqOdckqL3Y0LVm7A.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">一旦我们将日期转换为星期几列</figcaption></figure><p id="6d19" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对学校来说很酷！！我们在做生意。现在，我们需要查看其余的对象/字符串列，并决定我们将如何处理它们。我们肯定希望这些列作为我们的神经网络的输入，因为它们是像主队和客场队这样的列。我们需要把它们转换成数字。一种方法是把它们转换成数字，这样我们可以得到阿森纳= 1，阿斯顿维拉= 2等等。这很好，但不完全好。假设我们总共有50支球队，阿森纳= 1，西汉姆是最后一支，因此是50。这是否意味着我们的神经网络将给予西汉姆50倍于阿森纳的权重？我们不想那样。为了解决这个问题，我们将使用<em class="mm"> get_dummies </em> dataframe命令。<em class="mm"> get_dummies </em>命令将为每个团队及其状态创建虚拟列，这样我们将拥有相等的值。我们将得到如下所示的列:</p><ul class=""><li id="acb3" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">主队_阿森纳</li><li id="55e9" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">主场球队_阿斯顿维拉</li><li id="9dd8" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">纽卡斯尔客场队</li></ul><p id="969d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">诸如此类。这样的列将具有二进制值:除了实际参与该游戏的主队和客场队之外，所有球队的值都是0。我们现在已经消除了特征权重问题。用机器学习的话来说，我们已经将分类特征(具有一组有限的值且这些值之间没有排序的特征)转换为二元/指示变量。下面的代码为主队、客场队、HTR和比赛日功能完成了这个任务。</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="ee61" class="mg ka hi mc b fi mh mi l mj mk">epl_df_objects = pd.get_dummies(epl_df_objects, columns=['HomeTeam'], prefix = ['HomeTeam'])<br/>epl_df_objects = pd.get_dummies(epl_df_objects, columns=['AwayTeam'], prefix = ['AwayTeam'])<br/>epl_df_objects = pd.get_dummies(epl_df_objects, columns=['HTR'], prefix = ['HTR'])<br/>epl_df_objects = pd.get_dummies(epl_df_objects, columns=['matchDay'], prefix = ['matchDay'])</span><span id="09cd" class="mg ka hi mc b fi ml mi l mj mk">epl_df_objects.head()</span></pre><p id="7f57" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们现在有更多的列。下面我们将展示其中的几个新栏目。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mu"><img src="../Images/9b3c93e275525e2b49bfc5508e438bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGQiaMgFOSwktkWGf9AAqQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">一些新的二元变量</figcaption></figure><p id="26d9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好了，现在我们有了要输入神经网络的所有特征。标签怎么样？很高兴你问了。标签上有字母，所以我们需要将这些字母转换成数字。为了做到这一点，我们使用sklearn的<a class="ae jk" href="https://scikit-learn.org/stable/modules/preprocessing_targets.html" rel="noopener ugc nofollow" target="_blank"> LabelEncoder </a>，然后我们打印唯一的值来确认我们有数字。</p><p id="800f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们打印3个不同比赛的全职结果，这样我们就可以知道哪个数字代表哪个结果(主队获胜，客场获胜或平局)。最后，我们将所有特征分配给一个中间变量。下面的代码完成了所有这些操作。</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="04fd" class="mg ka hi mc b fi mh mi l mj mk">from sklearn.preprocessing import LabelEncoder<br/>label_encoder = LabelEncoder()</span><span id="294b" class="mg ka hi mc b fi ml mi l mj mk">epl_df_objects['FTR']= label_encoder.fit_transform(epl_df_objects['FTR'])</span><span id="dbf3" class="mg ka hi mc b fi ml mi l mj mk">print('Unique values for our label are: ', epl_df_objects['FTR'].unique())</span><span id="b49e" class="mg ka hi mc b fi ml mi l mj mk">print('if the home team wins the label is ', epl_df_objects['FTR'][0])<br/>print('if the away team wins the label is ', epl_df_objects['FTR'][2])<br/>print('if there is a tie the label is ', epl_df_objects['FTR'][3])</span><span id="0705" class="mg ka hi mc b fi ml mi l mj mk">label = epl_df_objects['FTR']</span><span id="b788" class="mg ka hi mc b fi ml mi l mj mk">print('the result for the match in row 149 is ', label[149])</span><span id="36db" class="mg ka hi mc b fi ml mi l mj mk">print(epl_df_objects.iloc[:,3:113])</span><span id="b779" class="mg ka hi mc b fi ml mi l mj mk">features = epl_df_objects.iloc[:,3:113]</span></pre><p id="271f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们应该得到如下所示的输出:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mv"><img src="../Images/5d5a122fdcb2853c9a2bf4c4794d639f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aGj-f2om1On835JDjtHlg.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">将标签转换为数字后的输出</figcaption></figure><p id="db0e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">很好，我们可以看到我们有三个唯一的值，我们还可以看到0表示客队赢了，1表示平局，2表示主队赢了。我们还可以看到，我们现在有110个特征，我们将输入到我们的神经网络；这与我们在本练习开始时拥有的最初的21个特性相比有很大的变化。</p><p id="0903" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">唷！至此，我们已经完成了数据的预处理。如你所见，这花了我们不少时间。</p><h1 id="7469" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">创建训练集和测试集</h1><p id="63d6" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">我们如何将我们的特性分解成训练集和测试集？好吧，一个建议是把原始数据集的67%作为训练集，剩下的作为测试集。我们将采纳这个建议，我们将使用sklearn的<em class="mm"> train_test_split </em>来进行拆分。</p><p id="cb5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面的代码显示了测试分割。分割之后，我们打印出结果训练集和测试集的形状，看看每一个上有多少行。</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="7f61" class="mg ka hi mc b fi mh mi l mj mk">from sklearn.model_selection import train_test_split</span><span id="9fd5" class="mg ka hi mc b fi ml mi l mj mk">y=np.ravel(label)</span><span id="6961" class="mg ka hi mc b fi ml mi l mj mk">X = features<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, shuffle=False)</span><span id="5685" class="mg ka hi mc b fi ml mi l mj mk">print("The shape of X_train is " + str(X_train.shape))<br/>print("The size of y_train is " + str(y_train.shape))<br/>print("The size of X_test set is " + str(X_test.shape))<br/>print("The size of y_test is " + str(y_test.shape))<br/></span></pre><p id="3365" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您的输出应该类似于下面的内容:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/fc03ae66c817bdb610f81e0da5ae93db.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*fcqC63UEWczhsX0eiHq9bg.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">定型集和测试集形状</figcaption></figure><p id="bd8f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，我们执行最后一个数据处理练习:我们使用keras '<em class="mm">to _ quantitative</em>命令将我们的标签转换为一个独热编码变量，如下面的代码片段所示。然后，我们打印一个热编码y集的形状，并打印一行训练标签，以确认标签是一个热编码的。</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="41cd" class="mg ka hi mc b fi mh mi l mj mk">#one hot-encoding y_train and y_test</span><span id="6275" class="mg ka hi mc b fi ml mi l mj mk">y_train = tf.keras.utils.to_categorical(y_train, num_classes=3)<br/>y_test = tf.keras.utils.to_categorical(y_test, num_classes=3)</span><span id="d9d5" class="mg ka hi mc b fi ml mi l mj mk">print("The size of y_train is " + str(y_train.shape))<br/>print("The size of y_test is " + str(y_test.shape))</span><span id="cf0e" class="mg ka hi mc b fi ml mi l mj mk">print(y_train[0])</span></pre><p id="a422" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的输出应该是这样的:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/ef4e229436b6eaf6c232a85299bd0e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*8vTzctpf24N8HsdyU8UJoA.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">标签集的形状和我们的一个一键编码标签的例子</figcaption></figure><p id="c3c2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以继续我们的神经网络。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="0686" class="jz ka hi bd kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw bi translated">创建神经网络</h1><p id="d480" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">我们创建我们的神经网络如下:</p><ul class=""><li id="44cb" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">一个输入为110个要素的图层，对应于我们要输入到数据集的要素数量</li><li id="3f28" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">一个中间层</li><li id="cfc8" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">一个输出层，带有激活softmax和3个输出，对应于我们的3种可能的结果:主队获胜，客场获胜或平局。我们使用<a class="ae jk" href="https://www.machinecurve.com/index.php/2020/01/08/how-does-the-softmax-activation-function-work/" rel="noopener ugc nofollow" target="_blank"> softmax </a>作为激活，因为我们有两个以上的可能结果。(如果我们只有2个结果，我们将使用<a class="ae jk" href="https://en.wikipedia.org/wiki/Sigmoid_function" rel="noopener ugc nofollow" target="_blank"> sigmod </a>作为激活函数。)</li></ul><p id="9591" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面的代码创建神经网络，打印模型摘要并编译它:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="0f07" class="mg ka hi mc b fi mh mi l mj mk">model = tf.keras.models.Sequential([</span><span id="bee0" class="mg ka hi mc b fi ml mi l mj mk">tf.keras.layers.Dense(330, input_dim=110, activation='relu'),</span><span id="0de2" class="mg ka hi mc b fi ml mi l mj mk">tf.keras.layers.Dense(10, input_dim=330, activation='relu'),</span><span id="28b7" class="mg ka hi mc b fi ml mi l mj mk">tf.keras.layers.Dense(3,activation='softmax')</span><span id="3bc4" class="mg ka hi mc b fi ml mi l mj mk">])</span><span id="8172" class="mg ka hi mc b fi ml mi l mj mk">model.summary()</span><span id="e807" class="mg ka hi mc b fi ml mi l mj mk">model.compile(loss = 'categorical_crossentropy', optimizer='adam', metrics=['accuracy'])</span></pre><p id="8e29" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的输出应该类似于下面的内容:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es my"><img src="../Images/e8665076c0536eba681255a574f96e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*G75vHWsM9czxoa2kZ9WGYg.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">我们的神经网络模型的模型总结</figcaption></figure><h1 id="ea77" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">用训练数据训练神经网络</strong></h1><p id="2ba9" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">我们现在可以用训练数据集来训练神经网络。我们通过下面的代码来实现这一点:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="a797" class="mg ka hi mc b fi mh mi l mj mk">history = model.fit(X_train, y_train, epochs=65)</span></pre><p id="9402" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以下是最近几个时期的输出:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mz"><img src="../Images/e106d0feec9fa750e97b0dea1ebba7fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b9Oh18O4kRsnoT6iifW3Zw.png"/></div></div></figure><p id="1830" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们注意到了什么？我们可以看到损失函数在下降，精度在上升，这很好。让我们绘制我们的损失函数和准确性，以更好地了解它们在我们训练模型时是如何变化的。我们通过下面的代码来实现这一点:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="99d1" class="mg ka hi mc b fi mh mi l mj mk">#accuracy history<br/>plt.plot(history.history['accuracy'])<br/>plt.title('model accuracy')<br/>plt.ylabel('accuracy')<br/>plt.xlabel('epoch')<br/>plt.legend(['train'], loc='upper left')<br/>plt.show()</span><span id="9139" class="mg ka hi mc b fi ml mi l mj mk">#loss history<br/>plt.plot(history.history['loss'])<br/>plt.title('model loss')<br/>plt.ylabel('loss')<br/>plt.xlabel('epoch')<br/>plt.legend(['train'], loc='upper left')<br/>plt.show()</span></pre><p id="e2b5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">生成的两个图表如下所示。当我们训练模型时，我们可以看到我们的模型损失在下降，模型精度在上升。还要注意，在两张图表的末尾，我们看到函数变得不稳定:上下波动。这表明我们可能不需要运行最后一个时期，因此，对于未来的培训课程，我们可以减少时期的数量。</p><div class="ld le lf lg fd ab cb"><figure class="na ij nb nc nd ne nf paragraph-image"><img src="../Images/09b03fe987c08b6aebe77d08dc6735e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*-RI00Myg9AKJlJ35O_jz5w.png"/></figure><figure class="na ij nb nc nd ne nf paragraph-image"><img src="../Images/86796409f769179131e679e0046bbd57.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*xCb7AtFFwGTT39Gkf28Lhw.png"/><figcaption class="ll lm et er es ln lo bd b be z dx ng di nh ni translated">我们的训练模型的损失和准确性</figcaption></figure></div></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="6309" class="jz ka hi bd kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw bi translated">用测试数据测试我们的神经网络</h1><p id="70e3" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">那么我们的结果好吗？是的，但是它们太好了吗？我们面临的一个危险是，我们让模型过度适应训练数据。这意味着我们的模型在训练数据集上表现很好，但在其他数据上表现不佳。</p><p id="ebd1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们怎么知道呢？我们将用测试数据来测试我们的模型，看看我们会得到什么样的结果。用测试集测试模型的代码如下:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="f840" class="mg ka hi mc b fi mh mi l mj mk">score = model.evaluate(X_test, y_test, verbose=1)</span><span id="ec10" class="mg ka hi mc b fi ml mi l mj mk">print("Test Score:", score[0])<br/>print("Test Accuracy:", score[1])</span></pre><p id="520c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们得到下面的结果。正如我们所怀疑的，我们过度拟合，模型精度和损失不能很好地转化为我们的测试集。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es nj"><img src="../Images/c0e2fb95d36375a505cb9fd2e8c8989d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wz0pIofqwglhKAzSoN3ECg.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">用测试数据评估我们的模型的损失和准确性</figcaption></figure><p id="8671" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以这里有一个岔路口。我们可以花更多的时间来改变我们的模型，以减少过度拟合，或者继续将模型作为API部署，看看阿森纳是否会进入冠军联赛。我们将继续部署，并在未来的帖子中优化我们的模型。</p><p id="f118" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们用我们的模型做一个预测，看看我们会得到什么。我们将输入2020年7月1日进行的阿森纳对诺维奇的比赛。下面的代码创建发送给模型的数据，接收预测并打印出来。</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="b7e5" class="mg ka hi mc b fi mh mi l mj mk">Xnew = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]])</span><span id="04f4" class="mg ka hi mc b fi ml mi l mj mk">print(Xnew.shape)</span><span id="65ee" class="mg ka hi mc b fi ml mi l mj mk"># make a prediction<br/>ynew = np.argmax(model.predict(Xnew), axis=-1)</span><span id="4468" class="mg ka hi mc b fi ml mi l mj mk"># show the inputs and predicted outputs<br/>print("X = %s " % Xnew)<br/>print("Prediction = %s" % ynew[0])</span></pre><p id="362e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出如下所示。我们的模型预测主队会赢，而碰巧阿森纳赢了那场比赛。即使一个模型有59%的准确率，有时也是正确的:-)</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es nk"><img src="../Images/f0b6fdee28eb0048ae918892ec5ea89d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*mlCRKvdXaqM_G1Y0U6hwBg.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">向我们的模型发送预测并打印输出</figcaption></figure><p id="c499" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以继续将我们的模型作为API进行部署。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="6d3f" class="jz ka hi bd kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw bi translated">使用TensorFlow模型服务将我们的模型部署为API</h1><p id="153a" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">我们需要做的第一件事是用下面的代码保存我们的模型文件。</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="42b7" class="mg ka hi mc b fi mh mi l mj mk">MODEL_DIR = tempfile.gettempdir()<br/>version = 1</span><span id="3d16" class="mg ka hi mc b fi ml mi l mj mk">export_path = os.path.join(MODEL_DIR, str(version))</span><span id="347b" class="mg ka hi mc b fi ml mi l mj mk"><br/>if os.path.isdir(export_path):<br/>    print('\nAlready saved a model, cleaning up\n')<br/>    !rm -r {export_path}</span><span id="7ef0" class="mg ka hi mc b fi ml mi l mj mk">model.save(export_path, save_format="tf")</span><span id="eee0" class="mg ka hi mc b fi ml mi l mj mk">print('\nexport_path = {}'.format(export_path))</span><span id="4358" class="mg ka hi mc b fi ml mi l mj mk">!ls -l {export_path}</span></pre><p id="6e4f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的模型保存在一个临时目录中，如下所示:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es nl"><img src="../Images/47d9091f11b7470176e7dd877c059890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*WSKM_5nUmVMHaQHF-SxbHQ.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">我们的模型文件保存在一个临时目录中</figcaption></figure><p id="ae31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以下载张量流模型服务器代码:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="5540" class="mg ka hi mc b fi mh mi l mj mk">!echo "deb http://storage.googleapis.com/tensorflow-serving-apt stable tensorflow-model-server tensorflow-model-server-universal" | tee /etc/apt/sources.list.d/tensorflow-serving.list &amp;&amp; \</span><span id="6d27" class="mg ka hi mc b fi ml mi l mj mk">curl https://storage.googleapis.com/tensorflow-serving-apt/tensorflow-serving.release.pub.gpg | apt-key add -</span><span id="acb1" class="mg ka hi mc b fi ml mi l mj mk">!apt update</span></pre><p id="d69c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">并安装服务器:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="f018" class="mg ka hi mc b fi mh mi l mj mk">!apt-get install tensorflow-model-server</span></pre><p id="001f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您应该会看到如下所示的输出:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es nm"><img src="../Images/697db4e46f69e8e3dc67d334ac3d0caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dp9SQ_uHG5dE-E_D8xQzQg.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">安装模型服务库后的输出</figcaption></figure><p id="4850" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">酷，现在我们可以运行我们的api服务器了:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="e8c5" class="mg ka hi mc b fi mh mi l mj mk">os.environ["MODEL_DIR"] = MODEL_DIR</span><span id="03a2" class="mg ka hi mc b fi ml mi l mj mk">%%bash --bg</span><span id="fb51" class="mg ka hi mc b fi ml mi l mj mk">nohup tensorflow_model_server \<br/>--rest_api_port=8501 \<br/>--model_name=epl_predictions \<br/>--model_base_path="${MODEL_DIR}" &gt;server.log 2&gt;&amp;1</span></pre><p id="7107" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">服务器运行后，您应该会看到以下消息:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es nn"><img src="../Images/31c06cc015d4e9af0194113ecdbbe8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*tpeBhABjVn7WtAsOnK_tCg.png"/></div></figure></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="7525" class="jz ka hi bd kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw bi translated">要求API预测阿森纳剩余比赛的结果</h1><p id="cc34" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">酷，我们的服务器正在运行。我们将把剩下的阿森纳游戏8发送到api服务器，然后看看我们的模型预测了什么。</p><p id="4895" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我们为每个游戏创建一个包含所有列(共110列)的对象。然后我们将它转换成一个列表，然后保存为一个JSON对象。下面的代码实现了这一点:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="89dd" class="mg ka hi mc b fi mh mi l mj mk">entry = np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0]])</span><span id="8604" class="mg ka hi mc b fi ml mi l mj mk">print(type(entry))<br/>print(entry.shape)</span><span id="9216" class="mg ka hi mc b fi ml mi l mj mk">the_list = entry.tolist()<br/>print(type(the_list))</span><span id="5247" class="mg ka hi mc b fi ml mi l mj mk">data = json.dumps({"signature_name": "serving_default", "instances": the_list})<br/>print('Data: {} ... {}'.format(data[:50], data[len(data)-52:]))</span></pre><p id="0925" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好了，现在我们有了正确格式的请求，我们可以用下面的代码将它发送给我们的api:</p><pre class="ld le lf lg fd mb mc md me aw mf bi"><span id="9fe6" class="mg ka hi mc b fi mh mi l mj mk">!pip install -q requests</span><span id="9926" class="mg ka hi mc b fi ml mi l mj mk">headers = {"content-type": "application/json"}<br/>json_response = requests.post('http://localhost:8501/v1/models/epl_predictions:predict', data=data, headers=headers)</span><span id="2c0a" class="mg ka hi mc b fi ml mi l mj mk">response = json.loads(json_response.text)<br/>predictions = response['predictions']</span><span id="014b" class="mg ka hi mc b fi ml mi l mj mk">print(json_response)<br/>print(json_response.text)<br/>print(response['predictions'])</span><span id="3eb3" class="mg ka hi mc b fi ml mi l mj mk">my_predictions = np.array(predictions)<br/>print("The predictions are: ",np.argmax(my_predictions,axis=1))</span></pre><p id="3d76" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面我们做的是用<em class="mm"> requests.post </em>命令发送请求，并在<em class="mm"> json_response </em>中接收响应。然后我们提取<em class="mm">预测</em>对象并打印出来，这样我们就可以看到3种可能结果的概率(如果客队赢了，0；如果两队打成平局，1；如果主队赢了，2)。最后，我们提取具有最大概率的数组索引，这告诉我们我们的预测是0，1或2。我们得到了下面的输出:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es no"><img src="../Images/2a52469e60a4d4b9b8c7ee35d0147a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sochKlRqQpeWIRpcrz8VmQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">我们的模型对阿森纳所有剩余比赛的预测</figcaption></figure><p id="5b0e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的模型预测主队将赢得所有比赛。</p><p id="b327" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们相信吗？就像我们在本页顶部的第一个直方图中看到的那样，主队获胜是最常见的结果，我们推测这是因为主队拥有人群优势。然而，在这个新冠肺炎时代已经没有人群了。但是，我们的模型不知道这一点，所以这是一个很好的特性，可以添加到模型的未来迭代中。</p><p id="910f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们假设我们相信它。如果是这样的话，那么我们有以下阿森纳的记录:</p><p id="4798" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">5胜(在我们派出的5场比赛中作为主队比赛)和3负(在我们派出的另外3场比赛中作为客场队比赛)</p><p id="cdd3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在对阵诺维奇(我们送到API的8场比赛的第一场)之前，阿森纳有43分。43 + 15(作为主队赢了5场)= 58所以，按照我们的模型，枪手将以58分结束本赛季。欧冠够不够？只有前4支球队有资格参加冠军联赛，所以阿森纳必须排在第4名或者更好。58分够第4名了吗？好吧，让我们看看30个比赛日之后的情况(英超联赛有38个比赛日):</p><ul class=""><li id="0e63" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">利物浦远远超过58分，所以只剩下3个名额了。</li><li id="5ed0" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">曼城有63分，所以他们也在冠军联赛中。</li><li id="5acb" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">莱斯特城有54分，所以他们离超过我们队还有5分之遥。莱斯特城不到59分的几率有多大？他们需要一场胜利和两场平局，这并不困难，因为莱斯特本赛季表现出色。所以我们会考虑他们。现在只剩下一个名额了。</li><li id="19ae" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">切尔西有51分，所以他们只需要2场胜利和几场平局就可以超过阿森纳。这很难，但也是可行的。</li><li id="5a2f" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">此外，曼联、狼队和谢菲尔德联队也在阿森纳之上，踢得很好。我的猜测是这四支球队(切尔西、曼联、狼队和谢菲尔德联队)中的一支会占据最后的位置，我们只剩下安慰奖:欧罗巴联赛。</li></ul></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="ec3d" class="jz ka hi bd kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw bi translated">结论</h1><p id="39fe" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">在这篇文章中，我们经历了很多。</p><p id="5c6c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了我的同胞们，TL；博士是，我们的球队很可能会在欧洲联赛(再次！)下一季；令人失望，但给米克尔时间，他刚刚来到这里(去年年底)，我认为他现在是阿森纳的合适人选。他只是需要时间。</p><p id="f619" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于我的ML爱好者同伴来说，我们经历了ML模型部署的完整周期:下载数据集，可视化数据集的几个维度，预处理数据，创建训练和测试集，创建神经网络，训练神经网络，用测试数据测试它，其中我们发现我们过度适应我们的训练数据，将模型保存到文件系统，使用TensorFlow模型服务将模型部署为api，创建发送到API的对象，接收所有预测并解释它们。咻，太多了！</p><p id="5f98" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以在<a class="ae jk" href="https://github.com/icarovazquez/premiership-predictor/blob/master/EPL_Match_Predictions.ipynb" rel="noopener ugc nofollow" target="_blank"> github </a>的这个Jupyter笔记本上学到很多东西。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="5d97" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在以后的帖子中，我们将关注:</p><ul class=""><li id="faef" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">我们如何设法减少我们观察到的过度拟合。</li><li id="dc3d" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">尝试不同的ML模型，看看那些模型是否比我们目前的神经网络更好。</li></ul><p id="6ca9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">感谢阅读！！如果你想鼓掌，请不要忘记在下面鼓掌。</p></div></div>    
</body>
</html>