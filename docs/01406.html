<html>
<head>
<title>Processing Files in a Stream Processing Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在流处理管道中处理文件</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/processing-files-in-a-stream-processing-pipeline-2cc6e70e3439?source=collection_archive---------4-----------------------#2019-10-20">https://medium.com/analytics-vidhya/processing-files-in-a-stream-processing-pipeline-2cc6e70e3439?source=collection_archive---------4-----------------------#2019-10-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/de0dae944d0ce7531199f3ab12e83b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEw6ZGhAv7LaZEgRJ7-GxQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在<a class="ae iu" href="https://www.pexels.com/photo/aerial-view-of-road-in-the-middle-of-trees-1173777/" rel="noopener ugc nofollow" target="_blank">的</a>上<a class="ae iu" href="https://www.pexels.com/@darshan394" rel="noopener ugc nofollow" target="_blank"> Deva Darshan </a>拍摄的照片。</figcaption></figure><p id="8ca1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于其灵活性和水平可伸缩性，流处理是目前流行的数据处理设计模式。流处理的基本要求是将我们的数据分割成单独的片段或事件，以便可以单独处理它们。每个事件也可以想象成关系数据库中的一行或一个元组。</p><p id="916b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种模式对于某些类型的事件非常有效，例如UI事件、数据库更新事件，因为它们通常是由单个事件产生的。然而，在实际应用中，我们经常需要使用某种类型的文件格式来支持批量数据上传。通常，我们会编写批处理代码来处理文件内容。但是，如果我们想重用相同的流处理管道来支持批量上传呢？</p><p id="91ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下面的示例应用程序中，我们将会这样做。基本思想是将文件内容分割成单独的记录，或者可以通过流处理管道发送的事件，从而重用同一管道进行批量上传。</p><h1 id="06a7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">作为流的文件</h1><p id="026d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">大多数类型的文件可以被视为记录/事件流，或者以某种方式进行流处理。在某些情况下，当我们在整个文件或文件中的记录组级别上处理逻辑时，可能需要更多的技巧，但仍然是可行的。这里，我们将看到一个简单的例子，我们可以将文件内容分割成单独的记录，并独立地处理它们。</p><p id="0bad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用流处理模式处理文件的一个很好的效果是，我们可以在管道的后端聚集处理状态。假设我们为每个输入事件发出某种输出事件，我们可以对这些输出事件进行计数，按照文件上传请求ID进行分组，并生成我们可以用来报告中间进度的二级流。这就是我们在这个简单的例子中要做的。我们将使用Apache Kafka，这是一个流行的流处理平台。然而，该技术非常适用于其他流处理平台。</p><h1 id="1d60" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">流水线架构</h1><p id="0982" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是我们将要建立的管道的整体架构。我们将在接下来的章节中讨论图中的每个模块。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/07cefb555b6a9f8c5ceccc076bc7a2e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-J-6gfa57m-VMZhVAFBgw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">流处理流水线</figcaption></figure><h1 id="6187" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">文件上传API</h1><p id="e656" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了支持文件上传，首先我们需要一个简单的服务器端REST API。我们将使用名为<a class="ae iu" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> Micronaut </a>的微服务框架。流行的<a class="ae iu" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>框架的用户应该熟悉这种编码风格。</p><p id="1ff3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">API将执行几件事情:</p><ol class=""><li id="2194" class="lb lc hi ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">为跟踪目的生成唯一的requestId。</li><li id="a809" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">计算整个文件中的行数。</li><li id="caea" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">逐行拆分文件，并转换成发送到目标Kafka主题的事件。</li><li id="05d1" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">当步骤#3完成时，将requestId返回给UI客户机。</li></ol><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">FileController.kt</figcaption></figure><h1 id="0f71" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">事件处理微服务</h1><p id="a823" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这将是在Kafka主题中咀嚼数据的实际数据处理逻辑。为了简单起见，我们将只执行一个简单的数据库查找，将查找结果附加到输入记录，并将丰富的记录输出到输出主题。在现实生活中，这种处理逻辑可以像您的需求所要求的那样复杂。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">ShipmentEnrichmentWorker.kt</figcaption></figure><p id="71ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，将原始的requestId传递给输出事件也非常重要，这样接下来的步骤就可以使用它进行聚合。</p><h1 id="0ad8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">流程状态聚合器微服务</h1><p id="1ba3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将使用Kafka Stream API构建一个简单的输出事件计数，该计数按requestId分组。发出聚合结果的频率可以通过设置Kafka Streams配置“commit.interval.ms”来调整。</p><p id="ed7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，它被设置为30秒，为了更精确，我们将它更改为1.5秒。目标是找到一个合理的大时间窗口以提高效率，同时能够定期获得更新。</p><p id="422c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，汇总的状态更新将被保存到数据库表中，以供流程状态API查询。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">ProcessStatusAggregator.kt</figcaption></figure><p id="30ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，Kafka流API提供了一个表结构，您可以使用它来存储requestId的状态结果。这个API将数据存储在运行聚合器流程的相同主机上。这是一种保存数据的便捷方式，不需要外部数据库。然而，它确实需要处理节点中的数据存储，并为查询提供额外的API。使用传统数据库可能更容易操作。</p><h1 id="7ec2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">流程状态API</h1><p id="3607" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于检索处理状态的UI，我们需要在服务器端提供一个REST API。这是一个非常简单的API，它基本上是通过clientId查询数据库，以获取从同一客户端上传的所有文件的状态。这里的clientId是每当UI初始化时生成的随机UUID。</p><p id="3132" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">UI将以一定的时间间隔轮询API，直到所有上传都完成处理。然后，返回的结果会呈现在UI上。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">ProcessStatusController.kt</figcaption></figure><p id="4884" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，我们可以通过使用web socket来提供基于推送的状态更新API。它将需要更多的移动部件来正确实现。这里，为了简单起见，我们选择实现传统的基于拉的API。</p><h1 id="8b31" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最后，用户界面</h1><p id="a796" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于UI，我们将使用React框架进行编码。然而，这里可以使用任何Web UI框架，因为逻辑非常简单。最终产品看起来会像这样:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/715bcf81463210bcd82a698f87c27b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpgFyoOkJqeSEbAlfaIR7Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">文件上传界面截图</figcaption></figure><p id="c03d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当用户选择要上传的文件时，UI调用upload API并将文件传递给服务器进行处理。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">将选定文件上传到服务器的功能。</figcaption></figure><p id="a7ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，UI将调用refresh()函数来获取所有当前正在处理的和最近完成的上传。有一个自动刷新机制来定期轮询服务器的处理状态。只有当至少有一个文件处于处理状态时，自动刷新机制才会打开。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">获取和更新处理状态的自动刷新机制。</figcaption></figure><h1 id="102d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">截屏</h1><p id="4e90" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是一切正常运行时的样子。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/779357e65e9fac9c553302e443a91360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tkHyu0eM3DrOx23AlYzM2Q.gif"/></div></div></figure><h1 id="68fc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">源代码</h1><p id="4076" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">该示例的完整源代码可以在<a class="ae iu" href="https://gitlab.com/yongtze/file-stream-sample" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="c242" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">摘要</h1><p id="43bd" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在我们上面看到的例子中，很有可能获取用户上传的文件，分割内容，通过流处理管道传递分割事件，并以中间进度更新UI。</p><p id="2b55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过利用Kafka这样的流媒体平台，我们可以通过横向扩展我们的微服务来处理大量数据。同时，我们已经看到很有可能聚合输出流以在UI中提供中间进度更新，这非常酷。</p></div></div>    
</body>
</html>