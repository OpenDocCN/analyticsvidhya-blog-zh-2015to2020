<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python3-objects-mutable-immutable-more-objects-7469b88f12ae?source=collection_archive---------35-----------------------#2020-05-27">https://medium.com/analytics-vidhya/python3-objects-mutable-immutable-more-objects-7469b88f12ae?source=collection_archive---------35-----------------------#2020-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="d7c6" class="hg hh hi bd hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie bi translated">Python3:对象，可变的，不可变的，更多的对象！</h2><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es if"><img src="../Images/08f7912746da56723ccc2c3209564d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFdMOAprQOLo1QY4IoIT9Q.png"/></div></div></figure><p id="e0d5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi jm translated"><span class="l jn jo jp bm jq jr js jt ju di"> T </span>这篇文章的主要目的是对python3做一个简单的介绍:方法id()和type()，可变和不可变对象及其区别，以及参数传递给这些对象上的函数的方式的含义。</p><h2 id="4999" class="hg hh hi bd hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie bi translated">id()和类型()</h2><p id="a3be" class="pw-post-body-paragraph ir is hi it b iu jv iw ix iy jw ja jb hs jx jd je hw jy jg jh ia jz jj jk jl hb bi translated">在了解这些函数之前，我们先从对象的定义说起。还记得python是面向对象的编程语言吗？嗯，因为它是<em class="ka">那种</em>语言，所以它把注意力集中在制作可以多次使用的代码模式上，并使代码更可读，以便使它更易于维护。</p><p id="82b3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">为了做到这一点，python把重点放在了对象上，这就引出了两个重要的概念:</p><ul class=""><li id="2a4a" class="kb kc hi it b iu iv iy iz hs kd hw ke ia kf jl kg kh ki kj bi translated"><strong class="it kk"> Class — </strong>它就像是你或者任何一个程序员为一个对象创建的<strong class="it kk"> </strong>蓝图。该蓝图将设置一些特征(<strong class="it kk">属性</strong>)或方法，这些特征或方法将被从该类实例化的任何对象所拥有。</li><li id="d168" class="kb kc hi it b iu kl iy km hs kn hw ko ia kp jl kg kh ki kj bi translated"><strong class="it kk">对象</strong> —它是一个类的实例。这是类的实现版本，其中类在程序中表现出来。一个对象总是有三个主要的东西:标识、类型和值。</li></ul><p id="0597" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">所以，假设人体是一个类:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="bc01" class="hg hh hi kr b fi kv kw l kx ky">class Human:<br/>    '''This is a docstring describing our class'''<br/>    pass</span></pre><p id="16cf" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">现在，这个类有一些构成人体的属性:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="1da7" class="hg hh hi kr b fi kv kw l kx ky">class Human:<br/>    '''This is a docstring describing our class'''<br/>    def arms(self):<br/>        print("A human body has two arms")</span><span id="a82f" class="hg hh hi kr b fi kz kw l kx ky">    def head(self):<br/>        print("A human body has one head")</span></pre><p id="5949" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">因为对象是类的实例。我们可以使用上面定义的<code class="du la lb lc kr b">Human</code>类，并用它来创建一个对象或它的实例。</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="5679" class="hg hh hi kr b fi kv kw l kx ky">felipe = Human() #initializing felipe as an object of Human<br/>felipe.arms()    #now that felipe is part of the class Human<br/>felipe.head()    #we can use the class attributes(methods)</span></pre><p id="9f36" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">所有这些与id()和type()有什么关系？id()和type()都是python的内置函数。</p><p id="1e74" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">id语法:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="3765" class="hg hh hi kr b fi kv kw l kx ky">id(object)</span></pre><p id="9c46" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">这个函数只接受一个对象作为参数，并返回该对象的标识。该对象的标识是唯一的(它就像一个内存地址),一旦创建，它就不会改变。如果两个生存期不重叠的对象可能具有相同的id()值。</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="21ef" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; <!-- -->id(felipe)<br/><strong class="kr kk">140162286256256</strong>   #this is the ID if the object felipe</span></pre><p id="7c1f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">您可以在任何需要的时候使用此方法，并且它可以用于任何对象:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="ba6e" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; a = 12<br/>&gt;&gt;&gt; str_1 = "Hello, world"<br/>&gt;&gt;&gt; b = 2.5<br/>&gt;&gt;&gt; id(a)<br/><strong class="kr kk">10105440</strong><br/>&gt;&gt;&gt; id(str_1)<br/><strong class="kr kk">140323560211568</strong><br/>&gt;&gt;&gt; id(b)<br/><strong class="kr kk">140323561456096</strong></span></pre><p id="9ae1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">如果你有两个值相同的变量，你会认为它们的id是什么？</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="1c39" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; a = 12<br/>&gt;&gt;&gt; b = 2.5<br/>&gt;&gt;&gt; id(a)<br/><strong class="kr kk">10105440</strong><br/>&gt;&gt;&gt; id(b)<br/><strong class="kr kk">10105440</strong><br/>&gt;&gt;&gt; str_1 = "Hello"<br/>&gt;&gt;&gt; str_2 = "Hello"<br/>&gt;&gt;&gt; id(str_1)<br/><strong class="kr kk">140323560211568</strong><br/>&gt;&gt;&gt; id(str_2)<br/><strong class="kr kk">140323560211568</strong><br/>&gt;&gt;&gt; t_1= (1, 2)<br/>&gt;&gt;&gt; t_2= (1, 2)<br/>&gt;&gt;&gt; id(t_1)<br/><strong class="kr kk">140323561456096</strong><br/>&gt;&gt;&gt; id(t_2)<br/><strong class="kr kk">140323561456096</strong></span></pre><p id="21f6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">他们的id是一样的！但是，为什么呢？因为Python缓存了字符串、元组、浮点和整数对象(它们是不可变的，这个概念将在下面解释)并使用它们来节省内存空间。所以，它们是<em class="ka">指向</em>相同值的变量。</p><p id="f21e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">字典、列表和集合怎么样？让我们看看:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="6e38" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; dict_1 = <!-- -->{"A": 1, "B": 2}<br/>&gt;&gt;&gt; dict_2 = <!-- -->{"A": 1, "B": 2}<br/>&gt;&gt;&gt; id(dict_1)<br/><strong class="kr kk">140211728791304</strong><br/>&gt;&gt;&gt; id(dict_2)<br/><strong class="kr kk">140211728791432</strong></span></pre><p id="2bd3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">嗯…他们的身份证是不同的。列表和集合也会发生同样的事情。所有这些对象都是可变的。</p><p id="8819" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">在我们讨论可变和不可变的东西之前，让我们继续讨论type()，看看它的语法:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="4876" class="hg hh hi kr b fi kv kw l kx ky">type(object)</span></pre><p id="15e8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">type()也是一个内置函数，它接收一个参数并返回该对象的类型，如果您认为正确的话:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="c45a" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; dict_1 = <!-- -->{"A": 1, "B": 2}<br/>&gt;&gt;&gt; <!-- -->type(dict_1)<br/><strong class="kr kk">&lt;class 'dict'&gt;</strong><br/>&gt;&gt;&gt; type(felipe)                           #from first example<br/><strong class="kr kk">&lt;class '__main__.Human'&gt;</strong><br/>&gt;&gt;&gt; type(1)<br/><strong class="kr kk">&lt;class 'int'&gt;</strong><br/>&gt;&gt;&gt; a = 2.5<br/>&gt;&gt;&gt; type(a)<br/><strong class="kr kk">&lt;class 'float'&gt;</strong></span></pre><p id="25c3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">您可能已经注意到，在Python中，对象的类型是由其类定义的。所以整数的类型是“int ”,因为它是int类的对象。</p><p id="24fb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">还有一点，有一个操作符<strong class="it kk"> <em class="ka"> is </em> </strong>，它比较对象的id来检查两个操作数是否引用同一个对象。不要将其与<strong class="it kk"><em class="ka">=</em></strong>、<strong class="it kk"> <em class="ka"> </em> </strong>混淆，因为这样会比较两个操作数的值并检查值是否相等。例如:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="329a" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; a = "School"<br/>&gt;&gt;&gt; b = "School"<br/>&gt;&gt;&gt; id(a)<br/><strong class="kr kk">140135852058556</strong><br/>&gt;&gt;&gt; id(b)<br/><strong class="kr kk">140135852058556</strong><br/>&gt;&gt;&gt; a is b            #using is to compare a and b id's<br/><strong class="kr kk">True</strong><br/>&gt;&gt;&gt; a == b            #usin == to compare a and b values<br/><strong class="kr kk">True</strong></span></pre><h2 id="f5e8" class="hg hh hi bd hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie bi translated">可变和不可变对象</h2><p id="41bb" class="pw-post-body-paragraph ir is hi it b iu jv iw ix iy jw ja jb hs jx jd je hw jy jg jh ia jz jj jk jl hb bi translated">不，他们不是忍者神龟！</p><p id="e1a9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">长话短说:可变对象是那些在创建后很容易被改变的对象，而不可变对象则不能。</p><p id="3aa3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><strong class="it kk">可变对象:</strong>列表，字典，集合，字节数组。</p><p id="bd60" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated"><strong class="it kk">不可变对象:</strong> int，float，complex，string，tuple，冻结集，bytes。</p><p id="0935" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">有意思，举个例子？</p><p id="43e8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">让我们继续使用一个<strong class="it kk">不可变的</strong>字符串对象:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="c863" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; str_1 = "Hello"               #Just assigning values<br/>&gt;&gt;&gt; str_2 = str_1<br/>&gt;&gt;&gt; id(str_1)<br/><strong class="kr kk">139979870453408</strong><br/>&gt;&gt;&gt; id(str_2)<br/><strong class="kr kk">139979870453408</strong></span></pre><p id="4821" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">那么，str_1和str_2的id都是一样的，我们用其中一个做运算的时候呢？：</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="70dc" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; str_1 = str_1 + " world"    #basic concatenation<br/>&gt;&gt;&gt; str_1<br/><strong class="kr kk">'Hello world'</strong><br/>&gt;&gt;&gt; id(str_1)<br/><strong class="kr kk">140149593810288</strong></span></pre><p id="3c06" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">在再次检查str_1 id后，我们注意到它的不同，这是因为str_1“指向”的“原始”对象<em class="ka"/>本身没有改变，但变量现在正在访问内存的另一部分或id，值为“Hello world”。</p><p id="bf7e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">另一方面，<strong class="it kk">可变对象</strong>在创建后可以被修改，并且仍然具有相同的id:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="bb27" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; a_list = ['A', 'B']<br/>&gt;&gt;&gt; a_list <br/><strong class="kr kk">['A', 'B']</strong><br/>&gt;&gt;&gt; id(a_list)<br/><strong class="kr kk">140587276456520</strong><br/>&gt;&gt;&gt; a_list.append('C')<br/>&gt;&gt;&gt; a_list<br/><strong class="kr kk">['A', 'B', 'C']</strong><br/>&gt;&gt;&gt; id(a_list)<br/><strong class="kr kk">140587276456520</strong></span></pre><p id="9c6a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">看到了吗？即使列表被修改，添加了一个新值，id在那之后是相同的，因为a_list仍然是<em class="ka">指向</em>同一个对象！</p><p id="cb2d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">之后，可以注意到python对可变和不可变对象的处理是不同的。不可变对象看起来访问起来更快，但是它们在更改方面负担更重，因为修改意味着创建该对象的副本。</p><p id="25f3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">相反，可变对象可以很容易地修改。当对象的大小或内容需要更新时，它们就会出现。</p><p id="9cbd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">但是…有一个关于元组的东西。我们说过元组是不可变的，但是它们可以托管其他类型(或类)的对象:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="f528" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; l = ['A', 'B']<br/>&gt;&gt;&gt; my_tuple = (l, "units")<br/>&gt;&gt;&gt; print(a)<br/><strong class="kr kk">(['A', 'B'], 'units')</strong><br/>&gt;&gt;&gt; print(id(a))<br/><strong class="kr kk">140684185703752</strong><br/>&gt;&gt;&gt; l.append('C')<br/>&gt;&gt;&gt; print(a)<br/><strong class="kr kk">(['A', 'B', 'C'], 'units')</strong><br/>&gt;&gt;&gt; print(id(a))<br/><strong class="kr kk">140684185703752</strong></span></pre><p id="2be2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">因此，列表是可变的，但元组不是。啊？列表仍然可以被修改，即使它是不可变对象的一部分！</p><p id="bdb7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">我们快到终点线了。</p><h2 id="f3ac" class="hg hh hi bd hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie bi translated">Python中的函数参数传递</h2><p id="80d0" class="pw-post-body-paragraph ir is hi it b iu jv iw ix iy jw ja jb hs jx jd je hw jy jg jh ia jz jj jk jl hb bi translated">在Python中，参数通过引用传递给函数。变量或对象由调用者和函数代码块共享。也就是说，如果我们在函数的作用域内改变或更新一个函数参数的值，该参数的值也会在函数块内改变，即使参数或变量的名称不同。这种行为取决于参数的类型:可变的或不可变的。</p><p id="d344" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">在Python中，参数总是通过引用传递给函数。调用者和函数代码块共享同一个对象或变量。当我们在函数代码块范围内更改函数参数的值时，无论参数或变量的名称是什么，该变量的值在调用方代码块范围内也会更改。对于Python 中的<strong class="it kk">可变参数和不可变参数，这个概念的表现是不同的。</strong></p><p id="88af" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">如果不可变对象的值在函数或方法块中发生了变化，那么它们在调用块中不会发生变化，而可变对象的值会发生变化。</p><p id="2639" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">让我们用一个例子来说明:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="e2bd" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; <!-- -->def increment(n):<br/>...   n += 1<br/>&gt;&gt;&gt; <!-- -->a = 1<br/>&gt;&gt;&gt; print(a)<br/><strong class="kr kk">1</strong><br/>&gt;&gt;&gt; <!-- -->increment(a)<br/>&gt;&gt;&gt; <!-- -->print(a)<br/><strong class="kr kk">1</strong></span></pre><p id="706e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi translated">因为a是一个不可变的对象，所以它没有改变。与可变对象不同的是:</p><pre class="ig ih ii ij fd kq kr ks kt aw ku bi"><span id="b220" class="hg hh hi kr b fi kv kw l kx ky">&gt;&gt;&gt; <!-- -->def increment(n):<br/>...   n.append(4)<br/>&gt;&gt;&gt; <!-- -->l = [1, 2, 3]<br/>&gt;&gt;&gt; <!-- -->print(l)<br/><strong class="kr kk">[1, 2, 3]</strong><br/>&gt;&gt;&gt; <!-- -->increment(l)<br/>&gt;&gt;&gt; <!-- -->print(l)<br/><strong class="kr kk">[1, 2, 3, 4]</strong></span></pre><p id="5fff" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb hs jc jd je hw jf jg jh ia ji jj jk jl hb bi jm translated"><span class="l jn jo jp bm jq jr js jt ju di">在</span>结论中，Python是OOP语言，所以一切都是对象！这是为了您的方便，所以您可以通过重用已经存在的类来更轻松地编码。我希望，既然你正在读这最后一行，你可以更自信地向另一个人谈论类、对象、id()、type()，可变和不可变对象，以及函数参数传递。</p></div></div>    
</body>
</html>