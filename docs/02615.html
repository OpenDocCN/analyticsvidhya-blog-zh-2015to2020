<html>
<head>
<title>Building Recommender System Using Machine Learning Techniques And Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用机器学习技术和Python构建推荐系统</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-recommender-system-using-machine-learning-techniques-and-python-45cfb8c88465?source=collection_archive---------10-----------------------#2019-12-25">https://medium.com/analytics-vidhya/building-recommender-system-using-machine-learning-techniques-and-python-45cfb8c88465?source=collection_archive---------10-----------------------#2019-12-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/4b697613eb6c21369773019936a7d70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNKt7zG_0uFZ2ILV8q5_SA.jpeg"/></div></div></figure><div class=""/><p id="d321" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你要在亚马逊上买一部手机，亚马逊建议你买一个屏幕保护玻璃和一个保护套。如果你把这三样东西一起买，它还会给你打折。如果你去Youtube看你最喜欢的歌曲，Youtube推荐你去看你可能喜欢的类似的其他歌曲。在谷歌搜索上，在搜索结果页面的底部，你会看到相关的搜索。你到处都能得到推荐；在网飞、脸书、推特上，所有的社交网站都建立了自己的推荐系统。不仅在网上网站上，而且在超市里你也能找到直接或间接的推荐。在超市里，一起买的东西放在一起，或者如果你一起买东西，他们会打折。他们怎么知道你的购买模式？他们怎么知道你的喜恶？我们将在这篇文章中了解这个秘密。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jo"><img src="../Images/eac2ba9b04bc8bde9e56267a65d4148b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8mIp1zPQqnj39E-J7RKHQ.jpeg"/></div></div></figure><p id="70db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">推荐系统是机器学习的一个重要而热门的领域。它帮助企业增加了销售额和利润。我们无法想象今天没有任何推荐系统的市场。这些公司分析我们的交易数据，试图推断我们的购买模式。他们从购买模式中创建关联规则。这些关联规则然后被用于形成推荐和交易。有各种各样的数据挖掘算法，如k-means、Page Rank、EM数据挖掘和Apriori，用于构建推荐系统。在这篇文章中，我们将使用Apriori算法来构建我们的推荐系统。</p><p id="392c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apriori算法是数据挖掘中最流行、最经典的算法之一。它使用关联规则挖掘，这是一种识别数据集中不同项目之间潜在关系的技术。我们先用一个超市的例子来理解关联规则挖掘。在超市里，顾客可以买到各种各样的商品。通常，顾客买的东西都有一个模式。例如，如果有人想准备一个面包三明治，那么她很可能会买面包、黄油、果酱和番茄酱。番茄酱很有可能和面包、黄油一起被购买。从超市交易数据中我们可以发现，有很多交易中，以上四样东西都是一起买的。所以，现在我们可以说番茄酱与面包、黄油和果酱有着密切的联系。而且，超市可以在他们的系统中创建一个新的规则来将这四样东西放在一起，因为它们经常被一起购买。关联规则挖掘就是发现这种规则的技术。</p><p id="ba9d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apriori算法是由Agrawal和Srikant在1994年提出的。Apriori被设计为对包含交易的数据库进行操作(例如，客户购买的商品集合，或者网站访问或IP地址的详细信息)。Apriori使用“自下而上”的方法，其中频繁子集一次扩展一个项目(这一步称为候选生成)，并根据数据测试候选组。当没有找到进一步的成功扩展时，算法终止。</p><h1 id="21ae" class="jt ju ht bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Apriori是如何工作的？</h1><p id="08e2" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">借助下面的简单例子，我们将探讨Apriori算法的内部步骤。下面是一个超级市场数据集样本。我们将对该数据集运行Apriori，从中挖掘关联规则。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es kw"><img src="../Images/6d8a2c02bdd9165b37cdf6202f3482c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*AV7KzHtwO7iRyf4Uk5T8LQ.jpeg"/></div></figure><p id="af9c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apriori使用三个重要的计算因素从输入数据集中挖掘关联规则。这三个计算因素是<strong class="is hu">支持度</strong>、<strong class="is hu">信心度</strong>和<strong class="is hu">升力</strong>。下面让我们看看如何计算它们。</p><h1 id="31bf" class="jt ju ht bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">支持:先验的第一步</h1><p id="8b6f" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">这是先验计算的第一步。在这一步中，首先，算法从输入数据集中识别所有唯一的项目。以下是我们的样本数据集中存在的唯一项目列表。除了唯一项目列表，它还找出输入数据集中的记录总数。在我们的例子中，记录总数= 5。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es kx"><img src="../Images/74529124bada46e30dbdc08351cbd2c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*RNnf6kIZ9eQqzhz2WQNLsA.jpeg"/></div></figure><p id="3749" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是计算上面列表中每个项目的支持度。支持指的是项目的默认流行度，并且可以通过找到包含特定项目的交易数除以交易总数来计算。</p><p id="0974" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们想为项目“番茄酱”寻找支持。这可以计算为:</p><p id="d70d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ky">支持("番茄酱")=包含("番茄酱")的交易/总交易；</em>T11】</strong></p><p id="ef33" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，总共五个交易中有三个交易包含“番茄酱”项。因此，</p><p id="f6f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Support("番茄酱")= 3/5 = 0.6；</p><p id="eb6a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，Apriori计算所有项目的支持度。请查看下表中所有项目的计算支持。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es kz"><img src="../Images/dc930d59f3a45d6a7fca219515796c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*8YfjuCzDtSrfEffI1d_LLw.jpeg"/></div></figure><p id="3bda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是计算对一组中有两个项目的项目组的支持。当一个组中有一个以上的项目时，它被称为一个项目集。例如itemset(“面包，番茄酱”)。创建项目集时，项目的顺序无关紧要。Itemset(“面包，番茄酱”)与itemset(“番茄酱，面包”)相同。</p><p id="4ff1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计算项目集支持度的公式与计算项目支持度的公式相同。例如，对项目集“面包，番茄酱”的支持计算如下:</p><p id="70f7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ky">支持("面包，番茄酱")=包含("面包，番茄酱")的交易/总交易；</em>T15】</strong></p><p id="a510" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，总共五个交易中有三个既有面包又有番茄酱。因此，</p><p id="239d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Support("面包，番茄酱")= 3/5 = 0.6；</p><p id="6094" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，Apriori计算大小为2的所有项目集的支持度。请查看下表中所有项目集的计算支持。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div class="er es la"><img src="../Images/cb4d8dfdc9506bddaaadf72593b26fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*UaLbVFHByAr6yJHKOK4buA.jpeg"/></div></figure><p id="dd49" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，Apriori计算所有可能项目集的支持度。它继续生成大小为1到N-1的项目集，其中N是最大事务中的项目总数。在我们的示例中，所有事务都有相同数量的条目，该值为3。因此，在我们的例子中，N的值是3，因此，该算法将只生成大小为1和2的项集。它会停在2，就像我们的例子N-1 =2。</p><h1 id="3f31" class="jt ju ht bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">自信:先验的第二步</h1><p id="1169" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">一个规则的置信度(面包= &gt;番茄酱)是指如果买了面包也买了番茄酱的可能性。置信度是规则被发现为正确的频率的指示。置信度的计算方法是，找出一起购买面包和番茄酱的交易次数，除以购买面包的总交易次数。数学上，它表示为</p><p id="9acb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ky">置信度(A= &gt; B) =(同时包含(A和B)的事务)/(包含A的事务)；</em>T3】</strong></p><p id="cb40" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述等式也可以表示为:</p><p id="5a93" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ky">信心(A= &gt; B) =支持(A和B))/支持(A)；</em> </strong></p><p id="d212" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在前面的步骤中计算的支持值可以在这里用于计算置信度。</p><p id="33c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回到我们的例子；面包和番茄酱一起购买有三个交易，面包被带来有四个交易。因此，</p><p id="e3e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ky">信心(面包= &gt;番茄酱)= 3/4 = 0.75 </em> </strong></p><p id="92dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">自信可以提供一些重要的见解，但它也有一个主要的缺点。它只考虑了项目集A的流行度(在我们的例子中，A是“面包”)，而没有考虑B的流行度(在我们的例子中，B是“番茄酱”)。如果B(番茄酱)和A(面包)一样受欢迎，那么包含A(面包)的交易也包含B(番茄酱)的概率更高，从而增加了可信度。在计算升力时克服了这个缺点。</p><h1 id="7164" class="jt ju ht bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">提升:先验的第三步</h1><p id="95ec" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">升力或升力比是置信度与预期置信度的比值。预期置信度是置信度除以b的频率。提升告诉我们一个规则在预测结果方面比一开始就假设结果要好得多。提升值越大，关联越强。</p><p id="03f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在计算lift(A=&gt;B)时，我们考虑了物品A和B的受欢迎程度。这个lift比率显示了在购买A时购买B的可能性。数学上，升力表示为</p><p id="225a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ky">提(A= &gt; B) =信心(A= &gt; B) /支持(B)；</em>T15】</strong></p><p id="6218" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者，</p><p id="5504" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">T17】Lift(A =&gt;B)= Support(A =&gt;B)/(Support(A)* Support(B))；T19】</strong></p><p id="3763" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们回到我们的例子，计算(面包= &gt;番茄酱)的升力。</p><p id="8e27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ky">举起(面包= &gt;番茄酱)=信心(面包= &gt;番茄酱)/支撑(番茄酱)；</em>T3】</strong></p><p id="0836" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ky">掀(面包= &gt;番茄酱)= 0.75 / 0.6 = 1.25 </em> </strong></p><p id="3471" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">lift值大于1表示如果A被购买，B很可能被购买，而小于1的值表示如果A被购买，B不太可能被购买。</p><h1 id="c7a5" class="jt ju ht bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Python实现:</h1><p id="5970" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">现在，让我们构建一个可以执行上述所有计算的python程序。它应该列出所有唯一的项目，创建唯一的项目集，计算项目和项目集的支持度，计算所有可能的项目-项目集组合的置信度和提升度。该程序应该返回给定项目/项目集用户建议。</p><p id="0bef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任何机器学习/数据挖掘系统首先需要的是数据。我们正在使用一个超市数据来为超市建立一个推荐系统。我们的数据是csv格式的。csv中的每一行都代表客户购买的商品列表。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lb"><img src="../Images/88ea940f113a0113200eed9d35215a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_AOv4YsBSWnZRY0Mlgtiw.jpeg"/></div></div></figure><p id="2e00" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输入csv文件没有标题。每行的项目总数可能不相等。在上图中，您可以看到第十三位顾客购买了五件商品，而第十六位顾客只购买了一件商品。你可以在这里找到样本数据文件和整个程序<a class="ae lc" href="https://github.com/srkhedkar/Recommender" rel="noopener ugc nofollow" target="_blank">https://github.com/srkhedkar/Recommender</a></p><p id="f168" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们利用apyori软件包计算关联规则。如果您的系统上没有安装，那么使用命令<em class="ky">“pip install apy ori”</em>安装它</p><p id="9057" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们来编写python代码。这里，我们已经导入了所需的包，定义了类<em class="ky">推荐者</em>并定义了它的构造函数。在实例化一个<em class="ky">推荐者</em>对象时，我们需要向它提供数据文件。</p><pre class="jp jq jr js fd ld le lf lg aw lh bi"><span id="d974" class="li ju ht le b fi lj lk l ll lm">from apyori import apriori<br/>from apyori import load_transactions<br/><br/>class Recommender():<br/><br/>    def __init__(self, inputFile):<br/>        self.AssociationRulesDictionary = {} # holds final output<br/>        self.dataFile = inputFile # input datafile in csv form        <br/>        self.association_rules = [] # holds output from Apriori algo</span></pre><p id="557e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是计算关联规则。为此，我们需要计算支持、信心和提升上面解释的所有这些东西。下面的函数被定义来计算所有这些东西。</p><pre class="jp jq jr js fd ld le lf lg aw lh bi"><span id="63f6" class="li ju ht le b fi lj lk l ll lm">def computeRules(self):<br/>        """<br/>        Copmputes all association rules.<br/>        :return:<br/>        """<br/>        with open(self.dataFile ) as fileObj:<br/>            transactions = list(load_transactions(fileObj, delimiter=","))<br/>            # remove empty strings if any<br/>            transactions_filtered = []<br/>            for li in transactions:<br/>                li = list(filter(None, li))<br/>                transactions_filtered.append(li)</span><span id="5362" class="li ju ht le b fi ln lk l ll lm">            # Following line does all computations<br/>            # lift &gt; 1 shows that there is a positive correlation within the itemset, i.e., items in the<br/>            # itemset, are more likely to be bought together.<br/>            # lift &lt; 1 shows that there is a negative correlation within the itemset, i.e., items in the<br/>            # itemset, are unlikely to be bought together.<br/>            # hence we have set min_lift=1.0 to ignore all rules with lift &lt; 1.0<br/>            self.association_rules = apriori(transactions_filtered,       min_support=0.01, min_confidence=0.01, min_lift=1.0,max_length=None)</span></pre><p id="4e6b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码中，你可以看到所有重要的计算都是在函数调用<em class="ky"> apriori() </em>中完成的，这个函数调用来自导入的包<em class="ky">apriori</em>。我们什么都不用做！！所有的事情都由<em class="ky"> apriori() </em>负责！！这就是我爱上这门语言的原因。就是这么简单；它是如此强大！！这个生态系统是如此的丰富，以至于我们可以发现大部分的东西都已经实现了。这让我想起了一个著名的python笑话。一天，小琼尼飞上了天空！！小杰克在地上问他:“嘿，乔尼，你怎么会飞得这么高呢？”你做了什么？”。小Jony回答“没什么…我只是导入了一个python的反重力模块！!"。:D·:D</p><p id="d7ef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ky"> apriori() </em>以如下所示的形式向我们返回输出。我们的下一个任务是从这个输出中提取信息，并将其存储在一个字典中以便于访问。</p><p id="759e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">先验输出:</strong></p><p id="c906" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ordered _ statistics =[ordered statistic(items _ base = frozenset()，items_add=frozenset({ '巧克力'，'牛奶'，'鸡蛋' })，confidence = 0.1666666666666666666，lift=1.0)，ordered statistic(items _ base = frozenset({ '巧克力' })，items_add=frozenset({ '牛奶'，'鸡蛋' })，confidence=0.5，lift=1.5)，ordered statistic(items _ base = frozenset({ '巧克力')</p><p id="eb91" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了从<em class="ky"> apriori() </em>的输出中提取规则，我们定义了<em class="ky"> extractRules() </em>。该函数提取规则，并按照提升值的降序将它们存储在<em class="ky">AssociationRulesDictionary</em>中。</p><pre class="jp jq jr js fd ld le lf lg aw lh bi"><span id="aff7" class="li ju ht le b fi lj lk l ll lm">def extractRules(self):</span><span id="8310" class="li ju ht le b fi ln lk l ll lm">        for item in self.association_rules:<br/>            # first index of the inner list<br/>            # Contains base item and add item<br/>            if len(item[0]) &lt; 2:<br/>                continue</span><span id="0b7b" class="li ju ht le b fi ln lk l ll lm">            for k in item[2]:<br/>                baseItemList = list(k[0])<br/>                # if base item set is empty then go to the next record.<br/>                if not baseItemList:<br/>                    continue<br/>                # sort the baseItemList before adding it as a key to the AssociationRules dictionary<br/>                baseItemList.sort()<br/>                baseItemList_key = tuple(baseItemList)<br/>                if baseItemList_key not in self.AssociationRulesDictionary.keys():                    self.AssociationRulesDictionary[baseItemList_key] = []                self.AssociationRulesDictionary[baseItemList_key].append((list(k[1]), k[3]))<br/>                # if something goes wrong, then use the following print block to print values<br/>                #print("Base item: ", baseItemList_key)<br/>                #print("Target item: ", list(k[1]))<br/>                #print("Confidence: " + str(k[2]))<br/>                #print("Lift: " + str(k[3]))<br/>        # sort the rules in descending order of lift values.<br/>        for ruleList in self.AssociationRulesDictionary:            self.AssociationRulesDictionary[ruleList].sort(key=lambda x: x[1], reverse=True)</span></pre><p id="e276" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面定义的两个方法不应该在类定义之外调用。作为一个老式的C++开发人员，我必须遵守这个限制。我把它留给你们；如果你想在类外调用这两个函数，你可以。</p><p id="1c1e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们定义了一个方法<em class="ky"> studyRules() </em>，该方法调用上面两个函数<em class="ky">computer rules()</em>和<em class="ky"> extractRules() </em>。这个函数<em class="ky"> studyRules() </em>在这里起到了一个模板方法的作用。如果您想扩展<em class="ky">推荐器</em>类，并使用另一种算法而不是Apriori来计算关联规则，那么<em class="ky"> studyRules() </em>将帮助您获得多态行为。推荐器类的一个对象应该调用<em class="ky"> studyRules() </em>来计算并从输入数据文件中提取关联规则。</p><pre class="jp jq jr js fd ld le lf lg aw lh bi"><span id="c8a3" class="li ju ht le b fi lj lk l ll lm">def studyRules(self):<br/>    """<br/>    This is a template method for computation and rule extraction.<br/>    :return:<br/>    """<br/>    self.computeRules()<br/>    self.extractRules()</span></pre><p id="7014" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们已经完成了所有的计算，并将所有的关联规则提取到一个字典中。让我们定义一些API来使用计算出的关联规则返回推荐和交易。</p><pre class="jp jq jr js fd ld le lf lg aw lh bi"><span id="fac3" class="li ju ht le b fi lj lk l ll lm">def recommend(self, itemList, Num=1):<br/>    """<br/>    itemList is a list of items selected by user<br/>    Num is total recommendations required.<br/>    :param item:<br/>    :return:<br/>    """<br/>    # convert itemList to itemTuple as our dictionary key is a sorted tuple<br/>    itemList.sort()<br/>    itemTuple = tuple(itemList)<br/>    if itemTuple not in self.AssociationRulesDictionary.keys():<br/>        return []<br/>    return self.AssociationRulesDictionary[itemTuple][:Num]</span></pre><p id="03ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ky"> recommend() </em>返回所选项目/项目集的建议。例如，如果您想找出“红酒”和哪个是最受欢迎的商品，那么您可以通过调用<em class="ky"> recommend() </em>来获得这个值，如下所示。</p><p id="e045" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ky"> objectName.recommend(['红酒']，1) </em></p><p id="dd73" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，对于我们正在使用的数据文件，它返回我们</p><p id="e32e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[(['意大利面条']，2.09638976)]</p><p id="ab05" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这告诉我们“意大利面条”和“红酒”是最受欢迎的食物。</p><p id="592d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们根据这些建议制定交易。API <em class="ky"> showDeals() </em>被定义为使用<em class="ky"> recommend() </em>返回的推荐创建交易。在<em class="ky"> showDeals() </em>中，我们使用推荐项目集的提升值来计算折扣百分比。API <em class="ky"> recommend() </em>返回有点抽象的输出；在<em class="ky"> showDeals() </em>中，我们试图赋予它一些意义。</p><pre class="jp jq jr js fd ld le lf lg aw lh bi"><span id="a2fe" class="li ju ht le b fi lj lk l ll lm">def showDeals(self, itemList, Num=1):</span><span id="1b15" class="li ju ht le b fi ln lk l ll lm">    """<br/>    we are converting the recommendations into deals. The lift value    is used to calculate discount percentage<br/>    discount percentage = 10 * lift<br/>    itemList is a list of items selected by user<br/>    Num is total deals required.<br/>    :return:<br/>    """<br/>    recommendations = self.recommend(itemList, Num)<br/>    for item in recommendations:<br/>        print( "If you buy ", item[0], " along with ", itemList, " then you will get ", round((item[1] * 10), 2), \<br/>               "% discount on total cost!!" )</span></pre><p id="f004" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们的整个推荐系统已经准备好了！！让我们玩玩它，看看它的表现如何。</p><pre class="jp jq jr js fd ld le lf lg aw lh bi"><span id="1de6" class="li ju ht le b fi lj lk l ll lm"># Create a recommender Alexa, give her the datafile containing transactions.<br/>Alexa = Recommender("store_data.csv")</span><span id="f63b" class="li ju ht le b fi ln lk l ll lm"># Request Alexa to study rules from the provided datafile<br/>Alexa.studyRules()<br/> <br/># Ask Alexa for the deals<br/>Alexa.showDeals(['red wine'], 2)</span></pre><p id="0fc6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嘿！艾丽莎。给我看看‘红酒’最上面的两笔交易。Alexa向您展示了以下交易。</p><p id="f3c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1.如果您购买['意大利面']和['红酒']，那么您将获得20.96 %的总费用折扣！！</p><p id="4101" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.如果您同时购买['矿泉水']和['红酒']，您将享受总费用16.3 %的折扣！！</p><p id="2812" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是不是很神奇。你可以使用相同的推荐系统来建立一个视频或歌曲推荐系统。您只需要提供相应的数据文件。例如，它可能是这样的。</p><pre class="jp jq jr js fd ld le lf lg aw lh bi"><span id="de40" class="li ju ht le b fi lj lk l ll lm">Michael = Recommender("songs_data.csv)<br/>Michael.studyRules()<br/>Michael.recommend(['summer of 69', 'Billie Jean'], 5)</span></pre><p id="4f42" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，迈克尔将推荐五首最常与《69年的夏天》和《比利·简》一起听的歌曲！！</p><p id="f3fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">整个程序和样本数据文件都上传到GitHub这里<a class="ae lc" href="https://github.com/srkhedkar/Recommender" rel="noopener ugc nofollow" target="_blank">https://github.com/srkhedkar/Recommender</a></p><p id="cd63" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你也可以在下面找到完整的程序。如果您对实施有任何意见/担忧，请随时联系我，我在srkhedkar@gmail.com</p><h2 id="421e" class="li ju ht bd jv lo lp lq jz lr ls lt kd jb lu lv kh jf lw lx kl jj ly lz kp ma bi translated">完整的Python推荐系统脚本:</h2><pre class="jp jq jr js fd ld le lf lg aw lh bi"><span id="8b14" class="li ju ht le b fi lj lk l ll lm">from apyori import apriori<br/>from apyori import load_transactions<br/></span><span id="8943" class="li ju ht le b fi ln lk l ll lm">class Recommender():<br/>    def __init__(self, inputFile):<br/>        self.AssociationRulesDictionary = {} # holds final output<br/>        self.dataFile = inputFile # input datafile in csv form<br/>        self.association_rules = [] # holds output from Apriori algo</span><span id="fea8" class="li ju ht le b fi ln lk l ll lm">    def computeRules(self):<br/>        """<br/>        Computes all association rules.<br/>        :return:<br/>        """<br/>        with open(self.dataFile ) as fileObj:</span><span id="e71a" class="li ju ht le b fi ln lk l ll lm">            transactions = list(load_transactions(fileObj, delimiter=","))</span><span id="b0d2" class="li ju ht le b fi ln lk l ll lm">            # remove empty strings if any<br/>            transactions_filtered = []<br/>            for li in transactions:<br/>                li = list(filter(None, li))<br/>                transactions_filtered.append(li)</span><span id="9d07" class="li ju ht le b fi ln lk l ll lm">            # Following line does all computations<br/>            # lift &gt; 1 shows that there is a positive correlation within the itemset, i.e., items in the<br/>            # itemset, are more likely to be bought together.<br/>            # lift &lt; 1 shows that there is a negative correlation within the itemset, i.e., items in the<br/>            # itemset, are unlikely to be bought together.<br/>            # hence we have set min_lift=1.0 to ignore all rules with lift &lt; 1.0<br/>            self.association_rules = apriori(transactions_filtered, min_support=0.01, min_confidence=0.01, min_lift=1.0,<br/>                                        max_length=None)</span><span id="cdf1" class="li ju ht le b fi ln lk l ll lm">    def extractRules(self):</span><span id="e05c" class="li ju ht le b fi ln lk l ll lm">        for item in self.association_rules:<br/>            # first index of the inner list<br/>            # Contains base item and add item</span><span id="17ee" class="li ju ht le b fi ln lk l ll lm">            if len(item[0]) &lt; 2:<br/>                continue</span><span id="f503" class="li ju ht le b fi ln lk l ll lm">            for k in item[2]:</span><span id="3cce" class="li ju ht le b fi ln lk l ll lm">                baseItemList = list(k[0])<br/>                # if base item set is empty then go to the next record.<br/>                if not baseItemList:<br/>                    continue</span><span id="b2f2" class="li ju ht le b fi ln lk l ll lm">                # sort the baseItemList before adding it as a key to the AssociationRules dictionary<br/>                baseItemList.sort()<br/>                baseItemList_key = tuple(baseItemList)</span><span id="c108" class="li ju ht le b fi ln lk l ll lm">                if baseItemList_key not in self.AssociationRulesDictionary.keys():<br/>                    self.AssociationRulesDictionary[baseItemList_key] = []</span><span id="89c7" class="li ju ht le b fi ln lk l ll lm">                self.AssociationRulesDictionary[baseItemList_key].append((list(k[1]), k[3]))</span><span id="b7ac" class="li ju ht le b fi ln lk l ll lm">                # if something goes wrong, then use the following print block to print values<br/>                #print("Base item: ", baseItemList_key)<br/>                #print("Target item: ", list(k[1]))<br/>                #print("Confidence: " + str(k[2]))<br/>                #print("Lift: " + str(k[3]))</span><span id="f2eb" class="li ju ht le b fi ln lk l ll lm">        # sort the rules in descending order of lift values.<br/>        for ruleList in self.AssociationRulesDictionary:<br/>            self.AssociationRulesDictionary[ruleList].sort(key=lambda x: x[1], reverse=True)<br/></span><span id="3ad7" class="li ju ht le b fi ln lk l ll lm">    def recommend(self, itemList, Num=1):<br/>        """<br/>        itemList is a list of items selected by user<br/>        Num is total recommendations required.<br/>        :param item:<br/>        :return:<br/>        """</span><span id="3fe3" class="li ju ht le b fi ln lk l ll lm">        # convert itemList to itemTuple as our dictionary key is a sorted tuple<br/>        itemList.sort()<br/>        itemTuple = tuple(itemList)</span><span id="3f3c" class="li ju ht le b fi ln lk l ll lm">        if itemTuple not in self.AssociationRulesDictionary.keys():<br/>            return []</span><span id="9550" class="li ju ht le b fi ln lk l ll lm">        return self.AssociationRulesDictionary[itemTuple][:Num]</span><span id="4c69" class="li ju ht le b fi ln lk l ll lm">    def studyRules(self):<br/>        """<br/>        This is a template method for computation and rule extraction.<br/>        :return:<br/>        """<br/>        self.computeRules()<br/>        self.extractRules()</span><span id="5bc5" class="li ju ht le b fi ln lk l ll lm">    def showDeals(self, itemList, Num=1):<br/>        """<br/>        we are converting the recommendations into deals. The lift value is used to calculate discount percentage<br/>        discount percentage = 10 * lift<br/>        itemList is a list of items selected by user<br/>        Num is total deals required.<br/>        :return:<br/>        """<br/>        recommendations = self.recommend(itemList, Num)</span><span id="f394" class="li ju ht le b fi ln lk l ll lm">        for item in recommendations:<br/>            print( "If you buy ", item[0], " along with ", itemList, " then you will get ", round((item[1] * 10), 2), \<br/>                   "% discount on total cost!!" )<br/></span><span id="9890" class="li ju ht le b fi ln lk l ll lm">Alexa = Recommender("store_data.csv")</span><span id="19c1" class="li ju ht le b fi ln lk l ll lm">Alexa.studyRules()</span><span id="7004" class="li ju ht le b fi ln lk l ll lm">print (Alexa.recommend(['red wine'], 1))</span><span id="4aac" class="li ju ht le b fi ln lk l ll lm">Alexa.showDeals(['red wine'], 2)</span></pre></div></div>    
</body>
</html>