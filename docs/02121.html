<html>
<head>
<title>How to build an enigma machine virtualisation in python.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用python构建一个enigma机器虚拟化？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-build-an-enigma-machine-virtualisation-in-python-b5476a1fd922?source=collection_archive---------1-----------------------#2019-12-02">https://medium.com/analytics-vidhya/how-to-build-an-enigma-machine-virtualisation-in-python-b5476a1fd922?source=collection_archive---------1-----------------------#2019-12-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7097cdea47e5c1e2354b2cd9c6841a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKqW7a6yTLWAFbqAL71Pxw.png"/></div></div></figure><p id="f8d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1939年至1944年是人类历史上的黑暗时期。第二次世界大战杀死了6000万人。但是如果盟军没有破解纳粹德国制造的最强大的机器之一——英格玛，这可能需要5年多的时间。</p><p id="7ca8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">恩尼格玛——那个时期最强大的加密设备之一。由亚瑟·谢尔比乌斯和T2·理查德·里特发明，起初德国海军并没有注意到它的发明。但是在1926年，海军开始建造自己的“谜”。这给了德国军队在这场血腥战争中的巨大优势。</p><p id="c962" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">恩尼格玛有一套非常复杂的加密和解密信息的方法。打破它花费了大量的时间和脑力。但最有趣的事实是，它基于一种最脆弱的加密算法——<strong class="is hj">凯撒密码</strong>。</p><h2 id="8efc" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">因此，在这篇文章中，我想解释一下enigma是如何以一个3转子的enigma为例工作的，同时展示你如何用python自己创建一个Enigma。</h2><h1 id="2bd2" class="kk jq hi bd jr kl km kn jv ko kp kq jz kr ks kt kc ku kv kw kf kx ky kz ki la bi translated">对谜的剖析</h1><p id="f767" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">基本上，英格玛由4个主要部分组成——一个用户界面，一个<em class="lg"> Steckerbrett，</em> 3转子(可能更多)和一个反射器。每一部分都在做一个特定的任务，但是把它们放在一起，它们就可以加密一条信息，如果不知道恩尼格玛密码机的初始设置，就不可能解密这条信息。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/2cf587f3c9030ffd602b54ec52a94021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uoYUlrpC1HFuytg72CtzyQ.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">对谜的剖析</figcaption></figure><p id="8412" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">恩尼格玛的主要特征之一是，为了正确解密，用户需要恩尼格玛在信息加密时的初始设置。如果一个设置不同，那么整个任务就变得不可能。</p><p id="1cb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们开始吧。</p><h1 id="64ae" class="kk jq hi bd jr kl km kn jv ko kp kq jz kr ks kt kc ku kv kw kf kx ky kz ki la bi translated">用户界面</h1><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/585789c0f9aa2ed1914d4b0719448b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDnyAhqilCkpYysMOPEgOg.jpeg"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">英格玛键盘。</figcaption></figure><p id="35ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用户界面非常简单——由26个字母的键盘表示。它用于在机器中插入输入。而且，按下的键激活改变第一转子状态的机构，使其旋转一个单元，因此在每次按下某个按钮后改变加密密钥。</p><h1 id="b962" class="kk jq hi bd jr kl km kn jv ko kp kq jz kr ks kt kc ku kv kw kf kx ky kz ki la bi translated"><strong class="ak">斯特克尔布雷特</strong></h1><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/65eae7c401eb198fc02a292e490ff93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PoFzu8Af3iQP81OpLw_gYg.jpeg"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">斯特克尔布雷特</figcaption></figure><p id="4576" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">stackerbrett是套接字的表格，是另一种机制，它被创建来使解密机制更加困难。但实际上这是机器最薄弱的部分。它是一种连接两个字母的机制，一个来自输入层，另一个来自输出层。把输入的字母编码成与之相连的输出层，而不使用机器的下一部分。然而，即使按下这样一个字母，转子还是会转动。</p><h1 id="2d2b" class="kk jq hi bd jr kl km kn jv ko kp kq jz kr ks kt kc ku kv kw kf kx ky kz ki la bi translated"><strong class="ak">转子</strong></h1><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/a49cf705c5f69aa6f14794b740a2cd83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bt2Wr4hTPlAKaH-Pvb4zHQ.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">英格玛转子。</figcaption></figure><p id="436c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">转子是带有26个销的特殊齿轮。每一枚别针都与一个英文字母有关。当电信号(在机械机器中)到达一个转子时，它将被传递到同一位置的下一个转子。在位置(0，0，0)处，每个字母将被编码为其自身。但是在状态(1，0，0)下，字母A将被编码为B，B被编码为C，依此类推。但是等等，为什么？</p><p id="5d21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">答案在于加密的凯撒密码算法。让我们来看看它是如何工作的。</p><p id="2a30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先我们需要一个有序的字母表→ A B C D E F G H …</p><p id="bab0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，为了加密，我们需要一个密钥K，我们将用它来加密我们的消息。K是一个正整数，它将每个字母编码为第一个字母之后K步之后的字母。在下图中，K = 3。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/d2857bcc37a46efd9753672df5df7344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*VTWBF_xrygGGaRy2aL0E3g.png"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">K = 3时的凯撒密码</figcaption></figure><p id="372e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，A将被D代替，B被E代替，C被F代替，依此类推。</p><p id="c5e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，每个转子加密信息。算法中置换的变量K实际上是从0状态开始的圈数。</p><p id="7a80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但这还不是结束，在第一个转子每旋转26次后，第二个转子也旋转一次。</p><p id="4b8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第三个转子也是如此，第二个转子每转26圈，它就转一圈，但第一对转子不太可能，当第三个转子转一圈时，第二个转子也转一圈。</p><h1 id="f02f" class="kk jq hi bd jr kl km kn jv ko kp kq jz kr ks kt kc ku kv kw kf kx ky kz ki la bi translated"><strong class="ak">反射器</strong></h1><p id="0738" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">反射器是谜的另一部分。它实际上给了机器使用相同的加密和解密设置的机会。它的工作方式如下:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/1dde420372f4d27af0ec6190d53ca585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_iZW44ZNdLKpPBXLeseig.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">反射器的结构。</figcaption></figure><h1 id="5ece" class="kk jq hi bd jr kl km kn jv ko kp kq jz kr ks kt kc ku kv kw kf kx ky kz ki la bi translated"><strong class="ak">这一切是如何运作的？</strong></h1><p id="fda8" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">有很多部分，每一个都有自己的工作原理，你可能会弄不清楚它们是如何协同工作的。这比你想象的要容易，所以让我们从头开始。</p><p id="5fde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们在键盘上按一个字母。如果它连接到stackerbrett，那么它将被编码为这个连接的结束字母。如果没有，它将通过转子，在每个转子后改变自己。当字母从第三个转子出来后，它进入反射器，在那里它随着它的反射而改变。然后反射进入3号转子，然后改变它，第二个和第一个转子也会改变它，给出新的加密。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/c0d89949ca76da26c4fb0aca0429e483.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*F3fS51uglCQRxLsX15Zn1Q.png"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">谜究竟是如何诠释一个角色的？</figcaption></figure><p id="c7b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们用代码实现它。</p><h1 id="d0f9" class="kk jq hi bd jr kl km kn jv ko kp kq jz kr ks kt kc ku kv kw kf kx ky kz ki la bi translated">Python代码。</h1><p id="8c36" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">首先，我们需要导入必要的库和包。</p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="e694" class="jp jq hi lx b fi mb mc l md me"># Importing all libraries<br/># We need ascii_lowercase from string to get the english alphabet<br/>from string import ascii_lowercase<br/># We need json library to add the possibility for enigma to import settings from a json format<br/>import json</span></pre><ul class=""><li id="bde8" class="mf mg hi is b it iu ix iy jb mh jf mi jj mj jn mk ml mm mn bi translated">From string — ascii_lowercase —用于生成字母表。</li><li id="ca87" class="mf mg hi is b it mo ix mp jb mq jf mr jj ms jn mk ml mm mn bi translated">json-用于从JSON格式的文件中上传enigma设置。</li></ul><p id="b4f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，我们创建一个类——enigma，它将代表我们的enigma，以及用于设置enigma的__init__函数，其中我们必须设置字母表(<strong class="is hj"> self.alphabet </strong>)和stecker Brett(<strong class="is hj">self . stecker Brett</strong>)。有三种方法:</p><ul class=""><li id="5dc3" class="mf mg hi is b it iu ix iy jb mh jf mi jj mj jn mk ml mm mn bi translated">从文件—从json文件导入所有设置。</li></ul><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="d9d0" class="jp jq hi lx b fi mb mc l md me">def __init__(self, steckerbrett = {" ":" "}, settings_file=None, alpha=None, beta=None, gama=None):<br/>    <em class="lg">''' The initial setting of enigma before the encryption '''<br/>    </em># Creating a list of all alphabet letters<br/>    self.alphabet = list(ascii_lowercase)<br/><br/>    '''<br/>        Steckerbrett is a system of sockets that connects pairs of letters that are interchanged between them,<br/>        without going throw all the rotors of enigma<br/>    '''<br/>    self.steckerbrett = steckerbrett<br/>    if settings_file != None:<br/>        ''' If the setting sites is got then we load the setting from it as a json format '''<br/>        try:<br/>            # I verify if there is a such file with setting that we got<br/>            self.settings = json.load(open(settings_file, 'r'))[0]<br/>        except IOError as e:<br/>            # The first enigma error - There is no such a settings file<br/>            print("Enigma Error 1: There is no such setting file")<br/>        finally:<br/>            # steckerbratt -&gt; a dictionary with pairs of interchangeable pairs of letters<br/>            self.steckerbrett = self.settings['steckerbrett']<br/>            # Setting the states of rotors<br/>            self.alpha = self.settings['alpha']<br/>            self.beta = self.settings['beta']<br/>            self.gama = self.settings['gama']</span></pre><ul class=""><li id="9c50" class="mf mg hi is b it iu ix iy jb mh jf mi jj mj jn mk ml mm mn bi translated">手动设置。</li></ul><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="0d33" class="jp jq hi lx b fi mb mc l md me">elif alpha != None and beta != None and gama != None and steckerbrett != None:<br/>    ''' Setting the rotors and the steckerbrett manually '''<br/>    if type(steckerbrett) is not dict:<br/>        self.steckerbrett = {" " : " "}<br/>    self.alpha = alpha<br/>    self.beta = beta<br/>    self.gama = gama</span></pre><ul class=""><li id="70b4" class="mf mg hi is b it iu ix iy jb mh jf mi jj mj jn mk ml mm mn bi translated">所有转子的默认设置。</li></ul><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="e1f5" class="jp jq hi lx b fi mb mc l md me">else:<br/>    # Setting all rotors to base states and steckerbrett to have only space case<br/>    if type(steckerbrett) is not dict:<br/>        self.steckerbrett = {" " : " "}<br/>    rotors = [self.alpha, self.beta, self.gama]<br/>    for rotor in rotors:<br/>        if rotor == None or type(rotor) is not int or type(rotor) is not float:<br/>            rotor = 0<br/>        else:<br/>            rotor = rotor % 26<br/>    self.alpha = rotors[0]<br/>    self.beta = rotors[1]<br/>    self.gama = rotors[2]</span></pre><p id="0d3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在__init__函数中，我们必须做的下一件事是在stackerbrett中进行最后的更改，并设置反射器。</p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="6ece" class="jp jq hi lx b fi mb mc l md me"># Making the steckerbrett interchangeable and removing these pairs from the alphabet<br/>for letter in list(self.steckerbrett.keys()):<br/>    if letter in self.alphabet:<br/>        self.alphabet.remove(letter)<br/>        self.alphabet.remove(self.steckerbrett[letter])<br/>        self.steckerbrett.update({self.steckerbrett[letter]:letter})<br/># Setting the reflector<br/>self.reflector = [leter for leter in reversed(self.alphabet)]</span></pre><p id="8cb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">排列的下一个功能。加密算法的核心。所有的转子——阿尔法、贝塔和伽马——决定着凯撒密码的密钥——K。</p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="b4cf" class="jp jq hi lx b fi mb mc l md me">def permutate(self, rotor):<br/>    <em class="lg">''' This function is permutatting the alphabet depending on the rotors settings '''<br/>    </em>new_alphabet = ''.join(self.alphabet)<br/>    new_alphabet = list(new_alphabet)<br/>    for iter in range(rotor):<br/>        new_alphabet.insert(0, new_alphabet[-1])<br/>        new_alphabet.pop(-1)<br/>    return new_alphabet</span><span id="a703" class="jp jq hi lx b fi mt mc l md me">def inverse_permutation(self, rotor):<br/>    <em class="lg">''' This function is permutatting the alphabet depending on the rotors settings on the back way '''<br/>    </em>new_alphabet = ''.join(self.alphabet)<br/>    new_alphabet = list(new_alphabet)<br/>    for iter in range(rotor):<br/>        new_alphabet.append(new_alphabet[0])<br/>        new_alphabet.pop(0)<br/>    print(self.alphabet)<br/>    print(new_alphabet)<br/>    return new_alphabet</span></pre><h1 id="80bd" class="kk jq hi bd jr kl km kn jv ko kp kq jz kr ks kt kc ku kv kw kf kx ky kz ki la bi translated">最重要的部分是加密过程。</h1><p id="fb9f" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">首先，我们将文本中的每个字母转换成lower，并将其转换成一个列表。</p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="5c69" class="jp jq hi lx b fi mb mc l md me">def encrypt_text(self, text):<br/>    <em class="lg">''' This function encrypts a string '''<br/>    </em>encrypted_text = []<br/>    # Text preprocessing<br/>    text = text.lower()<br/>    text.split()</span></pre><p id="ecc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，我们会仔细检查名单，处理每一封信。如果字母在栈中，那么我们只返回它所连接的值。当然，它会经历一个在英格玛系统中旋转转子的过程。</p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="17bc" class="jp jq hi lx b fi mb mc l md me">for letter in text:<br/>    # Checking if the letter is in steckerbrett<br/>    if letter in self.steckerbrett:<br/>        # If it is, the we encrypt it as it's pair<br/>        encrypted_text.append(self.steckerbrett[letter])<br/>        # Turning the rotors<br/>        self.alpha += 1<br/>        if self.alpha % 26 == 0:<br/>            self.beta += 1<br/>            self.alpha = 0<br/>        if self.beta % 26 == 0 and self.alpha % 26 != 0 and self.beta &gt;= 25:<br/>            self.gama += 1<br/>            self.beta = 1</span></pre><p id="75f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">否则，我们通过每个转子的设置来加密每个字母，我们在字母表中找到该字母的对应索引(当然是在我们从stackerbrett中移除字母之后)。我们对每个转子重复这个过程，使用每个前面转子的输出。</p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="c53e" class="jp jq hi lx b fi mb mc l md me">else:<br/>        # Encrypting throw rotors<br/>        # Letter is encrypted by first rotor<br/>        temp_letter = self.permutate(self.alpha)[self.alphabet.index(letter)]<br/>        # Letter is encrypted by second rotor<br/>        temp_letter = self.permutate(self.beta)[self.alphabet.index(temp_letter)]<br/>        # Letter is encrypted by third rotor<br/>        temp_letter = self.permutate(self.gama)[self.alphabet.index(temp_letter)]</span></pre><p id="3271" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在最后一个转子— gamma返回字母后，它被反射器“反射”,返回该字母的镜像。</p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="e507" class="jp jq hi lx b fi mb mc l md me"># Reflector is returning the inverse of that letter<br/>temp_letter = self.reflector[self.alphabet.index(temp_letter)]</span></pre><p id="26f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在那里，我们开始以相反的方式通过转子，按照下一个顺序——伽马、贝塔、阿尔法。</p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="229c" class="jp jq hi lx b fi mb mc l md me"># Back way<br/># Letter is encrypted by third rotor<br/>temp_letter = self.inverse_permutation(self.gama)[self.alphabet.index(temp_letter)]<br/>print("gama - {}".format(temp_letter))<br/># Letter is encrypted by second rotor<br/>temp_letter = self.inverse_permutation(self.beta)[self.alphabet.index(temp_letter)]<br/>print("beta - {}".format(temp_letter))<br/># Letter is encrypted by first rotor<br/>temp_letter = self.inverse_permutation(self.alpha)[self.alphabet.index(temp_letter)]<br/>print("alpha - {}".format(temp_letter))<br/>encrypted_text.append(temp_letter)<br/>print(temp_letter)</span></pre><p id="d963" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，我们只需将列表中所有加密的字母连接起来，就可以得到加密的文本。</p><p id="ffa9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看一个例子:</p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="9e40" class="jp jq hi lx b fi mb mc l md me">Enigma = enigma({"b":'a', ' ':' ', 'e':'z'}, alpha=5, beta=17, gama=24)</span></pre><p id="16e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我用手动设置创建了一个enigma，但是从一个文件设置它也可以。现在让我们加密一个字符串，我选择了一个从我的一个同事那里得到的短语— <strong class="is hj">“没有时间”。</strong></p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="cd61" class="jp jq hi lx b fi mb mc l md me">print(Enigma.encrypt_text('there is no time'))</span></pre><p id="288b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果是:</p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="689f" class="jp jq hi lx b fi mb mc l md me">iuzkz tj on itpz</span></pre><p id="a43f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我向后试的时候，我得到同样的短语:</p><pre class="li lj lk ll fd lw lx ly lz aw ma bi"><span id="3006" class="jp jq hi lx b fi mb mc l md me">print(Enigma.encrypt_text('iuzkz tj on itpz'))<br/>&gt;&gt;&gt;there is no time</span></pre><p id="63bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">成功了，成功了。</p><h1 id="c4b6" class="kk jq hi bd jr kl km kn jv ko kp kq jz kr ks kt kc ku kv kw kf kx ky kz ki la bi translated">结论</h1><p id="18c4" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">这个项目对我来说有点挑战性，即使我只用了两天就完成了。首先，我必须理解enigma的数学逻辑，然后用python实现它。</p><p id="2bfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想说的另一件事是，使用python你可以很容易地虚拟化几乎所有东西，甚至是一台花了4年时间解密的机器。我真的邀请你在我的<a class="ae jo" href="https://github.com/ScienceKot/Enigma.git" rel="noopener ugc nofollow" target="_blank"> github </a>上研究enigma的全部代码。还有一个功能——如何加密一个. txt文件。</p><p id="0faf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢大家。</p></div></div>    
</body>
</html>