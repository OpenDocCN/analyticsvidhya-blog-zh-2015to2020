<html>
<head>
<title>Stackoverflow Based Semantic Search Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于堆栈流的语义搜索引擎</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/stackoverflow-based-semantic-search-engine-139e2b2e8860?source=collection_archive---------7-----------------------#2020-03-04">https://medium.com/analytics-vidhya/stackoverflow-based-semantic-search-engine-139e2b2e8860?source=collection_archive---------7-----------------------#2020-03-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7762e0dc3fb5c4a58d65720f203ee735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*49shmWGsJdHomHodycLPGA.png"/></div></div></figure><p id="33d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你曾经写过代码，那么你一定很熟悉StackOverflow。对于那些不熟悉这个的人，StackOverflow为程序员提供了一个最大的QA平台。用户提出问题/疑问，他们的程序员同事试图以最有帮助的方式提供解决方案。答案越好，得到的票数就越高，这也提高了用户的声誉。</p><p id="caba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">鉴于它的受欢迎程度，可以肯定地说有大量的数据，然而，如此庞大的信息量也使得寻找解决方案变得困难。但并不是大程序员知道编程，因为他们知道如何用合适的关键词优化你的搜索查询。但是对于一个初来乍到的人来说，事情并没有那么简单。因此，一个最佳的搜索引擎是必要的导航通过这个烂摊子。</p><h1 id="8c2e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">索引</h1><ol class=""><li id="1672" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn kt ku kv kw bi translated">任务</li><li id="47c0" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">商业问题</li><li id="51c2" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">ML问题</li><li id="01c9" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">方法</li><li id="d24d" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">数据</li><li id="cb99" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">库导入</li><li id="11d9" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">数据分析和处理</li><li id="62bd" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">标签预测模型</li><li id="e46d" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">创建搜索管道</li><li id="1397" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">改进的范围</li><li id="b72d" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">参考</li></ol></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="f23f" class="jo jp hi bd jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl bi translated">1.任务</h1><p id="9e9d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">我们的目标是让平台真正理解用户试图搜索的内容，然后基于此返回最相似的结果。我需要收集Stack Overflow上发布的问题和答案。因此，我需要以下内容:</p><ul class=""><li id="4c7b" class="km kn hi is b it iu ix iy jb lr jf ls jj lt jn lu ku kv kw bi translated">标题</li><li id="b870" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">问题主体</li><li id="4d30" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">这个问题的答案</li><li id="2f0d" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">为每个答案投票</li></ul></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="8cef" class="jo jp hi bd jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl bi translated">2.商业问题</h1><p id="33ee" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">StackOverflow拥有大量的信息，因此很难找到想要的解决方案。对于编程老手和其他有经验的专业人士来说，这并不是什么大问题，因为他们知道获得适当答案所需的正确关键字。然而，对于一个初级程序员来说，这是一个很大的问题。例如，如果他需要学习“如何使用Python制作服务器”，他不太可能在搜索框中使用“Django”或“Flask”这两个词。因此，需要一个最佳的搜索引擎。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="1ad0" class="jo jp hi bd jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl bi translated">3.ML问题</h1><p id="307b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">我们必须建立一个基于语义的搜索引擎，使用StackOverflow数据进行搜索。</p><h2 id="20cb" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">性能指标</h2><p id="2b33" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">我使用微f1_score作为我的标签预测模型的度量，因为它是多标签分类模型，微f1_score是一个很好的选择度量</p><h2 id="4eec" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">限制</h2><p id="8962" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">因为它是一个搜索引擎，延迟应该很低。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="8c41" class="jo jp hi bd jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl bi translated">4.方法</h1><ul class=""><li id="52a5" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn lu ku kv kw bi translated">首先，我将从<a class="ae mj" href="https://www.kaggle.com/stackoverflow/stackoverflow" rel="noopener ugc nofollow" target="_blank"><em class="mk"/></a>获取数据，并对其进行一些预处理和特征工程。</li><li id="c665" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">然后我训练一个深度学习模型来预测输入查询的标签，这样我就知道输入查询属于哪个类别，我的度量将是micro f1_score。在这里，我也使用w2vec模型进行矢量化，因为我使用余弦相似度以及投票数和对答案的情感极性来选择投票最多的积极响应，为了实现这一点，我想将我的查询表示到向量空间中。</li><li id="984e" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">最后，我将创建一个小的UI来获取输入，当用户输入新的查询时，我将首先处理它，然后从它预测标记，之后过滤与预测的标记相关的主StackOverflow数据。这样做之后，我将把我的搜索和嵌入限制在仅过滤数据的语料库，并基于相似性以及大多数投票和积极的情绪。我将结果返回给用户。</li></ul></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="89c9" class="jo jp hi bd jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl bi translated">5.数据</h1><p id="5eb8" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">我将使用这个<a class="ae mj" href="https://www.kaggle.com/stackoverflow/stackoverflow" rel="noopener ugc nofollow" target="_blank"><em class="mk">https://www.kaggle.com/stackoverflow/stackoverflow</em></a>数据集。我包含了堆栈溢出内容的档案，包括<br/>帖子、投票、标签和徽章。该数据集被更新以反映互联网档案上的堆栈溢出内容。</p><ul class=""><li id="77f4" class="km kn hi is b it iu ix iy jb lr jf ls jj lt jn lu ku kv kw bi translated">我将使用bq_helper，它是一个助手类，用来执行只读的BigQuery任务。参考:<a class="ae mj" href="https://www.kaggle.com/sohier/introduction-to-the-bq-helper-package" rel="noopener ugc nofollow" target="_blank"><em class="mk">https://www . ka ggle . com/sohire/introduction-to-the-bq-helper-package</em></a></li><li id="4ef1" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">在Stackoverflow数据库中有许多表，但是我们只需要关注posts_questions和posts_answers。</li></ul></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="3ae8" class="jo jp hi bd jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl bi translated">6.库导入</h1><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h2 id="8a45" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">获取数据</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><figure class="ml mm mn mo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/1e5008f5f377ec0e4d7c3c547971756f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNvl3F4Y3vAHoRW0lv282Q.png"/></div></div><figcaption class="ms mt et er es mu mv bd b be z dx translated">来自Google BigQuery的原始数据</figcaption></figure><h2 id="4f5d" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">观察</h2><p id="69d5" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">基本上，这个查询连接两个表(<em class="mk">stack overflow . post _ questions</em>和<em class="mk">stack overflow . posts _ answers</em>)并收集10000000个问题所需的数据。因此，每行包含一个问题和一个答案。(<strong class="is hj">注</strong> : <em class="mk">可能存在问题相同但答案唯一的行</em>)。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="d111" class="jo jp hi bd jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl bi translated">7.数据分析和处理</h1><h2 id="116d" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">缺失值检查</h2><pre class="ml mm mn mo fd mw mx my mz aw na bi"><span id="bbb1" class="lv jp hi mx b fi nb nc l nd ne">original_data.isna().sum()</span></pre><figure class="ml mm mn mo fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/ad56dbb1af617aea07306eef4401793e.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*fHtNIx27hNxfZ-0VV6A91g.png"/></div><figcaption class="ms mt et er es mu mv bd b be z dx translated">缺失值输出</figcaption></figure><h2 id="9b88" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">观察</h2><ul class=""><li id="a3f4" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn lu ku kv kw bi translated">很高兴看到数据集中没有丢失值。</li><li id="824b" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">因此不需要数据插补。</li></ul><h2 id="5797" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">检查数据中的重复项(如果有)</h2><pre class="ml mm mn mo fd mw mx my mz aw na bi"><span id="04d3" class="lv jp hi mx b fi nb nc l nd ne">original_data.duplicated().any()<br/>--------------------------------<br/>True</span></pre><p id="eb90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上所述，数据集可能包含具有相同问题但唯一答案的行。我们希望将所有这些不同的行合并为一行，同时汇总每个答案的投票并合并所有答案。</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><figure class="ml mm mn mo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/f75ad92aa16002279a657dca9940be06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mtU-xVzag23UaqvfR6IWZA.png"/></div></div><figcaption class="ms mt et er es mu mv bd b be z dx translated">合并具有相同问题的行后的数据</figcaption></figure><p id="ea7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，既然我们已经准备好了原始数据，我们就可以开始清理和预处理这些原始文本数据了。我正在做一些基本的文本处理，包括以下步骤:</p><ul class=""><li id="bad3" class="km kn hi is b it iu ix iy jb lr jf ls jj lt jn lu ku kv kw bi translated">文本的标记化</li><li id="ac7c" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">将标记转换为小写</li><li id="68ec" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">从标记列表中删除标点符号</li><li id="f785" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">从标记列表中移除停用字词</li><li id="1689" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">代码字符串的标记化</li></ul><p id="6a3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您仔细观察数据集，您会发现问题和答案的原始文本是与HTML标记一起给出的，它最初是用HTML标记显示在StackOverflow上的。这些通常是指'<em class="mk"> p' </em>标签、<em class="mk"> 'h1-h6' </em>标签和'<em class="mk">代码'</em>标签。所以我的方法如下:</p><ul class=""><li id="b435" class="km kn hi is b it iu ix iy jb lr jf ls jj lt jn lu ku kv kw bi translated">我构建了一个新的专栏，叫做“post_corpus ”,将标题、问题主体和所有答案结合起来</li><li id="750e" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">我把标题加在问题正文的前面</li><li id="52a6" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">我使用“代码”部分来提取一些特征。</li><li id="c1f4" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">我通过在'<a class="ae mj" href="https://stackoverflow.com/questions/'" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/'</a>后面添加问题id来构建每个问题的URL</li><li id="24f4" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">我使用开源的<strong class="is hj"> Textblob库</strong>为情感构建了2个特征</li></ul><p id="f45b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每篇文章都有不同数量的标签。为了缩小更精确模型的选择范围，我决定用100个最常见的标签。计划是只过滤包含至少一个most _ common _ tags的数据。</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="e47a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">预处理步骤中的最后一项任务如下:</p><ul class=""><li id="1fb1" class="km kn hi is b it iu ix iy jb lr jf ls jj lt jn lu ku kv kw bi translated">我为“processed_title”创建了一个单独的列，因为我想保留原始标题，因为我想在最终输出中提供原始标题。</li><li id="f986" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">我也在规范数字“分数”</li><li id="3401" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">我还为“代码”创建了一个单独的列，因为我想将它用于标记预测</li></ul><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="1a5e" class="jo jp hi bd jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl bi translated">8.标签预测模型</h1><h2 id="976a" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">导入库</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h2 id="be4c" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">仅过滤掉最常见的标签</h2><p id="6be4" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">尽管我们在数据预处理步骤中过滤掉了许多标签，但是仍然存在许多“杂散”标签，与其他标签成千上万次的出现相比，这些标签可能只出现一次或两次。这增加了地面真实数据的维度，这对于我们的模型是不期望的。</p><p id="1733" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我根据出现的次数提取了前1000个标签。最后，我修改了标签数据，只包括这1000个标签中的一个标签，以获得更好的模型准确性。</p><figure class="ml mm mn mo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/467216a34434fd2d456e3ac53898a9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPb8MMEjmAu6cOQQIeXBjA.png"/></div></div></figure><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h2 id="b38e" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">使用Word2Vec训练单词嵌入</h2><p id="bb0b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">为了让我们的模型理解原始文本数据，我们需要对它进行矢量化，单词包和TF-IDF是非常常见的矢量化方法。然而，由于我将使用一个人工神经网络作为我的模型，BOW和TFIDF的稀疏特性会带来一个问题。因此，我决定选择单词嵌入，这是一种密集的向量表示，因此非常适合我们的神经网络。</p><p id="fcb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">人们在StackOverflow上交谈的方式是非常技术性的，他们使用非常特定的词汇，因此使用预先训练的单词嵌入不是一个好主意，因为他们是在普通英语文本上训练的，无法理解我们词汇中单词之间的关系。因此，我决定使用Word2Vec从头开始训练一个单词嵌入模型。</p><p id="3be3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此经过成功的训练，我们得到了以下结果:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><pre class="ml mm mn mo fd mw mx my mz aw na bi"><span id="39a0" class="lv jp hi mx b fi nb nc l nd ne">Terms most similar to "python"<br/>[('python3', 0.6342744827270508), ('perl', 0.5586778521537781), ('bash', 0.5048258304595947), ('python36', 0.4876842796802521),<br/>('pyhton', 0.482374906539917), ('python27', 0.4808519780635834), ('lua', 0.4791009724140167), ('ruby', 0.4676322937011719), ('py<br/>thon2', 0.46161943674087524), ('matlab', 0.46039116382598877)]<br/>--------------------------------------------------------------------<br/>Terms most similar to "Node"<br/>[('nodes', 0.6288038492202759), ('firstnode', 0.5410162210464478), ('nodetext', 0.5174486041069031), ('new_node', 0.51485019922<br/>25647), ('node1', 0.5093669891357422), ('nodedata', 0.4883999228477478), ('newnode', 0.481780469417572), ('nodename', 0.4755<br/>1754117012024), ('node2', 0.4689573049545288), ('node3', 0.45593389868736267)]<br/>--------------------------------------------------------------------<br/>Terms most similar to "java"<br/>[('scala', 0.4836808145046234), ('groovy', 0.46810388565063477), ('c', 0.4596169888973236), ('python', 0.44173622131347656), ('jd<br/>k7', 0.4374290406703949), ('kotlin', 0.4267594814300537), ('jdk', 0.42633625864982605), ('eclipse', 0.4209193289279938), ('netbea<br/>n', 0.41293397545814514), ('jdk6', 0.40997016429901123)]<br/>--------------------------------------------------------------------<br/>Terms most similar to "server"<br/>[('sever', 0.6860402822494507), ('client', 0.666864812374115), ('webserver', 0.5926132798194885), ('servers', 0.5850958824157715<br/>), ('machine', 0.5267062187194824), ('service', 0.5109481811523438), ('remote', 0.5007282495498657), ('backend', 0.49881637096<br/>40503), ('remotely', 0.4766204357147217), ('locally', 0.47090765833854675)]</span></pre><h2 id="5c16" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">训练神经模型</h2><p id="b52f" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">准备用于训练模型的数据包括:</p><ol class=""><li id="d36a" class="km kn hi is b it iu ix iy jb lr jf ls jj lt jn kt ku kv kw bi translated">一键编码数据</li><li id="7f2a" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">分成训练和测试数据</li><li id="82a0" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">标记化和填充</li><li id="fa63" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">创建嵌入矩阵</li></ol><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="854f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在拆分之前，我合并了post_corpus和code列，因为我想包含问题的代码部分，还因为我还包含了可用于预测标记的信息。</p><p id="7d54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在这里训练三个模型，分别是GRU、CNN和LSTM，基于这三个模型的f1_micro、recall_micro和precission _ micro结果，我选择了最终的模型</p><h2 id="e77e" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">模型1</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h2 id="645d" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">模型2</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h2 id="65ca" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">模型3</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h2 id="8b8d" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">模型比较</h2><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><figure class="ml mm mn mo fd ij er es paragraph-image"><div class="er es ni"><img src="../Images/d366f9df9c3b64d72623dec54e84d791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*Ck24J-ClCSOovDBsIezVxg.png"/></div><figcaption class="ms mt et er es mu mv bd b be z dx translated">模型比较</figcaption></figure><h2 id="bbab" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">观察</h2><ul class=""><li id="b780" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn lu ku kv kw bi translated">我训练了三个神经网络模型，一个基于GRU，一个基于CNN，一个基于LSTM。</li><li id="87b7" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">GRU模型具有最佳的召回率、精确度和f1值，所以我选择了这个模型。</li></ul></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="2cdb" class="jo jp hi bd jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl bi translated">9.创建搜索管道</h1><p id="f3df" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">到目前为止，我们已经训练了将预测用户的输入搜索查询的标签的模型。</p><p id="f845" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在这一节中，我将向您展示我们将如何使用这个预测标签以及其他简单但有用的余弦相似性技巧来获得输入搜索查询的最相似结果。</p><p id="ac66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要知道这两个句子有多相似，我们可以找出它们之间的距离。为了能够计算这样的距离，句子必须属于同一个向量空间。这是通过句子嵌入来完成的。</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h2 id="0110" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">观察</h2><ul class=""><li id="326b" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn lu ku kv kw bi translated">首先，我加载数据、训练模型、标题嵌入和W2Vec模型。</li><li id="2f6b" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">然后，我定义了必要的功能，如损失、评估指标、矢量化等。</li><li id="cd85" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">之后我计算了数据中所有标题的TFIDF。</li><li id="04b0" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">在这之后，我定义了一个名为“searchresult”的函数，它接受两个参数，一个是输入搜索字符串，另一个是输出中返回的搜索结果的编号。</li><li id="d693" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">在函数内部，我正在处理输入搜索查询，之后，我正在预测标签，一旦标签被预测，我就将主数据过滤为仅具有预测标签的数据，我还在计算输入查询的TFIDF，之后，我在计算输入搜索查询和所有过滤的数据标题的余弦相似性。</li><li id="cfff" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">在计算余弦相似性后，我将输入搜索的总得分、情感极性和TFIDF乘以适当的权重相加。</li><li id="31f2" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">最后，我将返回我希望在搜索输出中显示的所需内容的字典。</li></ul><h2 id="ebd7" class="lv jp hi bd jq lw lx ly ju lz ma mb jy jb mc md kc jf me mf kg jj mg mh kk mi bi translated">搜索引擎的GUI</h2><p id="a796" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">作为一个搜索引擎应该看起来像一个搜索栏，而不是像一个暴露的代码，所以在这一节中，我会教你我如何建立，所以用户不必挖掘代码来输入查询。</p><p id="dff4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在下面找到GUI的代码:</p><figure class="ml mm mn mo fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><figure class="ml mm mn mo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/c7ecd6fca3c532f14a005e26b48d2f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfYiO9Sijruq0QUqI0TB4g.png"/></div></div><figcaption class="ms mt et er es mu mv bd b be z dx translated">搜索引擎GUI</figcaption></figure><p id="ffab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于GUI，我使用了ipywidgets，这是一个非常简单的GUI，没有任何花哨的东西，它包含标题、两个输入框和一个搜索按钮。</p><ul class=""><li id="7a9d" class="km kn hi is b it iu ix iy jb lr jf ls jj lt jn lu ku kv kw bi translated">我从文本框中读取了两个输入字符串搜索查询和要打印的结果数。</li><li id="cb5c" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">之后，我使用名为preprocess_text的函数对输入查询进行预处理，我在utils笔记本中编写了这个函数，以使项目更加有组织。</li><li id="1b48" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">preprocess_text返回给我一个经过处理的文本，然后我将这个经过处理的文本和要打印的结果数作为“searchresult”方法的一个参数，我在一个名为search.ipynb的单独的笔记本中定义了这个方法，上面解释的操作发生了，并得到了最相似的结果</li><li id="f93c" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated">然后我把它作为搜索结果显示出来</li></ul><p id="4361" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在下面的视频块中看到搜索引擎的演示:</p><figure class="ml mm mn mo fd ij er es paragraph-image"><div class="er es nk"><img src="../Images/1d69a417984a2c6de656c05ede0ea59f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*qMEacLpqJkiKFTe-_wOX0A.gif"/></div><figcaption class="ms mt et er es mu mv bd b be z dx translated">搜索引擎演示视频</figcaption></figure></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="a1ca" class="jo jp hi bd jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl bi translated">10.改进的范围</h1><p id="689c" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">由于每个模型都有改进的余地，这个项目也有，你可以自由地做改变，尝试一些不同架构的其他模型来改善搜索结果。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="392c" class="jo jp hi bd jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl bi translated">11.参考</h1><ul class=""><li id="1fc4" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn lu ku kv kw bi translated"><a class="ae mj" href="https://www.appliedaicourse.com/course/11/applied-machine-learning-online-course" rel="noopener ugc nofollow" target="_blank">https://www . applied ai course . com/course/11/applied-machine-learning-online-course</a></li><li id="e67f" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated"><a class="ae mj" href="https://www.kaggle.com/stackoverflow/stackoverflow" rel="noopener ugc nofollow" target="_blank">T3【https://www.kaggle.com/stackoverflow/stackoverflow】T5</a></li><li id="81d7" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated"><a class="ae mj" href="https://www.kaggle.com/sohier/introduction-to-the-bq-helper-package" rel="noopener ugc nofollow" target="_blank"><em class="mk">https://www . ka ggle . com/sohire/introduction-to-the-bq-helper-package</em></a></li><li id="f731" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated"><a class="ae mj" href="https://machinelearningmastery.com/develop-word-embeddings-python-gensim/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/develop-word-embeddings-python-gensim/</a></li><li id="0d16" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn lu ku kv kw bi translated"><a class="ae mj" href="https://www.kaggle.com/pierremegret/gensim-word2vec-tutorial" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/pierremegret/gensim-word 2 vec-tutorial</a></li></ul><p id="ff9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">你可以在LinkedIn上联系我</strong><br/><a class="ae mj" href="https://www.linkedin.com/in/vashistnarayan-singh/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/vashistnarayan-singh/</a></p></div></div>    
</body>
</html>