<html>
<head>
<title>A smooth background image generator to colourize images such as one in EMNIST dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个平滑的背景图像生成器，用于给图像着色，例如EMNIST数据集中的图像</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-smooth-background-image-generator-to-colourize-images-such-as-one-in-emnist-dataset-c3e259716582?source=collection_archive---------17-----------------------#2020-09-12">https://medium.com/analytics-vidhya/a-smooth-background-image-generator-to-colourize-images-such-as-one-in-emnist-dataset-c3e259716582?source=collection_archive---------17-----------------------#2020-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4527" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们先来讨论一下这个帖子到底想做什么。</p><p id="fc7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在寻找的是一个很好的背景，这样我们就可以渲染灰度图像，如EMNIST数据集作为彩色图像，并且很容易在眼睛上识别图像中存在的对象。背景应该有一个从一种颜色到另一种颜色的良好过渡，使我们能够容易地识别物体。当然，我们希望它有尽可能多的颜色！</p><p id="ee35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们想要的是一种非常独特的欲望，我四处寻找，但找不到任何可以帮助我们的数据集。因此，我们将在没有任何数据集的情况下完成这一旅程。所以这完全取决于我们的损失函数。</p><p id="1111" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，为了定义我们的损失函数，我们应该首先有一个高层次的观点是什么使颜色出现在图像中。彩色图像有三个通道，分别对应红色、绿色和蓝色。所有这些颜色通道的数量级决定了哪种颜色出现在图像中。每个通道都将具有与图像相同的分辨率。因此，如果图像的分辨率为1024×1024，那么每个通道可以被可视化为1024×1024的网格。每一个都被称为像素。每个像素中的值的范围可以从0到255。每个通道中所有像素值都为0的图像对应于黑色图像，所有255对应于白色图像。介于两者之间的所有数值构成了其他颜色的全部范围。</p><p id="0d14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于神经网络在处理[0，1]范围内的数字时比处理[0，255]范围内的数字时工作得更好，所以我们将坚持使用[0，1]范围。这样做的效果是，虽然我们将能够生成所有可能的颜色(因为任何颜色都是基于像素的相对值而不是绝对值形成的)，但亮度会降低，这是一个好处，因为它将进一步增强对象。</p><p id="70cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这个背景，我们来定义损失函数。将会有几个函数，我们通过它们来测量模型的损失。这是两者中的第一个。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/87bc3ca710f4f606b61d0fc8e64be8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HzeIbze59QVBSJ9l0eLCw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">此功能确保图像中的数字均匀分布</figcaption></figure><p id="35cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jt">compute _ distribution _ loss</em>函数获取图像，并返回数字在范围[0，1]中分布的均匀程度。图像的像素值首先沿列排序，并与PyTorch框架的<a class="ae ju" href="https://pytorch.org/docs/stable/generated/torch.rand.html" rel="noopener ugc nofollow" target="_blank">和</a>函数给出的排序均匀分布进行比较。此函数确保范围内的数字均匀分布。因此具有以相等的概率产生所有颜色的能力。</p><p id="5b81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这个函数可以确保我们得到[0，1]范围内的所有数字，但是数字出现的顺序呢？如果这些数字杂乱无章，那么我们就很难识别这个物体，它就会被背景所掩盖。这将我们带到下一个损失函数，它确保从一种颜色到另一种颜色的平滑过渡。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jv"><img src="../Images/dee8e61243c3b09681d0dd94c54fecdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9wxcxGtYzJU_guxHBgnuQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">该功能确保从一种颜色到另一种颜色的平滑过渡</figcaption></figure><p id="af41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jt"> compute_var_loss </em>函数接收图像并返回像素值从一个过渡到另一个的平滑程度。对于每个图像，会生成一个16x16的随机裁剪。我们找到裁剪图像的方差，并将其除以最大值和最小值之间的差。计算随机裁剪图像的方差可确保此范围内的数字彼此接近，进而形成平滑过渡。为了使裁剪后的图像中的所有值都不相同(这会妨碍我们生成所有的数字)，我们用最大值和最小值之差来除它。</p><p id="2def" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">损失函数已经讲得够多了，现在让我们把注意力转移到模型的网络上。</p><p id="bf4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们模型的架构非常简单。它是一个三层网络。这三层是致密层，分别具有64、2048和4096个神经元。最后一层输出然后被整形为64x64以形成图像。下面给出了该架构的简单示意图。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jw"><img src="../Images/22b0a2b9f1bc0f0b7cc8b62c9e2348dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXV6OjRmDPAT55rXlmzhJw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">模型的架构</figcaption></figure><p id="b240" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们来谈谈我们想要使用的激活函数，尤其是最后一层要使用的函数。我们说过，我们希望输出在[0，1]的范围内。有几个函数可以满足这个属性。</p><p id="94a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Sigmoid函数就是这样一个函数。下面给出了函数的图形。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/d7025d160f64e8637f516c7cb6687423.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*BwZmaMBaVW8f8lBAQUoytw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">sigmoid激活函数图</figcaption></figure><p id="7683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，大多数值偏向0或1，只有一小部分数值介于两者之间。因此不太适合我们的应用。</p><p id="0c2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个功能是softmax功能。并且定义如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jy"><img src="../Images/bc568532ded8a691cd79e3bc13fa661f.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*jjymc5ss92gRhxRDkJny9A.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">softmax激活功能的定义</figcaption></figure><p id="2947" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，softmax实际上是取幂值的一部分指数。它非常适合多类分类。然而，softmax函数扩大了最大值和最小值之间的差异，并且大多数数字接近于零而不是一。这是因为我们将在4096个值输出中取softmax，这是模型的输出大小。</p><p id="e536" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决我们提出的问题，我们将使用我们自己的激活函数。让我们称它为<em class="jt"> Shift_range </em>，因为我们希望它将范围转换为[0，1]。并且定义如下。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jz"><img src="../Images/9d9cfdea7d08bca822f36da450508a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLBGW5BGGgiBqq401jbeKA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">最后一层使用的自定义激活功能<strong class="bd ka"> Shift_range </strong></figcaption></figure><p id="9eb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如人们可以观察到的，我们将把数字的规模减少到[0，1]。这使得我们可以得到[0，1]范围内的所有数字，而在生成的图像中没有太多技术问题。</p><p id="1819" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于损耗和激活函数，我们已经讨论得够多了。因此，没有太多的延迟，让我们的模型运行。看看它能给我们带来什么。我们将使用RMSprop优化算法以0.00001的学习率来训练网络。</p><p id="40a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以训练网络1000个历元后，这就是模型生成的样本图像。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kb"><img src="../Images/347a64779e3850e1d1ff62f033fafb6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*vKguOpwpu5eGpIvfsuLPyw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">1000个时期后生成的样本图像</figcaption></figure><p id="0f13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相当令人惊讶。我们说过希望所有的数字都在0到1之间。并且数字之间应该有平滑的过渡。我们把它们都拍进了图像中，但最终我们还是得到了一张黑白图像。这是因为我们假设模型每次都会有不同的输出。但是看起来生成的图像是相同的，与给定的输入无关。当然，通过深度学习，我们得到了我们想要的，而不是我们想要的！</p><p id="93cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是让我们看看我们能从中得到什么。产生彩色图像的一种方法是将特定的频道翻转90度或270度。通过这样做，我们可以得到下面的图像。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kb"><img src="../Images/cf674d0a3b44dcd778122fcade074bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*MZJsHz4U8OKxHncVAl2XZA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">将频道随机翻转90度或270度的示例图像</figcaption></figure><p id="cdfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这个，我们现在可以使用像EMNIST这样的数据集生成彩色图像。EMNIST是英文字母灰度图像的数据集。</p><p id="65c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在EMNIST数据集上训练了一个条件生成对抗网络，并将在这里使用它。这个项目可以在我的GitHub资源库中找到:<a class="ae ju" href="https://github.com/lokesh-kumar-t-n/conditional-generative-adversarial-network/" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/lokesh-Kumar-t-n/conditional-generative-adversarial-network</a>。</p><p id="13ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过将字母作为通道之一来使图像着色。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kb"><img src="../Images/b8e22e30fd9b06c7fb726c6313307ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*iQry2v_IF4GHEHsikGfQiA.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">将字母作为通道之一生成的图像</figcaption></figure><p id="552e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用边缘检测器，并将其添加到任何通道中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kb"><img src="../Images/d6138bf6716d801db82fa045d865199e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*JIMYuN_6g5mY3gVtJM5f0Q.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">通过在字母上添加边缘检测器的输出而生成的图像</figcaption></figure><p id="6150" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以使背景为彩色，保持字母为灰色。这是我最喜欢的！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kb"><img src="../Images/6c3a39e3c5e5eefe5ea69af5b8ce41b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*m6eP9Y8lXs6LrDzA7bqnWw.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">通过将背景颜色和字母设为灰色生成的图像</figcaption></figure><p id="03d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个项目需要的所有文件都可以在我的Github资源库中找到:【https://github.com/lokesh-kumar-t-n/Background_generator】T2。做这个项目很有趣，在课程中学到了很多东西。我希望你也玩得开心并有所收获。</p><p id="bb6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢大家！</p></div></div>    
</body>
</html>