<html>
<head>
<title>RECURSION FOR BEGINNERS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者递归</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/recursion-for-beginners-abc14052cc57?source=collection_archive---------27-----------------------#2020-07-30">https://medium.com/analytics-vidhya/recursion-for-beginners-abc14052cc57?source=collection_archive---------27-----------------------#2020-07-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="367c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于初学者来说，递归一开始可能有点难以理解，但它是一个非常重要的编程概念。递归可能不会用很多次，但在某些需要的情况下，它确实很有用。</p><p id="40ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是递归？<br/> </strong> <em class="jd">递归</em>是函数调用自身的过程。<em class="jd">递归</em>用于返回一个问题的解，这个问题依赖于同一个问题子集的解。<br/>递归函数有两个主要部分:</p><p id="ebee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a.<strong class="ih hj"> <em class="jd">一个终止条件</em> </strong> <strong class="ih hj"> <em class="jd">(基本情况)- </em> </strong>这是导致函数停止调用自己直到无限的退出条件。一旦满足基本情况条件，它就跳出循环并停止函数调用迭代。</p><p id="a556" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b.<strong class="ih hj"> <em class="jd">递归 case - </em> </strong>这是函数调用自身的部分。</p><p id="1850" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用 for 循环找出一个数的阶乘。<br/>记住 5 的阶乘，5！= 5*4*3*2*1</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="7ea4" class="jn jo hi jj b fi jp jq l jr js">function factorial (n) {<br/>  let total = 1;<br/>  for ( let i=n; i&gt;0 ; i--){<br/>     total= total * i<br/>  }<br/>  return total <br/>};</span><span id="e440" class="jn jo hi jj b fi jt jq l jr js">factorial(5);  //this will print 120</span></pre><p id="3ddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们用递归来写同一个函数:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="d9d5" class="jn jo hi jj b fi jp jq l jr js">function factorialRecursion (n) {<br/> if (n === 1) return 1;                //this is the base case<br/> return n * factorialRecursion (n-1)   //this is the recursive case<br/>};</span><span id="cfd5" class="jn jo hi jj b fi jt jq l jr js">factorial(5)  //this will print 120</span></pre><p id="1e70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面代码片段中的“if”条件是停止迭代的条件。函数“factorialRecursion”在内部尽可能多地调用自己，直到满足基本情况下的条件(当 n 等于 1 时，返回 1，而不是再次调用该函数)</p><p id="e828" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<em class="jd">递归</em>意味着更短的代码行，如上例所示，但是它真正的亮点是当你有大量的嵌套循环时。用普通循环结构难以迭代执行的操作可以用递归来解决，尤其是在嵌套循环的深度未知的情况下。让我用另一个例子来说明。在有孩子、孙子和曾孙的家谱中，我们希望打印出每个孩子的名字。用 for 循环来做这件事即使不是不可能，也是非常困难的，但是递归可以解决这个问题。</p><p id="5037" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">家谱对象如下图所示；</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="b91a" class="jn jo hi jj b fi jp jq l jr js">const tree = {<br/>  father: 'David',<br/>  children : [<br/>   {<br/>   name : 'Charles',<br/>   children : [{name: 'John', children :[]}]<br/>   },<br/>   {<br/>   name : 'Esther',<br/>   children : [ {name: 'Joy', children :[]},<br/>                {name: 'Ben', children :[]}<br/>              ]          <br/>   }<br/>  ]<br/> };</span></pre><p id="f8ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的家谱对象中，大卫有两个孩子查尔斯和埃丝特，他们分别有一个和两个孩子。要打印 David 的所有子子孙孙的名字，使用“for loops”几乎是不可能的。<br/>使用递归-</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="2c45" class="jn jo hi jj b fi jp jq l jr js">function printName (t) { <br/> if ( t.children.length === 0 ) {      //the base case<br/>   return <br/> } t.children.forEach (child =&gt; {<br/>   console.log(child.name)<br/>   printName (child)                   //the recursive case<br/> })<br/>};</span><span id="ae38" class="jn jo hi jj b fi jt jq l jr js">printName(tree);</span><span id="0261" class="jn jo hi jj b fi jt jq l jr js">//will print out the names - Charles, John, Esther, Joy and Ben.</span></pre><p id="c438" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来解释一下上面的代码片段:<br/> <strong class="ih hj"> <em class="jd">基础案例</em></strong>——如果子数组的长度为空，返回即不再调用该函数。<br/> else <br/> <strong class="ih hj"> <em class="jd">递归 case- </em> </strong>循环遍历并 console.log 孩子的名字，再次运行该函数，直到所有名字都打印在控制台上。</p><p id="0ab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下，如果 family 对象有更多的子对象和孙对象创建嵌套循环，事情会变得稍微复杂一些，但是递归将有助于解决这个问题。</p><p id="5e3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">n:B——在你的控制台上复制代码片段并运行它，看看它是如何实现的。</p><p id="46f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这篇文章是有帮助的。<br/>编码快乐！</p></div></div>    
</body>
</html>