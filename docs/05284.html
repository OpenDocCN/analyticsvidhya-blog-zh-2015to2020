<html>
<head>
<title>Web Browser internals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络浏览器内部</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/web-browser-internals-b1f9658f2302?source=collection_archive---------8-----------------------#2020-04-16">https://medium.com/analytics-vidhya/web-browser-internals-b1f9658f2302?source=collection_archive---------8-----------------------#2020-04-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="de70" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">为什么这应该是你走向web开发的第一步？</h2></div><p id="fb4f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你希望在<strong class="iz hj"> web开发</strong>领域开始职业生涯，了解web浏览器的内部原理可能会成为一个很好的救命稻草。</p><blockquote class="jt"><p id="792b" class="ju jv hi bd jw jx jy jz ka kb kc js dx translated">浏览器是主人——等待反应，vue，节点一点</p></blockquote><p id="7b97" class="pw-post-body-paragraph ix iy hi iz b ja kd ij jc jd ke im jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">Learn React，learn Vue，experiment Ember——如果你掌握了浏览器的内部原理，你会感受到与这些酷框架的联系，以及在未来适应任何框架的能力。</p><p id="500d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，用浏览器应该掌握什么呢？除了数百万行的<strong class="iz hj"> C++ </strong>为它提供动力之外，肯定还有很多。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/ae4ea63771d90e73ebe0a789574d41e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rh8NEpOcigg1J4N1Jp_eSQ.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">常用浏览器</figcaption></figure><p id="5ea1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">什么是浏览器？它是如何工作的？最常用的浏览器有哪些？</p><p id="a984" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有数以百万计的文章，参考资料，维基百科对这些的见解。很有可能你也已经知道这些了。因此，让我们试着找出一些非常重要但我们很难抓住的细节。</p><p id="0de3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你遇到过这种类型的CSS代码吗？</p><pre class="kj kk kl km fd ky kz la lb aw lc bi"><span id="9556" class="ld le hi kz b fi lf lg l lh li">-webkit-border-before: 1px;<br/>-webkit-border-before: 2px dotted;<br/>-webkit-border-before: medium dashed blue;</span></pre><p id="4df5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是的，你有没有想过它们与网络浏览器有什么关系，它们对兼容性有什么帮助。</p><blockquote class="lj lk ll"><p id="c9cf" class="ix iy lm iz b ja jb ij jc jd je im jf ln jh ji jj lo jl jm jn lp jp jq jr js hb bi translated">几乎所有流行的浏览器都基于<a class="ae lq" href="https://webkit.org/" rel="noopener ugc nofollow" target="_blank"> webkit </a>引擎</p></blockquote><p id="7415" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">WebKit基本上是一个<a class="ae lq" href="https://webkit.org/project" rel="noopener ugc nofollow" target="_blank">网络浏览器引擎</a>，供<a class="ae lq" href="https://www.apple.com/in/safari/" rel="noopener ugc nofollow" target="_blank"> Safari </a>、Mail、App Store以及macOS、iOS和Linux上的许多其他应用程序使用。</p><p id="4b09" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看什么样的引擎实际上驱动着我们喜欢使用的主浏览器，</p><ul class=""><li id="f0ed" class="lr ls hi iz b ja jb jd je jg lt jk lu jo lv js lw lx ly lz bi translated">Chrome和Opera(从15版开始)——<a class="ae lq" href="https://www.chromium.org/blink" rel="noopener ugc nofollow" target="_blank">眨眼</a></li><li id="1e08" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">火狐— <a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Mozilla/Gecko" rel="noopener ugc nofollow" target="_blank">壁虎</a></li><li id="14b9" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">Safari — <a class="ae lq" href="https://developer.apple.com/documentation/webkit" rel="noopener ugc nofollow" target="_blank"> Webkit </a></li><li id="7917" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">边缘— <a class="ae lq" href="https://www.chromium.org/blink" rel="noopener ugc nofollow" target="_blank">闪烁</a>【网络浏览器— <a class="ae lq" href="https://en.wikipedia.org/wiki/Trident_(software)" rel="noopener ugc nofollow" target="_blank">三叉戟</a></li></ul><p id="6f2a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，现在让我们来看看浏览器的高层结构是怎样的。</p><p id="9625" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">普通的web浏览器应该具有以下组件，</p><ul class=""><li id="9dd9" class="lr ls hi iz b ja jb jd je jg lt jk lu jo lv js lw lx ly lz bi translated">UI(用户界面)——这包括我们与之交互的一切，如地址栏、按钮(前、后、搜索等)</li><li id="d531" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">浏览器引擎——它作为浏览器和渲染引擎之间的接口工作(我们将在接下来介绍)</li><li id="e665" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">渲染引擎——它是解析HTML、CSS等的引擎。这就是负责显示请求内容的部分。</li><li id="b879" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">网络—用于HTTP请求</li><li id="9313" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">UI后端——用于绘制基本的小部件，如组合框和窗口。</li><li id="b514" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">Javascript解释器—解析并执行javascript代码</li><li id="26ac" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">数据存储——浏览器中的所有数据功能，即cookies、IndexedBD、localStorage等。</li></ul><p id="e51a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了这个背景，我再跟大家分享一件有趣的事。</p><blockquote class="lj lk ll"><p id="22d3" class="ix iy lm iz b ja jb ij jc jd je im jf ln jh ji jj lo jl jm jn lp jp jq jr js hb bi translated">Chrome 为不同的进程(比如标签)使用不同的渲染引擎实例</p></blockquote><p id="ad5f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是正常情况下的流动方式，</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mf"><img src="../Images/964e61667a1b5f5ffe7f3d1f6d481076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*cfQpu6Xvb7e9IiH4CCuiCg.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">信用——html5rocks.com</figcaption></figure><p id="dbe6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们可能对DOM很熟悉，但是流程中的其他部分呢，</p><ul class=""><li id="c7b2" class="lr ls hi iz b ja jb jd je jg lt jk lu jo lv js lw lx ly lz bi translated">在构建DOM树时，浏览器会构建另一棵树，称为渲染树。</li><li id="b5e6" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">它只不过是按照显示顺序排列的视觉元素。</li><li id="4a26" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">它的主要目的是使内容能够按照正确的顺序绘制。</li><li id="593e" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated"><a class="ae lq" href="https://www.mozilla.org/en-US/" rel="noopener ugc nofollow" target="_blank"> Firefox </a>称它们为框架，而基于WebKit的称它们为渲染器或渲染器对象。</li></ul><p id="86b4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哦，是的，让我分享一个与上述背景一致的重要注意事项，</p><p id="d6d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">非可视DOM元素将不会插入到呈现树中。听起来很有说服力，对吧？</p><p id="c5b2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">非视觉的意思就是说<strong class="iz hj">头</strong>元素。</p><ul class=""><li id="ab02" class="lr ls hi iz b ja jb jd je jg lt jk lu jo lv js lw lx ly lz bi translated">渲染器对应于DOM元素，但这种关系不是一对一的。有对应于几个可视对象的DOM元素。</li></ul><p id="a84c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如:“select”元素有三个呈现器:一个用于显示区域，一个用于下拉列表框，一个用于按钮。</p><ul class=""><li id="dbeb" class="lr ls hi iz b ja jb jd je jg lt jk lu jo lv js lw lx ly lz bi translated">当渲染器被创建并添加到树中时，它没有位置和大小。这就是<strong class="iz hj">布局</strong>出现的地方。</li></ul><h2 id="daac" class="ld le hi bd mg mh mi mj mk ml mm mn mo jg mp mq mr jk ms mt mu jo mv mw mx my bi translated">风格计算</h2><p id="5f97" class="pw-post-body-paragraph ix iy hi iz b ja mz ij jc jd na im jf jg nb ji jj jk nc jm jn jo nd jq jr js hb bi translated">这是最有趣的部分之一，</p><ul class=""><li id="a03c" class="lr ls hi iz b ja jb jd je jg lt jk lu jo lv js lw lx ly lz bi translated">构建渲染树需要计算每个渲染对象的视觉属性。这可能比我们实际想象的更复杂。</li><li id="8db9" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">样式表的来源是浏览器的默认样式表。</li></ul><p id="f1aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想了解更多，请点击此<a class="ae lq" href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Style_Computation" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><h2 id="6d0e" class="ld le hi bd mg mh mi mj mk ml mm mn mo jg mp mq mr jk ms mt mu jo mv mw mx my bi translated">样式表级联顺序</h2><p id="4314" class="pw-post-body-paragraph ix iy hi iz b ja mz ij jc jd na im jf jg nb ji jj jk nc jm jn jo nd jq jr js hb bi translated">你们中有多少人在调试CSS行为时遇到过困难？我想这可能会让人望而生畏。如果我们理解样式表级联顺序以及如何在我们的项目中正确使用它们，这绝不容易。</p><blockquote class="jt"><p id="fc61" class="ju jv hi bd jw jx jy jz ka kb kc js dx translated">浏览器吸入不同的风格——相信我</p></blockquote><p id="bac9" class="pw-post-body-paragraph ix iy hi iz b ja kd ij jc jd ke im jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">顺序是这样的，</p><ul class=""><li id="43d5" class="lr ls hi iz b ja jb jd je jg lt jk lu jo lv js lw lx ly lz bi translated">浏览器声明</li><li id="fb39" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">用户普通声明</li><li id="a11b" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">创作普通声明</li><li id="f436" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">创作重要声明</li><li id="9e00" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">用户重要声明</li></ul><p id="ae8c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">等等，我们说的是哪个用户或者作者？</p><p id="ba59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">作者</strong>根据文档语言的约定为源文档指定样式表。它基本上是网站创建者(或)的代码。</p><p id="6a4b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">用户</strong>可能能够指定特定文档的样式信息。在浏览器中与它互动的是我们！</p><p id="a532" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是关于CSS层叠的详细文档，可以帮助你更深入地了解这个问题。</p><p id="915e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">去吧，接触一些不同层次的CSS声明，以便对此有一个清晰的认识。</p><p id="84e7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么如何处理脚本呢？那也很重要。</p><p id="d633" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们打破这个循环，</p><h2 id="aca7" class="ld le hi bd mg mh mi mj mk ml mm mn mo jg mp mq mr jk ms mt mu jo mv mw mx my bi translated"><strong class="ak">脚本执行顺序</strong></h2><p id="b479" class="pw-post-body-paragraph ix iy hi iz b ja mz ij jc jd na im jf jg nb ji jj jk nc jm jn jo nd jq jr js hb bi translated">网络的本质通常是同步的。比方说，你有一个HTML文档，</p><pre class="kj kk kl km fd ky kz la lb aw lc bi"><span id="45fe" class="ld le hi kz b fi lf lg l lh li">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;</span><span id="93d8" class="ld le hi kz b fi ne lg l lh li">&lt;head&gt;<br/>&lt;script&gt;<br/>function myFunction() {<br/> document.getElementById(“demo”).innerHTML = “Paragraph changed.”;<br/>}<br/>&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;</span><span id="2866" class="ld le hi kz b fi ne lg l lh li">&lt;h1&gt;A Web Page&lt;/h1&gt;<br/>&lt;p id=”demo”&gt;A Paragraph&lt;/p&gt;<br/>&lt;button type=”button” onclick=”myFunction()”&gt;Try it&lt;/button&gt;</span><span id="ce2a" class="ld le hi kz b fi ne lg l lh li">&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="750d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当浏览器读取它时会发生什么？</p><p id="bc91" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它首先开始解析html，就像HTML标签，head标签…uff，</p><p id="9b83" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，它注意到脚本标记，并开始处理脚本。只有在完成之后，它才返回到HTML解析。在这种情况下，它是可以接受的，只是一个innerHTML语句。但是，如果它必须处理数百行代码，进行少量API调用，等等，那该怎么办呢？这可能真的令人生畏，对不对？因此，在HTML文档中应该把脚本放在哪里一直存在争议。这是一个非常不同的话题。让我把它留给你。</p><p id="5696" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于现代HTML规范，现在您可以明确指定浏览器是应该等待还是异步处理。</p><p id="84f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看看<a class="ae lq" href="https://javascript.info/script-async-defer" rel="noopener ugc nofollow" target="_blank">异步</a>和<a class="ae lq" href="https://javascript.info/script-async-defer" rel="noopener ugc nofollow" target="_blank">延迟</a>属性。这让工作变得更容易。</p><p id="ba83" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们讨论浏览器如何优化布局创建过程中发生的变化。如果你深入研究这个问题，听起来会非常有趣。不要担心，我会在最后分享一个美丽的资源给你做实验:)</p><h2 id="cd6c" class="ld le hi bd mg mh mi mj mk ml mm mn mo jg mp mq mr jk ms mt mu jo mv mw mx my bi translated">最佳化</h2><p id="a96e" class="pw-post-body-paragraph ix iy hi iz b ja mz ij jc jd na im jf jg nb ji jj jk nc jm jn jo nd jq jr js hb bi translated">当布局由“调整大小”或渲染器位置(而不是大小)的变化触发时，渲染大小从缓存中获取，而不会重新计算。酷吧？</p><p id="fc53" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想象一下，如果浏览器重新计算每一个变化，体验将会变得多么耗时和缺乏交互性。</p><p id="3d4c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在某些情况下，只修改一个子树，布局不是从根开始的。如果更改是局部的，并且不影响其周围环境，例如文本插入到文本字段中，就会发生这种情况。</p><blockquote class="lj lk ll"><p id="6ba7" class="ix iy lm iz b ja jb ij jc jd je im jf ln jh ji jj lo jl jm jn lp jp jq jr js hb bi translated">浏览器试图做尽可能少的动作来响应变化。</p></blockquote><p id="757c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于浏览器，你还可以探索和学习更多的东西。我只是计划以非常简短的方式分享一些概念，这样就不会太复杂，并鼓励你深入研究。</p><p id="7c71" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果这些让你着迷，是时候做更多的实验了。请务必看看这篇由我的一位导师分享给我的深入的<a class="ae lq" href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" rel="noopener ugc nofollow" target="_blank">文章</a>。我敢打赌你看完绝对不会后悔。</p><p id="4fd7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">信用</strong>:<a class="ae lq" href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" rel="noopener ugc nofollow" target="_blank">https://www . html 5 rocks . com/en/tutorials/internals/howsbrowserswork/</a></p><p id="156c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">由</strong> <a class="ae lq" href="https://www.html5rocks.com/profiles/#taligarsiel" rel="noopener ugc nofollow" target="_blank">程昕婷</a>和<a class="ae lq" href="https://www.html5rocks.com/profiles/#paulirish" rel="noopener ugc nofollow" target="_blank">保罗爱尔兰</a></p></div></div>    
</body>
</html>