<html>
<head>
<title>Practical ML Part 3: Predicting Breast Cancer with Pytorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用 ML 第 3 部分:用 Pytorch 预测乳腺癌</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/practical-ml-part-3-predicting-breast-cancer-with-pytorch-efc469242bfe?source=collection_archive---------4-----------------------#2020-12-15">https://medium.com/analytics-vidhya/practical-ml-part-3-predicting-breast-cancer-with-pytorch-efc469242bfe?source=collection_archive---------4-----------------------#2020-12-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1ad9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用神经网络构建分类器预测乳腺癌</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/ee99f6f7a70bacfb62bb153438383569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HKKOgb3iz6lzY-rPQVk36Q.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">在<a class="ae jt" href="https://unsplash.com/s/photos/breast-cancer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jt" href="https://unsplash.com/@ang10ze?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">angula Harry</a>拍摄的照片</figcaption></figure><h1 id="dd0f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">1-数据集</h1><p id="3012" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">有 30 个特征被监测以检测乳腺癌。加载数据集以了解一些关于这些变量的信息:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/863495d559fdd815849f9ba402cb98b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*EGhWpJQ0gujD-r-UqitjLg.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">数据帧的尺寸</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/c7549d2dbbcd75c1b6c2a0ba24b72f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*_a7xOVluLhrvYy6rMvQB-g.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">变量及其类型列表</figcaption></figure><p id="30e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在检查重复数据和空数据并确认数据集没有这些数据后，就该检查不必要的数据了。从数据集的 33 列中，删除了“id”和“未命名:32”:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="504a" class="le jv hi la b fi lf lg l lh li">df.drop(['id','Unnamed: 32'],axis=1,inplace=True)</span></pre><p id="c421" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了完成第一部分，我们来了解一下统计数据。描述():</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lj"><img src="../Images/7d44051f7d43a382cd001fcdd8acb685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*laBHPI-dBwGwKTBoFXHuXg.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">变量的统计数据</figcaption></figure><h1 id="7c79" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">2 —可视化</h1><p id="f316" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">检查恶性和良性肿瘤的计数:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/ac940d042c50597152264734d9eb20fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*LcYl7keoCZrDsRe-WrMMQw.png"/></div></figure><p id="b42a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">诊断良性肿瘤 357 例，恶性肿瘤 212 例。这似乎是一个相当平衡的数据集。</p><p id="222a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在可视化其他变量的分布:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/fc1f323a529949c4a73966259506fd6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hv9RfnMZ-UDMCq3W7JPvQQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">每个变量的分布</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/3dba043ffaf0ad0094dff415e5419ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHaAagpQhp5_rfOQdAxOPw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">变量之间的相关性</figcaption></figure></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="1ad3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这个初步我们可以得到以下的见解:</p><ul class=""><li id="ed3c" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated">这是一个非常复杂的模型，能够可视化的相关性。</li><li id="cebf" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">肿瘤的平均半径为 14.12，最小的为 6.98，最大的为 28.11。</li><li id="0c4e" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">与尺寸相关的变量是正相关的(例如 area_se 和 perimeter_se)，因为一个变量依赖于另一个变量。</li><li id="f73b" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">数据集中 62.7%的肿瘤是良性的，37.3%是恶性的。</li></ul><h1 id="7552" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">3-为机器学习准备数据</h1><p id="da47" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj">换标签</strong></p><p id="6025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们要预测的值在“诊断”列中—这些是标签。我们想要预测肿瘤是恶性的(“M”)还是良性的(“B”)。数据框中的所有其他列都是模型的预测值:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mi"><img src="../Images/f9484acefbcf04c77e7bc82e68f42a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*uhbI8oX6C8rhMvtgISMSiQ.jpeg"/></div></figure><p id="472f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">标签用字母 M(恶性)和 B(良性)表示。第一步是将该信息转换成数字类型的数据，0 表示良性，1 表示恶性:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="c761" class="le jv hi la b fi lf lg l lh li">lab ={'B':0,'M':1}<br/>df = df.replace({'diagnosis':lab})<br/>df.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mj"><img src="../Images/2dcffecc7993ad0ee94bb81b68d14825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*yJp6PTD4hRdkecB8nE2izA.jpeg"/></div></figure><p id="4a7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，数据可以分成两个子集:</p><ul class=""><li id="93d2" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated"><strong class="ih hj">预测值</strong> —我们将提供的信息作为模型的输入，以进行预测</li></ul><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="6632" class="le jv hi la b fi lf lg l lh li">predictors = df.iloc[:, 2:31]<br/>predictors</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mk"><img src="../Images/7ca6b780c66aba4dc22b3b96106d1e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*5xAtIefzbZmGG9xJbzWW5A.jpeg"/></div></figure><ul class=""><li id="4885" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated"><strong class="ih hj">标签</strong> —我们想要预测的信息，即给定预测数据集中的信息，肿瘤是恶性的还是良性的。</li></ul><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="10b6" class="le jv hi la b fi lf lg l lh li">labels = df.iloc[:, 0:1]<br/>labels</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ml"><img src="../Images/5ab915f64847032c717f30c2d807f631.png" data-original-src="https://miro.medium.com/v2/resize:fit:266/format:webp/1*5V8pHzPCrwthDWIhNSgLew.jpeg"/></div></figure><p id="0445" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">转换为张量并将数据分成训练和测试子集</strong></p><p id="6cbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用 scikit learn，数据集被分成训练和测试数据，比例为 20%:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="9004" class="le jv hi la b fi lf lg l lh li">predictors_train, predictors_test, labels_train, labels_test = train_test_split(predictors,labels,test_size = 0.20)</span></pre><p id="255d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，数据存储在熊猫的数据框中。由于我们将使用张量流实现深度学习模型，因此必须将数据转换为张量。首先，将 pandas 数据帧转换成数组:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="1dae" class="le jv hi la b fi lf lg l lh li">type(np.array(predictors_train))</span></pre><p id="8e39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Out[20]:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="416b" class="le jv hi la b fi lf lg l lh li">type(np.array(labels_train))</span></pre><p id="c839" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Out[21]:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="ad8e" class="le jv hi la b fi lf lg l lh li">numpy.ndarray</span></pre><p id="6d42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该模型将使用 PyTorch 实现，因此下一步是将数组转换为 Torch 元素:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="83d8" class="le jv hi la b fi lf lg l lh li">predictors_train = torch.tensor(np.array(predictors_train), dtype=torch.float)</span><span id="a83d" class="le jv hi la b fi mm lg l lh li">labels_train = torch.tensor(np.array(labels_train), dtype = torch.float)</span><span id="ff88" class="le jv hi la b fi mm lg l lh li">df_tf = torch.utils.data.TensorDataset(predictors_train, labels_train)<br/>type(df_tf)</span></pre><p id="c959" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Pytorch 小批量训练模型。有一个名为 DataLoader 的类来对数据集执行迭代。batch_size 参数给出了调整模型权重时考虑的样本数量:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="e183" class="le jv hi la b fi lf lg l lh li">train_loader = torch.utils.data.DataLoader(df_tf, batch_size=15, shuffle=True)</span></pre><h1 id="fbdd" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">4 —实施和评估模型</h1><p id="167c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在这个项目中，将实现一个具有两个隐藏层的神经网络。要实现这样的模型，我们需要以下内容:</p><ul class=""><li id="606f" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated">模型的结构(定义层数、神经元、激活函数)；</li><li id="98a3" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">选择一个训练标准；</li><li id="0e88" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">选择一个优化器。</li></ul><p id="2920" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于问题的复杂性和未知性，这种类型的实现被建模为优化问题。因此，选择优化器是这个过程的一部分。</p><p id="4bdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在优化问题中，我们有目标函数(称为成本函数或损失函数)。这就是我们要优化的功能。在神经网络中，目标是最小化误差，因此最小化损失(或成本)函数。</p><p id="adf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">构建模型</strong></p><p id="f1fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">神经网络模型定义如下:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="bba8" class="le jv hi la b fi lf lg l lh li">classifier = nn.Sequential(<br/>  <br/>    nn.Linear(in_features=29, out_features=15),<br/>    nn.ReLU(),<br/>    nn.Linear(15, 15),<br/>    nn.ReLU(),<br/>    nn.Linear(15, 1),<br/>    nn.Sigmoid()<br/>)</span></pre><ul class=""><li id="681e" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated">输入要素= 29(预测数据集中有 29 个要素)。</li><li id="7dbb" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">2 个隐藏层，每层 15 个神经元</li><li id="b700" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">具有一个神经元的输出层，具有输出标签 0(良性肿瘤)和 1(恶性肿瘤)</li><li id="b555" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated"><strong class="ih hj"> ReLu </strong>，内层的非线性激活函数</li><li id="91bc" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated"><strong class="ih hj"> Sigmoid </strong>，输出层的非线性激活函数，返回 0 到 1 之间的概率</li></ul><p id="57bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ReLu(整流线性单元)是一种非线性激活函数，具有不同时激活所有神经元的优点。在第一次尝试中，选择 ReLu 来建立在计算成本方面更有效的模型。</p><p id="37ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">据报道，Sigmoid 在分类问题上表现良好。因为我们有一个将肿瘤分类为良性或恶性的输出层，所以选择 sigmoid 作为激活函数。</p><p id="190e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">训练标准</strong></p><p id="6cb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们必须选择神经网络的训练标准。由于这是一个二元分类任务，因此选择了二元交叉熵标准:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="ebfa" class="le jv hi la b fi lf lg l lh li">criterion = nn.BCELoss()</span></pre><p id="f1cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优化器</strong></p><p id="9fc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三，也是最后一步是选择优化器。Adam 优化算法是深度学习问题中非常流行的选择。这是随机梯度下降算法的扩展，但不同于 SGD 算法，Adam optimizer 在训练期间不保持相同的学习速率。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="cd8d" class="le jv hi la b fi lf lg l lh li">optimizer = torch.optim.Adam(classifier.parameters(), lr=0.001, weight_decay=0.0001)</span></pre><p id="0452" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要阅读关于 Adam 优化器的更多信息，请查看《走向数据科学》中的这篇文章。</p><p id="965c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">训练模型</strong></p><p id="ce5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新的权重运行 100 次，如下面的 for 循环所示:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="c674" class="le jv hi la b fi lf lg l lh li">for epoch <strong class="la hj">in</strong> range(100):<br/>  #To store the error:<br/>  run_loss = 0.<br/><br/>  for data <strong class="la hj">in</strong> train_loader:<br/>    inputs, labels = data<br/>    optimizer.zero_grad()<br/><br/>    outputs = classifier(inputs) </span><span id="8657" class="le jv hi la b fi mm lg l lh li">    error = criterion(outputs, labels)<br/>    error.backward()<br/>    optimizer.step() <br/><br/>    run_loss += error.item()<br/>  print('Epoch <strong class="la hj">%3d</strong>: loss <strong class="la hj">%.5f</strong>' % (epoch+1, run_loss/len(train_loader)))</span></pre><ul class=""><li id="0a01" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated">训练加载器分批加载训练数据(记住为该模型选择的批量大小是 15 个样本)。</li><li id="01ac" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated"><strong class="ih hj"> zero_grad() </strong>在反向传播过程之前将梯度设置为零。</li><li id="da79" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated"><strong class="ih hj">输出</strong>计算模型的预测值。</li><li id="a1f1" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated"><strong class="ih hj">误差</strong>计算误差，将预测值与实际数据进行比较。</li><li id="2199" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated"><strong class="ih hj"> error.backward() </strong>是神经网络中更新权重的反向传播过程。</li><li id="c899" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated"><strong class="ih hj"> optimizer.step() </strong>更新权重。</li></ul><p id="e71b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">评估模型</strong></p><p id="9cc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该模型的准确率为 94.73%。在混乱矩阵中形象化这一点:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mn"><img src="../Images/e33b5687dfcaf16dc5df3850dc42565d.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*y8AEAxVa9XO7fR6-f2ZTnw.jpeg"/></div></figure><p id="a9b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分类器总共进行了 114 次预测，其中:</p><ul class=""><li id="1795" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated">70 个样本被正确地估计为良性肿瘤。</li><li id="56c2" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">38 个样本被正确地估计为恶性肿瘤。</li><li id="ec8f" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">有 3 个样本被估计为假阴性，这些样本本应被分类为恶性肿瘤，但被分类为良性。</li><li id="9019" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">3 个样本被估计为假阳性。</li></ul></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="a798" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是深度学习的第一步。下一步是研究这个模型并使用交叉验证。</p></div></div>    
</body>
</html>