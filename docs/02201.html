<html>
<head>
<title>Understanding OpenAI baseline source code and making it do self-play! Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解OpenAI基线源代码，让它做自玩！第三部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-openai-baseline-source-code-and-making-it-do-self-play-part-3-23eeeb6ab817?source=collection_archive---------14-----------------------#2019-12-05">https://medium.com/analytics-vidhya/understanding-openai-baseline-source-code-and-making-it-do-self-play-part-3-23eeeb6ab817?source=collection_archive---------14-----------------------#2019-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/0c4e24ae4dd215d07c5cf52498b2ba0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*BY5NA77e54PDoBWiaKHufw.png"/></div></figure><p id="8fea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在之前的文章中，我们介绍了OpenAI是如何构建的，以及我觉得有趣的一些部分。你可以查看第一部分和第二部分<a class="ae jk" rel="noopener" href="/analytics-vidhya/understanding-openai-baseline-source-code-and-making-it-do-self-play-part-1-9f30085a8c16">这里</a>和<a class="ae jk" rel="noopener" href="/@isamu.website/understanding-openai-baseline-source-code-and-making-it-do-self-play-part-2-9f8c4fd3e3b5">这里</a>！</p><h1 id="a0a6" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">SubprocVecEnv _ _ init _ _:深入了解多处理</h1><p id="efbc" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">__init__函数如下所示</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2217" class="kx jm hi kt b fi ky kz l la lb">class SubprocVecEnv(VecEnv):<br/>    """<br/>    VecEnv that runs multiple environments in parallel in subproceses and communicates with them via pipes.<br/>    Recommended to use when num_envs &gt; 1 and step() can be a bottleneck.<br/>    """<br/>    def __init__(self, env_fns, spaces=None, context='spawn', in_series=1):<br/>        """<br/>        Arguments:</span><span id="7eaa" class="kx jm hi kt b fi lc kz l la lb">        env_fns: iterable of callables -  functions that create   environments to run in subprocesses. Need to be cloud-pickleable<br/>        in_series: number of environments to run in series in a  single process<br/>        (e.g. when len(env_fns) == 12 and in_series == 3, it will run 4 processes, each running 3 envs in series)<br/>        """<br/>        self.waiting = False<br/>        self.closed = False<br/>        self.in_series = in_series<br/>        nenvs = len(env_fns)<br/>        assert nenvs % in_series == 0, "Number of envs must be divisible by number of envs to run in series"</span><span id="50f5" class="kx jm hi kt b fi lc kz l la lb">        self.nremotes = nenvs// in_series<br/>        env_fns = np.array_split(env_fns, self.nremotes)<br/>        ctx = mp.get_context(context)<br/>        self.remotes, self.work_remotes = zip(*[ctx.Pipe() for _ in range(self.nremotes)])<br/>        self.ps = [ctx.Process(target=worker, args=(work_remote, remote, CloudpickleWrapper(env_fn)))<br/>                   for (work_remote, remote, env_fn) in zip(self.work_remotes, self.remotes, env_fns)]<br/>        for p in self.ps:<br/>            p.daemon = True  # if the main process crashes, we should not cause things to hang<br/>            with clear_mpi_env_vars():<br/>                p.start()<br/>        for remote in self.work_remotes:<br/>            remote.close()</span><span id="4f32" class="kx jm hi kt b fi lc kz l la lb">        self.remotes[0].send(('get_spaces_spec', None))<br/>        observation_space, action_space, self.spec = self.remotes[0].recv().x<br/>        <br/>        self.viewer = None<br/>        VecEnv.__init__(self, nenvs, observation_space, action_space)</span></pre><p id="00f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第一行用于初始化</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9a39" class="kx jm hi kt b fi ky kz l la lb">self.waiting = False</span><span id="520b" class="kx jm hi kt b fi lc kz l la lb">self.closed = False</span><span id="1bdf" class="kx jm hi kt b fi lc kz l la lb">self.in_series = in_series</span><span id="3630" class="kx jm hi kt b fi lc kz l la lb">nenvs = len(env_fns)</span></pre><p id="228e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4aff" class="kx jm hi kt b fi ky kz l la lb">assert nenvs % in_series == 0, "Number of envs must be divisible by number of envs to run in series"</span><span id="cf2c" class="kx jm hi kt b fi lc kz l la lb">self.nremotes = nenvs// in_series</span></pre><p id="f97b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，in_series变量开始发挥作用。nenvs变量是环境的数量，但是in_series变量，正如文本所说，似乎将这些环境划分为in_series多个进程，并为每个进程分配nenvs // in_series多个环境，反之亦然！</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5252" class="kx jm hi kt b fi ky kz l la lb">env_fns = np.array_split(env_fns, self.nremotes)</span></pre><p id="7899" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这里，我们看到它是反过来的。像np.array_split函数一样，有nenv//in_series多个进程，每个进程在in _ series多个环境中运行。这个函数只是将它们分开，并让基本索引选择要查看的部分。举个例子，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c4aa" class="kx jm hi kt b fi ky kz l la lb">np.array_split(np.arange(6), 2)</span></pre><p id="ef44" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">will返回[array([0，1，2])，array([3，4，5])]。有趣的是，外部是一个列表，而不是一个np数组。然后，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="eb6d" class="kx jm hi kt b fi ky kz l la lb">ctx = mp.get_context(context)</span></pre><p id="4eea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就是跑。这位议员来自</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="572e" class="kx jm hi kt b fi ky kz l la lb">import multiprocessing as mp</span></pre><p id="b87c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">根据<a class="ae jk" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">文档</a>，很明显，当你使用一个上下文时，你可以把它们当作一个单独的对象。我不太清楚这是什么意思，但我们继续吧！</p><p id="96b4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3005" class="kx jm hi kt b fi ky kz l la lb">self.remotes, self.work_remotes = zip(*[ctx.Pipe() for _ in range(self.nremotes)])</span></pre><p id="8a35" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就是跑。一、什么是ctx。管道()？让我们检查一下！根据相同的<a class="ae jk" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">文档</a>，管道构成如下两个连接的对象</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e397" class="kx jm hi kt b fi ky kz l la lb">parent_conn, child_conn = Pipe()</span></pre><p id="7ab6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从这里你可以做的是，他们可以进一步互相交谈！你这样做的方法是</p><p id="5ace" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">parent_conn.send向child_conn发送消息，反之亦然！</p><p id="b36a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一方面，parent_conn.recv()从子节点获取消息，反之亦然。</p><p id="3a8b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，在这里，self.remotes对应于父节点的列表，而self.work_remotes对应于相应子节点的列表。</p><p id="778d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e23b" class="kx jm hi kt b fi ky kz l la lb">self.ps = [ctx.Process(target=worker, args=(work_remote, remote, CloudpickleWrapper(env_fn)))</span><span id="40ae" class="kx jm hi kt b fi lc kz l la lb">for (work_remote, remote, env_fn) in zip(self.work_remotes, self.remotes, env_fns)]</span></pre><p id="17b0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就是跑。</p><p id="f319" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将流程运行时运行的函数作为目标。这可以通过调用。运行()或by。start()调用在一个单独的进程中运行！</p><p id="cb3c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">参数只是目标函数的参数。在这种情况下，这就是工人。</p><p id="4ccd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">CloudpickleWrapper定义如下！</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e239" class="kx jm hi kt b fi ky kz l la lb">class CloudpickleWrapper(object):<br/>    """<br/>    Uses cloudpickle to serialize contents (otherwise multiprocessing tries to use pickle)<br/>    """</span><span id="1113" class="kx jm hi kt b fi lc kz l la lb">def __init__(self, x):<br/>        self.x = x</span><span id="df12" class="kx jm hi kt b fi lc kz l la lb">def __getstate__(self):<br/>        import cloudpickle<br/>        return cloudpickle.dumps(self.x)</span><span id="d713" class="kx jm hi kt b fi lc kz l la lb">def __setstate__(self, ob):<br/>        import pickle<br/>        self.x = pickle.loads(ob)</span></pre><p id="8da8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它主要做的是将env_fn函数保存在x中，然后，__getstate__ function返回self.x的序列化表示，这基本上意味着，如果将从cloudpickle.dumps(self.x)返回的东西保存到一个文件中，以后可以通过调用def __setstate__来加载它，以检索所有的属性等等！根据<a class="ae jk" href="https://pypi.org/project/cloudpickle/" rel="noopener ugc nofollow" target="_blank">这里的</a>，cloudpickle被用于__getstate__的原因是因为它支持更多的东西。</p><p id="78a3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2aca" class="kx jm hi kt b fi ky kz l la lb">for p in self.ps:<br/>            p.daemon = True  # if the main process crashes, we should not cause things to hang<br/>            with clear_mpi_env_vars():<br/>                p.start()</span></pre><p id="071c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就是跑。从计算机科学的角度来看，守护进程意味着后台进程。所以，即使它崩溃了，也不会有什么不好的事情发生，这是有道理的！</p><p id="2872" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于clear_mpi_env_vars，根据注释，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4b00" class="kx jm hi kt b fi ky kz l la lb">"""</span><span id="1147" class="kx jm hi kt b fi lc kz l la lb">from mpi4py import MPI will call MPI_Init by default.  If the child process has MPI environment variables, MPI will think that the child process is an MPI process just like the parent and do bad things such as hang.</span><span id="b285" class="kx jm hi kt b fi lc kz l la lb">This context manager is a hacky way to clear those environment variables temporarily such as when we are starting multiprocessing</span><span id="f0c9" class="kx jm hi kt b fi lc kz l la lb">Processes.</span><span id="d9a2" class="kx jm hi kt b fi lc kz l la lb">"""</span></pre><p id="fa61" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这很有趣。然后，最后，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d3e0" class="kx jm hi kt b fi ky kz l la lb">p.start()</span></pre><p id="8905" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">环境开始了！</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="aa5e" class="kx jm hi kt b fi ky kz l la lb">for remote in self.work_remotes:<br/>            remote.close()</span><span id="37c5" class="kx jm hi kt b fi lc kz l la lb">self.remotes[0].send(('get_spaces_spec', None))<br/>observation_space, action_space, self.spec = self.remotes[0].recv().x<br/>self.viewer = None<br/>VecEnv.__init__(self, len(env_fns), observation_space, action_space)</span></pre><p id="71b3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我不明白为什么close方法在这里，如果有人知道，请告诉我！我认为这与初始化有关，但我不完全确定。</p><p id="9f17" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，从环境中检索规范，并调用VecEnv的init函数。</p><p id="93d3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但这是一种新的叫法！我习惯于看到</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c3e6" class="kx jm hi kt b fi ky kz l la lb">class a:<br/>    def __init___(self):<br/>        self.a = "a"<br/>    def hello(self):<br/>        print(self.a)<br/>class b(a):<br/>    def __init__(self):<br/>        super(b, self).__init__()</span></pre><p id="382a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">而不是函数中的直接一个. __init__。我不完全确定，但我认为这允许a的属性值被复制到b，因为通常情况下，你不能这样做。</p><h1 id="fa7e" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">VecEnv</h1><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5a9f" class="kx jm hi kt b fi ky kz l la lb">class VecEnv(ABC):<br/>    """<br/>    An abstract asynchronous, vectorized environment.<br/>    Used to batch data from multiple copies of an environment, so that<br/>    each observation becomes an batch of observations, and expected action is a batch of actions to<br/>    be applied per-environment.<br/>    """<br/>    closed = False<br/>    viewer = None</span><span id="1769" class="kx jm hi kt b fi lc kz l la lb">metadata = {<br/>        'render.modes': ['human', 'rgb_array']<br/>    }</span><span id="c5ee" class="kx jm hi kt b fi lc kz l la lb">def __init__(self, num_envs, observation_space, action_space):<br/>        self.num_envs = num_envs<br/>        self.observation_space = observation_space<br/>        self.action_space = action_space</span></pre><p id="ee7a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">既然是设置属性，我怀疑我是对的！现在，让我们来看看重置，步进和渲染功能！</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a6f2" class="kx jm hi kt b fi ky kz l la lb">def step(self, actions):<br/>    """<br/>    Step the environments synchronously.</span><span id="6141" class="kx jm hi kt b fi lc kz l la lb">This is available for backwards compatibility.<br/>    """<br/>    self.step_async(actions)<br/>    return self.step_wait()</span><span id="2e6a" class="kx jm hi kt b fi lc kz l la lb">def render(self, mode='human'):<br/>    imgs = self.get_images()<br/>    bigimg = tile_images(imgs)<br/>    if mode == 'human':<br/>        self.get_viewer().imshow(bigimg)<br/>        return self.get_viewer().isopen<br/>    elif mode == 'rgb_array':<br/>        return bigimg<br/>    else:<br/>        raise NotImplementedError<br/>@abstractmethod<br/>def reset(self):<br/>    pass</span><span id="2f33" class="kx jm hi kt b fi lc kz l la lb">raise NotImplementedError</span><span id="e008" class="kx jm hi kt b fi lc kz l la lb"><a class="ae jk" href="http://twitter.com/abstractmethod" rel="noopener ugc nofollow" target="_blank">@abstractmethod</a><br/>def reset(self):<br/>    pass</span></pre><p id="c2b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">@abstractclass是由abc(抽象基类)模块提供的一个装饰器，它基本上是说这个方法需要被覆盖。</p><p id="19b5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，基本上，对于每个步骤，运行step_async函数并返回step_wait函数。而这些函数都是在SubprocVecEnv中给出的！</p><h1 id="a4b7" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤_异步</h1><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1dd2" class="kx jm hi kt b fi ky kz l la lb">def step_async(self, actions):<br/>        self._assert_not_closed()<br/>        actions = np.array_split(actions, self.nremotes)<br/>        for remote, action in zip(self.remotes, actions):<br/>            remote.send(('step', action))<br/>        self.waiting = True</span></pre><p id="3a9b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，远程将字符串“step”和动作发送给其子节点，并将变量self.waiting设置为True。</p><h1 id="e7c4" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤_等待</h1><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="78af" class="kx jm hi kt b fi ky kz l la lb">def step_wait(self):<br/>        self._assert_not_closed()<br/>        results = [remote.recv() for remote in self.remotes]<br/>        results = _flatten_list(results)<br/>        self.waiting = False<br/>        obs, rews, dones, infos = zip(*results)<br/>        return _flatten_obs(obs), np.stack(rews), np.stack(dones), infos</span></pre><p id="660d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们看到遥控器从它孩子那里收到一条信息，这是环境的状态！我们看到它通过运行_flatten_list展平列表后，返回obs，OBS，observations，rews，rewards，dones，是否结束，以及我推测是多余的infos。</p><p id="2cbd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，经过一些处理，它返回它们！现在，让我们看看工人，实际上运行一切的功能(进程的目标)</p><p id="1aea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，在继续之前，让我们看看flatten_list！</p><h1 id="a823" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">扁平化_列表</h1><p id="4409" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">我必须说，当我第一次看到这个的时候，我很困惑。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3fd2" class="kx jm hi kt b fi ky kz l la lb">def _flatten_list(l):<br/>    assert isinstance(l, (list, tuple))<br/>    assert len(l) &gt; 0<br/>    assert all([len(l_) &gt; 0 for l_ in l])<br/>    return [l__ for l_ in l for l__ in l_]</span></pre><p id="e374" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，我们先来看看l_。l_是l_的元素，因为它是为l_ in l而写的。因此，对于l_的每个元素，都返回一个名为l_的东西。这是l_的元素，正如它在l_中对l_的描述。因此，我们可以看到，这是一个2d循环的简写，通过将所有行彼此相邻放置，将索引放入1d数组中。</p><h1 id="63f5" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">工人</h1><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1ad4" class="kx jm hi kt b fi ky kz l la lb">def worker(remote, parent_remote, env_fn_wrappers):<br/>    def step_env(env, action):<br/>        ob, reward, done, info = env.step(action)<br/>        if done:<br/>            ob = env.reset()<br/>        return ob, reward, done, info</span><span id="0cd9" class="kx jm hi kt b fi lc kz l la lb">parent_remote.close()<br/>    envs = [env_fn_wrapper() for env_fn_wrapper in env_fn_wrappers.x]<br/>    try:<br/>        while True:<br/>            cmd, data = remote.recv()<br/>            if cmd == 'step':<br/>                remote.send([step_env(env, action) for env, action in zip(envs, data)])<br/>            elif cmd == 'reset':<br/>                remote.send([env.reset() for env in envs])<br/>            elif cmd == 'render':<br/>                remote.send([env.render(mode='rgb_array') for env in envs])<br/>            elif cmd == 'close':<br/>                remote.close()<br/>                break<br/>            elif cmd == 'get_spaces_spec':<br/>                remote.send(<br/>CloudpickleWrapper((envs[0].observation_space, envs[0].action_space, envs[0].spec)))<br/>            else:<br/>                raise NotImplementedError<br/>    except KeyboardInterrupt:<br/>        print('SubprocVecEnv worker: got KeyboardInterrupt')<br/>    finally:<br/>        for env in envs:<br/>            env.close()</span></pre><p id="8c7c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先是因为，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ec69" class="kx jm hi kt b fi ky kz l la lb">def step_env(env, action):<br/>        ob, reward, done, info = env.step(action)<br/>        if done:<br/>            ob = env.reset()<br/>        return ob, reward, done, info</span></pre><p id="2dc8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这似乎调用了我们环境的step函数，并返回观察结果、奖励、环境是否完成以及额外的信息并返回它们！</p><p id="4125" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此外，在这里，如果环境完成，环境被重置，第一个观察结果被返回，这取代了很酷的观察结果！</p><p id="084b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c731" class="kx jm hi kt b fi ky kz l la lb">parent_remote.close()<br/>envs = [env_fn_wrapper() for env_fn_wrapper in env_fn_wrappers.x]</span></pre><p id="d7c9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我最初认为这会一直创造一个新的环境，但如果是这样的话，我认为任何形式的游戏都是不可能的。因此，我怀疑__get_state__和__set_state__方法在维护环境状态方面发挥了作用。但是我没有在任何地方看到它，所以我不能完全确定。</p><p id="568c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">看起来像是工作程序运行env函数，当它完成时，它将数据发送到远程！这个函数中有很多关闭，这可能表明，它将暂时切断通信。例如，如果发送了两条消息，而孩子想一次读一条，我认为这类似于关闭通信，这样第二条消息还没有到达，读第一条消息然后等待下一条消息。但我不完全确定。</p><p id="544a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对我来说，另一件有趣的事情是，在reset函数中，观察值也需要被发送回来！所以我会这么做的！</p><p id="4128" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们回到run.py的build_env！</p><h1 id="690a" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">构建_环境</h1><p id="acc1" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">完成之后，build_env只返回环境。那我们上去训练吧！</p><h1 id="659e" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">火车</h1><p id="14c8" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">build_env完成后，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="696c" class="kx jm hi kt b fi ky kz l la lb">if args.save_video_interval != 0:<br/>        env = VecVideoRecorder(env, osp.join(logger.get_dir(), "videos"), record_video_trigger=lambda x: x % args.save_video_interval == 0, video_length=args.save_video_length)</span></pre><p id="b366" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">结束了。这个，只是用gym.wrappers.monitoring的video_recorder录视频。</p><p id="52ec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，在网络设置如下之后，</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2cf3" class="kx jm hi kt b fi ky kz l la lb">if args.network:<br/>        alg_kwargs['network'] = args.network<br/>else:<br/>        if alg_kwargs.get('network') is None:<br/>            alg_kwargs['network'] = get_default_network(env_type)</span></pre><p id="8024" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">型号设置为</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b7cd" class="kx jm hi kt b fi ky kz l la lb">model = learn(<br/>        env=env,<br/>        seed=seed,<br/>        total_timesteps=total_timesteps,<br/>        **alg_kwargs<br/>    )</span></pre><p id="a6c1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这基本上是所有选择的算法的学习功能！</p><p id="14cf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，返回模型和环境</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a428" class="kx jm hi kt b fi ky kz l la lb">return model, env</span></pre><p id="87f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，最后，让我们进入学习功能，看看我们应该做什么！</p><h1 id="ac24" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">ppo2学习功能</h1><p id="af1a" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">因为有很多算法，但我认为它们对环境的期望应该是相似的，所以我决定看看ppo2的学习功能！我选择ppo2是因为，嗯，我比其他人更了解它。</p><p id="9bd4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在learn函数中，我们看到的与环境交互的第一个实例是</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8d09" class="kx jm hi kt b fi ky kz l la lb">obs, returns, masks, actions, values, neglogpacs, states, epinfos = runner.run() #pylint: disable=E0632</span></pre><p id="9422" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，什么是跑步者？它被定义为</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c54c" class="kx jm hi kt b fi ky kz l la lb">runner = Runner(env=env, model=model, nsteps=nsteps, gamma=gamma, lam=lam)</span></pre><p id="de2d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Runner模块在baselines/ppo2/runner.py中定义</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4e7e" class="kx jm hi kt b fi ky kz l la lb">self.obs[:], rewards, self.dones, infos = self.env.step(actions)</span></pre><p id="dce8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在运行功能中。也</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2372" class="kx jm hi kt b fi ky kz l la lb">actions, values, self.states, neglogpacs = self.model.step(self.obs, S=self.states, M=self.dones)</span></pre><p id="5f41" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在它之前。</p><p id="3f9f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">总的来说，我们看到，虽然这是一次有趣的旅程，但我们已经回到了最本质的问题:我们应该做些什么来使这成为一个自我游戏的环境？</p><h1 id="20e0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">然后</h1><p id="7260" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">在下一篇文章中，我将在这里讨论我是如何实现这个<a class="ae jk" rel="noopener" href="/@isamu.website/understanding-openai-baseline-source-code-and-making-it-do-self-play-part-4-a54e075386bf">的</a>！</p></div></div>    
</body>
</html>