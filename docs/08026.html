<html>
<head>
<title>Unpivot a column of delimited data with R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用R取消一列分隔数据的透视</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/unpivot-a-column-of-delimited-data-with-r-65139942289b?source=collection_archive---------8-----------------------#2020-07-15">https://medium.com/analytics-vidhya/unpivot-a-column-of-delimited-data-with-r-65139942289b?source=collection_archive---------8-----------------------#2020-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前，我已经解释了如何在<a class="ae jd" rel="noopener" href="/analytics-vidhya/unpivot-data-with-delimeters-in-power-query-57f57a3ddb4f?source=friends_link&amp;sk=a9ae05c7f52c1a90d05a468ce034fbe2"> Power Query (Excel和Power BI) </a>和<a class="ae jd" rel="noopener" href="/swlh/unpivot-a-column-of-data-with-delimeters-in-pandas-dataframes-d1afa034705b?source=friends_link&amp;sk=8655dcc819ebfb65a9018adf815d95b7"> Python (pandas) </a>中获取一列分隔的数据并将单个值提取到它们自己的行中。</p><p id="986e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天，我将通过解释这些数据转换如何在r。</p><p id="4a89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将再次利用这个社交网络使用示例数据来演示这些转换。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/eeb5949f5828dc7f630b2b5f7ca2fe0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*_Y01d9OKtV_HTMwwtesX7A.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">抽样资料</figcaption></figure><p id="9f9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目标是获取上述初始数据(从CSV文件加载)并将其转换为以下形式:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jq"><img src="../Images/58985bf2adc407d0c3c7d71cf7e641c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*xArGzgyn_3UvA_ltobwZYw.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">结果数据</figcaption></figure><p id="53f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另外，我还将向你展示如何用Plotly在一个柱状图中可视化社交网络的频率。</p><p id="77c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想跳过解释直接跳到代码，请随意访问我的GitHub库，那里有所有的代码和样本数据。</p><h1 id="7ec3" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">拆分和取消透视数据</h1><p id="0574" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">本演示的主要重点是拆分和取消拆分分隔的数据。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/eeb5949f5828dc7f630b2b5f7ca2fe0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*_Y01d9OKtV_HTMwwtesX7A.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">抽样资料</figcaption></figure><p id="621c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到“使用的社交网络”列在每行中可以有多个社交网络(可能是调查中的多项选择问题)，用分号(；).这不是一个适合数据分析的格式，因为我们无法统计每个社交网络的频率。</p><p id="de65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，提取单个社交网络并将其放在自己的行上(unpivot)的逻辑如下:</p><ul class=""><li id="2230" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">将每行的值拆分到各自的列中(例如，脸书；Instagram分为两栏，一栏为脸书，另一栏为Instagram)</li><li id="c7fd" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">将这些带有单独选项的列放在一列中(取消这些列的透视)</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/7dfce70b795a21129c544e249f780cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlLCr5FEyxQgjG15XzItFw.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">拆分和取消透视数据转换</figcaption></figure><p id="56ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(请注意“回答者ID”和“性别”列中的数据是如何重复的，以确保社交网络仍然与他们的回答者相关)</p><p id="d921" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是R代码:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">拆分和取消透视数据</figcaption></figure><p id="c958" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先加载CSV文件并创建两个辅助变量，<code class="du lp lq lr ls b">max_split_cols</code>和<code class="du lp lq lr ls b">sep_into_cols</code>。</p><p id="fdeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lp lq lr ls b">max_spit_cols</code>是单个受访者选择的社交网络的最大数量，即我们需要确保该受访者的所有个人选项都在自己的列中的列数。该值的计算方法是计算一行中分号的最大数量，加上一(如果一行有两个分号，则意味着受访者选择了二加一，三，社交网络)。哦，还有<code class="du lp lq lr ls b">na.rm = TRUE</code>忽略NA/null值。</p><p id="ff74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lp lq lr ls b">sep_into_cols</code>是为包含单个选项的列生成名称。这些名称是字符串“Col”和一个数字的串联。<code class="du lp lq lr ls b">mapply</code>类似于for循环，它将函数(<code class="du lp lq lr ls b">paste</code>)应用于序列的所有值(1和<code class="du lp lq lr ls b">sep_into_cols</code>之间的数字)。<code class="du lp lq lr ls b">sep = ""</code>是传递给<code class="du lp lq lr ls b">paste</code>的额外参数。换句话说，<code class="du lp lq lr ls b">mapply</code>将通过连接“Col”和一个数字来创建一个字符串列表，在两者之间不留下任何间隔(一个空字符串，<code class="du lp lq lr ls b">""</code>)。<code class="du lp lq lr ls b">unname</code>从<code class="du lp lq lr ls b">mapply</code>返回的列表中提取实际的字符串(<code class="du lp lq lr ls b">mapply</code>实际上是返回一个命名字符串的列表，类似于Python中的字典)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lt"><img src="../Images/01a0749b1f0ad6c7b115e6aaba8d9bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*xdaWarDtksynm-QDQ3pmHA.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">sep_into_cols解释</figcaption></figure><p id="8151" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果文字解释不够清楚，上面的图片应该更清楚。</p><p id="1ccb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以将分隔值拆分到单独的列中(代码要点的第13行和第14行)。<code class="du lp lq lr ls b">%&gt;%</code>操作符将前面的值作为第一个参数传递(通过管道)给后面的函数调用。举个例子，</p><pre class="jf jg jh ji fd lu ls lv lw aw lx bi"><span id="55be" class="ly js hi ls b fi lz ma l mb mc">some_value %&gt;% f(y)</span></pre><p id="3a86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lp lq lr ls b">some_value</code>将被解释为<code class="du lp lq lr ls b">f</code>的函数调用的第一个参数，<code class="du lp lq lr ls b">y</code>将被解释为第二个参数(请注意该运算符是由<code class="du lp lq lr ls b">dplyr</code>库提供的，它不是内置的R运算符)。在我们的例子中，它传递从CSV加载的<code class="du lp lq lr ls b">data</code>作为<code class="du lp lq lr ls b">separate</code>函数的第一个参数。这个函数负责将分隔的数据分成多个列。</p><p id="c1fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了DataFrame之外，我们还指定了带有分隔数据的列的名称、“使用的社交网络”、为提取的值创建的列的名称(<code class="du lp lq lr ls b">sep_into_cols</code>)、用于分割值的分隔符(分号)，以及当分割的值不够时如何填充列。最后一个参数需要注意，因为它指定了如何处理拆分值的数量少于可用列的数量的行(即大多数行)。</p><p id="8efb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果创建四列来包含拆分值(四是单个回答者选择的社交网络的最高数量)，那么当某人只选择一个、两个或三个时会发生什么？剩余的列用NA填充，但是最后一个参数<code class="du lp lq lr ls b">separate</code>指定了我们是先用提取的值(<code class="du lp lq lr ls b">right</code>)还是用NAs ( <code class="du lp lq lr ls b">left</code>)来<code class="du lp lq lr ls b">fill</code>这些列。由于我们选择了<code class="du lp lq lr ls b">right</code>，结果是这样的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es md"><img src="../Images/e8febe360358f70389fb3eda0f6b1e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*0qxx8uirUOwMkjsOaZrQAg.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">用右填充分隔</figcaption></figure><p id="f3c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如果我们选择了<code class="du lp lq lr ls b">left</code>,结果会是这样:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es me"><img src="../Images/15abd40526b7f105a199c478e66dc983.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*kIhEZFe8UOcq1iO4JjiquQ.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">左侧填充分隔</figcaption></figure><p id="08ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在我们已经拆分了值，我们只需要取消这些列，我们已经完成了转换。这就是第19行的用途，使用<code class="du lp lq lr ls b">pivot_longer</code>函数。除了作为第一个参数传递的分割数据之外，我们还需要指定要取消透视的列的名称(将这些名称存储在<code class="du lp lq lr ls b">sep_into_cols</code>变量中会很方便)。取消多列透视时，这些列的名称放在一列中，它们的值放在另一列中。这就是分别使用<code class="du lp lq lr ls b">names_to</code>和<code class="du lp lq lr ls b">values_to</code>参数的目的。最后，我们不想保留那些在分割期间创建的额外NA，因此我们指定了<code class="du lp lq lr ls b">values_drop_na = TRUE</code>。</p><p id="e889" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们不需要包含那些具有拆分值的中间列的名称的列，所以我们在第28行通过“取消选择”来删除它(更确切地说，通过用减号<code class="du lp lq lr ls b">select</code>来删除它)。因此，得到的数据帧就是我们所寻找的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mf"><img src="../Images/67eee7a8ea6d90a6766fcf7feca026de.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*uddpVcwSozIY9Gs03ZAnKw.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">拆分和取消拆分数据</figcaption></figure><h1 id="5977" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">额外:统计社交网络的频率，并绘制图表</h1><p id="8d52" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">既然数据有了合适的格式，就很容易画出每个社交网络的频率。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">计算频率并绘图</figcaption></figure><p id="4fe4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要计算社交网络的频率，我们只需将数据框按“使用过的社交网络”这一栏分组，并计算每个独特选项的频率。在<code class="du lp lq lr ls b">summarize(Frequency = n())</code>中，Frequency是包含频率的列的名称，<code class="du lp lq lr ls b">n()</code>是用于计数的集合函数。不幸的是，返回的DataFrame只有两列，一列用于社交网络(“使用的社交网络”)，另一列用于频率(“频率”)，但这对于该图来说已经足够了。</p><p id="787c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第二个代码要点的第6行，我们按频率降序排列数据帧。</p><p id="de07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第11行，我们终于开始用Plotly创建条形图。<code class="du lp lq lr ls b">plot_ly</code>接收频率的数据帧，然后我们将该函数传送给<code class="du lp lq lr ls b">add_bar</code>函数，后者创建一个柱状图。列名前的波浪符号(~)用于将列标识为指定数据帧的列。之后，我们用管道传递另一个函数，来更新绘图的格式。我们给它一个标题，更改轴的标题，并按照“频率”列中的数据顺序排列X轴的数据。换句话说，X轴的社交网络是按照频率降序排列的！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mg"><img src="../Images/c1b7fd478bc6e536ff3f2c3b8f02878c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ocuZy5rQoZ01Z854Y8377w.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">社交网络频率条形图</figcaption></figure><p id="71d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Plotly图表是交互式的，即你可以放大/缩小图表，通过悬停查看额外信息等。，但在本文中只能添加一个截图。</p><h1 id="ae89" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结论</h1><p id="b21c" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这是文章的结尾。我们已经完成了以下内容:</p><ul class=""><li id="74d1" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">如何用列中的分隔符拆分数据</li><li id="537d" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">如何取消透视列</li><li id="78e1" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">如何计算列中值的出现频率</li><li id="2bc6" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">如何创建Plotly条形图</li></ul><p id="4cdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像往常一样，本文的所有代码都可以在<a class="ae jd" href="https://github.com/Ze1598/medium-articles/tree/master/Unpivot%20a%20column%20of%20delimited%20data%20with%20R" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="ae8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，这是完整的脚本:)</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">完整脚本</figcaption></figure></div></div>    
</body>
</html>