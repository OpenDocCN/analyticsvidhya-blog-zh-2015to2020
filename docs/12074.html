<html>
<head>
<title>Inner Working of cv2.rectangle() using NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NumPy对cv2.rectangle()进行内部处理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/inner-working-of-cv2-rectangle-using-numpy-b7bcdf333ef8?source=collection_archive---------9-----------------------#2020-12-30">https://medium.com/analytics-vidhya/inner-working-of-cv2-rectangle-using-numpy-b7bcdf333ef8?source=collection_archive---------9-----------------------#2020-12-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="26a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将尝试使用Python中的NumPy模块来理解<strong class="ig hi"> <em class="jc"> cv2.rectangle() </em> </strong>的内部工作原理。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f7fefbda2e3861290ed74af718f08b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YpSEtVEIiBKn7vM_"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@timmossholder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·莫斯霍尔德</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3656" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"><em class="jc">cv2 . rectangle()</em></strong>是OpenCV的方法——用来在图像上画一个矩形。我们可以选择决定矩形的厚度和颜色。但是我们需要确保颜色是以<strong class="ig hi"> <em class="jc"> RGB </em> </strong>码(R，G，B)传入的。在这篇博客文章中，我们将努力集中理解这个方法的内部工作原理，并使用NumPy模块从头开始实现它。</p><p id="c631" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">矩形就是我们想要在图像的指定位置绘制的形状。我们可以通过两点<strong class="ig hi"> <em class="jc"> pt1 </em> </strong>和<strong class="ig hi"> <em class="jc"> pt2 </em> </strong>来进行位置的绘制。图像矩阵被认为是一个2D平面，以便我们确定矩形的位置。我们先来了解一下库方法。</p><p id="8754" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上述方法的论据是:</p><ul class=""><li id="124d" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc"> img </em> </strong> →画矩形的图像。</li><li id="2358" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc"> pt1 </em> </strong> →点1决定矩形的位置。</li><li id="caff" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc"> pt2 </em> </strong> →点2也决定矩形的位置。</li><li id="8c71" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc">颜色</em> </strong> →作为<strong class="ig hi"> <em class="jc"> RGB </em> </strong>代码传递的矩形的颜色。</li><li id="a44d" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc">粗细</em> </strong> →矩形的线条粗细。</li></ul><p id="dfcc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其他论点及其重要性可以通过查看<strong class="ig hi"><em class="jc">help(cv2 . rectangle)</em></strong>了解。首先，我们将实现库方法，然后我们将从头开始实现代码。</p><h1 id="c630" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">编码时间到了</h1><p id="8c99" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">我们主要使用的软件包有:</p><ul class=""><li id="9298" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated">NumPy</li><li id="29bf" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">Matplotlib</li><li id="7f31" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">OpenCV →仅用于读取图像。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/18305c130ac5255d7e7a39a385ec518d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Nm7Ec_i9OjDnCPM59Nkdg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者图片</figcaption></figure><h2 id="1aac" class="lm kj hh bd kk ln lo lp ko lq lr ls ks ip lt lu kw it lv lw la ix lx ly le lz bi translated">导入包</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><h2 id="b5f3" class="lm kj hh bd kk ln lo lp ko lq lr ls ks ip lt lu kw it lv lw la ix lx ly le lz bi translated">阅读图像</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="8696" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上述函数读取灰度或RGB图像，并返回图像矩阵。</p><h2 id="67cb" class="lm kj hh bd kk ln lo lp ko lq lr ls ks ip lt lu kw it lv lw la ix lx ly le lz bi translated">用库实现代码</h2><p id="c125" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">我们将使用<strong class="ig hi"><em class="jc">cv2 . rectangle()</em></strong>方法。但是为了更好的可视化，我们可以将下面的函数作为参数:</p><ul class=""><li id="47dd" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc"> start_pos </em> </strong> →要知道要绘制的矩形的起始位置。</li><li id="3fc6" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc">长度</em> </strong> →矩形的长度(考虑绝对值)。</li><li id="7eb9" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc">宽度</em> </strong> →矩形的宽度(考虑绝对值)。</li></ul><p id="4bc0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从以上三个论点，我们可以得出<strong class="ig hi"><em class="jc">【pt1】</em></strong>和<strong class="ig hi"> <em class="jc"> pt2 </em> </strong>点实际上是在传递库函数。</p><ul class=""><li id="c817" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc">粗细</em> </strong> →矩形的粗细。</li><li id="e879" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc"> color_name </em> </strong> →不用传递<strong class="ig hi"> <em class="jc"> RGB </em> </strong>代码，我们可以从<strong class="ig hi"><em class="jc">color _ names _ data . JSON</em></strong>文件中提取(R，G，B)值，我在这个文件中已经分别存储了所有可能的颜色名称及其(R，G，B)值。颜色数据的样本可以在下面查看。</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="6765" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该功能适用于彩色图像和灰度图像。但是对于灰度图像，考虑默认颜色<strong class="ig hi"> <em class="jc">黑色</em> </strong>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="ac02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的函数比我们自己指定点更容易实现。我们可以简单地提到三个重要的论点，并在此基础上确定要点。让我们测试一下功能。</p><p id="4fa0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">对于彩色图像:</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/463f497954fe3af4f680ede39358745a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*HqGb4ipzMxKtx7q_G1hs0w.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者图片</figcaption></figure><p id="6f0c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">对于灰度图像:</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/793e6449b292cc61d0017815350bb0d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*KbgSPftzNhmNvWWr15x5Mw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者图片</figcaption></figure><p id="ff75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于thickness (-1)，有一种特殊情况，即根据指定的颜色对整个矩形区域进行着色。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/8ef5ba008e86978da3eafcdf153d7294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*7q74DiUR55RnpAPBIpqUWA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者图片</figcaption></figure><p id="de4f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以上案例都是使用库方法实现的。很明显，库方法肯定有效。是时候靠我们自己从零开始做点什么了。</p><h2 id="ac77" class="lm kj hh bd kk ln lo lp ko lq lr ls ks ip lt lu kw it lv lw la ix lx ly le lz bi translated">从头开始代码实现</h2><p id="703d" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">我们将使用在上述函数<strong class="ig hi"><em class="jc">rectangle _ lib()</em></strong>中使用的相同参数。但是我们遵循的技术是不同的。在这里，<strong class="ig hi"> <em class="jc">厚度</em> </strong>的说法与<strong class="ig hi"> <em class="jc"> start_pos </em> </strong>、<strong class="ig hi"> <em class="jc">长度</em> </strong>、宽度<strong class="ig hi"/>起着重要的作用。</p><p id="54b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实现背后的逻辑:</p><ol class=""><li id="8e5c" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb md ka kb kc bi translated">我们要根据<strong class="ig hi"> <em class="jc"> start_pos </em> </strong>，<strong class="ig hi"> <em class="jc">长度</em> </strong>，<strong class="ig hi"> <em class="jc">宽度</em> </strong>来抓取子图。基本上，我们必须裁剪图像。这个裁剪的图像将是矩形的内部部分(请阅读这篇<a class="ae jt" rel="noopener" href="/analytics-vidhya/crop-the-image-intuitively-numpy-d19ef55c2207">文章</a>以了解更多信息)。</li><li id="18df" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb md ka kb kc bi translated">我们需要用颜色值填充图像矩阵(从颜色名称获得)。如果图像是灰度的，那么我们将填充黑色值，即<strong class="ig hi"> <em class="jc"> 0 </em> </strong>。否则，我们将在分离<strong class="ig hi"> <em class="jc"> R </em> </strong>像素、<strong class="ig hi"> <em class="jc"> G </em> </strong>像素和<strong class="ig hi"> <em class="jc"> B </em> </strong>像素并最终将它们合并以形成单个图像之后填充3次。基本上，我们在裁剪图像的边缘(请阅读这篇文章<a class="ae jt" rel="noopener" href="/analytics-vidhya/adding-a-border-to-the-image-using-numpy-efa23f7f1cdf">以了解更多信息)。</a></li><li id="2474" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb md ka kb kc bi translated">最后，我们需要在原始图像中替换这个带边框的、裁剪过的图像，并显示该图像。</li></ol><p id="06b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将使用来自文件<strong class="ig hi"><em class="jc">color _ names _ data . JSON</em></strong>的相同颜色数据来获得颜色值。让我们编写逻辑代码。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="921a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我们不处理决定矩形位置的点。我们是用<strong class="ig hi"> <em class="jc">裁剪</em> </strong>、<strong class="ig hi"><em class="jc"/></strong>、用<strong class="ig hi"> <em class="jc">代替</em> </strong>的手法来达到主要动机。我们来测试一下上面的函数。</p><p id="106a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">对于彩色图像:</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/59d6b630c89e7ce1c197242f5d595c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*QZOoc2aSql-OTv5AL8VrjA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者图片</figcaption></figure><p id="5208" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">对于灰度图像:</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/23251220901b3b603f2be0dc6828710f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*uqzxYsf8DFeW_7wcvV86Cw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者图片</figcaption></figure><p id="dd26" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于thickness (-1)，有一种特殊情况，即根据指定的颜色对整个矩形区域进行着色。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/dd0ec80abeb77c3a92b35ac278b60b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*OO3OobzZjHQ3uI1llZL7FA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者图片</figcaption></figure><h1 id="9e0b" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">就是这个！</h1><p id="624e" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">我们终于得到了我们想要的。我们试图在NumPy矩阵运算的帮助下从头开始实现代码。我们使用了NumPy方法，如:</p><ul class=""><li id="2007" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc"> pad() </em> </strong> →用常数值填充矩阵。</li><li id="9f29" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc"> zeros() </em> </strong> →我们将此用于<strong class="ig hi"> <em class="jc">厚度</em> </strong>为-1的特殊情况。这仅在以灰度模式读取图像时使用。</li><li id="8acf" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated"><strong class="ig hi"> <em class="jc">满()</em> </strong> →我们用来获得一个相同值的矩阵。在以彩色模式读取图像的情况下，当<strong class="ig hi"> <em class="jc">厚度</em> </strong>为-1时，也可以使用该选项。</li></ul><p id="82af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就我个人而言，我从实施该方法中学到了很多。我希望你觉得这很有见地。你一定要看看我在个人资料中关于同一主题的其他文章。</p></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><p id="601a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你喜欢，你可以在这里给我买咖啡。</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://www.buymeacoffee.com/msameeruddin"><div class="er es ml"><img src="../Images/3237d6de51e7c3579e269a264cf0eeb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/0*PQ_KXFCI_o36WU_h.png"/></div></a></figure></div></div>    
</body>
</html>