<html>
<head>
<title>Artificial Intelligence at Play — Connect Four (Mini-max algorithm explained)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能在发挥作用—连接四个(解释最小最大算法)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/artificial-intelligence-at-play-connect-four-minimax-algorithm-explained-3b5fc32e4a4f?source=collection_archive---------0-----------------------#2020-10-14">https://medium.com/analytics-vidhya/artificial-intelligence-at-play-connect-four-minimax-algorithm-explained-3b5fc32e4a4f?source=collection_archive---------0-----------------------#2020-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/47eee30f199fb879c6ee16e6ac03bd09.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*HqTdkytsHijhlRsd.gif"/></div></figure><h1 id="bdd0" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">介绍</h1><p id="c30a" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">这是一个有几个世纪历史的游戏，甚至詹姆斯·库克船长在他的长途航行中也和他的军官们一起玩。米尔顿·布拉德利(Milton Bradley，现为孩之宝所有)在1974年出版了这款游戏的一个版本，名为“连接四个”。也叫“四连”和“第四区”两个玩家在一块有六排七个空洞的直立板上玩这个游戏。每个玩家都有相同数量的棋子(21)，开始时从棋盘顶部一次丢下一个。然后，他们将轮流玩，谁能垂直、水平或对角地走直线，谁就赢。</p><h1 id="bf43" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">问题陈述</h1><p id="e2e8" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">这个游戏被归类为零和游戏。因此，可以应用最小最大算法，这是在AI中使用的决策规则。这个项目的目标是研究如何通过人工智能在这个游戏中使用极大极小算法来应用决策树。</p><h1 id="b07f" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">制胜战略</h1><h1 id="de97" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">放在中间一栏</h1><p id="f528" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果玩家可以先玩，最好放在中间栏。由于电路板有七列，将圆盘放在中间可以实现垂直、对角和水平连接。总共有五种可能的方法。</p><h1 id="2d79" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">给对手设陷阱</h1><p id="6e6a" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">一个典型的不失败的方法是试图阻挡对手的胜利之路。比如通过提前在线旁放置圆盘进行阻挡来防止对手得到三的连接。这种策略也防止了对手对玩家设置陷阱。</p><h1 id="8e24" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">做一个“7”</h1><p id="3d3c" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">7陷阱是一种战略性移动的名称，在这种移动中，一个人将其磁盘放置在类似于7的配置中。三个水平盘连接到从最右边的水平盘分支出来的两个对角盘。7可以以任何方式配置，包括正确的方式，向后，颠倒，甚至颠倒和向后。这种盘的形式是一个很好的策略，因为它给玩家提供了多个方向来进行四连击。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es ki"><img src="../Images/ddfe41e597bdef3f2ff25f981be92b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*5DsKiI5QwLnDtjFb54yCUA.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">“7”策略(黄色圆盘)</figcaption></figure><h1 id="fed4" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">后面的逻辑和数学连接四个</h1><h1 id="b278" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">决策图表</h1><p id="b193" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">决策树是一种树形结构，其中每个内部节点表示对属性的测试，每个分支表示测试的结果，每个叶节点(终端节点)持有一个类标签。在下面的例子中，一个可能的流程如下:如果一个人年龄小于30岁并且不吃很多比萨饼，那么这个人被归类为健康。相反，如果一个人超过30岁，并且不在早上锻炼，那么这个人就被归类为不健康。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/7d2052cdd487e5148e4f767c2c4fc3d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*RQyw-Pg6UbAcm7btqIOVWg.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">关于适应度的简单决策树</figcaption></figure><p id="7f3c" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">决策树可以应用于不同的研究，包括商业战略计划、数学研究等等。此外，由于决策树显示了所有可能的选择，它可以在逻辑游戏中用作查找表，如Connect Four。</p><h1 id="da31" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">连接四中的决策树</h1><p id="5f5c" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">游戏开始时，第一个玩家可以在七列中选择一列来放置彩色圆盘。总共有7列，所以一个决策树每次有7个分支。在第一个玩家移动后，第二个玩家可以从第一个玩家选择的决策树中选择七列中的一列。</p><p id="cf2c" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">请注意，决策树继续处理一些特殊情况。首先，如果两个玩家总共选择了6次相同的列，那么该列对任何一个玩家都不再可用。意味着他们的选择分支减少了一个。第二，当两个玩家都做出了所有的选择(本例中为42)并且仍然没有连续的4张盘时，游戏以平局结束，决策树停止。最后，如果任何玩家连续4次，决策树停止，游戏结束。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/cb6d70c2bf8f9074ad4a6a50ed724967.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*DBpG8c3c7BOZ5g7p1n_S5Q.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">决策树中显示的连接四个游戏的每个迭代的可能移动</figcaption></figure><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/a52e844d380b1d006fe4e63ea9cb50f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*IyyCmHRYJpVhkU7SWyuF5Q.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">连接四种可能移动的决策树</figcaption></figure><h1 id="1182" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">极大极小算法</h1><p id="c29e" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">极大极小算法是一种递归算法，用于决策和博弈论，特别是在人工智能游戏中。它为玩家提供了最优的移动，假设对手也在最优地进行游戏。比如考虑两个对手:Max和Min玩。Max将尝试最大化该值，而Min将选择最小值。该算法执行深度优先搜索(DFS ),这意味着它将尽可能深入地探索整个游戏树，一直到叶子节点。下面用一个说明性的例子展示了该算法。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/44ae287776853e1e1702f0e1c24e4947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvmXgOZ2ckxIAiWAye54eg.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">极大极小算法伪代码</figcaption></figure><p id="58a9" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">最初，该算法生成整个博弈树，并通过应用效用函数产生终端状态的效用值。例如，在下面的树形图中，让我们把A作为树的初始状态。假设maximizer进行第一轮，它有一个等于负无穷大的最坏情况初始值。然后，极小值将进行下一轮，它有一个等于正无穷大的最坏情况初始值。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es le"><img src="../Images/f00ebc0d93b5eb04c51dda4d1f91b816.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*ILe9XxR8ofjDrJ7vG1CMLQ.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">树格式的极大极小算法——初始步骤</figcaption></figure><p id="d539" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">首先，我们考虑初始值= -∞的极大化器。每个终端节点将与最大化器的值进行比较，并最终将最大值存储在每个最大化器节点中。例如，从顶部数第三行(最大化器)。</p><p id="c229" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">对于节点D，最大值(-1，-∞) →最大值(-1，4) = 4</p><p id="3408" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">对于节点E，max(2，-∞) → max(2，6) = 6</p><p id="4610" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">对于节点F，最大值(-3，-∞) →最大值(-3，-5) = -3</p><p id="b840" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">对于节点G，max(0，-∞) → max(0，7) = 7</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/6df3b0f48c590f4dfb61e00fa84a65e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*QQ5IDHasN_ydJsvBS8jfgQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">树格式的极大极小算法—第二步</figcaption></figure><p id="ea07" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">接下来，我们将每个节点的值与极小值进行比较，即+∞。</p><p id="0bcf" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">节点B的tof = min(4，6) = 4</p><p id="8335" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">对于节点C= min(-3，7) = -3</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/e2034b9728291ad804b56ea7cda2d8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*HNWrjcr8VAeb_aEHMr-ybQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">树格式的极大极小算法—第三步</figcaption></figure><p id="241a" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">最后，最大化器将再次选择节点B和节点C之间的最大值，在本例中为4。因此，我们得到了博弈的最优路径:A → B → D → I。</p><p id="058c" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">对于节点A，max(4，-3)= 4</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/99bbf31e74a85a5857eaa15031a95fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*mawaGslmPWazK5oaswgiNQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">树格式的极大极小算法——最后一步</figcaption></figure><h1 id="e91a" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">人工智能在连接四个——实现极大极小</h1><p id="ccc5" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">下面是Connect Four中Minimax算法实现的python片段。在代码中，我们通过添加Alpha-beta剪枝策略扩展了原有的Minimax算法，提高了计算速度，节省了内存。下图是alpha-beta minimax算法的伪代码。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es li"><img src="../Images/b61dea9e38a989f426996ff2ef5773ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKIe5NUgrZStu8sbgHHjog.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">带有α-β剪枝伪代码的极大极小算法</figcaption></figure><p id="59d4" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated"><em class="lj">注:Https://github.com/KeithGalli/Connect4-Python最初提供代码</em></p><p id="a5cf" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">我正在总结并解释连接4中的算法</p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="491f" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">让我们以上面代码中的<strong class="jm hj"> maximizingPlayer </strong>为例(从第136行到第150行)。首先，程序将从每一列中查找所有有效位置，递归地获得在查找表中计算的新分数(将在后面解释)，最后从子节点中更新最优值。请注意，本节中的alpha是new_score，当它大于当前值时，它将停止执行递归并更新新值以节省时间和内存。</p><p id="0b9c" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">如上所述，查找表是根据下面的evaluate_window函数计算的。这里，窗口大小被设置为4，因为我们正在寻找4个磁盘的连接。考虑这个游戏中的奖励和惩罚方案。如果连接了四个盘，则奖励高的正分数(在本例中为100)。当连接三个片时，它的分数比连接四个片时的分数低。当两片相连时，它得到的分数比三片相连的情况低。最后，当对手有三个相连的棋子时，玩家会得到一个负分数的惩罚。表明这对于当前玩家来说不是最优的移动。</p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="1908" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">设置了评分标准后，程序现在需要计算游戏中每个玩家每个可能移动的所有分数。函数score_position从下面的代码片段中执行这一部分。人工智能玩家将利用这个函数来预测一个最佳的移动。</p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h1 id="c4dc" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">结论</strong></h1><p id="7b04" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">看着AI在这场游戏中击败了多少次人类玩家，我意识到它是靠理性和大量信息取胜的。在这个项目中，人工智能玩家使用极大极小算法提前检查最佳移动，通过理性地了解所有可能的移动来胜过人类玩家。有趣的是，当将minimax函数的深度数从高(例如6)调至低(例如2)时，AI玩家的表现可能会更差。尽管如此，在这个项目中应用的策略和算法已经被证明是有效的，并且取得了惊人的效果。</p><h1 id="fd8a" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">参考</h1><p id="6796" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">加利。(未注明)。KeithGalli/Connect4-Python。GitHub。<a class="ae lm" href="https://github.com/KeithGalli/Connect4-Python" rel="noopener ugc nofollow" target="_blank">https://github.com/KeithGalli/Connect4-Python</a></p><p id="05ed" class="pw-post-body-paragraph jk jl hi jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh hb bi translated">美国国家航空航天局、Didwania、Maji、s .、&amp; Kumar、V. (2018年)。mini-max算法中的Alpha-beta修剪-connect-4游戏的优化方法。里面的工程研究Technol，1637-1641年。</p></div></div>    
</body>
</html>