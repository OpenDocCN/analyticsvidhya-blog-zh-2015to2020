<html>
<head>
<title>Fastai v2 — An End-to-End Deep Learning Tutorial for Arabic character recognition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Fastai v2 —阿拉伯字符识别的端到端深度学习教程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/fastai-v2-an-end-to-end-deep-learning-tutorial-for-arabic-character-recognition-afd42aa218c8?source=collection_archive---------14-----------------------#2020-05-07">https://medium.com/analytics-vidhya/fastai-v2-an-end-to-end-deep-learning-tutorial-for-arabic-character-recognition-afd42aa218c8?source=collection_archive---------14-----------------------#2020-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6ae724044c11e27f759ca801f644acf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOmAqRA2QpJfV0e4yW1sig.png"/></div></div></figure><p id="946a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整的代码可以在GitHub上找到，它有一个多功能的<a class="ae jo" href="https://github.com/AnelMusic/Arabic_MNIST_Character_Classification/blob/master/Arabic_MNIST_Character_Classification.ipynb" rel="noopener ugc nofollow" target="_blank"> jupyter笔记本</a>。</p><h1 id="8af2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">简单地说:</strong></h1><p id="7deb" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">随着今天机器学习的快速发展，很难想象即使在几年前，鲁棒的字符识别也会带来真正的挑战。从那以后，著名的<a class="ae jo" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST </a>数据集被世界各地的研究人员用来训练新的算法。今天，MNIST对现代神经网络来说几乎没有挑战。受此启发，2017年一个研究小组开始对阿拉伯字母进行分类。Ahmed El-Sawy、Mohamed Loey和Hazem EL-Bakry在他们的工作“使用卷积神经网络的阿拉伯手写字符识别，WSEAS，2017”中实现了94.1%的准确率。我们的目标是展示使用现代训练方法击败2017年的这一最先进的研究结果是多么容易。</p><p id="f498" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">本文的目的</strong>:</p><ul class=""><li id="8cb8" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">下载并解压缩数据集</li><li id="591b" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">加载和格式化图像，并编写自定义标签函数</li><li id="2065" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">将数据集分成训练集、验证集和测试集</li><li id="f1a9" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">使用迁移学习和Resnet18架构来训练多类分类器</li><li id="2398" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">使用微调和区别学习率，在22个训练周期内达到97%的准确率</li><li id="3898" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">策划和解释培训结果</li></ul><h1 id="801d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤1:获取数据</h1><p id="ec68" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">该数据集包含16800幅阿拉伯字母手写字符的图像。每个图像的大小为32x32像素。训练集(13440个图像，每个字符490个图像)和验证集(3360个图像，每个字符120个图像)已经预定义。您可以从<a class="ae jo" href="https://github.com/AnelMusic/Arabic_MNIST_Character_Classification/blob/master/arabic_mnist_dataset.tar.gz" rel="noopener ugc nofollow" target="_blank">这里</a>直接下载数据集。下载后，您可以使用以下命令提取tar.gz文件:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5499" class="lp jq hi ll b fi lq lr l ls lt">tar -xzf arabic_mnist_dataset.tar.gz </span></pre><h1 id="06cb" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤2:加载数据</h1><p id="0ea0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">导入fastai模块后:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="587e" class="lp jq hi ll b fi lq lr l ls lt">from utils import *<br/>from fastai2.vision.all import *</span></pre><p id="71b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过提供包含提取数据集的目录的完整路径来创建path对象:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="88fc" class="lp jq hi ll b fi lq lr l ls lt"># Show what's inside the directory<br/>path = Path('/notebooks/storage/data/arabic_mnist')<br/>path.ls()</span></pre><p id="3190" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出</strong>:</p><p id="ae65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(# 3)[Path('/notebooks/storage/data/Arabic _ mnist/train ')，Path('/notebooks/storage/data/Arabic _ mnist/)。ipynb_checkpoints ')、路径('/notebooks/storage/data/Arabic _ mnist/test ')]</p><p id="5f97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我们可以看到数据集由一个训练集和一个测试集组成。为了使用fastai的数据集分割方法</p><p id="014d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="lu">grand parent splitter</em>(train _ name = ' train '，valid_name='valid') </strong></p><p id="878a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以提供包含数据的文件夹的名称，也可以直接重命名文件夹。这里，我们将使用以下内容重命名目录:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="35f5" class="lp jq hi ll b fi lq lr l ls lt"># Rename test to valid<br/>! mv {path / 'test'} {path / 'valid'}</span></pre><h1 id="22fc" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">步骤3:查看数据文件名</strong></h1><p id="5986" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了更好地理解数据和命名约定，我们可以打印训练集的文件名:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6a11" class="lp jq hi ll b fi lq lr l ls lt">train_data = path/"train/train"<br/>train_data.ls()[:10], len(train_data.ls())</span></pre><p id="e210" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出</strong>:</p><p id="b696" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">((# 10)[Path('/notebooks/storage/data/Arabic _ Mn ist/train/train/id _ 5374 _ label _ 28 . png ')、Path('/notebooks/storage/data/Arabic _ Mn ist/train/train/id _ 8290 _ label _ 1 . png ')、Path('/notebooks/storage/data/Arabic _ Mn ist/train/id _ 3424 _ label _ 8 . png ')、Path('/notebooks/storage/data/Arabic _ Mn ist/train/train/id _ id _ 8 . png)</p><p id="9499" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到数据集的创建者使用了从0到28的数字标签，其中每个数字代表阿拉伯字母表中的一个字符。虽然使用这些数字标签是完全可能的，但是我们希望使用字符串标签来代替，以便于以后的解释。为此，图像的文件名必须映射到相应的标识符。</p><p id="b07c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将首先创建一个简单的列表，其中包含我们想要使用的标签，而不是相应的数字标签:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="57e6" class="lp jq hi ll b fi lq lr l ls lt">arabic_mnist_labels = ['alef','beh','teh','theh','jeem','hah','khah','dal','thal','reh',<br/>'zain','seen','sheen','sad','dad','tah','zah','ain','ghain','feh',<br/>'qaf','kaf','lam','meem','noon','heh','waw','yeh']</span></pre><p id="7d26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们需要考虑如何将文件名映射到我们的arabic_mnist_labels字符串标识符。一种方便的方法是使用正则表达式。</p><blockquote class="lv lw lx"><p id="57ad" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">正则表达式是一种特殊的字符序列，它使用模式中的特殊语法来帮助您匹配或查找其他字符串或字符串集</p></blockquote><p id="ba0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以分析路径:<em class="lu">/笔记本/存储/数据/Arabic _ mnist/train/id 5374 label _ 28 . png</em>并等待"<strong class="is hj">标签</strong>"后跟下划线"<strong class="is hj"> _ </strong>"后跟数字"<strong class="is hj"> 28 </strong>"后跟"。<strong class="is hj"> png </strong>“俺只抓数字。</p><p id="8e74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实证明，定义这种模式的一种方法是使用下面的正则表达式:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="a35c" class="lp jq hi ll b fi lq lr l ls lt">regex = "label_(.+).png"</span></pre><p id="a3b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个正则表达式，我们现在可以定义自己的标签函数，为每个图像文件名返回相应的字符串标签。请记住，数字标签从1–28开始，而我们的arabic_mnist_labels从索引0–27开始。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="dc06" class="lp jq hi ll b fi lq lr l ls lt">def get_arabic_mnist_labels(file_path):<br/>    regex = "label_(.+).png"<br/>    label = re.search(regex, str(file_path)).group(1)<br/>    return arabic_mnist_labels[int(label)-1] # adapt index</span></pre><h1 id="5d1c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤4:创建数据块对象</h1><p id="56b2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Fastai的Datablock允许我们为我们的训练和验证集设置Pytorch的数据加载器，根据我们的需要分割数据并执行转换，如调整大小、旋转和标准化我们的数据。这里，我们将使用一个称为预调整的概念</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6167" class="lp jq hi ll b fi lq lr l ls lt">arab_mnist = DataBlock(blocks = (ImageBlock, CategoryBlock),<br/>                 get_items=get_image_files, <br/>                 splitter=GrandparentSplitter(),<br/>                 get_y=get_arabic_mnist_labels, <br/>                       item_tfms=Resize(460),<br/>                 batch_tfms=[*aug_transforms(do_flip = False,                    <br/>                 size=224, min_scale=0.85), <br/>                 Normalize.from_stats(*imagenet_stats)]<br/>                )<br/>#source<br/>dls = arab_mnist.dataloaders(path)</span></pre><blockquote class="lv lw lx"><p id="5e8d" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated"><strong class="is hj">预调整尺寸</strong>:首先，将图像调整到相对“大尺寸”的尺寸，即明显大于目标训练尺寸的尺寸。</p><p id="ac54" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">第二，将所有常见的扩充操作(包括调整到最终目标大小)组合成一个，并在处理结束时在GPU上仅执行一次组合操作，而不是单独执行它们并多次插值。</p></blockquote><p id="9d7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们可以检查标签以确保我们的自定义函数使用:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="dfc8" class="lp jq hi ll b fi lq lr l ls lt">dls.show_batch(nrows=3, ncols=3)</span></pre><p id="4adc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出</strong>:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/4675268d35719ed385d779599d054ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*ABuoPwf5lq9QUybo0hCgRQ.png"/></div></figure><p id="0d61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，数据看起来符合预期。我们的标签函数将数字标签映射到字符串标识符。</p><h1 id="b3d0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤5:创建神经网络</h1><p id="8cf6" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">由于我们的任务是对图像数据进行分类，我们将使用卷积神经网络。更准确地说，我们将使用ResNet-18架构:</p><blockquote class="lv lw lx"><p id="1158" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">ResNet-18是一个18层深的卷积神经网络。您可以加载网络的预训练版本，该网络在ImageNet数据库中的超过一百万个图像上进行训练</p></blockquote><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="a971" class="lp jq hi ll b fi lq lr l ls lt">#Setup Neural Net<br/>learn = cnn_learner(dls, resnet18, pretrained=True, loss_func = CrossEntropyLossFlat(), metrics=accuracy, model_dir="/tmp/model/")</span></pre><p id="034a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使用功率转移学习，我们可以将<strong class="is hj"> <em class="lu">预训练</em> </strong>参数设置为<strong class="is hj">真</strong>，尽管默认情况下它是真的。由于我们希望有一个分类器可以对两个以上的类别进行分类，但每个图像仅限于一个标签，因此我们将使用<a class="ae jo" href="https://ml-cheatsheet.readthedocs.io/en/latest/loss_functions.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">交叉熵</strong> </a>作为我们的损失函数。这里fastai将再次根据我们的数据块选择适当的损失函数，这里我们特别定义了参数<strong class="is hj"> <em class="lu"> blocks </em> </strong>以包含图像和类别的块(<em class="lu">参见步骤4 </em>)。请记住，计算机需要损失函数来计算梯度，而精确度是我们人类可以理解和解释的度量。</p><h1 id="a03d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">第六步:训练神经网络</h1><p id="8cb6" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在我们开始训练神经网络之前，我们可以使用学习率查找器来选择合适的学习率:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="7361" class="lp jq hi ll b fi lq lr l ls lt">learn.lr_find()</span></pre><p id="2899" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出</strong>:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/4adbf026e2d24d8378ca3c1c4f9007a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*shPetMe77N8O7aWjvReozQ.png"/></div></figure><p id="0b8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个好的经验法则是选择接近最陡负斜率的学习率，最陡负斜率接近最小值，但不是最小值本身。在本例中，我们将选择lr = 1e-2。</p><blockquote class="lv lw lx"><p id="b1ea" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated"><strong class="is hj">基本原理</strong>:开始训练模型，同时将学习率从很低提高到很大，当损失开始真正失控时停止。绘制损失与学习率的关系图，选择一个比最小值稍大的值，此时损失仍会改善。</p></blockquote><p id="b333" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有关学习率查找器的更多信息，请参考莱斯利·n·史密斯的<a class="ae jo" href="https://arxiv.org/abs/1506.01186" rel="noopener ugc nofollow" target="_blank">这篇论文</a>。</p><ol class=""><li id="ecce" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn md ky kz la bi translated"><strong class="is hj">培训</strong></li></ol><p id="2689" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们将使用<a class="ae jo" href="https://arxiv.org/pdf/1803.09820.pdf" rel="noopener ugc nofollow" target="_blank">一次循环训练策略</a>训练神经网络15个时期，并监控<em class="lu">training _ loss</em>以及<em class="lu"> validation_loss </em>以确保我们没有欠拟合或过拟合:</p><blockquote class="lv lw lx"><p id="0e7a" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated"><strong class="is hj">单周期策略</strong>:首先将学习速率缓慢增加到最大值(由学习速率探测器提供),然后再次降低，这样可以更快地训练复杂网络，并且精度相同或更高</p></blockquote><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d5ca" class="lp jq hi ll b fi lq lr l ls lt">lr = 1e-2<br/>learn.fit_one_cycle(15, lr)</span></pre><p id="c38f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出</strong>:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es me"><img src="../Images/6a174e4e4e806fd4406a091dbed608be.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*snFLdb2shPEdvlLGqRcWsA.png"/></div></figure><p id="cd33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果显示，经过15个时期的训练，我们实现了96.67%的分类准确率，因此已经超过了2017年的最高水平。然而，我们可以做得更好。默认情况下，18层ResNet-18的起始层是冻结的，这意味着我们的训练不会影响这些层，相应的权重也不会更新。我们可以解冻这些层来训练完整的神经网络:</p><blockquote class="lv lw lx"><p id="96f7" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated"><strong class="is hj">微调:</strong>微调是一个过程，采用一个已经为给定任务训练过的网络模型，并使其执行第二个类似的任务。</p></blockquote><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="c20b" class="lp jq hi ll b fi lq lr l ls lt">learn.unfreeze()</span></pre><p id="554b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们可以使用学习率查找器选择一个新的学习率:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5467" class="lp jq hi ll b fi lq lr l ls lt">learn.lr_find()</span></pre><p id="7813" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出:</strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/85adfa31a02e67f3b94dfa53ed6d29a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*YtWh_D-TIV7NZXvoZ03M3g.png"/></div></figure><p id="8ed9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于第一层现在已经解冻，我们将使用区别学习率，这意味着第一层将以较低的学习率进行训练，而需要适应我们特定领域的最后一层将以较高的学习率进行训练。我们可以通过提供一个包含(min_lr和max_lr)的slice对象来告诉fastai使用区别学习率:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="e9eb" class="lp jq hi ll b fi lq lr l ls lt">learn.fit_one_cycle(7, lr_max=slice(10e-6, 1e-4))</span></pre><p id="0af4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出:</strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/12d6e3e3f020cf6bb45c6d2c33c79f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*WAS1i46Tff6rQiXNfG8uCQ.png"/></div></div></figure><p id="550e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们所看到的，我们的最终精度达到了<strong class="is hj"> 97.08 </strong> %。在这一点上，我们对结果感到满意。如果<em class="lu"> train_loss </em>比<em class="lu"> valid_loss稍小，不要对出现的轻微过拟合感到吃惊。</em>一些深度学习理论家可能会反对这一点，但在实践中，稍微过度适应实际上是好的。我们最终感兴趣的是我们的度量(这里是准确度)尽可能高，并且有效损失尽可能低。</p><h1 id="66ef" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">第七步:分析结果</h1><p id="fd6c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">分析结果的一种方法是查看混淆矩阵。</p><blockquote class="lv lw lx"><p id="86ac" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">混淆矩阵:混淆矩阵，也称为误差矩阵，是一种特定的表格布局，允许算法性能的可视化。矩阵的每一行代表预测类中的实例，而每一列代表实际类中的实例</p></blockquote><p id="2afe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于数据集有28个类，分析混淆矩阵有点麻烦。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9575" class="lp jq hi ll b fi lq lr l ls lt">interp = ClassificationInterpretation.from_learner(learn)<br/>interp.plot_confusion_matrix(figsize=(12,12), dpi=60)</span></pre><p id="1453" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出:</strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/74edd271186f85351e87baddc40d06d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*nMe6Orq3i4mEAmMcu4K_Lg.png"/></div></figure><p id="15a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了矩阵，我们还可以只查看最常相互混淆的类别:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d4b7" class="lp jq hi ll b fi lq lr l ls lt">interp.most_confused(min_val=3)</span></pre><p id="9e6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出:</strong></p><p id="16c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[('zain '，' reh '，7)、(' qaf '，' feh '，6)、(' noon '，' teh '，5)、(' zah '，' tah '，5)、(' seen '，' sad '，4)、(' thal '，' dal '，4)、(' thal '，' zain '，4)、(' ain '，' khah '，3)、(' dad '，' sad '，3)、(' dal '，' reh '，3)、(' feh '，' qaf '，3)、(' teh '，' noon '，3)、(' theh '，' teh '，3)、(' zain</p><p id="8f6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们可以查看导致最高损失或对降低模型准确性贡献最大的分类:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="a930" class="lp jq hi ll b fi lq lr l ls lt">interp.plot_top_losses(9, figsize=(10,10))</span></pre><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/69f50cabdf7a6942d51d949fabf8a01d.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*m53spYQMxux95Z4hFfv3CQ.png"/></div></figure><p id="f2f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在与以阿拉伯语为母语的人交谈后，我们发现清理数据集将显著提高准确性，因此许多字符写得很差。在谷歌上快速搜索证实，上面输出的第一幅图像(feh/noon)也可能被人类错误地分类。</p><h1 id="8090" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">最后的话</h1><p id="d427" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">没有遗言。只要上GitHub，克隆这个<a class="ae jo" href="https://github.com/AnelMusic/Arabic_MNIST_Character_Classification" rel="noopener ugc nofollow" target="_blank">库</a>，你就可以开始了。</p><p id="d14f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你喜欢它。</p></div></div>    
</body>
</html>