<html>
<head>
<title>Segmentation of Products using OpenCV — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 OpenCV 进行产品细分—第 2 部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/segmentation-of-products-using-opencv-part-2-5095867683e4?source=collection_archive---------8-----------------------#2020-12-11">https://medium.com/analytics-vidhya/segmentation-of-products-using-opencv-part-2-5095867683e4?source=collection_archive---------8-----------------------#2020-12-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" rel="noopener" href="/analytics-vidhya/segmentation-of-products-using-opencv-part-1-4d5829679849">第一部分</a>中，我们采用原始图像，在 Canny 检测器中对灰度图像进行了不同阈值的实验，最终观察到了一些好的结果，图像的“R”、“G”和“B”带明显分叉。为了更好地理解，请在继续之前阅读我的第 1 部分。</p><p id="5498" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天，我们将检测每篇文章的确切区域，并使用不同的颜色将其分割出来。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="bb5a" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">检测篇</strong></h1><p id="5398" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们如何检测文章？。一种方式可以是使用简单的轮廓检测技术来检测物品的外部区域，并且近似检测到的轮廓以形成矩形框。另一种方式可以是使用预训练的深度学习(DL)来直接检测区域。DL 和简单的基本 OpenCV 方法的使用基于您正在处理的问题陈述。假设你想分割人、信号柱、树、猫、汽车、自行车等。在自动驾驶汽车的应用中，我们需要采用 DL 方法，因为汽车必须每隔几秒钟就对帧进行一次操作，以将您安全地驾驶到目的地。在这个应用程序中，我们只是试图从标准图像中检测 5 篇文章，所以我更喜欢前者。</p><p id="494a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进行膨胀以增强 canny 检测的图像</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="48ed" class="kx jm hi kt b fi ky kz l la lb">import cv2<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>image = cv2.cvtColor(cv2.imread(‘sample image.jpg’), cv2.COLOR_BGR2RGB)</span><span id="f312" class="kx jm hi kt b fi lc kz l la lb">gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)<br/>gray = cv2.GaussianBlur(gray,(3,3),0)</span><span id="07a4" class="kx jm hi kt b fi lc kz l la lb">img = image[:,:,2]<br/>img = cv2.Canny(img,60,200)</span><span id="8c42" class="kx jm hi kt b fi lc kz l la lb">kernel = np.ones((5,5),np.uint8)<br/>dilation = cv2.dilate(img,kernel,iterations = 5)<br/>plt.imshow(dilation,’gray’)</span></pre><div class="ko kp kq kr fd ab cb"><figure class="ld le lf lg lh li lj paragraph-image"><img src="../Images/2d9613255aa6cfacd9e4ac542c76ba26.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*bxNTnBGZaSq1xYeTWDyPKg.png"/></figure><figure class="ld le lf lg lh li lj paragraph-image"><img src="../Images/405d17e9fc280d6e5ba9e00d09ad8464.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*a6lNl5TSWrL5tIBPMinq5w.png"/><figcaption class="lm ln et er es lo lp bd b be z dx lq di lr ls translated">原始和放大图像</figcaption></figure></div><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a70c" class="kx jm hi kt b fi ky kz l la lb">orig = image.copy()<br/>cnts = cv2.findContours(dilation.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)<br/>cnts = imutils.grab_contours(cnts)<br/>cnts = sorted(cnts, key= cv2.contourArea, reverse=True)[:5]<br/>for c in cnts:<br/> peri = cv2.arcLength(c,True)<br/> apprx = cv2.approxPolyDP(c, 0.1*peri, True)<br/> x,y,w,h = cv2.boundingRect(apprx)<br/> cv2.rectangle(orig,(x,y),(x+w,y+h),(0,255,0),5)<br/>plt.imshow(orig)</span></pre><figure class="ko kp kq kr fd le er es paragraph-image"><div class="er es lt"><img src="../Images/0a3c7b4b13cada4b6dbae0228630c202.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*IYByQs4fks7Y7qnR722-8w.png"/></div></figure><p id="1281" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以看到文章用一个矩形框起来，上面的两篇文章被框起来作为一个整体，因为它们足够接近，轮廓无法检测到这两篇文章的分离，所以 thumps up 被框得很小。用正确的阈值进一步增强图像将有助于更好的检测。</p><p id="8352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用不同的颜色给每个识别的区域着色使其分段</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="255e" class="kx jm hi kt b fi ky kz l la lb">colors = [(236, 18, 41),(142, 30, 164),(130, 114, 239),(247, 89, 30),(119, 186, 243)]<br/>orig = image.copy()<br/>cnts = cv2.findContours(dilation.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)<br/>cnts = imutils.grab_contours(cnts)<br/>cnts = sorted(cnts, key= cv2.contourArea, reverse=True)[:4]<br/>count = 0<br/>for c in cnts:<br/> peri = cv2.arcLength(c,True)<br/> apprx = cv2.approxPolyDP(c, 0.1*peri, True)<br/> x,y,w,h = cv2.boundingRect(apprx)<br/> cv2.rectangle(orig,(x,y),(x+w,y+h),colors[count],-1)<br/> count+=1<br/>plt.imshow(orig)<br/>plt.axis(‘off’)<br/>plt.show()</span></pre><figure class="ko kp kq kr fd le er es paragraph-image"><div class="er es lt"><img src="../Images/0a4dab94b6ea08d264bf00deaba7e9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*CZVYuwi_kDBFeE1xyDleAw.png"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">分割图像</figcaption></figure><p id="9868" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">坚持读书学习！！！明天会想出一些有趣的话题:-)敬请期待…！</p></div></div>    
</body>
</html>