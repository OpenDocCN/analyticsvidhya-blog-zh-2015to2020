<html>
<head>
<title>Sniffing a system from outside a network: TCP reverse shell + ARP poisoning using Scapy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从网络外部嗅探系统:TCP反向外壳+使用Scapy的ARP中毒</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sniffing-a-system-from-outside-a-network-tcp-reverse-shell-arp-poisoning-using-scapy-77a57b545cf6?source=collection_archive---------7-----------------------#2020-06-30">https://medium.com/analytics-vidhya/sniffing-a-system-from-outside-a-network-tcp-reverse-shell-arp-poisoning-using-scapy-77a57b545cf6?source=collection_archive---------7-----------------------#2020-06-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/142ce2462d94eade0989b6014203ec67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*S9bwMx3SXgCGW0_4_T0vmg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">来源:<a class="ae iq" href="https://resources.infosecinstitute.com/hacker-tools-sniffers/#gref" rel="noopener ugc nofollow" target="_blank">https://resources . infosec institute . com/hacker-tools-sniffers/# gref</a></figcaption></figure><p id="598e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在网络中嗅探只是监视网络流量并从中提取感兴趣的信息。为了理解嗅探的基础知识，有必要了解本地网络是如何工作的。随着世界上系统/节点数量的不断增加，IPv4地址不足以唯一识别连接到互联网的所有系统。因此，某些被称为<em class="jp">不可路由地址</em>的IP地址空间被用于标识本地网络中的节点，所有这些节点都通过网关与外部世界通信。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jq"><img src="../Images/cf636e62d220615bd302166685361468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*193gvD_43tzKQFIqqsb0Vw.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">网关。来源:<a class="ae iq" href="https://bytesofgigabytes.com/networking/what-is-gateway-in-networking/" rel="noopener ugc nofollow" target="_blank">https://bytesofgigabytes . com/networking/what-is-gateway-in-networking/</a></figcaption></figure><p id="17bc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">从外部世界的角度来看，所有流量都来自和去往网关，然后网关进行操作，使得流量被传递到本地网络内的原始节点。几个概念如<a class="ae iq" href="https://en.wikipedia.org/wiki/Network_address_translation" rel="noopener ugc nofollow" target="_blank"> NAT </a>和<a class="ae iq" href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol" rel="noopener ugc nofollow" target="_blank"> ARP </a>(或IPv6情况下的替代邻居发现协议)正在发挥作用。我们对维护定期更新的MAC-IP映射表的ARP(地址解析协议)感兴趣。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/a70c18ffe72610f26f2f5329692c9a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*w9bsVAC1MWbP3ZsU5XTV8Q.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">将IPv4地址映射到MAC地址的ARP表示例</figcaption></figure><p id="7654" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">唯一的MAC地址可以被视为硬件地址，而IPv4地址是在节点加入网络后动态分配的。当接收到传入的网络流量时，网关使用NAT将目的IP地址转换为其本地IPv4地址之一。然后，它在ARP表中查找相应的MAC地址，用最近发现的MAC地址创建一个新的以太网层，并发送数据包。</p><p id="d84b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们正在寻找嗅探这样的交通。来自网络之外！！！</p><h1 id="85d1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">攻击概述</h1><p id="a408" class="pw-post-body-paragraph ir is hi it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hb bi translated">TCP反向外壳已在本文的<a class="ae iq" rel="noopener" href="/swlh/python-tcp-reverse-shell-compromising-a-kali-machine-using-a-mac-6449b8684836">中进行了解释和演示。因此，我们在本文中重点讨论ARP。</a></p><p id="7468" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">根据对ARP和NAT的讨论，出现了以下ARP中毒的可能性(这种攻击被防火墙检测到，并且在邻居发现协议的情况下是无效的)。然而，在我们的例子中，保护整个网络的防火墙将无法检测到任何异常，因为与外部的连接首先是从网络内部请求的(TCP反向外壳)。保护目标节点流量的自定义防火墙将能够检测到异常情况。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ld"><img src="../Images/3146cb1c822bbf90b41f08f9ae492447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utB0ku8wGhhXn9XZjMac-w.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">来源:https://tournasdimitrios1.wordpress.com/2011/02/08/4426/</figcaption></figure><p id="3ea6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这种情况下，Bob和Alice的ARP表与交换机(网关)通信。现在来了一个攻击者，他发起ARP病毒攻击(也称为MIT或中间人攻击),这样他们修改Bob、Alice和交换机的ARP缓存，如下所示:</p><ol class=""><li id="1051" class="le lf hi it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm bi translated"><strong class="it hj">交换机ARP: </strong>鲍勃的IP →攻击者MAC</li><li id="0bf9" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated"><strong class="it hj">交换机ARP: </strong>爱丽丝的IP →攻击者MAC</li><li id="577b" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated"><strong class="it hj"> Bob的ARP: </strong>交换机的IP →攻击者的MAC</li><li id="cd6e" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated"><strong class="it hj">爱丽丝的ARP: </strong>交换机的IP →攻击者的MAC</li></ol><p id="bc8a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">很明显，缓存中毒，认为系统试图与之通信的节点实际上位于攻击者的硬件目的地。例如，如果Bob必须向交换机发送数据包，他们将发送到交换机的IP地址(这是正确的),该地址又转到攻击者的IP地址(由于中毒/不正确的映射)。然后，攻击者嗅探数据包，根据需要进行修改，然后转发给交换机。</p><p id="fa7b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> IP转发</strong> ( <a class="ae iq" href="https://linuxconfig.org/how-to-turn-on-off-ip-forwarding-in-linux" rel="noopener ugc nofollow" target="_blank">启用/禁用方法</a>)在攻击者的机器上启用，并允许将发往交换机IP的传入数据包转发到交换机。因此，如果没有防火墙，Bob在浏览互联网时不会遇到任何异常，而实际上他们的网络流量是通过代理转发的。</p><h2 id="6d85" class="ls kb hi bd kc lt lu lv kg lw lx ly kk jc lz ma ko jg mb mc ks jk md me kw mf bi translated">但是在网络之外呢？</h2><p id="fa43" class="pw-post-body-paragraph ir is hi it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hb bi translated">这种攻击是从本地网络内部进行的。攻击者必须连接到同一个网关。我们更希望从网络外部进行监听。以下简单的组合效果很好:</p><ol class=""><li id="a120" class="le lf hi it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm bi translated">在目标网络中的<em class="jp">低挂果实</em>上打开TCP反向外壳。您有权访问或可以设计让TCP反向外壳运行的节点/系统。设此节点为<em class="jp"> M. </em></li><li id="2a79" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated">发现本地网络中的节点，并识别目标。设此节点为<em class="jp"> T. </em></li><li id="1d02" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated">从<em class="jp"> M </em>到<em class="jp"> T，</em>进行ARP中毒，利用TCP反向外壳将信息传递给攻击者。</li></ol><p id="7494" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">可以跨网络管理TCP反向外壳。</p><h2 id="8a50" class="ls kb hi bd kc lt lu lv kg lw lx ly kk jc lz ma ko jg mb mc ks jk md me kw mf bi translated">工具/库使用说明</h2><p id="8be6" class="pw-post-body-paragraph ir is hi it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hb bi translated">确实有一些工具可以在你的终端上用简单的命令启动，你可以导入和调用函数/方法来减少你的代码量。在抽象和底层材料之间有一个微妙的权衡:<em class="jp">更多的底层材料迫使你处理它们核心的大量问题，从而在减缓开发速度的同时暴涨学习，而抽象的工具/库可能会停滞学习。</em></p><p id="413b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">决定你学习道路上的最佳点是一项重要的任务。您可以使用工具/库来简单快速地实现下面描述的所有功能，或者您可以从零开始编写所有代码。这完全取决于你在学习抽象之前对基础知识的理解程度。至于这篇文章，我们坚持使用纯Python和套接字实现TCP反向shell，但是求助于Scapy来实现ARP中毒(或者一般来说，为了更快地创建和解析包，这在纯Python中是很麻烦的)。我们仍然限制执行ARP中毒攻击的内置Scapy函数。</p><h1 id="a6b5" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">设置TCP反向外壳</h1><p id="2d44" class="pw-post-body-paragraph ir is hi it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hb bi translated"><a class="ae iq" rel="noopener" href="/swlh/python-tcp-reverse-shell-compromising-a-kali-machine-using-a-mac-6449b8684836">文章</a>详细解释了设置TCP反向外壳的机制。然而，这是针对同一网络内的通信。要跨网络进行通信，只需很少的更改。</p><p id="26ca" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">第一点是发现攻击者的全局IP。在终端输入<code class="du mg mh mi mj b">hostname -I</code>或<code class="du mg mh mi mj b">ifconfig</code>(或者如果不起作用，访问<a class="ae iq" href="https://whatismyipaddress.com" rel="noopener ugc nofollow" target="_blank">https://whatismyipaddress.com</a>)。为此，我们将使用IPv6地址。</p><figure class="jr js jt ju fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="im in et er es io ip bd b be z dx translated">TCP反向外壳的目标端脚本的更改</figcaption></figure><p id="186f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">以下更改就足够了。在将<code class="du mg mh mi mj b">AF_INET6</code>套接字绑定到端口<code class="du mg mh mi mj b">12345</code>之前，对攻击者端脚本进行同样的更新。按照本文<a class="ae iq" rel="noopener" href="/swlh/python-tcp-reverse-shell-compromising-a-kali-machine-using-a-mac-6449b8684836">帖子</a>所述进行测试，连接工作正常。</p><h1 id="cc77" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">发现本地网络中的节点</h1><p id="7047" class="pw-post-body-paragraph ir is hi it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hb bi translated">下一步是从我们打开TCP反向外壳的机器上发现本地网络中的节点。在继续之前，请务必熟悉Scapy的<a class="ae iq" href="https://scapy.readthedocs.io/en/latest/usage.html" rel="noopener ugc nofollow" target="_blank">基础知识</a>。</p><figure class="jr js jt ju fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="im in et er es io ip bd b be z dx translated">发现本地网络上的节点</figcaption></figure><p id="4b5b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里我们看到了Scapy在包操作中的强大功能。参考以下格式。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es if"><img src="../Images/e38e8c938f1fe00b4b2982548dbe6ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*h4U9ReEle9hTPcc4f49KYg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">ARP数据包格式。来源:<a class="ae iq" href="https://support.huawei.com/enterprise/en/doc/EDOC1000166600/6bb92fd8/arp-implementation" rel="noopener ugc nofollow" target="_blank">https://support . Huawei . com/enterprise/en/doc/edoc 1000166600/6bb 92 FD 8/ARP-implementation</a></figcaption></figure><p id="a45e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如前所述，我们首先创建<code class="du mg mh mi mj b">Ethernet</code>层，它可以被视为包含源和目的MAC地址的硬件层。<code class="du mg mh mi mj b">Ethernet(dst=)</code>用于创建具有目的地<code class="du mg mh mi mj b">ff:ff:ff:ff:ff:ff</code>或未指定的MAC地址的层(因此，该数据包被ping到本地网络中基于第二层<code class="du mg mh mi mj b">ARP</code>进行应答的所有节点)。第二层控制哪些节点响应数据包。如果节点在ARP层(格式的<code class="du mg mh mi mj b">IP address of destination</code>部分)找到它们的IP地址，它们就应答<code class="du mg mh mi mj b">ARP</code>包。<code class="du mg mh mi mj b">srp</code>用于发送数据包和接收响应(<code class="du mg mh mi mj b">timeout</code>表示发送和接收持续的时间)。<code class="du mg mh mi mj b">ans</code>(或应答的数据包)是一个漂亮的元组列表，其中每个元素都是一个元组，包含发送的数据包和接收的相应响应。<code class="du mg mh mi mj b">received[ARP]</code>访问接收到的数据包的ARP层，之后我们可以提取任何需要的信息:</p><ol class=""><li id="76bc" class="le lf hi it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm bi translated"><code class="du mg mh mi mj b">psrc</code>:协议源(或源IP地址)</li><li id="ed64" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated"><code class="du mg mh mi mj b">pdst</code>:协议目的地(或目的IP地址)</li><li id="4df8" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated"><code class="du mg mh mi mj b">hwsrc</code>:硬件源(或源MAC地址)</li><li id="3ae1" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated"><code class="du mg mh mi mj b">hwdst</code>:硬件目的地(或目的MAC地址)</li></ol><p id="d905" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">目前，我们关心的是IP地址。因此有了术语<code class="du mg mh mi mj b">received[ARP].psrc</code>。既然我们知道了接收节点会应答ARP数据包<em class="jp">当且仅当</em>在<code class="du mg mh mi mj b">ARP()</code>中它们的地址被称为<code class="du mg mh mi mj b">pdst</code>时，我们指定一个IP地址范围，向所有节点发送数据包，并接受响应。</p><p id="b3bb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">启动一个终端，输入<code class="du mg mh mi mj b">ifconfig | grep inet</code>或类似的命令，显示你的机器的IP地址和子网掩码。样本响应的类型为:<code class="du mg mh mi mj b">inet 192.168.43.34 netmask 0xffffff00 broadcast 192.168.43.255</code>。由此，启动脚本并调用函数<code class="du mg mh mi mj b">discovery('192.168.43.1/24', 10)</code>。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/25372176c14ecd77be3f7679225fc2ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*-vuOfjOjA2xEQxFO0cUy-A.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">发现功能的示例响应。两个节点响应了。地址192.168.43.38是一个新条目。</figcaption></figure><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/29ba67d2a8e79db1bc1dee3074d6b7ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*o2qYeZAd3bpkNXofTF5H0A.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">请注意ARP表中的更新</figcaption></figure><h1 id="4e20" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">ARP病毒攻击</h1><p id="c0c0" class="pw-post-body-paragraph ir is hi it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hb bi translated">攻击分以下几个阶段进行(确保<a class="ae iq" href="https://linuxconfig.org/how-to-turn-on-off-ip-forwarding-in-linux" rel="noopener ugc nofollow" target="_blank">启用IP转发</a>):</p><ol class=""><li id="cd58" class="le lf hi it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm bi translated">获取网关和目标的MAC</li><li id="1e6f" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated">毒害和嗅嗅</li><li id="2718" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated">恢复:覆盖ARP表中的磁道。</li></ol><figure class="jr js jt ju fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="im in et er es io ip bd b be z dx translated">发现指定IP地址的MAC地址</figcaption></figure><p id="ce54" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du mg mh mi mj b">ff:ff:ff:ff:ff:ff</code>通过问题<code class="du mg mh mi mj b">who-has ip_address</code>向所有硬件地址广播该数据包。我们得到一个带有答案<code class="du mg mh mi mj b">is_at hwsrc</code>的数据包作为响应。我们提取接收到的包的硬件地址，因为这个硬件地址响应了我们的<code class="du mg mh mi mj b">ARP</code>包。</p><figure class="jr js jt ju fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="im in et er es io ip bd b be z dx translated">毒害ARP缓存</figcaption></figure><p id="23cd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du mg mh mi mj b">op</code>是一个我们不太关心的选项。中毒过程如下:</p><p id="c056" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">1 .<strong class="it hj">【目标至网关】:</strong>网关接收到一个数据包，该数据包表示</p><p id="8460" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">a) <code class="du mg mh mi mj b">hwdst</code>或目的MAC作为网关MAC。网关知道该分组是针对它的。同样，<code class="du mg mh mi mj b">pdst</code>也可以，或者IP是网关的IP。</p><p id="130f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">b) <code class="du mg mh mi mj b">hwsrc</code>是否为<strong class="it hj">留空。</strong>发送时，攻击者机器的MAC填入该字段。</p><p id="900d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">c) <code class="du mg mh mi mj b">psrc</code>是目标机器的IP。现在网关检查它的ARP表，发现<code class="du mg mh mi mj b">psrc</code>和<code class="du mg mh mi mj b">hwsrc</code> <strong class="it hj">不匹配。因此，它更新了表格。</strong></p><p id="ede2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">同样，<strong class="it hj">【通往目标】</strong>路线中毒。主要思想是伪造一个包，它携带一台机器的源IP和另一台机器的源MAC。接收节点会注意到这一差异，并更新ARP表。</p><figure class="jr js jt ju fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="im in et er es io ip bd b be z dx translated">嗅探器</figcaption></figure><p id="3e27" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">一旦中毒完成，我们就为<code class="du mg mh mi mj b">ip host target_ip</code>或来自<code class="du mg mh mi mj b">source target_ip</code>的通过攻击者机器的所有数据包设置一个嗅探器。因此，我们捕获来自目标的所有数据包，并在一个由<code class="du mg mh mi mj b">prn</code>引用的函数中对数据包执行操作(或者在嗅到有效数据包时做什么)。功能<code class="du mg mh mi mj b">callback</code>很简单；它寻找相关层，捕获信息，并将其写入变量。</p><p id="e764" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在我们完成攻击后，恢复就完成了。</p><figure class="jr js jt ju fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="im in et er es io ip bd b be z dx translated">修复工作</figcaption></figure><p id="9c3e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">还原类似于中毒；在某种程度上，我们代表网关和目标进行<strong class="it hj">发现调用。中毒后，假设从<strong class="it hj">网关到目标</strong>的每个数据包都被发送到攻击者的硬件地址。我们通过<strong class="it hj">代表网关发出一个发现/ARP调用来解决这个问题，这个调用试图发现目标的硬件地址</strong>；或者用<code class="du mg mh mi mj b">hwdst="ff:ff:ff:ff:ff:ff"</code>制作一个从网关到目标的数据包(源IP和MAC是网关的，目的IP还是以前的目标)。<code class="du mg mh mi mj b">hwdst</code>设置为<code class="du mg mh mi mj b">broadcast</code>只是为了当目标机(或<code class="du mg mh mi mj b">pdst</code>)响应ARP请求时，网关接收到目标MAC为<code class="du mg mh mi mj b">hwsrc</code>的ARP响应。网关再次查看ARP表，发现<code class="du mg mh mi mj b">hwsrc</code>(在中毒阶段设置为攻击者MAC)和<code class="du mg mh mi mj b">psrc</code>(设置为目标IP)之间不匹配。网关解决这个问题；网关的ARP就这样恢复了。</strong></p><p id="6088" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">类似的恢复是通过代表目标发出一个ARP调用来完成的，该调用寻找网关的硬件地址。有趣的是，由于我们已经指定了<code class="du mg mh mi mj b">hwsrc</code>并设置为<code class="du mg mh mi mj b">hwdst</code>到<code class="du mg mh mi mj b">broadcast</code>，尽管我们从攻击者的机器发出这个调用，但是响应还是会按照<code class="du mg mh mi mj b">psrc</code> / <code class="du mg mh mi mj b">hwsrc</code>的指定发送到网关或目标。注意与发现阶段的区别，在发现阶段<code class="du mg mh mi mj b">hwsrc</code>和<code class="du mg mh mi mj b">psrc</code>被设置为攻击者的机器，因此响应到达攻击者。</p><blockquote class="mo mp mq"><p id="e5cb" class="ir is jp it b iu iv iw ix iy iz ja jb mr jd je jf ms jh ji jj mt jl jm jn jo hb bi translated">因此，有可能在一个系统中创建分组，其响应被另一个系统接收。正是这一点有助于恢复。</p></blockquote><h1 id="e025" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">集成TCP反向外壳和ARP病毒脚本</h1><figure class="jr js jt ju fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="im in et er es io ip bd b be z dx translated">更新了运行命令方法</figcaption></figure><p id="dfa9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">修改来自<a class="ae iq" rel="noopener" href="/swlh/python-tcp-reverse-shell-compromising-a-kali-machine-using-a-mac-6449b8684836"> TCP反向外壳</a>的<code class="du mg mh mi mj b">run_command</code>方法，以处理两个独立的命令<code class="du mg mh mi mj b">poison</code>和<code class="du mg mh mi mj b">discover</code>。<code class="du mg mh mi mj b">entry</code>函数集合了ARP中毒脚本的所有部分。</p><figure class="jr js jt ju fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="im in et er es io ip bd b be z dx translated">主要功能集成了ARP病毒攻击的所有组件</figcaption></figure><p id="271d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">很明显，攻击的三个阶段是按顺序进行的。</p><h1 id="bed1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">样品运行</h1><p id="f3e8" class="pw-post-body-paragraph ir is hi it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hb bi translated">网络设置如下:</p><ol class=""><li id="5daa" class="le lf hi it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm bi translated">网络A:</li></ol><p id="f2a8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">a)网关:WiFi热点，<strong class="it hj"> Moto G6 </strong></p><p id="9487" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">b) TCP反壳:<strong class="it hj"> Macbook Air </strong>接<strong class="it hj"> moto G6 </strong></p><p id="4ecf" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">c)目标:<strong class="it hj"> Redmi </strong>连接到<strong class="it hj"> Moto G6 </strong></p><p id="f855" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">2.网络B:</p><p id="d380" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">a)网关:WiFi热点；<strong class="it hj">三星</strong></p><p id="c4f1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">b)攻击者:<strong class="it hj">HP</strong>T19】Kali Linux</p><p id="6b1b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">攻击者通过攻击者的全局IP地址在Macbook上打开一个TCP反向外壳。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es mu"><img src="../Images/e61d895e7e3f9ea42c271af4f3fdc6b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vmdbk648O5wjJxwgmq4rfw.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">攻击者的网关信息。注意标志G表示网关。</figcaption></figure><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/490e8e83eac0770ecff97ccb1aa86ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*GjwqAyr51jQR6KzmAJ2tfA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">TCP反向外壳目标的网关信息。注意标志G表示网关。</figcaption></figure><p id="32a2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">攻击者发出的发起攻击的一系列命令。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es mw"><img src="../Images/92e69c7a1f39e886e822581c50555705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwTZistqm-WNrrMQwYc1-Q.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">攻击者端命令</figcaption></figure><p id="e6f4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">使用<code class="du mg mh mi mj b">ifconfig</code>和<code class="du mg mh mi mj b">netstat</code>确定目标网络配置，主要是<code class="du mg mh mi mj b">netmask</code>和<code class="du mg mh mi mj b">inet</code>地址。使用这个信息，触发一个<code class="du mg mh mi mj b">discover 192.168.43.1/24 10</code>，其中第一个参数表示要发现的目标地址范围，第二个参数表示超时。我们收到三个响应，在研究ARP表时，发现一个<code class="du mg mh mi mj b">redminote5pro-redmi</code>位于<code class="du mg mh mi mj b">192.168.43.125</code>。我们从Macbook Air向Redmi发起ARP病毒攻击，并将嗅到的数据传输回位于本地网络外部的Kali节点。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/e0314ecb946c0691aa3fce3c6545d2c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*O1InQUKbKxUXQqXsFSIzzg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">在攻击者的机器上嗅探数据包的数据</figcaption></figure><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es my"><img src="../Images/1d32af329f9c0f9a22e0bf1c0b49c1ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*WZit-tiL42Gi3NqSTcMT7w.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">在TCP反向外壳目标上执行的命令。</figcaption></figure><h1 id="0622" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="e858" class="pw-post-body-paragraph ir is hi it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hb bi translated">有些事情需要牢记在心。</p><ol class=""><li id="e231" class="le lf hi it b iu iv iy iz jc lg jg lh jk li jo lj lk ll lm bi translated">我们可能会尝试在Scapy中开发一个反向shell，但这是不可靠的，而且经常会崩溃。此外，与套接字路由相比，Scapy路由是不可靠的。参见<a class="ae iq" href="https://github.com/secdev/scapy/issues/1941" rel="noopener ugc nofollow" target="_blank">本</a></li><li id="ac96" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated">Scapy需要root权限才能打开原始套接字。要在TCP反向外壳目标上正确运行，请参考<a class="ae iq" href="https://stackoverflow.com/questions/36215201/python-scapy-sniff-without-root" rel="noopener ugc nofollow" target="_blank">和</a>(必须小心操作)。</li><li id="f5ab" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated">泄露MAC地址是个问题吗？参见<a class="ae iq" href="https://security.stackexchange.com/questions/67893/is-it-dangerous-to-post-my-mac-address-publicly" rel="noopener ugc nofollow" target="_blank">本</a>。</li><li id="4df5" class="le lf hi it b iu ln iy lo jc lp jg lq jk lr jo lj lk ll lm bi translated">一个主要问题是需要攻击者的IPv6地址来开始通信。IPv6地址会定期更改，我们需要一种机制让TCP反向外壳目标自动适应这种情况。截至目前，我还没想过克服这个。</li></ol><p id="41bd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">祝你今天开心！玩的开心！</p></div></div>    
</body>
</html>