<html>
<head>
<title>Writing a Dataloader for a custom Dataset (Neural Network) in Pytorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Pytorch中为自定义数据集(神经网络)编写数据加载器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/writing-a-custom-dataloader-for-a-simple-neural-network-in-pytorch-a310bea680af?source=collection_archive---------0-----------------------#2019-09-06">https://medium.com/analytics-vidhya/writing-a-custom-dataloader-for-a-simple-neural-network-in-pytorch-a310bea680af?source=collection_archive---------0-----------------------#2019-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b6215bb1a8980a7061c991f1e796938b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Q2qbWqE2GRcTzW6X3f0Wag.jpeg"/></div></div></figure><p id="269e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个博客是为那些已经在Pytorch教程中看到如何使用数据加载器，并且想知道如何为数据集编写自定义数据加载器的程序员而写的。我想每个人都会同意，按照框架/算法要求的格式收集、预处理和馈送数据是一项艰巨的任务。在这篇博客中，我们将专注于创建您自己的数据集，并准备好将数据批次(数据加载器)输入pytorch神经网络架构。</p><p id="bea7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在波士顿数据集上工作。你可以在这里下载数据集<a class="ae jo" href="https://github.com/bhuvanakundumani/pytorch_Dataloader/tree/master/data" rel="noopener ugc nofollow" target="_blank">。</a>这是根据美国人口普查局收集的马萨诸塞州波士顿地区的住房信息得出的。它有506个观察值，13个输入变量，1个ID列和1个输出/目标变量。MEDV是以千美元为单位的自有住房的中值。显然，这是一个回归问题，因为输出/目标变量是数字的(或连续的)。让我们下载程序所需的库。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9076" class="jy jz hi ju b fi ka kb l kc kd">import numpy as np<br/>import pandas as pd<br/>import os<br/>import torch<br/>import torch.nn as nn<br/>import torch.nn.functional as F<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.utils import shuffle<br/>from torch.utils.data import DataLoader, Dataset<br/>from torch.nn import functional as F<br/>from sklearn.metrics import accuracy_score</span></pre><p id="c02b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们要把这个转化成一个分类问题。让我们使目标变量离散或分类。我们可以在<a class="ae jo" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.cut.html" rel="noopener ugc nofollow" target="_blank">熊猫</a>中对数据帧的列进行桶或箱操作。我们将有两个标签为0和1的容器——介于(0–30)之间的值将为0，介于(30–50)之间的值将为1。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="70d9" class="jy jz hi ju b fi ka kb l kc kd">bins = [0,30,50]<br/>labels = [0,1]<br/>train_data[‘medv’] = pd.cut(train_data[‘medv’], bins=bins, labels=labels)<br/>print (train_data[‘medv’].head())<br/>print(train_data.head())</span></pre><p id="0f80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">列“chas”是一个分类变量，数据集中还有一个“ID”变量。我们不希望这些出现在我们的模型中。让我们将这些列放到我们的数据框架中。除了“chas”、“ID”和“medv”之外，数字特征将具有我们的所有特征。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b9da" class="jy jz hi ju b fi ka kb l kc kd">id_col = ['ID']<br/>categorical_features = ['chas'] <br/>target_feature = 'medv'</span><span id="65cc" class="jy jz hi ju b fi ke kb l kc kd">dropped_cols = id_col+categorical_features<br/>train_data = train_data.drop(dropped_cols, axis=1)<br/>all_features = train_data.columns.tolist()  #this will not have 'chas' and 'ID'</span><span id="5865" class="jy jz hi ju b fi ke kb l kc kd">numerical_features = list(set(all_features)- set([target_feature]))</span></pre><p id="5837" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要一个训练数据集和验证数据集来训练和测试我们的网络。我们可以使用Scikit Learn的train_test_split功能来实现同样的目的。最后，Train_data有我们的训练数据集，Valid_data有我们的验证数据集。我们的训练数据集有404个观察值，验证数据集有102个观察值。</p><p id="1cac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">pytorch中的<a class="ae jo" href="http://pytorch.org/docs/master/data.html#torch.utils.data.Dataset" rel="noopener ugc nofollow" target="_blank">数据集</a>类和<a class="ae jo" href="http://pytorch.org/docs/master/data.html#torch.utils.data.DataLoader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>类帮助我们将自己的训练数据输入网络。数据集类用于提供访问数据集中所有定型或测试样本的接口。为了实现这一点，您必须实现至少两个方法，<code class="du kf kg kh ju b">__getitem__</code>和<code class="du kf kg kh ju b">__len__</code>，以便每个训练样本都可以通过其索引来访问。在类的初始化部分，我们加载数据集(作为float类型)并将它们转换成Float torch张量。<code class="du kf kg kh ju b">__getitem__ </code>将返回特性和目标值。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="fd39" class="jy jz hi ju b fi ka kb l kc kd">class oversampdata(Dataset):</span><span id="574c" class="jy jz hi ju b fi ke kb l kc kd">   def __init__(self, data):<br/>        self.data = torch.FloatTensor(data.values.astype('float'))<br/>        <br/>   def __len__(self):<br/>        return len(self.data)</span><span id="7cac" class="jy jz hi ju b fi ke kb l kc kd">   def __getitem__(self, index):<br/>        target = self.data[index][-1]<br/>        data_val = self.data[index] [:-1]<br/>        return data_val,target</span><span id="e525" class="jy jz hi ju b fi ke kb l kc kd">train_dataset = oversampdata(Train_data)<br/>valid_dataset = oversampdata(Valid_data)</span></pre><p id="09a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然我们可以使用Dataset类访问所有的训练数据，但对于深度学习，我们需要批处理、洗牌、多进程数据加载等。DataLoader类帮助我们做到这一点。DataLoader类接受数据集和其他参数，如<code class="du kf kg kh ju b">batch_size</code>、<code class="du kf kg kh ju b">batch_sampler</code>和数量<code class="du kf kg kh ju b">workers</code>来加载数据。然后我们可以迭代<code class="du kf kg kh ju b">Dataloader</code>来获得一批训练数据并训练我们的模型。我们已经定义了Train_Batch_Size= 101和Test_Batch_size =61(因为我们在训练数据集中有404个观察值，在验证数据集中有102个观察值)</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="2da2" class="jy jz hi ju b fi ka kb l kc kd">device = "cuda" if torch.cuda.is_available() else "cpu"<br/>kwargs = {'num_workers': 1, 'pin_memory': True} if device=='cuda' else {}</span><span id="46f6" class="jy jz hi ju b fi ke kb l kc kd">train_loader = DataLoader(train_dataset, batch_size=Train_Batch_Size, shuffle=True, **kwargs)<br/>test_loader = DataLoader(valid_dataset, batch_size=Test_Batch_Size, shuffle=False, **kwargs)</span></pre><p id="8143" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果torch.cuda.is_available()，我们设置device ="cuda "。这使得程序可以根据GPU的可用性在GPU或CPU上运行。在kwargs中，我们将num_workers设置为1，将pin_memory设置为True。<code class="du kf kg kh ju b">num_workers</code>表示并行生成批次的流程数量。将<code class="du kf kg kh ju b">num_workers</code>设置为正整数将开启多进程数据加载，加载器工作进程的数量为指定数量。对于数据加载，将<code class="du kf kg kh ju b">pin_memory=True</code>传递给<code class="du kf kg kh ju b"><a class="ae jo" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader" rel="noopener ugc nofollow" target="_blank">DataLoader</a></code>会自动将提取的数据张量放入固定内存，从而使数据更快地传输到支持CUDA的GPU。</p><p id="fe26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们都准备好训练我们的模型了。同样的神经网络架构的细节将在下一篇<a class="ae jo" href="https://link.medium.com/PoCKEbES3Z" rel="noopener">中期文章中提供。</a>代码可从github-<a class="ae jo" href="https://github.com/bhuvanakundumani/pytorch_Dataloader" rel="noopener ugc nofollow" target="_blank">https://github.com/bhuvanakundumani/pytorch_Dataloader</a>获得</p><p id="247f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考资料:</p><div class="ki kj ez fb kk kl"><a href="https://stanford.edu/~shervine/blog/pytorch-how-to-generate-data-parallel" rel="noopener  ugc nofollow" target="_blank"><div class="km ab dw"><div class="kn ab ko cl cj kp"><h2 class="bd hj fi z dy kq ea eb kr ed ef hh bi translated">PyTorch数据加载器的详细示例</h2><div class="ks l"><h3 class="bd b fi z dy kq ea eb kr ed ef dx translated">pytorch数据加载器由Afshine Amidi和Shervine Amidi并行开发的大型数据集您是否曾经加载过这样的数据集…</h3></div><div class="kt l"><p class="bd b fp z dy kq ea eb kr ed ef dx translated">stanford.edu</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz io kl"/></div></div></a></div></div></div>    
</body>
</html>