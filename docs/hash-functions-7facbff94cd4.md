# 哈希函数

> 原文：<https://medium.com/analytics-vidhya/hash-functions-7facbff94cd4?source=collection_archive---------10----------------------->

哈希函数将键映射到小整数(桶)。理想的哈希函数以类似随机的方式将键映射到整数，这样即使输入数据中存在规律性，桶值也是均匀分布的。

这个过程可以分为两个步骤:

*   将键映射到一个整数。
*   将整数映射到一个桶。

将实际上不像整数的东西(例如复杂的记录结构)映射到整数是很棘手的。我们不讨论这个。相反，我们将假设我们的键要么是整数，即可以被视为整数的东西(例如，字符、指针)，要么是这些东西的 ID 序列(整数列表、字符串)。

选择一个好的散列函数 **h(k)** ，对于基于散列表的搜索是至关重要的。 **h** 应该尽可能均匀地将集合的元素分布到散列表的“槽”中。关键的标准是应该有最小数量的冲突。

如果关键字 **k** 在我们的集合中出现的概率是 **P(k)** ，那么如果在我们的哈希表中有 **m** 个槽，一个*统一哈希函数*、 **h(k)** 将确保:

![](img/035166070dbc0e7cf2ced689a756bd2b.png)

有时候，这很容易保证。例如，如果密钥随机分布在(0， **r** )中，那么，

**h(k) = floor((mk)/r)** 将提供统一散列。

# **简单哈希函数:————**

以下函数将单个整数键(k)映射到一个小整数桶值 h(k)，m 是哈希表的大小(桶的数量)。

**除法**(科尔曼) **:** 选择一个不接近 2 的幂的质数， **h(k) = k mod m.** 对于输入数据中的许多类型的模式效果很差。

**例如**，如果我们有 4000 个元素，并且我们选择了溢出表组织，但是希望冲突的概率非常低，那么我们可以选择 **m** = 4093。(4093 是小于 4096 的最大质数= 212)

**除法上的 Knuth 变量** : **h(k) = k(k+3) mod m** 。据说比原始除法要好得多。

**乘法方法** (Cormen) **:** 选择 m 为 2 的幂。设 A 是一个看起来随机的实数。Knuth 建议 **M = 0.5*(sqrt(5) — 1)。**

```
s = k*A
x = fractional part of s
h(k) = floor(m*x)
```

这似乎是理论家们喜欢的方法。

为了用整数算术快速地做到这一点，设 w 是一个字中的位数(例如 32)，并且假设 m 是 2^p.，则计算:

```
s = floor(A * 2^w)
x = k*s
h(k) = x >> (w-p)       // i.e. right shift x by (w-p) bits
                        // i.e. extract the p most significant 
                        // bits from x
```

**通用散列:**恶意对手总是可以选择密钥，使得它们都散列到同一个槽，导致平均' **O(n)'** 检索时间。通用散列法试图通过从一组散列函数中随机选择散列函数来避免这种情况(*参见*科尔曼*等*，第 229 页-)。这使得散列函数产生不良行为的概率很小，并且产生良好的平均性能。

![](img/5474c87871000f8e32df26063c80160d.png)

# **散列字符序列:————**

本节中的哈希函数取一个整数序列 k = k1，…，kn 并产生一个小整数桶值 h(k)，m 是哈希表的大小(桶数)，应该是一个质数。整数序列可能是整数列表，也可能是字符数组(字符串)。

以下算法的具体调优假设整数实际上都是字符代码。在 C++中，字符是一个 char 变量，它是一个 8 位整数。ASCII 仅使用这 8 位中的 7 位。在这 7 个字符中，常用字符(字母和数字)仅使用低 6 位。这 6 位中的第一位主要表示字符的大小写，这相对来说并不重要。所以下面的算法集中于从每个数字的最后 5 位保留尽可能多的信息，而较少使用前 3 位。

当使用以下算法时，输入 k(i) **必须**是无符号整数。给它们输入带符号的整数可能会导致奇怪的行为。

对于这些算法中的每一个，设 h 为输出值。将“h”设置为 0。遍历整数序列，将整数一个接一个地加到“h”上。算法的不同之处在于如何将整数 k(i)与 h 组合起来。最终返回值是 h mod m。

![](img/06159cecf68d9bfde067e7a1905f094b.png)

**CRC 变体:**对 h 进行 5 位左循环移位，然后在 k(i)中进行 XOR 运算。具体来说:

```
highorder = h & 0xf8000000      // extract high-order 5 bits from h
                                //0xf8000000 is the hexadecimal rep.
                         //for the 32-bit number with the first five 
                              //   bits = 1 and the other bits = 0   
h = h << 5                    // shift h left by 5 bits 
h = h^(highorder>>27)       //move highorder 5 bits to the low-order
                            //   end and XOR into h
h = h ^ k(i)                // XOR h and k(i)
```

**PJW 哈希**:将 h 左移 4 位。加入 k(i)。将 h 的前 4 位移到底部。具体来说:

```
// The top 4 bits of h are all zero
h = (h << 4) + k(i)              // shift h 4 bits left, add in k(i)
g = h & 0xf0000000              // get the top 4 bits of h
if (g != 0)                     // if the top 4 bits aren't zero,
        h = h ^ (g >> 24)      //   move them to the low end of h
        h = h ^ g                    
// The top 4 bits of h are again all zero
```

PJW 和 CRC 变体都工作得很好，它们之间没有太大的区别。我们认为 CRC 变体可能稍好一些，因为

*   它使用所有 32 位。PJW 只用 24 位。这可能不是主要问题，因为最终值 m 将比两者都小得多。
*   5 位可能是比 4 位更好的移位值。3、4 和 5 位的移位都应该工作正常。
*   用 XOR 组合值可能比将它们相加稍微好一点。然而，差别还是很小。

**BUZ 哈希:**它会生成多达 *232* 个不同的哈希值，但是需要更多的 Pascal 初始化代码。建立一个接受 8 位字符值并返回随机数的函数 R。这个函数可以预先计算并存储在一个数组中。然后，为了将每个字符 k(i)加到 h 上，对 h 进行 1 位左循环移位，然后对 k(i)的随机值进行 XOR 运算。那就是:

```
highorder = h & 0x80000000    // extract high-order bit from h
h = h << 1                    // shift h left by 1 bit
h = h ^ (highorder >> 31)     // move them to the low-order end and
                              // XOR into h
h = h ^ R[ki]                 // XOR h and the random value for k(i)
```

有传言说，您可能需要对输出运行第二个哈希函数，以使它足够随机。从实验上看，这个函数产生了很好的结果，但是比 CRC 变体和 PJW 稍慢。

# **结论:————**

![](img/faef370d22d10d1d3df98cc3e92518eb.png)