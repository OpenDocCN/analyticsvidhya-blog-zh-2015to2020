<html>
<head>
<title>Data Structures in Python 3; Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3中的数据结构；第一部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-structures-in-python-3-part-1-ec125c3c3dc6?source=collection_archive---------27-----------------------#2020-04-11">https://medium.com/analytics-vidhya/data-structures-in-python-3-part-1-ec125c3c3dc6?source=collection_archive---------27-----------------------#2020-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a0df3ea0de2ed36ed3bc5c4cfaa4a58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMMItBlMLF9U_NMa9i36rA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用<a class="ae iu" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>创建</figcaption></figure><p id="40f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据结构是组织和存储数据的一种方式。数据结构是编程中非常重要的一部分！栈、队列、链表等是一些众所周知的数据结构。然而，Python编程语言有它自己的原始数据结构。它广泛使用的三种数据结构是:列表、元组和字典。还有其他数据结构，但我们将在后面讨论。</p><p id="87b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你有Python编程的基础知识，比如条件语句和循环语句，并且对一般的数据结构有很好的理解，那就更好了。但是如果你不知道，也不用担心，我相信这篇文章对你来说很容易理解！</p><p id="baca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们先来学习一下数据结构<strong class="ix hj">列表</strong>。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9eb05c0f98422946db2c8b108c84f362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jmgz2R98M3WCmOpn61GZ4Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用<a class="ae iu" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>创建</figcaption></figure><p id="0928" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python中的“List”是一个<strong class="ix hj">线性数据</strong>结构。这意味着数据是线性存储的(更像一个数组)。如果你把这个列表称为C编程语言中Array的升级版，你没有错。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4747752fdf4d479cdd01a266840ab855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QheXtV49rEzuNZvC_cJkDA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用<a class="ae iu" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>创建</figcaption></figure><p id="fe2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您还记得数组的定义，“数组是数据的一种<strong class="ix hj">同质</strong>表示”。<em class="jx">同质</em>这个词在这里很重要。因为它告诉我们一个数组可以存储相同数据类型的数据。例如，整数数组只能存储整数值，而字符串字符只能存储字符值。然而，Python中的列表是数据的异构表示。这意味着它可以存储不同数据类型的数据。</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="db6f" class="kd ke hi jz b fi kf kg l kh ki">my_list = ["String", 1, 3.14, 'c', True]</span></pre><p id="b29f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你在上面的例子中注意到的，列表“my_list”有一个字符串(“string”)、一个整数(1)、一个浮点(3.14)、一个字符(“c”)和一个布尔值(True)。</p><p id="fa51" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">创建列表</strong>:</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="4bf9" class="kd ke hi jz b fi kf kg l kh ki"># First method<br/>my_list = list()</span><span id="13c6" class="kd ke hi jz b fi kj kg l kh ki"># Second Method<br/>some_list = []</span><span id="2404" class="kd ke hi jz b fi kj kg l kh ki"># Third method<br/>programming_languages = [ "C", "C++", "Python", "Java"]</span></pre><p id="a792" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">打印列表元素</strong>:</p><p id="fd58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以使用<em class="jx">打印</em>方法或使用<em class="jx"> for-loop </em>直接打印列表的元素。如果您使用<em class="jx">打印</em>方法，列表的所有元素将与表示列表的“[”和“]”一起打印。如果您使用一个<em class="jx"> for循环</em>，元素将一个接一个地打印。</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="6784" class="kd ke hi jz b fi kf kg l kh ki">a_list = [1, "Some string here", True, 3.1416]</span><span id="584c" class="kd ke hi jz b fi kj kg l kh ki">print("The contents of the list are:\n", a_list)<br/># Output: <br/># The contents of the list are:<br/># [1, "Some string here", True, 3.1416]</span><span id="8356" class="kd ke hi jz b fi kj kg l kh ki">for element in a_list:<br/>    print(element)<br/># Output:<br/># 1<br/># "Some string here"<br/># True<br/># 3.1416</span></pre><p id="3ac9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们试着横向打印列表</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="5346" class="kd ke hi jz b fi kf kg l kh ki">for element in a_list:<br/>    print(element, end=",")<br/># 1, "Some string here", True, 3.1416,</span></pre><p id="97a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“end”是<em class="jx"> print </em>元素的关键字参数，它指定了在执行print方法之后应该是什么处理字符。“end”参数仅适用于Python 3，不适用于Python 2。默认情况下，“end”的值为“\n”。这就是为什么在每次执行print方法后，如果没有为“end”参数指定其他文字，控件会转到新的一行。</p><p id="0667" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">索引列表</strong>:</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="836e" class="kd ke hi jz b fi kf kg l kh ki">random_list = [1, "Python Programming", 2.71828, False, 2, "Let's code"]</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/af0302376b49b9e04d99c082bc5b5ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YB-_ljvQmb98g7E11uS8CA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">带有索引和值的列表示例</figcaption></figure><p id="a59b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与数组类似，列表的索引也是从“0”开始，向上到“n-1”，其中“n”是列表的长度。</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="3963" class="kd ke hi jz b fi kf kg l kh ki">print(random_list[0]) # 1<br/>print(random_list[3]) # False<br/>print(random_list[5]) # Let's code</span></pre><p id="db32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">列表长度</strong>:</p><p id="11c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用<em class="jx"> len </em>方法得到一个列表的长度。</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="bc6d" class="kd ke hi jz b fi kf kg l kh ki">#Basic syntax:<br/># len(list_name)</span><span id="9161" class="kd ke hi jz b fi kj kg l kh ki">for index in range(0, len(random_list)):<br/>     print(" item is {0} it's index is {1}".format(random_list[index], index))</span><span id="d361" class="kd ke hi jz b fi kj kg l kh ki"># Output:<br/># item is 1 it's index is 0<br/># item is Python Programming it's index is 1<br/># item is 2.71828 it's index is 2<br/># item is False it's index is 3<br/># item is 2 it's index is 4<br/># item is Let's code it's index is 5</span></pre><p id="3bbe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用<em class="jx"> index </em>方法得到列表的索引</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="ff21" class="kd ke hi jz b fi kf kg l kh ki">for item in random_list:<br/>     print(" item is {0} it's index is {1}".format(item, random_list.index(item)))</span><span id="ce01" class="kd ke hi jz b fi kj kg l kh ki"># Output:<br/># item is 1 it's index is 0<br/># item is Python Programming it's index is 1<br/># item is 2.71828 it's index is 2<br/># item is False it's index is 3<br/># item is 2 it's index is 4<br/># item is Let's code it's index is 5</span></pre><p id="dca3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">将元素插入列表</strong>:</p><p id="ba87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以通过两种方式将元素添加到列表中:</p><ol class=""><li id="c798" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated">使用<em class="jx">追加</em>的方法。</li><li id="6bf5" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">使用<em class="jx">插入</em>的方法。</li></ol><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="1426" class="kd ke hi jz b fi kf kg l kh ki">super_villains = ["The Joker", "Doctor Doom", "Loki", "Sinestro"]</span><span id="6d1a" class="kd ke hi jz b fi kj kg l kh ki">super_villains.append("Thanos")<br/>print(super_villains)<br/># ["The Joker", "Doctor Doom", "Loki", "Sinestro", "Thanos"]</span><span id="696d" class="kd ke hi jz b fi kj kg l kh ki">super_villains.insert(2, "Dr. Octopus")<br/>print(super_villains)<br/># ['The Joker', 'Doctor Doom', 'Dr. Octopus', 'Loki', 'Sinestro', 'Thanos']</span></pre><p id="36a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jx">追加</em>和<em class="jx">插入</em>方法的区别在于<em class="jx">追加</em>方法总是将元素添加到列表的末尾，而插入方法将s添加到列表中的指定位置。在上面的例子中，我们将索引指定为“2”。于是在索引“2”的位置加了‘章鱼博士’。</p><p id="5ef7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">从列表中删除元素</strong>:</p><p id="30a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以通过两种方式从列表中删除元素:</p><ol class=""><li id="c300" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated">使用<em class="jx">弹出</em>的方法。</li><li id="60eb" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">使用<em class="jx">拆卸</em>的方法。</li></ol><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="3c7a" class="kd ke hi jz b fi kf kg l kh ki">super_villains = ['The Joker', 'Doctor Doom', 'Dr. Octopus', 'Loki', 'Sinestro', 'Thanos']</span><span id="d589" class="kd ke hi jz b fi kj kg l kh ki">print(super_villains.pop()) <br/># 'Thanos'</span><span id="6b8d" class="kd ke hi jz b fi kj kg l kh ki">print(super_villains)<br/># ['The Joker', 'Doctor Doom', 'Dr. Octopus', 'Loki', 'Sinestro']</span><span id="0f35" class="kd ke hi jz b fi kj kg l kh ki">print(super_villains.remove("Doctor Doom"))</span><span id="f809" class="kd ke hi jz b fi kj kg l kh ki"># ['The Joker', 'Dr. Octopus', 'Loki', 'Sinestro']</span></pre><p id="f140" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，<em class="jx"> pop </em>方法从列表末尾删除数据，除非显式指定了索引。而<em class="jx"> remove </em>方法则是移除方法内部指定的元素。在我们的示例中，我们已经将“Doctor Doom”作为示例发送给了<em class="jx"> remove </em>方法。因此“末日博士”从名单中被删除。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/d96e4715f7bbbbcdc333835ce40f3b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6d6qH7FOXHTSMh1G2cauQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">从列表中删除元素</figcaption></figure><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="630e" class="kd ke hi jz b fi kf kg l kh ki">super_villains = ['The Joker', 'Doctor Doom', 'Dr. Octopus', 'Loki', 'Sinestro', 'Thanos']</span><span id="e9b3" class="kd ke hi jz b fi kj kg l kh ki">print(super_villains.pop(0) <br/># 'The Joker'</span></pre><p id="491b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果索引被指定给<em class="jx"> pop </em>方法，那么该索引中的元素被弹出。</p><p id="7438" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">切片单(寿司操作员)</strong>:</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/efd1b2ebca893009bac895e4f7680866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_7nnMlVfp-fIZ29BMOUKQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用<a class="ae iu" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>创建</figcaption></figure><p id="cbbf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">免责声明:用于分割列表的“:”操作符不是正式的“Sushi”操作符。但是我最喜欢的一个来自Python社区的博客作者Dan Bader在他的书《Python技巧，这本书——令人敬畏的Python特性的自助餐》中这样称呼它。我非常喜欢这个术语，从那时起我就开始使用它了。(还有，我不是在为这本书做广告！)</p><p id="f375" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">列表的切片是使用“:”完成的，有些人也称之为“寿司操作符”。列表切片就是收集列表的一个<strong class="ix hj">连续线性部分</strong>。例如，如果列表中有10个元素，那么选择前5个元素可以称为对列表进行切片。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/dbbebb5355a0c33561951be364c35d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUQTrNbU7h3CNBzlTFigUg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">分割列表插图</figcaption></figure><p id="16ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">列表切片就是从列表中选择“n”个元素。唯一的规则是元素应该是连续的。</p><p id="4b04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在python中，列表还有一种叫做<strong class="ix hj">负索引</strong>的东西。负指数与正常指数相反，正常指数从0开始上升到n-1。负索引从-n开始，一直到-1。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/d037afd03f625a4489c0ea7223cfdfc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SWSzN9Pkg_JeX6Smf4qjiA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">列表的负索引的图示</figcaption></figure><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="dfa3" class="kd ke hi jz b fi kf kg l kh ki">vowels = ["a", "e", "i", "o", "u"]<br/>print(vowels[0]) # a<br/>print(vowels[-5]) # a</span></pre><p id="9c4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在对列表进行切片时，这些负索引非常重要。</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="ea7b" class="kd ke hi jz b fi kf kg l kh ki">vowels = ["a", "e", "i", "o", "u"]<br/>print(vowels[-5]) # a<br/>print(vowels[0:3]) # ['a', 'e', 'i']<br/>print(vowels[-5:-2]) # ['a', 'e', 'i']<br/>print(vowels[::2]) # ['a', 'i', 'u']<br/>print(vowels[4 : 2])# []</span></pre><p id="73f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您指定“0:3”时，从第0个位置到第2个位置的元素将被选中(切片)。使用负索引“-5:-2”也可以达到同样的效果。当你“::2”时，我们得到每一个替代元素。因为第一个“:”选择列表中的所有元素，“:2”意味着“2”的<strong class="ix hj">步数</strong>，意味着选择每第2个元素。</p><p id="398d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“4:2”返回一个空列表，因为第一个数字大于第二个数字。</p><p id="3988" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注</strong>:</p><ol class=""><li id="8a6e" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated">在正索引的情况下，索引中的第一个数字应该总是大于第二个数字。</li><li id="7a63" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">在指数为负的情况下，指数中的第一个数字应该总是小于第二个数字。</li><li id="56d1" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">切片中的第三个元素是<strong class="ix hj">步数</strong>，它告诉每第n个元素要选择。</li></ol><p id="18cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">倒单</strong>:</p><p id="558a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<em class="jx">反转</em>方法可以反转列表。</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="d1b6" class="kd ke hi jz b fi kf kg l kh ki">vowels = ["a", "e", "i", "o", "u"]<br/>vowels.reverse()<br/>print(vowels)<br/># ['u', 'o', 'i', 'e', 'a']</span></pre><p id="6ea4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，整个列表已经被永久反转<strong class="ix hj"/>。但是，如果我们只希望列表中的元素以相反的顺序在其他操作中使用列表的内容，而不想永久地反转列表，该怎么办呢？</p><p id="e6ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是切片进入画面的时候。你还记得切片中使用的<strong class="ix hj">步数</strong>吗？我们有负的指数，那为什么负的步数不算呢？让我们试试步数“-1”</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="81cb" class="kd ke hi jz b fi kf kg l kh ki">vowels = ["a", "e", "i", "o", "u"]</span><span id="4f35" class="kd ke hi jz b fi kj kg l kh ki">print(vowels[::-1])<br/># ['u', 'o', 'i', 'e', 'a']</span><span id="f144" class="kd ke hi jz b fi kj kg l kh ki">print(vowels)<br/># ['a', 'e', 'i', 'o', 'u']</span></pre><p id="f435" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我们可以看到实际的列表本身并没有反转，但是我们以相反的顺序得到了它的元素！</p><p id="9f83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">— — — — — — — — — — — — — — — — — — -</p><p id="aa17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">列表测验</strong>:</p><p id="9219" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问:以下程序的输出是什么？<br/> a = ['foo '，' bar '，' baz '，' qux '，' quux '，' corge'] <br/> print(a[-5:-3])</p><p id="73e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(请在评论部分添加您的答案)</p><p id="ea01" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">— — — — — — — — — — — — — — — — — — -</p><p id="81ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们来看看Python中的下一个重要数据结构，<strong class="ix hj">元组</strong>。</p><p id="88ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">元组是一系列不可变的Python对象。它类似于列表，但有一个问题。问题是python中的元组是不可变的或不可改变的！这意味着，一旦创建了一个元组，就不能更改其中的任何元素。您不能从中添加或删除任何元素。只能对元组进行索引和切片。</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="39aa" class="kd ke hi jz b fi kf kg l kh ki">t = (1, 2, 3, 4)<br/>t[1] = 10</span><span id="68c0" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj"># ----------------------------------------------------------------</strong><br/><strong class="jz hj"># TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="jz hj"># &lt;ipython-input-2-ea14d3893f53&gt;</strong> in &lt;module&gt;<br/>#       1 t <strong class="jz hj">=</strong> <strong class="jz hj">(1,</strong> <strong class="jz hj">2,</strong> <strong class="jz hj">3,</strong> <strong class="jz hj">4)</strong><br/><strong class="jz hj"># ----&gt; 2 </strong>t<strong class="jz hj">[1]</strong> <strong class="jz hj">=</strong> <strong class="jz hj">10</strong><br/><br/><strong class="jz hj"># TypeError</strong>: 'tuple' object does not support item assignment</span></pre><p id="67b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我们得到了一个TypeError，因为我们试图修改索引1处的元组的内容。</p><p id="192c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是创建元组的方法:</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="ebc5" class="kd ke hi jz b fi kf kg l kh ki"># Method 1<br/>tuple1 = (1, 2, 3)</span><span id="151e" class="kd ke hi jz b fi kj kg l kh ki"># Method 2<br/>t = tuple()</span><span id="711f" class="kd ke hi jz b fi kj kg l kh ki"># Method 3<br/>my_tuple = ()</span></pre><p id="bd52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注</strong>:</p><ol class=""><li id="1d63" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated">该列表是使用“[]”括号创建的。</li><li id="1dd3" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">元组是使用“()”括号创建的。</li></ol><p id="fbbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">连接两个元组</strong>:</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="f4a2" class="kd ke hi jz b fi kf kg l kh ki">tuple1 = (1, "ABC", 543.21, ["a", "b", "c"])<br/>tuple2 = (4, 5, 6)</span><span id="d5c9" class="kd ke hi jz b fi kj kg l kh ki">tuple3 = tuple1 + tuple2</span></pre><p id="a6d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以连接两个现有的元组，并创建一个包含这两个元组的元素的新元组。但是你<strong class="ix hj">不能将</strong>元素添加到<strong class="ix hj">已有的元组</strong>中。</p><p id="c316" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">元组的索引和切片与列表的相同。</p><p id="7513" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">链表和元组之间的内存效率</strong>:</p><p id="d91e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">内存效率是用来存储一个单位数据的内存量。简单来说，链表和元组在RAM中需要多少空间来存储相同数量的数据。</p><p id="fafb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您在一个列表和一个元组中存储了从0到1000的数字。现在检查列表和元组的大小，看看哪个占用的空间更少。无论哪种数据结构占用的空间较少，都被认为是内存效率更高的。</p><p id="197e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<em class="jx"> __sizeof__() </em>方法获得内存中一个链表或元组的大小。<em class="jx"> __sizeof__() </em>方法以字节为单位给出内存的大小。</p><pre class="jt ju jv jw fd jy jz ka kb aw kc bi"><span id="3117" class="kd ke hi jz b fi kf kg l kh ki">mem_list = [i for i in range(2000)]<br/>mem_tuple = tuple(i for i in range(2000))</span><span id="427b" class="kd ke hi jz b fi kj kg l kh ki">print("List: ", mem_list.__sizeof__())<br/># List:  16536</span><span id="3fd8" class="kd ke hi jz b fi kj kg l kh ki">print("Tuple: ", mem_tuple.__sizeof__())<br/># Tuple:  16024</span></pre><p id="ecb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的系统中，列表的输出是16，536字节，元组的输出是16，024字节。这些数字在不同的系统中可能会有所不同。但有一点是肯定的，那就是无论如何，链表的<strong class="ix hj">大小总是大于元组的</strong>！</p><p id="3d34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么？</p><p id="4373" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python编程语言将一切都视为一个<strong class="ix hj">对象</strong>。因此，列表mem_list是类列表的对象，而mem_tuple是类元组的对象。</p><p id="3e94" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，当有一个对象的时候，有很多东西比如成员变量和成员函数与之相关联。因为元组是不可变的，所以它没有成员函数，比如append和pop。此外，由于列表是可变的，Python解释器保留了一定的空间来向列表中添加新元素。这就是元组内存效率更高的原因。我将会写一个单独的博客，提供关于这个特定主题的更多细节。</p><p id="95f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用像元组这样的不可变对象的另一个主要优点是线程安全。</p><p id="6cba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些都在第1部分中。请继续关注第2部分！</p></div></div>    
</body>
</html>