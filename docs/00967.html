<html>
<head>
<title>Difference Between Deep Copy and Shallow copy in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中深层拷贝和浅层拷贝的区别</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/difference-between-deep-copy-and-shallow-copy-in-python-8c7ebc3fca8?source=collection_archive---------3-----------------------#2019-09-22">https://medium.com/analytics-vidhya/difference-between-deep-copy-and-shallow-copy-in-python-8c7ebc3fca8?source=collection_archive---------3-----------------------#2019-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="255a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用复制模块在python中复制列表有两种流行的方法:</p><ol class=""><li id="9b8c" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">浅拷贝</li><li id="a9f0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">深层拷贝</li></ol><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/ff9213465ca2da4c072c097e3695c3bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJCm_LQB2eUR_YZK1NNdCg.png"/></div></div></figure><p id="f8ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们将内容从old_list复制到new_list。</p><p id="13c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kd">浅拷贝:</em> </strong>当我们进行浅拷贝时，新列表被创建，旧列表中的对象被分配给新列表。所以两个列表中的对象将共享内存中的<strong class="ih hj">相同的引用</strong></p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ke"><img src="../Images/20dabb5cba2529125a5624aacd575a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*GMbM-V66Yc3eXwtD8XhZ3A.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">两个列表中的对象共享相同的引用</figcaption></figure><p id="5856" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看代码，</p><p id="7459" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在下面的代码中观察到Old_list和New_list的对象在内存中没有相同的位置</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="20cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是old_list和new _list中的对象在内存中具有相同的位置</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="d554" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们试图改变new_list中的对象，old_list中具有相同对象的对象也将被改变</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="1bb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kd">深度复制:</em> </strong>这个方法会将old_list的内容逐字复制到new_list，并将old_list里面的对象克隆到new_list。new_list中的对象不会与old_list共享引用id或内存位置。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kl"><img src="../Images/f434a7f94c136d56e984f0ddd1295bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*pmwaxt7314OfYZ31UPUo0Q.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">old_list和new_list的对象具有相同的值，但两者存储在不同的位置</figcaption></figure><p id="39fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Old_list和New_list的对象在内存中的位置不同</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="800e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">旧列表和新列表中的对象具有相同的内容，但在内存中的位置不同</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="18b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们试图改变new_list中的对象，old_list中具有相同对象的对象将不会被改变</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="03f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如有任何关于此内容的问题，请随时联系我们。</p><p id="abaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">保持蟒蛇！！</p></div></div>    
</body>
</html>