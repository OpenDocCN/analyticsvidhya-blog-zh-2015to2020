<html>
<head>
<title>Genetic Algorithms for Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化的遗传算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/genetic-algorithms-for-optimization-77cffeba37ea?source=collection_archive---------14-----------------------#2020-03-28">https://medium.com/analytics-vidhya/genetic-algorithms-for-optimization-77cffeba37ea?source=collection_archive---------14-----------------------#2020-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="478b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">由于遗传算法与遗传进化的相似性以及在优化技术中的应用，遗传算法最近变得流行起来。被称为遗传算法之父的霍兰德教授于1960年在密执安大学提出了这个概念。这个想法主要是受查尔斯·达尔文的进化论的启发。这些算法在当今的计算数学中被广泛使用。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/1b3603345227e59601b68ea4f2e1403d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TM1nJHDC8jsytEMQ5zA2Zw.jpeg"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">图片提供:前线基因组学</figcaption></figure><p id="669a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遗传算法是一种不保证最优解的元启发式算法。试探法是一种算法，它执行搜索以找到无法直接解决的问题(如非多项式(NP)问题)的最佳解决方案。它使用生物算子，如选择、交叉和变异。在本文中，我们将描述引导搜索如何帮助这些算法进化到最佳解决方案。遗传算法是一种进化算法，可分为基于种群的算法和模因算法。此外，它还可以用于NP完全问题，如旅行商问题。</p><h1 id="40b0" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">他们从哪里来？</strong></h1><p id="431f" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">查尔斯·达尔文在他的《物种起源》一书中总结了他20年来对人类如何随时间进化的研究。它概括了进化的思想，提出了自然选择的理论。它强调世代间的适者生存。现代基因组告诉我们，每个人拥有30亿个核苷酸。(长到可以写在262K A4纸上)。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lf"><img src="../Images/1df70cf0a1397e214f4ff5c30df51f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*2xAW6Qe4j5CPcXujFH_ZjA.png"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">金字塔理论</figcaption></figure><p id="5eb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看一个关于“你”是如何成为他人中最优秀者的小类比。一个简单的金字塔理论描述了你有两个父母，这两个父母有四个祖先。这个谱系崩溃告诉我们，如果你将这个链条进一步移动到40代，保持25年的平均代沟，那么你就有近20亿祖先，那些在地震、降雨、干旱、战争和疾病中幸存下来的人。因此，我很高兴这个星球上幸存的20亿最健康的人的产物正在阅读这篇文章。</p><blockquote class="lg lh li"><p id="ca2c" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">你可以在这里阅读有关伯特关注<a class="ae ln" rel="noopener" href="/analytics-vidhya/an-insight-to-bert-attentions-2e106f004dc0">的内容</a>。</p></blockquote><h1 id="2ac2" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">如何利用这种进化进行编程？</strong></h1><p id="10a4" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">现在，让我们颠倒使用与倒金字塔理论相同的理论，在倒金字塔理论中，我们对任何问题都有数百万种可能的解决方案，我们希望从中选择最好的作为父母，并通过突变产生后代，在几代之后找到最合适的解决方案。</p><p id="e0f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法可以被设想成树状表示。GA有以下几个阶段</p><ol class=""><li id="cd3b" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated"><strong class="ih hj">初始群体</strong></li><li id="0898" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj">健身功能</strong></li><li id="1115" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj">选择</strong></li><li id="1ca3" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj">交叉</strong></li><li id="a041" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj">突变</strong></li></ol><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mc"><img src="../Images/f23148132bd71c2e65bb1e5c9e00e5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*1oELn6hqThrYpHDRW4hb9w.png"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">基于倒金字塔的优化</figcaption></figure><blockquote class="lg lh li"><p id="b941" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">即使是同卵双生的孩子，和其他人相比，每个人都有较小的变异。99%的人类DNA与其他人相似。此外，我们96%的DNA与黑猩猩相似，与猫和牛分别有90%和80%相似。</p></blockquote><h2 id="3c03" class="md kd hi bd ke me mf mg ki mh mi mj km iq mk ml kq iu mm mn ku iy mo mp ky mq bi translated"><strong class="ak"> 1。起源(初始化种群)</strong></h2><p id="eb20" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">对于每个试探法，我们预期一些随机的解决方案来检查函数值，然后执行梯度搜索或模拟退火来检查我们的进展。对于一个数学问题，我们总是有几个变量，这些变量往往有一些限制或范围。群体越大，就越容易收敛到一个解，但是在一些系统中，存储大量的值会受到内存的限制。</p><pre class="jn jo jp jq fd mr ms mt mu aw mv bi"><span id="0623" class="md kd hi ms b fi mw mx l my mz"># low = lower range for variables, high = higher range for variables<br/>def genesis(size,var, high , low):<br/>   pop_size = (size,var)<br/>   new_pop = np.random.uniform(low=low,high=high,size=pop_size)<br/>   return new_pop</span></pre><h2 id="03ff" class="md kd hi bd ke me mf mg ki mh mi mj km iq mk ml kq iu mm mn ku iy mo mp ky mq bi translated"><strong class="ak"> 2。健身功能</strong></h2><p id="3aba" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">这是一种为每个解决方案打分的功能，有助于选择最佳解决方案。这个适应度函数是一个我们想要最大化或最小化的数学方程。在人口较多的情况下，复杂的适应度函数会产生较高的计算成本。</p><pre class="jn jo jp jq fd mr ms mt mu aw mv bi"><span id="821f" class="md kd hi ms b fi mw mx l my mz">def fitness(p):<br/># Evaluating fitness Interference function "double fit (doublep[])".<br/>   fitness=np.zeros((len(p),1))<br/>   for i in range(len(p)):<br/>       x,y,z = p[i][0] , p[i][1] , p[i][2]<br/>       fitness[i,0] = 2*x*z*np.exp(-x) - 2*y**3 + y**2 -3*z**3<br/>   return fitness</span></pre><h2 id="6897" class="md kd hi bd ke me mf mg ki mh mi mj km iq mk ml kq iu mm mn ku iy mo mp ky mq bi translated"><strong class="ak"> 3。选择</strong></h2><p id="1847" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在使用一个评分标准找到最合适的之后，我们使用几个父母来繁殖下一代。更多的父节点意味着解决方案更加多样化，更容易达到最优解。</p><pre class="jn jo jp jq fd mr ms mt mu aw mv bi"><span id="f4f1" class="md kd hi ms b fi mw mx l my mz">def selection(pop, fitness, num_parents):<br/>   parents = np.empty((num_parents, pop.shape[1]))<br/>   for parent_num in range(num_parents):<br/>      max_fitness_idx = np.where(fitness == np.max(fitness))<br/>      max_fitness_idx = max_fitness_idx[0][0]<br/>      parents[parent_num, :] = pop[max_fitness_idx, :]<br/>      fitness[max_fitness_idx] = -99999999999<br/>   return parents</span></pre><h2 id="2b9a" class="md kd hi bd ke me mf mg ki mh mi mj km iq mk ml kq iu mm mn ku iy mo mp ky mq bi translated">4.交叉</h2><p id="8141" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">执行此操作是为了创建混合，并避免重复相同的解决方案。这就像自然选择，不同地区的人采用不同的肤色和发色。交叉有不同的类型，如单点、两点和均匀。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es na"><img src="../Images/5bfa5ed736dd6707c2417248a8e1ca11.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*rjOMHAeWi_qPYTXOAUHqkg.png"/></div></figure><pre class="jn jo jp jq fd mr ms mt mu aw mv bi"><span id="a361" class="md kd hi ms b fi mw mx l my mz">def crossover(parents, offspring_size):<br/>   offspring = np.empty(offspring_size)<br/>   crossover_point = np.uint8(offspring_size[1]/2)<br/>   for k in range(offspring_size[0]):<br/>      parent1_idx = k%parents.shape[0]<br/>      parent2_idx = (k+1)%parents.shape[0]<br/>      offspring[k, 0:crossover_point] = parents[parent1_idx,     0:crossover_point]<br/>      offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]<br/>   return offspring</span></pre><h2 id="8698" class="md kd hi bd ke me mf mg ki mh mi mj km iq mk ml kq iu mm mn ku iy mo mp ky mq bi translated"><strong class="ak"> 5。突变</strong></h2><p id="ff81" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">“变种人”这个词现在因电影《Xmen》而出名，在这部电影中，每个人都有独特的品质。我们初始化变异以增加解的多样性。突变率决定了我们想要在种群中引入多少变化。在人类的DNA中，同卵双胞胎可能会发生0.1%到0.4%的突变。有不同类型的突变，如位翻转、交换、反向、均匀、非均匀、高斯、收缩等。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es nb"><img src="../Images/19e2052c94065b924d0cc87b420c063c.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*cZiKaAyiJFPJpxzW2XU57A.png"/></div></figure><pre class="jn jo jp jq fd mr ms mt mu aw mv bi"><span id="0a75" class="md kd hi ms b fi mw mx l my mz">def mutation(offspring_crossover):<br/>   for idx in range(offspring_crossover.shape[0]):<br/>      random_value = np.random.uniform(0, 10, 1)<br/># 10 percent change maximum keeping 90 percent mutation rate <br/>      i= randint(0, 2)<br/>      offspring_crossover[idx, i] = offspring_crossover[idx, i] + random_value <br/>   return offspring_crossover</span></pre><h1 id="0351" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">优化的一个例子:</h1><p id="bbfd" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我们想最大化这个等式。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es nc"><img src="../Images/792d68cea5fa714f0c5d84cd0cb6199e.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*SF4BHEXzdYfaMzSfvNSElA.png"/></div></figure><blockquote class="nd"><p id="c731" class="ne nf hi bd ng nh ni nj nk nl nm jc dx translated">注意:我们可以通过简单地用相同的代码使一个函数为负来最小化它，例如:g(x) = -f(x)</p></blockquote><p id="1dad" class="pw-post-body-paragraph if ig hi ih b ii nn ik il im no io ip iq np is it iu nq iw ix iy nr ja jb jc hb bi translated">我们有三个变量x，y，z，我们选择这些参数进行求解:</p><p id="2d43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a) 50代</p><p id="53f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b)突变率:10%</p><p id="5e08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c)父母:2人</p><p id="2536" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">d)春季突变:4</p><p id="9d1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">e)初始人口:10万</p><pre class="jn jo jp jq fd mr ms mt mu aw mv bi"><span id="3754" class="md kd hi ms b fi mw mx l my mz">import numpy as np<br/>from random import randint</span><span id="0349" class="md kd hi ms b fi ns mx l my mz">num_var = 3</span><span id="9fb0" class="md kd hi ms b fi ns mx l my mz">sizeof_pop= 100000<br/>upper_limit = 100<br/>lower_limit = 0</span><span id="71da" class="md kd hi ms b fi ns mx l my mz">num_parents = 2</span><span id="e239" class="md kd hi ms b fi ns mx l my mz">population = genesis(sizeof_pop , num_var, upper_limit ,lower_limit)<br/>print(population)<br/>Scores=[]</span><span id="ccec" class="md kd hi ms b fi ns mx l my mz">num_generations = 50<br/>for generation in range(num_generations):<br/>   print("\n\nGeneration : ", generation)<br/>   fitness_score = fitness(population)<br/>   parents = selection(population, fitness_score, num_parents)<br/>   print("Best Parents \n",parents)<br/>   offspring_crossover = crossover(parents, offspring_size=(2*num_parents, num_var))<br/>   offspring_mutation = mutation(offspring_crossover)<br/>   print("Mutated OffSprings\n",offspring_mutation)<br/>   population[0:parents.shape[0], :] = parents<br/>   population[parents.shape[0]:6, :] = offspring_mutation<br/>   Scores.append(np.max(fitness_score))<br/>   print("Best result : ", np.max(fitness_score))</span></pre><p id="f4a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将运行算法50代，并显示结果。colab版本在<a class="ae ln" href="https://github.com/NeelKanwal/GeneticAlgorithms" rel="noopener ugc nofollow" target="_blank">这里</a>有售。</p><pre class="jn jo jp jq fd mr ms mt mu aw mv bi"><span id="cae6" class="md kd hi ms b fi mw mx l my mz">fitness = fitness(population)<br/>best_match_idx = np.where(fitness == np.max(fitness))<br/>print("P : ", population[best_match_idx, :][0][0])<br/>print(" Value for  x= {}".format(population[best_match_idx, :][0][0][0]))<br/>print(" Value for  y= {}".format(population[best_match_idx, :][0][0][1]))<br/>print(" Value for  z= {}".format(population[best_match_idx, :][0][0][2]))<br/>print("Best solution fitness : ", fitness[best_match_idx][0])</span></pre><p id="ec5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在每次运行中找到变量的不同值，如前所述，这不是一个确定性算法。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es nt"><img src="../Images/dacfed2e8c2a5533470211371947b548.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*q3QfsM0vZpBVkitiW_JpGg.png"/></div></figure><pre class="jn jo jp jq fd mr ms mt mu aw mv bi"><span id="46db" class="md kd hi ms b fi mw mx l my mz">import matplotlib.pyplot as plt<br/>Evaluations = Scores<br/>plt.plot(Evaluations,'o-',color='red')<br/>plt.xlabel('Generations')<br/>plt.ylabel('Function Value')<br/>plt.title("Maximization of Function")<br/>plt.grid(True)<br/>plt.show()</span></pre><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es nu"><img src="../Images/586865fbdee2dc864c633b68762bddfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*t8xF__eALQNAeUn5iUIkag.png"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">进化使方程式的价值最大化</figcaption></figure><p id="ec4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Matlab的全局优化工具箱可以执行类似的任务。</p><p id="e276" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码可以在这里找到。</p><div class="nv nw ez fb nx ny"><a href="https://github.com/NeelKanwal/GeneticAlgorithms" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab dw"><div class="oa ab ob cl cj oc"><h2 class="bd hj fi z dy od ea eb oe ed ef hh bi translated">尼尔坎瓦尔/遗传算法</h2><div class="of l"><h3 class="bd b fi z dy od ea eb oe ed ef dx translated">遗传算法由于其与遗传进化的相似性和在优化设计中的应用，最近得到了广泛的应用。</h3></div><div class="og l"><p class="bd b fp z dy od ea eb oe ed ef dx translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om jw ny"/></div></div></a></div></div></div>    
</body>
</html>