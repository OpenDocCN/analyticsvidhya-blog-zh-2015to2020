<html>
<head>
<title>Machine Learning: Data Preprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习:数据预处理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-data-preprocessing-5874289e922c?source=collection_archive---------23-----------------------#2020-05-28">https://medium.com/analytics-vidhya/machine-learning-data-preprocessing-5874289e922c?source=collection_archive---------23-----------------------#2020-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/60521928cf1449fc3b7583237532b904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKVPaiL8iWPIXhAGv6LrpQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">数据预处理。<em class="iv">来源:谷歌图片</em> </strong></figcaption></figure><p id="2dbf" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果我们把这与我们的现实生活联系起来，那将会很有趣。记住在烹饪一道菜之前先清洗然后切生蔬菜的任务。有点类似于这个任务。数据预处理是一种将原始形式的数据转换成更有用形式的方法。看起来很相似，对吗？这两个任务之间的唯一区别是，一个有助于烹饪美味的菜肴，另一个是机器学习模型，用于预测新观察的类别。事实上，对于大多数人来说，数据预处理这一步听起来并不有趣，但这是非常重要的第一步，因为每次构建模型时，都有数据预处理阶段要做。预处理步骤应该以这样的方式完成，即模型可以以正确的方式训练，因为模型的效率依赖于该步骤。</p><p id="5c3b" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj"> <em class="ju">数据预处理涉及的步骤:</em> </strong>这一步完全依赖于一些预处理工具:</p><ol class=""><li id="c4b0" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt ka kb kc kd bi translated"><strong class="iy hj">导入库:</strong>开始时，我们需要导入3个库(NumPy，Matplotlib，pandas)来开始预处理阶段。但是，什么是图书馆呢？库是模块的符号，它包含函数和类，通过这些函数和类你可以执行动作和操作。</li></ol><p id="2c46" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">I)<em class="ju">NumPy</em>——你需要这个库来处理数组。因为未来模型将需要阵列来实现。</p><p id="9f7a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">ii)M<em class="ju">atplotlib</em>——你需要这个库来创建一些漂亮的图表。</p><p id="16f4" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">iii) <em class="ju"> pandas- </em>该库不仅有助于导入数据集，还能创建特征矩阵和因变量向量。</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/818c914ff4a3a1bce5a144a7e84cbf8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*RYX4STmjxpIxA3yqFmQlyA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">导入库。</strong></figcaption></figure><p id="9cd5" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">2.<strong class="iy hj">导入数据集:</strong>下面是导入数据集的步骤，这是一个重要的阶段。</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/bd6e819152658c7c9a6800a28b2adc55.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*ZeHg66DHG0yvIFWI4q84BQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">导入数据集。</strong></figcaption></figure><p id="9233" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里的数据集变量充当类似于数据集(Data.csv)的行和列的数据框。</p><p id="24f5" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">i) <em class="ju">创建特征矩阵和因变量向量:</em></p><figure class="kf kg kh ki fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/b80129ce43996ea15cc9cd1b1059ff2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*CHl3VZytvGg0Wkm3JXw6iw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">矩阵的特性。</strong></figcaption></figure><p id="d924" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">所有我们需要知道的是玩矩阵的索引，我们可以很容易地创建这两个特征矩阵。这里x作为自变量矩阵，Y作为因变量向量。这两个特征矩阵将是进一步预处理的首要条件。</p><p id="d519" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">3.<strong class="iy hj">注意丢失的数据:</strong>一定要找出上图和包含值NaN的行，这些值表示丢失了值，它会影响模型的学习。</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/a4b2de6459ad6124c70e4dce25b0fe7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*J7Vx-RQPwraZoKpDZkMi0A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">缺失值替换为平均值。</strong></figcaption></figure><p id="6d1f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这可以通过多种方式完成，例如删除/忽略缺少值的行。但是，当丢失值的行数最多为1%时，这是有益的。</p><p id="0b85" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">其他方法是用该列的中值或平均值替换缺失值。</p><p id="38f9" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">但是，最优选的是用该列的平均值(<strong class="iy hj"> Mean </strong>)代替。这是在最佳数据科学库scikit-learn的帮助下完成的。</p><p id="5763" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">4.<strong class="iy hj">编码分类数据:</strong>上述特征矩阵包含具有字符串值的列，这很难处理和操作。因为计算机能很好地处理二进制值。所以，我们将把字符串值转换成二进制值。</p><p id="30c0" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">i) <em class="ju">编码自变量:</em></p><figure class="kf kg kh ki fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/d3faf9d6b6dec7f1e9191202606fa083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MrzXQW-F4LEwrjzGpAhkdQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu"> <em class="iv">自变量的编码。</em>T9】</strong></figcaption></figure><p id="155d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我们有三类数据，因此，编码值是:</p><p id="161a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">“印度为0，0，0”，“中国为0，0，1”，“美国为1，0，0”。</p><p id="4ede" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">ii) <em class="ju">因变量编码:</em></p><figure class="kf kg kh ki fd ij er es paragraph-image"><div class="er es kn"><img src="../Images/bce552c3ed9ce5352c493ef2e257dd53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*BFbkFXEQdGLrzhBoVtDaSg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu"> <em class="iv">因变量的编码。</em>T15】</strong></figcaption></figure><p id="9e12" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里，我们有两类值，因此，编码值是:</p><p id="6d73" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">“否为0”和“是为1”</p><p id="744b" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">5.<strong class="iy hj">将数据集分为训练集和测试集:</strong>在这一步中，我们致力于泛化。拆分的目的是为了避免过度拟合。<strong class="iy hj">过度拟合</strong>发生在模型学习训练数据中的细节和噪声，以至于对新数据的模型性能产生负面影响的时候。它优化了训练精度。我们需要我们的模型来很好地预测新观察(测试集)的结果，这类似于训练集。</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/81387ca7039191cd0bff1ed855a53760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eV_a3zWBVe5fYjhDhOnZjA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">将数据集分为80%的训练集和20%的测试集。</strong></figcaption></figure><p id="a714" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">6.<strong class="iy hj">特征缩放:</strong></p><figure class="kf kg kh ki fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/d556004c9b92c479964f233b67716be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*bAQGD4dpYzEX_BRLmZCFhQ.png"/></div></figure><p id="8d7a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">要素缩放对于将各种数据纳入同一比例非常重要。它包括将特定范围内的数据标准化的步骤。</p><p id="f3f5" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">两种最常用的缩放技术是规范化和标准化。但是，我们更喜欢标准化技术。</p><p id="d1b7" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj"> <em class="ju">结论:</em> </strong> <em class="ju">上述步骤非常重要，因为数据预处理是模型构建过程的支柱之一。我希望提到的细节将帮助许多初学者发展对数据预处理的理解。</em></p></div></div>    
</body>
</html>