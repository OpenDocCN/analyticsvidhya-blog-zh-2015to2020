<html>
<head>
<title>Image Flipping and Mirroring with NumPy and OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NumPy和OpenCV进行图像翻转和镜像</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/image-flipping-and-mirroring-with-numpy-and-opencv-aecc08558679?source=collection_archive---------2-----------------------#2020-11-20">https://medium.com/analytics-vidhya/image-flipping-and-mirroring-with-numpy-and-opencv-aecc08558679?source=collection_archive---------2-----------------------#2020-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5325" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客文章中，我将解释如何在Python中镜像或翻转图像。所需要的只是理解各种矩阵运算和矩阵操作背后的基本数学。</p><h1 id="d59f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">包装要求</h1><ul class=""><li id="2754" class="kb kc hi ih b ii kd im ke iq kf iu kg iy kh jc ki kj kk kl bi translated">NumPy —用于矩阵运算及其操作。</li><li id="4384" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">OpenCV —用于读取图像并将其转换为2D数组(矩阵)。</li><li id="21f5" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">Matplotlib —用于将矩阵绘制为图像。</li></ul><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kr"><img src="../Images/18305c130ac5255d7e7a39a385ec518d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Nm7Ec_i9OjDnCPM59Nkdg.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">作者图片</figcaption></figure><p id="f707" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个迷你项目，我使用一个著名的<a class="ae lh" href="https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png" rel="noopener ugc nofollow" target="_blank">莉娜图像</a>，它主要用于测试计算机视觉模型。确保下载该图像并保存在当前工作目录中。</p><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="9762" class="ln je hi lj b fi lo lp l lq lr">import cv2<br/>import numpy as np<br/>from matplotlib import pyplot as plt</span></pre><h1 id="b4e4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">我们开始吧</h1><p id="5763" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">首先，我们使用模块<code class="du lv lw lx lj b">cv2</code>中的方法<code class="du lv lw lx lj b">imread()</code>读取图像文件。为此，我们只需导入包并使用so。因此，通过这样做，我们得到了矩阵形式的图像。</p><p id="e2e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，<code class="du lv lw lx lj b">imread()</code>方法以<code class="du lv lw lx lj b">BGR</code> ( <code class="du lv lw lx lj b">Blue</code>、<code class="du lv lw lx lj b">Green</code>、<code class="du lv lw lx lj b">Red</code>)格式读取图像。为了将读取的图像转换成常规格式，即<code class="du lv lw lx lj b">RGB</code> ( <code class="du lv lw lx lj b">Red</code>、<code class="du lv lw lx lj b">Green</code>、<code class="du lv lw lx lj b">Blue</code>)，我们使用了来自同一模块<code class="du lv lw lx lj b">cv2</code>的<code class="du lv lw lx lj b">cvtColor()</code>方法。</p><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="8642" class="ln je hi lj b fi lo lp l lq lr">def read_this(image_file, gray_scale=False):<br/>    image_src = cv2.imread(image_file)<br/>    if gray_scale:<br/>        image_rgb = cv2.cvtColor(image_src, cv2.COLOR_BGR2GRAY)<br/>    else:<br/>        image_rgb = cv2.cvtColor(image_src, cv2.COLOR_BGR2RGB)<br/>    return image_rgb</span></pre><p id="50d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述函数从传递的图像文件中返回一个图像矩阵。如果我们想得到<code class="du lv lw lx lj b">gray_scale</code>或<code class="du lv lw lx lj b">RGB</code>格式的图像矩阵，它由常规的<code class="du lv lw lx lj b">if</code>和<code class="du lv lw lx lj b">else</code>条件组成。</p><h1 id="78e6" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">镜像图像</h1><p id="d9b6" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">为了镜像图像，我们需要从左到右逐行反转矩阵。例如，让我们考虑一个矩阵<code class="du lv lw lx lj b">A</code>。</p><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="3df0" class="ln je hi lj b fi lo lp l lq lr">&gt;&gt;&gt; A = [<br/>       [4, 1, 1],<br/>       [2, 8, 0],<br/>       [3, 8, 1]<br/>]</span></pre><p id="4094" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想要镜像这个矩阵(按行)，那么它将是-</p><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="88f4" class="ln je hi lj b fi lo lp l lq lr">&gt;&gt;&gt; import numpy as np<br/>&gt;&gt;&gt; mirror_ = np.fliplr(A)<br/>&gt;&gt;&gt; mirror_<br/>[[1, 1, 4],<br/> [0, 8, 2],<br/> [1, 8, 3]]</span></pre><p id="8d79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也可以不使用<code class="du lv lw lx lj b">NumPy</code>模块来完成此操作。如果是这样，我们就可以使用循环来反转每一行。这将需要一段时间，如果执行相同的图像矩阵，因为它们是非常大的矩阵，我们不希望我们的代码执行非常慢。</p><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="9896" class="ln je hi lj b fi lo lp l lq lr">def mirror_this(image_file, gray_scale=False, with_plot=False):<br/>    image_rgb = read_this(image_file=image_file, gray_scale=gray_scale)<br/>    image_mirror = np.fliplr(image_rgb)<br/>    if with_plot:<br/>        fig = plt.figure(figsize=(10, 20))</span><span id="2ca3" class="ln je hi lj b fi ly lp l lq lr">        ax1 = fig.add_subplot(2, 2, 1)<br/>        ax1.axis("off")<br/>        ax1.title.set_text('Original')<br/>        ax2 = fig.add_subplot(2, 2, 2)<br/>        ax2.axis("off")<br/>        ax2.title.set_text("Mirrored")</span><span id="d854" class="ln je hi lj b fi ly lp l lq lr">        if not gray_scale:<br/>            ax1.imshow(image_rgb)<br/>            ax2.imshow(image_mirror)<br/>        else:<br/>            ax1.imshow(image_rgb, cmap='gray')<br/>            ax2.imshow(image_mirror, cmap='gray')<br/>        return True<br/>    return image_mirror</span></pre><p id="8e06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的函数返回一个从左到右逐行反转的图像矩阵。</p><p id="845d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们画出同样的-</p><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="5a75" class="ln je hi lj b fi lo lp l lq lr">mirror_this(image_file="lena_original.png", with_plot=True)</span></pre><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lz"><img src="../Images/d66e11a009645f643333fe2681c98327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*ujBbdhc8DE9svvrKNPnaXg.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">作者图片</figcaption></figure><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="026e" class="ln je hi lj b fi lo lp l lq lr">mirror_this(image_file="lena_original.png", gray_scale=True, with_plot=True)</span></pre><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lz"><img src="../Images/646a83468c64cd26ae9c89b33afc5f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*mll-UZsKaHqGpnoPzdeicw.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">作者图片</figcaption></figure><h1 id="5a37" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">翻转图像</h1><p id="4d88" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">为了翻转图像，我们需要从上到下逐列翻转矩阵。例如，让我们考虑一个矩阵<code class="du lv lw lx lj b">B</code>。</p><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="0bbe" class="ln je hi lj b fi lo lp l lq lr">&gt;&gt;&gt; B = [<br/>       [4, 1, 1],<br/>       [2, 8, 0],<br/>       [3, 8, 1]<br/>]</span></pre><p id="1cf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想翻转这个矩阵(按列)，那么它会是-</p><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="9c8b" class="ln je hi lj b fi lo lp l lq lr">&gt;&gt;&gt; import numpy as np<br/>&gt;&gt;&gt; flip_= np.flipud(B)<br/>&gt;&gt;&gt; flip_<br/>[[3, 8, 1],<br/> [2, 8, 0],<br/> [4, 1, 1]]</span></pre><p id="7c20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了保持代码的快速性，我们使用<code class="du lv lw lx lj b">NumPy</code>来翻转矩阵。</p><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="8e15" class="ln je hi lj b fi lo lp l lq lr">def flip_this(image_file, gray_scale=False, with_plot=False):<br/>    image_rgb = read_this(image_file=image_file, gray_scale=gray_scale)<br/>    image_flip = np.flipud(image_rgb)<br/>    if with_plot:<br/>        fig = plt.figure(figsize=(10, 20))</span><span id="1de3" class="ln je hi lj b fi ly lp l lq lr">        ax1 = fig.add_subplot(2, 2, 1)<br/>        ax1.axis("off")<br/>        ax1.title.set_text('Original')<br/>        ax2 = fig.add_subplot(2, 2, 2)<br/>        ax2.axis("off")<br/>        ax2.title.set_text("Flipped")</span><span id="0ea4" class="ln je hi lj b fi ly lp l lq lr">        if not gray_scale:<br/>            ax1.imshow(image_rgb)<br/>            ax2.imshow(image_flip)<br/>        else:<br/>            ax1.imshow(image_rgb, cmap='gray')<br/>            ax2.imshow(image_flip, cmap='gray')<br/>        return True<br/>    return image_flip</span></pre><p id="b4ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的函数返回一个从上到下逐列反转的图像矩阵。</p><p id="903d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们画出同样的-</p><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="dd24" class="ln je hi lj b fi lo lp l lq lr">flip_this(image_file='lena_original.png', with_plot=True)</span></pre><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lz"><img src="../Images/e8c9e99d5cff4bcb9b69a16596c27153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*QOXVIdshK2XuRY0vPNbaoQ.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">作者图片</figcaption></figure><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="3e6c" class="ln je hi lj b fi lo lp l lq lr">flip_this(image_file='lena_original.png', gray_scale=True, with_plot=True)</span></pre><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lz"><img src="../Images/08949c2dc7453836c196f44c72c7fa9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*sO7PBlYS6M2U6ODIb9N1gA.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">作者图片</figcaption></figure><h1 id="cb40" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">完整的代码</h1><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="2366" class="ln je hi lj b fi lo lp l lq lr">class ImageOpsFromScratch(object):<br/>    def __init__(self, image_file):<br/>        self.image_file = image_file</span><span id="14ea" class="ln je hi lj b fi ly lp l lq lr">    def read_this(self, gray_scale=False):<br/>        image_src = cv2.imread(self.image_file)<br/>        if gray_scale:<br/>            image_rgb = cv2.cvtColor(image_src, cv2.COLOR_BGR2GRAY)<br/>        else:<br/>            image_rgb = cv2.cvtColor(image_src, cv2.COLOR_BGR2RGB)<br/>        return image_rgb</span><span id="c303" class="ln je hi lj b fi ly lp l lq lr">    def mirror_this(self, with_plot=True, gray_scale=False):<br/>        image_rgb = self.read_this(gray_scale=gray_scale)<br/>        image_mirror = np.fliplr(image_rgb)</span><span id="03d0" class="ln je hi lj b fi ly lp l lq lr">        if with_plot:<br/>            self.plot_it(orig_matrix=image_rgb, trans_matrix=image_mirror, head_text='Mirrored', gray_scale=gray_scale)<br/>            return None<br/>        return image_mirror</span><span id="718c" class="ln je hi lj b fi ly lp l lq lr">    def flip_this(self, with_plot=True, gray_scale=False):<br/>        image_rgb = self.read_this(gray_scale=gray_scale)<br/>        image_flip = np.flipud(image_rgb)</span><span id="ea30" class="ln je hi lj b fi ly lp l lq lr">        if with_plot:<br/>            self.plot_it(orig_matrix=image_rgb, trans_matrix=image_flip, head_text='Flipped', gray_scale=gray_scale)<br/>            return None<br/>        return image_flip</span><span id="d82d" class="ln je hi lj b fi ly lp l lq lr">    def plot_it(self, orig_matrix, trans_matrix, head_text, gray_scale=False):<br/>        fig = plt.figure(figsize=(10, 20))</span><span id="ecca" class="ln je hi lj b fi ly lp l lq lr">        ax1 = fig.add_subplot(2, 2, 1)<br/>        ax1.axis("off")<br/>        ax1.title.set_text('Original')</span><span id="214e" class="ln je hi lj b fi ly lp l lq lr">        ax2 = fig.add_subplot(2, 2, 2)<br/>        ax2.axis("off")<br/>        ax2.title.set_text(head_text)</span><span id="899e" class="ln je hi lj b fi ly lp l lq lr">        if not gray_scale:<br/>            ax1.imshow(orig_matrix)<br/>            ax2.imshow(trans_matrix)<br/>        else:<br/>            ax1.imshow(orig_matrix, cmap='gray')<br/>            ax2.imshow(trans_matrix, cmap='gray')</span><span id="3f20" class="ln je hi lj b fi ly lp l lq lr">        return True</span></pre><h1 id="a481" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">基本图像操作包</h1><pre class="ks kt ku kv fd li lj lk ll aw lm bi"><span id="7401" class="ln je hi lj b fi lo lp l lq lr">imo = ImageOpsFromScratch(image_file='lena_original.png')<br/>### Mirroring ###<br/>imo.mirror_this()<br/>imo.mirror_this(gray_scale=True)<br/>### Flipping ###<br/>imo.flip_this()<br/>imo.flip_this(gray_scale=True)</span></pre><p id="07f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将显示上述图像结果。现在一切都已排序，我们可以创建其他图像操作，如<code class="du lv lw lx lj b">equalize()</code>、<code class="du lv lw lx lj b">solarize()</code>等。我在本文中没有涉及到这个问题，但是在下一篇文章中肯定会涉及到。</p><h1 id="7709" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">我从中获得了什么？</h1><ul class=""><li id="c117" class="kb kc hi ih b ii kd im ke iq kf iu kg iy kh jc ki kj kk kl bi translated">通过实现这一点，我已经学习并理解了各种图像操作背后的逻辑，以及如何将其以代码的形式表达出来。</li></ul><p id="eb27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也可以使用一个众所周知的图像库<code class="du lv lw lx lj b">Pillow</code>来做同样的事情。但是，作为一名开发人员，我们需要知道事情从开始到结束都是有效的。这才是大家应该好奇的地方。</p><p id="35e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请务必阅读我的另一篇关于图像处理和计算机视觉的<a class="ae lh" rel="noopener" href="/analytics-vidhya/image-convolution-from-scratch-d99bf639c32a">文章</a>，在那里我从头开始解释<em class="ma">图像卷积</em>。</p></div></div>    
</body>
</html>