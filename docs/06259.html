<html>
<head>
<title>Optimising Elasticsearch — Stronger, Better, Faster.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化弹性搜索—更强、更好、更快。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/optimising-elasticsearch-stronger-better-faster-e56fed2bcc8b?source=collection_archive---------14-----------------------#2020-05-16">https://medium.com/analytics-vidhya/optimising-elasticsearch-stronger-better-faster-e56fed2bcc8b?source=collection_archive---------14-----------------------#2020-05-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="c932" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Elasticsearch是目前最热门的开源数据存储解决方案之一，它通过提供分布式架构和并行处理功能来简化数据分析，从而为我们提供了大量用例及功能。Elasticsearch是一个分布式数据存储和搜索引擎，具有容错和高可用性功能。</p><p id="0181" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了充分发挥Elasticsearch的作用，正确配置它是很重要的。单一的通用配置可能不适合所有用例，因此首先理解一个用例，然后基于这个用例配置集群是非常重要的。</p><p id="9f57" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本文将关注Elasticsearch的搜索密集型初始和动态配置，以及使用指标检测可伸缩性问题。</p><p id="31c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们开始之前，让我们清楚地理解几个术语</p><ol class=""><li id="157a" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">索引</strong>:在Elasticsearch中，索引是文档的集合。</li><li id="79c8" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated"><strong class="io hj">节点</strong>:单个Elasticsearch实例。在大多数环境中，每个节点运行在单独的机器或虚拟机上。</li><li id="5eaf" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated"><strong class="io hj">集群</strong>:一个Elasticsearch集群由一个或多个节点组成，可以通过它的集群名来识别。</li><li id="518d" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated"><strong class="io hj"> SHARD </strong>:因为Elasticsearch是一个分布式搜索引擎，所以一个索引通常被分割成多个元素，称为SHARD，分布在多个节点上。Elasticsearch自动管理这些碎片的排列。它还会根据需要重新平衡碎片，因此用户无需担心细节。</li><li id="abc0" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated"><strong class="io hj">副本</strong>:默认情况下，Elasticsearch为每个索引创建五个主分片和一个副本。这意味着每个索引将由五个主要碎片组成，每个碎片将有一个副本。</li></ol><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jy"><img src="../Images/188edd4920e1b478fb6139340898fef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2ReDuI-IR5nvtKZXaEsLg.png"/></div></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="ee36" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">默认情况下，一个Elasticsearch索引有5个主分片和1个副本。然而，这并不适合每一个用例。为了有效地维护索引，正确计算分片配置是非常重要的。</p><h1 id="69eb" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><strong class="ak">了解分片限制</strong></h1><p id="db7e" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">碎片大小对于搜索查询非常重要。如果分配给一个索引的分片太多，Lucene片段就会很小，这会导致开销增加。当同时进行多个查询时，大量的小碎片也会降低查询吞吐量。另一方面，太大的碎片会导致搜索性能下降和更长的故障恢复时间。因此，Elasticsearch建议一个碎片的大小应该在20到40 GB左右。</p><p id="419c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，如果您的索引将存储800 GBs的数据，您将为该索引分配20到40个主碎片。</p><p id="2276" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，根据集群的大小，假设集群中有25个节点，您将为该索引选择25个主碎片，以便在集群的节点之间平均分配碎片。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es ln"><img src="../Images/7bfdb22abc8e46f777c67f430ab35fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*GMzQoPamcWBqx4MRYfD9Fg.jpeg"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">弹性搜索索引拆分架构</figcaption></figure><blockquote class="ls lt lu"><p id="6108" class="im in lv io b ip iq ir is it iu iv iw lw iy iz ja lx jc jd je ly jg jh ji jj hb bi translated">确定最佳大小的最佳方法是用您自己的数据和查询进行测试。</p></blockquote><h1 id="0ea1" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><strong class="ak">本地负载均衡</strong></h1><p id="3e59" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">Elasticsearch自动处理负载平衡。但是，我们应该确保碎片总数(主碎片+次碎片)与节点数成比例。</p><p id="03ff" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这确保了负载在集群中不同节点之间的均匀分布。假设一个集群中有10个节点，碎片的数量应该是10的倍数。</p><p id="6fd3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果节点之间的负载分布不均衡，则碎片较多的节点上的资源使用率会较高，并且瞬时平均负载会高于其他节点。换句话说，其他节点上的资源将被较少使用，而具有更多碎片的节点将被较多使用。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lz"><img src="../Images/83959e0286d3487d2bff0d1d8f687df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5FJRBemXRaR9q5XdLgpMg.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">节点上索引的分片</figcaption></figure><p id="fd3a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里您可以看到，我们有12个主碎片，其中有3个副本。因此，我们总共有36个碎片分布在6个节点上。</p><p id="9e0a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">36/6 = 6(每个节点的碎片数)</p><p id="70dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当请求集群上的这个索引时，我们必须通过访问至少3个节点来搜索所有碎片(0到11)。我们应该访问最少数量的节点来快速满足请求。</p><h1 id="d3d9" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><strong class="ak">配置弹性搜索集群</strong></h1><p id="850f" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">配置Elasticsearch集群时，最主要的考虑之一是确保至少一半的可用内存用于文件系统缓存，以便Elasticsearch可以在物理内存中保留索引的热区域。</p><p id="bae4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在设计集群时，还应该考虑物理可用堆空间。Elasticsearch建议基于可用堆空间的碎片分配应该最大为20碎片/GB，这是一个很好的经验法则。例如，一个堆容量为30gb的节点最多应该有600个碎片，以保持集群的良好状态。一个节点上的存储可以用下面的公式表示:</p><p id="faaf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一个节点可以支持的磁盘空间= 20 *(每GB的堆大小)*(以GB为单位的碎片大小)</p><p id="12e3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于在高效集群中常见大小在20到40gb之间的碎片，因此具有16gb可用堆空间的节点最多可以支持12tb的磁盘空间。了解边界有助于为更好的设计和未来的扩展操作做准备。</p><blockquote class="ls lt lu"><p id="b36d" class="im in lv io b ip iq ir is it iu iv iw lw iy iz ja lx jc jd je ly jg jh ji jj hb bi translated">Elasticsearch可以使用的总内存是有限的，大约是32GB ( <a class="ae ma" href="https://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.html#compressed_oops" rel="noopener ugc nofollow" target="_blank">堆大小</a>)。备用内存用于操作系统缓存和Lucene内存数据结构。如果单个节点的索引总计大于32GB，那么GC收集会更频繁。</p></blockquote></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="8594" class="kk kl hi bd km kn mb kp kq kr mc kt ku kv md kx ky kz me lb lc ld mf lf lg lh bi translated"><strong class="ak">基于索引行为的优化</strong></h1><ol class=""><li id="68b5" class="jk jl hi io b ip li it lj ix mg jb mh jf mi jj jp jq jr js bi translated"><strong class="io hj">读取密集索引</strong></li></ol><p id="f5b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果索引被读取的频率远远高于它们被修改的频率，那么这个索引就被称为读密集型的。例如，电子商务产品搜索目录。</p><p id="1466" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于这样的索引，建议使用嵌套文档。与子文档相比，嵌套文档可以提高搜索性能。但是，将数据写入嵌套文档的成本非常高。</p><p id="f567" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">增加副本的数量可以在一定程度上提高性能。但是，由于硬件限制，性能会下降。可以通过逐个增加副本的数量来找到这个断点。可以使用JMeter、Apache Bench ab之类的工具，在增加副本数量的同时测量搜索性能。</p><p id="3711" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当索引设置为只读时，可以执行强制合并操作，通过合并段来减少段的数量。因此，优化的段将导致更好的搜索性能，因为每个分片的开销取决于段的数量和大小。不要将此应用于读写索引，因为这将导致产生非常大的段(每个段大于5Gb)。此外，该操作应该在非高峰时间进行，因为这是一个昂贵的操作。</p><p id="70b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.<strong class="io hj">写密集索引</strong></p><p id="0581" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果索引被修改的频率比被读取的频率高得多，那么这个索引就是读密集型的。在包含此类索引的集群中，资源通常用于写入数据。</p><p id="f8f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于写密集型索引，您应该定期重建索引。这是因为更新了文档。事实上，在elasticsearch中，文档不会更新，因为它们是不可变的。因此，用新数据创建了另一个文档，并且该文档的版本增加了1。当您重新编制索引时，新索引将包含最新版本的文档。因此索引大小将会减小。</p><p id="ed65" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.<strong class="io hj">过滤不查询</strong></p><p id="90b0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果在搜索中不需要评分功能，请避免使用查询。您应该更喜欢过滤器上下文。因为过滤器被缓存并且不影响分数，因此比查询更快。</p><p id="b002" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">4.<strong class="io hj">分度后复制</strong></p><p id="dc32" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当您索引一个文档时，首先将它写在主碎片上，然后复制到副本上。复制到副本是一项开销很大的操作，并且会限制初始索引。因此，在初始索引完成之前，应该禁用副本。</p><p id="c2da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">5.<strong class="io hj">主动监控集群</strong></p><p id="5217" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您应该使用一个好的性能监控工具来监控您的集群。比如ElasticHQ。这将允许您监视集群运行状况和更改后的响应。</p><p id="05b4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">6.<strong class="io hj">基于时间的索引</strong></p><p id="a2a0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您应该使用基于时间的索引来管理数据和更好地组织数据。如果对过去的索引没有写操作，可以将过去的每月索引设置为只读模式，以提高对这些索引的搜索性能。</p><p id="8cee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些是我在阅读其他媒体文章、技术博客和我自己的工作经验时发现的一些事实。</p><p id="83b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">希望你们觉得有帮助。</p><p id="9962" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">谢了。</p></div></div>    
</body>
</html>