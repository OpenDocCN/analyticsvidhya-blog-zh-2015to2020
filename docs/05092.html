<html>
<head>
<title>Understanding Generators in Python in Simple Way!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用简单的方式理解Python中的生成器！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-generators-in-python-in-simple-way-ae3cbf22309f?source=collection_archive---------31-----------------------#2020-04-10">https://medium.com/analytics-vidhya/understanding-generators-in-python-in-simple-way-ae3cbf22309f?source=collection_archive---------31-----------------------#2020-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="af11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python中的生成器函数允许我们编写一个函数，该函数可以发送回一个值，并在稍后恢复到它停止的地方。这些用来创建<a class="ae jd" href="https://www.geeksforgeeks.org/iterators-in-python/" rel="noopener ugc nofollow" target="_blank">迭代器</a>。</p><p id="a8f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设，我们想一个接一个地返回从1到10的数字的平方，然后我们创建一个函数，返回一个数字平方的列表，迭代返回的数字列表，然后一个接一个地打印数字:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="531a" class="jn jo hi jj b fi jp jq l jr js">def num_function():<br/>    num_list = []<br/>    for i in range(1, 11):<br/>        num_list.append(i**2)<br/>    return num_list<br/><br/>for i in num_function():<br/>    print(i)</span></pre><p id="1cfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的函数将逐行打印从1到10的数字的平方。这里，我们使用list将结果追加到其中。但是，你不认为把元素存储到一个列表中，然后再一次遍历这个列表来一个接一个地打印数字的平方是非常低效的吗？如果你也这样认为，那么python有一个解决方案，它提供了生成器函数来帮助你。现在，为了理解如何使用生成器函数，让我们创建上述相同的函数，但采用生成器函数的风格:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="6c9a" class="jn jo hi jj b fi jp jq l jr js">def num_gen_function():<br/>    for i in range(1, 11):<br/>        yield(i**2)<br/><br/>for i in num_gen_function():<br/>    print(i)</span></pre><p id="ed63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，你会得到相同的结果，但与内存效率。还有，这里你看到了<code class="du jt ju jv jj b">yield keyword</code>。这个yield关键字就像return关键字一样，返回值，但它与return关键字有很大不同。现在，我们知道return关键字在程序执行结束时返回值，但是这里yield的行为不同。yield在执行函数的中途返回一个值，它只是暂停函数，然后返回值。返回一个值后，函数从它停止的地方继续，新值将是先前返回的值的下一个值。这就是收益率和回报的区别。当我们想要返回一些值，并且在返回这些值之后，我们想要执行剩余的函数时，yield非常方便。</p><p id="42e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果你这样想，我们已经限制了list的使用，但是我们仍然使用for循环来迭代。对于这一点，我们也有一个解决方案，它的下一个()函数。让我们用它来访问从上面的num_gen_function()生成的元素:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="ef58" class="jn jo hi jj b fi jp jq l jr js">g = num_gen_function()<br/>print(next(g))           # will print 1<br/>print(next(g))           # will print 4<br/>print(next(next(g)))     # will print 16  why?</span></pre><p id="5ba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们将一个变量赋给了function，并使用next()函数来获取迭代器中的值。next()函数用于从集合中获取下一项。</p><blockquote class="jw jx jy"><p id="f1b8" class="if ig jz ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated">我们不能使用next()函数访问range()中的元素，因为它是一类不可变的iterable对象。欲了解更多信息，请访问<a class="ae jd" href="https://stackoverflow.com/a/13092317/12552274" rel="noopener ugc nofollow" target="_blank">此处</a>。现在，如果你想要一个迭代器，那么使用下面的方法将它转换成一个列表，并对它进行迭代:<br/> <code class="du jt ju jv jj b"><em class="hi">list(range(start, end)) or iter(range(start, end))</em></code></p></blockquote><figure class="je jf jg jh fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es kd"><img src="../Images/3f84d8a76ecbcf21862f2114a7712c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vE-D9nSofcZWKkXIJEBLRw.png"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated">高效内存生成器(图片来源:<a class="ae jd" href="http://www.pythonlikeyoumeanit.com" rel="noopener ugc nofollow" target="_blank">www.pythonlikeyoumeanit.com</a>)</figcaption></figure><p id="672d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以在任何需要的地方使用发电机。让我们看看如何使用生成器函数来生成斐波那契数列:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="5a98" class="jn jo hi jj b fi jp jq l jr js">def gen_fibonacci(n):<br/>	a = 1<br/>	b = 1<br/>	for i in range(n):<br/>		yield(a)<br/>		a, b = b, a+b<br/><br/>for num in gen_fibonacci(10):<br/>	print(num)</span></pre><p id="17cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们如何在python中使用生成器来实现更高效的内存程序，以及在返回值后执行一些代码。此外，我们可以有类似列表理解的生成器理解。欲了解更多关于发电机理解的信息，请访问<a class="ae jd" href="https://www.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Generators_and_Comprehensions.html#Creating-your-own-generator:-generator-comprehensions" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>