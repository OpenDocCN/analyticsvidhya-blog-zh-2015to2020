<html>
<head>
<title>15 reasons of read latency in Cassandra</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cassandra中读取延迟的15个原因</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/15-reasons-of-read-latency-in-cassandra-8d965f18f85c?source=collection_archive---------1-----------------------#2020-02-20">https://medium.com/analytics-vidhya/15-reasons-of-read-latency-in-cassandra-8d965f18f85c?source=collection_archive---------1-----------------------#2020-02-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/393f36a603f5d9107f97d12b9484132e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z7sx5fXNdXy7K0D6"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">斯坦尼斯拉夫·康德拉蒂耶夫在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4e5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是Cassandra读取延迟的一些可能原因:</p><p id="18d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 1。现代医学之父希波克拉底曾经说过“所有的疾病都始于肠道”，同样，我相信《卡桑德拉》中的所有主要问题都始于广泛的隔离。因此，这可能是你慢读的一个好理由。nodetool tablehistogram“分区大小”可以给出一个思路，理论上分区大小不应该超过100 mb。实际上，它应该远小于100 mb。</strong></p><p id="0208" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">修复:</strong>尝试对表的分区键进行分桶，使其具有瘦分区。例如:对于一个雇员表，组织名称上的分区键可能是一个坏的选择，但是(组织，部门)可能是一个修正。</p><p id="ad1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。错误查询:</strong>下面是一些会导致协调器级延迟的错误查询的示例。</p><ul class=""><li id="ac2b" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">全表扫描:例如select * from employeeselect count(*)from employee；</li><li id="f5ba" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">使用允许过滤。</li><li id="56f1" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">使用IN子句。</li></ul><p id="97ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">修复:</strong>对于全扫描，您可以使用spark。如果那是不可能的，你可以试试</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="aa2e" class="kq kr hi km b fi ks kt l ku kv">cqlsh -e "copy keyspace.table_name (first_partition_key_name) to '/dev/null'" | sed -n 5p | sed 's/ .*//'</span></pre><p id="0cf9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于其他人，尽量避免运行它们，因为它们不可扩展，并且会随着数据的增长而面临挑战。如果您发现任何特定的查询需要时间，那么您可以在cqlsh中进行“跟踪”,然后运行一个有问题的查询或“node tool settrace probability 0.001”(这里，要小心将该值设置得太高的含义)并检查跟踪以查看发生了什么。</p><p id="3e42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。触摸的表的数量:</strong>如果在读取过程中触摸了更多的表(例如:95%触摸2个以上的表),那么您可以期待cassandra集群有所改进。您可以使用nodetool表/cf直方图来检查这一点</p><p id="5570" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">修复:</strong>确保你的压实没有滞后。尝试调整压缩策略或concurrent _ compactors或compaction_throughput选项。</p><p id="f3b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 4。阻塞读取修复:</strong>由于读取期间的摘要不匹配，将触发阻塞读取修复。您可以检查调试日志digestmismatch异常(该异常的某些数字不是预期的，但不应该以吨为单位)</p><p id="57af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">修复:</strong>通过定期运行反熵修复来保持集群的一致性和健康性。写完数据后立即读取数据也可能导致这种情况，请检查延迟的可能性。</p><p id="bd2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 5。推测性重试:</strong> Cassandra被设计成容错的，因此可以很容易地处理故障节点，但是处理故障节点可能很困难。换句话说，Cassandra节点完全关闭是没问题的，但如果节点状态波动(经常无响应)，则会由于推测性重试而导致读取延迟，因为节点没有完全关闭，而是变得。</p><p id="edab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">修复:</strong>需要识别故障节点并排除故障。还要检查您的应用程序是否均匀地分配了负载。确保你的分区键是均匀分布的。也试着禁用cassandra.yaml中的dynamic _ snitch并测试。</p><p id="0268" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 6。次要索引:</strong>如果选择不当，将导致协调员级别的延迟。如果你在非常高的基数字段(例如:电子邮件id或任何唯一的id)或非常低的基数字段(例如:性别:男/女)上创建SI，那么你就有麻烦了。</p><p id="942c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 7。一致性级别和跨DC流量:</strong>随着一致性级别的提高，读取操作将会变慢。在多dc群集中使用QUOURM一致性会导致跨DC流量，从而导致读取速度变慢。</p><p id="aa33" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">修复:</strong>如果可能，在多dc集群的情况下，尝试使用LOCAL_QUORUM。如果您不想要很强的一致性，您可以使用小于QUORUM的读取一致性。避免在生产中使用所有一致性。</p><p id="1f60" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 8。墓碑:</strong>如果你的表和范围中有很多墓碑，那么读取将会很慢，如果在新版本的Cassandra中越过tombstone_warn_threshold，你将会看到警告。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9bd4" class="kq kr hi km b fi ks kt l ku kv">WARN org.apache.cassandra.db.ReadCommand Read 0 live rows and 87051 tombstone cells for query SELECT * FROM example.table</span></pre><p id="30a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您还可以检查sstable元数据来检查逻辑删除率。</p><p id="d7bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">修复:</strong>如果可能的话，首先尽量避免创建墓碑。也可以查看我的第一篇<a class="ae iu" rel="noopener" href="/analytics-vidhya/how-to-resolve-high-disk-usage-in-cassandra-870674b636cd">文章</a>如何通过调优来照顾墓碑。</p><p id="4786" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 9。每秒巨大的读取数(rkB/s): </strong>查看nodetool tpstats的输出以了解情况。大量挂起/数据块读取阶段会导致读取延迟增加。</p><p id="758a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">修复:</strong>通常通过添加节点或减少客户端的读取吞吐量来解决。</p><p id="42cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">10。缓存不足:没有足够的ram会降低读取速度，因为内核必须从磁盘读取，而不是从页面缓存读取。所以有足够的页面缓存是好的。Cassandra还提供了一些缓存，如键缓存、行缓存，这些缓存只能在非常特殊的情况下进行调整(例如:频繁读取一些行)</p><p id="f8d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">11。硬件问题:Cassandra中建议使用本地ssd进行快速读取。<strong class="ix hj">修复:</strong>避免使用NAS或SAN。</p><p id="9389" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 12。布隆过滤器:</strong>检查节点工具表状态，大量的布隆过滤器误报计数会导致读取延迟。修复:调整bloom_filter_fp_chance:根据可用ram和表的数量进行调整，对于读取速度慢和大量表，降低fp更改以减少磁盘io。请注意，这将增加内存的使用。</p><p id="5d9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 13。网络延迟和吞吐量:</strong>您可以检查nodetool proxyhistogram和，在系统级，您可以使用ping、traceroute或mtr检查延迟，使用iftop命令检查网络吞吐量</p><p id="9854" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 14垃圾收集:</strong>检查gc日志和nodetool gcstas以查看gc暂停。垃圾收集可能是由多种原因造成，如错误的数据模型、没有足够的最大堆大小(至少从8G开始)或未调优的其他垃圾收集参数等。</p><p id="e01f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">15。资源受限:检查您的系统在读取期间是否不受cpu或io的限制。您可以使用top/htop或iostat这样命令。页面缓存可以使查询更快，因此您还可以使用free命令检查是否有足够的页面缓存可用。较高的预读值(&gt; 128 kb)或默认的chunk_length_in_kb (256 kb)可能会导致较高的i/o和读取延迟。<br/> <strong class="ix hj">修复:</strong> Apache Cassandra有一篇关于相同的<a class="ae iu" href="http://cassandra.apache.org/doc/4.0/troubleshooting/use_tools.html" rel="noopener ugc nofollow" target="_blank">文章</a>。另外，使用<em class="kw"> blockdev — report </em>命令检查预读值，并使用<em class="kw"> blockdev— setra </em>命令将其设置为8 kb。尝试使用4 kb的chunk_length_in_kb在读取时一次读取较少字节的块，并观察性能。确保逐个调整参数，以确定每个变化的影响。</p><p id="c603" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">结论:</strong>只有拥有合适的数据模型和访问模式，Cassandra才能很好地适应您的应用。Cassandra调优是复杂的，在这篇博客中，我给出了解决Cassandra中读取延迟时需要检查的要点的高度概述。</p><p id="cfd7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你遇到任何问题，请随时在评论中添加更多观点。</p></div></div>    
</body>
</html>