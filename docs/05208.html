<html>
<head>
<title>How to extract emails and attachments from Gmail with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python从Gmail中提取邮件和附件</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-extract-emails-and-attachments-from-gmail-with-python-f694f297818b?source=collection_archive---------1-----------------------#2020-04-14">https://medium.com/analytics-vidhya/how-to-extract-emails-and-attachments-from-gmail-with-python-f694f297818b?source=collection_archive---------1-----------------------#2020-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="edba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个中等故事，非常精彩。这里有一个代码为<a class="ae jd" href="https://github.com/andreiaugustin/gmail_extractor" rel="noopener ugc nofollow" target="_blank">https://github.com/andreiaugustin/gmail_extractor</a>的TLDR</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/0653670fe90fa933cc18f811cf1c963d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nwg-6KFUn66GhjOu"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由<a class="ae jd" href="https://unsplash.com/@webaroo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Webaroo </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ad82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最近开发了一个新的支持系统，其中一个目标是将存储在Gmail邮箱中的旧数据转移到数据库中。</p><p id="da87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主要用C++工作，我很清楚我不能浪费超过一个下午的时间来提取数据，我当然不想用C++来做。因此，Python是这项任务的下一个合乎逻辑的选择。</p><p id="6a29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我把这个简单的工具放在一起，它提取一些信息，如主题、发件人、日期和邮件正文，并把所有这些信息转换成一种方便的JSON格式。此外，这也将提取电子邮件的所有附件。最后，它会将所有内容放入一个以电子邮件的UID命名的文件夹中。</p><p id="c9cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">逐步构建一切:</p><p id="ff04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，创建一个Python文件，例如gmail_extractor.py，让我们开始导入所需的模块。</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="b47c" class="jz ka hi jv b fi kb kc l kd ke">import imaplib<br/>import os<br/>import email<br/>import sys<br/>import json</span></pre><p id="7f39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，让我们创建一个满足我们所有需求的类。我知道大多数Python开发人员只会为此使用函数，并简单地在__main__中调用它们。然而，我喜欢在栈底保留__main__作为额外的控制级别，以防我需要向程序中添加内容。</p><p id="d77f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将调用类GMAIL_EXTRACTOR，并从定义两个函数开始，helloWorld和initializeVariables。helloWorld只是个人接触，想跳过就跳过:)</p><p id="b120" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想在Python中初始化变量的原因是因为我来自C++背景，当我阅读一些代码时，我喜欢看到一个类的成员，以便快速找出我将需要什么来将那个类集成到我的代码库中。</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="3347" class="jz ka hi jv b fi kb kc l kd ke">class GMAIL_EXTRACTOR():<br/>    def helloWorld(self):<br/>        print("\nWelcome to Gmail extractor,\ndeveloped by A. Augustin.")</span><span id="af92" class="jz ka hi jv b fi kf kc l kd ke"><br/>    def initializeVariables(self):<br/>        self.usr = ""<br/>        self.pwd = ""<br/>        self.mail = object<br/>        self.mailbox = ""<br/>        self.mailCount = 0<br/>        self.destFolder = ""<br/>        self.data = []<br/>        self.ids = []<br/>        self.idsList = []</span></pre><p id="c0c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，让我们定义一个函数来获取用户的登录详细信息:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="6651" class="jz ka hi jv b fi kb kc l kd ke">def getLogin(self):<br/>    print("\nPlease enter your Gmail login details below.")<br/>    self.usr = input("Email: ")<br/>    self.pwd = input("Password: ")</span></pre><p id="91ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，我们只从用户那里得到电子邮件和密码，并将它们保存在usr和pwd类变量中。</p><p id="a19a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理登录本身的函数:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="4316" class="jz ka hi jv b fi kb kc l kd ke">def attemptLogin(self):<br/>    self.mail = imaplib.IMAP4_SSL("imap.gmail.com", 993)<br/>    if self.mail.login(self.usr, self.pwd):<br/>        print("\nLogon SUCCESSFUL")<br/>        self.destFolder = input("\nPlease choose a destination folder in the form of /Users/username/dest/ (do not forget trailing slash!): ")<br/>        if not self.destFolder.endswith("/"): self.destFolder+="/"<br/>        return True<br/>    else:<br/>        print("\nLogon FAILED")<br/>        return False</span></pre><p id="cae8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们硬编码Google的IMAP地址和端口。他们不太可能改变，所以我们很好。接下来，我们尝试登录并向用户询问目标文件夹，否则我们只打印登录失败并返回False，这样我们可以在抽象的上一层处理失败。</p><p id="27bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从用户处获取邮箱名称并将其“选择”为我们的工作邮箱的功能:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="9537" class="jz ka hi jv b fi kb kc l kd ke">def selectMailbox(self):<br/>    self.mailbox = input("\nPlease type the name of the mailbox you want to extract, e.g. Inbox: ")<br/>    bin_count = self.mail.select(self.mailbox)[1]<br/>    self.mailCount = int(bin_count[0].decode("utf-8"))<br/>    return True if self.mailCount &gt; 0 else False</span></pre><p id="97ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将允许我们选择我们希望使用的邮箱，并跟踪邮箱中有多少电子邮件。如果电子邮件的数量为0或更少，我们也返回False，这样抽象的上一层可以处理当邮箱为空时应该发生的事情。在这个工具中，我只是在上面两种情况下使用sys.exit()-ing，虽然可以实现一些错误消息来使最终用户更容易使用它，但归根结底，这是开发人员的一个工具。</p><p id="2d41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个搜索邮箱的功能:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="bf72" class="jz ka hi jv b fi kb kc l kd ke">def searchThroughMailbox(self):<br/>    type, self.data = self.mail.search(None, "ALL")<br/>    self.ids = self.data[0]<br/>    self.idsList = self.ids.split()</span></pre><p id="8b5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个功能就不多说了。它搜索邮箱中的所有电子邮件，保存id，并列出id列表。</p><p id="51ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个问题是询问用户是否希望继续提取过程:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="45b6" class="jz ka hi jv b fi kb kc l kd ke">def checkIfUsersWantsToContinue(self):<br/>   print("\nWe have found "+str(self.mailCount)+" emails in the mailbox "+self.mailbox+".")<br/>   return True if input("Do you wish to continue extracting all the emails into "+self.destFolder+"? (y/N) ").lower().strip()[:1] == "y" else False</span></pre><p id="68ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将致力于我们的主要功能。如果你愿意，我们的引擎。这也许可以被分成更小的功能，但我只是想在一个下午得到一些工作。让我们称这个函数为parseEmails:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="e90d" class="jz ka hi jv b fi kb kc l kd ke">def parseEmails(self):<br/>    jsonOutput = {}<br/>        for anEmail in self.data[0].split():<br/>        type, self.data = self.mail.fetch(anEmail, '(UID RFC822)')<br/>        raw = self.data[0][1]<br/>        raw_str = raw.decode("utf-8")<br/>        msg = email.message_from_string(raw_str)</span><span id="469d" class="jz ka hi jv b fi kf kc l kd ke">        jsonOutput['subject'] = msg['subject']<br/>        jsonOutput['from'] = msg['from']<br/>        jsonOutput['date'] = msg['date']<br/>        <br/>        raw = self.data[0][0]<br/>        raw_str = raw.decode("utf-8")<br/>        uid = raw_str.split()[2]<br/>        # Body #<br/>        if msg.is_multipart():<br/>            for part in msg.walk():<br/>                partType = part.get_content_type()<br/>                ## Get Body ##<br/>                if partType == "text/plain" and "attachment" not in part:<br/>                    jsonOutput['body'] = part.get_payload()<br/>                ## Get Attachments ##<br/>                if part.get('Content-Disposition') is None:<br/>                    attchName = part.get_filename()<br/>                    if bool(attchName):<br/>                        attchFilePath = str(self.destFolder)+str(uid)+str("/")+str(attchName)<br/>                    os.makedirs(os.path.dirname(attchFilePath), exist_ok=True)<br/>                    with open(attchFilePath, "wb") as f:<br/>                        f.write(part.get_payload(decode=True))<br/>        else:<br/>            jsonOutput['body'] = msg.get_payload(decode=True).decode("utf-8") # Non-multipart email, perhaps no attachments or just text.</span><span id="5b59" class="jz ka hi jv b fi kf kc l kd ke">        outputDump = json.dumps(jsonOutput)<br/>        emailInfoFilePath = str(self.destFolder)+str(uid)+str("/")+str(uid)+str(".json")<br/>        os.makedirs(os.path.dirname(emailInfoFilePath), exist_ok=True)<br/>        with open(emailInfoFilePath, "w") as f:<br/>            f.write(outputDump)</span></pre><p id="53c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里发生了很多事情。我们首先获取电子邮件及其uid，对其进行解码，然后遍历其各个部分以获取正文和附件，然后将它们保存在每封电子邮件的特定文件夹中。</p><p id="f615" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了结束这堂课，我们写出__init__:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="49d2" class="jz ka hi jv b fi kb kc l kd ke">def __init__(self):<br/>    self.initializeVariables()<br/>    self.helloWorld()<br/>    self.getLogin()<br/>    if self.attemptLogin():<br/>        not self.selectMailbox() and sys.exit()<br/>    else:<br/>        sys.exit()<br/>    not self.checkIfUsersWantsToContinue() and sys.exit()<br/>    self.searchThroughMailbox()<br/>    self.parseEmails()</span></pre><p id="daed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结束我们的节目，我们的主要节目:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="90e9" class="jz ka hi jv b fi kb kc l kd ke">if __name__ == "__main__":<br/>    run = GMAIL_EXTRACTOR()</span></pre><p id="bb54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！这可以做得更好，但最终它完成了工作，我不用花超过几个小时的时间，所以每个人都很高兴:)</p><p id="eee0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">/*更新*/</p><p id="1e81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您发现自己遇到了一些UnicodeDecodeError异常问题，那是因为您可能正在解析的电子邮件具有不同的编码，即发件人可能正在使用Outlook。我们可以通过将转换为UTF-8的代码封装在try/except块中来解决这个问题，并尝试解码ASCII和ISO-8859–1，如下所示:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="0e24" class="jz ka hi jv b fi kb kc l kd ke">try:<br/>    raw_str = raw.decode("utf-8")<br/>except UnicodeDecodeError:<br/>    try:<br/>        raw_str = raw.decode("ISO-8859-1") # ANSI support<br/>    except UnicodeDecodeError:<br/>        try:<br/>            raw_str = raw.decode("ascii") # ASCII ?<br/>        except UnicodeDecodeError:<br/>            pass</span></pre></div></div>    
</body>
</html>