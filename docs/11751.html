<html>
<head>
<title>Building REST APIs using Flask-RESTPlus, SQLAlchemy &amp; Marshmallow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Flask-RESTPlus、SQLAlchemy &amp; Marshmallow 构建 REST APIs</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-rest-apis-using-flask-restplus-sqlalchemy-marshmallow-cff76b202bfb?source=collection_archive---------0-----------------------#2020-12-17">https://medium.com/analytics-vidhya/building-rest-apis-using-flask-restplus-sqlalchemy-marshmallow-cff76b202bfb?source=collection_archive---------0-----------------------#2020-12-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/be9b181a8405c15c771bc5b668c81607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y2ofBou72oLvZjo1h7O_ag.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">带 SqlAlchemy 的 flask-Restplus</figcaption></figure><p id="e980" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> Python </strong>是一种解释型的高级通用编程语言。它可以用来开发业务应用程序以及系统脚本，具有数据科学相关的功能，桌面图形用户界面，还为 web 和 internet 开发提供了许多选择。</p><p id="0c4e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> Flask </strong>是一个用 Python 编写的微型 web 框架，帮助你轻松构建 web 应用。它不需要工具或库，也没有数据库抽象层、表单验证、序列化程序、用户管理或内置国际化。但是，它支持可以添加应用程序特性的扩展，就好像它们是在 Flask 中实现的一样。一个有抱负的 Flask 开发者必须选择正确的扩展，并将它们组合在一起，以获得合适的功能集。</p><p id="fdd6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本教程的目的是使用 Flask 扩展，帮助我们创建一个生产环境就绪的 Python 应用程序，并顺利地与 Swagger UI 集成。我们将学习使用 Flask 扩展来构建 Rest API，例如<a class="ae js" href="https://flask-restplus.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj"><em class="jt">Flask-RestPlus</em></strong></a>，<a class="ae js" href="https://flask-marshmallow.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj"><em class="jt">Flask-Marshmallow</em></strong></a>和<a class="ae js" href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj"><em class="jt">Flask-SQLAlchemy</em></strong></a><strong class="iw hj"><em class="jt"/></strong>并使用<a class="ae js" href="https://swagger.io/tools/swagger-ui/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> Swagger 共享<strong class="iw hj"> <em class="jt"> API </em> </strong></strong></a></p><h2 id="5095" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated"><strong class="ak">烧瓶和烧瓶支架</strong></h2><p id="56ee" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">Flask 是一个轻量级的 web 服务器和框架。尽管我们可以直接用<code class="du ku kv kw kx b">flask</code>创建 Web API，但是<a class="ae js" href="https://flask-restplus.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Flask-RESTPlus </a>扩展使得构建 Rest APIs 更加简单。</p><ul class=""><li id="6633" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">它支持名称空间，名称空间是创建前缀和构建代码的方式。</li><li id="c195" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">它拥有解析和验证输入参数的完整解决方案。这意味着我们有一种简单的方法来处理需要几个参数的端点并验证它们。</li><li id="8684" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">它最好的特性是能够使用<a class="ae js" href="https://swagger.io/tools/swagger-ui/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> Swagger UI </strong> </a>为我们的 API 自动生成交互式文档。</li></ul><h2 id="9d09" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">烧瓶棉花糖</h2><p id="1733" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">Marshmallow 是一个 ORM/ODM/框架无关的库，旨在简化序列化和反序列化的过程。Flask-Marshmallow 扩展充当 Flask 和 Marshmallow 的一个薄集成层，为 Marshmallow 增加了额外的功能，包括 HATEOAS 就绪 API 的 URL 和超链接字段。它还集成了<strong class="iw hj"> Flask-SQLAlchemy </strong>并减少了一些样板代码。</p><h2 id="2e78" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">烧瓶化学</h2><p id="264f" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated"><a class="ae js" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>是一个方便 Python 程序和数据库之间通信的库，它为应用程序开发人员提供了 SQL 的全部功能和灵活性。Flask-SQLAlchemy 扩展通过提供有用的缺省值和额外的帮助器简化了 Flask 应用程序中<a class="ae js" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>的使用，使其更容易完成常见任务。它为我们提供了一个 ORM，通过简单地创建已定义的模型来修改应用程序数据。</p><h2 id="9a60" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated"><strong class="ak"> Swagger UI </strong></h2><p id="6eb7" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">Swagger UI 有助于生成交互式文档，这使得测试 Rest API 以及与其他用户共享 API 文档变得更加容易。因此，没有 Swagger UI，Flask API 是不完整的。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="e41f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是为商品和商店管理应用程序创建基于 Flask 的 API 示例所需的步骤:</p><ol class=""><li id="6089" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr lt le lf lg bi translated">设置和安装</li><li id="0e03" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr lt le lf lg bi translated">一体式烧瓶-棉花糖</li><li id="3084" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr lt le lf lg bi translated">一体化烧瓶-SQLAlchemy</li><li id="e3f9" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr lt le lf lg bi translated">创建模型</li><li id="0b5e" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr lt le lf lg bi translated">创建模式</li><li id="a4c7" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr lt le lf lg bi translated">创建资源</li><li id="857a" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr lt le lf lg bi translated">应用程序入口点</li><li id="3abd" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr lt le lf lg bi translated">测试 API</li></ol><h2 id="64b2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">先决条件</h2><p id="d229" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">我们需要安装了<strong class="iw hj"> Pipenv </strong>和<a class="ae js" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>的 Python 3。Pipenv 是一个包和一个虚拟环境管理器，它在幕后使用<code class="du ku kv kw kx b">PIP</code>。它提供了更高级的特性，比如版本锁定和项目间的依赖隔离。</p><h2 id="da5a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">1.设置和安装</h2><p id="c241" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">一旦先决条件就绪，我们就可以开始创建应用程序了。</p><p id="5c19" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> a)创建一个示例项目&amp; Store Management Flask 应用程序<br/> </strong>首先，我们的应用程序在磁盘上的任意目录下为我们的项目创建一个名为<code class="du ku kv kw kx b">python-sample-flask-application</code>的文件夹。</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="8ba3" class="ju jv hi kx b fi mc md l me mf">$ cd /path/to/my/workspace/<br/>$ mkdir python-sample-flask-application<br/>$ cd python-sample-flask-application</span></pre><p id="f87f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">导航到项目文件夹。</p><p id="9716" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">b)激活虚拟环境</p><p id="4652" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">进入项目文件夹后，执行以下命令来激活 VirtualEnv。</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="7584" class="ju jv hi kx b fi mc md l me mf">pipenv shell</span></pre><p id="6773" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">虚拟环境现在将被激活，这将提供所需的项目隔离和版本锁定。</p><p id="ded8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> c)安装依赖关系</strong></p><p id="516d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，使用 Pipenv 安装所有必需的依赖项，如图所示。</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="4109" class="ju jv hi kx b fi mc md l me mf">pipenv install flask-restplus<br/>pipenv install flask-marshmallow<br/>pipenv install flask-sqlalchemy<br/>pipenv install marshmallow-sqlalchemy</span></pre><p id="0e7a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们执行上述命令之后，将会安装所需的依赖项。</p><p id="0ea4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们现在可以看到在我们的项目文件夹中创建的两个文件，即<code class="du ku kv kw kx b">Pipfile</code>和<code class="du ku kv kw kx b">Pipfile.lock</code>。</p><ul class=""><li id="f20e" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated"><code class="du ku kv kw kx b">Pipfile</code>包含了我们刚刚安装的所有依赖项的名称。</li><li id="1854" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated"><code class="du ku kv kw kx b">Pipfile.lock</code>旨在根据<code class="du ku kv kw kx b">Pipfile</code>中出现的依赖关系，指定应该使用哪个特定版本的依赖关系，避免自动升级相互依赖的依赖关系和破坏项目依赖树的风险。</li></ul><p id="607f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">执行上述命令时安装的所有依赖版本如下所示。</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="00b2" class="ju jv hi kx b fi mc md l me mf">flask-restplus = "==0.13.0"<br/>flask-marshmallow = "==0.14.0"<br/>flask-sqlalchemy = "==2.4.4"<br/>marshmallow-sqlalchemy = "==0.24.1"</span></pre><p id="3660" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">依赖版本将取决于当时可用的最新版本。如果需要，我们还可以使用语法<code class="du ku kv kw kx b">flask-restplus = "==0.13.0"</code>在<code class="du ku kv kw kx b">Pipfile</code>中更新或指定任何依赖项的版本号</p><p id="0c8d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> d)更新‘Werkzeug’依赖版本</strong></p><p id="9d67" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我们安装<code class="du ku kv kw kx b">flask-restplus</code>时，<strong class="iw hj"> werkzeug </strong>是一个全面的 WSGI web 应用程序库，随版本<code class="du ku kv kw kx b">1.0.1</code>自动安装。我们可以在<code class="du ku kv kw kx b">Pipfile.lock</code>文件中找到该条目，如下所示:</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="f292" class="ju jv hi kx b fi mc md l me mf">"werkzeug": {<br/>    "hashes": [<br/>        "sha256:2de2a5db0baeae7b2d2664949077c2ac63fbd16d98da0ff71837f7d1dea3fd43",<br/>        "sha256:6c80b1e5ad3665290ea39320b91e1be1e0d5f60652b964a3070216de83d2e47c"<br/>    ],<br/>    "version": "==1.0.1"<br/>}</span></pre><p id="6c5a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，<strong class="iw hj"> flask-restplus </strong>目前与扩展"<strong class="iw hj"> werkzeug=1.0.1 </strong>"不兼容。因此，我们需要按照 Github 中的建议将版本降级为<code class="du ku kv kw kx b">werkzeug==0.16.1</code>:<a class="ae js" href="https://github.com/noirbizarre/flask-restplus/issues/777#issuecomment-583235327" rel="noopener ugc nofollow" target="_blank">https://Github . com/noirbizarre/flask-restplus/issues/777 # issue comment-583235327</a>。</p><p id="aa1d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，让我们将<code class="du ku kv kw kx b">Pipfile</code>中的<code class="du ku kv kw kx b">werkzeug</code>版本降级，并更新已安装的依赖项。</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="92a5" class="ju jv hi kx b fi mc md l me mf">[[source]]<br/>name = "pypi"<br/>url = "https://pypi.org/simple"<br/>verify_ssl = true<br/><br/>[dev-packages]<br/><br/>[packages]<br/>flask-restplus = "==0.13.0"<br/>flask-marshmallow = "==0.14.0"<br/>werkzeug = "==0.16.1"<br/>flask-sqlalchemy = "==2.4.4"<br/>marshmallow-sqlalchemy = "==0.24.1"<br/><br/>[requires]<br/>python_version = "3.7"</span></pre><p id="bd62" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要更新已安装的依赖项，请执行以下命令。</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="0547" class="ju jv hi kx b fi mc md l me mf">pipenv update</span></pre><p id="c06e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们已经准备好为我们的应用程序编写一些代码了。</p><h2 id="c53f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">2.一体式烧瓶-棉花糖</h2><p id="75b6" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">为了将 Flask-Marshmallow 与我们的应用程序集成，创建一个包含以下内容的文件<code class="du ku kv kw kx b">ma.py</code>。</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="84d6" class="ju jv hi kx b fi mc md l me mf">from flask_marshmallow import Marshmallow<br/>ma = Marshmallow()</span></pre><p id="7613" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，我们从<code class="du ku kv kw kx b">flask_marshmallow</code>进口了棉花糖。稍后，我们将使用这个棉花糖实例<code class="du ku kv kw kx b">ma</code>通过命令<code class="du ku kv kw kx b">ma.init_app(app)</code>与 flask 应用程序集成。</p><h2 id="bfde" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">3.一体化烧瓶-SQLAlchemy</h2><p id="7574" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">对于 Flask-SqlAlchemy 集成，创建一个名为<code class="du ku kv kw kx b">db.py</code>的文件，其内容如下。</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="1c43" class="ju jv hi kx b fi mc md l me mf">from flask_sqlalchemy import SQLAlchemy<br/>db = SQLAlchemy()</span></pre><p id="c1a0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，我们从<code class="du ku kv kw kx b">flask_sqlalchemy</code>引入了 SQLAlchemy。我们还将使用这个 SQLAlchemy 实例<code class="du ku kv kw kx b">db</code>通过命令<code class="du ku kv kw kx b">db.init_app(app)</code>与 flask 应用程序集成。</p><h2 id="cc06" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">4.创建数据库模型</h2><p id="e8c6" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">接下来，我们将为我们的数据存储和组织创建数据库模型。对于我们的应用程序，我们需要创建两个数据库模型 Item 和 Store。我们将使用<code class="du ku kv kw kx b">db</code>，来自 Flask-SQLAlchemy 的 SQLAlchemy 的实例，它是我们在前面(步骤 3)创建模型时创建的。</p><p id="dd3a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ku kv kw kx b">db</code>实例包含来自<code class="du ku kv kw kx b"><strong class="iw hj">sqlalchemy</strong></code>和<code class="du ku kv kw kx b"><a class="ae js" href="http://docs.sqlalchemy.org/en/latest/orm/scalar_mapping.html#module-sqlalchemy.orm" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">sqlalchemy.orm</strong></a></code>的所有函数和助手。它提供了一个名为<code class="du ku kv kw kx b">Model</code>的类，这是一个声明性的基础，可以用来声明我们的模型。</p><p id="e29e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建<code class="du ku kv kw kx b">models</code>包并添加两个名为<code class="du ku kv kw kx b">Item.py</code>和<code class="du ku kv kw kx b">Store.py</code>的文件。</p><p id="092e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">4.1 item . py<br/>T29】item . py 文件应该包含以下内容。</strong></p><figure class="lu lv lw lx fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="42a6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ku kv kw kx b">item.py</code>中的上述代码执行以下操作:</p><ul class=""><li id="83c1" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">我们从在<code class="du ku kv kw kx b">line 5</code>中创建 ItemModel 类开始。</li><li id="7a50" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">在<code class="du ku kv kw kx b">line 6</code>中，我们声明了这个模型将被映射到的表名<code class="du ku kv kw kx b">items</code>。</li><li id="54bf" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 8 to 10</code>开始，我们定义了表格列及其数据类型。</li><li id="6958" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">我们在<code class="du ku kv kw kx b">line 12 and 13.</code>中定义了与 StoreModel 的关系</li><li id="4a0d" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 26</code>到<code class="du ku kv kw kx b">36</code>，我们增加了一些帮助器方法来执行<code class="du ku kv kw kx b">items</code>表上的搜索操作。</li><li id="4e28" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 38</code>到<code class="du ku kv kw kx b">40</code>，我们定义了<code class="du ku kv kw kx b">save_to_db</code>方法来保存数据库中的条目。</li><li id="2f74" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 42</code>到<code class="du ku kv kw kx b">44</code>，我们定义了<code class="du ku kv kw kx b">delete_from_db</code>方法来从数据库中删除条目。</li></ul><p id="db83" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">4.2 store . py<br/>T29】store . py 文件应该包含以下内容。</strong></p><figure class="lu lv lw lx fd ij"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">商店. py</figcaption></figure><p id="d6bb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ku kv kw kx b">store.py</code>中的上述代码执行以下操作:</p><ul class=""><li id="5e7a" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">我们从在<code class="du ku kv kw kx b">line 5</code>创建 StoreModel 类开始。</li><li id="b605" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">在<code class="du ku kv kw kx b">line 6</code>中，我们声明了这个模型将被映射到的表名<code class="du ku kv kw kx b">stores</code>。</li><li id="c7fc" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 7 to 8</code>开始，我们定义了表格列及其数据类型。</li><li id="4226" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">我们在<code class="du ku kv kw kx b">line 10.</code>中定义了与 ItemModel 的关系</li><li id="b812" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 17</code>到<code class="du ku kv kw kx b">27</code>，我们添加了一些帮助器方法来对<code class="du ku kv kw kx b">stores</code>表执行搜索操作。</li><li id="2c97" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 29</code>到<code class="du ku kv kw kx b">31</code>，我们定义了<code class="du ku kv kw kx b">save_to_db</code>方法来保存数据库中的商店。</li><li id="8faa" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 33</code>到<code class="du ku kv kw kx b">35</code>，我们定义了从数据库中删除商店的<code class="du ku kv kw kx b">delete_from_db</code>方法。</li></ul><p id="5e20" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ku kv kw kx b">Item</code>和<code class="du ku kv kw kx b">Store</code>类继承自<code class="du ku kv kw kx b">db.Model</code>类，后者将该类声明为 SQLAlchemy 的模型。必需的列在模型类中定义。此外，我们定义了商品和商店之间的关系。商店与商品有一对多关系。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/27e048d69427106b1e090d8babedb0f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*emb3u8kDOmUx7BCjE8P7WA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">实体图</figcaption></figure><h2 id="cc6e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">5.创建模式</h2><p id="0608" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">使用<code class="du ku kv kw kx b"><a class="ae js" href="https://flask-marshmallow.readthedocs.io/en/latest/#flask_marshmallow.sqla.SQLAlchemyAutoSchema" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">SQLAlchemyAutoSchema</strong></a></code>从我们之前定义的模型中创建棉花糖<code class="du ku kv kw kx b"><a class="ae js" href="https://marshmallow.readthedocs.io/en/latest/api_reference.html#marshmallow.Schema" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">Schemas</strong></a></code>。我们将使用<code class="du ku kv kw kx b">ma</code>，来自 Flask-Marshmallow 的 Marshmallow 的实例，它是我们在前面(步骤 2)创建的，用于创建我们的模式。</p><p id="0205" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建<code class="du ku kv kw kx b">schemas</code>包并添加两个名为<code class="du ku kv kw kx b">Item.py</code>和<code class="du ku kv kw kx b">Store.py</code>的文件。</p><p id="e11c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">5.1 item . py<br/>T32】item . py 文件应该包含以下内容。</strong></p><figure class="lu lv lw lx fd ij"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">ItemSchema.py</figcaption></figure><p id="1a57" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">5.2 store . py<br/>T17】store . py 文件应该包含以下内容。</strong></p><figure class="lu lv lw lx fd ij"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">StoreSchema.py</figcaption></figure><p id="45d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们需要为每个模型类创建一个模式，这是我们之前定义的(步骤 4)。一旦我们定义了模式，我们现在就可以使用这些模式来转储和加载 ORM 对象。</p><h2 id="a85c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">6.创建资源</h2><p id="f9fd" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">Flask-RESTPlus 提供了许多方法来组织我们的应用程序，并在粒度级别上维护它们，例如资源、名称空间和蓝图。我们会继续讨论这个问题。</p><p id="f91c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">资源</strong><br/>Flask-RESTPlus 提供的主要构件是资源。资源构建在<a class="ae js" href="https://flask.palletsprojects.com/en/1.1.x/views/#views" rel="noopener ugc nofollow" target="_blank"> Flask pluggable views </a>之上，让我们只需在资源上定义方法就可以轻松访问多个 HTTP 方法。</p><p id="10ae" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ku kv kw kx b">resource</code>是一个类，它的方法被映射到一个 API/URL 端点。它可以有多个方法，但是每个方法都必须以一个可接受的 HTTP 动词命名。如果我们的 API 需要不止一个<code class="du ku kv kw kx b">GET</code>或<code class="du ku kv kw kx b">POST</code>方法，那么我们需要创建多个资源类并将每个方法放入相应的资源类中。</p><p id="98fc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，让我们开始为我们的应用程序创建资源。创建<code class="du ku kv kw kx b">resources</code>包，并添加两个名为<code class="du ku kv kw kx b">Item.py</code>和<code class="du ku kv kw kx b">Store.py</code>的文件。</p><h2 id="c385" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">6.1 项目. py</h2><p id="b85a" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">Item.py 文件应包含以下内容。</p><figure class="lu lv lw lx fd ij"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">项目资源. py</figcaption></figure><p id="a226" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<code class="du ku kv kw kx b">item.py</code>文件中，我们定义了两个资源，分别是<code class="du ku kv kw kx b">Item</code>和<code class="du ku kv kw kx b">ItemList</code>。</p><ul class=""><li id="42b3" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated"><code class="du ku kv kw kx b">Item</code>用于使用 id 字段在<code class="du ku kv kw kx b">Item</code>表上执行操作。</li><li id="af4f" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated"><code class="du ku kv kw kx b">ItemList</code>用于创建一个<code class="du ku kv kw kx b">Item</code>或返回<code class="du ku kv kw kx b">Item</code>表中的所有项目。</li></ul><p id="32d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">支持 Swagger-UI 的 API 模型</strong></p><p id="2cba" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">目前，Flask-RestPlus 不直接支持 ModelSchema 或 Model 作为要在 Swagger-UI 中显示的请求体，这有点开销。因此，作为一种变通方法，我们可以创建 API 模型与<code class="du ku kv kw kx b">expect</code>注释一起使用来实现我们的目标。Flask-RESTPlus 能够通过使用 API 模型自动记录和验证输入 JSON 对象的格式。只有在 Swagger-UI 中显示时才需要该模型。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/17adf318217a5e6f0c2dd19e6146299a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwokU6Wkc54YnD0gYrJamw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">请求体</figcaption></figure><p id="5289" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了发送或接收信息(JSON 对象)，我们可以创建 API 模型。RESTPlus API 模型通过列出所有预期字段来定义对象的格式。每个字段都有一个关联的类型，例如，<code class="du ku kv kw kx b">String</code>、<code class="du ku kv kw kx b">Integer</code>、<code class="du ku kv kw kx b">DateTime</code>，它确定哪些字段值将被视为有效。</p><p id="6d8e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下，我们通过指定它预期的信息和每个预期值的属性来定义项目模型，如下所示:</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="95f4" class="ju jv hi kx b fi mc md l me mf">item = items_ns.model('Item', {<br/>    'name': fields.String('Name of the Item'),<br/>    'price': fields.Float(0.00),<br/>    'store_id': fields.Integer<br/>})</span></pre><p id="db72" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该项目模型将作为<code class="du ku kv kw kx b">Item</code>资源的<code class="du ku kv kw kx b">Put</code>方法和<code class="du ku kv kw kx b">ItemList</code>资源的<code class="du ku kv kw kx b">Post</code>方法的一个整体使用。</p><p id="ad18" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过使用<code class="du ku kv kw kx b">expect</code>注释，对于每个 HTTP 方法，我们可以指定要在 Swagger 中显示的有效负载主体的预期<em class="jt">模型</em>。</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="41b6" class="ju jv hi kx b fi mc md l me mf">@item_ns.expect(item)</span></pre><p id="9758" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">命名空间</strong></p><p id="4aeb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">名称空间是可选的，并且主要从文档的角度为 API 添加了一些额外的组织性。命名空间允许您将相关资源分组到一个公共根下。按照以下步骤创建命名空间:</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="e38c" class="ju jv hi kx b fi mc md l me mf">item_ns = Namespace('item', description='Item related operations')<br/>items_ns = Namespace('items', description='Items related operations')</span></pre><p id="2394" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，我们为各个资源创建了一个单独的名称空间。函数的作用是:用一个 URL 前缀创建一个新的命名空间。在斯瓦格 UI 中将使用<code class="du ku kv kw kx b">description</code>字段来描述这套方法。</p><h2 id="73a1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">6.2 Store.py</h2><p id="9faf" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">Store.py 文件应包含以下内容。</p><figure class="lu lv lw lx fd ij"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">Store-Resource.py</figcaption></figure><p id="c63a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<code class="du ku kv kw kx b">store.py</code>文件中，我们定义了两个资源，即<code class="du ku kv kw kx b">Store</code>和<code class="du ku kv kw kx b">StoreList</code>。</p><ul class=""><li id="c669" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated"><code class="du ku kv kw kx b">Store</code>使用 id 字段对<code class="du ku kv kw kx b">Store</code>表进行操作。</li><li id="681e" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated"><code class="du ku kv kw kx b">StoreList</code>用于创建<code class="du ku kv kw kx b">Store</code>或返回<code class="du ku kv kw kx b">Store</code>表中的所有店铺。</li></ul><p id="a9da" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">大摇大摆 UI 支持的 API 模型</strong></p><p id="c066" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，我们也通过指定它预期的信息和每个预期值的属性创建了一个存储模型，如下所示:</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="0d99" class="ju jv hi kx b fi mc md l me mf">store = stores_ns.model('Store', {<br/>    'name': fields.String('Name of the Store')<br/>})</span></pre><p id="d38a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该门店模型将作为<code class="du ku kv kw kx b">StoreList</code>Resource<code class="du ku kv kw kx b">Post</code>方法中的一个体使用。</p><p id="2a1f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将使用<code class="du ku kv kw kx b">expect</code>注释如下:</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="d2d1" class="ju jv hi kx b fi mc md l me mf">@stores_ns.expect(store)</span></pre><p id="f977" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">命名空间</strong></p><p id="e1f9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与 Item Resources 类似，这里我们还创建了单独的名称空间。</p><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="d015" class="ju jv hi kx b fi mc md l me mf">store_ns = Namespace('store', description='Store related operations')<br/>stores_ns = Namespace('stores', description='Stores related operations')</span></pre><h2 id="7aa0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">7.应用程序入口点</h2><p id="4e2c" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">现在，让我们创建应用程序入口点，这将我们带到蓝图。</p><p id="b339" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">蓝图<br/> 烧瓶<a class="ae js" href="https://exploreflask.com/en/latest/blueprints.html" rel="noopener ugc nofollow" target="_blank">蓝图</a>通过将常见的功能分解成不同的组件来帮助我们组织应用程序。我们可以根据它们的功能或它们所迎合的应用程序的划分来组织我们的应用程序组件。</p><p id="88ff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在项目的根目录下，创建一个名为<code class="du ku kv kw kx b">app.py</code>的文件，内容如下:</p><figure class="lu lv lw lx fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="7bd3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码在<code class="du ku kv kw kx b">app.py</code>中执行以下操作:</p><p id="89bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 7.1 WSGI (Web 服务器网关接口):</strong></p><ul class=""><li id="691f" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">我们首先在<code class="du ku kv kw kx b">line 10</code>创建了一个 Flask WSGI 应用程序。</li></ul><p id="0acc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 7.2 烧瓶设计图:</strong></p><ul class=""><li id="005a" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">在<code class="du ku kv kw kx b">line 11</code>中，我们通过传递<code class="du ku kv kw kx b">name</code>、<code class="du ku kv kw kx b">import_name</code>和<code class="du ku kv kw kx b">url_prefix</code>创建了一个蓝图实例。<a class="ae js" href="https://flask.palletsprojects.com/en/1.1.x/blueprints/#blueprints" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">烧瓶蓝图</strong> </a> <strong class="iw hj">，</strong>帮助我们托管<code class="du ku kv kw kx b">/api</code> URL 前缀下的 API。这使我们能够将应用程序的 API 部分与其他部分分开。这是设计模块化应用程序的一种流行方式。</li><li id="9079" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated"><code class="du ku kv kw kx b">API</code>是 Flask-RESTPlus 应用程序资源的主要入口点。因此，我们用<code class="du ku kv kw kx b">line 12</code>中的<code class="du ku kv kw kx b">blueprint</code>对其进行了初始化。这里，我们通过向初始化器传递一个额外的参数<code class="du ku kv kw kx b">doc=/doc</code>覆盖了默认的 Swagger UI 文档位置。</li><li id="8b1c" class="ky kz hi iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">下一步是在<code class="du ku kv kw kx b">line 13</code>中用我们的 Flask 应用程序注册蓝图。</li></ul><p id="7672" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 7.3 SQLAlchemy </strong></p><ul class=""><li id="0868" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 14</code>到<code class="du ku kv kw kx b">16</code>我们添加了一些与 SQLAlchemy 相关的配置。这里，我们使用的是 SQLite DB。这些配置是将 SQLite DB 与 SQLAlchemy 链接起来所必需的。<code class="du ku kv kw kx b">data.db</code>是数据库文件的名称。</li></ul><p id="186b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 7.4 名称空间</strong></p><ul class=""><li id="aeb2" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 18</code>到<code class="du ku kv kw kx b">21</code>，我们将之前定义的所有名称空间添加到了<code class="du ku kv kw kx b">API</code>实例的名称空间列表中。如果您使用名称空间组合来构建 API，当您必须维护一个 API 的多个版本时，将它扩展到多个 API 会变得更简单。</li></ul><p id="7371" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 7.5 数据库</strong></p><ul class=""><li id="273f" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 24</code>到<code class="du ku kv kw kx b">26</code>,在用户访问服务器之前，我们已经使用 db 实例(来自文件<code class="du ku kv kw kx b">db.py</code>)创建了 DB 文件和表。</li></ul><p id="216e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 7.6 异常处理</strong></p><ul class=""><li id="b3c2" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated"><code class="du ku kv kw kx b"><a class="ae js" href="https://flask-restplus.readthedocs.io/en/stable/api.html#flask_restplus.Api.errorhandler" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">@api.errorhandler</strong></a></code> decorator 允许我们为一个给定的异常(或者从它继承的任何异常)注册一个特定的处理程序，就像我们用 Flask/Blueprint <code class="du ku kv kw kx b"><a class="ae js" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.Flask.errorhandler" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">@errorhandler</strong></a></code> decorator 做的一样。</li></ul><p id="0e1c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 7.7 向名称空间添加资源</strong></p><ul class=""><li id="06e2" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">从<code class="du ku kv kw kx b">line 34</code>到<code class="du ku kv kw kx b">37</code>,我们在名称空间上调用了<code class="du ku kv kw kx b">add_resource</code>方法，将所需的资源放在给定的名称空间下。我们还应该确保命名空间的名称替换资源的名称，这样端点就可以简单地引用作为参数指定的 URL。在这里，例如<code class="du ku kv kw kx b">item_ns.add_resource(Item,'/&lt;int:id&gt;')</code>项目资源在<code class="du ku kv kw kx b">item_ns</code>的端点<code class="du ku kv kw kx b">/item/{id}</code>名称处可用，端点<code class="du ku kv kw kx b">item_ns</code>是<code class="du ku kv kw kx b">item</code>后跟<code class="du ku kv kw kx b">/id</code>。我们可以注意到 Swagger UI 的如下变化:</li></ul><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/1333873e7d156fd551071a67e1481e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYF6g6LJRYGPw1HqqucAOg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">项目-Swagger-UI</figcaption></figure><p id="fd5c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 7.8 SQLAlchemy 和棉花糖</strong></p><ul class=""><li id="40a5" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">在<code class="du ku kv kw kx b">line 40</code>和<code class="du ku kv kw kx b">line 41</code>中整合 SQLAlchemy 和棉花糖。</li></ul><p id="e186" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">7.9 <strong class="iw hj">启动</strong>程序</p><ul class=""><li id="efb3" class="ky kz hi iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">最后，在<code class="du ku kv kw kx b">line 42</code>中，我们通过执行以下命令在端口=5000 启动应用程序。</li></ul><pre class="lu lv lw lx fd ly kx lz ma aw mb bi"><span id="e284" class="ju jv hi kx b fi mc md l me mf">python app.py</span></pre><p id="59c7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们完成了所有的编码部分，现在是测试时间。我们的项目结构现在看起来如下。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/d82ae4644e9e53ee7eb317bb62e66957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*Urs_H5bVPcrcWkSphIOigw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">项目结构</figcaption></figure><h2 id="e9e3" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jf kf kg kh jj ki kj kk jn kl km kn ko bi translated">8.测试 API</h2><p id="4de3" class="pw-post-body-paragraph iu iv hi iw b ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn kt jp jq jr hb bi translated">我们现在可以测试我们的应用程序，以确保一切工作正常。我们可以在浏览器中打开 URL <code class="du ku kv kw kx b"><a class="ae js" href="http://127.0.0.1:5000/api/doc" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/api/doc</a></code>。我们应该能够看到如下的 swagger 文档。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/a1b73f815a10b1b3fea76d93819af672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTRv7jCtmWTPKqMnNaZKqQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">斯瓦格-UI</figcaption></figure><p id="911a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们使用 swagger 测试 create Store 端点。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/e020d88ee53357e57511f01607a90ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwjt-siPlL_ba3ofhgaukg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">存储-创建</figcaption></figure><p id="e0dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们把所有的商店都拿来。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/a6fd41a4b8f1727e075e9e5246e5bb0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbeUZs3uvfn-DREFgtn68g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">取货商店</figcaption></figure><p id="6d5e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我们在回复中看到的，商店中没有任何商品。因此，让我们从向商店添加一些商品开始。</p><p id="3eaf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将商品添加到商店。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/7d05a5cbed8efefafbb11f45de429746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEELXrng6Yybht6I9wvP4w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">添加项目</figcaption></figure><p id="9167" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，如果我们再次获取商店，我们可以在商店中看到我们在前面的步骤中添加的商品。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/d993bab30f01fa9af77e348f897807f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14TgKTLJxXeEtOGKvgSNjA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">取货商店</figcaption></figure><p id="c253" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">同样，我们可以使用 Swagger-UI 测试其他操作。</p><p id="1789" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您想参考完整的代码，请检查:</p><p id="2116" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://github.com/sumanentc/python-sample-flask-application" rel="noopener ugc nofollow" target="_blank">https://github . com/suman entc/python-sample-flask-application</a></p><h1 id="5aa4" class="mq jv hi bd jw mr ms mt ka mu mv mw ke mx my mz kh na nb nc kk nd ne nf kn ng bi translated">参考资料和有用的读物</h1><div class="nh ni ez fb nj nk"><a href="https://flask-restplus.readthedocs.io/en/stable/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">烧瓶-RESTPlus</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">Flask-RESTPlus 是 Flask 的扩展，增加了对快速构建 REST APIs 的支持。Flask-RESTPlus 鼓励…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">flask-restplus.readthedocs.io</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny io nk"/></div></div></a></div><div class="nh ni ez fb nj nk"><a href="https://github.com/noirbizarre/flask-restplus/tree/master/examples" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">noirbizarre/flask-restplus</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">github.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny io nk"/></div></div></a></div><div class="nh ni ez fb nj nk"><a href="https://docs.sqlalchemy.org/en/13/orm/tutorial.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">SQLAlchemy 1.4 文档</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">关于本文档本教程涵盖了众所周知的 SQLAlchemy ORM API，它已经使用了很多年。截至…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">docs.sqlalchemy.org</p></div></div></div></a></div><div class="nh ni ez fb nj nk"><a href="https://flask.palletsprojects.com/en/1.1.x/quickstart/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">快速启动烧瓶文档(1.1.x)</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">一个最小的 Flask 应用程序看起来像这样:那么代码做了什么？首先，我们导入了这个类。安…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">flask.palletsprojects.com</p></div></div></div></a></div><div class="nh ni ez fb nj nk"><a href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">Flask-SQLAlchemy-Flask-SQLAlchemy 文档(2.x)</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">请参阅 SQLAlchemy 文档，深入了解如何使用 ORM。以下文档是一个简短的…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">flask-sqlalchemy.palletsprojects.com</p></div></div></div></a></div><div class="nh ni ez fb nj nk"><a href="https://flask-marshmallow.readthedocs.io/en/latest/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">烧瓶-棉花糖:美丽 API 的烧瓶+棉花糖</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">Flask-Marshmallow 是 Flask(一个 Python web 框架)和 Marshmallow(一个对象…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">flask-marshmallow . readthedocs . io</p></div></div></div></a></div></div></div>    
</body>
</html>