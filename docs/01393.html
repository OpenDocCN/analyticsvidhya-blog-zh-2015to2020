<html>
<head>
<title>Leetcode: Hard level problems made easy.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leetcode:难度问题变得简单。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/leetcode-hard-level-problems-made-easy-5d568dfe44bc?source=collection_archive---------10-----------------------#2019-10-19">https://medium.com/analytics-vidhya/leetcode-hard-level-problems-made-easy-5d568dfe44bc?source=collection_archive---------10-----------------------#2019-10-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/39f429baa0e4f4832c54dd91b4beadb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/1*bFODm4ogyUMUdtMhN59bMA.gif"/></div></figure><div class=""/><p id="2068" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们来谈谈一个简单而强大的工具——二分搜索法。有些人可能低估了它，认为它是一个原始的工具，但事实是，它被用于大量的应用程序中。让我们看几个现实生活中的例子:</p><ol class=""><li id="e366" class="jk jl hp io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">简单的老派字典搜索(不是数据结构)。</li></ol><p id="9628" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于一本1000页的字典，我们只需要大约10次检查就可以找到一个特定的单词。你们中的一些人，已经足够大了，可以使用它。算法看起来是这样的:</p><ul class=""><li id="ab1c" class="jk jl hp io b ip iq it iu ix jm jb jn jf jo jj jt jq jr js bi translated">在中间的某个地方打开字典。</li><li id="8f39" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jt jq jr js bi translated">将页面上第一个单词的首字母与我们要搜索的单词的首字母进行比较。</li><li id="b7b8" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jt jq jr js bi translated">如果我们要搜索的单词的第一个字母在字母表中页面的第一个字母下面，那么上面的所有页面都会被删除，反之亦然。</li><li id="eecc" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jt jq jr js bi translated">重复直到找到该单词。</li></ul><p id="92eb" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.<strong class="io hq">求一个数的平方根。</strong></p><p id="6890" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.<strong class="io hq">三元搜索。</strong></p><p id="d02e" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">4.<strong class="io hq"> 3D游戏开发。</strong></p><p id="7578" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">二分搜索法用于根据3D位置或相机识别要显示的空间细分。</p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="e5c3" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">最后，解题。</strong></p><p id="f3ef" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">先说一个<a class="ae kg" href="https://leetcode.com/problems/median-of-two-sorted-arrays/" rel="noopener ugc nofollow" target="_blank"> ' <strong class="io hq">两个排序数组的中值'</strong> </a>问题。总的运行时间复杂度应该是O(log (m+n))。</p><p id="ee3d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我们需要定义中位数。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7ef5" class="kq kr hp km b fi ks kt l ku kv">The median is the value separating the higher half from the lower half of a data sample.</span></pre><p id="bbab" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果数据集中的元素计数是奇数，则排序数组的中值将是中间的元素:</p><p id="5312" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">A=[1，2，3，4，5，6，7，8，9]；</p><p id="cb61" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">中位数(A)= 5；</p><p id="fc66" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果元素的数量是偶数，中值将是两个中心元素的平均值:</p><p id="6cff" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">A=[1，2，3，4]；</p><p id="d1ff" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">中位数(A)=(2+3)/2 = 2.5；</p><p id="ccd3" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，在这里我们可以看到中位数的主要特征:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d050" class="kq kr hp km b fi ks kt l ku kv">(1) Median divides a set into two equal length subsets, where one subset is always higher than the other.</span></pre><p id="8901" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以通过合并这两个数组来解决这个问题，这将导致O(n+m)的复杂度。但是，这并不符合O(log(m+n))的要求。</p><p id="52b4" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们已经对数组进行了排序，复杂度为O(log(m+n))，这应该会给我们一个解决方案的提示——二分搜索法。让我们试着在这里采用二分搜索法算法。</p><p id="c28e" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们有两个数组nums1和nums2的输入。nums1 = [1，3，5]</p><p id="e667" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">nums2 = [2，4，6]，n=len(nums1)，m = len(nums 2)；</p><p id="635f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们需要为nums1找到I，为nums2找到j，它将数组分成两部分:i -&gt;使用二分搜索法算法选择</p><p id="4a1e" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">j =(n+m+1)/2-I；</p><p id="51d4" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">len(left nums 1)+len(left nums 2)= = len(right nums 1)+len(right nums 2)；</p><p id="6912" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">max(left nums 1)&lt; min(right nums 2)；</p><p id="1328" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">max(left nums 2)&lt; min(right nums 1)；</p><figure class="kh ki kj kk fd hk er es paragraph-image"><div class="er es kw"><img src="../Images/c79ead1417d46ecb89b1be63cd05370e.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*y3gT2o0iNJghrbUY_hp2HQ.png"/></div></figure><p id="65b2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们发现了这样的索引后:</p><p id="26a9" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果((n+m) mod 2==0)</p><p id="2652" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">中位数=max(nums1[i-1]，nums[j -1])+min(nums1[i]，nums2[j])</p><p id="1138" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">else median=max(nums1[i-1]，nums[j-1])</p><p id="1f86" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们还需要确保n&lt;=m或者j可以是负数。</p><p id="1034" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们编写代码:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9dc3" class="kq kr hp km b fi ks kt l ku kv">public double FindMedianSortedArrays(int[] nums1, int[] nums2)<br/>{<br/>   if (nums1.Length &gt; nums2.Length)<br/>   {<br/>       int[] temp = nums1;<br/>       nums1 = nums2;<br/>       nums2 = temp;<br/>   }</span><span id="0dcf" class="kq kr hp km b fi kx kt l ku kv">   int n = nums1.Length, m = nums2.Length;<br/>   int middle = (n + m + 1) / 2;<br/>   int low = 0, high = nums1.Length;<br/>   while (low &lt;= high)<br/>   {<br/>       int i = (low + high) / 2;<br/>       int j = middle - i;<br/>       if (i &gt; low &amp;&amp; nums1[i - 1] &gt; nums2[j])<br/>       {<br/>           high = i - 1;<br/>       } else if (i &lt; high &amp;&amp; nums2[j - 1] &gt; nums1[i])<br/>       {<br/>           low = i + 1;<br/>       }<br/>       else<br/>       {<br/>           int maxLeft;<br/>           if (i == 0) maxLeft = nums2[j - 1];<br/>           else if (j == 0) maxLeft = nums1[i - 1];<br/>           else maxLeft = Math.Max(nums1[i - 1], nums2[j - 1]);<br/>           if ((m + n) % 2 != 0) return maxLeft;</span><span id="4532" class="kq kr hp km b fi kx kt l ku kv">           int minRight;<br/>           if (i == n) minRight = nums2[j];<br/>           else if (j == m) minRight = nums1[i];<br/>           else minRight = Math.Min(nums1[i], nums2[j]);<br/>           return (minRight + maxLeft) / 2.0;<br/>       }<br/>   }</span><span id="154b" class="kq kr hp km b fi kx kt l ku kv">   return 0;<br/>}</span></pre></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="1b67" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第二个问题是，<a class="ae kg" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq">“在旋转排序数组II中求最小值。”</strong> </a>正如我们在描述中看到的，数组可能包含重复项。</p><p id="01b9" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是一个数组旋转的示例:</p><p id="83eb" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi">[0, 2, 5, 6, 7, 7, 8, 10, 11] -&gt; [7, 8, 10, 11, 0, 2, 5, 6, 7];</p><p id="e44f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi">[0, 10, 10, 10] -&gt; [10, 0, 10, 10];</p><p id="bb62" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我们需要把问题简单化。尝试找到没有重复的数组的解决方案，然后调整有重复的数组的解决方案。</p><p id="ac99" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">A = [4，5，6，7，0，1，2]；</p><p id="4c1d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如我们所看到的，最小的元素总是第一个比前一个小的元素。这里，i = 4。A[i]是数组中最小的元素，A[I]&lt;= A[i-1].</p><p id="6126" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Now, we need to apply a binary search algorithm to find that element:</p><ol class=""><li id="493f" class="jk jl hp io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">start = 0, end = A.length.</li><li id="a4cf" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">Get a middle element middle = (start+end) / 2.</li><li id="7aa2" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">If middle+1 &lt; end and A[middle] &gt;A[中间+1]然后我们找到了解。返回一个[中+1]。</li><li id="d764" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">如果middle-1 &gt; start和A[middle] &lt; A[middle-1] than we found the solution. Return A[middle].</li><li id="4b19" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">If we haven’t found the solution, we need to decide where to search.</li><li id="32e7" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">If A[middle] &gt; A[end]比start = middle+1。转到步骤2。</li><li id="a3ec" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">如果A[start] &gt; A[middle]，那么end = middle-1。转到步骤2。</li><li id="250d" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">否则返回一个[start]。</li></ol><p id="e6ac" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，只要我们有了非重复数组的解决方案，它就可以适用于包含重复元素的数组。</p><p id="d405" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">A = [10，1，10，10]；</p><p id="bb64" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">解决方案大致相同，但有一些额外的检查:</p><ol class=""><li id="42c3" class="jk jl hp io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">开始= 0，结束= A.length。</li><li id="fe39" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">检查start == end或start == end — 1，然后返回min(A[start]，A[end])。</li><li id="dc44" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">得到一个中间元素middle = (start+end) / 2。</li><li id="b933" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">如果middle+1&lt; end and A[middle] &gt;A【middle+1】那么我们就找到了解。返回</li><li id="9dea" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">a[中+1]。</li><li id="b21c" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">如果middle-1 &gt; start和A[middle] &lt; A[middle-1] than we found the solution. Return A[middle].</li><li id="7003" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">If we haven’t found the solution, we need to decide where to search.</li><li id="737b" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">If A[middle] &gt; A[end]比start = middle+1。转到步骤2。</li><li id="5ee9" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">如果A[start] &gt; A[middle]，那么end = middle-1。转到步骤2。</li><li id="5070" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">如果A[start] == A[middle]和A[middle] == A[end]，那么我们需要递归地搜索两个半部分[start，… middle]和[middle+1，…end]并返回这两个结果中的最小值。</li><li id="0fbe" class="jk jl hp io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">否则返回一个[start]。</li></ol><p id="c5a2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">和代码:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b78c" class="kq kr hp km b fi ks kt l ku kv">public int FindMin(int[] nums) <br/>{<br/>    return FindMinRecursive(nums, 0, nums.Length - 1);<br/>}<br/><br/>public int FindMinRecursive(int[] nums, int start, int end) <br/>{<br/>    if (start == end ||start == end - 1) <br/>    {<br/>        return Math.Min(nums[start], nums[end]);<br/>    }<br/>    int middle = (start + end) / 2;<br/>    if (middle - 1 &gt; 0 &amp;&amp; nums[middle] &lt; nums[middle - 1]) {<br/>        return nums[middle];<br/>    }<br/>    if (middle + 1&lt; nums.Length &amp;&amp; nums[middle + 1] &lt; nums[middle])<br/>    {<br/>        return nums[middle + 1];<br/>    }<br/>    if (nums[end] &lt; nums[middle])<br/>    {<br/>        return FindMinRecursive(nums, middle+1, end);<br/>    }<br/>    if (nums[middle] &lt; nums[start]) {<br/>        return FindMinRecursive(nums, start, middle);<br/>    }<br/>    if (nums[middle] == nums[end] &amp;&amp; nums[end] == nums[start])<br/>    {<br/>        return Math.Min(FindMinRecursive(nums, middle + 1, end), <br/>            FindMinRecursive(nums, start, middle));<br/>    }<br/> <br/>    return nums[start];<br/>}</span></pre><p id="6e87" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">PS。如果您使用C#，出于性能原因，您应该使用类型标识符而不是“var”。</p><p id="e3b6" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我希望这能让你了解二分搜索法的用途。</p><figure class="kh ki kj kk fd hk er es paragraph-image"><div class="er es ky"><img src="../Images/921d9d09e6406f99992e5bb9b98742f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*DU8AeSXNhmom4NeHEnEZxQ.gif"/></div></figure></div></div>    
</body>
</html>