<html>
<head>
<title>A Traffic Signs Classifier — The Flask API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交通标志分类器Flask API</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-traffic-signs-classifier-the-flask-api-ceb9e34ad415?source=collection_archive---------13-----------------------#2019-11-25">https://medium.com/analytics-vidhya/a-traffic-signs-classifier-the-flask-api-ceb9e34ad415?source=collection_archive---------13-----------------------#2019-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7a86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最好系好安全带，我们才刚刚开始！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/9d665f9493bde3fed8abcddb0e2c77bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o1G3usSi_Up_Tdda"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">巴特·阿内斯廷在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="ju jv jw"><p id="a889" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">最终和完善的应用程序将为交通标志的在线和离线分类提供选项。</p><p id="5fa7" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">离线分类器应该与Tensorflow Lite实现一起很好地工作，而在线部分将使用基于Flask的API来处理分类任务。</p></blockquote><p id="ff1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先制作一个具有在线功能的最小可行产品，然后再添加离线功能。如果你想阅读<a class="ae jt" rel="noopener" href="/@tushar.sharma118">系列中这篇文章之前的文章，请点击这里</a>。</p><h1 id="6a2c" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">安装烧瓶</h1><p id="3b12" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">既然我们已经准备好了分类模型，我们必须创建一个API来处理来自移动应用程序的请求。为此，让我们确保我们的环境中存在Flask依赖。如果没有，请使用以下命令进行设置:</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="7d5c" class="lj kc hi lf b fi lk ll l lm ln">pip install flask</span></pre><p id="b5b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于安装flask和使用虚拟环境的深入指导(强烈推荐)，请参考<a class="ae jt" href="https://flask.palletsprojects.com/en/1.1.x/installation/#installation" rel="noopener ugc nofollow" target="_blank">官方flask指南</a>。</p><h1 id="8d32" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">构建项目</h1><p id="54a3" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">确保您训练的模型与API文件一起出现在根目录中。<br/>创建API需要注意一些事项，我们不希望每次发出请求时都要加载模型，不是吗？这将使响应速度极慢。<br/> <strong class="ih hj">那么要确保模型只被加载一次可以做些什么呢？</strong> <br/>我对此使用的解决方案是，一旦服务器解析了python文件，就加载模型。这确保了在处理任何请求之前加载模型。</p><h1 id="5291" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">创建API</h1><p id="1098" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">我们终于有了一步一步的指南，或者让我们避开它，我来解释重要的部分？这里的可以参考<a class="ae jt" href="https://github.com/Tusharsharma118/TrafficSignsClassifierApi" rel="noopener ugc nofollow" target="_blank">代码库。它绝不是最优的，尤其是在结构上，它肯定可以通过重组来实现。<br/>现在我们已经过了这个阶段，让我们从API所需的依赖项或导入开始:</a></p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="cc86" class="lj kc hi lf b fi lk ll l lm ln">import numpy as np<br/>from flask import Flask, request, jsonify, render_template<br/>import tensorflow as tf<br/>import skimage<br/>import math</span></pre><p id="b04c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">烧瓶依赖关系如下:</p><ul class=""><li id="e538" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">请求—用于处理传入API的请求对象。我们用它来接受应用程序发送的图像文件。</li><li id="0fd7" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">json ify——正如所料，它用于创建JSON对象，作为我们的API对应用程序的响应。</li><li id="2013" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">Render_Template —一种从templates文件夹中获取html文件并将其渲染到视口中的方法。它用于为我们的API提供一个简单的主页，以防有人试图从web浏览器访问它。</li></ul><p id="115c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用的其他依赖关系有:</p><ul class=""><li id="e0a9" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">skim age——它用于预处理从应用程序接收的图像，然后将其作为预测模型的输入。</li><li id="5a8c" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">张量流——它用于在我们的模型中加载和预测。</li></ul><p id="6217" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你不熟悉Flask，在迷失在代码中之前，通过这个简单的例子熟悉一下吧！</p><h1 id="e736" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">字典！</h1><p id="cdfa" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">过了一会儿，我在网上搜索了一下，在我们的模型中找到了62个类中的59个，并给它们贴上了标签。结果就是您可以在代码中找到的预测字典。</p><p id="9ff5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嘿，如果你碰巧知道这两个类，不要回避拉请求！你可以在这里查阅我的<a class="ae jt" href="https://www.kaggle.com/tusharsharma118/belgian-traffic-dataset/notebook" rel="noopener ugc nofollow" target="_blank"> kaggle笔记本上所有课程的图片。</a></p><h1 id="7bd8" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">接收图像</h1><p id="b8a2" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">Flask中的每个请求对象都有一个名为“files”的属性。如果请求有一个附加文件，它将出现在这个对象数组下。<strong class="ih hj">我们已经确保在发送图像时将密钥定义为“文件”。<br/> </strong>然后，我们可以使用scikit-Image的imread方法访问并读取图像，如下所示:</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="dabc" class="lj kc hi lf b fi lk ll l lm ln">file = request.files['file']<br/>predict_image = skimage.io.imread(file)</span></pre><h1 id="aa40" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">图像预处理</h1><p id="b6a1" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在开始解析图像之前，我们需要检查图像类型和尺寸。</p><h2 id="51f8" class="lj kc hi bd kd mc md me kh mf mg mh kl iq mi mj kp iu mk ml kt iy mm mn kx mo bi translated">步骤1:检查不透明的文件类型</h2><p id="e28a" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">如果输入图像是PNG，它包含一个额外的不透明通道。由于我们的模型期望输入具有三维，我们需要将接收到的图像转换为RGB。这里scikit-image库就派上用场了。它包含了一个将包含不透明度的图像转换为不包含不透明度的图像的方法。你也可以通过删除图像数组的第四维来手动完成，但是为什么要重新发明航天飞机呢？</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="28b2" class="lj kc hi lf b fi lk ll l lm ln">predict_image = skimage.color.rgba2rgb(predict_image)</span></pre><h2 id="b077" class="lj kc hi bd kd mc md me kh mf mg mh kl iq mi mj kp iu mk ml kt iy mm mn kx mo bi translated"><strong class="ak">第二步:变换图像</strong></h2><p id="1568" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">该模型期望输入图像具有[1，128，128，3] <br/>的尺寸，下一步是将图像调整到我们的模型所期望的大小。我们为此使用resize方法。</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="96ee" class="lj kc hi lf b fi lk ll l lm ln">predict_image128x128 = skimage.transform.resize(predict_image, (128,      128))<br/>predict_image128x128 = np.array(predict_image128x128)</span></pre><p id="4de2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你开始预测之前，还有最后一步。<br/>通过检查predict_image128x128的维度，您可以看到它是[128，128，3]，但该模型需要这样的图像数组作为输入，即输入维度应该是[1，128，128，3]。<br/>因此，用一个新的尺寸填充输入图像，然后你应该准备好在模型上测试图像。</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="4103" class="lj kc hi lf b fi lk ll l lm ln">predict_image128x128 = np.expand_dims(predict_image128x128, axis=0)</span></pre><h1 id="c931" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">预测！</h1><p id="5eb4" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">现在我们终于可以预测这张图片是关于什么的了！下一个神奇的步骤是将图像传递给模型，并检查它会给我们什么反馈！</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="6cb5" class="lj kc hi lf b fi lk ll l lm ln">classes = model.predict(predict_image128x128)</span></pre><p id="c020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">output classes数组应该包含我们模型的62个输出类中每一个的置信度值。在更简单的时候，人们会称这个分数代表这个孩子(图像)属于那个家庭(交通标志类)的几率。现在我们所需要的就是找到哪个家族在输出数组中的得分最高。</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="72bf" class="lj kc hi lf b fi lk ll l lm ln">np.argmax(classes) #returns the index of the class with the highest     #                   score</span></pre><h1 id="273c" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">反应</h1><p id="eed5" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">嘿，这应该是一个API吧？在我忘记之前，我们现在需要为API准备一个响应。我已经在“prepare_response”方法中做到了这一点。<br/>它接受包含置信度值的“类”数组作为输入。我将响应的结构定义为:</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="661e" class="lj kc hi lf b fi lk ll l lm ln">{<br/>"class": "41",<br/>"class_desc": "Parking and stopping prohibited",<br/>"confidence": 100<br/>}</span></pre><p id="8d88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将使用numpy中的argmax方法获得输出类索引。</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="80e0" class="lj kc hi lf b fi lk ll l lm ln">index = np.argmax(classes)</span></pre><p id="9ab7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果模特没有告诉我超人是停车标志，那就太好了，不是吗？<br/> </strong>为了确保模型不只是即兴发挥，确保在它给我们一个预测之前为它添加一个合适的阈值。我将它设置为60%，通过将最高置信度值与您的阈值进行比较来实现。</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="a7ec" class="lj kc hi lf b fi lk ll l lm ln">if classes[0][np.argmax(classes)] &gt; 0.6</span></pre><p id="4e19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在低置信度情况下设置响应的一个例子是</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="ebe5" class="lj kc hi lf b fi lk ll l lm ln">{<br/>    'class': 'None',<br/>    'class_desc': 'Traffic Sign not present',<br/>    'confidence': math.floor(classes[0][np.argmax(classes)] * 100)<br/>}</span></pre><p id="bc74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">math.floor方法使我们的置信度值保持为漂亮整洁的整数。<br/>最后一步是使用Flask库中的jsonify方法来确保我们上面创建的字典被转换成json对象。</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="b94e" class="lj kc hi lf b fi lk ll l lm ln">response = prepare_response(classes)<br/>return jsonify(response)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mp"><img src="../Images/d62af747325babe6eab3ef8d4e09e09c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCVqvWdQ-e8NuSMtsNyW1g.png"/></div></div></figure><p id="945a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇，真是漫长的一天！希望你能在这里成功！如果你做了，请留下你的进展，建议或者如果你想知道更多的话！</p><p id="0069" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另外，如果你想看一下代码，请点击这里。</p></div></div>    
</body>
</html>