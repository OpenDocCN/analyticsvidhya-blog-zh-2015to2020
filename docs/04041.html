<html>
<head>
<title>C libraries, a brief summary! — Part 1 (Static libraries)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">c库，简单总结！—第1部分(静态库)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/c-libraries-a-brief-summary-8ad7aa735046?source=collection_archive---------23-----------------------#2020-03-02">https://medium.com/analytics-vidhya/c-libraries-a-brief-summary-8ad7aa735046?source=collection_archive---------23-----------------------#2020-03-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7ec16a17e82f6fd2962840d693124a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V45c_3XCH2UM7Gp773e-pQ.jpeg"/></div></div></figure><p id="3733" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">库是一组功能实现，通常按照它们的效用进行分组，用编程语言进行编码，并提供一个定义良好的具有被调用功能的接口。这意味着我们可以找到一组预定义的功能(标准库C和标准库ANSI C)或由另一个人编译，在本出版物中，我们将关注我们每个人都可以创建的库，这些自定义库称为静态库</p><h2 id="acf9" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">静态库—定义。</h2><blockquote class="kj kk kl"><p id="cfcb" class="iq ir km is b it iu iv iw ix iy iz ja kn jc jd je ko jg jh ji kp jk jl jm jn hb bi translated">在<!-- -->计算机科学中，<strong class="is hj">静态库</strong>或<strong class="is hj">静态链接库</strong>是一组例程、外部函数和变量，它们在编译时在调用程序中被解析，并由编译器、链接器或绑定器复制到目标应用程序中，产生目标文件和独立的可执行文件。来源:<a class="ae kq" href="http://tldp.org/HOWTO/Program-Library-HOWTO/static-libraries.html" rel="noopener ugc nofollow" target="_blank">http://tldp . org/how to/Program-Library-how to/static-libraries . html</a></p></blockquote><h2 id="cd69" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">为什么使用库:</h2><p id="6a1e" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">如前所述，一个库集合了一组函数、变量和其他函数，提供了一组可能有或没有共同用途的实用程序，例如数学库是一个标准的C语言库，设计用于基本的数学运算。</p><p id="9cc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与数学库不同，静态库是我们可以根据正在开发的项目创建一组函数的库。理解库的目的是保存代码也是很重要的，要理解这一点，你必须记住函数是可以在程序的另一部分重用的代码块，当你把一个函数放在库中时，你就给了程序调用它的能力，只要你需要，不需要重写它，在不同的程序中。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/b95a4cd935fbf1312a8bd959d7975245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*KTNijT3BAo9XPhxv9QIIvw.jpeg"/></div></figure><h2 id="c6c5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">它们是如何工作的</h2><p id="3410" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">要理解一个库是如何工作的，你必须记住编译C程序时会发生什么，步骤如下</p><p id="cf5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1-预处理:解释所有已经使用过的预处理指令，比如#define、#include、#ifdef等…此外，它还会删除文件中写的所有注释。</p><p id="8733" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2-编译:编译将C代码转换成我们机器的处理器的汇编语言。</p><p id="f1a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3-汇编:汇编将汇编语言编写的程序转换成目标代码，目标代码是处理器可执行的机器语言二进制文件。</p><p id="060d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4-链接:目标文件链接在一起形成可执行文件。C函数包含在代码中。此时，目标代码中的一个或多个模块会遇到库中的现有代码。</p><p id="33cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">静态库是扩展文件(。a)通过<em class="km"> ar </em>命令生成(在以下段落中解释)，从目标文件中获取所有信息，并在链接阶段连接包含在库文件中的所有信息，以便可执行文件可以正确地与自定义库一起工作。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/1f684ac4d45138d17cb4d4493cc10ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*LX2NrLuBZq-o98l0JH8Rfg.png"/></div></figure><h2 id="8734" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">如何创建它们</h2><p id="4898" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">1.您必须将包含所有要添加到库中的函数的所有文件放入库中。确保用每个函数的原型创建头文件，记住在文件的顶部写<em class="km"># ifndef _ HOLBERTON _ H _ # define _ HOLBERTON _ H _</em>指令，在文件的结尾写<em class="km"> #endif </em>。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/f99e67441067a1024ce9089e4cd6a34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*Hgs0KaOQd0FLyt_rIkpC2Q.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">c文件</figcaption></figure><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/352944e735d11df9f6808db058a27ea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*d09cT1PPUqPAh_YonEknVQ.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">头文件。</figcaption></figure><p id="4d71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.在这一步中，您必须编译所有文件(。c)直到装配阶段(。o)，这意味着生成目标文件。要对文件夹中的所有文件自动执行此步骤，您必须执行以下命令</p><pre class="kx ky kz la fd li lj lk ll aw lm bi"><span id="3ab2" class="jo jp hi lj b fi ln lo l lp lq"><em class="km">$ gcc -c *.c</em></span></pre><p id="3c0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">c标志用于编译，直到汇编阶段。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/9d1975f1baa114e1bb49d700c6d41997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wKiWD6VEJoYioGengVXmsg.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">目标文件。</figcaption></figure><p id="8d0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.创建静态库(。a)对于所有的目标文件，如果已经创建了库，则使用ar命令和-r标志来更新库，如果库不存在，则使用|-c标志来创建库。</p><pre class="kx ky kz la fd li lj lk ll aw lm bi"><span id="1dc8" class="jo jp hi lj b fi ln lo l lp lq"><em class="km">$ ar -rc libhbtn.a *.o</em></span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/1e9c7d269af07d0c178b730692ca1a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W8Cg4SK8Vw5wdppPNjo6mA.png"/></div></div></figure><p id="759a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，通配符(*)被用来生成带有所有目标文件的库文件夹，如果需要，可以逐个指定每个文件。</p><p id="89e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想查看该库包含哪些函数，可以使用带有-t标志的ar命令</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/2f0751599483b3394457c5b4a71e2c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9MQJDrLxZRIj5unNTJIrQ.png"/></div></div></figure><p id="5fc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.为了使库具有更好的性能，有必要通过符号链接对其进行索引，这使得链接阶段执行得更快。这个过程是通过ranlib命令完成的。可以使用命令nm查看库中的符号，该命令列出了目标文件中每个符号的符号值、符号类型和符号名称。</p><pre class="kx ky kz la fd li lj lk ll aw lm bi"><span id="44b4" class="jo jp hi lj b fi ln lo l lp lq">$ ranlib libhbtn.a</span><span id="3d7b" class="jo jp hi lj b fi lu lo l lp lq">$ nm libhbtn.a</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/4fa1d90ab86324f2a9bf3070ca562833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ma4_w6FguWqD_vTGDyUVfg.png"/></div></div></figure><p id="b04d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，如果您想自动执行这个过程，您可以创建一个脚本来执行前面的步骤。记得给这个脚本分配执行权限。</p><pre class="kx ky kz la fd li lj lk ll aw lm bi"><span id="6df3" class="jo jp hi lj b fi ln lo l lp lq">#!/bin/bash<br/>gcc -c *.c<br/>ar -rc liball.a *.o<br/>ranlib liball.a</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/7ac07591092fd0d82cf5797af3caa9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*xb50EatH_qC9wSaOX3fl3w.png"/></div></figure><h2 id="2e5a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">如何使用静态库？</h2><p id="aa97" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">要使用这个库，必须在编译文件时调用它。c)这需要它。在这种情况下，main.c文件、gcc编译器(GNU编译器集合)将与以下标志一起使用。</p><p id="4c02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">-l <library_name without="" lib="" prefix="" and="" .a="" extension="">，这个标志添加了前缀和扩展名，这就是为什么你不能写它们。<br/> -L .，指定库的路径。我们可以用它来指向当前目录，用-L / home / tmp来指向/ home / tmp目录。<br/> -o，允许你给编译的输出指定一个特定的名字</library_name></p><pre class="kx ky kz la fd li lj lk ll aw lm bi"><span id="d1aa" class="jo jp hi lj b fi ln lo l lp lq">$ gcc main.c -L. -lhbtn -o maincompile</span></pre><h1 id="ed50" class="lw jp hi bd jq lx ly lz ju ma mb mc jy md me mf kb mg mh mi ke mj mk ml kh mm bi translated">参考</h1><ul class=""><li id="5f14" class="mn mo hi is b it kr ix ks jb mp jf mq jj mr jn ms mt mu mv bi translated">gcc官方编译器页面:<a class="ae kq" href="https://gcc.gnu.org/" rel="noopener ugc nofollow" target="_blank">https://gcc.gnu.org/</a></li><li id="ffa1" class="mn mo hi is b it mw ix mx jb my jf mz jj na jn ms mt mu mv bi translated">构建和使用静态和共享的“C”库:<a class="ae kq" href="https://docencia.ac.upc.edu/FIB/USO/Bibliografia/unix-c-libraries.html#what_is_a_library" rel="noopener ugc nofollow" target="_blank">https://docencia . AC . UPC . edu/FIB/USO/Bibliografia/UNIX-C-Libraries . html # what _ is _ a _ library</a></li><li id="a978" class="mn mo hi is b it mw ix mx jb my jf mz jj na jn ms mt mu mv bi translated">ar Linux手册页:【http://man7.org/linux/man-pages/man1/ar.1.html T2】</li><li id="0940" class="mn mo hi is b it mw ix mx jb my jf mz jj na jn ms mt mu mv bi translated">ranlib Linux手册页:【http://man7.org/linux/man-pages/man1/ranlib.1.html T4】</li></ul></div></div>    
</body>
</html>