<html>
<head>
<title>ELK stack in Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头上的麋鹿栈</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/elk-stack-in-docker-6285ec1ac1aa?source=collection_archive---------0-----------------------#2019-12-24">https://medium.com/analytics-vidhya/elk-stack-in-docker-6285ec1ac1aa?source=collection_archive---------0-----------------------#2019-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fcd4ab5ecf0a87da916aeb45f46d8122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLa-DYABokW2MeTayqiaZg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">码头上的麋鹿</figcaption></figure><p id="19f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://www.elastic.co/what-is/elk-stack" rel="noopener ugc nofollow" target="_blank"> Elastic stack </a>以前被称为ELK stack ( <strong class="iw hj"> E </strong> lasticsearch，<strong class="iw hj"> L </strong> ogstash，<strong class="iw hj"> K </strong> ibana)是一个流行的开源日志分析工具，在每天产生大量数据的不同功能领域都有用例。人们可以读取这些异构数据，提取相关部分，并使用弹性堆栈实时可视化它们。栈的第四个元素是beat(data shippers ),它被添加到ELK栈中，并被重命名为elastic stack。</p><p id="0426" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你是新手，在安装/配置elastic stack时可能会遇到困难，甚至可能会花费你估计的额外时间。使用Docker的安装过程的自动化将在很大程度上减少安装过程的时间和复杂性。因此，让我们从安装Docker开始，到在Kibana Dashboard中可视化Apache日志。</p><h1 id="63b1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">安装Docker</h1><p id="702a" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">用下面的一组命令安装Docker。如果您已经为Docker设置了环境，请跳过这一步。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6884" class="lf ju hi lb b fi lg lh l li lj">$ yum install wget<br/>$ wget -qO- https://get.docker.com/ | sh<br/>$ systemctl enable docker.service<br/>$ systemctl start docker.service<br/>$ systemctl status docker.service</span></pre><h1 id="66cc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">安装Docker撰写</h1><p id="8b61" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">有了docker compose，在YAML文件中为容器定义/配置服务和为应用程序设置环境变得很容易，我们也需要它，因为我们将使用Docker compose来定义多容器弹性堆栈。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c9d7" class="lf ju hi lb b fi lg lh l li lj">$ yum install -y epel-release<br/>$ yum install -y python-pip<br/>$ pip install --upgrade pip<br/>$ pip install docker-compose</span></pre><h1 id="ad26" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">弹性搜索容器</h1><p id="45d1" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">我们将从<a class="ae js" href="https://www.elastic.co/products/elasticsearch" rel="noopener ugc nofollow" target="_blank"> elasticsearch </a>开始集装箱化弹性堆栈。首先，创建一个根文件夹，在这个文件夹中，elastic stack的每个组件都将被放在一起。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3702" class="lf ju hi lb b fi lg lh l li lj">$ mkdir ~/docker-elk</span></pre><p id="b28a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">导航到elastic stack的根文件夹，为elasticsearch创建文件夹，并为elasticsearch创建相关的配置/存储。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="068a" class="lf ju hi lb b fi lg lh l li lj">$ cd ~/docker-elk<br/>$ mkdir -p elasticsearch/{config,storage}<br/>$ chown -R 1000:1000 elasticsearch/storage/</span></pre><p id="cc7d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du lk ll lm lb b">config</code>和<code class="du lk ll lm lb b">storage</code>文件夹将用于在后期定义docker合成文件中的<strong class="iw hj"> docker卷</strong>。docker卷将使主机中的文件夹与容器中的文件夹保持连接，并且将始终保持彼此同步。</p><p id="3648" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为elasticsearch创建一个docker文件，这是放置所有需要组装图像的命令的方法。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="cfb2" class="lf ju hi lb b fi lg lh l li lj">$ cd ~/docker-elk/elasticsearch<br/>$ vi Dockerfile<br/>ARG ELK_VERSION<br/>FROM docker.elastic.co/elasticsearch/elasticsearch:${ELK_VERSION}</span></pre><p id="88b6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">定义您想要在环境文件中打包的elasticsearch的版本。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="89e4" class="lf ju hi lb b fi lg lh l li lj">$ vi ~/docker-elk/.env<br/>ELK_VERSION=7.5.1</span></pre><p id="dcac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在继续在<code class="du lk ll lm lb b">config</code>文件夹中创建elasticsearch配置文件。在主机中有ES配置文件将使我们能够轻松地调整设置，并使用docker volume将其安装到容器中。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2068" class="lf ju hi lb b fi lg lh l li lj">$ vi ~/docker-elk/elasticsearch/config/elasticsearch.yml<br/>cluster.name: "docker-cluster"<br/>network.host: 0.0.0.0<br/>discovery.zen.minimum_master_nodes: 1<br/>discovery.type: single-node<br/>logger.level: DEBUG</span></pre><p id="fbb5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过docker compose定义elasticsearch容器所需的所有文件和文件夹现在都准备好了。继续在项目<code class="du lk ll lm lb b">~/docker-elk</code>的根目录下创建docker compose文件。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="76ed" class="lf ju hi lb b fi lg lh l li lj">$ vi ~/docker-elk/docker-compose.yml<br/>version: '3'<br/>services:<br/>  elasticsearch:<br/>     container_name: elasticsearch<br/>     build:<br/>        context: elasticsearch<br/>        args:<br/>           ELK_VERSION: $ELK_VERSION<br/>     volumes:<br/>       - ./elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml<br/>       - ./elasticsearch/storage:/usr/share/elasticsearch/data:rw<br/><br/>     ports:<br/>       - "9200:9200"<br/>       - "9300:9300"<br/><br/>     environment:<br/>       - ELASTIC_PASSWORD="changeme"<br/>       - ES_JAVA_OPTS=-Xmx256m -Xms256m<br/>       - discovery.type=single-node<br/>       - bootstrap.memory_lock=true<br/>       - http.cors.allow-origin=*<br/><br/>     ulimits:<br/>       memlock:<br/>         soft:  -1<br/>         hard:  -1<br/><br/>networks:<br/>   elk:<br/>     driver: bridge</span></pre><p id="d2b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">构建容器:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6aa7" class="lf ju hi lb b fi lg lh l li lj">$ cd ~/docker-elk<br/>$ docker-compose build elasticsearch</span></pre><p id="47df" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以分离模式启动容器:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b1f8" class="lf ju hi lb b fi lg lh l li lj">$ docker-compose up -d elasticsearch</span></pre><p id="f792" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">列出容器:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="09ce" class="lf ju hi lb b fi lg lh l li lj">$ docker ps -a</span></pre><p id="ff4a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从您的主机ping ES容器:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7554" class="lf ju hi lb b fi lg lh l li lj">$ curl http://127.0.0.1:9200/<br/>{<br/>  "name" : "a85bd40e10de",<br/>  "cluster_name" : "docker-cluster",<br/>  "cluster_uuid" : "cnGc-4uLSIWS-bFwr8ywug",<br/>  "version" : {<br/>    "number" : "7.5.1",<br/>    "build_flavor" : "default",<br/>    "build_type" : "docker",<br/>    "build_hash" : "3ae9ac9a93c95bd0cdc054951cf95d88e1e18d96",<br/>    "build_date" : "2019-12-16T22:57:37.835892Z",<br/>    "build_snapshot" : false,<br/>    "lucene_version" : "8.3.0",<br/>    "minimum_wire_compatibility_version" : "6.8.0",<br/>    "minimum_index_compatibility_version" : "6.0.0-beta1"<br/>  },<br/>  "tagline" : "You Know, for Search"<br/>}</span></pre><p id="4f05" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要找到任何有用的信息，您可以导航到elasticsearch容器的外壳:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d428" class="lf ju hi lb b fi lg lh l li lj">$ docker exec -it elasticsearch /bin/bash</span></pre><h1 id="479d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Logstash容器</h1><p id="dbf3" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">像以前一样，在项目的根目录中为<a class="ae js" href="https://www.elastic.co/products/logstash" rel="noopener ugc nofollow" target="_blank"> logstash </a>及其配置设置创建以下文件夹。</p><ul class=""><li id="2f99" class="ln lo hi iw b ix iy jb jc jf lp jj lq jn lr jr ls lt lu lv bi translated"><strong class="iw hj">config</strong>:<code class="du lk ll lm lb b">config</code>文件夹将保存logstash系统范围的配置设置。</li><li id="cecf" class="ln lo hi iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated"><strong class="iw hj">管道</strong>:<code class="du lk ll lm lb b">pipeline</code>文件夹将保存您想要处理的每个日志文件的logstash配置设置。</li><li id="2ea8" class="ln lo hi iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated"><strong class="iw hj">日志文件:</strong><code class="du lk ll lm lb b">logfile</code>文件夹将包含日志文件(网络日志、Apache日志等等)</li></ul><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4f1d" class="lf ju hi lb b fi lg lh l li lj">$ cd ~/docker-elk<br/>$ mkdir -p logstash/{config,pipeline,logfile}</span></pre><p id="a09b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为Logstash创建Dockerfile。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="797f" class="lf ju hi lb b fi lg lh l li lj">$ vi ~/docker-elk/logstash/Dockerfile<br/>ARG ELK_VERSION<br/>FROM docker.elastic.co/logstash/logstash-oss:${ELK_VERSION}<br/>RUN logstash-plugin install logstash-input-beats<br/>USER root<br/>RUN mkdir -p /home/logstash/logfile<br/>RUN chown -R logstash:logstash /home/logstash/logfile/</span></pre><p id="275a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在创建Logstash配置文件</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e080" class="lf ju hi lb b fi lg lh l li lj">$ vi ~/docker-elk/logstash/config/logstash.yml<br/>http.host: "0.0.0.0"<br/>path.config: /usr/share/logstash/pipeline</span></pre><p id="40d6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将使用Apache访问和错误日志来测试Logstash管道配置。那么如何将apache日志事件流式传输到logstash呢？一种实时传输apache日志的方法是使用filebeat。</p><p id="5f8c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为logstash创建一个管道配置，它将在端口号5000中接受apache日志事件，并在应用适当的过滤器后将它们推送到elasticsearch容器。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="cc19" class="lf ju hi lb b fi lg lh l li lj">$ vi ~/docker-elk/logstash/pipeline/01.apache.conf</span><span id="2a91" class="lf ju hi lb b fi mb lh l li lj">input {<br/>        beats {<br/>                port =&gt; 5000<br/>                type =&gt; apache<br/>        }<br/>}</span><span id="ccd6" class="lf ju hi lb b fi mb lh l li lj">filter {<br/>       if [type] == "apache" {<br/>        grok {<br/>               match =&gt; { "message" =&gt; "%{COMBINEDAPACHELOG}" }<br/>             }<br/>        }<br/>}</span><span id="d9b1" class="lf ju hi lb b fi mb lh l li lj">output {<br/>         if [type] == "apache" {<br/>         elasticsearch {<br/>                         hosts =&gt; ["http://elasticsearch:9200"]<br/>                         index =&gt; "apache-combined-%{+YYYY.MM.dd}"<br/>                       }<br/>         stdout { codec =&gt; rubydebug }<br/>         }<br/>}</span></pre><p id="9483" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">logstash的所有必要配置设置都已就绪，可以在docker compose中为它定义服务。编辑docker合成文件，并在其中添加以下内容。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3280" class="lf ju hi lb b fi lg lh l li lj">$ vi ~/docker-elk/docker-compose.yml<br/>...<br/>...<br/>  logstash:<br/>     container_name: logstash<br/>     build:<br/>        context: logstash<br/>        args:<br/>          ELK_VERSION: $ELK_VERSION<br/>     volumes:<br/>       - ./logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml<br/>       - ./logstash/pipeline:/usr/share/logstash/pipeline</span><span id="5575" class="lf ju hi lb b fi mb lh l li lj">     ports:<br/>       - "5000:5000"</span><span id="4574" class="lf ju hi lb b fi mb lh l li lj">     networks:<br/>       - elk</span><span id="3e2e" class="lf ju hi lb b fi mb lh l li lj">     depends_on:<br/>       - elasticsearch<br/>...<br/>...</span></pre><p id="0b76" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">构建日志存储容器</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="38d8" class="lf ju hi lb b fi lg lh l li lj">$ docker-compose build logstash</span></pre><p id="97dc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在没有分离模式的情况下运行Logstash容器，以在终端中查看logstash启动日志。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0297" class="lf ju hi lb b fi lg lh l li lj">$ docker-compose up logstash</span></pre><p id="c077" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果一切正常，按CTRL+C，在分离模式下再次运行logstash容器。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="cdbf" class="lf ju hi lb b fi lg lh l li lj">$ docker-compose up -d logstash</span></pre><p id="cfe2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">列出集装箱</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5c00" class="lf ju hi lb b fi lg lh l li lj">$ docker ps -a</span></pre><h1 id="3882" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">基巴纳集装箱</h1><p id="b519" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">从容器化<a class="ae js" href="https://www.elastic.co/products/kibana" rel="noopener ugc nofollow" target="_blank"> Kibana </a>开始，创建名为<strong class="iw hj"> config </strong>的文件夹来保存Kibana配置。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7e0e" class="lf ju hi lb b fi lg lh l li lj">$ cd ~/docker-elk<br/>$ mkdir -p kibana/config</span></pre><p id="ff66" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建一个docker文件来组装最新kibana的映像。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="19e7" class="lf ju hi lb b fi lg lh l li lj">$ vi ~/docker-elk/kibana/Dockerfile<br/>ARG ELK_VERSION<br/>FROM docker.elastic.co/kibana/kibana:${ELK_VERSION}</span></pre><p id="6ede" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">编辑和创建Kibana配置文件。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="167c" class="lf ju hi lb b fi lg lh l li lj">$ vi ~/docker-elk/kibana/config/kibana.yml<br/>server.name: kibana<br/>server.host: "0"<br/>server.basePath: "/kibana"<br/>elasticsearch.hosts: http://elasticsearch:9200<br/>apm_oss.enabled: true<br/>xpack.apm.enabled: true<br/>xpack.apm.ui.enabled: true<br/>logging.dest: stdout</span></pre><p id="7660" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，在docker文件中追加Kibana服务。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="fa68" class="lf ju hi lb b fi lg lh l li lj">$ vi docker-compose.yml<br/>…<br/>…<br/>  kibana:<br/>     container_name: kibana<br/>     build:<br/>        context: kibana/<br/>        args:<br/>          ELK_VERSION: $ELK_VERSION<br/>     volumes:<br/>       - ./kibana/config/:/usr/share/kibana/config<br/>     ports:<br/>       - "5601:5601"<br/>     environment:<br/>       - ELASTICSEARCH_PASSWORD="changeme"<br/>     networks:<br/>       - elk<br/>     depends_on:<br/>       - elasticsearch</span></pre><p id="ec42" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">构建并运行kibana</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2a81" class="lf ju hi lb b fi lg lh l li lj">$ docker-compose build kibana<br/>$ docker-compose up -d kibana</span></pre><p id="b1a7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">列出基巴纳容器:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9d0a" class="lf ju hi lb b fi lg lh l li lj">$ docker ps -a</span></pre><h1 id="51b1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">NGINX容器</h1><p id="cf33" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">添加NGINX容器的主要动机是通过反向代理提供对Kibana接口的密码保护访问。</p><p id="571e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在docker项目的根目录下为NGINX容器创建文件夹，然后创建两个名为<code class="du lk ll lm lb b">public</code>和<code class="du lk ll lm lb b">data</code>的子文件夹</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4d51" class="lf ju hi lb b fi lg lh l li lj">$ cd ~/docker-elk<br/>$ mkdir -p nginx/{public,data,etc}</span></pre><p id="412b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为NGINX创建一个简单的索引文件</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8d17" class="lf ju hi lb b fi lg lh l li lj">$ vi nginx/public/index.html<br/>&lt;html&gt;<br/>It Works<br/>&lt;/html&gt;</span></pre><p id="628b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建NGINX配置文件。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="be6b" class="lf ju hi lb b fi lg lh l li lj">$ vi ~/docker-elk/nginx/etc/nginx.conf<br/>worker_processes 4;   </span><span id="7735" class="lf ju hi lb b fi mb lh l li lj">events {<br/>              worker_connections 1024;<br/>}</span><span id="aba5" class="lf ju hi lb b fi mb lh l li lj">http {</span><span id="4b0d" class="lf ju hi lb b fi mb lh l li lj">server {<br/>       listen 80;<br/>       server_name IP_OR_DOMAIN ;</span><span id="7166" class="lf ju hi lb b fi mb lh l li lj">       location / {<br/>       root /usr/share/nginx/html;<br/>       <!-- -->index index.html;<!-- --> <br/>       }</span><span id="eb00" class="lf ju hi lb b fi mb lh l li lj">       location /elastic/ {<br/>       proxy_pass http://elasticsearch:9200/;<br/>       proxy_set_header X-Real-IP $remote_addr;<br/>       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br/>       proxy_set_header Host $http_host;</span><span id="61f7" class="lf ju hi lb b fi mb lh l li lj">       auth_basic "Restricted Content";<br/>       auth_basic_user_file /etc/nginx/.htpasswd.user;<br/>       }</span><span id="7a7d" class="lf ju hi lb b fi mb lh l li lj">       location /kibana/ {<br/>       proxy_pass http://kibana:5601/;<br/>       proxy_set_header X-Real-IP $remote_addr;<br/>       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br/>       proxy_set_header Host $http_host;<br/>       rewrite ^/kibana/(.*)$ /$1 break;<br/>       auth_basic "Restricted Content";<br/>       auth_basic_user_file /etc/nginx/.htpasswd.user;                     <br/>       }<br/>     }<br/>}</span></pre><p id="91be" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于kibana的密码保护访问，您需要安装<code class="du lk ll lm lb b">httpd-tools</code>并使用htpasswd创建用户/密码。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6b05" class="lf ju hi lb b fi lg lh l li lj">$ yum install httpd-tools<br/>$ cd ~/docker-elk/nginx/etc<br/>$ htpasswd -c .htpasswd.user admin</span></pre><p id="091a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为GINX定义docker服务</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="cf9e" class="lf ju hi lb b fi lg lh l li lj">$ vi ~/docker-elk/docker-compose.yml<br/>…<br/>…<br/> nginx:<br/>    image: nginx:alpine<br/>    container_name: nginx<br/>    volumes:<br/>      - './nginx/etc/nginx.conf:/etc/nginx/nginx.conf:ro'<br/>      - './nginx/public:/usr/share/nginx/html:ro'<br/>      - './nginx/etc/.htpasswd.user:/etc/nginx/.htpasswd.user:ro'<br/>    links:<br/>      - elasticsearch<br/>      - kibana<br/>    depends_on:<br/>      - elasticsearch<br/>      - kibana<br/>    ports:<br/>      - '80:80'<br/>    networks:<br/>      - elk</span></pre><p id="000a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">运行NGINX容器</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6ddf" class="lf ju hi lb b fi lg lh l li lj">$ docker-compose up -d nginx</span></pre><p id="4b13" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">列出NGINX容器:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="adb6" class="lf ju hi lb b fi lg lh l li lj">$ docker ps -a</span></pre><p id="a0c2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦NGINX容器启动并运行，使用<a class="ae js" href="http://server_ip/kibana" rel="noopener ugc nofollow" target="_blank"> http://SERVER_IP/kibana </a>访问kibana接口</p><p id="30b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用以下命令检查任何容器的日志</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c3e6" class="lf ju hi lb b fi lg lh l li lj">$ docker logs container_name_or_id<br/>e.g. docker logs elasticsearch</span></pre><p id="0a38" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">列出所有正在运行的容器</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d8aa" class="lf ju hi lb b fi lg lh l li lj">$ docker ps -a</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/5fe736c7caf742e4395ff4e3061fc014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKX9a3sVHn0JgsFqBCJ1Gw.png"/></div></div></figure><p id="d1ad" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">测试弹性搜索容器</p><p id="d965" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">打开自己喜欢的网页浏览器，指向<a class="ae js" href="http://SERVER_IP/elastic" rel="noopener ugc nofollow" target="_blank"> http://SERVER_IP/elastic </a></p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/792cb8ad76058f98b7795c2360326e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Iifsn38vo4BByUt62LlDQ.png"/></div></div></figure><h1 id="4316" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Filebeat配置(客户端):</h1><p id="c1c5" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">既然您的ELK栈已经启动并运行，那么使用<a class="ae js" href="https://www.elastic.co/products/beats/filebeat" rel="noopener ugc nofollow" target="_blank"> filebeat </a>从任何远程系统流式传输Apache日志来测试设置。您还可以选择一些其他日志事件，如NGINX、CISCO syslog等。但是要确保您有正确的logstash管道配置。</p><p id="8ec1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">安装filebeat:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c470" class="lf ju hi lb b fi lg lh l li lj">$ wget [https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.5.0-amd64.deb](https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.5.0-amd64.deb)<br/>$ dpkg -i filebeat-6.5.0-amd64.deb</span></pre><p id="31f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">配置filebeat:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1898" class="lf ju hi lb b fi lg lh l li lj">$ vi /etc/filebeat/filebeat.yml<br/>...<br/>...<br/>filebeat.inputs:<br/>- type: log<br/>  enabled: true<br/>  paths:<br/>    - /var/log/apache2/*.log<br/>...<br/>...<br/>output.logstash:<br/>  # The Logstash hosts<br/>  hosts: ["123.45.67.89:5000"]<br/>...<br/>...</span></pre><p id="1d99" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">运行filebeat</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a6f1" class="lf ju hi lb b fi lg lh l li lj">$ filebeat -e -d "*"</span></pre><p id="0a85" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过导航到管理-&gt;索引模式-&gt;创建索引模式并在文本框中键入apache-combined-*来找到kibana仪表板中的ES索引，以完成该过程。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/1540b99b1d410da974f9a6224c98db4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x66xshAGt-HxHuuyJzytNw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">基巴纳仪表板</figcaption></figure><h1 id="c02c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="2609" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">如果你已经弥补了这一点:——祝贺你！您已成功对接ELK堆栈。继续创建几个logstash管道，以便从不同的源传输日志事件。</p><p id="3c57" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">代码@<a class="ae js" href="https://github.com/DwijadasDey/docker-elk" rel="noopener ugc nofollow" target="_blank">https://github.com/DwijadasDey/docker-elk</a></p></div></div>    
</body>
</html>