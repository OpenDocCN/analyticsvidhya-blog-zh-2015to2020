<html>
<head>
<title>A Java Tour</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">爪哇之旅</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-java-tour-302046ea443d?source=collection_archive---------24-----------------------#2020-05-05">https://medium.com/analytics-vidhya/a-java-tour-302046ea443d?source=collection_archive---------24-----------------------#2020-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="910d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们利用这些天的空闲时间重温Java编程语言吧！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/245e0dfb2c50468589f6c7c716f57888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jls7q5BTxd-tDIe80ZKwSA.png"/></div></div></figure><p id="ad01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java被广泛认为是产生高质量代码的强大语言……至少如果你能驾驭野兽的话！因为Java也确实是一种(相当)冗长的语言，它不会试图隐藏任何东西:缺乏语法上的好处可能会让您感觉更接近计算机实际做的事情，这一特性可能会让通常使用JavaScript或Python的初学者甚至高级脚本编写人员感到沮丧。尽管如此，Java社区很清楚这一点，并努力以完全向后兼容的方式改进产品<em class="jp">。</em></p><p id="9616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也许你学过Java编程，也许是彻底的灾难！然后和很多人一样，你发现了Python，TypeScript，Kotline什么的，感觉轻而易举！这些年来，你一直认为Java是一种过时的语言，运行缓慢，还在使用，只是因为现有的代码库。好吧，让我们看看现代Java到底是什么样子。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="5103" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这次闲聊中，我们将研究一些现实问题的一个用例。客户有一个数据源(数据库、文件等)，我们可以通过查询来获取表单信息</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="2a28" class="kc kd hi jy b fi ke kf l kg kh">people_name ; zip_code ; waste_weight_yesterday</span></pre><p id="02ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不能像往常一样直接访问数据源。相反，我们需要向外部服务查询它:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="141f" class="kc kd hi jy b fi ke kf l kg kh">public interface RemoteService {<br/>   InputStream datasource() throws IOException;<br/>}</span></pre><p id="18b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户要求我们根据邮政编码(<code class="du ki kj kk jy b">String</code>)找出昨天产生最多垃圾的前3名(<code class="du ki kj kk jy b">String</code>)。数据源应该没有任何损坏的数据(这通常不会发生，但让我们假设一下！).客户要求用Java来完成，以便集成到自己的代码库中。但愿，这是个好机会！我写的就是这个问题，所以你不用写任何代码，只需复制/粘贴:你真幸运。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="1a65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个好的架构的最低要求是至少有一个描述我们计算结果的接口草图。基本上，我们的报告将是一些我们可以如下操作的对象:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="452a" class="kc kd hi jy b fi ke kf l kg kh">interface Report {</span><span id="653c" class="kc kd hi jy b fi kl kf l kg kh">   enum TopPosition {<br/>      TOP_1, TOP_2, TOP_3;<br/>   }</span><span id="583b" class="kc kd hi jy b fi kl kf l kg kh">   Optional&lt;Entry&gt; getTop(String zipCode, TopPosition position);<br/>   List&lt;String&gt; getAllZipCodes();<br/>}</span><span id="d022" class="kc kd hi jy b fi kl kf l kg kh">record Entry {<br/>   String name();<br/>   String zipCode();<br/>   int wasteAmount();<br/>}</span></pre><p id="f8b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jp">注意:</em>我们稍后将讨论记录类型。现在，让我们跳过这个！</p><p id="13e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jp">注意:</em>我们本应该用<code class="du ki kj kk jy b">Set</code>而不是<code class="du ki kj kk jy b">List</code>来设计界面，但是它将不会很好地适合下面的段落！所以过了这一段，自己做把<code class="du ki kj kk jy b">List</code>改成<code class="du ki kj kk jy b">Set</code>的心理练习吧！</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="6cdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实现任何进一步的机制之前，让我们以一种非平凡的方式通过查询<code class="du ki kj kk jy b">Report</code>来热身。我们要做的小练习是<strong class="ih hj">找到所有前1名</strong>。让我们看看不同的实现。首先是糟糕的Java:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="25d3" class="kc kd hi jy b fi ke kf l kg kh">List&lt;Entry&gt; top1s = new ArrayList&lt;&gt;(); // array-like, with mut. size<br/>List&lt;String&gt; codes = report.getAllZipCodes();<br/>for (int i = 0; i &lt; codes.size(); i++) {<br/>   Optional&lt;Entry&gt; top1 = getTop(codes.get(i), TOP_1);<br/>   if (top1.isPresent()) {<br/>      top1s.add(top1.get());<br/>   }<br/>}</span></pre><p id="5350" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不用说，这个实现(遗憾的是它仍然存在于社区中)是一个明智的宣战。如果你的<code class="du ki kj kk jy b">List</code>是一个<code class="du ki kj kk jy b">LinkedList</code>，上面的这个迭代很大程度上是为了<code class="du ki kj kk jy b">O(n²)</code>。此外，<code class="du ki kj kk jy b">ArrayList</code>实现可能不是我们所做的许多推送的最佳选择，因为内部数组缓冲区需要被复制很多次。不幸的是，学生们经常被告知要这样编码。</p><p id="3688" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看另一种更现代的实现方式:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="03fe" class="kc kd hi jy b fi ke kf l kg kh">List&lt;Entry&gt; top1s = new Stack&lt;&gt;(); // pushing in stack is O(1)<br/>for (String zipCode : report.getAllZipCodes())<br/>   getTop(zipCode, TOP_1).ifPresent(top1s::push);</span></pre><p id="391e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面，我们强调了这样一个事实，方法引用<code class="du ki kj kk jy b">top1s::push</code>可能被认为是lambda表达式，而这又可能被认为是匿名接口实例化。这里的接口是Java猜测的，因为<code class="du ki kj kk jy b">Optional&lt;Entry&gt;</code>上的<code class="du ki kj kk jy b">ifPresent</code>只需要一个<code class="du ki kj kk jy b">Consumer&lt;Entry&gt;</code>，所以</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="8c1d" class="kc kd hi jy b fi ke kf l kg kh">Consumer&lt;Entry&gt; c = top1s::push;</span></pre><p id="ad11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在语法上等同于</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="42c3" class="kc kd hi jy b fi ke kf l kg kh">Consumer&lt;Entry&gt; c = entry -&gt; top1s.push(entry);</span></pre><p id="248b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在语法上相当于</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="86b3" class="kc kd hi jy b fi ke kf l kg kh">Consumer&lt;Entry&gt; c = new Consumer&lt;&gt;() {<br/>   @Override public void accept(Entry entry) {<br/>      top1s.push(entry);<br/>   }<br/>}</span></pre><p id="b727" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">lambda表达式和方法引用可能被认为是后者的语法糖。其实也有编制差异。一般来说，与匿名类方法相比，编译器更喜欢方法引用方法。对于lambda表达式，这实际上取决于lambda的内容。</p><p id="49f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过避免先验的boiler-plated空列表初始化来进一步研究上面的例子:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="827d" class="kc kd hi jy b fi ke kf l kg kh">List&lt;Entry&gt; top1s = report.getAllZipCodes()<br/>       .stream()<br/>       .map(zipCode -&gt; report.getTop(zipCode, TOP_1))<br/>       .flatMap(Optional::stream)<br/>       .collect(Collectors.toList());</span></pre><p id="31e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有趣的是，虽然是以函数式风格编写的，但后者实际上比第二种基于循环的方法更冗长，而且没有太多的表现力。我们也失去了显式选择列表实现的好处。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="4dfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们来看一下报告的实施和数据处理本身。我们将一步一步来。首先，我们将尽快处理这些行以释放资源:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="5906" class="kc kd hi jy b fi ke kf l kg kh">Report process (RemoteService service) throws IOException {</span><span id="8872" class="kc kd hi jy b fi kl kf l kg kh">   List&lt;String&gt; rows = new Stack&lt;&gt;();</span><span id="87bd" class="kc kd hi jy b fi kl kf l kg kh">   try(InputStream inputStream = service.datasource();<br/>       Scanner scanner = new Scanner(inputStream)<br/>   ) {<br/>      while(scanner.hasNextLine())<br/>         rows.push(scanner.nextLine());<br/>   }</span></pre><p id="bcb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也许你不熟悉try-with-resource语法，它也是JDK7以来的一个语言特性。try-with-resource参数可以接受任何列表中的<code class="du ki kj kk jy b">AutoCloseable</code>子类型，并且在try-block结束时，或者如果发生任何异常，每个提供的<code class="du ki kj kk jy b">AutoCloseable</code> with be…会自动关闭。这意味着在Java中，永远不要自己调用<code class="du ki kj kk jy b">close</code>方法。这类似于Python的<code class="du ki kj kk jy b">with</code>语法。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="424d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在要处理每一行。客户需要我们根据邮政编码汇总每个<code class="du ki kj kk jy b">String</code>，然后找到前3个。让我们将每个<code class="du ki kj kk jy b">String</code>包装到一些更方便的类中:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="e008" class="kc kd hi jy b fi ke kf l kg kh">class Row {<br/>   private final String source, zipCode;<br/>   private final int wasteAmount;<br/>   Row(String source) {<br/>      this.source = source;<br/>      zipCode = source.substring(<br/>                        source.indexOf(";")+1,<br/>                        source.lastIndexOf(";")<br/>                    );<br/>      wasteAmount = Integer.parseInt(<br/>                        source.substring(source.lastIndexOf(";"))<br/>                    );<br/>   }</span><span id="1fd9" class="kc kd hi jy b fi kl kf l kg kh">   String getZipCode() { return zipCode; }<br/>   String getName() {<br/>      return source.substring(0, source.indexOf(";"));<br/>   }<br/>   int getWasteAmount() { return wasteAmount; }<br/>}</span></pre><p id="06d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，这个类是从一个<code class="du ki kj kk jy b">String</code>构造的，但是保持了一个更复杂的内部状态，因为它预先提取了邮政编码，并且将垃圾量转换为整数。最后，它提供了以更透明的方式访问这些信息和名称的方法。还要注意完全保护实例内部状态的封装模式。从外部的角度来看，只有getters存在:这个类的客户不应该知道更多。</p><p id="373e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样包装<code class="du ki kj kk jy b">String</code>源有效率吗？<code class="du ki kj kk jy b">String</code>的开销大约是内部数组<code class="du ki kj kk jy b">char[]</code>引用的64位+数组中每个字符的16位x长度，所以</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="cdbb" class="kc kd hi jy b fi ke kf l kg kh">String_weight ~ 64 + length * 16</span></pre><p id="168f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一个常见的用例中，姓名的顺序是2⁴，邮政编码的顺序是2。浪费量用小数表示应该挺小的，再说2位数吧。因此<code class="du ki kj kk jy b">source</code>场的权重大约是</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="3b9b" class="kc kd hi jy b fi ke kf l kg kh">source_weight ~ 64 + 2^5 * 16 ~ 2^9 </span></pre><p id="5aaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过内部对象引用，我们的类的权重是64位(我们有2个，2个<code class="du ki kj kk jy b">String</code>)，32位用于int原语类型，以及每个字符串权重的额外成本，所以:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="b365" class="kc kd hi jy b fi ke kf l kg kh">row_weight ~ 64 + (64 + 2^5 * 16) + 64 + (64 + 2^2 * 16) + 32 ~ 2^10</span></pre><p id="4ead" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比例是1.5，没那么大。从<code class="du ki kj kk jy b">String</code>到<code class="du ki kj kk jy b">Row</code>的转换将不再是一个问题，它将极大地改善算法方面。使用<code class="du ki kj kk jy b">Stream</code>方式可以非常平稳地完成转换:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="7a4f" class="kc kd hi jy b fi ke kf l kg kh">rows.stream().map(Row::new)  // Stream&lt;Row&gt;</span></pre><p id="9e47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看我们如何通过方法引用调用<code class="du ki kj kk jy b">Row</code>的构造函数。我们知道有一连串的行。没有必要再次将其转换为<code class="du ki kj kk jy b">List</code>，我们已经可以使用流的<code class="du ki kj kk jy b">collect</code>工具进行聚合:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="09b0" class="kc kd hi jy b fi ke kf l kg kh">rows.stream().map(Row::new)<br/>             .collect(Collectors.groupingBy(Row::getZip))</span></pre><p id="1902" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分组的结果是一个将每个邮政编码(<code class="du ki kj kk jy b">String</code>)映射到相应的<code class="du ki kj kk jy b">Row</code>列表的<code class="du ki kj kk jy b">Map&lt;String,List&lt;Row&gt;&gt;</code>。我们现在将迭代这个图的每个键，对于每个键，根据浪费量对列表进行排序，并将结果限制为3个元素。同样，<code class="du ki kj kk jy b">Stream</code>接口足够丰富，可以处理这种计算:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="bbfe" class="kc kd hi jy b fi ke kf l kg kh">rows.stream().map(Row::new)<br/>             .collect(Collectors.groupingBy(Row::getZip))<br/>             .entrySet().stream()<br/>             // Stream&lt;Map.Entry&lt;String, List&lt;Row&gt;&gt;&gt;<br/>             .collect(Collectors.toMap(<br/>                 Map.Entry::getKey,<br/>                 entry -&gt; entry.getValue().stream() // Stream&lt;Row&gt;<br/>                            .sorted(???)            // to do<br/>                            .limit(3)               // Stream&lt;Row&gt;<br/>                            .toArray(Row[]::new)    // Row[]<br/>             ));</span></pre><p id="0757" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面这里，蒸汽上的<code class="du ki kj kk jy b">sorted</code>方法需要一个<code class="du ki kj kk jy b">Comparator&lt;Row&gt;</code>。定义非常清楚:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="0200" class="kc kd hi jy b fi ke kf l kg kh">@FunctionalInterface public interface Comparator&lt;T&gt;</span></pre><p id="2c2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ki kj kk jy b">@FunctionalInterface</code>注释意味着一个比较器只有一个抽象方法。这表明有人被邀请在类实现中或通过方法引用实例化这样的接口。</p><p id="3035" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，在<code class="du ki kj kk jy b">Row</code>的层次上实现<code class="du ki kj kk jy b">Comparator</code>接口没有多大意义，因为从业务的角度来看，它们并不都是可比较的:我们只是被要求逐个邮政编码地比较它们。(当然，对它们进行全球比较是有意义的，但这是一种推断)。深入研究一下，我们发现JDK8中有一个工具可以从一个<code class="du ki kj kk jy b">Row</code>中提取int，并将其用作比较键:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="50b3" class="kc kd hi jy b fi ke kf l kg kh">.sorted(Comparator.comparingInt(Row::getWasteAmount))</span></pre><p id="6f77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总而言之，我们现在已经</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="4d3b" class="kc kd hi jy b fi ke kf l kg kh">var mapping<br/>  = rows.stream().map(Row::new)<br/>        .collect(Collectors.groupingBy(Row::getZip))<br/>        .entrySet().stream()<br/>        .collect(Collectors.toMap(Map.Entry::getKey,<br/>            entry -&gt; entry.getValue().stream()<br/>                          .sorted(comparingInt(row::getWasteAmount))<br/>                          .limit(3)<br/>                          .toArray(Row[]::new)<br/>        ));</span></pre><p id="aaf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的最后一次收集中，我们可以使用<code class="du ki kj kk jy b">List</code>进行收集，但是数组解决方案通常更便宜。</p><p id="7824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还使用了特殊的<code class="du ki kj kk jy b">var</code>关键字，因为编译器可以自己猜测正确的成员是一个<code class="du ki kj kk jy b">Map&lt;String,Row[]&gt;</code>，没有必要重复。<code class="du ki kj kk jy b">var</code>是JDK10的一个特性。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="b940" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的线都处理成功了，干得好！现在让我们实现我们的<code class="du ki kj kk jy b">Report</code>和<code class="du ki kj kk jy b">Entry</code>类型。我们已经在一个<code class="du ki kj kk jy b">Map&lt;String, Row[]&gt;</code>中收集了所有的信息，并且我们已经完全控制了地图，因为我们是它的创造者。让我们将这些信息封装在一个<code class="du ki kj kk jy b">Report</code>外壳中:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="a66c" class="kc kd hi jy b fi ke kf l kg kh">class ReportImpl implements Report {<br/>   private final Map&lt;String, Row[]&gt; mapping;<br/>   ReportImpl(Map&lt;String, Row[]&gt; mapping) {<br/>      this.mapping = mapping;<br/>   }</span><span id="d42f" class="kc kd hi jy b fi kl kf l kg kh">   @Override public Set&lt;? extends String&gt; getAllZipCodes() {<br/>      return mapping.keySet();<br/>   }</span><span id="8b89" class="kc kd hi jy b fi kl kf l kg kh">   @Override public Optional&lt;Entry&gt; getTop(String zipCode,<br/>                                           TopPosition position) {<br/>      var idx = switch(position) {<br/>         case TOP_1 -&gt; 0;<br/>         case TOP_2 -&gt; 1;<br/>         case TOP_3 -&gt; { yield 2; };<br/>      }<br/>      return Optional.ofNullable(mapping.get(zipCode))<br/>                     .map(arr -&gt; arr.length &gt; idx ? arr[idx]: null)<br/>                     .map(???);<br/>   }<br/>}</span></pre><p id="111e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意使用了<code class="du ki kj kk jy b">var</code>关键字来声明一个由右成员初始化的变量。这里，编译器可以自己推断出<code class="du ki kj kk jy b">idx</code>的类型是<code class="du ki kj kk jy b">int</code>。</p><p id="ee69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还要注意上面开关表达式的使用。在JDK14中，开关表达式允许在基本类型、字符串和枚举上进行模式匹配(实际上是通常的开关)，有以下区别:</p><ol class=""><li id="84ae" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">没有失败行为:不需要在案例之间中断，这更像是一个映射</li><li id="9898" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">映射的右侧可以是一个以<code class="du ki kj kk jy b">yield</code>结束的块，以提供一个值，就像我们的第三个例子</li><li id="dd01" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">在枚举匹配的情况下，不需要缺省情况:编译器检测映射是否穷尽。</li></ol><p id="0674" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JDK15中的<code class="du ki kj kk jy b">sealed class</code>旨在改进开关表达式，但那是以后的事了！</p><p id="2598" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们来说，我们现在需要的是能够创建一个<code class="du ki kj kk jy b">Entry</code>。因为一个<code class="du ki kj kk jy b">Entry</code>实际上是暴露给客户端的最后一个流程步骤，所以我们不会让它成为一个<code class="du ki kj kk jy b">Entry</code>来污染我们的<code class="du ki kj kk jy b">Row</code>类，尽管它已经包含了所有的信息！为什么？因为我们希望将这两者分开:<code class="du ki kj kk jy b">Row</code>旨在表示一个我们可以计算的可处理实体，而<code class="du ki kj kk jy b">Entry</code>只是一个数据传输对象，就像数据的快照。</p><p id="abd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这非常适合JDK14中作为预览功能引入的<code class="du ki kj kk jy b">record</code>!记录只不过是一个类，除了在其构造函数中提供的字段之外，不能包含任何其他字段。还记得我们的<code class="du ki kj kk jy b">Row</code>类是怎么回事吗？那是因为一个<code class="du ki kj kk jy b">Row</code>确实是我们操纵的东西，它可能包含很多信息。它显然不同于其构造函数参数的总和。对于一个更像是我们想要与客户端共享的一些异构元组的<code class="du ki kj kk jy b">Entry</code>,情况可能会有所不同。</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="b5ca" class="kc kd hi jy b fi ke kf l kg kh">record Entry(String name,String zipCode,int wasteAmount) {<br/>   EntryDto { // post-construct process, the record component exist!<br/>      assert name != null;<br/>      assert zipCode != null;<br/>   }<br/>}</span></pre><p id="5df2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记录机制为构造函数中提供的每个<code class="du ki kj kk jy b">x</code>字段(组件)自动生成一个方法<code class="du ki kj kk jy b">x()</code>。它还接受一个后构造函数块，当提供组件时将调用该块。我们可以使用它进行非常基本的验证(这里我们防止空引用)。</p><p id="fa04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记录机制还会根据字段自动为我们生成<code class="du ki kj kk jy b">hashCode</code>和<code class="du ki kj kk jy b">equals</code>方法。<code class="du ki kj kk jy b">record</code>是一种Scala case类，区别在于:</p><ol class=""><li id="9bf4" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">除了在构建时提供的字段之外，它不能包含其他字段</li><li id="c0c3" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">无论是类还是记录，都不能从另一个记录继承</li></ol></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="0734" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是最终的代码:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="a068" class="kc kd hi jy b fi ke kf l kg kh">record Entry(String name,String zipCode,int wasteAmount) {<br/>   Entry {<br/>      assert name != null;<br/>      assert zipCode != null;<br/>   }<br/>}</span><span id="e211" class="kc kd hi jy b fi kl kf l kg kh">class Row {<br/>   private final String source, zipCode;<br/>   private final int wasteAmount;<br/>   Row(String source) {<br/>      this.source = source;<br/>      zipCode = source.substring(<br/>                        source.indexOf(";")+1,<br/>                        source.lastIndexOf(";")<br/>                    ).trim();<br/>      wasteAmount = Integer.parseInt(<br/>                        source.substring(source.lastIndexOf(";"))<br/>                              .trim()<br/>                    );<br/>   }</span><span id="808c" class="kc kd hi jy b fi kl kf l kg kh">   String getZipCode() { return zipCode; }<br/>   String getName() {<br/>      return source.substring(0, source.indexOf(";")).trim();<br/>   }<br/>   int getWasteAmount() { return wasteAmount; }<br/>}</span><span id="e868" class="kc kd hi jy b fi kl kf l kg kh">class ReportImpl implements Report {<br/>   private final Map&lt;String, Row[]&gt; mapping;<br/>   ReportImpl(Map&lt;String, Row[]&gt; mapping) {<br/>      this.mapping = mapping;<br/>   }</span><span id="2090" class="kc kd hi jy b fi kl kf l kg kh">   @Override public Set&lt;? extends String&gt; getAllZipCodes() {<br/>      return mapping.keySet();<br/>   }</span><span id="ae23" class="kc kd hi jy b fi kl kf l kg kh">@Override public Optional&lt;Entry&gt; getTop(String zipCode,<br/>                                        TopPosition position) {<br/>      var idx = switch(position) {<br/>         case TOP_1 -&gt; 0;<br/>         case TOP_2 -&gt; 1;<br/>         case TOP_3 -&gt; 2;<br/>      }<br/>      return Optional.ofNullable(mapping.get(zipCode))<br/>                     .map(arr -&gt; arr.length &gt; idx ? arr[idx]: null)<br/>                     .map(row -&gt; new Entry(<br/>                                        row.getName(),<br/>                                        row.getZipCode(),<br/>                                        row.getWasteAmount()<br/>                     ));<br/>   }<br/>}</span><span id="273a" class="kc kd hi jy b fi kl kf l kg kh">Report process (RemoteService service) throws IOException {<br/>   var rows = new Stack&lt;String&gt;();<br/>   try(InputStream inputStream = service.datasource();<br/>       Scanner scanner = new Scanner(inputStream)<br/>   ) {<br/>      while(scanner.hasNextLine())<br/>         rows.push(scanner.nextLine());<br/>   }<br/>   var mapping = rows.stream()<br/>        .map(Row::new)<br/>        .collect(Collectors.groupingBy(Row::getZip))<br/>        .entrySet().stream()<br/>        .collect(Collectors.toMap(Map.Entry::getKey,<br/>            entry -&gt; entry.getValue().stream()<br/>                          .sorted(comparingInt(row::getWasteAmount))<br/>                          .limit(3)<br/>                          .toArray(Row[]::new)<br/>        ));<br/>   return new ReportImpl(mapping);<br/>}</span></pre></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="8ec8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你在我们的聊天中学到了一些关于Java的知识！</p><p id="faac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你现在确信Java不是纯粹邪恶的冗长语言。不要犹豫，分享你的感受吧！</p></div></div>    
</body>
</html>