<html>
<head>
<title>Designing a contextual chatbot in Telegram with Python, Github &amp; Heroku — part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python、Github和Heroku在Telegram中设计上下文聊天机器人—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/designing-a-contextual-chatbot-in-telegram-with-python-github-heroku-part-1-39e24e7c7723?source=collection_archive---------7-----------------------#2020-04-10">https://medium.com/analytics-vidhya/designing-a-contextual-chatbot-in-telegram-with-python-github-heroku-part-1-39e24e7c7723?source=collection_archive---------7-----------------------#2020-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="98c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">电报机器人是运行在应用程序内部的第三方应用程序。用户可以通过向机器人发送消息、命令和内嵌请求来与它们进行交互。上下文聊天机器人是一类只通过内嵌请求进行通信的机器人。它们是上下文相关的，因为它们维护一个上下文，用户只能在预定义的上下文中导航。这些在提供客户服务时特别有用。在本帖中，我们将看看如何使用Python在Telegram中设计这样的机器人。</p><p id="2528" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将由两部分组成。在第一部分中，我们将使用Telegram注册我们的机器人，设置我们的本地编码环境并为机器人编写代码。在第二部分中，我们将讨论如何在Heroku上托管bot，Heroku是一种基于云的服务，对于托管基于web的小型应用程序非常有用。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="49b1" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">用电报注册一个新的机器人</h1><p id="bd75" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">要注册一个新的机器人，请进入手机上的Telegram应用程序，然后按照以下步骤操作。在搜索栏中搜索“僵尸父亲”。“机器人父亲”是一个可以帮助你创建和管理所有机器人的机器人。启动BotFather并键入/help。这显示了这个机器人能够处理的所有可能的命令<br/> 3。键入/newbot或点击列表中的该命令<br/> 4。按照说明设置一个新的机器人，基本上就是为你的机器人选择一个名字和用户名。【提示:选择一个与你的机器人能做什么相关的用户名】<br/> 5。一旦bot成功创建，bot父亲将返回一个令牌来访问HTTP API。请妥善保管这个令牌。我们将使用这个令牌从python脚本中授权我们的bot</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="4c7c" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">设置新的Python虚拟环境</h1><p id="ebbf" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">为python项目创建虚拟环境是一个很好的实践。虚拟环境有助于将不同项目所需的依赖关系分开。虚拟环境还有助于轻松创建一个<em class="kn"> requirements.txt </em>文件，Heroku使用该文件在云中创建python环境。</p><p id="1084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然虚拟环境工具的选择很少，但我们将在我们的项目中使用virtualenv。按照以下步骤使用virtualenv创建一个Python虚拟环境</p><ul class=""><li id="cc58" class="ko kp hi ih b ii ij im in iq kq iu kr iy ks jc kt ku kv kw bi translated">在macOS或Linux中打开您的终端，并创建一个新的项目目录</li></ul><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="1901" class="lg jl hi lc b fi lh li l lj lk">mkdir telegram-bot &amp;&amp; cd telegram-bot</span></pre><ul class=""><li id="de97" class="ko kp hi ih b ii ij im in iq kq iu kr iy ks jc kt ku kv kw bi translated">检查系统中是否安装了virtualenv。如果安装了virtualenv，该命令将返回安装路径，否则不会返回任何内容。如果没有安装，您可以使用此<a class="ae ll" href="https://virtualenv.pypa.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank">链接</a>中提到的方法进行安装</li></ul><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="c87f" class="lg jl hi lc b fi lh li l lj lk">virtualenv --v</span></pre><ul class=""><li id="9af3" class="ko kp hi ih b ii ij im in iq kq iu kr iy ks jc kt ku kv kw bi translated">创建一个新的虚拟环境并激活它</li></ul><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="62d2" class="lg jl hi lc b fi lh li l lj lk">virtualenv venv<br/>source venv/bin/activate</span></pre><p id="4d2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然您可以为您的环境使用任何名称，但是venv是一个常用的约定。环境激活后，继续安装项目所需的python包</p><p id="28dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用这个项目的<a class="ae ll" href="https://github.com/python-telegram-bot/python-telegram-bot" rel="noopener ugc nofollow" target="_blank"><em class="kn">python-telegram-bot</em></a>库。这个库为<a class="ae ll" href="https://core.telegram.org/bots/api" rel="noopener ugc nofollow" target="_blank">电报机器人API </a>提供了一个纯Python接口。要安装该库，请使用以下命令</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="5ef5" class="lg jl hi lc b fi lh li l lj lk">python -m pip install -U python-telegram-bot</span></pre></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="a63e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">在项目文件夹中初始化Git存储库</h1><p id="aeaf" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">需要在项目文件夹中初始化git存储库，因为Heroku使用本地git存储库在他们的云服务中部署代码。虽然Heroku remote通常被添加到本地git存储库来推送提交，但对于这个项目，我们将从Github添加一个remote，并进一步将Github存储库连接到Heroku应用程序。</p><p id="5465" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您的项目文件夹中初始化本地git存储库</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="4791" class="lg jl hi lc b fi lh li l lj lk">git init</span></pre><p id="0e00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另外，创建一个. gitignore文件。的。gitignore file列出了应该在所有提交中忽略的那些文件的名称。我们可以稍后更新该文件</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="e0f7" class="lg jl hi lc b fi lh li l lj lk">touch .gitignore</span></pre><p id="6a73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将在Github中创建一个新的存储库。访问您的Github帐户并创建一个新的存储库。您可以将存储库设为公共或私有。我们将假设您创建的Github存储库的名称与您的项目文件夹相同。创建存储库后，复制它的URL。</p><p id="5ceb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要将本地存储库与新创建的Github存储库连接起来。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="b1ab" class="lg jl hi lc b fi lh li l lj lk">git remote add origin URL-to-your-Github-repository</span></pre><p id="16b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦建立了到远程存储库的连接</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="d588" class="lg jl hi lc b fi lh li l lj lk">git pull origin master</span></pre><p id="7662" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本地存储库现在可以将提交推送到Github存储库了</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="4342" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">编写Python应用程序</h1><p id="b7c1" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">万岁！现在我们终于可以开始为机器人编写Python脚本了。这个机器人将有一个非常简单的设计。有一个非常著名的scikit-learn <a class="ae ll" href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" rel="noopener ugc nofollow" target="_blank">机器学习图</a>可以帮助数据科学家根据数据决定尝试哪种估计器。虽然原始映射对于本教程来说是广泛的，但是我们只修改了分类部分(其他部分是聚类、回归和维度减少)。</p><figure class="kx ky kz la fd ln er es paragraph-image"><div class="er es lm"><img src="../Images/94098aa3c3a53b912445d0acf22b89d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*wE2cx_F_Q1PGbgmJfASAKg.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">分类流程图(<a class="ae ll" href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/tutorial/machine _ learning _ map/index . html</a>)</figcaption></figure><p id="4b35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">鉴于其大小，脚本不可能完全在这里托管。请点击这个<a class="ae ll" href="https://gist.github.com/escapist21/52346423fdeb0b1c49d6ccbb66a9cfe2" rel="noopener ugc nofollow" target="_blank">链接</a>来访问这个代码的Github要点。在您的项目文件夹中创建一个名为<em class="kn"> telegram_bot.py的新文件。</em>在您最喜欢的代码编辑器中打开该文件，并将文件中的代码粘贴到Github链接中。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="7f05" class="lg jl hi lc b fi lh li l lj lk">touch telegram_bot.py</span></pre><h1 id="5000" class="jk jl hi bd jm jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh bi translated">解释代码</h1><p id="cb7e" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">在这里，我们将查看部分代码，并试图理解发生了什么</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="f037" class="lg jl hi lc b fi lh li l lj lk">from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackQueryHandler, ConversationHandler</span><span id="700f" class="lg jl hi lc b fi lz li l lj lk">from telegram import InlineKeyboardButton, InlineKeyboardMarkup<br/>import os</span></pre><p id="0bf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们从python-telegram-bot库中导入必要的类。第一行导入了该程序所需的各种处理程序。你需要阅读这些处理程序是做什么的。第二行导入与创建内联键盘相关的模块。由于这是一个上下文聊天机器人，只有内嵌键盘将用于与机器人通信。</p><figure class="kx ky kz la fd ln er es paragraph-image"><div class="er es ma"><img src="../Images/a2875a82593679b1a70fdff922381e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*ApUS9pOCktYiM4qnXGDLQg.jpeg"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">内置键盘标记的机器人</figcaption></figure><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="e2fc" class="lg jl hi lc b fi lh li l lj lk">#States<br/>FIRST, SECOND = range(2)</span><span id="5ede" class="lg jl hi lc b fi lz li l lj lk">#Callback data<br/>ONE, TWO, THREE, FOUR, FIVE = range(5)</span></pre><p id="7b31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“States”是所有对话步骤的列表，稍后将在设置<em class="kn"> ConversationHandler </em>时使用。“回调数据”是当按下内联键盘时从该键盘返回的回调列表。“状态”和“回调数据”将从各种函数中返回，这些函数将构成我们的对话逻辑。这里我们只是初始化这些变量供以后使用。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="4f32" class="lg jl hi lc b fi lh li l lj lk">def start(update, context):<br/>    fname = update.message.from_user.first_name</span><span id="95c8" class="lg jl hi lc b fi lz li l lj lk">    # Build inline keyboard<br/>    keyboard1 = [InlineKeyboardButton("&lt;100K samples",<br/>                                      callback_data=str(ONE))]<br/>    keyboard2 = [InlineKeyboardButton("&gt;100K samples",<br/>                                      callback_data=str(TWO))]<br/>    <br/>    # create reply keyboard markup<br/>    reply_markup = InlineKeyboardMarkup([keyboard1, keyboard2])</span><span id="6e80" class="lg jl hi lc b fi lz li l lj lk">    # send message with text and appended inline keyboard<br/>    update.message.reply_text(<br/>        "Welcome {}. Let's figure out the best possible classifier for you data.\n\nHow many samples do you have?".format(fname),<br/>        reply_markup=reply_markup<br/>    )<br/>    # tell ConversationHandler that we are in state 'FIRST' now<br/>    return FIRST<br/>.<br/>.<br/>.</span><span id="eddb" class="lg jl hi lc b fi lz li l lj lk">def end(update,context):<br/>    """Returns 'ConversationHandler.END', which tells the CoversationHandler that the conversation is over"""<br/>    query = update.callback_query<br/>    query.answer()<br/>    query.edit_message_text(<br/>        "Goodbye, and all the best\n\nIf you need my help again click on /start"<br/>    )<br/>    return ConversationHandler.END</span></pre><p id="12e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">start()函数是从我们稍后将定义的<em class="kn"> ConversationHandler </em>中调用的第一个函数。它在响应/start命令时被激活。一旦<em class="kn"> ConversationHandler </em>被激活，它就使用从每个函数返回的“状态”和“回调数据”变量来控制对话流。</p><p id="fe27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">start()函数之后是作为对话的一部分调用的其他函数，每个函数都有一个唯一的内联键盘、附加的消息文本并返回“状态”和“回调数据”。参考脚本来研究这些函数。</p><p id="4a56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些函数后面是end()函数。当<em class="kn"> ConversationHandler </em>中的逻辑流到达对话的末尾时，将调用end函数。它返回<em class="kn"> ConversationHandler。END </em>信号，有效终止对话。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="247a" class="lg jl hi lc b fi lh li l lj lk">def main():<br/>    #setting to appropriate values<br/>    TOKEN = "YOUR ACCESS TOKEN"<br/>    # set up updater<br/>    updater = Updater(token=TOKEN, use_context=True)<br/>    # set up dispatcher<br/>    dispatcher = updater.dispatcher<br/>    #print a message to terminal to log successful start<br/>    print("Bot started")</span><span id="5212" class="lg jl hi lc b fi lz li l lj lk">    # Set up ConversationHandler with states FIRST and SECOND<br/>    conv_handler = ConversationHandler(<br/>        entry_points=[CommandHandler(command='start',<br/>                                     callback=start)],<br/>        states={<br/>            FIRST: [CallbackQueryHandler(linear_svc, pattern='^' + str(ONE) + '$'),<br/>                   .<br/>                   .<br/>                   .<br/>                   ],<br/>            SECOND: [CallbackQueryHandler(end, pattern='^' + str(ONE) + '$'),<br/>                   .<br/>                   .<br/>                   .<br/>                   ]<br/>                },<br/>            fallbacks=[CommandHandler(command='start',<br/>                                      callback=start)]<br/>        )</span><span id="4fa8" class="lg jl hi lc b fi lz li l lj lk">    # add ConversationHandler to dispatcher<br/>    dispatcher.add_handler(conv_handler)<br/>    <br/>    # start the bot<br/>    updater.start_polling()</span><span id="9abd" class="lg jl hi lc b fi lz li l lj lk">    # run the bot until Ctrl+C is pressed<br/>    updater.idle()<br/></span></pre><p id="7137" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kn"> Updater </em>类不断从Telegram中获取新的更新，并将其传递给<em class="kn"> Dispatcher </em>类。一旦<em class="kn">更新器</em>对象被创建，它就被用来创建<em class="kn">调度器</em>对象，然后它们在一个队列中被链接在一起。Dispatcher可以注册不同类型的处理程序，然后根据注册的处理程序对从Telegram收到的所有更新进行排序。例如，这里我们向调度程序添加了一个<em class="kn"> ConversationHandler </em>。</p><p id="ef1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kn"> ConversationHandler </em>管理其他处理程序的四个集合。在这个例子中，使用了三个这样的集合，即<em class="kn">入口点</em>、<em class="kn">状态</em>和<em class="kn">回退</em>。</p><p id="a282" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kn">入口点</em>集合是用于发起对话的列表。在本例中，使用了一个<em class="kn"> CommandHandler </em>类来响应“开始”命令。</p><p id="1cce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kn"> states </em>集合是一个包含不同对话步骤和一个或多个相关处理程序的字典。在这个例子中，所有的对话步骤都与<em class="kn"> CallbackQueryHandler </em>相关联，因为应用程序的所有更新都是以与按下内嵌键盘按钮相关联的回调的形式进行的。</p><figure class="kx ky kz la fd ln er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mb"><img src="../Images/b925490c5074a8bb955d6429d39f8977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QaI0w1j1lMeSs8n1MPF6sQ.jpeg"/></div></div></figure><p id="e9ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">左边的流程图用于设计在<em class="kn">状态</em>集合中定义的对话步骤。</p><p id="80cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kn"> fallbacks </em>集合是一个列表，如果当前对话中的用户返回的更新不是预期的类型，则使用该列表。例如，当预期的更新是命令时，将发送文本更新。这可以防止机器人崩溃。</p><p id="5e2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击这个<a class="ae ll" href="https://vimeo.com/405917388" rel="noopener ugc nofollow" target="_blank">链接</a>观看机器人的视频</p><p id="3f1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过键入<code class="du mg mh mi lc b">python telegram_bot.py</code>从终端运行python文件，你的机器人就会活跃起来，准备好与你对话。</p><p id="2589" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是这篇长文的内容。对于本教程的第二部分，点击此<a class="ae ll" rel="noopener" href="/@sourav90.adhikari/designing-a-contextual-chatbot-in-telegram-with-python-github-heroku-part-2-8e444c8a8386">链接</a>。</p></div></div>    
</body>
</html>