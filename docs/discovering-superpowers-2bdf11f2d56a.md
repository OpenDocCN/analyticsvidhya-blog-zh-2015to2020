# 发现超能力

> 原文：<https://medium.com/analytics-vidhya/discovering-superpowers-2bdf11f2d56a?source=collection_archive---------16----------------------->

![](img/463b93e379058c8d46360ad094f275f2.png)

1946 年贝克环礁的十字路口行动

只要你喜欢做一点日常数学，今天的帖子对编码员和非编码员都有一点帮助。是的，在新加坡，我们使用带“s”的数学——如果你愿意的话，这有点殖民主义的味道。

我一直对组合爆炸的概念及其对大‘O’(当然是在计算机科学中)的暗示很着迷。因此，当我着手使用递归构建一系列简短但相关的函数时，我惊讶地发现数学的一部分显而易见，但我从未想过它会轻易压倒组合爆炸，至少在某些情况下。如果你感兴趣，下面的维基百科链接中有更多的背景信息:

[](https://en.wikipedia.org/wiki/Combinatorial_explosion) [## 组合爆炸

### 在数学中，组合爆炸是一个问题复杂性的快速增长，这是由于…

en.wikipedia.org](https://en.wikipedia.org/wiki/Combinatorial_explosion) [](https://en.wikipedia.org/wiki/Big_O_notation) [## 大 O 符号

### 大 O 符号是一种数学符号，它描述了当自变量趋于…

en.wikipedia.org](https://en.wikipedia.org/wiki/Big_O_notation) 

但是，为了更好地理解我们正在做的事情，让我们从最简单的例子——加法——开始，掌握基本原理。我们定义一个递归函数，它接受两个变量 **x** 和 **n** ，其中 x 是操作数(或者你要加的数)，n 是所述操作数在等式中出现的次数。

当使用递归技术定义函数时，基本情况是在下面的第 2 行中，如果 n 是 1，函数将有效地返回操作数 x。我们可以将此视为一种逆向归纳法，当 n 最终达到 1 时，我们从最后一步开始。如果编码者忘记了这一步，这个函数将无限运行，内核很可能会崩溃。

如果 n 不为 1，该函数将返回函数结果的总和(本质上，函数本身与 x 有一个重要的区别)。区别在于，我们使用 n-1 来代替 n，从而确保以有序的方式减少函数，以安全地达到 n == 1，其中第 2 行中的基本情况将确保我们能够最终完成部分完成的函数的堆栈。如果这太难以理解，就想想从一堆梦境中一层一层地抓拍出来，以莱昂纳多·迪卡普里奥主演的电影《T4 盗梦空间》为例。

所以，如果 x 是 2，n 是 5，你实际上是在计算“2+2+2+2+2”，得到 10。

同样的原理也适用于其他常见的运算符——减法、乘法和除法——当 n 和 x 都很小时，答案应该是正常的。

然而，当我们将它应用于幂运算符时，非常有趣的事情发生了，幂运算符在 Python 和 JavaScript 中表示为“**”，在 MS Excel 中表示为'^'.当我测试递归函数时，我知道我应该怀疑出了什么问题——我厚颜无耻地称之为**超级函数**——n 值超过 5，同时保持 x 为 2。另一个有趣的发现是，为了得到正确的答案，我需要交换第 3 行返回的两个术语的位置——如果我知道原因，我会更新这一部分。

也就是说，在我们深入研究超能力功能的奥秘之前，我知道我们当中的编码人员现在会感到非常害怕。你说“为什么要把台词重复五遍”？事实上，函数的全部意义在于避免不必要的代码重复。所以，我能听到雷蒙德·赫廷格在我脑子里说，“我们能做得更好吗？—是的，我们可以！”

所以我开始重构我的代码，使用上面的一个通用函数将五个操作符中的任何一个作为字符串。您可能会注意到代码有点长，因为我添加了一个看门人来确保我们不使用任何无效的操作符——作为一种安全机制。

回到我们的故事。在第 10 行，你可能想知道为什么当操作符是' ** '，x 是 2，n 是 5 时，我没有简单地打印出答案。嗯，那是因为我不能，至少不能以一种整洁的方式。你看，第 12 行测量答案的*位数*。因此，如果答案是 42，输入代码将得到 2。

而看似无关痛痒的**操作(' ** '，2，5)** 的答案呢？一个有着惊人的 19729 位数的数字！相比之下，一个 googol——传说中的谷歌就是以它命名的——只有 101 个数字，或者“1”后面跟着 100 个“0”。

*下面的代码显示了前四个运算符的答案，其中 x 是 2，n 是 5。*