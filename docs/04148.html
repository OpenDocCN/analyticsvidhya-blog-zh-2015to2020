<html>
<head>
<title>Implementing Convolution without for loops in Numpy!!!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Numpy中实现没有for循环的卷积！！！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/implementing-convolution-without-for-loops-in-numpy-ce111322a7cd?source=collection_archive---------0-----------------------#2020-03-07">https://medium.com/analytics-vidhya/implementing-convolution-without-for-loops-in-numpy-ce111322a7cd?source=collection_archive---------0-----------------------#2020-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2733e682714c224a59aa47a87b205c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AEYOfwbJbdiZBkhOTu43Fg.jpeg"/></div></div></figure><h1 id="9599" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="2215" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">使用不同核(3×3，5×5)的卷积来对图像施加效果，即锐化、模糊、轮廓化或浮雕。</p><p id="c5c0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">图像是一串数字，表示为一些宽乘高像素的数组，每个像素与三个范围从0到255的浮点值相关联。这三个数字代表给定像素的红色、绿色和蓝色，这三个数字的组合捕捉到了它的颜色。</p><p id="db4e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果图像是灰度的，每个像素可以使用一个值，0表示黑色，255表示白色。卷积是通过将核放在图片的每个区域前面来获得的，就像滑动窗口一样，然后将我们的核中的值与图片中它重叠的值进行元素乘积，并将其求和，如下所示:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/90e7d71a88e7b19328e3b324707853e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*1VtTe4BuT6un7axHBtHUpw.png"/></div></figure><p id="367f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果我们有一个3通道的常规彩色图像，那么我们的内核也应该有3个通道，如下所示。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/09fb13c3b7558bed8f5c612841156c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*SFspqievtG6yzr1c94lhJQ.png"/></div></figure><p id="7422" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">对于这篇博客，我将主要使用灰度图像，尺寸为[1，1，10，10]，内核尺寸为[1，1，3，3]。</p><h1 id="d78f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">方法</h1><p id="9476" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们不会把卷积编码成一个循环，因为这样效率很低。取而代之的是，我们将对图像进行矢量化处理，这样卷积运算就变成了矩阵乘积。<strong class="jq hj">这意味着取每个感受野窗口，并将数字写在如下所示的</strong>栏中。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/79bbe97b4dc7e160aa7a9d8f36984a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZDopRXVAC2OTNSnq1aAWFg.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">*注意上图只显示了10个感受野列。</figcaption></figure><p id="aa9d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">类似的矢量化也可用于具有3个通道的彩色图像，如下所示。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/f7fa2d1211f5fe8310815d664a74aefd.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*KDnMK7I1GIfU4K2nZTX6-Q.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">彩色图像的矢量化。</figcaption></figure><h1 id="b5f2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">让我们对此进行编码！</h1><p id="f980" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">因此，让我们尝试使用Numpy从头实现卷积层！</p><p id="9fc5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">首先，我们将编写一个类<strong class="jq hj">conv _模块</strong>，它将有基本的代码流，这里正向传递没有实现，反向传递需要定义<strong class="jq hj"> bwd方法</strong>。<br/>其次，我们将使用一个类<strong class="jq hj">卷积</strong>，它继承自Conv模块，然后覆盖正向类，它还包含反向传递所需的<strong class="jq hj"> bwd方法</strong>。</p><pre class="ks kt ku kv fd ld le lf lg aw lh bi"><span id="e793" class="li ir hi le b fi lj lk l ll lm">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="6fdd" class="li ir hi le b fi ln lk l ll lm">img=np.random.rand(1,1,10,10)<br/>ker=np.random.rand(1,1,3,3)</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/f1aef32b80795f28bb0bfd060dbd7ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*Cj5YBuZ8KnMt27s_aE1wBQ.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">输入图像和内核可视化</figcaption></figure><p id="b840" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在<strong class="jq hj"> img上面，ker </strong>表示我们将在实现中使用的映像/内核。命名约定类似于[B，D，H，W],其中B是批量大小，D是通道数或深度，H是高度&amp;, W是宽度。<br/>默认填充和步幅为1，b是偏差，我们将其初始化为0。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated"><strong class="ak">conv _模块</strong></figcaption></figure><p id="66b4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们将使用的numpy的主要功能是<br/>1)NP . repeat()<br/>2)NP . tile()<br/>3)NP . add . at()</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/d798d2412bd18880a20d6f227e98aef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UP2FKnBpUOT1AmDYS4qGkA.png"/></div></div></figure><h1 id="7a76" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">前进传球</h1><p id="546d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了更好的理解，大部分地方都在代码中做了注释。在这篇博客的最后附上代码片段，我会通过代码，但主要是指数计算和向后传递，我觉得这是关键方面。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/2e3ad302d98b9c6b1709fe19faf97ea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*ecCrx-BDljyqc2L_rOcE7g.png"/></div></figure><p id="7dca" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">输出高度(self.out_h)和宽度(self.out_w)将类似于输入高度和宽度，即10，10，因为我们使用相同的填充。使用pad_img在原始图像周围创建填充。</p><p id="c733" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">指标计算</strong></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/fbaa2cab83c4baf1e32b33546f78e0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amD6-OEVn4U_rM4diWs9oQ.png"/></div></div></figure><p id="4a12" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了将感受野储存为载体，需要索引。这里<strong class="jq hj"> i与感受野的第一指标</strong>相关，<strong class="jq hj"> j与感受野的第二指标</strong>相关，<strong class="jq hj"> k为通道尺寸</strong>。self.i计算为i0和i1之和，类似地，self.j计算为j0和j1之和。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/f791979df5f5a64cf49469c5ce953457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lq4xP0VAVs7cSuzhXW5y9Q.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">对应于每个感受野的指数。</figcaption></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/4c4b0959f9426459028ea3145113e8e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*ZKKXOQ-kegtd4EMEuHN0Rg.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">向前传球公式</figcaption></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/85f6d25a8edd5ef6977f780d44bc9562.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*-HzhksyrCQvCezWG_3CduA.png"/></div></figure><p id="4cbd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">使用I、j、k索引，图像以矢量化形式存储，然后乘以权重以获得前向传递(卷积)的输出。下面是正向传递输出的可视化。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/65f4ae55acc23821487588aeda72a2e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*7fBS5j4AfhnCBWOXDEylOw.png"/></div></figure><h1 id="56d7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">偶数道次</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/190d6281551aa4ff2c49afe481483af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*0YZDYGj4NEmNdSzFdnJbNA.png"/></div></figure><p id="5425" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在反向传递期间，需要计算三个梯度:- <br/> a)相对于偏差的梯度。<br/> b)相对于重量的梯度。<br/> c)相对于输入图像的梯度。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/dec4b3504f1bcfef2ca37ce0eef9e26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*tMNq4uFBy2pviU70IVIYxA.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">计算不同参数梯度的公式。</figcaption></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/3c981caa225a0073c57b24a54d7547d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*OUn433lRJMihx8MTkF8rPQ.png"/></div></figure><p id="a3bb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">db是相对于偏差的梯度计算值，dw是相对于权重的梯度计算值，X是相对于输入的梯度计算值。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/7ab0017ceaabe194cea8f54c3f852e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*8t12k1xpMjsFaSeQuUV9eQ.png"/></div></figure><p id="76dc" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">创建维度为[1，1，12，12]的空白零填充，并使用填充有梯度值的索引值。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/9b130a1991932cf64e2eae308d596196.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*0JJvG6rdFZEncBc7scTVOA.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">输入图像的梯度wrt的可视化。</figcaption></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es md"><img src="../Images/49400d60cc9406d50b69286ebbaee0da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*EubJD_jWir_BVVjpeBF3ZQ.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">向前和向后计算花费的时间。</figcaption></figure><p id="cd0a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">正如我们所看到的，向前传递平均需要376 s，向后传递平均需要113 s。整个卷积代码片段如下…</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated"><strong class="ak">卷积类</strong></figcaption></figure></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="cf62" class="iq ir hi bd is it ml iv iw ix mm iz ja jb mn jd je jf mo jh ji jj mp jl jm jn bi translated">结论</h1><p id="4c12" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">因为卷积是任何体系结构的基本块，所以在没有任何for循环的情况下实现它节省了大量计算时间。请<strong class="jq hj">分享，如果你喜欢就留下你的评论</strong>。</p></div></div>    
</body>
</html>