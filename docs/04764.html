<html>
<head>
<title>The Modern Cpp Challenge on Mobile — Greatest commont divisor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代Cpp对手机的挑战——最大公约数</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-modern-cpp-challenge-on-mobile-greatest-commont-divisor-e7558229dcc7?source=collection_archive---------40-----------------------#2020-03-30">https://medium.com/analytics-vidhya/the-modern-cpp-challenge-on-mobile-greatest-commont-divisor-e7558229dcc7?source=collection_archive---------40-----------------------#2020-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8bcccc80dc01826cf6db9fc8c367c1ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MYYB5jHuLo9QfI4o"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@krisroller?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托弗·罗拉</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="ff54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好！我是Xavier Jouvenot，这是关于<a class="ae iu" href="https://amzn.to/2QdYmvA" rel="noopener ugc nofollow" target="_blank">现代C++挑战</a>的系列文章的第二部分。在这篇文章中，我将解释我如何在C++中解决第二个问题，以及我如何在一个Android项目中集成该解决方案。</p><p id="041c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个问题的目标很简单。我们必须计算用户给定的两个正整数的最大公约数，我们打印给用户。该解决方案将在C++中计算，获取用户输入和显示结果的界面将由Android Studio框架处理。</p><p id="fe61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我鼓励你阅读本系列的前一部分<a class="ae iu" href="https://10xlearner.com/2020/03/23/the-modern-c-challenge-on-mobile-the-first-problem/" rel="noopener ugc nofollow" target="_blank">，因为我们将继续我们在其中创建的程序。</a></p><h1 id="6353" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">C++解决方案</h1><p id="1e1a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">实现寻找两个数的最大公约数的算法并不简单…这是标准给出的字面意思！😉事实上，在C++17中，函数<a class="ae iu" href="https://en.cppreference.com/w/cpp/numeric/gcd" rel="noopener ugc nofollow" target="_blank"> std::gcd </a>就是这么做的！</p><p id="7595" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们所要做的，就是包含std中的“header”并使用<a class="ae iu" href="https://en.cppreference.com/w/cpp/numeric/gcd" rel="noopener ugc nofollow" target="_blank"> std::gcd </a>函数。</p><p id="9bc5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您使用的是C++标准的旧版本，那么您必须实现它。如果你想的话，我可以向你推荐这个关于它的<a class="ae iu" href="https://codereview.stackexchange.com/questions/66711/greatest-common-divisor" rel="noopener ugc nofollow" target="_blank">栈交换帖子</a>。🙂</p><h1 id="2558" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Android Studio上的用户界面</h1><p id="45fc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">与解决方案的C++实现不同，用户界面需要做一些工作。事实上，我们希望能够在我们的应用程序中找到第一个问题和第二个问题的解决方案。</p><p id="7a5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了实现这一目标，我们需要做两件事:</p><ul class=""><li id="e6fb" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">添加一个新活动，其中将显示第二个问题并计算解决方案</li><li id="33e9" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">添加按钮，以便能够从第一个问题进入第二个问题。</li></ul><h1 id="1f96" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">针对新问题的新活动</h1><p id="c96d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">要创建新活动，您只需右键单击您的应用程序文件夹架构，然后转到如下所示的<code class="du lk ll lm ln b">Empty Activity</code>:</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/84fced07cba00af5b65bdca4589937a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TKhBrjrQ6uD_tTq6.png"/></div></div></figure><p id="f8f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，指定您的新活动的名称(我将我的活动命名为<code class="du lk ll lm ln b">Problem_2</code>)，并单击<code class="du lk ll lm ln b">Finish</code>创建您的新活动。</p><p id="f648" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧，但具体来说，那是什么意思？首先，如果你打开文件<code class="du lk ll lm ln b">AndroidManifest.xml</code>，你可以看到你的活动已经在这里声明了:</p><pre class="lp lq lr ls fd lt ln lu lv aw lw bi"><span id="ab75" class="lx ju hi ln b fi ly lz l ma mb">&lt;activity android:name=".Problem_2"&gt;&lt;/activity&gt;</span></pre><p id="979f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，如果您查看您的Java文件，那么一定已经创建了一个新文件，其中有一个以您的新活动命名的类。在向用户显示结果之前，我们将在这个类中处理用户输入，并将它们交给C++算法。</p><p id="19e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，在您的资源的子文件夹<code class="du lk ll lm ln b">layout</code>中，您可以看到一个新的xml已经被添加。当用户查看第二个问题时，这个xml将包含我们希望在屏幕上显示的所有元素。</p><p id="6abb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像在<a class="ae iu" href="https://10xlearner.com/2020/03/23/the-modern-c-challenge-on-mobile-the-first-problem/" rel="noopener ugc nofollow" target="_blank">第一个问题</a>中一样，我们所需要的就是<code class="du lk ll lm ln b">EditText</code>和<code class="du lk ll lm ln b">TextView</code>来获取用户输入并向用户显示解决方案，所以如果你还没有阅读过<a class="ae iu" href="https://10xlearner.com/2020/03/23/the-modern-c-challenge-on-mobile-the-first-problem/" rel="noopener ugc nofollow" target="_blank"> it </a>，我鼓励你去阅读一下。</p><h1 id="e747" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">将两项活动联系起来</h1><p id="3a41" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在我们已经为我们的问题创建了新的活动，我们需要能够通过我们的应用程序访问它。最简单的方法是在第一个问题界面上创建一个按钮，转到第二个问题界面。</p><p id="d348" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们首先在第一个活动中添加回调，即按钮将调用的函数。这个函数看起来像这样:</p><pre class="lp lq lr ls fd lt ln lu lv aw lw bi"><span id="27d2" class="lx ju hi ln b fi ly lz l ma mb">public void goToNextProblem(View v) {<br/>  Intent intent = new Intent(this, Problem_2.class);<br/>  startActivity(intent);<br/>}</span></pre><p id="e5d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个函数中，我们创建了一个<code class="du lk ll lm ln b">Intent</code>,并将第二个活动的类提供给它。然后，我们开始这个活动。很简单，不是吗？！🙂</p><p id="a588" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们有了回调，让我们在活动中创建一个按钮，并将其链接到回调。这可以通过将以下元素添加到第一个活动的布局中来实现:</p><pre class="lp lq lr ls fd lt ln lu lv aw lw bi"><span id="2b27" class="lx ju hi ln b fi ly lz l ma mb">&lt;Button android:id="@+id/button"<br/>  android:layout_width="wrap_content"<br/>  android:layout_height="wrap_content"<br/>  android:onClick="goToNextProblem"<br/>  android:text="@string/button_next"<br/>  app:layout_constraintBottom_toBottomOf="parent"<br/>  app:layout_constraintEnd_toEndOf="parent"<br/>  app:layout_constraintHorizontal_bias="0.95"<br/>  app:layout_constraintStart_toStartOf="parent"<br/>  app:layout_constraintTop_toTopOf="parent"<br/>  app:layout_constraintVertical_bias="0.954" /&gt;</span></pre><p id="4e88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里重要的是我们用回调函数的名字设置了字段<code class="du lk ll lm ln b">android:onClick</code>。这样，当用户点击按钮时，就会触发我们的功能。</p><p id="904c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在第二个活动中做同样的事情，以便能够回到第一个活动。瞧，对于前两个问题，你有了一个合适的用户界面。我们所要做的就是把用户界面和C++算法联系起来。</p><h1 id="98be" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用C++本机代码</h1><p id="9cf7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在这一部分，我们将看看第二个活动的Java类。</p><pre class="lp lq lr ls fd lt ln lu lv aw lw bi"><span id="e56b" class="lx ju hi ln b fi ly lz l ma mb">public native String Gcd(int i, int j);</span><span id="b117" class="lx ju hi ln b fi mc lz l ma mb">private int extractNumberFromEditText(EditText et) {<br/>  assert et.getText().length() != 0 : "The EditText must not be empty";<br/>  return Integer.parseInt(et.getText().toString());<br/>}</span><span id="a66d" class="lx ju hi ln b fi mc lz l ma mb">private void computeAndDisplayResult() {<br/>  EditText et1 = findViewById(R.id.first_input_number);<br/>  EditText et2 = findViewById(R.id.second_input_number);<br/>  int firstNumber = extractNumberFromEditText(et1);<br/>  int secondNumber = extractNumberFromEditText(et2);<br/>  TextView tv = findViewById(R.id.result);<br/>  tv.setText(getString(R.string.result_placeholder, Gcd(firstNumber, secondNumber)));<br/>}</span></pre><p id="b7f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你读过我关于第一个问题的解决方案的<a class="ae iu" href="https://10xlearner.com/2020/03/23/the-modern-c-challenge-on-mobile-the-first-problem/" rel="noopener ugc nofollow" target="_blank">博文，这部分并没有带来新的。首先，我们声明C++库中链接的函数<code class="du lk ll lm ln b">Gcd</code>。然后我们有一个方法来获取用户输入的<code class="du lk ll lm ln b">EditText</code>,我们从用户输入中提取输入，我们获取要显示结果的<code class="du lk ll lm ln b">TextView</code>,我们计算结果并显示它。</a></p><p id="a9a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但与第一个问题不同的是，这段代码是在私有函数中。不在<code class="du lk ll lm ln b">EditText</code>回调中。这是因为一件重要的事情。如果只有一个输入用户，我们就无法计算GCD算法。我们必须确保两个用户输入都被填充。</p><p id="1bf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回调看起来是这样的:</p><pre class="lp lq lr ls fd lt ln lu lv aw lw bi"><span id="0d1a" class="lx ju hi ln b fi ly lz l ma mb">EditText et = findViewById(R.id.first_input_number);<br/>et.addTextChangedListener(new TextWatcher() {<br/>  @Override<br/>  public void beforeTextChanged(CharSequence s, int start, int count, int after) { }</span><span id="f88e" class="lx ju hi ln b fi mc lz l ma mb">  @Override<br/>  public void onTextChanged(CharSequence s, int start, int before, int count) {<br/>    EditText et = findViewById(R.id.second_input_number);<br/>    if(et.getText().length() == 0 || count == 0) { return; }<br/>    computeAndDisplayResult();<br/>  }</span><span id="a863" class="lx ju hi ln b fi mc lz l ma mb">  @Override<br/>  public void afterTextChanged(Editable s) { }<br/>});</span></pre><p id="bdfb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以对于第一个<code class="du lk ll lm ln b">EditText</code>，当文本改变时，我们检查的是新文本不为空(<code class="du lk ll lm ln b">count == 0</code>)以及第二个<code class="du lk ll lm ln b">EditText</code>不为空(<code class="du lk ll lm ln b">et.getText().length() == 0</code>)。如果没有空的，我们调用我们的函数来计算和显示结果。如果一个是空的，我们什么也不做，直接返回。对于第二个<code class="du lk ll lm ln b">EditText</code>，代码是相似的，只有<code class="du lk ll lm ln b">EditText</code>id发生变化。😉</p><h1 id="4ec9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="9738" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">因此，我们现在有一个应用程序可以解决前两个问题<a class="ae iu" href="https://amzn.to/2QdYmvA" rel="noopener ugc nofollow" target="_blank">现代C++挑战</a>并在Android Studio上学习新东西，对于这个问题，这是我的真正目的，因为C++算法已经集成到C++标准中。</p><p id="182d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以注意到，在这篇文章中所写的解决方案，并没有包括制作一个运行程序的所有源代码，而只是解决这个问题的源代码中有趣的部分。如果你想从头到尾看到节目，你可以上我的<a class="ae iu" href="https://github.com/Xav83/TheModernCppChallenge_AndroidStudio/tree/v0.0.2_SecondProblem" rel="noopener ugc nofollow" target="_blank"> GitHub账号</a>，探索完整解决方案，如果你想添加评论或提问，在你看这篇文章的平台上，它也会帮助我提高我的文章质量。</p><p id="9046" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢大家阅读这篇文章，直到我的下一篇文章，有一个精彩的一天😉</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/f9cd9ab08bfddc958672ebc78de0ddd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/0*uewtL1ck-HOsnscx.png"/></div></div></figure><h1 id="6eb1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">有趣的链接</h1><p id="b9e4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">- <a class="ae iu" href="https://amzn.to/2QdYmvA" rel="noopener ugc nofollow" target="_blank">现代C++挑战赛</a> <br/> - <a class="ae iu" href="https://en.cppreference.com/w/cpp/numeric/gcd" rel="noopener ugc nofollow" target="_blank"> std::gcd文档</a>-<a class="ae iu" href="https://github.com/Xav83/TheModernCppChallenge_AndroidStudio/tree/v0.0.2_SecondProblem" rel="noopener ugc nofollow" target="_blank">Github发布</a></p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="502f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ml">原载于2020年3月30日</em><a class="ae iu" href="https://10xlearner.com/2020/03/30/the-modern-cpp-challenge-on-mobile-greatest-commont-divisor/" rel="noopener ugc nofollow" target="_blank"><em class="ml">http://10xlearner.com</em></a><em class="ml">。</em></p></div></div>    
</body>
</html>