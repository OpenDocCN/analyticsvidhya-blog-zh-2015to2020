<html>
<head>
<title>Understanding TOTP : In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 TOTP:用 Python</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-totp-in-python-bbe994606087?source=collection_archive---------3-----------------------#2020-10-16">https://medium.com/analytics-vidhya/understanding-totp-in-python-bbe994606087?source=collection_archive---------3-----------------------#2020-10-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="aea3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解动态口令和基于时间的动态口令，实现以及如何在 Paypal、Whatsapp、脸书、Instagram、Twitter、亚马逊和谷歌等平台上实现。</h2></div><p id="9598" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TOTP 或基于时间的动态口令的使用正在慢慢增加。从<em class="jt">脸书</em>到<em class="jt"> WazirX </em>这样的加密交易平台，所有人都可以选择使用带有<em class="jt">微软/谷歌认证器</em>等应用的 TOTP。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/145216a903495db5da9c5438280546e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7ZQ1MRzx7TCl-fPzxYL-g.png"/></div></div></figure><p id="1ddb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于时间的 OTP 依赖于设备，而不是 sim 卡运营商/电子邮件帐户，如果其他人想要的话，他们可以很容易地访问这些帐户。它们不需要活跃的互联网连接。它们每 30 秒自动更新一次。我喜欢它的一点是，它不像传统的动态口令，不需要服务器在每次更新时计算/存储动态口令。那么这个是怎么算出来的呢？OTP 不是应该随机生成吗？</p><h2 id="09fa" class="kg kh hi bd ki kj kk kl km kn ko kp kq jg kr ks kt jk ku kv kw jo kx ky kz la bi translated">让我们尝试使用传统的 OTP:</h2><pre class="jv jw jx jy fd lb lc ld le aw lf bi"><span id="9046" class="kg kh hi lc b fi lg lh l li lj">import random</span><span id="0aa9" class="kg kh hi lc b fi lk lh l li lj">def OTPgenerator(length) :<br/> OTP = ""<br/> for i in range(length) :<br/>                OTP=OTP+str(random.choice(range(0,9)))<br/> return OTP</span></pre><p id="c51e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是模式为<em class="jt">秒的程序输出:输出</em></p><pre class="jv jw jx jy fd lb lc ld le aw lf bi"><span id="fbef" class="kg kh hi lc b fi lg lh l li lj">0  : 287424<br/>15 : 358754<br/>31 : 380135</span></pre><p id="9db3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的函数将<em class="jt">长度</em>作为参数，并返回一个定义长度的随机数。当用户请求 OTP 时，该功能在服务器中被触发，OTP 被临时存储并通过电子邮件/SMS 发送给用户。当用户输入动态口令时，它将与生成的动态口令进行匹配以进行验证。</p><h2 id="d21f" class="kg kh hi bd ki kj kk kl km kn ko kp kq jg kr ks kt jk ku kv kw jo kx ky kz la bi translated">基于时间的动态口令</h2><p id="8b0f" class="pw-post-body-paragraph ix iy hi iz b ja ll ij jc jd lm im jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">TOTP 顾名思义，考虑时间在它函数中的某个地方，想出一个随机数。分解到最简单的层面，服务器和客户端共享一个密钥，这在谷歌认证器这样的应用程序中是在扫描二维码时完成的。这个密钥和当前时间戳一起被定期处理以生成 OTP。由于客户机和服务器都有密钥，并且是时间同步的，所以服务器和客户机都可以生成 OTP，而无需相互通信。客户端以 30 秒的固定间隔生成 OTP，服务器仅在需要验证输入的 OTP 是否正确时才生成 OTP。这在一定程度上节省了服务器的资源。</p><p id="ca2e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">在 Python 中生成 TOTP 的代码</strong></p><pre class="jv jw jx jy fd lb lc ld le aw lf bi"><span id="e201" class="kg kh hi lc b fi lg lh l li lj">import hmac, base64, struct, hashlib, time</span><span id="ee9d" class="kg kh hi lc b fi lk lh l li lj">def get_hotp_token(secret, intervals_no):<br/>    key = base64.b32decode(secret, True)<br/>    #decoding our key<br/>    msg = struct.pack("&gt;Q", intervals_no)<br/>    #conversions between Python values and C structs represente<br/>    h = hmac.new(key, msg, hashlib.sha1).digest()<br/>    o = o = h[19] &amp; 15<br/>    #Generate a hash using both of these. Hashing algorithm is HMAC<br/>    h = (struct.unpack("&gt;I", h[o:o+4])[0] &amp; 0x7fffffff) % 1000000<br/>    #unpacking<br/>    return h</span><span id="5de6" class="kg kh hi lc b fi lk lh l li lj">def get_totp_token(secret):<br/>    #ensuring to give the same otp for 30 seconds<br/>    x =str(get_hotp_token(secret,intervals_no=int(time.time())//30))<br/>    #adding 0 in the beginning till OTP has 6 digits<br/>    while len(x)!=6:<br/>        x+='0'<br/>    return x</span><span id="2031" class="kg kh hi lc b fi lk lh l li lj">#base64 encoded key<br/>secret = 'MNUGC2DBGBZQ===='<br/>print(get_totp_token(secret))</span></pre><p id="0f61" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"><em class="jt"/></strong><em class="jt">——基于 HMAC 的一次性密码，即每次通话都要更改密码，符合</em> <a class="ae lq" href="http://tools.ietf.org/html/rfc4226" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> RFC4226 </em> </a></p><p id="ba97" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们检查这里的输出:</p><pre class="jv jw jx jy fd lb lc ld le aw lf bi"><span id="cc7a" class="kg kh hi lc b fi lg lh l li lj">0  : 924751<br/>15 : 924751<br/>31 : 975604</span></pre><p id="67c5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出在 30 秒的时间间隔内保持不变。</p><blockquote class="lr ls lt"><p id="187e" class="ix iy jt iz b ja jb ij jc jd je im jf lu jh ji jj lv jl jm jn lw jp jq jr js hb bi translated">Python 库实现 https://pyotp.readthedocs.io/en/latest<a class="ae lq" href="https://pyotp.readthedocs.io/en/latest" rel="noopener ugc nofollow" target="_blank">TOTP</a></p></blockquote><h2 id="c744" class="kg kh hi bd ki kj kk kl km kn ko kp kq jg kr ks kt jk ku kv kw jo kx ky kz la bi translated">结论</h2><p id="836d" class="pw-post-body-paragraph ix iy hi iz b ja ll ij jc jd lm im jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">所以我们看到了托普斯</p><ul class=""><li id="f494" class="lx ly hi iz b ja jb jd je jg lz jk ma jo mb js mc md me mf bi translated">不依赖于运营商/电子邮件。</li><li id="bdda" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mc md me mf bi translated">不需要活跃的互联网连接。</li><li id="6175" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mc md me mf bi translated">每隔固定时间更新一次。</li><li id="5912" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mc md me mf bi translated">仅在验证时要求在服务器端进行计算。</li></ul><p id="2d83" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于 TOTPs 不是随机的，人们总是可以用足够的数据来尝试强力执行这些操作。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h2 id="7355" class="kg kh hi bd ki kj kk kl km kn ko kp kq jg kr ks kt jk ku kv kw jo kx ky kz la bi translated">在不同平台上启用 2FA</h2><p id="d081" class="pw-post-body-paragraph ix iy hi iz b ja ll ij jc jd lm im jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">以下是你如何在 Paypal、Whatsapp、脸书、Instagram、Twitter、亚马逊和谷歌等常见平台上启用双因素认证。</p><p id="7871" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下载谷歌认证器或微软认证器。</p><p id="1726" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> Instagram </strong></p><p id="9f45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">档案&gt;点击右上角的汉堡菜单&gt;“设置”&gt;“安全”。您会发现双因素身份验证的菜单项。</p><p id="7a2b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">脸书</strong></p><p id="26f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">点击右上角的汉堡图标&gt;继续向下滚动到底部，找到“设置&amp;隐私”&gt;“设置”&gt;“安全和登录”，向下滚动到“使用双因素认证”。</p><p id="be2e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">推特</strong></p><p id="679a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae lq" href="https://twitter.com/settings/account" rel="noopener ugc nofollow" target="_blank">在这里</a> &gt;选择“安全”&gt;“双因素授权”</p><p id="2159" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">亚马逊</strong></p><p id="dc34" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过<a class="ae lq" href="https://www.amazon.com/a/settings/approval?ots=1&amp;tag=theverge02-20&amp;ascsubtag=[]vg[e]15536183[r]google.com[t]w[d]D" rel="noopener ugc nofollow" target="_blank">跟随此链接</a>直接导航至页面。</p><p id="5493" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">谷歌</strong></p><p id="4890" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae lq" href="https://www.google.com/landing/2step/" rel="noopener ugc nofollow" target="_blank"> 2FA 登陆页面</a>并设置。</p><p id="e32f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> Whatsapp </strong></p><p id="c492" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">打开 WhatsApp，在右上角的汉堡图标下找到设置菜单。在“帐户”&gt;“两步验证”&gt;“启用”下查找</p><p id="949e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">贝宝</strong></p><p id="b637" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在主摘要页面上，单击齿轮图标并找到安全选项卡。找到名为“两步验证”的部分，然后单击设置链接。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="66aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">参考文献</em></p><p id="1593" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae lq" href="https://stackoverflow.com/questions/8529265/google-authenticator-implementation-in-python" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/8529265/Google-authenticator-implementation-in-python</a></p><p id="ab00" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae lq" href="https://www.theverge.com/2017/6/17/15772142/how-to-set-up-two-factor-authentication" rel="noopener ugc nofollow" target="_blank">https://www . the verge . com/2017/6/17/15772142/how-to-set-up-two-factor-authentic ation</a></p></div></div>    
</body>
</html>