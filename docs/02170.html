<html>
<head>
<title>An Automated Voice Calling Chatbot 📲 (Part 3): How to drive Amazon Lex Bot using an AWS Lambda Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个自动语音呼叫聊天机器人📲(第3部分):如何使用AWS Lambda函数驱动Amazon Lex Bot</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/an-automated-voice-calling-chatbot-part-3-how-to-drive-amazon-lex-bot-using-an-aws-lambda-59273c17e82d?source=collection_archive---------4-----------------------#2019-12-04">https://medium.com/analytics-vidhya/an-automated-voice-calling-chatbot-part-3-how-to-drive-amazon-lex-bot-using-an-aws-lambda-59273c17e82d?source=collection_archive---------4-----------------------#2019-12-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/035e7cacd8c6f83173fc19c0ba00a268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ko1HLBYpEVGnqNWm5POPTw.png"/></div></div></figure><p id="8475" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇博客是系列博客的继续，在这些博客中，我描述了我如何通过语音呼叫实现聊天机器人来自动化单调的呼叫。你可以在这里找到<a class="ae jo" rel="noopener" href="/@abhi3072/an-automated-voice-calling-bot-using-amazon-lex-amazon-connect-amazon-polly-and-aws-lambda-1b72bf1e8f71"><strong class="is hj"><em class="jp"/></strong></a>的完整实现概述。</p><p id="4be7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将详细说明我如何使用一个<strong class="is hj"> AWS Lambda </strong>函数来驱动我的聊天机器人中的对话流，该聊天机器人使用<strong class="is hj"> Amazon Lex构建。</strong></p><h1 id="8de9" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">为什么需要使用自定义逻辑来驱动lex聊天机器人？😐</h1><p id="fdf5" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">如果聊天机器人是个性化的，并为用户提供相关的上下文，那么它会更有效，使用Amazon Lex实现开箱即用将意味着您将错过每个用户的个性化位，因为在执行槽填充操作时，您只能针对每个槽配置通用话语。这就是自定义逻辑派上用场的地方，因为使用它，您可以通过利用根据每个用户的上下文解析的占位符属性，轻松地将用户的上下文个性化并嵌入到聊天机器人中。</p><p id="b79f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了自定义逻辑带来的个性化方面，我使用它的整个灵感是制作一个更通用的个性化聊天机器人框架，它可以在各种用例中重用，而无需对Amazon Lex Bot或驱动它的自定义逻辑进行任何修改。这有助于避免为每个用例创建一个独特的Amazon Lex Bot和AWS Lambda对，因为您可以很好地利用单个对。</p><h1 id="19f6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">好吧！我知道为什么需要定制逻辑，但是我如何将它与我的Amazon Lex Bot集成在一起？😕</h1><p id="07cf" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">嗯，这很简单，amazon lex bot中的每个intent都有两个Lambda挂钩，一个执行<strong class="is hj">初始化和验证</strong>，另一个执行intent的<strong class="is hj">实现</strong>动作。</p><h2 id="f592" class="kt jr hi bd js ku kv kw jw kx ky kz ka jb la lb ke jf lc ld ki jj le lf km lg bi translated">这两个挂钩有什么不同？</h2><p id="48c4" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">不同之处在于当这些钩子被执行时，一个<strong class="is hj">初始化和验证</strong>钩子随着每个用户响应被执行，而<strong class="is hj">实现</strong>钩子仅在一个意图被实现并且一个后实现动作被执行之后被执行。</p><h2 id="87be" class="kt jr hi bd js ku kv kw jw kx ky kz ka jb la lb ke jf lc ld ki jj le lf km lg bi translated">那么，哪一个是驱动我们的定制逻辑的更好的选择呢？</h2><p id="2566" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">由于每个用户响应都要调用定制逻辑，这意味着我们应该使用<strong class="is hj">初始化和验证</strong> lambda钩子来驱动我们的Amazon Lex Bot定制逻辑。</p><h2 id="eb46" class="kt jr hi bd js ku kv kw jw kx ky kz ka jb la lb ke jf lc ld ki jj le lf km lg bi translated">我们如何在Lambda函数中接收请求？</h2><p id="32b6" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">该请求以Amazon Lex指定的JSON格式作为Lambda事件接收。格式如下所示。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="0773" class="kt jr hi lm b fi lq lr l ls lt">{<br/>  "messageVersion": "1.0",<br/>  "invocationSource": "DialogCodeHook",<br/>  "userId": "user_id",<br/>  "sessionAttributes": {<br/>    "attribute1" : "attribute_value_1"<br/>    "attribute2" : "attribute_value_2"<br/>    "attribute3" : "attribute_value_3"<br/>  },<br/>  "bot": {<br/>    "name": "BotName",<br/>    "alias": "$LATEST",<br/>    "version": "$LATEST"<br/>  },<br/>  "outputDialogMode": "Speech",<br/>  "currentIntent": {<br/>    "name": "IntentName",<br/>    "slots": {<br/>      "slot1" : "slot_value_1"<br/>      "slot2" : "slot_value_2"<br/>      "slot3" : "slot_value_3"<br/>    },<br/>    "confirmationStatus": "None"<br/>  }<br/>}</span></pre><p id="fc5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你在上面看到的，请求有3个主要部分，<strong class="is hj">会话属性</strong>、<strong class="is hj">当前意图元数据</strong>和<strong class="is hj">用户元数据</strong>。这些共同构成了Amazon Lex Bot的对话上下文</p><h2 id="c596" class="kt jr hi bd js ku kv kw jw kx ky kz ka jb la lb ke jf lc ld ki jj le lf km lg bi translated">我们现在如何从Lambda响应来指示机器人必须执行某个动作？</h2><p id="54ac" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">这里的想法是以Amazon Lex能够理解的格式返回一个响应，我们基本上有两个动作需要从我们的自定义逻辑中执行，这两个动作表示Amazon Lex。</p><ol class=""><li id="ae65" class="lu lv hi is b it iu ix iy jb lw jf lx jj ly jn lz ma mb mc bi translated">请亚马逊Lex引出一个特定的槽。</li><li id="c8c1" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">请Amazon Lex将意向标记为已实现。</li></ol><p id="5d0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这两个动作都可以通过返回Amazon Lex定义的特定响应结构来实现。响应以JSON的形式发送回来，结构如下。</p><p id="4018" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要引出特定的槽:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="46cb" class="kt jr hi lm b fi lq lr l ls lt">{<br/> "sessionAttributes": {<br/> "attribute1" : "attribute_value_1"<br/> "attribute2" : "attribute_value_2"<br/> "attribute3" : "attribute_value_3"<br/> },<br/> "dialogAction": {<br/> "type": "ElicitSlot",<br/> "intentName": "intent_name",<br/> "slots": {<br/> "slot1" : "slot_value_1"<br/> "slot2" : "slot_value_2"<br/> "slot3" : "slot_value_3"<br/> },<br/> "slotToElicit": "slot_to_elicit",<br/> "message": "message",<br/> "responseCard": null<br/>}<br/>}</span></pre><p id="67e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实现一个意图:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="c58f" class="kt jr hi lm b fi lq lr l ls lt">{<br/> "sessionAttributes": {<br/> "attribute1" : "attribute_value_1"<br/> "attribute2" : "attribute_value_2"<br/> "attribute3" : "attribute_value_3"<br/>}<br/>"dialogAction": {<br/>    "type": "Close",<br/>    "fulfillmentState": "Fulfilled",<br/>    "message": "message"<br/>}<br/>}</span></pre><h1 id="b350" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">好吧！我现在明白了如何将我们的定制逻辑与Amazon Lex集成在一起，但是你不是也提到了你编写的定制逻辑是通用的吗？😮</h1><p id="0d3b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">是的，为此我创建了一个小框架，可以处理多种用例。我基本上是通过实现一个对话树来实现这一点的，该对话树将根据当前用户上下文和用户响应来决定要引出的下一个响应和要执行的动作。</p><p id="f5e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个想法基本上是有一个会话节点树，它将基于用户的当前上下文和用户在最近的响应中填充的槽来遍历。</p><p id="5d33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个会话节点将由以下属性组成:</p><ol class=""><li id="d93b" class="lu lv hi is b it iu ix iy jb lw jf lx jj ly jn lz ma mb mc bi translated">当前插槽的提示</li><li id="1a40" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">失败提示</li><li id="f3bc" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">触发动作</li><li id="664b" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">插槽值和子会话节点之间的映射</li><li id="bb76" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">要引出的插槽的名称</li></ol><p id="57c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的想法是，当到达时，每个会话节点将执行一个<strong class="is hj">触发动作</strong>，并基于为该会话节点中的当前槽定义的<strong class="is hj">提示</strong>请求引出一个<strong class="is hj">槽</strong>。定义的提示包含在一个&lt; speak/ &gt;标签中，这样我们就可以使用SSML来配置<strong class="is hj"> Amazon Polly </strong>合成这些提示。</p><p id="4c53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当用户响应该会话节点时，将填充一个<strong class="is hj">槽值</strong>，然后基于该槽值遍历下一个会话节点。该槽中的每个槽值将对应于由当前会话节点持有的槽值到子节点的<strong class="is hj">映射中指定的子会话节点。</strong></p><p id="7118" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，通过将每个对话表示为一个对话树，就可以概括出驱动聊天机器人的逻辑。</p><p id="23e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要检查会话树的实现以及一些示例会话树配置，请越过<a class="ae jo" href="https://github.com/abhinavrohatgi30/an-automated-voice-calling-chatbot/tree/master/lambda/bot/chatbot-configs" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="jp">这里</em> </strong> </a>。</p><h1 id="7eea" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">酷！但是你也说过你可以个性化聊天机器人，你是怎么做到的？😮</h1><p id="b8c9" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">是的，正如我之前提到的，个性化可以通过在会话树的每个节点的话语/提示中添加占位符属性来实现，这些属性可以在运行时使用用户的上下文来解析。</p><p id="a1c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我通过使用DynamoDB数据库实现了这一点，在调用用户之前，我将特定于用户的元数据存储在数据库中，在运行时，我编写的框架会缓慢地获取元数据并个性化我的话语/提示。</p><p id="135c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在存储库<a class="ae jo" href="https://github.com/abhinavrohatgi30/an-automated-voice-calling-chatbot/tree/master/lambda/bot/chatbot-configs" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="jp">这里</em> </strong> </a>中的对话树配置示例中找到这个。</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="abdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦您实现了上述AWS Lambda函数，您现在就有了一个可用于驱动Amazon Lex Bot的自定义逻辑，在本系列的下一部分中，我们将了解如何将这个Amazon Lex Bot与Amazon Connect实例集成，以向用户发出出站呼叫并处理来自用户的入站呼叫！</p><p id="2fd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">敬请期待，并提供一个<strong class="is hj"> <em class="jp">鼓掌</em>👏如果你喜欢这个博客！</strong></p><p id="0af8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" rel="noopener" href="/@abhi3072/an-automated-voice-calling-bot-using-amazon-lex-amazon-connect-amazon-polly-and-aws-lambda-1b72bf1e8f71">第1部分:用例及架构的简要概述</a></p><p id="6edc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" rel="noopener" href="/@abhi3072/an-automated-voice-calling-chatbot-part-2-how-to-create-the-chatbot-in-amazon-lex-ba4a2907e537">第2部分:如何创建Amazon Lex Bot </a></p><p id="4e2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" rel="noopener" href="/@abhi3072/an-automated-voice-calling-chatbot-part-4-using-amazon-connect-with-amazon-lex-bfe5f680dbb9">第4部分:使用Amazon Connect和Amazon Lex </a></p></div></div>    
</body>
</html>