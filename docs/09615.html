<html>
<head>
<title>Algorithms In Context #3: Huffman Codes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上下文#3中的算法:霍夫曼码</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/algorithms-revisited-part-3-huffman-codes-7a60eca91d3b?source=collection_archive---------13-----------------------#2020-09-13">https://medium.com/analytics-vidhya/algorithms-revisited-part-3-huffman-codes-7a60eca91d3b?source=collection_archive---------13-----------------------#2020-09-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="a2de" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">你有没有想过像WinRAR或WinZip这样的数据压缩程序是如何工作的？你有没有问过自己，如果我们可以压缩数据，为什么不首先以那种方式存储和使用它？如果是这样，欢迎阅读本系列的第三章:<strong class="il hj">霍夫曼码。</strong></p></blockquote></div><div class="ab cl jh ji gp jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hb hc hd he hf"><p id="3847" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">所以，我刚刚在<a class="ae jr" href="https://www.hackerrank.com/dashboard" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>解决了我离开近两年后的第200个问题，顺便提一下关于<a class="ae jr" href="https://www.hackerrank.com/challenges/tree-huffman-decoding/problem" rel="noopener ugc nofollow" target="_blank">霍夫曼解码</a>的问题，发现自己写了这个帖子。让我先问一个问题:如何修改你电脑中的数据以减少占用空间？由<strong class="il hj"> </strong>用<strong class="il hj">较少的位来表示相同的数据。</strong></p><p id="20b9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated"><em class="ik">干得好，夏洛克，这是我们想不到的！但是不要太骄傲，因为最简单的想法通常是最有说服力的。考虑一个包含10.000个字符的文本文件。假设你用8位来存储一个字符，那么这个文本将在你的计算机中占据80.000位。但是如果我们能找到一种方法，用更少的比特来存储一个字符，我们就能降低文件的存储需求。</em></p><p id="a835" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated"><strong class="il hj">前缀码</strong></p><p id="b220" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">让我们稍微简化一下约束条件，这样我们就可以进行一些计算了。我们仍然有一个10.000字符长的文本，但我们只有从a到f的6个字母。如果我们对每个字符使用<strong class="il hj">固定长度代码</strong>，我们可以用3位表示6个字母，整个文本将占用30.000位内存。</p><p id="d957" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">正如你所猜测的，还有其他方式来表现人物。我们可以使用<strong class="il hj">变长码</strong>，而不是每个字符使用3位，通过存储的方式，变长码可以显著提高性能。为了实现这一点，我们将遵循两条规则:</p><ul class=""><li id="5e0f" class="js jt hi il b im in iq ir jo ju jp jv jq jw jg jx jy jz ka bi translated">文本中<strong class="il hj">出现频率较高的字符</strong>将用较少的位数表示</li><li id="c0c1" class="js jt hi il b im kb iq kc jo kd jp ke jq kf jg jx jy jz ka bi translated">代表字符的代码字应<strong class="il hj">可明确解码</strong></li></ul><p id="977c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">下面的例子直接摘自麻省理工学院的<a class="ae jr" href="https://www.amazon.com.tr/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844" rel="noopener ugc nofollow" target="_blank">算法简介</a>一书，这是一本令人惊叹的书，强烈建议任何对算法感兴趣的人阅读。在表格中，您可以看到我们文本中每个字母的<strong class="il hj">字母频率</strong>、<strong class="il hj">定长</strong>和<strong class="il hj">变长</strong>表示。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/5b42d1d6b2c985008aab9d72642dd4b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*EQh7QbJBOTKe6zQiwpjCMw.png"/></div></figure><p id="2a0d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">使用<strong class="il hj">可变长度</strong>代码，如果你想写单词“add ”,你需要写<em class="ik"> 0 111 111 </em>,这比其对应的<em class="ik"> 000 011 011 </em>的<strong class="il hj">固定长度</strong>少需要2位。让我们计算一下，使用频率和可变长度代码来表示10.000个字符长的文本。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ko"><img src="../Images/96061c90fe89ad90986dfab102a1adf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*TVN2owhHlligxj8zVYKzKA.png"/></div></figure><p id="4cef" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">我们将文本的空间需求从30.000位减少到了22.400位，比%25的改进稍多一点。更高的百分比是可以实现的，但是对于这个例子来说已经足够好了。</p><p id="82f0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated"><strong class="il hj">构造霍夫曼码</strong></p><p id="f8b2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">现在我们来谈谈我们是如何推导出<strong class="il hj">变长</strong>码的。使用<strong class="il hj">明确可解码的</strong>代码非常重要，因为否则，你将无法知道你的算法在解压缩阶段应该产生哪个字符。</p><p id="9931" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">一棵<strong class="il hj">二叉树</strong>将帮助我们导出我们的变长码。在每一步，我们取频率最低的两个字母，将它们合并到一个父节点下，并将它们的总频率分配给它们的父节点(一个<strong class="il hj">优先级队列</strong>可以帮助我们做到这一点)。我们将继续这样做，直到所有的字母合并到一个词根下。这是为我们的文本文件示例构建的最终树(频率以百分比给出<em class="ik">):</em></p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kp"><img src="../Images/a293ec6c00a40197de3461dc87500a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*93WheWIfFhYROGFsAbAv7g.png"/></div></figure><p id="eb0e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">一旦树被构建，你需要做的就是跟随边上的<strong class="il hj">位来获取一个字母的相应变长码</strong>。这样，我们获得了一个<strong class="il hj">明确的</strong>策略来解码每个字母，因为每个字母只有一条路径。</p><blockquote class="if ig ih"><p id="032a" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这里有一件额外的事情需要注意:因为我们对频率最高的字母使用最少的位数，这是一个<strong class="il hj">贪婪算法</strong>。你可以在我的上一篇文章中阅读更多关于贪婪算法的内容。</p></blockquote></div><div class="ab cl jh ji gp jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hb hc hd he hf"><p id="f28a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">现在让我们写一些代码。压缩文本应该很容易:你需要做的就是用相应的代码替换每个字符。所以，我只分享解压函数，我用来解决我在帖子开头提到的<a class="ae jr" href="https://www.hackerrank.com/challenges/tree-huffman-decoding/problem" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>问题。</p><pre class="kh ki kj kk fd kq kr ks kt aw ku bi"><span id="23be" class="kv kw hi kr b fi kx ky l kz la">void decodeHuffman(HuffmanTreeNode* root, string encoded) {</span><span id="3606" class="kv kw hi kr b fi lb ky l kz la">    HuffmanTreeNode* runner = root;<br/>    for (char current : encoded) {</span><span id="33f8" class="kv kw hi kr b fi lb ky l kz la">        if (current = '0') {<br/>            runner = runner-&gt;left;<br/>        } else {<br/>            runner = runner-&gt;right;<br/>        }</span><span id="ab63" class="kv kw hi kr b fi lb ky l kz la">        if (runner-&gt;isLeaf()) {<br/>            cout &lt;&lt; runner-&gt;data;<br/>            runner = root;<br/>        }<br/>    }<br/>}</span></pre><p id="47de" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">我们遍历编码字符串中的每个字符(可以是“0”或“1”)，并在构造的树中采用相应的路径。每当我们遇到一个<strong class="il hj">叶节点</strong>，就知道找到了一个字母。然后，我们重置指针，并做同样的事情，直到整个文本被解码。</p><p id="4120" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">如此简单的东西却如此有效，这不是很神奇吗？霍夫曼码提供了一种非常简单快速的<strong class="il hj">无损压缩</strong>方法，这启发了更多的压缩算法。</p></div><div class="ab cl jh ji gp jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hb hc hd he hf"><p id="f80b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">如果我们可以对数据进行<strong class="il hj">无损压缩</strong>，那么为什么不总是在我们的计算机中使用压缩数据呢？因为压缩的数据不太容易处理。事实上，如果我们想要处理压缩的数据，我们需要一直做额外的操作，这样效率不会很高。例如，当我们使用<strong class="il hj">固定长度代码</strong>来存储我们的文本时，我们知道每个字母与前一个和后一个字母的距离<strong class="il hj">正好是3位</strong>。使用<strong class="il hj">变长码</strong>时，不先解码能说出下一个字母有多少位吗？当然不是。这就是为什么我们使用固定格式来存储数据，即使它们包含一些冗余。</p><blockquote class="if ig ih"><p id="81fc" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">今天就到此为止，剩下的时间我会听铁娘子。我希望这篇短文能给你启发，下一节再见。</p></blockquote></div></div>    
</body>
</html>