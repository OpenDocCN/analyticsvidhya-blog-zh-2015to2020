<html>
<head>
<title>Faking Redis/PostgreSQL connections while testing with Pytest in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中用Pytest测试时伪造Redis/PostgreSQL连接</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/faking-redis-postgresql-connections-while-testing-with-pytest-in-python-727d9b9660f7?source=collection_archive---------10-----------------------#2020-01-02">https://medium.com/analytics-vidhya/faking-redis-postgresql-connections-while-testing-with-pytest-in-python-727d9b9660f7?source=collection_archive---------10-----------------------#2020-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="20bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最近不得不为使用Redis和PostgreSQL数据库存储数据的函数编写一些Python单元测试。为了实现这一点，我必须学习如何使用Pytest和能够伪造数据库连接的包。由于缺乏良好的文档和有用的在线示例，后者被证明是特别具有挑战性的。我花了很多时间谷歌，弄清楚如何在测试中建立这些虚假的联系，并建立了一个测试框架。因此，我想分享我所做的，来帮助其他想写类似测试的人节省时间。我将首先做一个假Redis连接的例子，然后看一个假PostgreSQL连接的例子。我将假设对Pytest(我是从这篇有用的文章<a class="ae jd" rel="noopener" href="/testcult/intro-to-test-framework-pytest-5b1ce4d011ae">https://medium . com/test cult/intro-to-test-framework-Pytest-5b 1 ce 4d 011 AE</a>)和Redis/PostgreSQL数据库有所了解。关于包括测试文件在内的所有代码，请参见<a class="ae jd" href="https://github.com/paluchasz/Pytest-testing" rel="noopener ugc nofollow" target="_blank">https://github.com/paluchasz/Pytest-testing</a>。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="c3c1" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">Redis示例</h1><p id="32e1" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">对于Redis示例，假设我们想要测试一个对某些Redis键的值求和的函数。这种函数的一个简单例子是</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c59f" class="kx jm hi kt b fi ky kz l la lb">def sum_redis_key_values(rc, key_format):<br/>    total = 0<br/>    for redis_key in rc.scan_iter(key_format.format(i="*")):<br/>        total += int(rc.get(redis_key))<br/>    return total</span></pre><p id="09f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我选择的键是:<em class="lc"> key:0，key:1，key:2，key:3 </em> (so <code class="du ld le lf kt b">key_format = “key:{i}"</code>)，它们的值是整数。</p><p id="99b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们想要测试三个不同测试用例的功能，并给出每个测试用例的通过/失败。这可以通过使用Pytest的parametrize decorator和一个返回元组列表的函数轻松实现。例如，将下面的代码放在一个文件中(测试Python的sum()方法)并运行<em class="lc">$ Python 3-m pytest filename . py-v</em></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="03b7" class="kx jm hi kt b fi ky kz l la lb">import pytest</span><span id="d076" class="kx jm hi kt b fi lg kz l la lb">def get_sum_test_data():<br/>    return [([3, -2, 6, -8], -1), ([20, 0, -30, 40], 30), ([2, 4, 1, 5], 12)]<br/><br/><br/>@pytest.mark.parametrize('nums, result', get_sum_test_data())<br/>def test_sum(nums, result):<br/>    assert sum(nums) == result</span></pre><p id="8446" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将产生三个PASS语句，每个测试用例一个。将数字30改为其他数字将导致通过/失败/通过。</p><p id="a161" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了真正伪造一个Redis连接，我使用了<a class="ae jd" href="https://pypi.org/project/birdisle/" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> birdisle </em> </a>包(<em class="lc"> 02/2021更新</em>:如果你使用的是Mac OS，我建议使用<a class="ae jd" href="https://pypi.org/project/redislite/" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> redislite </em> </a>包来代替，参见文章末尾的解释)。从文档中</p><blockquote class="lh li lj"><p id="b3a1" class="if ig lc ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">bird isle(“lib redis”的变位词)是redis的一个修改版本，它作为一个库在另一个进程中运行。主要目的是简化单元测试，提供一种在redis服务器上运行测试的方法，而不需要启动一个单独的进程并确保它被正确拆除。”</p></blockquote><p id="923d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用它，可以简单地做以下事情</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="288a" class="kx jm hi kt b fi ky kz l la lb">from birdisle import redis</span><span id="399d" class="kx jm hi kt b fi lg kz l la lb">rc = redis.StrictRedis(decode_responses=True)</span></pre><p id="3dc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常情况下，如果要连接到本地Redis数据库，您需要传入<code class="du ld le lf kt b">host = "localhost”</code>和<code class="du ld le lf kt b">port = 6379</code>。如果您将这个连接对象<code class="du ld le lf kt b">rc</code>与您从标准Redis包中获得的对象进行比较，您可以看到这个对象与<em class="lc"> LocalSocketConnection </em>略有不同。现在，您可以使用标准<em class="lc"> redis </em>包中的任何Redis命令。我喜欢保存一个全局<code class="du ld le lf kt b">rc</code> (redis client)变量，这样就可以在文件中的任何地方轻松地访问连接。</p><p id="7e63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要另外两个函数。在每个测试用例之后，一个创建数据，一个清除假Redis连接中的数据。您可以自己检查新的键实际上没有添加到本地Redis中。下面是完整的测试文件。</p><figure class="ko kp kq kr fd ln"><div class="bz dy l di"><div class="lo lp l"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">使用假Redis连接的完整测试文件</figcaption></figure><p id="0fcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们总结一下它的作用。当您运行<em class="lc">$ python 3-m pytest test _作伪_redis.py -v </em>时:</p><ul class=""><li id="26e1" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated">Pytest首先识别文件中哪些函数的名称以单词“test”开头或结尾。在我们的例子中，我们只有一个这样的函数叫做<code class="du ld le lf kt b">test_sum_keys()</code>。</li><li id="d3f6" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">然后从Pytest的参数化装饰器调用<code class="du ld le lf kt b">load_data_and_connect()</code>函数。</li><li id="1c36" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">在它内部，如果一个Redis连接还不存在的话，就会建立一个假的Redis连接。</li><li id="ff67" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">所有数据都被加载并转换成一个元组列表，如前面显示的Pytest示例所示。(因为我只使用了三个测试用例，所以我将每个测试用例存储在一个单独的json文件中，但是可能有更好的方法来做到这一点)。</li><li id="3b8e" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">一旦这个函数被执行，Pytest就依次运行每个元组的测试函数，作为每个测试用例的输入。</li><li id="7aa1" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">对于每个测试用例，创建假Redis数据，执行我们正在测试的函数<code class="du ld le lf kt b">sum_redis_key_values()</code>，清除Redis数据，并断言总和是否等于预期结果。</li><li id="22fc" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">Pytest记录断言的通过/失败，并继续下一个测试用例。</li></ul></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="1d64" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">PostgreSQL示例</h1><p id="6469" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">伪造PostgreSQL连接比预期的更具挑战性。首先，提醒一下如何在Python中连接和使用psql。我使用的包是<em class="lc"> PyGreSQL </em>。要建立连接，我们可以执行以下操作</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="cd6f" class="kx jm hi kt b fi ky kz l la lb">import pgdb</span><span id="04e8" class="kx jm hi kt b fi lg kz l la lb">CONNECTION = pgdb.connect(user=info['user'], host=info['host'], database=info['database'], port=info['port'])</span></pre><p id="3543" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<code class="du ld le lf kt b">info </code>是要指定的字典，可以从配置文件中加载。(注意，我认为还有另一个pgdb Python包，因此您需要安装正确的包，否则您可能会得到类似“pgdb没有连接方法”的错误)</p><p id="f1df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了查询数据库，我们可以这样做</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8a3c" class="kx jm hi kt b fi ky kz l la lb">cursor = CONNECTION.cursor()    <br/>records = cursor.execute("""SELECT age FROM students""").fetchall()<br/>cursor.close()</span></pre><p id="8162" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了创建一个假的psql连接，我使用了<em class="lc"> testing.postgresql </em>包(<a class="ae jd" href="https://pypi.org/project/testing.postgresql/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/testing.postgresql/</a>)。注意，这个包需要安装一个本地PostgresSQL数据库(与birdisle包相反，我认为它不需要Redis数据库)。该包提供了一个假的数据库/用户/主机/端口，可用于与PyGreSQL包建立假连接，如下所示</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0035" class="kx jm hi kt b fi ky kz l la lb">import pgdb<br/>import testing.postgresql</span><span id="dd9a" class="kx jm hi kt b fi lg kz l la lb">psql = testing.postgresql.Postgresql()<br/>info = psql.dsn()<br/>CONNECTION = pgdb.connect(user=info['user'], host=info['host'], database=info['database'], port=info['port'])</span></pre><p id="9d0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，假设我们要测试一个函数，该函数对psql中“学生”关系(表)中所有学生的年龄求和。该函数可能类似于</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="826d" class="kx jm hi kt b fi ky kz l la lb">def sum_ages():<br/>    records = query_database(operation="""SELECT age FROM students""")<br/>    ages = [r.age for r in records]<br/>    return sum(ages)</span></pre><p id="7b66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<code class="du ld le lf kt b">query_database()</code>是另一个函数，它执行前面显示的所有光标操作。</p><p id="9f4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了在伪psql数据库中创建学生关系,<em class="lc"> Pandas </em>包非常有用。它有一个方便的<code class="du ld le lf kt b">to_sql()</code>方法，可以将Pandas数据帧转换成psql关系。它需要传递一个引擎对象，告诉Pandas要插入哪个psql数据库。为了获得这个对象，我们需要使用另一个名为<em class="lc"> sqlalchemy </em> <strong class="ih hj"> <em class="lc">的包。</em> </strong>将制作学生表格所需的数据保存为csv文件是有意义的，这样就可以用<code class="du ld le lf kt b">read_csv()</code>方法轻松地将其加载到Pandas dataframe中。把这些放在一起，我们需要做一些事情</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="7418" class="kx jm hi kt b fi ky kz l la lb">import testing.postgresql<br/>import pandas as pd<br/>from sqlalchemy import create_engine</span><span id="c6d6" class="kx jm hi kt b fi lg kz l la lb">psql = testing.postgresql.Postgresql()<br/>engine = create_engine(psql.url())</span><span id="1a12" class="kx jm hi kt b fi lg kz l la lb">students_df = pd.read_csv(file)<br/>students_df.to_sql('students', engine, if_exists='replace')</span></pre><p id="e8a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ld le lf kt b">if_exists = “replace"</code>告诉熊猫替换同名的现有关系。还有其他有用的东西可以传递给<code class="du ld le lf kt b">to_sql() </code>方法，比如<code class="du ld le lf kt b">dtype </code>，它指定列的数据类型。</p><p id="64cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在处理psql连接时，我们需要在每个测试用例之后回滚连接(回滚用于撤销事务，似乎比试图清除数据库更容易——我也遇到过一些没有这样做的问题),并在最后一个测试用例之后关闭连接。因此，我们还需要跟踪总的测试用例以及测试用例id。下面是完整的测试文件</p><figure class="ko kp kq kr fd ln"><div class="bz dy l di"><div class="lo lp l"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">使用假PostgreSQL连接的完整测试文件</figcaption></figure><p id="f820" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们需要做的事情与Redis示例略有不同，并在每个测试函数中伪造连接，而不是在parametrize decorator中调用的<code class="du ld le lf kt b">load()</code>函数。旧的方法在这里仍然有效，但是如果我们在这个文件中有多个使用相同参数化的测试函数，问题就出现了。如果有多个函数，Pytest首先定位所有函数，并在运行所有测试之前依次执行每个参数化装饰器。因此，每次调用load函数时，我们的连接对象都会被覆盖。(我是在一次运行多个测试文件的Pytest时发现这个问题的；他们是单独经过，而不是一起经过！)</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="aabf" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">排除故障</h1><p id="055e" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">Pytest中有一些使用<code class="du ld le lf kt b">set_trace()</code>方法的调试(<a class="ae jd" href="https://qxf2.com/blog/debugging-in-python-using-pytest-set_trace/" rel="noopener ugc nofollow" target="_blank">https://qxf 2 . com/blog/debugging-in-python-using-py test-set _ trace/</a>)但是我没有发现它特别有用。但是，如果您使用PyCharm，您可以设置一个非常有用的运行/调试Pytest配置，让您运行Pytest并逐行检查代码。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="e45e" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">制作测试框架</h1><p id="1f67" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">首先，我将所有伪造的数据库连接功能转移到一个单独的共享文件中。然后我制作了一个类装饰器，它将处理每个测试的所有连接，以避免测试函数中的重复代码。由于装饰器必须包装测试函数，assert语句成了一个问题，因为如果断言失败，就不会执行其他代码，因此装饰器中的连接不会关闭。幸运的是，Pytest有一个额外的包叫做<em class="lc"> pytest_check </em>，可以如下使用</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="51c5" class="kx jm hi kt b fi ky kz l la lb">import pytest_check as check</span><span id="8c7a" class="kx jm hi kt b fi lg kz l la lb">check.equal(a, b)</span></pre><p id="b49c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这相当于断言a等于b，但它允许程序继续运行。因此，您甚至可以在每个测试函数中进行多次检查。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="b445" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">更新</h1><p id="96e4" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated"><strong class="ih hj"> 02/2021: </strong>后来我发现用来伪造Redis连接的<em class="lc"> birdisle </em>包有一个很大的缺点。如果您在Mac OS上工作，它将无法安装，测试也无法运行。一个痛苦的解决方法是拥有一个Linux虚拟机，并跨其同步您的文件。不过我后来发现有一个替代包叫<a class="ae jd" href="https://pypi.org/project/redislite/" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> redislite </em> </a>也一样好用。如果你想伪造一个连接，你只需要做</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="167c" class="kx jm hi kt b fi ky kz l la lb">from redislite import StrictRedis</span><span id="dfc3" class="kx jm hi kt b fi lg kz l la lb">rc = StrictRedis(decode_responses=True)</span></pre><p id="2b96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且应该支持<em class="lc"> redis </em>包的所有命令。</p><h1 id="d426" class="jl jm hi bd jn jo mi jq jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki bi translated">摘要</h1><p id="5519" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我希望这篇文章对您有用，如果您发现自己处于相同的位置，并且需要使用相同的软件包，它将为您节省一些时间。如果任何人对可以做得更好/更容易有任何问题或建议，请留下评论。</p></div></div>    
</body>
</html>