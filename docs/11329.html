<html>
<head>
<title>Recursion /Tail Recursion in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的递归/尾递归</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/recursion-tail-recursion-in-scala-8e86a9497514?source=collection_archive---------12-----------------------#2020-11-29">https://medium.com/analytics-vidhya/recursion-tail-recursion-in-scala-8e86a9497514?source=collection_archive---------12-----------------------#2020-11-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ddf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与其他语言相比，Scala有一些高级特性，包括对尾部递归的支持。但是让我们先看看它的意思，以及为什么它有助于构建递归算法。</p><p id="6fe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">在编程世界里，ecursion相当普遍。你可能知道，这是通过将问题分解成更小的子问题来解决问题的过程。如果您看到一个方法用较小的输入子集调用自己，您可以很容易地发现递归。</p><p id="ff60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">试试下面的程序，这是一个很好的递归例子，其中计算传递数的阶乘。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="c88e" class="jv jw hi jr b fi jx jy l jz ka">object Demo {<br/>   def main(args: Array[String]) {<br/>      for (i &lt;- 1 to 10)<br/>         println( "Factorial of " + i + ": = " + factorial(i) )<br/>   }<br/>   <br/>   def factorial(n: BigInt): BigInt = {  <br/>      if (n &lt;= 1)<br/>         1  <br/>      else    <br/>      n * factorial(n - 1)<br/>   }<br/>}</span></pre><h1 id="fc1c" class="kb jw hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">尾部递归概述:-</h1><p id="baf3" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">尾部递归是一个子程序(函数，方法)，其中最后一条语句被递归执行。简单来说，函数中的最后一条语句多次调用自己。</p><p id="2327" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些函数更加高效，因为它们利用了尾部调用优化。它们只是继续调用一个函数(函数本身)，而不是在内存中添加一个新的堆栈帧。</p><p id="42ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尾部递归函数应该通过它们的参数传递当前迭代的状态。它们是不可变的(它们将值作为参数传递，而不是将值重新赋给相同的变量)。</p><p id="8f10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Scala中的尾部调用优化:- </strong></p><p id="f4c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Scala通过执行尾部调用优化来支持尾部递归函数。它还有一个特殊的注释，<a class="ae ld" href="http://twitter.com/tailrec" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> @tailrec </strong> </a> <strong class="ih hj">，</strong>来保证方法可以以尾部递归的方式执行，否则编译器产生错误。</p><p id="bdae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">写尾递归函数有什么要求？</strong></p><p id="ae49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1-必须有一个退出条件:如果没有这个条件，函数将在一个永无止境的循环中结束，这肯定不是任何迭代计算的目标。退出条件可以通过使用条件来实现，当条件满足时，函数返回值，否则它继续用不同的属性值集合调用自己。</p><p id="a2f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2 -尾部递归函数必须能够调用自身:如果在第一次迭代中满足退出条件，这可能不会发生，但是对于任何后续调用，所有参数都必须传递给函数本身。</p><p id="ffbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3-在编写tail递归程序之前，需要导入tailrec注释。</p><h2 id="6ca3" class="jv jw hi bd kc le lf lg kg lh li lj kk iq lk ll ko iu lm ln ks iy lo lp kw lq bi translated">下面是Scala中尾部递归函数的一个例子:</h2><blockquote class="lr ls lt"><p id="ade7" class="if ig lu ih b ii ij ik il im in io ip lv ir is it lw iv iw ix lx iz ja jb jc hb bi translated">def factorial(n:BigInt):BigInt =<br/>{<br/><a class="ae ld" href="http://twitter.com/tailrec" rel="noopener ugc nofollow" target="_blank">@ tailrec</a>def factorial ACC(ACC:BigInt，n:BigInt):BigInt =<br/>{<br/>if(n&lt;= 1)<br/>ACC<br/>else<br/>factorial ACC(n * ACC，n — 1) <br/> } <br/> factorialAcc(1，n) <br/> } <br/> // Main方法<br/>def Main(t</p></blockquote><p id="414f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢读者推荐我关于这个话题的帖子！</p><p id="0f65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在以后的博客文章中更详细地讨论其他Scala主题！</p></div></div>    
</body>
</html>