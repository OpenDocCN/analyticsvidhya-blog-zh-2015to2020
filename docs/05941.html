<html>
<head>
<title>Insertion Sort: Implementation and Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">插入排序:实现和分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/insertion-sort-implementation-and-analysis-bd5c1860558a?source=collection_archive---------19-----------------------#2020-05-06">https://medium.com/analytics-vidhya/insertion-sort-implementation-and-analysis-bd5c1860558a?source=collection_archive---------19-----------------------#2020-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0655" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">插入排序对数组数据结构的作用如下:</p><ul class=""><li id="2618" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">从数组中的第二个元素开始，迭代到最后一个元素</li><li id="41bf" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在每次迭代中，<strong class="ih hj"> <em class="jr">选择</em> </strong> <em class="jr"> </em>一个元素，将该元素与其左侧的所有元素进行比较。</li><li id="7d95" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在比较时，每当我们发现一个比我们选择的元素更大的元素时，我们就将这个更大的元素向右移动一步</li><li id="6515" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在每次迭代结束时，我们找到一个空位<strong class="ih hj"> <em class="jr">插入</em> </strong>我们在迭代开始时选择的元素。</li></ul><p id="1e85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们直观地看一下，以便更好地理解。</p><p id="a810" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将对以下数组进行排序:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es js"><img src="../Images/9d0f1810a4954c1a1b457fe4235d45a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/0*ZeiyJG5GNcbDr23F"/></div></figure><p id="c4c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有五个元素，从索引0到索引4。</p><p id="af12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">直通1 </strong></p><p id="6fe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤1: </strong>算法从数组中的第二个元素开始，所以让我们选择索引为1的元素。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ka"><img src="../Images/ccaeea266dca3aa8ab6d6bb9ef51074a.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/0*VRyROAktttPRgqfR"/></div></figure><p id="7478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步:</strong>将选中的元素与其左侧的所有元素进行比较。这里我们只有1个元素向左-&gt;“6”在索引0处。我们来做个比较:6大于1吗？是的。然后根据算法，让我们将它向右移动一个位置:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kb"><img src="../Images/76b98b837011d19e97103103e6c0ea39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/0*fw3LOCxk3PzsG5iF"/></div></figure><p id="d4ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤3: </strong>因为我们在所选元素的左边只有一个元素，所以我们完成了这次传递的比较和移动。现在我们需要找到一个位置来插入我们选择的元素。</p><p id="e28c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，索引0处的位置变得可用，因为我们将元素“6”从索引0移动到了索引1。因此，让我们在那里插入我们选择的元素:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kc"><img src="../Images/26b4c9b811273b5bb0c75c819c6b32d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/0*4DCOQdjhiNt9hNLG"/></div></figure><p id="fc3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就结束了我们的第一次穿越。</p><p id="ea78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">直通2 </strong></p><p id="9301" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步:在第一次遍历中，我们选择了索引为1的元素。在此过程中，我们将移动到下一个元素，并选择索引为2的元素:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kd"><img src="../Images/372779f6a33d1aba2653a8f490c4f403.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/0*HbBtKfsEuavfUUcB"/></div></figure><p id="b26b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤2: </strong>我们现在开始比较过程，我们将所选元素与其左侧的所有元素进行比较。</p><p id="3a90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将所选元素“0”与“6”进行比较，后者是其左侧的第一个元素。由于6大于0，我们将它向右移动一步</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ke"><img src="../Images/e9a6dd4f41d4aa6d4470da389cb65f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/0*jYq1c1yje_8q-s6-"/></div></figure><p id="d740" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将所选元素“0”与其左侧的第二个元素“1”进行比较。由于1大于0，我们将它向右移动一步</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kf"><img src="../Images/608ce00afc7fc1083b074bbfd5ad5f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/0*usRCAJuikQIMgJJY"/></div></figure><p id="e27a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第三步:</strong>我们完成了这次传递的比较和移动。现在是时候将我们选择的元素插回到数组中的可用空位上了。因为我们移动了元素1和6，所以在索引0处有一个空位。因此，让我们继续在那里插入我们选择的元素</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kg"><img src="../Images/e11776328d3fec4a912cb4f068a74190.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/0*75omwWA42xIA3Kkw"/></div></figure><p id="2124" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">直通3 </strong></p><p id="e390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤1: </strong>现在我们已经掌握了算法，我们知道在这次遍历中，我们将选择索引为3的元素。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kh"><img src="../Images/a7283d6231ec2c8e81d3baccdb088b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/0*lMpW-77RmTXkrJT9"/></div></figure><p id="d20e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步:让我们开始比较。我们将比较我们选择的元素“10”和它左边的所有元素。</p><p id="5353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先与元素“6”进行比较。因为“6”是大于10的<strong class="ih hj">而不是</strong>，所以我们不把它移到右边。</p><p id="f871" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，从我们之前的经历中，我们知道<em class="jr">6左边的所有元素都小于6 </em>(因为我们之前做的所有步骤)。这意味着在这个传递中，我们不需要向右移动任何元素。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ki"><img src="../Images/bdcab597bc6ad7b5db0ed83f255e8e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/0*DNdRd4MgVcXXr33y"/></div></figure><p id="fac9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤3: 我们需要将我们选择的元素插入到数组中的一个可用位置。因为在最后一步中我们没有移动任何元素，所以空白点将与元素在通过之前的位置相同。因此，我们将元素放回那个位置，并继续进行下一次传递。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kj"><img src="../Images/5e585c16bea7a91df61cb2c4ed6beb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/0*hO8340HjjZOyMea0"/></div></figure><p id="0e16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">直通4 </strong></p><p id="093b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤1: </strong>我们移动到数组中的下一个元素，选择索引为4的元素。请注意，这是数组中的最后一个元素，因此这将是我们最后一次通过</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kk"><img src="../Images/f32c48462a07245932ededbc95d77320.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/0*v0Mq0s_Xkw3quk_y"/></div></figure><p id="83d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步:我们现在开始比较。我们需要比较元素“2”和它左边的所有元素。</p><p id="4e0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从索引3-&gt;“10”的元素开始。由于10大于2，我们将它向右移动一步。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kl"><img src="../Images/6d7f982a276b8a1383f27a75380341ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/0*2WUfjEQHvICP4tPH"/></div></figure><p id="81b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将选择的元素“2”与索引为2的元素进行比较。由于6大于2，我们将6向右移动一步</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es km"><img src="../Images/e51d6dfc323dac153c7fb22960a996a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*Tgp_KIbZfO2EfjjU"/></div></figure><p id="fddb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将选择的元素“2”与索引为1的元素进行比较。因为1是<strong class="ih hj">而不是</strong>大于2，所以我们不将其向右移动。</p><p id="3d06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，由于我们之前在算法中的遍历和步骤，我们可以肯定地知道“1”左侧的所有元素都将小于“1”。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kn"><img src="../Images/ac1bc9a7851af58ef1fcfb7b54a07f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/0*2ANXUcmDq4086xKk"/></div></figure><p id="4245" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤3: </strong>在我们完成了所有的比较之后，我们现在需要将我们选择的元素插回到数组中的空白处。因为索引2处的位置是空的，所以我们在索引2处插入我们选择的元素</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kd"><img src="../Images/b70a4209279a31e05bf0e5b6e9cc15e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/0*SowZ4HyRHtEM6pUj"/></div></figure><p id="010f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着这一遍的结束，我们已经对数组进行了排序！</p><p id="05ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重述</strong></p><p id="c95c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">插入排序有点难以理解，因为它有很多步骤，而且它在另一个方向(向左)比较元素，这与其他“向前看”的算法相反，后者比较右边的元素。</p><p id="c22e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们再次回顾一下我们所做的:</p><ul class=""><li id="7433" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">我们对5个元素的数组进行了4次遍历</li><li id="72ef" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在每次遍历中，我们选择一个元素</li><li id="c8fd" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">我们将选定的元素与其左侧的所有元素进行了比较</li><li id="93f4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">每当我们发现一个元素大于所选元素时，我们就将该元素向右移动</li><li id="6c06" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在所有的比较和移动结束时，我们在数组中有一个空位。我们将选定的元素插入到该点，结束我们的传递。</li></ul><p id="7195" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望现在可以理解为什么它被称为插入排序了！</p><p id="75ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用C#实现</strong></p><p id="b6f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是C#中插入排序算法的一个实现</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es ko"><img src="../Images/d648c88f765ca8688f0dfd560ce4862e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ol3lgWVph2izwE1g.png"/></div></div></figure><p id="3b15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行上面的代码，我们得到以下输出:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kt"><img src="../Images/9bec86088137d2c1c468f197344361c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/0*HijPUrjrC-1kGJZJ"/></div></figure><p id="4db2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">增长复杂性分析</strong></p><p id="dfc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在跳到涉及变量“N”的数学术语之前，让我们先看看我们在算法中执行了多少运算。</p><p id="dad7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对包含5个元素的数组执行了以下操作:</p><ol class=""><li id="cde7" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ku jj jk jl bi translated">4次<strong class="ih hj">穿越</strong></li><li id="69fb" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ku jj jk jl bi translated">1 <strong class="ih hj">比较</strong>和1 <strong class="ih hj">移动</strong>第一遍操作</li><li id="27b4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ku jj jk jl bi translated">第二次通过中的2次比较和2次移动操作</li><li id="b0d0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ku jj jk jl bi translated">1比较，第三次通过时没有移动</li><li id="78ac" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ku jj jk jl bi translated">第四次通过时的3次比较和2次移动</li><li id="c425" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ku jj jk jl bi translated">我们还在每次传递中执行了1次<strong class="ih hj">选择</strong>和1次<strong class="ih hj">插入</strong>操作，总共4次选择和4次插入操作</li></ol><p id="a3b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这给了我们总共4次通过+ 7次比较+ 5次移动+ 4次选择+ 4次插入</p><p id="6d37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者对我们的5个元素的数组总共进行24次运算。这更接近于(5)的平方。</p><p id="6360" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们试着用“N”来推导一个广义的复杂性。</p><p id="028f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们关注最坏的情况——数组中的所有元素都是降序排列的。</p><p id="1a19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于1次遍历，我们将进行大约:1次选择+ 1次插入+ (N-1)次比较+ (N-1)次移动</p><p id="e18b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对于(N-1)次通过，我们大约可以做到:</p><p id="cd8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(N-1) * (1 + 1 + (N-1) + (N-1))次运算</p><p id="d942" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们忽略所有的常数，我们会得到这样的结果:</p><p id="08ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(N) * (N)</p><p id="543b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这等于(N) (n的平方)次运算</p><p id="7a23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们可以说插入排序的最坏情况复杂度是O(N)或N的平方阶。</p><p id="1077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结</strong></p><p id="6a8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">插入排序从第二个元素开始，迭代数组直到最后一个元素。在每次迭代或遍历中，我们选择一个元素，并将其与左边的元素进行比较。每当左侧的元素大于所选元素时，我们就将它们向右移动一步。然后，我们将选择的元素插回到数组的空白处。</p><p id="87f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最坏的情况下，整个过程的时间复杂度为O(N)。</p></div></div>    
</body>
</html>