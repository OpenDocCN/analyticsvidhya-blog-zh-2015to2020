<html>
<head>
<title>End-to-End ML Workflow with GCP Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有GCP云功能的端到端ML工作流</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/end-to-end-ml-workflow-with-gcp-cloud-functions-b86bb766838e?source=collection_archive---------6-----------------------#2020-05-13">https://medium.com/analytics-vidhya/end-to-end-ml-workflow-with-gcp-cloud-functions-b86bb766838e?source=collection_archive---------6-----------------------#2020-05-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3fbb84044aa48ee5ece0554ee07f2c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1A2toPGG80d_2PxOeGho9Q.jpeg"/></div></div></figure><p id="cddb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Cloud Functions是谷歌云平台(GCP)提供的一个无服务器托管选项，允许用户部署事件驱动的代码，而不必管理底层硬件。</p><p id="6a39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这么多可用的GCP产品，问题就变成了:相对于App Engine、Compute Engine、Cloud Run、Kubernetes等其他产品，我们应该何时使用云功能。？</p><p id="91da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有许多场景都值得使用云函数——一个很大的指标是，如果您想要在不同的GCP产品之间设置一个触发器，它会很有帮助。</p><p id="2a6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一下这个<strong class="is hj">示例场景</strong>:每当我有一组新的图像(在这个例子中是动物)时，我想运行一个对象检测模型，我将这些图像手动上传到一个GCS桶中。我希望该模型(这将检测斑马)在图像上传后自动运行。</p><p id="2471" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这可以在云函数的帮助下完成，还有一个GCS bucket(用于我们的图像)和一个计算引擎VM，其中模型将通过启动脚本运行。</p><p id="b9b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此工作流的架构如下所示:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/d0726248c14aa07cb655c0de4a892837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBxq_bRGJoKL4XXpV12ZhA.jpeg"/></div></div></figure><p id="9880" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上图所示，云函数允许我们将两个GCP产品连接在一起:一个GCS bucket(这是我们的云函数的<em class="jt">触发器</em>)和一个计算引擎VM(这是我们的<em class="jt"> </em>云函数<em class="jt">触发</em>)。</p><p id="0840" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的图像被手动上传到我们的GCS bucket (input)文件夹后，我们的云功能将启动我们的计算引擎实例。一旦实例被打开，一个启动脚本将a) <a class="ae ju" href="https://cloud.google.com/storage/docs/gcs-fuse" rel="noopener ugc nofollow" target="_blank">挂载</a>我们的GCS bucket，并且b)在我们的bucket的输入文件夹中的映像上运行我们的模型(现在挂载为VM中的文件系统)。当模型完成运行时，它会将新的图像(已经识别出斑马的图像)写入我们的bucket的输出文件夹。然后，在卸载我们的bucket之前，我们的启动脚本会删除我们的输入图像文件。</p><p id="48af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是关于如何设置的分步指南:</p><p id="86b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第一步:创建云存储桶(云功能<em class="jt">触发</em>)</strong></p><p id="ae31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们创建一个云存储桶，在这里我们将上传我们的输入图像并接收我们的输出图像。这个存储桶可以在控制台中创建，也可以通过命令行创建:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="2360" class="ka kb hi jw b fi kc kd l ke kf">gsutil mb -c standard -l us-west1 gs://animal-images-sg</span></pre><p id="7316" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们添加两个文件夹:“输入图像”和“输出图像”</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/4d7560f5186afa960fddf35398aa22b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VYnzCTompoTqIGSNYCZBDQ.png"/></div></div></figure><p id="3e1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤2:配置虚拟机(<em class="jt">目标</em>云功能)</strong></p><p id="4e97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二步是设置我们的VM并配置它来运行我们的ML模型。</p><p id="dfdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我选择了一台已经安装了PyTorch的n1-standard-4机器，引导盘如下:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/f0d50123eda32d6ebc655c61f66ad6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8hx7TyD2l2Dw1MS51kFqA.png"/></div></div></figure><p id="309d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设置这个特定实例的gcloud命令是:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="e49a" class="ka kb hi jw b fi kc kd l ke kf">gcloud compute instances create zebra-classifier --zone=us-west1-b --machine-type=n1-standard-4 --scopes=https://www.googleapis.com/auth/cloud-platform --tags=http-server,https-server --image=c2-deeplearning-pytorch-1-4-cu101-20200414 --image-project=ml-images --boot-disk-size=100GB --boot-disk-type=pd-standard</span></pre><p id="eb53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我从Github克隆了对象检测模型repo(git预装了这个启动盘):</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="a3a6" class="ka kb hi jw b fi kc kd l ke kf">git clone <a class="ae ju" href="https://github.com/stefangouyet/pytorch_objectdetecttrack" rel="noopener ugc nofollow" target="_blank">https://github.com/stefangouyet/pytorch_objectdetecttrack</a></span></pre><p id="504d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jt">这段代码是从Chris Fotache的对象检测Github </em> <a class="ae ju" href="https://github.com/cfotache/pytorch_objectdetecttrack" rel="noopener ugc nofollow" target="_blank"> <em class="jt">资源库</em> </a> <em class="jt">中派生出来的，它为在PyTorch中使用CNN和YOLO算法提供了一个很好的起点。</em></p><p id="ad4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了下载我们的YOLO权重，我们首先运行以下代码:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="7016" class="ka kb hi jw b fi kc kd l ke kf">cd config/<br/>. download_weights.sh</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/d2b90afaf5d9081d27f576a968f7a6e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Td_hthTElNP5UVG2B1Iqg.png"/></div></div></figure><p id="46ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们安装GCS保险丝:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="be16" class="ka kb hi jw b fi kc kd l ke kf">export GCSFUSE_REPO=gcsfuse-`lsb_release -c -s`echo "deb </span><span id="168b" class="ka kb hi jw b fi kj kd l ke kf">http://packages.cloud.google.com/apt $GCSFUSE_REPO main" | sudo tee /etc/apt/sources.list.d/gcsfuse.listcurl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -sudo apt-get update</span><span id="3b54" class="ka kb hi jw b fi kj kd l ke kf">sudo apt-get install gcsfuse</span></pre><p id="86dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装后，让我们尝试安装我们的<em class="jt">动物图像-sg </em>桶，它将安装在一个同名的文件夹中:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="9270" class="ka kb hi jw b fi kc kd l ke kf">cd pytorch_objectdetecttrack/</span><span id="8ed0" class="ka kb hi jw b fi kj kd l ke kf">mkdir animal-images-sg</span><span id="6b77" class="ka kb hi jw b fi kj kd l ke kf">gcsfuse --implicit-dirs animal-images-sg animal-images-sg/</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/aa3514c8e52636555545d9ab2c3620af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rAxwLWQRMVZbo9Ujp17giw.png"/></div></div></figure><p id="b983" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在GCS Fuse正在工作，让我们尝试在一些输入图像上运行我们的模型。</p><p id="9d11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我已经向bucket的输入文件夹添加了四幅图像:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/50ef056242b2e0f5cd0d777ea7a319b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6RWlmpsNKUdN0tARcpLULQ.png"/></div></div></figure><p id="6c5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重新安装铲斗后，我们可以看到外壳中的图像:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/0bc306f2e57096018d52ff559f864116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_e7-BWhsddbpKWwZfdS-g.png"/></div></div></figure><p id="124b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jt">仅供参考:要卸载铲斗</em>，<em class="jt">运行</em>:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="29d4" class="ka kb hi jw b fi kc kd l ke kf">fusermount -u animal-images-sg</span></pre><p id="ab25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦装载了bucket并显示了新的图像，就该运行存储在main.py文件中的对象检测模型了:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="0624" class="ka kb hi jw b fi kc kd l ke kf">python3 main.py</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/478521e3d5ec250b960df18315261b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZru51--WnxUw9LhayI0og.png"/></div></div></figure><p id="915e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python脚本输出四个新图像(文件名后附加“<em class="jt">-det”</em>)。这些将被写入我们的输出图像文件夹，并将显示在我们的GCS存储桶中:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/1c679133cbcd1e8f290e3c8174abc3bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dqUBOADGy7D3plLuQqxSVw.png"/></div></div></figure><p id="9ecd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单击任何输出图像将显示对象检测模型已经正确运行，显示原始图像，以及斑马周围的边界框。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/5ad5c2bf65dbda4799b6b981650d299e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXLt-SMMdFJWQizVz86lJQ.png"/></div></div></figure><p id="197b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将继续关闭虚拟机，并编写启动脚本:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="cdd9" class="ka kb hi jw b fi kc kd l ke kf">#! /bin/sh<br/><br/>sleep 100</span><span id="efe7" class="ka kb hi jw b fi kj kd l ke kf">apt-get update</span><span id="ab4a" class="ka kb hi jw b fi kj kd l ke kf">cd /home/gouyetarchitecture/pytorch_objectdetecttrack/<br/><br/>gcsfuse --implicit-dirs animal-images-sg animal-images-sg/</span><span id="9fff" class="ka kb hi jw b fi kj kd l ke kf">python3 main.py</span><span id="a23c" class="ka kb hi jw b fi kj kd l ke kf">rm animal-images-sg/input-images/*</span><span id="d71f" class="ka kb hi jw b fi kj kd l ke kf">fusermount -u animal-images-sg</span><span id="ccaa" class="ka kb hi jw b fi kj kd l ke kf">sudo shutdown -h now</span></pre><p id="1a4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个启动脚本告诉我们的虚拟机a)移动到当前目录，b)挂载我们的GCS Fuse bucket，c)运行我们的对象检测模型，d)删除我们的输入文件夹中的图像，e)卸载我们的bucket，以及f)关闭虚拟机。我们将脚本添加到虚拟机的<em class="jt">自定义元数据</em>部分，关键字为<em class="jt"> startup-script: </em></p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/a7064b4020a4efae4aa797455d668a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JexM1EAeHlT6uMcRx6FEVg.png"/></div></div></figure><p id="5b80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第三步:设置云功能连接存储和计算引擎</strong></p><p id="5eef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的最后一步涉及使用云函数，我们将把它连接到我们的GCS bucket和我们的计算引擎实例。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/03f7496f0ff026ae71929c275d40095b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YN8sshzqTdGMh467mcIzcw.png"/></div></div></figure><p id="e258" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们希望我们的事件类型设置为“完成/创建”这告诉云函数等待在我们的桶中创建或覆盖一个对象(更多信息可以在GCP的文档中找到)。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/d29736fdb6f34a2b7981c83dad3211e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oOUrJHZBhWAZq1ZdH66C-A.png"/></div></div></figure><p id="6a9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们指定想要使用哪个桶(在我们的例子中，是animal-images-sg桶)。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/081cce8b4b1d420fadb830460c8b6407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXw67ojBoKzsgKqNoPvQKw.png"/></div></div></figure><p id="5b00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们声明当我们的云函数被触发时，我们希望发生什么。这可以用几种不同的语言来定义——通常，我使用Node.js(本例中是版本8)来定义:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="a094" class="ka kb hi jw b fi kc kd l ke kf">var http = require('http');</span><span id="5699" class="ka kb hi jw b fi kj kd l ke kf">var Compute = require('@google-cloud/compute');</span><span id="d671" class="ka kb hi jw b fi kj kd l ke kf">var compute = Compute();exports.startInstance = function startInstance(req, res) {</span><span id="2d08" class="ka kb hi jw b fi kj kd l ke kf">var zone = compute.zone('us-west1-b');</span><span id="e7a5" class="ka kb hi jw b fi kj kd l ke kf">var vm = zone.vm('zebra-classifier');</span><span id="8fbc" class="ka kb hi jw b fi kj kd l ke kf">vm.start(function(err, operation, apiResponse) {</span><span id="1ef3" class="ka kb hi jw b fi kj kd l ke kf">console.log('instance start successfully');</span><span id="8f94" class="ka kb hi jw b fi kj kd l ke kf">});</span><span id="c5a1" class="ka kb hi jw b fi kj kd l ke kf">res.status(200).send('Success start instance');};</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f8a83e810dbb2e995eb710bb7c1d29a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zsp2FiL3CA88jl-5NS-8vA.png"/></div></div></figure><p id="fc03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的index.js文件包含一个函数<em class="jt"> startInstance </em>，它将在区域<em class="jt"> us-west1-b </em>中查找我们的<em class="jt"> zebra-classifier </em>实例，并调用内置的<em class="jt"> vm.start </em>函数。</p><p id="36ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且package.json文件可以保留其默认配置:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/cdac88141eb298baa9b27543c74a3a79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84GJdJAh1xDIYjpPSpB5Jw.png"/></div></div></figure><p id="b757" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">概要:</strong></p><p id="2832" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是全部的设置！</p><p id="d9a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以看到我们的端到端工作流程:</p><p id="6a64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们将新映像上传到GCS存储桶时，我们的虚拟机会自动启动:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/8cbc2e264db27767d1cee87b15cddda9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pymV6C79STa4rSJ0lUPDqA.gif"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">在我们的bucket中上传图像会打开我们的zebra分类器VM实例</figcaption></figure><p id="b0dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经上传了10张图片，其中7张是斑马。等待几分钟后，我们会发现一个空的输入文件夹和一个输出文件夹，其中有七幅斑马的图像，动物周围有一个边框:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/5e65c2c005a0f77d2f0b00e5fdb9e389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NLq9K2saU3RIkkep5TZU2w.gif"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">输入图像被删除，输出图像现在可见</figcaption></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/9ea2d733fe247e4bd81ead6575f61890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zAvj4tX7AxuPXlpSz8k9Q.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">我们可以检测出哪些图像包含斑马！</figcaption></figure><p id="4dda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你喜欢读这篇文章。如果您有任何意见或建议，请在下面留言联系我。谢谢！</p></div></div>    
</body>
</html>