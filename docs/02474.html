<html>
<head>
<title>Getting Insights From Production Alerts using (basic) Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用(基本)机器学习从生产警报中获得洞察力</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/getting-insights-from-production-alerts-using-basic-machine-learning-44dd805d899?source=collection_archive---------8-----------------------#2019-12-18">https://medium.com/analytics-vidhya/getting-insights-from-production-alerts-using-basic-machine-learning-44dd805d899?source=collection_archive---------8-----------------------#2019-12-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ih ii ij ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ig"><img src="../Images/2350f54de1fc4a12794895bf0700aa0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MLKCoB_bW4LrhkOcKNWzUQ.jpeg"/></div></div></figure><p id="97ce" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">许多科技公司都有外部监控工具来帮助他们获得关于生产环境中发生的问题的通知。</p><p id="4648" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">然而不幸的是，不同错误之间的联系通常是由经验而不是实际研究来定义的，因此导致优先级定义不佳，并使缓解过程效率较低。</p><p id="e044" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">一些流行的监控工具有OpsGenie、Victor-Ops和Pager-Duty。<br/>(这将是一个很好的时机来澄清以上没有一个赞助本文的人)。</p><p id="3d3c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在本文中，我将分析来自OpsGenie的警报，因为我有机会使用它，但这无关紧要，因为稍加调整，任何其他监视工具都可以用作警报数据源。</p><figure class="jq jr js jt fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es jp"><img src="../Images/c4180b465b4d724d0209f8bcaa3749df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z8UatQrqUoqcFz8Wphz8ZA.png"/></div></div></figure><h1 id="2ae2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">首先，我们如何确定哪个错误导致了另一个错误？</h1><p id="2d7d" class="pw-post-body-paragraph ir is hi it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hb bi translated">有几种方法可以做到这一点，我们将探索一个简单的机器学习算法称为关联规则。</p><p id="7a15" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">算法实现我就不深究了，请参考这里理解算法的逻辑(并不复杂):</p><p id="ca06" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><a class="ae kx" href="https://en.wikipedia.org/wiki/Association_rule_learning" rel="noopener ugc nofollow" target="_blank">关联-规则-维基</a></p><p id="dd30" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">Let׳s通过一个例子说明了这种算法的使用。<br/>在超市中组织产品——输入将是一个类似如下的数据集:</p><pre class="jq jr js jt fd ky kz la lb aw lc bi"><span id="2882" class="ld jv hi kz b fi le lf l lg lh"><strong class="kz hj">transaction_id, name, groceries<br/></strong>1, John,{potato, onion}<br/>2, John,{cucumber, tomato}<br/>3, Don, {lettuce, onion}</span></pre><p id="18cb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">输出将是一起购买的产品(有一定的可能性)。<br/>所以，如果我们能知道大多数时候人们买土豆的同时也会买汉堡，我们会把它们放在一起。</p><h2 id="67ca" class="ld jv hi bd jw li lj lk ka ll lm ln ke jc lo lp ki jg lq lr km jk ls lt kq lu bi translated">了解了这个方法的用法之后，我们该如何使用它来达到我们的目的呢？</h2><figure class="jq jr js jt fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es lv"><img src="../Images/1973549436d5ce9c849e4ec2d13e7de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ektY8roPP9FMh0czX_oqdA.jpeg"/></div></div></figure><p id="9c1a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">通常，如果引发另一个警报的生产警报被触发，该另一个警报也会在不久的将来被触发。<br/>也就是说，我们需要创建警报数据集，使算法能够为我们提供有意义的连接，这些连接是由警报的时间戳得出的。</p><p id="5ee4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们看一个所需警报数据集的示例</p><pre class="jq jr js jt fd ky kz la lb aw lc bi"><span id="501e" class="ld jv hi kz b fi le lf l lg lh"><strong class="kz hj">alert_name,ts</strong><br/>alert_a, 22/01/2020:16:20<br/>alert_b, 22/01/2020:17:20<br/>alert_a, 22/02/2019:14:20<br/>…</span></pre><p id="31bc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这种情况下，我们将使用时间戳连接不同的警报，并将其输入到算法中，以便它可以生成相关警报之间的连接，类似于它如何在相关产品之间创建连接。<br/>只有在这个例子中，连接是一个单一的购买者——一个交易id，在这个例子中，有一个时段连接(例如，在30分钟范围内触发的所有警报都属于同一个交易)。</p><p id="cff7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">算法的输出看起来会像这样-</p><pre class="jq jr js jt fd ky kz la lb aw lc bi"><span id="fb64" class="ld jv hi kz b fi le lf l lg lh"><strong class="kz hj">alert_a, alert_b, confidence a-&gt;b, conf b-&gt;a</strong><br/>alert_a, alert_b, 0.8, 0.2<br/>alert_c, alert_b, 0.1,0.7<br/>alert_a, alert_c, 0.8, 0.3<br/>…</span></pre><p id="f52d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">任何一个运营团队的成员或者任何一个正在处理生产错误的专业人士(大多数创业公司都没有运营团队)都可以在这些结果中发现很多价值，并相应地设置警报的优先级。</p><p id="01c7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们流程的最后一个阶段是将结果建模为图表。<br/>由于我们想要了解不同错误之间的根源和原因，以这种方式显示我们的结果将允许我们了解警报之间的路径，该错误影响许多其他错误(图中的许多邻居)等等。</p><p id="eaa9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这可以通过简单地将每个唯一的错误名称声明为一个顶点，并在以足够高的概率<strong class="it hj">导致另一个错误的任何警报之间添加一条边来实现。<br/> </strong>这将是一个有向图(否则我们不会知道根源和原因是什么)。</p><ul class=""><li id="e9eb" class="lw lx hi it b iu iv iy iz jc ly jg lz jk ma jo mb mc md me bi translated">可视化图表的一个好方法是将每个误差表示为一个数字。<br/>(您可以将权重添加到边缘，作为一个警报引起另一个警报的概率)。</li></ul><figure class="jq jr js jt fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es mf"><img src="../Images/c315828f44e6ed0ece065c1f1f6fb2ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LAXq98Hhsyh9fLBdm5O-0w.png"/></div></div></figure><h1 id="c0c7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">那么如何在实践中运用呢？</h1><p id="5370" class="pw-post-body-paragraph ir is hi it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hb bi translated">在文章的最后，有一个到我的GitHub的链接，其中包含从OpsGenie获取警报的脚本，以及使用Spark的算法实现。</p><figure class="jq jr js jt fd ik er es paragraph-image"><div class="er es mg"><img src="../Images/3b8dbe61300f6da393ae93f280753a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*vEPEmyJIKc2wLun6PmT_IA.jpeg"/></div></figure><blockquote class="mh"><p id="274f" class="mi mj hi bd mk ml mm mn mo mp mq jo dx translated">有两种方法可以让你快速产生相关的错误—</p></blockquote><ul class=""><li id="3033" class="lw lx hi it b iu mr iy ms jc mt jg mu jk mv jo mb mc md me bi translated">在我看来(在准确性和效率方面)，首选是使用Spark FPGrowth算法。网上有很多信息，使用起来非常简单。<br/>请注意，我用于获取警报的脚本不会针对该算法正确组织数据，因为它期望每行代表一个完整的事务。<br/>您可以在时间窗口中组织警报，也就是说，假设您已经决定一个事务由一个小时组成。<br/>然后，您将从一个给定的时间(例如三个月前)开始，然后滑入一个时间窗口(例如两分钟)，并根据检查的小时数生成一条交易线。<br/>即使多行包含相同的错误，您也不会(几乎)错过两个不同错误之间的联系。</li><li id="41dd" class="lw lx hi it b iu mw iy mx jc my jg mz jk na jo mb mc md me bi translated">第二种方式是使用我的代码，这意味着您需要像在第一个示例中看到的那样组织它将使用的数据(alert_name，ts)。<br/>如前所述，您可以使用我的代码从OpsGenie获取警报(您需要提供一个API密钥),它会正确地安排数据。</li><li id="6151" class="lw lx hi it b iu mw iy mx jc my jg mz jk na jo mb mc md me bi translated">重要提示—代码写得又快又难看</li></ul><p id="8cbf" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我希望你能从这篇文章中受益，<br/>如果你把它作为一个资源使用，我将非常感谢收到任何评论和用例，也可以随时联系任何技术/其他问题。</p><ul class=""><li id="bb95" class="lw lx hi it b iu iv iy iz jc ly jg lz jk ma jo mb mc md me bi translated"><a class="ae kx" href="https://github.com/royashcenazi/spark_and_stuff" rel="noopener ugc nofollow" target="_blank"> Github资源库链接</a></li><li id="2cc2" class="lw lx hi it b iu mw iy mx jc my jg mz jk na jo mb mc md me bi translated">如果你需要将算法输出转换成可视化图形的帮助，有一个很好的Python库叫做networkx(还有很多其他的)<br/>有任何问题随时联系我。</li></ul><p id="05f9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">*我可以在这里联系到<a class="ae kx" href="https://www.linkedin.com/in/roy-ashcenazi-a09951142/" rel="noopener ugc nofollow" target="_blank"/></p><blockquote class="mh"><p id="2269" class="mi mj hi bd mk ml nb nc nd ne nf jo dx translated">感谢阅读！</p></blockquote></div></div>    
</body>
</html>