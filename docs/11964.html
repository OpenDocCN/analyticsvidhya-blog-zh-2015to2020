<html>
<head>
<title>A Short But Complete Guide To Python Flask App Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个简短但完整的 Python Flask 应用程序开发指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-short-but-complete-guide-to-python-flask-app-development-9b493f960bd1?source=collection_archive---------5-----------------------#2020-12-26">https://medium.com/analytics-vidhya/a-short-but-complete-guide-to-python-flask-app-development-9b493f960bd1?source=collection_archive---------5-----------------------#2020-12-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="e3a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">目标:</em> </strong></p><ul class=""><li id="4480" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">用 Python Flask framework 编写一个基本的 REST 应用程序。</li><li id="7d2d" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">提供基本特性的框架代码，这样你就不必在很多地方寻找基本的东西。</li><li id="5830" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">创建一个 Docker 映像，它可以很容易地部署在任何服务器上(机器或虚拟机)。</li><li id="4c2e" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">只为<em class="jc">提供概念的基本原则</em>，但为有用的设计模式提供工作代码。和链接，了解更多信息。</li></ul><p id="d31c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">注意:</em> </strong> <em class="jc">这可能感觉像是一篇很长的文章，它的目的是以简洁的方式来实现完整性。目标受众:初学者(但不是绝对的初学者)，或者中级。</em></p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><p id="a9ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jy translated"><span class="l jz ka kb bm kc kd ke kf kg di"> F </span>第一件事:<strong class="ig hi"> <em class="jc">设置开发环境。</em> </strong></p><p id="f538" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要轻松编写代码(自动完成、语法高亮等):使用<a class="ae kh" href="https://www.jetbrains.com/idea/" rel="noopener ugc nofollow" target="_blank"> IntelliJ </a>(带 Python 插件)，或者<a class="ae kh" href="https://www.jetbrains.com/pycharm/" rel="noopener ugc nofollow" target="_blank"> PyCharm </a> IDE，或者其他你喜欢的东西。</p><p id="e357" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行应用程序代码:基本上，您所需要的就是在您的机器上安装 python 解释器，但是建议您设置一个<a class="ae kh" href="https://docs.python.org/3/library/venv.html#:~:text=A%20virtual%20environment%20is%20a,part%20of%20your%20operating%20system." rel="noopener ugc nofollow" target="_blank">“虚拟环境”</a>(简称<em class="jc"/>，<em class="jc">这样，当您有多个 Python 项目，或者在您的系统上安装了 python2 并且想要在您的项目中使用 Python 3</em>时，就不太可能出错)。</p><p id="0811" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要使用 python 库、框架(例如 Flask):你需要一个包管理器——Pip。</p><p id="3f46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为您的项目设置<em class="jc"> Python 解释器</em>(使用 IntelliJ/PyCharm 应该很容易，只需按两次 Shift 键并搜索“Python 解释器”，它会打开一个窗口，您可以在其中设置解释器，您甚至可以创建一个虚拟环境)。创建虚拟环境有 3 个选项/工具:<strong class="ig hi"> virtulenv </strong>(最老的一个)<strong class="ig hi"> pyenv </strong>(基本就是 pip+virtualenv)<strong class="ig hi">conda。</strong> <a class="ae kh" href="https://stackoverflow.com/questions/38217545/what-is-the-difference-between-pyenv-virtualenv-anaconda" rel="noopener ugc nofollow" target="_blank">见这里的区别</a>。关于这一点，有大量令人困惑的工具。请访问此链接了解详情。</p><p id="cc86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Anaconda 和 Miniconda 中都包含了 pip 和 conda，所以不需要单独安装。不要混合 pip 和 conda，这可能会意外损坏东西。</p><p id="836b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们使用<code class="du ki kj kk kl b"><a class="ae kh" href="https://docs.python.org/3/library/venv.html" rel="noopener ugc nofollow" target="_blank">venv</a></code>工具。</p><p id="9fed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过运行一个简单的 python 脚本，确保到目前为止一切正常。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><p id="c618" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jy translated">第二件事:测试框架。</p><p id="642e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你是一个初学者，从测试开始是“最好的”,这样你就能建立起编写测试所需的肌肉记忆，并且不会感到前进的沉重。</p><p id="d97f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你是有经验的程序员，你一定已经对 TDD ( <a class="ae kh" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a>)有偏见，你可以试图说服自己支持或反对 TDD，但是无论如何你都需要测试。所以，让我们马上设置它。</p><p id="2197" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pytest 是一个很棒的/丰富的框架，用于在 python 中运行测试。</p><p id="50d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要使用它，在你的项目文件夹中创建一个名为<code class="du ki kj kk kl b">requirements</code>的文件夹，并在这个文件夹中创建两个文件<code class="du ki kj kk kl b">development.txt</code>和<code class="du ki kj kk kl b">production.txt</code>。这些文件将交给包管理器(pip)来安装库，包括<code class="du ki kj kk kl b">pytest</code>(我们称之为依赖)。但是为什么是两个文件呢:因为有些库，比如 pytest，在你创建一个可部署的工件(比如一个可以在服务器上部署的 docker 映像)时是不需要的，它只在开发时需要。以下是到目前为止的<code class="du ki kj kk kl b">development.txt</code>文件:</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="3a3b" class="ku kv hh kl b fi kw kx l ky kz">-r production.txt # Whatever library required in production, would also be required while developing, so include it here.</span><span id="6872" class="ku kv hh kl b fi la kx l ky kz">pytest</span></pre><p id="8186" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个名为<code class="du ki kj kk kl b">tests</code>的文件夹。Python 框架不强制/标准化任何特定的文件夹结构(不像 Java 世界中的框架，例如 maven/gradle)。但是<code class="du ki kj kk kl b">project_folder/app, project_folder/tests</code>、<code class="du ki kj kk kl b">project_folder/integration-tests</code>，看起来结构足够好。</p><p id="0f2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">确保在 tests 文件夹中编写一个虚拟测试，并使用 pytest 运行它。</p><p id="6d9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要运行虚拟测试，首先运行<code class="du ki kj kk kl b">pip install -r requirements/development.txt</code>，在安装完成后，运行<code class="du ki kj kk kl b">pytest</code> pytest 自动检测测试文件，<strong class="ig hi"> <em class="jc">你必须用</em> </strong> <code class="du ki kj kk kl b"><strong class="ig hi"><em class="jc">test_</em></strong></code> <strong class="ig hi"> <em class="jc">前缀开始你的测试文件和测试方法。</em>T25】</strong></p><p id="9ccb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以看到我们目前拥有的:<a class="ae kh" href="https://github.com/trexsatya/sample-flask-app/tree/Step_1" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><p id="df38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jy translated">第三件事:休息控制器</p><p id="046f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们希望为用户提供一个 REST API。(REST 基本上意味着资源/事物的标准化表示<em class="jc">，您可以在它上面学习更多内容</em>)</p><p id="f367" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">也就是说，我们希望我们的应用程序处理这些 HTTP URLs:</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="20d2" class="ku kv hh kl b fi kw kx l ky kz">GET /users, GET /users/{user_id}<br/>POST /users<br/>....</span></pre><p id="72b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们先写一个测试，</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="e449" class="ku kv hh kl b fi kw kx l ky kz">class TestUserController:<br/>    def test_that_application_handles_user_request(self):<br/>       response = testapp.get("/api/v1/users")<br/>       assert response is not None</span></pre><p id="15e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我们第一次测试中最不需要的。但是，我们没有建议下一个行动项目的<code class="du ki kj kk kl b">tesatpp</code>，我们需要设置我们的应用程序。</p><p id="8d65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此我们需要安装<a class="ae kh" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank">烧瓶</a>，在<code class="du ki kj kk kl b">requirements/production.txt</code>文件中添加新的一行<code class="du ki kj kk kl b">Flask==1.1.2</code>。我们还需要<code class="du ki kj kk kl b">WebTest</code>库。</p><p id="53f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后再次做<code class="du ki kj kk kl b">pip install</code>后，我们可以创建一个应用程序来测试。为此，我们将使用<a class="ae kh" href="https://docs.pytest.org/en/stable/fixture.html" rel="noopener ugc nofollow" target="_blank"> Pytest 夹具</a>。基本上，fixtures 允许你设置对象(服务，应用程序等等)，并把它作为测试函数的一个参数。<em class="jc">(这种设置测试夹具的风格不同于其他编程语言中的 JUnit、xUnit 框架。)</em></p><p id="88a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是 testapp <em class="jc">(因此，整个应用程序是一个单独的对象)</em>的测试夹具，我们将在我们的测试方法中使用它。</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="39b7" class="ku kv hh kl b fi kw kx l ky kz">import pytest<br/>from flask import Flask<br/>from webtest import TestApp<br/><br/><br/>class TestConfig:<br/>    pass<br/><br/><br/>def create_app(config_object):<br/>    _app = Flask(__name__.split(".")[0])<br/>    _app.config.from_object(config_object)<br/>    return _app<br/><br/><br/>@pytest.fixture(scope='function')<br/># scope='function' means that this object would be created when it is required by test function,<br/># and will be destroyed when the function completes (i.e. fixture goes out of scope)<br/>def app():<br/>    <em class="jc">"""An application for running tests"""<br/>    </em>_app = create_app(TestConfig)<br/><br/>    with _app.app_context():<br/>        pass<br/><br/>    ctx = _app.test_request_context()<br/>    ctx.push()<br/><br/>    yield _app<br/>    # Below is the tear-down code run after the fixture goes out of scope<br/>    ctx.pop()<br/><br/><br/>@pytest.fixture(scope='function')<br/>def testapp(app): # app comes from the fixture defined above<br/>    <em class="jc">"""A Webtest app."""<br/>    </em>return TestApp(app)</span></pre><p id="df6b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有一些重要的事情需要注意:</p><ol class=""><li id="f945" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb lb jj jk jl bi translated">这是一种<a class="ae kh" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>，你定义/告诉应用程序对象应该如何被创建，当需要时框架自动创建/注入它，当超出范围时销毁它<em class="jc">，你不必创建，只需在需要时询问</em>。</li><li id="3148" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lb jj jk jl bi translated">这看起来像注释(如果你熟悉其他编程语言的话)，但 python 中的机制与注释不同。这些被称为<a class="ae kh" href="https://wiki.python.org/moin/PythonDecorators" rel="noopener ugc nofollow" target="_blank">装饰者</a>又称包装者。基本上，每当调用<code class="du ki kj kk kl b">testapp</code>函数时，python 解释器实际上会调用<code class="du ki kj kk kl b">pytest.wrapper</code>并将<code class="du ki kj kk kl b">testapp</code>函数作为参数传递。我们将创建自己的定制装饰器，这将使它更加清晰。<em class="jc">(注意:这不同于装饰模式，在装饰模式中，你通过将一个对象封装到另一个具有相同接口的对象中来修改它的行为，这里你是动态地修改一个函数/类。</em> <a class="ae kh" href="https://stackoverflow.com/questions/8328824/what-is-the-difference-between-python-decorators-and-the-decorator-pattern" rel="noopener ugc nofollow" target="_blank"> <em class="jc">亦见此线程</em> </a> <em class="jc">。</em></li><li id="e024" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lb jj jk jl bi translated">我们有最小的配置对象，稍后我们将填充它。</li></ol><p id="dac3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，如果您运行<code class="du ki kj kk kl b">pytest</code>命令，您应该会看到错误</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="9a90" class="ku kv hh kl b fi kw kx l ky kz">webtest.app.AppError: Bad response: 404 NOT FOUND</span></pre><p id="af53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是因为 WebTest framework 会对所有不是 200 或 300 左右的响应抛出错误，<em class="jc">除非被告知要这样做。</em>所以，你只要在调用 get 方法的时候加一个参数<code class="du ki kj kk kl b">status='*'</code>就可以了。</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="bccc" class="ku kv hh kl b fi kw kx l ky kz">class TestUserController:<br/>    def test_that_application_handles_user_request(self):<br/>       response = testapp.get("/api/v1/users", status="*")<br/>       assert response is not None</span></pre><p id="37b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，你的测试应该通过了。但是，您实际上需要 200 个响应，而不是 404，因此我们需要通过编写一个控制器来处理这个 URL。</p><p id="beb1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">向您的测试添加一个新行，它应该会失败。</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="66c8" class="ku kv hh kl b fi kw kx l ky kz">assert response.status_code == 200</span></pre><p id="3bdf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:你需要一个<code class="du ki kj kk kl b">tests</code>文件夹下的<code class="du ki kj kk kl b">__main__.py</code>文件来使用<code class="du ki kj kk kl b">app</code>文件夹中的代码。</p><p id="797e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">文件:app/controllers/user _ controller . py</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="2b81" class="ku kv hh kl b fi kw kx l ky kz">from flask import jsonify, Blueprint<br/>from flask.views import MethodView<br/><br/>FAKE_DATA = [{"user_id": 1, "value": "duck"}, {"user_id": 2, "value": "cat"}]<br/><br/>user_blueprint = Blueprint("users_api", __name__)<br/><br/><br/>class UserController(MethodView):<br/>    def get(self, user_id):<br/>        if user_id is None:<br/>            return jsonify(FAKE_DATA)<br/>        else:<br/>            return jsonify(list(filter(lambda x: x['user_id'] == user_id, FAKE_DATA)))<br/><br/><br/>user_view = UserController.as_view("api")<br/>user_blueprint.add_url_rule(<br/>        "/api/v1/users", defaults={"user_id": None}, view_func=user_view, methods=["GET"]<br/>)<br/>user_blueprint.add_url_rule("/api/v1/users/&lt;int:user_id&gt;", view_func=user_view, methods=["GET"])</span></pre><p id="f553" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，我们使用了<a class="ae kh" href="https://flask.palletsprojects.com/en/1.1.x/tutorial/views/" rel="noopener ugc nofollow" target="_blank">烧瓶蓝图</a>和<a class="ae kh" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.views.MethodView" rel="noopener ugc nofollow" target="_blank">方法视图</a>。实际上，我们不需要蓝图和 MethodView，因为 Flask 需要的只是一个函数，它可以为配置的 URL 返回响应。但是，当您有很多 API 时，使用 Blueprint 会使事情易于管理，而使用 MethodView 会使它更适合 REST 实现。</p><p id="7496" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，如果你了解 Spring/SpringBoot 控制器，你会注意到我们必须在这里做一些额外的编码，而不仅仅是声明 API。这可以简化，有一个库可以做到这一点，但是我们现在不打算使用它。</p><p id="69b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，您已经在蓝图中配置了路由(URL ),但是 Flask 仍然不知道它们。为此，我们必须用从<code class="du ki kj kk kl b">create_app</code>函数返回的应用程序注册这个蓝图。但在此之前，让我们进行重构，将该函数从 tests 目录中取出，因为它将用于测试和作为服务器实际运行我们的应用程序。</p><p id="e21a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以看到我们到目前为止所拥有的，<a class="ae kh" href="https://github.com/trexsatya/sample-flask-app/tree/Step_2" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><p id="1044" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jy translated">第四件事:使用数据库</p><p id="4109" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们添加 api 来添加新用户，然后将其保存到数据库中。首先，编写一个添加用户的测试。</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="f948" class="ku kv hh kl b fi kw kx l ky kz">def test_that_invalid_data_is_not_allowed_in_creation(self, testapp):<br/>    response = testapp.post_json("/api/v1/users", {"name": 1231, "email": "invalid_mail"}, status="*")<br/>    assert response.status_code == 400<br/><br/>def test_that_we_can_create_new_user(self, testapp):<br/>    response = testapp.post_json("/api/v1/users", {"name": "ivhas", "email": "abc@mail.com"}, status="*")<br/>    assert response.status_code == 200<br/>    assert response.json["name"] == "ivhas"</span></pre><p id="0336" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你应该看到"&lt;405 METHOD NOT ALLOWED..” on running  【T1】  now.</p><p id="f0d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">We need to create some class for transferring request and response body for users, which also has information about what kind of data is allowed.</p><p id="f31e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">For that we’ll use another library <a class="ae kh" href="https://marshmallow.readthedocs.io/en/stable/quickstart.html" rel="noopener ugc nofollow" target="_blank">棉花糖</a>。它有不同的内置类型，例如电子邮件，日期时间等。基本上，它是一个用于序列化/反序列化目的的库。但是，它的工作模式又不同于 Java world(像 Jackson 这样的库)。这里我们添加了另外两个库(到 requirements/production . txt):<code class="du ki kj kk kl b">marshmallow</code>和<code class="du ki kj kk kl b">flask-apispec</code></p><p id="2de7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们创建一个新文件<code class="du ki kj kk kl b">app/dto/user.py</code>来包含用户的数据传输对象模型类:</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="c972" class="ku kv hh kl b fi kw kx l ky kz">from marshmallow import post_load, fields, Schema<br/>import datetime as dt<br/><br/><br/>class UserData:<br/>    def __init__(self, name, email):<br/>        self.name = name<br/>        self.email = email<br/>        self.created_at = dt.datetime.now()<br/><br/>    def __repr__(self):<br/>        return "&lt;User(name={self.name!r})&gt;".format(self=self)<br/><br/><br/>class UserSchema(Schema):<br/>    name = fields.Str(required=True)<br/>    email = fields.Email(required=True)<br/>    created_at = fields.DateTime()<br/><br/>    @post_load # So that when deserialising, you get UserData object<br/>    def make_user(self, data, **kwargs):<br/>        return UserData(**data)</span></pre><p id="1f74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">需要注意一些事情:</p><ol class=""><li id="7d32" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb lb jj jk jl bi translated">Marshmallow 定义了模型的模式，实际的 DTO 模型是 UserData。Marshmallow 允许您对字段进行验证，我们将为<code class="du ki kj kk kl b">name</code>字段添加一个自定义验证器。</li><li id="662d" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lb jj jk jl bi translated">您可以使用<code class="du ki kj kk kl b">dumps</code>和<code class="du ki kj kk kl b">load</code>方法来反序列化为 JSON 字符串，并从 JSON 字符串序列化。但是，为了在我们的控制器中使用它，我们将只直接使用<code class="du ki kj kk kl b">load</code>方法，并将使用<code class="du ki kj kk kl b">flask-apispec</code>库来发送响应。</li></ol><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="168a" class="ku kv hh kl b fi kw kx l ky kz">from flask import jsonify, Blueprint, request<br/>from flask.views import MethodView<br/>from flask_apispec import marshal_with<br/>from app.dto.user import UserSchema</span><span id="47b2" class="ku kv hh kl b fi la kx l ky kz">user_blueprint = Blueprint("users_api", __name__)<br/><br/>user_schema = UserSchema()<br/><br/><br/>class UserController(MethodView):</span><span id="8b2f" class="ku kv hh kl b fi la kx l ky kz">    #...</span><span id="4f55" class="ku kv hh kl b fi la kx l ky kz">    @marshal_with(user_schema)<br/>    def post(self):<br/>        user_data = user_schema.load(request.get_json())<br/>        return user_data<br/><br/><br/>user_view = UserController.as_view("api")<br/>...<br/>user_blueprint.add_url_rule("/api/v1/users", view_func=user_view, methods=["POST"])</span></pre><p id="73da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，你的一个测试应该通过了，当你的请求中有无效数据时，一个测试会失败，但是它实际上给出了 500 个响应，而不是 400 个。</p><p id="54f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，我们需要解决这个问题。</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="67ab" class="ku kv hh kl b fi kw kx l ky kz">def validate_with(schema: Schema):<br/>    req_json = request.get_json()<br/>    errors = schema.validate(req_json)<br/>    if errors:<br/>        resp = make_response(jsonify(errors), 400)<br/>        abort(resp)</span></pre><p id="b745" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以看到目前为止的代码- <a class="ae kh" href="https://github.com/trexsatya/sample-flask-app/tree/Step_3" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="1f10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们开始添加数据库。</p><p id="85ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，添加一个测试</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="b979" class="ku kv hh kl b fi kw kx l ky kz">def test_that_user_is_saved_to_database_after_creation(self, testapp, db):<br/>    response = testapp.post_json("/api/v1/users", {"name": "ivhas", "email": "abc@mail.com"}, status="*")<br/>    assert len(db.session.query(User).all()) == 1</span></pre><p id="3342" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，<code class="du ki kj kk kl b">db</code>就像 app 一样是一个固定物。我们需要配置它，我们还需要将它连接到 Flask app。我们将使用<a class="ae kh" href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/" rel="noopener ugc nofollow" target="_blank">flasksqlanchy</a>进行<a class="ae kh" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank">对象关系映射</a>(这样您就可以在代码中将 DB 表视为对象，<em class="jc">这主要是因为应用程序开发人员不想处理 SQL 代码</em>)。</p><p id="23cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将进入<code class="du ki kj kk kl b">conftest.py</code>文件</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="add4" class="ku kv hh kl b fi kw kx l ky kz">@pytest.fixture(scope="function")<br/>def db(app):<br/>    # By this fixture, we'll have a clean DB for each test method.<br/>    database.app = app<br/>    with app.app_context():<br/>        database.create_all()<br/><br/>    yield database<br/><br/>    database.session.close()<br/>    database.drop_all()</span></pre><p id="6fa9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里使用的<code class="du ki kj kk kl b">database</code>将是一个全局对象，它将绑定到我们在<code class="du ki kj kk kl b">create_app</code>函数中的应用程序，并且它还将绑定到所有的实体模型(在数据库中表示我们的表的类)。</p><p id="3e63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，把这段代码放在 app 文件夹的某个地方，我已经把它放在一个新的文件里<code class="du ki kj kk kl b">app/extensions.py</code></p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="e248" class="ku kv hh kl b fi kw kx l ky kz">database = SQLAlchemy(model_class=CRUDMixin)</span></pre><p id="3954" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">CRUDMixin</code>是一个实用程序类，为了简单起见，它可以使用<a class="ae kh" href="https://en.wikipedia.org/wiki/Active_record_pattern" rel="noopener ugc nofollow" target="_blank">活动记录</a>模式。</p><p id="c153" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的实体模型很简单:<code class="du ki kj kk kl b">app/entities/user.py</code></p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="a2b7" class="ku kv hh kl b fi kw kx l ky kz">from sqlalchemy import String, Integer<br/>import datetime as dt<br/>from app.extensions import database<br/><br/><br/>class User(database.Model):<br/>    __tablename__ = "users"<br/>    id = database.Column(Integer, primary_key=True)<br/>    name = database.Column(String(10), nullable=False)<br/>    email = database.Column(String(50), nullable=False)<br/><br/>    created_at = database.Column(database.DateTime, nullable=False, default=dt.datetime.utcnow)<br/>    updated_at = database.Column(database.DateTime, nullable=False, default=dt.datetime.utcnow)<br/><br/>    def __init__(self, **kwargs):<br/>        database.Model.__init__(self, **kwargs)</span></pre><p id="1703" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还有，你需要设置<code class="du ki kj kk kl b">SQLALCHEMY_DATABASE_URI = ‘sqlite://’</code> conftest.py 文件，<code class="du ki kj kk kl b">TestConfig</code>类。这意味着我们将使用内存中的<a class="ae kh" href="https://www.sqlite.org/index.html" rel="noopener ugc nofollow" target="_blank"> SQLite </a>数据库进行测试。</p><p id="9c43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">看到目前为止的代码— <a class="ae kh" href="https://github.com/trexsatya/sample-flask-app/tree/Step_4" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="1a09" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jy translated">第五件事:服务、事务和依赖注入</p><p id="cc69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基本上，服务充当控制器和数据库之间的中介。它们用于将一些相关的事情组合在一起，例如，创建新用户时应该发生的所有事情。他们还负责交易。<em class="jc">(事务是指一堆事情，要么全部成功，要么都不生效)</em>。</p><p id="b430" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，让我们将用户创建代码重构为一个单独的类<code class="du ki kj kk kl b">UserService</code></p><p id="b723" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">app/services/user.py</code></p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="f834" class="ku kv hh kl b fi kw kx l ky kz">from app.dto.user import UserData<br/>from app.entities.user import User<br/><br/><br/>class UserService:<br/>    def __init__(self):<br/>        pass<br/><br/>    def create_user(self, user_data: UserData):<br/>        user = User(name=user_data.name, email=user_data.email).save()<br/><br/>        return user</span></pre><p id="8df6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们需要另一个库来进行平滑的依赖注入:<code class="du ki kj kk kl b">Flask-Injector</code></p><p id="8e06" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这之后，我们需要配置哪些类/对象将由依赖注入来管理。更改<code class="du ki kj kk kl b">create_app</code>功能:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="a7a5" class="ku kv hh kl b fi kw kx l ky kz"><strong class="kl hi">from flask_injector import FlaskInjector<br/>from injector import singleton</strong></span><span id="7832" class="ku kv hh kl b fi la kx l ky kz">def create_app(config_object):<br/>    _app = Flask(__name__.split(".")[0])<br/>    _app.config.from_object(config_object)<br/>    _app.register_blueprint(user_blueprint)<br/><br/>    <strong class="kl hi">def configure_di(binder):<br/>        binder.bind(ExternalService, to=ExternalService, scope=singleton)<br/>        binder.bind(UserService, to=UserService, scope=singleton)</strong><br/><br/><strong class="kl hi">    FlaskInjector(app=_app, modules=[configure_di])</strong><br/>    database.init_app(_app)<br/><br/>    return _app</span></pre><p id="2eea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我创建 ExternalService 只是为了演示，它可以是用户服务使用的任何服务，例如进行 API 调用。</p><p id="f4fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们需要在任何需要的地方注入 服务。首先，UserController 中需要 UserService</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="7290" class="ku kv hh kl b fi kw kx l ky kz"><strong class="kl hi">from injector import inject</strong><br/>class UserController(MethodView):<br/><strong class="kl hi">    @inject</strong><br/>    <strong class="kl hi">def __init__(self, user_service: UserService):<br/>        self.user_service = user_service</strong></span><span id="85fd" class="ku kv hh kl b fi la kx l ky kz">    @marshal_with(user_schema)<br/>    def post(self):<br/>        validate_with(user_schema)<br/>        user_data: UserData = user_schema.load(request.get_json())<br/><strong class="kl hi">        user = self.user_service.create_user(user_data)</strong><br/>        return user</span></pre><p id="7957" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行<code class="du ki kj kk kl b">pytest</code>所有测试都应通过。所有的功能都是一样的。</p><p id="db8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们设置事务。对于这里的演示，我们将在创建用户时调用 ExternalService，如果该调用失败，则不应创建用户，因为事务意味着<em class="jc">“要么事务下的每个任务都成功，要么都不成功”</em>。所以，让我们写一个测试</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="2898" class="ku kv hh kl b fi kw kx l ky kz">def test_that_user_is_not_saved_to_database_if_transaction_fails(self, testapp, db, monkeypatch):<br/>    def mock_call():<br/>        raise Exception("Unknown")<br/>    monkeypatch.setattr(ExternalService, "call", mock_call)<br/>    response = testapp.post_json("/api/v1/users", {"name": "ivhas", "email": "abc@mail.com"}, status="*")<br/>    assert len(db.session.query(User).all()) == 0, "Shouldn't have been saved!"</span></pre><p id="fb66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们使用 pyests <code class="du ki kj kk kl b">monkeypatch</code>来代替对 ExternalService 的实际调用，这个<code class="du ki kj kk kl b">mock_call</code>函数将被调用，我们可以在测试本身中控制它。运行测试，这个应该会失败。</p><p id="1e3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了使用事务，我们将使用另一个名为<code class="du ki kj kk kl b">transaction</code>和<code class="du ki kj kk kl b">zope.sqlalchemy</code>的库(注意:zope 来自<a class="ae kh" href="http://www.zodb.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> ZODB </a>，但它实际上对它的依赖性很小，可以在我们的应用程序中不使用 ZODB 而使用)。</p><p id="2b3b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">transaction</code> package 提供了一种方法，可以用来将我们的 SQLAlchemy 数据库会话绑定到它的事务管理器。</p><p id="adaf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<code class="du ki kj kk kl b">app/extensions.py</code>文件中:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="d858" class="ku kv hh kl b fi kw kx l ky kz">register(database.session)</span></pre><p id="c818" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另外，用户服务中的<code class="du ki kj kk kl b">create_user</code>函数变成:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="c064" class="ku kv hh kl b fi kw kx l ky kz">def create_user(self, user_data: UserData):<br/>    <strong class="kl hi">transaction.begin()</strong><br/>    user = User(name=user_data.name, email=user_data.email).save(<strong class="kl hi">commit=False</strong>)<br/>    self.external_service.call()<br/><strong class="kl hi">    transaction.commit()</strong><br/>    return user</span></pre><p id="7fef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们还需要一件事，当一些异常发生时，我们需要中止事务。为了简单起见，我们将使用 Flask 在请求级别处理它。也就是说，我们将向我们的应用程序注册一个错误处理程序，并在那里中止事务。<em class="jc">(注:可能有更复杂的方式，对交易有更复杂的要求)</em></p><p id="4853" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的<code class="du ki kj kk kl b">app/main.py</code>文件中添加这个:-(如果出现意外情况，这个函数也会导致应用程序返回 JSON 错误消息作为响应)</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="df85" class="ku kv hh kl b fi kw kx l ky kz">def generic_error_handler(exception):<br/>    <em class="jc">"""<br/>    This will handle all uncaught exceptions while Flask is processing a request.<br/>    </em><strong class="kl hi"><em class="jc">:param</em></strong><em class="jc"> exception:<br/>    </em><strong class="kl hi"><em class="jc">:return</em></strong><em class="jc">:<br/>    """<br/></em><br/><strong class="kl hi">    transaction.abort()</strong><br/>    trace = "\n".join(traceback.format_exception(etype=type(exception), value=exception, tb=exception.__traceback__))<br/>    print(trace)<br/>    return {"message": "Error"}, 500</span></pre><p id="057f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并在<code class="du ki kj kk kl b">create_app</code>功能中添加:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="cff4" class="ku kv hh kl b fi kw kx l ky kz">_app.errorhandler(Exception)(generic_error_handler)</span></pre><p id="2499" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就是这样。现在，如果你运行<code class="du ki kj kk kl b">pytest</code>，所有的测试都应该通过。</p><p id="96d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:这一行在<code class="du ki kj kk kl b">app/extensions.py</code>文件中也发生了变化，因此在<code class="du ki kj kk kl b">Session.commit()</code>操作之后，会话中的对象不会<a class="ae kh" href="https://docs.sqlalchemy.org/en/13/glossary.html#term-expired" rel="noopener ugc nofollow" target="_blank">过期</a>，如果随后访问它们的属性，就会导致延迟加载。</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="a7bb" class="ku kv hh kl b fi kw kx l ky kz">database = SQLAlchemy(model_class=CRUDMixin, <strong class="kl hi">session_options={"expire_on_commit": False}</strong>)</span></pre><p id="1efe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">看到目前为止的代码— <a class="ae kh" href="https://github.com/trexsatya/sample-flask-app/tree/Step_5" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><p id="a67d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jy translated">第九件事:建立实际的应用程序，并创建一个可部署的 Docker 映像。</p><p id="6efd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我们将在这一部分实现的内容列表:-</p><ol class=""><li id="c008" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb lb jj jk jl bi translated">使应用程序可运行，这样你就可以从浏览器、终端(使用 curl 等)访问它</li><li id="1144" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lb jj jk jl bi translated">将应用程序连接到一个真实的数据库(目前是 MySQL)</li><li id="0954" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lb jj jk jl bi translated">使应用程序可部署。</li></ol><p id="4a4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了使应用程序可运行，我们需要使用<code class="du ki kj kk kl b">create_app</code>函数创建一个应用程序实例。我们在一个新文件<code class="du ki kj kk kl b">&lt;project_root&gt;/autoapp.py</code>中这样做，并把它放在那里:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="938e" class="ku kv hh kl b fi kw kx l ky kz">from flask.helpers import get_debug_flag<br/><br/>from app.configs import DevConfig, ProdConfig<br/>from app.main import create_app<br/><br/>CONFIG = DevConfig if get_debug_flag() else ProdConfig<br/><br/>app = create_app(CONFIG)</span></pre><p id="6f1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，我们还需要在一个新文件<code class="du ki kj kk kl b">app/configs.py</code>中创建单独的配置对象</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="5052" class="ku kv hh kl b fi kw kx l ky kz">import os<br/><br/>from dotenv import load_dotenv<br/><br/>load_dotenv()<br/># This will load .env file containing environment variables<br/><br/><br/>class Config(object):<br/>    <em class="jc">"""Base Configuration"""<br/>    </em>APP_DIR = os.path.abspath(os.path.dirname(__file__))  # This directory<br/>    PROJECT_ROOT = os.path.abspath(os.path.join(APP_DIR, os.pardir))<br/><br/><br/>class ProdConfig(Config):<br/>    ENV = 'prod'<br/>    DEBUG = False<br/>    SQLALCHEMY_DATABASE_URI = os.getenv("DB_URL")<br/><br/><br/>class DevConfig(Config):<br/>    ENV = 'dev'<br/>    DEBUG = True<br/>    DB_NAME = 'dev.db'<br/>    DB_PATH = os.path.join(Config.PROJECT_ROOT, DB_NAME)<br/>    SQLALCHEMY_DATABASE_URI = os.getenv('DB_URL',<br/>                                        'sqlite:///{0}'.format(DB_PATH)  # default<br/>                                        )</span></pre><p id="fb7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们已经使用<a class="ae kh" href="https://github.com/theskumar/python-dotenv" rel="noopener ugc nofollow" target="_blank"> Python-dotenv </a>将所有环境变量放在一个名为<code class="du ki kj kk kl b">.env</code>的文件中</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="caf4" class="ku kv hh kl b fi kw kx l ky kz">DB_URL=mysql+mysqlconnector://user:password@localhost:3306/db</span></pre><p id="006d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，可以使用以下命令启动该应用程序</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="13c3" class="ku kv hh kl b fi kw kx l ky kz">export FLASK_APP=./autoapp.py<br/>flask run</span></pre><p id="5b11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以尝试访问网址，你应该看到错误。我们还没有建立数据库。</p><p id="2d46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在你的系统上安装 mysql，并创建一个名为<code class="du ki kj kk kl b">db</code>的数据库，但是现在我们将使用 MySQL 的 docker 镜像。</p><p id="18a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在项目根目录下创建一个文件【T5:】</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="5eba" class="ku kv hh kl b fi kw kx l ky kz">version: "3"<br/><br/>networks:<br/>  backend:<br/>    driver: bridge<br/><br/>volumes:<br/>  my-db:<br/><br/>services:<br/>  mysql:<br/>    image: mysql:8.0.22<br/>    container_name: mydb<br/>    ports:<br/>      - "3306:3306"<br/>    environment:<br/>      MYSQL_DATABASE: 'db'<br/>      <em class="jc"># So you don't have to use root, but you can if you like<br/>      </em>MYSQL_USER: 'user'<br/>      <em class="jc"># You can use whatever password you like<br/>      </em>MYSQL_PASSWORD: 'password'<br/>      <em class="jc"># Password for root access<br/>      </em>MYSQL_ROOT_PASSWORD: 'password'<br/>    networks:<br/>      - backend<br/>    expose:<br/>      - '3306'<br/>    volumes:<br/>      - my-db:/var/lib/mysql</span></pre><p id="ca8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您需要在系统上安装<a class="ae kh" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"> DockerCompose </a>。</p><p id="462f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行命令<code class="du ki kj kk kl b">docker-compose up</code>它将从 DockerHub 下载 MySQL 的 docker 镜像并创建一个容器(这意味着镜像被启动/启动)。现在你有了一个我们的应用程序可以访问的数据库。</p><p id="1b17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，如果您再次运行应用程序并尝试访问 API，它仍然会抛出一个错误，因为我们仍然没有在数据库中创建表。</p><p id="8f77" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，我们将使用另一个库<a class="ae kh" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"> Flask-Migrate </a></p><p id="94f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它需要一个关键的改变(除了将它添加到 requirements/production.txt 文件中):-</p><p id="cedc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要创建一个迁移对象，并将其连接到我们的应用程序和数据库。</p><p id="dfc2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，先把这一行加到<code class="du ki kj kk kl b">app/extensions.py</code></p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="f78b" class="ku kv hh kl b fi kw kx l ky kz">migrate = Migrate()</span></pre><p id="1a72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，将这一行添加到<code class="du ki kj kk kl b">create_app</code>函数中:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="f404" class="ku kv hh kl b fi kw kx l ky kz">migrate.init_app(_app, db=database)</span></pre><p id="4ff6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们必须使用这个迁移框架在数据库中创建表。运行以下命令:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="d1db" class="ku kv hh kl b fi kw kx l ky kz">flask db init<br/>flask db migrate<br/>flask db upgrade</span></pre><p id="65fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个命令创建迁移所需的文件(在项目目录中)。</p><p id="4588" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个命令检测应用程序中关于表的更改，并创建一个迁移脚本文件。该文件的名称将是随机散列。</p><p id="c92a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第三个命令将迁移脚本应用于数据库，并创建/修改表等。</p><p id="96a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(注意:此框架的自动检测并不是 100%可靠的，因此请确保验证生成的迁移脚本文件中的更改。第一次没有必要检查，除非你想定制)</p><p id="a30d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，如果您重新运行应用程序，一切都应该工作正常。</p><p id="30e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们需要将应用程序部署为 docker 映像。</p><p id="83d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在项目目录中创建一个名为<code class="du ki kj kk kl b">Dockerfile</code>的文件:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="62a4" class="ku kv hh kl b fi kw kx l ky kz">FROM python:3.8-slim-buster<br/># This will serve as base image on which other things can be added via commands, basically you get a lightweight operating system with Python installed on it<br/><br/>WORKDIR /src<br/>#sets the working directory for any RUN, CMD, ENTRYPOINT, COPY and ADD instructions, a src folder will be created in docker image<br/><br/>ARG <em class="jc">BUILD_ENV<br/></em>ENV <em class="jc">FLASK_ENV </em>$<em class="jc">BUILD_ENV<br/></em>ENV <em class="jc">FLASK_APP </em>autoapp.py<br/><br/>#RUN mkdir requirements<br/><br/>COPY app/ ./app<br/>COPY autoapp.py .<br/>COPY requirements/ ./requirements<br/>COPY run_tests.sh .<br/># Copy required source code<br/>COPY tests ./tests<br/><br/>RUN ls .<br/># just for debugging to see what's ther in the WORKDIR<br/><br/>RUN if [ "$<em class="jc">BUILD_ENV</em>" = "test" ]; then pip install -r requirements/development.txt ; fi<br/>RUN if [ "$<em class="jc">BUILD_ENV</em>" = "test" ]; then export FLASK_DEBUG=true ; fi<br/>RUN if [ "$<em class="jc">BUILD_ENV</em>" != "test" ]; then pip install -r requirements/production.txt ; fi<br/><br/>RUN chmod 777 run_tests.sh<br/>RUN ./run_tests.sh<br/>ENTRYPOINT flask run<br/><br/><br/># A brief about RUN, CMD, and ENTRYPOINT<br/># Use RUN to do the installation, making changes etc<br/># Use ENTRYPOINT to run a command used to start the service<br/># Use CMD to pass arguments to that command, they get appended automatically; You can override CMD while running docker image.</span></pre><p id="f8b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你在理解 docker file<a class="ae kh" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">时遇到困难，访问官方网站，文档是很好的选择。</a></p><p id="2941" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，将以下内容添加到我们之前创建的<code class="du ki kj kk kl b">docker-compose</code>文件中:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="e3a2" class="ku kv hh kl b fi kw kx l ky kz">flask_app:<br/>    build:<br/>      dockerfile: Dockerfile<br/>      context: .<br/>      args:<br/>        BUILD_ENV: $BUILD_ENV<em class="jc"><br/>    </em>container_name: flask_app<br/>    expose:<br/>      - '5000'<br/>    environment:<br/>      - FLASK_DEBUG=$FLASK_DEBUG<br/>      - DB_URL=$DB_URL<br/>    ports:<br/>      - "5000:5000"<br/>    network_mode: bridge</span></pre><p id="2676" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">取消之前运行的命令，并再次运行 compose 命令:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="da97" class="ku kv hh kl b fi kw kx l ky kz">BUILD_ENV=test docker-compose up --build</span></pre><p id="152f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">注意:从浏览器或 Mac 终端访问 docker 中运行的应用程序可能会遇到困难。我还是没想出问题。</em></p><p id="ea7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用上面的命令为你的应用程序创建一个 docker 镜像，并标记为<code class="du ki kj kk kl b">latest</code>，你可以使用下面的命令查看它</p><p id="617f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">docker images</code></p><p id="25b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以将该映像推送到某个存储库(例如 Docker Hub)，然后在任何服务器(例如另一台机器或 Google Cloud 中的一台虚拟机器)上将其拉回，然后使用 docker compose 运行该应用程序。</p><p id="68fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了<a class="ae kh" href="https://docs.docker.com/engine/reference/commandline/push/" rel="noopener ugc nofollow" target="_blank">将图像推送到 Docker Hub </a></p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="f9df" class="ku kv hh kl b fi kw kx l ky kz">docker push sample-flask-project_flask_app:latest</span></pre><p id="d0ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，在你想运行的服务器上，你只需要复制<code class="du ki kj kk kl b">docker-compose</code>文件并注释掉 flask_app 的<code class="du ki kj kk kl b">build</code>部分，这里是完整的<code class="du ki kj kk kl b">docker-compose.yml</code>文件</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="dd34" class="ku kv hh kl b fi kw kx l ky kz">version: "3"<br/><br/>networks:<br/>  backend:<br/>    driver: bridge<br/><br/>volumes:<br/>  my-db:<br/><br/>services:<br/>  mysql:<br/>    image: mysql:8.0.22<br/>    container_name: mydb<br/>    ports:<br/>      - "3306:3306"<br/>    environment:<br/>      MYSQL_DATABASE: 'db'<br/>      <em class="jc"># So you don't have to use root, but you can if you like<br/>      </em>MYSQL_USER: 'user'<br/>      <em class="jc"># You can use whatever password you like<br/>      </em>MYSQL_PASSWORD: 'password'<br/>      <em class="jc"># Password for root access<br/>      </em>MYSQL_ROOT_PASSWORD: 'password'<br/>    networks:<br/>      - backend<br/>    expose:<br/>      - '3306'<br/>    volumes:<br/>      - my-db:/var/lib/mysql<br/><br/>  flask_app:<br/><em class="jc">#    build:<br/>#      dockerfile: Dockerfile<br/>#      context: .<br/>#      args:<br/>#        BUILD_ENV: $BUILD_ENV<br/>    </em><strong class="kl hi">image: sample-flask-project_flask_app:latest</strong><br/>    container_name: flask_app<br/>    expose:<br/>      - '5000'<br/>    environment:<br/>      - FLASK_DEBUG=$FLASK_DEBUG<br/>      - DB_URL=$DB_URL<br/>    ports:<br/>      - "5000:5000"<br/>    network_mode: bridge</span></pre><p id="cbd6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后你只需要运行命令<code class="du ki kj kk kl b">docker-compose up -d</code></p><p id="079e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(-d 表示它将作为守护进程在后台运行)。</p><p id="7e92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下是您可能会用到的有用的 docker 命令列表:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="daec" class="ku kv hh kl b fi kw kx l ky kz"># To see all the images on your system <br/>docker images</span><span id="9a5d" class="ku kv hh kl b fi la kx l ky kz"># To build the images (if a build config is specified in docker-compose.yml)<br/>docker-compose build --no-cache</span><span id="0f11" class="ku kv hh kl b fi la kx l ky kz"># To login to a running container, let's say we wan to see our database in mysql container named 'mydb'<br/>docker exec -it mydb /bin/bash<br/># then you can run mysql command i.e mysql -u user -p</span></pre><p id="3b53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae kh" href="https://github.com/trexsatya/sample-flask-app/tree/Step_6" rel="noopener ugc nofollow" target="_blank">这是目前为止的完整代码</a>。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><p id="91f5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jy translated"><span class="l jz ka kb bm kc kd ke kf kg di">第一个</span>现在<strong class="ig hi">安全</strong></p><p id="b491" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以我们几乎完成了 flask 应用程序的基本设置。</p><p id="072e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还剩下什么？</p><ol class=""><li id="6c95" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb lb jj jk jl bi translated">缓存。但是在 flask app 中添加缓存相当简单，内置了对 Memcache、simple cache、Redis cache 的支持。</li><li id="c2d7" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lb jj jk jl bi translated">部署等基础设施。CI/CD 设置。但这对 Flask 应用程序来说是不可知的。</li><li id="283d" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb lb jj jk jl bi translated">一个重要的东西:安全。</li></ol><p id="969f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了保护应用程序代码中的应用程序，我们需要设置身份验证和授权。</p><p id="01f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将使用另一个库名<code class="du ki kj kk kl b">Flask-HTTPAuth</code>进行认证。该库支持基本身份验证、基于摘要的身份验证和基于令牌的身份验证。还有另外一个库名叫做<strong class="ig hi"> flask_jwt_extended </strong>专门用于基于令牌的 auth，实际上有很多选项(见这里的<a class="ae kh" href="https://testdriven.io/blog/web-authentication-methods/" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="3237" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的自定义身份验证方案是基于社交登录的(目前只有 google 支持)，它是这样工作的:- <br/> 1。你从 google 获得访问令牌(<em class="jc">这可以很容易地通过在 UI 端集成 Google</em>)<br/>2。访问令牌被发送到我们的应用程序进行注册，或登录到应用程序。</p><p id="d734" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的应用程序验证令牌，然后创建自己的访问令牌，在用户登录时返回给用户。那么这个访问令牌必须作为访问 API 的承载令牌在报头中传递。</p><p id="44ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，首先让我们通过使 API 要求认证来保护它们。</p><p id="60d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">user_controller.py</code>文件的变化:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="fb06" class="ku kv hh kl b fi kw kx l ky kz"><strong class="kl hi">@auth.login_required()</strong><br/>def get(self, user_id):<br/>    .....</span><span id="2e1d" class="ku kv hh kl b fi la kx l ky kz"><strong class="kl hi">@auth.login_required(role="admin")</strong><br/>def post(self):<br/>    .....</span></pre><p id="56ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里的<code class="du ki kj kk kl b">auth</code>是我们在</p><p id="49f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">app/extensions.py</code></p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="e987" class="ku kv hh kl b fi kw kx l ky kz"><strong class="kl hi">...</strong></span><span id="4e4f" class="ku kv hh kl b fi la kx l ky kz"><strong class="kl hi">auth = HTTPTokenAuth('Bearer')</strong></span></pre><p id="ffa8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们需要为这个库提供一个函数，它可以验证请求头中的传入令牌。</p><p id="215f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在一个新的文件<code class="du ki kj kk kl b">app/services/auth_service.py</code>中这样做:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="9cd4" class="ku kv hh kl b fi kw kx l ky kz">from flask import request<br/><br/>from app.entities.user import User<br/>from itsdangerous import TimedJSONWebSignatureSerializer as Serializer<br/>import os<br/>from datetime import timedelta<br/><br/>from app.extensions import auth<br/><br/>token_serializer = Serializer(os.getenv("SECRET_KEY"), expires_in=3600, algorithm_name="HS256")<br/><br/><br/>class AuthService:<br/>    @staticmethod<br/>    def verify_token(token):<br/>        try:<br/>            data = token_serializer.loads(token)<br/>        except Exception as e:  <br/>            print("verify_token():", token, e, request.headers)<br/>            return False<br/>        return data<br/><br/>    @staticmethod<br/>    def create_token(user: User):<br/>        payload = {"email": user.email, "name": user.name, "roles": ["user"]}<br/>        print("payload", payload)<br/>        return token_serializer.dumps(payload).decode('utf-8')<br/><br/><br/>@auth.verify_token<br/>def verify_token(token):<br/>    return AuthService.verify_token(token)<br/><br/><br/>@auth.get_user_roles<br/>def get_user_roles(user):<br/>    print("get_user_roles", user)<br/>    return user["roles"]</span></pre><p id="5edd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">verify_token</code>在调用处理程序方法之前，函数将在每个请求上被自动调用。</p><p id="c2ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果向<code class="du ki kj kk kl b">@auth.login_required</code>传递了名为<code class="du ki kj kk kl b">role</code>的参数，将自动调用<code class="du ki kj kk kl b">get_user_roles</code>。我们已经在<code class="du ki kj kk kl b">post</code>方法的<code class="du ki kj kk kl b">user_controller.py</code>文件中完成了这项工作(现在创建用户，需要管理员角色)。<em class="jc">(注意:代码中的角色已经静态分配)</em></p><p id="8a13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，如果您运行测试，它们应该会由于 401 响应而失败。</p><p id="0820" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来的步骤是相应地修改测试，并为登录和注册编写一个控制器。</p><p id="5bef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">增加安全性的另一个步骤是增加对 CORS 的限制。</p><p id="efdd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更改<code class="du ki kj kk kl b">app/configs.py</code>文件中的配置类:-</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="89ca" class="ku kv hh kl b fi kw kx l ky kz">class Config(object):<br/>    <em class="jc">"""Base Configuration"""<br/>    </em>APP_DIR = os.path.abspath(os.path.dirname(__file__))  # This directory<br/>    PROJECT_ROOT = os.path.abspath(os.path.join(APP_DIR, os.pardir))<br/>    <strong class="kl hi">CORS_ORIGIN_WHITELIST = [<br/>        'http://0.0.0.0:4100',<br/>        'http://localhost:4100',<br/>        'http://0.0.0.0:8000',<br/>        'http://localhost:8000',<br/>        'http://0.0.0.0:4200',<br/>        'http://localhost:4200',<br/>        'http://0.0.0.0:4000',<br/>        'http://localhost:4000',<br/>    ]</strong></span></pre><p id="bdc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">看到目前为止的代码— <a class="ae kh" href="https://github.com/trexsatya/sample-flask-app/tree/Step_6" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="6382" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">认证/安全部分已经完成。</p></div><div class="ab cl jr js go jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ha hb hc hd he"><p id="5864" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在还剩下什么？</p><p id="1d63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对弗拉斯克来说没什么。如果我们谈论一个项目设置，当然还有代码质量的实现/改进、CI/CD 的基础设施设置(可以在 pipeline 本身中添加对库进行漏洞检查的步骤)、架构模式、更多功能等等。</p><p id="0a3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还可以改进 REST 的实现(我们也可以为 REST 实现<a class="ae kh" href="https://en.wikipedia.org/wiki/HATEOAS" rel="noopener ugc nofollow" target="_blank"> HATEOAS </a>)。有一个名为<a class="ae kh" href="https://github.com/python-restx/flask-restx" rel="noopener ugc nofollow" target="_blank"> Flask-Restx </a>的库会有所帮助。</p><p id="6480" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">出于演示的目的，SQLAlchemy 和 ORM 缺少的一点就是建立关系，但这对于 SQLAlchemy 的 api 来说也很容易。</p><p id="7fc8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">剩下的一件小事是日志记录。Flask 默认提供了一个记录器:</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="ed30" class="ku kv hh kl b fi kw kx l ky kz">from flask import current_app<br/></span><span id="3fa5" class="ku kv hh kl b fi la kx l ky kz">....<br/>current_app.logger.info("log")</span></pre><p id="41c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一个小问题是单元测试(我们还没有编写任何复杂的单元)。Python 的<code class="du ki kj kk kl b"><a class="ae kh" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">Unittest</a></code>包(Python 附带的)非常丰富，也提供了模仿功能。</p><p id="ceff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于 Python 应用部署的一个主要问题是，在生产中我们必须使用<a class="ae kh" href="https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface" rel="noopener ugc nofollow" target="_blank"> WSGI 服务器</a>(基本上是将请求转发给 Python 框架的 web 服务器)。有几个选项包括 Nginx，Gunicorn，NginxUnit 等。</p></div></div>    
</body>
</html>