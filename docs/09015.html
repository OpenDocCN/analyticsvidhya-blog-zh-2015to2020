<html>
<head>
<title>Clustering Taxi Geolocation Data To Predict Location of Taxi Service Stations- Answering Important Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚类出租车地理位置数据以预测出租车服务站的位置-回答重要问题</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/clustering-taxi-geolocation-data-to-predict-location-of-taxi-service-stations-answering-important-82535ed9bf57?source=collection_archive---------13-----------------------#2020-08-22">https://medium.com/analytics-vidhya/clustering-taxi-geolocation-data-to-predict-location-of-taxi-service-stations-answering-important-82535ed9bf57?source=collection_archive---------13-----------------------#2020-08-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/7c7b573aa8e8c90b6d121c4181092eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ctTC6JP1Cjhg_4M4.png"/></div></div></figure><p id="6f60" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">问候大家，欢迎回来！！</p><p id="d15a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这是关于我的上一篇文章— <a class="ae jw" rel="noopener" href="/analytics-vidhya/clustering-taxi-geolocation-data-to-predict-location-of-taxi-service-stations-pt-1-2471303e0965">聚类出租车地理位置数据以预测出租车服务站的位置(Pt 1) </a>。</p><p id="376f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">你们中的一些人提出了我在上一篇文章中没有解决的重要问题。所以在这一篇里，我会尽力回答他们。</p><h1 id="1382" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">1.理解问题陈述:</h1><p id="d837" class="pw-post-body-paragraph iy iz hi ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hb bi translated">让我们考虑一下约翰内斯堡市。在这么大的城市跑出租车，应该有出租车服务站的接入。加油站建在哪里？嗯，我们已经可以访问出租车停靠站(出租车等待乘客的地方，例如在机场)的地理位置数据。</p><p id="364f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们需要分析他们的地理位置数据，以了解在哪里建立服务站，我们可以使用聚类来实现这一点。一种简单的方法是在每个集群的中心建立一个服务站，为属于该集群的每辆出租车提供服务。在我的上一篇文章中，我们了解了如何通过使用简单的 k-means 方法来实现这一点。</p><p id="7c3c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">有许多<strong class="ja hj">集群</strong>的模式。这里，我们选择了被认为是其中最简单的模型之一。尽管简单，<strong class="ja hj"> K-means </strong>在许多数据科学应用中广泛用于聚类，如果您需要从<strong class="ja hj">未标记的数据</strong>(这就是我们选择它的原因)<strong class="ja hj">中快速发现洞察力，这一点尤其有用。</strong></p><h1 id="2c28" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">2.什么是集群？</h1><p id="ef5a" class="pw-post-body-paragraph iy iz hi ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hb bi translated">聚类可以认为是最重要的<em class="la">无监督学习</em>问题；因此，和其他这类问题一样，它处理的是在一组未标记的数据中找到一个<em class="la">结构</em>。<br/>聚类的宽泛定义可以是<strong class="ja hj">“将对象组织成其成员在某些方面相似的组的过程”。</strong><br/><em class="la">群集</em>因此是它们之间“相似”并且与属于其他群集的对象“不相似”的对象的集合。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lb"><img src="../Images/aad3d8e924ad26828e9e512f5decc4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLMZ_2NCwCZDOTUZyCUKiw.png"/></div></div></figure><p id="7acd" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在这种情况下，我们很容易识别出数据可以分成的 4 个组；相似性标准是<em class="la">距离</em>:如果两个或多个对象根据给定的距离(在这种情况下是几何距离)“接近”，则它们属于同一个集群。这被称为<em class="la">基于距离的聚类</em>。</p><p id="9de3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">因此，聚类的目标是确定一组未标记数据中的内在分组。</p><p id="d1f9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">而如果你想详细研究聚类分析-<a class="ae jw" href="https://www.analyticsvidhya.com/blog/2016/11/an-introduction-to-clustering-and-different-methods-of-clustering/" rel="noopener ugc nofollow" target="_blank">https://www . analyticsvidhya . com/blog/2016/11/an-introduction-to-clustering-and-different-methods-of-clustering/</a></p><h1 id="9df7" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">3.为什么我们需要为我们的问题陈述创建集群？</h1><p id="3684" class="pw-post-body-paragraph iy iz hi ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hb bi translated">好吧。所以这将是一个漫长的过程。请务必打开我以前的文章作为参考。这可能会令人困惑。</p><p id="40bc" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在这一节我们将<strong class="ja hj"> <em class="la">测试</em> </strong>一个简单的聚类算法，看看它是如何工作的。您可以在“集群强度/性能指标”标题下找到这一点(在我以前的文章或 GitHub 中)。</p><p id="4418" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">你们中的一些人可能想知道为什么我们需要创建测试数据并在其上测试我们的聚类算法？嗯，首先，我们需要检查正在讨论的算法是否像我们希望的那样好，如果是的话，那么我们需要检查它的聚类强度。如果测试数据设法勾选了上面的两个复选框，那么我们就可以使用我们的原始数据集了。</p><p id="9dcd" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">因此，我们将从使用 scikit learn 的<a class="ae jw" href="https://machinelearningmastery.com/generate-test-datasets-python-scikit-learn/#:~:text=The%20make_blobs()%20function%20can,a%20host%20of%20other%20properties." rel="noopener ugc nofollow" target="_blank"> <strong class="ja hj"> make_blobs </strong> </a>函数创建测试数据开始。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lc"><img src="../Images/8ba286268839b9762cc74f20cc1d2915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ahEB9XFys9lekQNPsrws2g.png"/></div></div></figure><p id="80ec" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们现在将理解 make_blobs 函数的这些特性的含义</p><ol class=""><li id="8c23" class="ld le hi ja b jb jc jf jg jj lf jn lg jr lh jv li lj lk ll bi translated"><strong class="ja hj"> n_samples: <em class="la"> int 或 array-like，可选(默认=100) </em> </strong> <em class="la"> - </em>如果是 int，则为聚类间等分的点的总数。如果<strong class="ja hj">像数组</strong> ( <strong class="ja hj">是我们当前的情况</strong>)，序列的每个元素表示每个聚类的样本数。</li><li id="c02e" class="ld le hi ja b jb lm jf ln jj lo jn lp jr lq jv li lj lk ll bi translated"><strong class="ja hj"> n_features: <em class="la"> int，可选(默认值=2) </em> </strong> <em class="la"> - </em>每个样本的特征数。</li><li id="fa25" class="ld le hi ja b jb lm jf ln jj lo jn lp jr lq jv li lj lk ll bi translated"><strong class="ja hj"> centers: <em class="la"> int 或 shape 的数组[n_centers，n_features]，可选</em> </strong> <em class="la"> - </em>(默认=无)要生成的中心数，或固定的中心位置。如果 n_samples 是 int，centers 是 None，则生成 3 个中心。如果 n_samples 是类似数组的，则中心必须是零或长度等于 n_samples 长度的数组。</li><li id="db99" class="ld le hi ja b jb lm jf ln jj lo jn lp jr lq jv li lj lk ll bi translated"><strong class="ja hj"> cluster_std: <em class="la"> float 或序列 float，可选(默认值=1.0) </em> </strong> <em class="la"> - </em>聚类的标准差。</li><li id="488b" class="ld le hi ja b jb lm jf ln jj lo jn lp jr lq jv li lj lk ll bi translated"><strong class="ja hj"> random_state: <em class="la"> int，RandomState 实例，default = None</em></strong><em class="la">-</em>决定数据集创建的随机数生成。在多个函数调用之间传递一个 int 以获得可再现的输出。</li></ol><p id="b06e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">接下来，我们将散点图测试数据。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lr"><img src="../Images/fd075944348e9bb78b53262f3707912e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0eFYqoECahrx_EESj_DtQ.png"/></div></div></figure><p id="b852" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">LHS 上有四个定义明确的集群，RHS 上有四个，右侧的一个看起来像是两个集群的融合。这是一个问题。我们需要修理它。</p><ul class=""><li id="8345" class="ld le hi ja b jb jc jf jg jj lf jn lg jr lh jv ls lj lk ll bi translated">对于下一个片段，您将需要以下文件——“sample _ clusters . npy”和“sample_clusters_improved.npy”(来自<a class="ae jw" href="https://drive.google.com/drive/u/0/folders/1j31pTDkqjE3IK2fEunaUjUAzmjIy-hBF" rel="noopener ugc nofollow" target="_blank">数据集</a>)。</li></ul><p id="96b7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在，我们要做的是创建单独的聚类(以解决上述问题)，我们可以通过在“sample_clusters.npy”上运行<strong class="ja hj"> <em class="la">类预测</em> </strong>来完成。</p><p id="21f4" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">(<strong class="ja hj">类预测</strong>是一种监督学习方法，其中算法从具有已知<strong class="ja hj">类</strong>成员资格(训练集)的样本中学习，并建立<strong class="ja hj">预测</strong>规则来对新样本(测试集)进行分类)</p><p id="0375" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">然后通过分配颜色(col)来区分它们，这样我们就可以区分每个集群。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lt"><img src="../Images/7556c3f69c85ab645617ad55becba8f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KtSU9X8Kgd826cSU.png"/></div></div></figure><p id="6e0b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">输出-</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lu"><img src="../Images/1ca88f9a7f2d9e42117cbd4a683959ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/0*cj1TDgTcjIwrw2M7.png"/></div></figure><p id="e09a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">你对结果满意吗？很明显，它没有解决我们的半合并问题，但是我们可以区分一些集群，所以这是个好消息。我们可以做得更好。</p><p id="7c9f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们现在将检查“<strong class="ja hj">剪影得分</strong>”。我们知道，它是用来给聚类算法打分的。它将为聚类算法分配一个介于-1 和 1 之间的分数，分数越接近 1 越好。它检查单个群集与相对群集的中心相比有多好。</p><p id="604d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">0:表示聚类无关紧要，或者我们可以说聚类之间的距离不显著。</p><p id="e624" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">-1:表示以错误的方式分配簇。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lv"><img src="../Images/8d56a36ba05d5708fccda20b96ff915f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pImeQoJpKp-PT3Hr.png"/></div></div></figure><p id="246d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们得到了大约 0.66 的分数，这很好。同样，我们可以做得更好。</p><p id="8967" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">因此，为了改进，我们将使用上面使用的相同代码，但是在“sample_clusters_improved.npy”上运行类预测。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lw"><img src="../Images/230f8dc7b809e0db18b9e3e3eaa2f787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yn6eZUMf0qVDTE-u.png"/></div></div></figure><p id="690a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们得到一个类似这样的图:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lx"><img src="../Images/5516cf69de4fd5204d7eba5789725c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*aZ8f1x_IroSIeUvs.png"/></div></figure><p id="fe9c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">伙计们，现在怎么样了？我们不仅可以区分所有的簇，还可以区分重叠的簇。还有，剪影评分也提高了。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ly"><img src="../Images/79ef3c62e473fb46c9ae434fd9f3f9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/0*Qtep_EnVRDdr9O8N.png"/></div></figure><p id="c921" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们做到了！</p><p id="4a99" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">因为我们的聚类算法在测试数据中表现得非常好，所以我认为现在是时候看看它在我们的原始数据集上表现如何了。</p><h1 id="5a22" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">4.k 均值聚类:</h1><p id="b9b8" class="pw-post-body-paragraph iy iz hi ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hb bi translated">你会在我之前的文章(或者 GitHub)中的“K-means 集群”下找到这一节，在那里我们已经深入讨论了一切。</p><p id="345c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们已经在本文的第一部分讨论了为什么我们更喜欢使用 K-Means 进行聚类。</p><p id="dc08" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在，K 均值聚类的步骤。</p><ul class=""><li id="b907" class="ld le hi ja b jb jc jf jg jj lf jn lg jr lh jv ls lj lk ll bi translated"><strong class="ja hj">第一步:选择聚类数 k </strong></li></ul><p id="e9da" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">k-means 的第一步是选择聚类的数量 k(我们如何做，将在下一节解释)。</p><ul class=""><li id="e220" class="ld le hi ja b jb jc jf jg jj lf jn lg jr lh jv ls lj lk ll bi translated"><strong class="ja hj">第二步:从数据中随机选择 k 个点作为质心</strong></li></ul><p id="123b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">接下来，我们随机选择每个聚类的质心。假设我们想要 2 个集群，那么这里 k 等于 2。然后我们随机选择质心:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lz"><img src="../Images/c60f3b65c73071100a6411b8b3393f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/0*bSV9p2ZnoqZyGULK.png"/></div></figure><p id="5582" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这里，红色和绿色的圆圈代表这些集群的质心。</p><ul class=""><li id="e10b" class="ld le hi ja b jb jc jf jg jj lf jn lg jr lh jv ls lj lk ll bi translated"><strong class="ja hj">步骤 3:将所有点分配到最近的聚类质心</strong></li></ul><p id="e53d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">初始化质心后，我们将每个点分配给最近的聚类质心:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ma"><img src="../Images/9b8b2133951de305d368fcd57c43c04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/0*FEDa61kWmDZ-qbF-.png"/></div></figure><p id="f9bc" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">您可以看到，靠近红点的点被分配给红色簇，而靠近绿点的点被分配给绿色簇。</p><ul class=""><li id="3c47" class="ld le hi ja b jb jc jf jg jj lf jn lg jr lh jv ls lj lk ll bi translated"><strong class="ja hj">步骤 4:重新计算新形成的星团的质心</strong></li></ul><p id="5544" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在，一旦我们将所有的点分配给任何一个簇，下一步就是计算新形成的簇的质心:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es mb"><img src="../Images/97df9d9fd8fde649ba26f8ec51fba644.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/0*YKJ79MMJXUMOO90n.png"/></div></figure><p id="3971" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这里，红色和绿色的十字是新的质心。</p><ul class=""><li id="2b69" class="ld le hi ja b jb jc jf jg jj lf jn lg jr lh jv ls lj lk ll bi translated"><strong class="ja hj">步骤 5:重复步骤 3 和 4 </strong></li></ul><p id="7ec4" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="la">计算质心并基于所有点与质心的距离将所有点分配给聚类的步骤是单次迭代</em>。但是等等——我们什么时候应该停止这个过程？它不能运行到永远，对不对？</p><h2 id="7ec3" class="mc jy hi bd jz md me mf kd mg mh mi kh jj mj mk kl jn ml mm kp jr mn mo kt mp bi translated">K-均值聚类的停止准则</h2><p id="9537" class="pw-post-body-paragraph iy iz hi ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hb bi translated">基本上有三个停止标准可以用来停止 K-means 算法:</p><ol class=""><li id="76b1" class="ld le hi ja b jb jc jf jg jj lf jn lg jr lh jv li lj lk ll bi translated">新形成的簇的质心不会改变</li><li id="ac5e" class="ld le hi ja b jb lm jf ln jj lo jn lp jr lq jv li lj lk ll bi translated">点保持在同一个群集中</li><li id="24b2" class="ld le hi ja b jb lm jf ln jj lo jn lp jr lq jv li lj lk ll bi translated">达到最大迭代次数</li></ol><p id="bafa" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">如果新形成的聚类的质心没有变化，我们可以停止该算法。即使在多次迭代之后，如果我们得到所有聚类的相同质心，我们可以说该算法没有学习任何新的模式，这是停止训练的标志。</p><p id="7099" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">另一个明显的迹象是，即使在多次迭代训练算法之后，如果这些点仍然在同一个聚类中，我们应该停止训练过程。</p><p id="39d3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">最后，如果达到最大迭代次数，我们可以停止训练。假设我们将迭代次数设为 100。该过程在停止之前将重复 100 次迭代。</p><h1 id="6693" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">5.我们如何决定迭代的次数？</h1><p id="ffc3" class="pw-post-body-paragraph iy iz hi ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hb bi translated">确定数据集中<strong class="ja hj">最优聚类数</strong>是划分聚类的一个基本问题，比如<a class="ae jw" href="https://www.datanovia.com/en/lessons/k-means-clustering-in-r-algorith-and-practical-examples/" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hj"> k-means 聚类</strong> </a>，需要用户指定要生成的聚类数 k。</p><p id="69ff" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">不幸的是，这个问题没有确定的答案。聚类的最佳数量在某种程度上是主观的，并且取决于用于测量相似性的方法和用于划分的参数。一个简单而流行的解决方案是检查使用<a class="ae jw" href="https://www.datanovia.com/en/lessons/agglomerative-hierarchical-clustering/" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hj">分层聚类</strong> </a>生成的树状图，看看它是否给出了特定数量的聚类。不幸的是，这种方法也是主观的。</p><p id="4d68" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">有一些方法包括直接方法和统计测试方法:</p><ol class=""><li id="eb08" class="ld le hi ja b jb jc jf jg jj lf jn lg jr lh jv li lj lk ll bi translated">直接方法:包括优化标准，如组内平方和或平均轮廓。相应的方法分别命名为<strong class="ja hj"> <em class="la">肘</em> </strong>和<strong class="ja hj"> <em class="la">剪影</em> </strong>方法。</li><li id="b704" class="ld le hi ja b jb lm jf ln jj lo jn lp jr lq jv li lj lk ll bi translated">统计测试方法:包括对比证据和无效假设。例如<strong class="ja hj"> <em class="la">缺口统计</em> </strong>。</li></ol><p id="25dc" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们将使用<strong class="ja hj"> <em class="la">剪影系数</em> </strong>的方法。这将在下一部分解释。</p><h1 id="567a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">6.K 均值聚类的分数验证:</h1><p id="d8d4" class="pw-post-body-paragraph iy iz hi ja b jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr kz jt ju jv hb bi translated">你可以在这里阅读所有这些-<a class="ae jw" href="https://towardsdatascience.com/silhouette-coefficient-validating-clustering-techniques-e976bb81d10c" rel="noopener" target="_blank">https://towards data science . com/silhouette-coefficient-validating-clustering-techniques-e 976 bb 81d 10c</a></p><p id="3049" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这是一个非常简单的方法。我不会给你密码。这是一个小作业。我们已经详细讨论了一切，你应该能够自己做这件事。</p><p id="197d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">根据我的结果，我可以推断 k=70 是聚类的理想值。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mq"><img src="../Images/80e746feb9a5b16861e923e5416f8c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLjdzWhqAb07q0dyXj7o_A.png"/></div></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="8ffc" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这就是本文的全部内容。我努力工作，尽我所能回答所有的问题。不过，如果你有任何问题，请随时询问。此外，请告诉我是否有我可以改进的地方。</p><p id="ff3b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在我的下一篇文章中，我们将通过使用一些先进的技术来改进我们目前的模型。这将是非常有趣的，相信我，一旦你理解了这一部分，你对这个项目的理解将完成一个完整的循环。</p><p id="1483" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">所以敬请关注，祝大家编码愉快！</p></div></div>    
</body>
</html>