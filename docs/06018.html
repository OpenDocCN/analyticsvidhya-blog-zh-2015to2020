<html>
<head>
<title>JavaScript Data Structure — Stack, Queue in detail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数据结构——详细的堆栈、队列</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/javascript-data-structure-stack-queue-in-detail-eba7c3762fdc?source=collection_archive---------24-----------------------#2020-05-08">https://medium.com/analytics-vidhya/javascript-data-structure-stack-queue-in-detail-eba7c3762fdc?source=collection_archive---------24-----------------------#2020-05-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a6b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">|与此同时，JavaScript在web技术领域取得了领先地位。所以，这是学习JavaScript和它的东西的最好时机。在学习了基本概念之后，你必须计划一些高级主题。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/df757f2aff648c3fc0b0a323ed86c7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8HiwTN6TehVtPmdg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">卢克·切瑟在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="598e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，让我们试着去理解一些高级的数据结构概念，比如堆栈和队列的细节。</p><h2 id="b335" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated"><strong class="ak">为什么需要数据结构？</strong></h2><p id="bcc6" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">数据就是一切。一些专家说，如果你有数据，你可能会领导世界。想象一下科技收益谷歌、脸书、亚马逊实际上引领着科技行业。原因是什么？事实上，他们有很多数据。</p><p id="0a2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，不知何故，你通过你的创业或类似的事情获得了大量的数据。这里，问题来了，你如何管理，整理，或存储你的数据？实际上，在这种情况下，计算机科学专家发明了数据结构概念，并且每天都在更新。所以，如果你想成为编程专家，这是一个必须学习的话题。</p><h2 id="d4c0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">堆</h2><p id="674b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">首先，很重要的一点是要知道，什么是栈？请看例子。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ku"><img src="../Images/de8f678c54a9f6f4fea855e84211337b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*4lmFab__SKumfRqzHdFYjw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图片:谷歌图片</figcaption></figure><p id="2d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，一些碗被放在一起，形成一堆。因此，在这种状态下，最后一个推入堆栈的项将是第一个被移除的项。这就是“堆栈”采用后进先出(<strong class="ih hj"> LIFO </strong>)机制的原因。最好的例子之一是网络浏览器中的后退按钮。您查看的每个页面都会添加到堆栈中，当您单击“后退”时，当前页面(最后添加的页面)会从堆栈中弹出。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kv"><img src="../Images/3904b78d7a6cbc9d8af566fbcd9a7751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FA49Ki0kH_hyDSXTKPhmzQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图片:<a class="ae jt" href="http://wikipedia.org/" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="7366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，让我们来关注一些编码的例子。从基本堆栈开始。做一个回文代码，基本上就是说像<em class="kw"> madam，</em> racecar一样的向前向后读。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/f57ae5875647c93ba2cf474a36e0e7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r79hdnPRPWH7v7NjgZKS4Q.png"/></div></div></figure><p id="e425" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看，我们有3个变量，比如空字符串的字母，单词和rword。在这段代码中，我们有两个for循环。首先，将单词变量放入字母数组中。现在，字母的值是<strong class="ih hj"> ['m '，' a '，' d '，' a '，' m'] </strong>。基本上，second for循环通过<strong class="ih hj"> pop </strong>方法使用“rword”变量反转单词。最后，我们只是条件性地检查了——它是不是回文？现在来看一个更深层次的堆栈示例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/e0a0dd365c53775ca5bbed6b3ac1ac4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*AurvaOtXJDuw2ZXsSk54IA.png"/></div></figure><p id="f053" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用JavaScript代码创建这个堆栈。我们必须创建一个函数，函数内部有push，pop，size，peek方法来执行堆栈。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="32d8" class="ju jv hi la b fi le lf l lg lh">let Stack = function() {<br/>    this.count = 0;<br/>    this.storage = {};<br/>}</span></pre><p id="537d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个“堆栈”函数体有两个局部变量，如count和storage。Count帮助遍历我们的堆栈，storage帮助我们在堆栈中存储数据。让我们在“堆栈”函数体中创建一个push函数。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="1147" class="ju jv hi la b fi le lf l lg lh">// Adds value to the end of the stack</span><span id="68ea" class="ju jv hi la b fi li lf l lg lh"><em class="kw">this</em>.push = function(<em class="kw">value</em>) {</span><span id="7cd5" class="ju jv hi la b fi li lf l lg lh"><em class="kw">    this</em>.storage[<em class="kw">this</em>.count] = <em class="kw">value</em>;</span><span id="e100" class="ju jv hi la b fi li lf l lg lh"><em class="kw">    this</em>.count++;</span><span id="8ecb" class="ju jv hi la b fi li lf l lg lh">}</span></pre><p id="5699" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“Push”函数将值添加到堆栈的末尾。在向堆栈添加值之后，count++表示我准备好存储下一个堆栈了。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="2c24" class="ju jv hi la b fi le lf l lg lh">// Removes and returns the value at the end of the stack</span><span id="1396" class="ju jv hi la b fi li lf l lg lh"><em class="kw">this</em>.pop = function(){</span><span id="a038" class="ju jv hi la b fi li lf l lg lh">    if(<em class="kw">this</em>.count === 0){</span><span id="36d6" class="ju jv hi la b fi li lf l lg lh">    return undefined;</span><span id="edcd" class="ju jv hi la b fi li lf l lg lh">}</span><span id="6221" class="ju jv hi la b fi li lf l lg lh"><em class="kw">this</em>.count--</span><span id="1aed" class="ju jv hi la b fi li lf l lg lh">let result = <em class="kw">this</em>.storage[<em class="kw">this</em>.count];</span><span id="d728" class="ju jv hi la b fi li lf l lg lh">delete <em class="kw">this</em>.storage[<em class="kw">this</em>.count];</span><span id="e272" class="ju jv hi la b fi li lf l lg lh"><em class="kw">console</em>.log(result);</span><span id="756c" class="ju jv hi la b fi li lf l lg lh">return result;</span><span id="8068" class="ju jv hi la b fi li lf l lg lh">}</span></pre><p id="2a92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初，当堆栈长度为“0”时，它返回“<strong class="ih hj">未定义的</strong>”。否则，下一步将移除堆栈的最后一个元素。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="c27f" class="ju jv hi la b fi le lf l lg lh"><em class="kw">this</em>.size = function() {</span><span id="d055" class="ju jv hi la b fi li lf l lg lh">    return <em class="kw">this</em>.count;</span><span id="cfdf" class="ju jv hi la b fi li lf l lg lh">}</span><span id="ddb4" class="ju jv hi la b fi li lf l lg lh">// Returns the value at the end of the stack</span><span id="c8a2" class="ju jv hi la b fi li lf l lg lh"><em class="kw">this</em>.peek = function() {</span><span id="c1ae" class="ju jv hi la b fi li lf l lg lh">    return <em class="kw">this</em>.storage[<em class="kw">this</em>.count -1];</span><span id="c47a" class="ju jv hi la b fi li lf l lg lh">}</span></pre><p id="4e27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两种方法就是这么简单。第一个是堆栈的总大小，第二个返回堆栈末尾的值。所以，最后的代码是，</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/843346f27caab9a6badd268249588c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27_kZbi5oTGVqFhTW4GaPQ.png"/></div></div></figure><h2 id="fcc0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">长队</h2><p id="bb0d" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">此处悬疑…</p><p id="02f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天不再讨论，稍后将对“队列”数据结构进行简要说明。在那之前，祝你编码愉快。</p></div></div>    
</body>
</html>