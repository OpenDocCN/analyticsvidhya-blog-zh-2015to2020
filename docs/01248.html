<html>
<head>
<title>Manipulating data with Numpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Numpy操作数据</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/manipulating-data-with-numpy-1bb9baaccfbf?source=collection_archive---------14-----------------------#2019-10-10">https://medium.com/analytics-vidhya/manipulating-data-with-numpy-1bb9baaccfbf?source=collection_archive---------14-----------------------#2019-10-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ae414569440c2923e7f4f7b81f0041cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ecb0MpRS8ZQEUUOKnouzhQ.png"/></div></div></figure><p id="170e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">收集和存储大量信息以供最终分析的行为由来已久。然而，今天的数据来自各种来源和格式，这使得清理、操作和链接变得很困难。数据可以是一些文本文档、数值的集合、图像、音频剪辑的集合或者其他东西。不管数据的类型如何，将它转换成数字数组肯定会帮助我们分析它。</p><p id="39a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想一想，图像基本上是表示像素网格上特定位置的红色、绿色和蓝色变化的数字。音频剪辑可以是强度对时间的一维数组，文本可以转换成二进制格式。因此，数值数组的存储和争论是一个重要的方面。</p><p id="4686" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">NumPy或Numerical Python是一个仅适用于Python的模块，用于处理数值数组。它支持大型多维数组和矩阵，以及对这些数组进行运算的大量数学函数。NumPy数组看起来类似于Python列表。然而，与列表相比，它们提供了更有效的存储、速度和操作。下面列出了一些值得注意的差异:</p><ul class=""><li id="10cc" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">可以存储在列表和数组中的数据类型:</strong></li></ul><p id="0080" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python列表可以存储不同类型的数据，因为它是动态类型的。它可以填充任何类型的数据。而NumPy数组被创建为同构数组。</p><ul class=""><li id="d2e0" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">与列表相比，数组的数据存储效率:</strong></li></ul><p id="6243" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python是一种动态类型语言，与其他静态类型语言相比，存储整数时会有开销。存储在静态类型语言(如C)中的整数基本上是内存中某个位置的标签，其字节编码一个整数值。另一方面，Python整数是指向内存中某个位置的指针，该位置包含所有Python对象信息，包括包含整数值的字节。因此，在植入级别，数组包含指向数据块的指针。而且，由于列表的异构性，它包含一个指向指针块的指针，而指针块又指向python对象块。与列表相比，数组占用的内存要少得多。</p><ul class=""><li id="bd01" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">数组和列表的数学运算:</strong></li></ul><p id="663e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对数组中存在的每个元素执行数组上的数学运算。但是，这对列表不起作用。在python列表上执行数学运算时，你肯定会得到一个错误。数组使得对大量数字数据的操作非常快，通常比列表更有效。</p><p id="b1e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Numpy数组是一个统一值的数组，单精度数字每个占用4个字节，双精度数字占用8个字节。因此，数组使得对大量数字数据的操作非常快，并且通常比列表有效得多，列表要求每个指针至少4个字节加上16个字节，即使是最小的Python对象也是如此；4用于类型指针，4用于引用计数，4用于值，内存分配器四舍五入到16。</p><h2 id="fbf3" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated"><strong class="ak"> <em class="ks"> 1 —创建Numpy数组:</em> </strong></h2><p id="67b8" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">例如，我将使用NumPy分析印度超级联赛(IPL)的数据集。印度超级联赛(IPL)是印度的职业T20板球联赛，每年4月至5月由代表印度城市的球队进行比赛。这是世界上参加人数最多的板球联赛，在所有体育联赛中排名第六。它有来自世界各地的球员组成的球队，非常具有竞争性和娱乐性，球队之间有很多势均力敌的比赛。</p><p id="9e9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据下载自<a class="ae ky" href="https://cricsheet.org/%c2%a0(data)" rel="noopener ugc nofollow" target="_blank">https://CRIC sheet . org/% C2 % A0(数据</a>)。分析的目的是找出哪些因素影响了一个团队的胜利，以及这种影响有多大。同时，它将帮助您解决NumPy问题。</p><p id="b685" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里是<code class="du kz la lb lc b">ipl_matches_small.csv</code>文件的前几行和前几列的快照，我将在整个演示中使用它:</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/b9d3e01c0b901667fdced2e4e7f820c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXFWoPjucss41yjRpJLn7Q.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">ipl_matches_small.csv快照</figcaption></figure><p id="ebe4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将从导入别名为np的包numpy开始。</p><pre class="le lf lg lh fd lm lc ln lo aw lp bi"><span id="6d40" class="jx jy hi lc b fi lq lr l ls lt">import numpy as np</span></pre><p id="088e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建数组最简单的方法是使用<code class="du kz la lb lc b">np.array</code>将python列表转换成数组。如果我们想显式设置数组的数据类型，我们可以使用<code class="du kz la lb lc b">dtype </code>关键字。下面指定一维和二维数组以供参考。</p><pre class="le lf lg lh fd lm lc ln lo aw lp bi"><span id="433f" class="jx jy hi lc b fi lq lr l ls lt">array_1 = np.array([1,2,3,4,5], dtype='float')  #Creates a 1-D array</span><span id="63d1" class="jx jy hi lc b fi lu lr l ls lt">array_2 = np.array([[1,2,3,4,5],[6,7,8,9,10]])  #Creates a 2-D array</span></pre><p id="6315" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上所述，与Python列表不同，NumPy仅限于包含相同类型的数组。当类型不匹配时，如果可能，NumPy将向上转换。(这里，整数将向上转换为字符串)</p><pre class="le lf lg lh fd lm lc ln lo aw lp bi"><span id="b29b" class="jx jy hi lc b fi lq lr l ls lt">In[1]: np.array([2, 5, 'two', 'five'])</span><span id="f8f4" class="jx jy hi lc b fi lu lr l ls lt">Out[1]: array([ '2', '5', 'two', 'five'])</span></pre><p id="193a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然已经了解了创建数组的基本知识，我们将尝试加载数据集来对其进行分析。我使用了<em class="lv"> genfromtxt </em>函数，该函数将文件的每一行从字符串格式转换为适当的数据类型。<em class="lv"> genfromtxt </em>比<em class="lv"> loadtxt </em>等函数更快更简单的好处是，它能够将丢失的数据考虑在内。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="c599" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lv"> genfromtxt </em>的默认数据类型为<em class="lv"> float </em>并将所有非数值转换为<em class="lv"> nan </em>。因此，数据类型被指定为<em class="lv">字符串。</em>关键字<code class="du kz la lb lc b">delimeter</code>指定了列之间应该如何分隔。这里，逗号<strong class="is hj">(，)</strong>被用来分割列。</p><h2 id="186a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">2 —阵列描述:</h2><p id="fde4" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">每个数组都有形状、大小和维数等特征。借助以下特性，您可以获得Numpy数组及其元素的必要信息。</p><blockquote class="ly lz ma"><p id="d1b6" class="iq ir lv is b it iu iv iw ix iy iz ja mb jc jd je mc jg jh ji md jk jl jm jn hb bi translated">形状:</p></blockquote><p id="2b10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它返回一个由数组维度组成的元组，即告诉我们每个维度中有多少项，可以使用<code class="du kz la lb lc b">ndarray</code>对象的<code class="du kz la lb lc b">.shape</code>属性找到。</p><blockquote class="ly lz ma"><p id="7675" class="iq ir lv is b it iu iv iw ix iy iz ja mb jc jd je mc jg jh ji md jk jl jm jn hb bi translated">尺寸:</p></blockquote><p id="790e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给出数组的维数。</p><blockquote class="ly lz ma"><p id="f0a4" class="iq ir lv is b it iu iv iw ix iy iz ja mb jc jd je mc jg jh ji md jk jl jm jn hb bi translated">尺寸:</p></blockquote><p id="61c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它指定数组中的总项数。更准确地说，它是数组的<code class="du kz la lb lc b">.shape</code>属性的元素的乘积。</p><blockquote class="ly lz ma"><p id="7fea" class="iq ir lv is b it iu iv iw ix iy iz ja mb jc jd je mc jg jh ji md jk jl jm jn hb bi translated">数据类型:</p></blockquote><p id="8af2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它告知数组中数据的类型。因为Numpy数组由同类数据组成</p><blockquote class="ly lz ma"><p id="b4e4" class="iq ir lv is b it iu iv iw ix iy iz ja mb jc jd je mc jg jh ji md jk jl jm jn hb bi translated">项目大小:</p></blockquote><p id="7c37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Itemsize表示数组中每个元素的字节数。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><pre class="le lf lg lh fd lm lc ln lo aw lp bi"><span id="3f7e" class="jx jy hi lc b fi lq lr l ls lt">Shape of the data set is:  (1451, 23)<br/>The dimension of the dataset is:  2<br/>Size of the data set is:  33373<br/>Data type of the dataset is:  &lt;U21<br/>The number of bytes in each element of the array is:  84</span></pre><p id="e7c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如图所示，数据集包含1452个数据点和23个要素，总大小为33373。它有一个包含21个字符字符串的结构化数据类型。</p><h2 id="bc3c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">3 —从数组中访问元素:</h2><p id="62ce" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">Numpy中的索引非常类似于Python的列表标准索引。在一维数组中，可以通过在方括号中声明索引来访问第n个元素，就像列表中所做的那样。此外，可以使用负索引从数组末尾开始索引。</p><p id="343b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在多维数组中，可以指定一个逗号分隔的索引元组来访问所需的元素。</p><p id="bf4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面，我尝试访问了关于第一场IPL比赛中第一个球的信息，以及参加该比赛的球队。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><pre class="le lf lg lh fd lm lc ln lo aw lp bi"><span id="800f" class="jx jy hi lc b fi lq lr l ls lt">1st match, 1st over, 1st ball:<br/> ['392203' '2009-05-01' 'East London' 'Kolkata Knight Riders'<br/> 'Mumbai Indians' 'Mumbai Indians' 'bat' 'Mumbai Indians' 'runs' '9.0' '1'<br/> '0.1' 'Mumbai Indians' 'ST Jayasuriya' 'SR Tendulkar' 'I Sharma' '0' '1'<br/> '1' 'wides' '' '' '']<br/>========================================<br/>Team 1 Kolkata Knight Riders<br/>Team 2 Mumbai Indians</span></pre><h2 id="1006" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">4 —访问子阵列:</h2><p id="8352" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">Numpy数组的切片也类似于Python列表的切片。通过在方括号中指定索引并使用由冒号(:)标记的<em class="lv">切片</em>符号来访问子数组。它遵循<code class="du kz la lb lc b">array[start:stop:step]</code>的相同模式。如果这些值中的任何一个没有被提及，那么它们将采用<code class="du kz la lb lc b">start=0, stop=size of the array, step=1</code>的默认值</p><p id="5181" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多维子数组是由逗号分隔的多个切片。</p><p id="eb5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了理解切片的概念，让我们试着找出数据集中所有参加比赛的独特球队。</p><p id="e345" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">英超联赛所有赛季涉及的不同球队将从数据集中的两列获得，即<em class="lv"> team1 </em>和<em class="lv"> team2。</em>这可以使用如下所示的数组切片轻松实现。如果您观察<em class="lv"> team1 </em>和<em class="lv"> team2 </em>的数据集，您会注意到团队名称重复出现，因为数据包含每次投球和每次跑垒的信息。光是切片就能给我们提供参赛队伍的名字和代表。为了避免这种情况，我使用了NumPy函数<em class="lv"> unique </em>来访问唯一的团队。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><pre class="le lf lg lh fd lm lc ln lo aw lp bi"><span id="5ed4" class="jx jy hi lc b fi lq lr l ls lt">['Chennai Super Kings' 'Deccan Chargers' 'Kings XI Punjab'<br/> 'Kolkata Knight Riders' 'Mumbai Indians' 'Pune Warriors'<br/> 'Rajasthan Royals']</span></pre><blockquote class="ly lz ma"><p id="9ea9" class="iq ir lv is b it iu iv iw ix iy iz ja mb jc jd je mc jg jh ji md jk jl jm jn hb bi translated">布尔索引:</p></blockquote><p id="8a9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Numpy数组可以使用标准的Python<em class="lv">x【obj】</em>语法进行索引，其中<em class="lv"> x </em>是数组，<em class="lv"> obj </em>是语法。</p><p id="3b8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将尝试找出该队在所有赛季中赢得比赛的总次数。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><pre class="le lf lg lh fd lm lc ln lo aw lp bi"><span id="0374" class="jx jy hi lc b fi lq lr l ls lt">Number of matches where Mumbai Indians has won the toss:  2</span></pre><h2 id="eebe" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">5 —阵列的整形:</h2><p id="a574" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">了解如何重塑NumPy数组以使您的数据满足特定Python库的期望是很重要的。例如，一些库，如scikit-learn，可能需要将输出变量(y)的一维数组整形为一个二维数组，其中一列和每行的结果。</p><p id="1cca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只要多重因子产生相同数量的元素，数组的维数就可以在执行过程中改变。</p><p id="054b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以尝试对可用数据集中的前四行和前四列进行整形，使其显示由两列和多行组成的组。</p><pre class="le lf lg lh fd lm lc ln lo aw lp bi"><span id="4992" class="jx jy hi lc b fi lq lr l ls lt">print("Subarray: \n", data_ipl[:4,:4])<br/>print("Reshaped subarray: \n", data_ipl[:4,:4].reshape(8,2))</span><span id="f6ed" class="jx jy hi lc b fi lu lr l ls lt">Subarray: <br/> [['392203' '2009-05-01' 'East London' 'Kolkata Knight Riders']<br/> ['392203' '2009-05-01' 'East London' 'Kolkata Knight Riders']<br/> ['392203' '2009-05-01' 'East London' 'Kolkata Knight Riders']<br/> ['392203' '2009-05-01' 'East London' 'Kolkata Knight Riders']]<br/>Reshaped subarray: <br/> [['392203' '2009-05-01']<br/> ['East London' 'Kolkata Knight Riders']<br/> ['392203' '2009-05-01']<br/> ['East London' 'Kolkata Knight Riders']<br/> ['392203' '2009-05-01']<br/> ['East London' 'Kolkata Knight Riders']<br/> ['392203' '2009-05-01']<br/> ['East London' 'Kolkata Knight Riders']]</span></pre><h2 id="5eeb" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">6 —矢量化:</h2><p id="09ea" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">矢量化是NumPy的一种能力，通过它我们可以对整个数组而不是单个元素执行操作。在Python中，对任何对象进行循环都会有很大的开销。NumPy中的矢量化运算将内部循环委托给高度优化的C和Fortran函数，从而使Python代码更简洁、更快速。</p><pre class="le lf lg lh fd lm lc ln lo aw lp bi"><span id="8cf8" class="jx jy hi lc b fi lq lr l ls lt"># Finding the datapoints where the kind of wicket is 'caught'</span><span id="bb9a" class="jx jy hi lc b fi lu lr l ls lt">data_ipl[data_ipl[:,21]=='caught']</span><span id="5601" class="jx jy hi lc b fi lu lr l ls lt">array([['392203', '2009-05-01', 'East London', ..., 'ST Jayasuriya',<br/>        'caught', 'MN van Wyk'],<br/>       ['392203', '2009-05-01', 'East London', ..., 'Harbhajan Singh',<br/>        'caught', 'AB Dinda'],<br/>       ['392203', '2009-05-01', 'East London', ..., 'SR Tendulkar',<br/>        'caught', 'BB McCullum'],<br/>       ...,<br/>       ['335987', '2008-04-21', 'Jaipur', ..., 'B Lee', 'caught',<br/>        'Kamran Akmal'],<br/>       ['335987', '2008-04-21', 'Jaipur', ..., 'M Kaif', 'caught',<br/>        'KC Sangakkara'],<br/>       ['335987', '2008-04-21', 'Jaipur', ..., 'Kamran Akmal', 'caught',<br/>        'PP Chawla']], dtype='&lt;U21')</span></pre><p id="1126" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，上面的指令返回整个数组，而不仅仅是一个元素，因为它比较了每个wicket类型为“catched”的数据点。</p><p id="383c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以对整个数组执行不同的矢量化算术运算。下面提到了其中的一些。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es me"><img src="../Images/4cd00669af3a603f6b7562f2e8f84375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*1_9TWiRGUjCvHR63LWxRFQ.png"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">矢量化算术运算</figcaption></figure><h2 id="cef4" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">7 —广播:</h2><p id="e76b" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">如果你操作的数组大小不一样，就不可能进行元素操作。在这种情况下，NumPy执行广播来尝试匹配元素。本质上，广播包括几个步骤:</p><ul class=""><li id="1f30" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">如果数组没有相同的秩，则在较低秩数组的形状前面加上1，直到两个形状具有相同的长度。</li><li id="2e04" class="jo jp hi is b it mf ix mg jb mh jf mi jj mj jn jt ju jv jw bi translated">如果两个数组在一个维度上具有相同的大小，或者其中一个数组在该维度上的大小为1，则称这两个数组在该维度上兼容。</li><li id="5e38" class="jo jp hi is b it mf ix mg jb mh jf mi jj mj jn jt ju jv jw bi translated">如果这些阵列在所有维度上都兼容，则它们可以一起广播。</li><li id="a4d5" class="jo jp hi is b it mf ix mg jb mh jf mi jj mj jn jt ju jv jw bi translated">广播后，每个数组的行为就好像它的形状等于两个输入数组的形状的元素最大值。</li><li id="375d" class="jo jp hi is b it mf ix mg jb mh jf mi jj mj jn jt ju jv jw bi translated">在任何维度中，如果一个数组的大小为1，而另一个数组的大小大于1，则第一个数组的行为就好像是沿着该维度复制的一样。</li></ul><pre class="le lf lg lh fd lm lc ln lo aw lp bi"><span id="8448" class="jx jy hi lc b fi lq lr l ls lt">arr_1 = np.arange(5)<br/>arr_1 + 5</span><span id="53ef" class="jx jy hi lc b fi lu lr l ls lt">array([5, 6, 7, 8, 9])</span></pre><p id="688c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以把它看作是将值<code class="du kz la lb lc b">5</code>复制到数组<code class="du kz la lb lc b">[5, 5, 5, 5, 5]</code>中，并将结果相加的操作。NumPy广播的优势在于，这种价值的复制实际上不会发生，但当我们思考广播时，这是一个有用的心理模型。</p><p id="b3f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更好地理解矢量化和广播，让我们试着对数据集进行一点管理。我们将尝试创建一个过滤器，只过滤那些击球手得了6分的记录。此外，我们将尝试找出谁的总得分最高。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><pre class="le lf lg lh fd lm lc ln lo aw lp bi"><span id="ff80" class="jx jy hi lc b fi lq lr l ls lt">Batsman and number of sixes scored by them: <br/> [['AC Gilchrist' '1']<br/> ['BJ Hodge' '3']<br/> ['CH Gayle' '1']<br/> ['DR Smith' '4']<br/> ['DS Kulkarni' '2']<br/> ['Harbhajan Singh' '2']<br/> ['IK Pathan' '1']<br/> ['JD Ryder' '1']<br/> ['JP Duminy' '4']<br/> ['K Goel' '2']<br/> ['KC Sangakkara' '1']<br/> ['Kamran Akmal' '1']<br/> ['M Manhas' '1']<br/> ['M Vijay' '1']<br/> ['MEK Hussey' '1']<br/> ['MS Dhoni' '1']<br/> ['PR Shah' '2']<br/> ['R Bhatia' '1']<br/> ['RA Jadeja' '1']<br/> ['RG Sharma' '1']<br/> ['RR Raje' '1']<br/> ['S Badrinath' '1']<br/> ['SC Ganguly' '1']<br/> ['SR Tendulkar' '6']<br/> ['SR Watson' '6']<br/> ['ST Jayasuriya' '4']<br/> ['SV Samson' '2']<br/> ['TL Suman' '2']<br/> ['Y Venugopal Rao' '1']<br/> ['Yuvraj Singh' '3']]<br/>Batsman who scored maximum runs: SR Tendulkar</span></pre><p id="7df4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，指令<code class="du kz la lb lc b">np.where(data_ipl[:,16]=='6')</code>返回<strong class="is hj">所有</strong>击球手已经得了6分的数据点。函数<em class="lv"> column_stack </em>用于显示数据，基本上将两个1D数组的列堆叠在一起，形成一个2D数组。将每个击球手与得分的6分联系起来会更容易些。另外，<em class="lv"> argmax </em>的聚合函数返回<code class="du kz la lb lc b">arr_01</code>中所有计数中最大值的位置。</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="91e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本演练中，只描述了最少的一组功能。我真诚地希望它对NumPy及其效率有足够的了解。如果您已经很好地掌握了NumPy，并且想更深入地研究它，下面是一些可能有用的资源。</p><div class="mr ms ez fb mt mu"><a href="http://cs231n.github.io/python-numpy-tutorial/#numpy" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">Python Numpy教程</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">斯坦福CS231n课程材料和笔记:视觉识别的卷积神经网络。</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">cs231n.github.io</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni io mu"/></div></div></a></div><div class="mr ms ez fb mt mu"><a href="https://jakevdp.github.io/PythonDataScienceHandbook/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">Python数据科学手册</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">该网站包含Jake VanderPlas的Python数据科学手册的全文；该内容可在…上获得</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">python NumPy数组的搭便车指南</p></div></div></div></a></div><p id="b5fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考资料:</p><ul class=""><li id="a503" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">Python数据科学手册——Jake Vander plas。</li><li id="5874" class="jo jp hi is b it mf ix mg jb mh jf mi jj mj jn jt ju jv jw bi translated">python NumPy数组的搭便车指南— Deepak K [Daksh] Gupta。</li><li id="1d64" class="jo jp hi is b it mf ix mg jb mh jf mi jj mj jn jt ju jv jw bi translated">SciPy。org—<a class="ae ky" href="https://docs.scipy.org/doc/" rel="noopener ugc nofollow" target="_blank">https://docs.scipy.org/doc/</a></li><li id="6723" class="jo jp hi is b it mf ix mg jb mh jf mi jj mj jn jt ju jv jw bi translated">使用Numpy进行数组编程—<a class="ae ky" href="https://realpython.com/numpy-array-programming/" rel="noopener ugc nofollow" target="_blank">https://realpython.com/numpy-array-programming/</a></li></ul></div></div>    
</body>
</html>