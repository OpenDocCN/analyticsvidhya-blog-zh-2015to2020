<html>
<head>
<title>Rendering a Google Map in a JavaScript Front-End</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript前端呈现谷歌地图</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/rendering-a-google-map-in-a-javascript-front-end-part-ii-922cfb9f9a4?source=collection_archive---------12-----------------------#2019-10-08">https://medium.com/analytics-vidhya/rendering-a-google-map-in-a-javascript-front-end-part-ii-922cfb9f9a4?source=collection_archive---------12-----------------------#2019-10-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8fbd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第二部分:存储和渲染地图上的点和多边形</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ea490a51031a82f694d010ab2b4decf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bGLbGTHPHG1LP6G_fkn_Q.png"/></div></div></figure><p id="8463" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我的<a class="ae kf" rel="noopener" href="/@lukemenard/rendering-a-google-map-in-a-javascript-front-end-part-i-a076420a9ee9">上一篇文章</a>中，我讨论了我在谷歌云平台上建立一个项目并通过谷歌地图JavaScript API在JavaScript前端呈现地图的方法。在本文中，我将详细介绍在渲染地图中生成新的点和多边形数据的方法，这些数据乐观地和悲观地保存在Ruby-on-Rails后端数据库中。</p><p id="4f2e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我创建的这个项目是一个网络工具，用来帮助消防员和护林员追踪野火和计划规定的烧伤。出于我的目的，我想让最终用户能够绘制可编辑、可删除和持久的新的点和面数据。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="aca7" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">后端</h1><h2 id="3142" class="lf ko hi bd kp lg lh li kt lj lk ll kx js lm ln kz jw lo lp lb ka lq lr ld ls bi translated">创建Rails API</h2><p id="6a05" class="pw-post-body-paragraph jj jk hi jl b jm lt ij jo jp lu im jr js lv ju jv jw lw jy jz ka lx kc kd ke hb bi translated">为了创建持久的Google Maps点和多边形数据，我首先构建了一个rails后端数据库和API来存放信息，然后通过API在前端检索必要的数据。我创建了一个“点”模型，其中包括用于标题、描述、链接的字符串/文本字段，以及用于点的纬度和经度的浮动字段:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="8526" class="lf ko hi lz b fi md me l mf mg">create_table "points", force: :cascade <em class="mh">do</em> |t|<br/>   t.string "title"<br/>   t.float "latitude"<br/>   t.float "longitude"<br/>   t.string "link"<br/>   t.text "description"<br/>   t.datetime "created_at", null: false<br/>   t.datetime "updated_at", null: false<br/><em class="mh">end</em></span></pre><p id="031a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我还用相同的字符串和文本字段生成了一个“多边形”模型。然而，我为潜在多边形顶点的纬度和经度包括了15个不同的浮点字段。这是一个有点随意的选择，将应用程序中创建的新多边形限制为14条边。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="33bb" class="lf ko hi lz b fi md me l mf mg">create_table "polygons", force: :cascade <em class="mh">do</em> |t|<br/>   t.string "title"<br/>   t.string "link"<br/>   t.string "description"<br/>   t.float "lat1"<br/>   t.float "long1"<br/>   t.float "lat2"<br/>   t.float "long2"<br/>   t.float "lat3"<br/>   t.float "long3"</span><span id="c031" class="lf ko hi lz b fi mi me l mf mg">   ...</span><span id="e5f1" class="lf ko hi lz b fi mi me l mf mg">   t.float "lat15"<br/>   t.float "long15"<br/>   t.datetime "created_at", null: false<br/>   t.datetime "updated_at", null: false<br/><em class="mh">end</em></span></pre><p id="773f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，我为点和多边形模型创建了控制器文件，包括相关的CRUD方法，并将生成的JSON数据呈现给Rails API。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="fc82" class="lf ko hi lz b fi md me l mf mg"><em class="mh">class</em> PointsController &lt; ApplicationController<br/>   <em class="mh">def</em> index<br/>      points = Point.all<br/>      render json: points, except: [:updated_at, :created_at]<br/>   <em class="mh">end</em></span><span id="9590" class="lf ko hi lz b fi mi me l mf mg"><em class="mh">def</em> create<br/>      point = Point.create(title: params[:title], latitude:<br/>      params[:latitude], longitude: params[:longitude], link:<br/>      params[:link], description: params[:description])<br/>      render json: point, except: [:updated_at, :created_at]<br/>   <em class="mh">end</em></span><span id="9b21" class="lf ko hi lz b fi mi me l mf mg"><em class="mh">def</em> show<br/>      point = Point.find_by(id: params[:id])<br/>      render json: point, except: [:updated_at, :created_at]<br/>   <em class="mh">end</em></span><span id="4559" class="lf ko hi lz b fi mi me l mf mg"><em class="mh">def</em> update<br/>      point = Point.find_by(id: params[:id])<br/>      point.update(point_params)<br/>      render json: point, except: [:updated_at, :created_at]<br/>   <em class="mh">end</em></span><span id="d249" class="lf ko hi lz b fi mi me l mf mg"><em class="mh">def</em> destroy<br/>      point = Point.find_by(id: params[:id])<br/>      point.delete<br/>   <em class="mh">end</em></span><span id="38cf" class="lf ko hi lz b fi mi me l mf mg">private</span><span id="fed8" class="lf ko hi lz b fi mi me l mf mg"><em class="mh">def</em> point_params<br/>      params.require(:point).permit(:id, :title, :latitude,<br/>      :longitude, :description, :link)<br/>   <em class="mh">end<br/>end</em></span></pre><p id="80e1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">出于我的目的，运行本地Rails服务器进行前端数据检索就足够了。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="8e16" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">前端</h1><h2 id="25e3" class="lf ko hi bd kp lg lh li kt lj lk ll kx js lm ln kz jw lo lp lb ka lq lr ld ls bi translated">创建新点数据</h2><p id="9925" class="pw-post-body-paragraph jj jk hi jl b jm lt ij jo jp lu im jr js lv ju jv jw lw jy jz ka lx kc kd ke hb bi translated">当用户以预定的方式与地图交互时，应该创建新的数据点。Google Maps JavaScript API有几个内置的<a class="ae kf" href="https://developers.google.com/maps/documentation/javascript/events" rel="noopener ugc nofollow" target="_blank">事件监听器</a>(例如，点击、双击、鼠标悬停)，它们可以在服务器端完成所选动作时触发一种方法。我构建了一个事件侦听器，它通过创建一个新的数据点来响应地图显示上的鼠标双击。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="3008" class="lf ko hi lz b fi md me l mf mg">google.maps.event.addListener(map, 'dblclick', function(event){<br/>})</span></pre><p id="690c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在事件监听器中，我创建了一个新的Google Maps标记，其位置设置为点击事件的纬度和经度。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="0a97" class="lf ko hi lz b fi md me l mf mg">let marker = new google.maps.Marker({<br/>   position: event.latLng,<br/>   map: map,<br/>   draggable: true<br/>})</span></pre><p id="d2ae" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">或者，您可以创建一个与创建时打开的每个新点相关联的新信息窗口。我还创建了一个空白的“div”元素作为info窗口中的占位符内容。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="5c87" class="lf ko hi lz b fi md me l mf mg">let div = document.createElement('div')</span><span id="85a9" class="lf ko hi lz b fi mi me l mf mg">let infoWindow = new google.maps.InfoWindow({<br/>   content: div<br/>})<br/>infoWindow.open(map, marker)</span></pre><p id="8216" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在事件监听器中，我还创建了一个表单，当存储在后端数据库中时，允许用户输入与每个新点相关联的内容。该表单包括一系列输入字段来收集相关的点信息，存储为innerHTML。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="1856" class="lf ko hi lz b fi md me l mf mg">let form = document.createElement('form')<br/>form.innerHTML =<br/>` &lt;div class='new-Form'&gt;<br/>   &lt;form&gt;<br/>      &lt;h3&gt; Create New Point &lt;/h3&gt;<br/>      &lt;input type="hidden" id="id" name="id"  value="id"&gt;<br/>      Title: &lt;input type="text" id="title" name="title"  value=""&gt;<br/>      Description: &lt;inputtype="textContent" id="description" name="description"  value=""&gt;<br/>      Latitude: &lt;input id="latitude" name="latitude"  value="${event.latLng.lat()}"&gt;<br/>      Longitude: &lt;input id="longitude" name="longitude"  value="${event.latLng.lng()}"&gt;<br/>      Link: &lt;input type="text" id="link" name="link"  value=""&gt;<br/>   &lt;/form&gt;<br/>&lt;/div&gt; `</span></pre><p id="c6c2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，我创建了一个带有click事件的表单提交按钮，单击该按钮将触发后续的“getFormData”函数(稍后讨论)。然后，我将form和submit按钮添加到每个新info窗口中包含的“div”元素中。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="3b10" class="lf ko hi lz b fi md me l mf mg">let submitButton = document.createElement('button')<br/>submitButton.innerText = 'Create New Point'<br/>submitButton.addEventListener('click', function(event){<br/>   event.preventDefault()<br/>   getFormData()<br/>})</span><span id="d26e" class="lf ko hi lz b fi mi me l mf mg">div.append(form, submitButton)</span></pre><p id="b7ab" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">双击并创建一个新的点，一个信息窗口完成上述表格和提交按钮应该打开，并允许用户输入。</p><p id="104a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在提交info window表单时，我需要收集用户输入的数据，以便在后面的方法中使用。我通过调用一个“getFormData”函数来实现这一点，该函数利用JavaScript FormData构造函数来检索每个用户输入并将其存储到一个变量中。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="d8c0" class="lf ko hi lz b fi md me l mf mg">function getFormData(){<br/>   let formData = new FormData(form)<br/>   let title = formData.get('title')<br/>   let description = formData.get('description')<br/>   let latitude = formData.get('latitude')<br/>   let longitude = formData.get('longitude')<br/>   let link = formData.get('link')</span><span id="67a1" class="lf ko hi lz b fi mi me l mf mg">addNewPoint(title, description, latitude, longitude, link)<br/>}</span></pre><p id="fece" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">“getFormData”调用一个附加函数“addNewPoint”，该函数接收用户输入数据，触发对已建立的API的HTTP POST请求，并向后端数据库添加一个新条目。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="d037" class="lf ko hi lz b fi md me l mf mg">function addNewPoint(title, description, latitude, longitude, link){<br/>   marker.setMap(null)</span><span id="a425" class="lf ko hi lz b fi mi me l mf mg">let clickconfig = {<br/>      method: "POST",<br/>      headers: {<br/>         "Content-Type": "application/json",<br/>         "Accept": "application/json"<br/>      },<br/>      body: JSON.stringify({<br/>         title,<br/>         description,<br/>         latitude,<br/>         longitude,<br/>         link<br/>      })<br/>   }</span><span id="17eb" class="lf ko hi lz b fi mi me l mf mg">fetch(POINTS_URL, clickconfig)<br/>      .then(response =&gt; response.json())<br/>      .then(renderPointCard)<br/>      .catch(function(error){<br/>         console.log(error.message)<br/>      })<br/>   }<br/>})</span></pre><p id="7e56" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">该函数将序列化的用户数据提交给API，并将结果解析为JSON。然后，我将结果数据传递给一个额外的函数“renderPointCard”，该函数在新点数据上创建额外的样式和单击功能，但这超出了本文的范围。</p><p id="aea0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">刷新页面时，新创建的点应该保留在页面上。</p><h2 id="b447" class="lf ko hi bd kp lg lh li kt lj lk ll kx js lm ln kz jw lo lp lb ka lq lr ld ls bi translated">创建新的多边形数据</h2><p id="8455" class="pw-post-body-paragraph jj jk hi jl b jm lt ij jo jp lu im jr js lv ju jv jw lw jy jz ka lx kc kd ke hb bi translated">谷歌地图JavaScript API有一个内置的特性，<a class="ae kf" href="https://developers.google.com/maps/documentation/javascript/drawinglayer" rel="noopener ugc nofollow" target="_blank">绘图管理器</a>，允许用户轻松绘制新的多边形(或圆形、矩形等)。)在地图上。我在“initMap”函数中创建了一个新的绘图管理器实例，将多边形选择器按钮的位置设置为地图的底部中心，并定制了多边形表示的样式。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="b651" class="lf ko hi lz b fi md me l mf mg">let drawingManager = new google.maps.drawing.DrawingManager({<br/>   drawingMode: null,<br/>   drawingControl: true,<br/>   drawingControlOptions: {<br/>      position: google.maps.ControlPosition.BOTTOM_CENTER,<br/>      drawingModes: ['polygon']<br/>   },<br/>   polygonOptions: {<br/>      fillColor: '#ff5733',<br/>      fillOpacity: 0.3,<br/>      strokeWeight: 1,<br/>      clickable: true,<br/>      editable: true,<br/>      zIndex: 1,<br/>   }<br/>});<br/>drawingManager.setMap(map)</span></pre><p id="06d8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如上所述，我创建了一个新的数据点，类似地，我创建了一个地图级别的事件监听器，它由绘图管理器多边形的完成来触发。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="53d4" class="lf ko hi lz b fi md me l mf mg">google.maps.event.addListener(drawingManager, 'polygoncomplete', function(polygon){<br/>}</span></pre><p id="d955" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">完成后，多边形的数据通过一个更大的函数传递，该函数标识每个多边形顶点的纬度和经度。我通过使用Google Maps API的内置“getPaths()”方法来识别组成多边形的所有标签的对象，并将结果值存储到一个变量中，从而实现了这一点。面要素是一个嵌套对象，需要一些钻孔来识别各个纬度和经度(请注意。g下面的链条)。使用for循环，我将各个纬度和经度分开，并存储在一个新的数组中。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="c5fb" class="lf ko hi lz b fi md me l mf mg">let p = polygon.getPaths("latLngs").g[0].g</span><span id="6b3f" class="lf ko hi lz b fi mi me l mf mg">let latLng = []<br/><em class="mh">for</em>(let i = 0; i &lt; p.length; i++){<br/>   let lat = 0<br/>   lat = p[i].lat()<br/>   <br/>   let long = 0<br/>   long = p[i].lng()</span><span id="3268" class="lf ko hi lz b fi mi me l mf mg">latLng.push(lat)<br/>   latLng.push(long)<br/>}</span></pre><p id="7d09" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我按照上面详述的相同过程为每个新多边形生成一个信息窗口。每个info窗口都包含一个可编辑的表单和submit按钮，该按钮触发一个方法来检索和存储用户输入到表单中的数据。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="a3c4" class="lf ko hi lz b fi md me l mf mg">let div = document.createElement('div')</span><span id="52cc" class="lf ko hi lz b fi mi me l mf mg">let form = document.createElement('form')<br/>form.innerHTML =<br/>`&lt;div&gt;<br/>   &lt;form&gt;<br/>      &lt;h3&gt; Create New Polygon &lt;/h3&gt;<br/>      &lt;input type="hidden" id="id" name="id"  value="id"&gt;<br/>      &lt;input type="hidden" id="polygon_id" name="polygon_id"  value="polygon_id"&gt;<br/>      &lt;input type="hidden" id="lat1" name="lat1" value="${latLng[0]}"<br/>      &lt;input type="hidden" id="lat2" name="lat2" value="${latLng[2]}"&gt;</span><span id="6ab7" class="lf ko hi lz b fi mi me l mf mg">...</span><span id="16a6" class="lf ko hi lz b fi mi me l mf mg">&lt;input type="hidden" id="lat15" name="lat15" value="${latLng[28]}"<br/>      &lt;input type="hidden" id="long1" name="long1" value="${latLng[1]}"&gt;<br/>      &lt;input type="hidden" id="long2" name="long2" value="${latLng[3]}"&gt;</span><span id="fa89" class="lf ko hi lz b fi mi me l mf mg">...<br/>      <br/>      &lt;input type="hidden" id="long15" name="long15" value="${latLng[29]}"&gt;</span><span id="1114" class="lf ko hi lz b fi mi me l mf mg">Title: &lt;input type="text" id="title" name="title"  value=""&gt;<br/>      Description: &lt;input type="textContent" id="description" name="description"  value=""&gt;<br/>      Link: &lt;input type="text" id="link" name="link"  value=""&gt;</span><span id="06c7" class="lf ko hi lz b fi mi me l mf mg">&lt;/form&gt;<br/>&lt;/div&gt;`</span><span id="4a52" class="lf ko hi lz b fi mi me l mf mg">let polySubmitButton = document.createElement('button')<br/>polySubmitButton.innerText = 'Create New Wildfire'<br/>polySubmitButton.addEventListener('click', function(event){<br/>   event.preventDefault()<br/>   getPolygonFormData()<br/>})</span><span id="4a78" class="lf ko hi lz b fi mi me l mf mg">div.append(form, polySubmitButton)</span></pre><p id="1104" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这种情况下，每个多边形顶点的纬度和经度值通过隐藏的表单字段传递给“getPolygonFormData”函数。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="c75c" class="lf ko hi lz b fi md me l mf mg">function getPolygonFormData(){<br/>   let formData = new FormData(form)<br/>   let title = formData.get('title')<br/>   let description = formData.get('description')<br/>   let link = formData.get('link')<br/>   let lat1 = formData.get('lat1')<br/>   let long1 = formData.get('long1')<br/>   let lat2 = formData.get('lat2')<br/>   let long2 = formData.get('long2')</span><span id="46a2" class="lf ko hi lz b fi mi me l mf mg">...</span><span id="2499" class="lf ko hi lz b fi mi me l mf mg">let lat15 = formData.get('lat15')<br/>   let long15 = formData.get('long15')</span><span id="5cb0" class="lf ko hi lz b fi mi me l mf mg">}</span></pre><p id="d4e1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后，该函数将表单数据传递给后续函数“addNewPolygon”，后者执行对API的HTTP POST请求，并向后端数据库添加一个新的多边形条目。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="21de" class="lf ko hi lz b fi md me l mf mg">function addNewPolygon(<br/>   title,<br/>   description,<br/>   link,<br/>   lat1,<br/>   long1,<br/>   lat2,<br/>   long2,</span><span id="6cb6" class="lf ko hi lz b fi mi me l mf mg">...<br/>   <br/>   lat15,<br/>   long15<br/>   ){</span><span id="f4f0" class="lf ko hi lz b fi mi me l mf mg">let polyConfig = {<br/>      method: "POST",<br/>      headers: {<br/>         "Content-Type": "application/json",<br/>         "Accept": "application/json"<br/>      },<br/>      body: JSON.stringify({<br/>         title,<br/>         description,<br/>         link,<br/>         lat1,<br/>         long1,<br/>         lat2,<br/>         long2,</span><span id="b812" class="lf ko hi lz b fi mi me l mf mg">...<br/>     <br/>         lat15,<br/>         long15<br/>      })<br/>   }<br/>   fetch(POLYGONS_URL, polyConfig)<br/>   .then(response =&gt; response.json())<br/>   .then(renderPolygonCard)<br/>   .catch(function(error){<br/>      console.log(error.message)<br/>   })<br/>}})</span></pre><p id="7d90" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">与上面描述的点数据方法一样，这个函数将序列化的用户数据提交给API，并将结果承诺解析为JSON。然后，我将结果数据传递给一个附加函数“renderPolygonCard”，该函数在新点多边形数据上创建附加的样式和单击功能。</p><p id="ef91" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">刷新页面时，新创建的多边形也应该保留在页面上。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="f004" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有关我如何使用普通JavaScript在点和多边形数据上启用完整CRUD方法的更多详细信息，请随意访问我的完整GitHub存储库，在这里可以找到:</p><div class="mj mk ez fb ml mm"><a href="https://github.com/lukemenard/Wildfire-Tracker" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">Luke menard/野火追踪器</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">一个基于谷歌地图的Javascript网络应用程序，使用野火追踪器近乎实时地追踪美国的野火…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">github.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na jh mm"/></div></div></a></div><p id="ed9e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">随时欢迎投稿和评论！</p></div></div>    
</body>
</html>