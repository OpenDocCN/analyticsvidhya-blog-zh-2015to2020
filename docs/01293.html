<html>
<head>
<title>Understanding The Knuth Morris Pratt Algorithm…In Bits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Knuth Morris Pratt算法…以比特为单位</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-the-knuth-morris-pratt-algorithm-in-bits-d21d93992057?source=collection_archive---------7-----------------------#2019-10-13">https://medium.com/analytics-vidhya/understanding-the-knuth-morris-pratt-algorithm-in-bits-d21d93992057?source=collection_archive---------7-----------------------#2019-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/23880fb675b11db159b6a217eb806b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgrA3zc4yKbATrpP3NkMrA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">格德·奥特曼(<a class="ae iu" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/users/geralt-9301/</a>)拍摄的照片</figcaption></figure><p id="25ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">字符串匹配是计算机科学中的一项重要任务，具有从搜索数据库到遗传学的广泛应用。有许多算法可以完成这项任务，在本文中，我将带您了解Knuth Morris Pratt算法<strong class="ix hj"> (KMP) </strong>。</p><h1 id="8fe8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">天真的方式</h1><p id="5996" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在我们进入<strong class="ix hj"> KMP </strong>算法之前，我想展示一下大多数人是如何尝试解决字符串匹配问题的。我这样做是为了让我们可以看到KMP是如何优化搜索的。</p><p id="430b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最简单但效率最低的搜索匹配的方法是遍历<strong class="ix hj">干草堆</strong>中的每个字符，并将该字符及其后的字符与<strong class="ix hj">针</strong>中的字符进行比较。下面的代码片段展示了我们如何做到这一点。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="6ea1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然我们可以通过在内循环中发现字符不匹配时立即将外循环推进一个字符来优化上面的代码片段，但是，当我们在最后一个字符之前都有匹配的字符时，这将给我们带来最坏情况下的时间复杂度<strong class="ix hj"> O(nm) </strong>。</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="0895" class="lh ju hi ld b fi li lj l lk ll">haystack = AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><span id="cbea" class="lh ju hi ld b fi lm lj l lk ll">needle = AAAAAAAAB</span></pre><h1 id="7ee1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">KMP之路</h1><p id="2a0b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><strong class="ix hj"> KMP </strong>算法从左至右遍历<strong class="ix hj">干草堆</strong>和<strong class="ix hj">针</strong>直到找到匹配。下面是两个字符串长度相等的特殊情况下的代码片段。这是为了让你习惯于<strong class="ix hj"> KMP </strong>如何遍历字符串来寻找匹配。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><h2 id="8127" class="lh ju hi bd jv ln lo lp jz lq lr ls kd jg lt lu kh jk lv lw kl jo lx ly kp lz bi translated">移动指针</h2><p id="7d20" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">既然我们看到了<strong class="ix hj"> KMP </strong>如何确定一个字符是否匹配，我们接下来将看到<strong class="ix hj"> KMP </strong>如何在【T30(n)】时间内移动<strong class="ix hj">指针</strong>通过<strong class="ix hj">干草堆</strong>来搜索匹配。看看下面的代码片段。</p><p id="7c46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ma">注意:这里提供的算法只适用于在这之后的代码片段中给出的测试用例，并将跳过其他测试用例中可能的匹配。这样做只是为了展示如何将针穿过干草堆。</em></p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="2b45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当发现不匹配并且其索引大于0时，我们立即将<strong class="ix hj">指针</strong>移动到<strong class="ix hj">干草堆</strong>中的那个字符，并开始我们的比较。如果不匹配发生在<strong class="ix hj">针</strong>的索引0处，我们将<strong class="ix hj">针</strong>移动到不匹配后的下一个字符。这有一个最好和最坏的时间复杂度<strong class="ix hj"> O(n) </strong>。</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="fbd1" class="lh ju hi ld b fi li lj l lk ll"># HOW KMP MOVES THE NEEDLE THROUGH THE HAYSTACK</span><span id="29b6" class="lh ju hi ld b fi lm lj l lk ll"><strong class="ld hj">C</strong>ABCDEKLSDSABCDEABCD<br/><strong class="ld hj">A</strong>BCDEABCD</span><span id="56f1" class="lh ju hi ld b fi lm lj l lk ll">CABCDE<strong class="ld hj">K</strong>LSDSABCDEABCD<br/> ABCDE<strong class="ld hj">A</strong>BCD</span><span id="24a3" class="lh ju hi ld b fi lm lj l lk ll">CABCDE<strong class="ld hj">K</strong>LABCDEABCD<br/>      <strong class="ld hj">A</strong>BCDEABCD</span><span id="64a1" class="lh ju hi ld b fi lm lj l lk ll">CABCDEK<strong class="ld hj">L</strong>ABCDEABCD<br/>       <strong class="ld hj">A</strong>BCDEABCD</span><span id="08fc" class="lh ju hi ld b fi lm lj l lk ll">CABCDEKL<strong class="ld hj">ABCDEABCD</strong><br/>        <strong class="ld hj">ABCDEABCD</strong></span></pre><h2 id="6a14" class="lh ju hi bd jv ln lo lp jz lq lr ls kd jg lt lu kh jk lv lw kl jo lx ly kp lz bi translated"><strong class="ak">前缀和后缀</strong></h2><p id="ddf6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">尽管上面的算法给出了相当好的时间复杂度<strong class="ix hj"> O(n) </strong>，但是它会跳过一些可能的匹配，仍然会进行不必要的比较，因此不会给出最佳的效率。为了进一步提高上述字符串匹配算法的效率，<strong class="ix hj"> KMP </strong>使用了<strong class="ix hj">针</strong>中包含的适当的前缀和后缀来避免不必要的比较。</p><p id="bb8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定一个字符串<strong class="ix hj"> ABCDEFABCR </strong>，我们在这个字符串中的正确前缀是<strong class="ix hj"> A，AB，ABC，ABCD，ABCDE，ABCDEF，ABCDEFA，ABCDEFAB，ABCDEFABC </strong>，后缀是<strong class="ix hj"> R，CR，BCR，ABCR，FABCR，EFABCR，DEFABCR，CDEFABCR，BCDEFABCR </strong>。现在，我们可以看到<strong class="ix hj"> A、AB、ABC </strong>是正确的前缀，它们也可以在字符串<strong class="ix hj"> ABCDEFABCR </strong>中包含的后缀中找到。</p><p id="bac4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="ix hj"> KMP </strong>中，我们构建了一个数组，告诉我们这些正确的前缀(也是<strong class="ix hj">指针</strong>的后缀)出现在哪里，我们用它来优化我们的搜索。下面的代码片段构建了一个数组，告诉我们<strong class="ix hj">“最长的正确前缀也是一个后缀(LPS)”</strong>出现在哪里。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><h2 id="6430" class="lh ju hi bd jv ln lo lp jz lq lr ls kd jg lt lu kh jk lv lw kl jo lx ly kp lz bi translated">使用LPS阵列</h2><p id="9f72" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">当我们发现正在比较的字符不匹配，并且该字符的索引不是第一个索引(0)时，我们查找该字符之前的<strong class="ix hj"> LPS </strong>值，以了解在<strong class="ix hj">针</strong>中可以跳过多少个字符。然后，我们开始将不匹配的字符与最后跳过的字符之后的字符进行比较。如果第一个字符出现不匹配，我们将<strong class="ix hj">针</strong>移动到<strong class="ix hj">干草堆</strong>中的下一个字符。</p><pre class="kw kx ky kz fd lc ld le lf aw lg bi"><span id="62b1" class="lh ju hi ld b fi li lj l lk ll"># HOW KMP MOVES UTILIZES THE LPS<br/>The LPS for <strong class="ld hj">ABCDEABCD = [0,0,0,0,0,1,2,3,4]</strong></span><span id="9542" class="lh ju hi ld b fi lm lj l lk ll"><strong class="ld hj">C</strong>ABCDEKLSDSABCDEABCD<br/><strong class="ld hj">A</strong>BCDEABCD</span><span id="ce77" class="lh ju hi ld b fi lm lj l lk ll">CABCDEAB<strong class="ld hj">R</strong>DABCDEABCD<br/> ABCDEAB<strong class="ld hj">C</strong>D</span><span id="addf" class="lh ju hi ld b fi lm lj l lk ll"># <strong class="ld hj">A</strong> and <strong class="ld hj">B </strong>are italicized to show that they are skipped. <br/># Rather than begin comparing from index 0, we start our comparison from index <strong class="ld hj">2<br/># </strong>The <strong class="ld hj">possible match</strong> <strong class="ld hj"><em class="ma">AB </em></strong>is<strong class="ld hj"><em class="ma"> </em></strong>however not skipped even though we never compare the two characters.</span><span id="5a98" class="lh ju hi ld b fi lm lj l lk ll">CABCDEAB<strong class="ld hj">R</strong>DABCDEABCD<br/>      <em class="ma">AB</em><strong class="ld hj">C</strong>DEABCD</span><span id="6c3e" class="lh ju hi ld b fi lm lj l lk ll">CABCDEABR<strong class="ld hj">D</strong>ABCDEABCD<br/>         <strong class="ld hj">A</strong>BCDEABCD</span><span id="7234" class="lh ju hi ld b fi lm lj l lk ll">CABCDEABRD<strong class="ld hj">ABCDEABCD</strong><br/>          <strong class="ld hj">ABCDEABCD</strong></span></pre><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">完整的Knuth Morris Pratt算法</figcaption></figure></div></div>    
</body>
</html>