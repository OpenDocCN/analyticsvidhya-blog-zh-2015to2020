<html>
<head>
<title>5 places where Initializer List is a compulsion in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中强制使用初始化列表的5个地方</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/5-places-where-initializer-list-is-a-compulsion-in-c-7b0417d927d1?source=collection_archive---------20-----------------------#2020-10-31">https://medium.com/analytics-vidhya/5-places-where-initializer-list-is-a-compulsion-in-c-7b0417d927d1?source=collection_archive---------20-----------------------#2020-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/43a7162214f6f1a06fce69ad8d6040d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*SH_DSvio2AXnWRj2Qzuf-g.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">初始化列表</strong></figcaption></figure><p id="4650" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">初始化列表用于初始化一个类的数据成员。要初始化的成员列表用constructor表示为逗号分隔的列表，后跟一个冒号。</p><p id="d716" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">语法以冒号(:)开头，然后是用逗号分隔的每个变量及其值。初始化列表不以分号结束。</p><p id="14cd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">语法:</strong> <br/> <code class="du jp jq jr js b">Constructorname(datatype value1, datatype value2):datamember{value1},datamember{value2}<br/>{<br/> ...<br/>}</code></p><p id="255e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里有5个地方，初始化列表在c++中是强制的，你不能直接赋值给成员变量</p><ol class=""><li id="a339" class="jt ju hi it b iu iv iy iz jc jv jg jw jk jx jo jy jz ka kb bi translated">没有初始化列表，你不能初始化你的类的非静态常量数据成员</li></ol><p id="faec" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">当你的类有一个常量数据成员<strong class="it hj"> _x，</strong>时，它必须使用初始化列表来初始化，你不能在构造函数中给它赋值</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kc"><img src="../Images/6ad7e481ecb8c1e8705253ad5527bbee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*dRhN2NYlVWe_mUkQLnVhYA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">【正确】工作正常</strong></figcaption></figure><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/7a79b18b7bc4ce676c4d3326bd8a4c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*33dq30ZiOSPXpp2R7T-Liw.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">错误:</strong>“const int”[-fpermissive]|<br/>|<strong class="bd iq">【错误】错误:</strong>只读成员“Base::_x”的赋值</figcaption></figure><p id="deaa" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> 2。没有初始化列表</strong>你不能初始化你的类的引用变量</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es ki"><img src="../Images/831700916abce24c1b81faee73dcfb7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*Jauu2hILE2T7I6tTF6-xJQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">【正确】工作正常</strong></figcaption></figure><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/1c8aa5b6bcad9c46948a915ef70caa7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*zRgxiLK-MtfoG1H_YmtmjA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">错误:</strong>在“int&amp;”[-fpermissive]|</figcaption></figure><p id="de6d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> 3。如果第一个类(类一)没有自己的默认构造函数，则不能在另一个类(类二)中初始化一个类数据成员。</strong></p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/1f85625bb9a0655297df953a81d64ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*wg0qTK1D1VqdrF0AseBNRQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">【正确】工作正常</strong></figcaption></figure><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/7f5ccd8d1b3a10005a83ac834913613b.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*spRBvelIEzcR6cksUDuezQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">错误:</strong>没有用于调用“One::One()”的匹配函数|</figcaption></figure><p id="7cf9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以在这里，当在main()函数中调用<strong class="it hj"> Two two(one) </strong>时，在第27行:当one作为class 2构造函数的参数x (One x)传递时，我们预计调用的是class 1的默认构造函数。</p><p id="c10a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">因为我们还没有为类一定义默认的构造函数，它抛出一个错误。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es km"><img src="../Images/23e851db42abba77e51220ff8acee450.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*9avaMMTemF_OSjxbAwdHrw.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">【正确】工作正常。</strong>像我们为类一()添加默认构造函数一样工作</figcaption></figure><p id="896f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> 4。不使用初始化列表</strong>就不能从子类初始化基类数据成员</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kn"><img src="../Images/559884bd38420a5734bc61a85a957c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*xzoeArhpKyQV-oyPHToiCQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">【正确】工作正常</strong></figcaption></figure><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/2173cb10b258818064633df81ce920ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*mnk-XO_gS8G9GEkctR1ncA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">错误:</strong>“int Base::_ x”在此上下文中是私有的</figcaption></figure><p id="234b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> 5。当你有与数据成员名完全相似的临时变量时，你必须使用一个初始化列表</strong></p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/bba4e010f99ae08e8a2e60b97a048c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*25OuI7esQz_bIimJ5DmvUQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">【正确】工作正常</strong></figcaption></figure><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/e7f2c1cb5e0db3b1e8f4178e3336fce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*PAHeYNx6vvJOgPhYgj6-cg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">【错误】</strong>打印变量_x的随机值</figcaption></figure><p id="1319" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">感谢阅读，将相关代码上传到我的Github页面<br/><a class="ae kr" href="https://github.com/MaajidKhan" rel="noopener ugc nofollow" target="_blank">【https://github.com/MaajidKhan】</a></p></div></div>    
</body>
</html>