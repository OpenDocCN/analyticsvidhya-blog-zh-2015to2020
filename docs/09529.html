<html>
<head>
<title>Create reproducible Machine Learning experiments using Sacred</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Sacred 创建可重复的机器学习实验</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/create-reproducible-machine-learning-experiments-using-sacred-f8176ea3d42d?source=collection_archive---------15-----------------------#2020-09-09">https://medium.com/analytics-vidhya/create-reproducible-machine-learning-experiments-using-sacred-f8176ea3d42d?source=collection_archive---------15-----------------------#2020-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e891" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">每个实验都是神圣的</em> <br/> <em class="jd">每个实验都是伟大的</em> <br/> <em class="jd">如果一个实验被浪费了</em> <br/> <em class="jd">上帝会非常生气</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/42696ae90c6c96630863b493d66905d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N0meVZd5_3XISn7t"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><a class="ae ju" href="https://unsplash.com/@kasiape?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Katarzyna Pe </a>在<a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="1ee0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ju" href="https://github.com/IDSIA/sacred" rel="noopener ugc nofollow" target="_blank">神圣</a>让你配置、组织、记录和复制实验。它是专门为 ML 实验设计的，但实际上可以用于任何种类的实验。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="e40b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了举例说明如何使用这个强大的框架，我将使用一个 Kaggle 竞赛的数据集，<a class="ae ju" href="https://www.kaggle.com/c/nlp-getting-started" rel="noopener ugc nofollow" target="_blank">真实与否？灾难推文 NLP</a>。这个竞赛是一个二元分类问题，你应该决定一条推文是否描述了一场真实的灾难。这里有两个例子:</p><p id="3433" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">真实灾难推文:</strong></p><pre class="jf jg jh ji fd kc kd ke kf aw kg bi"><span id="1066" class="kh ki hi kd b fi kj kk l kl km">Forest fire near La Ronge Sask. Canada</span></pre><p id="7e8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不是灾难推文:</strong></p><pre class="jf jg jh ji fd kc kd ke kf aw kg bi"><span id="9777" class="kh ki hi kd b fi kj kk l kl km">I love fruits</span></pre><blockquote class="kn"><p id="6dd0" class="ko kp hi bd kq kr ks kt ku kv kw jc dx translated">数据科学家迟早会注意到，模型的性能在很大程度上依赖于特定的配置和无数的数据修改。</p></blockquote><p id="2c86" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">假设我们想要运行一些实验，我们建立一个模型来对这些推文进行分类，并使用<a class="ae ju" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html" rel="noopener ugc nofollow" target="_blank"> k 倍交叉验证</a>来测量分类器的<a class="ae ju" href="https://en.wikipedia.org/wiki/F1_score" rel="noopener ugc nofollow" target="_blank"> F1 得分</a>。大多数数据科学家可能会打开一个 Jupyter 笔记本，开始探索数据(顺便说一句，这确实总是正确的事情)，进行一些特别的实验，建立和评估模型。数据科学家迟早会注意到，模型的性能在很大程度上依赖于特定的配置和无数的数据修改。这就是再现性的力量开始得到回报的地方。</p><h1 id="f122" class="lc ki hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么神圣？</h1><p id="1103" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">以下是使用<strong class="ih hj">圣物</strong>的主要特点和优势:</p><ul class=""><li id="4f7e" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc mj mk ml mm bi translated">轻松地<strong class="ih hj">定义</strong>和<strong class="ih hj">封装</strong>每个实验的<strong class="ih hj">配置</strong></li><li id="20da" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">自动<strong class="ih hj">收集每次运行的元数据</strong></li><li id="9724" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><strong class="ih hj">记录</strong>自定义指标</li><li id="b395" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><strong class="ih hj">使用<strong class="ih hj">观察器</strong>收集各地的</strong>日志</li><li id="e47a" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">确保<strong class="ih hj">确定性</strong>与<strong class="ih hj">自动播种</strong>一起运行</li></ul><h1 id="05e6" class="lc ki hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何设置一个神圣的实验</h1><p id="d9bb" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">我们从创建一个神圣的基础实验开始，如下所示:</p><pre class="jf jg jh ji fd kc kd ke kf aw kg bi"><span id="1352" class="kh ki hi kd b fi kj kk l kl km">logreg_experiment = <strong class="kd hj">Experiment</strong>(‘logreg’)</span></pre><p id="4ed6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个神圣的实验是由一个配置定义的，所以让我们创建一个:</p><pre class="jf jg jh ji fd kc kd ke kf aw kg bi"><span id="2531" class="kh ki hi kd b fi kj kk l kl km">@logreg_experiment.config<br/>def <strong class="kd hj">baseline_config</strong>():<br/>    max_features = None<br/>    classifier = <strong class="kd hj">Pipeline</strong>([<br/>        (‘tfidf’, <strong class="kd hj">TfidfVectorizer</strong>(max_features=max_features)),<br/>        (‘clf’, <strong class="kd hj">LogisticRegression</strong>())<br/>    ])</span></pre><p id="f995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，实验对象的<code class="du ms mt mu kd b">config</code>属性被用作函数装饰器。这使得神圣的自动检测，该功能应被用来配置实验。</p><p id="c89f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个非常简单的配置定义了一个包含两个步骤的<strong class="ih hj"> scikit-learn 管道</strong>:计算所有 tweets 的<a class="ae ju" href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf" rel="noopener ugc nofollow" target="_blank"> TF-IDF </a>表示，然后使用<a class="ae ju" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html" rel="noopener ugc nofollow" target="_blank">逻辑回归</a>对它们进行分类。我为其中一个超级参数<code class="du ms mt mu kd b">max_features</code>添加了一个变量，以展示如何通过修改配置来轻松创建新的实验。</p><p id="7162" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在运行这个实验之前，必须定义一个主函数:</p><pre class="jf jg jh ji fd kc kd ke kf aw kg bi"><span id="0e74" class="kh ki hi kd b fi kj kk l kl km">@logreg_experiment.automain<br/>def <strong class="kd hj">main</strong>(classifier):<br/>    datadir = <strong class="kd hj">Path</strong>(‘../data’)<br/>    train_df = pd.<strong class="kd hj">read_csv</strong>(datadir / ‘train.csv’)<br/>    scores = <strong class="kd hj">cross_val_score</strong>(classifier, train_df[‘text’],<br/>        train_df[‘target’], cv=5, scoring=’f1')<br/>    mean_clf_score = scores.<strong class="kd hj">mean</strong>()<br/>    logreg_experiment.<strong class="kd hj">log_scalar</strong>(‘f1_score’, mean_clf_score)</span></pre><p id="60ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，我们再次使用实验对象的属性作为装饰，在这个例子中是<code class="du ms mt mu kd b">automain</code>。这让 main 函数自动访问这个实验的配置中定义的任何变量。在这种情况下，我们只通过了<code class="du ms mt mu kd b">classifier</code>,将根据它在训练集上使用 5 重交叉验证对 Twitter 数据进行分类的能力进行评估。在最后一行代码中，我们想要测量的指标是使用<code class="du ms mt mu kd b">log_scalar</code>方法记录的。</p><h1 id="0be8" class="lc ki hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">进行实验</h1><p id="6692" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">要运行实验，只需调用它的<code class="du ms mt mu kd b">run()</code>方法。为了用不同的参数值运行它，您可以方便地传递一个 dict <code class="du ms mt mu kd b">config_updates</code>来指定这个实验运行的确切配置。相当整洁！</p><pre class="jf jg jh ji fd kc kd ke kf aw kg bi"><span id="c436" class="kh ki hi kd b fi kj kk l kl km"># Run with default values<br/>logreg_experiment.<strong class="kd hj">run</strong>()</span><span id="2f70" class="kh ki hi kd b fi mv kk l kl km"># Run with config updates<br/>logreg_experiment.<strong class="kd hj">run</strong>(config_updates={‘max_features’: 1000})</span></pre><p id="f576" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我通常将实验本身放在不同的文件中，然后有一个单独的脚本来一次运行所有的实验。</p><h1 id="d9cc" class="lc ki hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">记录您的结果</h1><p id="8f82" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">如果你运行上面的，你不会看到很多结果。你首先需要将一个<strong class="ih hj">观察者</strong>连接到实验上。然后<strong class="ih hj">观察者</strong>会将<strong class="ih hj">日志</strong>发送到某个<strong class="ih hj">目的地</strong>，通常是一个<strong class="ih hj">数据库</strong>。对于本地和非生产用途，您可以使用<code class="du ms mt mu kd b">FileStorageObserver</code>简单地写入磁盘。</p><pre class="jf jg jh ji fd kc kd ke kf aw kg bi"><span id="5597" class="kh ki hi kd b fi kj kk l kl km">logreg_experiment.observers.<strong class="kd hj">append</strong>(<strong class="kd hj">FileStorageObserver</strong>(‘logreg’))</span></pre><p id="89ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您在上面的 runner 脚本中包含这一行并运行它，那么每次运行都会创建一个新文件夹<code class="du ms mt mu kd b">logreg</code>,其中包含一个子文件夹。一个用于默认运行，一个具有更新的<code class="du ms mt mu kd b">max_features</code>值。每个人都创建了四个单独的文件，内容如下:</p><ul class=""><li id="ca59" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc mj mk ml mm bi translated"><strong class="ih hj"> config.json </strong>:配置<strong class="ih hj">中每个对象的状态</strong>，以及在所有<strong class="ih hj">非确定性函数</strong>中自动使用的<code class="du ms mt mu kd b">seed</code>参数，以保证<strong class="ih hj">再现性</strong>。</li><li id="6655" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><strong class="ih hj"> cout.txt </strong>:运行过程中产生的所有<strong class="ih hj">标准输出</strong>。</li><li id="31c5" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><strong class="ih hj"> metrics.json </strong> : <strong class="ih hj">在运行过程中记录的自定义指标</strong>，例如我们案例中的 F1 分数。</li><li id="7833" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated"><strong class="ih hj"> run.json </strong> : <strong class="ih hj">元数据</strong>例如关于源代码(git repo、文件、依赖项等。)、运行主机、启动/停止时间等。</li></ul><h1 id="928f" class="lc ki hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">把所有的放在一起</h1><p id="34b1" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">为了完整起见，我将创建最后一个示例来展示如何从同一个 runner 脚本运行多个实验:</p><pre class="jf jg jh ji fd kc kd ke kf aw kg bi"><span id="5902" class="kh ki hi kd b fi kj kk l kl km">from pathlib import Path<br/>import pandas as pd<br/>from sacred import Experiment<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.feature_extraction.text import TfidfVectorizer<br/>from sklearn.model_selection import cross_val_score<br/>from sklearn.pipeline import Pipeline</span><span id="ab05" class="kh ki hi kd b fi mv kk l kl km">rand_forest_experiment = <strong class="kd hj">Experiment</strong>(‘randforest’)</span><span id="3ec3" class="kh ki hi kd b fi mv kk l kl km"><br/>@rand_forest_experiment.config<br/>def <strong class="kd hj">baseline_config</strong>():<br/>    n_estimators = 100<br/>    classifier = <strong class="kd hj">Pipeline</strong>([<br/>        (‘tfidf’, <strong class="kd hj">TfidfVectorizer</strong>()),<br/>        (‘clf’, <strong class="kd hj">RandomForestClassifier</strong>(n_estimators=n_estimators))<br/>    ])</span><span id="4acc" class="kh ki hi kd b fi mv kk l kl km">@rand_forest_experiment.automain<br/>def <strong class="kd hj">main</strong>(classifier):<br/>    datadir = <strong class="kd hj">Path</strong>(‘../data’)<br/>    train_df = pd.<strong class="kd hj">read_csv</strong>(datadir / ‘train.csv’)<br/>    scores = <strong class="kd hj">cross_val_score</strong>(classifier, train_df[‘text’],<br/>        train_df[‘target’], cv=5, scoring=’f1')<br/>    mean_clf_score = scores.<strong class="kd hj">mean</strong>()<br/>    rand_forest_experiment.<strong class="kd hj">log_scalar</strong>(‘f1_score’, mean_clf_score)</span></pre><p id="3dd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们通过一些配置更新来运行这两个实验…</p><pre class="jf jg jh ji fd kc kd ke kf aw kg bi"><span id="3b99" class="kh ki hi kd b fi kj kk l kl km">from sacred.observers import FileStorageObserver<br/>from experiments.logreg import logreg_experiment<br/>from experiments.randforest import rand_forest_experiment</span><span id="64d9" class="kh ki hi kd b fi mv kk l kl km">logreg_experiment.observers.<strong class="kd hj">append</strong>(<strong class="kd hj">FileStorageObserver</strong>(‘logreg’))<br/>rand_forest_experiment.observers.<strong class="kd hj">append</strong>(<strong class="kd hj">FileStorageObserver</strong>(‘randforest’))</span><span id="d016" class="kh ki hi kd b fi mv kk l kl km"># Run with default values<br/>logreg_experiment.<strong class="kd hj">run</strong>()</span><span id="37d9" class="kh ki hi kd b fi mv kk l kl km"># Run with config updates<br/>logreg_experiment.<strong class="kd hj">run</strong>(config_updates={‘max_features’: 1000})</span><span id="46ce" class="kh ki hi kd b fi mv kk l kl km"># Run different experiment<br/>rand_forest_experiment.<strong class="kd hj">run</strong>()<br/>rand_forest_experiment.<strong class="kd hj">run</strong>(config_updates={‘n_estimators’: 500})</span></pre><p id="8d9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过查看每次运行的<code class="du ms mt mu kd b">metrics.json</code>文件，我们可以得出结论，默认的逻辑回归模型表现最好，F1 值约为 0.66，而有 100 个估计值的随机森林表现最差，F1 值约为 0.53。</p><p id="0c12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，所有这些 json 格式的输出看起来并不是很吸引人，但是有几个<strong class="ih hj">可视化工具</strong>你可以使用。然而，这已经超出了本文的范围，但是可以看看这里:<a class="ae ju" href="https://github.com/IDSIA/sacred#Frontends" rel="noopener ugc nofollow" target="_blank">https://github.com/IDSIA/sacred#Frontends</a></p><p id="526f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安全实验！</p><p id="f121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文是构建和设计机器学习系统的最佳实践系列的一部分。在这里阅读第一部分:<a class="ae ju" rel="noopener" href="/analytics-vidhya/how-to-get-data-science-to-truly-work-in-production-bed80e6bcfee">https://medium . com/analytics-vid hya/how-to-get-data-science-to-really-work-in-production-bed 80 E6 bcfee</a></p></div></div>    
</body>
</html>