<html>
<head>
<title>Sudoku Puzzle Solver — How To Build Your Very First Python Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数独解谜器——如何构建您的第一个Python项目</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sudoku-puzzle-solver-how-to-build-your-very-first-python-project-b2f4c3e2160e?source=collection_archive---------4-----------------------#2019-12-23">https://medium.com/analytics-vidhya/sudoku-puzzle-solver-how-to-build-your-very-first-python-project-b2f4c3e2160e?source=collection_archive---------4-----------------------#2019-12-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b99cf7be3a76964c69b064c627447dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*sim-Ik0EVULNgYImIaL7ng.jpeg"/></div></figure><p id="818c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">编程新手通常会先熟悉编程语言的语法，然后通过各种网站，如<a class="ae jk" href="http://hackerrank.com" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>、<a class="ae jk" href="http://hackerearth.com" rel="noopener ugc nofollow" target="_blank"> HackerEarth </a>、<a class="ae jk" href="https://www.codewars.com" rel="noopener ugc nofollow" target="_blank"> CodeWars </a>、<a class="ae jk" href="http://projecteuler.net" rel="noopener ugc nofollow" target="_blank"> Project Euler </a>等，练习大量的挑战。</p><p id="6167" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虽然这些平台可以有效地帮助构建推理、思考、应用逻辑的技能，并帮助即兴编写代码以有效地处理大量输入数据，但它们缺乏的一点是帮助您构建合理规模的项目。当手头的任务变得更复杂时，它需要很多很多行代码。代码越多，其中重复的元素就越多，因此需要建立基本的技能来围绕函数和类构建代码。</p><p id="6c14" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用函数和类有助于开发人员将技能提升到编写有效的可重用代码的下一个层次。这需要一些头脑风暴和大量的实践。数独解谜是一个谦逊的努力，帮助初学者开始他们的第一个迷你项目，可以在一个小时左右建成。</p><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es jl"><img src="../Images/bf9e2b376ec474bed5be6fe6dd2a03c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*LhILD3pWC10OwmjjyLC2Tg.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">一个简单的数独游戏</figcaption></figure><p id="140f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">来自<a class="ae jk" href="https://techwithtim.net/tutorials/python-programming/sudoku-solver-backtracking/" rel="noopener ugc nofollow" target="_blank"> Teach With Tim </a>的Tim帮我轻松理解回溯算法。与他的相比，我的实现要复杂和耗时得多。一定要参考他的视频来理解可视化表示的回溯算法。</p><p id="e28b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">数独游戏的规则</strong></p><ol class=""><li id="09d7" class="ju jv hi io b ip iq it iu ix jw jb jx jf jy jj jz ka kb kc bi translated">它包含一个9 x 9的拼图网格，细分为3 x 3的9个数字块。</li><li id="8a00" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj jz ka kb kc bi translated">9 x 9拼图中任何单元格的每个数字只能是1到9之间的数字，包括1和9。</li><li id="a8d4" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj jz ka kb kc bi translated">每个3 x 3块应该在任何单元格中包含1到9之间的所有数字。因为一个3 x 3的方块有9个单元，很明显没有数字可以重复。</li><li id="ed0e" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj jz ka kb kc bi translated">类似地，9 x 9拼图的每一行必须包含1到9之间的所有数字。同样，由于每行有9个单元格，没有数字可以重复。</li><li id="9bbb" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj jz ka kb kc bi translated">每一列需要有1到9之间的数字，如上所述，没有数字可以重复。</li></ol><p id="e464" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦我们完全填写了一个满足上述所有标准的数独谜题，我们就可以有把握地认为这个谜题已经解决了。</p><p id="8c8d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">构建程序的步骤</strong></p><ol class=""><li id="8279" class="ju jv hi io b ip iq it iu ix jw jb jx jf jy jj jz ka kb kc bi translated">我们从左到右，从上到下迭代这个难题</li><li id="f7b8" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj jz ka kb kc bi translated">迭代通过难题，直到你找到一个空的细胞。</li><li id="ec89" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj jz ka kb kc bi translated">请填写有效的数字。一个有效的数字既不在单元格所在的行中，也不在单元格所在的列中，也不在单元格所在的3 x 3块中。这是因为没有一个数字可以在一行、一列和3×3块中重复一次以上。</li><li id="5338" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj jz ka kb kc bi translated">找到有效号码后，重复步骤2和3。</li><li id="bb99" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj jz ka kb kc bi translated">在执行步骤4时，如果我们到达空单元格中没有有效数字的点，我们回溯并移动到由算法填充的前一个单元格，以找到下一个有效数字，并使用回溯和找到下一个有效数字来继续重复难题步骤2和3。回溯可能听起来有点复杂，但我会花时间用下面的代码解释它。</li><li id="d841" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj jz ka kb kc bi translated">重复该过程，直到拼图中不存在空单元格。</li></ol><p id="22ea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">既然我们已经制定了一个简单的算法来帮助生成数独难题的解决方案，让我们花点时间来分析需要定义函数的重复步骤。</p><ul class=""><li id="1baf" class="ju jv hi io b ip iq it iu ix jw jb jx jf jy jj ki ka kb kc bi translated">一个可选的功能，帮助加载从一个. txt文件的难题</li><li id="4536" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj ki ka kb kc bi translated">查找空单元格的函数</li><li id="49fe" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj ki ka kb kc bi translated">一个函数，用于判断一个数字是否可以填充到一个空单元格中。</li><li id="badc" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj ki ka kb kc bi translated">需要时随时打印纸板的功能</li><li id="1cef" class="ju jv hi io b ip kd it ke ix kf jb kg jf kh jj ki ka kb kc bi translated">使用上述方法解决难题的功能</li></ul><p id="3a14" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们一步一步地构建算法，以便更好地理解。</p><p id="61cf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">任务1:编写一个函数，帮助从文本文件 <br/>加载谜题，或者，你可以在你的程序中预定义变量<code class="du kj kk kl km b">board</code>并将一个谜题存储为9个元素的列表，每个元素代表数独谜题的一行，因此列表的每个元素也是9个数字的列表。</p><p id="3990" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请务必注意。为了便于表示，我们用一个<code class="du kj kk kl km b">0</code>填充拼图中所有的空白区域，并在<code class="du kj kk kl km b">1 and 9</code>之间分别填入数字。</p><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es jl"><img src="../Images/2172f3f021547f41ef66771d486965b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*WPbsBVeTXGf0vM1wEMXrgg.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">在空白单元格中填充0的拼图示例</figcaption></figure><p id="4da4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们现在从代码开始。让我先向您展示代码，然后解释它的作用。</p><pre class="jm jn jo jp fd kn km ko kp aw kq bi"><span id="8d2e" class="kr ks hi km b fi kt ku l kv kw">def loadPuzzle():<br/>    """<br/>    A method to read a file having puzzle in it. The puzzle should have nine lines<br/>     of nine numbers each between 0-9 seprated by commas.<br/>     <br/>    Arguments:<br/>    None<br/>    <br/>    Output:<br/>    A list variable board<br/>    """<br/>    board = []<br/>    fileHandle = open("SudokuPuzzle.txt", "r")<br/>    puzzle = fileHandle.readlines()<br/>    for line in range(len(puzzle)):<br/>        if line != len(puzzle) - 1:<br/>            puzzle[line] = puzzle[line][:-1]<br/>            board.append(list(map(int,puzzle[line].split(","))))<br/>        else:<br/>            board.append(list(map(int,puzzle[line].split(","))))<br/>    fileHandle.close()<br/>    return board</span></pre><p id="506b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们首先使用代码<code class="du kj kk kl km b">fileHandle = open("SudokuPuzzle.txt", "r")</code>以读取模式打开一个文本文件。您可以根据您的文件名和文件路径编辑此代码。</p><p id="ee9d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下一行代码，<code class="du kj kk kl km b">puzzle = fileHandle.readlines()</code>读取文件中的所有行。</p><p id="ac04" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">for循环遍历<code class="du kj kk kl km b">puzzle</code>变量中的每一行。for循环的内容如下。对于除最后一行之外的所有行，读取该行，删除最后一个字符，即<code class="du kj kk kl km b">\n</code>，这是一个新的行字符，出现在<code class="du kj kk kl km b">SudokuPuzzle.txt</code>文件中除最后一行之外的所有行中，用<code class="du kj kk kl km b">,</code>作为分隔符将其拆分，并将其转换为一个列表。对于<code class="du kj kk kl km b">SudokuPuzzle.txt</code>文件的最后一行，由于最后没有新的行字符，我们直接读取该行并用<code class="du kj kk kl km b">,</code>作为分隔符将其拆分。</p><p id="dab6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们关闭文件并返回<code class="du kj kk kl km b">board</code>变量，该变量实际上将数独难题存储为一个9个元素的列表，每个元素又是一个在<code class="du kj kk kl km b">0 and 9</code>和<code class="du kj kk kl km b">0</code>之间的9个数字的列表，代表一个空单元格。</p><p id="a1f6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">任务2:如前所述，查找下一个空单元格</strong> <br/>的函数。我们在拼图中首先从左到右，然后从上到下进行迭代。这基本上意味着我们必须遍历<code class="du kj kk kl km b">board</code>元素，获取第一个列表，遍历它，然后是下一个列表，依此类推。这个函数的代码非常简单，一目了然。</p><pre class="jm jn jo jp fd kn km ko kp aw kq bi"><span id="6fe9" class="kr ks hi km b fi kt ku l kv kw">def findEmpty(board):<br/>    """<br/>    A method to find the next empty cell of the puzzle.<br/>    Iterates from left to right and top to bottom<br/>    <br/>    Arguments:<br/>    board - a list of nine sub lists with 9 numbers in each sub list<br/>    <br/>    Output:<br/>    A tuple (i, j) which is index of row, column<br/>    """<br/>    for i in range(len(board)):<br/>        for j in range(len(board[0])):<br/>            if board[i][j] == 0:<br/>                return (i, j) #row, column<br/>    return None</span></pre><p id="cb6f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的函数基本上会返回一个元组<code class="du kj kk kl km b">(i, j)</code>，它是找到的空单元格的行号和列号。如果没有找到空单元格，函数返回<code class="du kj kk kl km b">None</code>变量。</p><p id="2a17" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.一个函数，用于判断一个数字是否可以填充到一个空单元格中。我们不尝试任何复杂的方法来预测哪个数字适合一个空单元格，算法所做的只是检查该数字是否已经存在于相应的行、列和3 x 3框中。如果号码已经存在，函数返回一个<code class="du kj kk kl km b">False</code>，否则返回<code class="du kj kk kl km b">True</code>。</p><pre class="jm jn jo jp fd kn km ko kp aw kq bi"><span id="da01" class="kr ks hi km b fi kt ku l kv kw">def valid(board, num, pos):<br/>    """<br/>    A method to find if a number num is valid or not<br/>    <br/>    Arguments:<br/>    board - a list of nine sub lists with 9 numbers in each sub list<br/>    num - a number between 1 to 9 both inclusive<br/>    pos - a tuple (i, j) representing row, column<br/>    <br/>    Output:<br/>    True if the number is valid in position pos of puzzle else False.<br/>    """<br/>    row = pos[0]<br/>    column = pos[1]</span><span id="0d43" class="kr ks hi km b fi kx ku l kv kw">    #checking rows<br/>    for i in range(len(board[0])):<br/>        if board[row][i] == num and column != i:<br/>            return False</span><span id="793b" class="kr ks hi km b fi kx ku l kv kw">    #checking columns<br/>    for i in range(len(board)):<br/>        if board[i][column] == num and row != i:<br/>            return False<br/>    <br/>    #checking box<br/>    startRowBox = row//3 <br/>    startColumnBox= column//3<br/>    for i in range(startRowBox*3, (startRowBox*3)+3):<br/>        for j in range(startColumnBox*3, (startColumnBox*3)+3):<br/>            if board[i][j] == num and row != i and column != j:<br/>                return False<br/>    return True</span></pre><p id="9370" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码非常简单。在第一种情况下，for循环遍历存储在变量<code class="du kj kk kl km b">row</code>中的行号的每个元素，除了正在被测试以填充值<code class="du kj kk kl km b">num</code>的单元格的位置。如果检测到该数字已经存在于该行中，则返回<code class="du kj kk kl km b">False</code>。</p><p id="feba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后它移动到检查列。列号存储在变量<code class="du kj kk kl km b">column</code>中。如果变量<code class="du kj kk kl km b">num</code>中的值已经存在于列号<code class="du kj kk kl km b">column</code>中，那么函数返回<code class="du kj kk kl km b">False</code>。</p><p id="2e61" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来是3 x 3框，其中显示了当前的空单元格。为了生成3×3代码迭代，我们假设整个拼图被分成9个3×3块的单元，每行的索引号为0、1和2，每列的索引号为0、1和2。第一个盒子的位置是(0，0)，第二个盒子的位置是(0，1)，依此类推，直到最后一个盒子的位置是(2，2)。</p><p id="f38b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">前两行代码帮助使用检测空单元格所在的框的位置。然后，我们使用这些位置信息来遍历3 x 3块，并检查变量<code class="du kj kk kl km b">num</code>中的值是否已经存在于该块中。如果存在，函数返回<code class="du kj kk kl km b">False</code>，否则函数结束返回<code class="du kj kk kl km b">True</code>。</p><p id="ce56" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 4。需要时随时打印棋盘的功能</strong> <br/>我们已经知道数独谜题以嵌套列表的形式存储在变量<code class="du kj kk kl km b">board</code>中，但是具有以视觉上吸引人的方式打印谜题的功能会有所帮助。</p><pre class="jm jn jo jp fd kn km ko kp aw kq bi"><span id="90fd" class="kr ks hi km b fi kt ku l kv kw">def printBoard(board):<br/>    """<br/>    A method to print the sudoku puzzle in a visually appealing format<br/>    <br/>    Arguments:<br/>    board - a list of nine sub lists with 9 numbers in each sub list<br/>    <br/>    Output:<br/>    Prints a nine x nine puzzle represented as a sudoku puzzle. Returns None.<br/>    """<br/>    if not findEmpty(board):<br/>        print("Finished puzzle")<br/>    else:<br/>        print("Unsolved puzzle")<br/>    for i in range(len(board)):<br/>        if i%3 == 0:<br/>            print("-------------------")<br/>            <br/>        for j in range(len(board[0])):<br/>            if j%3 == 0:<br/>                print("\b|", end ="")<br/>            <br/>            print(str(board[i][j])+" ", end="")<br/>        print("\b|")<br/>    print("-------------------")</span></pre><p id="be2d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同样，在非常基础的层面上，我们迭代通过<code class="du kj kk kl km b">board</code>变量并打印出每一行，但是我们检测位置0、3、6和9来打印它们之间的间隔符，这样它看起来就像一个数独游戏。</p><pre class="jm jn jo jp fd kn km ko kp aw kq bi"><span id="c181" class="kr ks hi km b fi kt ku l kv kw">Unsolved puzzle<br/>-------------------<br/>|7 8 0|4 0 0|1 2 0|<br/>|6 0 0|0 7 5|0 0 9|<br/>|0 0 0|6 0 1|0 7 8|<br/>-------------------<br/>|0 0 7|0 4 0|2 6 0|<br/>|0 0 1|0 5 0|9 3 0|<br/>|9 0 4|0 6 0|0 0 5|<br/>-------------------<br/>|0 7 0|3 0 0|0 1 2|<br/>|1 2 0|0 0 7|4 0 0|<br/>|0 4 9|2 0 6|0 0 7|<br/>-------------------</span></pre><p id="f018" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个函数的开始，它会检查拼图中是否还有空的单元格。如果是，它将标题打印为<code class="du kj kk kl km b">Unsolved puzzle</code>，但如果没有空单元格，则意味着已经找到解决方案，因此该函数将标题打印为<code class="du kj kk kl km b">Finished puzzle</code>。</p><pre class="jm jn jo jp fd kn km ko kp aw kq bi"><span id="47f9" class="kr ks hi km b fi kt ku l kv kw">Finished puzzle<br/>-------------------<br/>|7 8 5|4 3 9|1 2 6|<br/>|6 1 2|8 7 5|3 4 9|<br/>|4 9 3|6 2 1|5 7 8|<br/>-------------------<br/>|8 5 7|9 4 3|2 6 1|<br/>|2 6 1|7 5 8|9 3 4|<br/>|9 3 4|1 6 2|7 8 5|<br/>-------------------<br/>|5 7 8|3 9 4|6 1 2|<br/>|1 2 6|5 8 7|4 9 3|<br/>|3 4 9|2 1 6|8 5 7|<br/>-------------------</span></pre><p id="0323" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">5.使用上述方法解谜的功能<br/>解决方案的最后也是最重要的部分。我将首先分享整个代码，然后深入每一行进一步解释它，包括回溯部分。不要被复杂的词汇吓倒，比如回溯算法，这只是一个递归函数，就像最基本的斐波那契数列解一样，经常用递归来教授。</p><pre class="jm jn jo jp fd kn km ko kp aw kq bi"><span id="9502" class="kr ks hi km b fi kt ku l kv kw">def solve(board):<br/>    """<br/>    A method to solve the sudoku puzzle using the other functions defined.<br/>    We use a simple recursion and backtracking method.<br/>    <br/>    Arguments:<br/>    board - a list of nine sub lists with 9 numbers in each sub list<br/>    <br/>    Output:<br/>    Returns True once the puzzle is successfully solved else False<br/>    """<br/>    find = findEmpty(board)<br/>    <br/>    if not find:<br/>        return True<br/>    else:<br/>        row, col = find<br/>    <br/>    for i in range(1,10):<br/>        if valid(board, i, find):<br/>            board[row][col] = i<br/>            <br/>            if solve(board):<br/>                return True<br/>            <br/>            board[row][col] = 0<br/>    return False</span></pre><p id="a608" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码的第一部分<code class="du kj kk kl km b">find = findEmpty(board)</code>基本上是调用带参数的<code class="du kj kk kl km b">findEmpty(board)</code>函数作为board，并要求它找到下一个空单元格。如果没有找到空单元格，它要么返回一个元组作为<code class="du kj kk kl km b">(row, column)</code>坐标，要么返回<code class="du kj kk kl km b">None</code>。</p><p id="002d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后我们定义递归的基本情况</p><pre class="jm jn jo jp fd kn km ko kp aw kq bi"><span id="b779" class="kr ks hi km b fi kt ku l kv kw">if not find:<br/>    return True</span></pre><p id="40f2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">也就是说，如果<code class="du kj kk kl km b">find</code>的值为<code class="du kj kk kl km b">None</code>,则意味着谜题已经被成功解决，并且<code class="du kj kk kl km b">solve()</code>函数返回值<code class="du kj kk kl km b">True</code>,表示相同的情况。但是如果谜题还没有解决，并且<code class="du kj kk kl km b">findEmpty()</code>函数返回了一个元组，那么我们将<code class="du kj kk kl km b">find</code>的变量存储在<code class="du kj kk kl km b">row and column</code>变量中。我们也可以直接使用<code class="du kj kk kl km b">find[0] and find[1]</code>，但是使用更好的变量表示会更容易理解代码。</p><p id="c4c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后我们开始算法的一部分，开始猜测哪个值适合由<code class="du kj kk kl km b">find</code>表示的空单元格。我们从1开始迭代，直到9，每次都调用<code class="du kj kk kl km b">valid()</code>函数，直到它返回<code class="du kj kk kl km b">True</code>，表明它是有效的猜测。在填入猜测值后，我们用新填入的值再次递归调用<code class="du kj kk kl km b">solve()</code>函数。这一次，它将获得下一个空单元格，并重复这个过程。这种递归将继续下去，直到它成功地填充了这次迭代中的所有值，或者遇到了这样一种情况，即它到达了一个从1到9的值都无效的单元格。</p><p id="fa05" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当它到达一个单元格不能将任何数字作为有效值的情况时，它意味着先前的猜测之一是不正确的，因此递归在这里停止，并且在递归调用之后的代码行，<code class="du kj kk kl km b">board[row][column] = 0</code>用于最后猜测的递归深度被调用。所以这基本上意味着，把最后一个猜测值设回0，并为它寻找一个新的猜测值。例如:如果最后一次猜测是5，我们将其设置回0，for循环继续测试6是否是有效的猜测，然后是7、8、9等等。如果找到一个有效的猜测，它继续填充下一个空单元格，如果没有，那么它甚至进一步回溯并用0填充它，并再次尝试新的猜测。所以基本上，算法通过递归不断回溯每一步。</p><p id="4626" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦电路板被填入有效值，它返回<code class="du kj kk kl km b">True</code>并退出该功能。</p><p id="d207" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在这里分享一个程序的全部代码。</p><pre class="jm jn jo jp fd kn km ko kp aw kq bi"><span id="100f" class="kr ks hi km b fi kt ku l kv kw">#!/usr/bin/env python3<br/># -*- coding: utf-8 -*-<br/>"""<br/>Created on Sun Dec 22 12:24:49 2019</span><span id="2e9c" class="kr ks hi km b fi kx ku l kv kw"><a class="ae jk" href="http://twitter.com/author" rel="noopener ugc nofollow" target="_blank">@author</a>: raghu<br/>"""<br/>#uncomment the code below to initiate a puzzle board <br/>#instead of loading it from a file<br/># =============================================================================<br/># board = [<br/>#     [7, 8, 0, 4, 0, 0, 1, 2, 0],<br/>#     [6, 0, 0, 0, 7, 5, 0, 0, 9],<br/>#     [0, 0, 0, 6, 0, 1, 0, 7, 8],<br/>#     [0, 0, 7, 0, 4, 0, 2, 6, 0],<br/>#     [0, 0, 1, 0, 5, 0, 9, 3, 0],<br/>#     [9, 0, 4, 0, 6, 0, 0, 0, 5],<br/>#     [0, 7, 0, 3, 0, 0, 0, 1, 2],<br/>#     [1, 2, 0, 0, 0, 7, 4, 0, 0],<br/>#     [0, 4, 9, 2, 0, 6, 0, 0, 7]<br/># ] <br/># =============================================================================</span><span id="8c06" class="kr ks hi km b fi kx ku l kv kw"># loading the puzzle from a file <br/>#comment the loadPuzzle code below if you want to iniate the board above        <br/>def loadPuzzle():<br/>    """<br/>    A method to read a file having puzzle in it. The puzzle should have nine lines<br/>     of nine numbers each between 0-9 seprated by commas.<br/>     <br/>    Arguments:<br/>    None<br/>    <br/>    Output:<br/>    A list variable board<br/>    """<br/>    board = []<br/>    fileHandle = open("SudokuPuzzle.txt", "r")<br/>    puzzle = fileHandle.readlines()<br/>    for line in range(len(puzzle)):<br/>        if line != len(puzzle) - 1:<br/>            puzzle[line] = puzzle[line][:-1]<br/>            board.append(list(map(int,puzzle[line].split(","))))<br/>        else:<br/>            board.append(list(map(int,puzzle[line].split(","))))<br/>    fileHandle.close()<br/>    return board</span><span id="90bd" class="kr ks hi km b fi kx ku l kv kw">def findEmpty(board):<br/>    """<br/>    A method to find the next empty cell of the puzzle.<br/>    Iterates from left to right and top to bottom<br/>    <br/>    Arguments:<br/>    board - a list of nine sub lists with 9 numbers in each sub list<br/>    <br/>    Output:<br/>    A tuple (i, j) which is index of row, column<br/>    """<br/>    for i in range(len(board)):<br/>        for j in range(len(board[0])):<br/>            if board[i][j] == 0:<br/>                return (i, j) #row, column<br/>    return None</span><span id="b97b" class="kr ks hi km b fi kx ku l kv kw">def valid(board, num, pos):<br/>    """<br/>    A method to find if a number num is valid or not<br/>    <br/>    Arguments:<br/>    board - a list of nine sub lists with 9 numbers in each sub list<br/>    num - a number between 1 to 9 both inclusive<br/>    pos - a tuple (i, j) representing row, column<br/>    <br/>    Output:<br/>    True if the number is valid in position pos of puzzle else False.<br/>    """<br/>    row = pos[0]<br/>    column = pos[1]<br/>    #checking rows<br/>    for i in range(len(board[0])):<br/>        if board[row][i] == num and column != i:<br/>            return False<br/>    #checking columns<br/>    for i in range(len(board)):<br/>        if board[i][column] == num and row != i:<br/>            return False<br/>    <br/>    #checking box<br/>    startRowBox = row//3 <br/>    startColumnBox= column//3<br/>    for i in range(startRowBox*3, (startRowBox*3)+3):<br/>        for j in range(startColumnBox*3, (startColumnBox*3)+3):<br/>            if board[i][j] == num and row != i and column != j:<br/>                return False<br/>    return True</span><span id="8af9" class="kr ks hi km b fi kx ku l kv kw">def printBoard(board):<br/>    """<br/>    A method to print the sudoku puzzle in a visually appealing format<br/>    <br/>    Arguments:<br/>    board - a list of nine sub lists with 9 numbers in each sub list<br/>    <br/>    Output:<br/>    Prints a nine x nine puzzle represented as a sudoku puzzle. Returns None.<br/>    """<br/>    if not findEmpty(board):<br/>        print("Finished puzzle")<br/>    else:<br/>        print("Unsolved puzzle")<br/>    for i in range(len(board)):<br/>        if i%3 == 0:<br/>            print("-------------------")<br/>            <br/>        for j in range(len(board[0])):<br/>            if j%3 == 0:<br/>                print("\b|", end ="")<br/>            <br/>            print(str(board[i][j])+" ", end="")<br/>        print("\b|")<br/>    print("-------------------")<br/>        <br/>def solve(board):<br/>    """<br/>    A method to solve the sudoku puzzle using the other functions defined.<br/>    We use a simple recursion and backtracking method.<br/>    <br/>    Arguments:<br/>    board - a list of nine sub lists with 9 numbers in each sub list<br/>    <br/>    Output:<br/>    Returns True once the puzzle is successfully solved else False<br/>    """<br/>    find = findEmpty(board)<br/>    <br/>    if not find:<br/>        return True<br/>    else:<br/>        row, col = find<br/>    <br/>    for i in range(1,10):<br/>        if valid(board, i, find):<br/>            board[row][col] = i<br/>            <br/>            if solve(board):<br/>                return True<br/>            <br/>            board[row][col] = 0<br/>    return False<br/>          <br/>board = loadPuzzle()   #loading the board from puzzle file     <br/>printBoard(board)      #printing the board before solving the puzzle<br/>solve(board)           #solving the puzzle<br/>printBoard(board)      #printing the puzzle after solving</span></pre></div></div>    
</body>
</html>