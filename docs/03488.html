<html>
<head>
<title>Introduction To Scikit-Learn Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scikit简介-学习管道</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/scikit-learn-pipeline-d43c80559257?source=collection_archive---------4-----------------------#2020-02-04">https://medium.com/analytics-vidhya/scikit-learn-pipeline-d43c80559257?source=collection_archive---------4-----------------------#2020-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/dbe3e8f43c280a78575ccda24c167cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*tMPeETsBL2Qq8-QHw0eS0w.jpeg"/></div></figure><p id="4215" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">假设您是一名机器学习工程师，您被银行雇佣来创建一个机器学习算法，以确定欺诈性交易，从而避免客户损失金钱。我猜你会尝试不同的机器学习算法，比如支持向量机、梯度提升树和逻辑回归，然后你会想评估哪种算法最适合你的数据集。</p><p id="f3d6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在正常情况下，您会创建估计器并将其分别拟合到您的数据集，这既单调又令人厌倦，但如果存在一种解决方案，您只需将所有机器学习算法拟合到您的数据集一次，而无需逐一迭代拟合每个估计器的过程，会怎么样呢？这就是Scikit-Learn的管道类发挥作用的地方。</p><p id="ce5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">流水线类顺序地应用列表变换和最终估计器。管道的中间步骤必须是转换，也就是说，它们必须实现fit和transform方法。</p><p id="0445" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">管道的目的是组装可以在设置不同参数时一起交叉验证的步骤。</p><p id="9c66" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">回到我们根据上面的管道定义为银行开发的机器学习应用程序。我们将使用的数据集在输入到我们的机器学习模型之前需要进行预处理，以便我们可以获得最佳结果。pipeline类将允许我们应用转换方法，如用于缩放数据的标准scaler和其他sklearn类，如gridsearch和k-fold。</p><p id="a9d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们分解使用python实现pipeline类的代码。github回购的链接在这里是<a class="ae jk" href="https://github.com/isheunesutembo/Scikit-Learn-Pipelines/blob/master/SkLearn%20Pipelines.ipynb" rel="noopener ugc nofollow" target="_blank"><em class="jl"/></a><em class="jl">。</em></p><p id="381d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在youtube上的视频<a class="ae jk" href="http://youtube.com/watch?v=GmuUpLtMxSU" rel="noopener ugc nofollow" target="_blank">在这里。</a></p><p id="ade8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将使用从scikit-learn导入的iris数据集。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="81b1" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.datasets</strong> <strong class="jr hj">import</strong> load_iris<br/><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.model_selection</strong> <strong class="jr hj">import</strong> train_test_split<br/><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.preprocessing</strong> <strong class="jr hj">import</strong> StandardScaler<br/><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.decomposition</strong> <strong class="jr hj">import</strong> PCA<br/><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.pipeline</strong> <strong class="jr hj">import</strong> Pipeline<br/><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.externals</strong> <strong class="jr hj">import</strong> joblib<br/><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.linear_model</strong> <strong class="jr hj">import</strong> LogisticRegression<br/><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.ensemble</strong> <strong class="jr hj">import</strong> AdaBoostClassifier,GradientBoostingClassifier<br/><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.neighbors</strong> <strong class="jr hj">import</strong> KNeighborsClassifier<br/><strong class="jr hj">from</strong> <strong class="jr hj">sklearn</strong> <strong class="jr hj">import</strong> svm<br/><strong class="jr hj">from</strong> <strong class="jr hj">sklearn</strong> <strong class="jr hj">import</strong> tree</span><span id="9bdc" class="jv jw hi jr b fi kb jy l jz ka">iris=load_iris()</span></pre><p id="9ae0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们将变量iris设置为来自sklearn的load_iris()的实例。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="d572" class="jv jw hi jr b fi jx jy l jz ka">X_train,X_test,y_train,y_test=train_test_split(iris.data,iris.target,test_size=0.2,random_state=42)</span></pre><p id="2d26" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将数据集分为训练集和测试集，我们将20%的数据用于测试集，我们将使用测试集来查看我们的机器学习模型的执行情况。我们将我们的特征传入train_test-split()方法，我们的特征被解析为iris.data，我们的目标值或标签被解析为iris.target传入该方法。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="7691" class="jv jw hi jr b fi jx jy l jz ka">pipe_lr=Pipeline([('scl',StandardScaler()),<br/>                 ('pca',PCA(n_components=2)),<br/>                 ('clf',LogisticRegression(random_state=42))])<br/><br/><br/><br/>pipe_svm=Pipeline([('scl',StandardScaler()),<br/>                  ('pca',PCA(n_components=2)),<br/>                  ('clf',svm.SVC(random_state=42))])<br/><br/><br/><br/><br/>pipe_dt=Pipeline([('scl',StandardScaler()),<br/>                 ('pca',PCA(n_components=2)),<br/>                 ('clf',tree.DecisionTreeClassifier(random_state=42))])<br/><br/>pipe_adaboost=Pipeline([('scl',StandardScaler()),<br/>                       ('pca',PCA(n_components=2)),<br/>                       ('clf',AdaBoostClassifier())])<br/><br/>pipe_gradientboosting=Pipeline([('scl',StandardScaler()),<br/>                       ('pca',PCA(n_components=2)),<br/>                       ('clf',GradientBoostingClassifier())])<br/><br/>pipe_knn=Pipeline([('scl',StandardScaler()),<br/>                  ('pca',PCA(n_components=2)),<br/>                  ('clf',KNeighborsClassifier(n_neighbors=3))])</span></pre><p id="b515" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在是时候通过创建一个步骤列表来创建我们的管道了。首先，我们为逻辑回归创建管道步骤，它是变量pipe_lr。然后，我们将pipe_lr变量设置为pipeline类的实例，即Pipeline()。我们在一个元组中解析管道类的实例，该元组应该包含估计器或转换器的名称以及转换器或估计器的实例。例如，对于逻辑回归，我们将标准Scaler转换器的名称解析为“scl ”,将转换器的实例解析为Standard Scaler()。我们对支持向量机和决策树等其他算法也做了同样的工作，如上面的代码所示。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="4736" class="jv jw hi jr b fi jx jy l jz ka"><em class="jl">#List of pipelines for ease of iteration</em><br/>pipelines=[pipe_lr,pipe_svm,pipe_dt,pipe_adaboost,pipe_gradientboosting,pipe_knn]</span></pre><p id="c16e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们创建一个管道实例的列表，这样我们可以更容易地遍历它们。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="d8b0" class="jv jw hi jr b fi jx jy l jz ka"><em class="jl">#Dictionery of pipelines and classifier types for ease of reference</em><br/>pipe_dict={0:'LogisticRegression',1:'Support Vector Machine',2:'Decision tree',3:'AdaBoostClassifier',4:'GradientBoosting',5:'KNearestNeighbors'}</span></pre><p id="2bf5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们创建一个分类器或估计器的字典，以便我们更容易引用它们。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="a5bc" class="jv jw hi jr b fi jx jy l jz ka"><em class="jl">#fit the pipelines</em><br/><strong class="jr hj">for</strong> pipe <strong class="jr hj">in</strong> pipelines:<br/>    pipe.fit(X_train,y_train)</span></pre><p id="67c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们遍历上面创建的管道实例的列表或数组，遍历它们，并对每个分类器拟合我们的训练集。正如你所看到的，管道使我们的工作变得更容易，只需将多个分类器拟合到训练集，不像如果我们没有管道，我们会将每个估计器分别拟合到我们的数据集，这是低效的。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="b0a5" class="jv jw hi jr b fi jx jy l jz ka"><em class="jl">#compare accuracies</em><br/><strong class="jr hj">for</strong> idx,val <strong class="jr hj">in</strong> enumerate(pipelines):<br/>    print('<strong class="jr hj">%s</strong> pipeline test accuracy: <strong class="jr hj">%.3f</strong>' %(pipe_dict[idx],val.score(X_test,y_test)))</span></pre><p id="dae4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们比较每个估计量的准确性。</p><p id="9610" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jl">#识别测试数据上最准确的模型</em>best _ ACC = 0.0 best _ clf = 0.0 best _ pipe = ' '<strong class="io hj">for</strong>idx，val <strong class="io hj"> in </strong> enumerate(管道):<strong class="io hj"> if </strong> val.score(X_test，y _ test)&gt;best _ ACC:best _ ACC = val . score(X _ test，y _ test)best _ pipe = val best _ clf = idx print('具有最佳精度的分类器:<strong class="io hj"> %s</strong></p><p id="539c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们在测试数据上确定最准确的模型，这些数据是我们的模型没有训练过的数据，这样我们就可以评估我们的模型是否概括得很好。</p><p id="5706" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">感谢阅读我的文章，如果你觉得有用，请鼓掌。</p><p id="0a8b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你也可以跟着我</p><p id="43d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">推特:<a class="ae jk" href="https://twitter.com/IsheunesuTembo" rel="noopener ugc nofollow" target="_blank">https://twitter.com/IsheunesuTembo</a></p><p id="8df1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Instagram:<a class="ae jk" href="https://www.instagram.com/machine_learning_engineer/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/machine_learning_engineer/</a></p><figure class="jm jn jo jp fd ij"><div class="bz dy l di"><div class="kc kd l"/></div></figure></div></div>    
</body>
</html>