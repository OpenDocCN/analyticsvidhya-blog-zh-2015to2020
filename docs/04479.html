<html>
<head>
<title>DP Pizza With 3n Slices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3n片DP披萨</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dp-pizza-with-3n-slices-b5a9efece786?source=collection_archive---------10-----------------------#2020-03-21">https://medium.com/analytics-vidhya/dp-pizza-with-3n-slices-b5a9efece786?source=collection_archive---------10-----------------------#2020-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ad1f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从n！到2^n到北</h2></div><div class="ix iy ez fb iz ja"><a href="https://leetcode.com/problems/pizza-with-3n-slices/" rel="noopener  ugc nofollow" target="_blank"><div class="jb ab dw"><div class="jc ab jd cl cj je"><h2 class="bd hj fi z dy jf ea eb jg ed ef hh bi translated">3n片披萨- LeetCode</h2><div class="jh l"><h3 class="bd b fi z dy jf ea eb jg ed ef dx translated">有一个由3n片不同大小的比萨饼，你和你的朋友将采取比萨饼切片如下:你将…</h3></div><div class="ji l"><p class="bd b fp z dy jf ea eb jg ed ef dx translated">leetcode.com</p></div></div><div class="jj l"><div class="jk l jl jm jn jj jo jp ja"/></div></div></a></div><h2 id="9862" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">一个天真的解决方案将会失败</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d18f" class="jq jr hi kt b fi kx ky l kz la">from functools import lru_cache<br/>class Solution:<br/>    def maxSizeSlices(self, slices: List[int]) -&gt; int:<br/>        <a class="ae lb" href="http://twitter.com/lru_cache" rel="noopener ugc nofollow" target="_blank">@lru_cache</a>(None)<br/>        def dp(a):    <br/>            if len(a)==3:return max(a)<br/>            else:<br/>                res = -float('inf')<br/>                for i,k in enumerate(a):<br/>                    if i==0:<br/>                        new_a = a[2:-1]<br/>                        if len(new_a)%3!=0:print(new_a)<br/>                    elif i==len(a)-1:<br/>                        new_a = a[1:-2]<br/>                    else:<br/>                        new_a = a[:i-1]+a[i+2:]<br/>                    this_res = k+dp(new_a)<br/>                    res = max(res, this_res)<br/>            return res<br/>        return dp(tuple(slices))</span></pre><p id="0b63" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">运行结果:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0af9" class="jq jr hi kt b fi kx ky l kz la"><strong class="kt hj">24 / 69</strong> test cases passed.</span><span id="a786" class="jq jr hi kt b fi lv ky l kz la">Status:Time Limit Exceeded</span></pre><h2 id="c974" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">这个幼稚的解决方案的时间复杂度是多少？</h2><figure class="ko kp kq kr fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lw"><img src="../Images/d0dcb4bb93799954676de49957e6d091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlJgh2ydD-vqx3_l3z30dA.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx translated">如果我们有8块比萨饼，这是一个简单的例子</figcaption></figure><p id="6d17" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">从这个例子中，我们可以看到:</p><ul class=""><li id="081c" class="mh mi hi le b lf lg li lj kb mj kf mk kj ml lu mm mn mo mp bi translated">第一步:我们有8个选择</li><li id="eca0" class="mh mi hi le b lf mq li mr kb ms kf mt kj mu lu mm mn mo mp bi translated">第二步:除了两个边界节点，我们有8-3个选择。</li><li id="6d80" class="mh mi hi le b lf mq li mr kb ms kf mt kj mu lu mm mn mo mp bi translated">第3步:8–3–3</li><li id="3fcb" class="mh mi hi le b lf mq li mr kb ms kf mt kj mu lu mm mn mo mp bi">…</li></ul><p id="c05a" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">所以我们有的是n！当我们有3n片比萨饼时的可能状态。这解释了为什么我们得到了TLE。我们能做得更好吗？</p><h2 id="7f44" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用早期修剪的更好方法(失败)</h2><p id="3213" class="pw-post-body-paragraph lc ld hi le b lf mv ij lh li mw im lk kb mx lm ln kf my lp lq kj mz ls lt lu hb bi translated">是的，我们可以通过早期修剪做得更好。主要观点:</p><ol class=""><li id="5445" class="mh mi hi le b lf lg li lj kb mj kf mk kj ml lu na mn mo mp bi translated">到目前为止，DFS将收集最多的比萨饼</li><li id="c0b1" class="mh mi hi le b lf mq li mr kb ms kf mt kj mu lu na mn mo mp bi translated">对于一个新的搜索路径，如果我们确定它不能击败当前的最佳结果，就早点停止。</li></ol><p id="cde4" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">为了做2，而不是计算我们得到了什么，计算别人到目前为止得到了什么。如果其他人到目前为止得到的已经大于他们能得到的最小比萨饼(这意味着我们不能改善我们的结果)，我们停止探索这个分支。</p><p id="2bd0" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">代码如下:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3865" class="jq jr hi kt b fi kx ky l kz la">from functools import lru_cache<br/>class Solution:<br/>    def maxSizeSlices(self, slices: List[int]) -&gt; int:<br/>        self.others_min = float('inf')<br/>        def dfs(slices, others):<br/>            if len(slices)==3:<br/>                others += sum(slices)-max(slices)<br/>                self.others_min = min(self.others_min, others)<br/>                return<br/>            for i, slice in enumerate(slices):<br/>                if i==0:<br/>                    new_others = others + (slices[i+1]+slices[-1])<br/>                    new_slices = slices[2:-1]<br/>                elif i==len(slices)-1:<br/>                    new_others = others +  (slices[0] + slices[i-1])<br/>                    new_slices = slices[1:-2]<br/>                else:<br/>                    new_others = others + (slices[i-1]+slices[i+1])<br/>                    new_slices = slices[:i-1]+slices[i+2:]<br/>                # if others &gt;= others_min, no need to further explore<br/>                if new_others&lt;self.others_min:  <br/>                    dfs(new_slices, new_others)<br/>        dfs(slices, 0)<br/>        return sum(slices)-self.others_min</span></pre><p id="0048" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">然而，这一个比上一个慢</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="64a2" class="jq jr hi kt b fi kx ky l kz la"><strong class="kt hj">15 / 69</strong> test cases passed.</span><span id="5f4e" class="jq jr hi kt b fi lv ky l kz la">Status:Time Limit Exceeded</span></pre><p id="4fc1" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">为什么这种动态规划方法能够取得成功。</p><div class="ix iy ez fb iz ja"><a href="https://www.quora.com/Given-a-pizza-with-3n-slices-e-g-9-12-repeatedly-pick-a-slice-save-the-size-of-this-slice-When-you-do-this-the-slice-on-the-left-goes-to-someone-on-the-left-and-the-slice-on-the-right-goes-to-someone-on-the-right-Repeat-this-process-until-no-slices-are-left-How-can-you-write-a-program-to-find-a-list" rel="noopener  ugc nofollow" target="_blank"><div class="jb ab dw"><div class="jc ab jd cl cj je"><h2 class="bd hj fi z dy jf ea eb jg ed ef hh bi translated">给定具有3n个切片的比萨饼(例如9，12，...)，反复挑选一片(保存这个的大小…</h2><div class="jh l"><h3 class="bd b fi z dy jf ea eb jg ed ef dx translated">回答(第1步，共3步):起初，动态编程似乎没有希望，因为获取切片的顺序很重要…</h3></div><div class="ji l"><p class="bd b fp z dy jf ea eb jg ed ef dx translated">www.quora.com</p></div></div><div class="jj l"><div class="nb l jl jm jn jj jo jp ja"/></div></div></a></div><p id="b58c" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">从上面的链接</p><p id="8f1d" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">“起初，动态编程似乎没有希望，因为取切片的顺序很重要。为了看到这一点，考虑切片:… A B C D E …，其中点代表更多的切片，假设切片A、C和E非常大，因此是理想的。如果我先拿C片，那么A和E是邻居，我只能拿其中一个，而如果我先拿A片，那么就有可能在连续的移动中拿C片和E片。给问题增加了切片顺序的额外维度--有<em class="nc"> n </em>！取一组特定的<em class="nc"> n </em>个切片的顺序— —使得子问题的集合看起来是指数级的大</p><h2 id="cffa" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">数据处理</h2><p id="641a" class="pw-post-body-paragraph lc ld hi le b lf mv ij lh li mw im lk kb mx lm ln kf my lp lq kj mz ls lt lu hb bi translated">一个很好的总结</p><p id="e2d9" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated"><a class="ae lb" href="https://leetcode.com/problems/pizza-with-3n-slices/discuss/546574/Excellent-explanation-with-math-proof-on-Quora" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/pizza-with-3n-slices/discuse/546574/Excellent-explain-with-math-proof-on-Quora</a></p><p id="06f9" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">“基本想法:</p><ol class=""><li id="2546" class="mh mi hi le b lf lg li lj kb mj kf mk kj ml lu na mn mo mp bi translated">转化成这个问题:给定n个数，从中挑出n/3，使和最大。选取的数字不能相邻</li><li id="bd33" class="mh mi hi le b lf mq li mr kb ms kf mt kj mu lu na mn mo mp bi translated">这里0和n-1不能共存。所以我们需要一些特殊的技巧:要么弹出最小的(就像quora页面建议的那样)，要么处理0..n-2和1..n-1分开，就像论坛上其他人指出的那样”</li></ol><h2 id="ea90" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">具有早期剪枝的简洁DP解决方案</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4536" class="jq jr hi kt b fi kx ky l kz la">import functools<br/>class Solution:<br/>    def maxSizeSlices(self, A: List[int]) -&gt; int:<br/>        n = len(A)//3<br/>        @functools.lru_cache(None)<br/>        def dp(i, j, k):<br/>            if k == 1: return max(A[i:j + 1])<br/>            """<br/>            We have several cases:    <br/>            case1: my_pizza, others, my_pizza, others<br/>            case2: others, my_pizza, others, my_pizza<br/>            case3: others, my_pizza, others<br/>            case4: my_pizza, others, my_pizza<br/>            it means if I need K pizza, case 1 and case 2 need 2k. case 3 need 2k+1, case4 needs 2k-1(minimum)<br/>            If less than 2k-1, impossible<br/>            """<br/>            if j - i + 1 &lt; 2*k - 1: return -float('inf')<br/>            return max(dp(i+2, j, k - 1) + A[i], dp(i+1, j, k))<br/>        # Lots of posts pointed out why two cases here.<br/>        return  max(dp(0, len(A) - 2, n), dp(1, len(A) - 1, n))</span></pre><h2 id="a704" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">DP复杂性</h2><figure class="ko kp kq kr fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lw"><img src="../Images/88ae2d7e1ff702abf5fa27719f772964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xmpl9Oq_8OMapTCpbgIHsQ.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx translated">动力定位过程图解。我们有两个行动:1)不拿起第一片。2)拿起第一片</figcaption></figure><p id="2d2a" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">从上面的插图中，我们可以看到树有n层。如果每个节点我们有两个选择，那么我们将有:sum(2^i对于范围(3n)中的I，复杂度是O(2^n).同时，我们也可以观察到我们有重叠的节点。如果我们考虑重叠节点，我们将有:1，2，3，4…每层n个节点。这是O(n)。因为n只有500，所以即使不使用早期修剪，n也是可行的。</p><h2 id="d7f7" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">不使用早期修剪的DP。</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0014" class="jq jr hi kt b fi kx ky l kz la">import functools<br/>class Solution:<br/>    def maxSizeSlices(self, A: List[int]) -&gt; int:<br/>        n = len(A)//3<br/>        <a class="ae lb" href="http://twitter.com/functools" rel="noopener ugc nofollow" target="_blank">@functools</a>.lru_cache(None)<br/>        def dp(i, j, k):<br/>            # the bottom case will be we only have two slice pizza left.<br/>            # if k==0: good, we alreay have enough pizza, return 0<br/>            # if k==1: good, return the maximum pizza<br/>            # if k==2: impossible.<br/>            if j-i+1&lt;=2:<br/>                if k==0:return 0<br/>                elif k==1:return max(A[i:j + 1])<br/>                else:return -float('inf')<br/>            return max(dp(i+2, j, k - 1) + A[i], dp(i+1, j, k))<br/>        # Lots of posts pointed out why two cases here.<br/>        return  max(dp(0, len(A) - 2, n), dp(1, len(A) - 1, n))</span></pre><p id="d6c9" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">在本文中，我们将算法的复杂度从:</p><p id="e6b3" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">O(n！)到O(2^n)到O(n)。O(2^n)一个是一个解决方案，如果我们不使用记忆。</p><p id="96e6" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">希望有帮助。</p><p id="045f" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated">参考</p><p id="ccfd" class="pw-post-body-paragraph lc ld hi le b lf lg ij lh li lj im lk kb ll lm ln kf lo lp lq kj lr ls lt lu hb bi translated"><a class="ae lb" href="https://leetcode.com/problems/pizza-with-3n-slices/discuss/546474/Python-Robber-n3-Houses-in-Cycle" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/pizza-with-3n-slices/discuse/546474/Python-rober-n3-Houses-in-Cycle</a></p></div></div>    
</body>
</html>