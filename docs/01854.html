<html>
<head>
<title>Implementing SVM for Classification and finding Accuracy in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中实现SVM分类和查找精度</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/implementing-svm-for-performing-classification-and-finding-accuracy-in-python-using-datasets-wine-e4fef8e804b4?source=collection_archive---------2-----------------------#2019-11-18">https://medium.com/analytics-vidhya/implementing-svm-for-performing-classification-and-finding-accuracy-in-python-using-datasets-wine-e4fef8e804b4?source=collection_archive---------2-----------------------#2019-11-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9f8e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用数据集——葡萄酒、波士顿和糖尿病</h2></div><p id="87a3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">问题陈述:实现用于执行分类的SVM，并在给定数据上发现其准确性。(使用Python)(数据集——葡萄酒、波士顿和糖尿病)</strong></p><h2 id="5c53" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">程序和数据集的链接如下</h2><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ko"><img src="../Images/b7a65827e68b78c747257cb133fd5500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*7NNye14U4C-j_nuM.jpg"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">图片来源:- <a class="ae la" href="https://thinksproutinfotech.com/" rel="noopener ugc nofollow" target="_blank">思创资讯科技</a></figcaption></figure><p id="abe5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">SVM代表支持向量机。SVM是一种受监督的机器学习算法，通常用于分类和回归挑战。SVM算法的常见应用是入侵检测系统、手写识别、蛋白质结构预测、检测数字图像中的隐写术等。</p><p id="9fd6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在SVM算法中，每个点被表示为n维空间中的一个数据项，其中每个特征的值是特定坐标的值。</p><p id="df90" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">标绘后，通过寻找区分两类的平面进行分类。参考下图来理解这个概念。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lb"><img src="../Images/ab907ef4cf9f3de652dfd36b82b2d9f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/0*GjA-TNtWZRcDoXCI.png"/></div></figure><p id="a3c0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">支持向量机算法主要用于解决分类问题。支持向量只不过是每个数据项的坐标。支持向量机是使用超平面区分两类的前沿。</p><h1 id="a5f6" class="lc ju hi bd jv ld le lf jz lg lh li kd io lj ip kg ir lk is kj iu ll iv km lm bi translated">支持向量算法的工作原理</h1><p id="0177" class="pw-post-body-paragraph ix iy hi iz b ja ln ij jc jd lo im jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">SVM的工作原理是将数据映射到一个高维特征空间，以便可以对数据点进行分类，即使数据不是线性可分的。找到类别之间的分隔符，然后对数据进行转换，使得分隔符可以绘制为超平面。</p><p id="3039" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">支持向量机有一些特殊的数据点，我们称之为“支持向量”，还有一个分离超平面，我们称之为“支持向量机”。所以，从本质上来说，SVM是最好的阶级隔离的前沿。支持向量是最接近超平面的数据点，即我们的数据集的点，如果移除这些点，将会改变划分超平面的位置。正如我们可以看到的，可以有许多超平面可以分离这两个类，我们将选择的超平面是具有最高余量的超平面。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ko"><img src="../Images/1e19c108d725b8443552d142fbaccfd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*RmlUkJuy9HBxEe_H.png"/></div></figure><p id="c21c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用于转换的数学函数称为核函数。SVM支持以下内核类型:</p><p id="5dd9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">线性</p><p id="afc3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多项式</p><p id="791a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">径向基函数(RBF)</p><p id="f371" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">乙状结肠</p><h1 id="89e8" class="lc ju hi bd jv ld le lf jz lg lh li kd io lj ip kg ir lk is kj iu ll iv km lm bi translated">SVM程序，用于对给定数据进行分类并确定其准确性:</h1><p id="d8bc" class="pw-post-body-paragraph ix iy hi iz b ja ln ij jc jd lo im jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated"><strong class="iz hj">第一步:导入库</strong></p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ls"><img src="../Images/af4677eb697d0e6b4a1075a2109fd2d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/0*q-ghiQxxMuNefgBC.png"/></div></figure><p id="a5ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们将导入程序所需的库。</p><ul class=""><li id="1ad3" class="lt lu hi iz b ja jb jd je jg lv jk lw jo lx js ly lz ma mb bi translated">我们从sklearn库中导入svm和数据集</li><li id="5dcb" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated">进行有效数学计算的数字</li><li id="a9ae" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated"><strong class="iz hj">来自sklearn.metrics的accuracy_score </strong>用于预测模型的准确性，以及来自<strong class="iz hj">sk learn . model _ selection</strong>import<strong class="iz hj">train _ test _ split</strong>用于将数据拆分为训练集和测试集</li></ul><p id="8a95" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">第二步:添加数据集，插入所需数量的特征并训练模型</strong></p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ko"><img src="../Images/424b2d491521762a4ce1f5cd34e78c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*3F5e2Tz39OmOiE5o.png"/></div></figure><p id="3c59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是导入内置数据集的代码。“iris”是我们将在其中加载所需数据集的变量名。</p><p id="ab21" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以将数据集从它在计算机上的存储位置导入到一个新变量中。<strong class="iz hj"> pd.read_csv </strong>用于读取csv文件(数据集文件)。以下代码显示了语法:-</p><p id="8c21" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">Iris = PD . read _ CSV(' C:/Users/Kshitij Ved/Desktop/Iris . CSV ')</strong></p><p id="38ce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下一步中，X变量被加载有<strong class="iz hj"> iris.data[:，:2] </strong>，在这一步中，我们仅将前两个特征作为训练的输入。</p><p id="c47d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而Y变量加载的是iris.target，也就是原始数据的输出。</p><p id="2e6b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们使用<strong class="iz hj"> train_test_split() </strong>将数组或矩阵分成随机的训练和测试子集。我们提供用作测试集的数据比例，并且我们可以提供参数<strong class="iz hj"> random_state </strong>，该参数用于确保可重复的结果。<strong class="iz hj"> Test_size </strong>用于决定为模型测试提供多少数据。</p><p id="0462" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续，我们现在要定义我们的分类器…</p><p id="dd0f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用SVC(支持向量分类器)SVM(支持向量机)。我们的核是线性的，C等于1。c是对你想要正确分类或适合所有事物的“有多糟糕”的评估。我们现在坚持使用1，这是一个很好的默认参数。</p><p id="0cfa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">第三步:预测模型的输出和打印精度</strong></p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ko"><img src="../Images/d7b480dffe6eb4a202d06c2bcd1ad190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*n-mXg49tficyBq8X.png"/></div></figure><p id="c607" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下一步中，我们使用<strong class="iz hj"> clf.predict(x_test) </strong>，这是预测测试结果的分类器，然后我们打印准确性得分，在上面的示例中，76.31578947368422是我们加载iris作为数据集时模型的预测值。</p><p id="4316" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">第四步:最终为我们的程序绘制分类器</strong></p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mh"><img src="../Images/2805355a98e3c2737d5f6a4ef2f8fbbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/0*J-RyINGJqSSjPuou.png"/></div></figure><p id="6b74" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一步，我们将绘制我们的分类器。这里使用<strong class="iz hj"> np.meshgrid() </strong>函数从两个给定的一维数组中创建一个矩形网格，表示笛卡尔索引或矩阵索引。</p><p id="1f59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">NumPy在NumPy数组对象上提供了<strong class="iz hj"> reshape() </strong>函数，可用于对数据进行整形。在将一维数组整形为具有一列的二维数组的情况下，元组将是作为第一维的数组的形状，1表示第二维。</p><p id="7f3a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> plt.scatter() </strong>用于绘制图形上的点，<strong class="iz hj"> plt.show() </strong>显示图形。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mi"><img src="../Images/99a942ada98e8169f007459436306b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/0*htlG_TPonSKu32Q-.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">我们程序的最终输出</figcaption></figure><p id="bddf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">点击<a class="ae la" href="https://github.com/kshitijved/Support_Vector_Machine" rel="noopener ugc nofollow" target="_blank">这里</a>下载程序和数据集…</p></div></div>    
</body>
</html>