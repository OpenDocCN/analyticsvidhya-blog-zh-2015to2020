<html>
<head>
<title>Arrow Functions — When ‘NOT’ to use!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">箭头功能——何时“不”使用！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/arrow-functions-when-not-to-use-cfe03d53407d?source=collection_archive---------10-----------------------#2020-10-18">https://medium.com/analytics-vidhya/arrow-functions-when-not-to-use-cfe03d53407d?source=collection_archive---------10-----------------------#2020-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/024a904cbb52909c06bb66149b356c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwmT2WKK91WzcQT2V1huUg.jpeg"/></div></div></figure><p id="98dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大家好🌼！本文将告诉您JavaScript箭头函数中的异常。阅读本文前的先决条件-</p><ol class=""><li id="363a" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" href="https://www.w3schools.com/js/js_arrow_function.asp" rel="noopener ugc nofollow" target="_blank"> <em class="jy">箭头函数的语法</em> </a></li><li id="656f" class="jo jp hi is b it jz ix ka jb kb jf kc jj kd jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/@prachisown/this-in-javascript-45d70f989b6b"> <strong class="is hj"> <em class="jy">本</em> </strong> <em class="jy">本</em> </a></li></ol><p id="3bcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就我个人而言，我几乎每天都在使用JS arrow函数，我猜很多开发人员也是这样。这就是语法——JS语言中最好的语法之一。Arrow函数使开发变得更加容易，但是今天我们将讨论它的缺陷！🐞</p><h1 id="64aa" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">参数绑定🦋</h1><p id="f4ed" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">假设我们想定义一个函数，计算传递给它的任意数量的参数之和。最好的想法是使用函数重载(定义一个函数的能力，这样就可以用不同的形状或不同数量的参数来调用它)。</p><p id="1e99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript函数有一个内置的类似数组的对象，叫做arguments。它包含传递给函数的所有参数。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/6f6c3c0643990be077f736772d696a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxz2i7Y11ffaTXWtkt54Fg.png"/></div></div></figure><p id="445e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它的输出看起来像-</p><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/658b6f8a95d3aa3f1b64127ccd601d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*zd4eJgeEYsZySnRnBLi6Sw.png"/></div></figure><p id="9372" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们使用正则函数表达式定义sum()函数—</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/798ff8fc99fdec13c4ad33cff24de3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CBd3YpJSj_SCL5XxajXTw.png"/></div></div></figure><p id="8663" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用不同的参数调用sum()</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/383ab8ee6a603a0da1d3676d6ecaaae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1whomdx4YDrUNGT2pR07g.png"/></div></div></figure><p id="48c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们使用箭头函数语法复制sum()</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/7ac17a032020473cdfaea2671c77ea64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Evu_PVrA8YQySke0hoMIrA.png"/></div></div></figure><p id="37fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你现在测试这个函数时，它抛出一个<code class="du lp lq lr ls b">Reference Error</code>，抱怨<code class="du lp lq lr ls b">arguments</code>没有定义。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/407fc1b972b97c149eb28f648c4fb711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*AqnCG_e_q38kbrBG0JYuqQ.png"/></div></figure><h2 id="ac44" class="lu kf hi bd kg lv lw lx kk ly lz ma ko jb mb mc ks jf md me kw jj mf mg la mh bi translated">这有什么不好？？🎃</h2><blockquote class="mi mj mk"><p id="4c6e" class="iq ir jy is b it iu iv iw ix iy iz ja ml jc jd je mm jg jh ji mn jk jl jm jn hb bi translated">箭头函数不存在<code class="du lp lq lr ls b">arguments</code>绑定。它只为常规功能而存在。但是，箭头函数可以访问非箭头父函数的<code class="du lp lq lr ls b">arguments</code>对象。</p></blockquote><p id="c814" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的语句意味着—如果您想访问arrow函数中的argument对象，您必须返回常规父函数中立即调用的arrow函数。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/f37e656f71b8e893b4114c3617e9a92a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQQsctIMAsjNngqW_WZCsw.png"/></div></div></figure><p id="687b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码就可以了！</p><h2 id="8902" class="lu kf hi bd kg lv lw lx kk ly lz ma ko jb mb mc ks jf md me kw jj mf mg la mh bi translated">我们有更好的选择吗？？🐰</h2><p id="0f4d" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">是啊！向<code class="du lp lq lr ls b">rest parameters</code>问好。使用<code class="du lp lq lr ls b">rest parameters</code>,我们可以将任意数量的参数收集到一个数组中，并对它们做我们想做的事情。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/d5d102b548326095ba9474d76b14f846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CSiq8kHDdQyLergqQlfCw.png"/></div></div></figure><blockquote class="mi mj mk"><p id="cf6c" class="iq ir jy is b it iu iv iw ix iy iz ja ml jc jd je mm jg jh ji mn jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>其余参数必须在<strong class="is hj">最后一个参数</strong>处。这是因为它将所有的<code class="du lp lq lr ls b">remaining</code> / <code class="du lp lq lr ls b">excess</code>参数收集到一个数组中。所以像这样的函数会抛出错误—</p></blockquote><pre class="li lj lk ll fd mo ls mp mq aw mr bi"><span id="7b5c" class="lu kf hi ls b fi ms mt l mu mv">const sum = (a,…args, c) =&gt; {<br/>       .....<br/>       .....<br/>       return<br/>}</span></pre><h1 id="bc74" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">构造函数🐘</h1><p id="2a92" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">可以用关键字<code class="du lp lq lr ls b">new</code>调用一个常规的JavaScript函数，对于这个函数来说，它的行为就像一个创建新实例对象的类构造函数。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/cf81619535fda71dec6c072f22815ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Te4dV_JJfnY1H0JNgEyEyg.png"/></div></div></figure><p id="82f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我对箭头函数做同样的操作会怎么样？？🤔</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/61cc43cd642d7d12dbb95be9ec6638ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LMBpkBVJxIHUKwCMMYylA.png"/></div></div></figure><p id="849d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是抛出错误——一个箭头函数的<code class="du lp lq lr ls b">prototype</code>是<code class="du lp lq lr ls b">undefined</code>。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/4ac4c62fa44fc800425973caa49ee99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iuwYzqtsilQg4W4FYoIRnA.png"/></div></div></figure><blockquote class="mi mj mk"><p id="9744" class="iq ir jy is b it iu iv iw ix iy iz ja ml jc jd je mm jg jh ji mn jk jl jm jn hb bi translated">箭头函数永远不能用new关键字调用，因为它们没有<code class="du lp lq lr ls b">[[Construct]]</code>方法。因此，箭头函数也不存在<code class="du lp lq lr ls b">prototype</code>属性。</p></blockquote><h1 id="f219" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">这💭🎪</h1><p id="3485" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">在正则函数表达式中，这是指基于调用函数的<strong class="is hj"> <em class="jy">上下文</em> </strong>的值。而在arrow函数中，这个值依赖于<strong class="is hj"> <em class="jy">词法范围。👻</em>T11】</strong></p><p id="4bf4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jy">上下文— </em> </strong>上下文与对象相关。它指的是函数所属的对象。当您使用JavaScript“this”关键字时，它指的是函数所属的对象。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/3f9d80c75da79c90cfd16eabd5f03413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwLTXX5a1gc4qUtQBXQS_Q.png"/></div></div></figure><ol class=""><li id="06e6" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">方法<strong class="is hj"> <em class="jy">全称</em> </strong>是由<strong class="is hj"> <em class="jy">人</em> </strong>对象调用的，这就是为什么这个方法的上下文是<strong class="is hj"> <em class="jy">人</em> </strong>对象。方法内<strong class="is hj"> <em class="jy">这个</em> </strong>的值因此是<strong class="is hj"> <em class="jy">人</em> </strong>对象。</li><li id="1d2f" class="jo jp hi is b it jz ix ka jb kb jf kc jj kd jn jt ju jv jw bi translated">如果一个函数被全局调用，它的上下文是窗口，这就是为什么该函数内的<strong class="is hj"> <em class="jy">这个</em> </strong>的值是<strong class="is hj"> <em class="jy">窗口对象。</em> </strong></li></ol><p id="f9bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jy">作用域— </em> </strong>作用域决定变量的可见性。它与功能有关。让我们看看如何！！</p><p id="4b72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1.假设您在函数内部使用“var”初始化变量。您不能在函数外部访问此变量。</p><p id="db5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.但是如果父函数内部有函数，那么内部函数可以访问父函数的变量。而那个变量就被说成是<strong class="is hj"> <em class="jy">【作用域内】</em> </strong>。</p><p id="b02d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jy">词法作用域</em>意味着在一组嵌套的函数中，<strong class="is hj">内部函数可以访问其父作用域</strong>的变量和其他资源。</p><p id="2596" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jy">arrow函数中的这个</em> <strong class="is hj">从词法范围即父环境中取值。</strong></p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/21bf11dcb44e0b98ad3c41b7ae229f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8AZFNpoTjqAMYwDPgo4kw.png"/></div></div></figure><p id="77f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，需要注意以下几点—</p><ol class=""><li id="018e" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj"><em class="jy">console . log(this)</em></strong><em class="jy">在方法</em> <strong class="is hj"> <em class="jy"> fullName </em> </strong>里面打印对象<strong class="is hj"> <em class="jy"> person </em> </strong>因为方法<strong class="is hj"> <em class="jy"> fullName </em> </strong>是被对象<strong class="is hj"><em class="jy">【person】</em></strong>调用的，所以这个方法的上下文是<strong class="is hj"> <em class="jy"> person </em> </strong>对象。</li><li id="f106" class="jo jp hi is b it jz ix ka jb kb jf kc jj kd jn jt ju jv jw bi translated"><strong class="is hj"><em class="jy">console . log(this)</em></strong>箭头函数内部<strong class="is hj"> <em class="jy">内部</em> </strong>打印对象<strong class="is hj"> <em class="jy">人</em> </strong>因为<strong class="is hj"> <em class="jy">箭头函数内部的这个</em> </strong>从词法作用域即父包围<strong class="is hj">中取值。</strong>在其父环境(全名)中，这是指对象人。</li></ol><p id="bbc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们举个例子，了解一下这里的箭头函数有什么问题—</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/a300b65c7739c8c25d333ed1160e4b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t370AaE1gus2gdj0-IXJYg.png"/></div></div></figure><p id="4b61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，我们用箭头函数替换了常规函数。这就是为什么logging <strong class="is hj"> <em class="jy">这个</em> </strong>是返回窗口对象！</p><p id="ca9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">箭头函数不会将</strong> <code class="du lp lq lr ls b"><strong class="is hj">this</strong></code> <strong class="is hj">绑定到调用它们的对象上。它们只是在它们被定义的范围内使用</strong> <code class="du lp lq lr ls b"><strong class="is hj">this</strong></code> <strong class="is hj">的值。在这种情况下，这就是全局对象。所以箭头函数不能用于对象方法！</strong></p><h1 id="ca6d" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">重复参数🐯</h1><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/1c2d16d4c99a740c3648d0059c8bb15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y57T7hDJQzaMkdCTaTNGBg.png"/></div></div></figure><p id="3d10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lp lq lr ls b">first</code>参数重复。它被赋予传递给函数调用的第三个参数的值，该值完全覆盖传递的第一个参数。</p><p id="bd22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用箭头函数复制上面的例子—</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/31f481ea430157ec59cfcbd5f703b259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZIn14w4DQw9xrx2VhPt9Q.png"/></div></div></figure><p id="843e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它将抛出一个错误— <em class="jy">未捕获的语法错误:在这个上下文中不允许重复的参数名</em></p><blockquote class="mi mj mk"><p id="008e" class="iq ir jy is b it iu iv iw ix iy iz ja ml jc jd je mm jg jh ji mn jk jl jm jn hb bi translated">与常规函数不同，箭头函数不允许重复的参数，重复的参数会导致抛出一个<code class="du lp lq lr ls b">Syntax Error</code>。</p></blockquote><p id="eb53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你认为这些内容已经为你提供了一些价值，你可以关注我在<a class="ae jx" rel="noopener" href="/@prachisown">媒体</a>上的更多此类内容。</p><p id="d33a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的阅读！🌺🙏</p></div></div>    
</body>
</html>