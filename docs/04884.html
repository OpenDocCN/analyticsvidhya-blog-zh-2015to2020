<html>
<head>
<title>Understanding Association Mining and Market Basket Analysis with Apriori Algorithm using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python理解关联挖掘和使用Apriori算法的购物篮分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-association-mining-and-market-basket-analysis-with-apriori-algorithm-using-python-e216c0d22f3e?source=collection_archive---------7-----------------------#2020-04-04">https://medium.com/analytics-vidhya/understanding-association-mining-and-market-basket-analysis-with-apriori-algorithm-using-python-e216c0d22f3e?source=collection_archive---------7-----------------------#2020-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="aabf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">关联挖掘</strong></p><p id="74eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated"><span class="l je jf jg bm jh ji jj jk jl di"> S </span>暗示摆放，寻找物体之间的关系。例如，如果大多数人买了黄油，他们一定也买了面包。因此，一些超市将有很高可能性被一起购买的物品放在同一通道中，而另一些超市可能将它们放在两个不同的角落，以便顾客在找到其他必需品时浏览并购买其他产品。因此，关联挖掘在为目录设计、销售、市场营销等建立和改进决策和商业规则方面是非常重要的。</p><blockquote class="jm jn jo"><p id="0bf7" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated">频繁模式挖掘是发现数据集中频繁出现的模式，即发现关联和相关性。模式可以是牛奶和饼干等一组物品的形式，也可以是一个序列，例如购买手机，然后是存储卡和耳机。市场购物篮分析就是一个例子，其中根据客户的“购买习惯”来分析购买习惯并建立规则。模式以规则的形式表现出来。</p></blockquote><p id="1751" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">模式的兴趣度</strong></p><blockquote class="jm jn jo"><p id="6a86" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated">反映已建立规则的可用性和确定性水平。</p></blockquote><ol class=""><li id="4fc5" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated"><strong class="ih hj">支持</strong>:是涉及某个特定项目的交易占总交易数的比例。它定义了一个项目的受欢迎程度。它的范围在0和1之间。</li><li id="8b47" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">置信度</strong>:它是涉及两个项目X和Y的交易数与涉及X的交易数之比，因此，它告诉我们，在给定X发生的次数的情况下，项目X和Y一起发生的频率的可能性。它的范围在0和1之间。</li><li id="b69d" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">提升</strong>:提升表示规则的确定性。卖了B，X的销量增加了多少？</li></ol><h2 id="41b4" class="kh ki hi bd kj kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">升力(X=&gt;Y) =置信度(X，Y)/支持度(Y)</h2><blockquote class="jm jn jo"><p id="b5ea" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated">示例:A = &gt; B[支持度= 5%，置信度= 80%]</p></blockquote><p id="7318" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有交易的5%显示A和B是一起购买的。80%买了A的顾客也买了b。</p><p id="7f7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">常见的算法有Apriori，FP-growth等等。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es lc"><img src="../Images/e9d3905f46f702897a14d1f44b92b9cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*E7x5MDZWDlgqpWP9AvOR4Q.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">来源:数据挖掘概念和技术，第三版。</figcaption></figure><p id="92f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">亚马逊、Flipkart、Capital One、沃尔玛等公司巨头在其大数据上使用这种分析方法。例如:“经常一起购买的物品。”</p><p id="109c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>:关联和推荐是不同的，因为关联不是关于某个特定个人的偏好，而是关于项目集之间的关系。</p><p id="e57a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">关于数据</strong></p><p id="b792" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关联挖掘可用于需要根据客户习惯做出更好决策的问题。</p><p id="00a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如杂货店和基本商店、在线市场、音乐和电影类型、软件购买等。</p><p id="b098" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些数据通常是大数据和非结构化数据。也就是说，数据不会是严格的表格格式。一行中可以有任意数量的项目(列)，所以我们需要处理不同列数的问题。</p><h1 id="9a8b" class="lo ki hi bd kj lp lq lr kn ls lt lu kr lv lw lx ku ly lz ma kx mb mc md la me bi translated"><strong class="ak"> Apriori算法</strong></h1><blockquote class="jm jn jo"><p id="7426" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated"><strong class="ih hj"> 1。查找所有频繁项集</strong>:出现频率至少与最小支持计数相同的项集。</p><p id="d7e6" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated"><strong class="ih hj"> 2。从频繁项目集生成强关联规则</strong>:满足最小支持度和最小置信度的规则。</p></blockquote><p id="36ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">标准数据集— <a class="ae mf" href="https://github.com/stedy/Machine-Learning-with-R-datasets/blob/master/groceries.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="jp">杂货. csv </em> </strong> </a></p><p id="d753" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尺寸:9834 X 41</p><p id="4cdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">实施</strong></p><p id="85ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.对数据进行探索性数据分析。</p><ul class=""><li id="6394" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc mg jz ka kb bi translated">了解形状</li><li id="2a3f" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc mg jz ka kb bi translated">找出数据集中出现的前20个项目</li><li id="ee95" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc mg jz ka kb bi translated">这20项占多少？—项目百分比</li></ul><p id="8851" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">B.根据交易中的项目数量和总销售百分比来删减数据集。</p><p id="a060" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">C.应用Apriori算法，获取规则。</p><p id="18af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始寻找以上问题的答案吧！</p><ol class=""><li id="ccda" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">导入库</li></ol><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="3d64" class="kh ki hi mi b fi mm mn l mo mp">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/>import csv<br/>from apyori import apriori<br/>import itertools</span></pre><p id="0693" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.了解形状</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="c7e1" class="kh ki hi mi b fi mm mn l mo mp">data = pd.read_csv('groceries.csv')<br/>data.shape</span></pre><p id="cb3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="6306" class="kh ki hi mi b fi mm mn l mo mp">(9835, 41)</span></pre><p id="b045" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.接下来，找出前20项以及它们占总百分比的多少。</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="0d0d" class="kh ki hi mi b fi mm mn l mo mp">#Finding all items present in our data - groceries.csv<br/>#We will have to use the csv package so that we can read each line one by one and update any new grocery item.</span><span id="c342" class="kh ki hi mi b fi mq mn l mo mp">all_items = set()#set of all items<br/>with open("groceries.csv") as f:<br/>    reader = csv.reader(f, delimiter=",")<br/>    for i, line in enumerate(reader):<br/>        all_items.update(line)</span><span id="71d1" class="kh ki hi mi b fi mq mn l mo mp">#Now, we count if a particular item appears in the a particular row and update it in a list format.</span><span id="12b6" class="kh ki hi mi b fi mq mn l mo mp">counting = list()<br/>with open("groceries.csv") as f:<br/>    reader = csv.reader(f, delimiter=",")<br/>    for i, line in enumerate(reader):<br/>        row = {item:0 for item in all_items}<br/>        row.update({item:1 for item in line})<br/>        counting.append(row)</span><span id="32ad" class="kh ki hi mi b fi mq mn l mo mp">#Next, convert the list in to Pandas DataFrame so that wecan do pandas operations.</span><span id="98a8" class="kh ki hi mi b fi mq mn l mo mp">groceries = pd.DataFrame(counting)</span><span id="c1eb" class="kh ki hi mi b fi mq mn l mo mp">groceries.head()<br/># 0 represents that the item is not present in a particular row/ item order list.</span></pre><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="er es mr"><img src="../Images/4abda57445abc4a9737bf2a028c7a4f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h09wRJkqvvs2DK0jfr9P7w.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">输出</figcaption></figure><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="e690" class="kh ki hi mi b fi mm mn l mo mp"># Finding item count is now easy - we need to sum it up.</span><span id="5dd5" class="kh ki hi mi b fi mq mn l mo mp"># 1. Find total number of items sum of all the sums of rows<br/>tot_item_count = <strong class="mi hj">sum</strong>(groceries.<strong class="mi hj">sum</strong>()) # Answer is 43368</span><span id="ab75" class="kh ki hi mi b fi mq mn l mo mp"># 2. Sum the rows and sort is descending order to get top 20 items<br/>item_sum = groceries.<strong class="mi hj">sum</strong>().sort_values(ascending = False).reset_index().head(n=20)<br/>item_sum.rename(columns={item_sum.columns[0]:'Item_name',item_sum.columns[1]:'Item_count'}, inplace=True)</span><span id="74e8" class="kh ki hi mi b fi mq mn l mo mp"># 3. Add the percent so that we know how much it contributes. #Tot_percent of x determines the percentage of x and above elements in the total percentage i.e cumulative sum.<br/>item_sum['Item_percent'] = item_sum['Item_count']/tot_item_count<br/>item_sum['Tot_percent'] = item_sum.Item_percent.cumsum()<br/>item_sum.head(20) # List of top 20 items with percents</span><span id="2055" class="kh ki hi mi b fi mq mn l mo mp"># Plotting Code<br/># We will plot later, so that we can plot items + frequent items.<br/># But the function can be called here as well.<br/># Alternative Code</span><span id="5990" class="kh ki hi mi b fi mq mn l mo mp">obj = (list(item_sum['Item_name'].head(n=20)))<br/>y_pos = np.arange(len(obj))<br/>performance = list(item_sum['Item_count'].head(n=20))<br/> <br/>plt.bar(y_pos, performance, align='center', alpha=0.5)<br/>plt.xticks(y_pos, obj, rotation='vertical')<br/>plt.ylabel('Item count')<br/>plt.title('Item sales distribution')</span></pre><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es mw"><img src="../Images/76b5248e3f731390dd7aa467575ae079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*aqQzuqi45nz7uHr8bO5dRg.png"/></div></figure><p id="c98c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前5项= 21.74%，前20项= 50.37%</p><p id="fb1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们需要修剪/减少数据集，因为大多数元素对总销售额的贡献为零。</p><p id="365a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.我们已经完成了项目/问题陈述的一部分。现在我们来看看B部分。</p><p id="dd66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们将定义一个函数prune_dataset，它可以从用户/分析师那里获取以下参数。</p><ul class=""><li id="74fc" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc mg jz ka kb bi translated">输入数据帧</li><li id="8343" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc mg jz ka kb bi translated">要考虑的最小交易长度(即一行中的最小项目数)。</li><li id="13d7" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc mg jz ka kb bi translated">要考虑的项目的最小总销售额百分比。</li></ul><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="ea77" class="kh ki hi mi b fi mm mn l mo mp">def prune_dataset(olddf, len_transaction, tot_sales_percent):<br/>    # Delete the last column tot_items if present<br/>    if 'tot_items' in olddf.columns:<br/>        del(olddf['tot_items'])<br/>    #Finding the item_count for each item and total number of items.<br/>    #This is the same code as in step 3    <br/>    Item_count = olddf.sum().sort_values(ascending = False).reset_index()<br/>    tot_items = sum(olddf.sum().sort_values(ascending = False))<br/>    Item_count.rename(columns={Item_count.columns[0]:'Item_name',Item_count.columns[1]:'Item_count'}, inplace=True)<br/>    <br/>    # Code from Step 3 to find Item Percentage and Total Percentage.<br/>    Item_count['Item_percent'] = Item_count['Item_count']/tot_items<br/>    Item_count['Tot_percent'] = Item_count.Item_percent.cumsum()<br/>    <br/>    # Taking items that fit the condition/ minimum threshold for total sales percentage.<br/>    selected_items = list(Item_count[Item_count.Tot_percent &lt; tot_sales_percent].Item_name)<br/>    olddf['tot_items'] = olddf[selected_items].sum(axis = 1)<br/>    <br/>    # Taking items that fit the condition/ minimum threshold for length of transaction or number of items in a row.<br/>    olddf = olddf[olddf.tot_items &gt;= len_transaction]<br/>    del(olddf['tot_items'])<br/>    <br/>    #Return pruned dataframe.<br/>    return olddf[selected_items], Item_count[Item_count.Tot_percent &lt; tot_sales_percent]<br/></span></pre><p id="a896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将为len_transaction和tot_sales_percent输入不同的值，以获得apriori的适当数据集。</p><p id="5763" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jp">删除数据帧#1 </em></p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="abdb" class="kh ki hi mi b fi mm mn l mo mp">pruneddf, Item_count = prune_dataset(groceries,4,0.4)<br/>print(pruneddf.shape)<br/>print(list(pruneddf.columns))</span></pre><p id="ec9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出(列的列表实际上是我们先验考虑的项目。)</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="3407" class="kh ki hi mi b fi mm mn l mo mp">(1267, 13)<br/>['whole milk', 'other vegetables', 'rolls/buns', 'soda', 'yogurt', 'bottled water', 'root vegetables', 'tropical fruit', 'shopping bags', 'sausage', 'pastry', 'citrus fruit', 'bottled beer']</span></pre><p id="a08a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它有相当多的行和前13项(列)</p><p id="d23c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jp">修剪后的数据帧#2 </em></p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="6cb9" class="kh ki hi mi b fi mm mn l mo mp">pruneddf, Item_count = prune_dataset(groceries,4,0.5)<br/>print(pruneddf.shape)<br/>print(list(pruneddf.columns))</span></pre><p id="eaf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="17d6" class="kh ki hi mi b fi mm mn l mo mp">(1998, 19)<br/>['whole milk', 'other vegetables', 'rolls/buns', 'soda', 'yogurt', 'bottled water', 'root vegetables', 'tropical fruit', 'shopping bags', 'sausage', 'pastry', 'citrus fruit', 'bottled beer', 'newspapers', 'canned beer', 'pip fruit', 'fruit/vegetable juice', 'whipped/sour cream', 'brown bread']</span></pre><p id="9d12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，行的数量很好，在我们的压缩数据集中也有前19项。</p><p id="ad65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jp">删除数据帧#3 </em></p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="46b6" class="kh ki hi mi b fi mm mn l mo mp">pruneddf, Item_count <strong class="mi hj">=</strong> prune_dataset(groceries,2,0.5)<br/>print(pruneddf.shape)<br/>print(list(pruneddf.columns))</span></pre><p id="fecf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="34d4" class="kh ki hi mi b fi mm mn l mo mp">(5391, 19)<br/>['whole milk', 'other vegetables', 'rolls/buns', 'soda', 'yogurt', 'bottled water', 'root vegetables', 'tropical fruit', 'shopping bags', 'sausage', 'pastry', 'citrus fruit', 'bottled beer', 'newspapers', 'canned beer', 'pip fruit', 'fruit/vegetable juice', 'whipped/sour cream', 'brown bread']</span></pre><p id="7cc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个非常好的数据集，因为它包含了原始数据集的前19项和非常多(实际上是一半)的行/事务。所以，我们将继续进行。</p><p id="5d19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.b部分已经完成。现在，我们将应用Apriori，并在仅包含最相关数据的精简数据上生成规则和关系。</p><p id="9083" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要将我们的数据框转换成csv文件，这样它看起来就像我们的原始数据集，但维度减少了。</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="4db4" class="kh ki hi mi b fi mm mn l mo mp"># Converting 1's to appropriate item name(column name)<br/>y = list(pruneddf.columns)<br/>for s in y:<br/>    pruneddf.loc[(pruneddf[s] == 1),s]=s<br/>#Removing Zero's<br/>lol = pruneddf.values.tolist() <br/>for a in lol:<br/>    while (0 in a):<br/>        a.remove(0)<br/>#Making a new pruned dataset csv file<br/>with open("pruned.csv", "w", newline="") as f:<br/>    writer = csv.writer(f)<br/>    writer.writerows(lol)</span></pre><p id="51a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一个干净和有组织的csv文件，我们可以在其上应用先验代码。</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="1f49" class="kh ki hi mi b fi mm mn l mo mp">import csv<br/>import itertools<br/>#Delete Files prunedRules and PrunedFItems otherwise new data will be appended.<br/>Groceries = open('pruned.csv', 'r')<br/>#Minimum Support Count<br/>min_support = 0.04<br/>Rules = "prunedRules.txt"<br/>freqItemsets = "prunedFItems.txt"<br/>#Mininum Confidence<br/>min_confidence = 0.30</span><span id="0a43" class="kh ki hi mi b fi mq mn l mo mp"># Finding all Frequent 1-Item sets<br/>def OneItemSets():<br/>    #Get all 1-itemsets in the list items and their counts in the dictionary counts<br/>    DataCaptured = csv.reader(Groceries, delimiter=',')<br/>    data = list(DataCaptured)<br/>    for e in data:<br/>        e = sorted(e)<br/>    count = {}<br/>    for items in data:<br/>        for item in items:<br/>            if item not in count:<br/>                count[(item)] = 1<br/>            else:<br/>                count[(item)] = count[(item)] + 1</span><span id="f795" class="kh ki hi mi b fi mq mn l mo mp">count2 = {k: v for k, v in count.items() if v &gt;= min_support*9835}</span><span id="efaf" class="kh ki hi mi b fi mq mn l mo mp">return count2, data</span><span id="83b6" class="kh ki hi mi b fi mq mn l mo mp">#Ck is a superset of Lk. It is a part of Prune Step. its members may or may not be frequent, but all of the frequent k-itemsets are included in Ck.<br/># Generated by joing two Lk<br/>def generateCk(Lk_1, flag, data):<br/>    Ck = []<br/>    if flag == 1:<br/>        flag = 0<br/>        for item1 in Lk_1:<br/>            for item2 in Lk_1:<br/>                if item2 &gt; item1:<br/>                    Ck.append((item1, item2))<br/>        print("C2: ", Ck[1:3])<br/>        print("length : ", len(Ck))<br/>        print()</span><span id="4ee8" class="kh ki hi mi b fi mq mn l mo mp">else:<br/>        for item in Lk_1:<br/>            k = len(item)<br/>        for item1 in Lk_1:<br/>            for item2 in Lk_1:<br/>                if (item1[:-1] == item2[:-1]) and (item1[-1] != item2[-1]):<br/>                    if item1[-1] &gt; item2[-1]:<br/>                        Ck.append(item2 + (item1[-1],))<br/>                    else:<br/>                        Ck.append(item1 + (item2[-1],))<br/>        print("C" + str(k+1) + ": ", Ck[1:3])<br/>        print("Length : ", len(Ck))<br/>        print()<br/>    L = generateLk(set(Ck), data)<br/>    return L, flag</span><span id="05c4" class="kh ki hi mi b fi mq mn l mo mp">#If item in Ck belongs to a transaction, it makes it into list Ct Then Ct is thresholded to form L<br/># For K frequent Itemsets<br/>def generateLk(Ck, data):<br/>    <br/>    count = {}<br/>    for itemset in Ck:<br/>        #print(itemset)<br/>        for transaction in data:<br/>            if all(e in transaction for e in itemset):<br/>                if itemset not in count:<br/>                    count[itemset] = 1<br/>                else:<br/>                    count[itemset] = count[itemset] + 1</span><span id="d049" class="kh ki hi mi b fi mq mn l mo mp">print("Ct Length : ", len(count))<br/>    print()</span><span id="a777" class="kh ki hi mi b fi mq mn l mo mp">count2 = {k: v for k, v in count.items() if v &gt;= min_support*9835}<br/>    print("L Length : ", len(count2))<br/>    print()<br/>    return count2</span><span id="0bdd" class="kh ki hi mi b fi mq mn l mo mp">#  Generates association rules from the frequent itemsets<br/>def rulegenerator(fitems):<br/>    counter = 0<br/>    for itemset in fitems.keys():<br/>        if isinstance(itemset, str):<br/>            continue<br/>        length = len(itemset)</span><span id="1f9e" class="kh ki hi mi b fi mq mn l mo mp">union_support = fitems[tuple(itemset)]<br/>        for i in range(1, length):</span><span id="e8a7" class="kh ki hi mi b fi mq mn l mo mp">lefts = map(list, itertools.combinations(itemset, i))<br/>            for left in lefts:<br/>                if len(left) == 1:<br/>                    if ''.join(left) in fitems:<br/>                        leftcount = fitems[''.join(left)]<br/>                        conf = union_support / leftcount<br/>                else:<br/>                    if tuple(left) in fitems:<br/>                        leftcount = fitems[tuple(left)]<br/>                        conf = union_support / leftcount<br/>                if conf &gt;= min_confidence:<br/>                    fo = open(Rules, "a+")<br/>                    right = list(itemset[:])<br/>                    for e in left:<br/>                        right.remove(e)<br/>                    fo.write(str(left) + ' (' + str(leftcount) + ')' + ' -&gt; ' + str(right) + ' (' + str(fitems[''.join(right)]) + ')' + ' [' + str(conf) + ']' + '\n')<br/>                    print(str(left) + ' -&gt; ' + str(right) + ' (' + str(conf) + ')')<br/>                    counter = counter + 1<br/>                    #Greater than 1???<br/>                    fo.close()<br/>    print(counter, "rules generated")<br/>def plotitemfreq(L):<br/>    aux = [(L[key], key) for key in L]<br/>    aux.sort()<br/>    aux.reverse()<br/>    z = aux[0:20]<br/>    print(z)<br/>    df = pd.DataFrame(z, columns = ['Count', 'Word'])<br/>    df['Count']=pd.to_numeric(df['Count'])<br/>    print(df.info())<br/>    df.plot.bar(x='Word', y='Count')</span><span id="3af5" class="kh ki hi mi b fi mq mn l mo mp">def apriori():<br/>    L, data = OneItemSets()<br/>    flag = 1<br/>    FreqItems = dict(L)<br/>    while(len(L) != 0):<br/>        fo = open(freqItemsets, "a+")<br/>        for k, v in L.items():<br/>           <br/>            fo.write(str(k) + ' &gt;&gt;&gt; ' + str(v) + '\n\n')<br/>        fo.close()<br/>        plotitemfreq(L)</span><span id="eefb" class="kh ki hi mi b fi mq mn l mo mp">L, flag = generateCk(L, flag, data)<br/>        FreqItems.update(L)<br/>    rulegenerator(FreqItems)</span><span id="1056" class="kh ki hi mi b fi mq mn l mo mp">apriori()</span></pre><p id="02f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有输出:</p><ol class=""><li id="b974" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">频繁项目和项目集</li></ol><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es mx"><img src="../Images/3c70f77488f7700fa9c004b0814c20c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*lNYpR4PUiSFKyeEyBz2N2w.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">项目频率</figcaption></figure><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es my"><img src="../Images/f42c5af4f02d101c36c678b67b882b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*MALJRdaDrN2F7nY6Hu0B2g.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">项目集的频率</figcaption></figure><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es mz"><img src="../Images/3b20eb3266c44da8308552c94326d686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*8FIzVs0c33YM3oSFqfWxag.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">PrunedFitems.txt视图</figcaption></figure><p id="3e10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.生成的规则</p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es na"><img src="../Images/022973b41c2deb6bc59f95ce0528c69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*sQ52QH5SJJqRrBHGkl2AEw.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">生成的规则</figcaption></figure><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="er es nb"><img src="../Images/66372db8246d93eacc8e6e4f847202ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_Gemhk44eUF8zbtuO82bg.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">prunedRules.txt视图</figcaption></figure><p id="3476" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至此，我们已经完成了市场篮子分析。</p><p id="daec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae mf" href="https://github.com/HardiRathod/market-basket-analysis-apriori" rel="noopener ugc nofollow" target="_blank">完整代码- Github </a></p><p id="acf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如有任何疑问或问题，请评论或发送邮件。</p><p id="561f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一定要看看我的<a class="ae mf" rel="noopener" href="/@rathodhardi200">其他作品</a>。</p></div></div>    
</body>
</html>