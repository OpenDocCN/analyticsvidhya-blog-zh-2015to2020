# 一个平滑的背景图像生成器，用于给图像着色，例如 EMNIST 数据集中的图像

> 原文：<https://medium.com/analytics-vidhya/a-smooth-background-image-generator-to-colourize-images-such-as-one-in-emnist-dataset-c3e259716582?source=collection_archive---------17----------------------->

我们先来讨论一下这个帖子到底想做什么。

我们正在寻找的是一个很好的背景，这样我们就可以渲染灰度图像，如 EMNIST 数据集作为彩色图像，并且很容易在眼睛上识别图像中存在的对象。背景应该有一个从一种颜色到另一种颜色的良好过渡，使我们能够容易地识别物体。当然，我们希望它有尽可能多的颜色！

由于我们想要的是一种非常独特的欲望，我四处寻找，但找不到任何可以帮助我们的数据集。因此，我们将在没有任何数据集的情况下完成这一旅程。所以这完全取决于我们的损失函数。

因此，为了定义我们的损失函数，我们应该首先有一个高层次的观点是什么使颜色出现在图像中。彩色图像有三个通道，分别对应红色、绿色和蓝色。所有这些颜色通道的数量级决定了哪种颜色出现在图像中。每个通道都将具有与图像相同的分辨率。因此，如果图像的分辨率为 1024×1024，那么每个通道可以被可视化为 1024×1024 的网格。每一个都被称为像素。每个像素中的值的范围可以从 0 到 255。每个通道中所有像素值都为 0 的图像对应于黑色图像，所有 255 对应于白色图像。介于两者之间的所有数值构成了其他颜色的全部范围。

由于神经网络在处理[0，1]范围内的数字时比处理[0，255]范围内的数字时工作得更好，所以我们将坚持使用[0，1]范围。这样做的效果是，虽然我们将能够生成所有可能的颜色(因为任何颜色都是基于像素的相对值而不是绝对值形成的)，但亮度会降低，这是一个好处，因为它将进一步增强对象。

有了这个背景，我们来定义损失函数。将会有几个函数，我们通过它们来测量模型的损失。这是两者中的第一个。

![](img/87bc3ca710f4f606b61d0fc8e64be8a6.png)

此功能确保图像中的数字均匀分布

*compute _ distribution _ loss*函数获取图像，并返回数字在范围[0，1]中分布的均匀程度。图像的像素值首先沿列排序，并与 PyTorch 框架的[和](https://pytorch.org/docs/stable/generated/torch.rand.html)函数给出的排序均匀分布进行比较。此函数确保范围内的数字均匀分布。因此具有以相等的概率产生所有颜色的能力。

虽然这个函数可以确保我们得到[0，1]范围内的所有数字，但是数字出现的顺序呢？如果这些数字杂乱无章，那么我们就很难识别这个物体，它就会被背景所掩盖。这将我们带到下一个损失函数，它确保从一种颜色到另一种颜色的平滑过渡。

![](img/dee8e61243c3b09681d0dd94c54fecdf.png)

该功能确保从一种颜色到另一种颜色的平滑过渡

*compute_var_loss* 函数接收图像并返回像素值从一个过渡到另一个的平滑程度。对于每个图像，会生成一个 16x16 的随机裁剪。我们找到裁剪图像的方差，并将其除以最大值和最小值之间的差。计算随机裁剪图像的方差可确保此范围内的数字彼此接近，进而形成平滑过渡。为了使裁剪后的图像中的所有值都不相同(这会妨碍我们生成所有的数字)，我们用最大值和最小值之差来除它。

损失函数已经讲得够多了，现在让我们把注意力转移到模型的网络上。

我们模型的架构非常简单。它是一个三层网络。这三层是致密层，分别具有 64、2048 和 4096 个神经元。最后一层输出然后被整形为 64x64 以形成图像。下面给出了该架构的简单示意图。

![](img/22b0a2b9f1bc0f0b7cc8b62c9e2348dd.png)

模型的架构

现在让我们来谈谈我们想要使用的激活函数，尤其是最后一层要使用的函数。我们说过，我们希望输出在[0，1]的范围内。有几个函数可以满足这个属性。

Sigmoid 函数就是这样一个函数。下面给出了函数的图形。

![](img/d7025d160f64e8637f516c7cb6687423.png)

sigmoid 激活函数图

如您所见，大多数值偏向 0 或 1，只有一小部分数值介于两者之间。因此不太适合我们的应用。

另一个功能是 softmax 功能。并且定义如下:

![](img/bc568532ded8a691cd79e3bc13fa661f.png)

softmax 激活功能的定义

如您所见，softmax 实际上是取幂值的一部分指数。它非常适合多类分类。然而，softmax 函数扩大了最大值和最小值之间的差异，并且大多数数字接近于零而不是一。这是因为我们将在 4096 个值输出中取 softmax，这是模型的输出大小。

为了解决我们提出的问题，我们将使用我们自己的激活函数。让我们称它为 *Shift_range* ，因为我们希望它将范围转换为[0，1]。并且定义如下。

![](img/9d9cfdea7d08bca822f36da450508a77.png)

最后一层使用的自定义激活功能 **Shift_range**

正如人们可以观察到的，我们将把数字的规模减少到[0，1]。这使得我们可以得到[0，1]范围内的所有数字，而在生成的图像中没有太多技术问题。

关于损耗和激活函数，我们已经讨论得够多了。因此，没有太多的延迟，让我们的模型运行。看看它能给我们带来什么。我们将使用 RMSprop 优化算法以 0.00001 的学习率来训练网络。

所以训练网络 1000 个历元后，这就是模型生成的样本图像。

![](img/347a64779e3850e1d1ff62f033fafb6f.png)

1000 个时期后生成的样本图像

相当令人惊讶。我们说过希望所有的数字都在 0 到 1 之间。并且数字之间应该有平滑的过渡。我们把它们都拍进了图像中，但最终我们还是得到了一张黑白图像。这是因为我们假设模型每次都会有不同的输出。但是看起来生成的图像是相同的，与给定的输入无关。当然，通过深度学习，我们得到了我们想要的，而不是我们想要的！

但是让我们看看我们能从中得到什么。产生彩色图像的一种方法是将特定的频道翻转 90 度或 270 度。通过这样做，我们可以得到下面的图像。

![](img/cf674d0a3b44dcd778122fcade074bb6.png)

将频道随机翻转 90 度或 270 度的示例图像

有了这个，我们现在可以使用像 EMNIST 这样的数据集生成彩色图像。EMNIST 是英文字母灰度图像的数据集。

我在 EMNIST 数据集上训练了一个条件生成对抗网络，并将在这里使用它。这个项目可以在我的 GitHub 资源库中找到:[https://GitHub . com/lokesh-Kumar-t-n/conditional-generative-adversarial-network](https://github.com/lokesh-kumar-t-n/conditional-generative-adversarial-network/)。

我们可以通过将字母作为通道之一来使图像着色。

![](img/b8e22e30fd9b06c7fb726c6313307ca2.png)

将字母作为通道之一生成的图像

我们可以使用边缘检测器，并将其添加到任何通道中。

![](img/d6138bf6716d801db82fa045d865199e.png)

通过在字母上添加边缘检测器的输出而生成的图像

最后，我们可以使背景为彩色，保持字母为灰色。这是我最喜欢的！

![](img/6c3a39e3c5e5eefe5ea69af5b8ce41b9.png)

通过将背景颜色和字母设为灰色生成的图像

这个项目需要的所有文件都可以在我的 Github 资源库中找到:【https://github.com/lokesh-kumar-t-n/Background_generator】T2。做这个项目很有趣，在课程中学到了很多东西。我希望你也玩得开心并有所收获。

谢谢大家！