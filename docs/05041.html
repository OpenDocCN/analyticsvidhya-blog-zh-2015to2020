<html>
<head>
<title>Handwritten Digit Recognition GUI App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">手写数字识别GUI应用程序</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/handwritten-digit-recognition-gui-app-46e3d7b37287?source=collection_archive---------0-----------------------#2020-04-09">https://medium.com/analytics-vidhya/handwritten-digit-recognition-gui-app-46e3d7b37287?source=collection_archive---------0-----------------------#2020-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7eaa30e7917edb61a8a909901c0beb06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6K-V1gDfdRd0qo5ixnG0A@2x.jpeg"/></div></div></figure><h1 id="c362" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">简介</strong></h1><p id="83f5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">每天，开发人员都在努力研究机器，通过使用机器学习和深度学习技术使它们更加聪明和智能，以便它们可以执行类似于人类的任务。在这些技术的帮助下，人类在识别、学习、预测和许多其他领域的努力可以减少。</p><blockquote class="km kn ko"><p id="5119" class="jo jp kp jq b jr kq jt ju jv kr jx jy ks kt kb kc ku kv kf kg kw kx kj kk kl hb bi translated">计算机从纸质文件、图像、触摸屏等来源识别人类手写数字的能力被称为<strong class="jq hj">手写数字识别</strong>。</p></blockquote><p id="f15b" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">在这篇文章中，你将发现如何开发一个深度学习模型，以使用<strong class="jq hj"> MNIST </strong>数据集实现手写数字识别任务的高性能，并基于<strong class="jq hj"> Tkinter </strong>构建一个<strong class="jq hj"> GUI应用</strong>，其中，你可以绘制数字(单个以及多个)，并通过绘制每个数字周围的边界框来直接识别它。</p><h1 id="7fba" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">问题陈述</strong></h1><p id="1988" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于人类来说，通过反复练习并为下一次记忆来准确地执行任务是很容易的。人脑可以很容易地处理和分析图像。此外，识别图像中存在的不同元素。</p><blockquote class="km kn ko"><p id="71f5" class="jo jp kp jq b jr kq jt ju jv kr jx jy ks kt kb kc ku kv kf kg kw kx kj kk kl hb bi translated">手写数字识别中的挑战主要是由每个个体的书写风格变化引起的。因此，让机器像人类一样准确地识别手写数字并不容易。因此，稳健的特征提取对于提高机器的性能非常重要。</p></blockquote><h1 id="216c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">MNIST数据集</h1><p id="dc4a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">MNIST数据集(Modified National Institute of Standards and Technology)是一个庞大的手写数字数据集，广泛用于机器学习和深度学习领域的训练和测试。</p><blockquote class="km kn ko"><p id="7e6a" class="jo jp kp jq b jr kq jt ju jv kr jx jy ks kt kb kc ku kv kf kg kw kx kj kk kl hb bi translated">MNIST数据集包含从0到9(0到9)的手写数字的60，000幅训练图像和10，000幅测试图像。因此，MNIST数据集有10个不同的类。每个图像被表示为28×28矩阵，其中每个单元包含灰度像素值。</p></blockquote><h1 id="a5c1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么要深度学习？</h1><p id="433e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">深度学习是一种机器学习，它使用多层从输入中逐步提取更高级别的特征。因此，深度学习减少了为每个问题开发新的特征提取器的任务。深度学习的这一特点是比传统机器学习领先了一大步。</p><blockquote class="km kn ko"><p id="e3ca" class="jo jp kp jq b jr kq jt ju jv kr jx jy ks kt kb kc ku kv kf kg kw kx kj kk kl hb bi translated">大多数现代深度学习模型都基于人工神经网络，具体来说，就是我们将在本文中使用的卷积神经网络(CNN)。</p></blockquote><h1 id="5a9a" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">实现CNN手写数字识别GUI应用程序的步骤:</h1><ol class=""><li id="858b" class="ky kz hi jq b jr js jv jw jz la kd lb kh lc kl ld le lf lg bi translated">导入库并加载MNIST数据集</li><li id="275c" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl ld le lf lg bi translated">数据预处理和归一化</li><li id="2cf3" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl ld le lf lg bi translated">创建模型</li><li id="82f7" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl ld le lf lg bi translated">训练模型</li><li id="3191" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl ld le lf lg bi translated">评估模型</li><li id="f900" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl ld le lf lg bi translated">创建GUI来预测数字</li></ol><blockquote class="km kn ko"><p id="c004" class="jo jp kp jq b jr kq jt ju jv kr jx jy ks kt kb kc ku kv kf kg kw kx kj kk kl hb bi translated">该项目要求你有Python编程的基础知识，OpenCV，深度学习与Keras库和Tkinter库构建GUI。</p></blockquote><h1 id="395e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 1。导入库并加载MNIST数据集</strong></h1><p id="54a1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，我们将导入训练模型所需的库。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/fd29c743a7a0590788e37e72fb53abc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X63PbS5GXv9I1ZzAfhdStw@2x.jpeg"/></div></div></figure><p id="2bce" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">为了加载数据集，Keras深度学习库提供了一种加载MNIST数据集的便捷方法。所以我们可以通过调用<strong class="jq hj"> mnist.load_data </strong>()函数轻松导入数据集。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/e43236ecd8ab26c4e6435a7cac66309a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gj8OrgjOeniOvnI3rSbEaA@2x.jpeg"/></div></div></figure><p id="7a30" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">最好在使用数据集之前将其可视化。在这里，我们绘制了MNIST训练数据集的六个样本用于可视化。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/ef46a9e3422f3813b4768e911beb119b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uttg8i3VB7G03XpIJs4JMQ@2x.jpeg"/></div></div></figure><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/626606f9ceeb4dec95528547c2f8b5f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SeV-XFwxvkSZdz4gJa3gQ@2x.jpeg"/></div></div></figure><h1 id="a875" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 2。数据预处理和归一化</strong></h1><p id="e746" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们知道，所有图像(数据集)都表示为包含灰度像素值的28×28矩阵。据此，训练数据的维数是(60000，28，28)，但是CNN模型将需要多一个维数，因此我们需要通过将矩阵整形为(60000，28，28，1)来处理数据。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/3305b11568bcb5f8cf6df33c51900382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVG0hOGYtidwTaE2ssHVHw@2x.jpeg"/></div></div></figure><p id="a06c" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">使用神经网络模型时，最好对输入值进行一些缩放，通过将每个值除以最大值将像素值归一化到范围0和1(注意:像素值是0到255之间的灰度)。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/e9e6b6543146349f7ccb6b8ea0396eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wZ9rv3SYZJmDWUI2EKpY2g@2x.jpeg"/></div></div></figure><h1 id="e6b2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">3.创建模型</h1><p id="a0a2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在，我们将创建一个CNN模型，它具有同样大小的3×3的双卷积层、最大池层和全连接层。脱落层用于去激活一些神经元以减少过度拟合。最后，输出层有10个神经元用于10个类。然后，我们将使用ADAM优化器编译该模型。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/58634b2a1bedd1f44772961171487dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJEcbDXyralG9enDjvF4YQ@2x.jpeg"/></div></div></figure><h1 id="ffef" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">4.训练模型</h1><p id="af4b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Keras的<strong class="jq hj"> model.fit </strong>()函数采用训练数据、验证数据、时期和批量大小来训练模型。根据您的工作环境(CPU或GPU)，训练模型需要一些时间。完成后，我们将模型保存在名为“model.h5”的文件中，以备后用。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/26d8c39954cb23bdcb489df2aee817ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pJ8qXtHweQxrqja-deGUlQ@2x.jpeg"/></div></div></figure><h1 id="c1e1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">5.评估模型</h1><p id="ec06" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了评估我们的模型的性能，我们有10，000个手写数字的测试图像。MNIST数据集得到了很好的平衡，因此我们可以获得大约99%的准确性(即CNN error &lt; 1%).</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/4cc2f44563ed70290eb17345d060df8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7T298AF6Og2FJheZhD6ow@2x.jpeg"/></div></div></figure><h1 id="3659" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">6. Create GUI to predict digits</h1><p id="c676" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Finally it’s time to build GUI App using Tkinter. We will create a new file to build a GUI.</p><blockquote class="km kn ko"><p id="ae2e" class="jo jp kp jq b jr kq jt ju jv kr jx jy ks kt kb kc ku kv kf kg kw kx kj kk kl hb bi translated">The tkinter package is the standard Python interface to the Tk GUI toolkit. It is the fastest and easiest way to create the GUI applications. It provides a variety of common GUI elements – such as buttons, menus and various kinds of entry fields and display areas.</p></blockquote><p id="712e" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">There are two main methods:</p><ul class=""><li id="6bc6" class="ky kz hi jq b jr kq jv kr jz lz kd ma kh mb kl mc le lf lg bi translated">Tk()</li><li id="ba89" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl mc le lf lg bi translated">mainloop()</li></ul><p id="ff27" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated"><strong class="jq hj"> Tk </strong>()是我们用来创建应用程序主窗口的方法，而<strong class="jq hj"> mainloop </strong>()是我们想要运行应用程序时在主窗口上执行的方法。</p><p id="ab35" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">让我们从导入应用程序所需的模块开始。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/d5a9d957290582b92caa4be0d9ccd1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kDBqef4UZOMMSUNGYzowA@2x.jpeg"/></div></div></figure><p id="e6e3" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">这里，我们通过提供模型路径来加载保存的模型以识别手写数字。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/a78b732f55be3df5147283571119b488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*smlWNvY9siGlSvLpvrjDww@2x.jpeg"/></div></div></figure><p id="2ace" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">在代码块中，我们创建了根窗口，这是我们的应用程序的主窗口，标题为“<strong class="jq hj">手写数字识别GUI App </strong>”。</p><p id="40b2" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">tkinter内置了不同的小部件类，但我们将使用其中的几个来创建我们的应用程序:</p><ul class=""><li id="50c9" class="ky kz hi jq b jr kq jv kr jz lz kd ma kh mb kl mc le lf lg bi translated"><strong class="jq hj"> Canvas </strong>是一个绘制图形的小工具。它可以用来创建自定义部件，所以我们可以在里面画任何我们喜欢的东西。在我们的应用程序中，我们将使用小部件来绘制数字(单个和多个)。</li><li id="2c51" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl mc le lf lg bi translated">一个<strong class="jq hj">按钮</strong>通常直接映射到一个用户动作上。在我们的应用程序中，我们使用了两个按钮，分别名为“<strong class="jq hj">识别数字</strong>和“<strong class="jq hj">清除部件</strong>”。当用户点击一个按钮时，它触发指定的功能。</li></ul><blockquote class="km kn ko"><p id="12e1" class="jo jp kp jq b jr kq jt ju jv kr jx jy ks kt kb kc ku kv kf kg kw kx kj kk kl hb bi translated">Tkinter提供了一个强大的机制，可以让你处理事件并将处理程序绑定到它们，使用bind方法，我们可以在每个小部件类中找到它。事件由字符串格式的序列名称唯一标识。</p></blockquote><p id="88ef" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">在我们的应用程序中，我们将使用“<button-1>”和“<b1-motion>”事件。</b1-motion></button-1></p><blockquote class="km kn ko"><p id="3e31" class="jo jp kp jq b jr kq jt ju jv kr jx jy ks kt kb kc ku kv kf kg kw kx kj kk kl hb bi translated">"<button-1>"事件表示当鼠标光标位于小部件上时，鼠标左键被按下。</button-1></p><p id="ece2" class="jo jp kp jq b jr kq jt ju jv kr jx jy ks kt kb kc ku kv kf kg kw kx kj kk kl hb bi translated"><b1-motion>表示按下左键的同时移动了鼠标。</b1-motion></p></blockquote><p id="e056" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">现在我们在主窗口上执行<strong class="jq hj">主循环</strong>()方法来运行我们的应用程序。这个方法将永远循环，等待来自用户的事件，直到用户退出程序。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/50e80340fb88496dd9281ffb78372c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_hubzh3jp5KFEGaVjRF9_g@2x.jpeg"/></div></div></figure><p id="c549" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">在这段代码中，我们使用了三个函数:</p><ul class=""><li id="4e23" class="ky kz hi jq b jr kq jv kr jz lz kd ma kh mb kl mc le lf lg bi translated">清除_小部件()</li><li id="ced4" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl mc le lf lg bi translated">激活事件()</li><li id="38d0" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl mc le lf lg bi translated">绘制线条()</li></ul><p id="301a" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated"><strong class="jq hj"> clear_widget </strong>()函数用于清除画布。请注意，添加到画布的项目会一直保留，直到您移除它们。在我们的应用程序中，我们将使用<strong class="jq hj"> delete </strong>()方法来清除画布上以前绘制的数字，以便我们可以绘制新的数字。</p><p id="3e40" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">事件可以来自各种来源，包括用户的按键和鼠标操作。对于每个小部件，您可以将Python函数和方法绑定到事件。</p><p id="bfcf" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">在我们的应用程序中，我们使用Canvas小部件的bind方法将一个<strong class="jq hj"> activate_event </strong>()函数绑定到一个名为&lt; Button-1 &gt;的事件，并且在这个回调函数中我们将另一个函数<strong class="jq hj"> draw_lines </strong>()绑定到一个名为&lt; B1-Motion &gt;的事件。</p><blockquote class="km kn ko"><p id="d5fe" class="jo jp kp jq b jr kq jt ju jv kr jx jy ks kt kb kc ku kv kf kg kw kx kj kk kl hb bi translated">注意:移动鼠标，按住鼠标键1，鼠标指针的当前位置在传递给回调的事件对象的x和y成员中提供。</p></blockquote><p id="cd48" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated"><strong class="jq hj"> draw_lines </strong>()函数用来在画布上画一条线。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/9af09af3406aaf0bd490466e082b8186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYxLwfZMZjO27hEQeKMcEg@2x.jpeg"/></div></div></figure><p id="3f38" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">下一个块包含一个名为<strong class="jq hj"> Recognize_Digit </strong>()的函数。这个函数很大，所以为了更好的理解，我将它分成几部分。</p><p id="7b8b" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">在本节中，我们将使用<strong class="jq hj"> ImageGrab </strong>模块将屏幕或剪贴板的内容复制到<strong class="jq hj"> PIL </strong> (Python图像库)图像内存中。基本上，它拍摄屏幕快照。</p><p id="aa8e" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">拍摄完屏幕快照后，我们将使用一个<strong class="jq hj">裁剪</strong>方法，该方法将四个坐标作为输入，并从图像中返回一个矩形区域(在本例中是快照)，然后我们将<strong class="jq hj">以png格式在给定文件名下保存</strong>图像。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/96903656ec2dd356609a9ce6b9da6dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5KPlIRq0OgKJODACfbRMg@2x.jpeg"/></div></div></figure><p id="5760" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">在我们的应用中，我们将使用<strong class="jq hj"> OpenCV </strong>(开源计算机视觉)。</p><blockquote class="km kn ko"><p id="c50c" class="jo jp kp jq b jr kq jt ju jv kr jx jy ks kt kb kc ku kv kf kg kw kx kj kk kl hb bi translated">OpenCV-Python是一个Python绑定库，旨在解决计算机视觉问题。</p></blockquote><p id="e32b" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">在这一节中，我们将使用OpenCV来查找之前保存的图像的轮廓。轮廓可以简单地解释为连接所有连续点(沿边界)的曲线，具有相同的颜色或强度。它是物体检测和识别的有用工具。</p><p id="ba73" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">最好使用二进制图像以获得更好的准确性，因此在找到轮廓之前，应用一个<strong class="jq hj">阈值</strong>。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/ea0e010f77142b625c2f6d2eccd1def7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s7fL2Vc3g7bqDB-IS_nLGA@2x.jpeg"/></div></div></figure><p id="7e3b" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">这是函数<strong class="jq hj"> Recognize_Digit </strong>()的最后一部分。在本节中，我们将为轮廓创建<strong class="jq hj">边界框</strong>并提取<strong class="jq hj"> ROI </strong>。在提取出感兴趣的区域后，我们将对图像进行预处理(调整大小、整形和归一化)以支持我们的模型输入。现在，是时候执行<strong class="jq hj"> model.predict </strong>()方法来识别手写数字，并使用预测值和百分比绘制图像中出现的每个数字周围的边界框。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/979040885a4fd41ccfafea47627e8d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wgU-uBy-n3_vFULwWT7GQ@2x.jpeg"/></div></div></figure><h1 id="859d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">项目截图</h1><div class="ln lo lp lq fd ab cb"><figure class="mi ij mj mk ml mm mn paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/2dea7491633e62938a277b519a20af38.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*eGqb47FdteSkGHdtDBfuhQ@2x.jpeg"/></div></figure><figure class="mi ij mo mk ml mm mn paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/4883619597efe46d74c3ce9802575475.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*AkidhZ-6jKJEJlaWgSC3PQ@2x.jpeg"/></div></figure><figure class="mi ij mp mk ml mm mn paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/325709570ca63ce181591237b0389983.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*OivFJrANoLF1luYRQX7LYA@2x.jpeg"/></div></figure></div><h1 id="c9ec" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">摘要</h1><p id="b955" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在这篇文章中，我们基于CNN深度学习，用Python成功构建了一个手写数字识别GUI App。</p><p id="21bc" class="pw-post-body-paragraph jo jp hi jq b jr kq jt ju jv kr jx jy jz kt kb kc kd kv kf kg kh kx kj kk kl hb bi translated">我们已经训练了非常有效的卷积神经网络(CNN误差&lt; 1%)。最后，我们构建了一个应用程序，在这个应用程序中，我们可以在画布上绘制一个数字(单个和多个)，并在包围图像中每个数字的边界框顶部显示预测结果(值和百分比)。</p><h1 id="fa43" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">资源</h1><ul class=""><li id="e42f" class="ky kz hi jq b jr js jv jw jz la kd lb kh lc kl mc le lf lg bi translated">https://www.wikipedia.org/</li><li id="9cf0" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl mc le lf lg bi translated">https://keras.io</li><li id="dc54" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl mc le lf lg bi translated">https://docs.python.org/3/library/tkinter.html</li><li id="7dc7" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl mc le lf lg bi translated">https://opencv.org</li><li id="6110" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl mc le lf lg bi translated">https://pillow.readthedocs.io/</li><li id="4870" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl mc le lf lg bi translated">https://machinelearningmastery.com/</li><li id="e33f" class="ky kz hi jq b jr lh jv li jz lj kd lk kh ll kl mc le lf lg bi translated">https://data-flair.training/blogs</li></ul></div></div>    
</body>
</html>