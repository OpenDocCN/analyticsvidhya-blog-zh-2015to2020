<html>
<head>
<title>Parsing Slippi Files into Pandas DataFrames: The Metadata</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Slippi文件解析为Pandas数据帧:元数据</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/parsing-slippi-files-into-pandas-dataframes-the-metadata-2efdfcb8562c?source=collection_archive---------7-----------------------#2019-11-30">https://medium.com/analytics-vidhya/parsing-slippi-files-into-pandas-dataframes-the-metadata-2efdfcb8562c?source=collection_archive---------7-----------------------#2019-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b5ffbadb124586126208581d35c8cc29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3KcPZUEg4LfstaQb"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@north_of_rapture?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">pawedurczok</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="f7dc" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">超级粉碎兄弟。</h1><p id="3603" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">《超级粉碎兄弟》是任天堂发行的一个视频游戏系列，不同系列的视频游戏角色在其中一决雌雄。该系列的第二款游戏《超级粉碎兄弟混战》于2001年12月发布。这引发了有趣的聚会、快乐的玩家和激烈的竞争。到2002年，这些竞争从朋友团体发展到当地的邻里挑战，再到大规模的比赛。如果你有兴趣了解超级粉碎兄弟近战竞技场景的历史，我鼓励你观看一部由东点影业制作的名为<a class="ae iu" href="https://www.youtube.com/watch?v=NSf2mgkRm7Q&amp;list=PLoUHkRwnRH-IXbZfwlgiEN8eXmoj6DtKM" rel="noopener ugc nofollow" target="_blank"> <em class="kr">的粉碎兄弟</em> </a>的纪录片。</p><h1 id="8cd8" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">电子竞技的工具</h1><p id="9820" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这个社区的许多玩家都致力于成为最好的玩家。有许多粉丝制作的工具和游戏模块，目的是改善玩家在训练中的体验或改善内容的制作。一些工具允许玩家创建保存状态，这样他们可以很容易地快速练习一个场景。其他的允许内容创建者创建回放供观众欣赏。今天，我想强调其中的一个工具，Slippi项目。</p><ul class=""><li id="9ec8" class="ks kt hi jv b jw ku ka kv ke kw ki kx km ky kq kz la lb lc bi translated"><a class="ae iu" href="https://slippi.gg/" rel="noopener ugc nofollow" target="_blank">网站</a></li><li id="095f" class="ks kt hi jv b jw ld ka le ke lf ki lg km lh kq kz la lb lc bi translated"><a class="ae iu" rel="noopener" href="/project-slippi/project-public-release-4080c81d7205">中型博客文章</a></li><li id="2b93" class="ks kt hi jv b jw ld ka le ke lf ki lg km lh kq kz la lb lc bi translated"><a class="ae iu" href="https://github.com/project-slippi/project-slippi" rel="noopener ugc nofollow" target="_blank"> Github </a></li></ul><h1 id="adea" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">Slippi文件</h1><p id="33e5" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">使用Slippi，玩家可以记录游戏信息，如玩家正在玩的舞台，玩家正在使用的端口，以及游戏每一帧(1/60秒)的控制器输入。我将专注于Fight Pitt 9锦标赛，该锦标赛的所有记录游戏总计近2.5千兆字节的数据将被解析为数据帧。</p><p id="85f7" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">我邀请您参考<a class="ae iu" href="https://py-slippi.readthedocs.io/en/latest/py-modindex.html" rel="noopener ugc nofollow" target="_blank"> py-slippi </a>数据字典来了解slippi文件的结构。</p><p id="90ba" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">使用的数据来源于使用<code class="du ll lm ln lo b">!replaydumps</code>聊天命令的Slippi Discord。</p><h1 id="2f73" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">元数据</h1><p id="df4a" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">首先，这里是我们将要使用的库。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="aa77" class="lx iw hi lo b fi ly lz l ma mb">import pandas as pd<br/>import slippi as slp<br/>import os</span></pre><p id="ef36" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">首先，元数据将包含在单个匹配中不变的信息。要获取元数据，我们必须获取所需Slippi文件的文件路径并创建一个游戏对象。实例化游戏对象后，我们就可以查看元数据属性了。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/fb4cac88743485327973a79dc7dcb9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZxEp6KdwSXxULCbzK0KZQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">导航到元数据</figcaption></figure><p id="a760" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">你可能已经注意到元数据显示游戏中没有玩家。换句话说，每个端口有四个非类型值。除此之外，关于团队战斗是否开启，正在使用什么游戏版本，以及所选阶段的信息也丢失了。放心吧！这可以在游戏对象的start属性中找到。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/5b0eb531e445e75072de6c4aad9cafa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgquJs5zSEar3h_4rm3tEQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">导航到其他元数据</figcaption></figure><p id="78b0" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">我们现在知道如何浏览Slippi文件来获取单个游戏的元数据。然而，锦标赛是游戏的集合。我们需要创建一个函数来解析所有这些数据。下表描述了元数据数据帧的列，其中每行代表一个游戏。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/3a0a98f5ebea365035822af8c05c9bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SeE1blovz2qKo1B8pecAdg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">元数据数据字典</figcaption></figure><h1 id="daeb" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">该功能</h1><ol class=""><li id="219c" class="ks kt hi jv b jw jx ka kb ke mf ki mg km mh kq mi la lb lc bi translated">创建游戏对象</li><li id="485e" class="ks kt hi jv b jw ld ka le ke lf ki lg km lh kq mi la lb lc bi translated">收集元数据</li><li id="c8ba" class="ks kt hi jv b jw ld ka le ke lf ki lg km lh kq mi la lb lc bi translated">创建数据框架</li></ol><p id="5ef1" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">要创建游戏集合的游戏对象，我们可以创建所有游戏对象的列表。然而，如果我们希望解析在Fight Pitt 9中拍摄的所有Slippi文件，那么在一个列表中就有近2.5千兆字节的数据。为了从内存上缓解这个问题，我们将创建一个所有游戏的文件路径列表。目标是创建我们希望从中提取数据的文件的游戏对象。一旦我们从该文件中提取完数据，我们将用一个新文件覆盖该文件。这样，当执行函数时，我们将只有一个文件存储在内存中。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/8aa418cbec4ce8a54eae92af651148be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-xGKV1jG4vS6ywrZl7RMg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">创建Slippi文件路径列表</figcaption></figure><p id="ae30" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">现在来定义我们的函数。我们将使用Slippi文件路径列表作为输入。然后，我们需要为每一列实例化一个空列表。</p><p id="995c" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">注意:完整功能的代码块将在文章的底部。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="2e40" class="lx iw hi lo b fi ly lz l ma mb">def metadata_to_df(slp_files):<br/>    # lists of values to populate dataframe.<br/>    dates, game_id, durations, plats, num_players, p1_chars, \<br/>    p2_chars, p3_chars, p4_chars, stages, is_teams, is_pal = [], \<br/>    [], [], [], [], [], [], [], [], [], [], []</span></pre><p id="f374" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">使用我们在<code class="du ll lm ln lo b">fight_pitt_9</code>中生成的每个文件路径，我们将尝试创建游戏对象。如果目录中有一个非Slippi文件，我们将在这里使用<code class="du ll lm ln lo b">try-except</code>。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="0f9f" class="lx iw hi lo b fi ly lz l ma mb">    for path in slp_paths:<br/>        count += 1<br/>        print(f'Parsing metadata from file {count} of {length}:<br/>               {round(count / length * 100, 2)}%', end = '\r')<br/>      # try to create Game object, else skip it and try the next one<br/>        try:<br/>            game = slp.Game(path)<br/>        except:<br/>            print(f'Skip game {count} of {length}')<br/>            continue</span></pre><p id="3b8f" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">最后，我们可以填充每个列表。获取日期、持续时间、平台、阶段、团队设置和游戏版本就像导航到适当的属性一样简单。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="89fc" class="lx iw hi lo b fi ly lz l ma mb">        # take the date, duration, and platform data<br/>        dates.append(game.metadata.date)<br/>        durations.append(game.metadata.duration)<br/>        plats.append(game.metadata.platform)</span><span id="4150" class="lx iw hi lo b fi mk lz l ma mb">        # get stages played on<br/>        stages.append(game.start.stage)<br/>        <br/>        # is the game a 1v1<br/>        is_teams.append(game.start.is_teams)<br/>        <br/>        # is this a PAL match<br/>        is_pal.append(game.start.is_pal)</span></pre><p id="d5dc" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">为了获得活动端口，我们将使用一个list comprehension来提供播放器的端口索引。有了这些信息，我们就能够创建一个包含四个元素的列表。播放器正在使用的字符，或者如果在该端口索引处没有播放器，则为None。这使得人们很容易确定游戏中有多少玩家。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="f5f8" class="lx iw hi lo b fi ly lz l ma mb">        # get active ports<br/>        ports = [game.start.players.index(port) if port != None else<br/>                  None for port in game.start.players]</span><span id="5e3a" class="lx iw hi lo b fi mk lz l ma mb">        # get characters<br/>        characters = [game.start.players[port].character if port !=<br/>                       None else port for port in ports]<br/>        p1_chars.append(characters[0])<br/>        p2_chars.append(characters[1])<br/>        p3_chars.append(characters[2])<br/>        p4_chars.append(characters[3])</span></pre><p id="5e26" class="pw-post-body-paragraph jt ju hi jv b jw ku jy jz ka kv kc kd ke li kg kh ki lj kk kl km lk ko kp kq hb bi translated">一旦我们完成了对输入列表中最后一个文件路径的解析，我们就可以返回dataframe了。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="0a54" class="lx iw hi lo b fi ly lz l ma mb">    # return metadata DataFrame<br/>    return pd.DataFrame(data = {<br/>            'game_id': game_id,<br/>            'date': dates,<br/>            'duration': durations,<br/>            'platform': plats,<br/>            'p1_char': p1_chars,<br/>            'p2_char': p2_chars,<br/>            'p3_char': p3_chars,<br/>            'p4_char': p4_chars,<br/>            'stage': stages,<br/>            'is_teams': is_teams,<br/>            'is_pal': is_pal<br/>        })</span></pre><h1 id="07eb" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">创建数据帧</h1><p id="4dde" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">剩下要做的就是创建数据帧！调用我们刚才做的函数，把它赋给一个变量。然后走开，好好休息一下。实例化每个游戏对象的时间会迅速增加。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="ab50" class="lx iw hi lo b fi ly lz l ma mb">df = metadata_to_df(fight_pitt_9)</span></pre><h1 id="7c16" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">功能和数据框架</h1><p id="4c00" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如前所述，这里是完整的代码块和生成的数据帧的前5行的screencap。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="da8d" class="lx iw hi lo b fi ly lz l ma mb">def metadata_to_df(slp_paths):<br/>    '''<br/>    Of a collection of games, store the metadata as a dataframe.<br/>    <br/>    slp_paths (list): each value is the file path to games<br/>    returns a dataframe<br/>    '''<br/>    # Used to determine how far along the function is while waiting<br/>    length = len(slp_paths)<br/>    count = 0<br/>    <br/>    # lists of values to populate dataframe.<br/>    dates, game_id, durations, plats, num_players, p1_chars, p2_chars, \<br/>    p3_chars, p4_chars, stages, is_teams, is_pal = [], [], [], [], [], \<br/>    [], [], [], [], [], [], []<br/>    <br/>    # For each filepath in the provided list of filepaths<br/>    for path in slp_paths:<br/>        count += 1<br/>        print(f'Parsing metadata from file {count} of {length}: {round(count / length * 100, 2)}%', end = '\r')<br/>        <br/>        # try to instantiate the Game object, else skip it and try the next one<br/>        try:<br/>            game = slp.Game(path)<br/>        except:<br/>            print(f'Skip game {count} of {length}')<br/>            continue<br/>            <br/>        # set game ID<br/>        # to get file path using game_id:<br/>        # ../folder_directory/Game_[game_id].slp<br/>        ident_strip = slp_paths[count - 1].split('/')<br/>        game_id.append(ident_strip[-2] + ident_strip[-1].strip('Game_').strip('.slp'))<br/>        <br/>        # take the date, duration, and platform data<br/>        dates.append(game.metadata.date)<br/>        durations.append(game.metadata.duration)<br/>        plats.append(game.metadata.platform)</span><span id="deab" class="lx iw hi lo b fi mk lz l ma mb"># get active ports<br/>        ports = [game.start.players.index(port) if port != None else None for port in game.start.players]</span><span id="0431" class="lx iw hi lo b fi mk lz l ma mb"># get characters<br/>        characters = [game.start.players[port].character if port != None else port for port in ports]<br/>        p1_chars.append(characters[0])<br/>        p2_chars.append(characters[1])<br/>        p3_chars.append(characters[2])<br/>        p4_chars.append(characters[3])<br/>        <br/>        # get stages played on<br/>        stages.append(game.start.stage)<br/>        <br/>        # is the game not a 1v1<br/>        is_teams.append(game.start.is_teams)<br/>        <br/>        # is this not a v1.02 match<br/>        is_pal.append(game.start.is_pal)<br/>    <br/>    # return metadata DataFrame<br/>    return pd.DataFrame(data = {<br/>            'game_id': game_id,<br/>            'date': dates,<br/>            'duration': durations,<br/>            'platform': plats,<br/>            'p1_char': p1_chars,<br/>            'p2_char': p2_chars,<br/>            'p3_char': p3_chars,<br/>            'p4_char': p4_chars,<br/>            'stage': stages,<br/>            'is_teams': is_teams,<br/>            'is_pal': is_pal<br/>        })</span></pre><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/3dcb3ccceed1947adc95df07e26ea34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XOhYtXnn3tc9ysCX0Vig4Q.png"/></div></div></figure><h1 id="3253" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">接下来</h1><p id="d787" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><a class="ae iu" rel="noopener" href="/@raffysantayana/parsing-slippi-files-into-pandas-dataframes-using-pandas-map-to-filter-data-aebf0dc5e108">接下来</a>，我们将使用创建的数据帧过滤这些游戏，以仅包含最终目的地的Fox vs. Falco。</p></div></div>    
</body>
</html>