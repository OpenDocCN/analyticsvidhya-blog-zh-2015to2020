<html>
<head>
<title>Programming first principles — 10. First principle — Principle of least knowledge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程首要原则— 10。第一原理——最少知识原理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/programming-first-principles-10-first-principle-principle-of-least-knowledge-8e570871f472?source=collection_archive---------18-----------------------#2020-03-04">https://medium.com/analytics-vidhya/programming-first-principles-10-first-principle-principle-of-least-knowledge-8e570871f472?source=collection_archive---------18-----------------------#2020-03-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e55b7f570d519337416ffab8bfd19a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G03wDOZ2FSgaHGErjWQyZg.png"/></div></div></figure><p id="ebe6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本帖(<a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-principle-of-least-knowledge/" rel="noopener ugc nofollow" target="_blank">编程首要原则— 10。第一原理——最小知识原理</a>最初发表在<a class="ae jo" href="https://www.sargalias.com/" rel="noopener ugc nofollow" target="_blank">杂志</a>上。</p><ol class=""><li id="dca4" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-purpose-what-this-series-is-about/" rel="noopener ugc nofollow" target="_blank">目的——这个系列是关于什么的</a></li><li id="8af4" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-audience-who-this-series-is-for/" rel="noopener ugc nofollow" target="_blank">观众——这个系列是给谁看的</a></li><li id="3479" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-requirements-of-software/" rel="noopener ugc nofollow" target="_blank">软件需求</a></li><li id="0eaa" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-premise-minimal-information/" rel="noopener ugc nofollow" target="_blank">前提—最少信息</a></li><li id="2aa1" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-premise-we-must-understand-what-were-doing/" rel="noopener ugc nofollow" target="_blank">前提——我们必须明白我们在做什么</a></li><li id="cd6a" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-premise-minimize-propagating-changes/" rel="noopener ugc nofollow" target="_blank">前提——最小化在整个系统中传播的变更</a></li><li id="d48d" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-premise-complexity-increases-exponentially-with-scale/" rel="noopener ugc nofollow" target="_blank">前提—复杂性随规模呈指数增长</a></li><li id="2e92" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-proof-that-code-works/" rel="noopener ugc nofollow" target="_blank">第一原则——证明代码有效</a></li><li id="9015" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">第一原理——最小惊讶原理</li><li id="d052" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-principle-of-least-knowledge/" rel="noopener ugc nofollow" target="_blank">第一原理——最少知识原理</a>(本文)</li><li id="cbef" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-separation-of-concerns/" rel="noopener ugc nofollow" target="_blank">第一原则——关注点分离</a></li><li id="7922" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-abstraction/" rel="noopener ugc nofollow" target="_blank">第一原理——抽象</a></li><li id="bca3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-side-effects/" rel="noopener ugc nofollow" target="_blank">副作用</a></li></ol><p id="f530" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还建议:</p><ul class=""><li id="3332" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kd jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/when-not-to-apply-programming-principles/" rel="noopener ugc nofollow" target="_blank">何时不应用编程原则</a></li><li id="3ede" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/why-code-changes-are-error-prone/" rel="noopener ugc nofollow" target="_blank">为什么代码更改容易出错</a></li></ul></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><p id="47d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文视频版:<a class="ae jo" href="https://youtu.be/IIECT7Q5-Gk" rel="noopener ugc nofollow" target="_blank">https://youtu.be/IIECT7Q5-Gk</a></p><p id="70f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最少知识原则意味着代码应该尽可能少地了解其他代码。</p><p id="0f90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们开始之前，有一个小提示。从现在开始，我们将讨论所有剩下的首要原则(最少知识原则、关注点分离、抽象等。)重叠相当多。甚至前面的原则(最小惊讶原则)也可以被认为是这个原则的应用，反之亦然。我将尽可能保持它们的不同，但是请注意，在大多数情况下，它们都是彼此的应用程序。</p><p id="2106" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回到最少知识原则。</p><h1 id="4862" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">这是什么意思？</h1><p id="95c8" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">代码应该尽可能少地了解其他代码是什么意思？</p><p id="4dba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅仅说这句话可能没有多大意义，所以让我们从几个例子开始，以便更好地理解。</p><p id="6086" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">快速示例</strong></p><ul class=""><li id="3fa6" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kd jv jw jx bi translated">一个类或模块应该有尽可能少的公共或导出函数。完成工作所需的绝对最小值。</li><li id="4e69" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">模块/类不应该公开任何私有函数。</li><li id="3eaa" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">除非绝对必要，否则不应公开任何属性。</li><li id="366d" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">模块或类的“公共API”之间应该有明确的区别。</li><li id="b517" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">等等。</li></ul><p id="5197" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，如果我们使用像Java这样的语言……Java是基于类的，并且有公共和私有方法的正式概念。私有方法不向它们所在的类之外的任何东西公开。从其他地方无法访问它们。</p><p id="48f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这应用了最少知识的原则。使用该类的代码只知道一些公共函数，其他一无所知。其他的都是隐藏的，不可接近的。</p><p id="db99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管像JavaScript这样的语言还没有私有方法的正式概念，但其原理和重要性是完全一样的。不坚持这一原则将会付出同样的消极后果。应该应用同样的概念来避免这些后果。</p><p id="213f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">散列表示例</strong></p><p id="8f00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该原理的另一个应用是编码到<a class="ae jo" href="https://en.wikipedia.org/wiki/Protocol_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">接口</a>而不是实现。</p><p id="e586" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们使用一个接口时，我们会说“我不关心你内部如何工作，或者你有什么其他的方法，只要你有方法X”。</p><p id="9c70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank">接口分离原则</a>更进一步，有效地说“你的接口应该尽可能小”。即代码应该知道的越少越好。</p><p id="8bc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不过还是说一些代码吧。</p><p id="7cbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，假设我们的一些Java代码需要一个<code class="du lo lp lq lr b">Map</code>(相当于JavaScript中的<code class="du lo lp lq lr b">object</code>或<code class="du lo lp lq lr b">Map</code>)。在Java中，我们的代码会接受一个实现了<code class="du lo lp lq lr b">Map</code>接口的对象，它不会关心map是如何在内部实现的。可以是<code class="du lo lp lq lr b">HashMap</code>、<code class="du lo lp lq lr b">LinkedHashMap</code>、<code class="du lo lp lq lr b">CustomImplementation1</code>、<code class="du lo lp lq lr b">CustomImplementation2</code>等。这是一个实现细节。</p><p id="f984" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的代码所关心的只是它是<em class="ls">类似地图的</em>。它有我们的代码想要使用的特定方法。换句话说，需要最少的信息。它不需要知道内部实现。</p><p id="e374" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例</strong></p><p id="9d8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript中Java HashMap的一个类似例子是<code class="du lo lp lq lr b">Array.from</code>。如果我们查看Array.from 的<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" rel="noopener ugc nofollow" target="_blank"> MDN文档(在撰写本文时，2020年1月),我们会看到在语法下面写着:</a></p><blockquote class="lt lu lv"><p id="eeb6" class="iq ir ls is b it iu iv iw ix iy iz ja lw jc jd je lx jg jh ji ly jk jl jm jn hb bi translated"><code class="du lo lp lq lr b"><em class="hi">Array.from(arrayLike[, mapFn[, thisArg]])</em></code></p></blockquote><p id="b5a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意“类似数组”的部分。该功能适用于多种情况，如<code class="du lo lp lq lr b">Set</code>、<code class="du lo lp lq lr b">Array</code>、<code class="du lo lp lq lr b">HTMLCollection</code>等。它不关心我们使用什么样的数组。它关心的只是它有一个迭代器/可以在for循环中使用。</p><p id="6546" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是最少知识原则的一个应用。</p><p id="847b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下，如果我们只能使用带有<code class="du lo lp lq lr b">Set</code>的<code class="du lo lp lq lr b">Array.from</code>而没有其他的。我们会失去这个功能的大部分功能。</p><p id="cb10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">交货示例</strong></p><p id="355d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为另一个人为的例子，让我们考虑一个假想的送货公司。</p><p id="5565" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将再次是空谈多于编码，首先尝试获得概念上的理解。下一个例子将有更多的代码。</p><p id="582b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们的员工已经收到订单，让他们的团队准备产品，现在需要发送产品进行交付。</p><p id="608f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个人关心谁交付产品吗？</p><p id="29fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不完全是。他们所关心的是它能送到合适的人手里。但是他们不关心它最终是在飞机上还是在汽车上或者其他什么地方。</p><p id="4fa5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们把这个概念翻译成一些粗略的代码。</p><p id="0b03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像这样的代码就可以了:</p><pre class="lz ma mb mc fd md lr me mf aw mg bi"><span id="948f" class="mh km hi lr b fi mi mj l mk ml">function send(package, transporter) {<br/>  transporter.send(package);<br/>}</span></pre><p id="5d6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码可能不太好:</p><pre class="lz ma mb mc fd md lr me mf aw mg bi"><span id="ebc4" class="mh km hi lr b fi mi mj l mk ml">function send(package, transporter) {<br/>  switch (transporter.type) {<br/>    case 'Car':<br/>      if (!transporter.hasFuel()) {<br/>        transporter.fuelUp();<br/>      }<br/>      transporter.startEngine();<br/>      transporter.drive(package.destination);<br/>      break;<br/>    case 'Bicycle':<br/>      if (transporter.isHungry()) {<br/>        transporter.eatFood();<br/>      }<br/>      transporter.rideTo(package.destination);<br/>      break;<br/>  }<br/>}</span></pre><p id="2699" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码知道太多关于不同运输商的信息。我们有一个<code class="du lo lp lq lr b">switch</code>语句，询问运输机是什么类型，然后给它具体的指令。</p><p id="5bb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们把这和现实生活中的例子联系起来，那就太疯狂了。我们的仓库员工根本不会关心这东西是如何运输的。毕竟他们不是职业自行车手或司机。他们相信司机会专业地完成工作，他们不会微观地管理他们的工作方式。</p><p id="ed1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仓库员工不需要知道或关心司机会做什么。</p><p id="1a4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们希望我们的代码是相同的。</p><p id="85c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">外形示例</strong></p><p id="e185" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一个更像代码的例子。还是很简单做作…</p><p id="9ab8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经典的形状案例。</p><p id="5c97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑以下代码:</p><pre class="lz ma mb mc fd md lr me mf aw mg bi"><span id="e889" class="mh km hi lr b fi mi mj l mk ml">class Circle {<br/>  constructor(radius) {<br/>    this.radius = radius;<br/>    this.someImportantCircleProperty = 'something';<br/>  }</span><span id="df5b" class="mh km hi lr b fi mm mj l mk ml">  getArea() {<br/>    return Math.PI * this.radius ** 2;<br/>  }</span><span id="22fc" class="mh km hi lr b fi mm mj l mk ml">  draw(canvas) {<br/>    // Note: This implementation is fake and not important, don't spend time deciphering it<br/>    canvas.draw({ shape: 'Circle', center: [0, 0], radius: this.radius });<br/>  }</span><span id="7cb2" class="mh km hi lr b fi mm mj l mk ml">  _somePrivateCircleHelper() {<br/>    return 'foo';<br/>  }<br/>}</span><span id="19c6" class="mh km hi lr b fi mm mj l mk ml">class Square {<br/>  constructor(width) {<br/>    this.width = width;<br/>    this.someImportantSquareProperty = 'something';<br/>  }</span><span id="68d2" class="mh km hi lr b fi mm mj l mk ml">  getArea() {<br/>    return sideLength ** 2;<br/>  }</span><span id="2068" class="mh km hi lr b fi mm mj l mk ml">  draw(canvas) {<br/>    // Note: This implementation is fake and not important, don't spend time deciphering it<br/>    canvas.draw({<br/>      points: [<br/>        [0, 0],<br/>        [this.width, 0],<br/>        [this.width, this.width],<br/>        [0, this.width],<br/>      ],<br/>    });<br/>  }</span><span id="10f8" class="mh km hi lr b fi mm mj l mk ml">  _somePrivateSquareHelper() {<br/>    return 'foo';<br/>  }<br/>}</span><span id="5478" class="mh km hi lr b fi mm mj l mk ml">// do stuff with shape<br/>function main(shape, canvas) {<br/>  console.log(shape.getArea());<br/>  shape.draw(canvas);<br/>}</span></pre><p id="8bfa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码试图遵循最少知识的原则。</p><p id="dc38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">主函数知道工作所需的最小值。该代码旨在尽量减少我们的主要功能工作所需的知识。</p><p id="c034" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果语言支持接口，那么每个类都将实现一个<code class="du lo lp lq lr b">Shape</code>接口，其中包含每个形状所需的方法，以便我们的主函数能够工作。请注意，在这些类之外，不会使用任何私有属性或辅助方法。</p><p id="aae0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码怎么样:</p><pre class="lz ma mb mc fd md lr me mf aw mg bi"><span id="a08e" class="mh km hi lr b fi mi mj l mk ml">class Circle {<br/>  constructor(radius) {<br/>    this.radius = radius;<br/>    this.type = 'Circle';<br/>  }<br/>}</span><span id="c41d" class="mh km hi lr b fi mm mj l mk ml">class Square {<br/>  constructor(width) {<br/>    this.width = width;<br/>  }<br/>}</span><span id="2d06" class="mh km hi lr b fi mm mj l mk ml">// do stuff with shape<br/>function main(shape, canvas) {<br/>  if (shape.type === 'Circle') {<br/>    const area = Math.PI * shape.radius ** 2;<br/>    console.log(area);<br/>    canvas.draw({ shape: 'Circle', center: [0, 0], radius: shape.radius });<br/>  } else if (shape instanceof Square) {<br/>    const { width } = shape;<br/>    const area = width ** 2;<br/>    console.log(area);<br/>    canvas.draw({<br/>      points: [<br/>        [0, 0],<br/>        [width, 0],<br/>        [width, width],<br/>        [0, width],<br/>      ],<br/>    });<br/>  }<br/>}</span></pre><p id="f3ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面我们有一个知道得太多的主函数:</p><ul class=""><li id="e788" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kd jv jw jx bi translated">它必须明确询问它当前使用的是什么形状。</li><li id="dd09" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">它需要知道每个形状上不同命名的属性(应该是私有的)。</li><li id="b85b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">它需要知道如何计算每个形状的面积。</li><li id="c357" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">它需要知道如何画出每一个形状。</li></ul><p id="672b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有，可能不仅仅是主要功能。出于不同的原因，我们可能有多个函数需要使用形状。也许一个需要面积，另一个需要周长，等等。它们都需要与我们的主函数相似的代码。</p><p id="38ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们研究了最小知识原则的含义。我们也看到了一些例子。</p><p id="d20f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但那又怎样？如果我们违反了这个原则，又有什么关系呢？为什么上面的代码示例被认为是不好的？</p><h1 id="bc22" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">为什么最少知识原则很重要？</h1><p id="86b2" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">让我们考虑一些实际后果。</p><p id="f7d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在形状示例中，如果我们需要添加另一个形状呢？</strong></p><p id="b637" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将不得不遍历像<code class="du lo lp lq lr b">main</code>函数这样的每一个函数，并为那里的新形状添加逻辑。</p><p id="876e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下一个有10种形状的<code class="du lo lp lq lr b">main</code>函数会是什么样子。</p><p id="ea32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这打破了<a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-principle-of-least-astonishment/" rel="noopener ugc nofollow" target="_blank">最小惊讶/亲吻</a>原则。</p><p id="9fff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另外<a class="ae jo" href="https://www.sargalias.com/blog/why-code-changes-are-error-prone/" rel="noopener ugc nofollow" target="_blank">代码更改容易出错</a>，所以我们希望将它们包含在尽可能小的范围内，而不是让它们与函数中的其他10件事情搅在一起。</p><p id="d9ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是在干净的例子中，我们只需要为形状添加一个新的类，我们就完成了。我们的<code class="du lo lp lq lr b">main</code>函数只与提供的方法接口，所以不需要修改。</p><p id="f2c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如果我们想改变Circle的工作方式会怎样？</strong></p><p id="0733" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于某种原因，我们想把<code class="du lo lp lq lr b">radius</code>改名为<code class="du lo lp lq lr b">diameter</code>。</p><p id="dc97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们必须改变所有使用这个属性的函数，比如<code class="du lo lp lq lr b">main</code>，并且修改每个地方的逻辑，现在除以2(因为直径是半径的2倍)。</p><p id="0e28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再举个例子怎么样？我们有一个存储项目集合的类。如<code class="du lo lp lq lr b">this.points = [point1, point2, point3];</code>。例如，如果我们因为性能原因想换成<code class="du lo lp lq lr b">Set</code>呢？</p><p id="d8ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之，我们必须修改所有知道我们试图改变的属性的代码。</p><p id="c7f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，在这两个例子中，不知道这些私有属性的代码不会受到任何影响，如果我们改变它们的话。</p><p id="b373" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">所以我们需要修改很多代码，为什么会有问题？</strong></p><p id="777d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简答:<a class="ae jo" href="https://www.sargalias.com/blog/why-code-changes-are-error-prone/" rel="noopener ugc nofollow" target="_blank">代码修改容易出错</a>。</p><p id="1f36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总结一下代码更改的一些问题:</p><ol class=""><li id="b7c9" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">我们不会记得需要修改什么代码。我们将不得不搜索代码库，寻找将会受到影响的内容。</li><li id="b218" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">很有可能我们会遗漏一些东西，破坏系统。</li><li id="be95" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">这是大量重复的工作。我们不擅长重复。我们在做重复性的工作时很容易出错。</li><li id="c749" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">这将比我们不需要改变任何东西(除了我们试图修改的东西)花费更长的时间。</li></ol><p id="f183" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更不用说，如果我们在一个区域有级联变化，很可能我们会在整个代码库中都有它们。一个简单的改变需要修改系统中的每一个文件的经典案例。</p><p id="aa74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们只想尽可能地做最小的改变。</p><p id="dd58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在好的形状示例中，我们不需要更改任何代码来创建新的形状。</p><p id="8543" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们真的需要修改代码，例如为了性能，必要的修改会尽可能地包含在内。</p><h1 id="cfb2" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">其他应用</h1><p id="a506" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">最少知识原则适用于不同的形式，也与其他原则重叠。</p><p id="9c2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<a class="ae jo" href="https://en.wikipedia.org/wiki/Interface_(computing)" rel="noopener ugc nofollow" target="_blank">接口</a>是类中最少知识原则的一个应用。将一个接口应用于许多实现被称为<a class="ae jo" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank">多态</a>。</p><p id="8d96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank">界面分离原则</a>是一个更严格的应用，鼓励更少的知识。</p><p id="c50d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们不应该能够访问事物的“私有”属性。它的正式名称是<a class="ae jo" href="https://en.wikipedia.org/wiki/Information_hiding" rel="noopener ugc nofollow" target="_blank">信息隐藏</a>，这也是我们创建<a class="ae jo" href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" rel="noopener ugc nofollow" target="_blank">封装</a>的方式。</p><p id="c6bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">德米特定律<a class="ae jo" href="https://en.wikipedia.org/wiki/Law_of_Demeter" rel="noopener ugc nofollow" target="_blank">在方法和函数的范围内应用最少知识原则。</a></p><p id="7f35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开闭原则</a>正式强调最小化代码变更的重要性。它本质上由编程第一原则组成，其中最少知识原则起着重要作用。</p><p id="525b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不访问全局变量，这是最少知识原则的应用。理想情况下，我们不希望我们的函数知道任何事情，除了直接在它们作用域内的事情。如果有必要，我们可以达到实例范围或模块范围。这属于<a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-side-effects/" rel="noopener ugc nofollow" target="_blank">副作用</a>的概念，也是<a class="ae jo" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>中的一个重要话题。</p><p id="1bbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面给出的例子也可以被认为是应用了关注点分离或抽象原则。</p><p id="ef7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">非面向对象代码中的用法</strong></p><p id="4e3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不是所有的东西都使用接口，比如函数或者模块。然而，所有的东西都应该被视为有正式的接口。</p><p id="8e1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说，代码中最少知识的原则是通用的，不管语言是否为类提供接口，为函数提供参数类型(例如，TypeScript)或其他任何东西。</p><p id="961e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用建议</strong></p><p id="658b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对我个人来说，最少知识原则是最基本的原则之一。它可以用来推导其他的，如界面，界面分离原理，德米特定律，信息隐藏等。</p><p id="cdbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样我就知道了<strong class="is hj">为什么</strong>，原则背后的动机。这意味着我可以就如何更自然地构建我的代码做出明智的决定，甚至不用直接考虑诸如接口、德米特法则等原则。</p><p id="4975" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果有什么不同的话，这些原则更多的是作为如何进行的想法，或者确认我正在沿着正确的路线思考。此外，它让我更好地理解这些原则，因为通过最少知识原则，我可以看到它们背后的动机，它们试图解决什么，以及它们的目的是什么。</p><p id="f069" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那不一定是你必须要做的，那只是对我有用的。</p><h1 id="e190" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">理论</h1><p id="efc6" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">现在是本系列中承诺的理论治疗。这个会短很多，因为很笼统。</p><p id="60ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">概括地说，我们对软件的要求是:</p><ul class=""><li id="6e76" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kd jv jw jx bi translated">它应该按预期工作。</li><li id="db6b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">应该很容易改变。</li></ul><p id="46d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的前提是:</p><ul class=""><li id="ee10" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kd jv jw jx bi translated">我们只能意识到最少的信息</li><li id="d145" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">我们必须明白我们在做什么</li><li id="8a6e" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">我们必须尽量减少变化的传播</li><li id="f6db" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">复杂性随着规模呈指数增长</li></ul><p id="9414" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">最小惊讶原则的动机</strong></p><p id="c5e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">案例:代码X知道Y和z。</p><p id="f486" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">动作:我们需要修改y。</p><p id="0465" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问题:</p><ol class=""><li id="b1f4" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">我们需要意识到并记住X会受到影响。</li><li id="c5c8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">我们可能需要知道<strong class="is hj">X将会受到怎样的影响，所以我们不会做那些我们永远无法用在X上的改变，至少不会对X做太大的修改，超出了我们想要做的范围。</strong></li><li id="13c0" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">我们需要改变X来适应y的变化。</li><li id="f892" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">x可能在其他代码中有自己的级联更改，这将重复该过程。</li></ol><p id="624d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结论:</p><p id="d199" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这与我们所有的前提相冲突。</p><p id="5948" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要了解更多的事情，理解更多的代码，这样我们才能做出改变。将会有传播的变化，潜在的非常复杂的变化和大量的大规模变化。</p><p id="5bd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，如果我们对Y所做的任何改变都不会影响X或其他任何东西，那么我们将满足我们的前提。</p><p id="cb7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">指导方针</strong></p><ul class=""><li id="9275" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kd jv jw jx bi translated">记住这个原则。记住这一点，你可能会一直朝着它前进。这肯定比你一开始就不知道这个原则要好。</li><li id="8ee3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">重要的是使用代码创建系统，使它和其他代码之间的交流和知识最少。</li><li id="dc48" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">理想情况下，代码要么什么都不知道，要么只知道存在于其局部范围内的东西和它已显式接收的东西(参数)。</li><li id="96ff" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">正如接口分离原则和Demeter定律所建议的那样，代码应该只知道尽可能少的参数。</li><li id="a970" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">所有的交流和知识都应遵循约定的不变和不冲突的契约(也称为接口)。接口只是一种方式来说明某些东西在对象上总是可用的。它们可以安全使用，并且不会改变。</li></ul><p id="7cfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">好处</strong></p><ul class=""><li id="ed7d" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kd jv jw jx bi translated">程序员所需的关于代码所知道和依赖的最少知识。</li><li id="84d3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">代码之间需要最少的知识。</li><li id="5fc8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated">更改代码时传播更改的可能性最小(可能没有)。</li></ul></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><p id="67d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文是“编程首要原则系列”的一部分:</p><ol class=""><li id="7a83" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-purpose-what-this-series-is-about/" rel="noopener ugc nofollow" target="_blank">目的——这个系列是关于什么的</a></li><li id="8218" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-audience-who-this-series-is-for/" rel="noopener ugc nofollow" target="_blank">观众——这个系列是给谁的</a></li><li id="b52b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-requirements-of-software/" rel="noopener ugc nofollow" target="_blank">软件需求</a></li><li id="61bb" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-premise-minimal-information/" rel="noopener ugc nofollow" target="_blank">前提—最少信息</a></li><li id="c5f7" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-premise-we-must-understand-what-were-doing/" rel="noopener ugc nofollow" target="_blank">前提——我们必须明白我们在做什么</a></li><li id="6d0c" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-premise-minimize-propagating-changes/" rel="noopener ugc nofollow" target="_blank">前提——最小化在整个系统中传播的变更</a></li><li id="4a82" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-premise-complexity-increases-exponentially-with-scale/" rel="noopener ugc nofollow" target="_blank">前提—复杂性随规模呈指数增长</a></li><li id="2428" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-proof-that-code-works/" rel="noopener ugc nofollow" target="_blank">第一原则——证明代码有效</a></li><li id="78d1" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-principle-of-least-astonishment/" rel="noopener ugc nofollow" target="_blank">第一原理——最小惊讶原理</a></li><li id="27fb" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-principle-of-least-knowledge/" rel="noopener ugc nofollow" target="_blank">第一原理——最小知识原理</a>(本文)</li><li id="508f" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-separation-of-concerns/" rel="noopener ugc nofollow" target="_blank">第一原则——关注点分离</a></li><li id="4ff1" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-abstraction/" rel="noopener ugc nofollow" target="_blank">第一原理——抽象</a></li><li id="f833" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-side-effects/" rel="noopener ugc nofollow" target="_blank">副作用</a></li></ol><p id="4210" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还建议:</p><ul class=""><li id="c76c" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kd jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/when-not-to-apply-programming-principles/" rel="noopener ugc nofollow" target="_blank">何时不应用编程原则</a></li><li id="bda1" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn kd jv jw jx bi translated"><a class="ae jo" href="https://www.sargalias.com/blog/why-code-changes-are-error-prone/" rel="noopener ugc nofollow" target="_blank">为什么代码更改容易出错</a></li></ul></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><p id="b665" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ls">最初发表于</em><a class="ae jo" href="https://www.sargalias.com/blog/programming-first-principles-first-principle-principle-of-least-knowledge/" rel="noopener ugc nofollow" target="_blank"><em class="ls">https://www.sargalias.com</em></a><em class="ls">。</em></p></div></div>    
</body>
</html>