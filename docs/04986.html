<html>
<head>
<title>Dependency Injection: Concept of Spring Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入:Spring框架的概念</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dependency-injection-concept-of-spring-framework-d9c3688005f8?source=collection_archive---------7-----------------------#2020-04-07">https://medium.com/analytics-vidhya/dependency-injection-concept-of-spring-framework-d9c3688005f8?source=collection_archive---------7-----------------------#2020-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ca6193c311d986ea0732514ee020931b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOgTXbh1sNCdfoDD43r9EQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">依赖注入概述</strong></figcaption></figure><p id="a3fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当Rod Johnson写的一本名为<em class="jt">没有EJB的J2EE开发的书在2002年</em>发布时，Spring框架开始引人注目。带着spring框架想法的作者认为它可能比Java EE更好。当时，Java企业版被认为是非常重要的，而且从开发者的角度来看，与EJB合作是一项艰巨的任务。作者随后提出了spring框架，spring框架的一个重要概念是<em class="jt">依赖注入。</em></p><h1 id="b596" class="ju jv hi bd iu jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">依赖注入概述</strong></h1><p id="ed90" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Spring framework充当依赖注入，这是反转控制的一种形式(控制反转是一种编程原则，与传统的控制流相比，它反转了控制流)。IoC是好莱坞的一种原则，<em class="jt">别叫我们，我们就叫你</em>，应用在编程上。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/8ff07b5bb6b57f6a8043dc68ee451a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/1*NM7Rwawr-xdNzQjWONcXNQ.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">控制原理反转</strong></figcaption></figure><p id="1825" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为依赖注入的spring框架在您提供的指令的帮助下将您的应用程序的类绑定在一起，这些指令可以作为代码中的<em class="jt">注释</em>或者通过<em class="jt">显式绑定配置代码</em>或者通过使用<em class="jt"> XML </em>配置来提供。</p><h1 id="96ea" class="ju jv hi bd iu jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">举例说明</strong></h1><p id="0fb4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果您从一个应用程序开始，它可能还需要其他类，比如helper和utility类。因此，在basic Java中，应用程序类将实例化助手和实用程序类，然后开始使用它们，这将增加类之间的耦合。现在类之间有了一个紧密耦合的T21，因为应用程序类现在依赖于助手类和实用程序类的正确实现，而且类之间没有抽象的概念。这使得单独测试应用程序类变得困难，因为它总是会实例化其他两个类。</p><p id="d856" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是spring依赖注入容器出现的时候。在spring依赖注入的帮助下，您将拥有相同的类来运行您的应用程序，但是您将不得不指示<em class="jt"> spring DI容器</em>为您做同样的事情，而不是实例化和绑定这些类。这可以使用代码中的注释、配置代码或XML配置代码来完成。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/f0d89da519a0ceea2da4d094ee41ca10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-AhzYm6TNZDOFaZqF5I4A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd iu">弹簧DI容器的一个例子</strong></figcaption></figure><p id="91af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在spring框架中，我们必须告诉spring应用程序代码中使用的类以及这些类之间的相互依赖关系。spring DI控制器将实例化助手、实用程序和应用程序类，这些实例将被称为<em class="jt">spring bean。</em></p><p id="a761" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在DI容器已经配置好了，它知道了应用程序的类之间的依赖关系。但是，在没有从应用程序类实例化助手和实用程序类的情况下，spring DI容器会将助手和实用程序类注入到应用程序类中，这样助手和实用程序类将从应用程序类中<em class="jt">解耦</em>。此外，应用程序的配置现在更加<em class="jt">灵活</em>，因为它现在由配置类指示。</p><h1 id="70d2" class="ju jv hi bd iu jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">总结</strong></h1><p id="9202" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">因此，spring依赖注入在某种程度上帮助了你，你必须声明组件和它们之间的依赖，DI容器在运行时将它们绑定在一起。</p></div></div>    
</body>
</html>