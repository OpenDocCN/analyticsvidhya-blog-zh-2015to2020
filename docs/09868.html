<html>
<head>
<title>Palindrome LinkedList — Day 2(Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回文链接列表—第二天(Python)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/palindrome-linkedlist-day-2-python-441a963697dc?source=collection_archive---------11-----------------------#2020-09-23">https://medium.com/analytics-vidhya/palindrome-linkedlist-day-2-python-441a963697dc?source=collection_archive---------11-----------------------#2020-09-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a7c5513666bb345c43e9eb4a8ca55e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9pzaHkU_nQHPdzgH"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">祖尔莫里·萨维德拉在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5253" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天是我参加365天编码挑战的第二天。我将根据链接列表解决一个问题。在我深入这个问题之前，让我先谈谈LinkedList的几个特性。</p><ol class=""><li id="f79f" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">LinkedList包含一系列节点，这些节点使用指向下列节点的指针相互连接。</li></ol><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/767040c03a3d8a1d8072b614a14b2056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4PuJk9B2PKURsHgwEd3ew.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">单向链表</figcaption></figure><p id="250e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.一个基本节点将包含两个部分，</p><p id="3817" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">a.数据</p><p id="b83b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">b.下一个指针的地址</p><p id="f639" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.LinkedList有一个指向LinkedList开头的head指针。</p><p id="8d13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.LinkedList不一定有连续的内存分配。</p><p id="0267" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的代码显示了LinkedList上一个节点的结构。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="1507" class="km kn hi ki b fi ko kp l kq kr"><strong class="ki hj">class Node:<br/>def __init__(self, data):<br/>self.data = data<br/>self.next = None</strong></span></pre></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="565a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，现在我们已经看到了LinkedList，让我们继续今天的问题。</p><p id="aa46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/palindrome-linked-list/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> 234 </strong> </a> <strong class="ix hj">。回文链表</strong></p><p id="0cca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定一个单链表，判断它是否是回文。</p><p id="2152" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例1: </strong></p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="b123" class="km kn hi ki b fi ko kp l kq kr"><strong class="ki hj">Input:</strong> 1-&gt;2<br/><strong class="ki hj">Output:</strong> false</span></pre><p id="675e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例2: </strong></p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="0e85" class="km kn hi ki b fi ko kp l kq kr"><strong class="ki hj">Input:</strong> 1-&gt;2-&gt;2-&gt;1<br/><strong class="ki hj">Output:</strong> true</span></pre><p id="eafc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看到这个问题后我的第一个想法是用一个栈，把每个节点的数据插入到栈中，然后通过从栈中弹出元素和链表中的每个元素来比较元素。</p><p id="d642" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码将如下所示</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="46a8" class="km kn hi ki b fi ko kp l kq kr">class Solution:<br/>    def insert_stack(self, head):<br/>        stack_rev = []<br/>        while(head):<br/>            stack_rev.append(head.val)<br/>            head = head.next<br/>        return stack_rev<br/> <br/>    def isPalindrome(self, head: ListNode) -&gt; bool:<br/>        if head == None:<br/>            return True<br/>        stack_rev = self.insert_stack(head)<br/>        while(head):<br/>            if(head.val == stack_rev.pop()):<br/>                head = head.next<br/>            else:<br/>                return False<br/>        return True</span></pre><p id="e55e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复杂性分析</p><p id="d27b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="0f9a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要遍历LinkedList中的每个元素，这需要O(N)时间</p><p id="0d80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度</strong></p><p id="89c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用一个堆栈来存储元素，这将占用O(N)的空间。</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="55db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们能试着减少空间使用吗？</p><p id="187e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也许如果我们把LinkedList分成两半，颠倒前半部分，然后比较两半部分的节点。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="303e" class="km kn hi ki b fi ko kp l kq kr">class Solution:<br/>    <!-- -->def isPalindrome(self, head):<br/>    rev = None<br/>    # Slow pointer<br/>    slow = head<br/>    # Fast pointer<br/>    fast = head</span><span id="6373" class="km kn hi ki b fi kz kp l kq kr"># Until the first half keep reversing the nodes<br/>    while fast and fast.next:<br/>        #Keep moving in double speed<br/>        fast = fast.next.next<br/>        #Keep reversing the node<br/>        <!-- -->slow_next = slow.next<br/>        slow.next = rev<br/>        rev = slow<br/>        slow = slow_next<br/>    #In case lenght of linkedlist is odd<br/>    <!-- -->if fast:<br/>        slow = slow.next<br/>    # Compare the elements<br/>    while rev and rev.val == slow.val:<br/>        slow = slow.next<br/>        rev = rev.next<br/>    return not rev</span></pre><p id="3b4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复杂性分析</p><p id="b76a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="2e25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要遍历LinkedList中的每个元素，这需要O(N)时间</p><p id="f537" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度</strong></p><p id="8929" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们没有使用任何额外的空间来执行上述转换，因此使用的空间是O(1)。</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="fe6c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想提高我的写作技巧，所以任何建议或批评都非常欢迎。</p></div></div>    
</body>
</html>