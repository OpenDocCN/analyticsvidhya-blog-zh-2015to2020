<html>
<head>
<title>Asynchronous tasks in Python with Celery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的异步任务与芹菜</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/asynchronous-tasks-in-python-with-celery-e6a9d7e3b33d?source=collection_archive---------1-----------------------#2020-03-10">https://medium.com/analytics-vidhya/asynchronous-tasks-in-python-with-celery-e6a9d7e3b33d?source=collection_archive---------1-----------------------#2020-03-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fab4b9a5d58fbf1db655e68d5e937449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwkIHlDQnjww1-rcBuYAGw.jpeg"/></div></div></figure><p id="08c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Celery是一个基于分布式消息传递的异步任务队列/作业队列。理解什么是同步/异步编程这是理解芹菜的基础。下面一节解释一下，如果你已经知道了，可以跳到<strong class="is hj">什么时候用？</strong>路段或者直接去<strong class="is hj">芹菜</strong>路段。</p><h1 id="8c43" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">同步&amp;异步代码。</strong></h1><p id="d2c2" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在<a class="ae kr" href="https://stackoverflow.com/questions/748175/asynchronous-vs-synchronous-execution-what-does-it-really-mean" rel="noopener ugc nofollow" target="_blank">这个问题中</a>在stackoverflow中，用户<a class="ae kr" href="https://stackoverflow.com/users/1428344/themightysapien" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">the mighty sapien</strong></a>做了一个很棒的类比来解释同步和异步代码:</p><blockquote class="ks kt ku"><p id="d62a" class="iq ir kv is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated"><strong class="is hj">同步执行</strong></p><p id="554c" class="iq ir kv is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated">我的老板是个大忙人。他告诉我写代码。我告诉他:好吧。我刚开始，他就像秃鹰一样盯着我，站在我身后，从我的肩膀上。我就像“老兄，WTF:你为什么不去做点什么，而我完成这个？”</p><p id="e608" class="iq ir kv is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated">他说:“不，我就在这里等着，直到你结束。”这是同步的。</p><p id="a3c5" class="iq ir kv is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated"><strong class="is hj">异步执行</strong></p><p id="5eed" class="iq ir kv is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated">老板告诉我去做，而不是在那里等待我的工作，老板去做其他的任务。当我完成我的工作时，我只是向我的老板报告说:“我完成了！”这是异步执行。</p></blockquote><p id="133e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">异步代码是一段独立运行的代码，与程序的执行流分离。当我们不想阻塞程序的主执行流时，我们使用这个。</p><blockquote class="kz"><p id="e2ef" class="la lb hi bd lc ld le lf lg lh li jn dx translated">你可能会想:—好吧，我想到了！但是我为什么想要或者需要这么做呢？？？</p></blockquote><p id="338d" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">一个很好的理由是这段代码可能需要很长时间才能完成，而你不想等待。</p><h1 id="0f6b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么时候用？</h1><h2 id="6ae2" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated">例01:注册</h2><p id="2f80" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">让我们假设我们有一个网站，我们正在开发一个注册功能。在注册过程中，我们必须:</p><p id="871f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">验证用户的凭据；</p><p id="0f2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将用户信息存储在数据库中；</p><p id="f0c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">发送确认电子邮件；</p><p id="b9e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">负责发送电子邮件的SMTP服务器有时需要3、4甚至6、7秒才能完成。用户无需确认即可开始使用平台。我们不想让他们等这么久，看一个无聊的加载屏幕。在此期间，用户可以放弃注册。在这种情况下，除了电子邮件部分，我们需要同步做所有事情。我们只是把邮件放在盒子里，等会儿再送。查看下面的片段。</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="1b8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只有函数<strong class="is hj">start _ to _ send _ confirmation _ email</strong>应该是异步的。在执行时，解释器会在邮件发送前从第3行跳到第4行。函数<strong class="is hj">start _ to _ send _ confirmation _ email</strong>中的这段代码将与该流程分开执行。在电子邮件发送之前，用户将被返回<strong class="is hj">。</strong></p><h2 id="73da" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated">例02:财务报告</h2><p id="3760" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">财务分析师点击一个按钮来查看每月结果。这将需要一段时间，分析师不希望等待漫长而无聊的加载屏幕来查看结果，他希望继续使用该平台，并在结果准备就绪后检查结果。</p><p id="4e0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一名开发人员，您不希望请求被搁置几分钟，甚至几小时。实际上，这个请求很有可能达到您的web服务器或DNS提供商的超时限制(该死的cloudflare)。</p><blockquote class="kz"><p id="b9e5" class="la lb hi bd lc ld le lf lg lh li jn dx translated">—好了，现在我知道什么是异步代码，什么时候应该使用它。但是，用python怎么做呢？</p></blockquote><p id="f073" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">要做到这一点，我们可以使用python线程模块，手动完成，或者使用类似芹菜的任务作业。</p><h1 id="7f1d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">芹菜</strong></h1><p id="9f5b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">原理非常简单:一个(或多个)程序将任务添加到要执行的队列中。这个队列也被称为<strong class="is hj">消息代理。Celery不仅仅是一个库，它运行在不同于应用程序的服务中，比如数据库、SMTP服务器等。该服务监视队列，每次添加新任务时，celery都会执行它。</strong></p><figure class="mc md me mf fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/2b17b6024428bbfa987c8d2e0ffe4204.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*tK2hp_NpilSA9tInVxmmVg.png"/></div></figure><p id="9854" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">芹菜任务在很多情况下是一个复杂的代码，需要一个强大的机器来执行它。就像我之前说的，celery运行在一个从应用程序中分离出来的服务中，这意味着您可以在一个单独的机器上运行它，并且可以有任意多的队列。这对于扩展应用程序非常有帮助。</p><h2 id="06c0" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated"><strong class="ak">我们的第一款芹菜应用</strong></h2><p id="4505" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们将创建我们的第一个芹菜应用程序。这必须是简单的，重点是理解芹菜的概念。</p><h2 id="9e5c" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated">先决条件:</h2><ul class=""><li id="6a23" class="mj mk hi is b it km ix kn jb ml jf mm jj mn jn mo mp mq mr bi translated"><a class="ae kr" href="https://redis.io/topics/quickstart" rel="noopener ugc nofollow" target="_blank"> Redis </a></li><li id="5df4" class="mj mk hi is b it ms ix mt jb mu jf mv jj mw jn mo mp mq mr bi translated"><a class="ae kr" href="http://www.celeryproject.org/install/" rel="noopener ugc nofollow" target="_blank">芹菜</a></li></ul><p id="670a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kv">我们将使用Redis作为</em> <strong class="is hj"> <em class="kv">消息代理。</em> </strong> <em class="kv">基本上，消息代理组织队列，这是一个抽象概念。芹菜没有组织队列的意图，它只是执行任务。</em></p><p id="2df2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个空目录，命名为你想要的，并在里面做以下步骤。</p><ul class=""><li id="9640" class="mj mk hi is b it iu ix iy jb mx jf my jj mz jn mo mp mq mr bi translated">创建一个名为<strong class="is hj"> first_app.py </strong>的业务逻辑<strong class="is hj">文件</strong>；</li><li id="7f63" class="mj mk hi is b it ms ix mt jb mu jf mv jj mw jn mo mp mq mr bi translated">创建一个<strong class="is hj">文件夹</strong>名为<strong class="is hj">celery _ stuff</strong>；</li><li id="1911" class="mj mk hi is b it ms ix mt jb mu jf mv jj mw jn mo mp mq mr bi translated">在<strong class="is hj"> celery_stuff </strong>文件夹中，创建一个<strong class="is hj"> __init__。py </strong>文件；</li><li id="2245" class="mj mk hi is b it ms ix mt jb mu jf mv jj mw jn mo mp mq mr bi translated">在<strong class="is hj"> celery_stuff </strong>文件夹中，创建一个<strong class="is hj"> tasks.py </strong>文件；</li></ul><p id="3f11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您的项目树应该如下所示:</p><p id="4be1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">├──芹菜_stuff <br/> │ ├── __init__。py<br/>│└──tasks . py<br/>└──first _ app . py</p><p id="3af6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在<strong class="is hj"> first_app.py </strong>中创建一个异步执行芹菜任务的函数。注意<strong class="is hj"> start_serve_a_beer </strong>这是我们创建的一个普通的同步函数。<strong class="is hj"> serve_a_beer.delay() </strong>将任务放入队列(<em class="kv">消息代理</em>)中，由celery服务执行。serve_a_beer任务尚不存在，将在接下来的步骤中创建。</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="4ea7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在<strong class="is hj"> celery_stuff/tasks.py </strong>中，创建一个<strong class="is hj"> celery app实例，</strong>任务<strong class="is hj"> serve_a_beer </strong>和<strong class="is hj">将其注册</strong>到<strong class="is hj"> celery app中。</strong></p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h2 id="9c00" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated">运转</h2><p id="b7a9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在运行我们的应用程序之前，我们需要运行celery服务，因为当我们运行<strong class="is hj"> first_app.py </strong>时，代码会将一个任务添加到<strong class="is hj">队列(第11行)</strong>中，如果celery服务没有运行，该任务将不会被执行。</p><p id="c5fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">跑芹菜</strong></p><p id="9925" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kv">$ celery-A celery _ stuff . tasks worker-l调试</em></p><p id="0631" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">运行第一个App </strong></p><p id="cd80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kv"> $ python first_app.py </em></p><p id="6985" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果一切都好，您应该在芹菜日志中看到这一点:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h2 id="6094" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated">处理多项任务</h2><p id="a2aa" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">让我们回到<strong class="is hj"> celery_stuff/tasks.py </strong>并添加一个名为<strong class="is hj"> serve_a_coffee的新任务。</strong></p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="820f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj"> first_app.py </strong>文件中，让我们导入一个名为serve_a_coffee的新任务并启动它们。文件现在应该是这样的。</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="na nb et er es nc nd bd b be z dx translated">提示:不要忘记导入新任务(第1行)</figcaption></figure><p id="5481" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再次运行<strong class="is hj">芹菜</strong>和<strong class="is hj"> first_app </strong>。</p><p id="f647" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kv">$ celery-A celery _ stuff . tasks worker-l调试</em></p><p id="6842" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kv"> $ python first_app.py </em></p><p id="3ffe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两个任务都应该执行。</p><h2 id="8d89" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated">使用多个队列</h2><p id="d775" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">想象一下生产中这段代码，每分钟执行数千个任务。当然这两个任务非常相似，但是假设任务<strong class="is hj">比<strong class="is hj"> serve_a_coffee </strong>更慢更复杂。制作咖啡的过程非常简单，你只需要水、咖啡和一个过滤器。但是，要做一瓶啤酒，你需要很多原料，并且至少要等一个月！当您有不同的特性时，将它拆分到不同的队列中是一个明智的选择。这样，您可以选择不同的机器来运行不同的任务。</strong></p><figure class="mc md me mf fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/b14a47b995d54fede3bb99b284dd9b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*31zQNFFi1LcCAE7HTvOa4Q.png"/></div><figcaption class="na nb et er es nc nd bd b be z dx translated">在生产中，您可以在不同的机器上为每个队列运行服务。您还可以让多个应用程序实例向这些队列添加任务。</figcaption></figure><p id="b691" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">定义队列</strong></p><p id="d302" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们没有定义队列。因此，任务将被发送到默认的芹菜队列。啤酒和咖啡一起排队。这很糟糕，因为每次生产大量啤酒时，咖啡都要等很长时间。</p><p id="e528" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们更改代码，将我们的任务分成特定的队列。在<strong class="is hj"> celery_stuff/tasks.py </strong>文件中，配置app中的路线。在task_routes配置中，我们可以为每个任务指定队列。</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h2 id="522f" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated"><strong class="ak">跑芹菜排不同的队！</strong></h2><p id="73d7" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在上一节中，我们运行了两个服务:</p><ul class=""><li id="1294" class="mj mk hi is b it iu ix iy jb mx jf my jj mz jn mo mp mq mr bi translated"><em class="kv"> App服务</em></li><li id="f91e" class="mj mk hi is b it ms ix mt jb mu jf mv jj mw jn mo mp mq mr bi translated"><em class="kv">芹菜服务</em></li></ul><p id="331a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将运行3项服务:</p><ul class=""><li id="78d9" class="mj mk hi is b it iu ix iy jb mx jf my jj mz jn mo mp mq mr bi translated"><em class="kv">应用服务</em></li><li id="4231" class="mj mk hi is b it ms ix mt jb mu jf mv jj mw jn mo mp mq mr bi translated"><em class="kv">芹菜服务提供啤酒</em></li><li id="f24c" class="mj mk hi is b it ms ix mt jb mu jf mv jj mw jn mo mp mq mr bi translated"><em class="kv">另一种供应咖啡的芹菜服务</em></li></ul><p id="057e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行下面的命令来设置它们；</p><p id="abad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kv"> $ python first_app.py </em></p><p id="2b31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kv"> $芹菜-一根芹菜_ stuff . tasks worker-l debug-Q beer</em></p><p id="a659" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kv"> $芹菜-一根芹菜_ stuff . tasks worker-l debug-Q coffee</em></p><p id="0d8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用-Q参数来指定队列。如果我们有10个不同的队列，我们可以为每个队列运行一个芹菜服务！</p><p id="d243" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，如果您愿意，可以对许多队列使用相同的芹菜服务。这在开发模式中很常见。</p><p id="b9d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">$芹菜-芹菜_stuff.tasks worker -l debug -Q啤酒、咖啡</p><p id="4b50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你是否觉得一步一步安装所有东西很懒？只需在github 上克隆这个库，然后用docker运行它。</p><p id="33e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，将<strong class="is hj">celery _ stuff/first _ app . py</strong>上的第4行改为:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="fa33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，运行容器。</p><p id="d04d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kv">$ docker-撰写运行-构建</em></p><p id="98e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你应该在日志里看到啤酒和咖啡！</p><h1 id="cf3d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="81ff" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Celery是在python中执行异步任务的一个很好的选择。它是分布式的，易于使用和扩展。在本文中，我们学习了什么是芹菜应用程序，如何创建任务，如何将任务路由到不同的队列，以及如何将芹菜服务运行到特定的队列。芹菜在第一步可能会有点令人沮丧，特别是对于文档中的一些空白，但它非常容易使用，并抽象了许多复杂性。我希望我已经填补了这些空白，特别是第一步！</p></div></div>    
</body>
</html>