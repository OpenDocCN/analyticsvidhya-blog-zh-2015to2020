<html>
<head>
<title>Introduction to Monte Carlo Tree Search: The Game-Changing Algorithm behind DeepMind’s AlphaGo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蒙特卡洛树搜索简介:deep mind alpha go背后的游戏规则改变算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/introduction-to-monte-carlo-tree-search-the-game-changing-algorithm-behind-deepminds-alphago-554a9017f0c2?source=collection_archive---------1-----------------------#2019-01-23">https://medium.com/analytics-vidhya/introduction-to-monte-carlo-tree-search-the-game-changing-algorithm-behind-deepminds-alphago-554a9017f0c2?source=collection_archive---------1-----------------------#2019-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7eff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">五局三胜的游戏系列，100万美元的奖金——高赌注的枪战。2016年3月9日至15日期间，排名第二的围棋选手李西多(Lee Sidol)承担了一个名为AlphaGo的计算机程序。</p><p id="a78a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AlphaGo明显击败了Sidol先生，以4比1赢得了系列赛。该程序由谷歌的DeepMind设计，已经催生了许多其他人工智能的发展，包括AlphaGo Zero。这些突破被广泛认为是迈向人工智能的垫脚石(AGI)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/55745cdba35fdec8f4c36f62b4876605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*4P_YVoNqmOa2ypuX.jpg"/></div></figure><p id="4c55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将向您介绍AlphaGo的核心算法——蒙特卡罗树搜索(MCTS)。这种算法有一个主要目的——给定游戏的状态，选择最有希望的移动。</p><p id="c4b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了给你一些AlphaGo背后的背景，我们首先简单看看玩游戏的人工智能程序的历史。然后，我们将看到AlphaGo的组件、博弈树的概念、一些树搜索算法，最后深入了解MCTS算法是如何工作的。</p><h1 id="f80d" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">目录</h1><ol class=""><li id="2dea" class="kj kk hi ih b ii kl im km iq kn iu ko iy kp jc kq kr ks kt bi translated">游戏人工智能——综述</li><li id="0d68" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">AlphaGo程序的组成部分</li><li id="7d0f" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">博弈树的概念</li><li id="a7a0" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">树搜索算法<br/> 1。不知情的搜索<br/> 2。最佳第一搜索<br/> 3。极大极小</li><li id="90f3" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">蒙特卡洛树搜索<br/> 1。树的遍历和节点扩展<br/> a. UCB1(置信上限)<br/> b. Rollout <br/> 2 .通过示例完成演练</li></ol><h1 id="58b4" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">游戏人工智能——综述</h1><p id="15d8" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">人工智能是一个广阔而复杂的领域。但在人工智能正式成为公认的工作之前，计算机科学的早期先驱编写了游戏程序，以测试计算机是否可以解决人类智能水平的任务。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/1a03b595282165410cfb5513f759fce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r1MZN7asaVhOG7Sg.png"/></div></div></figure><p id="0e11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让你了解玩游戏的人工智能是从哪里开始的，以及它迄今为止的历程，我整理了以下关键的历史发展:</p><ol class=""><li id="817d" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc kq kr ks kt bi translated">A.1952年，S. Douglas编写了第一个控制游戏的软件。游戏？井字游戏。这是他在剑桥的博士论文的一部分</li><li id="85af" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><strong class="ih hj"> <em class="lk">几年后，亚瑟·塞缪尔第一次使用强化学习，即通过与自身对抗来玩跳棋</em> </strong></li><li id="5e80" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">1992年，Gerald Tesauro设计了一个现在很受欢迎的<strong class="ih hj">程序，叫做TD-Gammon，用来玩世界级水平的双陆棋</strong></li><li id="85a3" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">几十年来，国际象棋被视为“人工智能的终极挑战”。IBM的深蓝是第一个展示出超人象棋能力的软件。这个系统在1997年击败了当时的国际象棋大师加里·卡斯帕罗夫，这是一个著名的例子</li><li id="d6b2" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><strong class="ih hj">最受欢迎的棋盘游戏人工智能里程碑之一是在2016年的围棋比赛中达到的</strong>。9段职业围棋选手李·塞多尔(Lee Sedol)在与谷歌DeepMind的AlphaGo软件的五局比赛中失利，该软件采用了深度强化学习方法</li><li id="0b3b" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">视频游戏人工智能领域最近值得注意的里程碑包括由谷歌DeepMind开发的<strong class="ih hj">算法，该算法可以在经典的Atari 2600 </strong>视频游戏控制台上以超人的技能水平玩几个游戏</li><li id="bce9" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">去年，OpenAI构建了广受欢迎的<a class="ae ll" href="https://www.analyticsvidhya.com/blog/2018/06/openai-five-a-team-of-5-algorithms-is-beating-human-opponents-in-a-popular-game/" rel="noopener ugc nofollow" target="_blank"> OpenAI Five </a>系统，该系统掌握了DOTA的复杂策略游戏</li></ol><p id="c137" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这还只是表面现象！人工智能程序超出预期的例子还有很多。但这应该会让你对我们今天的处境有一个公平的概念。</p><h1 id="cc65" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">AlphaGo的组件</h1><p id="db46" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">Alpha Go的核心部分包括:</p><ul class=""><li id="9b8c" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated"><strong class="ih hj">蒙特卡洛树搜索:</strong>人工智能使用MCTS选择下一步棋</li><li id="03e6" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lm kr ks kt bi translated">残差<strong class="ih hj">CNN(卷积神经网络):</strong> AI使用这些网络评估新的位置</li><li id="cf19" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lm kr ks kt bi translated"><strong class="ih hj">强化学习:</strong>用当前最好的智能体来训练人工智能，让它和自己对弈</li></ul><p id="e2f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我们将<strong class="ih hj">只关注蒙特卡罗树搜索</strong>的工作。这有助于AlphaGo和AlphaGo Zero在有限的时间内智能地探索并达到有趣/良好的状态，进而帮助AI达到人类水平的性能。</p><p id="58bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的应用不仅仅局限于游戏。理论上，MCTS可以应用于任何可以用{ <em class="lk">状态</em>、<em class="lk">动作</em> }对和用于预测结果的模拟来描述的领域。如果这听起来太复杂，不要担心，我们将在本文中分解所有这些概念。</p><h1 id="46c5" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">博弈树的概念</h1><p id="6eca" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">游戏树是最广为人知的可以代表游戏的数据结构。这个概念实际上非常简单。</p><p id="0603" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">游戏树的每个节点代表游戏中的一个特定状态。在执行移动时，从一个节点转移到其子节点。<strong class="ih hj">命名法非常类似于决策树，其中终端节点被称为叶节点。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es ln"><img src="../Images/29998b942e1021f4325d982a982f2f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dqFzCCEUREe0V5LW.png"/></div></div></figure><p id="179d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如上面的树，每走一步就相当于在不同的位置放一个十字。这分支成各种其他状态，其中在每个位置放置零以产生新的状态。这个过程一直持续到到达叶节点，在那里胜负结果变得清楚。</p><h1 id="f567" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">树搜索算法</h1><p id="dcac" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们设计这些算法的主要目的是找到赢得游戏的最佳路径。换句话说，寻找/搜索一种遍历树的方法，找到最佳节点以获得胜利。</p><blockquote class="lo lp lq"><p id="a7e9" class="if ig lk ih b ii ij ik il im in io ip lr ir is it ls iv iw ix lt iz ja jb jc hb bi translated">大多数人工智能问题都可以归结为搜索问题，可以通过找到最佳计划、路径、模型或功能来解决。</p></blockquote><p id="8309" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">树搜索算法可以被视为构建搜索树:</p><ul class=""><li id="51b8" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated">根是表示搜索开始的州的节点</li><li id="c99a" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lm kr ks kt bi translated">边表示代理从一种状态到另一种状态所采取的动作</li><li id="4e2a" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lm kr ks kt bi translated">节点代表状态</li></ul><p id="66c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">树分支是因为在给定的状态下通常有几个不同的动作可以采取。树搜索算法根据浏览的分支和顺序而有所不同。</p><p id="89a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来讨论几种树搜索算法。</p><h1 id="144c" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">不知情的搜索</h1><p id="c9f2" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">不知情搜索算法，顾名思义，搜索一个状态空间，而不需要任何关于目标的进一步信息。这些被认为是基本的计算机科学算法，而不是人工智能的一部分。属于这种搜索类型的两种基本算法是<strong class="ih hj">深度优先搜索(DFS) </strong>和<strong class="ih hj">宽度优先搜索(BFS) </strong>。你可以在这篇<a class="ae ll" href="https://www.analyticsvidhya.com/blog/2018/04/introduction-to-graph-theory-network-analysis-python-codes/" rel="noopener ugc nofollow" target="_blank">博客文章</a>中读到更多关于他们的内容。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lu"><img src="../Images/80f677b2a25e631637667e4118821b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TJFlb6L57mPYnrpq.jpg"/></div></div></figure><h1 id="bcc3" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">最佳首次搜索</h1><p id="3190" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">最佳优先搜索(BFS)方法通过扩展根据特定规则选择的最有希望的节点来探索图形。这种搜索的定义特征是，不同于DFS或BFS(在对其一无所知的情况下盲目检查/扩展单元)，BFS使用评估函数(有时称为“启发式”)来确定哪个节点是最有希望的，然后检查这个节点。</p><p id="fd4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，A*算法保存了一个“打开”节点的列表，这些节点紧挨着被浏览的节点。请注意，这些开放的节点还没有被研究。对于每个打开的节点，估计其与目标的距离。基于最低成本基础选择新节点进行探索，其中成本是从源节点的距离加上到目标的距离的估计值。</p><h1 id="32c6" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">极大极小</h1><p id="3d56" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">对于单人游戏，可以使用简单的不知情或知情搜索算法来找到达到最佳游戏状态的路径。对于有另一个玩家要占的双人对抗游戏，我们应该怎么做？两个玩家的行动相互依赖。</p><p id="c0c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这些游戏，我们依靠对抗性搜索。这包括两个(或更多)敌对玩家的行动。基本的对抗性搜索算法被称为Minimax。</p><p id="21a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种算法已经非常成功地用于玩经典的完全信息双人棋盘游戏，如跳棋和国际象棋。事实上，它是专门为了构建一个下棋程序而被发明的。</p><p id="762b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">极大极小算法的核心循环在玩家1和玩家2之间交替，很像国际象棋中的白棋和黑棋。这些被称为最小播放器和最大播放器。每个玩家都要探索所有可能的移动。</p><p id="ef19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个结果状态，另一个玩家的所有可能的移动也被探索。这种情况一直持续到所有可能的移动组合都被尝试过，直到游戏结束(赢、输或平)。整个游戏树就是通过这个过程生成的，从根节点一直到树叶:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lv"><img src="../Images/968f5c3175e5bc071df3ab2a2f976403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w7NKh4H25gveUriO.jpg"/></div></div></figure><p id="61d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">探索每一个节点，以找到给我们最大值或分数的移动。</p><h1 id="2927" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">蒙特卡罗树搜索</h1><p id="e6a4" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">像井字游戏、跳棋和国际象棋这样的游戏可以用极大极小算法来解决。然而，当在每个状态下有大量潜在的操作要执行时，事情会变得有点棘手。这是因为minimax探索所有可用的节点。在有限的时间内解决像围棋这样复杂的游戏会变得非常困难。</p><p id="d75b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">围棋的分支因子约为300，也就是说，每种状态有大约300种可能的行动，而国际象棋通常有大约30种行动可供选择。此外，围棋的位置性质是围绕对手，这使得很难正确估计给定棋盘状态的价值。有关围棋规则的更多信息，请参考此<a class="ae ll" href="https://en.wikipedia.org/wiki/Rules_of_Go" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lw"><img src="../Images/a3f79ddb2abf7c40bae4f088b261c89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m2pjqpRnjrlwV4cA.jpg"/></div></div></figure><p id="c196" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有其他几个有复杂规则的游戏，minimax没有能力解决。其中包括信息不完全的战舰扑克和双陆棋、大富翁等非确定性游戏。2007年发明的蒙特卡罗树搜索提供了一种可能的解决方案。</p><p id="ff1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本的MCTS算法很简单:根据模拟播出的结果，一个节点接一个节点地建立搜索树。该过程可分为以下几个步骤:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lx"><img src="../Images/18d225e9d8047ad75822ea6e45f26002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/0*XvzHnKpHj5zPnkA7.png"/></div></figure><ol class=""><li id="17d8" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc kq kr ks kt bi translated"><strong class="ih hj">选择</strong> <br/>选择好的子节点，从根节点R开始，代表导致更好的整体结果(赢)的状态。</li><li id="9c9d" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><strong class="ih hj">展开</strong> <br/>如果<em class="lk"> L </em>不是一个终端节点(即它并没有结束游戏)，那么创建一个或多个子节点并选择一个<em class="lk"> </em>。</li><li id="77ca" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><strong class="ih hj">模拟(rollout) </strong> <br/>从<em class="lk"> C </em>开始运行模拟播放，直到获得结果。</li><li id="da86" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><strong class="ih hj">反向传播</strong> <br/>用模拟结果更新当前移动顺序。</li></ol><h1 id="558e" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">树遍历和节点扩展</h1><p id="b0ae" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在我们深入研究和理解树遍历和节点扩展之前，让我们先熟悉几个术语。</p><p id="e202" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> UCB价值</strong></p><p id="61fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">UCB1或节点的置信上限由以下公式给出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ly"><img src="../Images/382879aa7e6a9ba33aefcbc33b4fe528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/0*DJ4U_6xzM0NnaN8C.png"/></div></figure><p id="ca78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在哪里，</p><ul class=""><li id="8f39" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated">Vi是该节点下所有节点的平均回报/价值</li><li id="0695" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lm kr ks kt bi translated">n是父节点被访问的次数，以及</li><li id="1ddd" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lm kr ks kt bi translated">ni是子节点I被访问的次数</li></ul><h1 id="da2d" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">首次展示</h1><p id="6cb5" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们所说的首次展示是什么意思？直到我们到达叶子节点，我们在每一步随机选择一个动作，并模拟这个动作，以在游戏结束时获得平均奖励。</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="ae91" class="me jm hi ma b fi mf mg l mh mi">Loop Forever:<br/><br/>if Si is a terminal state:<br/><br/>   return Value(Si)<br/><br/>Ai = random(available_actions(Si))<br/><br/>Si = Simulate(Si, Ai)<br/><br/>This loop will run forever until you reach a terminal state.</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es mj"><img src="../Images/33237e46311bcc146bc8a8d41b37b8a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*exXtVxnZyl4JyBBb.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><em class="mo">蒙特卡洛树搜索流程图</em></figcaption></figure><p id="b4ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">树遍历&amp;节点扩展</strong></p><p id="27cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你从S0开始，这是初始状态。如果当前节点不是叶节点，我们计算UCB1的值，并选择最大化UCB值的节点。我们一直这样做，直到到达叶节点。</p><p id="9c50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们询问这个叶节点被采样了多少次。如果以前从未进行过采样，我们只需进行一次展示(而不是展开)。然而，如果它之前已经被采样过，那么我们为每个可用的动作向树中添加一个新的节点(状态)(这里我们称之为扩展)。</p><p id="e2ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您当前的节点就是这个新创建的节点。然后，我们从这一步开始进行展示。</p><h1 id="4135" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">通过示例完成演练</h1><p id="8db8" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">让我们做一个完整的算法演练，以真正扎根于这个概念，并以一种清晰的方式理解它。</p><p id="e218" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">迭代1: </strong></p><ul class=""><li id="5a9b" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated">我们从初始状态S0开始。这里，我们有动作a1和a2，它们导致状态s1和s2，总分为t，访问次数为n。但是我们如何在两个子节点之间进行选择呢？</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mp"><img src="../Images/592020a51444661330d05fdb24af3d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*k4aXvQMb7Jj05zVY.png"/></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><em class="mo">初始状态</em></figcaption></figure><ul class=""><li id="a26e" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated">这是我们计算两个子节点的UCB值并取最大值的节点的地方。因为没有一个节点被访问过，所以第二项对两者都是无限的。因此，我们只取第一个节点</li><li id="b717" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lm kr ks kt bi translated">我们现在在一个叶节点，我们需要检查我们是否已经访问了它。事实证明，我们没有。在这种情况下，在算法的基础上，我们一路向下进行到终端状态。假设该卷展栏的值为20</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mp"><img src="../Images/cb7e23610554d1990daf8e9f7d461d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*cg8f6zKZypKD7vZY.png"/></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><em class="mo">从S1推出</em></figcaption></figure><ul class=""><li id="310b" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated">现在到了第四阶段，或者说反向传播阶段。叶节点(20)的值一直反向传播到根节点。现在，对于节点S1和S0，t = 20，n = 1</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mq"><img src="../Images/974d036d2fc81896b106ed23c3e77935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*4seKg_b6B0Rh-2JE.png"/></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">后反馈</figcaption></figure><ul class=""><li id="da31" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated">这是第一次迭代的结束</li></ul><p id="4ced" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MCTS的工作方式是我们运行它一个确定的迭代次数，或者直到我们超时。这将告诉我们，为了获得最大回报，每一步应该采取的最佳行动是什么。</p><p id="a396" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">迭代2: </strong></p><ul class=""><li id="ed70" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated">我们回到初始状态，询问接下来要访问哪个子节点。我们再次计算UCB值，S1的值为<em class="lk"> 20 + 2 * sqrt(ln(1)/1) = 20 </em>，S2的值为无穷大。由于S2的值更高，我们将选择该节点</li><li id="ee9c" class="kj kk hi ih b ii ku im kv iq kw iu kx iy ky jc lm kr ks kt bi translated">首次展示将在S2完成，以获得值10，该值将被反向传播到根节点。根节点的值现在是30</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/ad8a89e75f3f747b13d2bae65b2936dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KU0SPVoUvG7R1P2q.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><em class="mo">来自S2的反馈</em></figcaption></figure><p id="0cad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">迭代3: </strong></p><ul class=""><li id="00fd" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated">在下图中，S1具有较高的UCB1值，因此应在此处进行扩展:</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/e3b391f687baeb44f169400800aeb3ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EqY8y5hi6zxrOtcV.png"/></div></div></figure><ul class=""><li id="2021" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated">现在在S1，我们处于与初始状态完全相同的位置，两个节点的UCB1值都为无穷大。我们从S3开始进行首次展示，最终在叶节点得到值0</li></ul><p id="fb42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">迭代4: </strong></p><ul class=""><li id="9d94" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated">我们再次不得不在S1和S2之间作出选择。S1的UCB值是11.48，S2是12.10:</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es mr"><img src="../Images/19cb11470212b30d3ef782a6b5ba79c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8IQw66jJpMEOJARd.png"/></div></div></figure><ul class=""><li id="244f" class="kj kk hi ih b ii ij im in iq lh iu li iy lj jc lm kr ks kt bi translated">我们将在S2进行扩展，因为那是我们当前的新节点。扩展时，会创建2个新节点— S5和S6。因为这是两个新的状态，所以在叶节点之前会进行一次展示，以获取值并进行反向传播</li></ul><p id="a612" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是这个算法的要点。我们可以根据需要执行更多的迭代(或者在计算上是可能的)。基本思想是随着迭代次数的增加，每个节点的值的估计变得更加精确。</p><h1 id="95d8" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">结束注释</h1><p id="3a46" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">Deepmind的AlphaGo和AlphaGo Zero程序要复杂得多，还有各种其他方面，超出了本文的范围。然而，蒙特卡罗树搜索算法仍然是它的核心。MCTS在让围棋这样的复杂游戏在有限的时间内变得更容易破解方面发挥了主要作用。MCTS的一些开源实现链接如下:</p><p id="b8ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ll" href="https://github.com/int8/monte-carlo-tree-search" rel="noopener ugc nofollow" target="_blank">用Python实现</a></p><p id="d630" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ll" href="https://github.com/PetterS/monte-carlo-tree-search" rel="noopener ugc nofollow" target="_blank">用C++实现</a></p><p id="87b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我预计强化学习将在2019年取得很大进展。很快就会看到很多更复杂的游戏被机器破解，这并不奇怪。这是学习强化学习的大好时机！</p><p id="a673" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我很乐意在下面的评论区听到你对这篇文章和这个算法的想法和建议。你以前用过这个算法吗？如果没有，你想在哪个游戏上试用？</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><p id="0004" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lk">原载于2019年1月23日</em><a class="ae ll" href="https://www.analyticsvidhya.com/blog/2019/01/monte-carlo-tree-search-introduction-algorithm-deepmind-alphago/" rel="noopener ugc nofollow" target="_blank"><em class="lk">www.analyticsvidhya.com</em></a><em class="lk">。</em></p></div></div>    
</body>
</html>