<html>
<head>
<title>Understanding regularization with PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 PyTorch 了解正则化</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-regularization-with-pytorch-26a838d94058?source=collection_archive---------3-----------------------#2020-08-25">https://medium.com/analytics-vidhya/understanding-regularization-with-pytorch-26a838d94058?source=collection_archive---------3-----------------------#2020-08-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a684" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">处理过度拟合问题</h2></div><p id="3377" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">过度拟合用于描述当训练模型不能很好地概括看不见的数据，但可以很好地模拟训练数据时的情况。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/f00316ba3a05c0b1727d89e86e1e2c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BbWYtAhsSX6dG-odVF9tng.png"/></div></div></figure><p id="010d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了处理过度拟合，可以使用各种技术。让我们探索其中的一些。</p><h1 id="e573" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated"><strong class="ak"> 1。辍学</strong></h1><p id="103f" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">辍学指的是放弃神经网络中的单元。通过丢弃一个单元，意味着将其暂时从网络中移除。选择丢弃哪些单元是随机的。每个单元以独立于其他单元的固定<strong class="iz hj">概率 p </strong>被保留。</p><p id="1fa0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该过程有效地在每次迭代中生成具有不同神经元拓扑的略微不同的模型，从而给予模型中的神经元较少的机会在过度拟合期间发生的记忆过程中进行协调。从而使其更好地泛化和处理过拟合问题。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lc"><img src="../Images/2c388a88da9c84658b3ef8e1cc45cd4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8xAcmXfO-3QaBZiAQykqw.png"/></div></div></figure><h2 id="c378" class="ld kg hi bd kh le lf lg kl lh li lj kp jg lk ll kr jk lm ln kt jo lo lp kv lq bi translated"><strong class="ak">在 PyTorch 实施</strong></h2><p id="ea38" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated"><strong class="iz hj">torch . nn . dropout(<em class="lr">p:float = 0.5</em>，<em class="lr">in place:bool = False</em>)</strong>-在训练期间，它以概率<strong class="iz hj"> p </strong>随机地将输入张量的一些元素置零。在实现下降时，输出形状将保持与输入形状相同。</p><p id="328a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们通过在具有 MNIST 数据集的简单卷积神经网络中使用辍学来理解辍学的影响。我创建了两个网络，一个没有漏失层，另一个有漏失层，并运行了 20 个时期。</p><ul class=""><li id="247d" class="ls lt hi iz b ja jb jd je jg lu jk lv jo lw js lx ly lz ma bi translated"><strong class="iz hj">型号 1-无脱落层</strong></li></ul><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mb"><img src="../Images/7be9089e8682e19649edf13364c6b99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-coh2eSOd8pcBFm7aTKug.png"/></div></div></figure><ul class=""><li id="ea44" class="ls lt hi iz b ja jb jd je jg lu jk lv jo lw js lx ly lz ma bi translated"><strong class="iz hj">型号 2-带脱落层</strong></li></ul><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mc"><img src="../Images/720b8db3161f36685b49caf9618be3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XA40fknMtMlMnAjb31pmGw.png"/></div></div></figure><p id="a156" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">推论:- </strong></p><p id="8949" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">无脱扣</strong>模型达到 99.23%的训练精度和 98.66%的测试精度，而<strong class="iz hj">有脱扣</strong>模型分别达到 98.86%和 98.87%，与无脱扣模型相比减少了过拟合。</p><h1 id="95e4" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">2.L1 和 L2 正规化</h1><p id="70b1" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated"><strong class="iz hj"> L1 正则化(Lasso 回归)</strong> -将模型中所有权重的绝对值之和添加到成本函数中。它将不太重要的特征的系数缩小到零，从而移除一些特征，从而提供稀疏的解决方案。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es md"><img src="../Images/543c26336a40269ac7d624b1256eeb6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GynUZDs7ore4NyFmwiJL1w.png"/></div></div></figure><p id="8746" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> L2 正则化(</strong> <strong class="iz hj">岭回归</strong>)——将模型中所有权重的平方和加到代价函数中。与 L1 正则化不同，它能够学习复杂的数据模式并给出非稀疏解。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es me"><img src="../Images/3a07877645eafee589de335e612e361b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hN8hMjGgCywpFTmMD0LTDw.png"/></div></div></figure><blockquote class="mf mg mh"><p id="6999" class="ix iy lr iz b ja jb ij jc jd je im jf mi jh ji jj mj jl jm jn mk jp jq jr js hb bi translated">这两个正则化都由(小)因子<strong class="iz hj">λ</strong>缩放(以控制正则化项的重要性)，这是一个超参数。</p></blockquote><h2 id="d12b" class="ld kg hi bd kh le lf lg kl lh li lj kp jg lk ll kr jk lm ln kt jo lo lp kv lq bi translated">PyTorch 中的实现</h2><h2 id="9c9e" class="ld kg hi bd kh le lf lg kl lh li lj kp jg lk ll kr jk lm ln kt jo lo lp kv lq bi translated">a) L1 正规化</h2><p id="4ccc" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">L1 _ penalty = torch . nn . L1 loss(size _ average = False)<br/>reg _ loss = 0<br/>for param in model . parameters():<br/>→reg _ loss+= L1 _ penalty(param)</p><p id="9cb8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">factor = const _ val # lambda<br/>loss+= factor * reg _ loss</p><h2 id="a9cc" class="ld kg hi bd kh le lf lg kl lh li lj kp jg lk ll kr jk lm ln kt jo lo lp kv lq bi translated">b) L2 正规化</h2><p id="0fc9" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated"><strong class="iz hj"> weight_decay </strong>参数在初始化优化器时应用 L2 正则化。这将正则化项添加到损失函数中，具有缩小参数估计的效果，使得模型更简单并且不太可能过拟合。</p><h1 id="b955" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">3.其他技术</h1><p id="56cd" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">除了本帖中讨论的辍学、L1 和 L2 正规化之外，处理过度拟合的其他方法有:</p><ul class=""><li id="e8b8" class="ls lt hi iz b ja jb jd je jg lu jk lv jo lw js lx ly lz ma bi translated"><strong class="iz hj">添加更多的训练数据</strong> —添加额外的数据将增加训练数据的多样性，从而减少过度拟合的机会。</li><li id="97a4" class="ls lt hi iz b ja ml jd mm jg mn jk mo jo mp js lx ly lz ma bi translated"><a class="ae mq" rel="noopener" href="/analytics-vidhya/transforming-data-in-pytorch-741fab9e008c"> <strong class="iz hj">数据扩充</strong> </a> -它有助于增加训练模型的数据种类，从而增加可用信息的广度。在我之前的博客<a class="ae mq" rel="noopener" href="/analytics-vidhya/transforming-data-in-pytorch-741fab9e008c">帖子</a>中讨论过。</li><li id="6a8a" class="ls lt hi iz b ja ml jd mm jg mn jk mo jo mp js lx ly lz ma bi translated"><a class="ae mq" rel="noopener" href="/analytics-vidhya/exploring-batch-normalisation-with-pytorch-1ac25229acaf"> <strong class="iz hj">批量规格化</strong></a>-批量规格化倾向于在训练过程中固定隐藏层值的分布。在我之前的博客<a class="ae mq" rel="noopener" href="/analytics-vidhya/exploring-batch-normalisation-with-pytorch-1ac25229acaf">帖子</a>中讨论过。</li><li id="10ff" class="ls lt hi iz b ja ml jd mm jg mn jk mo jo mp js lx ly lz ma bi translated"><strong class="iz hj">提前停止— </strong>意味着在模型达到过拟合阶段之前，提前停止模型的训练。可以监控培训和验证集的性能指标(如准确性、损失)来实现这一点。</li></ul><p id="dc3a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在<a class="ae mq" href="https://github.com/poojamahajan0712/medium_blog/tree/master/regularisation" rel="noopener ugc nofollow" target="_blank">这个</a>资源库中找到 dropout 实现、L1 和 L2 正则化的代码。</p><h2 id="f046" class="ld kg hi bd kh le lf lg kl lh li lj kp jg lk ll kr jk lm ln kt jo lo lp kv lq bi translated">参考</h2><ul class=""><li id="86bd" class="ls lt hi iz b ja kx jd ky jg mr jk ms jo mt js lx ly lz ma bi translated"><a class="ae mq" href="https://jmlr.org/papers/volume15/srivastava14a.old/srivastava14a.pdf" rel="noopener ugc nofollow" target="_blank">https://jmlr . org/papers/volume 15/srivastava 14 a . old/srivastava 14 a . pdf</a></li><li id="dfcb" class="ls lt hi iz b ja ml jd mm jg mn jk mo jo mp js lx ly lz ma bi translated"><a class="ae mq" href="https://learning.oreilly.com/library/view/deep-learning-with/9781617295263/OEBPS/Text/08.xhtml" rel="noopener ugc nofollow" target="_blank">https://learning . oreilly . com/library/view/deep-learning-with/9781617295263/OEBPS/Text/08 . XHTML</a></li><li id="d17a" class="ls lt hi iz b ja ml jd mm jg mn jk mo jo mp js lx ly lz ma bi translated"><a class="ae mq" href="https://www.youtube.com/watch?v=DEMmkFC6IGM" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=DEMmkFC6IGM</a></li><li id="737f" class="ls lt hi iz b ja ml jd mm jg mn jk mo jo mp js lx ly lz ma bi translated"><a class="ae mq" href="https://arxiv.org/pdf/1904.03392.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1904.03392.pdf</a></li></ul></div></div>    
</body>
</html>