<html>
<head>
<title>A Genetic Algorithm for Optimizing Neural Network Parameters using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python优化神经网络参数的遗传算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-genetic-algorithm-for-optimizing-neural-network-parameters-d8187d5114ed?source=collection_archive---------4-----------------------#2019-09-27">https://medium.com/analytics-vidhya/a-genetic-algorithm-for-optimizing-neural-network-parameters-d8187d5114ed?source=collection_archive---------4-----------------------#2019-09-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2b9823ec91dc7087262b0078c0fa299b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kB5_j9shRUOoLFWJ"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克莱门特·H</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="fca0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">人工神经网络是一种受监督的机器学习算法，在诸如语音和图像识别、时间序列预测、机器翻译软件等各种领域的应用中非常流行。它们在研究中很有用，因为它们能够解决随机问题，这通常允许对极其复杂的问题进行近似求解。</p><p id="fc5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，定义理想的网络架构是非常困难的。没有明确的规则规定中间层有多少个神经元，或者有多少层，或者这些神经元之间的连接应该如何实现。为了解决这类问题，本文介绍了如何使用遗传算法在Python中自动找到好的神经网络架构。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="8951" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，你需要安装<a class="ae iu" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn包</a>。一个简单有效的数据挖掘和数据分析工具。</p><p id="a2cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于混合算法的训练，我们将使用鸢尾花类(Setosa，Virginica和Versicolor)的数据库。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/d87fe1b16e4a3c71b0380f0bd289d897.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/0*4IDWqZT0OOZIt6jz.png"/></div></figure><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="d736" class="kk kl hi kg b fi km kn l ko kp">from sklearn import datasets<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from sklearn.neural_network import MLPClassifier<br/>from sklearn.metrics import accuracy_score<br/>from sklearn.model_selection import train_test_split<br/>from random import randint<br/>import random<br/>from sklearn.metrics import mean_absolute_error as mae</span><span id="2be9" class="kk kl hi kg b fi kq kn l ko kp">iris = <a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_iris.html#sklearn.datasets.load_iris" rel="noopener ugc nofollow" target="_blank">datasets.load_iris</a>()<br/>X = iris.data<br/>y = iris.target<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42)</span></pre><p id="af04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以开始构建遗传算法了。群体中的个体由激活、求解器和隐藏层中的神经元数量组成——这里的神经网络有两个隐藏层。下面的代码显示了一个填充初始化的示例。人口规模由size_mlp定义。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="ff26" class="kk kl hi kg b fi km kn l ko kp">def inicialization_populacao_mlp(size_mlp):<br/>  pop =  [[]]*size_mlp<br/>  activation = ['identity','logistic', 'tanh', 'relu']<br/>  solver = ['lbfgs','sgd', 'adam']<br/>  pop = [[random.choice(activation), random.choice(solver),  randint(2,100), randint(2,100)] for i in range(0, size_mlp)]<br/>  return pop</span></pre><p id="2d85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">交叉算子是一种用于结合两个亲本的信息来产生新个体的算子。目的是增加遗传变异并提供更好的选择。这里使用的重组是单点杂交。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="46b7" class="kk kl hi kg b fi km kn l ko kp">def crossover_mlp(mother_1, mother_2):<br/>  child = [mother_1[0], mother_2[1], mother_1[2], mother_2[3]]    <br/>  return child</span></pre><p id="609c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了进一步增加遗传可变性和避免局部极小值，使用的另一个算子是突变。突变的概率由prob_mut定义。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="e554" class="kk kl hi kg b fi km kn l ko kp">def mutation_mlp(child, prob_mut):<br/> for c in range(0, len(child)):<br/> if np.random.rand() &gt; prob_mut:<br/> k = randint(2,3)<br/> child[c][k] = int(child[c][k]) + randint(1, 10)<br/> return child</span></pre><p id="ba9a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样的例子是分类任务，适应度函数是根据神经网络的精度计算的，在这种情况下，遗传算法的目标是最大化神经网络的精度。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="541e" class="kk kl hi kg b fi km kn l ko kp">def function_fitness_mlp(pop, X_train, y_train, X_test, y_test): <br/>    fitness = []<br/>    j = 0<br/>    for w in pop:<br/>        clf = MLPClassifier(learning_rate_init=0.09, activation=w[0], solver = w[1], alpha=1e-5, hidden_layer_sizes=(int(w[2]), int(w[3])),  max_iter=1000, n_iter_no_change=80)</span><span id="16da" class="kk kl hi kg b fi kq kn l ko kp">try:<br/>            clf.fit(X_train, y_train)<br/>            f = accuracy_score(clf.predict(X_test), y_test)</span><span id="eddc" class="kk kl hi kg b fi kq kn l ko kp">fitness.append([f, clf, w])<br/>        except:<br/>            pass<br/>    return fitness#</span></pre><p id="fb80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，构造了遗传算法的主体。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="1e17" class="kk kl hi kg b fi km kn l ko kp">def ag_mlp(X_train, y_train, X_test, y_test, num_epochs = 10, size_mlp=10, prob_mut=0.8):<br/>    pop = inicializacao_populacao_mlp(size_mlp)<br/>    fitness = function_fitness_mlp(pop,  X_train, y_train, X_test, y_test)<br/>    pop_fitness_sort = np.array(list(reversed(sorted(fitness,key=lambda x: x[0]))))</span><span id="2e2d" class="kk kl hi kg b fi kq kn l ko kp">for j in range(0, num_epochs):<br/>        length = len(pop_fitness_sort)<br/>        #seleciona os pais<br/>        parent_1 = pop_fitness_sort[:,2][:length//2]<br/>        parent_2 = pop_fitness_sort[:,2][length//2:]</span><span id="7c24" class="kk kl hi kg b fi kq kn l ko kp">#cruzamento<br/>        child_1 = [cruzamento_mlp(parent_1[i], parent_2[i]) for i in range(0, np.min([len(parent_2), len(parent_1)]))]<br/>        child_2 = [cruzamento_mlp(parent_2[i], parent_1[i]) for i in range(0, np.min([len(parent_2), len(parent_1)]))]<br/>        child_2 = mutacao_mlp(child_2, prob_mut)<br/>        <br/>        #calcula o fitness dos filhos para escolher quem vai passar pra próxima geração<br/>        fitness_child_1 = function_fitness_mlp(child_1,X_train, y_train, X_test, y_test)<br/>        fitness_child_2 = function_fitness_mlp(child_2, X_train, y_train, X_test, y_test)<br/>        pop_fitness_sort = np.concatenate((pop_fitness_sort, fitness_child_1, fitness_child_2))<br/>        sort = np.array(list(reversed(sorted(pop_fitness_sort,key=lambda x: x[0]))))<br/>        <br/>        #seleciona individuos da proxima geração<br/>        pop_fitness_sort = sort[0:size_mlp, :]<br/>        best_individual = sort[0][1]<br/>        <br/>    return best_individual</span></pre><p id="598f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">享受你的编码！</p><p id="3069" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要下载代码，点击<a class="ae iu" href="https://github.com/luaffjk/ga-mlp" rel="noopener ugc nofollow" target="_blank">这里</a>。另外，如果你喜欢在Medium上阅读更多类似的东西，考虑注册会员来支持我和成千上万的其他作家。或者你可以给我买一杯 <a class="ae iu" href="https://www.buymeacoffee.com/luanagoncaz" rel="noopener ugc nofollow" target="_blank"> <em class="kr">这里的</em> </a> <em class="kr">代替。祝你愉快:)</em></p></div></div>    
</body>
</html>