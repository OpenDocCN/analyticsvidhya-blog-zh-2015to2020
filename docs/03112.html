<html>
<head>
<title>CERN Z Boson Identification &amp; Understanding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CERN Z玻色子识别和理解</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cern-z-boson-identification-understanding-3d4c4765bf1?source=collection_archive---------14-----------------------#2020-01-16">https://medium.com/analytics-vidhya/cern-z-boson-identification-understanding-3d4c4765bf1?source=collection_archive---------14-----------------------#2020-01-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="7443" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="ce7f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在接下来的文章中，我将分析从CERN的CMS探测器接收到的数据。其目的是探测大型强子对撞机中一组质子碰撞后可能出现的不同粒子；这使得科学家能够研究我们宇宙的构成，暗物质等等。在我们的模块中收集的数据考虑了来自碰撞粒子的纯μ子。μ子是被归类为轻子的基本粒子。因此，它被认为没有子结构。根据我们收集的数据，我们将主要从每个μ子中提取信息，以获得较大粒子的不变质量。不变质量是物体静止时的质量；被测量的粒子以高速运动。因此，我们没有它们的“真实质量”,因为它被扭曲了，也就是相对论质量。数据分析的目标是分析更重要的单个粒子，在我们的例子中，我们将关注z玻色子或z零粒子。欧洲粒子物理研究所在20世纪80年代早期发现了这种玻色子。很像W玻色子，z零粒子携带弱力，不像他的对应物(W)这个玻色子是中性的。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/195f6ebe135a6d59fd96f3eb0586474d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xf6lAzYWeNDVnDTLp1lZng.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">Z玻色子图</figcaption></figure></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="3d85" class="if ig hi bd ih ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc bi translated">历史</h1><p id="ec85" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了进一步了解我们将要会聚的粒子，我们将回顾一下它的历史。在欧洲粒子物理研究所，科学家们意识到通过发射W玻色子，弱力可以改变；例如，质子的电荷通过改变它的夸克构型。1958年，西德尼·布罗德曼(Sidney Bludman)提出，弱力中可能存在另一个角色，但这一次是一个中立的对应角色。一旦实验开始，科学家将中微子射入一个气泡室，在那里中微子开始相互作用，从而证明存在一种弱中性流:Z玻色子。此外，在超级质子同步加速器(20世纪70年代末)即质子-反质子对撞机诞生后，他们能够凭经验证明W玻色子和Z玻色子的存在，这要归功于欧洲核子研究中心SPS中的粒子探测器UA1。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="1f7b" class="if ig hi bd ih ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc bi translated">数据</h1><p id="0efd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">从CMS接收的数据来自一个根文件，其中包含超过5700万次冲突的信息。这些事件产生的μ子已经被记录下来；数据文件让我们知道它们碰撞后的电荷、横向动量、φ和θ角。μ子要么带正电，要么带负电(1或-1)。μ子的横向动量相当于动量在横向平面上的投影(3d向量),形成一个2d图形。μ子的θ角等于y轴和粒子投影之间的角度，而φ角等于粒子投影和x轴之间的角度。所有角度都以弧度为单位。</p><pre class="kc kd ke kf fd ld le lf lg aw lh bi"><span id="4d2f" class="li ig hi le b fi lj lk l ll lm">%<strong class="le hj">matplotlib</strong> inline<br/><strong class="le hj">import</strong> <strong class="le hj">numpy</strong> <strong class="le hj">as</strong> <strong class="le hj">np</strong><br/><strong class="le hj">import</strong> <strong class="le hj">matplotlib.mlab</strong> <strong class="le hj">as</strong> <strong class="le hj">mlab</strong><br/><strong class="le hj">import</strong> <strong class="le hj">matplotlib.pyplot</strong> <strong class="le hj">as</strong> <strong class="le hj">plt</strong><br/><strong class="le hj">import</strong> <strong class="le hj">ROOT</strong><br/><strong class="le hj">import</strong> <strong class="le hj">math</strong><br/><strong class="le hj">import</strong> <strong class="le hj">datetime</strong><br/>read = ROOT.TFile.Open("Run2012BC_DoubleMuParked.root")<br/>parse = read.Get("Events")<br/>phi={}<br/>theta={}<br/><strong class="le hj">print</strong> "start"<br/>df=[]<br/>start = datetime.datetime.now()<br/>k=0</span><span id="87a6" class="li ig hi le b fi ln lk l ll lm"><strong class="le hj">for</strong> i <strong class="le hj">in</strong> parse:<br/>    k+=1<br/>    <strong class="le hj">if</strong> k&gt;10000:<strong class="le hj">break</strong><br/>    <strong class="le hj">if</strong> k%<strong class="le hj">1000000</strong> == 0:<br/>        <strong class="le hj">print</strong>(k)<br/>    <strong class="le hj">for</strong> g <strong class="le hj">in</strong> range(i.nMuon):<br/>        fig1 = int(-(i.Muon_phi[g]-np.pi)/(np.pi/100))<br/>        cfig1= int(((fig1 * np.pi/100)- np.pi + (np.pi/200))*100)<br/>        fig2 = int(-(i.Muon_eta[g]-np.pi)/(np.pi/100))<br/>        cfig2 = int(((fig2 * np.pi/100)- np.pi + (np.pi/200))*100)<br/>        <strong class="le hj">if</strong> cfig1 <strong class="le hj">in</strong> phi:<br/>            phi[cfig1]+=1<br/>        <strong class="le hj">else</strong>:<br/>            phi[cfig1]=1<br/>        <strong class="le hj">if</strong> fig2 <strong class="le hj">in</strong> theta:<br/>            theta[fig2]+=1<br/>        <strong class="le hj">else</strong>:<br/>            theta[fig2]=1<br/>    <br/>    <br/><strong class="le hj">print</strong>(datetime.datetime.now()-start)<br/>f=plt.gcf()<br/>plt.title("Phi")<br/>f.set_size_inches(9.25, 5.25)<br/>plt.bar([i <strong class="le hj">for</strong> i <strong class="le hj">in</strong> phi],[i <strong class="le hj">for</strong> i <strong class="le hj">in</strong> phi.values()], color="blue")<br/>plt.show()<br/>g=plt.figure(2)<br/>plt.title("Theta")<br/>plt.bar([i <strong class="le hj">for</strong> i <strong class="le hj">in</strong> theta], [i <strong class="le hj">for</strong> i <strong class="le hj">in</strong> theta.values()], color="red")<br/>g.show()<br/>plt.xlabel('Values')<br/>plt.ylabel('Frequency')<br/>plt.show()</span></pre><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lo"><img src="../Images/4abde9742e3065ffff8ff6c10ba947b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*oMSdu9Hzy9rqoMuhwmUtaQ.png"/></div></figure><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lp"><img src="../Images/9350237ddda22cafd7db08cfb8e97519.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*nNWdKnrV8zQrWVhIwuYREQ.png"/></div></figure></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="3489" class="if ig hi bd ih ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc bi translated">不变质量</h1><p id="24c6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">不变质量图给了我们一个很强的指示，我们正在处理的粒子。我们注意到，在特定的时间，不变质量大幅度上升，这可能表明粒子的存在。在我们的数据集中，我们注意到有各种各样的峰，但我们将只关注本笔记本中的一个，即Z玻色子(正如我前面提到的)，它是不变质量图的最后一个峰。</p><pre class="kc kd ke kf fd ld le lf lg aw lh bi"><span id="1faf" class="li ig hi le b fi lj lk l ll lm"><strong class="le hj">def</strong> massm(pt,et,ph,ms):<br/>    mass1 = ms[0]<br/>    px1 = vector(pt[0],et[0],ph[0])[0]<br/>    py1 = vector(pt[0],et[0],ph[0])[1]<br/>    pz1 = vector(pt[0],et[0],ph[0])[2]<br/>    energy1 = math.sqrt(mass1**2 + px1**2 + py1**2 + pz1**2)<br/>    mass2 = ms[1]<br/>    px2 = vector(pt[1],et[1],ph[1])[0]<br/>    py2 = vector(pt[1],et[1],ph[1])[1]<br/>    pz2 = vector(pt[1],et[1],ph[1])[2]<br/>    energy2 = math.sqrt(mass2**2 + px2**2 + py2**2 + pz2**2)<br/>    <br/>    mass1 = energy1**2 + 2*energy1*energy2 + energy2**2<br/>    mass2 = (px1+px2)**2 + (py1+py2)**2 + (pz1+pz2)**2<br/>    mass = math.sqrt(mass1-mass2)<br/>    <br/>    <strong class="le hj">return</strong> mass</span><span id="e16e" class="li ig hi le b fi ln lk l ll lm">phi=[]<br/>theta=[]<br/>pt=[]<br/>mass=[]<br/>%<strong class="le hj">pylab</strong> inline<br/>mass2=[]<br/><strong class="le hj">print</strong> "start"<br/>k=0<br/><strong class="le hj">for</strong> i <strong class="le hj">in</strong> parse:<br/>    k+=1<br/>    <strong class="le hj">if</strong> k&gt;100000:<strong class="le hj">break</strong><br/>    <strong class="le hj">if</strong> k%<strong class="le hj">1000000</strong> == 0:<br/>        <strong class="le hj">print</strong>(k)<br/>    <strong class="le hj">for</strong> g <strong class="le hj">in</strong> range(i.nMuon):<br/>        phi.append(i.Muon_phi[g])<br/>        theta.append(i.Muon_eta[g])<br/>        tt = i.Muon_pt[g]<br/>        <strong class="le hj">if</strong> tt&lt;150: pt.append(tt)<br/>    <br/>    <br/>    <strong class="le hj">if</strong> i.nMuon!=2: <strong class="le hj">continue</strong>   <br/>    <strong class="le hj">if</strong> i.Muon_charge[0] * i.Muon_charge[1] &lt; 0:<br/>        qv0 = ROOT.Math.PtEtaPhiMVector(i.Muon_pt[0], i.Muon_eta[0], i.Muon_phi[0], i.Muon_mass[0])<br/>        qv1 = ROOT.Math.PtEtaPhiMVector(i.Muon_pt[1], i.Muon_eta[1], i.Muon_phi[1], i.Muon_mass[1])<br/>        ms = (qv0 + qv1).mass()<br/>        <strong class="le hj">if</strong> ms&lt;20:<br/>            mass2.append(ms)<br/>        <strong class="le hj">if</strong> ms&lt;120:<br/>            mass.append(ms)</span><span id="83ae" class="li ig hi le b fi ln lk l ll lm">f=plt.figure(1)<br/>plt.title("Phi")<br/>plt.hist(phi, color="blue")<br/>f.set_size_inches(9.25, 5.25)<br/>f.show()<br/>g=plt.figure(2)<br/>plt.title("Theta")<br/>plt.hist(theta, color="red")<br/>g.set_size_inches(9.25, 5.25)<br/>g.show()<br/>e=plt.figure(3)<br/>plt.title("Pt")<br/>plt.hist(pt, color="green", bins=10)<br/>e.set_size_inches(9.25, 5.25)<br/>e.show()<br/>t=plt.figure(4)<br/>plt.title("invariant mass")<br/>plt.hist(mass, color="yellow", bins=150)<br/>plt.yscale("log")<br/>t.set_size_inches(9.25, 5.25)<br/>t.show()<br/>h=plt.figure(5)<br/>plt.title("invariant mass")<br/>plt.hist(mass2, color="yellow", bins='auto')<br/>plt.yscale("log")<br/>h.set_size_inches(9.25, 5.25)<br/>h.show()</span></pre><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lq"><img src="../Images/36500b8d44bc0c471c993d1c69ef5a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*e5pxM0v3-ukRTYKP-vvCsQ.png"/></div></figure><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lq"><img src="../Images/6f8fc969f700bac3a8b9b238018eb5a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*RYCCjlZk8xoSeF7T0T5xzQ.png"/></div></figure><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lr"><img src="../Images/97d23116de5224c6638f353d76575ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*rI8dCIwUVE05WVHclal-6w.png"/></div></figure><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es ls"><img src="../Images/89053f136c02ca9465a4f37ccf01622e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*4Us2noVG7t-yYDOQUdGjPw.png"/></div></figure><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es ls"><img src="../Images/976b122a032bfe86416d9ceab99d6fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*uZVywyzP7F7ZOrfohSMoOw.png"/></div></figure><pre class="kc kd ke kf fd ld le lf lg aw lh bi"><span id="f1fa" class="li ig hi le b fi lj lk l ll lm">mass=[]<br/>bmass = []<br/>gmass=[]<br/>k=0<br/>g=0<br/><strong class="le hj">for</strong> i <strong class="le hj">in</strong> parse:<br/>    k+=1<br/>    <strong class="le hj">if</strong> k%<strong class="le hj">100000</strong> == 0:<br/>        <strong class="le hj">print</strong>(k)<br/>    <strong class="le hj">if</strong> k&gt;1000000:<strong class="le hj">break</strong><br/>    <strong class="le hj">if</strong> i.nMuon!=2: <strong class="le hj">continue</strong> <br/>    qv0 = ROOT.Math.PtEtaPhiMVector(i.Muon_pt[0], i.Muon_eta[0], i.Muon_phi[0], i.Muon_mass[0])<br/>    qv1 = ROOT.Math.PtEtaPhiMVector(i.Muon_pt[1], i.Muon_eta[1], i.Muon_phi[1], i.Muon_mass[1])  <br/>    ms = (qv0 + qv1).mass()<br/>    p = math.sqrt((qv0.X()+qv1.X())**2 + (qv0.Y()+qv1.Y())**2 + (qv0.Z()+qv1.Z())**2)<br/>    <strong class="le hj">if</strong> p &gt; 10:<br/>        <strong class="le hj">if</strong> i.Muon_charge[0] * i.Muon_charge[1] &gt; 0:  <br/>            <strong class="le hj">if</strong> ms&lt;120:<br/>                bmass.append(ms)<br/>        <strong class="le hj">elif</strong> i.Muon_charge[0] * i.Muon_charge[1] &lt; 0:<br/>            <strong class="le hj">if</strong> ms&lt;120:<br/>                gmass.append(ms)<br/><strong class="le hj">def</strong> mean_clean(cleanhist,xhist,start,end):<br/>    xv = xhist[1].tolist()<br/>    yv = cleanhist<br/>    k=0<br/>    sum = 0<br/>    <strong class="le hj">for</strong> i,j <strong class="le hj">in</strong> zip(xv,yv):<br/>        <strong class="le hj">if</strong> i &lt; start: <strong class="le hj">continue</strong><br/>        <strong class="le hj">if</strong> i &gt; end: <strong class="le hj">continue</strong><br/>        i = (xv[xv.index(i) + 1] + i)/2<br/>        sum += i * j<br/>        k += j<br/>    <strong class="le hj">return</strong> sum/k</span></pre></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="ff7b" class="if ig hi bd ih ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc bi translated">背景</h1><p id="4c2a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然而，原始数据/图表可能会相对误导。在CMS中，条件接近完美，但还没有完全达到，这意味着存在不同的干扰可能性，可能会影响检测或接收的数据质量。例如，在我们的情况下，即使我们有大量的数据，不变质量的第一个直方图中的背景显示的扰动仍然是明显的，因为数据是许多碰撞的集合，Z零并不总是存在。为了去除合理数量的背景，我们去除了两个重要的背景源。我们的第一个变数是粒子的质量:如果可能粒子的不变质量不值得注意，我们决定它可能不是粒子，而可能是先前碰撞的分支。我们考虑的第二个变量是动量。我们的结论是，如果一个可能的粒子的动量太低，那么它就没有必要被包括在计算中(因为z0具有相对较大的质量，我预计动量会很大)。</p><pre class="kc kd ke kf fd ld le lf lg aw lh bi"><span id="5b8a" class="li ig hi le b fi lj lk l ll lm">b=[]<br/><strong class="le hj">for</strong> i <strong class="le hj">in</strong> bmass:<br/>    b.append(2.4)<br/>h = plt.figure(1)<br/>plt.yscale("log")<br/>one = plt.hist(gmass, bins=500, facecolor='green')<br/>two = plt.hist(bmass,bins=500, facecolor='yellow', weights=b, alpha=0.7)<br/>plt.axis([60, 120, 0, 3000])<br/>h.set_size_inches(9.25, 5.25)<br/>plt.show()</span></pre><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lt"><img src="../Images/d5c61fde1f60440676f42a2da17a453d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*1RwPMd9n-Kw3gReK69DpNQ.png"/></div></figure></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="0803" class="if ig hi bd ih ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc bi translated">减法</h1><p id="3739" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一旦我们完成了对背景的估计/识别，我们必须找到一种从原始直方图中去除背景的方法。为了实现这一点，我们试图尽可能地将背景的直方图与原始直方图对齐，以查看背景对我们的数据有多大影响。对齐完成后，我们通过减去两个直方图(原始—背景)的y坐标数组来构建一个条形图。一旦这样做了，Z玻色子的峰值应该是单独的，并且平行于x轴。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="ed91" class="if ig hi bd ih ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc bi translated">Z零点的质量</h1><p id="6346" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们想计算Z玻色子的质量。为了实现这一点，我们将首先需要消除背景(解释了以上段落)。这种错误源的消除使得峰值与x轴平行，从而更容易计算。扰动的消除给我们展示了玻色子探测的清晰图像。它的质量等于这个峰的顶点的x坐标。为了检索此信息，我们计算峰内包含的面元的平均值，这将为我们提供一个以GeV/°c为单位的近似正确的质量值。如果我们没有犯任何重大错误，我们得到的值应该接近Z玻色子的合法值，约为91.18 GeV/°c。当然，如果我们考虑更多可能的错误来源，除了低动量和无关紧要的质量，我们计算的值将不断接近真实值。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="58b9" class="if ig hi bd ih ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc bi translated">FWHM</h1><p id="9dfb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">计算出粒子的质量后，另一个有趣的测量是半峰全宽(FWHM)值。该值表示粒子的衰减宽度，通过将剩余背景视为0并计算中点之间的距离来计算。该距离代表衰变宽度，该宽度与衰变寿命直接相关，并且是粒子共振的直接倒数。与假设值2.49 GeV/℃在被探测到之前，粒子会穿过多层物质/金属，因此它的“飞行路径”会发生偏离。因此，粒子的属性(例如速度、方向等)可以被改变。因此，这些最小的诉讼环境或多次散射将扩大检测器感知的结果。事实上，不变质量直方图的峰值变得更大，可能会扭曲结果。</p><pre class="kc kd ke kf fd ld le lf lg aw lh bi"><span id="509e" class="li ig hi le b fi lj lk l ll lm">bar = []<br/><strong class="le hj">for</strong> d <strong class="le hj">in</strong> range(len(one[1])):<br/>    <strong class="le hj">if</strong> d==0: <strong class="le hj">continue</strong><br/>            <br/>    middle = (one[1][d]+one[1][d-1])/2<br/>    bar.append(middle)<br/>new=[]<br/><strong class="le hj">for</strong> i,j <strong class="le hj">in</strong> zip(one[0],two[0]):<br/>    new.append(i-(j*2.3))<br/>point = mean_clean(new,one,87,94)<br/><strong class="le hj">print</strong>(point)<br/>big=0<br/>k=0<br/><strong class="le hj">for</strong> i <strong class="le hj">in</strong> new:<br/>    k+=1<br/>    <strong class="le hj">if</strong> k&lt;80:<strong class="le hj">continue</strong><br/>    <strong class="le hj">if</strong> i&gt;big:<br/>        big=i <br/>middle = big/2<br/>num=0<br/>k=0<br/>high = new.index(big)<br/><strong class="le hj">for</strong> i <strong class="le hj">in</strong> new:<br/>    k+=1<br/>    <strong class="le hj">if</strong> k&lt;high:<strong class="le hj">continue</strong><br/>    <strong class="le hj">if</strong> abs(middle-i)&lt;abs(middle-num):<br/>        num=i<br/>first = one[1][new.index(num)]<br/>num=0<br/>k=0<br/><strong class="le hj">for</strong> i <strong class="le hj">in</strong> new:<br/>    k+=1<br/>    <strong class="le hj">if</strong> k&lt;70:<strong class="le hj">continue</strong><br/>    <strong class="le hj">if</strong> k&gt;high:<strong class="le hj">continue</strong><br/>    <strong class="le hj">if</strong> abs(middle-i)&lt;abs(middle-num):<br/>        num=i<br/>second = one[1][new.index(num)] <br/>dif = first - second<br/><strong class="le hj">print</strong> dif<br/>p3=[first,second]<br/>p4=[middle, middle]<br/>p1=[0,100000]<br/>p2=[point,point]<br/>diff=plt.bar(bar, height=(one[0]-two[0]))<br/>plt.plot(p2,p1,color="red")<br/>plt.plot(p3,p4,color="red")<br/>plt.axis([70, 110, 0, 4000])<br/>plt.show()</span></pre><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lu"><img src="../Images/4dd440cd312e58389bd716e4ff8c1f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*myq2bo6JjO9-zrop7sNYbA.png"/></div></figure></div></div>    
</body>
</html>