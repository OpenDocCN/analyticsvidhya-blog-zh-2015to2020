<html>
<head>
<title>Unleash the Power of Pandas ‘category’ Dtype: Make Categorical Feature Serves Well for Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">释放熊猫“分类”的力量Dtype:使分类特征很好地服务于机器学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/unleash-the-power-of-pandas-category-dtype-encode-categorical-data-in-smarter-ways-eb787cd274df?source=collection_archive---------5-----------------------#2020-06-30">https://medium.com/analytics-vidhya/unleash-the-power-of-pandas-category-dtype-encode-categorical-data-in-smarter-ways-eb787cd274df?source=collection_archive---------5-----------------------#2020-06-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="13ec" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">更轻|更快|更安全|灵活|防呆</h2><div class=""/><div class=""><h2 id="0138" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">关于在Python中使用Pandas 'category '数据类型的教程</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/d87e389a8d500663b24e5340f7ad2229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3r3hSQoefsRBsNoCw99DDg.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">资源:《功夫熊猫:命运之爪》</figcaption></figure><p id="5198" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">最近，我在研究一个前Kaggle竞赛数据集- <a class="ae ks" href="https://www.kaggle.com/c/talkingdata-mobile-user-demographics" rel="noopener ugc nofollow" target="_blank"> TalkingData移动用户统计数据</a>。相关数据帧的总大小为2GB。但是在我尝试将这些数据框合并成一个表格数据框之后。嘣！2GB爆炸到18GB！！😟</p><p id="b48b" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">幸运的是，经过一些简单的技巧，我能够将数据集从18GB增加到5GB，而不会丢失任何信息或改变数据结构。我实现它的关键方法是在Pandas中使用“类别”日期类型。</p><p id="5c33" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">更好的是，我意识到“category”数据类型不仅使数据集变得轻量级，而且有助于提高数据操作性能和机器学习性能。</p><p id="b9be" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">今天我将谈论如何使用熊猫的“类别”类型，以及为什么你应该考虑使用它。</p><blockquote class="kt ku kv"><p id="a896" class="jw jx kw jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated">注意:在Python的行话中，Pandas数据类型通常被称为‘dtype’。如果以后看到更多的' dtype '，应该知道' dtype'=Pandas数据类型。</p></blockquote><h1 id="f8bb" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated">要涵盖的内容</h1><ul class=""><li id="5125" class="ls lt hi jy b jz lu kc lv kf lw kj lx kn ly kr lz ma mb mc bi translated">展示:为什么“类别”数据类型是好的</li><li id="6c38" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">教程:“类别”数据类型如何工作</li><li id="c70a" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">洞察:为什么“类别”数据类型对ML很重要</li><li id="a87c" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">要点:何时应该使用“类别”数据类型</li></ul><h1 id="02ae" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated">这篇文章是给你的吗？</h1><p id="f306" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">本教程的目标不是试图掩盖非常丰富的分类编码或如何在任何语言中为每个数据科学分区处理大数据。相反，重点是Python和它的Pandas库。如果你不是Python用户或者和熊猫有密切的工作关系，不要担心。相信这个帖子还是能有所启发的。</p><p id="abaa" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">事不宜迟，让我们把手弄脏，跳入数据集。</p><p id="b8fd" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">附:和往常一样，我会用动手的方式解释。你可以在这个<a class="ae ks" href="https://raw.githubusercontent.com/kefeimo/DataScienceBlog/master/3.category_dtype/pandas_data_type_0628.ipynb" rel="noopener ugc nofollow" target="_blank"> Github链接</a>上找到笔记本。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h1 id="3351" class="la lb hi bd lc ld ms lf lg lh mt lj lk ix mu iy lm ja mv jb lo jd mw je lq lr bi translated">表演开始:更轻更快</h1><h2 id="9bdc" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">加载数据</h2><p id="fb63" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">这里是<a class="ae ks" href="https://raw.githubusercontent.com/kefeimo/DataScienceBlog/master/3.category_dtype/df_example.csv" rel="noopener ugc nofollow" target="_blank">链接</a>你可以在演示中下载数据集。(我们不会处理原始Kaggle数据集，而是它的一部分。)</p><p id="0b2c" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><code class="du nk nl nm nn b">import pandas as pd</code></p><pre class="jh ji jj jk fd no nn np nq aw nr bi"><span id="83ba" class="mx lb hi nn b fi ns nt l nu nv">url = <!-- -->'<a class="ae ks" href="https://raw.githubusercontent.com/kefeimo/DataScienceBlog/master/3.category_dtype/df_example.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/kefeimo/DataScienceBlog/master/3.category_dtype/df_example.csv'</a></span><span id="a000" class="mx lb hi nn b fi nw nt l nu nv">df_original = pd.read_csv(url) <br/>df_original.head() <br/>df_original.info()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nx"><img src="../Images/8ada7beb81ebccdb43207a462bab7d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QD1NLKUZP-okBdZKtfEFXg.png"/></div></div></figure><p id="bbeb" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">根据“info”函数，数据集有130，821行和10列，“float64”、“int64”、“object”特征的数量分别为2、4、4。内存使用量约为10.0 MB。</p><h2 id="188d" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">做品类:怎么做？</h2><p id="414d" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">首先，让我们将“性别”特征数据类型改为“类别”。我们是这样做的。</p><pre class="jh ji jj jk fd no nn np nq aw nr bi"><span id="fa68" class="mx lb hi nn b fi ns nt l nu nv">df_tmp = df_original.copy()<br/>df_tmp.gender = df_tmp.gender.astype('category')</span></pre><h2 id="694c" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">展示1:节省内存使用</h2><p id="0e5d" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">更改“性别”特征数据类型后，再次检查。现在，我们已经节省了大约10%的内存使用。耶。🙌</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ny"><img src="../Images/35a58c4b08ba566781e99abb51b65e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTgTDLgQjTPRIk2qU24sRg.png"/></div></div></figure><h2 id="7138" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">展示2:加速数据操作</h2><p id="0564" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">对于分类数据分析,“groupby”是一种方便的操作(如果不是最有用的操作)。这里，我们通过使用类别数据类型来演示操作性能(即时间效率)。如下所示，通过使用“类别”数据类型，执行要快得多(例如，与使用“对象”数据类型相比，所用时间少于1/3)。)</p><pre class="jh ji jj jk fd no nn np nq aw nr bi"><span id="c316" class="mx lb hi nn b fi ns nt l nu nv">%timeit df_original.groupby('gender').latitude.mean()</span><span id="2efe" class="mx lb hi nn b fi nw nt l nu nv">df_tmp = df_original.copy()<br/>df_tmp.gender = df_tmp.gender.astype('category')</span><span id="6e1c" class="mx lb hi nn b fi nw nt l nu nv">%timeit df_tmp.groupby('gender').latitude.mean()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nz"><img src="../Images/c416451fb0cd1b05264ca0f94aff6441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QwK6anIAEguHAHOTdxMPxA.png"/></div></div></figure><h2 id="b2e2" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">让我们看看更多的例子</h2><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es oa"><img src="../Images/faeef548a87172d869ba2433a1db1efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrodEkHkeITDyoewAqkF7w.png"/></div></div></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ob"><img src="../Images/51f5ef979457af251277f0e31b85c8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dnCZL14i-IyF9L46VpCL_w.png"/></div></div></figure><blockquote class="kt ku kv"><p id="5570" class="jw jx kw jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated">在第一个例子中，我们节省了更多的内存使用。但是在第二个例子中，它占用了更多的内存。</p></blockquote><h2 id="e7ed" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">抓住你的时刻</h2><p id="7c63" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">在<a class="ae ks" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html" rel="noopener ugc nofollow" target="_blank">熊猫文档</a>中，我们可以找到以下信息。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es oc"><img src="../Images/4c4b4c666e92b86240d15cc84c37d751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xh2e_EolA06hZvf6GIRoGw.png"/></div></div></figure><p id="d6c3" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">显然，使用类别dtype并不总是保证节省内存使用。</p><p id="469e" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">但是为什么会这样呢？更重要的是，我们如何更好地利用“类别”日期类型，是时候了解“类别”日期类型是如何工作的了。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h1 id="3d5f" class="la lb hi bd lc ld ms lf lg lh mt lj lk ix mu iy lm ja mv jb lo jd mw je lq lr bi translated">解释“类别”数据类型如何工作</h1><p id="20b8" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">引用熊猫关于<a class="ae ks" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html" rel="noopener ugc nofollow" target="_blank">的文档分类数据</a> (1.0.5):</p><blockquote class="od"><p id="f9c4" class="oe of hi bd og oh oi oj ok ol om kr dx translated">分类数据的所有值都在categories或np.nan中。顺序是由类别的顺序定义的，而不是值的词汇顺序。在内部，数据结构由一个categories数组和一个指向categories数组中实际值的整数代码数组组成。</p></blockquote><p id="1dd4" class="pw-post-body-paragraph jw jx hi jy b jz on is kb kc oo iv ke kf op kh ki kj oq kl km kn or kp kq kr hb bi translated">现在更困惑了？别急，让我试着解释一下。</p><h2 id="86bc" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">哈希表</h2><p id="62b0" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">背后的机制是“哈希表”的思想。下面是哈希表工作原理的一个示例。(我们以‘性别’特征为例。)</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es os"><img src="../Images/3da5ae4a7448897a4648c3cfbc81a2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qA9S73GvhGFLh1Tti49BPA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">“类别”数据类型背后的机制图解(图片由作者提供)</figcaption></figure><ol class=""><li id="cd5f" class="ls lt hi jy b jz ka kc kd kf ot kj ou kn ov kr ow ma mb mc bi translated">首先，我们创建一个<strong class="jy hs">散列表</strong>，将唯一值‘M’和‘F’(也称为关键字)映射到‘0’和‘1’(也称为散列)。</li><li id="9f34" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr ow ma mb mc bi translated">然后我们<strong class="jy hs">编码</strong>原始数据集:分别用‘0’和‘1’代替‘M’和‘F’。编码的数据集将存储在内存中。这个过程通常可以(但不总是)节省内存使用(我将在后面解释)。</li><li id="9036" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr ow ma mb mc bi translated">请注意，值“0”和“1”不太容易解释。当显示时，Pandas不显示编码的数据集，而是将编码的数据集映射回原始的‘M’和‘F’值(<strong class="jy hs"> INV_ENCODE) </strong>。换句话说，具有“category”数据类型的新数据集看起来与原始数据集相同(但它们并不相同)。)</li></ol><h2 id="71ab" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">数据类型及其内存使用情况</h2><p id="ae95" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">需要记住的一点是:不同的数据类型可能会消耗不同的内存。下面是常见数据类型及其内存使用情况的列表。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ox"><img src="../Images/184cafc460248b8ee9224157c727372b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cZtniK7CFGXVGFPV43r5w.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">资源:<a class="ae ks" rel="noopener" href="/@vincentteyssier/optimizing-the-size-of-a-pandas-dataframe-for-low-memory-environment-5f07db3d72e">优化熊猫数据帧的大小</a></figcaption></figure><h2 id="fc06" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">计算内存使用量</h2><p id="8b63" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">我们已经讨论了类别数据类型如何使用哈希表。我们已经回顾了常见的数据类型及其内存使用情况。现在我们该谈谈内存使用了。</p><p id="12ef" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">您可以使用以下公式来近似计算内存使用量。</p><p id="532b" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">对于固有的Python数据类型(例如int64、float64、object)，</p><blockquote class="kt ku kv"><p id="b36e" class="jw jx kw jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated"><strong class="jy hs">memory _ usage = bytes * n _ rows</strong></p></blockquote><p id="2a2c" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">例如“性别”特征(在“对象”数据类型中)</p><ul class=""><li id="9fae" class="ls lt hi jy b jz ka kc kd kf ot kj ou kn ov kr lz ma mb mc bi translated">bytes = 8(对象数据类型为8字节)；</li><li id="4995" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">n_rows = 130，821；</li><li id="317d" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">memory _ usage = 8 * 130,821 = 1,046,568。</li><li id="faf7" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">我们可以用“nbytes”函数来检查这个结果:</li></ul><pre class="jh ji jj jk fd no nn np nq aw nr bi"><span id="2461" class="mx lb hi nn b fi ns nt l nu nv">print(df_original.gender.nbytes)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es oy"><img src="../Images/55e10d88d811922599385931dcb9adb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cf9GIZzjvW5mlRa0Z74KeA.png"/></div></div></figure><p id="b503" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">对于类别数据类型，公式如下:</p><blockquote class="kt ku kv"><p id="f44e" class="jw jx kw jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated"><strong class="jy hs">字节哈希*行数+ (0 +字节对象)* n唯一，</strong></p><p id="4ce0" class="jw jx kw jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated"><strong class="jy hs">其中，</strong></p><p id="946f" class="jw jx kw jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated"><strong class="jy hs">字节哈希=哈希函数(n唯一)</strong></p></blockquote><p id="56f0" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这个公式由两部分组成:一部分来自编码数据集(即df_encode)，一部分来自哈希表。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es oz"><img src="../Images/6f10ff8c39f722a8da819adf878864e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XBlrCF7ftQjptx-8J-pCqg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">内存使用量计算图解(图片由作者提供)</figcaption></figure><p id="d772" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">例如“性别”特征(在“类别”数据类型中)</p><ul class=""><li id="72c1" class="ls lt hi jy b jz ka kc kd kf ot kj ou kn ov kr lz ma mb mc bi translated">n_unique = 2，</li><li id="fa73" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">bytes_hashed = 1。(我们可以用int8对所有唯一值进行编码；int8数据类型占用1个字节。)</li><li id="2a1a" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">字节对象=8。(哈希表中的键占用的内存空间；pandas总是使用“对象”类型来保存哈希表键。)</li><li id="e659" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">所以，memory _ usage = 1 * 130821+(0+8)* 2 = 130837</li><li id="1d70" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">同样，我们可以使用“nbytes”函数进行检查</li></ul><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ob"><img src="../Images/8c92b4bd34afda21db117c582b1a68e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*isvgVYJ2QA_vX7F6afF6Cw.png"/></div></div></figure><h2 id="38b0" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">为什么“类别”数据类型不总是节省空间？</h2><p id="b240" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">这个公式解释了为什么有时通过“分类”数据可以节省内存，但有时却不行。它与有多少不同的类(即n_unique)有关。当n_unique较小时，pandas可以使用小型数据类型对原始数据集进行编码。例如，如果n_unique小于255，熊猫可以使用int8进行编码，只需要1个字节。</p><p id="eaf6" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">然而，当n_unique很大时，例如，对于event_id，n_unique=107，900，它需要int32来编码原始数据集，并且每个int32项占用4个字节。与在原始数据集中使用int64相比，这还不算太差，它需要8个字节。但是不要忘记哈希表也需要内存存储，Pandas总是使用' object '数据类型来存储哈希表中的键。由于n_unique非常大，接近n_rows (82%)，因此event_id类别数据集将占用更多的内存存储。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es pa"><img src="../Images/88cf1e0c2b2841d411a171c0a16676ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bH_0MZs8m38TDuFVlpBDQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">与总行数相比，每个特征和部分中的子类数</figcaption></figure><p id="36db" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">更多例子。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es pb"><img src="../Images/6297254f99596ffe22f56f5c06498489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5FtduFOjFf8IGadjKl3Mg.png"/></div></div></figure><blockquote class="kt ku kv"><p id="cdf7" class="jw jx kw jy b jz ka is kb kc kd iv ke kx kg kh ki ky kk kl km kz ko kp kq kr hb bi translated">注意:上述公式和“nbytes”函数只是计算内存使用量的粗略近似值。例如，不包括数据帧索引的内存使用。该公式是理解类别dtype mechanicsm的良好开端，但是，如果您想要更精确地分析内存使用情况，您可能想要检查<a class="ae ks" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.memory_usage.html" rel="noopener ugc nofollow" target="_blank"> memory_usage() </a>函数。</p></blockquote><h2 id="c584" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">一些评论</h2><p id="4f3d" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">你看，使用类别数据类型并不总是有助于节省内存使用。此外，如果节省内存是您的首要任务，这不是唯一的方法或最佳选择。例如，我们可以将“性别”特征改为“布尔”类型以节省更多空间。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es pc"><img src="../Images/6f481010418a37d8dd9550218f6cb449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96-i_mbJpYHO3dmmLOzo3Q.png"/></div></div></figure><p id="5e2a" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">然而，我仍然支持使用类别数据类型。一个原因是使用类别dtype是<strong class="jy hs">更安全</strong>和<strong class="jy hs">防呆</strong>。例如，下面的命令不是明智的选择，但在这样做时它不会发出任何警告。在“打字”你的数据之前，你必须仔细检查。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es pd"><img src="../Images/20c4eeada7f63e706e5ebc5b2f359b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TySaxEUiJTupdZW-2YZV5g.png"/></div></div></figure><p id="10ec" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">使用“category”dtype不会导致这样的问题。熊猫总是做出正确的选择来为你编码数据。</p><p id="74bb" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">另外，使用category dtype不会失去任何互操作性。我们仍然在读取具有原始子类名称而不是一些编码数字的数据集。</p><p id="2589" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">关于节省内存已经说得够多了。让我们继续下一节课，看看其他好处以及它对机器学习的重要性。(如果节省内存是category dtype唯一能做的事情，我不会卖它。😉)</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h1 id="7449" class="la lb hi bd lc ld ms lf lg lh mt lj lk ix mu iy lm ja mv jb lo jd mw je lq lr bi translated">为什么分类数据类型对机器学习很重要？</h1><p id="1512" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">如果机器学习包不能直接处理分类变量，传统上，有两种编码分类数据的惯例:标签编码和一次性编码。</p><p id="9a3b" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">(注意:理论上，机器学习模型使用分类数据可能没有任何问题，但是应用这种机器学习模型的包可能无法直接处理分类变量。例如，Sklearn中的随机森林模型不能处理分类数据，而随机森林算法本身对分类特征没有问题。)</p><h2 id="b780" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">标签编码</h2><p id="4c3e" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">以“brand_parse”为例。使用标签编码器时，我们将'华为'，'小米'…编码为' 0 '，' 1 '，…(int类型)。这是它的样子。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es pa"><img src="../Images/e937cf15512a157fdd2459a585760d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukdjkDmrL2aJMETa1jHJQw.png"/></div></div></figure><p id="0325" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这种编码方式的问题是，机器学习模型可能会错误解释编码标签的含义。换句话说，将原始的分类特征解释为序数(意思是:有顺序)，而它应该是名词性的(意思是:没有顺序)。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es pe"><img src="../Images/ca6441363c5e888b34f5ea8fb1e71768.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*OTZkVEAtb5QSjpO_BSYxTQ.jpeg"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">资源:模因</figcaption></figure><p id="812c" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">以品牌特色为例。如果华为编码为‘0’，小米编码为‘1’，那么说华为比小米‘品牌少’就没多大意义了。同样，如果小米的编码值比魅族小，我们也不应该认为小米比魅族“品牌差”。</p><p id="61b5" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">当不小心将分类特征编码为数字特征时，基于树的算法可能会错误地分割数据，认为编码数据中存在某些顺序。</p><h2 id="e425" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">一次热编码</h2><p id="5217" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">通过使用one-hot-encoding，我们将得到如下结果:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es pf"><img src="../Images/f29c8a1c52b76c791131d238af295c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MULQGue4lgqNejhLaNKaUQ.png"/></div></div></figure><p id="3b33" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这里我们也有一些问题。第一个问题是内存使用。如果使用密集矩阵对大型数据集进行一次热编码，很可能会占用大量内存。例如，在one-hot-encode之后，brand_parse将变成76列(有76个子类，假设您没有删除它们中的任何一个)。即使使用最轻的数据类型(int8或boolean ),它仍然会占用大量内存；想象一下，如果有超过76个子类。</p><p id="6048" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">有一些潜在的解决方案可以解决内存使用问题。</p><p id="bfe8" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hs">解决方案1 </strong>:使用稀疏矩阵</p><ul class=""><li id="8967" class="ls lt hi jy b jz ka kc kd kf ot kj ou kn ov kr lz ma mb mc bi translated">优点:节省空间</li><li id="8fa2" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">缺点:人类很难理解</li></ul><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es pg"><img src="../Images/c4a93812add02244c598d9be94e6396f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8JqxGZPC7xK9rWVMHHh1JA.png"/></div></div></figure><p id="dc2f" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jy hs">解决方案2 </strong>:分组和/或处理几个子类</p><ul class=""><li id="be6e" class="ls lt hi jy b jz ka kc kd kf ot kj ou kn ov kr lz ma mb mc bi translated">优点:节省空间，易于解读(看起来更干净)</li><li id="f5a7" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">缺点:难以决定分组或处理哪个子类，有丢失有价值信息的风险</li></ul><p id="7b88" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">此外，树算法不支持一次性热编码数据，因为它可能会生成稀疏的树。(有关更多信息，请查看此<a class="ae ks" href="https://towardsdatascience.com/one-hot-encoding-is-making-your-tree-based-ensembles-worse-heres-why-d64b282b5769" rel="noopener" target="_blank">链接</a>。)</p><h2 id="e5c7" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">基于树的机器学习模型的分类数据类型</h2><p id="43da" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">因为标签编码和一键编码都不是很好。我们做什么呢答案听起来非常简单:保持分类数据的原样。换句话说，直接处理它。(但是不好申请。)</p><p id="4807" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">lightgbm 是能够直接处理分类数据的Python库之一(并不多见)。这里我引用了lightgbm文档中关于“分类特性支持”的内容:</p><blockquote class="od"><p id="02ed" class="oe of hi bd og oh oi oj ok ol om kr dx translated">LightGBM通过整数编码的分类特征提供了良好的准确性。LightGBM应用<a class="ae ks" href="https://www.tandfonline.com/doi/abs/10.1080/01621459.1958.10501479" rel="noopener ugc nofollow" target="_blank"> Fisher (1958) </a>找到类别的最优分割，如这里所述的<a class="ae ks" href="https://lightgbm.readthedocs.io/en/latest/Features.html#optimal-split-for-categorical-features" rel="noopener ugc nofollow" target="_blank"/>。这通常比一键编码执行得更好。</p></blockquote><p id="3c84" class="pw-post-body-paragraph jw jx hi jy b jz on is kb kc oo iv ke kf op kh ki kj oq kl km kn or kp kq kr hb bi translated">(如果没听说过lightgbm，简短介绍一下。它是由微软开发的。在Kaggle的完成中很受欢迎。与xgboost、Catboost一起，lightgbm被认为是对表格数据进行机器学习的首选模型之一。(而神经网络对于非结构化数据更强大。)</p><p id="e0e2" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">顺便说一下，lightgbm Python库集成了四种不同的基于树的boosting模型，gbdt(传统梯度Boosting决策树)、rf(随机森林)、dart(droppets meet Multiple Additive Regression Trees)和goss(基于梯度的单侧采样)。它们都支持分类数据。你要做的是<code class="du nk nl nm nn b">astype('category')</code>。这比一次热编码简单得多。</p><h2 id="39f8" class="mx lb hi bd lc my mz na lg nb nc nd lk kf ne nf lm kj ng nh lo kn ni nj lq ho bi translated">最终音高</h2><p id="d876" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">将类别数据类型用于机器学习是有益，因为</p><ul class=""><li id="b661" class="ls lt hi jy b jz ka kc kd kf ot kj ou kn ov kr lz ma mb mc bi translated">它有助于节省空间，这意味着我们可以用手头有限的内存可用性和计算能力集成更多的信息。</li><li id="28d4" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">它使操作更有效，这意味着我们可以执行更多的迭代，从而更好地微调模型。</li><li id="c494" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">它使机器学习包能够直接处理分类变量，这有利于ML模型(特别是基于树的boosting模型)提取有用的特征，并防止过度拟合。</li></ul></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h1 id="f162" class="la lb hi bd lc ld ms lf lg lh mt lj lk ix mu iy lm ja mv jb lo jd mw je lq lr bi translated">讨论:总是使用“类别”？</h1><p id="2794" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">对于id类型、标签类型的数据，最好将其编码为“类别”。但是对于浮点数值类型，使用“category”数据类型可能不是一个好主意。而对于周期性数据，如一周中的某一天，我们不太清楚是否应该将它们编码为“0”、“1”、“2”、“6”(作为int)，或者“1”、“2”、“3”、“7”(作为int)，或者“sun”、“mon”、“tue”、“sat”(作为类别数据类型)。我们可能需要一些反复试验来确定哪种方法适合这种情况。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h1 id="b245" class="la lb hi bd lc ld ms lf lg lh mt lj lk ix mu iy lm ja mv jb lo jd mw je lq lr bi translated">警告:你仍然要做你的工作</h1><p id="575a" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">分类数据类型是好的，它可以帮你省去很多麻烦，加快机器学习过程，但是它做不了你的工作。例如，您仍然需要调整超参数。你仍然需要在合适的时候重组或者丢弃子类。</p><h1 id="31aa" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated">小贴士:泡菜</h1><p id="103a" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">当您试图保存数据集以备后用时，请保存它。它比另存为csv更快，更重要的是保持了熊猫的类型。否则，如果您将数据帧保存为csv，下次加载它时，您会发现数据类型又回到了int64、float64和object。换句话说，我们将失去迄今为止我们讨论过的所有好处。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es pb"><img src="../Images/7f792ac794ae7cfdf86c18b58ff7aa02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h71WBg9C1jpXxuwO4zUTUg.png"/></div></div></figure></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h1 id="9069" class="la lb hi bd lc ld ms lf lg lh mt lj lk ix mu iy lm ja mv jb lo jd mw je lq lr bi translated">这篇文章的要点</h1><p id="9d5f" class="pw-post-body-paragraph jw jx hi jy b jz lu is kb kc lv iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">在这篇文章中，我们讨论了很多关于Python中的“类别”数据类型。以下是一些要点。</p><ul class=""><li id="90f3" class="ls lt hi jy b jz ka kc kd kf ot kj ou kn ov kr lz ma mb mc bi translated">如何使用“类别”数据类型？就<code class="du nk nl nm nn b">astype('category')</code></li><li id="9d83" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">为什么要使用“类别”？节省内存(除了Gotchas情况)，加快操作性能(最有可能)，提高机器学习性能(没有科学证据，但有很好的理由这样做)。</li><li id="0edf" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">什么时候用？几乎总是，至少试一试。尽管有时它可能会占用更多空间，但从长远来看，它可以加快操作性能，并可以无缝集成到具有分类特征支持的机器学习模型中。</li><li id="36a2" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">但是，“类别”并不是灵丹妙药。试错和迭代是你的朋友。</li><li id="7093" class="ls lt hi jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">开始腌制。</li></ul></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="6e9a" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我希望你喜欢这篇文章。欢迎发表评论。下次见。</p><p id="3695" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">你可以通过下面的链接查看笔记本。</p><div class="ph pi ez fb pj pk"><a href="https://github.com/kefeimo/DataScienceBlog/blob/master/3.category_dtype/pandas_data_type_0628.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab dw"><div class="pm ab pn cl cj po"><h2 class="bd hs fi z dy pp ea eb pq ed ef hr bi translated">kefeimo/数据科学博客</h2><div class="pr l"><h3 class="bd b fi z dy pp ea eb pq ed ef dx translated">permalink dissolve GitHub是超过5000万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="ps l"><p class="bd b fp z dy pp ea eb pq ed ef dx translated">github.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py jq pk"/></div></div></a></div></div></div>    
</body>
</html>