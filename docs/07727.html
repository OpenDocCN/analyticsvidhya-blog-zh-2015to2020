<html>
<head>
<title>Part 2- A Beginners Guide to Time profiling in Python.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第2部分Python时间剖析初学者指南。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/part-2-a-beginners-guide-to-time-profiling-in-python-c56f71401b31?source=collection_archive---------19-----------------------#2020-07-05">https://medium.com/analytics-vidhya/part-2-a-beginners-guide-to-time-profiling-in-python-c56f71401b31?source=collection_archive---------19-----------------------#2020-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="2579" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">大家好，欢迎回来。如果你是从我的上一篇博客回来的，那么关于时间剖析已经有了相当多的背景，如果你还没有看完上一篇博客，我强烈建议你去看看，尽管这不是强制性的。</p></blockquote><p id="6f32" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated"><strong class="il hj">使用</strong> <code class="du jl jm jn jo b"><strong class="il hj">%lprun</strong></code> <strong class="il hj">进行时间剖析。</strong></p><p id="f587" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在我们<a class="ae jh" rel="noopener" href="/analytics-vidhya/a-beginners-guide-to-time-profiling-in-python-c2422c35faa7?source=friends_link&amp;sk=f35cabcf95a6c0073eaa84ac77e9c6cf">博客</a>的前一部分，我们学习了<code class="du jl jm jn jo b">ipython</code>魔法方法，即<code class="du jl jm jn jo b">%timeit and %%timeit</code>。我们用它们来计时python中的代码。在本系列的这一部分，我们将学习更多关于<code class="du jl jm jn jo b">line_profiler</code>的知识，并使用它进行更好的时间分析。</p><p id="b8d0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">当我们需要分析代码块所花费的总时间时,<code class="du jl jm jn jo b">%timeit</code>工作得很好。然而，当我们对每一行代码都使用它时，它就变得重复了。作为一名优秀的程序员，我们会寻找更聪明的方法。</p><p id="fa03" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">对于上述问题，我们可以使用一个名为<code class="du jl jm jn jo b"><a class="ae jh" href="https://github.com/rkern/line_profiler" rel="noopener ugc nofollow" target="_blank">line_profiler</a></code>的外部python模块。它用于逐行对代码进行时间分析。</p><p id="2f95" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">要使用pip安装<code class="du jl jm jn jo b">line_profiler</code>,我们可以在终端中运行<code class="du jl jm jn jo b">pip install line_profiler</code>。当你的代码块是在一个文件中定义的，而不是在一个笔记本或一些交互式的名称空间中定义的时候，它工作得最好。</p><p id="29ad" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们将在所有的演示中使用<code class="du jl jm jn jo b">ipython shell</code>。<br/>用于使用<code class="du jl jm jn jo b">line_profiler</code>包</p><ul class=""><li id="94e6" class="jp jq hi il b im in iq ir ji jr jj js jk jt jg ju jv jw jx bi translated">运行<code class="du jl jm jn jo b">ipython shell</code>中的<code class="du jl jm jn jo b">%load_ext line_profiler</code>。</li><li id="65a7" class="jp jq hi il b im jy iq jz ji ka jj kb jk kc jg ju jv jw jx bi translated">然后运行<code class="du jl jm jn jo b">%lprun -f &lt;name_of_function&gt; &lt;name_of_function&gt;()</code></li></ul><p id="39e3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">先看一个<code class="du jl jm jn jo b">line_profiler</code>的例子，然后我们就明白它是怎么工作的了。</p><p id="5616" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">为了进行演示，我们在主目录中创建了一个名为<code class="du jl jm jn jo b">line_profiler_demo.py</code>的python文件，并在我的文件中添加了以下代码块。</p><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="ff1a" class="kl km hi jo b fi kn ko l kp kq">def multiply_by_two(nums):<br/>    new_num = list()<br/>    for num in nums:<br/>        new_num.append(int(num) * 2)<br/>    return new_num</span></pre><p id="3943" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">让我们打开主目录中的<code class="du jl jm jn jo b">ipython shell</code>进行时间分析。</p><figure class="kd ke kf kg fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kr"><img src="../Images/6179553ea89578b5204a3bcebc21a4f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ph1XqW4RxCGyBNJRZFYKNg.png"/></div></div></figure><p id="8be7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">很明显，我们需要在python文件中创建一个函数，然后将其导入到<code class="du jl jm jn jo b">ipython shell</code>中，用<code class="du jl jm jn jo b">line_profiler</code>对该函数进行时间分析。</p><p id="10e1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们已经使用<code class="du jl jm jn jo b">random</code> python包生成了1000个随机数的列表，并将该列表保存到名为<code class="du jl jm jn jo b">random_numbers</code>的本地变量中。然后，我们将这个列表传递给我们的自定义函数<code class="du jl jm jn jo b">multiply_by_two(random_numbers)</code>。</p><p id="a99e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">对于概要分析，我们在ipython shell中编写了<code class="du jl jm jn jo b">%load_ext line_profiler</code>，因为我们使用了外部python库，即<code class="du jl jm jn jo b">line_profiler</code>。</p><p id="f2be" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们于是把<br/>叫做<code class="du jl jm jn jo b">%lprun -f multiply_by_two multiply_by_two(random_numbers).</code></p><p id="f440" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">现在让我们试着深入了解一下<code class="du jl jm jn jo b">%lprun</code>的输出。</p><ul class=""><li id="890d" class="jp jq hi il b im in iq ir ji jr jj js jk jt jg ju jv jw jx bi translated">在输出的开始，<code class="du jl jm jn jo b">Timer unit</code>给出了测量执行时间的单位，我们可以看到它是以微秒为单位报告的。</li><li id="154a" class="jp jq hi il b im jy iq jz ji ka jj kb jk kc jg ju jv jw jx bi translated"><code class="du jl jm jn jo b">Total time</code>给出了执行整个代码块所花费的总时间。</li><li id="5771" class="jp jq hi il b im jy iq jz ji ka jj kb jk kc jg ju jv jw jx bi translated"><code class="du jl jm jn jo b">Line</code>栏显示代码的行号。</li><li id="24cc" class="jp jq hi il b im jy iq jz ji ka jj kb jk kc jg ju jv jw jx bi translated"><code class="du jl jm jn jo b">Hits</code>列显示执行代码时点击特定行的次数。</li><li id="93c2" class="jp jq hi il b im jy iq jz ji ka jj kb jk kc jg ju jv jw jx bi translated"><code class="du jl jm jn jo b">Time</code>列显示了特定代码行所用的时间。</li><li id="16e4" class="jp jq hi il b im jy iq jz ji ka jj kb jk kc jg ju jv jw jx bi translated"><code class="du jl jm jn jo b">% Time</code>列显示每行代码的相对时间百分比。</li><li id="e92d" class="jp jq hi il b im jy iq jz ji ka jj kb jk kc jg ju jv jw jx bi translated"><code class="du jl jm jn jo b">Line Content</code>显示每行代码的内容。</li></ul><p id="09c7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们可以很容易地分析出，在我们的函数中，第4行，即<code class="du jl jm jn jo b">new_num.append(int(num)*2</code>占用了最大的时间百分比，即<code class="du jl jm jn jo b">61.3%</code>。</p><p id="a3c0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">本演示中使用的函数是一个非常简单的python函数。然而，在编写包含多行代码的复杂函数时，<code class="du jl jm jn jo b">line_profiler</code>在识别函数的执行时间瓶颈方面帮了我们很多。人们可以识别特定的代码行，并优化该代码行以获得更好的性能。</p><p id="4dcd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">太棒了。！！我们学到了另一个关于时间剖析的新东西。让我们在本系列的下一部分见面，学习python中更多的剖析方法。直到那时再见，继续学习。</p></div></div>    
</body>
</html>