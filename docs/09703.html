<html>
<head>
<title>CRUD WITH REACT HOOKS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有反应钩的污物</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/crud-with-react-hooks-a5b186b4732?source=collection_archive---------10-----------------------#2020-09-17">https://medium.com/analytics-vidhya/crud-with-react-hooks-a5b186b4732?source=collection_archive---------10-----------------------#2020-09-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0118b1913e84db4ef8daba69af302107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ddBma4hDT6orclNS"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@alexcpl?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="29d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些就是我们下面要讲的东西；</p><ul class=""><li id="b5ae" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">管理您的数据收集</li><li id="5948" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">了解flux如何与<strong class="ix hj"> <em class="kh">上下文</em> </strong> API一起工作</li><li id="d69e" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">自己用本地存储持久化数据。</li></ul><p id="aba6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之前，我在<a class="ae iu" rel="noopener" href="/@princewillchime43/crud-with-vanilla-javascript-ff1f54e93cf5?source=friends_link&amp;sk=2d27c1eca6cf57bfce6772e25dfa2a91"><strong class="ix hj"><em class="kh">vanilla JavaScript</em></strong></a><strong class="ix hj"><em class="kh"/></strong>中写过一篇关于<strong class="ix hj"><em class="kh">crud</em></strong>操作的文章，其中使用了一个产品列表应用程序来演示<strong class="ix hj"> <em class="kh">创建</em> </strong>、<strong class="ix hj"> <em class="kh">读取</em> </strong>、<strong class="ix hj"> <em class="kh">更新</em> </strong>和<strong class="ix hj"/></p><p id="bfb3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要再拖延了，让我们开始执行前面的任务吧。</p><p id="cbd3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">先决条件</em> </strong></p><ul class=""><li id="4cab" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">系统上安装的节点和npm</li><li id="25c7" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">了解HTML和JAVASCRIPT</li><li id="1da5" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">了解REACT的工作原理。</li></ul><p id="8655" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们创建一个新的react项目。在您的终端上运行以下命令:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="fe71" class="kr ks hi kn b fi kt ku l kv kw">cd Desktop</span><span id="9863" class="kr ks hi kn b fi kx ku l kv kw">npx create-react-app data_collection</span><span id="5b1f" class="kr ks hi kn b fi kx ku l kv kw">cd data_collection</span><span id="d08e" class="kr ks hi kn b fi kx ku l kv kw">code .</span></pre><p id="b23d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面，我们导航到我们的桌面文件夹，我们创建了一个名为<strong class="ix hj"><em class="kh">data _ collection</em></strong>的新react项目，我们最终在visual studio代码上打开了该项目。</p><p id="2a4b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经在visual studio代码上打开了我们的项目，让我们使用vscode终端运行它；</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="bf9b" class="kr ks hi kn b fi kt ku l kv kw">ctrl + ` //to open the vscode terminal</span><span id="290d" class="kr ks hi kn b fi kx ku l kv kw">npm start</span></pre><p id="60a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到项目并创建我们将在此项目中使用的<strong class="ix hj"> <em class="kh">上下文</em> </strong>组件。</p><p id="b092" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在终端上，将cd放入src文件夹，创建一个名为data_storage的文件夹，在其中创建我们将在本项目稍后使用的文件(组件)</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="ebba" class="kr ks hi kn b fi kt ku l kv kw">cd src</span><span id="8300" class="kr ks hi kn b fi kx ku l kv kw">mkdir data_storage</span><span id="855b" class="kr ks hi kn b fi kx ku l kv kw">cd data_storage</span><span id="84cc" class="kr ks hi kn b fi kx ku l kv kw">touch useContext.js form.js table.js thead.js tbody.js data_statistics.js</span></pre><p id="e4bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="ix hj"> <em class="kh"> useContext </em> </strong>组件内部，让我们创建我们的提供者。</p><p id="cd3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们先了解一下<strong class="ix hj"> <em class="kh"> context API </em> </strong>及其工作原理，然后再将其应用到我们的项目中。</p><p id="c8da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">上下文</em> </strong> <em class="kh">提供了一种通过组件树传递数据的方法，而不必在每一层手动向下传递</em> <strong class="ix hj"> <em class="kh">道具</em> </strong> <em class="kh">。— </em> <a class="ae iu" href="https://reactjs.org/docs/context.html#when-to-use-context" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="kh">反应文档</em> </strong> </a></p><p id="07d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">上下文</em> </strong> API持有一个<strong class="ix hj"> <em class="kh">提供者</em> </strong>和<strong class="ix hj"> <em class="kh">消费者</em> </strong>属性。provider属性包含一个名为<strong class="ix hj"> <em class="kh">的道具值</em> </strong>，我们将在其中传递我们希望子道具能够访问的值。下面是<strong class="ix hj"> <em class="kh">提供者</em> </strong>函数和<strong class="ix hj"> <em class="kh">上下文</em> </strong>值的截图，这些值将被传递给<strong class="ix hj"> <em class="kh">子道具</em> </strong></p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/758dcbc0fe8ea79295a5d9c90c2498c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*QLKifkBkPLvM8LJzZI9MWg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">创造环境</figcaption></figure><p id="7a70" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们创建了一个常量变量来保存我们的<strong class="ix hj"> <em class="kh">上下文</em> </strong>值。我们传递了一个数组，该数组包含一个包含七(7)个未定义函数的空对象。我们导入了useState、useEffect挂钩，我们将在项目的后面使用它们，导出了<strong class="ix hj"><em class="kh">collection context</em></strong>，以及<strong class="ix hj"> <em class="kh"> provider函数</em> </strong>，我们将在已知的时间内创建它们。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/f8b76e57b57d42e22536be55c784061e.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*ZtT7y0E4AkgQb-DlNiNrvg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">创建提供者功能</figcaption></figure><p id="ef88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如我所承诺的，截图是抱着<strong class="ix hj"> <em class="kh">提供者</em> </strong>功能的。我们声明了<strong class="ix hj"> <em class="kh">数据</em> </strong>(状态)选项，并将其传递给上下文<strong class="ix hj"> <em class="kh"> provider </em> </strong>的值props。</p><p id="f375" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们在app组件中导入context provider函数，并用它包装所有应该访问<strong class="ix hj"> <em class="kh">上下文</em> </strong> <strong class="ix hj"> <em class="kh">数组</em> </strong>的组件。</p><p id="0954" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">app组件应该如下图所示:</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es la"><img src="../Images/aaa82377caad677982550aa0e8a2522a.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*GncofGXkZ2gxvJr9YVmZ5w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">app.js文件</figcaption></figure><p id="a3c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在app组件中，我们导入了<strong class="ix hj"><em class="kh">data statistics</em></strong>组件(我们很快就会创建这个)，还有<strong class="ix hj"> <em class="kh"> collectionProvider组件</em> </strong>。</p><p id="74d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"><em class="kh">data statistics</em></strong>组件与collectionContext提供程序包装在一起，以便能够从子道具访问提供程序值</p><p id="7e7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们继续向导入到app组件的<strong class="ix hj"> <em class="kh">数据统计</em> </strong>组件添加一些代码。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/88252880fbae48f7d274f74ce6d681ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*tkl9gFLcXc3uqZdQDB9_Og.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">数据统计组件</figcaption></figure><p id="f62e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们导入了<strong class="ix hj"> <em class="kh">表</em> </strong>和<strong class="ix hj"> <em class="kh">表单</em> </strong>组件，它们作为其子组件返回。基本上，如果不使用<strong class="ix hj"> <em class="kh">上下文</em> </strong> API，我们会像传递<strong class="ix hj"> <em class="kh">道具</em> </strong>一样向下传递到<strong class="ix hj"> <em class="kh">表单</em> </strong>和<strong class="ix hj"> <em class="kh">表格</em> </strong>组件，鼓励数据单向流动，从顶部到最后一个子节点。</p><p id="65ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们创建将收集用户项目/集合的表单字段。</p><p id="5297" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="ix hj"> <em class="kh">表单</em> </strong>组件内部，我们添加下面的代码；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/4fe27c5dff983f578c444e0f3905e294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_MhuLqm8NQlXofw_j30wA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">form.js组件</figcaption></figure><p id="76f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们导入了保存<strong class="ix hj"> <em class="kh">上下文</em> </strong>值的<strong class="ix hj"> <em class="kh">集合上下文</em> </strong>和<strong class="ix hj"> <em class="kh">使用上下文</em> </strong>钩子API。</p><p id="0f3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在钩子中提取<strong class="ix hj"> <em class="kh">上下文</em> </strong>，上下文在<strong class="ix hj"><em class="kh">use context</em></strong>API内部传递。通过这样做，它赋予我们访问<strong class="ix hj"><em class="kh"/></strong>的<strong class="ix hj"> <em class="kh">提供者</em> </strong>的能力，这将类似于下面的代码，如果我们使用一个<strong class="ix hj"> <em class="kh">类组件</em> </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="644c" class="kr ks hi kn b fi kt ku l kv kw">&lt;collectionContext.consumer&gt;</span><span id="a16f" class="kr ks hi kn b fi kx ku l kv kw">{context =&gt; &lt;form onSubmit={context.handleSubmitFunc}&gt;&lt;input value={context.data.item}/&gt;</span><span id="c31e" class="kr ks hi kn b fi kx ku l kv kw">&lt;/form&gt;<br/>&lt;/collectionContext&gt;</span></pre><p id="0c0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像我之前说过的，上下文包含两个属性，称为<strong class="ix hj"> <em class="kh">提供者</em> </strong>和<strong class="ix hj"> <em class="kh">消费者</em> </strong>。定义值时，使用<strong class="ix hj"> <em class="kh">提供者</em> </strong>，而<strong class="ix hj"> <em class="kh">消费者</em> </strong>属性用于呈现<strong class="ix hj"> <em class="kh">提供者</em> </strong>。</p><p id="96a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果仔细观察上面的截图，会发现没有使用<strong class="ix hj"> <em class="kh">消费者</em> </strong>属性，而是使用了导入的<strong class="ix hj"> <em class="kh"> useContext </em> </strong>并在其中传递我们的上下文提供者。这使我们能够访问上下文提供者<strong class="ix hj"> <em class="kh">。数据</em> </strong>是这样从<strong class="ix hj"> <em class="kh">提供者</em> </strong>中析构出来的；</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5171" class="kr ks hi kn b fi kt ku l kv kw">const [data] = useContext(collectionContext)</span></pre><p id="2de9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">表单元素包含输入字段。将<strong class="ix hj"> d <em class="kh"> ata </em> </strong>属性分配给输入字段的值，还将一些函数传递给表单元素，一旦提交表单，这些函数将运行。</p><p id="48b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看这个函数是如何以及在哪里创建的。在useContext组件内部，让我们添加<strong class="ix hj"><em class="kh">handle change</em></strong>函数</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/11cd5d5a78526ee8922a4d92c9c57c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*w3j4zDI0tazD_8-90Pwbyw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">onChange功能</figcaption></figure><p id="d5eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh"> handleChange </em> </strong>功能是将用户收藏设置为状态。在该函数中，<strong class="ix hj"> <em class="kh">目标</em> </strong>被析构，以在输入字段每次改变时获取特定的输入字段。</p><p id="39a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh"> setData </em> </strong>类似于类组件中的<strong class="ix hj"> <em class="kh"> setState方法</em> </strong>。这是一个获取输入字段值的函数。它检查名称值是否在<strong class="ix hj"> <em class="kh">数据</em> </strong>(状态)中定义，如果是，它循环通过<strong class="ix hj"> <em class="kh">数据</em> </strong>并将输入值分配给与该输入字段的名称值相匹配的数据字段。</p><p id="cdde" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成这些后，现在让我们添加<strong class="ix hj"> <em class="kh"> handleChange </em> </strong>函数，该函数将在<strong class="ix hj"> <em class="kh"> provider </em> </strong>值中创建，如下所示；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es le"><img src="../Images/37e61a03a241ec1b7be1089e1df3d090.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*wdNHVBxUoLYtmLVTaFF9rw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">向value属性添加了句柄更改</figcaption></figure><p id="16dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在表单组件中，析构如下的<strong class="ix hj"> <em class="kh"> handleChange </em> </strong>函数。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/d9c2e1c2abb73f44c0210c829baf0f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*zg5PASJSYEWtH1RMUMss-g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">从useContext中析构handlechange</figcaption></figure><p id="d28b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面是一个<a class="ae iu" href="https://javascript.info/destructuring-assignment" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="kh">数组析构</em> </strong> </a> <strong class="ix hj"> <em class="kh">方法</em> </strong>，它用来从<strong class="ix hj"> <em class="kh"> </em> </strong>上下文中提取<strong class="ix hj"> <em class="kh">提供者</em> </strong>到<strong class="ix hj"> <em class="kh">子道具</em> </strong>。</p><p id="0462" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:<em class="kh">数组</em> </strong>使用析构方法是因为<strong class="ix hj"> <em class="kh">上下文提供者</em> </strong>持有一个<strong class="ix hj"> <em class="kh">数组</em> </strong>。阅读更多关于解构<strong class="ix hj"><em class="kh"/></strong><a class="ae iu" href="https://javascript.info/destructuring-assignment" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="kh">这里</em> </strong> </a>。</p><p id="acc7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，让我们创建如下所示的提交函数</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/dedcd0fe3dd8c65f009a88ba4fd6406c.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*e5d8J0bwN81Cq5dLRUt4kA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">从useContext中析构handleFormSubmit</figcaption></figure><p id="618f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，防止表单试图返回避免使用<strong class="ix hj"><em class="kh">e . prevent default</em></strong>方法，状态值从<strong class="ix hj"> <em class="kh">数据</em> </strong>中被<strong class="ix hj">析构。</strong></p><p id="975b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将<strong class="ix hj"><em class="kh"/></strong>的<strong class="ix hj"> <em class="kh">集合</em> </strong>属性展开，在里面增加了用户<strong class="ix hj"> <em class="kh">集合</em> </strong> ( <strong class="ix hj">用户表单值</strong>)。</p><p id="d8cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在useContext组件中，添加集合字段作为数据属性之一，如下所示；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/3922db02ca490d6cb128a16edc7ffd00.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*s8M4e6K_KhXrWEOTNEBiTQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">集合属性</figcaption></figure><p id="f6c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">集合</em> </strong>字段被条件化，我们检查<strong class="ix hj">存储数据</strong>是否存在，如果存在，我们将<strong class="ix hj"> <em class="kh">解析</em></strong><strong class="ix hj"><em class="kh">存储数据</em> </strong>。否则它将返回一个空数组。目前，<strong class="ix hj"> <em class="kh"> storageData </em> </strong>为空，因此集合将返回一个空的<strong class="ix hj"> <em class="kh">数组</em> </strong>。</p><p id="776c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经创建了<strong class="ix hj"><em class="kh">handleDataSubmit</em></strong>函数，让我们到浏览器看看我们到目前为止做了什么…</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/6468e782c756037cbb9a874e68fc089e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SS_5HQjXCqIe99BebFlmAw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">获取表单字段值</figcaption></figure><p id="715b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哇！我们的代码正在有效地工作。我们刚刚添加了一些值并打印这些值。查看控制台中的<strong class="ix hj"> <em class="kh">数据</em> </strong>对象，<strong class="ix hj"> <em class="kh">集合</em> </strong>数组保存着用户集合，<strong class="ix hj"> <em class="kh">数据</em> </strong>也保存着输入值。</p><p id="aca0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然<strong class="ix hj"> <em class="kh"> handleChange </em> </strong>和<strong class="ix hj"> <em class="kh"> handleSubmit </em> </strong>函数工作正常，让我们创建一个函数来处理总价计算。之后，我们将输入的总价设置为<strong class="ix hj"> <em class="kh">只读</em> </strong>。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/7b745b137b4953ca3773120612293986.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*auVLZWpqVTS1dF5ZP59GhA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">handleCalculate函数</figcaption></figure><p id="b752" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们创建了一个函数来处理每个集合的商品数量和价格的动态相乘。<strong class="ix hj"> <em class="kh">数字构造函数</em> </strong>用于将输入字段的值转换为纯数字。</p><p id="1786" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们检查<strong class="ix hj"><em class="kh"/></strong>字段是否已经有值，如果有，它将<strong class="ix hj"> <em class="kh">总变量</em> </strong>设置为<strong class="ix hj"> <em class="kh"> </em> </strong>状态(<strong class="ix hj"> <em class="kh">数据</em> </strong>)</p><p id="f770" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意</strong>:在<strong class="ix hj"><em class="kh"/></strong>上下文中声明的所有函数都被传递给<strong class="ix hj"> <em class="kh">提供者值</em> </strong> <strong class="ix hj"> <em class="kh">道具</em> </strong>，以便<strong class="ix hj"> <em class="kh">上下文提供者</em> </strong>组件的<strong class="ix hj"> <em class="kh">子道具</em> </strong>访问。</p><p id="fbb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从useContext中析构<strong class="ix hj"><em class="kh">handle calculation</em></strong>函数。因为我们希望<strong class="ix hj"> <em class="kh"> totalPrice </em> </strong>字段注意<strong class="ix hj"> <em class="kh"> price </em> </strong>字段中的变化，所以我们将把<strong class="ix hj"><em class="kh">handle calculate</em></strong>函数传递给<strong class="ix hj"> <em class="kh"> onInput </em> </strong>函数props of<strong class="ix hj"><em class="kh">price</em></strong>输入，如下所示。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/772fb0f1e609a8e3ff926155f6a98148.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*EHjCzGu0ULJa4w13dlheog.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">价格输入字段</figcaption></figure><p id="3ad3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续进行，<strong class="ix hj"> <em class="kh"> totalPrice </em> </strong>输入将不会在其中保存任何函数，物品价格和物品数量的结果被动态地设置给它。让我们看看下面的<strong class="ix hj"> <em class="kh">总价</em> </strong>输入字段。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/c9e490b095797225bff64260729af8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*lfabKQxGI6tdIFn80ehGAA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">总价输入字段</figcaption></figure><p id="8ada" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面没有传递任何函数，输入被改为只读<strong class="ix hj"><em class="kh"/></strong>，输入的<strong class="ix hj"> <em class="kh">只读</em> </strong>属性被设置为<strong class="ix hj"> <em class="kh">真</em> </strong>。<strong class="ix hj"> <em class="kh"> readOnly </em> </strong>方法限制用户直接向输入中添加值。</p><p id="0a2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">表单组件已经准备好，可以有效地工作了。让我们继续将用户集合保存到<a class="ae iu" rel="noopener" href="/@princewillchime43/local-storage-with-vanilla-javascript-c87e3923163a?source=friends_link&amp;sk=85673734d89b5926166023b806067643"> <strong class="ix hj"> <em class="kh">本地存储</em> </strong> </a>。</p><p id="cc82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">创建收藏</em> </strong></p><p id="fab9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<strong class="ix hj"> <em class="kh"> ctrl + p </em> </strong>在你的<strong class="ix hj"> <em class="kh"> vscode </em> </strong>中打开搜索文件提示框，快速搜索你想要打开的文件，在我们的例子中，就是useContext组件。</p><p id="ecd6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将创建一个<strong class="ix hj"><em class="kh">handleLocalStorage</em></strong>函数来帮助我们将用户集合添加到<strong class="ix hj"> <em class="kh">本地存储中。</em> </strong>下面是功能截图；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/dfc52387e13b5beccd899a59a9d31023.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*plwGzCQGpHSjGGKq3QQBiQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">将集合添加到本地存储</figcaption></figure><p id="a24f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"><em class="kh">handleLocalStorage</em></strong>是在<strong class="ix hj"> <em class="kh"> useEffect </em> </strong>函数中定义的<strong class="ix hj"> <em class="kh"> </em> </strong>。每当组件更新时，使用<strong class="ix hj"> <em class="kh"> useEffect </em> </strong>方法更新<strong class="ix hj"> <em class="kh">数据</em> </strong>。useEffect函数与<strong class="ix hj"> <em class="kh">类组件</em> </strong>中的<strong class="ix hj"><em class="kh">componentDidUpdate</em></strong>相同。</p><p id="fc3f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="ix hj"><em class="kh">handleLocalStorage</em></strong>函数中，集合字段被从<strong class="ix hj"> <em class="kh">数据(状态)中析构。</em> </strong>一个名为<a class="ae iu" href="https://javascript.info/try-catch" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="kh">try…catch</em></strong></a><strong class="ix hj"><em class="kh"/></strong>的错误处理方法用于在使用<a class="ae iu" rel="noopener" href="/@princewillchime43/local-storage-with-vanilla-javascript-c87e3923163a?source=friends_link&amp;sk=85673734d89b5926166023b806067643"> <strong class="ix hj"> <em class="kh">存储API setItem</em></strong></a><strong class="ix hj"><em class="kh">将<strong class="ix hj"> <em class="kh"> jsonState </em> </strong>设置到本地存储之前管理错误。</em> </strong></p><p id="d059" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">阅读收藏</em> </strong></p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/19ca5d97e21dc7b741af96d138a52829.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*4m2wQf5PatHh6PUG8Msfeg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">获取存储集合。</figcaption></figure><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/51767aa7b66b3381f49a53182d66e9c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*SsqqWa5grflyIuCBa6Ra0g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">将集合保存到表中</figcaption></figure><p id="5fef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们从本地存储中获取用户集合，并将其作为检查添加到集合字段中。每当组件更新时，<strong class="ix hj"> <em class="kh">会自动读取</em> </strong>用户数据。请看一个<a class="ae iu" href="https://res.cloudinary.com/hobbyluv07/video/upload/v1600014140/Screencast_from_13-09-2020_17_16_01_srtg9k.webm" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="kh">的演示这里</em> </strong> </a> <strong class="ix hj"> <em class="kh">。</em>T49】</strong></p><p id="9cdd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">更新收藏</em> </strong></p><p id="1b80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="ix hj"> <em class="kh">表格</em> </strong>组件中我们将导入<strong class="ix hj"> <em class="kh"> Thead </em> </strong>和<em class="kh"> Tbody </em> 组件，并将其作为表格子道具返回如下；</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/03bb83336e4e7896a7371ad1b30f7d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*BEAmfJlUwFb1cgZMBc_Aww.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">表格组件</figcaption></figure><p id="86b0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们给<strong class="ix hj"> <em class="kh"> Thead </em> </strong>组件添加一些代码，如下图所示</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/2c8a9e0ebba39be10a923928f7312b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*pCogG9yg1dGpoEQse2HSSg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">该表头组件</figcaption></figure><p id="a9d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"><em class="kh">head</em></strong>组件正在返回一个表行(<strong class="ix hj"> <em class="kh"> tr </em> </strong>)，该表行包含一个已声明的<strong class="ix hj"> <em class="kh"> headingArr </em> </strong>的循环。首先，检查<strong class="ix hj"> <em class="kh">集合</em> </strong>数组是否不为空。如果不是，则进行循环，最后从地图返回表格标题(<strong class="ix hj"> <em class="kh"> th </em> </strong>)。</p><p id="2ef0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们已经看到了表格标题是如何得到的，以及它是如何呈现的，那么让我们转到<strong class="ix hj"> <em class="kh"> Tbody </em> </strong>组件，用下面的屏幕截图检查一下。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/3b66650002975493cea5f82ffd012c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*VcZiLZSv1cgQNJyT9OSReQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">表体组件</figcaption></figure><p id="b361" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh"> Tbody </em> </strong>组件包含一个函数，该函数获取将被单击的每一行(<strong class="ix hj"> <em class="kh"> tr </em> </strong>)的索引和值。导出的值和索引将被设置为数据(<strong class="ix hj"> <em class="kh">状态</em> </strong>)</p><p id="372b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该组件正在返回保存有集合  <strong class="ix hj"> <em class="kh">数组</em> </strong>的循环的<strong class="ix hj"> <em class="kh"> tbody </em> </strong>，它正在返回一个表行(<strong class="ix hj"> <em class="kh"> tr </em> </strong>)和一个保存集合值的<strong class="ix hj"> <em class="kh">表数据(td) </em> </strong>。</p><p id="1a77" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们在下面的<strong class="ix hj"> <em class="kh"> useContext </em> </strong>组件中添加<strong class="ix hj"><em class="kh">handleEditData</em></strong>函数</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/f45b3285ec99c0146c945f8cf3a230e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*U1eiqGHfUJNoajS718_Dsg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">函数来处理集合的编辑</figcaption></figure><p id="f3e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">真是<strong class="ix hj"> <em class="kh"> </em> </strong>简单。一如既往，我会一步一步来。</p><p id="4156" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们循环存储数据以获得集合的索引，该集合将被点击用于<strong class="ix hj"> <em class="kh">更新</em> </strong>。我们移除了被点击的集合，并使用数组的拼接方法用<strong class="ix hj"> <em class="kh">数据</em> </strong>(状态)的当前数据更新它。反过来，更新后的集合被<strong class="ix hj"> <em class="kh">字符串化</em> </strong>并设置回本地存储</p><p id="c71d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，在获得<strong class="ix hj"> <em class="kh">更新的</em> </strong>存储集合之前一直刷新浏览器会有一点压力，我发现如果一旦存储数据被<strong class="ix hj"><em class="kh"/></strong>更新，数据可以同步就好了。为此，这就是为什么<strong class="ix hj"> <em class="kh">更新</em> </strong>集合同时<strong class="ix hj"> <em class="kh">更新</em> </strong>中的<strong class="ix hj"> <em class="kh">数据</em> </strong>(状态)</p><p id="25c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">删除收藏</em> </strong></p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/fbc72b0b3c79ece2a3fcb9e4079b24b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*7ABFOnJvbtgN8PUR94nrhw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">删除功能</figcaption></figure><p id="da21" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个截屏展示了从本地存储和表中删除集合的神奇之处。我们<strong class="ix hj"> <em class="kh">解析</em></strong><strong class="ix hj"><em class="kh">storage data</em></strong>，析构<strong class="ix hj"> <em class="kh"> keyHolder </em> </strong>，它保存了被点击的行的索引。</p><p id="dd22" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用名为<strong class="ix hj"> <em class="kh"> filter方法、</em> </strong>的数组方法循环通过<strong class="ix hj"> <em class="kh"> parseStorage </em> </strong>，该方法用于过滤掉被点击的集合，并将剩余的集合设置回<strong class="ix hj"> <em class="kh">本地存储。</em>T103】</strong></p><p id="710a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后但同样重要的是，在应用了<strong class="ix hj"> <em class="kh"> crud </em> </strong>操作之后，我发现这是一个管理<strong class="ix hj"> <em class="kh">集合</em> </strong>的所有缓存清除的好方法。为此，我将添加一个<strong class="ix hj"> <em class="kh"> handleCache </em> </strong>函数来帮助我们做到这一点。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/5f70ea7a81aca99c67f4b924a10287d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*SoDzA-Ai9OiPHWvftKUa2w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">缓存功能</figcaption></figure><p id="6041" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个快速的问题，我想非常简单。提醒你一下，如果你误按了它的按钮，这个功能会让你想发疯。</p><p id="180d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将<strong class="ix hj"> <em class="kh">数据</em> </strong>(状态<strong class="ix hj"> <em class="kh"> ) </em> </strong> <em class="kh">集合设置为空数组，最后，我们返回了</em><strong class="ix hj"><em class="kh">setItem</em></strong><em class="kh">方法来使我们能够将</em><strong class="ix hj"><em class="kh">storage data</em></strong>设置为空数组。</p><p id="c08a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们终于走到了桥的尽头，这是一件了不起的事情。对此，我愿意相信我们现在都可以使用<strong class="ix hj"> <em class="kh"> react钩子</em> </strong>和<strong class="ix hj"> <em class="kh">上下文API </em> </strong>创建一个<strong class="ix hj"><em class="kh"/></strong>。别忘了点击<strong class="ix hj"> <em class="kh">鼓掌图标</em> </strong>。</p><p id="f4ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">跟随<a class="ae iu" href="https://github.com/chibuike07/data_collection_react" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="kh"> me </em> </strong> </a>访问源代码，查看演示<a class="ae iu" href="https://chibuike07.github.io/data_collection_react/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="kh">这里</em> </strong> </a> <strong class="ix hj"> <em class="kh">。</em> </strong>关注我上我的<a class="ae iu" rel="noopener" href="/@princewillchime43"> <strong class="ix hj"> <em class="kh">中</em></strong></a><strong class="ix hj"><em class="kh"/></strong>想看更多我的牛逼文章，你也可以关注我上我的<a class="ae iu" href="https://www.linkedin.com/in/chime-princewill-3a2b1b192/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="kh">LinkedIn</em></strong></a><strong class="ix hj"><em class="kh">。</em> </strong>谢谢，我保持忠诚。</p></div></div>    
</body>
</html>