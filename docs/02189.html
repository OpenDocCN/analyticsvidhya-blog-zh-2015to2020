<html>
<head>
<title>Building a simple neural network in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C#构建一个简单的神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-simple-neural-network-in-c-7e917e9fc2cc?source=collection_archive---------2-----------------------#2019-12-05">https://medium.com/analytics-vidhya/building-a-simple-neural-network-in-c-7e917e9fc2cc?source=collection_archive---------2-----------------------#2019-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7790" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在没有AI库支持的情况下，用C#搭建一个简单的神经网络有多难？让我们来看看…</p><p id="cf45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那我为什么要这么做呢？</p><p id="ae42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我是一个. NET人，对这种语言的背景可以追溯到2012年。但是我从来没有真正尝试过用C#来构建一个人工智能代理，我最接近的一次尝试是在我实现一个GLPK解算器的时候，一个线性优化问题，这是我过去的工作之一，我们可以稍后再谈。</p><p id="98dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另外，我在大学的一个教授要求我这么做，所以我来了…</p><p id="55ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我想通过文章<a class="ae jf" rel="noopener" href="/technology-invention-and-more/how-to-build-a-simple-neural-network-in-9-lines-of-python-code-cc8f23647ca1">如何用9行Python代码</a>构建一个简单的神经网络来感谢<a class="jd je ge" href="https://medium.com/u/dbe41548e496?source=post_page-----7e917e9fc2cc--------------------------------" rel="noopener" target="_blank">米洛·斯潘塞-哈珀</a>。在这个探索过程中，我用这篇文章作为指南，我真的建议你在开始这篇文章之前先阅读这篇文章。</p><h1 id="1704" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">神经网络的一点概述</h1><p id="756a" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">这种人工智能方法试图模仿自然大脑处理信息以产生行动的方式。所以人工神经网络试图复制大脑神经元和突触。</p><p id="f48a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">人工神经网络中的神经元被组织成加权图，其中每个节点是一个神经元，加权分支代表突触。</p><p id="7fe1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">人工神经网络由多层神经元组成，可以是输入层、隐含层和输出层。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es kj"><img src="../Images/9cc38a744ea1299021b7d7927cb686c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/0*WQWF0qAtR7miZmnj.png"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated"><a class="ae jf" href="https://www.innoarchitech.com/blog/artificial-intelligence-deep-learning-neural-networks-explained" rel="noopener ugc nofollow" target="_blank">https://www . innoarchitech . com/blog/人工智能-深度学习-神经网络-解释</a></figcaption></figure><p id="4ef9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输入层是智能体的传感器，它们感知环境。一个人工神经网络代理只有一个输入层，但是可以创建互连的代理，将一个代理的输出连接到另一个代理的输入。</p><p id="322e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隐藏层将处理输入层发送的数据，一个代理可以根据需要有多个隐藏层。</p><p id="e27a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出层将生成我们的结果。</p><h2 id="3e0f" class="kv jh hi bd ji kw kx ky jm kz la lb jq iq lc ld ju iu le lf jy iy lg lh kc li bi translated">神经元</h2><p id="9672" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">为了更好地理解人工神经网络是如何工作的，我们需要更深入地了解神经元的功能。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es lj"><img src="../Images/8f4378cca4098059fdfd4eea570f88d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*To0CuzNiwWrSIW0jXezvLA.png"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated"><a class="ae jf" href="https://www.innoarchitech.com/blog/artificial-intelligence-deep-learning-neural-networks-explained" rel="noopener ugc nofollow" target="_blank">https://www . innoarchitech . com/blog/artificial-intelligence-deep-learning-neural-networks-explained</a></figcaption></figure><p id="9c04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的神经元都使用上图的概念。</p><ol class=""><li id="a789" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">每一个突触(用X1…Xn表示)都有一个权重(用W1…Wn表示)。</li><li id="6b22" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">神经元会将所有突触的权重乘以输入值，然后将它们相加。</li><li id="c1f0" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">偏置值(由b表示)用于延迟神经元的激活。这是触发阈值的最小值。</li><li id="a248" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">突触的和值+偏差(由Z表示)将用于激活函数。</li><li id="a9df" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">激活函数用于将求和结果归一化为简单的1和0结果，1 =激活0 =非激活</li><li id="daec" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">激活函数的结果将决定神经元是否激活。</li><li id="a637" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">如果神经元变得活跃，另一个神经元可以接收另一个突触，或者如果这是输出层，我们就有了结果。</li></ol><h2 id="8824" class="kv jh hi bd ji kw kx ky jm kz la lb jq iq lc ld ju iu le lf jy iy lg lh kc li bi translated">激活功能</h2><p id="5a71" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">大多数神经网络算法的例子将使用sigmoid作为激活函数。</p><p id="9012" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是为什么呢？</p><blockquote class="ly lz ma"><p id="d604" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">我们之所以用sigmoid函数，主要是因为它存在于<strong class="ih hj"> (0到1)之间。</strong>因此，它特别用于我们必须<strong class="ih hj">预测概率</strong>作为输出的模型。由于任何事情的概率只存在于<strong class="ih hj"> 0和1之间，</strong> sigmoid是正确的选择。</p></blockquote><p id="b8d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我从SAGAR SHARMA 写的这篇伟大的文章中摘录了这段文字，你可以在这里找到完整的文章<a class="ae jf" href="https://towardsdatascience.com/activation-functions-neural-networks-1cbd9f8d91d6" rel="noopener" target="_blank">。</a></p><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es mf"><img src="../Images/65a4683d48ec922540a81ff6f0e1a748.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*TLu6oQen3SYSNRMl"/></div></figure><h2 id="fb71" class="kv jh hi bd ji kw kx ky jm kz la lb jq iq lc ld ju iu le lf jy iy lg lh kc li bi translated">培训步骤</h2><ol class=""><li id="defd" class="lk ll hi ih b ii ke im kf iq mg iu mh iy mi jc lp lq lr ls bi translated">在训练开始之前，程序需要知道给定一组输入后的预期输出。</li><li id="0fcb" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">每一个突触都有重量。一开始，这个权重通常是一个随机数。</li><li id="e8f8" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">当程序开始分析算法给出的输出时，它将与预期输出的期望值进行比较。</li><li id="e77b" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">训练函数将对权重执行很小的调整，以补偿输出的误差。</li><li id="4fae" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">重复很多次，然后你的神经网络就训练好了。</li></ol><p id="4b18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里委托的事情是，训练的知识仅仅停留在突触的重量上。</p><h2 id="9244" class="kv jh hi bd ji kw kx ky jm kz la lb jq iq lc ld ju iu le lf jy iy lg lh kc li bi translated">但是算法怎么知道需要调整多少权重呢？</h2><p id="f2f2" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">嗯……当然我们有一个公式，它有一个名字,<strong class="ih hj">误差加权导数公式</strong></p><p id="8e34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你研究一下这个，你会发现一些非常可怕的东西，真的…</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/393bc9e9666d8e5378dc800a8251d9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tGrsCP2TwqqRMGJidkt4bg.png"/></div></div></figure><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es mo"><img src="../Images/8de82e8e5c76ec6487da5ccb7a77d8c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*leCbNlmjom64Spwp46s1Bg.png"/></div></figure><p id="2b64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我想保持简单……所以我对米洛·斯潘塞-哈珀的文章中的信息做了一个总结。</p><p id="de69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终公式由下式给出:</p><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es mp"><img src="../Images/306ee6b196ea650335da709f14d91a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*5WlsycgIB3mSdoeywmIPVQ.png"/></div></figure><ol class=""><li id="7f0b" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">调整权重是需要添加到突触的实际权重的值。</li><li id="1541" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">误差由预期结果和实际结果之差给出，因此<em class="mb">误差=目标输出-实际输出</em></li><li id="c323" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">输入是实际的输入值。它可能是1或0。如果输入为0，那么所有的公式将自动取消，如果输入为1，那么公式可以计算并生成调整。</li><li id="aeb3" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">最后一部分是sigmoid曲线的梯度，由下式给出</li></ol><p id="846b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mb"> (1减去输出的当前值)乘以输出的当前值。</em></p><h1 id="32ef" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">让我们开始编码吧…</h1><p id="1b93" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">这将是一个简单的编码，我们不需要一个花哨的界面。因此，我们将使用以下命令创建一个. net核心控制台应用程序。</p><pre class="kk kl km kn fd mq mr ms mt aw mu bi"><span id="12fe" class="kv jh hi mr b fi mv mw l mx my"><em class="mb">dotnet new console</em></span></pre><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mz"><img src="../Images/354c0b18b694e4ca4b7a98ac85f5b539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AxkNvAyuyvIJ-sm7bAi_bw.png"/></div></div></figure><p id="b0ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了一个git存储库来保存代码，你可以通过这个<a class="ae jf" href="https://github.com/lschmittalves/simple-neural-network" rel="noopener ugc nofollow" target="_blank">链接</a>来访问</p><p id="f60f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们用C#编写的一个简单神经网络的最终代码，你可以从GitHub克隆这个库，并在克隆的文件夹中运行follow命令。</p><pre class="kk kl km kn fd mq mr ms mt aw mu bi"><span id="c278" class="kv jh hi mr b fi mv mw l mx my"><em class="mb">dotnet run</em></span></pre><div class="na nb ez fb nc nd"><a href="https://github.com/lschmittalves/simple-neural-network/blob/master/Program.cs" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">lschmittalves/简单神经网络</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr kp nd"/></div></div></a></div><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="ns nt l"/></div></figure><h1 id="3c7b" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated"><strong class="ak">结果</strong></h1><p id="bbd4" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">为了测试，我使用了米洛·斯潘塞-哈珀在他的文章中使用的同一组数据。</p><p id="5042" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">桌子上惨叫一声。您可以注意到，当第一个输入列的值为1时，输出也是1。</p><p id="053e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们知道最后一行的答案是1。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es nu"><img src="../Images/eb56e42f1e1a566c3950ed07f9300c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/0*4qMH4jw8VGcspI-T.png"/></div></figure><p id="c317" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们用这个表训练我们的算法，然后要求最后一行的答案，该值应该是1或非常接近1的值。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es nv"><img src="../Images/be8dad880158bcbb54cf6b906446e851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cb8b_VdYtea3gJFww9Ph4Q.png"/></div></div></figure><p id="0fa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们做到了，经过很多努力，在没有numpy支持的情况下，用C#编写了代码，我们真的做到了。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es nw"><img src="../Images/09c683a77221a81d0c1fa282cf567885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OnlwAkwkp3yEheE5nzjaCQ.png"/></div></div></figure><h1 id="e958" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">最后的想法</h1><p id="282c" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq kg is it iu kh iw ix iy ki ja jb jc hb bi translated">不使用任何辅助库是一种令人迷惑的事情，用所有的矩阵相乘和转置矩阵。</p><p id="1eb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里使用python和numpy库至少可以节省我们一半的精力。</p><blockquote class="nx"><p id="06c3" class="ny nz hi bd oa ob oc od oe of og jc dx translated">有可能在没有库支持的情况下实现一个神经网络吗？</p></blockquote><p id="20e5" class="pw-post-body-paragraph if ig hi ih b ii oh ik il im oi io ip iq oj is it iu ok iw ix iy ol ja jb jc hb bi translated">是的，它是。但是值得努力吗？嗯……我会说不。我需要4倍多的代码来实现python在米洛·斯潘塞-哈珀的文章中所做的事情。这还不算评论…</p><p id="cec3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一件事，当你做计算的时候，注意圆括号。我花了一天时间想明白为什么算法的结果会错得这么离谱，然后我发现我忘了sigmoid函数上的一对括号。</p></div></div>    
</body>
</html>