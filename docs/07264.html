<html>
<head>
<title>Automatic Random Forest Imputer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动随机森林估算器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/automatic-missingvalueshandler-library-with-a-random-forest-d8d380da1fe0?source=collection_archive---------7-----------------------#2020-06-19">https://medium.com/analytics-vidhya/automatic-missingvalueshandler-library-with-a-random-forest-d8d380da1fe0?source=collection_archive---------7-----------------------#2020-06-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="139c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在一般机器学习任务中使用Python自动处理空单元格</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f5d496825c4e12b98a7f190aa8818711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SWH2hQcAEH4kBfUuBuCtEA.jpeg"/></div></div></figure><blockquote class="jj"><p id="3b88" class="jk jl hi bd jm jn jo jp jq jr js jt dx translated">定型集和测试集的缺失值替换</p></blockquote><p id="df17" class="pw-post-body-paragraph ju jv hi jw b jx jy ij jz ka kb im kc kd ke kf kg kh ki kj kk kl km kn ko jt hb bi translated">您想要在机器学习(监督学习任务)中启动一个新项目，但不幸的是，您注意到您的数据集在一个、两个或多个样本中包含缺失值(在要素或目标变量中也是如此)。摆脱它们是一个快速但鲁莽的解决方案，可能会损害您正在构建的模型的性能。这就是设计和实现一个库的原因:通过利用随机森林的邻近定义，作为一种自动替换空单元的方式。</p><p id="47fd" class="pw-post-body-paragraph ju jv hi jw b jx kp ij jz ka kq im kc kd kr kf kg kh ks kj kk kl kt kn ko jt hb bi translated">该模块可通过<strong class="jw hj"> pip </strong>获得。您可以使用<code class="du ku kv kw kx b"><strong class="jw hj">pip install MissingValuesHandler</strong></code>下载这个库，并在数据集上测试它。事不宜迟，我们将开始简要说明如何利用它。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="0a46" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">属国</h1><ul class=""><li id="e144" class="lx ly hi jw b jx lz ka ma kd mb kh mc kl md jt me mf mg mh bi translated">Python(版本&gt; =3.6)</li><li id="33f2" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated">Numpy</li><li id="bde9" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated">熊猫</li><li id="8d3c" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated">马特普利卜</li><li id="687b" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated">Sklearn</li><li id="e722" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated">张量流(版本&gt; =2.0)</li></ul><h1 id="3e0f" class="lf lg hi bd lh li mn lk ll lm mo lo lp io mp ip lr ir mq is lt iu mr iv lv lw bi translated">怎么用？</h1><p id="c3fc" class="pw-post-body-paragraph ju jv hi jw b jx lz ij jz ka ma im kc kd ms kf kg kh mt kj kk kl mu kn ko jt hb bi translated"><strong class="jw hj"><em class="mv">MissingValuesHandler</em></strong>是在<em class="mv"> Scikit-Learn </em>之上用<em class="mv"> Python </em>编写的库。它能够自动检测我们的数据集中的特征类型(分类还是数字),并决定随机森林分类器或回归器是否适合该任务。例如，让我们替换以下数据集中的<em class="mv"> nan值</em>:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/1ecac74f881ac616ac0f93dda7254f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPJsfCE_DzOy-vPZhc6Rjw.jpeg"/></div></div></figure><p id="42ff" class="pw-post-body-paragraph ju jv hi jw b jx kp ij jz ka kq im kc kd kr kf kg kh ks kj kk kl kt kn ko jt hb bi translated">这个数据集只是一个简单的信用评分案例:这是一个分类任务。我们将通过应用以下脚本来替换丢失的值:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="fd03" class="pw-post-body-paragraph ju jv hi jw b jx kp ij jz ka kq im kc kd kr kf kg kh ks kj kk kl kt kn ko jt hb bi translated"><strong class="jw hj"> 1 </strong> -我们首先需要<strong class="jw hj">导入</strong>库并实例化它。</p><p id="77ac" class="pw-post-body-paragraph ju jv hi jw b jx kp ij jz ka kq im kc kd kr kf kg kh ks kj kk kl kt kn ko jt hb bi translated"><strong class="jw hj"> 2- </strong> <strong class="jw hj">运行时</strong>(训练你的算法):</p><ul class=""><li id="debe" class="lx ly hi jw b jx kp ka kq kd mz kh na kl nb jt me mf mg mh bi translated">我们可以用熊猫来读取数据集。</li><li id="1e55" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated">我们必须设置<strong class="jw hj"><em class="mv">missing _ data _ handler</em></strong>对象将要检测和使用的随机森林的参数。除了<strong class="jw hj"><em class="mv">additional _ estimator</em>，</strong>之外，您可以随意使用随机森林的所有常用参数(分类器和回归器)，当模型的开箱得分不够高时，这些参数允许我们添加任意多的树。你不用担心<strong class="jw hj"> <em class="mv">判据</em> </strong> (mse，gini或者熵)，模块里已经搞定了。</li><li id="a8d7" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated">该算法使用随机森林来定义一个<strong class="jw hj"> <em class="mv">邻近矩阵</em> </strong>。该矩阵将用于计算新值的<strong class="jw hj"> <em class="mv">加权平均值</em> </strong>。</li><li id="0e5c" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated">如果你没有足够的计算能力，我建议你从低数量的<strong class="jw hj"> <em class="mv">估值器</em> </strong>开始。然后，随着训练的继续，您可以决定添加少量的树，直到算法达到其最高的预算外得分。</li></ul><p id="05ec" class="pw-post-body-paragraph ju jv hi jw b jx kp ij jz ka kq im kc kd kr kf kg kh ks kj kk kl kt kn ko jt hb bi translated"><strong class="jw hj"> 3- </strong>方法<strong class="jw hj">训练</strong>是该类的主要功能。除其他外，它有三个重要论点:</p><ul class=""><li id="2b0a" class="lx ly hi jw b jx kp ka kq kd mz kh na kl nb jt me mf mg mh bi translated"><strong class="jw hj"> forbidden_variables_list </strong>:不需要编码的变量会放在那个列表里。如果一个变量已经被编码，你必须把它的名字放在列表上，因为默认情况下算法会对每个分类变量进行一次热编码(因为sklearn的树不能直接处理分类数据)。</li><li id="8714" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated"><strong class="jw hj"> ordinal_variables_list </strong>:适用于顺序分类变量编码。</li><li id="1ef3" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated"><strong class="jw hj">n _ iterations _ for _ convergence</strong>:n轮后检查预测值是否收敛。如果没有达到收敛，我们进行另一轮，如果每个值都收敛或者没有改进，训练将停止。未收敛的值将分别替换为分类变量和数值变量的众数和中位数。如果满足收敛，用邻近矩阵计算的<strong class="jw hj"> <em class="mv">加权平均值</em> </strong>将替换空单元。</li><li id="db57" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated">根据我的经验，<strong class="jw hj"> 4或5 </strong>回合通常就够了。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nc"><img src="../Images/de1d8e2fffe345f21669d3ef4a1b0ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*mnz-NtuNsdHU2pl46CyUBw.jpeg"/></div><figcaption class="nd ne et er es nf ng bd b be z dx translated">训练期间</figcaption></figure><p id="8488" class="pw-post-body-paragraph ju jv hi jw b jx kp ij jz ka kq im kc kd kr kf kg kh ks kj kk kl kt kn ko jt hb bi translated"><strong class="jw hj"> 4-获得结果</strong></p><ul class=""><li id="a79f" class="lx ly hi jw b jx kp ka kq kd mz kh na kl nb jt me mf mg mh bi translated">我们得到了新的数据集</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nh"><img src="../Images/b9d6b77376e835fd95dfba47a76b6516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MFKPWiGoXRwNXoBgHn47LQ.jpeg"/></div></div><figcaption class="nd ne et er es nf ng bd b be z dx translated">具有新值的数据集</figcaption></figure><ul class=""><li id="62bc" class="lx ly hi jw b jx kp ka kq kd mz kh na kl nb jt me mf mg mh bi translated">我们还可以得到对象已经计算并使用的最后一个<strong class="jw hj"> <em class="mv">邻近矩阵</em> </strong>:</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ni"><img src="../Images/9a8551ca2bb15e0bf6261aa6a12f1dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7l3BOCff6odV7JjxK0Mnrg.jpeg"/></div></div><figcaption class="nd ne et er es nf ng bd b be z dx translated">邻近矩阵</figcaption></figure><h1 id="4a08" class="lf lg hi bd lh li mn lk ll lm mo lo lp io mp ip lr ir mq is lt iu mr iv lv lw bi translated">评估收敛性</h1><blockquote class="nj nk nl"><p id="cf47" class="ju jv mv jw b jx kp ij jz ka kq im kc nm kr kf kg nn ks kj kk no kt kn ko jt hb bi translated">对于<strong class="jw hj"><em class="hi"/></strong>数值，如果它们各自的标准差在<strong class="jw hj">范围【0，1】<em class="hi"/></strong><em class="hi">内，则达到收敛，在</em>上已经对它们进行了最后n次迭代。</p><p id="6084" class="ju jv mv jw b jx kp ij jz ka kq im kc nm kr kf kg nn ks kj kk no kt kn ko jt hb bi translated">对于<strong class="jw hj"> <em class="hi">分类值</em> </strong>，如果模态<strong class="jw hj">固定</strong>，则达到收敛。</p></blockquote><p id="e19b" class="pw-post-body-paragraph ju jv hi jw b jx kp ij jz ka kq im kc kd kr kf kg kh ks kj kk kl kt kn ko jt hb bi translated">我们可以在字典里找到，已经收敛的加权平均值。我们甚至可以画出n次迭代后它们的演化图。在<strong class="jw hj"> <em class="mv">行550 </em> </strong>和<strong class="jw hj"> <em class="mv">列‘loan amount’</em></strong>的值不稳定，甚至在  20 <strong class="jw hj"> <em class="mv">迭代</em> </strong>之后也不收敛<strong class="jw hj"> <em class="mv">。该值的范围很宽[144，150]。在最后5次迭代中，标准差是<strong class="jw hj"> <em class="mv">大于1 </em> </strong>。<strong class="jw hj"> <em class="mv">中值</em> </strong>已被用作替换。</em></strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es np"><img src="../Images/eb21353dc6ceac28032ea628ed2157c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*Gijv21Dxa-b75n9o7HDsdA.jpeg"/></div></figure><p id="94e2" class="pw-post-body-paragraph ju jv hi jw b jx kp ij jz ka kq im kc kd kr kf kg kh ks kj kk kl kt kn ko jt hb bi translated">对于在<strong class="jw hj"> <em class="mv">行435 </em> </strong>和<strong class="jw hj"> <em class="mv">列‘loan amont’</em></strong>的值，情况并非如此。该值变化的范围[144，145]较小。该值只需要<strong class="jw hj"> <em class="mv"> 5次迭代</em> </strong>就可以收敛到<strong class="jw hj"> <em class="mv"> 145 </em> </strong>，标准差为<strong class="jw hj"> <em class="mv"> 0.49 </em> </strong>。<strong class="jw hj"> <em class="mv">加权平均值</em> </strong>，等于145，已作为替代。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nq"><img src="../Images/5ba9e8a09164b40d2e2306acc0070cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*5IepMnpLJyuMurDlos8-Vw.jpeg"/></div></figure><h1 id="415a" class="lf lg hi bd lh li mn lk ll lm mo lo lp io mp ip lr ir mq is lt iu mr iv lv lw bi translated">不收敛值的提示</h1><ul class=""><li id="c8b3" class="lx ly hi jw b jx lz ka ma kd mb kh mc kl md jt me mf mg mh bi translated">你可以用更多的树重新开始这个过程，并随着训练的进行增加一些。</li><li id="3be6" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated"><strong class="jw hj"><em class="mv">training _ resilience</em></strong>是一个参数，它让算法知道它必须保持搜索多少次与在最后一组迭代中没有收敛的剩余值有关的收敛。它必须大于或等于2。例如，如果它被设置为3，该算法将继续进行3组以上的迭代(3次以上的机会),并将评估剩余值是否已经减少。如果它们减少了，算法将追求它的标准目的。如果不是这种情况，它将完全停止后，这三个机会，和模式和中位数将被用来作为替代。</li><li id="097d" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated">您可以在引导时使用其他超参数，例如<strong class="jw hj"><em class="mv">min _ sample _ split</em></strong>，<strong class="jw hj"><em class="mv">min _ samples _ leaf</em></strong>，<strong class="jw hj"> <em class="mv"> max_features </em> </strong>等等</li></ul><p id="bfd0" class="pw-post-body-paragraph ju jv hi jw b jx kp ij jz ka kq im kc kd kr kf kg kh ks kj kk kl kt kn ko jt hb bi translated">就是这样！您可以在数据集上尝试这种算法，看看它是如何工作的。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><p id="a969" class="pw-post-body-paragraph ju jv hi jw b jx kp ij jz ka kq im kc kd kr kf kg kh ks kj kk kl kt kn ko jt hb bi translated">算法的参考:</p><ul class=""><li id="4a35" class="lx ly hi jw b jx kp ka kq kd mz kh na kl nb jt me mf mg mh bi translated">[1]:利奥·布雷曼的网站。<em class="mv">兰登森林【莱奥布雷曼】和阿黛尔卡特勒</em>stat.berkeley.edu/~breiman/RandomForests/cc_home.htm<em class="mv">T42</em>T45】</li><li id="6606" class="lx ly hi jw b jx mi ka mj kd mk kh ml kl mm jt me mf mg mh bi translated">[2]: <em class="mv"> </em>约翰·斯塔默在Youtube频道StatQuest上的视频。<a class="ae nr" href="https://www.youtube.com/watch?v=sQ870aTKqiM" rel="noopener ugc nofollow" target="_blank"> <em class="mv">随机森林第二部分:缺失数据和聚类</em> </a></li></ul></div></div>    
</body>
</html>