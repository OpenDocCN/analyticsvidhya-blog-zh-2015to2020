<html>
<head>
<title>PersonAttributes Classifier — training a multi-task neural network to detect attributes like age, gender, …, emotion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人物属性分类器——训练一个多任务神经网络来检测年龄、性别、情感等属性</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/personattributes-classifier-training-a-multi-task-neural-network-to-detect-attributes-like-age-a3b877d21d22?source=collection_archive---------12-----------------------#2020-01-21">https://medium.com/analytics-vidhya/personattributes-classifier-training-a-multi-task-neural-network-to-detect-attributes-like-age-a3b877d21d22?source=collection_archive---------12-----------------------#2020-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这项挑战的目标是从一张图像中检测一个人的<code class="du jd je jf jg b">gender, age, weight, carryingbag, footwear, emotion, bodypose</code>和<code class="du jd je jf jg b">imagequality</code>。任何神经网络架构都是允许的，但<strong class="ih hj">训练必须从头开始，这意味着没有预先训练的权重，也没有迁移学习。为了成功地完成这一点，我们需要一个具有多个输出的卷积神经网络，每个输出服务于一个预测。<br/>对于这个挑战，我最终使用了一个<a class="ae jh" href="https://towardsdatascience.com/understanding-and-visualizing-densenets-7f688092391a" rel="noopener" target="_blank"> <strong class="ih hj"> Densenet121 </strong> </a>架构，但是任何具有跳过连接的现代并行网络都应该提供良好的结果。</strong></p><p id="08c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<strong class="ih hj"> Keras </strong>完成训练。我也在tensorflow 中尝试了<strong class="ih hj">单循环策略和循环LR，但是发现keras解决方案简单有效。<br/>在我们了解建议的网络架构之前，让我们先来看看我们正在处理的数据集。</strong></p><p id="9a04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以从<a class="ae jh" href="https://drive.google.com/file/d/1Abe336Tzvi8BC6bVGTN3unlAtj1XdiTT/view" rel="noopener ugc nofollow" target="_blank"> person-data-gdrive </a>下载数据集进行实验。<br/>还要找到<a class="ae jh" href="https://github.com/baronrogers5/person-classifier" rel="noopener ugc nofollow" target="_blank">person-classifier-github-link</a>，里面有可以直接在<a class="ae jh" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> google-colab </a>上运行的笔记本。如果你在colab上运行笔记本，只需确保下载数据并将其作为<code class="du jd je jf jg b">hvc_data.zip</code>放入你的谷歌硬盘的<code class="du jd je jf jg b">My Drive</code>中。<br/>下面显示的所有需要的文件都在<code class="du jd je jf jg b">hvc_data.zip</code>文件中。</p></div><div class="ab cl ji jj gp jk" role="separator"><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn"/></div><div class="hb hc hd he hf"><h1 id="604e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">可视化数据</h1><p id="acaf" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">每个图像都根据下面给出的数据框架进行标记:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/14b2790a6296e02d36e086ecbc757ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*juuiP2QI9uxB9zX1.png"/></div></div></figure><p id="0f21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一些图像的例子。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es le"><img src="../Images/ee3069fe4dcd9ba3e4d71b15dee5e28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p9CVXmSLlcMUniET.png"/></div></div></figure><p id="9d25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看每个类别所有可能的预测</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="0846" class="jp jq hi bd jr js lh ju jv jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km bi translated">查看网络的头部</h1><p id="8be5" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">正如所承诺的，让我们看看网络的头部(输出到达的地方)，这样我们可以更好地理解代码。为了张贴更清晰的图像，有些连接是不可见的。在这里找到完整的网络图片<a class="ae jh" href="https://github.com/baronrogers5/person-classifier/blob/master/images/model.png" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lm"><img src="../Images/71241ac0817c20a95c0967ce7fb1b55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*46LO89V-Afi2S8MS.png"/></div></div></figure><p id="d500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经对手头的问题有了一个想法，让我们从从头开始训练一个令人敬畏的分类器所需的实际步骤开始。</p><ul class=""><li id="22d6" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ls lt lu lv bi translated"><strong class="ih hj">数据预处理</strong> -</li><li id="b5c8" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">转换为一键编码。</li><li id="50dc" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">使用平均值和标准差进行标准化。</li><li id="48bb" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">数据扩充(<a class="ae jh" href="https://github.com/yu4u/cutout-random-erasing" rel="noopener ugc nofollow" target="_blank">删减</a>)</li><li id="2213" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">构建一个keras序列以馈入训练循环。</li><li id="7f76" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated"><strong class="ih hj">设计建筑</strong> -</li><li id="f0d8" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">选择骨干</li><li id="5aa4" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">建造这座塔。</li><li id="7441" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">为每一个班级构建标题[最终预测]。</li><li id="accb" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated"><strong class="ih hj">定义培训回访</strong></li><li id="8376" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated"><strong class="ih hj">实战训练。</strong></li></ul></div><div class="ab cl ji jj gp jk" role="separator"><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn"/></div><div class="hb hc hd he hf"><h1 id="efa1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">数据预处理</h1><p id="6e92" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">神经网络期望预测标签是一次性编码的。以便预测的概率[等于类的数量]可以直接与正确的标签匹配。</p><p id="788f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们需要将我们所有的预测标签转换为带有前缀的单热编码<em class="mb">，以便更容易识别它们。</em></p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="885e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">(13573, 9)</p><p id="ba29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">独热编码数据</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es mc"><img src="../Images/790c52f25ff170bd0be168fa5127bf31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J7_8c6oChGSJiQ9l.png"/></div></div></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es md"><img src="../Images/0bf95a842c8bfd45f8f57560fdb1d8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r5WMwwngeOUfPWLw.png"/></div></div></figure><h1 id="84d3" class="jp jq hi bd jr js lh ju jv jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km bi translated">使用平均值和标准差进行归一化</h1><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="3330" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些图像的原始大小是(200x200)，但是我们的数据集包含它们的调整后版本(224x224)。</p><p id="7e11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为，我们将使用一个<a class="ae jh" href="https://towardsdatascience.com/review-densenet-image-classification-b6631a8ef803" rel="noopener" target="_blank"> densenet </a>作为我们没有头部的架构，我们不需要额外的计算，因此我们将图像的大小调整为(200x200)。</p><p id="fc96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种调整是在PersonDataGenerator类中完成的。</p><p id="a1c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建keras序列，当被<code class="du jd je jf jg b">fit_generator</code>调用时，可以调用该序列来给出一系列批处理</p><h1 id="f8cc" class="jp jq hi bd jr js lh ju jv jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km bi translated">将属性列名存储在变量中</h1><p id="8468" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在创建one-hot编码版本时，我们用属性名作为列的前缀，这样我们可以将具有特定属性名的列放在一起，这将有助于识别特定目标属于哪些列。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="6c73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们构建一个sequence类，它将作为一个生成器给出一批数据，如果指定的话，将它混洗并应用数据扩充。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="085b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们快速调用PersonDataGenerator类来创建训练和测试生成器。为了实现剪切，我们使用<a class="ae jh" href="https://github.com/yu4u/cutout-random-erasing/blob/master/random_eraser.py" rel="noopener ugc nofollow" target="_blank"> get_random_generator </a>函数。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure></div><div class="ab cl ji jj gp jk" role="separator"><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn"/></div><div class="hb hc hd he hf"><h1 id="bb89" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">设计架构</h1><h1 id="928e" class="jp jq hi bd jr js lh ju jv jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km bi translated">选择骨干</h1><p id="34ae" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们没有使用预先训练的重量和从零开始，因为这是这项练习的要求之一。我们带一个<strong class="ih hj"> DenseNet121 </strong>骨干，不带头。这比<strong class="ih hj"> Resnet50 </strong>要好得多，但也应该能提供可比较的结果。</p><p id="a8d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为这是多任务分类。我们想要的最终模型应该是这样的:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><ol class=""><li id="2eb0" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc me lt lu lv bi translated">选择一个架构作为主干(这里我们选择densenet121，因为它在初始测试中比resnet50工作得更好)，不要包括头部，因为我们将构建自己的架构。</li><li id="290a" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc me lt lu lv bi translated">为每个职业建造塔，塔的结构基本上保持不变。</li><li id="0e61" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc me lt lu lv bi translated">建立各自的标题，作为每个类的输出。</li><li id="8668" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc me lt lu lv bi translated">构建整体模型，指定输入和输出。</li></ol><p id="1172" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主干的代码。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es mf"><img src="../Images/1c7cf9e1b87b1682503342dc36ae0086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nDEA_q-XcxyUP3X_.png"/></div></div></figure><p id="c2b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">relu后的最终形状是(6，6，1024)。</p><p id="b9f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这通过GlobalAveragePooling(进一步称为GAP)传递，以对通道维度上的每个要素地图进行平均。这使得张量形状变得平坦(无，1024)。</p><p id="2009" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我坚信，如果不仅仅使用GAP，我们还使用GlobalMaxPooling并连接输出，这一点可以得到改善。这导致2048个秩1张量，其将具有平均值和最大值结果的优点。</p><p id="ea2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的意思是这样的:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="c457" class="jp jq hi bd jr js lh ju jv jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km bi translated">建造这座塔</h1><p id="070a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">tower在GAP之后添加了一个batchnorm，以标准化GAP之后的结果，还添加了少量的dropout，以提高弹性。<br/>接下来是密集连接层，将节点减少到128个，每个头在其上构建。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="49a5" class="jp jq hi bd jr js lh ju jv jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km bi translated">构建头部</h1><p id="d00c" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">头部是产生输出的最后一层。<br/>假设<strong class="ih hj"> pose </strong>(我们需要预测的属性之一)，它有3个可能的输出，即<strong class="ih hj">(正面、背面和侧面)</strong>，所以每个可能的输出都需要一个最终节点来代表它出现的概率。<br/> <code class="du jd je jf jg b">num_units</code>包含每个名称的映射和类别的数量。<code class="du jd je jf jg b">build_head</code>根据<code class="du jd je jf jg b">num_units</code>建立每个类别的头，分配适当的最终节点。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="670b" class="jp jq hi bd jr js lh ju jv jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km bi translated">构建完整模型的代码</h1><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="7f81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里查看完整网络的样子<a class="ae jh" href="https://github.com/baronrogers5/person-classifier/blob/master/images/model.png" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="3e08" class="jp jq hi bd jr js lh ju jv jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km bi translated">定义培训回访</h1><ol class=""><li id="a927" class="ln lo hi ih b ii kn im ko iq mg iu mh iy mi jc me lt lu lv bi translated"><code class="du jd je jf jg b">ReduceLROnPlateau</code> - &gt;当模型值损失在一些<code class="du jd je jf jg b">patience</code>时期内没有通过<code class="du jd je jf jg b">min_delta</code>改善时，降低学习率</li><li id="87f4" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc me lt lu lv bi translated"><code class="du jd je jf jg b">ModelCheckpoint</code> - &gt;将模型权重保存在指定的目录下。</li><li id="660a" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc me lt lu lv bi translated"><code class="du jd je jf jg b">EarlyStopping</code> - &gt;停止训练如果<code class="du jd je jf jg b">val_loss</code>在<code class="du jd je jf jg b">patience</code>周期内<code class="du jd je jf jg b">min_delta</code>没有改善，停止后在训练期间恢复<code class="du jd je jf jg b">best_weights</code>。</li></ol><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="41a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开始实际训练之前，我们先编译一下模型。</p><p id="2e7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型编译步骤已经被实现为一个函数，因此它可以从任何单元和任何模型(主干或部分模型)上被调用。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure></div><div class="ab cl ji jj gp jk" role="separator"><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn"/></div><div class="hb hc hd he hf"><h1 id="652b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">让训练开始吧</h1><p id="0333" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">培训按以下顺序进行:</p><ol class=""><li id="526a" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc me lt lu lv bi translated">(100x100)所有图层均可训练的图像。</li><li id="7313" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc me lt lu lv bi translated">(100x100)主干冻结的图像，以便可以微调最终图层。</li><li id="acac" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc me lt lu lv bi translated">(100x100)图像，具有所有可训练层，但使用<code class="du jd je jf jg b">lr = 1e-4</code>进行了积极的数据扩充。</li><li id="ff44" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc me lt lu lv bi translated">(200x200)包含所有可训练图层的图像。</li><li id="c093" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc me lt lu lv bi translated">(200x200)主干冻结的图像。</li></ol><p id="979a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的训练循环都启用了<code class="du jd je jf jg b">EarlyStopping</code>,因此在每种情况下，历元的数量在8-15之间，在此之后，训练停止并运行下一步。</p><p id="020f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简洁起见，我不会在这里包括所有的训练步骤，但是你可以随时查看<a class="ae jh" href="https://github.com/baronrogers5/person-classifier/blob/master/Person_using_DenseNet.ipynb" rel="noopener ugc nofollow" target="_blank">实际的colab文件</a>，其中有所有的步骤和日志。</p><p id="dae1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您希望继续训练，并希望使用我预先训练的重量，您可以在<a class="ae jh" href="https://github.com/baronrogers5/person-classifier/tree/master/models" rel="noopener ugc nofollow" target="_blank"> github回购模型文件夹</a>中找到它们。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="70f8" class="jp jq hi bd jr js lh ju jv jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km bi translated">结果</h1><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lf lg l"/></div></figure></div><div class="ab cl ji jj gp jk" role="separator"><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn"/></div><div class="hb hc hd he hf"><h1 id="d7bc" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">进一步的实验/改进模型的方法</h1><p id="b178" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">有很多方法可以提高我们在这里取得的成绩。我将继续更新实际的github repo 中的一些建议。如果你喜欢这篇文章或者想要进一步的更新，请“观看”github repo或者“开始”它。这将激励我写其他类似的文章。</p><p id="38ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以事不宜迟，我列出了一些建议，排名不分先后。</p><p id="0406" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.更好的标准化和权重初始化。</p><p id="c4f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.每个单独类别的损失权重。</p><p id="f1da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.更好的图像增强，尤其是<a class="ae jh" href="https://github.com/aleju/imgaug" rel="noopener ugc nofollow" target="_blank"> imgaug </a>。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es mj"><img src="../Images/3fe8b2070de9a432d0a062a480967c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/1*twdVtdNWqsQYjQYYgKflCw.gif"/></div></figure><p id="8d1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.尝试不同的架构示例，如概念4、效率网、ResNext。</p><p id="d84a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.放松管制，比如退学。</p><p id="1df3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.尝试一个周期策略和周期学习率，特别是用<a class="ae jh" href="https://www.fast.ai/" rel="noopener ugc nofollow" target="_blank"> fast.ai </a>实现。</p><p id="6c92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7.不要只用GAP，而要用‘concatenate(GAP，GMP)’,然后建造塔。</p><p id="d3fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望实施其中的一些，看到损失减少，并获得更好的结果，如果你们中的任何人实施并看到一些有趣的结果，会很乐意听到更多关于它的信息。</p></div></div>    
</body>
</html>