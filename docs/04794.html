<html>
<head>
<title>Get to know about Cluster Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解聚类分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/get-to-know-about-cluster-analysis-1c6fce416712?source=collection_archive---------29-----------------------#2020-03-31">https://medium.com/analytics-vidhya/get-to-know-about-cluster-analysis-1c6fce416712?source=collection_archive---------29-----------------------#2020-03-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8932" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我计划讨论一种机器学习分组技术的理论背景——聚类。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/b4947c8444c6afbeb166095989d2c56f.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/0*etz8ZkzoS_Y0dUyi"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">示例:两个集群</figcaption></figure><p id="6889" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用分类方法来表示一种组织大型数据集的方便方法。这些小组将帮助经理们做出决定。例如，在银行业，经理希望识别他们的NPA客户。为此，我们需要首先根据关键指标/参数对客户进行分组。然后，我们可以确定哪个群体的NPA风险更大，并据此做出决策。</p><p id="872d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">聚类介绍。</strong></p><p id="538b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分类可以被看作是将相似的对象分成类别或组。这样一组相似的群被称为<strong class="ih hj">星团</strong>。</p><p id="89c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了能够将相似的对象放入组中，我们需要一种接近度或相似度的度量。相似性度量的选择取决于变量类型。这意味着它是离散的、连续的、二进制的还是其他的..</p><p id="3eb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我将讨论如何基于变量类型进行测量。这里我们可以把变量分成两大类，定性的和定量的。</p><p id="42f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">量化变量的相似性度量。</strong></p><p id="42fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们考虑两个项目x和y，我可以把这两个变量定义为数学上的矩阵。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jp"><img src="../Images/0a523f0cd0856df260f7f279667fe24a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*75ur-fWPRXpMWHia6LQ1Aw.png"/></div></figure><p id="85d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二维观测值之间的距离可以用两种方法测量。</p><p id="f645" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。欧几里德距离</strong></p><p id="ac34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是欧氏空间中两点之间的普通直线距离。等式如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/2c878b118558e2a6b226e9d2ee07bf21.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*ehnnlNEdN8_4Iw2iakS3Xw.png"/></div></figure><p id="91b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。统计(马哈拉诺比斯)距离</strong></p><p id="c014" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是对测量x距离y的平均值多少标准差的概念的多维概括(来自统计理论多元)。该方程包含一个新符号，<strong class="ih hj"> S-1 </strong>，它来自称为<strong class="ih hj">共方差矩阵</strong>的多元统计方法。等式如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jr"><img src="../Images/e19f0609577dc7874d2a648b351fee59.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*0T4sMgVcrBfzOorWtlgLmA.png"/></div></figure><p id="49df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面我只提到了一种测量距离的方法，但是有很多方法可以进行测量。例如，如果我们想测量一个二元变量中的距离，有一个单独的方法来做。在这种情况下，我们首先需要将所有的分类变量归类为二元变量。然后根据调查结果继续分析。</p><p id="e236" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我将讨论聚类方法。</p><p id="bd0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">聚类方法。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es js"><img src="../Images/5738b820424cb235eecd1b40925fe71a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1Ow_XRnnfTbp3h0s"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">聚类方法图。</figcaption></figure><p id="5b10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">聚类方法基本上可以分为两大类。</p><ol class=""><li id="15f0" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated">层次聚类方法</li><li id="9efc" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">非等级聚类方法</li></ol><p id="fbf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">层次聚类方法</strong></p><p id="7b6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">层次聚类方法通过一系列连续的合并或一系列连续的分割来进行。有两种类型的层次聚类方法；</p><p id="4182" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。凝聚层次方法</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kl"><img src="../Images/76cc3374bfbbdfe4c33a767fdffa4941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/0*9iOaEAzRyC_Y5iXA"/></div></figure><p id="6d1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法从单个对象作为主群集开始。最相似的对象首先被组合以形成一个组，并且这些初始组根据它们的相似性被合并。同样，最后一个集群出现了。凝聚法的主要类型。</p><ul class=""><li id="eda2" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc km kd ke kf bi translated">单链——考虑最短距离(最近邻)的一组成员</li><li id="bce3" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc km kd ke kf bi translated">完全连锁——考虑最远距离(最远邻居)的一组成员</li><li id="3d7a" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc km kd ke kf bi translated">平均关联-根据平均距离对成员进行分组。</li></ul><p id="e810" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。分裂层次法</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kn"><img src="../Images/736554ab4c6e36defdcda1ef66de3bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/0*EuhSYO5HlyCN3ZaE"/></div></figure><p id="e3fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对象的初始组被分成两个子组，使得每组中的对象远离另一组中的对象。这些子群被进一步划分成不同的子群。这个过程一直持续到得到不同的子群。</p><p id="1eb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">凝聚法和除法的结果都可以显示在一个叫做<strong class="ih hj">树状图</strong>的图表中。这有助于以清晰的方式识别集群。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es ko"><img src="../Images/3a74a9036a38fef34fb023dcebae1758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xhwec59kNdr5O7gl"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">样本树突图</figcaption></figure><p id="57d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">非层次聚类方法</strong></p><p id="4640" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非层次聚类技术被设计成将项目而不是变量分组到K个聚类的集合中。可以预先或者通过遵循分层聚类技术来定义聚类的数量。</p><p id="e445" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">K-均值聚类。</strong></p><p id="2c2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">K-means将每个项目分配给具有最近质心的聚类。(此处质心描述平均值)。这里我列出了K均值聚类的理论步骤。</p><ol class=""><li id="93cc" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated">将项目划分为K个初始聚类。</li><li id="b78c" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">继续查看项目列表，将一个项目分配给质心最近的群集。重新计算接收新项目的群和丢失项目的群的质心。</li><li id="d872" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">重复步骤2，直到不再发生重新分配。</li></ol><p id="2361" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望本文能帮助你获得一些关于聚类分析的理论基础。这是我在Medium上的第一篇文章，非常感谢你的评论和反馈。</p></div></div>    
</body>
</html>