<html>
<head>
<title>Using Logistic Regression to detect if a feature is Numerical or Categorical</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用逻辑回归检测特征是数值型还是分类型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/using-a-logistic-regression-to-detect-if-a-feature-is-numerical-or-categorical-825eaf49f1a2?source=collection_archive---------8-----------------------#2020-02-29">https://medium.com/analytics-vidhya/using-a-logistic-regression-to-detect-if-a-feature-is-numerical-or-categorical-825eaf49f1a2?source=collection_archive---------8-----------------------#2020-02-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ce15f18c1cc210cb90b94cc3cf7ac66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6E4uYdgUHq6axNzupxaGg.jpeg"/></div></div></figure><p id="d26b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你读了标题，你可能想知道为什么有人想要自动检测一个给定的特征是数字的还是分类的。这对于更大的任务来说会很方便，因为这只是处理数据集中缺失值的一个步骤(对于一般的机器学习问题)。最终目标是通过考虑每一个变量类型，能够用集合方法(例如随机森林)替换每一个空单元格。但首先，让我们关注如何才能真正实现这个目标。</p><p id="d6b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以用什么特征来区分数字变量和分类变量？</p><p id="e055" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在接下来的章节中，我们将讨论和剖析用<strong class="is hj"> <em class="jp"> Python </em> </strong>编写的每一段代码。完整代码可在<a class="ae jo" href="https://github.com/YA26/Data_type_identifier" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">这里</strong> </a>。</p><h1 id="aefb" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">分类变量与数值变量</strong></h1><p id="c59e" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">分类变量可以有多个类别或模态(有或没有顺序),而数值变量测量群体中每个个体的数量。</p><p id="d715" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jp">分类变量的例子:</em> </strong></p><ul class=""><li id="2feb" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated"><strong class="is hj">饿</strong>:是，不是，是，是，不是</li><li id="a329" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">性别:1，0，1，1，0，1</li><li id="88ee" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">疼痛 : 1，5，2，7，1，10</li></ul><p id="3463" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jp">数值变量的例子:</em> </strong></p><ul class=""><li id="a7f4" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">年龄:15岁、30岁、26岁、74岁、25岁、12岁</li><li id="26a0" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><strong class="is hj">工资($) </strong> : 5000，1000，3000，25000，1500，7500</li></ul><h1 id="fffe" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">唯一值、浮点数和顺序性</h1><p id="2d1f" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">分类变量的唯一值往往比数值变量少。与我们在数字中观察到的相比，它也不呈现浮点数。</p><p id="beca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果满足以下条件，我们将认为某个特征是绝对的:</p><ul class=""><li id="c96a" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">它有很少的唯一值(但不仅仅是)</li><li id="d004" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">它包含一个字符或字符串</li><li id="0c8a" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">它包含整数(但不仅仅是)</li></ul><p id="5dcc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果满足以下条件，我们将认为特征是数字的:</p><ul class=""><li id="07be" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">它有大量独特的价值</li><li id="155b" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">它包含浮点数</li><li id="f59b" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">它包含整数(但不仅仅是)</li></ul><p id="2e7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当分类变量由整数组成时，唯一值自然是连续的。数字变量将包含非顺序模态。</p><h1 id="f8a3" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">存储库的架构</h1><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/a35e003522fcc51629e52bb0b1e15c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Lc8U4jA5rLp7gEHWYsz6oQ.jpeg"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">贮藏室ˌ仓库</figcaption></figure><p id="9bc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有两个主要模块:</p><ul class=""><li id="d512" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">在<strong class="is hj"><em class="jp">data _ type _ identifier . py</em></strong>中，我们编写了一个类，用于预处理数据，建立我们的模型和我们的预测方法。</li><li id="2bef" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">在<strong class="is hj"> <em class="jp"> run.py </em> </strong>中我们实例化我们的类并执行一切。</li></ul><p id="4043" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在每一步，我们都将展示在类<strong class="is hj"> <em class="jp">数据类型标识符</em> </strong>中写了什么，以及它在run.py中的执行情况</p><h1 id="5bf9" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">数据预处理</h1><p id="4e7d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">下面的数据集完全是针对这种情况制作的。让我们来看看。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/0161d5ea607d7873cea5503692c8ed36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28-vkLOPEszYuq85kxRYng.jpeg"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">数据片段</figcaption></figure><p id="4325" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每一条线或观测值都是一个样本大小为21的特征。<strong class="is hj"> <em class="jp"> Y </em> </strong>是我们的目标变量，只包含两种模态(数字模态和分类模态)。我们希望对每个观察值的所有唯一值进行计数，并且我们还希望知道它们是否包含浮点数。让我们转换数据集。</p><p id="3d1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们试图导入一个包含缺失值的整数列时，Pandas会自动将其转换成一个数据类型为<em class="jp"> object </em>的列。有时它甚至能把一切都变成浮点数。为了避免必须手动设置每个列的数据类型，我编写了一个名为<strong class="is hj"><em class="jp">keep _ initial _ data _ types</em></strong><em class="jp">的方法。我使用了一种特殊的pandas数据类型(Int64Dtype)来保持数据集的原始性。</em></p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="67d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们实例化我们的类，导入数据，将特征从目标变量中分离出来。在使用前面的方法之前，我们需要转置数据集，因为如果每个要素都是列格式的，那么分析它们会更容易。</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="8655" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是构建训练集的时候了。我们检查每个单独的特征(列)是否包含浮点数，并计算所有唯一值。最后，我们不要忘记对目标变量进行编码。</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="aa66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在run.py中，我们还获得了目标变量的training_set和映射。当后者被编码时，“0”代表分类，而“1”代表数字。最后，我们对特征(X_train)和目标变量(y_train)进行混洗，以在训练过程中增加一些随机性。</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="70f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是我们的决赛:</p><div class="li lj lk ll fd ab cb"><figure class="lt ij lu lv lw lx ly paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/e0ed03be040fb5d2642c7274d5e0b363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*tK5PdWDV9YeuJhWUcjMWhw.jpeg"/></div></figure><figure class="lt ij lz lv lw lx ly paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/c0251395da6135929d6c5418f6bec910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*87m4w0mtszsCX2xE6nE3_w.jpeg"/></div></figure></div><h1 id="5510" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">训练:乙状结肠神经元</h1><p id="555a" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我使用Tensorflow 2.0(带有Keras API)构建了一个sigmoid神经元(也可以使用Scikit-Learn)。在Scikit-Learn中，我们使用最大似然法来寻找模型的最佳权重(包括偏差)。这里，我们选择使用Keras来最小化二元交叉熵代价函数，以便优化权重。进行交叉验证是为了避免过度拟合。使用Adam实现梯度下降(AdaGrad和RmsProp的最佳方案)。如果你想了解更多优化技术，这是一篇很好的文章。</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="fe02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我能够在训练集上获得88.62%的准确率。这并没有太大的意义，因为它衡量的是模型在已经看到的数据上的表现。获得了96.43%的验证准确性:这是一个好迹象，因为该分数是在验证集上计算的。让我们看看在随机测试集上能得到什么。</p><h1 id="626e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">测试</h1><p id="461f" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">由于在这次经历之前我没有任何数据，我不得不通过使用在互联网上找到的随机特征来建立一个测试集。这个模型正确地预测了每一个。这并不奇怪，因为它只在10个不同的特性上进行了测试。</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="92dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">已经创建了一个分类报告，可以在Github存储库中找到</p><h1 id="24dd" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="2193" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">检测一个给定的特征是分类的还是数值的可以用两个变量来完成。一个计算所有唯一值(unique_values)，另一个发现任何浮点数的存在(is_float)。然而，可以肯定的是，可能有其他的预测，可以提高这个模型的质量。同样，更大的测试集肯定会受到欢迎，因为错误预测的可能性会增加。但就目前而言，该模型将有助于自动填充数据集中缺失的值。请随时添加任何贡献给这个项目。</p></div></div>    
</body>
</html>