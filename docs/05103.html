<html>
<head>
<title>Linear Regression from Scratch in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Java中从头开始线性回归</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/linear-regression-from-scratch-in-java-dc7aead2ba04?source=collection_archive---------10-----------------------#2020-04-11">https://medium.com/analytics-vidhya/linear-regression-from-scratch-in-java-dc7aead2ba04?source=collection_archive---------10-----------------------#2020-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="66de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么是AI/ML:当我们缓慢而稳定地走向算法时代时，是时候思考我们是如何传统地使用现有的工具解决问题了。对人工智能/人工智能的需求不能被忽视，因为有更具挑战性的问题不能用现有的工具来解决。例如，尝试编写代码来预测输入图像是橙色还是苹果色。如果你解决了这个问题，再想想其他情况。如果输入图像是黑白的呢？如果图像包含叶子和水果会怎样？当然，增加中频和开关模块并不是解决这个问题的理想方法。</p><p id="4f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我试图解释如何在不使用任何框架的情况下，用java为scratch编写线性回归。不使用任何框架背后的逻辑是理解和详细解释算法的内部原理。理论讲够了，让我们回到编码上来。</p><p id="2e84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线性回归:根据数学定义，一个变量的线性方程可以定义如下。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="1f7a" class="jm jn hi ji b fi jo jp l jq jr">y = mx+c</span></pre><p id="7693" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将它与现实世界的例子联系起来，让我们假设一家小公司想要根据一个月的平均温度来预测该月所需的25升饮用水瓶的数量。他们想要建立瓶子数量和月平均温度之间的模式[为了简单起见，我们假设员工数量是固定的]。该公司希望使用他们的历史数据来建立模型，以帮助他们实现这一目标。</p><p id="ceab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据集的例子。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="6cb3" class="jm jn hi ji b fi jo jp l jq jr">Month's Avg Temperature   Number of Bottles consumed in month<br/>35                                  4<br/>37                                  8</span></pre><p id="5aed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试着把它和方程式联系起来。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="7045" class="jm jn hi ji b fi jo jp l jq jr">Temperature is x  and y is bottles </span><span id="b68f" class="jm jn hi ji b fi js jp l jq jr">now we have to find m and c. so that when we put x in below equation it should help with prediction of number of bottles</span><span id="3212" class="jm jn hi ji b fi js jp l jq jr">y = mx+c</span></pre><p id="b156" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题陈述:找出m和c的最佳值，以便我们可以使用上面的等式来预测值。</p><p id="cadf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案:为了找到m和c的最佳值，我们必须从两者的一些随机初始值开始。我们将逐步修正这些值，以达到预测所需的精度[现在请不要考虑过度拟合]。这种逐渐纠正价值观的过程，就是我们会用到高中所学数学的空间。值的修正是在训练阶段使用历史数据完成的。更新m和c公式如下所示。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="5e1e" class="jm jn hi ji b fi jo jp l jq jr">m1 = m0 - learningRate * differentitaion of M.S.E with respect to m</span><span id="9b4d" class="jm jn hi ji b fi js jp l jq jr">learning rate is fixed 0001d [ Learning rate hyper parameter which can be optimized using GridSearch or Randomoptimizer (Out of scope )]</span><span id="afc0" class="jm jn hi ji b fi js jp l jq jr">M.S.E = Mean squared error [ I find it difficult type maths formula using keyboards hence attaching image]</span></pre><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jt"><img src="../Images/cd47611a5bce3bbd0f59801958f3bd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j-j7IhTcC16KFSJT"/></div></div></figure><p id="f606" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们用微分来计算MSE相对于m和c的变化率，我在高中时总是想知道为什么我们在学习微积分，现在看到它在运行是一种享受。</p><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jt"><img src="../Images/96288791db5716d03e6272591fea935e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WFAthczf4Ld-OdT7"/></div></div></figure><p id="43a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这篇文章，我们将使用随机梯度下降[其他类型是批处理，迷你批处理]。随机梯度下降法仅从训练数据集中选取一个条目，并为其计算预测值。然后，它根据使用该值计算的值调整权重。微分方程将n作为考虑的记录数，但是在这个方程中，它是1，因此1/n可以从MSE导数中忽略。在这里，epoch也是一个暂时固定的超级参数，但它也可以使用GridSearch /RandomOptimizer作为学习率进行优化。</p><pre class="jd je jf jg fd jh ji kb bn kc kd bi"><span id="e8af" class="ke jn hi ji b be kf kg l kh jr"><br/> public void trainSGD(double[][] trainData, double[] result) {<br/><br/>  if (trainData == null || trainData.length &lt;= 0) {<br/>   throw new RuntimeException("Input data can not be null");<br/>  }<br/>  // Stochastic Gradient descent<br/>  for (int e = 0; e &lt; epochs; e++) {<br/>   double mse = 0d;<br/>   for (int i = 0; i &lt; trainData.length; i++) {<br/>    double[] tempInput = trainData[i];<br/><br/>    Optional&lt;Double&gt; predictedValueOptional = this.predict(tempInput);<br/><br/>    double predictedValue = predictedValueOptional.get();<br/><br/>    double error = predictedValue - result[i];<br/>    mse = error * error + mse;<br/><br/>    for (int j = 0; j &lt; weights.length; j++) {<br/>     weights[j] = weights[j] - learningRate * error * tempInput[j];<br/><br/>    }<br/>    beta = beta - learningRate * error;<br/><br/>   }<br/>   mse = (Math.sqrt(mse)) / trainData.length;<br/>   System.out.println(" MSE " + mse + " Weights " + Arrays.toString(weights) + " Beta " + beta);<br/>  }<br/> }</span></pre><p id="0f76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更详细地解释代码，我使用了for循环，但理想情况下，我们应该使用矩阵运算而不是for循环。我将在下一篇文章中介绍它。</p><p id="cd6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是完整的代码</p><pre class="jd je jf jg fd jh ji kb bn kc kd bi"><span id="1c80" class="ke jn hi ji b be kf kg l kh jr">package org.ai.hope.core;<br/><br/>import java.util.Arrays;<br/>import java.util.Optional;<br/><br/><br/><br/>public class LinearRegression {<br/><br/> private double beta;<br/><br/> private double[] weights;<br/><br/> private double learningRate = 0.001d;<br/><br/> private int epochs;<br/> <br/> //private Function&lt;T, R&gt;<br/><br/> public LinearRegression(int featuresCount, int epochs) {<br/>  weights = new double[featuresCount];<br/>  this.epochs = epochs;<br/> }<br/><br/> public Optional&lt;Double&gt; predict(double[] inputs) {<br/>  if (inputs == null || inputs.length &lt;= 0) {<br/>   return Optional.empty();<br/>  }<br/><br/>  double result = 0d;<br/>  for (int i = 0; i &lt; inputs.length; i++) {<br/>   result = inputs[i] * weights[i] + result;<br/>  }<br/><br/>  result = result + beta;<br/><br/>  return Optional.of(result);<br/> }<br/><br/> <br/> @Override<br/> public void trainSGD(double[][] trainData, double[] result) {<br/>  <br/>  if (trainData == null || trainData.length &lt;= 0) {<br/>   throw new RuntimeException("Input data can not be null");<br/>  }<br/>  // Stochastic Gradient descent<br/>  for (int e = 0; e &lt; epochs; e++) {<br/>   double mse = 0d;<br/>   for (int i = 0; i &lt; trainData.length; i++) {<br/>    double[] tempInput = trainData[i];<br/><br/>    Optional&lt;Double&gt; predictedValueOptional = this.predict(tempInput);<br/><br/>    double predictedValue = predictedValueOptional.get();<br/><br/>    double error = predictedValue - result[i];<br/>    mse = error * error + mse;<br/><br/>    for (int j = 0; j &lt; weights.length; j++) {<br/>     weights[j] = weights[j] - learningRate * error * tempInput[j];<br/><br/>    }<br/>    beta = beta - learningRate * error;<br/><br/>   }<br/><br/>   mse = (Math.sqrt(mse)) / trainData.length;<br/>   System.out.println(" MSE " + mse + " Weights " + Arrays.toString(weights) + " Beta " + beta);<br/>  }<br/>  <br/> }<br/><br/><br/>}</span></pre><p id="8c68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用样本数据运行程序的代码。</p><pre class="jd je jf jg fd jh ji kb bn kc kd bi"><span id="a731" class="ke jn hi ji b be kf kg l kh jr"> private static void trainModel()<br/> {<br/>  double[][] trainSet = {{20},{16},{19.8},{18.4},{17.1},{15.5}};<br/>  double[] result = {88.6,71.6,93.3,84.3,80.6,75.2};<br/>  LinearRegression linearRegression = new LinearRegression(trainSet[0].length, 1000);<br/>  linearRegression.train(trainSet, result);<br/>  <br/> }<br/> <br/> public static void main(String[] args) {<br/>  //trainModel();<br/>  trainModel1();<br/>  //testRandom();<br/> }</span></pre><p id="87ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">敬请关注。</p><p id="83c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请在nirmal1067@gmail.com给我留言</p></div></div>    
</body>
</html>