<html>
<head>
<title>How I Built an Intelligent Agent to Play Flappy Bird</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何构建一个智能代理来扮演Flappy Bird</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-i-built-an-ai-to-play-flappy-bird-81b672b66521?source=collection_archive---------1-----------------------#2020-05-20">https://medium.com/analytics-vidhya/how-i-built-an-ai-to-play-flappy-bird-81b672b66521?source=collection_archive---------1-----------------------#2020-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/96da64dc4857e902ee4203c82cdc01ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yuq6P5aeqkSQKh3voMhAVQ.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">一个智能代理扮演Flappy Bird</figcaption></figure><h1 id="47f5" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="66b1" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">你玩过Flappy Bird吗？在这个动画中，你看到的是一个熟练的玩家在玩游戏Flappy Bird。但是，这个玩家不是人类。这是一个我用增强拓扑结构的神经进化算法<strong class="ju hj">构建的<strong class="ju hj">智能代理</strong>(IA)</strong>(NEAT)算法。</p><p id="59db" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">2019年9月，OpenAI发布的一篇名为<a class="ae kv" href="https://openai.com/blog/emergent-tool-use/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">从多智能体交互中紧急使用工具</em> </a>的文章展示了智能体如何在模拟的捉迷藏环境中逐步学习使用复杂的工具和策略。我觉得特别有意思，想多了解一下<strong class="ju hj">强化学习</strong> (RL)。</p><div class="kx ky kz la fd ab cb"><figure class="lb ij lc ld le lf lg paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/5485225e54020341b6f6a1d6b86d4ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/1*Yoq0mkOiVAWhIazhXbkoYg.gif"/></div></figure><figure class="lb ij lc ld le lf lg paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/a41200d443cce1c40c215b17cb9044d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/1*wU3MBYuS0PE1FBrIqzWdCQ.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx lh di li lj translated">多智能体捉迷藏。来源:<a class="ae kv" href="https://openai.com/blog/emergent-tool-use/" rel="noopener ugc nofollow" target="_blank"> <em class="lk">通过</em> </a><a class="ae kv" href="https://openai.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lk"> OpenAI </em> </a>从多智能体交互  <em class="lk">中使用紧急工具</em></figcaption></figure></div><p id="30b0" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">在我的研究中，我看到了优步人工智能实验室的一篇论文，题为<a class="ae kv" href="https://arxiv.org/pdf/1712.06567.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="kw">深度神经进化:遗传算法是训练深度神经网络进行强化学习</em> </a>的一个有竞争力的替代方案，其中研究人员提出了经验证据，表明一个简单的<strong class="ju hj">遗传算法</strong> (GA)可以在RL问题上表现得非常好。除了上面我们看到的<a class="ae kv" href="https://openai.com/blog/emergent-tool-use/" rel="noopener ugc nofollow" target="_blank">捉迷藏</a>的例子，RL还被成功应用于<a class="ae kv" href="https://towardsdatascience.com/atari-reinforcement-learning-in-depth-part-1-ddqn-ceaa762a546f" rel="noopener" target="_blank"> <strong class="ju hj">雅达利</strong></a><a class="ae kv" href="https://towardsdatascience.com/how-to-teach-an-ai-to-play-games-deep-reinforcement-learning-28f9b920440a" rel="noopener" target="_blank"><strong class="ju hj">贪吃蛇</strong></a><a class="ae kv" rel="noopener" href="/acing-ai/how-i-build-an-ai-to-play-dino-run-e37f37bdf153"><strong class="ju hj">迪诺跑</strong> </a>等各种游戏中。如果我们可以用GA来构建一个游戏IA呢？这个想法引发了我对使用NEAT构建Flappy Bird IA的浓厚兴趣，NEAT是Ken Stanley在2002年开发的g a。</p><div class="kx ky kz la fd ab cb"><figure class="lb ij ll ld le lf lg paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/f75ca38ecb61f3f3c23f58e13210a08a.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/1*xzVa_7d-chiw1E54ZxLEqQ.gif"/></div></figure><figure class="lb ij lm ld le lf lg paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/d6b6cae042dba78580653f68831bf9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/1*TkUKx8B5fK1hQQwt94zUBg.gif"/></div></figure><figure class="lb ij ln ld le lf lg paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/080cecd9612aa6b47bcd46171ec8df01.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/1*fBU32noWL5GDK-meSF8gUw.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx lo di lp lj translated">用强化学习教AI玩游戏。来源:<a class="ae kv" href="https://towardsdatascience.com/atari-reinforcement-learning-in-depth-part-1-ddqn-ceaa762a546f" rel="noopener" target="_blank"> <strong class="bd iw">雅达利</strong> </a> <strong class="bd iw">，</strong> <a class="ae kv" href="https://towardsdatascience.com/how-to-teach-an-ai-to-play-games-deep-reinforcement-learning-28f9b920440a" rel="noopener" target="_blank"> <strong class="bd iw">蛇</strong> </a> <strong class="bd iw">，</strong> <a class="ae kv" rel="noopener" href="/acing-ai/how-i-build-an-ai-to-play-dino-run-e37f37bdf153"> <strong class="bd iw">迪诺跑</strong> </a> <strong class="bd iw">。</strong></figcaption></figure></div></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="131c" class="iu iv hi bd iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr bi translated">为什么是Flappy Bird？</h1><p id="883d" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">对于那些不熟悉游戏Flappy Bird的人来说，这是一款由Dong Nguyen在2013年开发的热门手机游戏。Flappy Bird获得了大量涌入的玩家，并在短时间内取得了巨大的成功。玩家点击屏幕来导航这只鸟，它必须在正确的时间跳跃通过一组类似马里奥的管道。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/544130f2c5e48b374448282295dc4f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/1*w7IklXEC8buCvzTwI5sSiw.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">拍打鸟。来源:<a class="ae kv" href="http://flappybird.io/" rel="noopener ugc nofollow" target="_blank"> flappybird.io </a></figcaption></figure><p id="2465" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">Flappy Bird对于有兴趣从头开始构建游戏的初学者来说是一个合理的选择，因为游戏的机制很简单，唯一的游戏动作是跳跃。此外，创建一个IA不会太复杂，因为我们只需要一些输入就可以得到一个二进制输出(我稍后会谈到)。最后但同样重要的是，Flappy Bird是我最喜欢的手机游戏之一！所以，当我开始制作我的第一个游戏时，Flappy Bird是一个不用动脑筋的人。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="2232" class="iu iv hi bd iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr bi translated">如何用Python构建Flappy Bird？</h1><p id="6271" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">我使用的主要模块是Pygame。网上有大量的教程，以下是我最喜欢的一些:</p><ul class=""><li id="d8ad" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated">Pygame新手指南</li><li id="58a4" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="http://pygametutorials.wikidot.com/tutorials" rel="noopener ugc nofollow" target="_blank"> PyGame教程:游戏编程简单介绍</a></li><li id="5c4f" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated">【thenewboston的PyGame教程的YouTube播放列表</li></ul><p id="e54f" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">在Pygame中构建Flappy Bird方面，也有大量的教程。以下是我发现非常有用的教程列表。我从他们那里记笔记，总结他们的方法，并试图在他们的基础上构建我的代码。如果你想了解更多这方面的信息，请查阅它们。</p><ul class=""><li id="d7d8" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><a class="ae kv" href="https://www.youtube.com/playlist?list=PLzMcBGfZo4-lwGZWXz5Qgta_YNX3_vLS2" rel="noopener ugc nofollow" target="_blank"> AI和Tim一起用Tech的NEAT Python玩Flappy Bird</a></li><li id="20e5" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="https://www.youtube.com/playlist?list=PLZ1QII7yudbebDQ1Kiqdh1LNz6PavcptO" rel="noopener ugc nofollow" target="_blank">使用Bluefever软件开发的Flappy和Pygame的神经网络</a></li><li id="543b" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated">CodeWithHarry为绝对初学者编写的Flappy Bird Python教程</li></ul><p id="a7ce" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">在编码之前，我总是画一个思维导图来指导我完成整个过程。下面是思维导图的演示:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/22f6a644f639107d06b1be231bd4468b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rIi92csCZmP1Ro3UYZxfSw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">构建Flappy Bird的思维导图示例</figcaption></figure><p id="5f7e" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">要制作Flappy Bird，我们需要三个Python对象:鸟、管道和地板。我们还需要一些功能来检查碰撞，显示和运行游戏。像大多数游戏一样，游戏选项部分允许我们根据自己的喜好改变一些游戏特性。</p><h2 id="2799" class="ms iv hi bd iw mt mu mv ja mw mx my je kd mz na ji kh nb nc jm kl nd ne jq nf bi translated">现在，让我们深入研究代码！</h2><p id="a124" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">首先导入包，初始化Pygame，设置屏幕显示游戏。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="ak">游戏初始化</strong></figcaption></figure><p id="597a" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">下面是一些以后会用到的游戏选项。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">游戏参数设置</figcaption></figure><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/302924cb41375a1a5120645f0f51fdb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IoC9YoinhUovyVajlcL-Fg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Flappy鸟游戏设计</figcaption></figure><ul class=""><li id="267e" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj">如何建造一只鸟？</strong></li></ul><p id="c10c" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我们需要一些类方法来模拟这个运动。回想一下我们在中学物理课上学过的，计算一个从时间0到时间<strong class="ju hj"> <em class="kw"> t </em> </strong>以非零速度开始的物体的位移<strong class="ju hj"><em class="kw">d</em></strong>v<em class="kw">v</em>的方程是:<a class="ae kv" href="http://zonalandeducation.com/mstm/physics/mechanics/kinematics/EquationsForAcceleratedMotion/Introductions/Displacement/Introduction.htm" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> d = vt + 1/2at </em> </a>，其中<strong class="ju hj"> <em class="kw"> a </em> </strong>是加速度。如果鸟跳跃，它获得一个向上的速度。然后我们根据位移计算更新鸟的位置。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">造一只鸟</figcaption></figure><ul class=""><li id="4b7b" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj">如何搭建管道？</strong></li></ul><p id="b9a7" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">管子比鸟更直截了当。管道以固定的速度水平移动。一个简单的<em class="kw">移动</em>方法如下图所示。我们需要的另一个类方法是随机化管道间隙的位置。因为每个缝隙的大小都是一样的，所以我们可以简单的把上面管子的高度随机化，然后下面管子的高度也会相应的变化。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">建造管道</figcaption></figure><ul class=""><li id="e93a" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj">如何搭建地板？</strong></li></ul><p id="e6fe" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">地板是最简单的一种。它以固定的速度水平移动。我们可以复制三幅图像，并将它们连接在一起。一旦第一个图像移出屏幕，我们就把它附加到最后一个图像的右边。这同样适用于第二和第三幅图像。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">建一层楼</figcaption></figure><ul class=""><li id="755a" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj">如何检查碰撞？</strong></li></ul><div class="kx ky kz la fd ab cb"><figure class="lb ij nj ld le lf lg paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/4d5721e658b0dedb07d58993644bd0ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*-0kNzSXSDY0cxwIrRshgGw.png"/></div></figure><figure class="lb ij nk ld le lf lg paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/0e07d2bac56bab28ccc046162bf4948f.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*DVcdpJ8agheMUz3NDJGI7w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx nl di nm lj translated"><a class="ae kv" href="https://www.pygame.org/docs/ref/rect.html" rel="noopener ugc nofollow" target="_blank">矩形碰撞检测</a>(左)vs <a class="ae kv" href="http://renesd.blogspot.com/2017/03/pixel-perfect-collision-detection-in.html" rel="noopener ugc nofollow" target="_blank">像素完美碰撞检测</a>(右)</figcaption></figure></div><p id="6bef" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">如果一只鸟的图像与一根管子的图像重叠，那么我们说这只鸟撞到了管子。主要有两种方法来检查重叠。一个叫做<strong class="ju hj">矩形碰撞检测</strong>由<a class="ae kv" href="https://www.pygame.org/docs/ref/rect.html" rel="noopener ugc nofollow" target="_blank">的<em class="kw"> pygame完成。rect . collider rect</em></a><em class="kw"/>函数。另一个由<a class="ae kv" href="https://www.pygame.org/docs/ref/mask.html" rel="noopener ugc nofollow" target="_blank"><em class="kw">pygame . mask . mask . overlap</em></a>函数调用<strong class="ju hj">像素完美碰撞检测</strong>。注意，我们也说鸟撞到上限或者地面就碰撞了。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">检查碰撞</figcaption></figure><ul class=""><li id="bc4c" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj">如何展示游戏？</strong></li></ul><p id="88fb" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">下面是显示游戏的函数。我们画一个背景，一个移动的地板，一组管道和一群鸟。我们还添加了一些文本消息来显示一些附加信息。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">绘制游戏屏幕</figcaption></figure><p id="3c65" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">现在游戏差不多做好了，我们来看看如何建立一个IA。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="d914" class="iu iv hi bd iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr bi translated">扩充拓扑的神经进化(NEAT)</h1><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/bf471ed56ac3707ff7215666e0250252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*21gFrA7fAHNAr1aihPeZLw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">扩充拓扑的神经进化。来源:<a class="ae kv" href="https://www.evolv.ai/blog/ai-101-intro-to-evolutionary-algorithms/" rel="noopener ugc nofollow" target="_blank"> Evolv科技</a></figcaption></figure><p id="79d4" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><strong class="ju hj"> NEAT </strong>代表<strong class="ju hj">增强拓扑的神经进化</strong>，这是一种遗传算法，旨在高效进化人工神经网络拓扑。这是一项了不起的技术，解决了<strong class="ju hj">拓扑和权重进化人工神经网络</strong>(tween)的一些挑战。在深入到NEAT之前，我们先来看看两个关键概念:<strong class="ju hj">人工神经网络</strong> (ANN)和<strong class="ju hj">遗传算法</strong> (GA)。</p><h2 id="6d11" class="ms iv hi bd iw mt mu mv ja mw mx my je kd mz na ji kh nb nc jm kl nd ne jq nf bi translated">什么是人工神经网络？</h2><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/588c2ae571d684164f21dbaa7bb6f7a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XggAN4M0vM2Nyh25cqwQmA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">典型的人工神经网络结构</figcaption></figure><p id="1c35" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">人工神经网络(ANN)是一种受大脑启发的计算系统，由相互连接的节点和加权连接组成。典型的人工神经网络结构包含一个输入层、一些隐藏层和一个输出层。隐藏层和输出层中的每个节点由一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Activation_function" rel="noopener ugc nofollow" target="_blank"> <em class="kw">激活函数</em> </a>组成，该函数将输入值的加权和转换为输出。在大多数情况下，人工神经网络可以通过<a class="ae kv" href="https://en.wikipedia.org/wiki/Backpropagation" rel="noopener ugc nofollow" target="_blank"> <em class="kw">反向传播</em> </a>适当调整其连接权重来学习，这是一种执行梯度方法以最小化损失的技术。</p><p id="257f" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">如果您想了解更多关于ANN的信息，以下资源可能会有所帮助:</p><ul class=""><li id="47dd" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Artificial_neural_network" rel="noopener ugc nofollow" target="_blank">维基百科:人工神经网络</a></li><li id="2caf" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="https://towardsdatascience.com/introduction-to-artificial-neural-networks-ann-1aea15775ef9" rel="noopener" target="_blank">人工神经网络简介</a></li><li id="a44f" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="https://www.youtube.com/playlist?list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi" rel="noopener ugc nofollow" target="_blank">3 blue 1 brown的神经网络教程的YouTube播放列表</a></li></ul><h2 id="a4cd" class="ms iv hi bd iw mt mu mv ja mw mx my je kd mz na ji kh nb nc jm kl nd ne jq nf bi translated">什么是遗传算法？</h2><blockquote class="np nq nr"><p id="64fd" class="js jt kw ju b jv kq jx jy jz kr kb kc ns ks kf kg nt kt kj kk nu ku kn ko kp hb bi translated">"我们在有机世界的任何地方和任何部分都能看到美丽的适应."——<em class="hi">查尔斯·达尔文</em>《物种起源》。</p></blockquote><p id="6c51" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">1859年，查尔斯·达尔文提出的自然选择理论奠定了进化生物学的基石。这个理论的精髓是那些最能适应变化的人最有可能生存下来。从那时起，“适者生存”的概念为人们理解物种进化提供了一种新的方式。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nv"><img src="../Images/c7f7a5fe161ed90592b92420e928c40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ddEvD7nCB7UPv06e274GUQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">古尔德的达尔文雀。来源:<a class="ae kv" href="https://commons.wikimedia.org/wiki/File:Darwin%27s_finches_by_Gould.jpg" rel="noopener ugc nofollow" target="_blank">维基媒体</a></figcaption></figure><p id="cdf2" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">如果生物进化能够产生像人类和许多其他人一样的惊人物种，<strong class="ju hj">是否有可能将现代遗传学与机器学习技术相结合来解决一个问题</strong>？遗传算法打开了机会之门，照亮了通向可能性的道路。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nw"><img src="../Images/76d11593089fba0a64744036d17e9dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOFRqRL-4K4mG8-d5n9zVg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">遗传算法。来源:<a class="ae kv" href="https://www.newscientist.com/term/dna/" rel="noopener ugc nofollow" target="_blank">新科学家</a></figcaption></figure><p id="9fd7" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">根据定义，遗传算法是一种启发式技术，<strong class="ju hj">模拟自然选择的过程来解决各种各样的优化问题</strong>，尤其是那些具有不可微或随机目标函数的问题。</p><p id="3c15" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">以下是一些关键术语:</p><ul class=""><li id="791b" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj">适应度函数</strong>:在许多情况下，适应度函数与目标函数相同。它是一个函数，将解决方案作为输入，并生成一个适应度分数作为输出，以评估每个解决方案的质量。这是遗传算法的一个基本要素。我们应该根据每个具体问题来定制适应度函数。</li><li id="7ff7" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated">群体:在遗传算法中，群体是给定问题的所有候选解的子集。</li><li id="2489" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj">染色体</strong>:群体中的每一个候选解都是一条染色体，有时也称为基因组。</li><li id="48fe" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj">基因</strong>:染色体内的每一个元素位置都是一个基因，它有一个特定的值，决定了解的基因型和表现型。</li><li id="10c4" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj">世代</strong>:在每次迭代中，GA执行一组遗传操作(选择、交叉、变异等。)对当前人口产生连续一代。</li><li id="7f8b" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj">选择</strong>:选择是根据适应度得分筛选和保留解的过程。适应性更高的解决方案更有可能被推进到下一代。可以选择一对被选择的解作为亲本，通过交叉将它们的基因繁殖和传播给下一代。</li><li id="efc3" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj">交叉</strong>:交叉是亲代染色体产生子代染色体的方式。双亲的基因根据一组交叉点重新组合，形成新的后代。</li><li id="c588" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj">突变</strong>:GA中的突变是染色体中基因的微小随机调整。它允许遗传算法探索解空间，避免陷入局部极小值。</li></ul><p id="07b6" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">下面是一个典型遗传算法如何工作的演示:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nx"><img src="../Images/4d1e391cc690e05a42343075c13c568e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Neqg9wuBYfDPB7I9Wptmuw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">典型的遗传算法工作流程</figcaption></figure><p id="95f3" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">开始时，我们随机产生N个解决方案作为我们的初始群体。然后，我们进入评估阶段，分配任务并计算每个解决方案的适合度分数。接下来，我们基于以下条件确定是否终止文献:我们是否获得了可接受的解决方案？我们达到时间或世代限制了吗？我们是否陷入了业绩停滞？如果没有，我们将继续进行遗传操作，为下一代繁殖后代。</p><p id="cf6f" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">为了帮助说明工作流程，下面是GA的“Hello World”问题、<a class="ae kv" href="https://en.wikipedia.org/wiki/Knapsack_problem" rel="noopener ugc nofollow" target="_blank"> <em class="kw">背包问题</em> </a>。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ny"><img src="../Images/7da7db3c46cf3b602e644ab1abeea26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QfjIhd7eXpzdhtBQ_9azUg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">背包问题。来源:<a class="ae kv" href="https://en.wikipedia.org/wiki/Knapsack_problem" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="9d1e" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">想象一下，给你五件不同重量和价值的物品。你想最大化你包里物品的总价值。但是，你的容量是15公斤。这个例子中的最优集合对你来说似乎很直观，但是让我们看看GA是如何处理这个问题的。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nz"><img src="../Images/ad3185f6a85c68693b766586fd89590b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8FD0U4nbT2MMWu9IWaPSg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">背包问题的遗传工作流实例</figcaption></figure><p id="0965" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">在这种情况下，我们将<em class="kw">适应度函数</em>定义为包含在我们包中的每件物品的值的总和。换句话说，我们相信如果一个收藏的总价值越高，它就越好。此外，总重量不应超过我们的能力。在迭代的开始，我们随机生成四个解决方案(<em class="kw">人口</em>)作为我们的第一个<em class="kw">代</em>。对于每个解(<em class="kw">染色体</em>，我们表示一个项目是包含(“1”)还是不包含(“0”)，代表一个<em class="kw">基因</em>。每个建议的解决方案都有一个适合度分数。得分最高的解决方案更有可能被选为父代(<em class="kw">选择</em>)。两个被选择的染色体基于交叉点交换它们的一些基因(<em class="kw">交叉</em>)。而且有小概率新后代的某些基因会发生变化(<em class="kw">突变</em>)。终于，新一代诞生了。该循环将继续，直到满足终止要求。</p><p id="6c5d" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">现在我们已经有了一些关于ANN和GA的基础知识，让我们开始学习NEAT吧！</p><h2 id="1e1d" class="ms iv hi bd iw mt mu mv ja mw mx my je kd mz na ji kh nb nc jm kl nd ne jq nf bi translated">扩充拓扑的神经进化是什么？</h2><p id="7a58" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">简而言之，<strong class="ju hj"> NEAT是一个设计用来进化ANN的GA</strong>。你可能会有一个大问题，是什么让整洁变得特别？我相信这个问题的答案可以在肯尼斯·斯坦利2002年写的这篇精彩的6页论文中找到。下面的讨论就是基于这篇<a class="ae kv" href="http://nn.cs.utexas.edu/downloads/papers/stanley.cec02.pdf" rel="noopener ugc nofollow" target="_blank">原文</a>。</p><p id="6120" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">使用遗传算法而不是反向传播来进化人工神经网络的过程也被称为<strong class="ju hj">神经进化</strong> (NE)。NEAT的美妙之处在于它提供了解决NE面临的三个主要挑战的解决方案:</p><ul class=""><li id="b1e3" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated">有没有一种基因表达允许不同的拓扑以一种有意义的方式交叉？</li><li id="bb72" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated">需要几代优化的拓扑创新如何保护，才不会过早从种群中消失？</li><li id="46bd" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated">如何在进化过程中最小化拓扑结构，而不需要专门设计的适合度函数来测量复杂性？</li></ul><p id="4ee5" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">以下是支撑NEAT的关键概念:</p><ul class=""><li id="c696" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj">遗传编码</strong>:遗传编码是在GA中表示染色体的过程。NEAT使用一个直接编码方案，即每个基因组由一个节点基因列表和一个连接基因列表组成。节点基因表示所有可以连接的输入、隐藏和输出节点，而连接基因存储连接信息和用于历史标记的创新数。通过这样做，NEAT可以在交叉过程中快速排列相应的基因。</li></ul><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oa"><img src="../Images/8efe366ba7eeb7903618ad7d93760de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PiGeyT43PMpKR5fmVj1xxw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">一个基因编码的例子。来源:<a class="ae kv" href="http://nn.cs.utexas.edu/downloads/papers/stanley.cec02.pdf" rel="noopener ugc nofollow" target="_blank">神经网络拓扑的高效进化</a></figcaption></figure><ul class=""><li id="36e4" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj">生长</strong> : NEAT通过结构突变来生长和进化拓扑结构。突变可以是在旧连接中添加新节点，或者在两个未连接的节点之间添加新连接。因此，NEAT能够提高基因组多样性，探索解空间，避免局部极小值。</li></ul><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ob"><img src="../Images/bb5bc7dbfe9b7177c9b59fd2f2865e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6vb3hbrqW9N0M5B-rCszlw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">净增长的一个例子。来源:<a class="ae kv" href="http://nn.cs.utexas.edu/downloads/papers/stanley.cec02.pdf" rel="noopener ugc nofollow" target="_blank">神经网络拓扑结构的高效进化</a></figcaption></figure><ul class=""><li id="d74f" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj">历史标记</strong>:历史标记就是追踪基因的过程。NEAT使用一个全球<em class="kw">创新编号</em>来表示系统中一个基因的年表，以执行历史标记。每当创建一个新的节点或连接时，都会为该基因分配一个新的创新编号。在交叉过程中，后代随机选择来自任一父代的具有相同新息数的基因(<em class="kw">匹配基因</em>)，并继承来自更适合的父代的具有不同新息数的基因(<em class="kw">分离基因</em>或<em class="kw">过量基因</em>)。因此，NEAT确保了交叉是有意义的，并解决了<strong class="ju hj"> </strong> <em class="kw">竞争约定</em>，这是一种具有相似表型的父母产生受损后代的情况。</li></ul><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oc"><img src="../Images/6dec8e05e45ece3a095539c109c8b938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhRa8i8lwBE87ELEKbxHqQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">一个整洁的历史标记的例子。来源:<a class="ae kv" href="http://nn.cs.utexas.edu/downloads/papers/stanley.cec02.pdf" rel="noopener ugc nofollow" target="_blank">神经网络拓扑的高效进化</a></figcaption></figure><ul class=""><li id="1d45" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated">物种形成:拓扑创新通常伴随着适应性的降低，并且需要时间来优化它的性能。然而，如果直接与总体竞争，新的拓扑很可能在达到其最佳适应度之前被淘汰。这就是为什么物种形成在NEAT中起着关键作用。NEAT测量两个基因组之间的相容性距离。相容性是由<em class="kw">匹配基因</em>的平均重量差和<em class="kw">过量</em>和<em class="kw">分离基因</em>的数量的线性组合计算的。基于相容性阈值，基因组被聚类成不同的物种。通过这样做，每一个基因组都与同一生态位内的基因组竞争。因此，一个新的物种将得到保护。</li></ul><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es od"><img src="../Images/db95ce49b01c9c3312ad0968fa9f700b.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*A_A-P3BsZAlBlKcpChFAsw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">相容距离的一个方程。来源:<a class="ae kv" href="http://nn.cs.utexas.edu/downloads/papers/stanley.cec02.pdf" rel="noopener ugc nofollow" target="_blank">神经网络拓扑的高效进化</a></figcaption></figure><ul class=""><li id="045b" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj">最小化维度</strong> : NEAT总是从一个统一的群体开始，没有任何隐藏节点。通过结构突变引入新的结构，并通过物种形成保护新的结构。然后，适应性评估确定创新是否有用。因此，NEAT只在需要时增加复杂性，从而减少训练时间。</li></ul><p id="779e" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">以下是对NEAT的这些重要组件之间的依赖关系的概述:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oe"><img src="../Images/75f3690b092921c5e4b2d5afb0aebae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-VKoq41VqTIdr0ywYb71w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">简单组件之间的依赖关系。来源:<a class="ae kv" href="http://nn.cs.utexas.edu/downloads/papers/stanley.cec02.pdf" rel="noopener ugc nofollow" target="_blank">神经网络拓扑结构的高效进化</a></figcaption></figure><p id="3c12" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">总之，NEAT (1)利用历史标记来固定基因并避免竞争约定，从而可以发生有意义的交叉，并且需要较少的拓扑分析；(2)基于相容性距离将种群分成物种，使得竞争主要在相同的生态位内，并且创新受到保护；(3)从最简单的结构开始，通过突变仅在必要时增长，以便更快地找到解决方案。</p><p id="2c8d" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">现在我们知道了NEAT是如何工作的，让我们看看如何使用它。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="43d2" class="iu iv hi bd iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr bi translated">Flappy Bird怎么涂NEAT？</h1><p id="c5cf" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">用Python实现NEAT相当简单，因为有一个开发良好的<a class="ae kv" href="https://neat-python.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> NEAT模块</a>，我们可以通过<em class="kw"> pip install neat-python </em>安装它。本模块的文档清楚地解释了如何在Python中运行NEAT。所以，来看看吧！</p><p id="062a" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">首先，设置一些稍后会用到的参数。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">整洁参数设置</figcaption></figure><p id="21e4" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我们还需要一个NEAT的配置文件。你可以在这里找到更多解释<a class="ae kv" href="https://neat-python.readthedocs.io/en/latest/config_file.html#" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7d78" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">以下是配置文件中的一些重要参数:</p><ul class=""><li id="99fa" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj"> fitness_threshold </strong>:用于检查我们是否得到可接受的解的参数。如果计算的适应度达到或超过该阈值，进化过程将终止。</li><li id="27bd" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj"> pop_size </strong>:每次迭代的基因组数量。</li><li id="d2af" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj"> survival_threshold </strong>:对于每一个物种，允许被选择用于繁殖的基因组的百分比。</li><li id="1631" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj"> activation_default </strong>:分配给每个新节点的激活函数。</li><li id="4215" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj"> conn_add_prob: </strong>在变异中，添加新连接的概率。</li><li id="6437" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj"> node_add_prob: </strong>在变异中，增加一个新节点的概率。</li></ul><p id="3055" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我的这个项目的配置文件如下所示。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">简洁的配置文件</figcaption></figure><p id="f248" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">适应度函数是游戏分数、存活时间和碰撞惩罚的组合。</p><p id="9b04" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">对于每一帧，模型的输入为:</p><ul class=""><li id="e086" class="md me hi ju b jv kq jz kr kd mf kh mg kl mh kp mi mj mk ml bi translated"><strong class="ju hj"><em class="kw">△_ x</em>:</strong>鸟与管道之间的水平距离</li><li id="adc6" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj"> <em class="kw"> delta_y_top </em> : </strong>鸟与顶部管道之间的垂直距离</li><li id="70a9" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><strong class="ju hj"><em class="kw">delta _ y _ bottom</em>:</strong>吊舱与底管之间的垂直距离。</li></ul><p id="1c69" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">输出是跳还是不跳。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/9579b97b1a50e158d9505070b994f1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdHLSNzf51njCy6sHSzolQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">输入和输出的演示</figcaption></figure><p id="6041" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">注意，所有的输入信息都来自即将到来的管道，所以我们需要一个函数来获取管道列表中最近的管道的索引。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">获取输入索引</figcaption></figure><p id="5f24" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我们还需要一些可视化的功能。你可以在这里查看一个例子<a class="ae kv" href="https://github.com/CodeReclaimers/neat-python/blob/master/examples/xor/visualize.py" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3c31" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">然后，我们将NEAT整合到游戏循环中。游戏通过循环运行。每个循环是一帧。在每一帧中，我们移动我们创建的三个对象，如果需要的话跳过鸟，检查碰撞，并计算游戏分数。游戏将根据游戏输入和游戏逻辑进行更新。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">主游戏循环</figcaption></figure><p id="6aff" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">最后，我们在终端中显示学习进度，将其可视化，并检查最佳模型的统计数据。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ng nh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">跑得整齐</figcaption></figure><h1 id="e86d" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结果</h1><p id="2de3" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">既然Flappy Bird是一个简单的游戏(从计算机的立场来看)，那么破解这个游戏只需要整整十代(0代是我们的第一种群)。我们来看看物种分布和适合度提升。</p><div class="kx ky kz la fd ab cb"><figure class="lb ij of ld le lf lg paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/d2d10cddac97ad944a4992b0c43db908.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*DEIppACRPpS9rn8TQ4ti2Q.png"/></div></figure><figure class="lb ij og ld le lf lg paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/641d8b09d510bf4bceac19b3334f5608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*6ULNv7CNE_XCDS1avflt1Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx oh di oi lj translated">物种分布(左)和适合度改善(右)</figcaption></figure></div><p id="e616" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">请注意，所有个体都属于同一物种，因为我们在任何拓扑创新发生之前就找到了解决方案。从第0代到第4代，所有的鸟几乎都是立刻撞到地面或者上限。从第5代开始，NEAT开始知道如何让这只鸟飞起来，但它仍然不知道如何通过管道。到了第9代，一个巨大的突破发生了:<strong class="ju hj">一只鸟学会了如何通过管道，成为了你在本文开头看到的熟练玩家</strong>。</p><p id="7d6d" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">这是我们最佳模型的架构。实线表示启用的连接，而虚线表示禁用的连接。绿线表示连接的权重为正，而红线表示权重小于或等于零。线宽表示连接权重的大小。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oj"><img src="../Images/ed8c3fe5c83898fb0450bbec75e3f5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gIC2qB00WH5Ng3fmQ61CQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">最佳模型的人工神经网络结构</figcaption></figure><p id="c29c" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">最终的架构只包括一个输入层和一个输出层。回想一下，NEAT总是从最小的起点进化结构(<em class="kw">最小化维度</em>)，所以NEAT能够有效地找到低维的解决方案。此外，<em class="kw"> delta_y_top </em>和<em class="kw"> delta_y_bottom </em>的权重均为正，而<em class="kw"> delta_x </em>的权重为非正。每个连接权重的大小几乎相同。</p><p id="b4dc" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">虽然种群很小(5条染色体/代)，但NEAT在十次迭代内就掌握了Flappy Bird。证明了NEAT是一种有效演化网络结构的健壮技术。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><p id="baac" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">非常感谢您的阅读！😄我希望你喜欢这篇文章。不要忘记检查这个项目的源代码。请随意使用、修改或投稿！我做过的更有趣的项目可以在<a class="ae kv" href="https://github.com/XuebinZhu/Projects" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="11e6" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">不要犹豫，在下面的评论区留下你的反馈。我很乐意与您分享任何关于Pygame、GA或NEAT的想法！你也可以通过<a class="ae kv" href="http://www.linkedin.com/in/xuebin-zhu" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。我总是想聊天！😃</p><p id="6ac0" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">如果你喜欢这篇文章，请点击拍手按钮👏所以其他人可能会偶然发现它。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="fb93" class="iu iv hi bd iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr bi translated">参考</h1><ul class=""><li id="9cb8" class="md me hi ju b jv jw jz ka kd ok kh ol kl om kp mi mj mk ml bi translated"><a class="ae kv" href="http://nn.cs.utexas.edu/downloads/papers/stanley.cec02.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="kw">高效进化的神经网络拓扑</em> </a>作者肯尼思·o·斯坦利</li><li id="2ea0" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="kw">通过扩充拓扑进化神经网络</em> </a>作者肯尼思·o·斯坦利</li><li id="673f" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="http://nn.cs.utexas.edu/downloads/papers/stanley.phd04.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="kw">通过复杂化实现神经网络的高效进化</em> </a>作者肯尼思·o·斯坦利</li><li id="1b1e" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="https://neat-python.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="kw">工整-Python文档</em> </a></li><li id="5f78" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated">亨特·海登赖希的《整洁:一种令人敬畏的神经进化方法》</li><li id="d9b3" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=b3D8jPmcw-g" rel="noopener ugc nofollow" target="_blank"> <em class="kw">【神经进化的扩增拓扑(工整)</em> </a>亨利·艾实验室著</li><li id="97be" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="https://openai.com/blog/emergent-tool-use/" rel="noopener ugc nofollow" target="_blank"><em class="kw">open ai从多智能体交互中使用的突现工具</em> </a> <em class="kw"> </em></li><li id="3794" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="https://arxiv.org/pdf/1712.06567.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="kw">深度神经进化:遗传算法是优步AI实验室训练深度神经网络进行强化学习</em> </a>的一种有竞争力的替代方案</li><li id="be63" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="https://www.pygame.org/docs/tut/newbieguide.html" rel="noopener ugc nofollow" target="_blank"><em class="kw">Pygame新手指南</em> </a></li><li id="1fc2" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="http://pygametutorials.wikidot.com/tutorials" rel="noopener ugc nofollow" target="_blank"> PyGame教程:游戏编程简单介绍</a></li><li id="e647" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated">【thenewboston的PyGame教程的YouTube播放列表</li><li id="5827" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="https://www.youtube.com/playlist?list=PLzMcBGfZo4-lwGZWXz5Qgta_YNX3_vLS2" rel="noopener ugc nofollow" target="_blank"> AI和Tim一起用Tech的NEAT Python玩Flappy Bird】</a></li><li id="cba1" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="https://www.youtube.com/playlist?list=PLZ1QII7yudbebDQ1Kiqdh1LNz6PavcptO" rel="noopener ugc nofollow" target="_blank">使用Bluefever软件开发的Flappy和Pygame的神经网络</a></li><li id="c293" class="md me hi ju b jv mm jz mn kd mo kh mp kl mq kp mi mj mk ml bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=itB6VsP5UnA" rel="noopener ugc nofollow" target="_blank">CodeWithHarry为绝对初学者编写的Flappy Bird Python教程</a></li></ul></div></div>    
</body>
</html>