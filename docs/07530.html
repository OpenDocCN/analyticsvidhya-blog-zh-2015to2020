<html>
<head>
<title>Setting Apache Nifi on Docker Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Docker容器上设置Apache Nifi</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/setting-apache-nifi-on-docker-containers-a00e862a8399?source=collection_archive---------0-----------------------#2020-06-29">https://medium.com/analytics-vidhya/setting-apache-nifi-on-docker-containers-a00e862a8399?source=collection_archive---------0-----------------------#2020-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c556" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如果您正在寻找一个简单但健壮的工具来处理来自不同来源的数据，那么Apache Nifi是您的首选。你想尝试，但不知道从哪里开始？这本指南是给你的。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d9b80d9344961dacfa8b07c19050781b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jwbVB8P9gWAjy4lrBY5seQ.png"/></div></div></figure><p id="9a1f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我工作的系统即将经历一次重大的技术更新。目标是改善当前阻止获取更多数据的障碍。补救措施需要一种产品，它从外部来源接收输入，对其进行处理，并将结果传播到目的地。</p><p id="f6b4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Apache Nifi实现了<a class="ae kf" href="https://en.wikipedia.org/wiki/Flow-based_programming" rel="noopener ugc nofollow" target="_blank">基于流的编程(FBP) </a>范式；它由通过预定义的连接交换数据的黑盒过程组成(摘自维基百科)。</p><blockquote class="kg"><p id="f49c" class="kh ki hi bd kj kk kl km kn ko kp ke dx translated">简而言之，Apache NiFi是一个处理和分发数据的工具。其直观的UI支持路由定义、各种连接器(输入/输出)和许多内置处理器。所有这些特性结合在一起，使它成为我们用例的一个合适的可选平台。</p></blockquote><p id="010c" class="pw-post-body-paragraph jj jk hi jl b jm kq ij jo jp kr im jr js ks ju jv jw kt jy jz ka ku kc kd ke hb bi translated">考虑到我们系统未来的需求，我们决定对Nifi进行彻底的评估。起点是建立一个环境。</p><p id="ad6c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我将描述如何使用Docker映像建立一个Nifi环境，并运行一个简单的预定义模板；从头开始构建Nifi流将在另一篇文章中讨论。文章的三个主要部分是:</p><ul class=""><li id="7bc1" class="kv kw hi jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld bi translated">回顾Apache Nifi概念和构建块</li><li id="c839" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated">设置Nifi流和Nifi注册表(基于Docker图像)</li><li id="8812" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated">加载模板并运行它</li></ul><p id="dd13" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">准备好了吗？让我们从基础开始。</p><h1 id="84a0" class="lj lk hi bd ll lm ln lo lp lq lr ls lt io lu ip lv ir lw is lx iu ly iv lz ma bi translated">Nifi组件和概念</h1><p id="386a" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">Nifi基于以下层次结构:</p><ul class=""><li id="a879" class="kv kw hi jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld bi translated"><strong class="jl hj">进程组</strong> <br/>处理器及其连接的集合。进程组是保存在版本控制(Nifi注册表)中的最小单元。一个进程组可以有允许连接进程组的输入和输出端口。这样，数据流可以由多个进程组组成。</li><li id="0b6f" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated"><strong class="jl hj">处理器<br/> </strong>(大部分)具有通过连接器<em class="mg">链接到另一个处理器的输入和输出的处理单元。每个处理器都是一个执行单一操作的黑盒；例如，处理者可以更改流文件的内容或属性(见下文)。</em></li><li id="7cc8" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated"><strong class="jl hj">流文件</strong> <br/>这是由两部分(内容和属性)组成的逻辑数据集，在Nifi处理器之间传递。FlowFile对象是不可变的，但是它的内容和属性可以在处理过程中改变。</li><li id="5669" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated"><strong class="jl hj">连接<br/> </strong>连接是在处理器之间路由流文件的队列。路由逻辑基于与处理器结果相关的条件；一个连接与一个或多个结果类型相关联。连接的条件是处理器之间的关系，可以是静态的，也可以是动态的。静态关系是固定的(例如，成功、失败、匹配或不匹配)，而<em class="mg">动态关系</em>基于用户定义的流文件的属性；本文的最后一节用<em class="mg"> RouteOnAttribute </em>处理器举例说明了这个特性。</li><li id="f681" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated"><strong class="jl hj">端口<br/> </strong>一个进程组的入口和出口点。每个进程组可以有一个或多个输入或输出端口，通过它们的名称来区分。</li><li id="ceab" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated"><strong class="jl hj">漏斗<br/> </strong>将来自多个连接的数据组合成一个连接。</li></ul><p id="3208" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的Nifi流程描述了这些组件:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/c293341c62d05290eafaeaa291b8e7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMqHXbUruXHCEj4iUDctuA.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">过程组和Nifi元素</figcaption></figure><p id="8072" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在回顾了Nifi数据流组件之后，让我们看看如何设置一个环境。</p><h1 id="fddf" class="lj lk hi bd ll lm ln lo lp lq lr ls lt io lu ip lv ir lw is lx iu ly iv lz ma bi translated">设置Nifi环境</h1><p id="4638" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">我没有在我的机器上安装Nifi，而是选择使用托管在Docker容器上的Nifi，主要原因如下:</p><ul class=""><li id="51ba" class="kv kw hi jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld bi translated">可移植性:Nifi应用程序可以被复制或移动到另一台主机上。</li><li id="083d" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated">在同一台主机上拥有多个Nifi应用程序的灵活性，每个应用程序都有不同的端口。</li><li id="1d06" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated">低占用空间:避免更换主机。</li><li id="e41d" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated">在定义Nifi流的过程中拍摄快照时，能够冻结环境。</li></ul><h2 id="c283" class="mm lk hi bd ll mn mo mp lp mq mr ms lt js mt mu lv jw mv mw lx ka mx my lz mz bi translated">启动Nifi应用程序</h2><p id="b284" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">我使用的是Ubuntu，一个基于Debian的Linux，所以你可以在本文中找到安装和配置<a class="ae kf" href="https://liorshalom.com/2019/02/12/docker-on-a-linux-based-ec2-containerizing-a-c-net-api-service/" rel="noopener ugc nofollow" target="_blank"> Docker的命令。</a></p><p id="b14d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">安装Docker后，从<a class="ae kf" href="https://hub.docker.com/r/apache/nifi/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>下载最新的Nifi镜像版本。</p><p id="24fa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您<strong class="jl hj">可以</strong>使用默认设置创建并启动Docker容器:</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="c6b9" class="mm lk hi nb b fi nf ng l nh ni">$ docker run apache/nifi</span></pre><p id="2b92" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是，我想创建一个稍微复杂一点的容器，它允许:</p><ul class=""><li id="d9ea" class="kv kw hi jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld bi translated">命名我的容器(我将其命名为<em class="mg"> nifi2 </em>)</li><li id="2f6d" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated">控制端口，而不是默认的8080端口</li><li id="ef9b" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated">能够看到Nifi的加载和标准输出</li><li id="c9b8" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated">在我的主机(<em class="mg">共享目录</em>)和容器(<em class="mg"> ls目标</em>)之间创建一个共享卷</li></ul><p id="1c45" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的示例命令实现了上述功能(容器的名称是<em class="mg"> nifi2) </em>:</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="7b74" class="mm lk hi nb b fi nf ng l nh ni">$ docker run --name nifi2 -p 8091:8080 <!-- -->-i <strong class="nb hj">-v </strong>~/document/Nifi/<strong class="nb hj">shared-directory:</strong>/opt/nifi/nifi-current/<strong class="nb hj">ls-target </strong>apache/nifi</span></pre><p id="dc5f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">万岁！您的Nifi应用程序正在运行，可以通过端口8091访问。</p><p id="8826" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来是设置一个版本控制工具——Nifi注册表。</p><h2 id="893c" class="mm lk hi bd ll mn mo mp lp mq mr ms lt js mt mu lv jw mv mw lx ka mx my lz mz bi translated">启动Nifi注册表</h2><p id="7057" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated"><a class="ae kf" href="https://nifi.apache.org/registry" rel="noopener ugc nofollow" target="_blank"> Nifi Registry </a>是Nifi的一个独立子项目，允许对Nifi流进行版本控制。它允许保存流的状态，在不同的Nifi应用程序之间共享流，支持回滚和其他版本控制特性。</p><p id="1ea4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然您可以备份包含所有进程组信息的flowfile.xml.gz<em class="mg">文件，但是管理版本的正确方法是使用Nifi Registry它的主要优点是保存封装在每个进程组专用的<em class="mg"> flow.json </em>文件中的更改的简单性。</em></p><p id="418f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Nifi注册表镜像在<a class="ae kf" href="https://hub.docker.com/r/apache/nifi-registry/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>中可用；运行命令<code class="du nj nk nl nb b">docker pull</code>来安装它。</p><p id="4e4e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的Docker命令定义并启动一个Nifi注册表容器。我选择不使用<code class="du nj nk nl nb b">-d</code> (detach)选项，正如DockerHub中所建议的，这样容器的进度和输出将在运行时可见。与Nifi容器不同，这次我选择保留默认端口，因为我不会使用多个Nifi注册表实例。</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="b003" class="mm lk hi nb b fi nf ng l nh ni">$ docker run --name nifi-registry -p 18080:18080 apache/nifi-registry</span></pre><h2 id="11e5" class="mm lk hi bd ll mn mo mp lp mq mr ms lt js mt mu lv jw mv mw lx ka mx my lz mz bi translated">将Nifi应用程序连接到版本控制</h2><p id="7c95" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">通常，我们可以将一个Nifi应用程序连接到一个或多个注册中心。这为在多个环境中工作提供了灵活性。</p><p id="1536" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要将我们的nifi应用程序(<em class="mg">http://localhost:8091/Nifi</em>)连接到注册表，让我们访问Nifi设置→注册表客户端→ [+]。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nm"><img src="../Images/bef8d63ec3c1c469cd4b121af4e5b2e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3D34s492WBSC1m77ZIiQFg.png"/></div></div></figure><p id="88a7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们需要注册地址。由于Nifi应用程序没有在主机上运行，因此尝试使用地址<a class="ae kf" href="http://localhost:18080/nifi-registry" rel="noopener ugc nofollow" target="_blank"><em class="mg">http://localhost:18080/Nifi-Registry</em></a>访问Nifi注册表将不起作用。我们的Nifi应用程序从一个容器中运行，因此它需要外部主机的IP。通过检查Nifi的容器可以获得主机的IP。</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="562d" class="mm lk hi nb b fi nf ng l nh ni">$ docker inspect nifi2</span></pre><p id="211a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">主机的IP是<em class="mg">网关</em>:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nn"><img src="../Images/a801c1fdb6396ee5203eeb90ae68d076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*goQ6estQ3iFoiMr1"/></div></div></figure><p id="376a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于此命令的输出非常广泛，下面的命令将只获取网关IP:</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="6739" class="mm lk hi nb b fi nf ng l nh ni">$ docker inspect nifi2 --format='{{<!-- -->.NetworkSettings.Networks.bridge.Gateway<!-- -->}}'</span></pre><p id="dccb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">之后，Nifi注册中心的定义就很简单了。下图举例说明了一个连接到两个Nifi注册表实例的Nifi应用程序。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es no"><img src="../Images/170a0adb9ba4b515b1ffd4f97f0876d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nm-TSFvHEm5n7AwOgRVEAg.png"/></div></div></figure><p id="982b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，在设置了至少一个注册表之后，有一个新的菜单选项可以在版本控制中保存一个进程组。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es np"><img src="../Images/938e67835f3ccb4b3ab42f5446d3f6d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*WcbLf2Y51wpxuWJmnOG3RQ.png"/></div></figure><p id="8472" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">配置Bucket是设置Nifi注册表的下一步，也是最后一步。一个桶是一个或多个版本的过程组的容器；在Nifi注册表中至少应该有一个篮子来存放Nifi流。</p><p id="f65d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们创建一个桶，并将其命名为<em class="mg">流程开发。</em>在下图中，我创建了两个存储桶，一个用于开发，另一个用于暂存:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nq"><img src="../Images/043475ea58317bdd2e419efe67880fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XICPDhEwtbz9jPyev9K5yA.png"/></div></div></figure><p id="f58d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然我们的Nifi画布是空的，没有要保存的进程组，但是基础在那里。在我们创建一个进程组之后，它可以被保存到注册表中。</p><p id="a754" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们准备继续前进。</p><h1 id="dc33" class="lj lk hi bd ll lm ln lo lp lq lr ls lt io lu ip lv ir lw is lx iu ly iv lz ma bi translated">探索Nifi容器</h1><p id="27e2" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">一旦Nifi容器运行，我们就可以运行命令<code class="du nj nk nl nb b">docker exec</code>进入容器并探索它；下面的命令在容器中运行<em class="mg"> bash </em>(使用参数<em class="mg"> -i </em>进行交互，使用参数<em class="mg"> -t </em>进行终端):</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="d14c" class="mm lk hi nb b fi nf ng l nh ni">$ docker exec -i -t nifi2 /bin/bash</span></pre><p id="c7ad" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在容器的目录中导航，您可以到达保存有<strong class="jl hj">flow.xml.gz</strong>文件的<code class="du nj nk nl nb b">nifi/conf</code>目录。该文件包含所有Nifi UI画布信息，包括所有进程组；任何更改都会自动保存。</p><p id="64b4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">另一个重要文件是<code class="du nj nk nl nb b">conf/nifi.properties</code>。它保存了Nifi 的<a class="ae kf" href="https://github.com/apache/nifi/blob/master/nifi-commons/nifi-properties/src/test/resources/NiFiProperties/conf/nifi.properties" rel="noopener ugc nofollow" target="_blank">配置，包括<strong class="jl hj">flow.xml.gz</strong>的位置。您可以在此链接</a>中阅读更多关于<a class="ae kf" href="https://nifi.apache.org/docs/nifi-docs/html/administration-guide.html" rel="noopener ugc nofollow" target="_blank">配置文件的信息。</a></p><h2 id="b180" class="mm lk hi bd ll mn mo mp lp mq mr ms lt js mt mu lv jw mv mw lx ka mx my lz mz bi translated">Nifi知识库</h2><p id="6ca7" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">Nifi有三个主要的存储库:</p><ol class=""><li id="b17a" class="kv kw hi jl b jm jn jp jq js kx jw ky ka kz ke nr lb lc ld bi translated">流文件存储库:在活动流期间存储流文件的元数据。</li><li id="2790" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke nr lb lc ld bi translated">内容存储库:保存流文件的实际内容。</li><li id="4ba6" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke nr lb lc ld bi translated">出处储存库:存储每个处理器中的流文件的快照。这样，它概述了详细的数据流和每个处理器中的变化，并允许深入发现事件链。</li></ol><p id="c6ee" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在进入Nifi容器之后，这些存储库揭示了:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ns"><img src="../Images/923f29f876cc2be16d32fe5783242bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*5aSMe8QmHe53OrPK7J8B-Q.png"/></div></figure><h1 id="1fc5" class="lj lk hi bd ll lm ln lo lp lq lr ls lt io lu ip lv ir lw is lx iu ly iv lz ma bi translated">导入Nifi流</h1><p id="1a48" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">因此，在设置和运行Nifi应用程序并将其连接到Nifi Registry之后，您就可以开始运行数据流了。</p><p id="a4e6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们加载一个现有的Nifi流，而不是从头开始构建。将流加载到Nifi有两个选项:</p><ul class=""><li id="4b4e" class="kv kw hi jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld bi translated">将模板导入Nifi流(XML文件)</li><li id="1a23" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated">将流定义(JSON文件)导入到Nifi Registry中，然后从中创建一个流程组。</li></ul><p id="fe24" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">第一种是直接的，而后者稍微复杂一点，但是可以使用Nifi工具包轻松完成，这不在本文讨论范围之内。</p><p id="541f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可以从GitHub 下载<a class="ae kf" href="https://github.com/liorksh/Nifi/blob/master/SimpleFlow/SimpleFlow-template.xml" rel="noopener ugc nofollow" target="_blank">示例模板，然后上传到您的Nifi应用程序:</a></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nt"><img src="../Images/e8e27c1cb3bd4c44635fd0c9136adc07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oeUCtO7UNOTQQCe-tldcJg.png"/></div></div></figure><h1 id="2db3" class="lj lk hi bd ll lm ln lo lp lq lr ls lt io lu ip lv ir lw is lx iu ly iv lz ma bi translated">了解模板的流程</h1><p id="1ab7" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated"><a class="ae kf" href="https://github.com/liorksh/Nifi/blob/master/SimpleFlow/SimpleFlow-template.xml" rel="noopener ugc nofollow" target="_blank">这个模板</a>包括五个步骤，从生成一个带有随机文本的文件开始，重命名它，提取属性，并根据提取的属性将结果路由到目录中(细节在<a class="ae kf" href="https://github.com/liorksh/Nifi/blob/master/SimpleFlow/TemplateDescription.md" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中描述)。</p><p id="d15a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦处理结束，文件就保存在容器本身的本地目录下。回到容器的<em class="mg">运行</em>命令显示它包含一个共享卷定义(<code class="du nj nk nl nb b">ls-target</code>)。该卷是已处理文件的目标，因此可以从主机访问它:</p><pre class="iy iz ja jb fd na nb nc nd aw ne bi"><span id="cee1" class="mm lk hi nb b fi nf ng l nh ni">$ docker run --name nifi2 -p 8091:8080 <!-- -->-i <strong class="nb hj">-v </strong>~/document/Nifi/<strong class="nb hj">shared-folder:</strong>/opt/nifi/nifi-current/<strong class="nb hj">ls-target </strong>apache/nifi</span></pre><p id="0dbe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">故障排除</strong>:如果未授予权限，您可能无法将文件放入目录中:(错误消息为<em class="mg">“权限被拒绝”):</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nu"><img src="../Images/f71e215ee8bb65182b3e95c3d7d3d20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/0*uR8ZFiwLUi-4mmuP"/></div></div></figure><p id="647f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要纠正这个问题，请授予目录权限(<em class="mg"> chmod </em>命令)。</p><p id="418c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个目录也可以从容器内部访问:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ns"><img src="../Images/f5c998d8d1e1891737279172f14c74bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*1oQtP9Op4byYnn4ahfI2iA.png"/></div></figure><p id="fe52" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">打开进程组的变量，可以看到在那里定义了目标文件夹:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nv"><img src="../Images/1e88c0963d5f30d8df76b831bf501a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*mge2zNxtGrNGzZVI9AmLuQ.png"/></div></figure><h2 id="d88f" class="mm lk hi bd ll mn mo mp lp mq mr ms lt js mt mu lv jw mv mw lx ka mx my lz mz bi translated">潜入Nifi处理器</h2><p id="e7dd" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">右键单击画布(不是特定的处理器)并选择<em class="mg">启动</em>按钮，可以同时启动所有处理器。过一会儿，文件应该到达目标文件夹。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nw"><img src="../Images/690ccc43350b9d655c92a989828a2f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3n07w65M08X_ug-B93p-g.png"/></div></div></figure><p id="7af9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">每个生成的文件都经历了一个更改其名称并根据其内容进行路由的过程；我更喜欢保持简单，避免改变文件的内容。然而，这个模板举例说明了Nifi处理器的一些特性:</p><ul class=""><li id="4ae2" class="kv kw hi jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld bi translated">基于内容提取属性:</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nx"><img src="../Images/4c3eea9016155fda6a1e38fdb9bdb757.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*5ufWcPlnO3q30HWgOAiscA.png"/></div></figure><ul class=""><li id="2756" class="kv kw hi jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld bi translated">使用属性并改变文件名(<a class="ae kf" href="https://nifi.apache.org/docs/nifi-docs/html/nifi-in-depth.html#updating-attributes" rel="noopener ugc nofollow" target="_blank">flow file的一个属性</a>):</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ny"><img src="../Images/1fc1e49b123eb4f184532c2711bbd4a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*Fi2RRAQ6yZZliJ9ZHJhxWQ.png"/></div></figure><ul class=""><li id="5ecb" class="kv kw hi jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld bi translated">举例说明Nifi表达语言:</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nz"><img src="../Images/ada6a1b13fd71b73159b6e2b4641940a.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*KuZKZcQ6_YHgWd8x9shWSA.png"/></div></figure><ul class=""><li id="67d1" class="kv kw hi jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld bi translated">基于属性的路由逻辑:</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oa"><img src="../Images/83bd684f3e96ae45ad5beafb248585ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*WBztPEWjK5AyViN-PDFJgA.png"/></div></figure></div><div class="ab cl ob oc gp od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="hb hc hd he hf"><p id="57d4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">该模板使用以下处理器:</p><ul class=""><li id="263d" class="kv kw hi jl b jm jn jp jq js kx jw ky ka kz ke la lb lc ld bi translated"><strong class="jl hj"> GenerateFlowFile </strong>:生成流文件，用于测试目的。它允许控制每个流文件的频率、数量和大小。</li><li id="ce4a" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated"><strong class="jl hj">提取文本</strong>:从流文件的内容中提取文本。</li><li id="86ac" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated"><strong class="jl hj">更新属性</strong>:更新流文件的属性。</li><li id="8c4d" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated"><strong class="jl hj"> RouteOnAttribute </strong>:创建动态关系，并根据属性值定义路由逻辑。</li><li id="fb41" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated"><strong class="jl hj"> PutFile </strong>:将流文件的内容保存到一个目录中。在本例中，如果目标目录不存在，处理器将创建它并设置文件的权限。</li></ul><h2 id="64d2" class="mm lk hi bd ll mn mo mp lp mq mr ms lt js mt mu lv jw mv mw lx ka mx my lz mz bi translated">演示背压特性</h2><p id="3562" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">一旦进程运行，你可以停止<em class="mg">更新文件名</em>处理器，看看会发生什么。不一会儿，将流文件传递给<em class="mg">更新文件名</em>的连接器将达到一个极限，并抑制文件流入流中的前一个处理器。</p><p id="3a62" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这种行为展示了背压的定义；连接器受到流文件数量或其整体大小的限制。万一这个机制被激活，就指出了一个问题。这是开始调查哪里出了问题的导火索。这可能是一个问题，例如处理器故障，或者是基本负载增加的指示，因此应该调整或分配流量。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oi"><img src="../Images/9196e8ccf5eb902db104d753d0ad161c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A47qgYBv4wa3RpCfKkeP6Q.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">背压示例</figcaption></figure><h1 id="457f" class="lj lk hi bd ll lm ln lo lp lq lr ls lt io lu ip lv ir lw is lx iu ly iv lz ma bi translated">将进程组保存到Nifi注册表中</h1><p id="d98f" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">在运行模板并对其稍作修改后，您想要保存它。还记得Nifi注册表吗？</p><p id="0816" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">选择<em class="mg">启动版本控制</em>，将流程组保存到之前创建的桶中:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oj"><img src="../Images/7b2b1cf033414f3846b85784d067556e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iV9Nf9yQtOsumEdMEDgrFA.png"/></div></div></figure><p id="4173" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Nifi指示版本控制中是否捕获了进程组的最新状态:绿色的复选标记表示它已经保存在注册表中。如果有未提交到注册表的更改，则用一个暗星号表示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ok"><img src="../Images/4ec905f200e48bd7aca7ab74f92c77ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsVSQvLuLGYuOIvcd8SgKg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">提交的过程组与未提交变更的PG</figcaption></figure><h1 id="523a" class="lj lk hi bd ll lm ln lo lp lq lr ls lt io lu ip lv ir lw is lx iu ly iv lz ma bi translated">关闭前的一些最佳实践</h1><ul class=""><li id="ffd2" class="kv kw hi jl b jm mb jp mc js ol jw om ka on ke la lb lc ld bi translated">建议使用进程组，因为这是保存在Nifi注册表中的最小单元。</li><li id="ed78" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated">使用注释、标签和颜色来记录和组织Nifi流程。</li><li id="a44c" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated">Nifi具有广泛的自动化功能(Nifi REST API，<a class="ae kf" href="https://nifi.apache.org/docs/nifi-docs/html/toolkit-guide.html" rel="noopener ugc nofollow" target="_blank"> Nifi Toolkit </a>)，这在本文中没有涉及。Nifi工具包可以使用命令行工具自动化流程；除了工作效率更高之外，这种自动化的好处对于建立CI/CD管道也很重要。</li></ul><h1 id="e923" class="lj lk hi bd ll lm ln lo lp lq lr ls lt io lu ip lv ir lw is lx iu ly iv lz ma bi translated">下一步是什么？</h1><p id="2181" class="pw-post-body-paragraph jj jk hi jl b jm mb ij jo jp mc im jr js md ju jv jw me jy jz ka mf kc kd ke hb bi translated">如果您已经做到了这一点，那么您已经获得了实现应用程序的工作平台；这个模板只使用了几个基本的处理器，但是它可以作为一个跳板，继续构建一个更复杂的流，使用令人印象深刻的各种Nifi处理器。</p><p id="72d8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这篇文章只触及了冰山一角；有许多方面和功能需要涵盖，如数据来源、日志记录、变量和参数、Nifi服务、使用漏斗聚合处理器输出等等。自动化的支持工具也是一个很大的领域。</p><p id="2ac1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我将把这些主题留给后续文章。</p><p id="623e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">继续建设！</p><p id="33f8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">— Lior</p><h1 id="d4a3" class="lj lk hi bd ll lm ln lo lp lq lr ls lt io lu ip lv ir lw is lx iu ly iv lz ma bi translated">参考资料:</h1><ul class=""><li id="d783" class="kv kw hi jl b jm mb jp mc js ol jw om ka on ke la lb lc ld bi translated"><a class="ae kf" href="https://nifi.apache.org/docs/nifi-docs/html/user-guide.html" rel="noopener ugc nofollow" target="_blank"> Nifi文档</a></li><li id="8037" class="kv kw hi jl b jm le jp lf js lg jw lh ka li ke la lb lc ld bi translated"><a class="ae kf" href="https://nifi.apache.org/docs/nifi-registry-docs/index.html" rel="noopener ugc nofollow" target="_blank"> Nifi注册管理机构文档</a></li></ul></div></div>    
</body>
</html>