<html>
<head>
<title>A Week of Machine Learning: Day 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一周的机器学习:第四天</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-week-of-machine-learning-4th-day-599e53032c97?source=collection_archive---------6-----------------------#2019-09-18">https://medium.com/analytics-vidhya/a-week-of-machine-learning-4th-day-599e53032c97?source=collection_archive---------6-----------------------#2019-09-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bc70b5e6eef69f6424e4a803ee2de2b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pm03aRq3G8iZGUTWZUeshA.png"/></div></div></figure><ul class=""><li id="2437" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">一周的机器学习:第一天</li><li id="fcdf" class="iq ir hi is b it jj iv jk ix jl iz jm jb jn jd je jf jg jh bi translated"><a class="ae ji" rel="noopener" href="/analytics-vidhya/a-week-of-machine-learning-2nd-day-d14c4a9b08f">一周的机器学习:第二天</a></li><li id="d0d8" class="iq ir hi is b it jj iv jk ix jl iz jm jb jn jd je jf jg jh bi translated"><a class="ae ji" rel="noopener" href="/analytics-vidhya/a-week-of-machine-learning-3rd-day-13843fda63c3">为期一周的机器学习:第三天</a></li></ul><h1 id="0e2c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">决策树</h1><p id="2cfe" class="pw-post-body-paragraph km kn hi is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hb bi translated">我会尽量保持简单。想象一棵树。因为树有不同的分支，每个分支又进一步分成新的分支。这里使用了相同的概念。我们称之为决策树，是因为在每个节点上，我们都决定向哪个分支前进。像这样移动，我们到达终点，我们在那里有我们的答案。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/93f914e257fc7c8fa900b10d64c06e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X39y-RVQIxQTbQP4naXyoA.png"/></div></div></figure><p id="c3ab" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">我将解释代码的每一部分。事实证明，在处理表格数据或结构化数据时，树非常有效。以上是决策树的一个实现。我们正在解决一个分类问题。你应该自己编写整个代码来更好地理解它，这也会让你在编码时感到舒服。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/e40b33cc4f7990c5011472fa0359cfb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*tl-LEaD7IhgiYIQ5doxnTA.png"/></div></figure><p id="eeb9" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">在这里，我们导入所需的库。熊猫加载和处理数据。另一个是我们的分类器。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/cd8c3ce8086b33f5abd4fe4bf03ba1a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*oLSzyYMAsY2wKfKMYU9fqA.png"/></div></figure><p id="a1ad" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">我们正在这里加载数据。在pandas中，我们可以提供本地数据的路径，即已经下载的路径，或者我们可以传递数据的URL。熊猫将下载数据并载入数据帧。这里链接到数据集的是<a class="ae ji" href="https://query.data.world/s/67p5gkjye5vocfiqm2cuxnrkx4ijim" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="ln">。</em> </strong> </a></p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/c9f438f681285a886bdc7359e9715da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*tQcI9fwSvZ4VtExe-XmAsA.png"/></div></figure><p id="2ccf" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">这是为了打印前5行。我们需要调查我们的数据。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/9a03fb7847c27628b99a240d23ecf09c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*GesiVw0VDi5GZnIQAPjkQQ.png"/></div></figure><p id="dfe5" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">这提供了关于我们数据的基本信息。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/fe89649db0dff6cf8fbeb6428a231ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*tkaF_rfpeJjuarJBM2Ngbw.png"/></div></figure><p id="648f" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">从<strong class="is hj"> <em class="ln"> info() </em> </strong>中，我们发现‘3P %’的值为空。所以我们需要填充这些空值。我们使用<strong class="is hj"> <em class="ln"> fillna() </em> </strong>函数将它们填充为0。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/ef0c4870df589af08005fc3705d3987c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*bOE1_eJHiHROCvj2rHGumA.png"/></div></figure><p id="91db" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">这里我们绘制了目标值，以检查我们有多少真值和多少假值。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/c89691feee5e51bb57e6fde2b48548a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*zYUyU1VG6nerczah0f3A0g.png"/></div></figure><p id="ea4a" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">获取不同变量中的目标值和特征值。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/d4c84720bb6da5ecffc39ccf1d0bcd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*uZPlG0V5yEwmiDgxI6rC5w.png"/></div></figure><p id="598c" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">在训练和测试集中拆分我们的数据。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/a71389e3d95ae7a8a4659c4919c0ef6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*yLI4arFDVVlC26fTUZzBEA.png"/></div></figure><p id="946e" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">创建分类器。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/eaaeb427c7ddc7f02ea3a60f80dfedeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*AhSaPqGZwq69LAHx6Pr5Vw.png"/></div></figure><p id="02fb" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">训练分类器并根据测试数据对其进行测试。<strong class="is hj"> <em class="ln">得分()</em> </strong>用于打印准确度。</p><h1 id="a610" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">集成学习</h1><p id="cdcd" class="pw-post-body-paragraph km kn hi is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hb bi translated">单一模型无法覆盖数据的多样性。因此，我们需要一个以上的模型一起工作。这种技术被称为集成学习。在这种情况下，我们将不同模型的结果结合起来，产生我们的最终结果。所有模型都对最终结果有贡献。这就像把对一个问题有不同看法的不同人的意见结合起来。</p><p id="d087" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">集成学习用于增加决策树的能力。我们有两种方法</p><ol class=""><li id="faec" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd lu jf jg jh bi translated"><strong class="is hj">装袋</strong></li><li id="bed8" class="iq ir hi is b it jj iv jk ix jl iz jm jb jn jd lu jf jg jh bi translated"><strong class="is hj">增压</strong></li></ol><h1 id="4c08" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">制袋材料</h1><p id="69e4" class="pw-post-body-paragraph km kn hi is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hb bi translated">在这种技术中，我们创建了彼此独立的不同的树。然后在最后，我们结合他们的结果得到我们的最终结果。随机森林是装袋的一个很好的例子。性能非常好。我不会深入研究它背后的数学原理，因为现在还不需要。作为初学者，首先要学会如何使用事物及其基本概念。然后一个接一个地，我们应该深入他们。这保持了学习的趣味性。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><h1 id="3e3c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">随机森林</h1><p id="889b" class="pw-post-body-paragraph km kn hi is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hb bi translated">这是装袋的一种。在该算法中，样本和特征是随机选取的。选择特征来分割树的分支。在决策树中，这是通过杂质分数来完成的。选择具有最小杂质分数的特征来分割树。但是在随机森林的情况下，我们是随机进行的。通过这样做，我们有了许多较弱的树。我们把所有弱树的结果结合起来，这就是我们如何覆盖大量的多样性。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/cb2d5809350aae5771aec64ecdcdae03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JO-Z4h35jjM2GZX380nitg.png"/></div></div></figure><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/3c80eb57d3c55b12c3da8525ac11dcc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*NbXPwL8GHnlRx6CkxsDSVQ.png"/></div></div></figure><p id="dc76" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">代码的其余部分是相同的。只有两个部分有所增加。我们导入了RandomForestClassifier来创建模型。使用sklearn非常简单。我们可以很容易地创建和训练一个模型。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/3badf144f0b0f4f7e1eaf93a7d427039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*VoE1TIS2uzPMGHcFxvQJ3w.png"/></div></figure><p id="a4f8" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">这里我们创建了RandomForestClassifier的一个实例。然后用<strong class="is hj"> <em class="ln"> fit() </em> </strong>的方法我们训练了它。score()方法用于检查准确性。</p><h1 id="a42b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">助推</h1><p id="57c6" class="pw-post-body-paragraph km kn hi is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hb bi translated">在这里，我们创建了许多不同的树，但是它们依赖于前面的树。一棵树试图最小化先前树的误差。这一切背后的数学原理非常简单，但现在，我不打算深究。请记住，在提升一棵树的过程中，需要从之前的树中获取输入，并尽量减少误差，就像这样，我们有很多不同的树。但是在bagging中，我们创建不同的树，它们独立工作，最后我们平均(在回归的情况下)或最高票(在分类的情况下)。</p><h1 id="cdc5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">LightGBM</h1><p id="9c3d" class="pw-post-body-paragraph km kn hi is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hb bi translated">这是一个非常著名且被广泛使用的算法。它使用助推概念。它非常简单，易于使用。Lightgbm在大多数情况下非常适合处理表格数据。下面是一个代码示例。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/41c4f73dad19406a40a6ac30e834543d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9q5rdsFjydSzlqj88koBg.png"/></div></div></figure><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/0327bb82edf08e85f1098fe98f767dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*yaK8Smyoq_1lwczQXYsAOw.png"/></div></div></figure><p id="33f0" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">我们需要安装LightGBM库。如果你正在使用谷歌Colab，那么你不必担心它。但是如果你在本地机器上工作，那么就安装LightGBM。这是一个非常简单和容易的过程。我们给LightGBM分配了<strong class="is hj"> <em class="ln"> lgb </em> </strong>名称，这样我们就不需要每次都输入全名了。<strong class="is hj"> <em class="ln"> as </em> </strong>用于指定任何你想给的名字。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/6b1314b6c70bca25d76e3ba7cbec74c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*0N24kvrbu16ZBZjCMrkccw.png"/></div></figure><p id="5d2f" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">简单的步骤。创建LightGBM的实例，然后使用<strong class="is hj"> <em class="ln"> fit() </em> </strong>方法训练模型，使用<strong class="is hj"> <em class="ln"> score() </em> </strong>方法测试或检查准确性。</p><p id="1a3e" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">还有其他的提升算法。比较有名的有XGBoost，CatBoost等。但是LightGBM比XGBoost使用的内存更少，效率更高。</p><p id="77ac" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">如果你自己写代码，你会学到更多。因为你是初学者，不要只是复制和粘贴代码。如果你想复制一段代码，那就看着它，自己打出来。看多少遍都没关系。但是你应该试着自己输入，在你的工作完成后，再去玩那些代码。</p><p id="657f" class="pw-post-body-paragraph km kn hi is b it iu kp kq iv iw ks kt ix li kv kw iz lj ky kz jb lk lb lc jd hb bi translated">如果你有一些表格数据，但不知道该用哪种算法。我会说去找树。从随机森林开始，然后尝试LightGBM。</p><h1 id="d12d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">快乐学习！！</h1><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="mc lw l"/></div></figure></div></div>    
</body>
</html>