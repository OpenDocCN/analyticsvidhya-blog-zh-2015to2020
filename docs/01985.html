<html>
<head>
<title>Data Preprocessing techniques in Data Mining</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据挖掘中的数据预处理技术</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-preprocessing-techniques-in-data-mining-4c90666f6f7a?source=collection_archive---------3-----------------------#2019-11-25">https://medium.com/analytics-vidhya/data-preprocessing-techniques-in-data-mining-4c90666f6f7a?source=collection_archive---------3-----------------------#2019-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/47996e546901caa8927743d66ce934a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46PDHwNtRNLfBJgT4shQ_w.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图片来自pexel</figcaption></figure><div class=""/><p id="3e67" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">假设你从任何一个著名的电子商务网站上搜索了一条牛仔裤，后来因为某些原因你决定不买它，并关闭了你的购物应用程序，过了一段时间，如果你打开浏览器进行冲浪，你会发现你当时搜索的相同产品，这是机器学习的一个非常重要的实现。另一个著名的实现是谷歌语音助手，你可能已经在你的手机和Alexa中看到了它的实现，顾名思义，当通过语音询问时，它们可以帮助找到信息。机器学习是这些个人助理的重要组成部分，因为它们根据你之前与它们的接触来收集和提炼信息。稍后，这组数据将用于呈现根据您的偏好定制的结果。</p><p id="901c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在事情变得越来越有趣，我最喜欢的机器学习在ML中的应用是，它在视频监控系统中的使用。如今的视频监控系统是由人工智能驱动的，这使得在犯罪发生之前发现犯罪成为可能。他们跟踪人们不寻常的行为，比如长时间一动不动地站着，磕磕绊绊，或者在长椅上打盹等等。因此，该系统可以向服务员发出警报，这最终有助于避免灾难。</p><p id="cef3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么，你认为实现所有这些应用的主要重要因素是什么？不要太担心它的数据🤗。因此，我们需要处理这些数据，并针对我们的应用进行相应的调整。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es js"><img src="../Images/d680adc9621b89f013355598bc8a77ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*KKVMgAShkxsVOsVztblL1w.gif"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">来源:<a class="ae jx" href="https://tenor.com/view/data-on-data-off-appurv-gupta-the-laugh-club-comedy-bar-comedy-stint-gif-12085621" rel="noopener ugc nofollow" target="_blank">期限</a></figcaption></figure><blockquote class="jy jz ka"><p id="14d7" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr hb bi translated">我将在这篇文章中讨论什么？？</p></blockquote><p id="74bb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">1.数据预处理及其子技术介绍。</p><p id="367a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.我们将获取一个数据集，并在<strong class="iw hy">上工作，通过找到缺失值和有噪声的数据来清理数据</strong>，然后使用一些基本的python命令(如Mean、Median、Mode)填充缺失值。并使用一些复杂的填充技术，如K近邻、多元插补和深度学习技术。</p><p id="e9dd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.稍后我们将看到一些数据整理技术。</p><p id="edb9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">数据预处理介绍</strong></p><p id="cda1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">数据预处理是一项至关重要的数据挖掘技术，主要处理清理原始数据并将其转换成有用且可理解的格式。通俗地说，原始数据往往是不完整的，不一致的，可能缺乏某些行为，并可能包含许多错误，将我们的算法应用于它将减少不准确性。数据预处理是解决这类问题的一种行之有效的方法。数据预处理是从记录集、表或数据库中检测和纠正(或删除)损坏或不准确记录的过程，是指识别数据中不完整、不正确、不准确或不相关的部分，然后替换、修改或删除脏数据或粗糙数据。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kf"><img src="../Images/cbb7a98de39414a66331d29464c18118.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*FuvPo8yxt1vrjnkJ4_cd0A.gif"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">来源:<a class="ae jx" href="https://tenor.com/view/tired-panda-gif-9965672" rel="noopener ugc nofollow" target="_blank">期限</a></figcaption></figure><p id="a7a6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在数据预处理中，主要有三个重要的子主题:</p><ul class=""><li id="64b1" class="kg kh hx iw b ix iy jb jc jf ki jj kj jn kk jr kl km kn ko bi translated"><em class="kb">数据清洗。</em></li><li id="f75e" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr kl km kn ko bi translated"><em class="kb">数据转换。</em></li><li id="2ea8" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr kl km kn ko bi translated"><em class="kb">数据还原。</em></li></ul><h2 id="8baa" class="ku kv hx bd kw kx ky kz la lb lc ld le jf lf lg lh jj li lj lk jn ll lm ln lo bi translated">数据清理:</h2><p id="f7ea" class="pw-post-body-paragraph iu iv hx iw b ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn lt jp jq jr hb bi translated">数据清洗是通过处理不相关和缺失的元组来清洗原始数据的过程。在进行我们的机器学习项目时，我们获取的数据集可能并不完美，它们可能有许多杂质、有噪声的值，并且大多数时候实际数据可能会丢失。在数据清理期间，我们将面临的主要问题是:</p><p id="bd52" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以故意将缺失值添加到我们的数据集中吗？</p><p id="88b8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">是啊！在我们的例子中，我们的数据集中可能有缺失值，但是如果您想要处理其他数据集中没有缺失值的数据，您可以使用下面的代码按照您的意愿故意添加缺失值:</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="f5c8" class="ku kv hx lv b fi lz ma l mb mc">import pandas as pd<br/>import numpy as np<br/>import random<br/>df = pd.read_csv(r'diabetes.csv')<br/>nan_percent = {'Pregnancies':0.10, 'Glucose':0.15, 'BloodPressure':0.10,'SkinThickness':0.12,'Insulin':0.10,'BMI':0.13,'DiabetesPedigreeFunction':0.11,'Age':0.11,'Outcome':0.12}  <br/>for col in df:                         <br/>    for i, row_value in df[col].iteritems():<br/>        if random.random() &lt;= nan_percent[col]:              <br/>            df[col][i] = np.nan<br/>df.to_csv(r'NaNdiabetes.csv')</span></pre><p id="2ecc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的代码中，在第5行我们提到了在我们的数据集的每一列中我们需要多少百分比的缺失值。这将导致以上述速率插入缺失值。</p><p id="2011" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">a) <strong class="iw hy">缺失数据:</strong></p><p id="06b3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们正在处理的数据集包含缺失值，我们需要使用各种技术来填充它们:</p><blockquote class="jy jz ka"><p id="7761" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr hb bi translated">1.忽略丢失的值<em class="hx">😉</em>。</p></blockquote><p id="1ba9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下面的实践中，我将使用<a class="ae jx" href="https://www.kaggle.com/uciml/pima-indians-diabetes-database" rel="noopener ugc nofollow" target="_blank">皮马印第安人糖尿病</a>数据集</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="8bfb" class="ku kv hx lv b fi lz ma l mb mc">import pandas as pd<br/>df=pd.read_csv("pima-indians-diabetes.csv")<br/>cols=["Pregnancies","Glucose","BloodPressure","SkinThickness","Insulin","BMI","DiabetesPedigreeFunction","Age"]<br/>df[cols] = df[cols].replace({0:np.nan})<br/>df.isnull().sum()</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es md"><img src="../Images/aa1b04a1ad09dee1300b83f898f99428.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*SnP0e_WWw3dI-guDIrrOkA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图1:上面代码的输出</figcaption></figure><p id="b27e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在原始数据集中，缺失的NaN值用0表示，因此为了方便起见，我用'替换它们。“replace()”函数。</p><p id="c898" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您遵循上面的命令，您将得到上面的输出，显示每一列中缺少的值。因此，如果我们删除所有缺失值的行，那么我们的数据集将变得不完整，我们可能会丢失其他列中存在的一些重要信息，从而使我们的预测不太准确。如果缺少的值非常少，我们可以遵循这种方法，但是如果缺少的值很多，我们就不应该删除它们。因此，如果缺失值计数太高，我们就不应该采用这个定理。</p><blockquote class="jy jz ka"><p id="4c98" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr hb bi translated">2.填充缺少的值<em class="hx">。</em></p></blockquote><p id="0c0b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">既然我们不能忽略计数过高的缺失值，那么我们现在要做什么呢？？😕。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es js"><img src="../Images/d9d12d9d86a78dd88f6bff9452cc4dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*pXDDLvGYqNf7vhJqbx6pCA.gif"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">来源:<a class="ae jx" href="https://tenor.com/search/dont-worry-gifs" rel="noopener ugc nofollow" target="_blank">男高音</a></figcaption></figure><p id="4b99" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不要担心，我们可以通过使用一些基本和高级的填充技术填充适当的值来处理它们。这些技术包括:</p><ol class=""><li id="0448" class="kg kh hx iw b ix iy jb jc jf ki jj kj jn kk jr me km kn ko bi translated">用像零这样的常数值填充。</li><li id="5885" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr me km kn ko bi translated">卑鄙。</li><li id="991d" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr me km kn ko bi translated">中位数。</li><li id="5b90" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr me km kn ko bi translated">模式。</li><li id="c16e" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr me km kn ko bi translated">K-最近邻居。</li><li id="e011" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr me km kn ko bi translated">使用链式方程多元插补的插补(小鼠)。</li><li id="5834" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr me km kn ko bi translated">使用深度学习的插补(Datawig)。</li></ol><p id="49d7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们把手弄脏(就像一些程序员说的..😅)通过编码来填补我们缺失的值</p><blockquote class="jy jz ka"><p id="302f" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr hb bi translated"><strong class="iw hy"> 1。使用常数值(如“零”</strong>)填充缺失值</p></blockquote><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="ee92" class="ku kv hx lv b fi lz ma l mb mc">import pandas as pd<br/>import numpy as np<br/>df=pd.read_csv("diabetes.csv")<br/>cols = ["Pregnancies","Glucose","BloodPressure","SkinThickness","Insulin","BMI","DiabetesPedigreeFunction","Age"]<br/>df[cols] = df[cols].replace({np.nan:0})<br/>df.isnull().sum()</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mf"><img src="../Images/bd574c91038286c47754de2ce836d8db.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*F014Sw5RkJzV3PC1Fk89qg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图2</figcaption></figure><p id="8101" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如您在图2中看到的，缺失值的总和是0，这意味着所有缺失值都被替换为零。</p><blockquote class="jy jz ka"><p id="c0c0" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr hb bi translated">2.<strong class="iw hy">使用平均值填充缺失值。</strong></p></blockquote><p id="0af1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我希望你们都知道它的含义，但我只用两个词来概括它。</p><ul class=""><li id="7689" class="kg kh hx iw b ix iy jb jc jf ki jj kj jn kk jr kl km kn ko bi translated">它是给定集合中所有值的算术平均值。</li><li id="695c" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr kl km kn ko bi translated">计算方式为所有数字的总和除以数据点的总数</li></ul><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mg"><img src="../Images/a54adf3ffbe2e544e6c683473b440bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*Saa2R_W59JIQLKA2EDoVQw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">平均公式</figcaption></figure><p id="0d45" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用平均值填充缺失值的第一步是计算每列的平均值。</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="ce52" class="ku kv hx lv b fi lz ma l mb mc">import pandas as pd<br/>import numpy as np<br/>df=pd.read_csv("diabetes.csv")<br/>df.mean()</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mh"><img src="../Images/4eaf974458f380186357b327935e3f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*jtKIXPD-KPNSLZiUNl1NYA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图3:每列的平均值</figcaption></figure><p id="34cb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们看看如何用上面生成的<strong class="iw hy">平均值</strong>填充数据集中的空值:</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="6cd3" class="ku kv hx lv b fi lz ma l mb mc">print(df.head())<br/>for index,value in enumerate(cols):<br/>    df[value]=df[value].replace([0],c[index])</span><span id="826a" class="ku kv hx lv b fi mi ma l mb mc">print(df.head())</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mj"><img src="../Images/46a03171963363e232d724408de4c69a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9bC2U5KAqnqyXWUrBLyyQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图4</figcaption></figure><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mk"><img src="../Images/efc1572c70fb51e1bde8bc121a7e0a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*tmYijOLwMO6xQktqWC_02Q.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图5</figcaption></figure><p id="33d8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在图4的<strong class="iw hy">中，</strong>如您所见，缺失值表示为NaN，现在，如果我们将缺失值填充代码应用于数据集，我们将获得如图5所示的结果。在图5 的<strong class="iw hy">中没有缺失值，所有缺失值都由各自列的平均值填充。</strong></p><blockquote class="jy jz ka"><p id="3e1a" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr hb bi translated"><strong class="iw hy"> 3。用中值填充缺失值。</strong></p></blockquote><p id="a176" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以遵循与上面相同的技术，但是需要用中间值代替平均值。</p><p id="937a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们谈一谈中位数，简单来说，它是按升序排列时数据集的最中间值。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es ml"><img src="../Images/59f10759a33c93910dac2d7fac1c0967.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*EuRA65hKDGctrhkw3tWeZA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">中位数公式</figcaption></figure><p id="fbbe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么什么时候应该使用中位数而不是平均数来填充缺失值呢？🤔</p><p id="9fac" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们的数据集有很多异常值，我们必须使用中值高于平均值，因为对不规则数据应用平均值会导致异常输出，从而导致错误的准确性。</p><p id="38e0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我将用一个例子来说明这一点，假设您正在处理一个数据集，该数据集包含来自一个州的成年人的体重。一般来说，成年人的体重在50-110公斤之间，但是当数据输入时，一只猫🐹走在你的键盘上，输入一些重量，如998，530，213，12，-234，-4546等..，这些不规则的值称为异常值。现在，如果您对包含异常值的不规则数据集应用平均值，将导致异常平均值。因此，为了避免这种人为错误，我们将使用<strong class="iw hy">中值。</strong></p><p id="9ed9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了应用<strong class="iw hy">中位数，</strong>数据应该按降序或升序排列。使用<strong class="iw hy">中值函数</strong>的最大优点是数据列表在作为参数发送给median()函数之前不需要排序。</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="3743" class="ku kv hx lv b fi lz ma l mb mc">import pandas as pd<br/>import numpy as np<br/>df=pd.read_csv("diabetes.csv")<br/>c=df.median()<br/>print(c)</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mm"><img src="../Images/95a3e5f9f73141bab2c2d7e3bef99978.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*JVyDzPnPbPik0Fmn8dXg0g.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图6:每列的中值</figcaption></figure><p id="39cc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你想检查中位数是否默认排序数据，参考下面的代码，这里我在应用<strong class="iw hy"> median() </strong>函数本身之前删除了丢失的值。最后，两者给我们相同的结果:—</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="5880" class="ku kv hx lv b fi lz ma l mb mc">import pandas as pd<br/>import numpy as np<br/>df=pd.read_csv("diabetes.csv")<br/>cols = ["Pregnancies","Glucose","BloodPressure","SkinThickness","Insulin","BMI","DiabetesPedigreeFunction","Age"]<br/>for i in cols:<br/>    a=df[i]<br/>    a=a.dropna()<br/>    b=a.sort_values(axis=0,ascending=True)<br/>    print(b.median())</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mn"><img src="../Images/9d7e2c96d8c9adc95cd374e5f7dc839a.png" data-original-src="https://miro.medium.com/v2/resize:fit:126/format:webp/1*d_GxSiFxMw7kVpFvaJROeA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图7:上述代码的输出</figcaption></figure><p id="1841" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们看看如何用上面生成的<strong class="iw hy">中值</strong>填充数据集中的空值:</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="1646" class="ku kv hx lv b fi lz ma l mb mc">print(df.head())<br/>for index,value in enumerate(cols):<br/>    df[value]=df[value].replace([0],c[index])<br/>print(df.head())</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mo"><img src="../Images/3751e3135dfc31b4938787b9b7b74dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*tbyvnJT-u3SWMXP5l2t0AQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图8</figcaption></figure><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mp"><img src="../Images/8eb3bd29cc6b3bbfa983a679cd5b2cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*gMTw7DFEbxMyyjwPIab23Q.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图9</figcaption></figure><p id="09c8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在图8中，缺失值由<strong class="iw hy"> NaN </strong>值表示，缺失的NaN值由我们之前计算的中值代替，如图9所示。</p><blockquote class="jy jz ka"><p id="8021" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr hb bi translated">4.<strong class="iw hy">用模式填充缺失值。</strong></p></blockquote><p id="3c0b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">众数是给定数据集中重复次数最多的值，由离散值或分类值组成。也可以有两种模式(双模态)、三种模式(三模态)或四种或更多种模式(多模态)。</p><p id="7c55" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以最重要的问题是我们应该什么时候使用Mode来填充缺失的值？</p><p id="b2f3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">答案很简单，最好是使用<strong class="iw hy">模式</strong>如果你有分类变量，分类变量取值为名称或标签。这些是定性的。我们可以进一步将这些分类属性定义为名词性的<strong class="iw hy">或序数的<strong class="iw hy"/>。一个名义变量对其类别没有内在的排序。例如，性别是一个具有两个类别(男性和女性)的分类变量，这些类别没有内在的顺序。序数变量有明确的顺序。例如，温度作为一个变量有三个<em class="kb">有序的</em>类别(低、中、高)。</strong></p><p id="4682" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">我们的数据集由数字属性组成，每个数字可能不会重复很多次，因此不推荐使用模式作为填充缺失值的主要技术，因为它可能不会给出期望的结果。</strong></p><p id="7cc8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们看看<strong class="iw hy"> mode() </strong>函数的工作原理。</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="bf16" class="ku kv hx lv b fi lz ma l mb mc">for i in cols:<br/>    a = df.groupby(np.arange(len(df))//768)[i].apply(lambda x: x.mode())<br/>    print(a)</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es ml"><img src="../Images/7999fb83341a8fb05ef6ae98001d6f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*qzJiY3KR0ZIajnUbqR67Rw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图10:上述代码的输出</figcaption></figure><p id="7a8f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">代替上面的代码，你可以直接在数据框上使用简单的<strong class="iw hy"> mode() </strong>函数，如下所示:</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="ebc8" class="ku kv hx lv b fi lz ma l mb mc">import pandas as pd<br/>import numpy as np<br/>df=pd.read_csv("diabetes.csv")<br/>df=df.replace([0],np.NaN)<br/>c=df.mode()<br/>print(c)</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es et"><img src="../Images/f56996e9a4068dbabf1ed85e654019dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOy1gJGvf2KKwoskl98irw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图11:上述代码的输出</figcaption></figure><p id="72fe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您在图10和11中观察到，葡萄糖和糖尿病谱系函数属性有两个模式值，这意味着可能有两个值出现的次数最多。</p><p id="8a51" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，让我们使用计算出的模式值来填充缺失的值。</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="c732" class="ku kv hx lv b fi lz ma l mb mc">cols = ["Pregnancies","Glucose","BloodPressure","SkinThickness","Insulin","BMI","DiabetesPedigreeFunction","Age"]<br/>for i in cols:<br/>    a = df[i].mode()<br/>    print(a[0])<br/>    df[i]=df[i].replace(to_replace=[0],value=a[0])<br/>print(df.head(10))</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mq"><img src="../Images/c8ba3976d2abfc453e5f5b348fc57319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*U1wweUzrrqlK8l0RpjdEmw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图12:上述程序的输出</figcaption></figure><p id="01ad" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，如果您观察第7个实例中的血压值，您可以看到缺失的值被相应的模式值所替代。</p><blockquote class="jy jz ka"><p id="d70d" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr hb bi translated"><strong class="iw hy"> 5。使用K近邻填充缺失值</strong></p></blockquote><p id="6a6d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么什么是K近邻呢？这是什么意思？是新话题吗？很难吗？</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mr"><img src="../Images/268e29d20ac1d1c7646b257642c5d05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/1*1wuNgZyRmAleYh7Ez0cMBw.gif"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">来源:<a class="ae jx" href="https://tenor.com/view/panic-spongebob-patrick-scared-running-gif-7888576" rel="noopener ugc nofollow" target="_blank">男高音</a></figcaption></figure><p id="3891" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不要慌！！这是一种非常先进的技术，可用于连续、离散、有序和分类的各种数据。K-NN是一种算法，它将所需的值与其k个最近的邻居之一进行匹配。它属于非参数的、基于实例的和<strong class="iw hy">监督学习领域</strong>，并在模式识别、数据挖掘、入侵检测中找到应用。考虑下面的例子</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es ms"><img src="../Images/e8bb32b5118a2216765387d3d941ae79.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*fhl_92B_W_AoFATo9F7Jkg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图13</figcaption></figure><p id="5fbe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在图13中，绘制了两种不同的类别，红色和蓝色。现在考虑一个用绿点表示的新实例被引入数据帧(图14)</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mt"><img src="../Images/2c67e4cb3a5dc0197058b2e35f23ff08.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*dBI7ejChnMYbD0B7WQz25Q.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图14</figcaption></figure><p id="df57" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们的目标是将绿点分配到红类或蓝类。对于这种类型的分类，我们将使用K-NN技术。K-NN的参数为“<strong class="iw hy"> k </strong>”。它是一个数值，表示该点周围相邻点的数量。选择满足我们要求的合适k值非常重要-采用低k值会减少周围的邻域，导致结果的概化程度较低。另一方面，采用高k值会覆盖所有可能的类别，会模糊局部效果，而这正是我们想要的。</p><h2 id="fb9a" class="ku kv hx bd kw kx ky kz la lb lc ld le jf lf lg lh jj li lj lk jn ll lm ln lo bi translated">那么KNN是如何运作的呢？</h2><p id="10bb" class="pw-post-body-paragraph iu iv hx iw b ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn lt jp jq jr hb bi translated">假设<strong class="iw hy"> k=10 </strong>，意味着我们必须选择围绕绿点的10个最近的邻居。为了选出这10个点，我们需要计算从绿点到数据集中所有其他可能点的距离，为此，我们将主要使用<strong class="iw hy">欧几里德距离。</strong>由<strong class="iw hy"> : </strong>给出</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es md"><img src="../Images/72ace0de51e123d25fbb7d335dcb0454.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*n6TsibvBRNJC63k3__y75w.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae jx" href="https://kevinzakka.github.io/2016/07/13/k-nearest-neighbor/#:~:targetText=Despite%20its%20simplicity%2C%20KNN%20can,based%20on%20their%20expression%20profiles." rel="noopener ugc nofollow" target="_blank">公式为<strong class="bd kw">欧氏距离</strong>公式为</a></figcaption></figure><p id="d9b7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">涉及的步骤:</p><ul class=""><li id="9f68" class="kg kh hx iw b ix iy jb jc jf ki jj kj jn kk jr kl km kn ko bi translated"><strong class="iw hy"> Step1: </strong>遍历数据集中的每个点，计算<strong class="iw hy"> x </strong>与每个训练观测值之间的距离<strong class="iw hy"> d </strong>(这里x1，x2，…&amp;x’1，x’2…代表数据点的坐标)。</li><li id="b901" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr kl km kn ko bi translated"><strong class="iw hy"> Step2: </strong>在所有距离(d)中，我们称最接近<strong class="iw hy"> x的<strong class="iw hy"> k </strong>点，</strong>这些是我们的k近邻。</li><li id="5761" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr kl km kn ko bi translated"><strong class="iw hy">步骤3: </strong>获得最近的邻居后，我们的下一步是将该点绘制到一个合适的类中。</li></ul><p id="c541" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你参考图15，你可以观察到在一组点周围画了一个圆，也包括我们的绿点。如果您计算圆内的点，除了绿色之外还有10个点，这意味着围绕绿色点选择了10个邻居，其中点<strong class="iw hy"> 4是蓝色的</strong>和<strong class="iw hy"> 6是红色的，</strong>因此，在良好的置信水平下，我们可以说绿色点应该属于红色类。在该算法中，参数K的选择非常关键。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es mu"><img src="../Images/f3c6fb550299ca6fb7e2d77d5d6daa28.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*aPNCyWcYjoLe8xGw-ARpuQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图15</figcaption></figure><p id="8856" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">代码:</strong></p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="2384" class="ku kv hx lv b fi lz ma l mb mc">import pandas as pd<br/>import numpy as np<br/>import impyute<br/>from impyute.imputation.cs import fast_knn <br/>df=pd.read_csv("diabetes.csv")<br/>cols = ["Pregnancies","Glucose","BloodPressure","SkinThickness","Insulin","BMI","DiabetesPedigreeFunction","Age"]<br/>for i in cols:<br/>    df[i]=df[i].replace(to_replace=[0],value=np.NaN)<br/>k-nn_impute=fast_knn(df, k=3)<br/>pd.DataFrame(k-nn_impute).to_csv("file_k-nn.csv")</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mv"><img src="../Images/3bf949a92a077fbf8237ae942ff4173f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFQk5TrSmi3Q-N6RJDdt1w.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图16:上述代码的输出</figcaption></figure><p id="0b3e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在图16中，您可以看到缺失值已被加权最近邻值填充。</p><blockquote class="jy jz ka"><p id="00a8" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr hb bi translated">6。通过链式方程使用多元插补填补缺失值(小鼠)</p></blockquote><p id="6253" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">多重插补是复杂的不完整数据问题的首选方法。MICE在假定插补程序中使用的给定变量在随机位置具有缺失数据的情况下运行，称为<strong class="iw hy">随机缺失(MAR)。</strong>填充缺失值将在以下步骤中完成:</p><ul class=""><li id="3b3d" class="kg kh hx iw b ix iy jb jc jf ki jj kj jn kk jr kl km kn ko bi translated">第一步:首先，我们将使用各自属性的平均值来填充每个变量/属性中所有缺失的值。</li><li id="aa95" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr kl km kn ko bi translated">第二步:现在，第一个变量(姑且称之为<strong class="iw hy"> v) </strong>的估算平均值将被设置回NaN，剩下的其他变量(姑且称之为<strong class="iw hy"> totalset-v=l </strong>)将使用它们的估算平均值。</li><li id="4e17" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr kl km kn ko bi translated">第三步:现在对由<strong class="iw hy"> l预测的<strong class="iw hy"> v </strong>进行线性回归，使用所有观察到<strong class="iw hy"> v </strong>的情况运行</strong>。</li><li id="3445" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr kl km kn ko bi translated">步骤4:这里，缺失值<strong class="iw hy"> v </strong>的预测将从回归方程中获得并进行估算。此时，变量<strong class="iw hy"> v </strong>中没有任何缺失值。</li><li id="e0c8" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr kl km kn ko bi translated">步骤5:将重复步骤2-4，取一个新变量为<strong class="iw hy"> v，</strong>也改变<strong class="iw hy"> l. </strong>的值</li></ul><p id="8c9f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">代号:</strong></p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="8e58" class="ku kv hx lv b fi lz ma l mb mc">import pandas as pd<br/>import numpy as np<br/>import impyute<br/>from impyute.imputation.cs import mice<br/>df=pd.read_csv("diabetes.csv")<br/>cols = ["Pregnancies","Glucose","BloodPressure","SkinThickness","Insulin","BMI","DiabetesPedigreeFunction","Age"]<br/>for i in cols:<br/>    df[i]=df[i].replace(to_replace=[0],value=np.NaN)<br/>mice_imp=mice(df)<br/>pd.DataFrame(mice_imp).to_csv("file_MICE.csv")</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mw"><img src="../Images/2330bbd714491da7834f6a356456ad75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0tDCKzcZq4R3WvJjlC8npw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图17:上述代码的输出</figcaption></figure><p id="3c2b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在图17中，您可以观察到缺失值已被多元插补填补。</p><blockquote class="jy jz ka"><p id="3a50" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr hb bi translated"><strong class="iw hy"> 7。使用Datawig填充缺失值。</strong></p></blockquote><p id="9660" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里我们将使用库<strong class="iw hy"> Datawig </strong>，这种方法对于<br/>分类和非数字特征非常有效。这是一个学习机器<br/>学习模型的库，使用深度神经网络来估算<br/>数据帧中的缺失值。</p><p id="b1af" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> Datawig </strong>期待您提供:</p><ul class=""><li id="3791" class="kg kh hx iw b ix iy jb jc jf ki jj kj jn kk jr kl km kn ko bi translated">您要为其估算值的列的列名(下面称为output_column)和一些。</li><li id="55b9" class="kg kh hx iw b ix kp jb kq jf kr jj ks jn kt jr kl km kn ko bi translated">包含您认为对插补有用的值的列名(以下称为input_columns)。</li></ul><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="ffe6" class="ku kv hx lv b fi lz ma l mb mc">import datawig<br/>import pandas as pd<br/>import numpy as np<br/>df=pd.read_csv("diabetes.csv")<br/>cols = ["Pregnancies","Glucose","BloodPressure","SkinThickness","Insulin","BMI","DiabetesPedigreeFunction","Age"]<br/>for i in cols:<br/>    df[i]=df[i].replace(to_replace=[0],value=np.NaN)<br/>df_train, df_test = datawig.utils.random_split(df)<br/>imputer = datawig.SimpleImputer(<br/>    input_columns=[ 'Glucose', 'BloodPressure','SkinThickness','Insulin','BMI','DiabetesPedigreeFunction','Age','Outcome'],output_column= 'Pregnancies',output_path = 'imputer_model')<br/>imputer.fit(train_df=df_train)<br/>imputed = imputer.predict(df_test)<br/>pd.DataFrame(imputed).to_csv("file_datawig.csv")</span></pre><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es js"><img src="../Images/2d1cf7de801a1b67fbea368ffe75d125.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*tXkoFOQgZw4xPYTYZNvnEg.gif"/></div></figure><p id="429e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以，本文到此结束。感谢您阅读这篇文章，希望您喜欢它，并发现它很有趣！！</p><blockquote class="jy jz ka"><p id="2719" class="iu iv kb iw b ix iy iz ja jb jc jd je kc jg jh ji kd jk jl jm ke jo jp jq jr hb bi translated">那么下一步是什么？？</p></blockquote><p id="3251" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的下一步是对数据集应用不同的算法，并计算我们之前讨论过的不同算法的精确度，然后比较精确度，找出哪个模型最适合清理数据集。</p><p id="3837" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我将在接下来的文章中讨论这些问题。</p><p id="a3f0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi">……………………………………………………………………………………….</p></div></div>    
</body>
</html>