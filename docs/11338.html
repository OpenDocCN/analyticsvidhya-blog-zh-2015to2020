<html>
<head>
<title>Building a Data Pipeline with Python Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python生成器构建数据管道</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e?source=collection_archive---------3-----------------------#2020-11-30">https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e?source=collection_archive---------3-----------------------#2020-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="92d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，你将了解到我们如何使用Python的生成器特性来创建数据流管道。对于生产级管道，我们可能会使用合适的框架，比如Apache Beam，但是这个特性是构建Apache Beam的定制组件所必需的。</p><h1 id="643f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">问题是</h1><p id="fe0c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">让我们看看对数据管道的以下需求:</p><blockquote class="kg kh ki"><p id="d5b0" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">写一个小框架，处理一个无穷无尽的整数事件流。假设处理将是静态和顺序的，其中每个处理单元将输出传递到下一个处理单元，除非有不同的定义(例如，过滤器、固定事件窗口)。该框架应包括以下6个“构件”:</p><p id="8d9f" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">1.stdin-source:从stdin中读取一个数字，打印'&gt; '和后面的数字。例如，如果用户输入1，它将打印" &gt; 1" <br/> 2。filter:只传递与谓词匹配的事件(给定一个数字，返回true或false的函数)。谓词是在过滤器初始化期间给出的。<br/> 3。fixed-event-window:将事件聚集到一个固定大小的数组中，当数组满时将其向前传递。固定数组的大小是在固定事件窗口初始化期间定义的。<br/> 4。fold-sum:对数组中事件的值求和，并将和向前传递。<br/> 5。fold-median:计算数组中事件的中值，并将中值向前传递。<br/> 6。stdout-sink:将数字打印到stdout并向前传递。</p><p id="8464" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">从这6个构建块中，可以构建任何管道，这里有一个例子:<br/>stdin-source-&gt;filter(I =&gt;I&gt;0)-&gt;固定事件窗口(2) - &gt; fold-sum - &gt;固定事件窗口(3)-&gt;fold-median-&gt;stdout-sink</p></blockquote><p id="39e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你将如何解决这样的问题？我首先尝试的是为每一个“构建模块”编写一个函数，然后在用户输入的无限循环中运行每一个函数，并按照管道所需的顺序重新组织这些函数。</p><p id="2f9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法有两个明显的问题:</p><p id="71d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.如果谓词返回<em class="kj"> false </em>，则<em class="kj"> filter </em>函数必须返回null，这要么迫使其他函数优雅地处理null，要么迫使管道自己处理null——这意味着管道或其他函数必须知道<em class="kj"> filter </em>函数的实现——如果我们改变管道中filter函数的顺序，我们也必须移动相关的null检查。</p><p id="5b51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<em class="kj">固定事件窗口</em>函数必须每X次批量输入元素并输出它们——这意味着函数必须在多次执行中<strong class="ih hj">保持其状态</strong>。这要求管道不仅要知道<em class="kj"> filter </em>函数的实现，而且它实际上必须是实现的一部分(使用函数范围之外的变量来处理批处理)。</p><p id="59da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例中编写管道的代码很容易编写，但是要以一种允许我们随心所欲地摆弄构建块的方式编写它(将它编写为一个实际的管道，而不仅仅是以特定方式放在一起的一堆代码)，这需要我们使用生成器。</p><h1 id="8cd0" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">发电机简介</h1><p id="6bb4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">生成器函数是返回称为生成器(迭代器的子类)的对象的函数。我们通过使用关键字<em class="kj"> yield </em>而不是关键字<em class="kj"> return </em>来创建一个生成器函数。让我们先创建一个:</p><p id="ac37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个返回0-4整数的生成器示例:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="c77b" class="kw je hi ks b fi kx ky l kz la">&gt;&gt;&gt; def gen(): <br/>…     for i in range(5): <br/>…       yield i </span></pre><p id="afed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这里发生了什么？与<em class="kj"> return </em>关键字不同，该函数在第一个<em class="kj"> yield </em>语句之后并没有结束。只有当没有更多的值要产生时，函数才会结束执行——这里是指循环结束的时候。</p><p id="332d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们运行这个函数，看看会发生什么:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f31b" class="kw je hi ks b fi kx ky l kz la">&gt;&gt;&gt; gen() <br/>&lt;generator object gen at 0x7f58682b7820&gt;</span></pre><p id="a559" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我说过一个生成器函数返回一个生成器对象，我也说过它是一个迭代器，所以如果我们想计算结果，我们必须这样做:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="819e" class="kw je hi ks b fi kx ky l kz la"># returns a generator object, the function's code isn't executed yet<br/>&gt;&gt;&gt; res = gen()</span><span id="8570" class="kw je hi ks b fi lb ky l kz la"># here the code inside the generator is actually being run<br/>&gt;&gt;&gt; for j in res:<br/>...   print(j) <br/>0 <br/>1 <br/>2 <br/>3 <br/>4</span></pre><p id="7c19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关键字的<em class="kj">隐式调用迭代器上的<em class="kj">下一个</em>函数，直到它的值用完为止(我们也可以只使用对象上的<em class="kj">列表</em>函数——这将隐式调用所有元素上的<em class="kj">下一个</em>)。</em></p><p id="90ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你仍然好奇发电机到底是如何在幕后工作的(你应该好奇，这很有趣)，这里<a class="ae lc" href="https://hackernoon.com/the-magic-behind-python-generator-functions-bc8eeea54220" rel="noopener ugc nofollow" target="_blank">有一篇关于这个主题的非常酷的博客文章。</a></p><h1 id="87c5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">建设管道</h1><p id="6c93" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在我们已经非常了解什么是生成器以及我们如何创建它们，让我们回到解决手头的问题。任务是编写一个流框架，其中每个构建块对当前值进行一些处理，并在需要时向前传递，同时仍然处理更多的值。对于固定事件窗口步骤，我们需要在多次执行中保持函数的状态——这正是生成器能为我们做的。</p><p id="998c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从框架的构建模块开始:</p><ol class=""><li id="b7ff" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">从用户处读取整数输入流，并将其向前传递:</li></ol><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3d7f" class="kw je hi ks b fi kx ky l kz la">def stdin_source():<br/>  def try_to_int(val):<br/>    try:<br/>      return int(val)<br/>    except ValueError:<br/>      return None</span><span id="e5e5" class="kw je hi ks b fi lb ky l kz la">  for input in sys.stdin:<br/>    if input.strip() == 'exit':<br/>      exit()</span><span id="a67f" class="kw je hi ks b fi lb ky l kz la">    val = try_to_int(input)<br/>    if val is not None:<br/>      print(‘&gt; %d’ % val)<br/>      yield val</span></pre><p id="0d51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.向前传递与谓词匹配的值:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="c017" class="kw je hi ks b fi kx ky l kz la">def filter_numbers(numbers, predicate):<br/>  for val in numbers:<br/>    if predicate(val):<br/>      yield val</span></pre><p id="a9ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.将用户输入批处理到在本地定义的数组<strong class="ih hj"/>(数组的状态在执行中被保留，因为它是一个生成器)，为每个<em class="kj"> batch_size </em>元素传递一个固定大小的列表:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="e75a" class="kw je hi ks b fi kx ky l kz la">def fixed_event_window(numbers, batch_size):<br/>  arr = []<br/>  for val in numbers:<br/>    arr.append(val)</span><span id="cbb8" class="kw je hi ks b fi lb ky l kz la">    if len(arr) == batch_size:<br/>      res = arr.copy()<br/>      arr = []<br/>      yield res</span></pre><p id="b72b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.对数组元素求和:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="982d" class="kw je hi ks b fi kx ky l kz la">def fold_sum(arrs):<br/>  for arr in arrs:<br/>    yield sum(arr)</span></pre><p id="315e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.计算数组元素的中值:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="52c4" class="kw je hi ks b fi kx ky l kz la"># 5. fold-median<br/>def fold_median(arrs):<br/>  for arr in arrs:<br/>    yield median(arr)</span></pre><p id="b571" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.打印并向前传递值:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="ca66" class="kw je hi ks b fi kx ky l kz la"># 6. stdout-sink<br/>def stdout_sink(numbers):<br/>  for val in numbers:<br/>    print(val)<br/>    yield val</span></pre><p id="596f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，让我们按照要求将所有这些构建模块放在一起:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="eac0" class="kw je hi ks b fi kx ky l kz la">numbers = stdin_source()<br/>filtered = filter_numbers(numbers, lambda x: x &gt; 0)<br/>windowed_for_sum = fixed_event_window(filtered, 2)<br/>folded_sum = fold_sum(windowed_for_sum)<br/>windowed_for_median = fixed_event_window(folded_sum, 3)<br/>folded_median = fold_median(windowed_for_median)<br/>res = stdout_sink(folded_median)</span></pre><p id="fe99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很漂亮，对吧？这里发生的事情非常清楚，而且也很容易改变函数的顺序，创建一个完全不同的管道，而不必改变管道中的其他任何东西。</p><p id="83dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，这条管道实际上不会开始运行——这只是管道的<strong class="ih hj">定义</strong>,如果我们让它保持原样，什么都不会发生——我们创建了一堆生成器对象并将它们放在一起放入管道——但是没有数据被发送到管道，因为没有东西在生成器上迭代，所以用户甚至不会被提示输入。为了运行它，我们只需迭代管道的结果:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3a8a" class="kw je hi ks b fi kx ky l kz la">....<br/>res = stdout_sink(folded_median)</span><span id="f960" class="kw je hi ks b fi lb ky l kz la"># implicitly calling next() on the generator object until there are # no more values<br/>list(res)</span></pre><p id="7960" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们愿意，我们可以只运行管道的一部分——如果我们选择迭代<em class="kj"> folded_sum </em>生成器，那么管道将只运行到那个步骤。</p><h1 id="a4db" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">摘要</h1><p id="7d69" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">帖子中的所有代码都可以在<a class="ae lc" href="https://github.com/SockworkOrange/blog-posts/tree/main/data-pipeline-via-generators" rel="noopener ugc nofollow" target="_blank">这里</a>找到——希望你对这个帖子感兴趣，并且了解了一些关于生成器的知识以及它们的用处。在下一篇文章中，我将讨论如何使用这个特性在Apache Beam管道中编写定制组件。</p></div></div>    
</body>
</html>