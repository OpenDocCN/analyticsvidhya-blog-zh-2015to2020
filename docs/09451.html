<html>
<head>
<title>Object Detection using Tensorflow2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用张量流 2 的对象检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/object-detection-using-tensorflow2-3422da78b33e?source=collection_archive---------27-----------------------#2020-09-06">https://medium.com/analytics-vidhya/object-detection-using-tensorflow2-3422da78b33e?source=collection_archive---------27-----------------------#2020-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b6b4c6b521aa2da9364d699d16c2c972.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*eVTJGqQDFYeyBpB7FRHurw.png"/></div></figure><p id="a8d2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用 TensorFlow 对象检测 API 对图像进行对象检测的简单方法。</p><p id="d0e5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Google 发布了新的运行在 TensorFlow 2 上的物体检测 API。</p><h1 id="110e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="3732" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">物体检测的一般步骤:<br/> 1。收集和标记数据<br/> 2。安装培训库<br/> 3。选择和训练模型</p><p id="ed2d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kn" href="https://github.com/ManojKesani/fire_detection" rel="noopener ugc nofollow" target="_blank">我的 GitHub 回购</a></p><h1 id="0de4" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">迁移学习</h1><p id="da74" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在训练模型的实践中，需要大量的标记数据<br/>，这并不总是可能的。因此，我们在巨大的公共数据集上训练一个网络。以此为起点，我们然后根据我们的<br/>定制数据训练网络。这里的假设是，模型将学会从较大的数据集识别<br/>模式，并帮助我们在<br/>小数据集上更好地收敛。一般来说，库提供预先训练的模型，我们从那里开始。</p><h2 id="8762" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">1.收集和标注数据</h2><p id="aa96" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">收集数据时，应注意涵盖各种照明<br/>条件，如白天、夜晚、多云、..等等。这有助于开发稳健的型号<br/>。收集后，将图像的名称随机化是一个好主意。这将有助于我们直接与他们合作，而不用担心打乱数据和标签。<br/> <em class="lc">提示:拥有多个对象时，在数据集中重叠对象会有所帮助。</em></p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ld"><img src="../Images/143d5baaf6181d1e04e191a0aa9e3cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CcukxZVUg3mORIYW5bcatA.png"/></div></div></figure><p id="1d58" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">LabelImg 是一种用于标记数据集的流行工具，可通过 pip 在系统中安装 label img<br/>进行安装。安装后，导航至<br/>数据文件夹并开始贴标签。在感兴趣的物体周围画一个方框，并给出它们的名称。这将为所选目录中的每张图片<br/>创建带有标签的 XML 文件。现在我们有了标记的数据，我们将它们分成<br/>训练和测试目录。应该达到的比率<br/>主要取决于数据集的大小，通常建议 80/20。<br/> <em class="lc">提示:A、D 是上一张、下一张图像的快捷键。r 用于调出矩形标注工具。</em></p><h2 id="cef7" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">2.安装培训图书馆</h2><p id="9bb6" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">训练神经网络需要 NVIDIA 驱动程序。对于软件和更新中的 Ubuntu <br/>，进入 Ubuntu 软件，将下载从<br/>改为“主服务器”，然后在附加驱动中选择版本 435(我已经在这个驱动上测试了<br/>)。下载并安装 cuda10.0，并将路径添加到。bashrc</p><p id="940b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lc">导出路径=/usr/local/cuda-10.0/bin $ { PATH:+:$ { PATH } }<br/>导出 LD _ LIBRARY _ PATH =/usr/local/cuda-10.0/lib 64 $ { LD _ LIBRARY _ PATH:+:$ { LD _ LIBRARY _ PATH } }</em></p><p id="be67" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后在 Nvidia developers 上注册并下载 cuDNN 库<br/>并遵循安装过程。不同<br/>版本的兼容性列表可在<a class="ae kn" href="https://docs.nvidia.com/deeplearning/sdk/cudnn-support-matrix/ index.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><ul class=""><li id="132e" class="lm ln hi io b ip iq it iu ix lo jb lp jf lq jj lr ls lt lu bi translated">对于 TensorFlow，pip 安装-升级 tensorflow-gpu</li><li id="63f1" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">对于探测器 2，去 pytorch.org 选择你的设置并安装<br/> pytorch 1.4。(在 GCC 5.6 上测试)</li></ul><p id="4916" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上述库的深入文档可从以下网址获得</p><div class="ma mb ez fb mc md"><a href="https://tensorflow-object-detection-api-tutorial.readthedocs.io/en/latest/install.html#tensorflow-gpu" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">安装- TensorFlow 2 对象检测 API 教程文档</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">虽然安装和使用 TensorFlow 并不一定要有 Anaconda，但我建议这样做，因为它…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">tensor flow-object-detection-API-tutorial . readthedocs . io</p></div></div></div></a></div><div class="ma mb ez fb mc md"><a href="https://detectron2.readthedocs.io/tutorials/install.html" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">安装-检测器 2 0.2.1 文档</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">编辑描述</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">detectron2.readthedocs.io</p></div></div></div></a></div><h2 id="a1c8" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">3.选择和训练模型</h2><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/44654079b350c88817cfde669d990181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*jpjiRElDGKbpi-nhflXSqg.png"/></div><figcaption class="mn mo et er es mp mq bd b be z dx translated"><a class="ae kn" href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/tf2_detection_zoo.md" rel="noopener ugc nofollow" target="_blank">https://github . com/tensor flow/models/blob/master/research/object _ detection/g3doc/tf2 _ detection _ zoo . MD</a></figcaption></figure><p id="60db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">TensorFlow 提供了许多用于检测的模型，我选择了 efficientdet_d0 进行训练，因为最终的模型大小较小，并且易于共享最终训练的权重(易于下载和上传)。所以我们下载 efficientdet_d0 的权重。除此之外，我们还需要一些来自我的 github repo 的文件，它们是</p><ul class=""><li id="b82d" class="lm ln hi io b ip iq it iu ix lo jb lp jf lq jj lr ls lt lu bi translated">generate_tfrecord.py —将 XML 转换为 TF 记录。(来自文档)</li><li id="7bbb" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">label map . Pb txt-包含标签 FIRE</li><li id="1527" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">pipeline.config —包含培训结构，如班级数量、学习率、批量大小...等等</li></ul><p id="1148" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们从 XML 文件生成 Tf 记录，并开始训练。文献建议在终止前达到 1 的损耗，但由于数据集非常小，损耗从 0.6 开始，在 6300 步后达到 0.2 的平稳状态。现在，在终止训练之后，我们导出用于推理的模型。</p><p id="1fea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们定义一个检测函数，将模型加载到内存中。这个训练过的模型权重也和测试图片一起在我的 Github repo 中。对于这个函数，我们提供了一个到我们想要推断的图像的路径列表，然后可视化输出。</p><h2 id="563a" class="ko jl hi bd jm kp kq kr jq ks kt ku ju ix kv kw jy jb kx ky kc jf kz la kg lb bi translated">输出</h2><p id="f1f9" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">代码的推理部分加载权重，如果检测置信度大于 0.5，则绘制一个边界框。将打印一份声明，说明“着火”或“不着火”，可用作报警系统的触发器。</p><p id="ddf5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">模型剪枝和量化可以进一步提高推理速度。</p></div></div>    
</body>
</html>