<html>
<head>
<title>Painting sketches with ML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用ML画素描</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/painting-sketches-with-ml-33a3ece74d31?source=collection_archive---------15-----------------------#2020-07-26">https://medium.com/analytics-vidhya/painting-sketches-with-ml-33a3ece74d31?source=collection_archive---------15-----------------------#2020-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fa6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">训练一个U-NET深度学习模型绘制黑白草图</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/ca3a8e0a8294ae7e224fe2054cb72404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E4E4dX7V6GC6_xMO.jpg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">资料来源:deepdreamgenerator.com</figcaption></figure><p id="684a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">艺术是把我们和机器以及机器能做什么区分开来的东西之一。算法往往没有创造力，它们试图自动化某些决策，或者复制其他人创造的一些规则。这项任务是机器胜过人类的地方。</p><p id="5301" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是为什么我总是对产生艺术的算法感兴趣:可以自己创作音乐或绘画的机器。以谷歌的<a class="ae ju" href="https://github.com/google/deepdream" rel="noopener ugc nofollow" target="_blank">深梦项目</a>为例，其中一个团队训练了一个卷积神经网络来检测图像上的物体，但他们强迫该模型在它们不存在的地方找到物体，从而产生了一些心理图像。或者看看谷歌的<a class="ae ju" href="https://magenta.tensorflow.org/" rel="noopener ugc nofollow" target="_blank">洋红色</a>项目。Magenta Studio是谷歌大脑项目“探索机器学习作为工具在创作过程中的作用”。</p><p id="7ec8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，我们还远远没有让机器产生艺术，但是现在有大量的软件来帮助艺术家指导他们的工作。这些软件使用人工智能来推荐或纠正他们工作的某些方面。</p><p id="304a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如今，训练深度学习模型来完成某些任务也非常容易。这就是我们在这篇文章中要做的，我们将训练一个深度学习模型来绘制黑白草图。我们将使用TensorFlow 2中的Keras API来开发和训练我们的深度学习模型。你可以在这个<a class="ae ju" href="https://github.com/luchonaveiro/color-sketch" rel="noopener ugc nofollow" target="_blank"> Github repo </a>上找到所有代码。</p><h1 id="f0cc" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">数据</h1><p id="c558" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">要开发深度学习模型，我们首先需要的是数据，大量的数据。在这种情况下，要教一台机器如何绘画，我们需要两样东西:黑白草图和已绘草图。因此，在训练机器时，我们将展示大量绘画图像的例子，这样我们就可以使用这种算法来绘画。</p><p id="02fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将要使用的数据是您可以在<a class="ae ju" href="https://www.kaggle.com/wuhecong/danbooru-sketch-pair-128x" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上找到的数据。对于这个例子，我们不会使用所有的图片，我将在我的机器上本地训练模型，所以我们将使用15000张图像的子集来训练我们的模型。</p><p id="4e81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们将要使用的一些草图和彩色图像:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ky"><img src="../Images/b680f89731574219732b7a560ba13a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*psLVNzqO0Fu4uLUMFDwr2Q.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">Kaggle数据集上的两个图像示例</figcaption></figure><h1 id="a1c0" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">模型</h1><p id="017e" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">为了完成这项任务，我将训练一个深度学习模型，特别是一个U-NET架构。我将使用一个类似于这篇<a class="ae ju" href="https://arxiv.org/abs/1505.04597" rel="noopener ugc nofollow" target="_blank">论文</a>中提出的生物医学图像分割的架构。</p><p id="09ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该论文中提出的U-NET架构大致如下:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kz"><img src="../Images/d7987ec6daf65c79c1de9659b886c21e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LOQTv6BSbEcCvU__xR2ulg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">U-NET架构图</figcaption></figure><p id="4299" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，这种类型的模型有两条路径:收缩路径或编码器路径(左边的一条)和扩展路径或解码器路径(右边的一条)。而且在编码器层和解码器层之间有一个连接。这种连接使我们能够映射原始图像，在每个向上调用的卷积层上都有彩色图像。</p><h1 id="2448" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">模特培训</h1><p id="2ed7" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">因此，为了能够训练模型，首先我们要设置图像。由于它们很多，在训练算法时不适合内存，我们将使用模型类<em class="jd">、</em>的<em class="jd"> train_on_batch </em>方法，因此我们必须准备那些批图像。</p><p id="d9c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，首先我们确定将用于训练、验证和测试的图像文件名:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="41c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们有12000张图片用于训练，1500张用于验证，1500张用于测试。如果我们打印<em class="jd"> img_train </em>数组，我们会得到以下响应:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="5c34" class="lh jw hi ld b fi li lj l lk ll">['0000/2762000.png',  <br/>'0000/973000.png',  <br/>'0000/810000.png',  <br/>'0000/2914000.png',  <br/>'0000/15000.png',<br/>...]</span></pre><p id="ed7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们在这里存储所有的文件名，然后我们将用来创建每个批处理。为此，我们定义了以下函数，其中<em class="jd"> imd_idx </em>是已经处理的图像数量，<em class="jd"> arr </em>是包含文件名的列表，<em class="jd"> n_samples </em>是要处理的图像数量。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="6757" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数加载图像并将它们作为numpy数组附加在一起。因此，它返回处理的新图像数、附加的黑白草图数组和附加的彩色图像数组。</p><p id="3510" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以定义模型架构了:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="dd19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们的输入大小是128x128像素的图像，这里我们可以看到我们如何通过使用Keras的<em class="jd"> Add() </em>函数将编码器路径与解码器路径连接起来。我们还使用<em class="jd"> Conv2DTranspose() </em>函数再次放大图像。</p><p id="8fd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以开始训练它了，正如我之前所说的，我们将使用模型类的<em class="jd"> train_on_batch </em>和<em class="jd"> test_on_batch </em>方法来创建训练管道。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="9a26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，一旦模型被训练好，我们就可以用它来画草图，并将它们与真正的画进行比较。让我们从测试集中画一些图像。左边是草图，中间是真实的绘画图像，右边是模特画的图像。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lm"><img src="../Images/9105258f1aa97402b2465f8a94390521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_NWQxHP-wHXlevwH2tKOg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">将真实的油漆与模型油漆进行比较</figcaption></figure><p id="94d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，在第一张图片上，模型遇到了一点麻烦，可能是因为背景的原因，但在第二张图片上，模型做得非常好。</p><h1 id="cacf" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">AI绘画App</h1><p id="cdb2" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">有了训练好的模型，我们可以用它开发一个应用程序来给用户想要画的任何图像上色。为此，首先我们将使用TensorFlow服务于模型。你可以看我之前的文章来解释如何做到这一点。</p><p id="a8ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们运行了该服务，我们就可以将任何图像作为请求发布到TensorFlow服务端点，作为响应，我们会将该图像显示为彩色。</p><p id="df4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在我们打算用<a class="ae ju" href="https://plotly.com/dash/" rel="noopener ugc nofollow" target="_blank"> Dash by Plotly </a>来构建一个app。该应用程序将接收输入图像，对其进行处理，将其发送到TensorFlow服务端点，并向客户端显示处理后的输出。这里我们有一个视频作为例子</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ln"><img src="../Images/e7ed9a2f0425d5bac17433bb294fb604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*9kEcmItFZcE1tdBJRvJJ_Q.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">Plotly应用程序，内置经过训练的模型</figcaption></figure><p id="9411" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了构建这个应用程序，我们将使用<a class="ae ju" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>。Compose是一个定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，只需一个命令，您就可以从您的配置中创建并启动所有服务。</p><p id="f3b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，首先我们必须定义两个docker文件。TensorFlow服务Dockerfile文件如下</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="a3a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Plotly应用程序的Dockerfile文件如下</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="43f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们必须在YAML配置文件上定义服务:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="644c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们定义了每个服务的端口和镜像，我们定义了Plotly app依赖TensorFlow服务。因此，要运行它，我们应该执行以下命令:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="ff56" class="lh jw hi ld b fi li lj l lk ll">docker-compose up</span></pre><p id="a0a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经运行了Plotly应用程序和TensorFlow服务端点。所以如果我们去<a class="ae ju" href="http://localhost:8050/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8050/ </a>就可以开始玩app了。</p></div></div>    
</body>
</html>