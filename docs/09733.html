<html>
<head>
<title>CUDA — Compute Unified Device Architecture— Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CUDA —计算统一设备架构—第 1 部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cuda-compute-unified-device-architecture-part-1-8f9ff3179440?source=collection_archive---------8-----------------------#2020-09-18">https://medium.com/analytics-vidhya/cuda-compute-unified-device-architecture-part-1-8f9ff3179440?source=collection_archive---------8-----------------------#2020-09-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2872f92cddf63a1034d7cf621c7d3682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_DF20Zk4DTh6fUMl5lp8Og.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由乔丹·哈里森提供</figcaption></figure><p id="82d5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">异构计算</strong>正在成为新常态。让我们以智能手机为例，典型的智能手机有中央处理器(CPU)、图形处理单元(GPU)、数字信号处理器(DSP)、调制解调器和各种编码器&amp;解码器。每个计算单元都是为处理特定的工作负载而定制的，但是如果这些定制的计算单元(而不是 CPU)可以在空闲状态下用于通用计算，那么这种工作负载共享将卸载 CPU 的一部分工作负载，从而提高性能。</p><p id="63b1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">GPU 就是这样一种定制处理器，最初是为并行处理像素而设计的。从像素操作开始，GPU 已经走过了漫长的道路，现在 GPGPU 或通用图形处理单元变得越来越普遍。GPU 目前用于加速人工智能、高性能计算、边缘计算等的工作负载。</p><p id="009f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了利用成千上万个 GPU 核心的能力，NVIDIA 开发了一种称为 CUDA 的编程模型。现在，成千上万的应用使用 CUDA 和 NVIDIA GPUs 加速。这一系列文章的重点是 CUDA 编程入门，从在我们的机器上使用 CUDA 开始，到编写我们自己的 CUDA 代码，理解编码时每个架构选择背后的直觉。</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="c60c" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">我们开始吧！</h1><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/8cd09b2040d2d098263730c493af27cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffdEPFKghybRp9J82VQQmw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由马库斯·斯皮斯克提供</figcaption></figure><p id="dfad" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇文章中，我将设置背景并列出某些术语。</p><p id="b763" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">进程</strong> —进程是处理器当前正在处理的应用程序的实例。</p><p id="b171" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">线程</strong> —线程是一个进程中可以由处理器独立执行的一组指令。一个进程中可以有多个线程，但至少该进程必须有一个线程，即充当该进程入口点的主线程。</p><p id="8a14" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">上下文</strong> —上下文就像一个进程的元数据，存储着进程的当前状态、内存地址、计数器值等信息。</p><p id="3557" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">并发</strong> —通过上下文切换，不同的进程可以在随后的时隙中执行，因此看起来像是所有进程的并行执行。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/ba680485cf9f44de23b2c516e020986d.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/1*LIpyfw0RG9I7FyMPpwa-PQ.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由 IBM 知识中心提供</figcaption></figure><p id="cdf3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">并行处理</strong> —指各进程线程并行执行，不在有上下文切换的时隙内执行。</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="1c09" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">以下是 CUDA 程序的基本布局</strong>，</p><ol class=""><li id="ff7e" class="ld le hi iw b ix iy jb jc jf lf jj lg jn lh jr li lj lk ll bi translated">CPU 中数据的初始化。</li><li id="ba6b" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">将数据从 CPU 上下文转移到 GPU 上下文。</li><li id="b9f4" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">启动 GPU 内核，指定所需的 GPU 参数。</li><li id="bca8" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">将结果从 GPU 上下文转移到 CPU 上下文。</li><li id="65fd" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">回收 CPU 和 GPU 的内存。</li></ol><p id="b254" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从现在开始，我们将称 CPU 为主机，GPU 为设备。因此，在 CPU 上执行的代码是主机代码，在 GPU 上执行的代码是设备代码。</p><h1 id="1010" class="jz ka hi bd kb kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw bi translated">“你好世界！”</h1><pre class="ky kz la lb fd lw lx ly lz aw ma bi"><span id="1372" class="mb ka hi lx b fi mc md l me mf">//Pre-processor directives<br/>#include &lt;stdio.h&gt;</span><span id="37cf" class="mb ka hi lx b fi mg md l me mf">#include "cuda_runtime.h"<br/>#include "device_launch_parameters.h"</span><span id="6b32" class="mb ka hi lx b fi mg md l me mf">//Device code<br/>__global__<br/>void cuda_kernel()<br/>{<br/>    printf("Hello World!");<br/>}</span><span id="227d" class="mb ka hi lx b fi mg md l me mf">//Host code<br/>int main()<br/>{<br/>    cuda_kernel &lt;&lt;&lt; 1, 1 &gt;&gt;&gt; ();<br/>    cudaDeviceSynchronize();</span><span id="ff52" class="mb ka hi lx b fi mg md l me mf">    cudaDeviceReset();  <br/>    return 0;<br/>}</span></pre><p id="4bc3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">关于代码的要点:</strong></p><ol class=""><li id="6ae9" class="ld le hi iw b ix iy jb jc jf lf jj lg jn lh jr li lj lk ll bi translated"><strong class="iw hj"> __global__ </strong>修饰符告诉编译器跟在后面的函数是设备代码。</li><li id="7cb9" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">设备功能的返回类型始终为“<strong class="iw hj">无效</strong>”。应该声明显式语句来将数据从设备传输到主机。</li><li id="7a3b" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">主函数中设备函数调用的语法不同。尖括号中的 1 表示一个块中的线程数和一个网格中的总块数。更多细节将在第二部分介绍。</li><li id="2e51" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">cudaDeviceSynchronize() 指示主机代码等待设备代码完成执行。如果代码中不包含此方法，则主机执行将继续进行，而不等待设备执行和结果。</li></ol></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="5f6e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">内务工作</h1><ol class=""><li id="c0f5" class="ld le hi iw b ix mh jb mi jf mj jj mk jn ml jr li lj lk ll bi translated">我已经跟随这个<a class="ae mm" href="https://developer.nvidia.com/cuda-downloads" rel="noopener ugc nofollow" target="_blank">链接</a>下载了 CUDA。我已经安装了 CUDA 11.0 版本。为了安装 CUDA，我遵循了这个<a class="ae mm" href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html" rel="noopener ugc nofollow" target="_blank">链接</a>。</li><li id="62b8" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">我使用 Eclipse IDE 和 NVIDIA NSIGHT 插件，因为 Eclipse NSIGHT edition 在 CUDA Toolkit 的当前版本中已被否决。此<a class="ae mm" href="https://docs.nvidia.com/cuda/nsight-eclipse-plugins-guide/index.html" rel="noopener ugc nofollow" target="_blank">链接</a>将指导您完成此操作。</li></ol></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="8474" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">第二部分</strong></h1><p id="9a2a" class="pw-post-body-paragraph iu iv hi iw b ix mh iz ja jb mi jd je jf mn jh ji jj mo jl jm jn mp jp jq jr hb bi translated">在下一部分，我将详细介绍 CUDA 运行时将初始化的设备启动参数和其他隐式变量。此外，我将讨论设备启动参数的边界值，以及这些值如何影响性能。</p><p id="49ee" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第二部分的链接在这里是<a class="ae mm" rel="noopener" href="/analytics-vidhya/cuda-compute-unified-device-architecture-part-2-f3841c25375e"/>。</p></div></div>    
</body>
</html>