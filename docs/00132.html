<html>
<head>
<title>Deploy Your First Deep Learning Model On Kubernetes With Python, Keras, Flask, and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python、Keras、Flask和Docker在Kubernetes上部署您的第一个深度学习模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deploy-your-first-deep-learning-model-on-kubernetes-with-python-keras-flask-and-docker-575dc07d9e76?source=collection_archive---------0-----------------------#2018-10-04">https://medium.com/analytics-vidhya/deploy-your-first-deep-learning-model-on-kubernetes-with-python-keras-flask-and-docker-575dc07d9e76?source=collection_archive---------0-----------------------#2018-10-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d04780ba30aa4e81a237c85f1e708a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hpICfSgnYcww5kt5"/></div></div></figure><h1 id="89db" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">如此简单，连你的老板都能做到！</h1><p id="9105" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这篇文章展示了一个<em class="km"> *basic* </em>的例子，展示了如何使用Keras构建深度学习模型，使用Flask将其作为REST API，并使用Docker和Kubernetes进行部署。</p><p id="24b0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这不是一个健壮的生产实例。对于那些听说过Kubernetes但还没有尝试过的人来说，这是一个快速指南。</p><p id="15df" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为此，我在这个过程的每一步都使用谷歌云。原因很简单——我不想在我的Windows 10家用笔记本电脑上安装Docker和Kubernetes。谷歌云非常好用。</p><p id="2c11" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">对你们所有人的额外好处是复制我的步骤应该容易得多，因为你们可以使用我所使用的精确规范来运行一切。</p><p id="9d7c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">此外，如果你担心成本，不要。谷歌为新账户提供了数百美元的免费信用额度，对于我将要向你展示的一切，我甚至还没有触及它的表面。</p><h1 id="8575" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么Kubernetes支持ML和数据科学</h1><p id="64b4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Kubernetes及其更广泛的新流行语“原生云”正在席卷全球。别担心——你有理由怀疑。我们都看到科技炒作泡沫变成了名副其实的术语海啸，其中有<em class="km">人工智能</em>、<em class="km">大数据</em>，以及<em class="km">云</em>。Kubernetes是否会出现同样的情况，还有待观察。</p><p id="b624" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">但是在你的数据科学外行今天指导你的情况下，我对使用Kubernetes的变革性原因既没有理解也没有兴趣。我的动机很简单。我想部署、扩展和管理一个提供预测服务的REST API。正如您将看到的，Kubernetes使这变得非常容易。</p><p id="718f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">让我们开始吧</p><h1 id="ba27" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">快速大纲</h1><ol class=""><li id="a446" class="ks kt hi jq b jr js jv jw jz ku kd kv kh kw kl kx ky kz la bi translated">使用谷歌云创建您的环境</li><li id="7646" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">使用Keras、Flask和Docker将深度学习模型作为API</li><li id="1adc" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">使用Kubernetes部署所述模型</li><li id="4240" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">沉浸在你新发现的知识的荣耀中</li></ol><h1 id="425d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">步骤1—使用谷歌云创建环境</h1><p id="941a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我使用Google Compute Engine上的一个小VM来构建、服务和对接一个深度学习模型。不要求您也这样做。我尝试在我的Windows 10笔记本电脑上安装最新版本的Docker CE(社区版)。失败了。我认为，比起弄清楚如何安装Docker，花钱(只是使用免费的谷歌云信用)是对我时间的更好利用。选择权在你。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/c2d0882d795a4303013b45e73b392146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUAYU6Ol3kc-BJF5gZ4_RA.png"/></div></div></figure><p id="8d82" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">要启动Google Cloud VM，请打开屏幕左侧的功能区。选择计算引擎。</p><p id="5805" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">然后选择“创建实例”。您可以在下面的照片中看到，我已经运行了一个实例。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/5fd6e970b013a488a06db78af529caec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1cx80c0CgohQRvIYmkck9w.png"/></div></div></figure><p id="d4bf" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">下一步是选择我们想要使用的计算大小。默认(读:最便宜的)设置应该工作得很好，但是考虑到我们最多只需要这个虚拟机1个小时，我选择了4个15GBs内存的4vCPUs。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/27f5d84387f826bef64a237cf617e991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*TlybZKutOgD2xF4_vDt8rA.png"/></div></div></figure><p id="fb12" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">接下来，我选择我想要使用的操作系统和磁盘空间。选择“引导磁盘”来编辑默认值。我选择Centos 7作为我的操作系统，并将磁盘容量从10GB增加到100GB。我选择的操作系统(Centos)不是必需的。然而，我建议将磁盘大小增加到10GBs以上，因为我们创建的Docker容器每个大约1GB。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/394145d8a4af7a7955cd702c2a0c1d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVqtn1_MgvA646M27TH9rQ.png"/></div></div></figure><p id="b013" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">创建虚拟机之前的最后一步是设置防火墙规则以允许HTTP/S。完全透明，我不确定是否需要这一步。我将向您展示在我们将API部署到Kubernetes之前，如何编辑防火墙设置来测试我们在VM上的API。因此，勾选这些复选框是不够的，还有更多的工作要做。我只是没有回去再次尝试这个教程没有检查他们。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/42f9dd769063260a65eae436137f7586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*97xCXpVyFMnrk6k1m5ympQ.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">不确定是否需要此步骤</figcaption></figure><p id="f676" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在点击“创建”。太棒了。难的部分基本完成了！</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/521bec6c48abc4a5def6f6d560325d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b80mKfRZXXbvWf77gwZX3Q.png"/></div></div></figure><h1 id="5228" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">步骤2-使用Keras建立深度学习模型</h1><p id="d68a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在，让我们SSH到我们的虚拟机，并开始构建我们的模型。最简单的方法就是点击你的虚拟机旁边的SSH图标(如下)。这将在您的浏览器中打开一个终端。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/b32fbf9a63f7dd5a974bb647e7b61386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qRWFVHOiL5HJHWsXfSPMeQ.png"/></div></div></figure><ol class=""><li id="dbc9" class="ks kt hi jq b jr kn jv ko jz lv kd lw kh lx kl kx ky kz la bi translated"><strong class="jq hj">删除现有版本的Docker </strong></li></ol><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="4a40" class="md ir hi lz b fi me mf l mg mh">sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine</span></pre><p id="fe58" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">请注意，如果您选择Centos 7以外的操作系统，这些命令会有所不同。</p><p id="7fdd" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">2.<strong class="jq hj">安装最新版本的Docker </strong></p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="87a1" class="md ir hi lz b fi me mf l mg mh">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><span id="e3e0" class="md ir hi lz b fi mi mf l mg mh">sudo yum-config-manager — add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><span id="8fb0" class="md ir hi lz b fi mi mf l mg mh">sudo yum install docker-ce</span></pre><p id="e206" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">3.<strong class="jq hj">启动Docker并运行测试脚本</strong></p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="c4bb" class="md ir hi lz b fi me mf l mg mh">sudo systemctl start docker<br/>sudo docker run hello-world</span></pre><p id="4cf4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果您看到类似以下消息的输出，那么您就一切就绪了。</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="43aa" class="md ir hi lz b fi me mf l mg mh">Hello from Docker!<br/>This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.</span></pre><p id="e5dc" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">4.<strong class="jq hj">创建我们的深度学习模型</strong></p><p id="e6b7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们要复制阿德里安·罗斯布鲁克写的剧本。Adrian创建了一个优秀的简短教程，介绍如何使用Keras构建深度学习模型，并使用Flask提供服务。你可以在这里深入阅读教程<a class="ae mj" href="https://blog.keras.io/building-a-simple-keras-deep-learning-rest-api.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="11d4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我不得不对艾利安的剧本做了两处关键的修改来让它运行。如果你不关心Docker和Tensorflow的细节，可以跳过下面两段。</p><p id="4f35" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我改变的第一件事与Docker有关。在本地运行应用程序时，默认flask行为是在本地主机(127.0.0…)上提供应用程序。这在Docker容器内部运行时会导致问题。解决办法很简单。调用<code class="du mk ml mm lz b">app.run()</code>时，像<code class="du mk ml mm lz b">app.run(host='0.0.0.0')</code>一样指定url为0.0.0.0。现在，我们的应用程序在本地主机和外部IP上都可用。</p><p id="f9c9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">下一个问题与张量流有关。当我运行Adrian的原始脚本时，我无法成功调用该模型。我阅读了这个<a class="ae mj" href="https://github.com/tensorflow/tensorflow/issues/14356" rel="noopener ugc nofollow" target="_blank"> Github问题</a>，并对代码进行了后续修改。</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="3e3b" class="md ir hi lz b fi me mf l mg mh">global graph<br/>graph = tf.get_default_graph()<br/>...<br/>with graph.as_default():<br/>    preds = model.predict(image)</span></pre><p id="4471" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">老实说，我不知道为什么会这样。但确实如此。所以让我们开始吧。</p><p id="2aaa" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">首先，让我们创建一个名为keras-app的新目录，并移入该目录</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="34ad" class="md ir hi lz b fi me mf l mg mh">mkdir keras-app<br/>cd keras-app</span></pre><p id="a21b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在让我们创建一个名为app.py的文件。您可以使用您选择的文本编辑器。我更喜欢使用vim。要创建并打开app.py，请键入:</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="fe2f" class="md ir hi lz b fi me mf l mg mh">vim app.py</span></pre><p id="b1a8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">从你的文件内部，点击“I”键进入插入模式。现在，您已经准备好粘贴以下代码。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="909c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">一旦你复制了上面的代码，你可以点击“Esc”键退出编辑模式。</p><p id="c33f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">然后通过键入<code class="du mk ml mm lz b">:x</code>保存并关闭文件</p><p id="2933" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">5.<strong class="jq hj">创建一个requirements.txt文件</strong></p><p id="06b5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在回到正题。我们将在Docker容器中运行这段代码。因此，为了做到这一点，我们需要首先创建一个requirements.txt文件。这个文件将包含我们的代码需要运行的包，例如，keras、flask等。这样，无论我们将Docker容器发布到哪里，底层服务器都能够安装我们代码所需的依赖项。</p><p id="db4c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">和前面一样，通过键入<code class="du mk ml mm lz b">vim requirements.txt</code>用vim创建并打开一个名为requirements.txt的文件</p><p id="d767" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">将以下内容复制到requirements.txt中，并像之前一样保存和关闭</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="861c" class="md ir hi lz b fi me mf l mg mh">keras<br/>tensorflow<br/>flask<br/>gevent<br/>pillow<br/>requests</span></pre><p id="7e66" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">6.<strong class="jq hj">创建一个Dockerfile </strong></p><p id="9963" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">太好了！现在让我们创建docker文件。这是Docker将读取的文件，用于构建和运行我们的项目</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="609b" class="md ir hi lz b fi me mf l mg mh">FROM python:3.6<br/>WORKDIR /app</span><span id="bd95" class="md ir hi lz b fi mi mf l mg mh">COPY requirements.txt /app<br/>RUN pip install -r ./requirements.txt</span><span id="5384" class="md ir hi lz b fi mi mf l mg mh">COPY app.py /app<br/>CMD ["python", "app.py"]~</span></pre><p id="e043" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">事情是这样的。我们正在指导Docker下载Python 3的基础映像。一旦完成，我们要求Docker使用Python包管理器<code class="du mk ml mm lz b">pip</code>来安装<code class="du mk ml mm lz b">requirements.txt</code>中详述的包</p><p id="1822" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">之后，我们告诉Docker通过<code class="du mk ml mm lz b">python app.py</code>运行我们的脚本</p><p id="20b1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">7.<strong class="jq hj">构建Docker容器</strong></p><p id="af0b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们一直在前进。现在让我们构建并测试我们的应用程序。</p><p id="7dbe" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">要构建我们的Docker容器，运行:</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="5ade" class="md ir hi lz b fi me mf l mg mh">sudo docker build -t keras-app:latest .</span></pre><p id="a55b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这指示Docker为位于我们当前工作的director <code class="du mk ml mm lz b">keras-app</code>中的代码构建一个容器</p><p id="2e3f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">该命令需要一两分钟才能完成。幕后发生的事情是Docker正在拉下Python 3.6的映像并安装requirements.txt中列出的包。</p><p id="eaf6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">8.<strong class="jq hj">运行Docker容器</strong></p><p id="496f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在让我们运行Docker容器来测试我们的应用程序:</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="e32f" class="md ir hi lz b fi me mf l mg mh">sudo docker run -d -p 5000:5000 keras-app</span></pre><p id="1c0e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">关于数字的一个快速注释，<code class="du mk ml mm lz b">5000:5000</code> —这里我们告诉Docker让端口5000对外可用，并将我们的本地应用转发到那个端口(它也在本地端口5000上运行)</p><p id="4e41" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">通过运行<code class="du mk ml mm lz b">sudo docker ps -a</code>来检查容器的状态。您应该会看到如下所示的内容</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="b9bd" class="md ir hi lz b fi me mf l mg mh">[gustafcavanaugh@instance-3 ~]$ sudo docker ps -a<br/>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS                    NAMES<br/>d82f65802166        keras-app           "python app.py"     About an hour ago   Up About an hour          0.0.0.0:5000-&gt;5000/tcp   nervous_northcutt<br/></span></pre><p id="7551" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> 9。测试我们的模型</strong></p><p id="3b89" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">随着我们的模型运行，现在是测试它的时候了。这个模型接受一张狗的照片作为输入，并返回狗的品种。在Adrian的回购中，他提供了一个<a class="ae mj" href="https://github.com/jrosebr1/simple-keras-rest-api/blob/master/dog.jpg" rel="noopener ugc nofollow" target="_blank">示例图像</a>，我们将使用相同的图像。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/67e416e2ecc412eda5096dd321607a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*FJWlc5VIb2k5Y64DgMZuww.jpeg"/></div></figure><p id="43d7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">从终端运行:</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="d624" class="md ir hi lz b fi me mf l mg mh">curl -X POST -F image=@dog.jpg 'http://localhost:5000/predict'</span></pre><p id="d2e7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">确保“dog.jpg”在您的当前目录中(或者提供该文件的适当路径)</p><p id="a74f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您应该会看到如下结果:</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="5838" class="md ir hi lz b fi me mf l mg mh">{"predictions":[{"label":"beagle","probability":0.987775444984436},{"label":"pot","probability":0.0020967808086425066},{"label":"Cardigan","probability":0.001351703773252666},{"label":"Walker_hound","probability":0.0012711131712421775},{"label":"Brittany_spaniel","probability":0.0010085132671520114}],"success":true}</span></pre><p id="0c92" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们可以看到，我们的模型正确地将狗归类为小猎犬。太棒了。你已经成功地用Keras运行了一个训练好的深度学习模型，用Flask服务了它，用Docker包装了它。最困难的部分已经过去了。现在让我们用Kubernetes部署这个容器</p><h1 id="8a80" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">步骤3 —使用Kubernetes部署模型</h1><p id="4ec7" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">下一部分进展很快。</p><ol class=""><li id="5b9f" class="ks kt hi jq b jr kn jv ko jz lv kd lw kh lx kl kx ky kz la bi translated"><strong class="jq hj">创建一个Docker Hub账户(如果你没有)</strong></li></ol><p id="5825" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们做的第一件事是将我们的模型上传到Docker Hub。(如果您没有Docker Hub帐户，现在就创建一个，不要担心，它是免费的)。我们这样做的原因是，我们不会将我们的容器物理地移动到我们的Kubernetes集群。相反，我们将指示Kubernetes从一个集中托管的服务器(即Docker Hub)安装我们的容器。</p><p id="e835" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> 2。登录您的Docker Hub账户</strong></p><p id="4365" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">一旦你创建了你的Docker Hub账户，通过<code class="du mk ml mm lz b">sudo docker login</code>从命令行登录。您需要提供您的用户名和密码，就像您登录网站一样。</p><p id="c8f1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果您看到这样的消息:</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="35a0" class="md ir hi lz b fi me mf l mg mh">Login Succeeded</span></pre><p id="2c78" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">然后你就可以成功登录了。现在让我们进入下一步。</p><p id="1de8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> 3。给你的容器贴上标签</strong></p><p id="bd25" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在上传之前，我们需要标记我们的容器。把这一步想象成给我们的容器命名。</p><p id="bfde" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">首先，运行<code class="du mk ml mm lz b">sudo docker images</code>并定位我们的keras-app容器的<em class="km">图像id </em>。</p><p id="d9e4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">输出应该如下所示:</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="0695" class="md ir hi lz b fi me mf l mg mh">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE keras-app           latest              ddb507b8a017        About an hour ago   1.61GB</span></pre><p id="f2fe" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在让我们标记我们的keras-app。确保遵循我的格式，并用您的特定值替换图像id和docker hub id的值。</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="1d40" class="md ir hi lz b fi me mf l mg mh">#Format<br/>sudo docker tag &lt;your image id&gt; &lt;your docker hub id&gt;/&lt;app name&gt;<br/>#My Exact Command - Make Sure To Use Your Inputs<br/>sudo docker tag ddb507b8a017 gcav66/keras-app</span></pre><p id="7c17" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj"> 4。将我们的集装箱推到码头中心</strong></p><p id="6f73" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在我们可以推动我们的容器。从shell运行:</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="ffe5" class="md ir hi lz b fi me mf l mg mh">#Format<br/>sudo docker push &lt;your docker hub name&gt;/&lt;app-name&gt;</span><span id="f4f6" class="md ir hi lz b fi mi mf l mg mh">#My exact command<br/>sudo docker push gcav66/keras-app</span></pre><p id="dda8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，如果您导航回Docker Hub的网站，您应该会看到您的keras-app存储库。干得好！我们准备好最后的冲刺了。</p><p id="34a1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">5.创建一个Kubernetes集群</p><p id="a4da" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">从Google Cloud主页屏幕中，选择Kubernetes引擎</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/74600be6b4ea354b862991c3575bf7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*P8FATFdAexW6xBL-75J9Dg.png"/></div></figure><p id="68dd" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">然后创建一个新的Kubernetes集群</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/8227ddc64331727804e5abea9bb9b5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*EDPwclExoLfsNLhMH0X1Aw.png"/></div></figure><p id="1942" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">接下来，我们将定制集群中节点的大小。我将选择4个15 GBs内存的4vCPUs。您可以尝试使用较小的集群。请记住，默认设置会启动3个节点，因此您的集群将拥有3倍于您所提供的资源，例如，在我的例子中，45gb的Ram。我有点懒，选择了一个更大的尺寸，因为我们不会让我们的kubernetes集群运行很长时间。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/e39e5d3acd576f5b334a2a71d21a8af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*EZ-W4R0P0skF1l6gKUWH4A.png"/></div></figure><p id="0949" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">之后点击<strong class="jq hj">创建</strong>即可。您的群集将需要一两分钟的时间来加速旋转。</p><p id="b679" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，让我们连接到集群。点击<strong class="jq hj"> Run in Cloud Shell </strong>调出Kubernetes集群的控制台。请注意，这是一个独立于VM的shell环境，在这里您创建并测试了Docker容器。我们可以在虚拟机上安装Kubernetes，但谷歌的Kubernetes服务为我们实现了自动化。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/86057b6cfa208eebbca318ec8c2e4845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fMLWSUB6kn2ueG5QgTZ5w.png"/></div></div></figure><p id="dac9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在我们在Kubernetes运行docker容器。注意，图像标签只是指向docker Hub上托管的Docker图像。此外，我们将使用<code class="du mk ml mm lz b">--port</code>指定我们希望在端口5000上运行我们的应用程序。</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="fa06" class="md ir hi lz b fi me mf l mg mh">kubectl run keras-app --image=gcav66/keras-app --port 5000</span></pre><p id="ae0c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在Kubernetes，容器都在豆荚里运行。我们可以通过键入<code class="du mk ml mm lz b">kubectl get pods</code>来验证我们的pod正在运行。如果你看到下面这样的东西，你就万事俱备了。</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="b3d5" class="md ir hi lz b fi me mf l mg mh">gustafcavanaugh@cloudshell:~ (basic-web-app-test)$ kubectl get pods<br/>NAME                         READY     STATUS    RESTARTS   AGE<br/>keras-app-79568b5f57-5qxqk   1/1       Running   0          1m</span></pre><p id="4ff1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在我们的pod已经激活并运行，我们需要将端口80上的pod暴露给外界。这意味着任何访问我们部署的IP地址的人都可以访问我们的API。这也意味着我们不必像以前那样在url后面指定一个讨厌的端口号(告别<code class="du mk ml mm lz b">:5000</code>)。</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="558c" class="md ir hi lz b fi me mf l mg mh">kubectl expose deployment keras-app --type=LoadBalancer --port 80 --target-port 5000</span></pre><p id="d17b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们快到了！现在，我们通过运行<code class="du mk ml mm lz b">kubectl get service</code>来确定部署的状态(以及调用API所需的URL)。同样，如果该命令的输出如下所示，那么您做得很好。</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="22f0" class="md ir hi lz b fi me mf l mg mh">gustafcavanaugh@cloudshell:~ (basic-web-app-test)$ kubectl get service<br/>NAME         TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)        AGE<br/>keras-app    LoadBalancer   10.11.250.71   35.225.226.94   80:30271/TCP   4m<br/>kubernetes   ClusterIP      10.11.240.1    &lt;none&gt;          443/TCP        18m</span></pre><p id="42cc" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为您的keras应用程序获取集群ip，因为现在是关键时刻。打开您的本地终端(或者您手边有狗狗照片的任何地方)并运行以下命令来调用API <code class="du mk ml mm lz b">curl -X POST -F image=@dog.jpg 'http://&lt;your service IP&gt;/predict'</code>。</p><p id="e00a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">尽情享受结果吧！</p><p id="afdb" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如下图所示，API正确地返回了图片的beagle标签。</p><pre class="lh li lj lk fd ly lz ma mb aw mc bi"><span id="748c" class="md ir hi lz b fi me mf l mg mh">$ curl -X POST -F image=@dog.jpg 'http://35.225.226.94/predict'<br/>{"predictions":[{"label":"beagle","probability":0.987775444984436},{"label":"pot","probability":0.0020967808086425066},{"label":"Cardigan","probability":0.001351703773252666},{"label":"Walker_hound","probability":0.0012711131712421775},{"label":"Brittany_spaniel","probability":0.0010085132671520114}],"success":true}</span></pre><h1 id="fb28" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">第四步——总结</h1><p id="157f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在本教程中，我们使用Keras和Flask将深度学习模型作为REST API。然后，我们将该应用程序放入Docker容器中，将容器上传到Docker Hub，并使用Kubernetes部署它。</p><p id="d64e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">只需两个命令，Kubernetes就可以部署我们的应用，并向世界展示它。拍拍自己的背，你应该感到自豪。</p><p id="83db" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，我们可以对这个项目做很多改进。首先，我们应该将运行flask应用程序的python web服务器从本地python服务器改为生产级服务器，如gunicorn。我们还应该探索Kubernetes的伸缩和管理特性，这一点我们几乎没有涉及到。最后，我们可以尝试从头构建一个kubernetes环境。</p><p id="8561" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">如何联系</strong></p><p id="15b5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果这篇教程有用，你想了解更多，请给我在hello@guscav.com写封短信。此外，请继续关注上述所有内容的视频演示。但最重要的是…</p><p id="9775" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">保持美丽</p></div></div>    
</body>
</html>