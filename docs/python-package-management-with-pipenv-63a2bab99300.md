# 使用 Pipenv 的 Python 包管理

> 原文：<https://medium.com/analytics-vidhya/python-package-management-with-pipenv-63a2bab99300?source=collection_archive---------11----------------------->

Pipenv 是一个现代的包管理器，它将其他语言中的最佳包管理实践引入到 Python 中。为了理解 Pipenv 的好处，让我们从为什么我们应该使用包管理器开始。

![](img/0c7558c5fdb9391ddd8f602a9e05d5ef.png)

[夏羽·亚伊奇](https://unsplash.com/@stefyaich?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 为什么要做包管理？

在一些只有一两个程序员的小项目中使用 Python 是微不足道的。然而，随着团队和项目规模的增长，问题开始出现。

想象一群人在一个 Python 项目中工作。艾伦成功地开始了这个项目，然后把它转给了鲍勃。Bob 在他的机器上检查了这个项目，发现它不能在他的机器上运行，因为 Alan 使用了一些包的较新版本。Bob 试图将这些包更新到 Alan 使用的相同版本，但是后来他发现这些更新破坏了他与 Carthy 合作的项目的另一部分。在这一点上，Bob 的选择是要么修复 Alan 代码中的依赖问题，要么修复 Carthy 代码中的依赖问题，这两者都不容易，而且没有破坏其他代码的风险。

解决这类问题是包管理器的任务。

现代包装管理包括两个主要概念:

1.  依赖性管理
2.  环境隔离

依赖管理声明项目使用什么包，这些包依赖于什么其他包，以及它们确切使用什么版本。它允许在同一个项目中工作的每个人都使用相同的版本，消除了代码中的兼容性和功能性问题。

环境隔离是一种保持每个项目的依赖关系完全隔离的机制。它允许一个项目使用一组依赖项，而另一个项目使用另一组依赖项，它们可能是不同的版本。

# Python 的包管理方式

Python 的一个主要缺点是缺乏内置的包管理系统。与其他现代语言如 *NodeJS* 或 *Go* 不同，Python 没有设计包管理机制。默认情况下，每个软件包都由用户手动安装到所谓的“基础环境”中，在这个环境中，安装的软件包可以在整个系统中看到和使用。这种行为正是前面提到的问题的原因。基础环境(也称为全局环境)的使用使得项目无法独立管理它们的依赖关系。

Python 程序员通过使用`virtualenv`包和`pip`( Python 的默认包安装程序)创建一个“临时”包管理实践来解决这个限制。

`virtualenv`包允许一个项目通过创建一个虚拟环境来实现环境隔离，这个虚拟环境隐藏了基础环境。在虚拟环境中，所有代码的行为就好像包安装在基础环境中一样，即使它们安装在项目本身中。

为了实现依赖管理，Python 程序员使用所谓的`requirements.txt`文件作为依赖声明。该文件是使用`pip`创建的，在重新创建项目时由`pip`使用。

# 标准包装管理实践

第一个程序员通过以下方式创建新项目:

1.  使用`virtualenv`为项目创建一个新的虚拟环境
2.  使用`pip install`安装所有依赖项
3.  使用`pip freeze > requirements.txt`命令创建需求文件。

另一个程序员可以通过

1.  使用`virtualenv`为项目创建一个新的虚拟环境
2.  使用`pip install -r requirements.txt`安装所有依赖项

# 当前解决方案的问题

虽然标准实践允许 Python 程序员实现其他语言的包管理器所提供的相同功能，但它包含两个主要缺陷:

1.  虚拟环境和依赖关系管理是分开的
2.  需求文件不是真正的依赖管理

## 1.虚拟环境和依赖关系管理是分开的

对于 Python 程序员来说，处于错误的环境中太容易了。当程序员创建需求文件时，他们可能会错误地位于基础环境而不是虚拟环境中。因此，他们创建的需求文件列出了他们基础环境中的包，而这些包可能与项目中使用的包非常不同。更糟糕的是，当程序员从需求文件中安装依赖项时，它们也可能在基础环境中，而不是在预期的环境中。列出的软件包在系统范围内安装，其影响是他们想象中最糟糕的。

Python 虚拟环境不容易激活的事实对这种情况没有帮助。人们很容易忘记在`pip install -r requirements.txt`之前`source venv/bin/activate`，并看到他们的工作机器在他们眼前腐败。

## 2.需求文件不是真正的依赖管理

`pip freeze > requirements.txt`到底是做什么的？`pip freeze`命令的作用是将所有已安装软件包的列表及其版本号打印到屏幕上。`> requirements.txt`是一个叫做*重定向*的小命令行技巧。这意味着将这些打印文本写入`requirements.txt`文件。因此，需求文件的内容是环境中所有已安装的包及其版本号的列表。

将它与其他包管理器的依赖关系管理文件进行比较，例如 *npm* 或 *cargo* ，差异非常明显。

**1。这个 requirements.txt 属于什么项目？**

依赖文件应该包含项目的名称和版本号，这样就不可能混淆项目/版本之间的依赖关系。

**2。没有依赖关系层次**

一个程序员安装了他们需要的一个包。然后他们创建了一个`requirements.txt`文件，发现里面列出了十几个软件包。`requirements.txt`中列出的大多数包都是列表中其他包的依赖项。项目所依赖的、由程序员安装的包和那些*顶层*包所依赖的包之间没有区别。

这就是为什么使用`requirements.txt`作为依赖文件是个坏主意的主要原因。当存在冲突包问题时，大多数情况下，冲突包是那些依赖包，而不是顶层包。因为程序员自己通常不知道他们安装的包依赖于什么包，所以手动避免冲突是不可能的。

现代的包管理器通常将依赖分成这两组。由程序员手动安装的“真正的”依赖项存储在主依赖项文件中。依赖关系的依赖关系在安装过程中被解析，并存储在一个单独的文件中，通常称为*锁文件*。

**3。作为要求的包版本。**

`requirements.txt`中的版本号是准确的。当它显示`numpy==1.19.1`时，只能安装 1.19.1 版本。依赖文件中的版本号应该是有条件的。例如，它应该指出项目是否需要 1.19.1 版本，或者包括任何更新的版本(> =1.19.1)，或者任何版本(*)。这允许解析器找到最适合项目的版本。实际使用的版本将被记录在锁文件中。

大多数包管理器还将主要依赖项(程序逻辑所需的包)和用于开发目的(如测试和调试)的开发依赖项分开。通过这种设置，只有相关的包将被打包并分发给最终用户。

# Pipenv 简介

Pipenv 是一个 Python 包管理器，旨在为 Python 引入一个优秀的现代包管理器。来自 Pipenv 官方文档:

> *Pipenv 是一个生产就绪的工具，旨在将所有打包世界的精华引入 Python 世界。*

Pipenv 是`virtualenv`和`pip`的包装器。它支持 Python 中的依赖管理和环境隔离，这符合其他语言的包管理器所遵循的实践。使用 pipenv 解决了上述所有问题，无需任何手动过程。

# 如何使用 pipenv

## 装置

按照[https://pypi.org/project/pipenv](https://pypi.org/project/pipenv/)上的说明安装 pipenv

## 创建新项目并安装新包

要创建一个新项目，只需通过

```
pipenv install <package name>
```

Pipenv 将创建新的 Pipfile——这是一个依赖文件——如果还不存在的话。否则，它将更新 Pipfile 来添加新的包。

然后，Pipenv 将解析依赖列表并创建锁文件(Pipfile.lock)。

## 激活虚拟环境

要激活和使用虚拟环境，只需运行

```
pipenv shell
```

进入在虚拟环境中运行的新外壳。所有已安装的软件包对于在这个 shell 中运行的任何程序都是可见的。

另一种选择是直接在虚拟环境中启动程序，而不进入 shell。奔跑

```
pipenv run <program name>
```

这个命令在许多常见的 Python 用例中非常方便，比如在使用 Jupyter Notebook 时。人们可以简单地

```
pipenv run jupyter notebook
```

在虚拟环境中启动新笔记本。

## 停用虚拟环境

要停用虚拟环境，只需在 shell 中键入`exit`。

# 结论

尽管 Python 传统上缺乏一个好的包管理器，Pipenv 最终将现代包管理的最佳特性带到了这种语言中，因此 Python 程序员现在可以跨多个项目高效、安全地工作。

*原载于 2020 年 9 月 29 日 https://wattanit.com*[](https://wattanit.com/2020/09/python-package-management-with-pipenv/)**。**