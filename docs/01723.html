<html>
<head>
<title>Convert an Image into One Comprised of Dice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将图像转换成由骰子组成的图像</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/convert-an-image-into-one-comprised-of-dice-4a3cbcb241c5?source=collection_archive---------2-----------------------#2019-11-11">https://medium.com/analytics-vidhya/convert-an-image-into-one-comprised-of-dice-4a3cbcb241c5?source=collection_archive---------2-----------------------#2019-11-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a813" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个项目始于一个朋友问我是否可以制作一个程序，将照片转换成骰子制成的黑白图像。该程序将按如下方式运行:</p><ol class=""><li id="3054" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">导入图像</li><li id="d9a6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">将图像转换为灰度</li><li id="2bf0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">计算每个7x7像素正方形的平均饱和度</li><li id="d86b" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">将每个7x7正方形转换成六面骰子的图像。最低饱和度(0)被转换到管芯的1侧，最高饱和度(255)被转换到6侧</li><li id="70e1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">导出新图像</li></ol><p id="1e4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">听起来很简单。</p><p id="b531" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我做了些调查。我发现PIL(Python图像库)包含了我需要的所有工具。我做了一些挖掘，找到了教程“<a class="ae jr" href="https://www.codementor.io/isaib.cicourel/image-manipulation-in-python-du1089j1u" rel="noopener ugc nofollow" target="_blank">Python</a>中的图像处理”，作者是Isai B. Cicourel。稍加修改，我就能使用本教程中的方法将图像转换成灰度。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="43e0" class="kb kc hi jx b fi kd ke l kf kg">from PIL import Image                                             </span><span id="827d" class="kb kc hi jx b fi kh ke l kf kg"># Create a Grayscale version of the image<br/>def convert_grayscale(image):<br/> # Get size<br/> width, height = image.size</span><span id="8cc8" class="kb kc hi jx b fi kh ke l kf kg"> # Create new Image and a Pixel Map<br/> new = Image.new("RGB", (width, height), "white")<br/> pixels = new.load()</span><span id="db9e" class="kb kc hi jx b fi kh ke l kf kg"> # Transform to grayscale<br/> for i in range(width):<br/>  for j in range(height):<br/>   # Get Pixel<br/>   pixel = image.getpixel((i,j))</span><span id="b3a6" class="kb kc hi jx b fi kh ke l kf kg">   # Get R, G, B values (This are int from 0 to 255)<br/>   red = pixel[0]<br/>   green = pixel[1]<br/>   blue =  pixel[2]</span><span id="244d" class="kb kc hi jx b fi kh ke l kf kg">   # Transform to grayscale<br/>   gray = (red * 0.299) + (green * 0.587) + (blue * 0.114)</span><span id="17c1" class="kb kc hi jx b fi kh ke l kf kg">   # Set Pixel in new image<br/>   pixels[i, j] = (int(gray), int(gray), int(gray))</span><span id="cf79" class="kb kc hi jx b fi kh ke l kf kg"> # Return new image<br/> return new</span></pre><p id="23d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个好的开始，但是我仍然需要代码将灰度图像转换成骰子图像。下面的代码块是我第一次尝试转换图像的方法。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="1c48" class="kb kc hi jx b fi kd ke l kf kg"># Create a version of the image made of dice<br/>def convert_dice(image):<br/> # Get size<br/> width, height = image.size<br/> # Create new Image and a Pixel Map<br/> new = Image.new(width, height)<br/> pixels = new.load()</span><span id="97c5" class="kb kc hi jx b fi kh ke l kf kg"> # Transform to dice                        <br/> 1 = 0<br/> j = 0<br/> while j &lt; height:                         <br/>  while i &lt; width:                          <br/>   # Get saturation                          <br/>   saturation = 0                          <br/>   for k in range(7):                           <br/>    for l in range(7):                            <br/>     pixel = get_pixel(image, i+l, j+k)                                <br/>     saturation += pixel[2]                            <br/>     saturation = saturation/49 # calculate average</span><span id="0b71" class="kb kc hi jx b fi kh ke l kf kg">   for k in range(7):                           <br/>    for l in range(7):                                  <br/>     pixels[i+l, j+k] = (255,255,255)</span><span id="2396" class="kb kc hi jx b fi kh ke l kf kg">   # draw die                          <br/>   if saturation &gt; 212.5:                           <br/>    pixels[i+3, j+3] = (0,0,0)                          <br/>   elif saturation &gt; 170:                           <br/>    pixels[i+1, j+2] = (0,0,0)                                <br/>    pixels[i+5, j+4] = (0,0,0)                          <br/>   elif saturation &gt; 127.5:                           <br/>    pixels[i+1, j+1] = (0,0,0)                               <br/>    pixels[i+3, j+3] = (0,0,0)                                 <br/>    pixels[i+5, j+5] = (0,0,0)                          <br/>   elif saturation &gt; 85:                           <br/>    pixels[i+2, j+2] = (0,0,0)                               <br/>    pixels[i+2, j+4] = (0,0,0)                           <br/>    pixels[i+4, j+2] = (0,0,0)                           <br/>    pixels[i+4, j+4] = (0,0,0)                          <br/>   elif saturation &gt; 42.5:                                 <br/>    pixels[i+1, j+1] = (0,0,0)                           <br/>    pixels[i+5, j+1] = (0,0,0)                           <br/>    pixels[i+3, j+3] = (0,0,0)                           <br/>    pixels[i+1, j+5] = (0,0,0)                           <br/>    pixels[i+5, j+5] = (0,0,0)                          <br/>   else:                           <br/>    pixels[i+2, j+1] = (0,0,0)                           <br/>    pixels[i+4, j+1] = (0,0,0)                           <br/>    pixels[i+2, j+3] = (0,0,0)                           <br/>    pixels[i+4, j+3] = (0,0,0)                           <br/>    pixels[i+2, j+5] = (0,0,0)                           <br/>    pixels[i+4, j+5] = (0,0,0)                                <br/>   i+=7                         <br/>  i=0                         <br/>  j+=7                                                <br/>   <br/> # return new image                        <br/> return new</span></pre><p id="32d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我添加了“main”方法。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="d5c9" class="kb kc hi jx b fi kd ke l kf kg">def main():                       <br/> # Load Image (JPEG/JPG needs libjpeg to load)                        <br/> original = Image.open('img_001.png')                                                </span><span id="6425" class="kb kc hi jx b fi kh ke l kf kg"> # Convert to Grayscale and save                        <br/> new = convert_grayscale(original)                           <br/> new.save('gray.png')                                                </span><span id="0202" class="kb kc hi jx b fi kh ke l kf kg"> # Load gray image                        <br/> gray = Image.open('gray.png')                                                </span><span id="066c" class="kb kc hi jx b fi kh ke l kf kg"> # Crop and save gray image                        <br/> width, height = gray.size                        <br/> gray.crop((0,0,width-width%7,height-heiht%7)).save('gray.png','png')  # makes sure that width and height (pixels) are multiples of 7                                            </span><span id="1f59" class="kb kc hi jx b fi kh ke l kf kg"> # Re-load gray image                        <br/> gray = Image.open('gray.png')                                              </span><span id="2310" class="kb kc hi jx b fi kh ke l kf kg"> # Convert to dice and save                        <br/> new = convert_dice(gray)                        <br/> new.save('dice.png')</span><span id="28ec" class="kb kc hi jx b fi kh ke l kf kg"># run the script<br/>if __name__ == "__main__":<br/> main()</span></pre><p id="d089" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个好的开始。当我运行这段代码时，它转换了这个图像:</p><figure class="js jt ju jv fd kj er es paragraph-image"><div class="er es ki"><img src="../Images/5bd5cd788bd74992cc162009e5e21484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*YWa-uJ1a7_BIBsoYZuieEQ.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">原象</figcaption></figure><p id="d0c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对此:</p><figure class="js jt ju jv fd kj er es paragraph-image"><div class="er es kq"><img src="../Images/7699d1c53c7c0af93092a4fc2aa327e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*M7b4LioZQdMTdEtdIVEB3g.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">骰子做成的图像</figcaption></figure><p id="310a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个图像满足了我开始时的所有要求，但是您很难看出新图像是由原始图像制作的。我知道我可以做得更好。</p><p id="200a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我尝试提高分辨率，并根据原始图像的最大饱和度调整饱和度。我没有把每一个7x7像素的正方形变成一个骰子的边，而是把每一个像素变成一个骰子的边。下面是我修改的“convert_dice”方法。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="cc11" class="kb kc hi jx b fi kd ke l kf kg"># Create a version of the image made of dice<br/>def convert_dice(image):</span><span id="7dc3" class="kb kc hi jx b fi kh ke l kf kg"> # Get size<br/> width, height = image.size</span><span id="095b" class="kb kc hi jx b fi kh ke l kf kg"> # Create new Image and a Pixel Map<br/> new = Image.new("RGB", (width*7, height*7), "white")<br/> pixels = new.load()</span><span id="0cca" class="kb kc hi jx b fi kh ke l kf kg"> i = 0<br/> j = 0<br/> maxSaturation = 0<br/> count = 0</span><span id="6275" class="kb kc hi jx b fi kh ke l kf kg"> while i &lt; height:<br/>  while j &lt; width:<br/>   pixel = image.getpixel((i,j))<br/>   if pixel[2] &gt; maxSaturation:<br/>    maxSaturation = pixel[2]<br/>   count += 1<br/>   j+=1<br/>  i+=1</span><span id="6e91" class="kb kc hi jx b fi kh ke l kf kg"> i = 0<br/> j = 0</span><span id="85c4" class="kb kc hi jx b fi kh ke l kf kg"> # Transform to dice<br/> while j &lt; height:<br/>  while i &lt; width:<br/>   # Get saturation<br/>   saturation = 0<br/>   pixel = image.getpixel((i,j))<br/>   saturation += pixel[2]</span><span id="c422" class="kb kc hi jx b fi kh ke l kf kg">   for k in range(7):<br/>    for l in range(7):<br/>     pixels[(i*7)+l, (j*7)+k] = (255,255,255)</span><span id="acce" class="kb kc hi jx b fi kh ke l kf kg">   # Transform to dice<br/>   if saturation &gt; maxSaturation*(5/6):<br/>    pixels[(i*7)+3, (j*7)+3] = (0,0,0)<br/>   elif saturation &gt; maxSaturation*(2/3):<br/>    pixels[(i*7)+1, (j*7)+2] = (0,0,0)<br/>    pixels[(i*7)+5, (j*7)+4] = (0,0,0)<br/>   elif saturation &gt; maxSaturation*(1/2):<br/>    pixels[(i*7)+1, (j*7)+1] = (0,0,0)<br/>    pixels[(i*7)+3, (j*7)+3] = (0,0,0)<br/>    pixels[(i*7)+5, (j*7)+5] = (0,0,0)<br/>   elif saturation &gt; maxSaturation*(1/3):<br/>    pixels[(i*7)+2, (j*7)+2] = (0,0,0)<br/>    pixels[(i*7)+2, (j*7)+4] = (0,0,0)<br/>    pixels[(i*7)+4, (j*7)+2] = (0,0,0)<br/>    pixels[(i*7)+4, (j*7)+4] = (0,0,0)<br/>   elif saturation &gt; maxSaturation*(1/6):<br/>    pixels[(i*7)+1, (j*7)+1] = (0,0,0)<br/>    pixels[(i*7)+5, (j*7)+1] = (0,0,0)<br/>    pixels[(i*7)+3, (j*7)+3] = (0,0,0)<br/>    pixels[(i*7)+1, (j*7)+5] = (0,0,0)<br/>    pixels[(i*7)+5, (j*7)+5] = (0,0,0)<br/>   else:<br/>    pixels[(i*7)+2, (j*7)+1] = (0,0,0)<br/>    pixels[(i*7)+4, (j*7)+1] = (0,0,0)<br/>    pixels[(i*7)+2, (j*7)+3] = (0,0,0)<br/>    pixels[(i*7)+4, (j*7)+3] = (0,0,0)<br/>    pixels[(i*7)+2, (j*7)+5] = (0,0,0)<br/>    pixels[(i*7)+4, (j*7)+5] = (0,0,0)<br/>   i+=1<br/>  i=0<br/>  j+=1</span><span id="35af" class="kb kc hi jx b fi kh ke l kf kg"> # Return new image<br/> return new</span></pre><p id="20a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果如下:</p><figure class="js jt ju jv fd kj er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kr"><img src="../Images/64ece9b741678efad89be6ce44f0a2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1YS-2g2Ro-_TZ_YD2huHQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">由骰子制成的高分辨率图像</figcaption></figure><p id="eb1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我对这个结果非常满意；然而，我也希望能够将图像作为参数传递给脚本，并认为脚本可以使用一些错误处理。下面是我最后的代码。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="32f3" class="kb kc hi jx b fi kd ke l kf kg">from PIL import Image<br/>import sys</span><span id="2024" class="kb kc hi jx b fi kh ke l kf kg"># Create a Grayscale version of the image<br/>def convert_grayscale(image):<br/> # Get size<br/> width, height = image.size</span><span id="690c" class="kb kc hi jx b fi kh ke l kf kg"> # Create new Image and a Pixel Map<br/> new = Image.new("RGB", (width, height), "white")<br/> pixels = new.load()</span><span id="ca52" class="kb kc hi jx b fi kh ke l kf kg"> # Transform to grayscale<br/> for i in range(width):<br/>  for j in range(height):<br/>   # Get Pixel<br/>   pixel = image.getpixel((i,j))</span><span id="24c8" class="kb kc hi jx b fi kh ke l kf kg">   # Get R, G, B values (This are int from 0 to 255)<br/>   red = pixel[0]<br/>   green = pixel[1]<br/>   blue =  pixel[2]</span><span id="2e86" class="kb kc hi jx b fi kh ke l kf kg">   # Transform to grayscale<br/>   gray = (red * 0.299) + (green * 0.587) + (blue * 0.114)</span><span id="a879" class="kb kc hi jx b fi kh ke l kf kg">   # Set Pixel in new image<br/>   pixels[i, j] = (int(gray), int(gray), int(gray))</span><span id="1b7a" class="kb kc hi jx b fi kh ke l kf kg"> # Return new image<br/> return new</span><span id="bef9" class="kb kc hi jx b fi kh ke l kf kg"># Create a version of the image made of dice<br/>def convert_dice(image):</span><span id="405b" class="kb kc hi jx b fi kh ke l kf kg"> # Get size<br/> width, height = image.size</span><span id="3985" class="kb kc hi jx b fi kh ke l kf kg"> # Create new Image and a Pixel Map<br/> new = Image.new("RGB", (width*7, height*7), "white")<br/> pixels = new.load()</span><span id="dca1" class="kb kc hi jx b fi kh ke l kf kg"> i = 0<br/> j = 0<br/> maxSaturation = 0<br/> count = 0</span><span id="ea5d" class="kb kc hi jx b fi kh ke l kf kg"> while i &lt; height:<br/>  while j &lt; width:<br/>   pixel = image.getpixel((i,j))<br/>   if pixel[2] &gt; maxSaturation:<br/>    maxSaturation = pixel[2]<br/>   count += 1<br/>   j+=1<br/>  i+=1</span><span id="ecc9" class="kb kc hi jx b fi kh ke l kf kg"> i = 0<br/> j = 0</span><span id="1115" class="kb kc hi jx b fi kh ke l kf kg"> # Transform to dice<br/> while j &lt; height:<br/>  while i &lt; width:<br/>   # Get saturation<br/>   saturation = 0<br/>   pixel = image.getpixel((i,j))<br/>   saturation += pixel[2]</span><span id="3ea2" class="kb kc hi jx b fi kh ke l kf kg">   for k in range(7):<br/>    for l in range(7):<br/>     pixels[(i*7)+l, (j*7)+k] = (255,255,255)</span><span id="0406" class="kb kc hi jx b fi kh ke l kf kg">   # Transform to dice<br/>   if saturation &gt; maxSaturation*(5/6):<br/>    pixels[(i*7)+3, (j*7)+3] = (0,0,0)<br/>   elif saturation &gt; maxSaturation*(2/3):<br/>    pixels[(i*7)+1, (j*7)+2] = (0,0,0)<br/>    pixels[(i*7)+5, (j*7)+4] = (0,0,0)<br/>   elif saturation &gt; maxSaturation*(1/2):<br/>    pixels[(i*7)+1, (j*7)+1] = (0,0,0)<br/>    pixels[(i*7)+3, (j*7)+3] = (0,0,0)<br/>    pixels[(i*7)+5, (j*7)+5] = (0,0,0)<br/>   elif saturation &gt; maxSaturation*(1/3):<br/>    pixels[(i*7)+2, (j*7)+2] = (0,0,0)<br/>    pixels[(i*7)+2, (j*7)+4] = (0,0,0)<br/>    pixels[(i*7)+4, (j*7)+2] = (0,0,0)<br/>    pixels[(i*7)+4, (j*7)+4] = (0,0,0)<br/>   elif saturation &gt; maxSaturation*(1/6):<br/>    pixels[(i*7)+1, (j*7)+1] = (0,0,0)<br/>    pixels[(i*7)+5, (j*7)+1] = (0,0,0)<br/>    pixels[(i*7)+3, (j*7)+3] = (0,0,0)<br/>    pixels[(i*7)+1, (j*7)+5] = (0,0,0)<br/>    pixels[(i*7)+5, (j*7)+5] = (0,0,0)<br/>   else:<br/>    pixels[(i*7)+2, (j*7)+1] = (0,0,0)<br/>    pixels[(i*7)+4, (j*7)+1] = (0,0,0)<br/>    pixels[(i*7)+2, (j*7)+3] = (0,0,0)<br/>    pixels[(i*7)+4, (j*7)+3] = (0,0,0)<br/>    pixels[(i*7)+2, (j*7)+5] = (0,0,0)<br/>    pixels[(i*7)+4, (j*7)+5] = (0,0,0)<br/>   i+=1<br/>  i=0<br/>  j+=1</span><span id="0a83" class="kb kc hi jx b fi kh ke l kf kg"> # Return new image<br/> return new</span><span id="0319" class="kb kc hi jx b fi kh ke l kf kg">def main():<br/> # process input<br/> input = sys.argv[1].strip()<br/> delimiter = ""</span><span id="e647" class="kb kc hi jx b fi kh ke l kf kg"> if "/" in input:<br/>  delimiter = "/"<br/> elif "\\" in input:<br/>  delimiter = "\\"</span><span id="b62d" class="kb kc hi jx b fi kh ke l kf kg"> input = input.split(delimiter)<br/> file = input[-1]<br/> path = ""</span><span id="1e07" class="kb kc hi jx b fi kh ke l kf kg"> if len(input) != 1:<br/>  path = delimiter</span><span id="debe" class="kb kc hi jx b fi kh ke l kf kg"> for i in range(len(input)-1):<br/>  path += input[i] + delimiter</span><span id="55bb" class="kb kc hi jx b fi kh ke l kf kg"> try:<br/>  # Load Image (JPEG/JPG needs libjpeg to load)<br/>  original = Image.open(path + file)</span><span id="54cb" class="kb kc hi jx b fi kh ke l kf kg"> except FileNotFoundError:<br/>  print(path + file)<br/>  print("File not found. Please make sure your path and file name are correct and try again.")</span><span id="e722" class="kb kc hi jx b fi kh ke l kf kg"> else:<br/>  suffix = "." + file.split(".")[-1]</span><span id="e8f5" class="kb kc hi jx b fi kh ke l kf kg">  # Convert to Grayscale and save<br/>  new = convert_grayscale(original)<br/>  new.save(path + 'gray' + suffix)</span><span id="6618" class="kb kc hi jx b fi kh ke l kf kg">  # Load gray image<br/>  gray = Image.open(path + 'gray' + suffix)</span><span id="59e0" class="kb kc hi jx b fi kh ke l kf kg">  # Convert to dice and save<br/>  new = convert_dice(gray)<br/>  new.save(path + 'dice' + suffix)</span><span id="ca5d" class="kb kc hi jx b fi kh ke l kf kg">if __name__ == "__main__":<br/> main()</span><span id="52cc" class="kb kc hi jx b fi kh ke l kf kg">if __name__ == "__main__":<br/> main()</span></pre><p id="d7e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你有它！如果你想使用这段代码或建议修改，请查看<a class="ae jr" href="https://github.com/shepnathand/2dice" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>！感谢阅读！</p></div></div>    
</body>
</html>