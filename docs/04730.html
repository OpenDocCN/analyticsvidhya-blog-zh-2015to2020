<html>
<head>
<title>Angular Routing: Imperative vs PopState</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度路由:命令式vs PopState</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/angular-routing-imperative-vs-popstate-7d254b495c54?source=collection_archive---------6-----------------------#2020-03-30">https://medium.com/analytics-vidhya/angular-routing-imperative-vs-popstate-7d254b495c54?source=collection_archive---------6-----------------------#2020-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/057009555df216a4a9235cdc7ca77668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gwt2xrje04RpxdGT5n_42Q.jpeg"/></div></div></figure><p id="34e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">页面之间的导航是任何web应用程序的重要组成部分。学习Angular时，你会意识到路由(导航)是Angular的基本概念之一。</p><p id="092f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注</strong>:你用过<a class="ae jo" href="https://www.npmjs.com/package/aop-routing" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">AOP-routing</strong></a><strong class="is hj"/>NPM库吗？它充分利用了本文中解释的概念，并为角度导航系统提供了一些功能，比如装饰路由和在运行时动态修改角度路由表。你也可以在这里阅读关于aop路由<a class="ae jo" rel="noopener" href="/analytics-vidhya/the-aop-routing-library-for-angular-9ada05f1741d">的文章。</a></p><p id="748c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任何使用过Angular的开发人员至少应该对路由的概念以及路由器对象如何在Angular单页应用程序(SPA)中工作有一个较高的理解。</p><p id="72ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们从Angular中的“路由”或“路由器对象”的简单定义开始:</p><p id="a6d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">直接从Angular文档中提取定义—<br/><a class="ae jo" href="https://angular.io/guide/router" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">Angular路由器支持在用户执行应用任务时从一个视图导航到下一个视图</strong> </a></p><p id="da3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除此之外，Angular还支持通过“Router”<br/>对象的公开方法在单页面应用程序(SPA)中进行路由，例如</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="856a" class="jy jz hi ju b fi ka kb l kc kd">router.navigate(['page to navigate to'])<br/></span></pre><p id="98aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将允许您从一个组件导航到另一个组件。路由器对象使用“router outlet”指令作为占位符，在html中呈现组件的视图。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="35e1" class="jy jz hi ju b fi ka kb l kc kd">&lt;router-outlet&gt;&lt;/router-outlet&gt;</span></pre><h2 id="1fe5" class="jy jz hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">简单吧？</h2><p id="2828" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">从表面的角度路由似乎很简单，易于使用。但你知道吗，除了“看起来”之外，角度路由还有更多。</p><p id="fbe0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将触及角度路由的一个领域，一些(如果不是大多数的话)开发人员要么没有意识到，要么忽略了，这有时会导致很多令人头痛的问题！</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="10b5" class="lj jz hi bd ke lk ll lm ki ln lo lp km lq lr ls kp lt lu lv ks lw lx ly kv lz bi translated">命令式vs流行状态</h1><p id="6a9f" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">在角度应用中有两种不同类型的导航。命令式和Popstate导航。理解这两者之间的区别，以及这两种类型的导航是如何在应用程序中防止意外的路由行为或混乱(如下图所示)是非常必要的。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/3c9b34709568472e23dedbae2ce4f1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*GFZwRwolC3Atq9n_YSzx1w.jpeg"/></div></figure><h2 id="9a53" class="jy jz hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">那么这两者的区别是什么呢？</h2><p id="f35d" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated"><strong class="is hj">命令式导航</strong>:是通过使用路由器对象的公开方法触发的任何导航，例如</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9f1a" class="jy jz hi ju b fi ka kb l kc kd">router.navigate() or router.navigateByUrl()</span></pre><p id="62d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述方法通常绑定到html按钮、链接或其他元素，将导航到指定页面，路由器将在浏览器历史记录中记录活动。</p><p id="55a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Popstate导航</strong>:是由浏览器特定动作触发的任何导航，并不是Angular独有的。这是一个标准的浏览器导航。这种导航类型可以通过执行以下操作来触发；</p><ol class=""><li id="ad60" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated">单击浏览器的后退和前进按钮</li><li id="1b61" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">使用<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/history" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> window.history </strong> </a>对象的<strong class="is hj"> go() </strong>和<strong class="is hj"> back() </strong>方法</li><li id="b6cd" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">使用Angular的<a class="ae jo" href="https://angular.io/api/common/Location#forward" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">位置服务</strong> </a>方法如<strong class="is hj">后退()</strong>或<strong class="is hj">前进()</strong></li></ol></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="5826" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我之前提到过，不理解这两者之间的区别会导致混淆。这里有一个例子。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="c35e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个运行在stack-blitz上的简单的angular应用程序。它包含几个带有“下一页”和“上一页”按钮的页面。<br/>要使其正常工作，请务必点击底部的“<strong class="is hj">预览</strong>”选项卡，打开正在运行的应用程序，复制URL并将其粘贴到新的选项卡或窗口中..</p><p id="7a72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尝试以下步骤:</p><ol class=""><li id="26f4" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated">点击每页上的“下一页”按钮，直到进入第3页。</li><li id="3ba8" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">点击第3页的<strong class="is hj">上一页按钮</strong>返回第2页。</li><li id="efa6" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">现在在第2页，再次点击<strong class="is hj">上一页按钮</strong>返回第1页。</li><li id="33ca" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">到目前为止，导航流程一切正常，对吗？。</li><li id="351a" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">再次重新加载应用程序，从头开始(<a class="ae jo" href="https://angular-imperative.stackblitz.io/" rel="noopener ugc nofollow" target="_blank">https://angular-imperative.stackblitz.io/</a>)</li><li id="2158" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">再次执行步骤1和2。</li><li id="d4b7" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">现在在第2页点击<strong class="is hj">浏览器的后退按钮</strong>。</li></ol><p id="ed98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你现在回到了第3页。导航流程已更改。如果你更进一步地使用下一个和上一个按钮以及浏览器的后退和前进按钮，你会注意到导航变得更加混乱。</p><h2 id="c416" class="jy jz hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">为什么会这样？</h2><p id="f384" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">这很简单，注意我使用的上一个按钮的每个方法</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="578c" class="jy jz hi ju b fi ka kb l kc kd">router.navigate()</span></pre><p id="934c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将用户导航到上一页。但是有一个条件！router.navigate()将始终<strong class="is hj">在历史中向前导航！</strong></p><p id="8bc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">router.navigate()将总是向前导航，并在浏览器历史记录中添加一个新条目。因此，即使您有一个后退按钮，并且您正在使用router.navigate()返回到上一页，<strong class="is hj">您也不是在历史</strong>中向后遍历，您实际上正在做的是前进到上一页。用户可能认为他们已经倒退了，但实际上他们已经前进了。</p><h2 id="f67f" class="jy jz hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">那么为什么使用浏览器后退按钮会改变流程呢？</h2><p id="0f31" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">浏览器的后退按钮(与使用router.navigate返回不同)实际上将用户导航到历史上的上一页。因此，如果开发者不采取额外的预防措施，如果用户混合这两种导航，将会给用户带来很多困惑。下面是之前的逐步操作图。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/640b1ab4d8a89b330286a4f600f11aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yD5T5gaulz2IVpqMrVGGlA.png"/></div></div></figure><p id="c47b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在尝试运行下面的应用程序。记得再次点击底部的<strong class="is hj">预览</strong>标签，打开正在运行的应用，复制网址并粘贴到一个新的标签或窗口..</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="a918" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这次为了回到上一页，我使用了位置服务“back”方法，其行为与使用history.back()相同。</p><p id="9176" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再次执行以下操作..</p><ol class=""><li id="4fcf" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated">点击每页上的“下一页”按钮，直到进入第3页。</li><li id="3f49" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">点击第3页的<strong class="is hj">上一页按钮</strong>返回第2页。</li><li id="0136" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">现在在第2页点击<strong class="is hj">浏览器的后退按钮。</strong></li></ol><p id="518a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意这次你被带到了第一页？这是用户所期望的。还要注意一个细微的区别，当你点击每一页上的“上一页”按钮时，浏览器的“前进”按钮被激活。这是因为下面两种方法</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="db4e" class="jy jz hi ju b fi ka kb l kc kd">location.back() or history.back()</span></pre><p id="f32c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用popstate导航，其行为就像用户单击了浏览器的后退按钮一样。我强烈建议在导航用户返回到上一页时使用上述方法，而不是router.navigate()。因为这将使命令式导航和popstate导航同步。</p><h2 id="f39d" class="jy jz hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">但是等等！</h2><p id="4d62" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">使用location.back()或history.back()时需要注意一些事情</p><ol class=""><li id="6ca7" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated">因为这两种方法都启用了前进按钮，所以用户可以单击前进按钮返回(前进)到他们来自的页面。这意味着，如果页面B要求在点击页面A的下一步按钮时执行一个逻辑，那么当用户点击前进浏览器按钮转到页面B时，该逻辑将不会被执行。<br/>对此的一个解决方案是，不从页面A的下一步按钮执行页面B所依赖的任何逻辑。而是在页面B的<a class="ae jo" href="https://angular.io/api/core/OnInit" rel="noopener ugc nofollow" target="_blank"> ngOnInit </a>上执行该逻辑，或者使用<a class="ae jo" href="https://angular.io/api/router/Resolve" rel="noopener ugc nofollow" target="_blank">解析器</a>。</li><li id="e3bb" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">如果您正在订阅路由器事件，并且如果您将对象结果显示到控制台，您会注意到对于location.back()和history.back()，路由对象navigationTrigger属性将是<strong class="is hj"> popstate </strong>。(您可以通过在运行上一节中的“impressive-pop state”应用程序时打开开发人员工具来验证这一点。</li></ol></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="7225" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的阅读。我希望您现在已经了解了命令式和popstate之间的导航。</p><p id="ca28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢这篇文章，一定要点击拍手按钮，也检查我下面的其他文章！</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><ul class=""><li id="28cc" class="mb mc hi is b it iu ix iy jb md jf me jj mf jn ms mh mi mj bi translated"><a class="ae jo" rel="noopener" href="/p/b324d20cc277"> <strong class="is hj">地图vs WeakMap </strong> </a></li><li id="f68b" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn ms mh mi mj bi translated"><a class="ae jo" rel="noopener" href="/analytics-vidhya/the-aop-routing-library-for-angular-9ada05f1741d"><strong class="is hj"/>Aop-路由库为角状</a></li><li id="0d92" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn ms mh mi mj bi translated"><a class="ae jo" rel="noopener" href="/javascript-in-plain-english/dynamically-add-and-remove-canactivate-route-guards-in-angular-e7820ab4e061"> <strong class="is hj">动态添加和移除角形</strong> </a>中的可激活守卫</li><li id="7d6f" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn ms mh mi mj bi translated"><a class="ae jo" href="https://ericsarpong.medium.com/asynchronous-programming-in-a-nutshell-theory-d5fd07cf3b22" rel="noopener"> <strong class="is hj">简单地说异步编程(理论)</strong> </a></li><li id="b040" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn ms mh mi mj bi translated"><a class="ae jo" rel="noopener" href="/@ericsarpong/what-is-a-typescript-tuple-814a016f61fd"> <strong class="is hj">什么是类型脚本元组</strong> </a></li><li id="05b5" class="mb mc hi is b it mk ix ml jb mm jf mn jj mo jn ms mh mi mj bi translated"><a class="ae jo" rel="noopener" href="/@ericsarpong/deep-dive-into-javascript-map-object-24c012e0b3fe"> <strong class="is hj">深入探究Javascript图</strong> </a></li></ul></div></div>    
</body>
</html>