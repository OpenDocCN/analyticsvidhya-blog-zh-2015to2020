<html>
<head>
<title>Weird, funny and tricky Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">怪异、有趣和狡猾的蟒蛇</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/weird-funny-and-tricky-python-b3fbe12df3b6?source=collection_archive---------9-----------------------#2020-04-26">https://medium.com/analytics-vidhya/weird-funny-and-tricky-python-b3fbe12df3b6?source=collection_archive---------9-----------------------#2020-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4f4a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">你应该知道的关于python的鲜为人知的事实列表</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6309de5273a24676eaf1ac0f1f812963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dRIUKI2Sq8A0pJHx"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="fca1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">4年前，我第一次在我的机器学习项目中使用Python，从那时起，我就爱上了它简单的语法和广泛的应用。这些年来，它已经成为我任何MVP或小项目的首选语言。随着python 3的出现，它逐渐成为继C++和Java之后最流行的竞争性编程语言之一。以下是让python从其他语言中脱颖而出的几个特性:</p><ol class=""><li id="3f24" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated"><strong class="jq hj">动态类型化</strong>:你不需要事先提到每个变量的数据类型和大小。这一特性使开发人员能够集中精力解决实际问题，而不是被众多的数据类型搞得晕头转向。</li><li id="bfba" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><strong class="jq hj">动态列表</strong> : Python列表是一种多用途的数据结构。你可以用它们作为数组，堆栈。以及排队。最好的部分是你不必用长度来初始化它们，一个列表可以有混合的数据类型。</li><li id="7000" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><strong class="jq hj">强大的字符串</strong>:在python中，可以将字符串作为字符列表来访问，对字符串进行所有的列表操作(除了编辑索引)。你可以用简单的语法将它们反转、分割和添加。其他语言不提供这种自由的字符串。</li><li id="1ddc" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="https://docs.python.org/2/library/collections.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">集合</strong> </a> <strong class="jq hj">模块</strong> : Python有<code class="du ky kz la lb b">collections</code>模块，有很多数据结构，性能更好，应用更广。驻留在这个包中的一些数据结构有:<code class="du ky kz la lb b"><a class="ae jn" href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="noopener ugc nofollow" target="_blank">Counter</a></code> <strong class="jq hj">、</strong> <code class="du ky kz la lb b"><a class="ae jn" href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="noopener ugc nofollow" target="_blank">defaultdict</a></code> <strong class="jq hj"> </strong>和<strong class="jq hj"> </strong> <code class="du ky kz la lb b"><a class="ae jn" href="https://docs.python.org/2/library/collections.html#collections.deque" rel="noopener ugc nofollow" target="_blank">deque</a></code>。</li><li id="4aba" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="https://www.geeksforgeeks.org/comprehensions-in-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">列表和字典理解</strong> </a>:让您能够在一行代码中完成复杂的基于条件的操作，如连接、交集和过滤，这通常比python中的普通for或while循环更快。</li></ol><p id="52f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果没有这些特性，python就不会像现在这样有趣和受欢迎。</p><h1 id="c4be" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">怪异而令人困惑的python</h1><p id="8813" class="pw-post-body-paragraph jo jp hi jq b jr lu ij jt ju lv im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">Python并不全是铃铛和叮当声，由于它的动态特性，您经常会陷入不知道自己做错了什么的境地。下面是我在python中遇到的一些令人困惑和奇怪的例子。</p><h2 id="a3ee" class="lz ld hi bd le ma mb mc li md me mf lm jx mg mh lo kb mi mj lq kf mk ml ls mm bi translated">1.按值调用或按引用调用</h2><p id="8b7b" class="pw-post-body-paragraph jo jp hi jq b jr lu ij jt ju lv im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">这绝对是python中最容易出错的地方，尤其是当你来自Javascript或JAVA背景时。假设你正在以矩阵的形式遍历(DFS或BFS)一个图，为了跟踪访问过的节点，你用下面提到的第一种方法初始化了一个包含所有<code class="du ky kz la lb b">False</code>的矩阵。</p><pre class="iy iz ja jb fd mn lb mo mp aw mq bi"><span id="3989" class="lz ld hi lb b fi mr ms l mt mu">In [1]: visited1 = [[False]*4]*4</span><span id="d38f" class="lz ld hi lb b fi mv ms l mt mu">In [2]: visited1<br/>Out[2]:<br/>[[False, False, False, False],<br/> [False, False, False, False],<br/> [False, False, False, False],<br/> [False, False, False, False]]</span><span id="e879" class="lz ld hi lb b fi mv ms l mt mu">In [4]: visited2 = [[False for i in range(4)]for j in range(4)]</span><span id="e0a8" class="lz ld hi lb b fi mv ms l mt mu">In [5]: visited2<br/>Out[5]:<br/>[[False, False, False, False],<br/> [False, False, False, False],<br/> [False, False, False, False],<br/> [False, False, False, False]]</span></pre><p id="a98d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如你所见，<code class="du ky kz la lb b">visited1</code>和<code class="du ky kz la lb b">visited2</code>乍一看完全一样，但有很大的不同。当我们以同样的方式修改它们时，它们会产生不同的输出。</p><pre class="iy iz ja jb fd mn lb mo mp aw mq bi"><span id="399b" class="lz ld hi lb b fi mr ms l mt mu">In [6]: visited1[2][2]=True           # set (2,2) cell to True</span><span id="decf" class="lz ld hi lb b fi mv ms l mt mu">In [7]: visited2[2][2]=True</span><span id="a65e" class="lz ld hi lb b fi mv ms l mt mu">In [8]: visited1<br/>Out[8]:<br/>[[False, False, True, False],<br/> [False, False, True, False],<br/> [False, False, True, False],<br/> [False, False, True, False]]</span><span id="53e7" class="lz ld hi lb b fi mv ms l mt mu">In [9]: visited2<br/>Out[9]:<br/>[[False, False, False, False],<br/> [False, False, False, False],<br/> [False, False, True, False],<br/> [False, False, False, False]]</span></pre><p id="ffdc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如你所见，虽然<code class="du ky kz la lb b">visited2</code>提供了我们想要的输出，但<code class="du ky kz la lb b">visited1</code>已经完成了所有第3列<code class="du ky kz la lb b">True</code>。为什么会这样？🤔嗯，<code class="du ky kz la lb b">visited1</code>是通过引用将同一行乘以4次创建的。虽然看起来我们只改变了第三行，但是所有其他行都引用了同一行。</p><p id="0a31" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Python有一些可变(可以更改或编辑)和不可变(不能直接更改或修改)的数据类型。我们举个例子更好理解。</p><pre class="iy iz ja jb fd mn lb mo mp aw mq bi"><span id="ebfb" class="lz ld hi lb b fi mr ms l mt mu">In [51]: a = 2              # a : int =&gt; an immutable data type</span><span id="3317" class="lz ld hi lb b fi mv ms l mt mu">In [52]: def add_one(n):    # function take int param &amp; add 1 to it<br/>    ...:     n=n+1<br/>In [54]: add_one(a)<br/>In [55]: a<br/>Out[55]: 2                  # a is still 2. No change</span><span id="fb91" class="lz ld hi lb b fi mv ms l mt mu">In [56]: l = [1,3,4]        # list -&gt; mutable data types<br/>In [58]: def add_item(a):   # function to add 5 in list supplied<br/>    ...:     a.append(5)<br/>In [59]: add_item(l)        # pass l list to function<br/>In [60]: l<br/>Out[60]: [1, 3, 4, 5]       # 5 is added to list </span></pre><p id="eb14" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mw"> int、strings、float和tuple </em>都是不可变的数据类型，因此通过值传递给函数。鉴于<em class="mw"> dict、list和set </em>是可变数据类型，因此通过引用传递给函数。通过在函数之前和内部打印对象id，您可以自己看到它。</p><pre class="iy iz ja jb fd mn lb mo mp aw mq bi"><span id="f033" class="lz ld hi lb b fi mr ms l mt mu">In [64]: id(l)<br/>Out[64]: 4367146352<br/>In [61]: def add_item(a):<br/>    ...:     a.append(a)<br/>    ...:     print (id(a))      # print memory address of object<br/>    ...:</span><span id="8495" class="lz ld hi lb b fi mv ms l mt mu">In [62]: add_item(l)<br/>4367146352                       # same object is used/returned </span><span id="6b8c" class="lz ld hi lb b fi mv ms l mt mu">In [65]: id(a)<br/>Out[65]: 4312653616</span><span id="8c99" class="lz ld hi lb b fi mv ms l mt mu">In [68]: def add_one(n):<br/>    ...:     print (id(n))<br/>    ...:     n=n+1<br/>    ...:     print (id(n))<br/>    ...:</span><span id="b296" class="lz ld hi lb b fi mv ms l mt mu">In [69]: add_one(a)<br/>4312653616               # Object ID before adding 1 <br/>4312653648               # Object ID after adding 1 -&gt; a new object</span></pre><p id="b4c6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于可变性，在递归函数中显式使用列表和字典来缓存中间结果(例如DP)以加快计算速度。</p><h2 id="e657" class="lz ld hi bd le ma mb mc li md me mf lm jx mg mh lo kb mi mj lq kf mk ml ls mm bi translated">2.以不同的方式面向对象</h2><p id="b7b0" class="pw-post-body-paragraph jo jp hi jq b jr lu ij jt ju lv im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">虽然Python支持面向对象编程及其特性，如继承、封装和多态，但它们与JAVA并不十分相似，也不像JAVA那样严格实现。例如，可以动态地将属性添加到python对象中，但是在JAVA中不可能做到这一点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/ec6786d50b8502ae8df54d49a59ebdb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlRgW9uy_EQFAYRx20_TDw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">动态属性的JAVA和python比较</figcaption></figure><p id="68c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尝试动态添加属性时，JAVA抛出错误<code class="du ky kz la lb b">cannot find symbol</code>。但是python代码运行时没有错误并且修改对象。python类的这种行为有时会在生产中产生难以调试的错误。所以最好小心这个。</p><p id="7d53" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">虽然python支持封装，但是方法却完全不同。与使用<code class="du ky kz la lb b">private</code>、<code class="du ky kz la lb b">protected</code>和<code class="du ky kz la lb b">public</code>关键字的JAVA/C++相反，Python早期的开发者决定只支持带有双下划线前缀的私有属性(例如__name)。很奇怪，对吧！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/917416f336864bd59c2c910f17d606f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBAew9ecQoeTiFUYlNVeMA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Python类及其奇怪的封装</figcaption></figure><p id="e6a8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，您可以只使用类方法来访问<code class="du ky kz la lb b">__version</code>属性，这是一种解脱，尤其是在担心数据隐私的情况下。但是当你在私有变量后添加一个下划线时事情变得更奇怪了，现在你可以通过类对象直接访问它们，但是属性名变成了<code class="du ky kz la lb b">_CLASSNAME__attribute_</code>。</p><h2 id="15d9" class="lz ld hi bd le ma mb mc li md me mf lm jx mg mh lo kb mi mj lq kf mk ml ls mm bi translated">3.应该用'是'还是' == '呢？</h2><p id="4bf7" class="pw-post-body-paragraph jo jp hi jq b jr lu ij jt ju lv im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">Python语法非常容易编写，它与英语非常相似，以至于您可以使用单词<code class="du ky kz la lb b">is</code>和<code class="du ky kz la lb b">not</code>进行等式检查。但是，在此之前，请阅读这篇技巧，避免几个小时的调试。</p><p id="8c2f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Python以两种方式处理整数等式。从numbers [-5，256]开始，整数是基本的int数据类型。超出此范围，它们被视为<a class="ae jn" href="https://docs.python.org/3/c-api/long.html" rel="noopener ugc nofollow" target="_blank">普通整数对象</a>。让我们在控制台上摆弄它们，找出答案。</p><pre class="iy iz ja jb fd mn lb mo mp aw mq bi"><span id="fee7" class="lz ld hi lb b fi mr ms l mt mu">In [89]: p = 256<br/>In [90]: q = 256<br/>In [91]: p is q<br/>Out[91]: True              # -5 &lt;= p,q &lt;=256</span><span id="e332" class="lz ld hi lb b fi mv ms l mt mu">In [113]: p=-5<br/>In [114]: q=-5<br/>In [115]: p is q<br/>Out[115]: True </span><span id="3102" class="lz ld hi lb b fi mv ms l mt mu">In [116]: p = 257<br/>In [117]: q = 257</span><span id="f210" class="lz ld hi lb b fi mv ms l mt mu">In [118]: id(p)            <br/>Out[118]: 4389255888      <br/>In [119]: id(q)<br/>Out[119]: 4378917296    # p and q have different address &amp; reference</span><span id="66e3" class="lz ld hi lb b fi mv ms l mt mu">In [120]: p is q<br/>Out[120]: False</span><span id="bbf0" class="lz ld hi lb b fi mv ms l mt mu">In [121]: p==q         # if you do p==q is it True         <br/>Out[121]: True</span></pre><p id="8319" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个故事的寓意是:当有疑问的时候，用“==”来保险起见。它还与其他编程语言齐头并进。</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><h1 id="36cf" class="lc ld hi bd le lf ng lh li lj nh ll lm io ni ip lo ir nj is lq iu nk iv ls lt bi translated">关于python鲜为人知的有趣事实</h1><ol class=""><li id="131d" class="kk kl hi jq b jr lu ju lv jx nl kb nm kf nn kj kp kq kr ks bi translated"><em class="mw">python的禅:</em>python导入中有一个<code class="du ky kz la lb b">this</code>模块，可以向你展示1999年<a class="ae jn" href="https://en.wikipedia.org/wiki/Tim_Peters_(software_engineer)" rel="noopener ugc nofollow" target="_blank"> Tim Peters </a>给出的python编程语言的19+1(等待)指导原则。</li></ol><pre class="iy iz ja jb fd mn lb mo mp aw mq bi"><span id="4ae8" class="lz ld hi lb b fi mr ms l mt mu">In [86]: import this                       # import 'this' module<br/>The Zen of Python, by Tim Peters</span><span id="5510" class="lz ld hi lb b fi mv ms l mt mu">Beautiful is better than ugly.<br/>Explicit is better than implicit.<br/>Simple is better than complex.<br/>Complex is better than complicated.<br/>Flat is better than nested.<br/>Sparse is better than dense.<br/>Readability counts.<br/>Special cases aren't special enough to break the rules.<br/>Although practicality beats purity.<br/>Errors should never pass silently.<br/>Unless explicitly silenced.<br/>In the face of ambiguity, refuse the temptation to guess.<br/>There should be one-- and preferably only one --obvious way to do it.<br/>Although that way may not be obvious at first unless you're Dutch.<br/>Now is better than never.<br/>Although never is often better than *right* now.<br/>If the implementation is hard to explain, it's a bad idea.<br/>If the implementation is easy to explain, it may be a good idea.<br/>Namespaces are one honking great idea -- let's do more of those!</span></pre><p id="ff50" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">2.<em class="mw"> Python想要飞:</em> Python内置了<code class="du ky kz la lb b">antigravity</code>模块导入，会带你去漫画网站<a class="ae jn" href="https://xkcd.com/353/" rel="noopener ugc nofollow" target="_blank">https://xkcd.com/353/</a>。在python控制台输入<code class="du ky kz la lb b">import antigravity</code>就可以自己看了。Python就是这么简单。😄</p><p id="5e2c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">3.<em class="mw">散列它，直到你成功:</em><code class="du ky kz la lb b">float('-inf')</code>的散列将产生-314159(pi)，而在python 2中，相同的散列产生-271828 (epsilon)。python 2.7的值是-271828，python 3的值是-314159，这看起来像是巧合吗？😆不尽然！！</p><pre class="iy iz ja jb fd mn lb mo mp aw mq bi"><span id="2713" class="lz ld hi lb b fi mr ms l mt mu">#python2<br/>&gt;&gt;&gt; hash(float('-inf'))<br/>-271828</span><span id="2df1" class="lz ld hi lb b fi mv ms l mt mu">#python3<br/>In [123]: hash(float('-inf'))<br/>Out[123]: -314159</span></pre></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><h1 id="67e2" class="lc ld hi bd le lf ng lh li lj nh ll lm io ni ip lo ir nj is lq iu nk iv ls lt bi translated"><strong class="ak">python数据结构技巧</strong></h1><p id="5500" class="pw-post-body-paragraph jo jp hi jq b jr lu ij jt ju lv im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">有时候，对于相同的整体逻辑和算法，我发现我的python代码比其他代码慢。在对多个编码问题进行更深入的分析时，我发现了开发人员(包括我)会犯的这三个错误，以及避免它们的一些方法。</p><h2 id="2360" class="lz ld hi bd le ma mb mc li md me mf lm jx mg mh lo kb mi mj lq kf mk ml ls mm bi translated">技巧1:探索更多的数据结构和模块</h2><p id="393e" class="pw-post-body-paragraph jo jp hi jq b jr lu ij jt ju lv im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">在python中，列表数据结构无处不在且易于使用，以至于人们没有探索其他更好的数据类型，如<code class="du ky kz la lb b">deque</code>、<code class="du ky kz la lb b">Counter</code>等。虽然你可以使用list作为一个队列，但这不是它的设计目的。我昨天才知道<code class="du ky kz la lb b">bisect</code>模块，它维护了一个排序列表，所以开发者不需要做while-loop和寻找位置来低效地插入。</p><pre class="iy iz ja jb fd mn lb mo mp aw mq bi"><span id="5f63" class="lz ld hi lb b fi mr ms l mt mu">&gt;&gt;&gt; list.pop(0)      # Time complexity O(n) <br/>&gt;&gt;&gt; deque.popleft()   # Time complexity O(1)</span><span id="c913" class="lz ld hi lb b fi mv ms l mt mu">&gt;&gt;&gt; a = [1,3,6,9]       # sorted list <br/>&gt;&gt;&gt; b = 5               # find position where 5 should be inserted<br/>&gt;&gt;&gt; i=0<br/>&gt;&gt;&gt; while i&lt;len(a) and a[i]&lt;b:<br/>         i+=1<br/>&gt;&gt;&gt; i<br/>2<br/>&gt;&gt;&gt; i = bisect.bisect_left(a,b)      #return 2 in i. Better approach</span></pre><p id="9911" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">类似地，<code class="du ky kz la lb b">list</code>在查找唯一的元素集时不如<code class="du ky kz la lb b">set</code>高效，因为<code class="du ky kz la lb b">set</code>散列了密钥。</p><pre class="iy iz ja jb fd mn lb mo mp aw mq bi"><span id="5674" class="lz ld hi lb b fi mr ms l mt mu">&gt;&gt;&gt; if item in list:       # order preserved but ~ O(n)<br/>       doSomething()<br/>&gt;&gt;&gt; if item in set:        # order is not preserved but ~ O(1)<br/>       doSomethingElse()</span></pre><p id="c09d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">关于python中不同数据结构的时间复杂性的更多细节，请点击<a class="ae jn" href="https://wiki.python.org/moin/TimeComplexity" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><h2 id="51f8" class="lz ld hi bd le ma mb mc li md me mf lm jx mg mh lo kb mi mj lq kf mk ml ls mm bi translated">技巧2:最大堆实现</h2><p id="583d" class="pw-post-body-paragraph jo jp hi jq b jr lu ij jt ju lv im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">虽然python提供了开箱即用的<code class="du ky kz la lb b">heapq</code>模块来使用堆。但是它公开的方法<code class="du ky kz la lb b">heappush</code>、<code class="du ky kz la lb b">heappop</code>和<code class="du ky kz la lb b">heapify</code>只支持最小堆。max-heap对应的方法有<code class="du ky kz la lb b">_heappop_max</code>，<code class="du ky kz la lb b">_heapify_max</code>是隐藏的，甚至<a class="ae jn" href="https://docs.python.org/3/library/heapq.html" rel="noopener ugc nofollow" target="_blank">都没有记载</a>。</p><h2 id="86d1" class="lz ld hi bd le ma mb mc li md me mf lm jx mg mh lo kb mi mj lq kf mk ml ls mm bi translated">技巧3:小心设置</h2><p id="14c0" class="pw-post-body-paragraph jo jp hi jq b jr lu ij jt ju lv im jw jx lw jz ka kb lx kd ke kf ly kh ki kj hb bi translated">通常情况下，需要在一个<code class="du ky kz la lb b">list</code>中拥有独特的元素。最简单也是最常见的方法是将其投射到<code class="du ky kz la lb b">set</code>，然后再将其投射回<code class="du ky kz la lb b">list</code>。如果元素的顺序不重要，这种方法也可以。但是如果顺序很重要，你将很难跟踪代码中的错误。</p><pre class="iy iz ja jb fd mn lb mo mp aw mq bi"><span id="c8a3" class="lz ld hi lb b fi mr ms l mt mu">In [129]: set([2,2,4,200,100,5])     # list with duplicates<br/>Out[129]: {2, 4, 5, 100, 200}.       # unique items order changes</span><span id="24c1" class="lz ld hi lb b fi mv ms l mt mu">In [130]: list(set([2,2,4,200,100,5]))   # cast back to list <br/>Out[130]: [2, 100, 4, 5, 200]        # order of items change further</span></pre><p id="69d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果元素的顺序和快速O(1)查找一样重要，可以使用<code class="du ky kz la lb b">OrderedDict</code>代替set。</p><pre class="iy iz ja jb fd mn lb mo mp aw mq bi"><span id="2437" class="lz ld hi lb b fi mr ms l mt mu">In [133]: collections.OrderedDict.fromkeys([2,2,4,200,100,5])<br/>Out[133]: OrderedDict([(2, None), (4, None), (200, None), (100, None), (5, None)])         # order is same as input list</span><span id="5966" class="lz ld hi lb b fi mv ms l mt mu">In [134]: list(collections.OrderedDict.fromkeys([2,2,4,200,100,5]).keys())<br/>Out[134]: [2, 4, 200, 100, 5]     #order of output is same </span></pre><p id="398d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">希望这有助于巩固你对python的理解，并让你离编写更多的python代码更近一步。额外的提示，你可以把它们带到与其他python开发者的对话中，看起来更聪明、更酷。😆</p><p id="7d9a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请在下面的评论中告诉我，有多少你已经知道了。此外，我希望听到更多这样疯狂的python事实。别忘了点击下面的拍手图标。</p></div></div>    
</body>
</html>