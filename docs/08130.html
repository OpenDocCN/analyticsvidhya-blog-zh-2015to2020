<html>
<head>
<title>5 amazing things about pandas!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于熊猫的5件令人惊奇的事情！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/5-amazing-things-about-pandas-ed8a6decdfb2?source=collection_archive---------19-----------------------#2020-07-18">https://medium.com/analytics-vidhya/5-amazing-things-about-pandas-ed8a6decdfb2?source=collection_archive---------19-----------------------#2020-07-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/67a3c4103a0690f88b0bd2127a641984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sN2N9VNsdF5iliEb"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">锡德·巴拉钱德朗在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7bc6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要！不是这个。我说的是改变了我们处理数据方式的python库，“熊猫”。随着python越来越受欢迎和适应，pandas成为处理数据的高效便捷的工具。在过去的十年中，这个开源工具已经有了很大的发展，为开发人员提供了更好的代码直观和用户友好的环境。虽然pandas提供的每个功能本身都是独一无二的，但还有一些鲜为人知的已实现的功能经常会派上用场。您可能不会每次都使用这些功能，但它们可能会节省您的精力和时间来解决一些罕见项目中的任何关键任务。事不宜迟，让我们直接跳到他们身上。</p><h1 id="d82c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 1。枢轴</strong></h1><p id="766c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">“pivot”功能帮助用户重新调整数据帧的形状，并使结果数据帧聚焦在特定的列上。因此，目标列成为我们的轴，导航数据变得更加简单。让我们通过一个例子来理解这一点，假设我们有以下数据</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/4d870246468f79a7cfc54eda0e1f5bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*LKFSdNJ5IS35nnhPo5cpLg.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">学生-科目-分数-成绩</figcaption></figure><p id="bc76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们在上面的数据中看到的，有5个不同的学生，他们在3个科目中的分数记录在上面。虽然数据是结构化的，但在其中导航是乏味的。使用pivot函数，我们可以将这些数据转换成一个以学生为中心的数据框架，使读取数据变得非常容易。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2915" class="lg ju hi lc b fi lh li l lj lk">data.pivot(index='Student_name',columns='Subject',values='Marks')</span></pre><p id="e953" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">pivot函数有3个值</p><ul class=""><li id="795a" class="ll lm hi ix b iy iz jc jd jg ln jk lo jo lp js lq lr ls lt bi translated">index:目标列，dataframe在其基础上重新成形。该列中的每个唯一值将成为结果数据帧的轴。</li><li id="dbb4" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">columns:将作为新数据框架标题的列。</li><li id="a432" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">值:将填充数据框的索引和列各自的结果数据，如果没有数据，结果将为“NaN”。</li></ul><p id="0d4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，对输入数据进行透视操作的结果将如下所示:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/d77855b1b489d52ca39ff94477ede2fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*R4x2DnNOoRDq2VmLEg2e0w.png"/></div></figure><p id="8ad9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以看到结果是更容易导航和理解。结果数据帧的轴是来自指定“索引”的唯一值，而指定“列”中列出的唯一值成为标题。“值”描述索引和列之间的关系。您还可以像这样向结果数据帧添加多个值</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="ec02" class="lg ju hi lc b fi lh li l lj lk">data.pivot(index='Student_name',columns='Subject',values=['Marks','Grade'])</span></pre><p id="f989" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出数据帧将包含以如下值指定的每一列的部分</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/306cabe57f1282220652814e85e332d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*j7qNyDDnvW46lk5QWXmwzQ.png"/></div></figure><p id="4efc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要注意的一点是“pivot <em class="mb">不支持聚合</em>，因此多个值将导致多个索引”。</p><h1 id="45e8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 2。数据透视表</strong></h1><p id="5af8" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">“数据透视表”功能可以理解为“数据透视表”功能的扩展，但它不仅仅是重塑数据框架。使用<em class="mb"> pivot_table </em>我们可以以更有意义的方式汇总数据。不像pivot函数是dataframe类的一个方法，pivot table是pandas本身的一个方法。数据透视表用于执行类似于数据透视的任务，并具有聚合数据的额外好处。让我们用上面的例子来理解</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="a560" class="lg ju hi lc b fi lh li l lj lk">pd.pivot_table(data,values='Marks',index='Subject',columns='Grade',<br/>aggfunc='sum')</span></pre><p id="4ff1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参数值、索引和列与pivot函数相同，“data”是保存数据帧的对象，“aggfunc”用于指定要实现的数据聚合方法。我们可以使用的基本汇总方法有“总和”、“平均值”、“中位数”等。输出数据帧将如下所示</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/e6b9e918643a5b53272a49e1f84c7738.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*-KvdymvbJctsZaEuME45HQ.png"/></div></figure><p id="6f3d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该数据框架将学生在各科目相应年级类别中的所有分数相加。因此，我们可以通过使用<em class="mb"> pivot_table </em>和<em class="mb">聚合</em>函数来生成对数据的进一步洞察。与需要所有3个参数(索引、列和值)的<em class="mb"> pivot </em>函数不同，<em class="mb"> pivot_table </em>可以在没有值和列的情况下使用</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="8ae1" class="lg ju hi lc b fi lh li l lj lk">pd.pivot_table(data,values='Marks',index='Subject',aggfunc='sum')<br/>(or)<br/>pd.pivot_table(data,index='Subject',aggfunc='sum')</span></pre><p id="530f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">两种情况下的输出是一样的，就像这样</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es md"><img src="../Images/3c7d77f9bbf1f980c40e1f511d1bee44.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*U1RFOU_sxj0kVB44X0xpbA.png"/></div></figure><p id="16ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据框汇总了所有科目的所有分数</p><p id="9d13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，与<em class="mb"> pivot不同的是，</em>我们可以将<em class="mb"> pivot_table </em>与多个索引一起使用。数据透视表中的级别将存储在结果数据帧的索引和列上的多索引对象(分层索引)中。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="1d1b" class="lg ju hi lc b fi lh li l lj lk">pd.pivot_table(data, values='Marks',<br/>index=['Subject','Student_name'], aggfunc='sum')</span></pre><p id="07b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多索引输出将是</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es me"><img src="../Images/0895d13685b239949b146bc6534bd0ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*rEEBaKp-TVw7hiZyce9ngQ.png"/></div></figure><p id="b628" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，<em class="mb"> pivot_table </em>还提供了像“dropna”和“fill_value”这样值得尝试的特性。</p><h1 id="7da4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 3。数据帧上的算术运算</strong></h1><p id="94ae" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">正如不言自明的标题所暗示的，我们经常需要对整个数据帧或某些指定的列执行各种算术运算。与循环和迭代每个元素不同，直接对目标列实现算术运算使任务变得容易并节省了大量时间。让我们考虑同一个学生分数的例子，如果你要在数据框中添加另一列“百分比”,该数据框包含在特定科目中获得的百分比，那么可以简单地这样做</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="c34d" class="lg ju hi lc b fi lh li l lj lk">data['Percentage'] = data['Marks']/100</span></pre><p id="4a66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将向我们的dataframe添加一个新的列百分比，结果如下所示:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/89fcf40fead68b0aa6925544512e5e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*k8zlX7OX5knnuU9wapAH1w.png"/></div></figure><p id="15e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然这种算术运算可以直接使用普通的数学符号来完成，但pandas dataframe有以下内置方法来完成同样的操作</p><ul class=""><li id="0cd0" class="ll lm hi ix b iy iz jc jd jg ln jk lo jo lp js lq lr ls lt bi translated">dataframe.add()</li><li id="ecf4" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">dataframe.sub()</li><li id="2922" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">dataframe.mul()</li><li id="74da" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">dataframe.div()</li></ul><p id="b4e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么数学运算符和内置方法有什么区别呢？<em class="mb">内置方法有助于用“fill_value”替换丢失的数据。</em></p><p id="0e3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这两种方法都使我们能够在两个数据帧、数据帧和序列、数据帧和定标器之间执行算术运算。熊猫也提供了更多这样的算术和比较运算符。</p><h1 id="82c2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 4。应用</strong></h1><p id="ff53" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">“应用”是一种dataframe方法，允许用户在任何行或列上实现任何预定义或用户定义的函数。这提供了与Microsoft Excel相同的功能，用户可以定义一个<em class="mb">公式</em>，该公式将可用的<em class="mb">数据作为输入</em>，并生成<em class="mb">结果</em>来填充指定的列。这个功能非常节省时间。让我们用同一个例子来理解这一点。我们将通过使用学生的成绩执行条件格式化来生成一个名为“Notes”的新列。为此，我们将定义自己的函数</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="0d38" class="lg ju hi lc b fi lh li l lj lk">def notes(x):<br/>   if str(x) == 'C':<br/>       return 'Poor result'<br/>   elif str(x) == 'B':<br/>       return 'Good'<br/>   elif str(x) == 'A':<br/>       return 'Excellent'</span><span id="09c6" class="lg ju hi lc b fi mg li l lj lk">data['Notes'] = data['Grade'].apply(notes)</span></pre><p id="ee06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">生成的数据帧将有一个额外的“注释”列，如下所示</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/79a4bb6fa1d352d8287373715f87085b.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*7IpBmqdkIOXN5MU-36UBpw.png"/></div></figure><p id="b6a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们也可以把“应用”和“λ”结合起来。如果你没有听说过(或者忘记了)什么是<em class="mb">‘lambda’</em>，lambda是一个用来定义匿名函数ie的关键字；python中不带任何名称的函数。Lambda是一个单行函数，可以接受任意数量的参数，但只能有一个表达式。它的行为与我们使用关键字<em class="mb"> def </em>定义的函数完全一样。Lambda通常用于函数很小并且可能不会在代码中再次使用的情况。我们可以在apply中使用lambda执行与上面相同的任务</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="e063" class="lg ju hi lc b fi lh li l lj lk">data['Notes'] = data['Grade'].apply(lambda x: <br/>'Poor result' if x == 'C' else ('Good' if x == 'B' else'Excellent'))</span></pre><p id="eaa0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mb">注意:在if lambda情况下实现“elif”的唯一方法是使用嵌套的if-else条件</em></p><h1 id="ae2c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 5。是唯一的</strong></h1><p id="9163" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这可能是你们很多人都熟悉的东西。“is_unique”方法将列名作为输入，如果列中的所有值都是唯一的，则返回<strong class="ix hj"> True </strong>，否则返回<strong class="ix hj"> False </strong>。这是一个非常简单而有用的函数，通常在处理ETL过程或数据建模时，您需要识别唯一的列。根据手头的任务，这些列可以被删除，也可以被计入。<em class="mb">是唯一的</em>函数适用于熊猫的系列数据类型。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="c9bf" class="lg ju hi lc b fi lh li l lj lk">test = pd.Series(data=[1,2,3,4,5,6,7])<br/>test.is_unique</span><span id="9157" class="lg ju hi lc b fi mg li l lj lk">#output<br/>#True</span></pre><p id="a70c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以从数据帧中选取任何特定的列，并测试它是否是唯一的。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="5233" class="lg ju hi lc b fi lh li l lj lk">data['Student_name'].is_unique</span><span id="d46b" class="lg ju hi lc b fi mg li l lj lk">#output<br/>#False</span></pre></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="d442" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些是pandas中一些简单、有用、省时的功能，可以帮助你优化代码。这样一个高效且代码直观的生态系统帮助用户更专注于实现而不是编码。</p><p id="a9d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">参考文献</strong></p><ul class=""><li id="d450" class="ll lm hi ix b iy iz jc jd jg ln jk lo jo lp js lq lr ls lt bi translated"><a class="ae iu" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/</a></li></ul></div></div>    
</body>
</html>