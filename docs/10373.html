<html>
<head>
<title>Unlock the Power of Reentrant Lock in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">释放 Java 中可重入锁的威力</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/unlock-the-power-of-reentrant-lock-in-java-d55ae9135443?source=collection_archive---------8-----------------------#2020-10-16">https://medium.com/analytics-vidhya/unlock-the-power-of-reentrant-lock-in-java-d55ae9135443?source=collection_archive---------8-----------------------#2020-10-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/454beedf274cce1505bd1b4e27ad1c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQGHUEmQHnSox7wQvVARkg.jpeg"/></div></div></figure><h2 id="c916" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">历史</h2><p id="dc12" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">可重入锁是在 Java 5.0 中添加的，以提升固有锁定游戏的级别。早期的“synchronized”和“volatile”是 Java 中实现并发性的主要手段。</p><h2 id="b390" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">那么什么是可重入锁呢？</h2><p id="e695" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">ReentrantLock 类实现了锁接口。与其他锁一样，它在访问共享资源时为方法提供同步。</p><h2 id="28ee" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">但是为什么叫可重入呢？</h2><p id="6b65" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">顾名思义，ReentrantLock 允许线程在一个资源上不止一次地进入锁(或重新进入)。<br/>当线程第一次进入资源锁时，保持计数被设置为 1。线程可以再次将线程重新输入锁中，直到资源被解锁，并且每个“锁”操作将使保持计数增加 1。每一次“解锁”操作将使保持计数减一。<br/> <em class="kj">只有当 hold count 设置为 0 时，资源才真正解锁。</em></p><h2 id="66b1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">好吧，那它是怎么工作的？</h2><p id="19c5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">根据 Oracle，ReentrantLock 由最后成功锁定但尚未解锁的线程拥有。当锁不属于另一个线程时，调用锁的线程将返回，成功获取锁。如果当前线程已经拥有锁，该方法将立即返回。<em class="kj">这可以使用方法 isHeldByCurrentThread()和 getHoldCount()来检查。</em></p><h2 id="2d7b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">好看，怎么用？</h2><p id="d849" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">使用共享资源的代码被对锁定和解锁方法的调用所包围。</p><p id="c96a" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">样本示例:-</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/64b088fb33acf4822ee173ea8b0c6318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*A3wEc-O1yODMm7hGb-qDdA.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">ReentrantLock 示例</figcaption></figure><h2 id="1606" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">提醒一句:</h2><p id="23a7" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">问题:<br/> <em class="kj">如果 task 抛出一个 RuntimeException，锁可能会永远保持不变，导致所有试图获取锁的其他线程阻塞。</em></p><p id="9e93" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">解决方案:<br/> <em class="kj">我们需要用 try 包围 task，用 finally 块包围 lock.unlock()。<br/>首先应该这样使用它。</em></p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/19b839c2b714a828cae93338112692cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*GsPwrb701ZLlbEtAYg9LfA.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">重入锁定警告</figcaption></figure><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/285a0e221f3fd3dcf4e96f0a84b44b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1VO-pSakJLsR_ICZ3rIpdQ.jpeg"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">我在这里只是为了吸引你的注意力</figcaption></figure><h2 id="f5a5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">lock.tryLock()方法的威力:</h2><p id="f02a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">Java 说:如果锁没有被另一个线程持有，则获取锁，并立即返回值 true，将锁持有计数设置为 1，否则返回 false。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/9c31c81ac9afedddd91508eb39c02339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*vfMhbHLPJ_4gBUq2fA7GPw.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">lock.tryLock 方法</figcaption></figure><h2 id="dc0a" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">lock.lockInterruptibly()方法的功能:</h2><p id="bb2f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">Java 说:线程试图获得锁，除非当前线程被中断，允许它立即对中断信号作出反应。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es la"><img src="../Images/d0a97066ce80798e384aa323da2ac1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*a_NdXOvOSD29qtuIVfkLPA.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">lock.lockInterruptibly 方法</figcaption></figure><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/bd2d71b55df5972e34a628e761cc8af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iE2PwMaD5hBQ1Sj5q63GKw.jpeg"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">锁的钥匙</figcaption></figure><h2 id="b7ef" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">公平呢？</h2><p id="c828" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated"><em class="kj">这个类的构造函数接受一个可选的公平性参数。<br/>根据 Oracle，当设置为 true 时，锁倾向于授予等待时间最长的线程访问权限。否则，它不保证任何特定的顺序。<br/> public ReentrantLock(布尔公平)</em></p><h2 id="7015" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">那么我为什么要用 ReentrantLock 呢？</h2><p id="bf41" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">内在锁是块结构的，而外在锁允许有更明确的控制空间。比如使用 tryLock 进行流量控制，或者使用 lockInterruptibly 对中断信号做出反应。</p><p id="fef7" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated">除了实现锁接口之外，这个类还定义了 isLocked 和 getLockQueueLength 方法，以及一些相关的受保护的访问方法，这些方法可能对检测和监控有用。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="563a" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated"><strong class="jq hj">在这里阅读更多关于并发编程的内容</strong></p><p id="a17e" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated"><strong class="jq hj">Java 中的锁:</strong><a class="ae lj" rel="noopener" href="/analytics-vidhya/understanding-java-thread-synchronization-with-methods-vs-objects-vs-locks-5428e3342fee">https://medium . com/analytics-vid hya/understanding-Java-thread-synchron ization-with-methods-vs-objects-vs-Locks-5428 e 3342 fee</a></p><p id="c519" class="pw-post-body-paragraph jo jp hi jq b jr kk jt ju jv kl jx jy jb km ka kb jf kn kd ke jj ko kg kh ki hb bi translated"><strong class="jq hj">重入锁:</strong><a class="ae lj" rel="noopener" href="/analytics-vidhya/unlock-the-power-of-reentrant-lock-in-java-d55ae9135443">https://medium . com/analytics-vid hya/unlock-the-power-of-Reentrant-lock-in-Java-d55ae 9135443</a></p></div></div>    
</body>
</html>