<html>
<head>
<title>HTML Canvas Optimization of Rendering Loop with JSAPI for Drawing on Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JSAPI优化地图绘制的渲染循环</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/html-canvas-optimization-of-rendering-loop-with-jsapi-for-drawing-on-map-71cb0500a213?source=collection_archive---------14-----------------------#2019-12-17">https://medium.com/analytics-vidhya/html-canvas-optimization-of-rendering-loop-with-jsapi-for-drawing-on-map-71cb0500a213?source=collection_archive---------14-----------------------#2019-12-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ef36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您是否有兴趣开发一种工具来绘制形状或在地图上可视化数据？您可能想知道如何使用ArcGIS 的<a class="ae jd" href="https://developers.arcgis.com/javascript/" rel="noopener ugc nofollow" target="_blank"> JSAPI优化您的自定义渲染器，那么这篇文章就是您的了。</a></p><div class="je jf jg jh fd ab cb"><figure class="ji jj jk jl jm jn jo paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/a536ff20add14d9f50938ea3cd854769.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*wIgDQy2_Dk0N783nu2VRNQ.png"/></div></figure><figure class="ji jj jv jl jm jn jo paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/d50d35367379a8d8ae1f0fe2ca846388.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*-aQnAAJ6zS4fV3IZPM9mrw.png"/></div></figure><figure class="ji jj jw jl jm jn jo paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/66ba9bde077a58af581c23c6c2770718.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*jICtp8z2NcMMdC4V2a1BPQ.png"/></div></figure></div><p id="af89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">为什么是HTML画布？</strong></p><p id="2818" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有什么特别的理由表明<a class="ae jd" href="https://www.w3schools.com/graphics/canvas_intro.asp" rel="noopener ugc nofollow" target="_blank"> HTML画布</a>是在网络浏览器上绘图的最佳方式，相比之下<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API" rel="noopener ugc nofollow" target="_blank"> WebGL </a>或<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/SVG" rel="noopener ugc nofollow" target="_blank"> SVG </a>也可以被认为是绘图工具。然而，它提供了在Web环境中进行动态绘制的简单而直接的方法。Canvas被认为是在Web浏览器上绘制或可视化的一种简单的交互式方式。</p><p id="14a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">为什么要用JSAPI来映射和可视化数据</strong></p><p id="ad0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ESRI的地图产品JSAPI为我们提供了许多强大的API，使我们能够在地图上进行分析、可视化和绘制。HTML画布和来自JSAPI的投影，我们可以在地图上构建一个定制的绘图工具。使用JSAPI中的Map和MapView对象，我们可以创建一个基于地理位置和屏幕位置坐标系的动态绘图工具。</p><p id="5624" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，尽管在JSAPI中使用HTML Canvas有很多方面(稍后我会介绍更多有趣和令人兴奋的东西)，但本文主要分享在JSAPI(MapView object)实时图形中使用HTML Canvas的几种优化方法。</p><p id="ec67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回顾一下HTML Canvas的传统和众所周知的优化技术，我们可以采用它来最小化渲染循环中的计算和绘图。</p><ol class=""><li id="6b60" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated">减少渲染循环</li><li id="960e" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">避免使用<code class="du kl km kn ko b">context.shadowBlur</code>等阴影。</li><li id="5cbf" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">避免使用API: <code class="du kl km kn ko b">context.save()</code>和<code class="du kl km kn ko b">context.restore()</code></li><li id="53f9" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">在不同的情况下使用多个画布:静态或动态场景。</li><li id="443a" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">使用requestAnimationFrame，而不是<code class="du kl km kn ko b">setTimeout</code>或<code class="du kl km kn ko b">setInterval</code></li><li id="f6a0" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">越来越…</li></ol><p id="8e4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然'<code class="du kl km kn ko b">requestAnimationFrame</code>'有很多渲染循环的优化，但有一些空间我们可以显式地优化计算。</p><p id="c9e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">控制渲染循环</strong></p><p id="c2b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了上面我提到的，还有更多，但是，不用说，我们不想在没有交互的时候做渲染循环。例如，当鼠标离开div或HTML画布上下文时，或者在它渲染某些循环以完成开始的动画后，我们可以在不清除画布的情况下停止循环。因此，我们仍然可以看到地图上的形状或图像。</p><p id="f191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">甚至进一步优化，可以控制帧速率。例如，当缩放或平移地图时，渲染循环的低帧速率会显示某种锯齿状的动画，不能很好地附着在地图上。显然这对实时图形没有好处。在这种情况下，我们可以根据MapView对象的平移或缩放事件动态切换渲染循环的帧速率。</p><p id="091e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">区分任务</strong></p><p id="ed90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数实时图形环境，如Unity、Unreal等，有三个不同的步骤:在单个循环中的(1)初始化，(2)更新，和(3)渲染阶段的步骤。利用每一步在优化计算和循环中起着重要的作用。不希望在每个渲染循环中计算相同的数据。在这种情况下，我们将这个计算放在初始化阶段。因此，就开发架构中的管道而言，我们需要仔细设计一组数据流，以便在必要时进行控制。</p><p id="6969" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在更新阶段，我们可以计算有意义的计算，如检查距离、动力学物理、悬停效果等等。在帧速率降低的情况下，我们可以跳过一定数量的帧来计算，因为它与渲染无关，在渲染中它在我们可以看到的屏幕上绘制实际的形状。有些函数每秒钟执行15或10次是可以的。</p><p id="e157" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看渲染步骤，我们可以根据计算机系统的能力自由调节帧速率，因为更新阶段与渲染无关。从功能强大的机器到移动设备，我强烈建议你安装一种观察器来监控和改变渲染循环中的帧速率。根据形状或可视化实体的数量，或者根据平移或缩放等事件，我们可以应用不同的帧速率。此外，由于GPU的并行处理，绘制特定的操作在渲染阶段进行。我的意思是，关注点或任务的分离和隔离总是可以被认为是一个良好的实践，以便在一定的架构复杂度内进行调试和优化。</p><p id="0c8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">挑选形状</strong></p><p id="23a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于图形来说，选择是一个非常重要和广泛的操作。尽管拾取通常是一个根本不同的故事，但它也会影响渲染循环。想想这样一种情况，每当你移动鼠标、点击或拖动某物时，我们需要在渲染循环的同时跟踪和计算管道中的事件。当然，在当前渲染循环之上，我们不希望为循环中的事件添加额外的计算。但不幸的是，没有办法避免处决。否则，什么都不会发生。</p><p id="497b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了最小化拾取的计算量，有许多方法可以通过诸如<a class="ae jd" href="https://en.wikipedia.org/wiki/Quadtree" rel="noopener ugc nofollow" target="_blank">四叉树</a>、屏幕外渲染或简单的数学如距离检查来实现拾取。但同样，我们需要最小化循环本身，这是维持循环条件的基本帮助。</p><p id="61c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">鼠标按下、按下、单击、双击事件在渲染循环中作为一次性操作发生。在这种情况下，无法在循环时跳过执行。然而，我们可以通过跳过鼠标事件中的某些帧来优化循环。例如，在移动鼠标时，有必要检查指针是否悬停在某个形状上。我们不需要一秒钟执行60次这种庞大的操作。或者每一帧。</p><p id="43f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更复杂的情况是，在地图上拖动多边形的顶点时，我们可以检查形状的最近顶点，以将所选顶点捕捉到最近的顶点。在这个操作中，我们可以不在单个循环中计算检查操作，而是在循环的每一个偶数帧或每五帧中计算检查操作。然后，我们捕捉形状的最近顶点，并在鼠标释放时重用捕捉到的顶点。现在你可以看到我们可以减少多少帧来计算运算。</p><p id="7732" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">处理渲染循环中的事件</strong></p><p id="350c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在渲染循环期间，有许多管道和输入来触发执行计算。比如键盘或者UI按钮或者滑动条。持续启动这些函数会影响性能。作为一种保护措施，我们可以安装一些功能来监听事件，并智能地插入或跳过其中的一些事件，如果相同的事件根据场景和MapView的状态持续快速出现的话。</p><figure class="je jf jg jh fd jj er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es kp"><img src="../Images/ee451425a3dd3c14a412ee99553385e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6YCcnkixZicDZUZLUBWaw.png"/></div></div></figure><p id="3958" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我相信在整个架构中，在纳米、微米和宏观层面上有很多优化的技巧。在这篇文章中，我分享了用JSAPI的MapView减少渲染循环次数的技巧。作为一个例子，我建议访问<a class="ae jd" href="https://storymaps.arcgis.com" rel="noopener ugc nofollow" target="_blank">story map</a>(【https://storymaps.arcgis.com】T2)并鼓励你体验我在上面应用了这些方法的Expressmap，以及更多。</p></div></div>    
</body>
</html>