<html>
<head>
<title>Solving complex big data problems using combinations of window functions, deep dive in PySpark.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用窗口函数的组合解决复杂的大数据问题。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/solving-complex-big-data-problems-using-combinations-of-window-functions-deep-dive-in-pyspark-b1830eb00b7d?source=collection_archive---------0-----------------------#2020-03-21">https://medium.com/analytics-vidhya/solving-complex-big-data-problems-using-combinations-of-window-functions-deep-dive-in-pyspark-b1830eb00b7d?source=collection_archive---------0-----------------------#2020-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3b60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> Spark2.4，Python3。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/df91a5f0f57d78df79897221358653bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOHZPXGjsDKIPEsmeEIiGA.png"/></div></div></figure><p id="a0d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">窗口函数是Spark中极其强大的聚合工具。它们具有<strong class="ih hj">窗口特有的</strong>功能，如<em class="jd">等级、密集等级、滞后、领先、</em>累积等级、百分比等级、<a class="ae jq" href="https://jaceklaskowski.gitbooks.io/mastering-spark-sql/spark-sql-functions-windows.html#ntile" rel="noopener ugc nofollow" target="_blank">整体等级</a>。除此之外，我们还可以使用<strong class="ih hj">正常聚合</strong>函数，如<em class="jd"> sum，avg，collect_list，collect_set，approximate _ count _ distinct，count，first，skewness，std，sum_distinct，variance，list </em>等。</p><p id="c413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过选择您的聚合窗口，窗口<strong class="ih hj">比您的普通分组更加灵活。Windows提供这种灵活性的选项有:<strong class="ih hj"> <em class="jd"> partitionBy、orderBy、rangeBetween、rowsBetween </em> </strong>子句。<strong class="ih hj"> PartitionBy </strong>类似于你通常的groupBy，通过<strong class="ih hj"> orderBy </strong>你可以指定一列来排序你的窗口，并且<strong class="ih hj">range between/rows between</strong>子句允许你指定你的<strong class="ih hj">窗口框架。</strong>框架可以是unboundedPreceding，或unboundingFollowing，currentRow或long(BigInt)值(9，0)，其中0是当前行。</strong></p><blockquote class="jr js jt"><p id="ff76" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">对于大数据，几乎总是建议在partitionBy子句中有一个分区/分组列，因为它允许<strong class="ih hj"> spark跨分区分布数据，而不是将其全部加载到一个</strong>中。该子句中可以有多列。</p></blockquote><p id="614b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你的数据帧在你的窗口函数中的partitionBy列上被<strong class="ih hj">分区，窗口函数也有能力<strong class="ih hj">显著地</strong>胜过你的groupBy。这将允许您的窗口函数只将您的<strong class="ih hj">数据混洗一次(一遍)。</strong></strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jx"><img src="../Images/720ac7539b7f94275fce610428e0aa50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JM3d1-XMixo_szMl4sdHKA.png"/></div></div></figure><p id="f28c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以通过调用<strong class="ih hj"> repartition(col，numofpartitions)或repartition(col) </strong>来实现这一点，然后再调用您的窗口聚合函数，该函数将由<strong class="ih hj"> (col) </strong>进行分区。重新分区基本上是<strong class="ih hj">平均分配</strong>您的数据，而不管您正在重新分区的列中的<strong class="ih hj">倾斜。</strong></p><blockquote class="jr js jt"><p id="607c" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">还要避免使用只有一个唯一值的parititonBy列<strong class="ih hj">，因为这等同于将其全部加载到一个分区</strong>。</p></blockquote><p id="1786" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在真实世界的大数据场景中，<em class="jd"/><strong class="ih hj"><em class="jd">窗口功能的真正威力在于使用其所有不同功能</em> </strong> <em class="jd">的组合来解决复杂问题。</em></p><p id="b1d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我将<strong class="ih hj">概述一些见解</strong>，然后我将<strong class="ih hj">提供真实世界的例子</strong>来展示我们如何<strong class="ih hj">使用不同窗口函数的组合</strong>来解决复杂的问题。</p><h1 id="d058" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">见解和技巧:</h1><ul class=""><li id="406b" class="kw kx hi ih b ii ky im kz iq la iu lb iy lc jc ld le lf lg bi translated">带有<strong class="ih hj"> sum函数</strong>的窗口允许您获得整个窗口的<strong class="ih hj">和，或者如果指定了orderBy子句，则获得窗口的<strong class="ih hj">增量/累积和。</strong>如果您对orderBy列执行累积求和，而order by列在像<strong class="ih hj"> [a，b，c，d，e] </strong>这样的窗口组中具有所有唯一值，那么<strong class="ih hj">您不需要指定rowsBetween子句</strong>来确保它正常工作，但是，如果您按<strong class="ih hj"> [a，a，a，b，b] </strong>进行排序，并且您需要增量/累积求和<strong class="ih hj"> </strong>，那么您需要指定【T20</strong>增量总和可以成为<strong class="ih hj">计算特定值增长率的有力工具</strong>。也可以与其他窗口函数结合<strong class="ih hj">使用，例如<strong class="ih hj">填充动态分区</strong>，如<strong class="ih hj">例2所示。</strong>我们还可以对窗框的<strong class="ih hj">逐步</strong>移动应用其他功能。</strong></li><li id="0315" class="kw kx hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">如果有一列的窗口组的值为<strong class="ih hj"> [0，0，0，0，5，0，0] </strong>(基本上，<strong class="ih hj">除了一个值</strong>之外都是零)，并且出于某种原因，您希望窗口组具有<strong class="ih hj"> [5，5，5，5，5，5，5，5，5] </strong>，您可以使用<em class="jd"> sum(columntosum)。结束(窗口()。partition by(grouping col/id))</em>。这相当于将计算列分组5的总数，并且由于没有orderBy子句，它将基本上<strong class="ih hj">广播到整个窗口</strong>。类似地，如果您的列有类似[null，null，null，5，null]的组，您可以使用<strong class="ih hj">sum和mean，</strong>将值传播到[ 5，5，5，5，5]。</li><li id="5ccc" class="kw kx hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">当处理窗口分区中的<strong class="ih hj">空值时，可以使用带有<strong class="ih hj"> asc_nulls_first() </strong>或<strong class="ih hj"> desc_nulls_first() </strong>的orderBy子句，这样空值可以占据顶部的所有行。当<strong class="ih hj">试图使用窗口函数将值归入空值</strong>时，它可以派上用场。</strong></li><li id="0955" class="kw kx hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">有一些窗口聚集函数，如<strong class="ih hj"> max或last </strong>要求窗口框架无界，否则它们将无法正常工作。因此，如果你写了一个有orderBy但没有:<strong class="ih hj">rows between(window . unboundedpressing，Window.unboundedFollowing)，</strong>的窗口，那么你的max/last函数<strong class="ih hj">将不会给出它想要的输出。</strong> <em class="jd">参考我回答的StackOverflow问题</em><strong class="ih hj">:</strong><a class="ae jq" href="https://stackoverflow.com/questions/60327952/pyspark-partitionby-leaves-the-same-value-in-column-by-which-partitioned-multip/60344140#60344140" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/60327952/py spark-partition by-leaves-the-same-value-in-column-by-which-partitioned-multip/60344140 # 60344140</a>。</li></ul><blockquote class="jr js jt"><p id="6f9e" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">另一种让max正常工作的方法是<strong class="ih hj">只使用partitionBy </strong>子句<strong class="ih hj">而不使用orderBy子句</strong>。最大值函数<strong class="ih hj">不需要顺序</strong>，因为它正在计算整个窗口的最大值，并且窗口将是无界的。</p></blockquote><ul class=""><li id="e22c" class="kw kx hi ih b ii ij im in iq lm iu ln iy lo jc ld le lf lg bi translated">就像我们在增量步骤中使用sum一样，如果我们希望从窗口中收集的列表按照orderBy子句 <em class="jd">中指定的顺序进行收集，我们也可以以类似的方式使用collect _ list<strong class="ih hj">(order by子句可以接受订单的多列)。</strong></em> <strong class="ih hj">参考例1 </strong>。<strong class="ih hj"> Spark2.4 </strong>确实提供了新的<strong class="ih hj">数组函数和高阶函数</strong>，允许我们以<strong class="ih hj">可伸缩的方式</strong>对数组进行排序，但是<strong class="ih hj">从窗口中以正确的顺序收集它们可能会更好。</strong></li><li id="ceb3" class="kw kx hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">我们也可以使用<strong class="ih hj"> when &amp; otherwise子句在窗口</strong>上使用sum和collect_list等聚集函数，以便<strong class="ih hj">隔离窗口</strong>的某些行，如果它们不满足子句中的条件。一个用例可以是当<strong class="ih hj"> <em class="jd">是Null()或isNotNull()时使用，以对窗口分区上的列表求和/收集。</em>T41】</strong></li><li id="c56d" class="kw kx hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">另一种处理窗口分区中的空值的方法是使用函数<strong class="ih hj"> first和last，</strong>，它们有一个名为<strong class="ih hj"> IgnoreNulls </strong>的<strong class="ih hj">参数</strong>，该参数接受一个<strong class="ih hj">布尔值</strong>(默认设置为False) <strong class="ih hj">。</strong>基本上你可以在你的窗口中计算出<strong class="ih hj">第一个非空值或者最后一个非空值。</strong></li><li id="c4c0" class="kw kx hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">如果您有一个需求或一个大难题中的一小部分，基本上需要您<strong class="ih hj">用max row_number(来自有序窗口)</strong>填充一个窗口分区，您可以在不同的窗口上联合使用row_number()和max()。它看起来会像这样:</li></ul><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="304b" class="lu jz hi lq b fi lv lw l lx ly">df.withColumn("xyz", F.max(F.row_number().over(w)).over(w2))</span></pre><p id="7b9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">麦克斯会要求窗户无界。</strong>这可能看起来相当模糊和无意义，这就是为什么我将详细解释这如何帮助我<strong class="ih hj">计算中位数(因为中位数你需要n行的总数)</strong>。这也将有助于保持<strong class="ih hj">解决方案的动态性</strong>，因为我可以使用<strong class="ih hj">整个列</strong>作为<strong class="ih hj">列</strong> <strong class="ih hj">，其中包含跨每个窗口分区广播的总行数。</strong>更多细节和视觉帮助参见<strong class="ih hj">示例3 </strong>。</p><ul class=""><li id="182a" class="kw kx hi ih b ii ij im in iq lm iu ln iy lo jc ld le lf lg bi translated">使用不同窗口功能的<strong class="ih hj">组合的一个<strong class="ih hj">用例</strong>是当<strong class="ih hj">需要在分区窗口</strong>内创建新分区时。如果由partitionBy列<strong class="ih hj">提供的分区窗口不足以获得期望的输出</strong>，这可能是真的。一旦计算出较大组分区内的那些新组，该<strong class="ih hj">新列</strong>可以被添加到新窗口</strong>函数的<strong class="ih hj"> partitionBy子句中，该函数将更加<strong class="ih hj">动态</strong>，因为它进入分组</strong>更深<strong class="ih hj">。这在我对<strong class="ih hj">例2 </strong>的解释中会更有意义。</strong></li><li id="96ed" class="kw kx hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">这是<strong class="ih hj">并不专门针对涉及窗口函数</strong>的问题，但有时当创建具有不同窗口函数的新列并试图计算您想要的输出时，您可能会遇到这样的情况:基本上给出2个结果的<strong class="ih hj"> when/otherwise子句</strong>(您可以在when子句中使用&amp;、| etc运算符，但它仍然会导致1个结果)<strong class="ih hj">不足以获得您想要的输出。在这些情况下，你可以<strong class="ih hj">像<strong class="ih hj"> <em class="jd"> when(…)一样链接你的when/otherwise子句</em></strong>。当(…)。).当(…)。否则(…)。T47】</strong></strong></li><li id="b36d" class="kw kx hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">如果有效使用，Spark窗口功能非常强大，但是有一个限制，即窗口框架本质上不是动态的。意味着<strong class="ih hj"> rangBetween子句只能接受不会随着每个不同的窗口框架而改变的长整型(bigInt)值。最初，我期望窗口框架rangeBetween接受一列作为前面的参数，然而这是不可能的，它给出了一个错误，即<strong class="ih hj">只接受一个文字值。</strong>因此，<strong class="ih hj">如果你想开发一个动态窗口</strong>，你将让<strong class="ih hj">使用特定于每个用例的逻辑来计算它。</strong>我第一次面对这个问题时，我的任务是<strong class="ih hj">根据日期</strong>计算一列的year today总和，这基本上意味着随着窗口经过<strong class="ih hj">的每个日期，窗口框架都必须改变并计算新的日期范围，以获得year today</strong>。如果我可以计算一个从年初开始的天数为<strong class="ih hj">的列</strong>，然后<strong class="ih hj">将该列放入子句</strong>的范围内，这就很容易了，但是这是不可能的<strong class="ih hj"/>。<strong class="ih hj">绕过这个路障的一个方法，</strong>是从日期、<strong class="ih hj">年、月、日</strong>创建新的列，然后创建一个窗口函数，用<em class="jd"> partitionBy作为年，orderBy month and day和rows between(window . unbounded preding，Window.currentRow) </em>。您也可以应用类似的逻辑让MonthToDate也能这样做。我将在例6中深入探讨这是如何工作的。</strong></li></ul><p id="2b51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用这种逻辑也是高度优化的，如Spark更新中所述:</strong><a class="ae jq" href="https://issues.apache.org/jira/browse/SPARK-8638" rel="noopener ugc nofollow" target="_blank">https://issues.apache.org/jira/browse/SPARK-8638</a></p><blockquote class="jr js jt"><p id="e8aa" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">"1.在运行情况下<strong class="ih hj">(例如，在未绑定的前一行和当前行之间)性能更好(10倍)。”</strong></p></blockquote><p id="63af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这里需要注意的一件事</strong>是，这种使用<strong class="ih hj">unbounded preding、</strong>和<strong class="ih hj"> currentRow </strong>的方法只会让我们得到<strong class="ih hj">正确的YTD </strong>，如果<strong class="ih hj">对于我们试图对</strong>求和的每个日期只有一个条目的话。如果<strong class="ih hj">每个日期</strong>有多个条目，那么<strong class="ih hj">将不会工作</strong>，因为<strong class="ih hj">行框架会将同一日期的每个条目视为不同的条目</strong>，因为它会逐渐向上移动。这种情况也使用窗口功能的<strong class="ih hj">组合进行处理，并在示例6 </strong>中进行解释。</p><h1 id="b677" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">示例1:</h1><p id="e093" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq lz is it iu ma iw ix iy mb ja jb jc hb bi translated">假设您有一个<strong class="ih hj">数据帧:</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mc"><img src="../Images/8c637c801e1ee7e8822bb70919e2cbaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*RqjMty_MtCbBkL4aZqfOow.png"/></div></figure><p id="5598" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而<strong class="ih hj">输出</strong>所需的是:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es md"><img src="../Images/a83a6963e4d55bf4b4efeb5508f0924c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*hgOEOkWbeDRwZ1Fg5Uczmg.png"/></div></figure><p id="c6d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这看起来很简单，你可以首先通过函数名来分组和收集列表，然后通过收集列表来分组，并收集函数名的列表。这里唯一的问题是，<strong class="ih hj">结果列表</strong>必须按照特定的<strong class="ih hj">顺序收集。</strong>如上文所述，我们现在可以使用数组函数对<strong class="ih hj"> spark2.4 </strong>、<strong class="ih hj">中的数组进行排序，但</strong>上面显示的数据只是一个样本，而<strong class="ih hj">结果列表可以跨越数十或数百个条目。</strong>因此，高度可伸缩的解决方案将使用<strong class="ih hj">窗口函数来收集由orderBy指定的列表。</strong>窗口将<strong class="ih hj">递增</strong> collect_list <strong class="ih hj"> s </strong> o我们只需要获取/过滤包含整个列表的<strong class="ih hj">组的最后一个元素。</strong>实现这一点的一种方法是在窗口上计算<strong class="ih hj"> row_number() </strong>，并仅过滤该行号的<strong class="ih hj"> max() </strong>。一旦我们有了<strong class="ih hj">完整列表</strong>和<strong class="ih hj">所需的适当顺序</strong>，我们就可以最终<em class="jd">根据收集列表和function_name收集列表进行分组。</em></p><p id="f253" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">代号</em> </strong> <em class="jd"> : </em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es me"><img src="../Images/e4ff2dac92fd5535bd853aa225b0f52f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8FcuknAL5Pe5n2CH-yptA.png"/></div></div></figure><p id="f874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该问题要求按照w. 的<strong class="ih hj"> orderBy子句所示的<strong class="ih hj"> param1、param2、param3 </strong>中指定的<strong class="ih hj">字母</strong>的顺序收集列表。第二个窗口(<strong class="ih hj"> w1 </strong>)只有一个partitionBy子句，因此没有orderBy </strong>的<strong class="ih hj">才能使max函数正常工作。在<strong class="ih hj">过滤器中使用了<strong class="ih hj"> max和row_number </strong>来强制代码只取完整的数组。</strong>group by向我们展示了我们也可以<strong class="ih hj">通过ArrayType列进行分组。</strong></strong></p><p id="1f26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用窗口上的<strong class="ih hj">最后一个函数也可以实现<strong class="ih hj">最大行数逻辑</strong>。然而，最后一个函数的<strong class="ih hj">窗口需要是无界的</strong>，然后我们可以<strong class="ih hj">过滤最后一个函数的值。这方面的代码应该是这样的:</strong></strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mf"><img src="../Images/10868f5ff05e442b5ccccfe96f39aae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wdum159ZdtDpGSM0iENjqg.png"/></div></div></figure><p id="a363" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，我在这里试图阐明的观点是，我们可以使用windows的<strong class="ih hj">增量操作，使用orderBy和collect_list、sum或mean </strong>来解决许多问题。使用增量窗口(w)的集合将在下面<strong class="ih hj">看起来像这样，因此，<strong class="ih hj">我们必须获取组中的最后一行(使用max或last)。</strong></strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mg"><img src="../Images/f06db5297718ed1cd15cd764a906f33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*ISjKKEK1jZQ1n1cQjkx48A.png"/></div></figure><p id="bb6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">链接到我在StackOverflow上回答的问题:</em><a class="ae jq" href="https://stackoverflow.com/questions/60155347/apache-spark-group-by-df-collect-values-into-list-and-then-group-by-list/60155901#60155901" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/60155347/Apache-spark-group-by-df-collect-values-into-list-then-group-by-list/60155901 # 60155901</a></p><h1 id="d43f" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">示例2:</h1><p id="745c" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq lz is it iu ma iw ix iy mb ja jb jc hb bi translated">假设您有一个<strong class="ih hj">数据框架</strong>，其中有一个<strong class="ih hj">项目存储组</strong>，如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mh"><img src="../Images/bd9473adf97c72292ad7b8bf10a1ae26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*V3lLIWaoDFPUeuF2L5oeLA.png"/></div></figure><p id="1423" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要求是<strong class="ih hj">根据<strong class="ih hj">最后一个非空值</strong>估算库存</strong>的空值，然后<strong class="ih hj">使用sales_qty从库存值</strong>中减去。这里的<strong class="ih hj">捕捉</strong>是指<strong class="ih hj">每个非空股票值</strong>正在创建另一个<strong class="ih hj">组或项目-商店组合的组</strong>内的分区。</p><p id="3850" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的<strong class="ih hj">方法</strong>应该是以某种方式创建<strong class="ih hj">另一列以添加到partitionBy子句(item，store) </strong>中，以便<strong class="ih hj">窗口框架、</strong>可以<strong class="ih hj"> <em class="jd">更深入到我们的股票列</em> </strong> <em class="jd">。</em></p><p id="067c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">本质上，通过向我们的partitionBy </em>  <em class="jd">添加另一列</em> <strong class="ih hj"> <em class="jd">，我们将使我们的窗口</em> <strong class="ih hj"> <em class="jd">更加动态，更适合这个特定的用例。</em>T11】</strong></strong></p><p id="40c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">所需输出:</em> </strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mh"><img src="../Images/ca05296082e4108fe6d414f8ac9e50e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*xwsgFDLag9qoUPrgmEUpTg.png"/></div></figure><p id="abed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">完整的代码如下所示。</strong>我将提供<strong class="ih hj">解决方案的逐步解释</strong>，向您展示使用窗口功能组合的<strong class="ih hj">威力。</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mi"><img src="../Images/3c5dc9b98da9ac8ba9ce42fbf04f58c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8sVdAIOgQEOr-QaSh-ardg.png"/></div></div></figure><p id="a35a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">读到这里，有人可能会想，为什么不能用ignorenulls=True的<strong class="ih hj"> First函数呢？</strong>答案是我们在同一个分组/窗口中有<strong class="ih hj">多个非空值，而<strong class="ih hj">第一个</strong>函数只能给我们整个窗口的<strong class="ih hj">第一个非空值。</strong>也就是说，第一个带有忽略空值选项的函数是一个非常强大的函数，可以用来解决许多复杂的问题，<strong class="ih hj">只是不是这个。</strong></strong></p><p id="f3a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个<strong class="ih hj">输出显示了我用来获得期望结果</strong>的所有列。如果你<strong class="ih hj">能看到正在发生的事情</strong>，解释起来会更容易:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mj"><img src="../Images/2bba2a3c9c96d71a5c59831e76933921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dS_1x_QvguNqXuEQIxhG7A.png"/></div></div></figure><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="5698" class="lu jz hi lq b fi lv lw l lx ly">df.withColumn("stock1", F.when(F.col("stock").isNull(), F.lit(0)).otherwise(F.col("stock")))\</span></pre><p id="b0d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">股票1列</strong>基本上是用0替换空值，这在以后做增量求和来为深入股票列的窗口创建新行时会很方便。</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="4d21" class="lu jz hi lq b fi lv lw l lx ly"><strong class="lq hj">w=Window().partitionBy("item","store").orderBy("timestamp")</strong><br/>.withColumn("stock4", F.when(F.col("stock1")!=0, F.rank().over(<strong class="lq hj">w</strong>)).otherwise(F.col("stock1")))\</span></pre><p id="41e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Stock 4列</strong>在when/otherwise语句中使用窗口上的rank函数，以便我们仅在原始股票值存在时填充等级(<strong class="ih hj">忽略stock1中的0</strong>)。</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="9e29" class="lu jz hi lq b fi lv lw l lx ly"><strong class="lq hj">w=Window().partitionBy("item","store").orderBy("timestamp")<br/>w3=Window().partitionBy("item","store","stock5").orderBy("timestamp")</strong><br/>.withColumn("stock5", F.sum("stock4").over(w))\<br/>.withColumn("stock6", F.sum("stock1").over(w3))\</span></pre><p id="d591" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Stock5和stock6 </strong>列对于这个例子的整个逻辑非常重要。<strong class="ih hj"> Stock5基本上累加</strong>到<strong class="ih hj"> stock4 </strong>，<strong class="ih hj"> stock4除了股票值</strong>之外都是0，因此那些<strong class="ih hj">值在它们的特定分组</strong>中广播。Stock5列将允许我们<strong class="ih hj">创建一个名为w3 </strong>的新窗口，并且<strong class="ih hj"> stock5将进入已经有<strong class="ih hj">项的partitionBy列</strong>并存储</strong>。</p><p id="c237" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Stock6将使用新窗口(w3) </strong>进行计算，该窗口将对我们的初始<strong class="ih hj"> stock1 </strong>求和，这将在stock5列定义的各自的<strong class="ih hj">分区中传播非空的<strong class="ih hj">股票值</strong>。</strong></p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="823e" class="lu jz hi lq b fi lv lw l lx ly"><strong class="lq hj">w3=Window().partitionBy("item","store","stock5").orderBy("timestamp")</strong><br/>.withColumn(“sum”, F.sum(F.when(F.col(“stock1”)!=F.col(“stock6”),F.col(“sales_qty”)).otherwise(F.lit(0))).over(w3))\</span></pre><p id="edaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> sum </strong>列也非常重要，因为它允许我们根据我们计算的新窗口(w3) 将<strong class="ih hj"> sales_qty(这是问题的第二部分)</strong>的增量变化包含在我们的<strong class="ih hj">中间数据框架</strong>、<strong class="ih hj">中。</strong></p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="dcf3" class="lu jz hi lq b fi lv lw l lx ly">.withColumn("stock2", F.when(F.col("sales_qty")!=0, F.col("stock6")-F.col("sum")).otherwise(F.col("stock")))\<br/>.withColumn("stock", F.when((F.col("stock2").isNull())&amp;(F.col("sales_qty")==0),F.col("stock6")-F.col("sum")).otherwise(F.col("stock2")))</span></pre><p id="d174" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面显示的代码中，我们最终使用所有新生成的列来获得我们想要的输出。<strong class="ih hj"> Stock2 </strong>列计算足以处理几乎所有我们想要的输出，唯一留下的漏洞是那些后面跟有0 sales_qty增量的<strong class="ih hj">行。</strong>为了处理这些部分，我们使用如上所示的另一个case语句，以获得我们的最终输出作为<strong class="ih hj">股票</strong>。</p><blockquote class="jr js jt"><p id="e803" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">将不同的窗口函数相互结合使用(生成新的列)可以让我们解决您的复杂问题，这个问题基本上需要我们在stock-store的窗口中创建一个<strong class="ih hj">新的分区列。</strong></p></blockquote><p id="bca8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我回答的这个StackOverflow问题的链接</strong>:</p><p id="bb4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jq" href="https://stackoverflow.com/questions/60673457/pyspark-replacing-null-values-with-some-calculation-related-to-last-not-null-val/60688094#60688094" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/60673457/py spark-replacing-null-values-with-some-calculation-related-to-last-not-null-val/60688094 # 60688094</a></p><h1 id="25da" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">示例3:</h1><p id="6c81" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq lz is it iu ma iw ix iy mb ja jb jc hb bi translated">对于这个例子，我们必须<strong class="ih hj">将中间值</strong>估算到组上的<strong class="ih hj">零值。Spark没有内置的聚合函数来计算组/窗口的中值。Spark有<strong class="ih hj"> approxQuantile() </strong>但是它不是一个聚合函数，因此你不能在一个窗口上使用<strong class="ih hj">。</strong>因此，我们必须使用窗口函数来计算我们自己的<strong class="ih hj">自定义中值输入函数。</strong></strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mk"><img src="../Images/9aecc13173700ccb3cb2d4845bbcf282.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*g8-qtu70_tbUdDPqljNe0g.png"/></div></figure><p id="315d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算中位数的公式如下:</p><blockquote class="jr js jt"><p id="e341" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">“{(n+1)÷2 }个值，其中n是一组数据中值的个数。为了<strong class="ih hj">计算</strong>的<strong class="ih hj">中值</strong>，必须首先对数据进行排序(按升序排序)。<strong class="ih hj">中位数</strong>是中间的数字。<strong class="ih hj">中位数</strong> = <strong class="ih hj">一组有序数据的中间值</strong>。</p><p id="9f04" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">来自<a class="ae jq" href="https://www150.statcan.gc.ca/n1/edu/power-pouvoir/ch11/median-mediane/5214872-eng.htm" rel="noopener ugc nofollow" target="_blank">https://www 150 . stat can . GC . ca/n1/edu/power-pouvoir/ch11/median-mediane/5214872-eng . htm</a>。</p></blockquote><p id="953c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">窗口将被I_id和p _ id分割成<strong class="ih hj">,我们需要窗口的顺序为<strong class="ih hj">升序</strong>。我们还需要<strong class="ih hj">计算一组数据中值</strong>的总数，我们还需要确定值的总数是奇数还是偶数，因为如果有奇数个值</strong>的<strong class="ih hj">，中值就是<strong class="ih hj">的中心值</strong>，但是如果有偶数个值<strong class="ih hj">的</strong>，我们必须将<strong class="ih hj">的两个中间项相加，然后除以2。</strong>我们还必须确保如果<strong class="ih hj">有1个以上的空值</strong>，它们都用中值估算，并且<strong class="ih hj">空值不应该干扰我们的非空row_number()计算。</strong></strong></p><p id="1e23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">奇数总计</strong>例:1，3，3，<strong class="ih hj"> 6 </strong>，7，8，9</p><p id="4bbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">中值:6 </strong></p><p id="3efc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">偶数总计</strong>例:1，2，3，<strong class="ih hj"> 4，5 </strong>，6，8，9</p><p id="3ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">中位数:4.5 </strong></p><p id="2916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">所有这些都需要针对每个窗口分区进行计算，因此我们将使用窗口函数的组合。</em></p><p id="31f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">整个代码:</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ml"><img src="../Images/0f3ab2ff10ee00b3f4323a6d00ff4281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kr6KyLqV1HwFwgh_llwkeg.png"/></div></div></figure><blockquote class="jr js jt"><p id="89d2" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">这可能看起来过于复杂，一些阅读本文的人可能会觉得有更好的解决方案。所以对于那些人来说，如果他们能提供一个更优雅或不太复杂的解决方案(满足所有边缘情况)，我很乐意<strong class="ih hj">审阅它并将其添加到本文中。</strong></p></blockquote><p id="06a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前，<strong class="ih hj">我解包了上面</strong>的代码，我想<strong class="ih hj">给你看我用来得到想要的结果的所有列</strong>:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mm"><img src="../Images/d2a0ce7b3ea341a7d68a0befec05168a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LH6Wo-qf-EBvlgulOhTw0g.png"/></div></div></figure><p id="594b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的一些列本可以被<strong class="ih hj">缩减并与其他的</strong>合并，但是为了能够完整地显示<strong class="ih hj">逻辑</strong>和<strong class="ih hj">显示</strong> <strong class="ih hj">我是如何导航逻辑的，</strong>我选择保留它们，如上图所示。</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="63cd" class="lu jz hi lq b fi lv lw l lx ly"><strong class="lq hj">Imports used:<br/>from pyspark.sql import functions as F<br/>from pyspark.sql.window import Window<br/>from pyspark.sql.functions import when</strong></span><span id="e075" class="lu jz hi lq b fi mn lw l lx ly"><strong class="lq hj">Windows used:</strong></span><span id="bb8b" class="lu jz hi lq b fi mn lw l lx ly">w=   <strong class="lq hj">Window().partitionBy("I_id","p_id").orderBy(F.col("xyz").asc_nulls_first())</strong><br/>w2=<br/> <strong class="lq hj">Window().partitionBy("I_id","p_id")</strong></span></pre><p id="053c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我将解释为什么以及如何得到列<strong class="ih hj"> xyz1、xy2、xyz3、xyz10 </strong>:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="11bc" class="lu jz hi lq b fi lv lw l lx ly">df.withColumn("<strong class="lq hj">xyz1</strong>",F.count(F.col("xyz").isNotNull()).over(w))\<br/>.withColumn("<strong class="lq hj">xyz2</strong>", F.max(F.row_number().over(w)).over(w2))\<br/>.withColumn("<strong class="lq hj">xyz3</strong>", F.first("xyz1").over(w))\<br/>.withColumn("<strong class="lq hj">xyz10</strong>", F.col("xyz2")-F.col("xyz3"))\</span></pre><p id="eb87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Xyz1 </strong>基本上是对一个窗口内的<strong class="ih hj"> xyz </strong>值进行计数，在这个窗口内，我们首先按空值排序。可以使用<strong class="ih hj"> isNotNull或isNull </strong>进行计数，两者都将在窗口的第一行向我们提供窗口中Null的总数<strong class="ih hj">(经过大量测试后，我得出结论，两者都适用于这种情况，但如果使用没有Null条件的计数，它将不起作用)。</strong></p><p id="29be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Xyz3 </strong>从每个窗口分区获取第一个值<strong class="ih hj"> xyz </strong> 1，为我们提供在每个分区上广播的空值的<strong class="ih hj">总数。</strong></p><p id="0ec6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Xyz2 </strong>结合使用<strong class="ih hj"> max和row_number() </strong>为我们提供了跨分区窗口广播的每个分区的总行数，但是两者都用于不同的分区，因为为了使<strong class="ih hj"> max正确工作，它应该是无界的</strong>(如本文的见解部分所述)。</p><p id="a073" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Xyz10 </strong>通过从条目总数中减去空条目总数<strong class="ih hj">给出每个窗口分区的非空条目总数。</strong></p><p id="31e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我将解释列<strong class="ih hj"> xyz9、xyz4、xyz6、xyz7。</strong></p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="1f60" class="lu jz hi lq b fi lv lw l lx ly">.withColumn(“<strong class="lq hj">xyz9</strong>”, F.when((F.col(“xyz2”)-F.col(“xyz3”))%2!=0, F.col(“xyz2”)-F.col(“xyz3”)+1).otherwise(F.col(“xyz2”)-F.col(“xyz3”)))\<br/>.withColumn(“<strong class="lq hj">xyz4</strong>”, (F.col(“xyz9”)/2))\<br/>.withColumn(“<strong class="lq hj">xyz6</strong>”, F.col(“xyz4”)+F.col(“xyz3”))\<br/>.withColumn(“<strong class="lq hj">xyz7</strong>”, F.when(F.col(“xyz10”)%2==0,(F.col(“xyz4”)+F.col(“xyz3”)+1)).otherwise(F.lit(None)))\</span></pre><p id="4646" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Xyz9 </strong>基本使用<strong class="ih hj"> Xyz10(即xyz2列xyz3列)</strong>，查看数字是否为奇数(<strong class="ih hj">使用模2！=0 </strong>)然后给它加1，使它偶数，如果是偶数就保持原样。这个以后会派上用场的。</p><p id="0015" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Xyz4 </strong>除以<strong class="ih hj"> Xyz9 </strong>的结果，结果是<strong class="ih hj">偶数，给我们一个四舍五入的值</strong>。</p><p id="e32d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Xyz6 </strong>计算<strong class="ih hj"> xyz4和xyz3 </strong>的和。</p><p id="d511" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上,<strong class="ih hj"> xyz9和xyz6 </strong>满足这样的情况:我们将有一个总数为奇数的<strong class="ih hj">条目，因此我们可以将<strong class="ih hj">加1，除以2，其答案将是我们的中位数</strong>。对于<strong class="ih hj">偶数情况</strong>来说是不同的，因为中值必须通过将<strong class="ih hj">中间的2个值相加，然后除以2来计算。</strong></strong></p><p id="05df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Xyz7 </strong>将用于满足<strong class="ih hj">窗口分区</strong>条目总数为偶数的要求。如果Xyz10(col xyz2-col xyz3)数是偶数，使用(<strong class="ih hj">模2=0 </strong>)，对xyz4和xyz3求和，<strong class="ih hj">否则在该位置放置一个空值</strong>。Xyz7将用于<strong class="ih hj">与窗口分区</strong>的row_number()进行比较，然后如果我们的条目总数<strong class="ih hj">是偶数，则为我们提供<strong class="ih hj">额外的中间项</strong>。</strong></p><p id="3a75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我将解释最后3列，即<strong class="ih hj"> xyz5、medianr和medianr2 </strong>，它们<strong class="ih hj">驱动我们的逻辑。</strong></p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="cd89" class="lu jz hi lq b fi lv lw l lx ly">.withColumn("<strong class="lq hj">xyz5</strong>", F.row_number().over(w))\<br/>.withColumn("<strong class="lq hj">medianr</strong>", F.when(F.col("xyz6")==F.col("xyz5"), F.col("xyz")).when(F.col("xyz7")==F.col("xyz5"),F.col("xyz")).otherwise(F.lit(None)))\<br/>.withColumn("<strong class="lq hj">medianr2</strong>", (F.mean("medianr").over(w2)))\<br/>.withColumn("xyz", F.when(F.col("xyz").isNull(), F.col("medianr2")).otherwise(F.col("xyz")))\<br/>.orderBy("I_id").show()</span></pre><p id="1bbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Xyz5 </strong>就是先出现空值的窗口分区上的<strong class="ih hj"> row_number() </strong>。</p><p id="064a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Medianr </strong>将检查<strong class="ih hj"> xyz6(中间项的行号)</strong>是否等于<strong class="ih hj"> xyz5(分区的row _ number())</strong>，如果等于，它将用该行的xyz值<strong class="ih hj">填充Medianr</strong>。它还将检查以查看<strong class="ih hj"> xyz7(在偶数条目的情况下第二个中间项的行号)</strong>是否等于<strong class="ih hj"> xyz5(分区的row _ number())</strong>，如果是，它将用该行的xyz填充medianrr。如果这些条件都不满足，medianr将得到一个空值。</p><blockquote class="jr js jt"><p id="6719" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">在计算medianr时，我们必须<strong class="ih hj">链接2个when子句</strong>(这就是为什么我必须<strong class="ih hj">从函数</strong>导入‘when ’,因为<strong class="ih hj">链接F.when将不起作用</strong>),因为有<strong class="ih hj"> 3个结果。</strong></p></blockquote><p id="f09f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Medianr2可能是这个例子中最美的部分。</strong>它为每个分区计算无界窗口上<strong class="ih hj"> medianr </strong>的平均值。它很好地处理了具有<strong class="ih hj"> 1个中间项和2个中间项的两种情况</strong>，就好像只有<strong class="ih hj">一个中间项，那么这将是在分区窗口</strong>上广播的平均值，因为<strong class="ih hj">空值不计数</strong>。此外，如果有<strong class="ih hj"> 2个中间项(对于偶数)</strong>，则平均值将是这2个项的和<strong class="ih hj">然后除以2 </strong>，然后该结果将被<strong class="ih hj">在分区窗口上广播</strong>。</p><p id="8f8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个任务的最后一部分是用medianr2 值替换任何有<strong class="ih hj"> null的地方，如果那里没有<strong class="ih hj">null，那么保持原来的xyz值</strong>。我们能够做到这一点，因为我们的<strong class="ih hj">逻辑(具有空值的窗口的平均值)发送整个分区</strong>的中值，所以我们可以对每个窗口中的每一行使用<strong class="ih hj"> case语句。</strong></strong></p><p id="92c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所解释的代码处理所有的边缘情况，例如:没有空值的<strong class="ih hj">、<strong class="ih hj">只有1个值和1个空值的</strong>、<strong class="ih hj">只有2个值和1个空值，以及每个分区/组有同样多的空值</strong>、<strong class="ih hj">。</strong></strong></p><p id="a4d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要获得我们的<strong class="ih hj">输出</strong>:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mo"><img src="../Images/957435de0cf1d219574caa674381e22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*uRNeoiErqo8fyLyhA1etOw.png"/></div></figure><p id="8c81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">链接到我回答的StackOverflow问题:<br/><a class="ae jq" href="https://stackoverflow.com/questions/60408515/replace-na-with-median-in-pyspark-using-window-function/60409460#60409460" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/60408515/replace-na-with-median-in-py spark-using-window-function/60409460 # 60409460</a></p><p id="1bb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>另一种不用窗口函数实现的方法是创建一个组udf(计算每个组的中值)，然后使用groupBy和这个UDF创建一个新的df。将此df连接回原始df，然后使用when/otherwise子句估算它们各自的中间值。这种方法是可行的，但在99%的大数据用例中，上面使用的窗口函数会优于UDF、Join和GroupBy。</p><blockquote class="jr js jt"><p id="3eee" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi"> Spark3.0 </em> </strong> <em class="hi">发布了</em><strong class="ih hj">percentile _ approximate</strong><em class="hi">等sql函数，可以在windows </em>  <em class="hi">上使用</em> <strong class="ih hj"> <em class="hi">。链接:</em>T18】https://issues.apache.org/jira/browse/SPARK-</strong></p></blockquote><h1 id="8c13" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">示例4:</h1><p id="c3c0" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq lz is it iu ma iw ix iy mb ja jb jc hb bi translated">假设您有一个如下图所示的数据帧，并且您的任务是<strong class="ih hj">计算stn_fr_cd和stn_to_cd两个列对于<strong class="ih hj">每个id </strong>具有相同的对角值</strong>的次数，并且对于<strong class="ih hj">每个val_no. </strong>将发生<strong class="ih hj">对角比较</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es md"><img src="../Images/24fbf7bcf283ba1ed8ede659fc781d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*ZdbeiMa5KiNTmnWwH-Fk7g.png"/></div></figure><p id="67e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，val_no = 5的行没有两条匹配的对角线(<strong class="ih hj"> GDN=GDN </strong>但是<strong class="ih hj"> CPH不等于GDN </strong>)</p><p id="14a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">期望输出</strong>如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mo"><img src="../Images/aabd9a043d481b18d3ff82e9b3e9888c.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*sprfY-qhVIjvX-J4H59sYg.png"/></div></figure><p id="3de0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的方法应该是使用一个带有窗口的<strong class="ih hj">引导函数</strong>，在该窗口中，partitionBy将是<strong class="ih hj"> id和val_no列。</strong>我们将在<strong class="ih hj">stn _ fr _ CD和stn_to_cd </strong>列上使用lead函数，这样我们就可以将每列的下一项放入<strong class="ih hj">的同一首行，这将使我们能够运行case(when/other)语句来比较对角线值</strong>。</p><p id="1eb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果对角线的两个<strong class="ih hj">条件都满足，我们将创建一个<strong class="ih hj">新列并输入1，如果它们不满足我们的条件，我们将输入0 </strong>。这里需要注意的一点是，第二行<strong class="ih hj">将总是输入空值，</strong>因为在任何分区中都没有第三行(<strong class="ih hj">作为主要函数计算下一行</strong>)，因此第二行的case语句将<strong class="ih hj">总是输入0，</strong>对我们有效。</strong></p><p id="534b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们运行了它，我们就可以对我们为其编写when/otherwise子句的列进行groupBy和sum。看看下面的<strong class="ih hj">代码和用于计算我们期望的输出</strong>的列，以便更好地理解我刚才解释的内容。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mp"><img src="../Images/0e896e010c725d6497a9bd63da6d7075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJqcWIRO9rf7nhDe3oliPQ.png"/></div></div></figure><p id="f51b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的这个<strong class="ih hj">输出是在groupBy: </strong>之前的获取的<strong class="ih hj"/></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mq"><img src="../Images/c713f3afa4d0907538c2d48fa40e9b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIFbYhwUvkuSYboDKv2w-Q.png"/></div></div></figure><p id="fedc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，<strong class="ih hj">的<strong class="ih hj">第二行</strong>的每个id和val_no分区</strong>将<strong class="ih hj">始终为空</strong>，因此，该分区的<strong class="ih hj">校验列行将始终为0 </strong>。在when/otherwise子句中，我们正在<strong class="ih hj">检查stn_fr_cd列是否等于‘to’</strong>列，以及<strong class="ih hj"> stn_to_cd列是否等于‘for’</strong>列。</p><p id="59bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这个例子中回答的<strong class="ih hj"> StackOverflow问题:</strong></p><p id="52de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jq" href="https://stackoverflow.com/questions/60535174/pyspark-compare-two-columns-diagnolly/60535681#60535681" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/60535174/py spark-compare-two-columns-diagnolly/60535681 # 60535681</a></p><h1 id="6667" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">示例5:</h1><p id="094c" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq lz is it iu ma iw ix iy mb ja jb jc hb bi translated">假设您有一个<strong class="ih hj">数据帧，包含2列秒、小时和总计。</strong> Total列是在那个特定的第二个时刻某个网站的访客总数；</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mr"><img src="../Images/d56c13cf0eaadca764606491ceb379fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*X2p_6wiWRh2_z5Tw2YmBEw.png"/></div></figure><p id="c240" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们必须计算每秒钟进入和离开网站的人数。 因此，我们必须在列中计算一个<strong class="ih hj">，在</strong>列中计算一个<strong class="ih hj">来显示<strong class="ih hj">进入</strong>网站，然后<strong class="ih hj">退出。</strong></strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ms"><img src="../Images/72bba05aa6fe1e8305d5dc284c4800c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mVLB3Q8ZDTtSnA69yVKng.png"/></div></div></figure><p id="7aaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">所需输出:</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mt"><img src="../Images/31e4939b7dcf2441cd77b7eb62a46572.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*k2eARr4H30z7KCSaQpkXmQ.png"/></div></figure><p id="182d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个用例，我们必须在窗口上使用<strong class="ih hj"> lag函数(在这种情况下，窗口不会被<strong class="ih hj">分区，因为没有小时列</strong>，但是在真实数据中会有，我们<strong class="ih hj">应该总是分区一个窗口以避免性能问题</strong>)。该解决方案的要点是对输入和输出使用<strong class="ih hj">相同的滞后函数，但要修改这些列，使其提供正确的输入和输出计算。</strong></strong></p><p id="db6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面，我提供了实现所需输出的<strong class="ih hj">完整代码</strong>:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mu"><img src="../Images/339d1fa6c3e27bbb760f3c852776067f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7fNkRmP821GrcD0qdFhi2w.png"/></div></div></figure><p id="7e62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的<strong class="ih hj">我提供了不同的列</strong>，我用它们来得到<strong class="ih hj">的进出。</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mv"><img src="../Images/d7e5c251bddb2cc5ea80a4f848bb40fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuayASVOj27kdqt24Nn9Zg.png"/></div></div></figure><p id="d5a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在上面的代码和输出中看到的，我们使用的唯一的lag函数用于计算<strong class="ih hj">列lagdiff </strong>，并且从这个<strong class="ih hj">列我们将计算我们的in和Out列</strong>。<strong class="ih hj"> Lagdiff </strong>通过<strong class="ih hj">从每个总值中减去滞后来计算。</strong>因此，lagdiff中的<strong class="ih hj">列和</strong>列都有值。</p><p id="f365" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Lagdiff3 </strong>是使用when/otherwise子句计算的，其逻辑是，如果<strong class="ih hj"> lagdiff为负，我们将把负值转换为正的</strong>(通过乘以1)，如果是正的<strong class="ih hj">，那么我们将用0 </strong>替换该值，这样我们基本上过滤掉了值中的所有<strong class="ih hj">，给出了我们的<strong class="ih hj"> Out </strong>列。</strong></p><p id="4633" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Lagdiff4 </strong>也是使用when/otherwise子句计算的。这里的逻辑是，如果<strong class="ih hj"> lagdiff是负的，我们将使用0 </strong>替换它，如果它是正的，我们将让它保持原样。这样我们就过滤掉了所有的<strong class="ih hj">和</strong>值，在列中给出了我们的<strong class="ih hj">。</strong></p><p id="c6d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码中计算<strong class="ih hj"> In/Out </strong>的下两行只是处理<strong class="ih hj">在<strong class="ih hj"> lagdiff3 &amp; lagdiff4 </strong>的开始</strong>中的空值，因为在列上使用<strong class="ih hj"> lag函数</strong>将<strong class="ih hj">总是为第一行产生一个空值。</strong></p><h1 id="7783" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">示例6:</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mw"><img src="../Images/b6cf3aae68f4547b234d83f57c92b847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RAEw9779h8OT6SyL1htxg.png"/></div></div></figure><p id="b588" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我将向您展示如何有效地<strong class="ih hj">计算一个YearToDate (YTD)总和作为一个新列</strong>。正如我在<strong class="ih hj">洞见部分</strong>中所说，PySpark窗口<strong class="ih hj">中的窗口框架不能完全动态</strong>。这意味着rangeBetween或rowsBetween子句只能接受Window.unboundedPreceding，Window.unboundedFollowing，Window.currentRow或literal long值，<strong class="ih hj">而不是整列值</strong>。</p><p id="f33a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以计算像过去4周总销售额或过去52周总销售额这样的结果，因为我们可以通过一个<strong class="ih hj">时间戳(转换为long) </strong>进行排序，然后使用rangeBetween遍历回一个<strong class="ih hj">设置的天数</strong> ( <em class="jd">使用秒到天的转换</em>)。年初至今变得棘手，因为<strong class="ih hj">的天数对于每个日期</strong>都是变化的，而rangeBetween <strong class="ih hj">只能取文字/静态值。</strong>因此，我们必须用给定的窗口工具获得<strong class="ih hj"> YTD </strong>。</p><p id="859d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算YTD有两种可能的方法，这取决于您的使用情形，您更喜欢使用哪一种方法:</p><p id="914c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算YTD的<strong class="ih hj">第一种方法</strong>使用<em class="jd">rows between(window . unbounded preding，Window.currentRow) </em>(我们也放0代替Window.currentRow)。只有当<strong class="ih hj">每个日期只有一个条目需要求和时，这个方法才有效，因为即使在同一个分区中，它也会将<strong class="ih hj">每一行视为新事件(rowsBetween子句)</strong>。这种方法基本上使用增量求和逻辑来累计我们的YTD值。</strong></p><p id="5f67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二种<strong class="ih hj">方法</strong>更复杂，但<strong class="ih hj">更动态</strong>。这两种情况都适用于<strong class="ih hj"/>:<strong class="ih hj">每个日期1个条目，</strong>或<strong class="ih hj">每个日期超过1个条目</strong>。因此，它几乎总是理想的解决方案。</p><p id="25cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一种方法是最佳选择的唯一情况是，如果你<strong class="ih hj"> 100%肯定每个日期只有一个条目</strong>，并且你想<strong class="ih hj">最小化你在火花簇</strong>上的足迹。由于仅使用一个带有子句间行的窗口比第二种方法<strong class="ih hj">更有效，第二种方法更复杂</strong>并涉及使用更多窗口功能的<strong class="ih hj">。</strong></p><p id="9b95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将并排计算这两种方法，向您展示它们的不同之处，以及为什么方法2是最佳选择。</p><p id="c018" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个<strong class="ih hj">数据框架，</strong>，我们必须<strong class="ih hj">计算每个product_id </strong>的YTD销售额:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mx"><img src="../Images/e90b7f012150fe3f7c0b6f8530c96b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*81a5wX2wfHJz9IZOTPPJVg.png"/></div></figure><p id="4cd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我<strong class="ih hj">解包所有这些逻辑(一步一步)</strong>之前，我想展示一下<strong class="ih hj">输出</strong>和用于获取它的<strong class="ih hj">完整代码</strong>:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es my"><img src="../Images/8348a96d54fd69d6927cf56e7e7a99cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUwIWeeG8biHbuSD_WyezQ.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mz"><img src="../Images/b73f99bd0955285135bcc165c9139cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jdi8oQVrr7REW5g2Cdg4zg.png"/></div></div></figure><p id="e1b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乍一看，如果你看一下<strong class="ih hj">第5排和第6排</strong>，它们有相同的<strong class="ih hj">日期</strong>和相同的<strong class="ih hj">产品id </strong>。这是<strong class="ih hj">方法1 </strong>不正常工作的唯一地方，因为它仍然从<strong class="ih hj"> 139增加到143，</strong>另一方面<strong class="ih hj">，方法2 </strong>基本上包含了当天的<strong class="ih hj">的全部总和，如143。</strong></p><blockquote class="jr js jt"><p id="a435" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">这似乎是一个可以忽略的问题，但是在企业环境中，查询该数据的BI分析师、数据科学家、销售团队成员会希望YTD完全包含他们正在查看的日期行中<strong class="ih hj">天的<strong class="ih hj">。</strong></strong></p></blockquote><p id="d3d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码的<strong class="ih hj">顶部，从df </strong>计算<strong class="ih hj"> df1，基本上确保<strong class="ih hj">日期列的日期类型为</strong>，<strong class="ih hj">将年、月、日提取到自己的</strong>列中。在计算这两种方法时，我们使用所有这些列来得到我们的<strong class="ih hj"> YTD。基本上，我们在partitionBy和orderBy子句上变得越来越狡猾。</strong></strong></p><p id="c840" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方法1 </strong>非常简单:</p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="b67d" class="lu jz hi lq b fi lv lw l lx ly"><strong class="lq hj">w</strong>=Window().partitionBy(F.col("<strong class="lq hj">product_id</strong>"),F.col("<strong class="lq hj">Year</strong>"))\<br/>.orderBy(F.col("<strong class="lq hj">Month</strong>"),F.col("<strong class="lq hj">Day</strong>"))\<br/>.rowsBetween(W<strong class="lq hj">indow.unboundedPreceding,Window.currentRow</strong>)</span><span id="85ab" class="lu jz hi lq b fi mn lw l lx ly">df1.withColumn("<strong class="lq hj">YTD_METHOD1</strong>", F.sum("<strong class="lq hj">sale</strong>").over(<strong class="lq hj">w</strong>))</span></pre><p id="87db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用一个由<strong class="ih hj"> product_id和年份</strong>划分的窗口，并按<strong class="ih hj">月和</strong>日排序。排序允许以正确的顺序维护<strong class="ih hj">增量行变化</strong>，并且<strong class="ih hj">分区与年份</strong>确保我们将它<strong class="ih hj">保持在年份分区</strong>内。窗口在前面的中是<strong class="ih hj">无界的，这样我们就可以<strong class="ih hj">总结我们的销售</strong>直到<strong class="ih hj">当前行日期</strong>。</strong></p><p id="bc07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方法2 </strong>稍微复杂一点:</p><p id="797a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用的窗口:</strong></p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="bc2a" class="lu jz hi lq b fi lv lw l lx ly"><strong class="lq hj">w3</strong>=Window().partitionBy(<strong class="lq hj">"product_id","Year","Month","Day"</strong>)<br/><strong class="lq hj">w4</strong>=Window().partitionBy(<strong class="lq hj">"product_id","Year","Month","Day"</strong>)\<br/>           .orderBy(<strong class="lq hj">"Day"</strong>)<br/><strong class="lq hj">w5</strong>=Window().partitionBy(<strong class="lq hj">"product_id","Year"</strong>).orderBy(<strong class="lq hj">"Month","Day"</strong>)</span></pre><p id="86a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">组合使用的窗口功能:</strong></p><pre class="jf jg jh ji fd lp lq lr ls aw lt bi"><span id="3d5f" class="lu jz hi lq b fi lv lw l lx ly">df1.withColumn(<strong class="lq hj">“total_sales_by_day”</strong>, <strong class="lq hj">F.sum(“sale”).over(w3)</strong>)\<br/> .withColumn(<strong class="lq hj">“rownum”</strong>, <strong class="lq hj">F.row_number().over(w4)</strong>)\<br/> .withColumn(<strong class="lq hj">“newday”</strong>, F.<strong class="lq hj">when</strong>(F.col(<strong class="lq hj">“rownum”</strong>)!=1, F.lit(<strong class="lq hj">0</strong>)).<strong class="lq hj">otherwise</strong>(F.col(<strong class="lq hj">“total_sales_by_day”</strong>)))\<br/> .withColumn(<strong class="lq hj">“YTD_METHOD2”</strong>, <strong class="lq hj">F.sum(“newday”).over(w5)</strong>)</span></pre><p id="d8e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地解释这个逻辑，我想用<strong class="ih hj">展示我用来计算<strong class="ih hj">方法2 </strong>的列</strong>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mp"><img src="../Images/407ba6810ff718443a9ab6e2db444a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxApPFMqcdEudntrfRPheg.png"/></div></div></figure><p id="8216" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> total_sales_by_day </strong>列计算每天的<strong class="ih hj">总数，并将其发送到当天的每个条目</strong>。<strong class="ih hj"> Rownum </strong>列为我们提供了每个年-月-日分区的<strong class="ih hj">行号，按行号排序。</strong></p><p id="59e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Newday </strong>列使用这两个列(<strong class="ih hj"> total_sales_by_day和rownum </strong>)来得到我们的<strong class="ih hj">倒数第二列</strong>。这里的逻辑是除了第一行编号之外的所有<strong class="ih hj">都将被<strong class="ih hj">替换为0。</strong>这样做的主要目的是，对于那些有<strong class="ih hj">多个条目</strong>的日期，它将当天的<strong class="ih hj">总和保留在最上面，其余的为0 </strong>。</strong></p><p id="4c90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将允许我们使用<strong class="ih hj"> F.sum("newday ")对我们的newday列求和。over(w5)</strong>with Window as<strong class="ih hj">w5 = Window()。partitionBy("产品标识"，"年份")。orderBy("月"，"日")。</strong>这确保了即使相同的日期有多个条目，整个日期的<strong class="ih hj">总和将出现在该日期</strong>的所有行中，同时<strong class="ih hj">保持总和</strong>的YTD进度。</p><h1 id="325d" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">总结:</h1><p id="65f2" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq lz is it iu ma iw ix iy mb ja jb jc hb bi translated">乍一看，窗口函数似乎是微不足道的普通聚合工具。然而，一旦您使用它们来解决复杂的问题，并看到它们对于大数据的可扩展性，您就会意识到它们实际上是多么强大。了解它们隐藏的工具、怪癖和优化的唯一方法是实际使用它们的组合来导航复杂的任务。</p><ul class=""><li id="d1be" class="kw kx hi ih b ii ij im in iq lm iu ln iy lo jc ld le lf lg bi translated"><em class="jd">感谢您的阅读！随时补充意见和建议！</em></li><li id="e8c6" class="kw kx hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">特别感谢</em><strong class="ih hj"><em class="jd">data bricks</em></strong><em class="jd">为我的代码原型提供了一个免费的社区版集群，并感谢</em><strong class="ih hj"><em class="jd">stack overflow</em></strong><em class="jd">社区让我提供自己的见解和答案来帮助他人。</em></li></ul><p id="b807" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想用我最喜欢的一句话来结束这篇文章。</p><blockquote class="na"><p id="a519" class="nb nc hi bd nd ne nf ng nh ni nj jc dx translated">“不要只练习你的艺术，而是强行进入它的秘密；艺术理应如此，因为它和知识可以把人提升到神的境界。”<strong class="ak">――路德维希·范·贝多芬</strong></p></blockquote></div></div>    
</body>
</html>