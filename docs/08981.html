<html>
<head>
<title>ML Classification Algorithms to Predict Market Movements and Backtesting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测市场运动和回溯测试的ML分类算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/ml-classification-algorithms-to-predict-market-movements-and-backtesting-2382fdaf7a32?source=collection_archive---------1-----------------------#2020-08-21">https://medium.com/analytics-vidhya/ml-classification-algorithms-to-predict-market-movements-and-backtesting-2382fdaf7a32?source=collection_archive---------1-----------------------#2020-08-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="c45b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我们将使用基于多种机器学习分类算法的股票交易策略来预测市场运动。为了分析性能，我们将执行简单的矢量化回溯测试，然后使用Backtrader测试最佳性能策略，以获得更真实的情况。你可以在我的<a class="ae jk" href="https://github.com/sabirjana/blog/tree/master/Classification_ML" rel="noopener ugc nofollow" target="_blank"> Github </a>页面上找到本文使用的相关Jupyter笔记本。总体方法如下:</p><ol class=""><li id="31fc" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">收集历史定价数据。</li><li id="0f02" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">特征工程。</li><li id="2116" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">建立和应用分类机器学习算法。</li><li id="2833" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用Backtrader对所选策略进行回溯测试。</li><li id="438a" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">回溯测试的性能分析。</li></ol></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="a39c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">收集历史定价数据</strong></p><p id="541c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将使用Nifty-50指数进行分析。我们将借助<code class="du jz ka kb kc b"><a class="ae jk" href="https://github.com/ranaroussi/yfinance" rel="noopener ugc nofollow" target="_blank">yfinance</a></code> python库下载每日收盘价格数据，计算每日日志回报，并在此基础上得出市场方向。我们将可视化收盘价和每日回报，以快速检查我们的数据。让我们看一下代码:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="2204" class="kl km hi kc b fi kn ko l kp kq"># make the necessary imports <br/>import numpy as np<br/>from matplotlib import pyplot as plt<br/>import pandas as pd<br/>import seaborn as sns<br/>import yfinance as yf<br/>import warnings<br/>from sklearn import linear_model<br/>from sklearn.naive_bayes import GaussianNB<br/>from sklearn.svm import SVC<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.neural_network import MLPClassifier<br/>import datetime<br/>import pyfolio as pf<br/>import backtrader as bt<br/>from backtrader.feeds import PandasData<br/>import warnings</span><span id="5ec6" class="kl km hi kc b fi kr ko l kp kq"># set the style and ignore warnings<br/>plt.style.use(‘seaborn-colorblind’)<br/>warnings.simplefilter(action=’ignore’, category=FutureWarning)<br/>warnings.filterwarnings(‘ignore’)</span><span id="48ac" class="kl km hi kc b fi kr ko l kp kq"># this is to display images in notebook<br/>%matplotlib inline<br/>%config InlineBackend.figure_format = 'retina'</span><span id="13e8" class="kl km hi kc b fi kr ko l kp kq"># ticker and the start and end dates for testing<br/>ticker =  '^NSEI' # Nifty 50 benchmark<br/>start = datetime.datetime(2010, 1, 1)<br/>end = datetime.datetime(2020, 7, 31)</span><span id="7c23" class="kl km hi kc b fi kr ko l kp kq"># download ticker ‘Adj Close’ price from yahoo finance<br/>stock =  yf.download(ticker, progress=True, actions=True,start=start, end=end)['Adj Close']<br/>stock = pd.DataFrame(stock)<br/>stock.rename(columns = {'Adj Close':ticker}, inplace=True)<br/>stock.head(2)</span><span id="c6b6" class="kl km hi kc b fi kr ko l kp kq"># calculate daily log returns and market direction<br/>stock['returns'] = np.log(stock / stock.shift(1))<br/>stock.dropna(inplace=True)<br/>stock['direction'] = np.sign(stock['returns']).astype(int)<br/>stock.head(3)</span><span id="291c" class="kl km hi kc b fi kr ko l kp kq"># visualize the closing price and daily returns<br/>fig, ax = plt.subplots(2, 1, sharex=True, figsize = (12,6))<br/>ax[0].plot(stock[ticker], label = f'{ticker} Adj Close')<br/>ax[0].set(title = f'{ticker} Closing Price', ylabel = 'Price')<br/>ax[0].grid(True)<br/>ax[0].legend()</span><span id="bc96" class="kl km hi kc b fi kr ko l kp kq">ax[1].plot(stock['returns'], label = 'Daily Returns')<br/>ax[1].set(title = f'{ticker} Daily Retunrs', ylabel = 'Returns')<br/>ax[1].grid(True)<br/>plt.legend()</span><span id="c158" class="kl km hi kc b fi kr ko l kp kq">plt.tight_layout();<br/>plt.savefig('images/chart1', dpi=300)</span></pre><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ks"><img src="../Images/5d1c07e237dca88563c74b040bb879d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVAgIqldS6WElwk9K9j_jA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">每日收盘价和日志回报</figcaption></figure><p id="dbc7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="59d0" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">进行必要的进口。</li><li id="631b" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">将股票代码设置为index Nifty-50，开始和结束日期分别为2010年1月1日和2020年7月31日。</li><li id="3b91" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">在雅虎财经<code class="du jz ka kb kc b">yfinance</code>的帮助下下载每日<code class="du jz ka kb kc b">Adj Close</code>数据。</li><li id="1ec9" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用<code class="du jz ka kb kc b">np.sign().astype(int)</code>计算每日日志回报和市场方向。</li><li id="45fe" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">可视化每日收盘价和日志回报。</li></ol></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="3738" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">特征工程</strong></p><p id="7a0b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本节中，我们将创建特征变量来预测市场方向。作为第一步，我们将使用对数收益序列的五个滞后，然后将其数字化为二进制(0，1)，以预测向上和向下市场运动的概率为(+1，-1)。python代码如下:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="b29f" class="kl km hi kc b fi kn ko l kp kq"># define the number of lags<br/>lags = [1, 2, 3, 4, 5]</span><span id="d6a0" class="kl km hi kc b fi kr ko l kp kq"># compute lagged log returns<br/>cols = []<br/>for lag in lags:<br/>    col = f'rtn_lag{lag}'<br/>    stock[col] = stock['returns'].shift(lag)<br/>    cols.append(col)</span><span id="8dc2" class="kl km hi kc b fi kr ko l kp kq">stock.dropna(inplace=True)<br/>stock.head(2)</span><span id="3f7f" class="kl km hi kc b fi kr ko l kp kq"># function to transform the lag returns to binary values (0,+1)<br/>def create_bins(data, bins=[0]):<br/>    global cols_bin<br/>    cols_bin = []<br/>    for col in cols:<br/>        col_bin = col + '_bin'<br/>        data[col_bin] = np.digitize(data[col], bins=bins)  <br/>        cols_bin.append(col_bin)</span><span id="c977" class="kl km hi kc b fi kr ko l kp kq">create_bins(stock)<br/>stock[cols+cols_bin].head(2)</span></pre><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es le"><img src="../Images/05ab251e07ff7d538b9e4503429f22ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q2GrAyTt1dk6HM319NqL_w.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">滞后返回和相应的二进制值(0，+1)</figcaption></figure><p id="2736" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="943e" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">计算五天的滞后回报，并将回报序列转换为滞后数，使其与一天的远期回报一致。</li><li id="bc28" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用函数<code class="du jz ka kb kc b">np.digitize().</code>定义将滞后返回转换为二进制值(0，1)的函数</li></ol></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="b309" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">建立并应用分类机器学习算法</strong></p><p id="7ffe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们将使用逻辑回归、高斯朴素贝叶斯、支持向量机(SVM)、随机森林和MLP分类器方法来预测市场方向为(+1，-1)。请参考<a class="ae jk" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> sklearn文档</a>了解这些和其他算法的详细信息。然后，我们将使用矢量化回溯测试来评估每个模型的性能，并可视化累积回报。让我们看一下python代码:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="a595" class="kl km hi kc b fi kn ko l kp kq"># create a dictionary of selected algorithms<br/>models = {<br/> ‘log_reg’: linear_model.LogisticRegression(),<br/> ‘gauss_nb’: GaussianNB(),<br/> ‘svm’: SVC(),<br/> ‘random_forest’: RandomForestClassifier(max_depth=10, n_estimators=100),<br/> ‘MLP’ : MLPClassifier(max_iter=500),<br/>}</span><span id="bd3f" class="kl km hi kc b fi kr ko l kp kq"># function that fits all models.<br/>def fit_models(data):  <br/>    mfit = {model: models[model].fit(data[cols_bin], data['direction']) for model in models.keys()}</span><span id="034e" class="kl km hi kc b fi kr ko l kp kq"># function that predicts (derives all position values) from the fitted models<br/>def derive_positions(data):  <br/>    for model in models.keys():<br/>        data['pos_' + model] = models[model].predict(data[cols_bin])</span><span id="f935" class="kl km hi kc b fi kr ko l kp kq"># function to evaluate all trading strategies<br/>def evaluate_strats(data):  <br/>    global strategy_rtn<br/>    strategy_rtn = []<br/>    for model in models.keys():<br/>        col = 'strategy_' + model <br/>        data[col] = data['pos_' + model] * data['returns']<br/>        strategy_rtn.append(col)<br/>    strategy_rtn.insert(0, 'returns')</span><span id="fc67" class="kl km hi kc b fi kr ko l kp kq"># fit the models<br/>fit_models(stock)</span><span id="e2fe" class="kl km hi kc b fi kr ko l kp kq"># derives all position values<br/>derive_positions(stock)</span><span id="acd4" class="kl km hi kc b fi kr ko l kp kq"># evaluate all trading strategies by multiplying predicted directions to actual daily returns<br/>evaluate_strats(stock)</span><span id="c2ff" class="kl km hi kc b fi kr ko l kp kq"># calculate total return and std. deviation of each strategy<br/>print('\nTotal Returns: \n')<br/>print(stock[strategy_rtn].sum().apply(np.exp))<br/>print('\nAnnual Volitility:')<br/>stock[strategy_rtn].std() * 252 ** 0.5</span><span id="29de" class="kl km hi kc b fi kr ko l kp kq"># number of trades over time for highest and second highest return strategy<br/>print('Number of trades SVM = ', (stock['pos_svm'].diff()!=0).sum())<br/>print('Number of trades Ramdom Forest = ',(stock['pos_random_forest'].diff()!=0).sum())</span><span id="9393" class="kl km hi kc b fi kr ko l kp kq"># vectorized backtesting of the resulting trading strategies and visualize the performance over time<br/>ax = stock[strategy_rtn].cumsum().apply(np.exp).plot(figsize=(12, 6), <br/>                                                     title = 'Machine Learning Classifiers Return Comparison')<br/>ax.set_ylabel("Cumulative Returns")<br/>ax.grid(True);<br/>plt.tight_layout();<br/>plt.savefig('images/chart2', dpi=300)</span></pre><p id="3fe5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="4a8a" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">创建所选算法的字典。</li><li id="8cac" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">定义一个适合所有模型的函数，将<code class="du jz ka kb kc b">direction </code>列作为因变量，将<code class="du jz ka kb kc b">_bin </code>列作为特征变量。</li><li id="4f7b" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">定义一个从拟合模型预测所有位置值的函数。</li><li id="c507" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">定义一个函数来评估所有的交易策略。</li><li id="b85c" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">接下来，我们拟合模型，预测头寸，并通过将预测方向乘以实际日收益来评估所有交易策略。</li><li id="1544" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">计算每个策略的总收益和标准差。</li><li id="d7b1" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">计算最高和第二高回报策略的超时交易次数。</li><li id="dede" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">对最终的交易策略进行向量化回溯测试，并可视化一段时间内的表现。</li></ol><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ks"><img src="../Images/2ffd667d6b574299ac8689d2e289252e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWarfLYgx1kjTWetYlfJQA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">机器学习分类器返回比较</figcaption></figure><figure class="kd ke kf kg fd kt er es paragraph-image"><div class="er es lf"><img src="../Images/9104de2cda8bd2cabf196b47e4198b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*b16bKiLUe-_uq1zEpS6NRA.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">总回报和年度波动</figcaption></figure><p id="96a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以看到，支持向量机模型已经给出了最大的总回报随着时间的推移与可比的年度波动与其他模型。然而，基于向量化的回溯测试结果部署任何这样的策略都是非常不成熟的。下面列出了一些原因:</p><ol class=""><li id="730d" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">交易的数量非常多，而且矢量化回溯测试没有考虑交易和市场滑点等成本。</li><li id="8bbd" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">该策略考虑了多头和空头头寸，但由于多种原因，卖空可能不可行。</li></ol><p id="fc16" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我们的回溯测试需要更加现实和事件驱动，以解决上述差距。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="a146" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">使用Backtrader对所选策略进行回溯测试</strong></p><p id="26c0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本节中，我们将采用我们性能最好的模型，即支持向量机(SVM)，并使用python库<a class="ae jk" href="https://www.backtrader.com/docu/" rel="noopener ugc nofollow" target="_blank"> Backtrader </a>执行回溯测试。回溯测试策略如下:</p><ol class=""><li id="2396" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">我们从100，000英镑的初始资本和0.1%的交易佣金开始。</li><li id="a7f0" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">当<code class="du jz ka kb kc b">predicted</code>值为+1时，我们买入，当预测值为-1时，我们卖出(仅当持有股票时)。</li><li id="0379" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">全进策略——在创建买入订单时，尽可能多地买入股票。</li><li id="1949" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">不允许卖空。</li></ol><p id="e028" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看一下python代码:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="4867" class="kl km hi kc b fi kn ko l kp kq"># fetch the daily pricing data from yahoo finance<br/>prices = yf.download(ticker, progress=True, actions=True, start=start, end=end)<br/>prices.head(2)</span><span id="3f91" class="kl km hi kc b fi kr ko l kp kq"># rename the columns as needed for Backtrader<br/>prices.drop(['Close','Dividends','Stock Splits'], inplace=True, axis=1)<br/>prices.rename(columns = {'Open':'open','High':'high','Low':'low','Adj Close':'close','Volume':'volume',<br/>                         }, inplace=True)<br/>prices.head(3)</span><span id="516c" class="kl km hi kc b fi kr ko l kp kq"># add the predicted column to prices dataframe. This will be used as signal for buy or sell<br/>predictions = stock['strategy_svm']<br/>predictions = pd.DataFrame(predictions)<br/>predictions.rename(columns = {'strategy_svm':'predicted'}, inplace=True)<br/>prices = predictions.join(prices, how='right').dropna()<br/>prices.head(2)</span><span id="f34e" class="kl km hi kc b fi kr ko l kp kq">OHLCV = ['open', 'high', 'low', 'close', 'volume']</span><span id="dd15" class="kl km hi kc b fi kr ko l kp kq"># class to define the columns we will provide<br/>class SignalData(PandasData):<br/>    """<br/>    Define pandas DataFrame structure<br/>    """<br/>    cols = OHLCV + ['predicted']</span><span id="8e2e" class="kl km hi kc b fi kr ko l kp kq"># create lines<br/>    lines = tuple(cols)</span><span id="dcc6" class="kl km hi kc b fi kr ko l kp kq"># define parameters<br/>    params = {c: -1 for c in cols}<br/>    params.update({'datetime': None})<br/>    params = tuple(params.items())</span></pre><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lg"><img src="../Images/de59e0f714a024e4f4404d8b1904e700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6FpWwCSdejX4hqaLKcNfrQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">具有预测列的数据框架</figcaption></figure><p id="2939" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="6e80" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">从yahoo finance获取每日定价数据，并将这些列重命名为Backtrader所需的OHLCV格式。</li><li id="3858" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">从<code class="du jz ka kb kc b">stock </code>数据框架中提取SVM策略收益，并将其加入到<code class="du jz ka kb kc b">prices </code>数据框架中。该列的值将是下单时买入或卖出的信号。</li><li id="8cd5" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">为要提供给Backtrader的dataframe列定义一个自定义的<code class="du jz ka kb kc b">SignalData</code>类。</li></ol><p id="6aa4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们为回溯测试策略定义<code class="du jz ka kb kc b">MLStrategy</code>类。它需要继承自<code class="du jz ka kb kc b">bt.Strategy</code>。由于我们已经预测了当天收盘价的市场方向，因此我们将在创建<code class="du jz ka kb kc b">bt.Cerebro</code>对象时使用<code class="du jz ka kb kc b">cheat_on_open=True </code>。这意味着我们想要购买的股票数量将基于t+1日的开盘价。因此，我们还在策略类中定义了<code class="du jz ka kb kc b">next_open</code>方法，而不是<code class="du jz ka kb kc b">next</code>。</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="7fc4" class="kl km hi kc b fi kn ko l kp kq"># define backtesting strategy class<br/>class MLStrategy(bt.Strategy):<br/>    params = dict(<br/>    )<br/>    <br/>    def __init__(self):<br/>        # keep track of open, close prices and predicted value in the series<br/>        self.data_predicted = self.datas[0].predicted<br/>        self.data_open = self.datas[0].open<br/>        self.data_close = self.datas[0].close<br/>        <br/>        # keep track of pending orders/buy price/buy commission<br/>        self.order = None<br/>        self.price = None<br/>        self.comm = None</span><span id="e665" class="kl km hi kc b fi kr ko l kp kq">    # logging function<br/>    def log(self, txt):<br/>        '''Logging function'''<br/>        dt = self.datas[0].datetime.date(0).isoformat()<br/>        print(f'{dt}, {txt}')</span><span id="cdb2" class="kl km hi kc b fi kr ko l kp kq">    def notify_order(self, order):<br/>        if order.status in [order.Submitted, order.Accepted]:<br/>            # order already submitted/accepted - no action required<br/>            return</span><span id="868f" class="kl km hi kc b fi kr ko l kp kq">        # report executed order<br/>        if order.status in [order.Completed]:<br/>            if order.isbuy():<br/>                self.log(f'BUY EXECUTED --- Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f},Commission: {order.executed.comm:.2f}'<br/>                )<br/>                self.price = order.executed.price<br/>                self.comm = order.executed.comm<br/>            else:<br/>                self.log(f'SELL EXECUTED --- Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f},Commission: {order.executed.comm:.2f}'<br/>                )</span><span id="a600" class="kl km hi kc b fi kr ko l kp kq">        # report failed order<br/>        elif order.status in [order.Canceled, order.Margin, <br/>                              order.Rejected]:<br/>            self.log('Order Failed')</span><span id="02cf" class="kl km hi kc b fi kr ko l kp kq">        # set no pending order<br/>        self.order = None</span><span id="57c7" class="kl km hi kc b fi kr ko l kp kq">    def notify_trade(self, trade):<br/>        if not trade.isclosed:<br/>            return<br/>        self.log(f'OPERATION RESULT --- Gross: {trade.pnl:.2f}, Net: {trade.pnlcomm:.2f}')</span><span id="035c" class="kl km hi kc b fi kr ko l kp kq">    # We have set cheat_on_open = True.This means that we calculated the signals on day t's close price, <br/>    # but calculated the number of shares we wanted to buy based on day t+1's open price.<br/>    def next_open(self):<br/>        if not self.position:<br/>            if self.data_predicted &gt; 0:<br/>                # calculate the max number of shares ('all-in')<br/>                size = int(self.broker.getcash() / self.datas[0].open)<br/>                # buy order<br/>                self.log(f'BUY CREATED --- Size: {size}, Cash: {self.broker.getcash():.2f}, Open: {self.data_open[0]}, Close: {self.data_close[0]}')<br/>                self.buy(size=size)<br/>        else:<br/>            if self.data_predicted &lt; 0:<br/>                # sell order<br/>                self.log(f'SELL CREATED --- Size: {self.position.size}')<br/>                self.sell(size=self.position.size)</span></pre><p id="3392" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="43dc" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">功能<code class="du jz ka kb kc b">__init__</code>跟踪打开、关闭、预测和未决订单。</li><li id="21e8" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">功能<code class="du jz ka kb kc b">notify_order</code>跟踪订单状态。</li><li id="dc2f" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">如果订单完成，则触发功能<code class="du jz ka kb kc b">notify_trade</code>并记录交易的损益。</li><li id="2290" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">函数<code class="du jz ka kb kc b">next_open</code>检查可用现金，并计算可以购买的最大股票数量。如果我们不持有任何头寸，并且<code class="du jz ka kb kc b">predicted </code>值大于零，它就会发出买入订单。否则，如果<code class="du jz ka kb kc b">predicted</code>值小于零，则发出卖出指令。</li></ol><p id="32ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，我们实例化<code class="du jz ka kb kc b">SignalData </code>和<code class="du jz ka kb kc b">Cerebro</code>对象，并添加<code class="du jz ka kb kc b">prices</code>数据帧、<code class="du jz ka kb kc b">MLStrategy</code>、初始资本、佣金和<code class="du jz ka kb kc b">pyfolio </code>分析器。最后，我们运行回溯测试并获取结果。</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="ceab" class="kl km hi kc b fi kn ko l kp kq"># instantiate SignalData class<br/>data = SignalData(dataname=prices)</span><span id="1072" class="kl km hi kc b fi kr ko l kp kq"># instantiate Cerebro, add strategy, data, initial cash, commission and pyfolio for performance analysis<br/>cerebro = bt.Cerebro(stdstats = False, cheat_on_open=True)<br/>cerebro.addstrategy(MLStrategy)<br/>cerebro.adddata(data, name=ticker)<br/>cerebro.broker.setcash(100000.0)<br/>cerebro.broker.setcommission(commission=0.001)<br/>cerebro.addanalyzer(bt.analyzers.PyFolio, _name='pyfolio')</span><span id="b600" class="kl km hi kc b fi kr ko l kp kq"># run the backtest<br/>print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())<br/>backtest_result = cerebro.run()<br/>print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())<br/></span></pre><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lh"><img src="../Images/e8b5ce383810c1772f13c6139b595fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJqTmPqlSnOEhmQPGq261A.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">回溯测试日志</figcaption></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="80b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">回测性能分析</strong></p><p id="2ff0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将使用<code class="du jz ka kb kc b"><a class="ae jk" href="https://github.com/quantopian/pyfolio" rel="noopener ugc nofollow" target="_blank">pyfolio</a></code>来分析性能统计数据。pyfolio是一个Python库，用于金融投资组合的性能和风险分析，由Quantopian公司开发。</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="50eb" class="kl km hi kc b fi kn ko l kp kq"># Extract inputs for pyfolio<br/>strat = backtest_result[0]<br/>pyfoliozer = strat.analyzers.getbyname(‘pyfolio’)<br/>returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()<br/>returns.name = ‘Strategy’<br/>returns.head(2)</span><span id="cefe" class="kl km hi kc b fi kr ko l kp kq"># get benchmark returns<br/>benchmark_rets= stock['returns']<br/>benchmark_rets.index = benchmark_rets.index.tz_localize('UTC') <br/>benchmark_rets = benchmark_rets.filter(returns.index)<br/>benchmark_rets.name = 'Nifty-50'<br/>benchmark_rets.head(2)</span><span id="975a" class="kl km hi kc b fi kr ko l kp kq"># get performance statistics for strategy<br/>pf.show_perf_stats(returns)</span><span id="b496" class="kl km hi kc b fi kr ko l kp kq"># plot performance for strategy vs benchmark<br/>fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(16, 9),constrained_layout=True)<br/>axes = ax.flatten()</span><span id="ce59" class="kl km hi kc b fi kr ko l kp kq">pf.plot_drawdown_periods(returns=returns, ax=axes[0])<br/>axes[0].grid(True)<br/>pf.plot_rolling_returns(returns=returns,<br/>                        factor_returns=benchmark_rets,<br/>                        ax=axes[1], title='Strategy vs Nifty-50')<br/>axes[1].grid(True)<br/>pf.plot_drawdown_underwater(returns=returns, ax=axes[2])<br/>axes[2].grid(True)<br/>pf.plot_rolling_sharpe(returns=returns, ax=axes[3])<br/>axes[3].grid(True)<br/># fig.suptitle('Strategy vs Nifty-50 (Buy and Hold)', fontsize=16, y=0.990)</span><span id="a3aa" class="kl km hi kc b fi kr ko l kp kq">plt.grid(True)<br/>plt.legend()<br/>plt.tight_layout()<br/>plt.savefig('images/chart3', dpi=300)</span></pre><p id="cd0a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码注释:</p><ol class=""><li id="5364" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">我们从回溯测试结果中提取投资组合所需的输入。</li><li id="ed50" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">获取基准日回报率，与策略进行比较和对比。</li><li id="c683" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">使用pyfolio <code class="du jz ka kb kc b">show_perf_stats</code>获取策略的性能统计数据。</li><li id="c8d1" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">可视化下降，累积回报，水下图，滚动夏普比率。</li></ol><figure class="kd ke kf kg fd kt er es paragraph-image"><div class="er es li"><img src="../Images/a95105609d03d73163dfc2f8b7dfc41e.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*962uNS5J3bwWNoZ0VCZfDg.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">战略绩效</figcaption></figure><p id="4865" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们分析一下我们策略的性能。年回报率仅为3.9%，累计回报率为48%，相比之下，我们在向量化回测期间观察到的总回报率为8.86倍。如果我们将一些其他性能参数与基准进行比较，我们可以看到我们的策略无法击败简单的买入并持有策略。</p><p id="82f9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以显而易见的问题是为什么？这是因为我们为大量交易支付了巨额佣金。第二个原因；在使用Backtrader进行回溯测试时，我们不允许卖空。</p><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lj"><img src="../Images/0846b72131c3d483f2c2895f56b15821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gHWJrP0-U49IDCgc7TdQYw.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">战略与基准</figcaption></figure><p id="156d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">总之，通常矢量化的回溯测试结果在纸面上看起来很棒，但是在我们决定实施这种策略之前，我们需要考虑实施不足和可行性的所有方面。此外，请记住，资本市场不仅仅是机器学习，否则所有的数据科学家现在都已经成为超级富豪了。</p><p id="fa6d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">祝投资愉快，请在文章中留下您的评论！</p><p id="0816" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意:此分析仅用于教育目的，作者不对您的任何投资决策负责。</p><p id="c90f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">参考资料:</p><ol class=""><li id="3694" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><a class="ae jk" href="https://www.amazon.in/Python-Finance-2e-Yves-Hilpisch/dp/1492024333" rel="noopener ugc nofollow" target="_blank"> Python for Finance 2e:掌握数据驱动的金融</a>作者Yves Hilpisch</li><li id="0651" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://www.amazon.in/Python-Finance-Cookbook-libraries-financial-ebook/dp/B083KG9DC7/ref=sr_1_2?dchild=1&amp;keywords=Python+for+Finance+Cookbook&amp;qid=1597938216&amp;s=books&amp;sr=1-2" rel="noopener ugc nofollow" target="_blank"> Python for Finance食谱:将现代Python库应用于金融数据分析的50多个食谱</a>，作者Eryk Lewinson</li><li id="048f" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">Stefan Jansen的《算法交易的机器学习》</li><li id="b544" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">请在我的<a class="ae jk" href="https://www.linkedin.com/in/sabirjana/detail/recent-activity/shares/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>页面或<a class="ae jk" rel="noopener" href="/@sabirh.jana"> Medium </a>查看我关于量化金融的其他文章/帖子。</li></ol></div></div>    
</body>
</html>