<html>
<head>
<title>Time Series Clustering &amp; The Curse of Dimensionality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列聚类&amp;维数灾难</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-clustering-the-curse-of-dimensionality-c0d837f00415?source=collection_archive---------17-----------------------#2020-01-05">https://medium.com/analytics-vidhya/time-series-clustering-the-curse-of-dimensionality-c0d837f00415?source=collection_archive---------17-----------------------#2020-01-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0af8513fb72e8f99ab684bb14d27482f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tuaB0nNXzAiGG5uz30D-hA.jpeg"/></div></div></figure><p id="fb5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，想象一下，你有一堆代表相同类型观察的时间序列，比如零售日销售额、慢跑者的心跳或一些模糊的传感器。在数据发现过程中或对数据集本身建模时应用聚类有很大的好处，这种好处主要与了解数据集的某些部分之间的现有相似性有关，例如将夏季繁荣的零售点与圣诞节期间繁荣的零售点聚集在一起，或者寻找正确的解释来解释为什么1，000名慢跑者被视为同一群体的一部分，他们是否有任何共同的健康问题，或者是否与高海拔生活有关，例如。你已经猜到了，聚类时间序列可以产生很多积极的结果，因此通过避免一些可能导致无效或绝对错误的陷阱来正确处理时间序列是非常重要的。</p><p id="a70e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在继续之前，让我们花几秒钟时间问一个基本问题:是什么让时间序列与其他类型的数据集相比如此特殊？主要是两件事，第一个是“系列”部分，这意味着每个观察都与一个序列、某种频率、一次心跳、一个脉冲或类似的东西相关联。第二件事，表现在“时间”和“年表”部分，是观察的顺序，改变顺序将被认为是产生一个完全不同的时间序列。在下图中，即使数据集是相似的(当然不考虑顺序)，混洗<strong class="is hj"> <em class="jo"> sin </em> </strong>信号也会产生除了<strong class="is hj"> <em class="jo"> sin </em> </strong>之外的信号，因为每个观察的时间位置对于定义我们的时间序列非常重要。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jp"><img src="../Images/fc41927f4fd68a0f3f5856da747ed1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o463DTUQAv_vg5Rl8tr8iA.png"/></div></div></figure><p id="fedf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另外要提到的是，时间序列一般是在高维空间中定义的。如果您碰巧记录了一家冰淇淋店一年中的日销售额，那么这个维度的基数等于365，所以想象一下，如果我们有十年的数据。</p><h1 id="dece" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">维度的诅咒</h1><h2 id="3825" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jb kz la ki jf lb lc km jj ld le kq lf bi translated">一两句关于距离的话</h2><p id="f8a4" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">当我们谈到距离时，我们往往会马上想到欧几里得距离。简单提醒一下，欧几里德距离在<a class="ae ll" href="https://en.wikipedia.org/wiki/Euclidean_space" rel="noopener ugc nofollow" target="_blank">欧几里德空间</a>中定义为:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/6d39d9cadb988025241e105ef1b682b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rC147ZA1DY5SDNtW7e7ujA.png"/></div></div></figure><p id="b00b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中<strong class="is hj"> <em class="jo"> a </em> </strong>和<strong class="is hj"> <em class="jo"> b </em> </strong>是空间中的两个点，具有各自的空间坐标</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/1eea686597fa9f1dce23ebbc67bdf007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCySrZR9HaosGAdS9-qe2Q.png"/></div></div></figure><p id="3901" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且<em class="jo"> n </em>是一个严格的正整数，意味着<em class="jo"> n </em> ∈ ℕ*.</p><p id="7313" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实是，距离的概念是一个更加抽象和普遍的概念，欧几里得距离只是许多现存距离中的一个。我们可以称任何满足一组数学条件的东西为距离:如果我们考虑函数d在集合e中运算，其中d: E× E→ℝ⁺，如果它满足下列条件，则d称为距离:</p><ul class=""><li id="4985" class="lo lp hi is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw bi translated"><strong class="is hj">对称性</strong> : ∀ (a，b) ∈ E，d(a，b)=d(b，a)</li><li id="12ed" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated"><strong class="is hj">巧合</strong> : ∀ (a，b) ∈ E，d(a，b)=0 ⇔ a=b</li><li id="bafd" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated"><strong class="is hj">三角形不等式</strong> : ∀ (a，b，c) ∈ E，d(a，c)≤ d(a，b)+d(b，c)</li></ul><p id="9013" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，如果您碰巧创建了一个满足这三个约束的函数，那么恭喜您创建了一个距离度量！</p><p id="3cb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是我为什么要说这些呢？这和我想说的有什么关系？事实上，我在这里的主要观点是，我们本能地使用的欧几里德距离并不是唯一存在的距离，还有一堆其他的距离，比如<a class="ae ll" href="https://en.wikipedia.org/wiki/Taxicab_geometry" rel="noopener ugc nofollow" target="_blank">曼哈顿距离</a>、<a class="ae ll" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦距离</a>、<a class="ae ll" href="https://en.wikipedia.org/wiki/Chebyshev_distance" rel="noopener ugc nofollow" target="_blank">切比雪夫距离</a>、<a class="ae ll" href="https://en.wikipedia.org/wiki/Minkowski_distance" rel="noopener ugc nofollow" target="_blank">闵可夫斯基距离</a>等等。并且聚类算法强烈地基于距离度量，空间中的相似点意味着它们碰巧彼此靠近，因此改变距离度量可以在很大程度上改变我们的聚类算法的行为。事实上，这适用于一大块机器学习概念。</p><h2 id="bc00" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jb kz la ki jf lb lc km jj ld le kq lf bi translated">高维&amp;诅咒！</h2><p id="68b3" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">到目前为止，一切都很好，我们对我们的距离指标很满意。这里要问的一个大问题是，距离在高维空间中的表现是否相似？我们能相信一些距离度量来区分吗，这意味着知道我们数据集上人口的相似性和非相似性，在高维空间中？</p><p id="feee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我不会马上回答，而是做一个简单的实验。让我们生成500个均匀分布的随机点，然后计算所有可能对(124，750对)之间的欧几里德距离，然后我们将绘制这些距离的分布。我们将通过增加我们空间的维度来做到这一点，看看在高维度下到底会发生什么。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/70e1fa7bcd658f311072b5478e2924a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WS23DvYr4G91ZIskTgCTtQ.png"/></div></div></figure><p id="e97f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用以下代码自行测试:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="fc55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们观察到，在高维空间中，距离方差减小，在10，000维的极端情况下，成对距离收敛到一个非常窄的值，这就像空间中的所有点都处于墨西哥式的对峙状态，没有真正的赢家。事实上，我们失去了成对距离的方差，这意味着我们不能区分人口或找到任何重要的相似性，因此聚类的努力注定要失败。</p><p id="9cef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在时间序列聚类的背景下，很多人倾向于使用最经典的聚类算法，即K-Means聚类。在其最经典的形式中，它基于欧几里德距离，并将它应用于时间序列，如十年间冰淇淋店的日销售额，相当于在高维空间中使用欧几里德度量，这肯定会导致维数灾难。</p><h1 id="b4e6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">那我们该怎么办？</h1><p id="c5e4" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">所以现在我已经告诉了你坏消息，不要认为你没救了…我将与你分享两个主要策略来对抗时间序列聚类时维数灾难的影响。</p><h2 id="8c6a" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jb kz la ki jf lb lc km jj ld le kq lf bi translated">通过特征提取减少空间！</h2><p id="3009" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">如果您想保持对时间序列进行聚类的方式，而不使用花哨的技术，最好的方法是减少定义时间序列的空间。事实上，我所说的“减少”指的是通过计算你的时间序列上观察到的一些相关特征，如趋势、均值、某些天的最大值或熵，将你的时间序列转移到一个完全不同的空间(这里列出了一个非穷举的<a class="ae ll" href="https://tsfresh.readthedocs.io/en/latest/text/list_of_features.html" rel="noopener ugc nofollow" target="_blank">相关特征</a>待计算)。因此，如果我们想象你只需要10个特征来描述你的时间序列，当然，这取决于你的背景，它肯定会比十年期间的每日值更好(大约3650个特征)。</p><p id="622e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">有一个非常有用的库可以用来计算这些特性，这个库叫做</em> <a class="ae ll" href="https://github.com/blue-yonder/tsfresh" rel="noopener ugc nofollow" target="_blank"> <em class="jo"> TSFRESH </em> </a> <em class="jo">。</em></p><h2 id="978b" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jb kz la ki jf lb lc km jj ld le kq lf bi translated">改变我们衡量相似性的方式</h2><p id="c803" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">第二个策略是完全改变度量标准，因为我们之前已经看到有许多现有的距离度量标准，我们需要选择一个能够减少影响的度量标准，不幸的是，这不是一个安全的赌注。</p><p id="9dee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也就是说，最好的测量方法是使用<a class="ae ll" href="https://en.wikipedia.org/wiki/Dynamic_time_warping" rel="noopener ugc nofollow" target="_blank">动态时间扭曲</a>(或DTW)，即使从数学上来说，它不是一个<a class="ae ll" href="https://www.sciencedirect.com/science/article/abs/pii/0167639385900585" rel="noopener ugc nofollow" target="_blank">距离度量</a>。DTW是一种测量两个时间序列之间相似性的算法，我们可以将其用作一种<a class="ae ll" href="https://tslearn.readthedocs.io/en/latest/auto_examples/plot_kmeans.html" rel="noopener ugc nofollow" target="_blank"> K均值聚类</a>的测量方法，并且在我们的环境中，它不受维数灾难的影响，因为其核心算法在二维空间中运行。</p><p id="718b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">DTW可以是一个很好的解决方案来对抗诅咒，但它在处理具有太多时间序列的数据集时有两个主要问题。第一个问题是需要计算所有现有时间序列的成对距离，这相当于创建一个对角线全为零(时间序列到其自身的DTW为零)的上三角矩阵(我们考虑对称DTW)。为此，我们需要计算(m -m)/2个DTW(其中m是我们拥有的时间序列的数量)，因此对于1，000个时间序列，我们必须计算499，500个DTW值。下图显示了16个时间序列的DTW距离矩阵形状。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/fa8f8c54c01cdd1231cea3849b508d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*hqmf_k0GADZwzkRRbUTlkQ.png"/></div></figure><p id="1c98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二个问题是算法性能:DTW算法是O(n ),所以对于1，000个时间序列计算DTW 499，500次可能要花很长时间！</p><p id="e36b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望您在处理聚类时间序列时能记住这篇文章，并且我希望它能让您更好地理解维数灾难的影响。</p><p id="4543" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在<a class="ae ll" href="https://twitter.com/ALemaizi" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，以便在有新帖子发布时得到通知！</p></div></div>    
</body>
</html>