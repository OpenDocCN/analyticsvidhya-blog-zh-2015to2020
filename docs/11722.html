<html>
<head>
<title>Sitri = Vault + Pydantic: continuation of the saga, local development.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sitri = Vault + Pydantic:传奇的延续，局部发展。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sitri-vault-pydantic-continuation-of-the-saga-local-development-6ccd11da17e0?source=collection_archive---------20-----------------------#2020-12-15">https://medium.com/analytics-vidhya/sitri-vault-pydantic-continuation-of-the-saga-local-development-6ccd11da17e0?source=collection_archive---------20-----------------------#2020-12-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a815c6e716de59ac5f9ffe0e8d7acf2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJUDDo7dpFQhN6iHyrIA0g.jpeg"/></div></div></figure><h1 id="d9e3" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">背景</h1><p id="8cd4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在<a class="ae km" href="https://egnod.medium.com/configuring-the-service-using-vault-and-pydantic-ad66bd8dfeac" rel="noopener">上一篇文章</a>中，我写了如何使用<a class="ae km" href="https://sitri.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Sitri </a>配置您的应用程序，然而，我忽略了本地开发的要点，因为您会同意在本地部署一个Vault并不方便，并且在一个公共Vault中存储一个本地配置更加不方便，特别是如果几个人在一个项目上工作的话。</p><p id="3238" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在<a class="ae km" href="https://sitri.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Sitri </a>中，这个问题解决得非常简单——使用本地模式设置类，也就是说，你甚至不需要重写任何东西或复制代码，本地模式的结构json文件将几乎完全重复秘密的结构。</p><p id="6744" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">那么，现在，让我们给我们的<a class="ae km" href="https://github.com/Egnod/article_sitri_vault_pydantic" rel="noopener ugc nofollow" target="_blank">项目</a>添加几行代码+如果您的项目在docker-compose中本地运行，我将向您展示如何使用所有这些代码…</p><h1 id="ef25" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">准备代码</h1><p id="fb04" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，让我们同意当<em class="ks"> ENV </em> = "local ":)时local_mode为真</p><p id="1aad" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">接下来，我建议稍微编辑一下我们的<em class="ks"> provider_config.py </em>并创建一个<em class="ks"> BaseConfig </em>类，我们将从那里继承我们的<em class="ks"> Config </em>设置类。我们这样做是为了不重复代码，也就是说，设置类本身将只包含特定于它们的内容。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="cc80" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">关于<em class="ks"> local_provider_args </em>在这个字段中，我们指定了用于创建<em class="ks"> JsonConfigProvider </em>实例的参数，它们将被验证，并且这个字典必须匹配模式，所以不要担心——这不是什么肮脏的把戏。然而，如果您想自己创建一个本地提供者的实例，那么您只需将它放在可选的<em class="ks"> local_provider </em>字段中。</p><p id="8b84" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，我们可以很容易地从基类继承配置类。例如，用于连接到Kafka的设置类如下所示:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="f9bc" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如您所见，所需的更改很少。我们指定通用配置的结构保存在我们的json文件中。现在，让我们为本地配置编写这个json文件:</p><pre class="kt ku kv kw fd kz la lb lc aw ld bi"><span id="1858" class="le ir hi la b fi lf lg l lh li">{<br/>    "db":<br/>    {<br/>        "host": "testhost",<br/>        "password": "testpassword",<br/>        "port": 1234,<br/>        "user": "testuser"<br/>    },<br/>    "faust":<br/>    {<br/>        "agents":<br/>        {<br/>            "X":<br/>            {<br/>                "concurrency": 2,<br/>                "partitions": 5<br/>            }<br/>        },<br/>        "app_name": "superapp-workers",<br/>        "default_concurrency": 5,<br/>        "default_partitions_count": 10<br/>    },<br/>    "kafka":<br/>    {<br/>        "auth_data":<br/>        {<br/>            "password": "testpassword",<br/>            "username": "testuser"<br/>        },<br/>        "brokers": "kafka://test",<br/>        "mechanism": "SASL_PLAINTEXT"<br/>    }<br/>}</span></pre><p id="0122" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">…嗯，或者直接从上一篇文章的末尾复制粘贴。如你所见，这里的一切都很简单。为了我们的进一步研究，将项目根中的<em class="ks"> main.py </em>重命名为<em class="ks"> __main__。这样你就可以用docker-compose命令运行这个包了。</em></p><h1 id="5e00" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">将应用程序放入容器并享受构建过程</h1><p id="2166" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们应该做的第一件事是写一个小docker文件:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="de69" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在这里，我们只安装依赖项，就是这样，因为它是本地开发，我们不复制项目代码。</p><p id="d199" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">接下来，我们需要一个包含本地模式所需变量的env文件:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="051e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如您所见，没有多余的东西，Vault不需要配置信息，因为在本地模式下，应用程序甚至不会尝试“敲”Vault。</p><p id="b9e2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们需要写的最后一件事是docker-compose.yml文件本身:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="4b64" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这里一切都很简单。我们将json文件放在根目录中，就像上面在容器的环境变量中写的那样。</p><p id="aa96" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，发射:</p><pre class="kt ku kv kw fd kz la lb lc aw ld bi"><span id="6f58" class="le ir hi la b fi lf lg l lh li">docker-compose up</span><span id="be66" class="le ir hi la b fi lj lg l lh li">Creating article_sitri_vault_pydantic_superapp_1 ... done<br/>Attaching to article_sitri_vault_pydantic_superapp_1</span><span id="3b3c" class="le ir hi la b fi lj lg l lh li">superapp_1  | db=DBSettings(user='testuser', password='testpassword', host='testhost', port=1234) faust=FaustSettings(app_name='superapp-workers', default_partitions_count=10, default_concurrency=5, agents={'X': AgentConfig(partitions=5, concurrency=2)}) kafka=KafkaSettings(mechanism='SASL_PLAINTEXT', brokers='kafka://test', auth_data={'password': 'testpassword', 'username': 'testuser'})</span><span id="2be4" class="le ir hi la b fi lj lg l lh li">superapp_1  | {'db': {'user': 'testuser', 'password': 'testpassword', 'host': 'testhost', 'port': 1234}, 'faust': {'app_name': 'superapp-workers', 'default_partitions_count': 10, 'default_concurrency': 5, 'agents': {'X': {'partitions': 5, 'concurrency': 2}}}, 'kafka': {'mechanism': 'SASL_PLAINTEXT', 'brokers': 'kafka://test', 'auth_data': {'password': 'testpassword', 'username': 'testuser'}}}</span></pre><p id="d8c7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">正如您所看到的，一切都成功地启动了，来自我们json文件的信息成功地通过了所有检查，并成为应用程序的本地版本yuhhu的设置！</p><p id="586e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我把这个“延续”的代码放在了存储库的一个单独的分支中，所以你可以看看它在更改后是什么样子的:<a class="ae km" href="https://github.com/Egnod/article_sitri_vault_pydantic/tree/local_mode_example" rel="noopener ugc nofollow" target="_blank">分支</a></p></div></div>    
</body>
</html>