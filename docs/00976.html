<html>
<head>
<title>Classifying Tech-Data Job Postings on Indeed.com with Natural Language Processing (NLP) and Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用自然语言处理(NLP)和机器学习对Indeed.com的技术数据职位发布进行分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/classifying-tech-data-job-postings-on-indeed-com-1fd8ca6e7cdd?source=collection_archive---------4-----------------------#2019-09-23">https://medium.com/analytics-vidhya/classifying-tech-data-job-postings-on-indeed-com-1fd8ca6e7cdd?source=collection_archive---------4-----------------------#2019-09-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/fdea4c8b62a07f5e1bc02fdcd73de664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MbgAmg44dJ0a5iSxSUteIg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">谷歌的(大)数据中心(信用:<a class="ae hv" href="https://news.cnrs.fr/opinions/does-big-data-cause-pollution" rel="noopener ugc nofollow" target="_blank"> CNRS </a></figcaption></figure><div class=""/><p id="a9d5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随着计算和信息存储及处理系统的不断进步，以数据为中心的职位在过去几十年里已经<em class="jt">爆炸式增长</em>。一些人现在声称<a class="ae hv" href="https://www.northridgegroup.com/blog/more-valuable-than-oil-data-reigns-in-todays-data-economy/" rel="noopener ugc nofollow" target="_blank">大数据比石油更有价值</a>，国际数据公司(IDC)预测“到2025年，世界数据的总和将从今年的33zb(本文于2018年撰写)增长到175ZB，复合年增长率为61%。随着前所未有的数字信息膨胀和革命在我们眼前发生，这可能会让一些人想知道:在这样一个技术先进的未来，工作会是什么样子？</p><p id="84e7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一篇新闻文章强调了11个数据工作的例子，它们将对未来的形成产生巨大的影响。这些工作中的许多(如果不是大部分的话)将承担包括弄清楚如何从我们的机器和计算机收集和产生的海量数据中争论和获得洞察力的职责。其中一些工作包括“数据分析师”、“数据工程师”和“数据科学家”等头衔为了看到人们对这些的兴趣疯狂增长，我快速浏览了一下2004年以来这些搜索查询的<a class="ae hv" href="https://trends.google.com/trends/explore?date=all&amp;geo=US&amp;q=%22data%20analyst%22,%22data%20scientist%22,%22data%20engineer%22,%22business%20intelligence%20analyst%22,%22full%20stack%22%20%22developer%22" rel="noopener ugc nofollow" target="_blank"> Google Trends </a>(其中“商业智能分析师”被列为第四类，“全栈开发者”被列为第五类/控制类):</p><figure class="jv jw jx jy fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ju"><img src="../Images/748ae4994d41ad4ebda91098a621191d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Du0ElGU2aPP0PjJppQiBKA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">在谷歌上搜索趋势:“数据分析师”(蓝色)与“数据科学家”(红色)与“数据工程师”(黄色)与“商业智能分析师”(绿色)与“全栈开发人员”(紫色)</figcaption></figure><p id="04ab" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">显然，“数据分析师”已经成为一个职位和技术能力有一段时间了(从2004年或更早)。然而，直到2012年末到2013年初，人们才开始在谷歌上搜索“数据科学家”这个词。从那时起，“数据科学家”的搜索量迅速上升，并与“数据分析师”的搜索量同步上升。其他3个类别(“数据工程师”、“商业智能分析师”、“全栈开发人员”)在过去4-5年中的搜索量也稳步增长(自2013-2014年左右开始)，但搜索频率不如其他两个类别。</p><p id="306e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">人们，甚至是那些从事技术工作的人，经常想知道上述类型的工作到底有多大的不同。例如,“数据科学家”这个工作标签是不是只是一个更有经验/受过教育/经验丰富的数据分析师的更花哨或更浮夸的品牌？考虑到数据分析师和商业智能分析师都是涉及从数据中获取洞察力的分析师角色，他们的工作职责之间真的有任何形式的分离吗？当涉及到数据处理和计算机编程时，全栈开发人员做了很多工作，那么他们与其他“数据”角色有多大区别呢？</p><p id="6160" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了回答这些和其他问题，这篇文章调查并分析了一小部分来自<a class="ae hv" href="https://www.indeed.com/" rel="noopener ugc nofollow" target="_blank">Indeed.com</a>的当前招聘信息。然后，我们深入研究如何基于职位描述文本，使用自然语言处理(NLP)技术，构建用于对职位发布进行分类的机器学习模型的细节和步骤。最后，使用降维算法可视化工作发布数据，以在低维(2D)空间中可视化数据。</p><h2 id="e177" class="jz ka hy bd kb kc kd ke kf kg kh ki kj jg kk kl km jk kn ko kp jo kq kr ks kt bi translated"><strong class="ak">从Indeed.com获取招聘信息</strong></h2><p id="a221" class="pw-post-body-paragraph iv iw hy ix b iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js hb bi translated">要开始，我们首先需要一个非常重要的东西——数据！我在网上找到了一个名叫Michael Salmon的人发布的<a class="ae hv" rel="noopener" href="/@msalmon00/web-scraping-job-postings-from-indeed-96bd588dcb4b">脚本，该脚本使用Beautifulsoup Python库从Indeed.com</a>搜集职位信息。然而，该脚本并没有完全按照我需要的方式工作，所以我必须做一些修改，使它能够用于这个应用程序(您可以在本文底部我的Github帐户的链接中找到修改后的代码)。</p><p id="b615" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外——完全披露——我曾在2011年至2012年期间为Indeed.com工作，担任在线营销技术分析师，我强烈建议，如果你真的从搜索结果页面获取数据，你只是出于自己的求知欲，非常轻微地抓取搜索结果页面(如果你太用力访问网站，它们会屏蔽/压制你！！).网页抓取的替代方法是<a class="ae hv" href="https://opensource.indeedeng.io/api-documentation/" rel="noopener ugc nofollow" target="_blank"> Indeed API </a>(如果你是他们合作伙伴计划的成员，就可以访问)。</p><p id="6455" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了跳过获取数据的大部分繁琐细节，您需要导入以下库来抓取数据:</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="7b21" class="jz ka hy la b fi le lf l lg lh">import requests<br/>import bs4<br/>import string<br/>from bs4 import BeautifulSoup<br/>import numpy as np<br/>import pandas as pd<br/>import time<br/>import random</span></pre><p id="b108" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据将存储在pandas DataFrame对象中:</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="2705" class="jz ka hy la b fi le lf l lg lh">state_set = ("Texas", "California", "New York", "Florida", "North Carolina", "Colorado", "Washington")<br/>job_title_set = ("business+intelligence", "data+analyst", "data+scientist", "data+engineer", "full+stack+developer")</span><span id="5b29" class="jz ka hy la b fi li lf l lg lh">max_results_per = 10</span><span id="3852" class="jz ka hy la b fi li lf l lg lh">columns = ["state", "full_job_title", "company_name", "url", "job_class"]</span><span id="5cd3" class="jz ka hy la b fi li lf l lg lh">df = pd.DataFrame(columns = columns)<br/>df["Text"] = ""</span></pre><p id="d8a2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的，所以在上面的代码中，我们指定我们将收集横跨<a class="ae hv" href="https://www.ciodive.com/news/5-states-dominating-tech-employment/551315/" rel="noopener ugc nofollow" target="_blank"> 7个拥有高水平技术就业的美国州</a>的职位列表结果，针对5个职位类别(上面列出)，硬限制为最多10个结果(每个州/职位对)。该脚本将在Pandas DataFrame对象中存储公司名称、url、职位分类和职位发布文本。</p><p id="736c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在运行脚本一段时间后(使用随机暂停来轻触Indeed.com的服务器)，我能够获得500多行数据:</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="6329" class="jz ka hy la b fi le lf l lg lh">df.tail()</span></pre><figure class="jv jw jx jy fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lj"><img src="../Images/4a75394ba166c0343e66d78ae82bfb7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnRTqNn82aOXb3a8bDfxow.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">我们填充的DataFrame对象的视图</figcaption></figure><p id="054b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太棒了，现在我们有了数据，让我们深入研究一下吧！</p><p id="eeca" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">数据清理/格式化/转换</strong></p><p id="eaa3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在基于文本的数据分析项目中，通常可以执行几项操作。以下是其中的几个例子:</p><ul class=""><li id="9876" class="lk ll hy ix b iy iz jc jd jg lm jk ln jo lo js lp lq lr ls bi translated">小写文本</li><li id="d3a3" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">正在删除特殊文本(\n，\r，\t)</li><li id="c7b1" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">删除标点符号</li><li id="8fe3" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">删除停用词</li><li id="9d8a" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">符号化</li><li id="fa17" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">生成n元语法</li></ul><p id="5085" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，为了让您省心，我在下面提供了执行必要的文本清理和准备的代码(以及必要的Python库导入):</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="69a7" class="jz ka hy la b fi le lf l lg lh">from nltk import ngrams<br/>from nltk.tokenize import word_tokenize<br/>from nltk.corpus import stopwords<br/>from nltk.tokenize import RegexpTokenizer</span><span id="4afe" class="jz ka hy la b fi li lf l lg lh">#lowercase<br/>df["Text_1"] = df.Text.str.lower()</span><span id="554c" class="jz ka hy la b fi li lf l lg lh">#remove \n<br/>df["Text_2"] = df.Text_1.str.replace("\\n", " ")</span><span id="2274" class="jz ka hy la b fi li lf l lg lh">#remove punctuation and tokenize<br/>df["Tokens"] = df.apply(lambda row: tokenizer.tokenize(row['Text_2']), axis=1)</span><span id="c859" class="jz ka hy la b fi li lf l lg lh">#remove stopwords<br/>df['Tokens_1'] = df['Tokens'].apply(lambda x: [item for item in x if item not in stop_words])</span><span id="14bc" class="jz ka hy la b fi li lf l lg lh">#merge tokens back into string text<br/>df['Text_3']=[" ".join(txt) for txt in df["Tokens_1"].values]</span><span id="35e8" class="jz ka hy la b fi li lf l lg lh">#create bigrams<br/>df["Tokens_2"] = df["Tokens_1"].apply(lambda row: list(ngrams(row, 2)))</span></pre><p id="dd41" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很好，现在让我们开始为我们的文本机器学习模型准备变量(独立/相关)。通常，我们的<em class="jt">自变量(X) </em>将是给定工作的工作描述中包含的文本，它将用于<em class="jt">预测</em><em class="jt">因变量(Y) </em> —职位/类型(例如，“数据分析师”、“数据工程师”、“数据科学家”)。</p><p id="8594" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">生成合适的标签(Y) </strong></p><p id="dbd4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了快速方便地为我们的因变量生成标签，我们从sklearn库中导入LabelEncoder，并将我们的job_class列编码为一个数字(0–4)以便处理:</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="a48a" class="jz ka hy la b fi le lf l lg lh">from sklearn.preprocessing import LabelEncoder</span><span id="6c33" class="jz ka hy la b fi li lf l lg lh">encoder = LabelEncoder()<br/>y = encoder.fit_transform(df.job_class)<br/>print(y)</span></pre><p id="3f05" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">生成适当的特征向量(X) </strong></p><p id="a56e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一点上，我们已经对工作描述文本做了一些重要的清理，但它仍然是原始文本格式，这对于我们的机器学习模型来说不是理想的。为了将文本转换成有用的东西，我们将原始的工作描述文本转换成<a class="ae hv" href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf" rel="noopener ugc nofollow" target="_blank"> TFIDF格式</a>，并选择初始的最大特征数(单词数)为100:</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="7ef0" class="jz ka hy la b fi le lf l lg lh">from sklearn.feature_extraction.text import TfidfVectorizer</span><span id="24ce" class="jz ka hy la b fi li lf l lg lh">v = TfidfVectorizer(max_features=100)<br/>x = df["Text_3"]<br/>v.fit(x)<br/>x_tfidf = v.transform(x)</span></pre><p id="d494" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用下面的Python命令，我们可以看到矢量器的<em class="jt">词汇</em>:</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="9062" class="jz ka hy la b fi le lf l lg lh">print(v.vocabulary_)</span></pre><figure class="jv jw jx jy fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ly"><img src="../Images/5d4d6ecffec9aaeb854eb75716f620c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OolaCl_35RoPeOz1eeSfKQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">tfidf矢量器对象的词汇表</figcaption></figure><p id="447b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据我们自己的直觉，我们已经可以在词汇表中看到一些可能对分类有用的术语(例如，“sql”、“工程”、“bi”、“营销”、“报告”、“软件”、“开发”、“完整”、“机器”)。我们还会看到许多在分类任务中可能根本不重要的术语(例如，“高”、“跨”、“人”、“使用”、“必须”、“角色”、“寻找”、“需求”)。</p><p id="9d1c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用以下命令检查与每个示例职位发布相关联的TFIDF向量:</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="527e" class="jz ka hy la b fi le lf l lg lh">print(x_tfidf)</span></pre><figure class="jv jw jx jy fd hk er es paragraph-image"><div class="er es lz"><img src="../Images/d1a998f353e024f7ebdb0e7cf9e957de.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*yL1yNifnjWlv7hAvJqy60Q.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">与每个职位发布(0-547个职位发布)的职位描述文本(单词0-99)相关联的特征向量(X)</figcaption></figure><p id="5469" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TFIDF向量被收集到一个<a class="ae hv" href="https://en.wikipedia.org/wiki/Sparse_matrix" rel="noopener ugc nofollow" target="_blank">稀疏矩阵</a>格式中(如果矩阵中没有大部分条目是零的话，也是一样多)。看第一个文档(文档0)，我们可以看到单词71和40具有相对较高的TFIDF值。使用上面的词汇表进行反向查找，我们可以看到71和40分别对应于单词“reports”和“intelligence”。因此，我们可以进行有根据的猜测(使用我们自己的直觉)来推测第一个文档可能与商业智能分析师的职位发布相关联。</p><p id="0709" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们人类的直觉是正确的，但我们的任务是建立一个<em class="jt">自动机器学习系统/模型</em>，它应该尽可能少地进行人工调整/微调，并能够处理大量数据(超过人类手动处理的能力)。因此，我们不会试图手动挑选哪些术语对工作类型分类任务有意义和无意义，而是让我们的机器学习模型来确定哪些对最佳文本分类重要，哪些不重要。</p><p id="8d00" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">使用支持向量机建立机器学习模型</strong></p><p id="e58f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">许多类型的机器学习模型都包含在<a class="ae hv" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn Python库</a>中。虽然机器学习有许多可能的模型，但在本文中，我们将使用<a class="ae hv" href="https://scikit-learn.org/stable/modules/svm.html" rel="noopener ugc nofollow" target="_blank">支持向量机(SVM) </a>作为我们的机器学习模型。</p><p id="134a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据scikit-learn文档，支持向量机的一些优点是:</p><ul class=""><li id="54c0" class="lk ll hy ix b iy iz jc jd jg lm jk ln jo lo js lp lq lr ls bi translated">在高维空间有效。</li><li id="d5ae" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">在维数大于样本数的情况下仍然有效。</li><li id="6970" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">在决策函数中使用训练点的子集(称为支持向量)，因此它也是内存高效的。</li><li id="46aa" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">通用:可以为决策函数指定不同的<a class="ae hv" href="https://scikit-learn.org/stable/modules/svm.html#svm-kernels" rel="noopener ugc nofollow" target="_blank">内核函数</a>。提供了通用内核，但是也可以指定定制内核。</li></ul><p id="4d37" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的例子中，我们的X特征向量包括100个变量，这可能符合“高维空间”的条件这也是为什么SVM模型是我们理想的开始选择的一个原因。</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="27e4" class="jz ka hy la b fi le lf l lg lh">from sklearn import svm</span><span id="d4dd" class="jz ka hy la b fi li lf l lg lh"># Classifier - Algorithm - SVM<br/>s = svm.LinearSVC(C=1.0)</span><span id="7798" class="jz ka hy la b fi li lf l lg lh"># fit the training dataset on the classifier<br/>s.fit(x_tfidf, y)# predict the labels on validation dataset</span><span id="7575" class="jz ka hy la b fi li lf l lg lh"># make predictions using the trained model<br/>s_pred = s.predict(x_tfidf</span><span id="614a" class="jz ka hy la b fi li lf l lg lh">from sklearn.metrics import accuracy_score</span><span id="cd38" class="jz ka hy la b fi li lf l lg lh"># Use accuracy_score function to get the accuracy<br/>print("SVM Accuracy Score -&gt; ",accuracy_score(s_pred, y)*100)</span></pre><p id="b8f4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以及输出的准确度分数:</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="6c1c" class="jz ka hy la b fi le lf l lg lh">SVM Accuracy Score -&gt;  87.22627737226277</span></pre><p id="bc2e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该输出表明，使用仅100个单词的集合，我们最初尝试的模型能够在87%的时间内预测正确的职称分类。对第一次开始来说还不错！</p><p id="d660" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了了解我们的模型在哪里工作得好(也许更重要的是，在哪里<em class="jt">没有</em>工作得好)，我们根据真实的工作标签绘制了我们结果的<em class="jt">混淆矩阵</em>(注意<em class="jt"> plot_confusion_matrix </em>是使用本文底部Github链接中的代码定义的自定义函数):</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="6302" class="jz ka hy la b fi le lf l lg lh">import matplotlib.pyplot as plt<br/>from sklearn.metrics import confusion_matrix</span><span id="73c2" class="jz ka hy la b fi li lf l lg lh">class_names = np.unique(y)</span><span id="bbcb" class="jz ka hy la b fi li lf l lg lh">plot_confusion_matrix(y, s_pred, classes=class_names, title='Confusion matrix')</span></pre><figure class="jv jw jx jy fd hk er es paragraph-image"><div class="er es ma"><img src="../Images/6ba512747a6b75df0a87259cc934aece.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*jZ223yOLcwm7IfXCj8RD3A.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">困惑矩阵(0 =“商业+智能”)；1 = "数据+分析师"；2 =“数据+工程师”；3 =“数据+科学家”；4 =“完整+堆栈+开发人员”)</figcaption></figure><p id="9277" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总的来说，这个矩阵看起来相当不错:</p><ul class=""><li id="9aae" class="lk ll hy ix b iy iz jc jd jg lm jk ln jo lo js lp lq lr ls bi translated">很高兴看到我们的混淆矩阵的对角线充满了高计数值(=高真阳性)，非对角线条目大多接近于零(=低假阳性)。这些属性反映了我们初始模型的大约87%的准确性；</li><li id="f749" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">“全栈开发人员”工作的工作描述直观上比四个更具体的数据角色更不同——我们的模型显然认识到了这一事实，这反映在最后一行和最后一列几乎全是零，除了最低的对角线元素(4/4)几乎完全填满。这些方面表明，我们的模型不仅在正确分类全栈开发人员作业方面的准确率超过98%，而且在涉及到<em class="jt">不将</em>其他“数据”作业误分类为全栈开发人员作业时，它也非常好。</li></ul><p id="03c2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也就是说，有几个非对角线条目似乎明显大于零。例如，第2类(=“数据工程师”)和第3类(“数据科学家”)之间似乎有点混淆。这很有意义，因为数据工程师和科学家通常都会使用复杂的算法处理大量数据(&gt; 10 GB)，并且经常会在AI/ML应用的生产环境中部署机器和深度学习方法。为了更好地理解为什么我们的模型在某些情况下无法准确分类，我们为什么不看一个贴错标签的招聘启事样本呢？</p><figure class="jv jw jx jy fd hk er es paragraph-image"><div class="er es mb"><img src="../Images/6d4b6961d3a0afd91ff076c44e731742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*AT2OYdFUOXQPSFocly6UMw.png"/></div></figure><p id="0a78" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请看左边的(贴错标签的)招聘启事，这个启事的职位名称是“助理数据科学家”因此，我们的方法应该将该职位发布分类为第3类(=“数据科学家”)。然而，我们训练有素的SVM将这个帖子归类为0级(=“商业智能”)。这是为什么呢？</p><p id="ae4d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，这个职位的技能/能力和知识非常一般——潜在的候选人必须能够读、写、说英语，了解数据、分析和报告，并且有风度、善于分析和独立。此外，工作描述包括“Tableau”和“Microstrategy”这两个词，它们是商业智能(BI)中经常使用的工具。最后，数据科学家和工程师使用的非常复杂的算法和工具(Hadoop、AWS、机器学习、Tensorflow、深度神经网络等。)似乎完全不在这份工作清单上。因此，现在我们深入研究了数据，这份工作可能应该被称为“商业智能”角色，而不是“数据科学家”角色！这表明，有时，与其说是我们的模型可能不准确，不如说是我们的数据并不总是被准确标记！</p><p id="760e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然观察一项工作可能很有趣，也很有启发性，但问题仍然存在:所有这些“数据”角色的重叠程度如何，我们是否有办法直观地检查这种重叠？</p><p id="bbc5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">可视化与PCA和t-SNE的重叠</strong></p><p id="1087" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">两种流行的降维方法是<a class="ae hv" href="https://en.wikipedia.org/wiki/Principal_component_analysis" rel="noopener ugc nofollow" target="_blank">主成分分析(PCA) </a>和<a class="ae hv" href="https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding" rel="noopener ugc nofollow" target="_blank"> T分布随机邻居嵌入(t-SNE) </a>。虽然主成分分析已经存在了一段时间，但t-SNE是一种相对较新的方法，与主成分分析相比，它产生类似但数量不同的输出。</p><p id="67eb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了避免您了解这两种方法之间的所有差异，我们将只调用我们的自定义绘图函数(参见底部的Github链接，改编自<a class="ae hv" href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_confusion_matrix.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn文档</a>)并使用PCA和t-SNE绘制结果，以可视化我们的文本文档簇及其重叠。</p><p id="1c1a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们试试PCA:</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="16ae" class="jz ka hy la b fi le lf l lg lh">plot_dim_red("PCA", features=x_tfidf.toarray(), labels=y, n_components=2)</span></pre><figure class="jv jw jx jy fd hk er es paragraph-image"><div class="er es mc"><img src="../Images/635bae104fbb2e817ae11f153d4b9c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*iH0ES1chtpx10yP1Nq0Tcg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">PCA输出，将100个特征减少到2D向量空间表示</figcaption></figure><p id="516b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">文本职位描述数据的2D向量空间表示揭示了我们数据中的许多有趣模式:</p><ul class=""><li id="4338" class="lk ll hy ix b iy iz jc jd jg lm jk ln jo lo js lp lq lr ls bi translated"><strong class="ix hz"> <em class="jt">【全栈开发者】(紫色)</em> </strong>在很大程度上与其他4种工作类型很好的分开。显然这是有意义的，因为我们选择了四个密切相关的数据角色，以及第五个不太关注数据而更关注前端和后端网站设计的全栈角色。</li><li id="ab8b" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated"><strong class="ix hz"> <em class="jt">(红色)</em> </strong>与<strong class="ix hz"> <em class="jt">数据分析师(黄色)</em> </strong>重叠最明显，这也是有意义的，因为他们都是分析师角色，具有相似的教育和技能要求。</li><li id="8010" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated"><strong class="ix hz"> <em class="jt">数据工程师(蓝色)</em> </strong>也与<strong class="ix hz"> <em class="jt">数据科学家(绿色)</em> </strong>高度重叠，呼应了我们PCA模型对这两个角色的混淆(如上图混淆矩阵所示)。</li><li id="1be7" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated"><strong class="ix hz"> <em class="jt">数据分析师(黄色)</em> </strong>在很大程度上与其他三个数据角色重叠。同样，这并不意外，因为数据分析通常是一项非常广泛的技能，在任何以数据为中心的角色中都可以使用。许多作为经验丰富的数据分析师工作多年的人也可能频繁地转换到作为工程师/科学家的更高级的角色，这是这种密切关系的另一个原因。</li></ul><p id="69c4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑PC1和PC2这两个变量的实际含义是很发人深省的:</p><ul class=""><li id="a458" class="lk ll hy ix b iy iz jc jd jg lm jk ln jo lo js lp lq lr ls bi translated">查看上图中的<strong class="ix hz"> PC1 </strong>，绝大多数全栈作业位于其他“数据”作业的右侧。这种模式可以支持以下假设:对于给定的工作描述，PC1得分越高，与该工作描述相关联的工作就越“像全栈”(例如，任何PC2 &gt; 0.2的工作都有资格成为“全栈开发人员”工作)。</li><li id="62e0" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">对于<strong class="ix hz"> PC2 </strong>来说，通常需要更多资历/教育/计算机科学技能的角色往往具有负的PC2值，而“分析师”类型的工作往往具有正的PC2值。因此，具有正PC2值的工作可能更倾向于“商业”或“报告”类型的工作，而具有负PC2值的工作可能倾向于需要算法、机器学习和/或大数据工具的知识。</li></ul><p id="e7c3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，这些变量(PC1，PC2)分别代表什么，有很多解释！</p><p id="adee" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么SNE霸王龙呢？让我们看看可视化方法产生了什么！</p><pre class="jv jw jx jy fd kz la lb lc aw ld bi"><span id="b644" class="jz ka hy la b fi le lf l lg lh">plot_dim_red("TSNE", features=x_tfidf.toarray(), labels=y, n_components=2)</span></pre><figure class="jv jw jx jy fd hk er es paragraph-image"><div class="er es md"><img src="../Images/4dc29cc8c772165b4c435636d4f184c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*B9ctfkBnzY8ILUhsbIaeXQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">t-SNE输出，将100个要素缩减为2D平面空间表示</figcaption></figure><p id="d505" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于t-SNE有几点需要注意:对于重叠组，这种方法比PCA产生更多的分离。此外，t-SNE依赖于非确定性的随机过程，而PCA是确定性的。这意味着使用相同的数据，主成分分析始终具有相同的输出，而t-SNE输出低维数据的不同(随机化)表示。两者的比较可以在StackExchange文章中找到<a class="ae hv" href="https://stats.stackexchange.com/questions/238538/are-there-cases-where-pca-is-more-suitable-than-t-sne" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="36ec" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么我们在SNE霸王龙身上看到了什么？与PCA一样，全堆栈作业显然属于自己的分组。数据科学家、数据工程师和商业智能(分析师)之间的重叠也少得多。然而，数据分析师数据点仍然与其他三个数据角色混杂在一起，这意味着，即使使用t-SNE(它试图正确地映射<em class="jt">的本地邻居</em>，至少一些数据分析师角色看起来几乎与数据科学、数据工程师或BI分析师角色没有什么区别。在这个t-SNE迭代中，PC1和PC2值的实际意义似乎也随着上述PCA中PC1和PC2的意义发生了变化。</p><p id="a778" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">兜了一圈(没有双关语)</strong></p><p id="cc8c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到，事实上，设计一个机器学习系统是可能的，它可以通过查看工作描述来预测给定工作的类型/职位/类别，精确度很高(~87%或更高)。此外，我们对我们的数据和其中的模式有了更好的理解，我们的系统在理论上可以<em class="jt">应用于任何工作发布/列表/描述的文本语料库！</em></p><p id="3101" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就<em class="jt">实际应用</em>而言，这种ML文本分类系统的一个应用可以是在线发布的新工作的新工作分类的自动化，这对于潜在的求职者缩小可能的工作机会列表非常有帮助。例如，如果一个人正在专门寻找一份BI分析师的工作，但不是数据科学或工程职位，他们可以使用该系统只检查“看起来”(从<em class="jt">文本角度</em> ) BI分析师工作的工作。</p><p id="6083" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来还有很多事情要做。以下是一些关于未来调查和分析哪些方向会富有成效的想法:</p><ul class=""><li id="a449" class="lk ll hy ix b iy iz jc jd jg lm jk ln jo lo js lp lq lr ls bi translated"><strong class="ix hz">获取更多(大)数据；将数据分成培训/测试组:</strong>我们的数据包括略多于500个数据点/个人工作列表。有了数千个数据点，我们就有足够的数据通过测试和训练组来验证我们的模型(例如，避免过度拟合)。</li><li id="1ed7" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated"><strong class="ix hz">二元语法、三元语法、多元语法:</strong>我们的分析只关注单个单词。更复杂的分析将包括<a class="ae hv" href="https://en.wikipedia.org/wiki/N-gram" rel="noopener ugc nofollow" target="_blank"> n-grams </a>(例如，“业务”和“智能”与“商业智能”)。</li><li id="1a9a" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated"><strong class="ix hz">测试不同的模型:</strong>虽然我们只使用了一种分类方法(SVM)，但是还有许多其他的分类方法。一些可能适用于文本分类的方法包括<a class="ae hv" href="https://en.wikipedia.org/wiki/Logistic_regression" rel="noopener ugc nofollow" target="_blank">逻辑回归</a>、<a class="ae hv" href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier" rel="noopener ugc nofollow" target="_blank">朴素贝叶斯</a>和<a class="ae hv" href="https://en.wikipedia.org/wiki/Recurrent_neural_network" rel="noopener ugc nofollow" target="_blank">递归神经网络(RNNs) </a>。</li><li id="d502" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated"><strong class="ix hz">检查学习到的模型参数，以发现相关的工作技能:</strong>另一个应用是以某种方式导出哪些技能对特定的职位有用。我不确定使用我们当前的SVM模型有多容易，但是其他模型(多项逻辑回归？)可能能够区分哪些单词/标记与哪种工作类型相关(例如，Tensorflow可能与数据科学家和机器学习角色更相关，而Tableau可能与BI和分析报告角色更相关)。</li></ul><p id="c613" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你是一个在数据分析领域工作的人(即使你不是)，我希望你喜欢这篇文章。如果有，请鼓掌/喜欢！</p><p id="456e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Github回购:<a class="ae hv" href="https://github.com/vincent86-git/Data_Job_Analysis" rel="noopener ugc nofollow" target="_blank">https://github.com/vincent86-git/Data_Job_Analysis</a></p></div></div>    
</body>
</html>